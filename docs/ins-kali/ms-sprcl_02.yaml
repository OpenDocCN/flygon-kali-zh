- en: Spring for Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向微服务的Spring
- en: I don't know many Java developers who have never touched Spring Framework. Actually,
    it consists of so many projects and can be used with many other frameworks that
    sooner or later you will be forced to try it. Although experiences with Spring
    Boot are rather less common, it has quickly gained a lot of popularity. In comparison
    with Spring Framework, Spring Boot is a relatively new solution. Its actual version
    is 2, instead of 5 for Spring Framework. What was the purpose of its creation?
    What is the difference between a running application with Spring Boot instead
    of the standard Spring Framework way?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我不认识很多从未接触过Spring Framework的Java开发人员。实际上，它包括了很多项目，并且可以与许多其他框架一起使用，所以迟早你会被迫尝试它。尽管对Spring
    Boot的经验相对较少，但它很快就获得了很多的人气。与Spring Framework相比，Spring Boot是一个相对较新的解决方案。它的实际版本是2，而Spring
    Framework的版本是5。它的创建目的是什么？使用Spring Boot而不是标准的Spring Framework方式运行应用程序有什么区别？
- en: 'Topics we will cover in this chapter include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖的主题包括：
- en: Using starters in order to enable additional features for the project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用启动器以启用项目的其他功能
- en: Using Spring Web library for implementing services that expose REST API methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Web库实现暴露REST API方法的服务
- en: Customizing service configuration using properties and YAML files
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性和YAML文件自定义服务配置
- en: Documenting and providing the specification for exposed REST endpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和提供暴露的REST端点的规范
- en: Configuring health checks and monitoring features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置健康检查和监控功能
- en: Using Spring Boot profiles to adapt the application to run in different modes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Spring Boot配置文件来使应用程序适应不同模式的运行
- en: Using ORM features for interacting with embedded and remote NoSQL databases
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ORM功能与嵌入式和远程NoSQL数据库进行交互
- en: Introducing Spring Boot
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Spring Boot
- en: Spring Boot is dedicated to running standalone Spring applications, the same
    as simple Java applications, with the `java -jar` command. The basic thing that
    makes Spring Boot different than standard Spring configuration is simplicity.
    This simplicity is closely related to the first important term we need to know
    about, which is a starter. A **starter** is an artifact that can be included in
    the project dependencies. It does nothing more than provide a set of dependencies
    to other artifacts that have to be included in your application in order to achieve
    the desired functionality. A package delivered in that way is ready for use, which
    means that we don't have to configure anything to make it work. And that brings
    us to the second important term related to Spring Boot, auto-configuration. All
    artifacts included by the starters have default settings set, which can be easily
    overridden using properties or other types of starters. For example, if you include
    `spring-boot-starter-web` in your application dependencies it embeds a default
    web container and starts it on the default port during application startup. Looking
    forward, the default web container in Spring Boot is Tomcat, which starts on port `8080`.
    We can easily change this port by declaring the specified field in the application
    properties file and even change the web container by including `spring-boot-starter-jetty`
    or `spring-boot-starter-undertow` in our project dependencies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot致力于运行独立的Spring应用程序，与简单的Java应用程序一样，使用`java -jar`命令。使Spring Boot与标准Spring配置不同的基本事情是简单性。这种简单性与我们需要了解的第一个重要术语密切相关，即启动器。**启动器**是可以包含在项目依赖项中的工件。它只是提供一组依赖项给其他必须包含在应用程序中以实现所需功能的工件。以这种方式交付的软件包是可供使用的，这意味着我们不必配置任何内容使其工作。这就引出了与Spring
    Boot相关的第二个重要术语，自动配置。由启动器包含的所有工件都具有默认设置，可以通过属性或其他类型的启动器轻松覆盖。例如，如果在应用程序的依赖项中包含`spring-boot-starter-web`，它会嵌入一个默认的Web容器，并在应用程序启动期间在默认端口上启动它。展望未来，Spring
    Boot中的默认Web容器是Tomcat，它在端口`8080`上启动。我们可以通过在应用程序属性文件中声明指定字段来轻松更改此端口，甚至可以通过在项目依赖项中包含`spring-boot-starter-jetty`或`spring-boot-starter-undertow`来更改Web容器。
- en: 'Let me say a few words more about starters. Their official naming pattern is
    `spring-boot-starter-*`, where `*` is the particular type of starter. There are
    plenty of starters available within Spring Boot, but I would like to give you
    a short briefing on the most popular of them, which have also been used in the
    examples provided in the following chapters of this book:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我多说几句关于启动器。它们的官方命名模式是`spring-boot-starter-*`，其中`*`是特定类型的启动器。Spring Boot中有大量的启动器可用，但我想给你简要介绍一下其中最受欢迎的一些，这些启动器也在本书的后续章节中提供的示例中使用：
- en: '| **Name** | **Description** |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **描述** |'
- en: '| `spring-boot-starter` | Core starter, including auto-configuration support,
    logging, and YAML. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter` | 核心启动器，包括自动配置支持、日志记录和YAML。 |'
- en: '| `spring-boot-starter-web` | Allows us to build web applications, including
    RESTful and Spring MVC. Uses Tomcat as the default embedded container. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-web` | 允许我们构建Web应用程序，包括RESTful和Spring MVC。使用Tomcat作为默认的嵌入式容器。
    |'
- en: '| `spring-boot-starter-jetty` | Includes Jetty in the project and sets it as
    the default embedded servlet container. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jetty` | 在项目中包含Jetty并将其设置为默认的嵌入式Servlet容器。 |'
- en: '| `spring-boot-starter-undertow` | Includes Undertow in the project and sets
    it as the default embedded servlet container. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-undertow` | 在项目中包含Undertow并将其设置为默认的嵌入式Servlet容器。 |'
- en: '| `spring-boot-starter-tomcat` | Includes Tomcat as the embedded servlet container.
    The default servlet container starter used by `spring-boot-starter-web`. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-tomcat` | 将Tomcat作为嵌入式Servlet容器包含在内。`spring-boot-starter-web`使用的默认Servlet容器启动器。
    |'
- en: '| `spring-boot-starter-actuator` | Includes Spring Boot Actuator in the project,
    which provides features for monitoring and managing applications. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-actuator` | 在项目中包含Spring Boot Actuator，提供监视和管理应用程序的功能。
    |'
- en: '| `spring-boot-starter-jdbc` | Includes Spring JBDC with the Tomcat connection
    pool. The driver for the specific database should be provided by yourself. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-jdbc` | 包括带有Tomcat连接池的Spring JBDC。特定数据库的驱动程序应由您自己提供。
    |'
- en: '| `spring-boot-starter-data-jpa` | Includes all artifacts needed for interaction
    with relational databases using JPA/Hibernate. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-jpa` | 包括使用JPA/Hibernate与关系数据库交互所需的所有构件。 |'
- en: '| `spring-boot-starter-data-mongodb` | Includes all artifacts needed for interaction
    with MongoDB and initializing a client connection to Mongo on localhost.   |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-data-mongodb` | 包括与MongoDB交互所需的所有构件，并在本地初始化与Mongo的客户端连接。
    |'
- en: '| `spring-boot-starter-security` | Includes Spring Security in the project
    and enables basic security for applications by default. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-security` | 在项目中包含Spring Security，并默认启用应用程序的基本安全性。 |'
- en: '| `spring-boot-starter-test` | Allows the creation of unit tests using such
    libraries as JUnit, Hamcrest, and Mockito. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-test` | 允许使用诸如JUnit、Hamcrest和Mockito等库创建单元测试。 |'
- en: '| `spring-boot-starter-amqp` | Includes Spring AMQP to the project and starts
    RabbitMQ as the default AMQP broker. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `spring-boot-starter-amqp` | 将Spring AMQP包含到项目中，并启动RabbitMQ作为默认的AMQP代理。 |'
- en: If you are interested in the full list of available starters, refer to the Spring
    Boot specification. Now, let's get back to the main differences between Spring
    Boot and standard configuration with Spring Framework. Like I mentioned before
    we can include `spring-boot-starter-web`, which embeds a web container into our
    application. With standard Spring configuration, we do not embed a web container
    into the application, but deploy it as a WAR file on the web container. This is
    a key difference and one of the most important reasons that Spring Boot is used
    for creating applications deployed inside microservice architecture. One of the
    main features of microservices is independence from other microservices. In this
    case, it is clear that they should not share common resources, such as databases
    or web containers. Deploying many WAR files on one web container is an anti-pattern
    for microservices. Spring Boot is, therefore, the obvious choice.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对可用的启动器的完整列表感兴趣，请参考Spring Boot规范。现在，让我们回到Spring Boot和标准Spring Framework配置之间的主要区别。就像我之前提到的，我们可以包含`spring-boot-starter-web`，它将一个Web容器嵌入到我们的应用程序中。使用标准的Spring配置，我们不会将Web容器嵌入到应用程序中，而是将其部署为WAR文件到Web容器上。这是一个关键的区别，也是Spring
    Boot用于创建部署在微服务架构内的应用程序的最重要原因之一。微服务的主要特点之一是独立于其他微服务。在这种情况下，很明显它们不应该共享诸如数据库或Web容器之类的公共资源。在一个Web容器上部署许多WAR文件是微服务的反模式。因此，Spring
    Boot是显而易见的选择。
- en: 'Personally, I have used Spring Boot while developing many applications, not
    only when working in a microservice environment. If you try it instead of standard
    Spring Framework configuration, you will not want to go back. In support of that
    conclusion you can find an interesting diagram that illustrates the popularity
    of Java frameworks repositories on GitHub: [http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png](http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png).
    Let''s take a closer look at how to develop applications with Spring Boot.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我在开发许多应用程序时都使用了Spring Boot，不仅仅是在微服务环境中。如果您尝试使用它而不是标准的Spring Framework配置，您将不想回头。为了支持这个结论，您可以找到一个有趣的图表，说明了GitHub上Java框架仓库的流行程度：[http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png](http://redmonk.com/fryan/files/2017/06/java-tier1-relbar-20170622-logo.png)。让我们更仔细地看看如何使用Spring
    Boot开发应用程序。
- en: Developing applications with Spring Boot
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring Boot开发应用程序
- en: 'The recommended way to enable Spring Boot in your project is by using a dependency
    management system. Here, you can see a short snippet of how to include appropriate
    artifacts in your Maven and Gradle projects. Here is a sample fragment from the
    Maven `pom.xml`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中启用Spring Boot的推荐方法是使用依赖管理系统。在这里，您可以看到如何在Maven和Gradle项目中包含适当的构件的简短片段。以下是来自Maven
    `pom.xml`的示例片段：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With Gradle, we do not need to define parent dependency. Here''s a fragment
    from `build.gradle`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle，我们不需要定义父依赖项。以下是来自`build.gradle`的片段：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When using Maven, it is not necessary to inherit from the `spring-boot-starter-parent`
    POM. Alternatively, we can use the dependency management mechanism:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Maven时，不需要继承自`spring-boot-starter-parent` POM。相反，我们可以使用依赖管理机制：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, all we need is to create the main application class and annotate it with `@SpringBootApplication`,
    which is an equivalent to three other annotations used together—`@Configuration`,
    `@EnableAutoConfiguration`, and `@ComponentScan`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要创建主应用程序类，并用`@SpringBootApplication`进行注释，这相当于一起使用的另外三个注释—`@Configuration`、`@EnableAutoConfiguration`和`@ComponentScan`：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have the main class declared and `spring-boot-starter-web` included,
    we only need to run our first application. If you use a development IDE, such
    as Eclipse or IntelliJ, you should just run your main class. Otherwise, the application
    has to be built and run like a standard Java application with the `java -jar`
    command. First, we should provide the configuration that is responsible for packaging
    all dependencies into an executable JAR (sometimes called **fat JARs**) during
    application build. This action would be performed by `spring-boot-maven-plugin`
    if it is defined in the Maven `pom.xml`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了主类并包含了`spring-boot-starter-web`，我们只需要运行我们的第一个应用程序。如果您使用开发IDE，如Eclipse或IntelliJ，您应该只运行您的主类。否则，应用程序必须像标准的Java应用程序一样构建和运行，使用`java
    -jar`命令。首先，我们应该提供负责在应用程序构建期间将所有依赖项打包成可执行JAR（有时称为**fat JARs**）的配置。如果在Maven的`pom.xml`中定义了`spring-boot-maven-plugin`，则会执行此操作：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sample application does nothing more than start a Spring context on the
    Tomcat container, which is available on port `8080`. The fat JAR is about 14 MB
    in size. You can easily, using an IDE, check out which libraries are included
    in the project. These are all basic Spring libraries, such as `spring-core`, `spring-aop`, `spring-context`;
    Spring Boot; Tomcat embedded; libraries for logging including Logback, Log4j,
    and Slf4j; and Jackson libraries used for JSON serialization or deserialization.
    A good idea is to set the default Java version for the project. You can easily
    set it up in `pom.xml` by declaring the `java.version` property:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序除了在Tomcat容器上启动Spring上下文外，什么也没做，该容器可在端口`8080`上使用。这个fat JAR的大小约为14 MB。您可以很容易地使用IDE查看项目中包含的库。这些都是基本的Spring库，如`spring-core`，`spring-aop`，`spring-context`；Spring
    Boot；嵌入式Tomcat；用于日志记录的库，包括Logback，Log4j和Slf4j；以及用于JSON序列化或反序列化的Jackson库。为项目设置默认的Java版本是个好主意。您可以在`pom.xml`中通过声明`java.version`属性轻松设置它：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can change the default web container just by adding a new dependency, for
    example, to the Jetty server:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加新的依赖项来更改默认的Web容器，例如Jetty服务器：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Customizing configuration files
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义配置文件
- en: 'It''s one thing to have the ability to create applications quickly and without
    a huge volume of work, but no less important is the ability to easily customize
    and override default settings. Spring Boot comes in handy and provides mechanisms
    that enable configuration management. The simplest way to do that is using configuration
    files, which are appended to the application fat JAR. Spring Boot automatically
    detects configuration files whose name start with the `application` prefix. Supported
    file types are `.properties` and `.yml`. Therefore, we can create configuration
    files, such as `application.properties` or `application.yml`, and even including
    profile-specific files such as, `application-prod.properties` or `application-dev.yml`.
    Moreover, we can use OS environment variables and command-line arguments to externalize
    configuration. When using properties or YAML files, they should be placed in one
    of the following locations:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 能够快速创建应用程序而不需要大量工作是一回事，但同样重要的是能够轻松定制和覆盖默认设置。Spring Boot非常方便，并提供了使配置管理变得容易的机制。最简单的方法是使用配置文件，这些文件附加到应用程序的fat
    JAR。Spring Boot会自动检测文件名以`application`前缀开头的配置文件。支持的文件类型是`.properties`和`.yml`。因此，我们可以创建配置文件，例如`application.properties`或`application.yml`，甚至包括特定配置文件，如`application-prod.properties`或`application-dev.yml`。此外，我们可以使用操作系统环境变量和命令行参数来外部化配置。在使用属性或YAML文件时，它们应放置在以下位置之一：
- en: A `/config` subdirectory of the current application directory
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序目录的`/config`子目录
- en: The current application directory
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前应用程序目录
- en: A classpath `/config` package (for example, inside your JAR)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径`/config`包（例如，在您的JAR内部）
- en: The classpath root
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类路径根目录
- en: 'If you would like to give a specific name to your configuration file, other
    than application or `application-{profile}`, you need to provide a `spring.config.name`
    environment property during startup. You can also use the `spring.config.location`
    property, which contains a comma-separated list of directory locations or file
    paths:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要为配置文件指定一个特定的名称，而不是应用程序或`application-{profile}`，您需要在启动时提供`spring.config.name`环境属性。您还可以使用`spring.config.location`属性，其中包含逗号分隔的目录位置或文件路径：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Inside configuration files, we can define two types of properties. First, there
    is a group of common, predefined Spring Boot properties consumed by the underlying
    classes mostly from the `spring-boot-autoconfigure` library. We can also define
    our own custom configuration properties, which are then injected into the application
    using the `@Value` or `@ConfigurationProperties` annotations.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置文件中，我们可以定义两种类型的属性。首先，有一组常见的预定义Spring Boot属性，大多数是由`spring-boot-autoconfigure`库中的底层类消耗的。我们还可以定义自己的自定义配置属性，然后使用`@Value`或`@ConfigurationProperties`注解将其注入到应用程序中。
- en: 'Let''s begin with the predefined properties. The full list of supported by
    the Spring Boot project is available in their documentation in *Appendix A**,* in
    the *Common application properties* section. Most of them are specific to certain
    Spring modules, such as databases, web servers, security, and some other solutions,
    but there is also a group of core properties. Personally, I prefer using YAML
    instead of properties files because it is easily readable by humans, but the decision
    is yours. Most commonly, I override such properties as application name, which
    is used for service discovery and distributed configuration management; web server
    port; logging; or database connection settings. Usually, `application.yml` file
    is placed in the `src/main/resources` directory, which is then located in the
    JAR root directory after the Maven build. Here''s a sample configuration file,
    which overrides default server port, application name, and logging properties:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从预定义属性开始。Spring Boot项目支持的完整列表可在其文档的*附录A*中的*常见应用程序属性*部分找到。其中大部分是特定于某些Spring模块的，如数据库、Web服务器、安全性和其他一些解决方案，但也有一组核心属性。我个人更喜欢使用YAML而不是属性文件，因为它易于人类阅读，但决定权在您手中。通常，我会覆盖应用程序名称、用于服务发现和分布式配置管理的Web服务器端口、日志记录或数据库连接设置等属性。通常，`application.yml`文件放在`src/main/resources`目录中，然后在Maven构建后位于JAR根目录中。以下是一个覆盖默认服务器端口、应用程序名称和日志记录属性的示例配置文件：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The one really cool thing here is that you don't have to define any other external
    configuration files, for example, `log4j.xml` or `logback.xml`, for logging configuration.
    In the previous fragment, you can see that I changed the default log level for
    `org.springframework.web` to `DEBUG` and log patterns, and created a log file, `app.log`,
    placed in the current application directory. Now, the default application name
    is `first-service` and the default HTTP port is `2222`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正酷的一点是，你不必定义任何其他外部配置文件，例如`log4j.xml`或`logback.xml`，用于日志配置。在前面的片段中，你可以看到我将`org.springframework.web`的默认日志级别更改为`DEBUG`，并创建了一个名为`app.log`的日志文件，放在当前应用程序目录中。现在，默认应用程序名称是`first-service`，默认HTTP端口是`2222`。
- en: 'Our custom configuration settings should also be placed in the same properties
    or YAML files. Here''s a sample `application.yml` with custom properties:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义配置设置也应该放在相同的属性或YAML文件中。以下是一个带有自定义属性的示例`application.yml`：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A simple property can be injected using the `@Value` annotation:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`@Value`注解注入一个简单的属性：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also the ability to inject more complex configuration properties using
    the `@ConfigurationProperties` annotation. The list of values defined in the `my.servers`
    property inside the YAML file was injected to the target bean of type `java.util.List`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以使用`@ConfigurationProperties`注解注入更复杂的配置属性。在YAML文件中定义的`my.servers`属性的值列表被注入到类型为`java.util.List`的目标bean中：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, we have managed to create a simple application that does nothing more
    than start Spring on a web container such as Tomcat or Jetty. In this part of
    the chapter, I wanted to show you how simple it is to start application development
    using Spring Boot. Apart from that, I have described how to customize configuration
    using YAML or properties files. For those people who prefer clicking to typing,
    I recommend the Spring Initializr website ([https://start.spring.io/](https://start.spring.io/)),
    where you can generate the project stub based on options you choose. In the simple
    site view, you can choose build tools (Maven/Gradle), language (Java/Kotlin/Groovy),
    and Spring Boot version. Then, you should provide all necessary dependencies using
    the search engine following the Search for dependencies label. I included `spring-boot-starter-web`,
    which is just labeled as `Web` on Spring Initializr as you see in the following
    screenshot. After clicking on Generate project, the ZIP file with the generated
    source code gets downloaded onto your computer. You might also be interested in
    knowing that by clicking Switch to the full version, you are able to see almost
    all available Spring Boot and Spring Cloud libraries, which can be included in
    the generated project:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建了一个简单的应用程序，除了在Web容器上启动Spring，如Tomcat或Jetty，什么也没做。在本章的这一部分，我想向你展示使用Spring
    Boot开始应用程序开发有多简单。除此之外，我还描述了如何使用YAML或属性文件自定义配置。对于那些更喜欢点击而不是打字的人，我推荐使用Spring Initializr网站（[https://start.spring.io/](https://start.spring.io/)），在那里你可以根据你选择的选项生成项目存根。在简单的网站视图中，你可以选择构建工具（Maven/Gradle）、语言（Java/Kotlin/Groovy）和Spring
    Boot版本。然后，你应该使用搜索引擎提供所有必要的依赖项，按照`Search for dependencies`标签。我包括了`spring-boot-starter-web`，在Spring
    Initializr上标记为`Web`，如下面的截图所示。点击`Generate project`后，生成的源代码ZIP文件将下载到你的计算机上。你可能也会对知道，点击`Switch
    to the full version`，你可以看到几乎所有可用的Spring Boot和Spring Cloud库，这些库可以包含在生成的项目中，感兴趣：
- en: '![](img/557eaa38-1948-4896-88cf-48587b8e60d8.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/557eaa38-1948-4896-88cf-48587b8e60d8.png)'
- en: I think that, since we have been going over the basics about building projects
    using Spring Boot, this is the right time to add some new features to our sample
    application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，既然我们已经讨论了使用Spring Boot构建项目的基础知识，现在是时候为我们的示例应用程序添加一些新功能了。
- en: Creating RESTful Web Services
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建RESTful Web服务
- en: 'As a first step, let''s create RESTful Web Services exposing some data to the
    calling clients. As mentioned before, the Jackson library, which is responsible
    for the serialization and deserialization of JSON messages, is automatically included
    in our classpath together with `spring-boot-starter-web`. Thanks to that, we don''t
    have to do anything more than declare a model class, which is then returned or
    taken as a parameter by REST methods. Here''s our sample model class, `Person`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些RESTful Web服务，向调用客户端公开一些数据。如前所述，负责JSON消息序列化和反序列化的Jackson库与`spring-boot-starter-web`一起自动包含在我们的类路径中。由于这个，我们不必做任何事情，只需声明一个模型类，然后通过REST方法返回或作为参数接收。这是我们的示例模型类`Person`：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Spring Web provides some annotations for creating RESTful Web Services. The
    first of them is the `@RestController` annotation, which should be set on your
    controller bean class that is responsible for handling incoming HTTP requests.
    There is also the `@RequestMapping` annotation, which is usually used for mapping
    controller methods to HTTP. As you see in the following code fragment, it can
    be used on the whole controller class to set the request path for all methods
    inside it. We can use more specific annotations for the concrete HTTP methods
    such as `@GetMapping` or `@PostMapping`.  `@GetMapping` is the same as `@RequestMapping`
    with the parameter `method=RequestMethod.GET`. Two other commonly used annotations
    are `@RequestParam` and `@RequestBody`. The first binds path and query params
    to objects; the second maps input JSON to objects using the Jackson library:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Web提供了一些用于创建RESTful Web服务的注解。其中第一个是`@RestController`注解，应该设置在负责处理传入HTTP请求的控制器bean类上。还有`@RequestMapping`注解，通常用于将控制器方法映射到HTTP。如你在下面的代码片段中看到的，它可以用在整个控制器类上，为其中的所有方法设置请求路径。我们可以使用更具体的注解来处理具体的HTTP方法，比如`@GetMapping`或`@PostMapping`。`@GetMapping`与带有参数`method=RequestMethod.GET`的`@RequestMapping`相同。另外两个常用的注解是`@RequestParam`和`@RequestBody`。第一个将路径和查询参数绑定到对象；第二个使用Jackson库将输入JSON映射到对象：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To be compatible with REST API standards, we should handle `PUT` and `DELETE`
    methods. After their implementation, our service performs all CRUD operations:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与REST API标准兼容，我们应该处理`PUT`和`DELETE`方法。在它们的实现之后，我们的服务执行所有CRUD操作：
- en: '| **Method** | **Path** | **Description** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **路径** | **描述** |'
- en: '| `GET` | `/person` | Returns all existing persons |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/person` | 返回所有现有的人员 |'
- en: '| `GET` | `/person/{id}` | Returns person with the given *id* |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `/person/{id}` | 返回具有给定*id*的人员 |'
- en: '| `POST` | `/person` | Adds new person |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `/person` | 添加新人员 |'
- en: '| `PUT` | `/person` | Updates existing person |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | `/person` | 更新现有人员 |'
- en: '| `DELETE` | `/person/{id}` | Removes person from list using given *id* |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `/person/{id}` | 使用给定的*id*从列表中删除人员 |'
- en: 'Here''s a fragment of a sample `@RestController` implementation with the `DELETE`
    and `PUT` methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个样本`@RestController`实现的片段，其中包括`DELETE`和`PUT`方法：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The controller code is really simple. It stores all data in the local `java.util.List`,
    which is obviously not a good programming practice. However, treat that as a simplification
    adopted for the purposes of the basic example. In the section *Integrating application
    with database*, in this chapter, I'll cover more advanced sample application that
    integrates with the NoSQL database.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器代码非常简单。它将所有数据存储在本地的`java.util.List`中，这显然不是一个好的编程实践。但是，出于基本示例的目的，请将其视为一种简化。在本章的*将应用程序与数据库集成*部分，我将介绍更高级的示例应用程序，该应用程序与NoSQL数据库集成。
- en: Probably some of you have experience with SOAP Web Services. If we had created
    a similar service using SOAP instead of REST, we would provide a WSDL file for
    the client with all service definitions described. Unfortunately, REST doesn't
    support such standard notation as WSDL. In the initial stage of RESTful Web Services,
    it was said that **Web Application Description Language** (**WADL**) would perform
    that role. But the reality is that many providers, including Spring Web, do not
    generate WADL files after application startup. Why am I mentioning this? Well,
    we have already finished our first microservice, which exposes some REST operations
    over HTTP. You have probably run this microservice from your IDE or using the `java
    -jar` command after building the fat JAR. If you didn't change the configuration
    properties inside the `application.yml` file, or did not set the `-Dport` option
    while running the application, it is available under `http://localhost:2222`.
    In order to enable others to call our API, we have two choices. We can share a
    document describing its usage or mechanisms for automatic API client generation.
    Or both of them. That's where Swagger comes in.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有些人有使用SOAP Web服务的经验。如果我们使用SOAP而不是REST创建了类似的服务，我们将为客户端提供一个包含所有服务定义的WSDL文件。不幸的是，REST不支持WSDL这样的标准符号。在RESTful
    Web服务的初始阶段，曾经说过**Web应用程序描述语言**（**WADL**）将扮演这个角色。但现实是，包括Spring Web在内的许多提供者在应用程序启动后不会生成WADL文件。为什么我要提到这个？嗯，我们已经完成了我们的第一个微服务，它通过HTTP公开了一些REST操作。您可能已经从您的IDE或使用`java
    -jar`命令运行了这个微服务，构建了fat JAR后。如果您没有在`application.yml`文件中更改配置属性，或者在运行应用程序时没有设置`-Dport`选项，它将在`http://localhost:2222`下可用。为了让其他人调用我们的API，我们有两种选择。我们可以共享描述其用法或自动生成API客户端的机制的文档。或者两者都有。这就是Swagger的用武之地。
- en: API Documentation
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API文档
- en: Swagger is the most popular tool for designing, building, and documenting RESTful
    APIs. It has been created by SmartBear, the designers of a very popular tool for
    SOAP Web Services, SoapUI. I think that might be sufficient recommendation for
    those who have long experience with SOAP. Anyway, with Swagger, we can design
    APIs using notation and then generate source code from it, or the other way around,
    where we start with the source code and then generate a Swagger file. With Spring
    Boot, we use the second option.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger是设计、构建和记录RESTful API的最流行工具。它是由SmartBear创建的，他们是一个非常流行的SOAP Web服务工具SoapUI的设计者。我认为这对于那些有长期SOAP经验的人来说可能已经足够推荐了。无论如何，使用Swagger，我们可以使用符号设计API，然后从中生成源代码，或者反过来，我们从源代码开始，然后生成Swagger文件。使用Spring
    Boot，我们使用第二个选项。
- en: Using Swagger 2 together with Spring Boot
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger 2与Spring Boot
- en: 'The integration between Spring Boot and Swagger 2 is realized by the Springfox
    project. It examines application at runtime to infer API semantics based on Spring
    configurations, class structure, and Java annotations. To use Swagger in conjunction
    with Spring, we need to add the following two dependencies to the Maven `pom.xml` and
    annotate the main application class with `@EnableSwagger2`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 'Spring Boot和Swagger 2之间的集成由Springfox项目实现。它在运行时检查应用程序，根据Spring配置、类结构和Java注释推断API语义。要与Spring一起使用Swagger，我们需要将以下两个依赖项添加到Maven的`pom.xml`中，并在主应用程序类中注释`@EnableSwagger2`： '
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The API documentation will be automatically generated from the source code
    by the Swagger library during application startup. The process is controlled by
    the `Docket` bean, which is also declared in the main class. A nice idea might
    be to get the API version from the Maven `pom.xml` file. We can get it by including
    the `maven-model` library in the classpath and using the `MavenXpp3Reader` class.
    We also set some other properties, such as title, author, and description using
    the `apiInfo` method. By default, Swagger generates documentation for all REST
    services, including those created by Spring Boot. We would like to limit this
    documentation only to our `@RestController` located inside the `pl.piomin.services.boot.controller`
    package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: API文档将在应用程序启动期间由Swagger库从源代码自动生成。该过程由`Docket` bean控制，该bean也在主类中声明。一个好主意可能是从Maven的`pom.xml`文件中获取API版本。我们可以通过在类路径中包含`maven-model`库并使用`MavenXpp3Reader`类来获取它。我们还使用`apiInfo`方法设置了一些其他属性，例如标题、作者和描述。默认情况下，Swagger为所有REST服务生成文档，包括Spring
    Boot创建的服务。我们希望将此文档限制在我们的`@RestController`中，该`@RestController`位于`pl.piomin.services.boot.controller`包内：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing API with Swagger UI
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger UI测试API
- en: 'An API documentation dashboard is available at `http://localhost:2222/swagger-ui.html`
    after application startup. This is a more user-friendly version of the Swagger
    JSON definition file, which is also automatically generated and available at `http://localhost:2222/v2/api-docs`.
    That file can be imported by any other REST tools, for example, SoapUI:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动后，可以在`http://localhost:2222/swagger-ui.html`上找到API文档仪表板。这是Swagger JSON定义文件的更用户友好版本，该文件也会自动生成，并在`http://localhost:2222/v2/api-docs`上提供。该文件可以被任何其他REST工具导入，例如SoapUI：
- en: '![](img/596d9d1a-0019-43dd-b4c8-62222a248ba9.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/596d9d1a-0019-43dd-b4c8-62222a248ba9.png)'
- en: 'If you prefer SoapUI instead of Swagger UI, you can easily import the Swagger
    definition file by selecting Project | Import Swagger. Then, you need to provide
    a file address, as you can see in this screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢SoapUI而不是Swagger UI，您可以通过选择项目|导入Swagger轻松导入Swagger定义文件。然后，您需要提供一个文件地址，就像您在这个屏幕截图中看到的那样：
- en: '![](img/8cc43aa0-54b2-4fe5-b60f-3ac8f70ef909.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cc43aa0-54b2-4fe5-b60f-3ac8f70ef909.png)'
- en: 'Personally, I prefer Swagger UI. You can expand every API method to see their
    details. Every operation can be tested by providing the required parameters or
    JSON input, and clicking the Try it out! button. Here''s a screenshot illustrating
    sending a `POST /person` test request:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就我个人而言，我更喜欢Swagger UI。您可以展开每个API方法以查看其详细信息。通过提供所需的参数或JSON输入并单击“试一下！”按钮，可以测试每个操作。这里有一张屏幕截图，说明了发送一个`POST
    /person`测试请求：
- en: '![](img/05eff4f3-d1c5-46ab-86b2-5d61833a77c6.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05eff4f3-d1c5-46ab-86b2-5d61833a77c6.png)'
- en: 'Here''s the response screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这是响应屏幕：
- en: '![](img/edd90841-af55-443e-b42c-53ed834daf17.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/edd90841-af55-443e-b42c-53ed834daf17.png)'
- en: Spring Boot Actuator features
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot执行器功能
- en: 'Just creating the working application and sharing standardized API documentation
    is not everything, especially if we are talking about microservices, where there
    are plenty of independent entities structuring one managed environment. The next
    important thing that needs to be mentioned is monitoring and gathering metrics
    from applications. In that aspect, Spring Boot also comes through. Project Spring
    Boot Actuator provides a number of built-in endpoints, which allow us to monitor
    and interact with the application. To enable it in our project, we should include
    `spring-boot-starter-actuator` in the dependencies. Here''s a list of the most
    important Actuator endpoints:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建工作应用程序并共享标准化的API文档并不是一切，特别是如果我们谈论的是微服务，在那里有许多独立的实体构建一个受管理的环境。需要提到的下一个重要事项是监控和从应用程序中收集指标。在这方面，Spring
    Boot也能胜任。项目Spring Boot执行器提供了许多内置端点，允许我们监视和与应用程序交互。要在我们的项目中启用它，我们应该在依赖项中包含`spring-boot-starter-actuator`。以下是最重要的执行器端点列表：
- en: '| **Path** | **Description** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **路径** | **描述** |'
- en: '| `/beans` | Displays a full list of all the Spring beans initialized in the
    application. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `/beans` | 显示应用程序中初始化的所有Spring bean的完整列表。|'
- en: '| `/env` | Exposes properties from Spring’s Configurable Environment, which
    means, for example, OS environment variables and properties from configuration
    files. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `/env` | 显示来自Spring的可配置环境的属性，这意味着，例如，操作系统环境变量和配置文件中的属性。|'
- en: '| `/health` | Shows application health information. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `/health` | 显示应用程序的健康信息。|'
- en: '| `/info` | Displays arbitrary application information. It can be taken, for
    example, from the `build-info.properties` or `git.properties` files. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `/info` | 显示任意应用程序信息。例如，可以从`build-info.properties`或`git.properties`文件中获取。|'
- en: '| `/loggers` | Shows and modifies the configuration of loggers in the application.
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `/loggers` | 显示并修改应用程序中记录器的配置。|'
- en: '| `/metrics` | Shows metrics information for the current application, such
    as memory usage, number of running threads, or REST method response time. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `/metrics` | 显示当前应用程序的度量信息，例如内存使用情况，运行线程数或REST方法响应时间。|'
- en: '| `/trace` | Displays trace information (by default the last 100 HTTP requests).
    |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `/trace` | 显示跟踪信息（默认情况下是最后100个HTTP请求）。|'
- en: 'Endpoints can be easily customized using Spring configuration properties. For
    example, we can disable one of the enabled by default endpoints. By default, all
    endpoints except for `shutdown` are enabled. Most of these endpoints are secured.
    If you would like to call them from your web browser, you should provide security
    credentials in the request header or disable security for the whole project. To
    do the latter, you have to include the following statement in your `application.yml`
    file:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Spring配置属性轻松自定义端点。例如，我们可以禁用默认情况下启用的端点之一。默认情况下，除了`shutdown`之外，所有端点都是启用的。这些端点中的大多数都是受保护的。如果您想从Web浏览器调用它们，您应该在请求标头中提供安全凭据或为整个项目禁用安全性。要执行后者，您必须在您的`application.yml`文件中包含以下语句：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Application information
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序信息
- en: 'The full list of endpoints available for the project is visible in application
    logs during startup. After disabling security, you can test all of them in your
    web browser. It''s interesting that the `/info` endpoint does not provide any
    information by default. If you would like to change this, you might use one of
    the three available auto-configured `InfoContributor` beans or write your own.
    The first of them, `EnvironmentInfoContributor`, exposes environment keys in the
    endpoint. The second, `GitInfoContributor`, detects the `git.properties` file
    in the classpath and then displays all necessary information about commits, such
    as branch name or commit ID. The last one, named `BuildInfoContributor`, gathers
    information from the `META-INF/build-info.properties` file and also displays it
    in the endpoint. These two properties files for Git and build information can
    be automatically generated during application build. To achieve this, you should
    include `git-commit-id-plugin` in your `pom.xml` and customize `spring-boot-maven-plugin`
    to generate `build-info.properties` in the way visible in this code fragment:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 项目可用的端点完整列表在启动期间的应用程序日志中可见。在禁用安全性后，您可以在Web浏览器中测试所有这些端点。有趣的是，默认情况下`/info`端点不提供任何信息。如果您想要更改这一点，您可以使用三个可用的自动配置的`InfoContributor`
    bean之一，或者编写自己的。其中之一，`EnvironmentInfoContributor`在端点中公开环境键。第二个`GitInfoContributor`检测类路径中的`git.properties`文件，然后显示有关提交的所有必要信息，例如分支名称或提交ID。最后一个名为`BuildInfoContributor`，从`META-INF/build-info.properties`文件中收集信息，并在端点中显示它。这两个用于Git和构建信息的属性文件可以在应用程序构建期间自动生成。要实现这一点，您应该在您的`pom.xml`中包含`git-commit-id-plugin`，并自定义`spring-boot-maven-plugin`以生成`build-info.properties`，以便在此代码片段中可见的方式：
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With the `build-info.properties` file available, your `/info` would be a little
    different than before:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`build-info.properties`文件，您的`/info`将与以前有些不同：
- en: '[PRE19]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Health information
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 健康信息
- en: 'As with the `/info` endpoint, there are also some auto-configured indicators
    for the `/health` endpoint. We can monitor the status of disk usage, mail service,
    JMS, data sources, and NoSQL databases, such as MongoDB or Cassandra. If you check
    out that endpoint from our sample application, you only get the information about
    disk usage. Let''s add MongoDB to the project to test one of the available health
    indicators, `MongoHealthIndicator`. MongoDB is not a random selection. It will
    be useful for us in the future for a more advanced example of the `Person` microservice.
    To enable MongoDB use, we need to add the following dependencies to `pom.xml`.
    The `de.flapdoodle.embed.mongo` artifact is responsible for starting the embedded
    database instance during application startup:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与`/info`端点一样，`/health`端点也有一些自动配置的指标。我们可以监视磁盘使用情况、邮件服务、JMS、数据源和NoSQL数据库（如MongoDB或Cassandra）的状态。如果您从我们的示例应用程序中检查该端点，您只会得到有关磁盘使用情况的信息。让我们将MongoDB添加到项目中，以测试其中一个可用的健康指标`MongoHealthIndicator`。MongoDB不是随机选择。它将在未来对我们的`Person`微服务的更高级示例非常有用。要启用MongoDB使用，我们需要将以下依赖项添加到`pom.xml`中。`de.flapdoodle.embed.mongo`工件负责在应用程序启动期间启动嵌入式数据库实例：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, the `/health` endpoint returns information about disk usage and MongoDB
    status:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`/health`端点返回有关磁盘使用情况和MongoDB状态的信息：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we can see the power of Spring Boot auto-configuration. We
    didn't have to do anything more than include two dependencies to the project to
    enable embedded MongoDB. Its status has been automatically added to the `/health`
    endpoint. It also has a ready-to-use client connection to Mongo, which can be
    further used by the repository bean.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到Spring Boot自动配置的强大功能。我们只需要将两个依赖项包含到项目中，就可以启用嵌入式MongoDB。它的状态已经自动添加到`/health`端点。它还具有一个可供使用的Mongo客户端连接，可以进一步由存储库bean使用。
- en: Metrics
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指标
- en: 'As we usually say, there is no such thing as a free lunch. Development is fast
    and easy, but after including some additional libraries in the project, the fat
    JAR file now has about 30 MB. Using one of the auto-configured actuator endpoints, `/metrics`,
    we can easily check out our microservice heap and non-heap memory usage. After
    sending some test requests, heap usage was about 140 MB and non-heap was 65 MB.
    Total memory usage for the application was about 320 MB. Of course, these values
    can be reduced a little even just by using the `-Xmx` parameter during startup
    with the `java -jar` command. However, we should not reduce this limit too much
    if we care about reliable working in production mode. Apart from memory usage,
    the `/metrics` endpoint displays information about the number of loaded classes,
    the number of active threads, the average duration of each API method, and a lot
    more. Here''s a fragment of the endpoint response for our sample microservice:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通常说的，没有免费的午餐。开发快速简单，但在项目中包含一些额外的库之后，fat JAR文件现在大约有30 MB。使用其中一个自动配置的执行器端点`/metrics`，我们可以轻松查看我们的微服务堆和非堆内存使用情况。发送一些测试请求后，堆使用量约为140
    MB，非堆使用量为65 MB。应用程序的总内存使用量约为320 MB。当然，即使只是在启动时使用`java -jar`命令和`-Xmx`参数，这些值也可以稍微减少。但是，如果我们关心在生产模式下可靠地工作，我们不应该将这个限制减少太多。除了内存使用情况，`/metrics`端点还显示有关加载类的数量、活动线程的数量、每个API方法的平均持续时间等信息。以下是我们示例微服务的端点响应片段：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There is the possibility to create our own custom metrics. Spring Boot Actuator
    provides two classes in case we would like to do that—`CounterService` and `GaugeService`.
    `CounterService`, as its name indicates, exposes methods for value incrementation,
    decrementation, and reset. By contrast, `GaugeService` is intended to just submit
    the current value. Default metrics for the API method calling statistics are a
    little imperfect because they are based only on the invoking path. There is no
    distinguishing between method types if they are available  on the same path. In
    our sample endpoint, this applies to `GET /person`, `POST /person`, and `PUT /person`.
    Anyway, I created the `PersonCounterService` bean, which counts the number of
    `add` and `delete` method calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有可能创建自己的自定义指标。Spring Boot Actuator提供了两个类，以便我们可以这样做——`CounterService`和`GaugeService`。`CounterService`如其名称所示，提供了用于增加、减少和重置值的方法。相比之下，`GaugeService`旨在仅提交当前值。API方法调用统计的默认指标有些不完善，因为它们仅基于调用路径。如果它们在相同的路径上可用，就不区分方法类型。在我们的示例端点中，这适用于`GET
    /person`、`POST /person`和`PUT /person`。无论如何，我创建了`PersonCounterService` bean，用于计算`add`和`delete`方法的调用次数：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This bean needs to be injected into our REST controller bean, and the methods
    incrementing the counter value can be invoked when a person is added or removed:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bean需要注入到我们的REST控制器bean中，并且在添加或删除人员时可以调用增加计数器值的方法：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, if you display application metrics again, you will see the following two
    new fields in the JSON response:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果再次显示应用程序指标，您将在JSON响应中看到以下两个新字段：
- en: '[PRE25]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All metrics generated by the Spring Boot application may be exported from the
    in-memory buffers to a place where they can be analyzed and displayed. We can
    store them, for example, in Redis, Open TSDB, Statsd, or even InfluxDB.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot应用程序生成的所有指标都可以从内存缓冲区导出到可以进行分析和显示的地方。我们可以将它们存储在Redis、Open TSDB、Statsd甚至InfluxDB中。
- en: I think that's about all the details about built-in monitor endpoints I wanted
    to give you. I had designated a relatively large amount of space to such topics
    as documentation, metrics, and health checks, but in my opinion, these are the
    important aspects of microservice development and maintenance. Developers often
    do not care if these mechanisms are well implemented, but others often see our
    application just through the prism of those metrics, health checks and application's
    logs quality. Spring Boot provides such an implementation out of the box, and
    therefore developers do not have to spend much time enabling them.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这就是我想给你的关于内置监视端点的所有细节。我已经为文档、指标和健康检查等主题指定了相当大的空间，但在我看来，这些是微服务开发和维护的重要方面。开发人员通常不在乎这些机制是否实现良好，但其他人经常通过这些指标、健康检查和应用程序日志的质量来看待我们的应用程序。Spring
    Boot提供了这样一个开箱即用的实现，因此开发人员不必花费太多时间来启用它们。
- en: Developer tools
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发人员工具
- en: 'Spring Boot offers some other useful tools for developers. The really cool
    thing for me is that the application is automatically restarted whenever files
    on the project classpath change. If you use Eclipse as your IDE, the only thing
    you have to do to enable it is to add the `spring-boot-devtools` dependency to
    the Maven `pom.xml`. Then, try to change something in one of your classes and
    save it. The application automatically restarts, and it takes much less than stopping
    and starting in the standard way. When I start our sample application, it takes
    about 9 seconds, and automatic restart takes only 3 seconds:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot为开发人员提供了一些其他有用的工具。对我来说真正酷的事情是，每当项目类路径上的文件发生更改时，应用程序会自动重新启动。如果您使用Eclipse作为您的IDE，您只需要在Maven的`pom.xml`中添加`spring-boot-devtools`依赖项即可启用它。然后，尝试更改您的某个类中的内容并保存。应用程序会自动重新启动，而且比以标准方式停止和启动要快得多。当我启动我们的示例应用程序时，大约需要9秒，而自动重新启动只需要3秒：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can exclude some resources if there is no need to trigger a restart when
    they are changed. By default, any file available on the classpath that points
    to a folder will be monitored for changes, even static assets or view templates,
    which do not need restarting. For example, if they are placed in the static folder,
    you can exclude them by adding the following property to the `application.yml`
    configuration file:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不需要在更改时触发重新启动，我们可以排除一些资源。默认情况下，类路径上指向文件夹的任何文件都将被监视以进行更改，即使是静态资产或视图模板，它们也不需要重新启动。例如，如果它们放在静态文件夹中，您可以通过将以下属性添加到`application.yml`配置文件中来排除它们：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Integrating application with database
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序与数据库集成
- en: You can find more interesting features described in the Spring Boot specification.
    I would like to spend more time describing other cool functionalities provided
    by that framework, but we should not go too far away from the main topic—Spring
    for microservices. As you may recall, through including embedded MongoDB in the
    project, I promised you a more advanced microservice example. Before starting
    to work on it, let's go back for a moment to the current version of our application.
    Its source code is available on my public GitHub account. Clone the following
    Git repository to your local machine: [https://github.com/piomin/sample-spring-boot-web.git](https://github.com/piomin/sample-spring-boot-web.git).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Spring Boot规范中找到更多有趣的功能描述。我想花更多时间描述该框架提供的其他酷功能，但我们不应该离主题——微服务的Spring太远。您可能还记得，通过在项目中包含嵌入式MongoDB，我向您承诺了一个更高级的微服务示例。在开始处理它之前，让我们回到我们应用程序的当前版本。它的源代码可以在我的公共GitHub账户上找到。将以下Git存储库克隆到您的本地计算机：[https://github.com/piomin/sample-spring-boot-web.git](https://github.com/piomin/sample-spring-boot-web.git)。
- en: Building a sample application
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建示例应用程序
- en: 'The basic example is available in the `master` branch. The more advanced sample,
    with embedded MongoDB, is committed to the `mongo` branch. In case you would like
    to try running more advanced sample, you need to switch to that branch using `git
    checkout mongo`. Now, we need to perform some changes in the model class to enable
    object mapping to MongoDB. The model class has to be annotated with `@Document`
    and the primary key field with `@Id`. I also changed the ID field type from `Long`
    to `String` because MongoDB generates primary keys in UUID format, for example, `59d63385206b6d14b854a45c`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 基本示例可在`master`分支中找到。更高级的示例，带有嵌入式MongoDB，已提交到`mongo`分支。如果您想尝试运行更高级的示例，您需要切换到该分支，使用`git
    checkout mongo`。现在，我们需要对模型类进行一些更改，以实现对象映射到MongoDB。模型类必须用`@Document`进行注释，主键字段用`@Id`进行注释。我还将ID字段类型从`Long`更改为`String`，因为MongoDB以UUID格式生成主键，例如`59d63385206b6d14b854a45c`。
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to create a repository interface that extends `MongoRepository`.
    MongoRepository provides basic methods for searching and storing data, such as `findAll`,
    `findOne`, `save`, and `delete`. Spring Data has a very smart mechanism for performing
    queries using repository objects. We don''t have to implement queries by ourselves,
    but only define an interface method with the right name. The method name should
    have the prefix `findBy` and then the searched field name. It may end with a standard
    search keyword suffix, such as `GreaterThan`, `LassThan`, `Between`, `Like`, and
    many more. A MongoDB query is automatically generated by Spring Data classes based
    on the full method name. The same keywords may be used in conjunction with `delete…By`
    or `remove…By` to create remove queries. In the `PersonRepository` interface,
    I decided to define two find methods. The first of them, `findByLastName`, selects
    all `Person` entities with the given `lastName` value. The second, `findByAgeGreaterThan`,
    is designed to retrieve all `Person` entities with an age greater than a given
    value:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个扩展`MongoRepository`的存储库接口。MongoRepository提供了用于搜索和存储数据的基本方法，如`findAll`、`findOne`、`save`和`delete`。Spring
    Data具有一个非常智能的机制，可以使用存储库对象执行查询。我们不必自己实现查询，而只需定义一个具有正确名称的接口方法。方法名称应该以`findBy`为前缀，然后是搜索字段名称。它可能以标准的搜索关键字后缀结束，如`GreaterThan`、`LassThan`、`Between`、`Like`等等。基于完整方法名称，Spring
    Data类会自动生成MongoDB查询。相同的关键字可以与`delete…By`或`remove…By`结合使用来创建删除查询。在`PersonRepository`接口中，我决定定义两个查找方法。其中第一个`findByLastName`，选择所有`lastName`值为给定值的`Person`实体。第二个`findByAgeGreaterThan`，旨在检索所有年龄大于给定值的`Person`实体：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The repository should be injected into the REST controller class. Then, we
    can finally call all the required CRUD methods provided by `PersonRepository`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 将存储库注入到REST控制器类中。然后，我们最终可以调用`PersonRepository`提供的所有必需的CRUD方法：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have also added two API methods for custom find operations from the `PersonRepository`
    bean:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为`PersonRepository` bean添加了两个自定义查找操作的API方法：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That's all that had to be done. Our microservice that exposes basic API methods
    implementing CRUD operations on an embedded Mongo database is ready to launch.
    You have probably noticed that it didn't require us to create a lot of source
    code. Implementation of any interaction with databases, whether relational or
    NoSQL, using Spring Data is fast and relatively easy. Anyway, there is still one
    more challenge facing us. An embedded database is a good choice, but only in development
    mode or for unit testing, not in production. If you have to run your microservice
    in production mode, you would probably launch one standalone instance or some
    instances of Mongo deployed as a sharded cluster, and connect the application
    to them. For our example purposes, I'll run a single instance of MongoDB using
    Docker.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要做的。我们的微服务已经准备好启动，它在嵌入式Mongo数据库上实现了基本的API方法，执行CRUD操作。您可能已经注意到，它并不需要我们创建大量的源代码。使用Spring
    Data实现与数据库的任何交互，无论是关系型还是NoSQL，都是快速且相对容易的。无论如何，我们仍然面临着一个挑战。嵌入式数据库是一个不错的选择，但只适用于开发模式或单元测试，而不适用于生产。如果您必须在生产模式下运行您的微服务，您可能会启动一个独立的实例或一些Mongo实例作为分片集群，并将应用程序连接到它们。对于我们的示例目的，我将使用Docker运行单个MongoDB实例。
- en: If you are not familiar with Docker, you can always just install Mongo on your
    local or remote machine. For more information about Docker, you can also refer
    to [Chapter 14](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml), *Docker Support*
    where I will give you a short briefing about it. There, you will find all you
    need to begin, for example, how to install it on Windows and use basic commands.
    I will also use Docker in the examples implemented for the purposes of the next
    chapters and topics, so I think it would be useful if you have basic knowledge
    about it.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Docker不熟悉，您可以在本地或远程机器上安装Mongo。有关Docker的更多信息，您也可以参考[第14章](0756243e-39c9-4696-8d79-4175e7cf4c48.xhtml)，*Docker支持*，我将在那里给您一个简短的简介。在那里，您将找到开始所需的一切，例如如何在Windows上安装它和使用基本命令。我还将在下一章和主题的示例中使用Docker，因此我认为如果您对它有基本的了解，那将是有用的。
- en: Running the application
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Let''s start MongoDB using the Docker `run` command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Docker的`run`命令启动MongoDB：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Something that may be useful for us is the Mongo database client. Using this,
    it is possible to create a new database and add some users with credentials. If
    you have Docker installed on Windows, the default virtual machine address is `192.168.99.100`.
    The Mongo container has port `27017` exposed as a result of setting the `-p` parameter
    inside the `run` command. Well, in fact, we do not have to create the database
    because, when we provide the name while defining the client connection, it will
    automatically be created if it doesn''t exist:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们可能有用的是Mongo数据库客户端。使用这个客户端，可以创建一个新的数据库并添加一些带凭据的用户。如果您在Windows上安装了Docker，默认虚拟机地址是`192.168.99.100`。由于在`run`命令中设置了`-p`参数，Mongo容器的端口`27017`被暴露出来。实际上，我们不必创建数据库，因为当我们在定义客户端连接时提供名称时，如果不存在，它将自动创建：
- en: '![](img/6028efdc-ae01-4769-87ff-30e34816bae8.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6028efdc-ae01-4769-87ff-30e34816bae8.png)'
- en: 'Next, we should create a user for the application with sufficient authority:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该为应用程序创建一个具有足够权限的用户：
- en: '![](img/37885b34-9466-4902-89cd-0d23223f6eef.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37885b34-9466-4902-89cd-0d23223f6eef.png)'
- en: 'Finally, we should set the Mongo database connection settings and credentials
    in the `application.yml` configuration file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在`application.yml`配置文件中设置Mongo数据库连接设置和凭据：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Spring Boot has good support for multi-profile configuration. A YAML file can
    be separated into a sequence of documents using `*---*` lines, and each section
    of the document is parsed independently to a flattened map. The preceding example
    does exactly the same as a separated configuration file with `application-production.yml`.
    If you run the application without any additional options, it uses the default
    settings, which have no profile name set. If you would like to run it using production
    properties, you should set the VM argument `spring.profiles.active`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot对多配置文件有很好的支持。一个YAML文件可以使用`*---*`行分隔成一系列文档，并且文档的每个部分都被解析为一个扁平化的映射。前面的示例与使用`application-production.yml`分离的配置文件完全相同。如果您在没有任何附加选项的情况下运行应用程序，它将使用默认设置，这些默认设置没有设置配置文件名称。如果您想要使用生产属性运行它，您应该设置VM参数`spring.profiles.active`：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That''s not all. Now, the application with the active production profile failed
    to start because it tried to initialize the `embeddedMongoServer` bean. As you
    might already know, almost all of the additional solutions have auto configuration
    set in Spring Boot. It is no different in this case. We need to exclude the `EmbeddedMongoAutoConfiguration` class from
    auto configuration in the production profile:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部。现在，具有活动生产配置文件的应用程序启动失败，因为它尝试初始化`embeddedMongoServer` bean。您可能已经知道，几乎所有的附加解决方案在Spring
    Boot中都有自动配置。在这种情况下也是如此。我们需要在生产配置文件中排除`EmbeddedMongoAutoConfiguration`类的自动配置：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We might as well use the configuration class to exclude that artifact:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用配置类来排除该组件：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Of course, we could have used a more elegant solution, such as Maven profiles,
    and excluded the whole `de.flapdoodle.embed.mongo` artifact from the target build
    package. The presented solution is just one of several possibilities to solve
    the problem, but it shows the auto configuration and profile mechanisms in Spring
    Boot. Now, you can run our sample application and perform some tests using, for
    example, Swagger UI. You can also connect to the database using the Mongo client
    and check out the changes in the database. Here''s our sample project''s final
    file structure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用更加优雅的解决方案，比如Maven配置文件，并从目标构建包中排除整个`de.flapdoodle.embed.mongo`组件。所提供的解决方案只是解决问题的几种可能性之一，但它展示了Spring
    Boot中的自动配置和配置文件机制。现在，您可以运行我们的示例应用程序，并使用Swagger UI执行一些测试。您还可以使用Mongo客户端连接到数据库，并查看数据库中的更改。这是我们示例项目的最终文件结构：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The example application is complete. These are all Spring Boot features I would
    like to show you in this chapter. I have focused on those that are especially
    useful for creating REST-based services.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 示例应用程序已经完成。这些都是我想在本章中向您展示的Spring Boot功能。我专注于那些特别适用于创建基于REST的服务的功能。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I have guided you through the process of single-microservice development, from
    a really basic example to a more advanced, production-ready Spring Boot application.
    I have described how to use starters to enable additional features for the project; use
    the Spring Web library to implement services that expose REST API methods; and
    then we moved on to customizing the service configuration using properties and
    YAML files. We also saw how to document and provide specifications for exposed
    REST endpoints. Next, we configured health checks and monitoring features. We
    used Spring Boot profiles to adapt the application to run in different modes and,
    finally, we used ORM features for interacting with embedded and remote NoSQL databases.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经引导您完成了从一个非常基本的示例到一个更高级的、适用于生产的Spring Boot应用程序的单一微服务开发过程。我已经描述了如何使用启动器为项目启用附加功能；使用Spring
    Web库来实现暴露REST API方法的服务；然后我们继续使用属性和YAML文件来自定义服务配置。我们还看到了如何为暴露的REST端点编写文档并提供规范。接下来，我们配置了健康检查和监控功能。我们使用Spring
    Boot配置文件来使应用程序适应不同模式运行，最后，我们使用ORM功能与嵌入式和远程NoSQL数据库进行交互。
- en: It's not an accident that I have not mentioned anything about Spring Cloud in
    this chapter. You just can't start using Spring Cloud projects without basic knowledge
    and experience in working with Spring Boot. Spring Cloud provides many different
    features that allow you to place your service inside a full microservice-based
    ecosystem. We will be discussing these functionalities one by one in the following
    chapters.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我没有提到Spring Cloud并非偶然。你不能在没有Spring Boot的基本知识和经验的情况下开始使用Spring Cloud项目。Spring
    Cloud提供了许多不同的功能，允许您将服务放置在完整的基于微服务的生态系统中。我们将在接下来的章节中逐一讨论这些功能。
