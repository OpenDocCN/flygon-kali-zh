["```cs\n    <ItemGroup> \n      <ProjectReference\n        Include=\"..\\MonitoringLib\\MonitoringLib.csproj\"\n\n     />\n    </ItemGroup> \n\n    ```", "```cs\n     using\n\n     System.Diagnostics; // Stopwatch\n\n    using\n\n     static\n\n     System.Console;\n    using\n\n     static\n\n     System.Diagnostics.Process; // GetCurrentProcess()\n\n    namespace\n\n     Packt.Shared\n\n    ;\n    public\n\n     static\n\n     class\n\n     Recorder\n\n    {\n      private\n\n     static\n\n     Stopwatch timer = new\n\n    ();\n      private\n\n     static\n\n     long\n\n     bytesPhysicalBefore = 0\n\n    ;\n      private\n\n     static\n\n     long\n\n     bytesVirtualBefore = 0\n\n    ;\n      public\n\n    static\n\n    void\n\n    Start\n\n    ()\n\n      {\n        // force two garbage collections to release memory that is\n\n        // no longer referenced but has not been released yet\n\n        GC.Collect();\n        GC.WaitForPendingFinalizers();\n        GC.Collect();\n        // store the current physical and virtual memory use \n\n        bytesPhysicalBefore = GetCurrentProcess().WorkingSet64; \n        bytesVirtualBefore = GetCurrentProcess().VirtualMemorySize64; \n        timer.Restart();\n      }\n      public\n\n    static\n\n    void\n\n    Stop\n\n    ()\n\n      {\n        timer.Stop();\n        long\n\n     bytesPhysicalAfter =\n          GetCurrentProcess().WorkingSet64;\n        long\n\n     bytesVirtualAfter =\n          GetCurrentProcess().VirtualMemorySize64;\n        WriteLine(\"{0:N0} physical bytes used.\"\n\n    ,\n          bytesPhysicalAfter - bytesPhysicalBefore);\n        WriteLine(\"{0:N0} virtual bytes used.\"\n\n    ,\n          bytesVirtualAfter - bytesVirtualBefore);\n        WriteLine(\"{0} time span ellapsed.\"\n\n    , timer.Elapsed);\n        WriteLine(\"{0:N0} total milliseconds ellapsed.\"\n\n    ,\n          timer.ElapsedMilliseconds);\n      }\n    } \n\n    ```", "```cs\n     using\n\n     Packt.Shared; // Recorder\n\n    using\n\n     static\n\n     System.Console;\n    WriteLine(\"Processing. Please wait...\"\n\n    );\n    Recorder.Start();\n    // simulate a process that requires some memory resources...\n\n    int\n\n    [] largeArrayOfInts = Enumerable.Range(\n      start: 1\n\n    , count: 10\n\n    _000).ToArray();\n    // ...and takes some time to complete\n\n    Thread.Sleep(new\n\n     Random().Next(5\n\n    , 10\n\n    ) * 1000\n\n    );\n    Recorder.Stop(); \n\n    ```", "```cs\n    Processing. Please wait...\n    655,360 physical bytes used.\n    536,576 virtual bytes used.\n    00:00:09.0038702 time span ellapsed.\n    9,003 total milliseconds ellapsed. \n\n    ```", "```cs\nProcessing. Please wait...\n294,912 physical bytes used.\n10,485,760 virtual bytes used.\n00:00:06.0074221 time span ellapsed.\n6,007 total milliseconds ellapsed. \n\n```", "```cs\n     int\n\n    [] numbers = Enumerable.Range(\n      start: 1\n\n    , count: 50\n\n    _000).ToArray();\n    WriteLine(\"Using string with +\"\n\n    );\n    Recorder.Start();\n    string\n\n     s = string\n\n    .Empty; // i.e. \"\"\n\n    for\n\n     (int\n\n     i = 0\n\n    ; i < numbers.Length; i++)\n    {\n      s += numbers[i] + \", \"\n\n    ;\n    }\n    Recorder.Stop();\n    WriteLine(\"Using StringBuilder\"\n\n    );\n    Recorder.Start();\n    System.Text.StringBuilder builder = new\n\n    ();\n    for\n\n     (int\n\n     i = 0\n\n    ; i < numbers.Length; i++)\n    {\n      builder.Append(numbers[i]);\n      builder.Append(\", \"\n\n    );\n    }\n    Recorder.Stop(); \n\n    ```", "```cs\n    Using string with +\n    14,883,072 physical bytes used.\n    3,609,728 virtual bytes used.\n    00:00:01.6220879 time span ellapsed.\n    1,622 total milliseconds ellapsed.\n    Using StringBuilder\n    12,288 physical bytes used.\n    0 virtual bytes used.\n    00:00:00.0006038 time span ellapsed.\n    0 total milliseconds ellapsed. \n\n    ```", "```cs\n    <ItemGroup>\n      <PackageReference Include=\"BenchmarkDotNet\"\n\n     Version=\"0.13.1\"\n\n     />\n    </ItemGroup> \n\n    ```", "```cs\n     using\n\n     BenchmarkDotNet.Running; \n\n    ```", "```cs\n     using\n\n     BenchmarkDotNet.Attributes; // [Benchmark]\n\n    public\n\n     class\n\n     StringBenchmarks\n\n    {\n      int\n\n    [] numbers;\n      public\n\n    StringBenchmarks\n\n    ()\n\n      {\n        numbers = Enumerable.Range(\n          start: 1\n\n    , count: 20\n\n    ).ToArray();\n      }\n      [Benchmark(Baseline = true)\n\n    ]\n      public\n\n    string\n\n    StringConcatenationTest\n\n    ()\n\n      {\n        string\n\n     s = string\n\n    .Empty; // e.g. \"\"\n\n        for\n\n     (int\n\n     i = 0\n\n    ; i < numbers.Length; i++)\n        {\n          s += numbers[i] + \", \"\n\n    ;\n        }\n        return\n\n     s;\n      }\n      [Benchmark\n\n    ]\n      public\n\n    string\n\n    StringBuilderTest\n\n    ()\n\n      {\n        System.Text.StringBuilder builder = new\n\n    ();\n        for\n\n     (int\n\n     i = 0\n\n    ; i < numbers.Length; i++)\n        {\n          builder.Append(numbers[i]);\n          builder.Append(\", \"\n\n    );\n        }\n        return\n\n     builder.ToString();\n      }\n    } \n\n    ```", "```cs\n    BenchmarkRunner.Run<StringBenchmarks>(); \n\n    ```", "```cs\n    // ***** BenchmarkRunner: Finish  *****\n    // * Export *\n      BenchmarkDotNet.Artifacts\\results\\StringBenchmarks-report.csv\n      BenchmarkDotNet.Artifacts\\results\\StringBenchmarks-report-github.md\n      BenchmarkDotNet.Artifacts\\results\\StringBenchmarks-report.html\n    // * Detailed results *\n    StringBenchmarks.StringConcatenationTest: DefaultJob\n    Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation\n    Mean = 412.990 ns, StdErr = 2.353 ns (0.57%), N = 46, StdDev = 15.957 ns\n    Min = 373.636 ns, Q1 = 413.341 ns, Median = 417.665 ns, Q3 = 420.775 ns, Max = 434.504 ns\n    IQR = 7.433 ns, LowerFence = 402.191 ns, UpperFence = 431.925 ns\n    ConfidenceInterval = [404.708 ns; 421.273 ns] (CI 99.9%), Margin = 8.282 ns (2.01% of Mean)\n    Skewness = -1.51, Kurtosis = 4.09, MValue = 2\n    -------------------- Histogram --------------------\n    [370.520 ns ; 382.211 ns) | @@@@@@\n    [382.211 ns ; 394.583 ns) | @\n    [394.583 ns ; 411.300 ns) | @@\n    [411.300 ns ; 422.990 ns) | @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n    [422.990 ns ; 436.095 ns) | @@@@@\n    ---------------------------------------------------\n    StringBenchmarks.StringBuilderTest: DefaultJob\n    Runtime = .NET 6.0.0 (6.0.21.37719), X64 RyuJIT; GC = Concurrent Workstation\n    Mean = 275.082 ns, StdErr = 0.558 ns (0.20%), N = 15, StdDev = 2.163 ns\n    Min = 271.059 ns, Q1 = 274.495 ns, Median = 275.403 ns, Q3 = 276.553 ns, Max = 278.030 ns\n    IQR = 2.058 ns, LowerFence = 271.409 ns, UpperFence = 279.639 ns\n    ConfidenceInterval = [272.770 ns; 277.394 ns] (CI 99.9%), Margin = 2.312 ns (0.84% of Mean)\n    Skewness = -0.69, Kurtosis = 2.2, MValue = 2\n    -------------------- Histogram --------------------\n    [269.908 ns ; 278.682 ns) | @@@@@@@@@@@@@@@\n    ---------------------------------------------------\n    // * Summary *\n    BenchmarkDotNet=v0.13.1, OS=Windows 10.0.19043.1165 (21H1/May2021Update)\n    11th Gen Intel Core i7-1165G7 2.80GHz, 1 CPU, 8 logical and 4 physical cores\n    .NET SDK=6.0.100\n      [Host]     : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT\n      DefaultJob : .NET 6.0.0 (6.0.21.37719), X64 RyuJIT\n    |                  Method |     Mean |   Error |   StdDev | Ratio | RatioSD |\n    |------------------------ |---------:|--------:|---------:|------:|--------:|\n    | StringConcatenationTest | 413.0 ns | 8.28 ns | 15.96 ns |  1.00 |    0.00 |\n    |       StringBuilderTest | 275.1 ns | 2.31 ns |  2.16 ns |  0.69 |    0.04 |\n    // * Hints *\n    Outliers\n      StringBenchmarks.StringConcatenationTest: Default -> 7 outliers were removed, 14 outliers were detected (376.78 ns..391.88 ns, 440.79 ns..506.41 ns)\n      StringBenchmarks.StringBuilderTest: Default       -> 2 outliers were detected (274.68 ns, 274.69 ns)\n    // * Legends *\n      Mean    : Arithmetic mean of all measurements\n      Error   : Half of 99.9% confidence interval\n      StdDev  : Standard deviation of all measurements\n      Ratio   : Mean of the ratio distribution ([Current]/[Baseline])\n      RatioSD : Standard deviation of the ratio distribution ([Current]/[Baseline])\n      1 ns    : 1 Nanosecond (0.000000001 sec)\n    // ***** BenchmarkRunner: End *****\n    // ** Remained 0 benchmark(s) to run **\n    Run time: 00:01:13 (73.35 sec), executed benchmarks: 2\n    Global total time: 00:01:29 (89.71 sec), executed benchmarks: 2\n    // * Artifacts cleanup * \n\n    ```", "```cs\n     using\n\n     System.Diagnostics; // Stopwatch\n\n    using\n\n     static\n\n     System.Console; \n\n    ```", "```cs\n     static\n\n    void\n\n    OutputThreadInfo\n\n    ()\n\n    {\n      Thread t = Thread.CurrentThread;\n      WriteLine(\n        \"Thread Id: {0}, Priority: {1}, Background: {2}, Name: {3}\"\n\n    ,\n        t.ManagedThreadId, t.Priority,\n        t.IsBackground, t.Name ?? \"null\"\n\n    );\n    } \n\n    ```", "```cs\n     static\n\n    void\n\n    MethodA\n\n    ()\n\n    {\n      WriteLine(\"Starting Method A...\"\n\n    );\n      OutputThreadInfo();\n      Thread.Sleep(3000\n\n    ); // simulate three seconds of work\n\n      WriteLine(\"Finished Method A.\"\n\n    );\n    }\n    static\n\n    void\n\n    MethodB\n\n    ()\n\n    {\n      WriteLine(\"Starting Method B...\"\n\n    );\n      OutputThreadInfo();\n      Thread.Sleep(2000\n\n    ); // simulate two seconds of work\n\n      WriteLine(\"Finished Method B.\"\n\n    );\n    }\n    static\n\n    void\n\n    MethodC\n\n    ()\n\n    {\n      WriteLine(\"Starting Method C...\"\n\n    );\n      OutputThreadInfo();\n      Thread.Sleep(1000\n\n    ); // simulate one second of work\n\n      WriteLine(\"Finished Method C.\"\n\n    );\n    } \n\n    ```", "```cs\n    OutputThreadInfo();\n    Stopwatch timer = Stopwatch.StartNew();\n    WriteLine(\"Running methods synchronously on one thread.\"\n\n    ); \n    MethodA();\n    MethodB();\n    MethodC();\n    WriteLine($\"\n\n    {timer.ElapsedMilliseconds:#,##\n\n    0\n\n    }\n\n    ms elapsed.\"\n\n    ); \n\n    ```", "```cs\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Running methods synchronously on one thread.\n    Starting Method A...\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Finished Method A.\n    Starting Method B...\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Finished Method B.\n    Starting Method C...\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Finished Method C.\n    6,017ms elapsed. \n\n    ```", "```cs\n    OutputThreadInfo();\n    Stopwatch timer = Stopwatch.StartNew();\n\n    **/***\n\n    WriteLine(\"Running methods synchronously on one thread.\");\n\n    MethodA();\n\n    MethodB();\n\n    MethodC();\n\n    ***/**\n\n    **WriteLine(**\n\n    **\"Running methods asynchronously on multiple threads.\"**\n\n    **);** \n\n    **Task taskA =** \n\n    **new**\n\n    **(MethodA);**\n\n    **taskA.Start();**\n\n    **Task taskB = Task.Factory.StartNew(MethodB);** \n\n    **Task taskC = Task.Run(MethodC);**\n\n    WriteLine($\"\n\n    {timer.ElapsedMilliseconds:#,##\n\n    0\n\n    }\n\n    ms elapsed.\"\n\n    ); \n\n    ```", "```cs\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Running methods asynchronously on multiple threads.\n    Starting Method A...\n    Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Starting Method C...\n    Thread Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Starting Method B...\n    Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    6ms elapsed. \n\n    ```", "```cs\n    Task[] tasks = { taskA, taskB, taskC };\n    Task.WaitAll(tasks); \n\n    ```", "```cs\n    Id: 1, Priority: Normal, Background: False, Name: null\n    Running methods asynchronously on multiple threads.\n    Starting Method A...\n    Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Starting Method B...\n    Id: 7, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Starting Method C...\n    Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Finished Method C.\n    Finished Method B.\n    Finished Method A.\n    3,013ms elapsed. \n\n    ```", "```cs\n     static\n\n    decimal\n\n    CallWebService\n\n    ()\n\n    {\n      WriteLine(\"Starting call to web service...\"\n\n    );\n      OutputThreadInfo();\n      Thread.Sleep((new\n\n     Random()).Next(2000\n\n    , 4000\n\n    ));\n      WriteLine(\"Finished call to web service.\"\n\n    );\n      return\n\n     89.99\n\n    M;\n    }\n    static\n\n    string\n\n    CallStoredProcedure\n\n    (\n\n    decimal\n\n     amount\n\n    )\n\n    {\n      WriteLine(\"Starting call to stored procedure...\"\n\n    );\n      OutputThreadInfo();\n      Thread.Sleep((new\n\n     Random()).Next(2000\n\n    , 4000\n\n    ));\n      WriteLine(\"Finished call to stored procedure.\"\n\n    );\n      return\n\n     $\"12 products cost more than \n\n    {amount:C}\n\n    .\"\n\n    ;\n    } \n\n    ```", "```cs\n    WriteLine(\"Passing the result of one task as an input into another.\"\n\n    ); \n    Task<string\n\n    > taskServiceThenSProc = Task.Factory\n      .StartNew(CallWebService) // returns Task<decimal>\n\n      .ContinueWith(previousTask => // returns Task<string>\n\n        CallStoredProcedure(previousTask.Result));\n    WriteLine($\"Result: \n\n    {taskServiceThenSProc.Result}\n\n    \"\n\n    ); \n\n    ```", "```cs\n    Thread Id: 1, Priority: Normal, Background: False, Name: null\n    Passing the result of one task as an input into another.\n    Starting call to web service...\n    Thread Id: 4, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Finished call to web service.\n    Starting call to stored procedure...\n    Thread Id: 6, Priority: Normal, Background: True, Name: .NET ThreadPool Worker\n    Finished call to stored procedure.\n    Result: 12 products cost more than \u00a389.99.\n    5,463ms elapsed. \n\n    ```", "```cs\n     static\n\n    void\n\n    OuterMethod\n\n    ()\n\n    {\n      WriteLine(\"Outer method starting...\"\n\n    );\n      Task innerTask = Task.Factory.StartNew(InnerMethod);\n      WriteLine(\"Outer method finished.\"\n\n    );\n    }\n    static\n\n    void\n\n    InnerMethod\n\n    ()\n\n    {\n      WriteLine(\"Inner method starting...\"\n\n    );\n      Thread.Sleep(2000\n\n    );\n      WriteLine(\"Inner method finished.\"\n\n    );\n    } \n\n    ```", "```cs\n    Task outerTask = Task.Factory.StartNew(OuterMethod);\n    outerTask.Wait();\n    WriteLine(\"Console app is stopping.\"\n\n    ); \n\n    ```", "```cs\n    Outer method starting...\n    Inner method starting...\n    Outer method finished.\n    Console app is stopping. \n\n    ```", "```cs\n    Task innerTask = Task.Factory.StartNew(InnerMethod,\n\n    **TaskCreationOptions.AttachedToParent**\n\n    ); \n\n    ```", "```cs\n    Outer method starting...\n    Inner method starting...\n    Outer method finished.\n    Inner method finished.\n    Console app is stopping. \n\n    ```", "```cs\n using\n\n System.Text.RegularExpressions;\nnamespace\n\n Packt.Shared\n\n;\npublic\n\n static\n\n class\n\n StringExtensions\n\n{\n  public\n\nstatic\n\n Task<\n\nbool\n\n> \n\nIsValidXmlTagAsync\n\n(\n\nthis\n\nstring\n\n input\n\n)\n\n  {\n    if\n\n (input == null\n\n)\n    {\n      return\n\n Task.FromException<bool\n\n>(\n        new\n\n ArgumentNullException(\"Missing input parameter\"\n\n));\n    }\n    if\n\n (input.Length == 0\n\n)\n    {\n      return\n\n Task.FromException<bool\n\n>(\n        new\n\n ArgumentException(\"input parameter is empty.\"\n\n));\n    }\n    return\n\n Task.FromResult(Regex.IsMatch(input,\n      @\"^<([a-z]+)([^<]+)*(?:>(.*)<\\/\\1>|\\s+\\/>)$\"\n\n));\n  }\n  // other methods\n\n} \n\n```", "```cs\n public\n\n Task \n\nDeleteCustomerAsync\n\n()\n\n{\n  // ...\n\n  return\n\n Task.CompletedTask;\n} \n\n```", "```cs\n     static\n\n    void\n\n    MethodA\n\n    ()\n\n    {\n      for\n\n     (int\n\n     i = 0\n\n    ; i < 5\n\n    ; i++)\n      {\n        Thread.Sleep(SharedObjects.Random.Next(2000\n\n    ));\n        SharedObjects.Message += \"A\"\n\n    ;\n        Write(\".\"\n\n    );\n      }\n    }\n    static\n\n    void\n\n    MethodB\n\n    ()\n\n    {\n      for\n\n     (int\n\n     i = 0\n\n    ; i < 5\n\n    ; i++)\n      {\n        Thread.Sleep(SharedObjects.Random.Next(2000\n\n    ));\n        SharedObjects.Message += \"B\"\n\n    ;\n        Write(\".\"\n\n    );\n      }\n    }\n    static\n\n     class\n\n     SharedObjects\n\n    {\n      public\n\n     static\n\n     Random Random = new\n\n    ();\n      public\n\n     static\n\n     string\n\n    ? Message; // a shared resource\n\n    } \n\n    ```", "```cs\n    WriteLine(\"Please wait for the tasks to complete.\"\n\n    );\n    Stopwatch watch = Stopwatch.StartNew();\n    Task a = Task.Factory.StartNew(MethodA);\n    Task b = Task.Factory.StartNew(MethodB);\n\n    Task.WaitAll(new\n\n     Task[] { a, b });\n    WriteLine();\n    WriteLine($\"Results: \n\n    {SharedObjects.Message}\n\n    .\"\n\n    );\n    WriteLine($\"\n\n    {watch.ElapsedMilliseconds:N0}\n\n     elapsed milliseconds.\"\n\n    ); \n\n    ```", "```cs\n    Please wait for the tasks to complete.\n    ..........\n    Results: BABABAABBA.\n    5,753 elapsed milliseconds. \n\n    ```", "```cs\n     public\n\n     static\n\n     object\n\n     Conch = new\n\n    (); \n\n    ```", "```cs\n     **lock**\n\n     **(SharedObjects.Conch)**\n\n    **{**\n\n      for\n\n     (int\n\n     i = 0\n\n    ; i < 5\n\n    ; i++)\n      {\n        Thread.Sleep(SharedObjects.Random.Next(2000\n\n    ));\n        SharedObjects.Message += \"A\"\n\n    ;\n        Write(\".\"\n\n    );\n      }\n\n    **}** \n\n    ```", "```cs\n    Please wait for the tasks to complete.\n    ..........\n    Results: BBBBBAAAAA.\n    10,345 elapsed milliseconds. \n\n    ```", "```cs\n lock\n\n (SharedObjects.Conch)\n{\n  // work with shared resource\n\n} \n\n```", "```cs\n try\n\n{\n  Monitor.Enter(SharedObjects.Conch);\n  // work with shared resource\n\n}\nfinally\n\n{\n  Monitor.Exit(SharedObjects.Conch);\n} \n\n```", "```cs\n     **try**\n\n    **{**\n\n    **if**\n\n     **(Monitor.TryEnter(SharedObjects.Conch, TimeSpan.FromSeconds(**\n\n    **15**\n\n    **)))**\n\n      {\n        for\n\n     (int\n\n     i = 0\n\n    ; i < 5\n\n    ; i++)\n        {\n          Thread.Sleep(SharedObjects.Random.Next(2000\n\n    ));\n          SharedObjects.Message += \"A\"\n\n    ;\n          Write(\".\"\n\n    );\n        }\n      }\n\n    **else**\n\n     **{**\n\n     **WriteLine(**\n\n    **\"Method A timed out when entering a monitor on conch.\"**\n\n    **);**\n\n     **}**\n\n    **}**\n\n    **finally**\n\n    **{**\n\n     **Monitor.Exit(SharedObjects.Conch);**\n\n    **}** \n\n    ```", "```cs\n // event delegate field\n\npublic\n\n event\n\n EventHandler Shout;\n// conch\n\nprivate\n\n object\n\n eventLock = new\n\n();\n// method\n\npublic\n\nvoid\n\nPoke\n\n()\n\n{\n  lock\n\n (eventLock) // bad idea\n\n  {\n    // if something is listening...\n\n    if\n\n (Shout != null\n\n)\n    {\n      // ...then call the delegate to raise the event\n\n      Shout(this\n\n, EventArgs.Empty);\n    }\n  }\n} \n\n```", "```cs\n int\n\n x = 3\n\n;\nx++; // is this an atomic CPU operation? \n\n```", "```cs\n     public\n\n     static\n\n     int\n\n     Counter; // another shared resource \n\n    ```", "```cs\n    Interlocked.Increment(ref\n\n     SharedObjects.Counter); \n\n    ```", "```cs\n    WriteLine($\"\n\n    {SharedObjects.Counter}\n\n     string modifications.\"\n\n    ); \n\n    ```", "```cs\n    Please wait for the tasks to complete.\n    ..........\n    Results: BBBBBAAAAA.\n    13,531 elapsed milliseconds.\n\n    **10 string modifications.** \n\n    ```", "```cs\n     using\n\n     static\n\n     System.Console; \n\n    ```", "```cs\n    HttpClient client = new\n\n    ();\n    HttpResponseMessage response =\n      await\n\n     client.GetAsync(\"http://www.apple.com/\"\n\n    );\n    WriteLine(\"Apple's home page has {0:N0} bytes.\"\n\n    ,\n      response.Content.Headers.ContentLength); \n\n    ```", "```cs\n    Program.cs(14,9): error CS4033: The 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'. [/Users/markjprice/Code/ Chapter12/AsyncConsole/AsyncConsole.csproj] \n\n    ```", "```cs\n    Apple's home page has 40,252 bytes. \n\n    ```", "```cs\n    <Project Sdk=\"Microsoft.NET.Sdk\"\n\n    >\n      <PropertyGroup>\n        <OutputType>WinExe</OutputType>\n        <TargetFramework>net6.0\n\n    -windows</TargetFramework>\n        <Nullable>enable</Nullable>\n        <UseWPF>true\n\n    </UseWPF>\n      </PropertyGroup>\n\n     **<ItemGroup>**\n\n     **<PackageReference Include=**\n\n    **\"Microsoft.Data.SqlClient\"**\n\n     **Version=**\n\n    **\"3.0.0\"**\n\n     **/>**\n\n     **</ItemGroup>**\n\n    </Project> \n\n    ```", "```cs\n     <\n\n    Grid\n\n    >\n\n    **<**\n\n    **StackPanel**\n\n    **>**\n\n    **<**\n\n    **Button**\n\n    **Name**\n\n    **=**\n\n    **\"GetEmployeesSyncButton\"**\n\n    **Click**\n\n    **=**\n\n    **\"GetEmployeesSyncButton_Click\"**\n\n    **>**\n\n     **Get Employees Synchronously**\n\n    **</**\n\n    **Button**\n\n    **>**\n\n    **<**\n\n    **Button**\n\n    **Name**\n\n    **=**\n\n    **\"GetEmployeesAsyncButton\"**\n\n    **Click**\n\n    **=**\n\n    **\"GetEmployeesAsyncButton_Click\"**\n\n    **>**\n\n     **Get Employees Asynchronously**\n\n    **</**\n\n    **Button**\n\n    **>**\n\n    **<**\n\n    **TextBox**\n\n    **HorizontalAlignment**\n\n    **=**\n\n    **\"Stretch\"**\n\n    **Text**\n\n    **=**\n\n    **\"Type in here\"**\n\n     **/>**\n\n    **<**\n\n    **ListBox**\n\n    **Name**\n\n    **=**\n\n    **\"EmployeesListBox\"**\n\n    **Height**\n\n    **=**\n\n    **\"400\"**\n\n     **/>**\n\n    **</**\n\n    **StackPanel**\n\n    **>**\n\n    </\n\n    Grid\n\n    > \n\n    ```", "```cs\n     private\n\n     const\n\n     string\n\n     connectionString = \n      \"Data Source=.;\"\n\n     +\n      \"Initial Catalog=Northwind;\"\n\n     +\n      \"Integrated Security=true;\"\n\n     +\n      \"MultipleActiveResultSets=true;\"\n\n    ;\n    private\n\n     const\n\n     string\n\n     sql =\n      \"WAITFOR DELAY '00:00:05';\"\n\n     +\n      \"SELECT EmployeeId, FirstName, LastName FROM Employees\"\n\n    ;\n    private\n\n    void\n\n    GetEmployeesSyncButton_Click\n\n    (\n\n    object\n\n     sender, RoutedEventArgs e\n\n    )\n\n    {\n      Stopwatch timer = Stopwatch.StartNew();\n      using\n\n     (SqlConnection connection = new\n\n    (connectionString))\n      {\n        connection.Open();\n        SqlCommand command = new\n\n    (sql, connection);\n        SqlDataReader reader = command.ExecuteReader();\n        while\n\n     (reader.Read())\n        {\n          string\n\n     employee = string\n\n    .Format(\"{0}: {1} {2}\"\n\n    ,\n            reader.GetInt32(0\n\n    ), reader.GetString(1\n\n    ), reader.GetString(2\n\n    ));\n          EmployeesListBox.Items.Add(employee);\n        }\n        reader.Close();\n        connection.Close();\n      }\n      EmployeesListBox.Items.Add($\"Sync: \n\n    {timer.ElapsedMilliseconds:N0}\n\n    ms\"\n\n    );\n    }\n    private\n\n    async\n\n    void\n\n    GetEmployeesAsyncButton_Click\n\n    (\n\n    object\n\n     sender, RoutedEventArgs e\n\n    )\n\n    {\n      Stopwatch timer = Stopwatch.StartNew();\n      using\n\n     (SqlConnection connection = new\n\n    (connectionString))\n      {\n        await\n\n     connection.OpenAsync();\n        SqlCommand command = new\n\n    (sql, connection);\n        SqlDataReader reader = await\n\n     command.ExecuteReaderAsync();\n        while\n\n     (await\n\n     reader.ReadAsync())\n        {\n          string\n\n     employee = string\n\n    .Format(\"{0}: {1} {2}\"\n\n    ,\n            await\n\n     reader.GetFieldValueAsync<int\n\n    >(0\n\n    ), \n            await\n\n     reader.GetFieldValueAsync<string\n\n    >(1\n\n    ), \n            await\n\n     reader.GetFieldValueAsync<string\n\n    >(2\n\n    ));\n          EmployeesListBox.Items.Add(employee);\n        }\n        await\n\n     reader.CloseAsync();\n        await\n\n     connection.CloseAsync();\n      }\n      EmployeesListBox.Items.Add($\"Async: \n\n    {timer.ElapsedMilliseconds:N0}\n\n    ms\"\n\n    );\n    } \n\n    ```", "```cs\n     using\n\n     static\n\n     System.Console; // WriteLine() \n\n    ```", "```cs\n     async\n\n    static\n\n     IAsyncEnumerable<\n\n    int\n\n    > \n\n    GetNumbersAsync\n\n    ()\n\n    {\n      Random r = new\n\n    ();\n      // simulate work\n\n      await\n\n     Task.Delay(r.Next(1500\n\n    , 3000\n\n    ));\n      yield\n\n     return\n\n     r.Next(0\n\n    , 1001\n\n    );\n      await\n\n     Task.Delay(r.Next(1500\n\n    , 3000\n\n    ));\n      yield\n\n     return\n\n     r.Next(0\n\n    , 1001\n\n    );\n      await\n\n     Task.Delay(r.Next(1500\n\n    , 3000\n\n    ));\n      yield\n\n     return\n\n     r.Next(0\n\n    , 1001\n\n    );\n    } \n\n    ```", "```cs\n     await\n\n     foreach\n\n     (int\n\n     number \n\n    in\n\n    GetNumbersAsync\n\n    ())\n\n    {\n      WriteLine($\"Number: \n\n    {number}\n\n    \"\n\n    );\n    } \n\n    ```", "```cs\n    Number: 509\n    Number: 813\n    Number: 307 \n\n    ```"]