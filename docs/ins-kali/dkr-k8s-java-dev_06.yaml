- en: Running Containers with Java Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java应用程序运行容器
- en: 'In [Chapter 5](text00084.html) , *Creating Images with Java Applications* ,
    we learned about the structure of a Dockerfile and how to build our images. At
    this point, you should be able to create your own Docker image and start using
    it. Actually, we did run the containers several times, but without getting much
    into details. We built the image manually, using a Dockerfile, and then issuing
    a `docker build` command. We have also been using Maven to automate the build
    process. The image we have created contains our simple REST Java service. We''ve
    already been running it for the purpose of checking if it really works. This time,
    however, we are going into some more detail about running the containers from
    our images. This chapter will include the following concepts:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](text00084.html) *使用Java应用程序创建镜像*中，我们学习了Dockerfile的结构以及如何构建我们的镜像。在这一点上，您应该能够创建自己的Docker镜像并开始使用它。实际上，我们已经多次运行了容器，但没有深入细节。我们手动构建了镜像，使用Dockerfile，然后发出了`docker
    build`命令。我们还使用Maven来自动化构建过程。我们创建的镜像包含了我们简单的REST Java服务。我们已经运行它来检查它是否真的有效。然而，这一次，我们将更详细地讨论从我们的镜像运行容器的一些细节。本章将包括以下概念：
- en: Starting and stopping containers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: Container running modes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器运行模式
- en: Monitoring containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控容器
- en: Container restart policies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器重启策略
- en: Runtime constraints on resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的运行时约束
- en: Running containers using Maven
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Maven运行容器
- en: Starting and stopping containers
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: 'Let''s go back a little and begin with the basics: how to run and stop the
    Docker container manually, from the shell or the command line.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到一点，从基础知识开始：如何手动从shell或命令行运行和停止Docker容器。
- en: Starting
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: As you have seen in the previous chapters, to spin-up the container from the
    image, we use the `docker run` command. The running container will have its own
    file system, networking stack, and isolated process tree separate from the host.
    As you will remember from [Chapter 5](text00084.html) , *Creating Images with
    Java Applications* , every single `docker run` command creates a new container
    and executes a command specified in the Dockerfile, `CMD` , or `ENTRYPOINT` .
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前几章中看到的那样，要从镜像中启动容器，我们使用`docker run`命令。运行的容器将有自己的文件系统、网络堆栈和与主机分开的隔离进程树。正如您在[第5章](text00084.html)
    *使用Java应用程序创建镜像*中所记得的，每个`docker run`命令都会创建一个新的容器，并执行Dockerfile、`CMD`或`ENTRYPOINT`中指定的命令。
- en: 'The syntax of the `docker run` command is as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令的语法如下：'
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The command takes the image name, with the optional `TAG` or `DIGEST` . If you
    skip the `TAG` and `DIGEST` command parameters, Docker will run the container
    based on the image tagged `latest` . The `docker run` command also takes a set
    of possible options you may find useful, such as the runtime mode, detached or
    foreground, network settings, or runtime restrictions on CPU and memory. We are
    going to cover these later in this chapter. Of course, you can execute the `docker
    run` command without almost any arguments except the image name. It will run and
    take the default options defined in the image. Specifying options gives you the
    chance to override the options specified by the author of the image and also runtime
    defaults of the Docker engine.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令使用镜像名称，可选的`TAG`或`DIGEST`。如果跳过`TAG`和`DIGEST`命令参数，Docker将基于标记为`latest`的镜像运行容器。`docker
    run`命令还接受一组可能有用的选项，例如运行时模式、分离或前台、网络设置或CPU和内存的运行时限制。我们将在本章后面介绍这些内容。当然，您可以执行`docker
    run`命令，几乎没有任何参数，除了镜像名称。它将运行并采用镜像中定义的默认选项。指定选项可以让您覆盖图像作者指定的选项以及Docker引擎的运行时默认值。
- en: The `COMMAND` parameter is not mandatory, the author of the image may have already
    provided a default `COMMAND` using the `CMD` instruction in the `Dockerfile` .
    The `CMD` occurs only once in a Dockerfile and it's usually the last instruction.
    When starting the container from an image, we can override the `CMD` instruction,
    simply by providing our own command or parameters as the `COMMAND` parameter for
    the `docker run` . Anything that appears after the image name in the `docker run`
    command will be passed to the container and treated as `CMD` arguments. If the
    image also specifies an `ENTRYPOINT` then the `CMD` or `COMMAND` gets appended
    as an argument to the `ENTRYPOINT` . But guess what, we can override the `ENTRYPOINT`
    as well, using the `--entrypoint` option for the `docker run` command.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`COMMAND`参数不是必需的，镜像的作者可能已经在`Dockerfile`中使用`CMD`指令提供了默认的`COMMAND`。`CMD`在Dockerfile中只出现一次，通常是最后一条指令。从镜像启动容器时，我们可以通过提供自己的命令或参数作为`docker
    run`的`COMMAND`参数来覆盖`CMD`指令。在`docker run`命令中出现在镜像名称之后的任何内容都将传递给容器，并被视为`CMD`参数。如果镜像还指定了`ENTRYPOINT`，那么`CMD`或`COMMAND`将作为参数附加到`ENTRYPOINT`。但是猜猜，我们也可以使用`docker
    run`命令的`--entrypoint`选项来覆盖`ENTRYPOINT`。'
- en: Stopping
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止
- en: 'To stop one or more running Docker containers we use the `docker stop` command.
    The syntax is simple:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止一个或多个正在运行的Docker容器，我们使用`docker stop`命令。语法很简单：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can specify one or more container to stop. The only option for `docker
    stop` is `-t` (`--time` ) which allows us to specify a time to wait before stopping
    a container. 10 seconds is the default value, which is supposed to be enough for
    the container to gracefully stop. To stop the container in a more brutal way,
    you can execute the following command:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以指定一个或多个要停止的容器。`docker stop`的唯一选项是`-t`（`--time`），它允许我们指定在停止容器之前等待的时间。默认值为10秒，应该足够容器优雅地停止。要以更加残酷的方式停止容器，可以执行以下命令：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'What''s the difference between `docker stop` and `docker kill` ? They will
    both stop a running container. There''s an important difference though:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker stop`和`docker kill`之间有什么区别？它们都会停止正在运行的容器。但有一个重要的区别：'
- en: '`docker stop` : The main process inside the container will first receive a
    `SIGTERM` , and after a grace period, a `SIGKILL`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stop`：容器内的主进程首先会收到`SIGTERM`，然后经过一个宽限期，会收到`SIGKILL`'
- en: '`docker kill` : The main process inside the container will be sent `SIGKILL`
    (by default) or any signal specified with option `--signal`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker kill`：容器内的主进程将被发送`SIGKILL`（默认）或使用`--signal`选项指定的任何信号'
- en: In other words, `docker stop` attempts to trigger a graceful shutdown by sending
    the standard POSIX signal `SIGTERM` , whereas `docker kill` just brutally kills
    the process and, therefore, shuts down the container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`docker stop`尝试通过发送标准的POSIX信号`SIGTERM`来触发优雅的关闭，而`docker kill`只是残酷地杀死进程，因此关闭容器。
- en: Listing the running containers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出正在运行的容器
- en: 'To list the running containers, simply execute the `docker ps` command:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出正在运行的容器，只需执行`docker ps`命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To include all containers present on your Docker host, include the `-a` option:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要包括Docker主机上存在的所有容器，请包括`-a`选项：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also filter the list using `-f` option to specify a filter. The filter
    needs to be provided as a `key=value` format. Currently available filters include:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-f`选项过滤列表以指定过滤器。过滤器需要以`key=value`格式提供。当前可用的过滤器包括：
- en: '`id` : Filters by the container''s id'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`：按容器的id筛选'
- en: '`label` : Filters by label'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`：按标签筛选'
- en: '`name` : Filters by the container''s name'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：按容器的名称筛选'
- en: '`exited` : Filters by the container''s exit code'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`退出`：按容器的退出代码筛选'
- en: '`status` : Filters by status, which can be created, restarting, running, removing,
    paused, exited or dead'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`状态`：按状态筛选，可以是created、restarting、running、removing、paused、exited或dead'
- en: '`volume` : When specified with volume name or mount point will include containers
    that mount specified volumes'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：当指定卷名称或挂载点时，将包括挂载指定卷的容器'
- en: '`network` : When specified with network id or name, will include containers
    connected to the specified network'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network`：当指定网络ID或名称时，将包括连接到指定网络的容器'
- en: 'Consider the following example, which will take all containers present on the
    Docker host and filter them out by running status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例，它将获取Docker主机上的所有容器，并通过运行状态进行筛选：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Removing the containers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'To remove the container from the host, we use the `docker rm` command. The
    syntax is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要从主机中删除容器，我们使用`docker rm`命令。语法如下：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can specify a single container or more containers at once. If you are running
    short-term foreground processes over and over many times, these file systems can
    grow rapidly in size. There''s a solution for that: instead of cleaning manually
    by hand, tell Docker to automatically clean up the container and remove the file
    system when the container exits. You do this by adding the `--rm` flag, so that
    the container data is removed automatically after the process has finished.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以一次指定一个或多个容器。如果您一遍又一遍地运行短期前台进程，这些文件系统的大小可能会迅速增长。有一个解决方案：不要手动清理，告诉Docker在容器退出时自动清理容器并删除文件系统。您可以通过添加`--rm`标志来实现这一点，这样在进程完成后容器数据会被自动删除。
- en: '`--rm` flag will make Docker remove container after it has been shut down.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`--rm`标志将使Docker在容器关闭后删除容器。'
- en: 'For example, use the `run` command as in the following example:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下示例中的`run`命令：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding command tells Docker to remove the container if it's shut down.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令告诉Docker在关闭容器时将其删除。
- en: When starting a Docker container, you can decide if you want to run the container
    in the default mode, in the foreground, or in the background, in the so called
    detached mode. Let's explain what the difference is.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动Docker容器时，您可以决定是以默认模式、前台模式还是后台模式（即分离模式）运行容器。让我们解释一下它们之间的区别。
- en: Container running modes
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器运行模式
- en: Docker has two container running modes, foreground and detached. Let's begin
    with the default one, the foreground mode.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有两种容器运行模式，前台和分离。让我们从默认模式，即前台模式开始。
- en: Foreground
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前台
- en: 'In the foreground mode, the console you are using to execute `docker run` will
    be attached to standard input, output, and error streams. This is the default;
    Docker will attach `STDIN` , `STDOUT` and `STDERR` streams to your shell console.
    If you need to, you can change this behavior and use the `-a` switch for the `docker
    run` command. As a parameter for the `-a` switch, you use the name of the stream
    you want to attach to the console. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前台模式下，您用来执行`docker run`的控制台将附加到标准输入、输出和错误流。这是默认行为；Docker将`STDIN`、`STDOUT`和`STDERR`流附加到您的shell控制台。如果需要，您可以更改此行为，并为`docker
    run`命令使用`-a`开关。作为`-a`开关的参数，您使用要附加到控制台的流的名称。例如：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding command will attach both `stdin` and `stdout` streams to your
    console.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将把`stdin`和`stdout`流附加到您的控制台。
- en: 'The useful `docker run` options are the `-i` or `--interactive` (for keeping
    `STDIN` stream open, even if not attached) and `-t` or `-tty` (for attaching a
    `pseudo-tty` ) switches, commonly used together as `-it` which you will need to
    use to allocate a `pseudo-tty` console for the process running in the container.
    Actually, we used this option in [Chapter 5](text00084.html) , *Creating Images
    with Java Applications* , when we were running our REST service:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的`docker run`选项是`-i`或`--interactive`（用于保持`STDIN`流开放，即使未附加）和`-t`或`-tty`（用于附加`伪tty`）开关，通常一起使用为`-it`，您需要使用它为在容器中运行的进程分配`伪tty`控制台。实际上，我们在[第5章](text00084.html)中使用了这个选项，*使用Java应用程序创建镜像*，当我们运行我们的REST服务时。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Simply speaking, the `-it` is used combined to attach the command line to the
    container after it has started. This way you can see what's going on in the running
    container in your shell console and interact with the container, if needed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说，`-it`用于在容器启动后将命令行附加到容器。这样，您可以在shell控制台中查看正在运行的容器的情况，并在需要时与容器交互。
- en: Detached
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离
- en: 'You can start a Docker container in detached mode with a `-d` option. It''s
    the opposite of the foreground mode. The container starts up and runs in background,
    the same as a daemon or a service. Let''s try to run our rest-example in the background,
    executing the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`-d`选项以分离模式启动Docker容器。这是前台模式的相反。容器启动并在后台运行，就像守护进程或服务一样。让我们尝试在后台运行我们的rest-example，执行以下命令：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After the container starts, you will be given a control and can use a shell
    or command line for executing other commands. Docker will just output the container
    ID, as you can see on the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，您将获得控制权，并可以使用shell或命令行执行其他命令。Docker将只输出容器ID，如下面的屏幕截图所示：
- en: '![](Image00074.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00074.jpg)'
- en: 'You can use the container ID to reference the container in other docker commands,
    for example, if you need to stop the container or attach to it. Our service, while
    sitting in the background, still works: the Spring Boot application listens on
    port `8080` for `HTTP` `GET` or `POST` requests. Take note that containers started
    in detached mode stop when the root process used to run the container exits. Understanding
    this is important, even if you have some process running in the background (started
    from the instruction in the Dockerfile), Docker will stop the container if the
    command that started the container finishes. In our case, Spring Boot application
    is running and listening, and, at the same time, prevents Docker from shutting
    down the container. To bring the container back from the background into the foreground
    of your console, you will need to attach to it.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用容器ID在其他docker命令中引用容器，例如，如果您需要停止容器或附加到容器。我们的服务虽然在后台运行，但仍在工作：Spring Boot应用程序在端口`8080`上监听`HTTP`
    `GET`或`POST`请求。请注意，以分离模式启动的容器会在用于运行容器的根进程退出时停止。了解这一点很重要，即使您有一些在后台运行的进程（从Dockerfile中的指令启动），Docker也会在启动容器的命令完成时停止容器。在我们的情况下，Spring
    Boot应用程序正在运行和监听，并且同时防止Docker关闭容器。要将容器从后台带回到控制台的前台，您需要附加到它。
- en: Attaching to running containers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加到运行的容器
- en: 'To retain control over a detached container, use `docker attach` command. The
    syntax for `docker attach` is quite simple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要保持对分离容器的控制，请使用`docker attach`命令。`docker attach`的语法非常简单：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In our case this would be the ID we were given, when the container was started:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这将是在启动容器时给我们的ID：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this time, if there is something that gets printed out, such as another
    log line from our running REST service, you will see it on the console. As you
    can see, the `docker attach` command can come in handy if you need to see what
    is written to the `stdout` stream in real time. It will basically *reattach* your
    console to the process running in the container. In other words, it will stream
    the `stdout` into your screen and map the `stdin` to your keyboard, allowing you
    to enter the commands and see their output. Note that pressing the *CTRL + C*
    keyboard sequence while being attached to the container would kill the running
    process of the container, not detach from the console. To detach from the process
    use the default *CTRL+P* and *CTRL+Q* keyboard sequence. If the *CTRL + P* and
    *CTRL + Q* sequence clashes with your existing keyboard shortcuts, you can provide
    your own detach sequence by setting the `--detach-keys` option for the `docker
    attach` command. If you would like to be able to detach using *CTRL + C* , you
    may tell Docker not to send `sig-term` to the process running in the container
    by using the `sig-proxy` parameter set to `false` :'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果有什么东西被打印出来，比如我们运行的REST服务的另一条日志行，您将在控制台上看到它。正如您所看到的，如果您需要实时查看写入`stdout`流的内容，`docker
    attach`命令会很有用。它基本上会*重新附加*您的控制台到容器中运行的进程。换句话说，它将`stdout`流传输到您的屏幕，并将`stdin`映射到您的键盘，允许您输入命令并查看它们的输出。请注意，当附加到容器时按下*CTRL
    + C*键序列会终止容器的运行进程，而不是从控制台中分离。要从进程中分离，请使用默认的*CTRL+P*和*CTRL+Q*键序列。如果*CTRL + P*和*CTRL
    + Q*序列与您现有的键盘快捷键冲突，您可以通过为`docker attach`命令设置`--detach-keys`选项来提供自己的分离序列。如果您希望能够使用*CTRL
    + C*分离，您可以通过将`sig-proxy`参数设置为`false`来告诉Docker不要向容器中运行的进程发送`sig-term`：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If the container is running in the background, it would be nice to be able to
    monitor its behavior. Docker provides a set of features for doing that. Let's
    see how we can monitor running containers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器在后台运行，监视其行为将是很好的。Docker提供了一套功能来实现这一点。让我们看看如何监视运行中的容器。
- en: Monitoring containers
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监视容器
- en: There are some ways of monitoring running Docker containers. It can be viewing
    the log files, looking at the container events and statistics, and also inspecting
    container properties. Let's begin with the powerful logging features Docker has.
    Access to the log entries is crucial, especially if you have your container running
    in the detached runtime mode. Let's see what Docker can offer when it comes to
    a logging mechanism.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 监视运行中的Docker容器有一些方法。可以查看日志文件，查看容器事件和统计信息，还可以检查容器属性。让我们从Docker具有的强大日志记录功能开始。访问日志条目至关重要，特别是如果您的容器在分离的运行时模式下运行。让我们看看在日志记录机制方面Docker能提供什么。
- en: Viewing logs
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看日志
- en: 'Most applications output their log entries to the standard `stdout` stream.
    If the container is being run in the foreground mode, you will just see it in
    the console. However, when running a container in detached mode, you will see
    nothing but the container ID on the console. However, the Docker engine collects
    all the `stdout` output from a running container in a history file on the host.
    You can display it by using the `docker logs` command. The syntax of the command
    is as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序将它们的日志条目输出到标准的`stdout`流。如果容器在前台模式下运行，您将在控制台上看到它。但是，当以分离模式运行容器时，您在控制台上将什么也看不到，只会看到容器ID。但是，Docker引擎会在主机上的历史文件中收集运行容器的所有`stdout`输出。您可以使用`docker
    logs`命令来显示它。命令的语法如下：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `docker logs` command will output just a few last lines of the log into
    the console. As the container still works in the background (in detached mode),
    you will be given the prompt back immediately, as you can see on the following
    screenshot, presenting a fragment of the logfile from our REST service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`命令将仅将日志的最后几行输出到控制台。由于容器仍在后台运行（以分离模式），您将立即收到提示，如下面的屏幕截图所示，显示了我们的REST服务日志文件的片段：'
- en: '![](Image00075.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00075.jpg)'
- en: The `-f` flag acts as the same flag in Linux `tail` command, it will continuously
    display new log entries on the console. When you are done, hit *CTRL + C* to stop
    displaying log files on the console. Note that this is different from hitting
    *CTRL + C* when attached to the container, where *CTRL + C* would kill the process
    running within the container. This time, it will just stop displaying the log
    file and it's safe.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`标志在Linux `tail`命令中起着相同的作用，它会在控制台上持续显示新的日志条目。当你完成后，按下*CTRL + C*停止在控制台上显示日志文件。请注意，这与在容器中按下*CTRL
    + C*不同，那里*CTRL + C*会终止容器内运行的进程。这次，它只会停止显示日志文件，很安全。'
- en: The log file is permanent and available even after the container stops, as long
    as its file system is still present on disk (until it is removed with the `docker
    rm` command). By default, the log entries are stored in a JSON file located in
    the `/var/lib/docker` directory. You can see the complete path of the log file
    using the `docker inspect` command and using a template to extract the `LogPath`
    (we are going to cover `inspect` and templates in a while).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 日志文件是永久的，即使容器停止，只要其文件系统仍然存在于磁盘上（直到使用`docker rm`命令删除为止）。默认情况下，日志条目存储在位于`/var/lib/docker`目录中的JSON文件中。您可以使用`docker
    inspect`命令查看日志文件的完整路径，并使用模板提取`LogPath`（我们将在稍后介绍`inspect`和模板）。
- en: 'We have said that, by default, the log entries will go to the JSON file. But
    this can be easily changed, because Docker utilizes the concept of logging drivers.
    By using different drivers, you can pick other storage for your containers log.
    The default driver is the `json-file` driver, which just writes out the entries
    into the JSON file. Each driver can take additional parameters. The JSON driver
    accepts, for example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，默认情况下，日志条目将进入JSON文件。但这可以很容易地改变，因为Docker利用了日志驱动程序的概念。通过使用不同的驱动程序，您可以选择其他存储容器日志的方式。默认驱动程序是`json-file`驱动程序，它只是将条目写入JSON文件。每个驱动程序都可以接受附加参数。例如，JSON驱动程序接受：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you may have guessed, it's similar to a rolling file in our Java applications.
    The `max-size` specifies the maximum file size that can be created; after reaching
    the specified size, Docker will create a new file. You can use the size suffixes
    `k` , `m` , or `g` , where k will be for kilobytes, `m` for megabytes and `g`
    for gigabytes. Splitting a log into separate files makes it easier to transfer,
    archive, and so on. Also, searching through the log file is a lot more convenient
    if the file is smaller.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经猜到，这类似于我们Java应用程序中的滚动文件。`max-size`指定可以创建的最大文件大小；达到指定大小后，Docker将创建一个新文件。您可以使用大小后缀`k`，`m`或`g`，其中k代表千字节，`m`代表兆字节，`g`代表千兆字节。将日志拆分为单独的文件使得传输、存档等变得更加容易。此外，如果文件更小，搜索日志文件会更加方便。
- en: The `docker log` command only displays log entries from the latest log file.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker log`命令只显示最新日志文件中的日志条目。'
- en: 'There are some other log drivers available. The list includes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他可用的日志驱动程序。列表包括：
- en: '`none` : It will just switch off logging completely'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：它将完全关闭日志记录'
- en: '`syslog` : It''s a `syslog` logging driver for Docker. It will write log messages
    to the system `syslog`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`syslog`：这是Docker的`syslog`日志驱动程序。它将日志消息写入系统`syslog`'
- en: '`journald` : Will log messages to `journald` . `systemd-journald` is a daemon
    responsible for event logging, with append-only binary files serving as its logfiles'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`journald`：将日志消息记录到`journald`。`systemd-journald`是负责事件记录的守护程序，其追加日志文件作为其日志文件'
- en: '`splunk` : Provides the writing of log messages to Splunk using `Event Http`
    Collector. Splunk can be used as an enterprise-grade log analyzer. You can read
    more about it at [https://www.splunk.com](https://www.splunk.com)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splunk`：提供使用`Event Http` Collector将日志消息写入Splunk。Splunk可用作企业级日志分析工具。您可以在[https://www.splunk.com](https://www.splunk.com)了解更多信息'
- en: '`gelf` : Will write log entries into a GELF endpoint such as Graylog or Logstash.
    Graylog, available at [https://www.graylog.org](https://www.graylog.org) , is
    an open source log management, supporting search, analysis, and alerting across
    all of your log files. Logstash, which you can find at [https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash)
    , is a pipeline for processing any data (including log data) from any source'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gelf`：将日志条目写入GELF端点，如Graylog或Logstash。 Graylog可在[https://www.graylog.org](https://www.graylog.org)找到，是一个开源日志管理工具，支持对所有日志文件进行搜索、分析和警报。您可以在[https://www.elastic.co/products/logstash](https://www.elastic.co/products/logstash)找到Logstash，它是用于处理任何数据（包括日志数据）的管道。'
- en: '`fluentd` : Writes log messages to `fluentd` . Fluentd is an open source data
    collector for a unified logging layer. The main feature of Fluentd is that it
    separates data sources from backend systems by providing a unified logging layer
    in between. It''s small, fast and has hundreds of plugins that make a very flexible
    solution out of it. You can read more about `fluentd` on its website at [https://www.fluentd.org](https://www.fluentd.org)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fluentd`：将日志消息写入`fluentd`。Fluentd是一个用于统一日志层的开源数据收集器。Fluentd的主要特点是通过提供统一的日志层来将数据源与后端系统分离。它体积小，速度快，并且具有数百个插件，使其成为非常灵活的解决方案。您可以在其网站[https://www.fluentd.org](https://www.fluentd.org)上了解更多关于`fluentd`的信息'
- en: '`gcplogs` : Will send the log entries to Google Cloud logging'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gcplogs`：将日志条目发送到Google Cloud日志记录'
- en: '`awslogs` : This driver will write log messages to the Amazon CloudWatch logs.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awslogs`：此驱动程序将日志消息写入Amazon CloudWatch日志。'
- en: 'As you can see, again, the Docker''s pluggable architecture gives you almost
    infinite flexibility when running the container. To switch to the other log driver,
    use the `--log-driver` option for the `docker run` command. To store log entries
    in the `syslog` for example, execute the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Docker的可插拔架构在运行容器时提供了几乎无限的灵活性。要切换到其他日志驱动程序，请使用`docker run`命令的`--log-driver`选项。例如，要将日志条目存储在`syslog`中，请执行以下操作：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `docker logs` command works only for the `json-file` and `journald`
    drivers. To access logs written to another log engine, you will need to use the
    tool matching the driver you have chosen. It will often be more convenient to
    use the specialized tool for browsing log entries; actually, this is often the
    reason you choose another logging driver. For example, searching and browsing
    the logs in Logstash or Splunk is way faster than digging though the text files
    full of JSON entries.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`docker logs`命令仅适用于`json-file`和`journald`驱动程序。要访问写入其他日志引擎的日志，您将需要使用与您选择的驱动程序匹配的工具。使用专门的工具浏览日志条目通常更方便；实际上，这通常是您选择另一个日志驱动程序的原因。例如，在Logstash或Splunk中搜索和浏览日志比在充满JSON条目的文本文件中查找要快得多。
- en: Looking at the log entries is the convenient way of monitoring how our application
    behaves on the host. Sometimes, it could be also nice to see the properties of
    the running containers, as the mapped network port or volume being mapped and
    so on. To display the container properties, we use the `docker inspect` command,
    which is extremely useful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志条目是监视我们的应用程序在主机上的行为的便捷方式。有时，看到运行容器的属性也是很好的，比如映射的网络端口或映射的卷等等。为了显示容器的属性，我们使用`docker
    inspect`命令，这非常有用。
- en: Inspecting a container
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查容器
- en: 'The `docker ps` command we have been using to list the running containers gives
    us a lot of information about containers, such as their IDs, uptime, mapped ports,
    and so on. To display more details about the running container, we can user `docker
    inspect` . The syntax of the command is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用的`docker ps`命令用于列出运行的容器，它给我们提供了很多关于容器的信息，比如它们的ID、运行时间、映射端口等等。为了显示关于运行容器的更多细节，我们可以使用`docker
    inspect`。命令的语法如下：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'By default, the `docker inspect` command will output information about the
    container or image in a JSON array format. Because there are many properties,
    it may not be very readable. If we know what we are looking for, we can provide
    a template for processing the output, using the `-f` (or `--format` ) option.
    The template uses the template format coming from the Go language (Docker itself
    is written in Go, by the way). The simplest and the most often used template for
    the `docker inspect` command is just a short template to extract exactly the information
    you need, for example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker inspect`命令将以JSON数组格式输出有关容器或镜像的信息。由于有许多属性，这可能不太可读。如果我们知道我们要找的是什么，我们可以提供一个模板来处理输出，使用`-f`（或`--format`）选项。模板使用来自Go语言的模板格式（顺便说一句，Docker本身是用Go语言编写的）。`docker
    inspect`命令最简单和最常用的模板只是一个简短的模板，用于提取你需要的信息，例如：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As the `inspect` command accepts the Go template to form the output of the container
    or image metadata, this feature gives you almost infinite possibilities for processing
    and transforming the results. The Go templating engine is quite powerful, so,
    instead of piping the output through grep, which is quick but messy, you can use
    the template engine to further process the result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`inspect`命令接受Go模板来形成容器或镜像元数据的输出，这个特性为处理和转换结果提供了几乎无限的可能性。Go模板引擎非常强大，所以，我们可以使用模板引擎来进一步处理结果，而不是通过grep来处理输出，这样虽然快速但混乱。
- en: 'The argument to `--format` is a just a template that we want to apply to the
    metadata of the container. In this template, we can use conditional statements,
    loops, and other Go language features. For example, the following will find the
    names of all containers with a non-zero exit code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`--format`的参数只是我们要应用于容器元数据的模板。在这个模板中，我们可以使用条件语句、循环和其他Go语言特性。例如，以下内容将找到所有具有非零退出代码的容器的名称：'
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we provide `$(docker ps -aq)` instead of the container ID or name.
    As a result, all of the running containers'' IDs will be piped to the `docker
    inspect` command, which can be quite a handy shortcut. The curly brackets `{{}}`
    mean Go template directives, anything outside of them will be printed out literally.
    The dot (`.` ) in Go templates means context. Most of the time the current context
    will be whole data structure for the metadata, but it can be rebound when needed,
    including using the `with` action. For example, these two `inspect` commands will
    print out exactly the same result:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们提供了`$(docker ps -aq)`，而不是容器ID或名称。因此，所有正在运行的容器的ID将被传递给“docker inspect”命令，这可能是一个很方便的快捷方式。花括号“{{}}”表示Go模板指令，它们之外的任何内容都将被直接打印出来。在Go模板中，“.”表示上下文。大多数情况下，当前上下文将是元数据的整个数据结构，但在需要时可以重新绑定，包括使用“with”操作。例如，这两个“inspect”命令将打印出完全相同的结果：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you are inside the bound context, the dollar sign (`$` ) will always get
    you the `root` context. We can execute this command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在绑定的上下文中，美元符号（`$`）将始终让您进入“root”上下文。我们可以执行这个命令：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It will then output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将输出：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The template engine supports logical functions, such as `and` , `or` and `not`
    ; they will return a boolean result. Also, the comparison functions are supported,
    such as `eq` (equals), `ne` (not equals), `lt` (less than), `le` (less than or
    equal to), `gt` (greater than), and `ge` (greater than or equal to). Comparison
    functions can compare strings, floats or integers. Together with the conditional
    functions such as `if` , all of these can be very useful when creating some more
    sophisticated output from the `inspect` command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎支持逻辑函数，如“and”、“or”和“not”；它们将返回布尔结果。还支持比较函数，如“eq”（相等）、“ne”（不相等）、“lt”（小于）、“le”（小于或等于）、“gt”（大于）和“ge”（大于或等于）。比较函数可以比较字符串、浮点数或整数。与条件函数一起使用，如“if”，所有这些在从“inspect”命令创建更复杂的输出时都非常有用：
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Sometimes the huge output of the `docker inspect` command can be quite confusing.
    Since the output comes in JSON format, the `jq` tool can be used to get an overview
    of the output and pick out interesting parts.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，“docker inspect”命令的大量输出可能会令人困惑。由于输出以JSON格式呈现，可以使用“jq”工具来获取输出的概述并挑选出有趣的部分。
- en: 'The `jq` tool is available for free at [https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)
    . It''s a lightweight and flexible command-line JSON processor, such as `sed`
    command for the JSON data. For example, let''s extract the container IP address
    from the metadata:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “jq”工具可以免费获取，网址为[https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)。它是一个轻量灵活的命令行JSON处理器，类似于JSON数据的“sed”命令。例如，让我们从元数据中提取容器的IP地址：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, the `docker inspect` command provides useful information about
    Docker containers. Combined with the Go template features and optionally with
    the `jq` tool, it gives you a powerful tool to get the information about your
    containers and can be used further in scripting. But there's another source of
    valuable information apart from the metadata. It's runtime statistics, which we
    are going to focus on now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，“docker inspect”命令提供了有关Docker容器的有用信息。结合Go模板功能，以及可选的“jq”工具，它为您提供了一个强大的工具，可以获取有关您的容器的信息，并可以在脚本中进一步使用。但除了元数据之外，还有另一个有价值的信息来源。这就是运行时统计信息，现在我们将重点关注这一点。
- en: Statistics
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统计信息
- en: 'To see the CPU, memory, disk i/o and network i/o statistics for containers,
    use the `docker stats` command. The syntax for the command is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器的CPU、内存、磁盘I/O和网络I/O统计信息，请使用“docker stats”命令。该命令的语法如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can limit the statistics measure to one or more specific containers by
    specifying a list of container IDs or names separated by a space. By default,
    if no containers are specified, the command will display statistics for all running
    containers, as you can see on the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定由空格分隔的容器ID或名称列表来将统计量限制为一个或多个特定容器。默认情况下，如果未指定容器，则该命令将显示所有运行中容器的统计信息，如下面的屏幕截图所示：
- en: '![](Image00076.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00076.jpg)'
- en: 'The `docker stats` command accepts options, which can include:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker stats`命令接受选项，其中可以包括：'
- en: '`--no-stream` : This will disable streaming stats and only pull the first result'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-stream`：这将禁用流式统计信息，并且只拉取第一个结果'
- en: '`-a` (`--all` ): This will show statistics for all (not only running) containers'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-a`（`--all`）：这将显示所有（不仅仅是运行中的）容器的统计信息'
- en: The statistics can be used to see if our containers behave well when running.
    The information can be useful to check if we need some constraints on the resources
    to be applied to containers, we are going to cover the runtime constraints in
    a while in this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 统计信息可用于查看我们的容器在运行时的行为是否良好。这些信息可以用来检查是否需要对容器应用一些资源约束，我们将在本章稍后讨论运行时约束。
- en: Viewing logs, container metadata and runtime statistics, give you almost infinite
    possibilities when monitoring your running containers. Apart from this, we can
    see what's happening on your docker host globally. When the docker engine on the
    host receives a command, it will emit an event we can observe. Let's look at this
    mechanism now.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 查看日志、容器元数据和运行时统计信息，可以在监视运行中的容器时给您几乎无限的可能性。除此之外，我们还可以全局查看docker主机上发生的情况。当主机上的docker引擎接收到命令时，它将发出我们可以观察到的事件。现在让我们来看看这个机制。
- en: Container events
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器事件
- en: 'To observe the events coming to the docker engine in real time, we use the
    `docker events` command. If the container has been started, stopped, paused, and
    so on, the event will be published. This can be very useful if you would like
    to know what has happened during the container runtime. It''s a powerful monitoring
    feature. Docker containers report a huge list of events, which you can list with
    the `docker events` command. The list includes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实时观察到docker引擎接收的事件，我们使用`docker events`命令。如果容器已启动、停止、暂停等，事件将被发布。如果您想知道容器运行时发生了什么，这将非常有用。这是一个强大的监控功能。Docker容器报告了大量的事件，您可以使用`docker
    events`命令列出。列表包括：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `docker events` command can take the `-f` switch, which will filter the
    output if you are looking for something specific. If no filter is provided, all
    events will be reported. Currently the list of possible filters includes:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker events`命令可以使用`-f`开关，如果您正在寻找特定内容，它将过滤输出。如果未提供过滤器，则将报告所有事件。目前可能的过滤器列表包括：'
- en: container (`container=<name or id>` )
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器（`container=<名称或ID>`）
- en: event (`event=<event action>` )
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件（`event=<事件操作>`）
- en: image (`image=<tag or id>` )
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像（`image=<标签或ID>`）
- en: plugin (experimental) (`plugin=<name or id>` )
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件（实验性）（`plugin=<名称或ID>`）
- en: label (`label=<key> or label=<key>=<value>` )
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签（`label=<键>`或`label=<键>=<值>`）
- en: type (`type=<container or image or volume or network or daemon>` )
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型（`type=<容器或镜像或卷或网络或守护程序>`）
- en: volume (`volume=<name or id>` )
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷（`volume=<名称或ID>`）
- en: network (`network=<name or id>)`
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络（`network=<名称或ID>`）
- en: daemon (`daemon=<name or id>` )
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 守护程序（`daemon=<名称或ID>`）
- en: 'Take a look at the following example. The `docker events` command has been
    run in one console window, while the `docker run rest-example` has been issued
    in the separate console. As you can see in the following screenshot, `docker events`
    will report create, attach, connect and start events for our rest-example container:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例。在一个控制台窗口中运行了`docker events`命令，而在另一个控制台中发出了`docker run rest-example`命令。如您在以下截图中所见，`docker
    events`将报告我们的rest-example容器的创建、附加、连接和启动事件：
- en: '![](Image00077.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00077.jpg)'
- en: As a result, you will get a timestamp and the name of the event, together with
    the ID of the container that has caused an event. The `docker events` command
    can take additional options, such as `--since` and `--until` , which can be used
    to specify a timeframe that you want to get the events from. Monitoring container
    events is a great tool to see what's going on the docker host. However, there's
    more. You can also influence, how your containers behave in case of a crash, for
    example. We use container restart policies for that.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将获得一个时间戳和事件的名称，以及导致事件的容器的ID。`docker events`命令可以接受其他选项，例如`--since`和`--until`，用于指定要获取事件的时间范围。监视容器事件是一个很好的工具，可以看到Docker主机上发生了什么。但这还不是全部。您还可以影响容器在崩溃时的行为，例如。我们使用容器重启策略来实现这一点。
- en: Restart policies
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重启策略
- en: 'By using the `--restart` option with the `docker run` command you can specify
    a restart policy. This tells Docker how to react when a container shuts down.
    The container then can be restarted to minimize downtime, for example if running
    on a production server. However, before we explain the Docker restart policy,
    let''s focus for a while on exit codes. The exit code is crucial information,
    it tells why the container failed to run or why it exited. Sometimes it''s related
    to the contained command you will give to the `docker run` as a parameter. When
    the `docker run` command ends with a non-zero code, the exit codes follow the
    `chroot` standard, as you can see here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`docker run`命令中使用`--restart`选项，您可以指定重启策略。这告诉Docker在容器关闭时如何反应。然后可以重新启动容器以最小化停机时间，例如在生产服务器上运行时。然而，在我们解释Docker重启策略之前，让我们先专注一会儿退出代码。退出代码是关键信息，它告诉我们容器无法运行或退出的原因。有时它与您将作为参数提供给`docker
    run`的命令有关。当`docker run`命令以非零代码结束时，退出代码遵循`chroot`标准，如您在这里所见：
- en: 'exit code `125` : The `docker run` command fails by itself'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出代码`125`：`docker run`命令本身失败
- en: 'exit code`126` : The supplied command cannot be invoked'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出代码`126`：提供的命令无法调用
- en: 'exit code `127` : The supplied command cannot be found'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退出代码`127`：提供的命令找不到
- en: Other, non-zero, application dependent exit code
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他非零的、应用程序相关的退出代码
- en: 'As you may remember, in previous chapters we have been using the `docker ps`
    command to list running containers. To list the non-running containers as well,
    we can add the `-a` switch for the `docker ps` command. The exit code can be found
    in the output of the `docker ps -a` command in a Status column when a container
    completes. It''s possible to automatically restart crashed containers by specifying
    a restart policy when starting the container. Specifying the desired restart policy
    is done by the -restart switch for the `docker run` command, as in the example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，在之前的章节中，我们一直在使用`docker ps`命令列出运行中的容器。要列出非运行中的容器，我们可以为`docker ps`命令添加`-a`开关。当容器完成时，退出代码可以在`docker
    ps -a`命令的输出中的状态列中找到。可以通过在启动容器时指定重启策略来自动重新启动崩溃的容器。通过`docker run`命令的-restart开关来指定所需的重启策略，就像这个例子中一样：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Currently Docker has four restart policies. Let''s get to know them now one
    by one, starting with the simplest: `no` .'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 目前Docker有四种重启策略。让我们逐一了解它们，从最简单的开始：`no`。
- en: 'no'
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有
- en: The `no` policy is the default restart policy and simply will not restart a
    container under any case. Actually, you do not have to specify this policy, because
    this is the default behavior. Unless you have some configurable setup to run Docker
    containers, then the `no` policy can be used as an off switch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “no”策略是默认的重启策略，简单地不会在任何情况下重新启动容器。实际上，您不必指定此策略，因为这是默认行为。除非您有一些可配置的设置来运行Docker容器，否则“no”策略可以用作关闭开关。
- en: always
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 始终
- en: If we wanted the container to be restarted no matter what exit code the command
    has, we can use the `always` restart policy. Basically, it does what it says;
    Docker will restart the container in every case. The restart policy will always
    restart the container. This is true, even if the container has been stopped before
    the reboot. Whenever the Docker service is restarted, containers using the always
    policy will also be restarted, it doesn't matter whether they were executing or
    not.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望无论命令的退出代码是什么，容器都会重新启动，我们可以使用“always”重启策略。基本上，它就是字面意思；Docker将在任何情况下重新启动容器。重启策略将始终重新启动容器。即使容器在重新启动之前已停止，也是如此。每当Docker服务重新启动时，使用always策略的容器也将被重新启动，无论它们是否正在执行。
- en: With the `always` restart policy, the Docker daemon will try to restart the
    container **indefinitely.**
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“always”重启策略，Docker守护程序将尝试无限次重新启动容器。
- en: on-failure
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在失败时
- en: This is a kind of special restart policy and probably the most often used. By
    using the `on-failure` restart policy, you instruct Docker to restart your container
    whenever it exits with a non-zero exit status and not restart otherwise. That's
    the reason we have begun explaining restart policies with the exit codes. You
    can optionally provide a number of times for Docker to attempt to restart the
    container. The syntax of this restart policy is also a little bit different, because
    using this policy, you can also specify a maximum number of tries that Docker
    will make to automatically restart the container.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种特殊的重启策略，可能是最常用的。通过使用“on-failure”重启策略，您指示Docker在容器以非零退出状态退出时重新启动容器，否则不重新启动。这就是我们从退出代码开始解释重启策略的原因。您还可以选择为Docker尝试重新启动容器的次数提供一个数字。此重启策略的语法也略有不同，因为使用此策略，您还可以指定Docker将尝试自动重新启动容器的最大次数。
- en: 'Consider this example:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个例子：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding command will run the container with our REST service and will
    try to restart it five times in the case of failure before giving up. The main
    benefit of the `on-failures` restart policy is that, when an application exits
    with a successful exit code (that means there were no errors in the application;
    it just finished executing), the container will not be restarted. The number of
    restart tries for a container can be obtained via the `docker inspect` command
    we already know. For example, to get the number of restarts for a container with
    a specific ID or name:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在失败的情况下，上述命令将运行具有我们的REST服务的容器，并在放弃之前尝试重新启动五次。 “on-failures”重启策略的主要好处是，当应用程序以成功的退出代码退出时（这意味着应用程序没有错误，只是执行完毕），容器将不会重新启动。可以通过我们已经知道的“docker
    inspect”命令获取容器的重新启动尝试次数。例如，要获取具有特定ID或名称的容器的重新启动次数：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You can also discover the last time the container was started again:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以发现容器上次启动的时间：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You should know that Docker uses a delay between restarting the container, to
    prevent flood-like protection. This is an increasing delay; it starts with the
    value of 100 milliseconds, then Docker will double the previous delay. In effect,
    the daemon will wait for 100 ms, then 200 ms, 400, 800 and so on, until either
    the `on-failure` limit is reached, or when you stop the container using `docker
    stop,` or execute the force removal by executing the `docker rm -f` command.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该知道，Docker在重新启动容器之间使用延迟，以防止洪水般的保护。这是一个递增的延迟；它从100毫秒的值开始，然后Docker将加倍上一个延迟。实际上，守护程序将等待100毫秒，然后是200毫秒，400，800等，直到达到`on-failure`限制，或者当您使用`docker
    stop`停止容器，或者通过执行`docker rm -f`命令强制删除容器。
- en: If a container is successfully restarted, the delay is reset to the default
    value of 100 milliseconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器成功重新启动，则延迟将重置为默认值100毫秒。
- en: unless-stopped
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unless-stopped
- en: Again, similar to `always` , if we want the container to be restarted regardless
    of the exit code, we can use `unless-stopped` . The `unless-stopped` restart policy
    acts the same as `always` with one exception, it will restart the container regardless
    of the exit status, but do not start it on daemon startup if the container has
    been put to a stopped state before. This means that with the `unless-stopped`
    restart policy, if the container was running before the reboot, the container
    would be restarted once the system restarted. When an application within a Docker
    container exits, that container will be also halted. If an application that is
    running within a container crashes, the container stops and that container will
    remain stopped until someone or something restarts it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 与`always`类似，如果我们希望容器无论退出代码如何都重新启动，我们可以使用`unless-stopped`。`unless-stopped`重启策略与`always`相同，唯一的例外是，它将重新启动容器，而不管退出状态如何，但如果容器在停止状态之前已被停止，则不会在守护程序启动时启动它。这意味着使用`unless-stopped`重启策略，如果容器在重新启动前正在运行，则系统重新启动后容器将被重新启动。当Docker容器中的应用程序退出时，该容器也将被停止。如果容器中运行的应用程序崩溃，容器将停止，并且该容器将保持停止状态，直到有人或某物重新启动它。
- en: Before you apply the restart policy to your container, it's good to think first
    what kind of work the container will be used to do. That also depends on the kind
    of software that will be running on the container. A database, for example, should
    probably have the `always` or `unless-stopped` policy applied. If your container
    has some restart policy applied, it will be shown as `Restarting` or `Up` status
    when you list your container using the `docker ps` command.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在将重启策略应用于容器之前，最好先考虑容器将用于做什么样的工作。这也取决于将在容器上运行的软件的类型。例如，数据库可能应该应用`always`或`unless-stopped`策略。如果您的容器应用了某种重启策略，当您使用`docker
    ps`命令列出容器时，它将显示为`Restarting`或`Up`状态。
- en: Updating a restart policy on a running container
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新正在运行的容器的重启策略
- en: 'Sometimes, there''s a need to update the Docker runtime parameters after the
    container has already started, *on the fly* . An example would be if you want
    to prevent containers from consuming too many resources on the Docker host. To
    set the policy during runtime, we can use the `docker update` command. Apart from
    other runtime parameters (such as memory or CPU constraints for example, which
    we are going to discuss later in this chapter), the `docker update` command gives
    you the option to update the restart policy on a running container. The syntax
    is quite straightforward, you just need to provide the new restart policy that
    you would like the container to have and the container''s ID or name:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在容器已经启动后，有必要*即时*更新Docker运行时参数。一个例子是，如果您想要防止容器在Docker主机上消耗过多资源。为了在运行时设置策略，我们可以使用`docker
    update`命令。除了其他运行时参数（例如内存或CPU约束，我们将在本章后面讨论），`docker update`命令还提供了更新运行中容器的重启策略的选项。语法非常简单，您只需要提供您希望容器具有的新重启策略以及容器的ID或名称：
- en: '[PRE31]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A new restart policy will take effect immediately after you run the `docker
    update` command on a container. On the other hand, if you execute the `update`
    command on a container that is stopped, the policy will be used when you start
    the container later on. The possible options are exactly the same as those you
    can specify when starting the container:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker update`命令后，新的重启策略将立即生效。另一方面，如果您在已停止的容器上执行`update`命令，该策略将在以后启动容器时使用。可能的选项与您启动容器时可以指定的选项完全相同：
- en: '`no` (which is default)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no`（默认值）'
- en: '`always`'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`'
- en: '`on-failure`'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时
- en: '`unless-stopped`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unless-stopped`'
- en: If you have more than one container running on the Docker host, and want to
    specify a new restart policy on all of them at once, just provide all of their
    IDs or names, separated by a space.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Docker主机上运行多个容器，并且想要一次性为它们指定新的重启策略，只需提供它们所有的ID或名称，用空格分隔。
- en: 'You can also see which restart policy was applied using the `docker events`
    command, which you already know from the previous section. The `docker events`
    which can be used to observe the history of runtime events that the container
    has reported, will also report the `docker update` event, providing you with details
    about what has changed. If the container has been applied the restart policy,
    the event will be published. If you want to check the restart policy of a running
    container use `docker inspect` with the container ID or name with the `--format`
    argument set for the path of the value:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`docker events`命令查看应用了哪种重启策略，这是您已经在上一节中了解过的。`docker events`可以用来观察容器报告的运行时事件的历史记录，还会报告`docker
    update`事件，提供有关已更改的详细信息。如果容器已应用重启策略，事件将被发布。如果要检查运行中容器的重启策略，请使用`docker inspect`与容器ID或名称以及设置`--format`参数的路径：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The ability to set a restart policy on a container by container basis is great
    for those cases where your images are self-contained and you don't need to do
    more complex orchestration tasks. The restart policy is not the only parameter
    you can change on running containers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 根据容器设置重启策略的能力非常适用于那些图像是自包含的，不需要进行更复杂的编排任务的情况。重启策略不是您可以在运行中容器上更改的唯一参数。
- en: Runtime constraints on resources
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源的运行时约束
- en: It may be useful to restrict the Docker container usage of resources when running.
    Docker gives you a many possibilities to set constraints on the memory, CPU usage
    or disk access usage. Let's begin with setting the memory constraints.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时限制Docker容器使用资源可能是有用的。Docker为您提供了许多设置内存、CPU使用或磁盘访问使用的约束的可能性。让我们从设置内存约束开始。
- en: Memory
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存
- en: It's worth knowing that, by default, that is, if you use the default settings
    without any constraints, the running container can use all of the host memory.
    To change this behavior we can use the `--memory` (or `-m` for short) switch for
    the `docker run` command. It takes the usual suffixes `k` , `m` , or `g` for kilobytes,
    megabytes and gigabytes, respectively.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值得知道，默认情况下，即如果您在没有任何约束的情况下使用默认设置，则运行的容器可以使用所有主机内存。要更改此行为，我们可以使用`docker run`命令的`--memory`（或`-m`简称）开关。它分别采用`k`，`m`或`g`后缀，表示千字节，兆字节和千兆字节。
- en: 'The syntax of the `docker run` command with memory constraints set will be
    as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 具有设置内存约束的`docker run`命令的语法将如下所示：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding command will execute the Ubuntu image with the maximum memory
    that can be used by the container of half of a gigabyte.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将执行Ubuntu镜像，容器可以使用的最大内存为半个千兆字节。
- en: If you do not set the limit on memory that the container can allocate, this
    can lead to random issues where a single container can easily make the whole host
    system unstable and/or unusable. So it's a wise decision to always use the memory
    constraints on the container.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有设置容器可以分配的内存限制，这可能会导致随机问题，其中单个容器可以轻松使整个主机系统变得不稳定和/或无法使用。因此，始终在容器上使用内存约束是明智的决定。
- en: Apart from user memory limit, there are also memory reservation and kernel memory
    constraints. Let's explain what a memory reservation limit is. Under normal working
    conditions, a running container can, and probably will, use as much of the memory
    as needed, up to the limit you have set using the `--memory` (`-m` ) switch for
    the `docker run` command. When memory reservation is applied, Docker will detect
    a low memory situation and will try to force the container to restrict its consumption
    up to a reservation limit. If you do not set the memory reservation limit, it
    will be exactly the same as the hard memory limit set with the `-m` switch.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户内存限制外，还有内存预留和内核内存约束。让我们解释一下内存预留限制是什么。在正常工作条件下，运行的容器可以并且可能会使用所需的内存，直到您使用`docker
    run`命令的`--memory`（`-m`）开关设置的限制。当应用内存预留时，Docker将检测到低内存情况，并尝试强制容器将其消耗限制到预留限制。如果您没有设置内存预留限制，它将与使用`-m`开关设置的硬内存限制完全相同。
- en: Memory reservation is not a hard limit feature. There's no guarantee the limit
    won't be exceeded. The memory reservation feature will attempt to ensure that
    memory will be allocated, based on the reservation setting.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内存预留不是硬限制功能。不能保证不会超出限制。内存预留功能将尝试确保根据预留设置分配内存。
- en: 'Consider the following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE34]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding command sets the hard memory limit to `1g` , and then sets the
    memory reservation to half a gig. With those constraints set, when the container
    consumes memory more than `500M` and less than `1G` , Docker will attempt to shrink
    container memory less than `500M` .
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将将硬内存限制设置为`1g`，然后将内存预留设置为半个千兆字节。设置这些约束后，当容器消耗的内存超过`500M`但少于`1G`时，Docker将尝试将容器内存缩小到少于`500M`。
- en: 'In the next example we are going to set the memory reservation without setting
    the hard memory limit:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将设置内存预留而不设置硬内存限制：
- en: '[PRE35]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding example, when the container starts, it can use as much memory
    as its processes need. The `--memory-reservation` switch setting will prevent
    the container from consuming too much memory for a long time, because every memory
    reclaim will shrink the container's memory usage to the size specified in the
    reservation.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，当容器启动时，它可以使用其进程所需的内存。`--memory-reservation`开关设置将阻止容器长时间消耗过多的内存，因为每次内存回收都会将容器的内存使用量缩小到预留中指定的大小。
- en: The kernel memory is something entirely different from the user memory, the
    main difference is that kernel memory can't be swapped out to disk. It includes
    stack pages, slab pages, sockets memory pressure and TCP memory pressure. You
    use the --kernel-memory switch to set up the kernel memory limit to constrain
    these kinds of memory. As with setting the user memory limit, just provide a number
    with a suffix such as `k` , `b` , and `g,` for kilobyte, megabyte or gigabyte
    respectively, although setting it in kilobytes may be a really rare case.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 内核内存与用户内存完全不同，主要区别在于内核内存无法交换到磁盘。它包括堆栈页面、slab页面、套接字内存压力和TCP内存压力。您可以使用`--kernel-memory`开关来设置内核内存限制以约束这些类型的内存。与设置用户内存限制一样，只需提供一个带有后缀的数字，例如`k`、`b`和`g`，分别表示千字节、兆字节或千兆字节，尽管以千字节设置它可能是一个非常罕见的情况。
- en: For example, every process eats some stack pages. By restricting kernel memory,
    you can prevent new processes from being started when the kernel memory usage
    is too high. In addition, because the host cannot swap the kernel memory to disk,
    the container can block the whole host service by consuming too much kernel memory.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个进程都会占用一些堆栈页面。通过限制内核内存，您可以防止在内核内存使用过高时启动新进程。此外，由于主机无法将内核内存交换到磁盘，容器可能会通过消耗过多的内核内存来阻塞整个主机服务。
- en: 'Setting the kernel memory limit is straightforward. We can set the `--kernel-memory`
    alone, without limiting the total memory with `-m` , as in the following example:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 设置内核内存限制很简单。我们可以单独设置`--kernel-memory`，而不限制总内存使用量，就像下面的例子一样：
- en: '[PRE36]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding example, the process in the container can take memory as it
    needs, but it can only consume `100M` of kernel memory. We can also setup the
    hard memory limit, as in the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，容器中的进程可以根据需要使用内存，但只能消耗`100M`的内核内存。我们还可以设置硬内存限制，如下面的命令所示：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding command, we set memory and kernel memory altogether, so the
    processes in the container can use `1G` memory in total, and this `1G` will include
    `100M` of the kernel memory.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们同时设置了内存和内核内存，因此容器中的进程可以总共使用`1G`内存，其中包括`100M`的内核内存。
- en: 'One more constraint related to the memory which can be useful when running
    containers, is the swappines constraint. We apply the constraint by using the
    `--memory-swappiness` switch to the `docker run` command. It can be helpful when
    you want to avoid performance drops related to memory swapping. The parameter
    for the `--memory-swappiness` switch is the percentage of anonymous memory pages
    that can be swapped out, so it takes values from `0` to `100` . Setting the value
    to zero, will, depending on your kernel version, disable swapping or use the minimal
    swap. In contrast, a value of `100` sets all anonymous pages as candidates for
    swapping out. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与内存相关的另一个约束条件在运行容器时可能会有用，这是swappines约束。我们可以使用`--memory-swappiness`开关来应用约束到`docker
    run`命令。当你想要避免与内存交换相关的性能下降时，这可能会有所帮助。`--memory-swappiness`开关的参数是可以交换的匿名内存页面的百分比，因此它的值范围是从`0`到`100`。将值设置为零，将根据您的内核版本禁用交换或使用最小交换。相反，值为`100`会将所有匿名页面设置为可以交换出去的候选项。例如：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding command, we turn the swapping completely for our `ubuntu` container.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，我们完全关闭了`ubuntu`容器的交换。
- en: Apart from setting the memory usage constraint, you can also instruct Docker
    how the processor power should be assigned to containers it's going to run.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置内存使用约束外，您还可以指示Docker如何分配处理器能力给它将要运行的容器。
- en: Processors
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理器
- en: By using the `-c` (or `--cpu-shares` as an equivalent) for the `docker run`
    command switch, it's possible to specify a value of shares of the CPU that a container
    can allocate. By default, every new container has 1024 shares of CPU and all containers
    get the same part of CPU cycles. This percentage can be altered by shifting the
    container's CPU share weighting relative to the weighting of all other running
    containers. But take note, that you cannot set the precise processor speed that
    a container can use. This is a **relative weight** and has nothing to do with
    the real processor speed. In fact, there is no way to say precisely that a container
    should have the right to use only 2 GHz of the host's processor.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`-c`（或`--cpu-shares`作为等效项）来为`docker run`命令开关指定CPU份额的值是可能的。默认情况下，每个新容器都有1024份CPU份额，并且所有容器获得相同的CPU周期。这个百分比可以通过改变容器的CPU份额权重相对于所有其他正在运行的容器的权重来改变。但请注意，您不能设置容器可以使用的精确处理器速度。这是一个**相对权重**，与实际处理器速度无关。事实上，没有办法准确地说一个容器应该有权利只使用主机处理器的2
    GHz。
- en: CPU share is just a number, it's not related at all to the CPU speed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: CPU份额只是一个数字，与CPU速度没有任何关系。
- en: If we start two containers and both will use 100% CPU, the processor time will
    be divided equally between the two containers. The reason for that is two containers
    will have the same number of processor shares. But if you constrain one container's
    processor shares to 512, it will receive just a half of the CPU time. This does
    not mean that it can use only half of the CPU; the proportion will only apply
    when CPU-intensive processes are running. If the other container (with `1024`
    shares) is idle, our container will be allowed to use 100% of the processor time.
    The real amount of CPU time will differ depending on the number of containers
    running on the system. It's easier to understand on a tangible example.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们启动两个容器，两者都将使用100%的CPU，处理器时间将在两个容器之间平均分配。原因是两个容器将拥有相同数量的处理器份额。但是如果您将一个容器的处理器份额限制为512，它将只获得CPU时间的一半。这并不意味着它只能使用CPU的一半；这个比例只在运行CPU密集型进程时适用。如果另一个容器（具有`1024`份份额）处于空闲状态，我们的容器将被允许使用100%的处理器时间。实际的CPU时间将取决于系统上运行的容器数量。这在一个具体的例子中更容易理解。
- en: Consider three containers, one (let's call it `Container1` ) has `--cpu-shares`
    set for `1024` and two others (`Container2` and `Container3` ) have a `--cpu-shares`
    setting of `512` . When processes in all three containers attempt to use all of
    the CPU power, `Container1` will receive 50% of the total CPU time, because it
    has half of the CPU usage allowed in comparison to the sum of other running containers
    (`Container2` and `Container3` ). If we add a fourth container (`Container4` )
    with a `--cpu-share` of 1024, our first `Container1` will only get 33% of the
    CPU, because it now has one third of the total CPU power assigned, relatively.
    `Container2` will receive 16.5%, `Container3` also 16.5% and the last one, `Container4`
    , again, will be allowed to use 33% of the CPU.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑三个容器，一个（我们称之为`Container1`）设置了`--cpu-shares`为`1024`，另外两个（`Container2`和`Container3`）设置了`--cpu-shares`为`512`。当所有三个容器中的进程尝试使用所有的CPU功率时，`Container1`将获得总CPU时间的50%，因为它相对于其他正在运行的容器（`Container2`和`Container3`的总和）有一半的CPU使用量。如果我们添加一个`--cpu-share`为1024的第四个容器（`Container4`），我们的第一个`Container1`只会获得CPU的33%，因为它现在相对于总CPU功率的三分之一。`Container2`将获得16.5%，`Container3`也是16.5%，最后一个`Container4`再次被允许使用CPU的33%。
- en: 'While the `-c` or `--cpu_shares` flag for the `docker run` command modifies
    the container''s CPU share weighting relative to the weighting of all other running
    containers, it does not restrict the container''s use of CPU from the host machine.
    But there''s another flag to limit the CPU usage for the container: `--cpu-quota`
    . Its default value is `100000` which means an allowance of 100% of the CPU usage.
    We can use the `--cpu-quota` to limit CPU usage , for example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`docker run`命令的`-c`或`--cpu_shares`标志修改了容器相对于所有其他运行容器的CPU份额权重，但它不限制容器对主机机器CPU的使用。但是还有另一个标志可以限制容器的CPU使用：`--cpu-quota`。其默认值为`100000`，表示允许使用100%的CPU使用率。我们可以使用`--cpu-quota`来限制CPU使用，例如：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding command, the limit for the container will be 50% of a CPU
    resource. The `--cpu-quota` is usually used in conjunction with the `--cpu-period`
    flag for the `docker run` . This is the setting for the CPU CFS (Completely Fair
    Scheduler) period. The default period value is 100000 which is 100 milliseconds.
    Take a look at the example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，容器的限制将是CPU资源的50%。`--cpu-quota`通常与`docker run`的`--cpu-period`标志一起使用。这是CPU
    CFS（Completely Fair Scheduler）周期的设置。默认周期值为100000，即100毫秒。看一个例子：
- en: '[PRE40]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It means that the container can get 50% of the CPU usage every 50 ms.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着容器可以每50毫秒获得50%的CPU使用率。
- en: 'Limiting CPU shares and usage is not the only processor-related constraint
    we can set on the container. We can also assign the container''s processes to
    a particular processor or processor core. The `--cpuset` switch of the `docker
    run` command comes in handy when we want to do this. Consider the following example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 限制CPU份额和使用率并不是我们可以在容器上设置的唯一与处理器相关的约束。当我们想要执行此操作时，`docker run`命令的`--cpuset`开关非常方便。考虑以下例子：
- en: '[PRE41]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding command will run the `ubuntu` image and allow the container to
    use all four processor cores. To start the container and only allow usage of one
    processor core, you can change the `--cpuset` value to `1` :'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将运行`ubuntu`镜像，并允许容器使用所有四个处理器核心。要启动容器并只允许使用一个处理器核心，可以将`--cpuset`值更改为`1`：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can of course mix the option `--cpuset` with `--cpu_shares` to tweak you
    container's CPU constraints.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以将`--cpuset`选项与`--cpu_shares`混合在一起，以调整容器的CPU约束。
- en: Updating constraints on a running container
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新正在运行的容器的约束
- en: As with the restart policies, the constraints can also be updated when the container
    is already running. This may be helpful, if you see your containers eating too
    much of the Docker host system resources and would like to limit this usage. Again,
    we use the `docker update` command to do this.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与重启策略一样，当容器已经在运行时也可以更新约束。如果您发现您的容器占用了太多的Docker主机系统资源，并希望限制此使用，这可能会有所帮助。同样，我们使用`docker
    update`命令来执行此操作。
- en: 'As with restart policies, the syntax for the `docker update` command will be
    the same as when starting the container, you specify the desired constraints as
    an argument for the docker update command and then give the container ID (taken
    from the `docker ps` command output for example) or its name. Again, if you would
    like to change the constraints on more than one container at once, just provide
    their IDs or names separated by a space. Let''s look at some examples of how to
    update constraints at runtime:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 与重启策略一样，`docker update`命令的语法与启动容器时相同，您将所需的约束作为docker update命令的参数指定，然后提供容器ID（例如从`docker
    ps`命令输出中获取）或其名称。同样，如果您想一次更改多个容器的约束，只需提供它们的ID或名称，用空格分隔。让我们看一些在运行时如何更新约束的示例：
- en: '[PRE43]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding command will limit the CPU shares to the value of 512\. Of course,
    you can apply CPU and memory constraints at the same time, to more than one container:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将限制CPU份额的值为512。当然，您也可以同时对多个容器应用CPU和内存约束：
- en: '[PRE44]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding command will update CPU shares and memory limits to two containers,
    identified by `abbdef1231677` and `dabdff1231678` .
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将更新CPU份额和内存限制到两个容器，标识为`abbdef1231677`和`dabdff1231678`。
- en: 'Of course, when updating the runtime constraints, you can also apply the desired
    restart policy in one single command, as in the following example:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新运行时约束时，当然也可以在一个命令中应用所需的重启策略，就像下面的例子一样：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As you can see, the ability to set constraints gives you a lot of flexibility
    when running Docker containers. But it''s worth noting, that applying constraints
    is not always possible. The reason for that is the constraint setting features
    depend heavily of the internals of the Docker host, especially its kernel. For
    example, it''s not always possible to set up the kernel memory limit or `memory
    swappiness` for example, sometimes all you will get is `Your kernel does not support
    kernel memory limit or kernel does not support memory swappiness capabilities`
    messages. Sometimes those limitations can be configurable, sometimes not. For
    example if you get `WARNING: Your kernel does not support cgroup swap limit on
    Ubuntu` , you can tweak your Grub bootloader with the `cgroup_enable=memory swapaccount=1`
    setting in the Grub configuration file, this will be `/etc/default/grub` in Ubuntu,
    for example. It''s important to read logs printed out by Docker, to make sure
    your constraints are in place.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，设置约束的能力在运行Docker容器时给了您很大的灵活性。但值得注意的是，应用约束并不总是可能的。原因是约束设置功能严重依赖于Docker主机的内部情况，特别是其内核。例如，设置内核内存限制或`内存swappiness`并不总是可能的，有时您会收到`您的内核不支持内核内存限制或内核不支持内存swappiness功能`的消息。有时这些限制是可配置的，有时不是。例如，如果您收到`警告：您的内核不支持Ubuntu上的cgroup交换限制`，您可以在Grub配置文件中使用`cgroup_enable=memory
    swapaccount=1`设置来调整Grub引导加载程序，例如在Ubuntu中，这将是`/etc/default/grub`。重要的是要阅读Docker打印出的日志，以确保您的约束已经生效。
- en: Always take note of the warnings Docker outputs during the container startup
    or after updating your constraints on the fly, it may happen that your constraints
    will not take action!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器启动或在动态更新约束后，始终注意Docker输出的警告，可能会导致您的约束不起作用！
- en: We already know how to run and observe containers using the commands available
    from the command line. It's not very convenient, however, if you need to spin-up
    your containers during the development flow, for example for integration testing.
    The Fabric8 Docker Maven plugin we've been using in [Chapter 5](text00084.html)
    , *Creating Images with Java Applications* , to build images, comes in handy if
    we need to run containers, as well. Let's do it now.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何使用命令行中可用的命令来运行和观察容器。然而，如果您需要在开发流程中启动容器，例如进行集成测试，这并不是很方便。我们在[第5章](text00084.html)中使用的Fabric8
    Docker Maven插件，用于构建镜像，如果我们需要运行容器，也会很方便。现在让我们来做吧。
- en: Running with Maven
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven运行
- en: 'The plugin provides two Maven goals related to starting and stopping containers.
    This will be `docker:start` and `docker:stop` . Containers are created and started
    with the `docker:start` and stopped and destroyed with the `docker:stop` . If
    you need to run the container during the integration tests, the typical use case
    will be to include those goals in Maven build phases: the `docker:start` will
    be bound to the `pre-integration-test` and `docker:stop` to the `post-integration-test`
    phase.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件提供了两个与启动和停止容器相关的Maven目标。这将是 `docker:start` 和 `docker:stop` 。使用 `docker:start`
    创建和启动容器，使用 `docker:stop` 停止和销毁容器。如果需要在集成测试期间运行容器，典型用例将是在Maven构建阶段中包含这些目标：`docker:start`
    将绑定到 `pre-integration-test`，`docker:stop` 绑定到 `post-integration-test` 阶段。
- en: Plugin configuration
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件配置
- en: 'The plugin uses the configuration from the `<run>` sub-element of the `<configuration>`
    in the `pom.xml` file. The list of the most important configuration elements is
    as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件使用 `pom.xml` 文件中 `<configuration>` 的 `<run>` 子元素中的配置。最重要的配置元素列表如下：
- en: '| `cmd` | Command which should be executed at the end of the container''s startup.
    If not given, the image''s default command is used. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `cmd` | 应在容器启动结束时执行的命令。如果未给出，则使用图像的默认命令。'
- en: '| `entrypoint` | Entry point for the container. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `entrypoint` | 容器的入口点。'
- en: '| `log` | Log configuration for whether and how log messages from the running
    containers should be printed. This can also configure the log driver to use. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `log` | 日志配置，用于控制是否以及如何打印运行容器的日志消息。这也可以配置要使用的日志驱动程序。'
- en: '| `memory` | Memory limit in bytes |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `memory` | 内存限制（以字节为单位）'
- en: '| n`amingStrategy` | Naming strategy for how the container name is created:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '| n`amingStrategy` | 容器名称创建的命名策略：'
- en: '`none` : Uses randomly assigned names from Docker (default)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：使用来自Docker的随机分配的名称（默认）'
- en: '`alias` : Uses the alias specified in the image configuration. An error is
    thrown, if a container already exists with this name.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`alias`：使用图像配置中指定的别名。如果已经存在具有此名称的容器，则会抛出错误。'
- en: '|'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `network` | The `<network>` element can be used to configure the network
    mode of the container. It knows the following sub elements:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '| `network` | `<network>` 元素可用于配置容器的网络模式。它知道以下子元素：'
- en: '`<mode>` : The network mode, which can be one of the following values:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<mode>`：网络模式，可以是以下值之一：'
- en: '`bridge` : Bridged mode with the default Docker bridge (default)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bridge`：使用默认的Docker桥接模式（默认）'
- en: '`host` : Share the Docker host network interfaces'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host`：共享Docker主机网络接口'
- en: '`container` : Connect to the network of the specified container'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`container`：连接到指定容器的网络'
- en: 'The name of the container is taken from the `<name>` element :'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的名称取自 `<name>` 元素：
- en: '`custom` : Use a custom network, which must be created before using Docker
    network create'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`custom`：使用自定义网络，必须在使用Docker网络创建之前创建'
- en: '`none` : No network will be setup'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`none`：不会设置网络'
- en: '|'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `ports` | The`<ports>` configuration contains a list of port mappings. Each
    mapping has multiple parts, each separate by a colon. This is equivalent to the
    port mapping when using the `docker run` command with option `-p` .An example
    entry can look same as this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '| `ports` | `<ports>` 配置包含端口映射的列表。每个映射有多个部分，每个部分由冒号分隔。这相当于使用 `docker run` 命令和
    `-p` 选项时的端口映射。一个示例条目可以看起来像这样：'
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '|'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `restartPolicy` | Provides a restart policy we''ve been discussing earlier
    in this chapter. An example entry can look same as following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '| `restartPolicy` | 提供了我们在本章前面讨论过的重启策略。一个示例条目可以看起来像下面这样：'
- en: '[PRE47]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `volumes` | Volume configuration for binding to host directories and from
    other containers. The example configuration could look same as following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '| `volumes` | 用于绑定到主机目录和其他容器的卷配置。示例配置可以看起来像下面这样：'
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '|'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The complete `<configuration>` element of our Java REST service can look same
    as following. This is a very basic example, we are only configuring the runtime
    port mapping here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Java REST服务的完整`<configuration>`元素可以看起来和以下一样。这是一个非常基本的例子，我们只在这里配置了运行时端口映射：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Having configured our container, let's try to run it, using Maven.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了我们的容器后，让我们尝试运行它，使用Maven。
- en: Starting and stopping containers
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动和停止容器
- en: 'To start-up the container, execute the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动容器，请执行以下操作：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Maven will build our REST service from source, build the image and start up
    the container in the background. As the output, we will be given the ID of the
    container, as you can see on the following screenshot:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Maven将从源代码构建我们的REST服务，构建镜像，并在后台启动容器。作为输出，我们将得到容器的ID，如你可以在以下截图中看到的那样：
- en: '![](Image00078.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00078.jpg)'
- en: 'The container is now running in the background. To test if it''s running, we
    could issue a `docker ps` to list all the running containers, or just call the
    service by executing some `HTTP` methods such as `GET` or `POST` on the mapped
    `8080` port. The port has been exposed in the`<build>` configuration element and
    exposed in the `<run>` configuration element. This is convenient, isn''t it? But
    what if we would like to see the container''s output instead of running it in
    the background? That''s also easy; let''s stop it first by issuing the following
    command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 容器现在在后台运行。要测试它是否在运行，我们可以发出`docker ps`命令来列出所有正在运行的容器，或者通过在映射的`8080`端口上执行一些`HTTP`方法，如`GET`或`POST`来调用服务。端口已在`<build>`配置元素中公开，并在`<run>`配置元素中公开。这很方便，不是吗？但是，如果我们想要看到容器的输出而不是在后台运行它怎么办？这也很容易；让我们首先通过发出以下命令来停止它：
- en: '[PRE51]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'After 10 seconds (as you''ll remember, it''s a default timeout before stopping
    the container), Maven will output a statement that the container has been stopped:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 10秒后（你会记得，这是在停止容器之前的默认超时时间），Maven将输出一个声明，表示容器已经停止：
- en: '[PRE52]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s run the container again, this time using the Maven `docker:run` goal
    instead of `docker:start` . Execute the following:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行容器，这次使用Maven的`docker:run`目标，而不是`docker:start`。执行以下操作：
- en: '[PRE53]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This time, Maven Docker plugin will run the container and we will see the Spring
    Boot banner on the console, as you can see on the following screenshot:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，Maven Docker插件将运行容器，我们将在控制台上看到Spring Boot横幅，如你可以在以下截图中看到的那样：
- en: '![](Image00079.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00079.jpg)'
- en: I guess you can identify the difference between `docker:start` and `docker:run`
    now. Correct, `docker:run` is the equivalent of option `-i` for the `docker run`
    command. The `docker:run` will also automatically switch on the `showLogs` option,
    so that you can see what is happening within the container. As an alternative,
    you can provide `docker.follow` as system property so that the `docker:start`
    will never return but block until *CTRL + C* is pressed, exactly the same as when
    you execute the `docker:run` Maven goal.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我猜你现在可以辨别`docker:start`和`docker:run`之间的区别了。正确，`docker:run`相当于`docker run`命令的`-i`选项。`docker:run`还会自动打开`showLogs`选项，这样你就可以看到容器内发生了什么。作为替代，你可以提供`docker.follow`作为系统属性，这样`docker:start`将永远不会返回，而是阻塞，直到按下*CTRL
    + C*，就像当你执行`docker:run` Maven目标时一样。
- en: 'As you can see, the Fabric8 Docker Maven plugin gives you the same control
    as you would have when running and stopping containers from the shell or the command
    line. But here comes the advantage of the Maven build process itself: you can
    automate things. The Docker containers can be now used during the build, the integration
    testing, and the continuous delivery flow you may have; you name it.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Fabric8 Docker Maven插件给了你与从shell或命令行运行和停止容器时一样的控制。但这里是Maven构建过程本身的优势：你可以自动化事情。Docker容器现在可以在构建过程中使用，集成测试和持续交付流程中使用；你说了算。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have learned how to manage the container's life, start it
    using different run modes (foreground and detached), stop or remove it. We also
    know how to create constraints to make our containers run exactly how we want
    them to, by limiting the CPU and RAM usage using runtime constraints. Having our
    containers running, we are now able to inspect the container's behavior in numerous
    ways, it will be reading log output, looking at events or browsing the statistics.
    If you are using Maven, and as the Java developer you probably are, you can now
    configure the Docker Maven plugin to start or stop containers for you automatically.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经学会了如何管理容器的生命周期，使用不同的运行模式（前台和后台）启动它，停止或删除它。我们还知道如何创建约束，使我们的容器按照我们想要的方式运行，通过使用运行时约束来限制CPU和RAM的使用。当我们的容器运行时，我们现在能够以多种方式检查容器的行为，比如读取日志输出，查看事件或浏览统计数据。如果你正在使用Maven，作为Java开发人员，你可能会配置Docker
    Maven插件，以便自动启动或停止容器。
- en: We know a lot about Docker already, we can build and run images. It's time to
    go further. We are going automate deployment, scaling, and management of containerized
    applications using Kubernetes. And this is the moment where the real fun begins.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对Docker有了很多了解，我们可以构建和运行镜像。现在是时候更进一步了。我们将使用Kubernetes自动化部署、扩展和管理容器化应用程序。这是真正有趣的时刻。
