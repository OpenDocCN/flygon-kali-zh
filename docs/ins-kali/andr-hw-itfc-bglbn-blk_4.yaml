- en: Chapter 4. Storing and Retrieving Data with I2C
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用I2C存储和检索数据
- en: In the last chapter, you used GPIOs to exchange simple digital data with the
    outside world. However, what about interfacing with more advanced devices that
    require complex sequences of bits or bytes for communication?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您使用GPIO与外部世界交换简单的数字数据。但是，如何与需要复杂的位序列或字节进行通信的更高级设备进行接口？
- en: 'One of the most popular interfacing buses in use today within embedded systems
    is the **Inter-Integrated Circuit** serial bus (commonly abbreviated as **IIC**,
    **I**2**C**, or **I2C**). In this chapter, you will learn how to write an app
    that uses the BBB''s I2C interface to store data to and retrieve data from a FRAM
    chip. We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 今天在嵌入式系统中使用最广泛的接口总线之一是**Inter-Integrated Circuit**串行总线（通常缩写为**IIC**、**I**2**C**或**I2C**）。在本章中，您将学习如何编写一个应用程序，该应用程序使用BBB的I2C接口将数据存储到FRAM芯片并从中检索数据。我们将涵盖以下主题：
- en: Understanding I2C
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解I2C
- en: Multiplexing for I2C on the BBB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BBB上的I2C复用
- en: Representing I2C devices in the Linux kernel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux内核中表示I2C设备
- en: Building an I2C interface circuit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建I2C接口电路
- en: Exploring the I2C FRAM example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索I2C FRAM示例应用程序
- en: Understanding I2C
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解I2C
- en: Originally developed by Philips Semiconductor in 1982 as a bus for communicating
    with the ICs, the I2C protocol has become a general-use bus that is supported
    by a wide variety of IC manufacturers. I2C is a multimaster and multislave bus,
    though the most common configuration is that of a single master device and one
    or more slave devices on a single bus. An I2C master device sets the pace for
    the bus by generating a clock signal, and it initiates communication with the
    slave devices. Slave devices receive the master's clock signal and respond to
    the master's queries.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: I2C协议最初由飞利浦半导体于1982年开发，用作与IC通信的总线，现已成为受多种IC制造商支持的通用总线。I2C是一种多主机和多从机总线，尽管最常见的配置是单主机设备和单总线上的一个或多个从机设备。
    I2C主设备通过生成时钟信号为总线设置节奏，并启动与从机设备的通信。从机设备接收主时钟信号并响应主设备的查询。
- en: 'Only four wires are required to communicate via I2C:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要四根导线即可通过I2C进行通信：
- en: One clock signal (SCL)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时钟信号（SCL）
- en: One data signal (SDA)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数据信号（SDA）
- en: A positive supply voltage
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正电源电压
- en: A ground
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地面
- en: Requiring only two pins (for the SCL and SDA signals) to communicate with a
    number of slave devices makes I2C an enticing interfacing option. One of the difficulties
    in hardware interfacing is effectively allocating a limited number of processor
    pins to best handle communicating with a large number of different devices simultaneously.
    By only requiring two processor pins to communicate with a variety of devices,
    I2C frees up pins that can now be allocated to other tasks.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要两根引脚（用于SCL和SDA信号）即可与多个从设备进行通信，这使得I2C成为一种诱人的接口选项。在硬件接口中的一个困难是有效地分配有限数量的处理器引脚，以最佳地处理与大量不同设备同时通信的任务。通过只需要两个处理器引脚与各种设备进行通信，I2C释放了可以用于其他任务的引脚。
- en: '![Understanding I2C](img/00014.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![理解I2C](img/00014.jpeg)'
- en: An example of the I2C bus with a single master device and three slave devices
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 具有单主设备和三个从设备的I2C总线示例
- en: Devices that use I2C
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用I2C的设备
- en: Due to the flexibility and wide usage of the I2C bus, there are many devices
    that use it for communication. Different varieties of storage devices, such as
    EEPROM and FRAM ICs, are commonly interfaced via I2C. For example, the EEPROMs
    present on BBB capes are all accessed by the BBB's processor via I2C. Sensors
    for temperature, pressure, and humidity, accelerometers, LCD controllers, and
    stepper motor controllers are all examples of devices that are available through
    the I2C bus.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于I2C总线的灵活性和广泛使用，有许多设备使用它进行通信。不同类型的存储设备，如EEPROM和FRAM IC，通常通过I2C进行接口。例如，BBB披风上的EEPROM都是通过I2C由BBB处理器访问的。温度、压力和湿度传感器、加速度计、LCD控制器和步进电机控制器都是可以通过I2C总线获得的设备的例子。
- en: Multiplexing for I2C on the BBB
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BBB上的I2C复用
- en: 'The AM335X processor of the BBB provides three I2C buses:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的AM335X处理器提供了三条I2C总线：
- en: I2C0
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C0
- en: I2C1
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C1
- en: I2C2
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I2C2
- en: The BBB exposes the I2C1 and I2C2 buses via its P9 header, but the I2C0 bus
    is not easily accessible. I2C0 currently provides the communication channel between
    the BBB's processor and the HDMI framer chip of the built-in HDMI cape, so it
    should be considered unavailable for your use (unless you would like to void your
    warranty by soldering wires directly to the traces and chip pins on the BBB).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: BBB通过其P9标头公开了I2C1和I2C2总线，但是I2C0总线不易访问。I2C0目前提供了BBB处理器与内置HDMI披风片上的HDMI帧器芯片之间的通信通道，因此应该考虑不可用于您的使用（除非您愿意通过直接焊接导线到BBB上的线路和芯片引脚来取消保修）。
- en: The I2C1 bus is available for your general use and is often the *go to* bus
    for I2C interfacing. If I2C1 is at its maximum capacity or unavailable, the I2C2
    bus is also available for your use.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: I2C1总线可供您一般使用，并且通常是I2C接口的*首选*总线。如果I2C1已达到最大容量或不可用，则I2C2总线也可供您使用。
- en: Connecting to I2C via the P9 header
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过P9标头连接到I2C
- en: By default, I2C1 is not muxed to any pins and I2C2 is available via the P9.19
    and P9.20 pins. I2C2 provides I2C communication between the identification EEPROMs
    present on external cape boards and the kernel's capemgr. You can mux I2C2 to
    other pins, or even disable it entirely, but if you do so, the capemgr will no
    longer be able to automatically detect the presence of cape boards that are attached
    to the BBB. Generally speaking, you probably do not want to do this.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，I2C1未复用到任何引脚，I2C2可通过P9.19和P9.20引脚使用。I2C2提供了外部披风板上的识别EEPROM和内核capemgr之间的I2C通信。您可以将I2C2复用到其他引脚，甚至完全禁用它，但如果这样做，capemgr将不再能够自动检测连接到BBB的披风板的存在。一般来说，您可能不想这样做。
- en: 'The following figure shows each of the potential pins on the P9 header where
    I2C signals can be muxed:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了P9标头上可以复用I2C信号的潜在引脚：
- en: '![Connecting to I2C via the P9 header](img/00015.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![通过P9标头连接到I2C](img/00015.jpeg)'
- en: Locations of the I2C buses on the P9 header with different pinmux modes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: P9标头上I2C总线的位置，具有不同的引脚复用模式
- en: Multiplexing for I2C
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I2C的复用
- en: 'When deciding how you would like your pins to be muxed when using I2C in your
    projects, keep the following items in mind:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中使用I2C时，决定在使用I2C时如何对引脚进行复用时，请记住以下几点：
- en: Avoid muxing any single I2C signal to more than one pin. Doing so wastes one
    of your pins for no good reason.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将任何单个I2C信号复用到多个引脚。这样做没有好处，浪费了一个引脚。
- en: Avoid muxing I2C2 away from its default location, as this prevents the capemgr
    from automatically detecting cape boards connected to the BBB.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免将I2C2从其默认位置复用，因为这会阻止capemgr自动检测连接到BBB的cape板。
- en: You can use the default I2C2 bus for your own projects, but note that it is
    clocked at 100 KHz and the addresses 0x54 through 0x57 are reserved for cape EEPROMs.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为自己的项目使用默认的I2C2总线，但请注意，它的时钟速度为100 KHz，地址0x54到0x57保留给cape EEPROM。
- en: Muxing the I2C1 channel to P9.17 and P9.18 conflicts with the SPI0 channel,
    so you generally wouldn't want to use this configuration if you also wish to use
    SPI.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将I2C1通道复用到P9.17和P9.18与SPI0通道冲突，因此如果您还希望使用SPI，则通常不希望使用此配置。
- en: Representing I2C devices in the Linux kernel
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux内核中表示I2C设备
- en: I2C buses and devices are exposed in user space as files in the `/dev` filesystem.
    I2C buses are exposed as the `/dev/i2c-X` file, where `X` is the logical number
    of the I2C channel. While the hardware signals for the I2C bus are clearly numbered
    as 0, 1, and 2, the logical channel numbers won't necessarily be the same as their
    hardware counterparts.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: I2C总线和设备在用户空间中作为`/dev`文件系统中的文件公开。I2C总线公开为`/dev/i2c-X`文件，其中`X`是I2C通道的逻辑编号。虽然I2C总线的硬件信号明确编号为0、1和2，但逻辑通道号不一定与其硬件对应物相同。
- en: Logical channel numbers are assigned in the order that the I2C channels are
    initialized in the Device Tree. For example, the I2C2 channel is usually the second
    I2C channel initialized by the kernel. Therefore, even though it is physical I2C
    channel 2, it will be logical I2C channel 1 and accessible as the `/dev/i2c-1`
    file.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑通道号按照设备树中初始化的I2C通道的顺序分配。例如，I2C2通道通常是内核初始化的第二个I2C通道。因此，即使它是物理I2C通道2，它将成为逻辑I2C通道1，并且可以作为`/dev/i2c-1`文件访问。
- en: Underneath all of the layers of Android APIs and services, Android ultimately
    interacts with device drivers in the kernel by opening files in the `/dev` and
    `/sys` filesystems and then reading, writing, or performing `ioctl()` calls on
    those files. While it is possible to interact with any I2C device using only the
    `ioctl()` calls on the `/dev/i2c-X` files to directly control the I2C bus, this
    approach is complicated and generally should be avoided. Instead, you should try
    to use a kernel driver that communicates with your device on the I2C bus for you.
    You can then make `ioctl()` calls on the file exposed by that kernel driver to
    easily control your device.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有Android API和服务的层下面，Android最终通过在`/dev`和`/sys`文件系统中打开文件，然后读取、写入或执行`ioctl()`调用来与内核中的设备驱动程序交互。虽然可以仅使用`/dev/i2c-X`文件上的`ioctl()`调用与任何I2C设备交互，直接控制I2C总线，但这种方法很复杂，通常应该避免。相反，您应该尝试使用一个与I2C总线上的设备通信的内核驱动程序。然后，您可以对该内核驱动程序公开的文件进行`ioctl()`调用，轻松控制您的设备。
- en: Preparing Android for FRAM use
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为FRAM使用准备Android
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files to your
    Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable a kernel device driver that handles FRAM
    interfacing, mux the pins to enable the I2C1 bus, and allow your apps to access
    it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "第2章。与Android接口")*与Android接口*中，您使用`adb`将两个预构建文件推送到Android系统。这两个文件，`BB-PACKTPUB-00A0.dtbo`和`init.{ro.hardware}.rc`，配置您的Android系统以启用处理FRAM接口的内核设备驱动程序，复用引脚以启用I2C1总线，并允许您的应用程序访问它。
- en: 'As far as I2C is concerned, the `BB-PACKTPUB-00A0.dtbo` overlay muxes the P9.24
    and P9.26 pins into the I2C SCL and SDA signals. In the `PacktHAL.tgz` file, the
    source code for the overlay is located in the `cape/BB-PACKTPUB-00A0.dts` file.
    The code responsible for muxing these two pins is located in the `bb_i2c1a1_pins`
    node within `fragment@0`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就I2C而言，`BB-PACKTPUB-00A0.dtbo`叠加将P9.24和P9.26引脚复用为I2C SCL和SDA信号。在`PacktHAL.tgz`文件中，叠加的源代码位于`cape/BB-PACKTPUB-00A0.dts`文件中。负责复用这两个引脚的代码位于`fragment@0`中的`bb_i2c1a1_pins`节点中。
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this sets up the muxing, it doesn''t assign and configure a device driver
    to these pins. The `fragment@1` node performs this kernel driver allocation:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这设置了复用，但它并没有为这些引脚分配和配置设备驱动程序。`fragment@1`节点执行此内核驱动程序分配：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Without going into too much detail, there are four settings in `fragment@1`
    that are of interest to you:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不详细介绍，`fragment@1`中有四个您感兴趣的设置：
- en: The first setting is `pinctrl-0`, which ties this node of the Device Tree to
    the pins muxed in the `bb_i2c1a1_pins` node
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个设置是`pinctrl-0`，它将设备树的这个节点与`bb_i2c1a1_pins`节点中复用的引脚联系起来
- en: The second setting is `clock-frequency`, which sets the I2C bus speed to 400
    KHz
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个设置是`clock-frequency`，它将I2C总线速度设置为400 KHz
- en: The third setting is `compatible`, which specifies the particular kernel driver
    (the `24c256` driver for EEPROM-like devices) that will handle our hardware device
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个设置是`compatible`，它指定了将处理我们的硬件设备的特定内核驱动程序（用于类似EEPROM的`24c256`驱动程序）
- en: The last setting is `reg`, which specifies the address on the I2C bus where
    this device will reside (`0x50`, in our case)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个设置是`reg`，它指定了该设备将驻留在I2C总线上的地址（在我们的情况下为`0x50`）
- en: Building an I2C-interfacing circuit
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建I2C接口电路
- en: Now that you have an understanding of where I2C devices are connected to the
    BBB and how the Linux kernel presents an interface to those devices, it is time
    to connect an I2C device to the BBB.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了I2C设备连接到BBB的位置以及Linux内核如何向这些设备提供接口，是时候将I2C设备连接到BBB了。
- en: As we mentioned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction
    to Android and the BeagleBone Black"), *Introduction to Android and the BeagleBone
    Black*, you will be interfacing with a FRAM chip in this chapter. Specifically,
    it is a Fujitsu Semiconductor MB85RC256V FRAM chip. This 8-pin chip provides 32
    KB of nonvolatile storage. This particular chip is only available in a **small
    outline package** (**SOP**), which is a surface mount chip that can be difficult
    to work with when building prototype circuits. Luckily for us, the AdaFruit breakout
    board for the FRAM already has the chip mounted, which makes prototyping simple
    and easy.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0014_split_000.html#page "第1章。Android和BeagleBone Black简介")中提到的，*Android和BeagleBone
    Black简介*，在本章中您将与FRAM芯片进行接口。具体来说，它是富士通半导体MB85RC256V FRAM芯片。这个8引脚芯片提供32KB的非易失性存储。这个特定的芯片只能以**小外形封装**（**SOP**）的形式获得，这是一种表面贴装芯片，在构建原型电路时可能会很难处理。幸运的是，AdaFruit的FRAM分线板已经安装了芯片，这使得原型设计变得简单和容易。
- en: Tip
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t disassemble your circuit!**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不要拆卸你的电路！
- en: The FRAM circuit in this chapter is part of a much larger circuit used in [Chapter
    6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing Solution"),
    *Creating a Complete Interfacing Solution*. If you build the circuit as positioned
    in the diagram (towards the bottom of the breadboard), you can simply leave the
    FRAM breakout board and wires in place as you build the remaining circuits in
    this book. This way, it will already be constructed and working when you reach
    [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing
    Solution").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的FRAM电路是[第6章](part0041_split_000.html#page "第6章。创建完整的接口解决方案")中使用的一个更大电路的一部分，*创建完整的接口解决方案*。如果按照图示中的位置（靠近面包板底部）构建电路，您可以在构建本书中的其余电路时将FRAM分线板和导线留在原位。这样，当您到达[第6章](part0041_split_000.html#page
    "第6章。创建完整的接口解决方案")时，它已经被构建并且可以正常工作。
- en: Connecting the FRAM
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接FRAM
- en: Each I2C device must use an address to identify itself on the I2C bus. The FRAM
    chip that we are using can be configured to use an address in the range of 0x50
    to 0x57\. This is a common address range for EEPROM devices. The exact address
    is set by using the address lines (A0, A1, A2) of the breakout board. The FRAM
    has a base address of 0x50\. If the A0, A1, and/or A2 lines are connected to a
    3.3 V signal, 0x1, 0x2, and/or 0x4 are added to the address, respectively. For
    this interfacing project, none of the addressing lines are connected, which results
    in the FRAM retaining its base address of 0x50 on the I2C bus.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 每个I2C设备必须使用一个地址在I2C总线上标识自己。我们使用的FRAM芯片可以配置为使用0x50到0x57的地址范围。这是EEPROM设备的常见地址范围。确切的地址是通过使用分线板的地址线（A0、A1、A2）来设置的。FRAM的基地址是0x50。如果A0、A1和/或A2线连接到3.3V信号，则分别向地址添加0x1、0x2和/或0x4。对于这个接口项目，没有连接任何寻址线，这导致FRAM在I2C总线上保留其基地址0x50。
- en: '![Connecting the FRAM](img/00016.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![连接FRAM](img/00016.jpeg)'
- en: The FRAM breakout board (the A0, A1, and A2 addressing lines are the three right-most
    terminals of the board)
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: FRAM分线板（A0、A1和A2寻址线是板的最右侧三个端子）
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The addresses of many I2C devices are configurable by connecting the address
    pins of the device to either the ground or voltage signals. This is because there
    can be multiple copies of the same device on a single I2C bus. The circuit designer
    can assign a different address to each device by rewiring the address pins, rather
    than having to buy different parts with different pre-assigned addresses that
    do not conflict with each other.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 许多I2C设备的地址可以通过将设备的地址引脚连接到地线或电压信号来配置。这是因为在单个I2C总线上可以有多个相同设备的副本。电路设计师可以通过重新连接地址引脚为每个设备分配不同的地址，而不必购买具有不同预分配地址且不会相互冲突的不同零件。
- en: The following figure shows the connections between the FRAM breakout board and
    the BBB. The four main I2C bus signals (+3.3 V, ground, and I2C SCL/SDA) are made
    using the pins of the P9 connector, so we've placed the breadboard on the P9 side
    of the BBB.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了FRAM分线板与BBB之间的连接。使用P9连接器的引脚进行了四个主要的I2C总线信号（+3.3V、地线和I2C SCL/SDA）连接，因此我们将面包板放在了BBB的P9侧。
- en: '![Connecting the FRAM](img/00017.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![连接FRAM](img/00017.jpeg)'
- en: The complete I2C-interfacing circuit
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的I2C接口电路
- en: 'Let''s get started:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Connect P9.1 (ground) to the vertical ground bus of the breadboard and connect
    P9.3 (3.3 V) to the vertical VCC bus of the breadboard. These connections are
    identical to the ones made for the GPIO breadboard circuit that you created in
    [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将P9.1（地线）连接到面包板的垂直地线总线，将P9.3（3.3V）连接到面包板的垂直VCC总线。这些连接与您在[第3章](part0024_split_000.html#page
    "第3章。使用GPIO处理输入和输出")中创建的GPIO面包板电路相同。
- en: The I2C signals, SCL and SDA, are on the P9.24 and P9.26 pins, respectively.
    Wire the P9.24 pin to the pin marked SCL on the breakout board, and wire the P9.26
    pin to the pin marked SDA on the breakout board.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: I2C信号SCL和SDA分别在P9.24和P9.26引脚上。将P9.24引脚连接到分线板上标有SCL的引脚上，将P9.26引脚连接到分线板上标有SDA的引脚上。
- en: Wire the ground bus to the GND pin of the breakout board and wire the VCC bus
    to the VCC pin of the breakout board. Leave the **write protect** (**WP**) pin
    and the three address pins (A0, A1, A2) unconnected.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地线总线连接到分线板的GND引脚，将VCC总线连接到分线板的VCC引脚。将**写保护**（**WP**）引脚和三个地址引脚（A0、A1、A2）保持未连接状态。
- en: The FRAM breakout board is now electrically connected to the BBB and is ready
    for your use. Double-check your wiring against the diagram of the complete FRAM
    interfacing circuit to ensure that everything is connected properly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: FRAM分线板现在已经电气连接到BBB，并且可以使用。请仔细检查您的布线，确保一切连接正确，与完整的FRAM接口电路图相符。
- en: Checking the FRAM connection with I2C tools
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用I2C工具检查FRAM连接
- en: The I2C tools are a set of utilities that allow you to probe and interact with
    the I2C bus. These tools work on systems that use a Linux kernel, and they are
    included in the BBBAndroid image. The utilities interact with the I2C bus by opening
    the `/dev/i2c-X` device files and making `ioctl()` calls on them. By default,
    you must have root access to use `i2c-tools`, but BBBAndroid reduces the permissions
    on the `/dev/i2c-X` files so that any process (including `i2c-tools`) can read
    and write information about the I2C buses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: I2C工具是一组实用程序，允许您探测和与I2C总线交互。这些工具适用于使用Linux内核的系统，并包含在BBBAndroid映像中。这些实用程序通过打开`/dev/i2c-X`设备文件并对其进行`ioctl()`调用与I2C总线进行交互。默认情况下，您必须具有root访问权限才能使用`i2c-tools`，但BBBAndroid降低了`/dev/i2c-X`文件的权限，以便任何进程（包括`i2c-tools`）都可以读取和写入有关I2C总线的信息。
- en: 'As an example, let''s try using the `i2cdetect` utility in `i2c-tools`. `i2cdetect`
    will sweep a specified I2C bus and identify bus addresses where I2C devices are
    located. Using the ADB shell, you will probe the i2c-2 physical bus, which is
    also the second logical bus (`/dev/i2c-1`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们尝试使用`i2c-tools`中的`i2cdetect`实用程序。`i2cdetect`将扫描指定的I2C总线，并识别I2C设备所在的总线地址。使用ADB
    shell，您将探测i2c-2物理总线，这也是第二个逻辑总线（`/dev/i2c-1`）：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The output of `i2cdetect` shows every device detected on the current bus. Any
    address that is not in use has a `--` identifier. Any address that is reserved
    for a device driver in the Device Tree, but does not currently have a device located
    at that address, has a `UU` identifier. If a device is detected at a particular
    address, the device's two-digit hexadecimal address will appear as an identifier
    in the `i2cdetect` output.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cdetect`的输出显示了当前总线上检测到的每个设备。未使用的任何地址都有`--`标识符。为设备树中的设备驱动程序保留的任何地址，但当前没有设备位于该地址上，都有`UU`标识符。如果在特定地址检测到设备，则设备的两位十六进制地址将出现在`i2cdetect`输出中作为标识符。'
- en: The output of `i2cdetect` shows that the Device Tree has allocated drivers for
    four I2C devices on the i2c-2 physical bus. These four devices are the EEPROMs
    at addresses 0x54-0x57 of the capemgr. The devices aren't actually present because
    no cape boards are connected to the BBB, so each address has a `UU` identifier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`i2cdetect`的输出显示，设备树已为i2c-2物理总线上的四个I2C设备分配了驱动程序。这四个设备是capemgr地址为0x54-0x57的EEPROM。实际上这些设备并不存在，因为没有cape板连接到BBB，所以每个地址都有一个`UU`标识符。'
- en: 'After the FRAM breakout board is electrically connected to the BBB, you must
    verify that the FRAM is a visible device on the I2C bus. To do this, use `i2cdetect`
    to examine the devices present on the i2c-1 physical bus (logical bus 2):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将FRAM扩展板电连接到BBB后，您必须验证FRAM是否在I2C总线上可见。为此，请使用`i2cdetect`检查i2c-1物理总线（逻辑总线2）上存在的设备：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Double-check your wiring**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**仔细检查您的接线**'
- en: If the `i2cdetect` output shows a `UU` at the 0x50 address location, you know
    that the I2C bus does not recognize the FRAM as being attached. Make sure that
    you don't accidentally swap the SCL (P9.24) and SDA (P9.26) wires when connecting
    the FRAM breakout board to the BBB.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`i2cdetect`的输出显示0x50地址位置有`UU`，则说明I2C总线未识别出连接的FRAM。确保在连接FRAM扩展板到BBB时不要意外交换SCL（P9.24）和SDA（P9.26）线。
- en: Exploring the I2C FRAM example app
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索I2C FRAM示例应用程序
- en: In this section, we will examine our example Android app that interfaces with
    the FRAM using I2C on BBB. The purpose of this application is to demonstrate how
    to use PacktHAL to perform FRAM reads and writes from within an actual app. PacktHAL
    provides a set of interfacing functions that you will use to work with the FRAM
    from within your Android apps. These functions allow you to retrieve blocks of
    data from the FRAM and write new data to be stored on the FRAM. The low-level
    details of the hardware interfacing are implemented in PacktHAL, so you can quickly
    and easily get your apps interacting with the FRAM breakout board.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将检查我们的示例Android应用程序，该应用程序使用BBB上的I2C与FRAM进行接口。此应用程序的目的是演示如何使用PacktHAL从实际应用程序中执行FRAM读取和写入。PacktHAL提供了一组接口函数，您将使用这些函数来处理Android应用程序中的FRAM。这些函数允许您从FRAM中检索数据块，并写入新数据以存储在FRAM上。硬件接口的底层细节在PacktHAL中实现，因此您可以快速轻松地使您的应用程序与FRAM扩展板进行交互。
- en: Before digging through the FRAM app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app as well as the precompiled `.apk` package, are located in the `chapter4.tgz`
    file, which is available for download from the Packt website. Follow the same
    process to download and add the app to your Eclipse ADT environment that was described
    in [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究FRAM应用程序的代码之前，您必须将代码安装到开发系统并将应用程序安装到Android系统。应用程序的源代码以及预编译的`.apk`包都位于`chapter4.tgz`文件中，该文件可从Packt网站下载。按照[第3章](part0024_split_000.html#page
    "第3章。使用GPIO处理输入和输出")中描述的相同过程下载并将应用程序添加到Eclipse ADT环境中。
- en: The app's user interface
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的用户界面
- en: Launch the `fram` app on the Android system to see the app's UI. If you are
    using a touchscreen cape, you can simply touch the **fram** app icon on the screen
    to launch the app and interact with its UI. If you are using the HDMI for video,
    connect a USB mouse to the BBB's USB port and use the mouse to click on the **fram**
    app icon to launch the app. As this app accepts text input from the user, you
    might find it convenient to connect a USB keyboard to the BBB. Otherwise, you'll
    be able to use the onscreen Android keyboard to input text.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android系统上启动`fram`应用程序以查看应用程序的用户界面。如果您使用触摸屏cape，只需触摸屏幕上的**fram**应用程序图标即可启动应用程序并与其用户界面进行交互。如果您使用HDMI进行视频，将USB鼠标连接到BBB的USB端口，并使用鼠标单击**fram**应用程序图标以启动应用程序。由于此应用程序接受用户的文本输入，因此您可能会发现将USB键盘连接到BBB很方便。否则，您可以使用屏幕上的Android键盘输入文本。
- en: This app's UI is a bit more complex than that of the GPIO app in the last chapter,
    but it is still fairly simple. As it is so simple, the only activity that the
    app has is the default `MainActivity`. The UI consists of two text fields, two
    buttons, and two text views.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用的用户界面比上一章的GPIO应用复杂一些，但仍然相当简单。因为它非常简单，所以应用程序只有默认的`MainActivity`活动。用户界面包括两个文本字段、两个按钮和两个文本视图。
- en: '![The app''s user interface](img/00018.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的用户界面](img/00018.jpeg)'
- en: The FRAM sample app screen
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: FRAM示例应用程序屏幕
- en: The top text field has the `saveEditText` identifier in the `activity_main.xml`
    file. The `saveEditText` field accepts up to 60 characters that will be stored
    to the FRAM. The top button with the **Save** label has the `saveButton` identifier.
    This button has an `onClick()` method called `onClickSaveButton()` that triggers
    the process of interfacing with the FRAM to store the text contained within the
    `saveEditText` text field.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部文本字段在`activity_main.xml`文件中具有`saveEditText`标识符。`saveEditText`字段最多接受60个字符，这些字符将被存储到FRAM中。带有**保存**标签的顶部按钮具有`saveButton`标识符。该按钮具有一个名为`onClickSaveButton()`的`onClick()`方法，触发与FRAM进行接口的过程，以存储`saveEditText`文本字段中包含的文本。
- en: The bottom text field has the `loadEditText` identifier. This text field will
    display any data that is held in the FRAM. The bottom button with the **Load**
    label has the `loadButton` identifier. This button has an `onClick()` method called
    `onClickLoadButton()` that triggers the process of interfacing with the FRAM to
    load the first 60 bytes of data and then updating the text displayed in the `loadEditText`
    text field.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 底部文本字段具有`loadEditText`标识符。该文本字段将显示FRAM中保存的任何数据。带有**加载**标签的底部按钮具有`loadButton`标识符。该按钮具有一个名为`onClickLoadButton()`的`onClick()`方法，触发与FRAM进行接口的过程，加载前60个字节的数据，然后更新`loadEditText`文本字段中显示的文本。
- en: Calling the PacktHAL FRAM functions
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用PacktHAL FRAM函数
- en: 'The FRAM interface functionality in PacktHAL is implemented in four C functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL中的FRAM接口功能是通过四个C函数实现的：
- en: '`openFRAM()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openFRAM()`'
- en: '`readFRAM()`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readFRAM()`'
- en: '`writeFRAM()`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writeFRAM()`'
- en: '`closeFRAM()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeFRAM()`'
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file within the app''s project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的原型位于应用程序项目中的`jni/PacktHAL.h`头文件中：
- en: '[PRE4]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `openFRAM()` function opens the file in the `/dev` filesystem that provides
    the interface to the 24c256 EEPROM kernel driver. Its counterpart function is
    `closeFRAM()`, which closes this file once hardware interfacing with the FRAM
    is no longer needed. The `readFRAM()` function reads a buffer of data from the
    FRAM, and the `writeFRAM()` function writes a buffer of data to the FRAM for persistent
    storage. Together, these four functions provide all of the necessary functionality
    that you need to interact with the FRAM.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`openFRAM()`函数打开`/dev`文件系统中提供24c256 EEPROM内核驱动程序接口的文件。它的对应函数是`closeFRAM()`，一旦不再需要与FRAM进行硬件接口，就会关闭该文件。`readFRAM()`函数从FRAM读取数据缓冲区，`writeFRAM()`函数将数据缓冲区写入FRAM以进行持久存储。这四个函数一起提供了与FRAM交互所需的所有必要功能。'
- en: 'Just like the `gpio` app from the previous chapter, the `fram` app loads the
    PacktHAL shared library via a `System.loadLibrary()` call to access the PacktHAL
    FRAM interface functions and the JNI wrapper functions that call them. However,
    unlike the `gpio` app, the `MainActivity` class of the `fram` app does not specify
    methods with the `native` keyword to call the PacktHAL JNI-wrapper C functions.
    Instead, it leaves the hardware interfacing to an *asynchronous task* class named
    `HardwareTask`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的`gpio`应用程序一样，`fram`应用程序通过`System.loadLibrary()`调用加载PacktHAL共享库，以访问PacktHAL
    FRAM接口函数和调用它们的JNI包装函数。但是，与`gpio`应用程序不同，`fram`应用程序的`MainActivity`类没有指定带有`native`关键字的方法来调用PacktHAL
    JNI包装器C函数。相反，它将硬件接口留给了名为`HardwareTask`的*异步任务*类：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Understanding the AsyncTask class
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解AsyncTask类
- en: '`HardwareTask` extends the `AsyncTask` class, and using it provides a major
    advantage over the way hardware interfacing is implemented in the `gpio` app.
    `AsyncTask`s allows you to perform complex and time-consuming hardware-interfacing
    tasks without your app becoming unresponsive while the tasks are executed. Each
    instance of an `AsyncTask` class can create a new **thread of execution** within
    Android. This is similar to how multithreaded programs found on other OSes spin
    new threads to handle file and network I/O, manage UIs, and perform parallel processing.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareTask`扩展了`AsyncTask`类，并且使用它相比`gpio`应用程序中实现的硬件接口方式具有重大优势。`AsyncTask`允许您执行复杂和耗时的硬件接口任务，而应用程序在执行这些任务时不会变得无响应。每个`AsyncTask`类的实例都可以在Android中创建一个新的**执行线程**。这类似于其他操作系统上找到的多线程程序，它们会旋转新线程来处理文件和网络I/O，管理UI，并执行并行处理。'
- en: In the previous chapter, the `gpio` app only used a single thread during its
    execution. This thread is the main UI thread that is part of all Android apps.
    The UI thread is designed to handle UI events as quickly as possible. When you
    interact with a UI element, that element's handler method is called by the UI
    thread. For example, clicking a button causes the UI thread to invoke the button's
    `onClick()` handler. The `onClick()` handler then executes a piece of code and
    returns to the UI thread.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，`gpio`应用程序在执行期间只使用了一个线程。这个线程是所有Android应用程序的主UI线程的一部分。UI线程旨在尽快处理UI事件。当您与UI元素交互时，UI线程会调用该元素的处理程序方法。例如，单击按钮会导致UI线程调用按钮的`onClick()`处理程序。`onClick()`处理程序然后执行一段代码并返回到UI线程。
- en: Android is constantly monitoring the execution of the UI thread. If a handler
    takes too long to finish its execution, Android shows an **Application Not Responding**
    (**ANR**) dialog to the user. You *never* want an ANR dialog to appear to the
    user. It is a sign that your app is running inefficiently (or even not at all!)
    by spending too much time in handlers within the UI thread.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Android不断监视UI线程的执行。如果处理程序花费太长时间来完成执行，Android会向用户显示**应用程序无响应**（**ANR**）对话框。您*绝对不希望*出现ANR对话框。这表明您的应用程序在UI线程的处理程序中花费太多时间，运行效率低下（甚至根本没有运行！）。
- en: '![Understanding the AsyncTask class](img/00019.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![理解AsyncTask类](img/00019.jpeg)'
- en: The Application Not Responding dialog in Android
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Android中的应用程序无响应对话框
- en: The `gpio` app in the last chapter performed reads and writes of the GPIO states
    very quickly from within the UI thread, so the risk of triggering the ANR was
    very small. Interfacing with the FRAM is a much slower process. With the BBB's
    I2C bus clocked at its maximum speed of 400 KHz, it takes approximately 25 microseconds
    to read or write a byte of data when using the FRAM. While this is not a major
    concern for small writes, reading or writing the entire 32,768 bytes of the FRAM
    can take close to a full second to execute!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的`gpio`应用程序从UI线程中非常快速地执行GPIO状态的读写，因此触发ANR的风险非常小。与FRAM的接口速度要慢得多。使用BBB的I2C总线以其最大速度400
    KHz时，使用FRAM读写一个字节的数据大约需要25微秒。虽然这对于小写入来说不是一个主要问题，但是读取或写入整个32,768字节的FRAM可能需要接近一秒的时间来执行！
- en: Multiple reads and writes of the full FRAM can easily trigger the ANR dialog,
    so it is necessary to move these time-consuming activities out of the UI thread.
    By placing your hardware interfacing into its own `AsyncTask` class, you decouple
    the execution of these time-intensive tasks from the execution of the UI thread.
    This prevents your hardware interfacing from potentially triggering the ANR dialog.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 多次读写整个FRAM很容易触发ANR对话框，因此有必要将这些耗时的活动移出UI线程。通过将硬件接口放入自己的`AsyncTask`类中，您可以将这些耗时的任务的执行与UI线程的执行分离开来。这可以防止您的硬件接口潜在地触发ANR对话框。
- en: Learning the details of the HardwareTask class
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习HardwareTask类的细节
- en: 'The `AsyncTask` base class of `HardwareTask` provides many different methods,
    which you can further explore by referring to the Android API documentation. The
    four `AsyncTask` methods that are of immediate interest for our hardware-interfacing
    efforts are:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareTask`的基类`AsyncTask`提供了许多不同的方法，您可以通过参考Android API文档进一步探索。对于我们的硬件接口工作，四个`AsyncTask`方法是立即感兴趣的：'
- en: '`onPreExecute()`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPreExecute()`'
- en: '`doInBackground()`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doInBackground()`'
- en: '`onPostExecute()`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute()`'
- en: '`execute()`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`'
- en: Of these four methods, only the `doInBackground()` method executes within its
    own thread. The other three methods all execute within the context of the UI thread.
    Only the methods that execute within the UI thread context are able to update
    screen UI elements.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这四种方法中，只有`doInBackground()`方法在自己的线程中执行。其他三种方法都在UI线程的上下文中执行。只有在UI线程上下文中执行的方法才能更新屏幕UI元素。
- en: '![Learning the details of the HardwareTask class](img/00020.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![学习HardwareTask类的细节](img/00020.jpeg)'
- en: The thread contexts in which the HardwareTask methods and the PacktHAL functions
    are executed
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: HardwareTask方法和PacktHAL函数执行的线程上下文
- en: 'Much like the `MainActivity` class of the `gpio` app in the last chapter, the
    `HardwareTask` class provides four `native` methods that are used to call PacktHAL
    JNI functions related to FRAM hardware interfacing:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章中`gpio`应用程序的`MainActivity`类一样，`HardwareTask`类提供了四个`native`方法，用于调用与FRAM硬件接口相关的PacktHAL
    JNI函数：
- en: '[PRE6]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `openFRAM()` method initializes your app's access to a FRAM located on a
    logical I2C bus (the `bus` parameter) and at a particular bus address (the `address`
    parameter). Once the connection to a particular FRAM is initialized via an `openFRAM()`
    call, all `readFRAM()` and `writeFRAM()` calls will be applied to that FRAM until
    a `closeFRAM()` call is made.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`openFRAM()`方法初始化您的应用程序对逻辑I2C总线（`bus`参数）上的FRAM的访问，并且在特定总线地址（`address`参数）上。一旦通过`openFRAM()`调用初始化了与特定FRAM的连接，所有`readFRAM()`和`writeFRAM()`调用都将应用于该FRAM，直到进行`closeFRAM()`调用。'
- en: The `readFRAM()` method will retrieve a series of bytes from the FRAM and return
    it as a Java `String`. A total of `bufferSize` bytes are retrieved starting at
    an offset of `offset` bytes from the start of the FRAM. The `writeFRAM()` method
    will store a series of bytes to the FRAM. A total of `bufferSize` characters from
    the Java string `buffer` are stored in the FRAM started at an offset of `offset`
    bytes from the start of the FRAM.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFRAM()`方法将从FRAM中检索一系列字节，并将其作为Java `String`返回。从FRAM的起始偏移`offset`字节开始检索`bufferSize`字节。`writeFRAM()`方法将一系列字节存储到FRAM中。从Java字符串`buffer`中存储`bufferSize`个字符，从FRAM的起始偏移`offset`字节开始存储。'
- en: 'In the `fram` app, the `onClick()` handlers for the **Load** and **Save** buttons
    in the `MainActivity` class each instantiate a new `HardwareTask`. Immediately
    after the instantiation of `HardwareTask`, either the `loadFromFRAM()` or `saveToFRAM()`
    method is called to begin interacting with the FRAM:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在`fram`应用程序中，`MainActivity`类中**Load**和**Save**按钮的`onClick()`处理程序各自实例化一个新的`HardwareTask`。在实例化`HardwareTask`之后，立即调用`loadFromFRAM()`或`saveToFRAM()`方法开始与FRAM进行交互：
- en: '[PRE7]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both the `loadFromFRAM()` and `saveToFRAM()` methods in the `HardwareTask`
    class call the base `AsyncTask` class `execution()` method to begin the new thread
    creation process:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareTask`类中的`loadFromFRAM()`和`saveToFRAM()`方法都调用基类`AsyncTask`类的`execution()`方法来开始新线程的创建过程：'
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each `AsyncTask` instance can only have its `execute()` method called once.
    If you need to run an `AsyncTask` a second time, you must instantiate a new instance
    of it and call the `execute()` method of the new instance. This is why we instantiate
    a new instance of `HardwareTask` in the `onClick()` handlers of the **Load** and
    **Save** buttons, rather than instantiating a single `HardwareTask` instance and
    then calling its `execute()` method many times.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`AsyncTask`实例只能调用其`execute()`方法一次。如果需要第二次运行`AsyncTask`，必须实例化一个新实例并调用新实例的`execute()`方法。这就是为什么在**Load**和**Save**按钮的`onClick()`处理程序中实例化一个新的`HardwareTask`实例，而不是实例化一个单一的`HardwareTask`实例然后多次调用其`execute()`方法。
- en: 'The `execute()` method automatically calls the `onPreExecute()` method of the
    `HardwareTask` class. The `onPreExecute()` method performs any initialization
    that must occur prior to the start of the new thread. In the `fram` app, this
    requires disabling various UI elements and calling `openFRAM()` to initialize
    the connection to the FRAM via PacktHAL:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()`方法会自动调用`HardwareTask`类的`onPreExecute()`方法。`onPreExecute()`方法执行任何必须在新线程启动之前发生的初始化。在`fram`应用中，这需要禁用各种UI元素，并调用`openFRAM()`来通过PacktHAL初始化与FRAM的连接：'
- en: '[PRE9]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Disabling your UI elements**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用UI元素**'
- en: When you are performing a background operation, you might wish to keep your
    app's user from providing more input until the operation is complete. During a
    FRAM read or write, we do not want the user to press any UI buttons or change
    the data held within the `saveText` text field. If your UI elements remain enabled
    all the time, the user can launch multiple `AsyncTask` instances simultaneously
    by repeatedly hitting the UI buttons. To prevent this, disable any UI elements
    required to restrict user input until that input is necessary.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行后台操作时，可能希望在操作完成之前阻止应用的用户提供更多输入。在进行FRAM读取或写入时，我们不希望用户按下任何UI按钮或更改`saveText`文本字段中保存的数据。如果您的UI元素始终保持启用状态，用户可以通过反复点击UI按钮同时启动多个`AsyncTask`实例。为了防止这种情况发生，禁用任何需要限制用户输入的UI元素，直到输入是必要的。
- en: Once the `onPreExecute()` method finishes, the `AsyncTask` base class spins
    a new thread and executes the `doInBackground()` method within that thread. The
    lifetime of the new thread is only for the duration of the `doInBackground()`
    method. Once `doInBackground()` returns, the new thread will terminate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`onPreExecute()`方法完成，`AsyncTask`基类会启动一个新线程，并在该线程内执行`doInBackground()`方法。新线程的生命周期仅限于`doInBackground()`方法的持续时间。一旦`doInBackground()`返回，新线程将终止。
- en: 'As everything that takes place within the `doInBackground()` method is performed
    in a background thread, it is the perfect place to perform any time-consuming
    activities that would trigger an ANR dialog if they were executed from within
    the UI thread. This means that the slow `readFRAM()` and `writeFRAM()` calls that
    access the I2C bus and communicate with the FRAM should be made from within `doInBackground()`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`doInBackground()`方法中发生的一切都是在后台线程中执行的，所以它是执行任何耗时活动的理想场所，如果这些活动在UI线程中执行，将触发ANR对话框。这意味着慢速的`readFRAM()`和`writeFRAM()`调用应该在`doInBackground()`中进行，这些调用访问I2C总线并与FRAM通信：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `loadData` and `saveData` string variables used in the `readFRAM()` and
    `writeFRAM()` calls are both class variables of `HardwareTask`. The `saveData`
    variable is populated with the contents of the `saveEditText` text field via a
    `saveEditText.toString()` call in the `HardwareTask` class' `onPreExecute()` method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFRAM()`和`writeFRAM()`调用中使用的`loadData`和`saveData`字符串变量都是`HardwareTask`的类变量。`saveData`变量通过`HardwareTask`类的`onPreExecute()`方法中的`saveEditText.toString()`调用填充了`saveEditText`文本字段的内容。'
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How do I update the UI from within an AsyncTask thread?**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**如何在AsyncTask线程内更新UI？**'
- en: While the `fram` app does not make use of them in this example, the `AsyncTask`
    class provides two special methods, `publishProgress()` and `onPublishProgress()`,
    that are worth mentioning. The `AsyncTask` thread uses these methods to communicate
    with the UI thread while the `AsyncTask` thread is running. The `publishProgress()`
    method executes within the `AsyncTask` thread and triggers the execution of `onPublishProgress()`
    within the UI thread. These methods are commonly used to update progress meters
    (hence the name `publishProgress`) or other UI elements that cannot be directly
    updated from within the `AsyncTask` thread. You will use the `publishProgress()`
    and `onPublishProgress()` methods in [Chapter 6](part0041_split_000.html#page
    "Chapter 6. Creating a Complete Interfacing Solution"), *Creating a Complete Interfacing
    Solution*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个例子中`fram`应用没有使用它们，但是`AsyncTask`类提供了两个特殊方法`publishProgress()`和`onPublishProgress()`，值得一提。`AsyncTask`线程在运行时使用这些方法与UI线程进行通信。`publishProgress()`方法在`AsyncTask`线程内执行，并触发UI线程内的`onPublishProgress()`的执行。这些方法通常用于更新进度条（因此称为`publishProgress`）或其他无法直接从`AsyncTask`线程内更新的UI元素。您将在[第6章](part0041_split_000.html#page
    "Chapter 6. Creating a Complete Interfacing Solution")*Creating a Complete Interfacing
    Solution*中使用`publishProgress()`和`onPublishProgress()`方法。
- en: After `doInBackground()` has completed, the `AsyncTask` thread terminates. This
    triggers the calling of `doPostExecute()` from the UI thread. The `doPostExecute()`
    method is used for any post-thread cleanup and updating any UI elements that need
    to be modified. The `fram` app uses the `closeFRAM()` PacktHAL function to close
    the current FRAM context that it opened with `openFRAM()` in the `onPreExecute()`
    method.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`doInBackground()`完成后，`AsyncTask`线程终止。这会触发从UI线程调用`doPostExecute()`。`doPostExecute()`方法用于任何后线程清理和更新需要修改的任何UI元素。`fram`应用使用`closeFRAM()`
    PacktHAL函数关闭了在`onPreExecute()`方法中使用`openFRAM()`打开的当前FRAM上下文。'
- en: '[PRE11]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The user must now be notified that the task has been completed. If the **Load**
    button was pressed, then the string displayed in the `loadTextField` widget is
    updated via the `MainActivity` class `updateLoadedData()` method. If the **Save**
    button was pressed, a `Toast` message is displayed to notify the user that the
    save was successful.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在必须被通知任务已经完成。如果按下了**Load**按钮，那么通过`MainActivity`类的`updateLoadedData()`方法更新`loadTextField`小部件中显示的字符串。如果按下了**Save**按钮，将显示一个`Toast`消息，通知用户保存成功。
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Giving Toast feedback to the user**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**向用户提供Toast反馈**'
- en: The `Toast` class is a great way to provide quick feedback to your app's user.
    It pops up a small message that disappears after a configurable period of time.
    If you perform a hardware-related task in the background and you want to notify
    the user of its completion without changing any UI elements, try using a `Toast`
    message! `Toast` messages can only be triggered by methods that are executing
    from within the UI thread.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`类是向应用程序用户提供快速反馈的好方法。它会弹出一条小消息，一段可配置的时间后消失。如果您在后台执行与硬件相关的任务，并且希望在不更改任何UI元素的情况下通知用户任务已完成，请尝试使用`Toast`消息！`Toast`消息只能由在UI线程内执行的方法触发。'
- en: '![Learning the details of the HardwareTask class](img/00021.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![学习HardwareTask类的细节](img/00021.jpeg)'
- en: An example of the `Toast` message
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toast`消息的示例'
- en: 'Finally, the `onPostExecute()` method will re-enable all of the UI elements
    that were disabled in `onPreExecute()`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`onPostExecute()`方法将重新启用在`onPreExecute()`中禁用的所有UI元素：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `onPostExecute()` method has now finished its execution and the app is back
    to patiently waiting for the user to make the next `fram` access request by pressing
    either the **Load** or **Save** button.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`onPostExecute()`方法现在已经完成了执行，应用程序又在耐心等待用户通过按下**Load**或**Save**按钮来发出下一个`fram`访问请求。'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you ready for a challenge?**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你准备好迎接挑战了吗？
- en: Now that you have seen all of the pieces of the `fram` app, why not change it
    to add new functionality? For a challenge, try adding a counter that indicates
    to the user how many more characters can be entered into the `saveText` text field
    before the 60-character limit is reached. We have provided one possible implementation
    of this in the `chapter4_challenge.tgz` file, which is available for download
    from the Packt's website.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经看到了`fram`应用程序的所有部分，为什么不改变它以添加新功能呢？作为挑战，尝试添加一个计数器，指示用户在达到60个字符限制之前还可以输入多少个字符到`saveText`文本字段中。我们在`chapter4_challenge.tgz`文件中提供了一个可能的实现，可以从Packt的网站上下载。
- en: Summary
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to the I2C bus. You constructed a circuit
    that connected an I2C FRAM breakout board to the BBB, and then you did some basic
    testing on the circuit using `i2cdetect` from `i2c-tools` to ensure that the circuit
    was constructed properly and the kernel is able to interact with the circuit via
    the filesystem. You also learned about the portions of the PacktHAL `init.{ro.hardware}.rc`
    file and Device Tree overlay that are responsible for configuring and making the
    I2C bus and I2C device drivers available for your app's use. The `fram` app in
    this chapter demonstrated how to use the `AsyncTask` class to perform time-intensive
    hardware interfacing tasks without stalling the app's UI thread and triggering
    the ANR dialog.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了I2C总线。您构建了一个电路，将I2C FRAM扩展板连接到BBB，然后使用`i2c-tools`中的`i2cdetect`对电路进行了一些基本测试，以确保电路被正确构建，并且内核能够通过文件系统与电路进行交互。您还了解了PacktHAL
    `init.{ro.hardware}.rc`文件和设备树叠加的部分，这些部分负责配置和使I2C总线和I2C设备驱动程序可供应用程序使用。本章中的`fram`应用程序演示了如何使用`AsyncTask`类执行耗时的硬件接口任务，而不会使应用程序的UI线程停滞并触发ANR对话框。
- en: In the next chapter, you will learn about the high-speed **serial peripheral
    interface** (**SPI**) bus and use it to interface with an environmental sensor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将了解高速**串行外围接口**（**SPI**）总线，并使用它与环境传感器进行接口。
