- en: '*Chapter 12*: Creating Animations with Animator, Cinemachine, and Timeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：使用动画师、电影机和时间轴创建动画'
- en: At our current game status, we mostly have a static Scene, without considering
    the Shader and particle animations. In the next chapter, when we will add scripting
    to our game, everything will start to move according to the behavior we want.
    But sometimes, we need to move objects in a predetermined way, such as with cutscenes,
    or specific character animations, such as jumping, running, and so on. The idea
    of this chapter is to go over several Unity animation systems to create all the
    possible movements of objects we can get without scripting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的游戏状态下，除了考虑着色器和粒子动画外，我们大部分时间都处于静态场景中。在下一章中，当我们为游戏添加脚本时，一切都将根据我们想要的行为开始移动。但有时，我们需要以预定的方式移动对象，例如通过过场动画，或者特定的角色动画，例如跳跃、奔跑等。本章的目的是介绍几种Unity动画系统，以创建所有可能的对象运动，而无需脚本。
- en: 'In this chapter, we will examine the following animation concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下动画概念：
- en: Using skeletal animations with Animator
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画师进行骨骼动画
- en: Creating dynamic cameras with Cinemachine
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用电影机创建动态摄像机
- en: Creating cutscenes with Timeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用时间轴创建过场动画
- en: By the end of this chapter, you will be able to create cutscenes to tell the
    history of your game or highlight specific areas of your level, as well as create
    dynamic cameras that are capable of giving an accurate look of your game, regardless
    of the situation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章结束时，您将能够创建过场动画来讲述游戏的故事或突出显示级别的特定区域，以及创建能够准确展示游戏外观的动态摄像机，无论情况如何。
- en: Using skeletal animations with Animator
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画师进行骨骼动画
- en: So far, we have used what are called static meshes, which are solid three-dimensional
    models that are not supposed to bend or animate in any way (aside from moving
    separately, like the doors of a car). We also have another kind of mesh, called
    skinned meshes, which are meshes that have the ability to be bent based on a skeleton,
    so they can emulate the muscle movements of the human body. We are going to explore
    how to integrate animated humanoid characters into our project to create the enemy
    and player movements.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用的是静态网格，这些是实心的三维模型，不应该以任何方式弯曲或动画化（除了单独移动，如汽车的门）。我们还有另一种网格，称为蒙皮网格，它们具有根据骨骼弯曲的能力，因此可以模拟人体肌肉的运动。我们将探讨如何将动画人形角色整合到我们的项目中，以创建敌人和玩家的动作。
- en: 'In this section, we will examine the following skeletal mesh concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下骨骼网格概念：
- en: Understanding skinning
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解蒙皮
- en: Importing skinned meshes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入蒙皮网格
- en: Integration using Animator Controllers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画师控制器进行整合
- en: We are going to explore the concept of skinning and how it allows you to animate
    characters. Then, we are going to bring animated meshes into our project to finally
    apply animations to them. Let's start by discussing how to bring skeletal animations
    into our project.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨蒙皮的概念以及它如何使您能够为角色添加动画。然后，我们将把动画网格引入我们的项目，最终对其应用动画。让我们从讨论如何将骨骼动画引入我们的项目开始。
- en: Understanding skinning
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解蒙皮
- en: 'In order to get an animated mesh, we need to have four pieces, starting with
    the mesh itself and the model that will be animated, which is created the same
    way as any other mesh. Then, we need the skeleton, which is a set of bones that
    will match the desired mesh topology, such as the arms, fingers, feet, and so
    on. In *Figure 12.1*, you can see an example of a set of bones aligned with our
    target mesh. You will notice that these kinds of meshes are usually modeled with
    the *T* pose, which will facilitate the animation process:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得动画网格，我们需要四个部分，从网格本身和将要进行动画的模型开始，这与任何其他网格的创建方式相同。然后，我们需要骨骼，这是一组骨骼，将与所需的网格拓扑匹配，例如手臂、手指、脚等。在*图12.1*中，您可以看到一组骨骼与我们的目标网格对齐的示例。您会注意到这类网格通常是用*T*姿势建模的，这将有助于动画制作过程：
- en: '![Figure 12.1 – A ninja mesh with a skeleton matching its default pose'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1 – 忍者网格与其默认姿势匹配的骨骼'
- en: '](img/Figure_12.01_B14199.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.01_B14199.jpg)'
- en: Figure 12.1 – A ninja mesh with a skeleton matching its default pose
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 忍者网格与其默认姿势匹配的骨骼
- en: 'Once the artist has created the model and its bones, the next step is to do
    the skinning, which is the act of associating every vertex of the model to one
    or more bones. In this way, when you move a bone, the associated vertexes will
    move with it. This is done in such a way because it is easier to animate a reduced
    amount of bones instead of every single vertex of the model. In the next screenshot,
    you will see the triangles of a mesh being painted according to the color of the
    bone that affects it as a way to visualize the influence of the bones. You will
    notice blending between colors, meaning that those vertexes are affected differently
    by different bones to allow the vertexes near an articulation to bend nicely.
    Also, the screenshot illustrates an example of a two-dimensional mesh used for
    two-dimensional games, but the concept is the same:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦艺术家创建了模型及其骨骼，下一步就是进行蒙皮，即将模型的每个顶点与一个或多个骨骼相关联的过程。这样，当您移动骨骼时，相关的顶点也会随之移动。这样做是因为动画化少量骨骼比动画化模型的每个单独顶点更容易。在下一个截图中，您将看到网格的三角形根据受其影响的骨骼的颜色进行着色，以可视化骨骼的影响。您将注意到颜色之间的混合，这意味着这些顶点受不同骨骼的不同影响，以使关节附近的顶点能够很好地弯曲。此外，截图还说明了用于二维游戏的二维网格的示例，但概念是相同的：
- en: '![Figure 12.2 – Mesh skinning weights visually represented as colors'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2 – 网格蒙皮权重以颜色形式可视化表示'
- en: '](img/Figure_12.02_B14199.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.02_B14199.jpg)'
- en: Figure 12.2 – Mesh skinning weights visually represented as colors
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 网格蒙皮权重以颜色形式可视化表示
- en: Finally, the last piece you need is the actual animation, which will simply
    consist of a blending of different poses of the meshes. The artist will create
    keyframes in an animation, determining which pose the model needs to have at different
    moments, and then the animation system will simply interpolate between them. Basically,
    the artist will animate the bones, and the skinning system will apply this animation
    to the whole mesh. You can have one or several animations, which you will later
    switch between according to the animation that you want to match the character's
    motion (such as idle, walking, falling, and so on).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要的最后一部分是实际的动画，它将简单地由网格的不同姿势混合而成。艺术家将在动画中创建关键帧，确定模型在不同时刻需要采取哪种姿势，然后动画系统将简单地在它们之间进行插值。基本上，艺术家将对骨骼进行动画处理，而蒙皮系统将把这个动画应用到整个网格上。你可以有一个或多个动画，之后你可以根据你想要匹配角色动作的动画来在它们之间切换（比如站立、行走、跌倒等）。
- en: In order to get the four parts, we need to get the proper assets containing
    them. The usual format in this scenario is **Filmbox** (**FBX**), which is the
    same that we have used so far to import 3D models. This format can contain every
    piece we need—the model, the skeleton with the skinning, and the animations—but
    usually, we will split the parts into several files to reutilize the pieces.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得这四个部分，我们需要获取包含它们的适当资产。在这种情况下，通常的格式是**Filmbox**（**FBX**），这与我们迄今为止用来导入3D模型的格式相同。这种格式可以包含我们需要的每一部分——模型、带有蒙皮的骨骼和动画——但通常，我们会将部分拆分成多个文件以重复利用这些部分。
- en: 'Imagine a city simulator game where we have several citizen meshes with different
    aspects and all of them must be animated. If we have a single FBX per citizen
    containing the mesh, the skinning, and the animation, it will cause each model
    to have its own animation, or at least a clone of the same one, repeating them.
    When we need to change that animation, we will need to update all the mesh citizens,
    which is a time-consuming process. Instead of this, we can have one FBX per citizen,
    containing the mesh and the bones with the proper skinning based on that mesh,
    as well as a separate FBX for each animation, containing the same bones that all
    the citizens have with the proper animation, but without the mesh. This will allow
    us to mix and match the citizen FBX with the animation''s FBX files. You may be
    wondering why both the model FBX and the animation FBX must have the mesh. This
    is because they need to match in order to make both files compatible. In the next
    screenshot, you can see how the files should look:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个城市模拟游戏，我们有几个市民网格，外观各异，所有这些网格都必须进行动画处理。如果每个市民的单个FBX包含网格、蒙皮和动画，那么每个模型都会有自己的动画，或者至少是相同动画的克隆，重复出现。当我们需要更改动画时，我们需要更新所有网格市民，这是一个耗时的过程。与此相反，我们可以为每个市民准备一个FBX，其中包含网格和骨骼，以及一个单独的FBX文件用于每个动画，其中包含所有市民都具有的相同骨骼和适当动画，但不包含网格。这将允许我们混合和匹配市民FBX和动画的FBX文件。也许你会想为什么模型FBX和动画FBX都必须有网格。这是因为它们需要匹配才能使两个文件兼容。在下一个截图中，你可以看到文件应该是什么样子的：
- en: '![Figure 12.3 – The animation and model FBX files of the package we will use
    in our project'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.3 – 我们将在项目中使用的包的动画和模型FBX文件'
- en: '](img/Figure_12.03_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.03_B14199.jpg)'
- en: Figure 12.3 – The animation and model FBX files of the package we will use in
    our project
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 我们将在项目中使用的包的动画和模型FBX文件
- en: Also, it is worth mentioning a concept called retargeting. As we said before,
    in order to mix a model and an animation file, we need them to have the same bone
    structure, which means the same amount of bones, hierarchy, and names. Sometimes,
    this is not possible, especially when we mix custom models created by our artist
    with external animation files that you can record from an actor using motion capture
    techniques or just by buying a Mocap library. In such cases, it is highly likely
    that you will encounter different bone structures between the one in the Mocap
    library and your character model, so here is where retargeting kicks in. This
    technique allows Unity to create a generic mapping between two different humanoid-only
    bone structures to make them compatible. In a moment, we will see how to enable
    this feature.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，值得一提的是一个叫做重定向的概念。正如我们之前所说，为了混合模型和动画文件，我们需要它们具有相同的骨骼结构，这意味着相同数量的骨骼、层次结构和名称。有时，这是不可能的，特别是当我们混合我们的艺术家创建的自定义模型与使用动作捕捉技术从演员那里记录下来的外部动画文件，或者只是购买一个Mocap库。在这种情况下，很可能会遇到Mocap库中的骨骼结构与您的角色模型不同，这就是重定向发挥作用的地方。这种技术允许Unity创建两种不同的仅限于人形的骨骼结构之间的通用映射，使它们兼容。一会儿，我们将看到如何启用这个功能。
- en: Now that we understand the basics behind skinned meshes, let's see how we can
    get the model's assets with bones and animations.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了有关蒙皮网格的基础知识，让我们看看如何获取带有骨骼和动画的模型资产。
- en: Importing skeletal animations
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入骨骼动画
- en: Let's start with how to import some animated models from the Asset Store, under
    the **3D** | **Characters** | **Humanoids** section. You can also use external
    sites, such as Mixamo, to download them. But for now, I will stick to the Asset
    Store as you will have less trouble making the assets work. In my case, I have
    downloaded a package, as you can see in the following screenshot, that contains
    both models and animations.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从如何从资产商店导入一些带有动画的模型开始，在**3D** | **Characters** | **Humanoids**部分。你也可以使用外部网站，比如Mixamo，来下载它们。但现在，我会坚持使用资产商店，因为你在使资产工作时会遇到更少的麻烦。在我的情况下，我已经下载了一个包，正如你在下面的截图中所看到的，其中包含了模型和动画。
- en: 'Note that sometimes you will need to download them separately because some
    assets will be model- or animation-only. Also, consider that the packages used
    in this book might not be available at the time you''re reading; in that case,
    you can either look for another package with similar assets (characters and animations,
    in this case) or download the project files from the GitHub repository of the
    book and copy the required files from there:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有时您需要单独下载它们，因为某些资产将仅为模型或动画。另外，请注意，本书中使用的软件包可能在您阅读时不可用；在这种情况下，您可以寻找另一个具有类似资产（角色和动画）的软件包，或者从书的GitHub存储库中下载项目文件，并从那里复制所需的文件：
- en: '![Figure 12.4 – Soldier models for our game'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.4 - 我们游戏的士兵模型'
- en: '](img/Figure_12.04_B14199.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.04_B14199.jpg)'
- en: Figure 12.4 – Soldier models for our game
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 - 我们游戏的士兵模型
- en: In my package content, I can find the animation's FBX files in the `Animations`
    folder and the single model FBX file in `Model`. Remember that sometimes you won't
    have them separated like this, and the animations may be located in the same FBX
    as the model, if any animations are present at all. Now that we have the required
    files, let's discuss how to properly configure them.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的包内容中，我可以在`Animations`文件夹中找到动画的FBX文件，而在`Model`中找到单个模型的FBX文件。请记住，有时您不会将它们分开，动画可能位于与模型相同的FBX中，如果有任何动画的话。现在我们有了所需的文件，让我们讨论如何正确配置它们。
- en: 'Let''s start selecting the **Model** file and checking the **Rig** tab. Within
    this tab, you will find a setting called **Animation Type**, as in the following
    screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始选择**模型**文件并检查**骨骼**选项卡。在此选项卡中，您将找到一个名为**动画类型**的设置，如下图所示：
- en: '![Figure 12.5 – The Rig properties'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.5 - 骨骼属性'
- en: '](img/Figure_12.05_B14199.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.05_B14199.jpg)'
- en: Figure 12.5 – The Rig properties
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 - 骨骼属性
- en: 'This property contains the following options:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性包含以下选项：
- en: '**None**: Mode for non-animated models; every static mesh in your game will
    use this mode.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无**：非动画模型的模式；您游戏中的每个静态网格将使用此模式。'
- en: '**Legacy**: The mode to be used in old Unity Projects and models; do not use
    this in new projects.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传统**：用于旧Unity项目和模型的模式；不要在新项目中使用此模式。'
- en: '**Generic**: A new animation system that can be used in all kinds of models
    but is commonly used in non-humanoid models, such as horses, octopuses, and so
    on. If you use this mode, both the model and animation FBX files must have the
    exact same bone names and structure, thereby reducing the possibility of combining
    animation from external sources.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用：一种新的动画系统，可以用于各种模型，但通常用于非人形模型，如马、章鱼等。如果使用此模式，模型和动画FBX文件必须具有完全相同的骨骼名称和结构，从而减少了来自外部来源的动画组合的可能性。
- en: '**Humanoid**: New animation systems designed to be used in humanoid models.
    It enables features such as retargeting and **Inverse Kinematics** (**IK**). This
    allows you to combine models with different bones than the animation because Unity
    will create a mapping between those structures and a generic one, called the avatar.
    Take into account that sometimes the automatic mapping can fail, and you will
    need to correct it manually; so, if your generic model has everything you need,
    I would recommend you to stick to **Generic** if that''s the default configuration
    of the FBX.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人形**：设计用于人形模型的新动画系统。它启用了重新定位和**反向运动学**（**IK**）等功能。这使您能够将具有不同骨骼的模型与动画结合，因为Unity将在这些结构和一个通用结构之间创建映射，称为阿凡达。请注意，有时自动映射可能会失败，您将需要手动更正；因此，如果您的通用模型具有您需要的一切，我建议您坚持使用**通用**，如果那是FBX的默认配置。'
- en: In my case, the FBX files in my package have the modes set to **Humanoid**,
    so that's good, but remember, only switch to other modes if it is absolutely necessary
    (for example, if you need to combine different models and animations). Now that
    we have discussed the **Rig** settings, let's talk about the **Animation** settings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我的软件包中的FBX文件的模式设置为**Humanoid**，所以很好，但请记住，只有在绝对必要时才切换到其他模式（例如，如果您需要组合不同的模型和动画）。现在我们已经讨论了**骨骼**设置，让我们谈谈**动画**设置。
- en: 'In order to do this, select any animation FBX file and look for the **Animation**
    section of the Inspector window. You will find several settings, such as the **Import
    Animation** checkbox, which must be marked if the file has an animation (not the
    model files), and the **Clips** list, where you will find all the animations in
    the file. In the following screenshot, you can see the **Clips** list for one
    of our animation files:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请选择任何动画FBX文件，并查找检视器窗口中的**动画**部分。您会发现几个设置，例如**导入动画**复选框，如果文件有动画（而不是模型文件），必须标记该复选框，以及**剪辑**列表，您将在其中找到文件中的所有动画。在下面的截图中，您可以看到我们一个动画文件的**剪辑**列表：
- en: '![Figure 12.6 – A Clips list in the Animation settings'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6 - 动画设置中的剪辑列表'
- en: '](img/Figure_12.06_B14199.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.06_B14199.jpg)'
- en: Figure 12.6 – A Clips list in the Animation settings
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 - 动画设置中的剪辑列表
- en: 'An FBX file with animations usually contains a single large animation track,
    which can contain one or several animations. Either way, by default, Unity will
    create a single animation based on that track, but if that track contains several
    animations, you will need to split them manually. In our case, our FBX contains
    several animations already split by the package creator, but in order to learn
    how to do a manual split, do the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 带有动画的FBX文件通常包含单个大动画轨道，其中可以包含一个或多个动画。无论如何，默认情况下，Unity将基于该轨道创建单个动画，但如果该轨道包含多个动画，则您需要手动拆分它们。在我们的情况下，我们的FBX已经由软件包创建者拆分为多个动画，但为了学习如何手动拆分，请执行以下操作：
- en: From the `HumanoidCrouchIdle`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`HumanoidCrouchIdle`。
- en: Take a look at the **Start** and **End** values below the animation timeline
    and remember them; we will use them to recreate this clip:![Figure 12.7 – The
    Clip settings
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下动画时间轴下方的**开始**和**结束**值，并记住它们；我们将使用它们来重新创建此剪辑：![图12.7 - 剪辑设置
- en: '](img/Figure_12.07_B14199.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.07_B14199.jpg)'
- en: Figure 12.7 – The Clip settings
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 - 剪辑设置
- en: Click on the minus button on the bottom-right part of the **Clips** list to
    delete the selected clip.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**片段**列表底部右侧的减号按钮以删除所选的片段。
- en: Use the plus button to create a new clip and select it.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用加号按钮创建一个新的片段并选择它。
- en: Rename it to something similar to the original using the `Take 001` input field.
    In my case, I will name it `Idle`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Take 001`输入字段将其重命名为与原始名称类似的内容。在我的例子中，我会将其命名为`空闲`。
- en: Set the `319` for `264` for **Start**. This information usually comes from the
    artist, but you can just try the number that works best or simply drag the blue
    markers in the timeline on top of these properties.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**开始**设置为`319`，将`结束`设置为`264`。这些信息通常来自艺术家，但您可以尝试最适合的数字，或者简单地在时间轴上拖动蓝色标记到这些属性上。
- en: 'You can preview the clip by clicking on the bar titled for your animation (**HumanoidIdle**,
    in my case) at the very bottom of the Inspector window and click on the Play button.
    You will see the default Unity model, but you can see your own by dragging the
    model file to the preview window because it is important to check whether our
    models are properly configured. If the animation does not play, you will need
    to check whether the **Animation Type** setting matches the animation file:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过单击检视器窗口底部的标题栏上的条形图来预览片段，然后单击播放按钮来预览您的动画（在我的例子中是**HumanoidIdle**）。您将看到默认的Unity模型，但是您可以通过将模型文件拖放到预览窗口中来查看自己的模型，因为检查我们的模型是否正确配置是很重要的。如果动画没有播放，您需要检查**动画类型**设置是否与动画文件匹配：
- en: '![Figure 12.8 – Animation preview'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8 - 动画预览'
- en: '](img/Figure_12.08_B14199.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.08_B14199.jpg)'
- en: Figure 12.8 – Animation preview
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 - 动画预览
- en: 'Now, open the animation file, click on the arrow, and check the sub-assets.
    You will see that here, there is a file titled for your animation, alongside the
    other animations in the clip list, which contains the cut clips. In a moment,
    we will play them. In the following screenshot, you can see the animations in
    our `.fbx` file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开动画文件，单击箭头，然后检查子资产。您会看到这里有一个与您的动画标题相对应的文件，以及剪辑列表中的其他动画，其中包含了剪辑。一会儿，我们将播放它们。在下面的截图中，您可以看到我们`.fbx`文件中的动画：
- en: '![Figure 12.9 – Generated animation clips'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9 - 生成的动画片段'
- en: '](img/Figure_12.09_B14199.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.09_B14199.jpg)'
- en: Figure 12.9 – Generated animation clips
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9 - 生成的动画片段
- en: Now that we covered the basic configuration, let's see how to integrate animations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了基本配置，让我们看看如何集成动画。
- en: Integration using Animation Controllers
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用动画控制器进行集成
- en: When adding animations to our characters, we need to think about the flow of
    the animations, which means thinking about which animations must be played, when
    each animation must be active, and how transitions between animations should happen.
    In previous Unity versions, you needed to code that manually, generating complicated
    scripts of C# code to handle complex scenarios; but now, we have Animation Controllers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在为角色添加动画时，我们需要考虑动画的流程，这意味着考虑必须播放哪些动画，每个动画何时处于活动状态，以及动画之间的过渡应该如何发生。在以前的Unity版本中，您需要手动编写复杂的C#代码脚本来处理复杂的情景；但现在，我们有了动画控制器。
- en: Animation Controllers are a state machine-based asset where we can diagram the
    transition logic between animations with a visual editor called **Animator**.
    The idea is that each animation is a state and our model will have several of
    them. Only one state can be active at a time, so we need to create transitions
    in order to change them, which will have conditions that must be met in order
    to trigger the transition process. Conditions are comparisons of data about the
    character to be animated, such as its velocity, whether it's shooting or crouched,
    and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 动画控制器是基于状态机的资产，我们可以使用名为**动画师**的可视编辑器来绘制动画之间的转换逻辑。其思想是每个动画都是一个状态，我们的模型将有多个状态。一次只能激活一个状态，因此我们需要创建转换来改变它们，这些转换将具有必须满足的条件才能触发转换过程。条件是关于要进行动画的角色的数据的比较，例如其速度、是否在射击或蹲下等。
- en: 'So, basically, an Animation Controller or state machine is a set of animations
    with transition rules that will dictate which animation should be active. Let''s
    start creating a simple Animation Controller by doing the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，动画控制器或状态机基本上是一组带有转换规则的动画，它将决定哪个动画应处于活动状态。让我们通过以下步骤开始创建一个简单的动画控制器：
- en: Click the `Player`. Remember to locate your asset within a folder for proper
    organization; I will call mine `Animators`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“播放器”。记得将您的资产放在一个文件夹中以便进行适当的组织；我会把我的称为“动画师”。
- en: Double-click on the asset to open the **Animator** window. Don't confuse this
    window with the **Animation** window; the **Animation** window does something
    different.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击资产以打开**动画师**窗口。不要将此窗口与**动画**窗口混淆；**动画**窗口有不同的功能。
- en: Drag the **Idle** animation clip of your character into the **Animator** window.
    This will create a box in the Controller representing the animation that will
    be connected to the entry point of the Controller, indicating that the animation
    will be the default one because it is the first one that we dragged. If you don't
    have an **Idle** animation, I encourage you to find one. We will need at least
    one **Idle** and one walking/running animation clip:![Figure 12.10 – Dragging
    an animation clip from an FBX asset into an Animator Controller
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您角色的**空闲**动画片段拖放到**动画师**窗口中。这将在控制器中创建一个框，表示将连接到控制器的默认动画，因为这是我们拖动的第一个动画。如果您没有**空闲**动画，我建议您找一个。我们至少需要一个**空闲**和一个行走/奔跑的动画片段：![图12.10
    - 从FBX资产中拖动动画片段到动画控制器
- en: '](img/Figure_12.10_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.10_B14199.jpg)'
- en: Figure 12.10 – Dragging an animation clip from an FBX asset into an Animator
    Controller
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 - 从FBX资产中拖动动画片段到动画控制器
- en: Drag the running animation in the same way.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式拖动奔跑动画。
- en: Right-click on the **Idle** animation, select **Create Transition**, and left-click
    on the **Run** animation. This will create a transition between **Idle** and **Run**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Idle**动画，选择**Create Transition**，然后左键点击**Run**动画。这将在**Idle**和**Run**之间创建一个过渡。
- en: Create another transition from **Run** to **Idle** in the same way:![Figure
    12.11 – Transitions between two animations
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以相同的方式从**Run**到**Idle**创建另一个过渡：![图12.11 – 两个动画之间的过渡
- en: '](img/Figure_12.11_B14199.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.11_B14199.jpg)'
- en: Figure 12.11 – Transitions between two animations
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 两个动画之间的过渡
- en: 'Transitions must have conditions in order to prevent animations from swapping
    constantly, but in order to create conditions, we need data to make comparisons.
    We will add properties to our Controller, which will represent data used by the
    transitions. Later, in *Part 3*, we will set that data to match the current state
    of our object. But for now, let''s create the data and test how the Controller
    reacts with different values. In order to create conditions based on properties,
    do the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 过渡必须有条件，以防止动画不断切换，但为了创建条件，我们需要数据进行比较。我们将向我们的Controller添加属性，这些属性将代表过渡所使用的数据。稍后在*第3部分*中，我们将设置这些数据以匹配对象的当前状态。但现在，让我们创建数据并测试Controller对不同值的反应。为了基于属性创建条件，做如下操作：
- en: Click on the **Parameters** tab in the top-left part of the **Animator** window.
    If you don't see it, click on the crossed-eye button to display the tabs.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Animator**窗口左上角的**Parameters**选项卡。如果你没有看到它，点击交叉眼按钮显示选项卡。
- en: Click on the `Velocity`. If you missed the renaming part, just left-click on
    the variable and rename it:![Figure 12.12 – The Parameters tab with a float Velocity
    property
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Velocity`。如果你错过了重命名部分，只需左键点击变量并重命名：![图12.12 – 具有浮点速度属性的参数选项卡
- en: '](img/Figure_12.12_B14199.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.12_B14199.jpg)'
- en: Figure 12.12 – The Parameters tab with a float Velocity property
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – 具有浮点速度属性的参数选项卡
- en: Click on the `Conditions` property in the Inspector window.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器窗口中点击`Conditions`属性。
- en: Click on the `0`. This tells us that the transition will execute from `0`. I
    recommend you to set a slightly higher value, such as `0.01`, to prevent any float
    rounding errors (a common CPU issue). Also, remember that the actual value of
    **Velocity** needs to be set manually via scripting, which we will do in *Part
    3*:![Figure 12.13 – Condition to check whether the velocity is greater than 0.01
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`0`。这告诉我们过渡将从`0`执行。我建议你设置一个稍高一点的值，比如`0.01`，以防止任何浮点舍入错误（常见的CPU问题）。还要记住，**Velocity**的实际值需要通过脚本手动设置，这将在*第3部分*中进行：![图12.13
    – 检查速度是否大于0.01的条件
- en: '](img/Figure_12.13_B14199.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.13_B14199.jpg)'
- en: Figure 12.13 – Condition to check whether the velocity is greater than 0.01
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 – 检查速度是否大于0.01的条件
- en: 'Do the same to the `0.01`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`0.01`做同样的操作：
- en: '![Figure 12.14 – Condition to check whether a value is less than 0.01'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14 – 检查值是否小于0.01的条件'
- en: '](img/Figure_12.14_B14199.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.14_B14199.jpg)'
- en: Figure 12.14 – Condition to check whether a value is less than 0.01
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14 – 检查值是否小于0.01的条件
- en: 'Now that we have our first Animator Controller set up, it''s time to apply
    it to an object. In order to do that, we will need a series of components. First,
    when we have an animated character, rather than a regular Mesh Renderer, we use
    the Skinned Mesh Renderer. If you drag the model of the character to the scene
    and explore its children, you will see a component, as shown:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了第一个Animator Controller，是时候将它应用到一个对象上了。为了做到这一点，我们需要一系列的组件。首先，当我们有一个动画角色时，我们使用蒙皮网格渲染器而不是普通的网格渲染器。如果你将角色模型拖到场景中并探索它的子级，你会看到一个组件，如下所示：
- en: '![Figure 12.15 – A Skinned Mesh Renderer component'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.15 – 一个蒙皮网格渲染器组件'
- en: '](img/Figure_12.15_B14199.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.15_B14199.jpg)'
- en: Figure 12.15 – A Skinned Mesh Renderer component
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 一个蒙皮网格渲染器组件
- en: 'This component will be in charge of applying the bones'' movements to the mesh.
    If you search the children of the model, you will find some bones; you can try
    rotating, moving, and scaling them to see the effect, as shown in the following
    screenshot. Consider the fact that your bone hierarchy might be different from
    mine if you downloaded another package from the Asset Store:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将负责将骨骼的移动应用到网格上。如果你搜索模型的子级，你会发现一些骨骼；你可以尝试旋转、移动和缩放它们，以查看效果，如下面的截图所示。请注意，如果你从资产商店下载了另一个包，你的骨骼层次结构可能与我的不同：
- en: '![Figure 12.16 – Rotating the neckbone'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.16 – 旋转颈骨'
- en: '](img/Figure_12.16_B14199.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.16_B14199.jpg)'
- en: Figure 12.16 – Rotating the neckbone
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 旋转颈骨
- en: 'The other component that we need is **Animator**, which is automatically added
    to skinned meshes at its root GameObject. This component will be in charge of
    applying the state machine that we created in the Animator Controller if the animation
    FBX files are properly configured as we mentioned earlier. In order to apply the
    Animator Controller, do the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的另一个组件是**Animator**，它会自动添加到其根GameObject的蒙皮网格上。这个组件将负责应用我们在Animator Controller中创建的状态机，如果动画FBX文件按照我们之前提到的方式正确配置的话。为了应用Animator
    Controller，做如下操作：
- en: Drag the model of the character to the Scene if it's not already there.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果场景中还没有角色模型，将角色模型拖到场景中。
- en: Select it and locate the **Animator** component in the root GameObject.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它并定位根GameObject中的**Animator**组件。
- en: Click on the circle to the right of the **Controller** property and select the
    **Player** controller we created earlier. You can also just drag it from the Project
    window.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Controller**属性右侧的圆圈，选择之前创建的**Player**控制器。你也可以直接从项目窗口拖动它。
- en: Make sure that the **Avatar** property is set to the avatar inside the FBX model;
    this will tell the animator that we will use that skeleton. You can identify the
    avatar asset by its icon of a person, as in the following screenshot. Usually,
    this property is correctly set automatically when you drag the FBX model to the
    Scene:![Figure 12.17 – Animator using the Player controller and the robot avatar
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保**Avatar**属性设置为FBX模型内的avatar；这将告诉动画师我们将使用该骨架。您可以通过其人物图标来识别avatar资源，如下面的屏幕截图所示。通常，当您将FBX模型拖到场景中时，此属性会自动正确设置：![图12.17
    - 动画师使用玩家控制器和机器人avatar
- en: '](img/Figure_12.17_B14199.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.17_B14199.jpg)'
- en: Figure 12.17 – Animator using the Player controller and the robot avatar
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 - 动画师使用玩家控制器和机器人avatar
- en: Set the **Camera** GameObject so that it's looking at the player and play the
    game, and you will see the character executing its **Idle** animation.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Camera**游戏对象设置为朝向玩家并播放游戏，您将看到角色执行其**Idle**动画。
- en: Without stopping the game, open the Animator Controller asset again by double-clicking
    it and selecting the character in the **Hierarchy** pane. By doing this, you should
    see the current state of the animation being played by that character, using a
    bar to represent the current part of the animation:![Figure 12.18 – The Animator
    Controller in Play mode while an object is selected,
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不停止游戏的情况下，再次通过双击打开动画控制器资源，并在**Hierarchy**窗格中选择角色。通过这样做，您应该看到该角色正在播放的动画的当前状态，使用条形图表示动画的当前部分：![图12.18
    - 在选择对象时播放模式下的动画控制器，
- en: showing the current animation and its progress
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 显示当前动画及其进度
- en: '](img/Figure_12.18_B14199.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.18_B14199.jpg)'
- en: Figure 12.18 – The Animator Controller in Play mode while an object is selected,
    showing the current animation and its progress
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 - 在选择对象时播放模式下的动画控制器，显示当前动画及其进度
- en: Using the `1.0` and see how the transition will execute:![Figure 12.19 – Setting
    the velocity of the Controller to trigger a transition
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`1.0`并查看转换的执行方式：![图12.19 - 设置控制器的速度以触发转换
- en: '](img/Figure_12.19_B14199.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.19_B14199.jpg)'
- en: Figure 12.19 – Setting the velocity of the Controller to trigger a transition
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 - 设置控制器的速度以触发转换
- en: 'Depending on how the **Run** animation was set, your character might start
    to move. This is caused by the root motion, a feature that will move the character
    based on the animation movement. Sometimes, this is useful, but due to the fact
    that we will fully move our character using scripting, we want that feature to
    be turned off. You can do that by unchecking the **Apply Root Motion** checkbox
    in the **Animator** component of the **Character** object:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '根据**Run**动画的设置方式，您的角色可能会开始移动。这是由根动作引起的，这是一个根据动画移动角色的功能。有时这是有用的，但由于我们将完全使用脚本移动角色，我们希望关闭该功能。您可以通过取消**Character**对象的**Animator**组件中的**Apply
    Root Motion**复选框来实现。:'
- en: '![Figure 12.20 – Disabled root motion'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20 - 禁用根动作'
- en: '](img/Figure_12.20_B14199.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.20_B14199.jpg)'
- en: Figure 12.20 – Disabled root motion
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 - 禁用根动作
- en: 'You will also notice a delay between changing the **Velocity** value and the
    start of the animation transition. That''s because, by default, Unity will wait
    for the original animation to end before executing a transition, but in this scenario,
    we don''t want that. We need the transition to start immediately. In order to
    do this, select each transition of the Controller and in the Inspector window,
    uncheck the **Has Exit Time** checkbox:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还会注意到更改**Velocity**值和动画转换开始之间存在延迟。这是因为默认情况下，Unity会等待原始动画结束后再执行转换，但在这种情况下，我们不希望如此。我们需要立即开始转换。为了做到这一点，选择控制器的每个转换，并在检查器窗口中取消选中**Has
    Exit Time**复选框：
- en: '![Figure 12.21 – Disabling the Has Exit Time checkbox to execute the transition
    immediately'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.21 - 禁用“具有退出时间”复选框以立即执行转换'
- en: '](img/Figure_12.21_B14199.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.21_B14199.jpg)'
- en: Figure 12.21 – Disabling the Has Exit Time checkbox to execute the transition
    immediately
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 - 取消“具有退出时间”复选框以立即执行转换
- en: You can start dragging other animations into the Controller and create complex
    animation logic, such as adding jumping, falling, or crouched animations. I invite
    you to try other parameter types, such as a Boolean, that use checkboxes instead
    of numbers. Also, as you develop your game further, your Controller will grow
    in its number of animations. To manage that, there are other features worth researching,
    such as Blend Trees and sub-state machines, but that's beyond the scope of this
    book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以开始将其他动画拖入控制器并创建复杂的动画逻辑，例如添加跳跃、下落或蹲伏动画。我邀请您尝试其他参数类型，例如布尔值，它使用复选框而不是数字。此外，随着游戏的进一步开发，您的控制器将增加其动画数量。为了管理它，还有其他值得研究的功能，例如混合树和子状态机，但这超出了本书的范围。
- en: Now that we understand the basics of character animations in Unity, let's discuss
    how to create dynamic camera animations to follow our player.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Unity中角色动画的基础知识，让我们讨论如何创建动态摄像机动画来跟随我们的玩家。
- en: Creating dynamic cameras with Cinemachine
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Cinemachine创建动态摄像机
- en: Cameras are a very important subject in video games. They allow the player to
    see their surroundings to make decisions based on what they see. The game designer
    usually defines how it behaves to get the exact gameplay experience they want,
    and that's no easy task. A lot of behaviors must be layered to get the exact feeling.
    Also, during cutscenes, it is important to control the path that the camera will
    be traversing and where the camera is looking to focus the action during those
    constantly moving scenes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机在视频游戏中是一个非常重要的主题。它们允许玩家看到周围的环境，以便根据所见做出决策。游戏设计师通常定义其行为方式，以获得他们想要的确切游戏体验，这并不容易。必须层叠许多行为才能获得确切的感觉。此外，在过场动画期间，控制摄像机将要穿越的路径以及摄像机的焦点是重要的，以便在这些不断移动的场景中聚焦动作。
- en: In this chapter, we will use the Cinemachine package to create both of the dynamic
    cameras that will follow the player's movements, which we will code in *Part 3*,
    and also, the cameras to be used during cutscenes.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Cinemachine软件包创建两个动态摄像机，这些摄像机将跟随玩家的动作，我们将在*第3部分*中编写，并且还将用于过场动画中使用的摄像机。
- en: 'In this section, we will examine the following Cinemachine concepts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下Cinemachine概念：
- en: Creating camera behaviors
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建摄像机行为
- en: Creating dolly tracks
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建摄影机轨道
- en: Let's start by discussing how to create a Cinemachine controlled camera and
    configure behaviors in it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先讨论如何创建一个Cinemachine控制的摄像机，并在其中配置行为。
- en: Creating camera behaviors
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建摄像机行为
- en: Cinemachine is a collection of different behaviors that can be used in the camera,
    which when properly combined can generate all kinds of common camera types in
    video games, including following the player from behind, first-person cameras,
    top-down cameras, and so on. In order to use these behaviors, we need to understand
    the concept of brain and virtual cameras.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Cinemachine是一组不同的行为，可以用于摄像机中，当正确组合时可以生成各种常见的视频游戏摄像机类型，包括从后面跟随玩家，第一人称摄像机，俯视摄像机等。为了使用这些行为，我们需要了解大脑和虚拟摄像机的概念。
- en: In Cinemachine, we will only keep one main camera, as we have done so far, and
    that camera will be controlled by virtual cameras, separated GameObjects that
    have the previously mentioned behaviors. We can have several virtual cameras and
    swap between them at will, but the active virtual camera will be the only one
    that will control our main camera. This is useful for switching cameras at different
    points of the game, such as switching between our player's first-person camera.
    In order to control the main camera with the virtual cameras, it must have a **Brain**
    component.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cinemachine中，我们将只保留一个主摄像机，就像我们迄今为止所做的那样，该摄像机将由虚拟摄像机控制，这些虚拟摄像机是分开的游戏对象，具有先前提到的行为。我们可以有几个虚拟摄像机，并且可以随意在它们之间切换，但是活动虚拟摄像机将是唯一控制我们主摄像机的摄像机。这对于在游戏的不同点之间切换摄像机非常有用，例如在我们玩家的第一人称摄像机之间切换。为了使用虚拟摄像机控制主摄像机，它必须具有**Brain**组件。
- en: 'To start using Cinemachine, first, we need to install it from the Package Manager,
    as we did previously with other packages. If you don''t remember how to do this,
    just do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Cinemachine，首先我们需要从软件包管理器中安装它，就像我们之前安装其他软件包一样。如果您不记得如何做到这一点，只需执行以下操作：
- en: Go to **Window** | **Package Manager**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**窗口** | **软件包管理器**。
- en: Ensure that the **Packages** option in the top-left part of the window is set
    to **Unity Registry**:![Figure 12.22 – The Packages filter mode
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保窗口左上角的**软件包**选项设置为**Unity Registry**：![图12.22 – 软件包过滤模式
- en: '](img/Figure_12.22_B14199.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.22_B14199.jpg)'
- en: Figure 12.22 – The Packages filter mode
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – 软件包过滤模式
- en: Wait a moment for the left panel to populate all packages from the servers (internet
    is required).
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待左侧面板从服务器中填充所有软件包（需要互联网）。
- en: Look for the **Cinemachine** package from the list and select it. At the moment
    of writing this book, we are using Cinemachine 2.6.0.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找列表中的**Cinemachine**软件包并选择它。在撰写本书时，我们使用的是Cinemachine 2.6.0。
- en: Click the **Install** button in the bottom-right corner of the screen.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击屏幕右下角的**安装**按钮。
- en: 'Let''s start creating a virtual camera to follow the character we animated
    previously, which will be our player hero. Do the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个虚拟摄像机来跟随我们之前制作的角色，这将是我们的玩家英雄。执行以下操作：
- en: Click `CM vcam1`:![Figure 12.23 – Virtual camera creation
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击`CM vcam1`：![图12.23 – 虚拟摄像机创建
- en: '](img/Figure_12.23_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.23_B14199.jpg)'
- en: Figure 12.23 – Virtual camera creation
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – 虚拟摄像机创建
- en: If you select the main camera from the `CinemachineBrain` component has been
    automatically added to it, making our main camera follow the virtual camera. Try
    to move the created virtual camera, and you will see how the main camera follows
    it:![Figure 12.24 – The CinemachineBrain component
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您从`CinemachineBrain`组件中选择了主摄像机，那么我们的主摄像机将自动添加到其中，使我们的主摄像机跟随虚拟摄像机。尝试移动创建的虚拟摄像机，您将看到主摄像机如何跟随它：![图12.24
    – CinemachineBrain组件
- en: '](img/Figure_12.24_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.24_B14199.jpg)'
- en: Figure 12.24 – The CinemachineBrain component
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – CinemachineBrain组件
- en: Select the virtual camera and drag the character to the **Follow** and **Look
    At** properties of the Cinemachine virtual camera component. This will make the
    movement and looking behaviors use that object to do their jobs:![Figure 12.25
    – Setting the target of our camera
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择虚拟摄像机，并将角色拖动到Cinemachine虚拟摄像机组件的**跟随**和**看向**属性中。这将使移动和观察行为使用该对象来完成它们的工作：![图12.25
    – 设置我们摄像机的目标
- en: '](img/Figure_12.25_B14199.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.25_B14199.jpg)'
- en: Figure 12.25 – Setting the target of our camera
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 设置我们摄像机的目标
- en: You can see how the `0`, `3`, and `-3`) values:![Figure 12.26 – The camera following
    the character from behind
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到`0`，`3`和`-3`）值：![图12.26 – 摄像机从后面跟随角色
- en: '](img/Figure_12.26_B14199.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.26_B14199.jpg)'
- en: Figure 12.26 – The camera following the character from behind
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.26 – 摄像机从后面跟随角色
- en: '*Figure 12.26* shows the `0`, `1.5`, and `0` worked well to make the camera
    look at the chest instead:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图12.26显示`0`，`1.5`和`0`很好地使摄像机看向胸部：
- en: '![Figure 12.27 – Changing the Aim offset'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.27 – 改变瞄准偏移'
- en: '](img/Figure_12.27_B14199.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.27_B14199.jpg)'
- en: Figure 12.27 – Changing the Aim offset
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.27 – 改变瞄准偏移
- en: 'As you can see, using Cinemachine is pretty simple, and in our case, the default
    settings were mostly enough for the kind of behavior we needed. However, if you
    explore the other **Body** and **Aim** modes, you will find that you can create
    any type of camera for any type of game. We won''t cover the other modes in this
    book, but I strongly recommend you look at the documentation for Cinemachine to
    check what the other modes do. To open the documentation, do the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用Cinemachine非常简单，在我们的情况下，默认设置大多已经足够满足我们需要的行为。但是，如果您探索其他**Body**和**Aim**模式，您会发现您可以为任何类型的游戏创建任何类型的摄像机。我们不会在本书中涵盖其他模式，但我强烈建议您查看Cinemachine的文档，以了解其他模式的功能。要打开文档，请执行以下操作：
- en: Open the Package Manager by going to **Window** | **Package Manger**.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**窗口** | **包管理器**来打开包管理器。
- en: Find **Cinemachine** in the left-hand side list. Wait a moment if it doesn't
    show up. Remember that you need an internet connection for it to work.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中找到**Cinemachine**。如果没有显示，请稍等一会。请记住，您需要互联网连接才能使用它。
- en: Once **Cinemachine** is selected, look for the **View documentation** link in
    blue. Click on it:![Figure 12.28 – The Cinemachine documentation link
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了**Cinemachine**，请查找蓝色的**查看文档**链接。单击它：![图12.28 - Cinemachine文档链接
- en: '](img/Figure_12.28_B14199.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.28_B14199.jpg)'
- en: Figure 12.28 – The Cinemachine documentation link
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.28 - Cinemachine文档链接
- en: 'You can explore the documentation using the navigation menu on the left:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用左侧的导航菜单来探索文档：
- en: '![Figure 12.29 – The Cinemachine documentation'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.29 - Cinemachine文档'
- en: '](img/Figure_12.29_B14199.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.29_B14199.jpg)'
- en: Figure 12.29 – The Cinemachine documentation
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.29 - Cinemachine文档
- en: As you did with Cinemachine, you can find other packages' documentation in the
    same way. Now that we have achieved the basic camera behavior that we need, let's
    explore how we can use Cinemachine to create a camera for our intro cutscene.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 就像您在Cinemachine中所做的那样，您也可以以同样的方式找到其他软件包的文档。现在我们已经实现了我们需要的基本摄像机行为，让我们探索如何使用Cinemachine为我们的开场动画创建摄像机。
- en: Creating dolly tracks
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建推车轨道
- en: When the player starts the level, we want a little cutscene with a pan over
    our scene and the base before entering the battle. This will require the camera
    to follow a fixed path, and that's exactly what Cinemachine's dolly camera does.
    It creates a path where we can attach a virtual camera so that it will follow
    it. We can set Cinemachine to move automatically through the track or follow a
    target to the closest point to the track; in our case, we will use the first option.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家开始关卡时，我们希望有一个小的过场动画，展示我们的场景和战斗之前的基地。这将需要摄像机沿着固定路径移动，这正是Cinemachine的推车摄像机所做的。它创建了一个我们可以附加虚拟摄像机的路径，以便它会跟随它。我们可以设置Cinemachine自动沿着轨道移动或者跟随目标到轨道最近的点；在我们的情况下，我们将使用第一个选项。
- en: 'In order to create a dolly camera, do the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建推车摄像机，请执行以下操作：
- en: Let's start creating the track with a cart, which is a little object that will
    move along the track, which will be the target to follow the camera. To do this,
    click on **Cinemachine** | **Create Dolly Track with Cart**:![Figure 12.30 – A
    dolly camera with a default straight path
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始用一个推车创建轨道，这是一个小物体，将沿着轨道移动，这将是摄像机跟随的目标。要做到这一点，请单击**Cinemachine** | **创建带有推车的推车轨道**：![图12.30
    - 默认直线路径的推车摄像机
- en: '](img/Figure_12.30_B14199.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.30_B14199.jpg)'
- en: Figure 12.30 – A dolly camera with a default straight path
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.30 - 默认直线路径的推车摄像机
- en: If you select the `DollyTrack1` object, you can see two circles with the numbers
    `0` and `1`. These are the control points of the track. Select one of them and
    move it as you move other objects using the arrows of the translation gizmo.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果选择`DollyTrack1`对象，您可以看到两个带有数字`0`和`1`的圆圈。这些是轨道的控制点。选择其中一个并像移动其他对象一样移动它，使用平移图标的箭头。
- en: You can create more control points by clicking the `CinemachineSmoothPath` component
    of the `DollyTrack1` object:![Figure 12.31 – Adding a path control point
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过单击`DollyTrack1`对象的`CinemachineSmoothPath`组件来创建更多的控制点：![图12.31 - 添加路径控制点
- en: '](img/Figure_12.31_B14199.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.31_B14199.jpg)'
- en: Figure 12.31 – Adding a path control point
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.31 - 添加路径控制点
- en: Create as many waypoints as you need to create a path that will traverse the
    areas you want the camera to oversee in the intro cutscene. Remember, you can
    move the waypoints by clicking on them and using the translation gizmo:![Figure
    12.32 – A dolly track for our scene. It ends right behind the character
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建尽可能多的航点，以创建一个将在开场动画中遍历您希望摄像机监视的区域的路径。请记住，您可以通过单击它们并使用平移图标来移动航点：![图12.32 -
    我们场景中的推车轨道。它在角色的后面结束
- en: '](img/Figure_12.32_B14199.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.32_B14199.jpg)'
- en: Figure 12.32 – A dolly track for our scene. It ends right behind the character
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.32 - 我们场景中的推车轨道。它在角色的后面结束
- en: Create a new virtual camera. If you go to the **Game** view after creating it,
    you will notice that the character camera will be active. In order to test how
    the new camera looks, select it and click on the **Solo** button in the Inspector
    window:![Figure 12.33 – The Solo button to temporarily enable this virtual camera
    while editing
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟摄像机。创建后，如果您转到**游戏**视图，您会注意到角色摄像机将处于活动状态。为了测试新摄像机的外观，选择它并在检查器窗口中单击**独奏**按钮：![图12.33
    - 在编辑时临时启用虚拟摄像机的“独奏”按钮
- en: '](img/Figure_12.33_B14199.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.33_B14199.jpg)'
- en: Figure 12.33 – The Solo button to temporarily enable this virtual camera while
    editing
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.33 - 在编辑时临时启用虚拟摄像机的“独奏”按钮
- en: Set the `DollyCart1` object that we previously created with the track.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置我们之前使用轨道创建的`DollyCart1`对象。
- en: Set `0`, `0`, and `0` to keep the camera in the same position as the cart.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`0`，`0`和`0`设置为使摄像机保持在与推车相同的位置。
- en: Set **Aim** to **Same As Follow Target** to make the camera look in the same
    direction as the cart, which will follow the track curves:![Figure 12.34 – Configuration
    to make the virtual camera follow the dolly track
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Aim**设置为**与跟随目标相同**，使摄像机朝着相同的方向看，这将跟随轨道曲线：![图12.34 - 配置以使虚拟摄像机跟随推车轨道
- en: '](img/Figure_12.34_B14199.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.34_B14199.jpg)'
- en: Figure 12.34 – Configuration to make the virtual camera follow the dolly track
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.34 – 配置使虚拟相机跟随推车轨道
- en: 'Select the **DollyCart1** object and change the **Position** value to see how
    the cart moves along the track. Do this while the game window is focused and **CM
    vcam2** is in solo mode to see how the camera will look:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**DollyCart1**对象，并更改**位置**值，以查看推车沿着轨道移动的情况。在游戏窗口聚焦且**CM vcam2**处于独立模式时执行此操作，以查看相机的外观：
- en: '![Figure 12.35 – The Dolly Cart component'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.35 – 推车组件'
- en: '](img/Figure_12.35_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.35_B14199.jpg)'
- en: Figure 12.35 – The Dolly Cart component
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.35 – 推车组件
- en: With the dolly track properly set, we can create our cutscene using **Timeline**
    to sequence it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了正确设置的推车轨道，我们可以使用**时间轴**来创建我们的剧情场景。
- en: Creating cutscenes with Timeline
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用时间轴创建剧情场景
- en: We have our intro camera, but that's not enough to create a cutscene. A proper
    cutscene is a sequence of actions happening at the exact moment that they should
    happen, coordinating several objects to act as intended. We can have actions such
    as enabling and disabling objects, switching cameras, playing sounds, moving objects,
    and so on. To do this, Unity offers **Timeline**, which is a sequencer of actions
    to coordinate that kind of cutscenes. We will use **Timeline** to create an intro
    cutscene for our scene, showing the level before starting the game.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有我们的开场相机，但这还不足以创建一个剧情场景。一个合适的剧情场景是一系列在应该发生的确切时刻发生的动作，协调多个对象以按预期方式行动。我们可以有启用和禁用对象、切换相机、播放声音、移动对象等动作。为此，Unity提供了**时间轴**，这是一个协调这种类型剧情场景的动作的序列器。我们将使用**时间轴**为我们的场景创建一个开场剧情，展示游戏开始前的关卡。
- en: 'In this section, we will examine the following Timeline concepts:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究以下时间轴概念：
- en: Creating animation clips
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: Sequencing our intro cutscene
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排我们的开场剧情
- en: We are going to see how to create our own animation clips in Unity to animate
    our GameObjects and then place them inside a cutscene to coordinate their activation
    using the Timeline sequencer tool. Let's start creating a camera animation to
    use later in Timeline.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在Unity中创建自己的动画剪辑，以动画我们的游戏对象，然后将它们放入一个剧情场景中，使用时间轴序列工具协调它们的激活。让我们开始创建一个相机动画，以便稍后在时间轴中使用。
- en: Creating animation clips
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建动画剪辑
- en: This is actually not a Timeline-specific feature, but rather a Unity feature
    that works great with Timeline. When we downloaded the character, it came with
    animation clips that were created using external software, but you can create
    custom animation clips using Unity's **Animation** window. Don't confuse it with
    the **Animator** window, which allows us to create animation transitions that
    react to the game situation. This is useful to create small object-specific animations
    that you will coordinate later in Timeline with other objects' animations.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上不是时间轴特定的功能，而是一个与时间轴很好配合的Unity功能。当我们下载角色时，它带有使用外部软件创建的动画剪辑，但您可以使用Unity的**动画**窗口创建自定义动画剪辑。不要将其与**动画师**窗口混淆，后者允许我们创建根据游戏情况做出反应的动画过渡。这对于创建您稍后将在时间轴中与其他对象的动画协调的小对象特定动画非常有用。
- en: 'These animations can control any value of an object''s component properties,
    such as the positions, colors, and so on. In our case, we want to animate the
    dolly track''s **Position** property to make it go from start to finish in a given
    time. In order to this, do the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动画可以控制对象组件属性的任何值，例如位置、颜色等。在我们的情况下，我们想要动画推车轨道的**位置**属性，使其在给定时间内从起点到终点。为了做到这一点，请执行以下操作：
- en: Select the `DollyCart1` object.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`DollyCart1`对象。
- en: Open the **Animation** (not **Animator**) window by going to **Window** | **Animation**
    | **Animation**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**动画**（而不是**动画师**）窗口，方法是转到**窗口** | **动画** | **动画**。
- en: Click on the **Create** button at the center of the **Animation** window. Remember
    to do this while the dolly cart (not track) is selected:![Figure 12.36 – Creating
    a custom animation clip
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**动画**窗口中心的**创建**按钮。记住在选择推车（而不是轨道）时执行此操作：![图12.36 – 创建自定义动画剪辑
- en: '](img/Figure_12.36_B14199.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.36_B14199.jpg)'
- en: Figure 12.36 – Creating a custom animation clip
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.36 – 创建自定义动画剪辑
- en: After doing this, you will be prompted to save the animation clip somewhere.
    I recommend you create an `Animations` folder in the project (inside the `Assets`
    folder) and call it `IntroDollyTrack`.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，系统将提示您在某个位置保存动画剪辑。我建议您在项目中（在`Assets`文件夹内）创建一个`Animations`文件夹，并将其命名为`IntroDollyTrack`。
- en: If you pay attention, the dolly cart now has an **Animator** component with
    an Animator Controller created, which contains the animation we just created.
    As with any animation clip, you need to apply it to your object with an Animator
    Controller; custom animations are no exception. So, the **Animation** window created
    them for you.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到，推车现在有一个带有创建的动画控制器的**动画师**组件，其中包含我们刚刚创建的动画。与任何动画剪辑一样，您需要将其应用到具有动画控制器的对象上；自定义动画也不例外。所以，**动画**窗口为您创建了它们。
- en: Animating in this window consists of specifying the value of its properties
    at given moments. In our case, we want `0` at the beginning of the animation at
    the second 0 at the timeline, and have a value of `240` at the end of the animation
    at second `5`. I chose `240` because that's the last possible position in my cart,
    but that depends on the length of your dolly track. Just test which is the last
    possible position in yours. Also, I chose the second `5` because that's what I
    feel is the correct length for the animation, but feel free to change it as you
    wish. Now, whatever happens between the animation's `0` and `5` seconds is an
    interpolation of the `0` and `240` values, meaning that in `2.5` seconds, the
    value of `120`. Animating always consists of interpolating different states of
    our object at different moments.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在此窗口中进行动画操作包括在给定时刻指定其属性的值。在我们的情况下，我们希望在动画的开始时在时间轴的第0秒处为`0`，并在动画结束时在第`5`秒处为`240`。我选择了`240`，因为这是我的手推车的最后可能位置，但这取决于您的手推车轨道的长度。只需测试一下您的最后可能位置是什么。此外，我选择第`5`秒，因为我觉得这是动画的正确长度，但随时可以根据需要进行更改。现在，在动画的`0`和`5`秒之间发生的任何事情都是`0`和`240`值的插值，这意味着在`2.5`秒时，值为`120`。动画始终包括在不同时刻对对象的不同状态进行插值。
- en: 'In order to do this, do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，执行以下操作：
- en: In the **Animation** window, click on the record button (the red circle in the
    top-left section). This will make Unity detect any changes in our object and save
    it to the animation. Remember to do this while you have selected the dolly cart.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**动画**窗口中，单击记录按钮（位于左上角的红色圆圈）。这将使Unity检测对象的任何更改并将其保存到动画中。记得在选择手推车时进行此操作。
- en: Set the `1` and then `0`. Changing this to any value and then to `0` again will
    create a keyframe, which is a point in the animation that says that at `0` seconds,
    we want the `0`. We need to set it first to any other value if the value is already
    at `0`. You will notice that the **Position** property has been added to the animation:![Figure
    12.37 – The animation in Record mode after changing the Position value to 0
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`1`，然后设置为`0`。将其更改为任何值，然后再次更改为`0`将创建一个关键帧，这是动画中的一个点，表示在`0`秒时，我们希望`0`。如果值已经为`0`，则首先将其设置为任何其他值。您会注意到**位置**属性已添加到动画中：![图12.37
    - 在将位置值更改为0后，记录模式下的动画
- en: '](img/Figure_12.37_B14199.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.37_B14199.jpg)'
- en: Figure 12.37 – The animation in Record mode after changing the Position value
    to 0
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.37 - 在将位置值更改为0后，记录模式下的动画
- en: Using the mouse scroll wheel, zoom out the timeline to the right of the `5`
    seconds in the top bar:![Figure 12.38 – The timeline of the Animation window showing
    5 seconds
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用鼠标滚轮，将时间轴向右缩小到顶部栏的`5`秒：![图12.38 - 显示5秒的动画窗口时间轴
- en: '](img/Figure_12.38_B14199.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.38_B14199.jpg)'
- en: Figure 12.38 – The timeline of the Animation window showing 5 seconds
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.38 - 显示5秒的动画窗口时间轴
- en: Click on the `5` second label in the top bar of the timeline to position the
    playback header at that moment. This will locate the next change we do at that
    moment.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击时间轴顶部的`5`秒标签，将播放头定位到该时刻。这将定位我们在该时刻进行的下一个更改。
- en: Set the `240`. Remember to have the **Animation** window in **Record** mode:![Figure
    12.39 – Creating a keyframe with the 240 value at second 5 of the animation
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置`240`。记得将**动画**窗口设置为**记录**模式：![图12.39 - 在动画的第5秒创建一个值为240的关键帧
- en: '](img/Figure_12.39_B14199.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.39_B14199.jpg)'
- en: Figure 12.39 – Creating a keyframe with the 240 value at second 5 of the animation
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.39 - 在动画的第5秒创建一个值为240的关键帧
- en: Hit the play button in the top-left section of the `CM vcam2` is in solo mode.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`CM vcam2`左上角的播放按钮，它处于独奏模式。
- en: 'Now, if we hit play, the animation will start playing, but that''s something
    we don''t want. In this scenario, the idea is to give control of the cutscene
    to the cutscene system, Timeline, because this animation won''t be the only thing
    that needs to be sequenced in our cutscene. One way to prevent the **Animator**
    component from automatically playing the animation we created is to create an
    empty animation state in the Controller and set it as the default state by doing
    the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们点击播放，动画将开始播放，但这并不是我们想要的。在这种情况下，想法是将过场动画的控制权交给过场动画系统Timeline，因为这个动画不是我们需要在过场动画中进行排序的唯一内容。防止**Animator**组件自动播放我们创建的动画的一种方法是在控制器中创建一个空动画状态，并通过以下方式将其设置为默认状态：
- en: Search the Animator Controller that we created when we created the animation
    and open it. If you can't find it, just select the dolly cart and double-click
    on the **Controller** property of the **Animator** component on our Game Object
    to open the asset.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索我们创建动画时创建的动画控制器并打开它。如果找不到它，只需选择手推车，然后双击我们游戏对象的**Animator**组件的**Controller**属性以打开资产。
- en: Right-click on an empty state in the Controller and select **Create State**
    | **Empty**. This will create a new state in the state machine as if we created
    a new animation, but it is empty this time:![Figure 12.40 – Creating an empty
    state in the Animator Controller
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器中的空状态上右键单击，然后选择**创建状态** | **空**。这将在状态机中创建一个新状态，就好像我们创建了一个新动画，但这次是空的：![图12.40
    - 在动画控制器中创建一个空状态
- en: '](img/Figure_12.40_B14199.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.40_B14199.jpg)'
- en: Figure 12.40 – Creating an empty state in the Animator Controller
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.40 - 在动画控制器中创建一个空状态
- en: Right-click on **New State** and click on **Set as Layer Default State**. The
    state should become orange:![Figure 12.41 – Changing the default animation of
    the Controller to an empty state
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**新状态**，然后单击**设置为层默认状态**。状态应变为橙色：![图12.41 - 将控制器的默认动画更改为空状态
- en: '](img/Figure_12.41_B14199.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.41_B14199.jpg)'
- en: Figure 12.41 – Changing the default animation of the Controller to an empty
    state
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.41 - 将控制器的默认动画更改为空状态
- en: Now, if you hit play, no animation will play as the default state of our dolly
    cart is empty.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果点击播放，由于我们手推车的默认状态为空，不会播放任何动画。
- en: Now that we have created our camera animation, let's start creating a cutscene
    that switches from the intro cutscene camera to the player camera by using Timeline.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了我们的摄像机动画，让我们开始创建一个通过时间轴从intro片段摄像机切换到玩家摄像机的片段。
- en: Sequencing our intro cutscene
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对我们的intro片段进行排序
- en: Timeline is already installed in your project, but if you go to the Package
    Manager of Timeline, you may see an **Update** button to get the latest version
    if you need some of the new features. In our case, we will keep the default version
    included in our project (1.3.4, at the time of writing this book).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴已经安装在您的项目中，但是如果您转到时间轴的包管理器，您可能会看到一个“更新”按钮，以获取最新版本，如果您需要一些新功能。在我们的情况下，我们将保留包含在我们项目中的默认版本（在撰写本书时为1.3.4）。
- en: 'The first thing we will do is create a cutscene asset and an object in the
    scene responsible for playing it. To do this, follow these steps:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是创建一个片段资产和一个负责播放它的场景中的对象。要做到这一点，请按照以下步骤进行：
- en: Create an empty GameObject using the **GameObject** | **Create Empty** option.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“GameObject” | “Create Empty”选项创建一个空的GameObject。
- en: Select the empty object and call it `Director`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择空对象并将其命名为“导演”。
- en: Go to **Window** | **Sequencing** | **Timeline** to open the **Timeline** editor.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到“窗口” | “排序” | “时间轴”以打开“时间轴”编辑器。
- en: Click the **Create** button in the middle of the **Timeline** window while the
    **Director** object is selected to convert that object into the cutscene player
    (or director).
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“导演”对象被选中时，单击“时间轴”窗口中间的“创建”按钮，将该对象转换为片段播放器（或导演）。
- en: After doing this, a window will pop up asking you to save a file. This file
    will be the cutscene or timeline; each cutscene will be saved in its own file.
    Save it in a `Cutscenes` folder in your project (the `Assets` folder).
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，将弹出一个窗口询问您保存文件。这个文件将是片段或时间轴；每个片段将保存在自己的文件中。将其保存在项目中的“Cutscenes”文件夹中（“Assets”文件夹）。
- en: 'Now, you can see that the **Director** object has a **Playable Director** component
    with the **Intro** cutscene asset saved in the previous step set for the **Playable**
    property, meaning this cutscene will be played by the director:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到“导演”对象具有“可播放导演”组件，并且在“可播放”属性中设置了上一步保存的“Intro”片段资产，这意味着这个片段将由导演播放：
- en: '![Figure 12.42 – Playable Director prepared to play the Intro Timeline asset'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.42 - 可播放导演准备播放Intro时间轴资产'
- en: '](img/Figure_12.42_B14199.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.42_B14199.jpg)'
- en: Figure 12.42 – Playable Director prepared to play the Intro Timeline asset
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.42 - 准备播放Intro时间轴资产的可播放导演
- en: Now that we have the Timeline asset ready to work with, let's make it sequence
    actions. To start, we need to sequence two things—first, the cart position animation
    we did in the last step and then the camera swap between the dolly track camera
    (**CM vcam2**) and the player cameras (**CM vcam1**). As we said before, a cutscene
    is a sequence of actions executing at given moments, and in order to schedule
    actions, you will need tracks. In Timeline, we have different kinds of tracks,
    each one allowing you to execute certain actions on certain objects. We will start
    with the animation track.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好使用时间轴资产进行工作，让我们让它排序动作。首先，我们需要排序两件事 - 首先是我们在上一步中做的cart位置动画，然后是dolly轨道摄像机（CM
    vcam2）和玩家摄像机（CM vcam1）之间的摄像机切换。正如我们之前所说，片段是在给定时刻执行的一系列动作，为了安排动作，您需要轨道。在时间轴中，我们有不同类型的轨道，每种轨道都允许您在特定对象上执行某些动作。我们将从动画轨道开始。
- en: 'The animation track will control which animation a specific object will play;
    we need one track per object to animate. In our case, we want the dolly track
    to play the **Intro** animation that we created, so let''s do that doing the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 动画轨道将控制特定对象播放哪个动画；我们需要为每个要进行动画处理的对象创建一个轨道。在我们的情况下，我们希望dolly轨道播放我们创建的“Intro”动画，所以让我们这样做：
- en: Create an Animation Track doing right click in the left part of the Timeline
    editor and clicking Animation Track:![Figure 12.43 – Creating Animation Track
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击时间轴编辑器的左侧并单击“动画轨道”创建动画轨道：![图12.43 - 创建动画轨道
- en: '](img/Figure_12.43_B14199.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.43_B14199.jpg)'
- en: Figure 12.43 – Creating Animation Track
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.43 - 创建动画轨道
- en: Select the **Director** object and check the **Bindings** list of the **Playable
    Director** component in the Inspector window.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“导演”对象并检查检查器窗口中“可播放导演”组件的“绑定”列表。
- en: Drag the **Cart** object to specify that we want the animation track to control
    its animation:![Figure 12.44 – Making the animation track control the dolly cart
    animation in this director
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动“Cart”对象以指定我们希望动画轨道控制其动画：![图12.44 - 使动画轨道控制dolly cart动画
- en: '](img/Figure_12.44_B14199.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.44_B14199.jpg)'
- en: Figure 12.44 – Making the animation track control the dolly cart animation in
    this director
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.44 - 使动画轨道控制dolly cart动画
- en: 'Important note:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Timeline is a generic asset that can be applied to any scene, but as the tracks
    control specifics objects, you need to manually bind them in every scene. In our
    case, we have an animation track that expects to control a single animator, so
    in every scene, if we want to apply this cutscene, we need to drag the specific
    animator to control in the **Bindings** list.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 时间轴是一个通用资产，可以应用到任何场景，但是由于轨道控制特定对象，您需要在每个场景中手动绑定它们。在我们的情况下，我们有一个期望控制单个动画师的动画轨道，因此在每个场景中，如果我们想应用这个片段，我们需要将特定的动画师拖放到“绑定”列表中。
- en: Drag the **Intro** animation asset that we created to the animation track in
    the **Timeline** window. This will create a clip in the track showing when and
    for how long the animation will play. You can drag many animations that the cart
    can play into the track to sequence different animations at different moments;
    but right now, we want just that one:![Figure 12.45 – Making the animator track
    play the intro clip
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们创建的“Intro”动画资产拖放到“时间轴”窗口中的动画轨道中。这将在轨道中创建一个剪辑，显示动画将播放的时间和持续时间。您可以将许多动画拖放到轨道中，以便在不同时刻对不同动画进行排序；但是现在，我们只需要这一个：![图12.45
    - 使动画轨道播放intro剪辑
- en: '](img/Figure_12.45_B14199.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.45_B14199.jpg)'
- en: Figure 12.45 – Making the animator track play the intro clip
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.45 – 使动画师轨道播放介绍剪辑
- en: You can drag the animation to change the exact moment you want it to play. Drag
    it to the beginning of the track.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以拖动动画来改变你想要它播放的确切时刻。将它拖到轨道的开头。
- en: 'Hit the Play button in the top-left part of the **Timeline** window to see
    it in action. You can also manually drag the white arrow in the **Timeline** window
    to view the cutscene at different moments:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**时间轴**窗口左上角的播放按钮来查看它的运行情况。你也可以手动拖动**时间轴**窗口中的白色箭头来查看不同时刻的过场动画：
- en: '![Figure 12.46 – Playing a timeline and dragging the playback header'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.46 – 播放时间轴并拖动播放头'
- en: '](img/Figure_12.46_B14199.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.46_B14199.jpg)'
- en: Figure 12.46 – Playing a timeline and dragging the playback header
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.46 – 播放时间轴并拖动播放头
- en: 'Important note:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Remember that you don't need to use Timeline to play animations. In this case,
    we did it this way to control at exactly which moment we want the animation to
    play. You can control animators using scripting as well.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你不需要使用时间轴来播放动画。在这种情况下，我们是这样做的，以便精确控制我们希望动画播放的时刻。你也可以使用脚本来控制动画师。
- en: 'Now, we will make our Intro timeline asset tell the `CinemachineBrain` component
    (the main camera) which camera will be active during each part of the cutscene,
    switching to the player camera once the camera animation is over. We will create
    a second track—a Cinemachine track—which is specialized in making a specific `CinemachineBrain`
    component to switch between different virtual cameras. To do this, follow these
    steps:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使我们的介绍时间轴资产告诉`CinemachineBrain`组件（主摄像头）在过场动画的每个部分时使用哪个摄像头，一旦摄像头动画结束就切换到玩家摄像头。我们将创建第二个轨道—Cinemachine轨道—专门用于使特定的`CinemachineBrain`组件在不同的虚拟摄像头之间切换。要做到这一点，请按照以下步骤进行：
- en: Right-click on the empty space below the animation track and click on **Cinemachine
    Track**. Note that you can install Timeline without Cinemachine, but this kind
    of track won't show up in that case:![Figure 12.47 – Creating a new Cinemachine
    Track
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击动画轨道下方的空白处，然后单击**Cinemachine轨道**。请注意，你可以安装不带Cinemachine的时间轴，但在这种情况下，这种轨道不会显示出来：![图12.47
    – 创建新的Cinemachine轨道
- en: '](img/Figure_12.47_B14199.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.47_B14199.jpg)'
- en: Figure 12.47 – Creating a new Cinemachine Track
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.47 – 创建新的Cinemachine轨道
- en: In the **Playable Director** component's **Bindings** list, drag the main camera
    to **Cinemachine Track** to make that track control which virtual camera will
    be the one that controls the main camera at different moments of the cutscene:![Figure
    12.48 – Making the Cinemachine Track control our Scene's Main Camera
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Playable Director**组件的**Bindings**列表中，将主摄像头拖到**Cinemachine轨道**，以使该轨道控制在过场动画的不同时刻哪个虚拟摄像头将控制主摄像头：![图12.48
    – 使Cinemachine轨道控制我们场景的主摄像头
- en: '](img/Figure_12.48_B14199.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.48_B14199.jpg)'
- en: Figure 12.48 – Making the Cinemachine Track control our Scene's Main Camera
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.48 – 使Cinemachine轨道控制我们场景的主摄像头
- en: The next step indicates which virtual camera will be active during specific
    moments of the timeline. To do so, our Cinemachine Track allows us to drag virtual
    cameras to it, which will create virtual camera clips. Drag both **CM vcam2**
    and **CM vcam1**, in that order, to the Cinemachine Track:![Figure 12.49 – Dragging
    virtual cameras to the Cinemachine Track
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步指示了时间轴的特定时刻将使用哪个虚拟摄像头。为此，我们的Cinemachine轨道允许我们将虚拟摄像头拖到其中，这将创建虚拟摄像头剪辑。按顺序将**CM
    vcam2**和**CM vcam1**拖到Cinemachine轨道中：![图12.49 – 拖动虚拟摄像头到Cinemachine轨道
- en: '](img/Figure_12.49_B14199.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.49_B14199.jpg)'
- en: Figure 12.49 – Dragging virtual cameras to the Cinemachine Track
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.49 – 拖动虚拟摄像头到Cinemachine轨道
- en: If you hit the play button or just drag the **Timeline Playback** header, you
    can see how the active virtual camera changes when the playback header reaches
    the second virtual camera clip. Remember to view this in the **Game** view.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你点击播放按钮或者只是拖动**时间轴播放**头，你可以看到当播放头到达第二个虚拟摄像头剪辑时，活动虚拟摄像头是如何改变的。记得在**游戏**视图中查看。
- en: If you place the mouse near the ends of the clips, a resize cursor will show
    up. If you drag them, you can resize the clips to specify their duration. In our
    case, we will need to match the length of the **CM vcam2** clip to the **Cart**
    animation clip and then put **CM vcam1** at the end of it by dragging it so that
    the camera will be active when the dolly cart animation ends. In my case, they
    were already the same length, but just try to change it anyway to practice. Also,
    you can make the **CM vcam1** clip be shorter; we just need that to play it for
    a few moments to execute the camera swap.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你将鼠标放在剪辑的末端附近，会出现一个调整大小的光标。如果你拖动它们，你可以调整剪辑的持续时间。在我们的情况下，我们需要将**CM vcam2**剪辑的长度与**Cart**动画剪辑匹配，然后通过拖动将**CM
    vcam1**放在其末端，这样当手推车动画结束时摄像头就会激活。在我的情况下，它们已经是相同的长度，但是尝试改变一下也是练习。另外，你可以使**CM vcam1**剪辑变短；我们只需要它播放几个时刻来执行摄像头切换。
- en: 'You can also overlap the clips a little bit to make a smooth transition between
    the two cameras, instead of a hard switch, which will look odd:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以让剪辑有一点重叠，以使两个摄像头之间有一个平滑的过渡，而不是一个突然的切换，这看起来会很奇怪：
- en: '![Figure 12.50 – Resizing and overlapping clips to interpolate them'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.50 – 调整大小和重叠剪辑以插值它们'
- en: '](img/Figure_12.50_B14199.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.50_B14199.jpg)'
- en: Figure 12.50 – Resizing and overlapping clips to interpolate them
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.50 – 调整大小和重叠剪辑以插值它们
- en: If you wait for the full cutscene to end, you will notice how at the very end,
    `CinemachineBrain` component, which will pick the virtual camera with the highest
    **Priority** value. We can change the **Priority** property of the virtual cameras
    to be sure that **CM vcam1** (the player camera) is always the more important
    one, or set **Wrap Mode** of the **Playable Director** component to **Hold**,
    which will keep everything, as the last frame of the timeline specifies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你等待完整的过场动画结束，你会注意到在最后，`CinemachineBrain`组件会选择具有最高**优先级**值的虚拟摄像机。我们可以更改虚拟摄像机的**优先级**属性，以确保**CM
    vcam1**（玩家摄像机）始终是最重要的，或者将**Playable Director**组件的**包裹模式**设置为**保持**，这将保持一切，就像时间轴的最后一帧指定的那样。
- en: 'In our case, we will use the latter option to test the Timeline-specific features:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将使用后一种选项来测试时间轴特定的功能：
- en: '![Figure 12.51 – Wrap Mode set to the Hold mode'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.51 - 包裹模式设置为保持模式'
- en: '](img/Figure_12.51_B14199.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_12.51_B14199.jpg)'
- en: Figure 12.51 – Wrap Mode set to the Hold mode
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.51 - 包裹模式设置为保持模式
- en: Most of the different kinds of tracks work under the same logic; each one will
    control a specific aspect of a specific object using clips that will execute during
    a set time. I encourage you to test different tracks to see what they do, such
    as **Activation**, which enables and disables objects during the cutscene. Remember,
    you can check out the documentation of the Timeline package in the Package Manager.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数不同类型的轨道都遵循相同的逻辑；每个轨道将控制特定对象的特定方面，使用剪辑在设定的时间内执行。我鼓励你测试不同的轨道，看看它们的作用，比如**激活**，它可以在过场动画期间启用和禁用对象。记住，你可以在包管理器中查看时间轴包的文档。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced the different animation systems that Unity provides
    for different requirements. We discussed importing character animations and controlling
    them with Animation Controllers. We also saw how to make cameras that can react
    to the game's current situation, such as the player's position, or that can used
    during cutscenes. Finally, we looked at Timeline and the animation system to create
    an intro cutscene for our game. These tools are useful for making the animators
    in our team work directly in Unity without the hassle of integrating external
    assets (except for character animations) and also preventing the programmer from
    creating repetitive scripts to create animations, wasting time in the process.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Unity提供的不同动画系统，以满足不同的需求。我们讨论了导入角色动画并使用动画控制器控制它们的方法。我们还看到了如何制作可以根据游戏当前情况（如玩家位置）做出反应的摄像机，或者在过场动画中使用的摄像机。最后，我们看了时间轴和动画系统如何为游戏创建开场过场动画。这些工具对于让我们团队中的动画师直接在Unity中工作非常有用，而无需整合外部资产（除了角色动画），也可以避免程序员创建重复的脚本来创建动画，从而节省时间。
- en: Now, you are able to import and create animation clips in Unity, as well as
    apply them to GameObjects to make them move according the clips. Also, you can
    place them in the Timeline sequencer to coordinate them and create cutscenes for
    your game. Finally, you can create dynamic cameras to use in-game or in cutscenes.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在Unity中导入和创建动画剪辑，并将它们应用到游戏对象上，使它们根据剪辑移动。此外，你还可以将它们放置在时间轴序列中进行协调，并为游戏创建过场动画。最后，你可以创建动态摄像机在游戏中或过场动画中使用。
- en: So far, we have discussed lots of Unity systems that allow us to develop different
    aspects of our game without coding, but sooner or later, scripting will be needed.
    Unity provides generic tools for generic situations, but our game's unique gameplay
    must usually be coded manually. In the next chapter, the first chapter of *Part
    3*, we will start learning how to code in Unity using C#.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了许多Unity系统，允许我们在不编码的情况下开发游戏的不同方面，但迟早需要编写脚本。Unity提供了通用工具来处理通用情况，但我们游戏独特的玩法通常需要手动编码。在下一章中，也就是*第三部分*的第一章，我们将开始学习如何使用C#在Unity中编码。
