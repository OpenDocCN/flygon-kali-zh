- en: Building Container Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器映像
- en: 'In this chapter, we are going to get you started building container images.
    We will look at several different ways with which you can define and build your
    images using the tools built into Docker. We will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始构建容器映像。我们将看几种不同的方式，使用内置在Docker中的工具来定义和构建映像。我们将涵盖以下主题：
- en: Introducing the Dockerfile
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Dockerfile
- en: Building container images using a Dockerfile
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建容器映像
- en: Building container images using an existing container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有容器构建容器映像
- en: Building container images from scratch
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从头开始构建容器映像
- en: Building container images using environmental variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境变量构建容器映像
- en: Building container images using multi-stage builds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建构建容器映像
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In the previous chapter, we installed Docker on the following target operating
    systems:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在以下目标操作系统上安装了Docker：
- en: macOS High Sierra and above
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS High Sierra及以上版本
- en: Windows 10 Professional
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 10专业版
- en: Ubuntu 18.04
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ubuntu 18.04
- en: In this chapter, we will be using our Docker installation to build images. While
    the screenshots in this chapter will be from my preferred operating system, which
    is macOS, the Docker commands we will be running will work on all three of the
    operating systems on which we have installed Docker so far. However, some of the
    supporting commands, which will be few and far between, may only be applicable
    to macOS and Linux-based operating systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的Docker安装来构建映像。虽然本章中的截图将来自我的首选操作系统macOS，但我们将在迄今为止安装了Docker的三个操作系统上运行的Docker命令都可以工作。然而，一些支持命令可能只适用于macOS和基于Linux的操作系统。
- en: A full copy of the code used in this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有代码可以在以下位置找到：[https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter02)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码实际操作：
- en: '[http://bit.ly/2D0JA6v](http://bit.ly/2D0JA6v)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2D0JA6v](http://bit.ly/2D0JA6v)'
- en: Introducing the Dockerfile
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Dockerfile
- en: In this section, we will cover Dockerfiles in depth, along with the best practices
    to use. So what is a Dockerfile?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入介绍Dockerfile，以及使用的最佳实践。那么什么是Dockerfile？
- en: 'A **Dockerfile** is simply a plain text file that contains a set of user-defined
    instructions. When the Dockerfile is called by the `docker image build` command,
    which we will look at next, it is used to assemble a container image. A Dockerfile
    looks like the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dockerfile**只是一个包含一组用户定义指令的纯文本文件。当Dockerfile被`docker image build`命令调用时，它用于组装容器映像。Dockerfile看起来像下面这样：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, even with no explanation, it is quite easy to get an idea of
    what each step of the Dockerfile instructs the `build` command to do.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，即使没有解释，也很容易了解Dockerfile的每个步骤指示`build`命令要做什么。
- en: Before we move on to working our way through the previous file, we should quickly
    touch upon Alpine Linux.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续处理之前的文件之前，我们应该快速了解一下Alpine Linux。
- en: '**Alpine Linux** is a small, independently developed, non-commercial Linux
    distribution designed for security, efficiency, and ease of use. While small (see
    the following section), it offers a solid foundation for container images due
    to its extensive repository of packages, and also thanks to the unofficial port
    of grsecurity/PaX, which is patched into its kernel it offers proactive protection
    dozens of potential zero-day and other vulnerabilities.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**Alpine Linux**是一个小型、独立开发的非商业Linux发行版，旨在提供安全、高效和易用性。尽管体积小（见下一节），但由于其丰富的软件包仓库以及非官方的grsecurity/PaX移植，它在内核中提供了主动保护，可以防范数十种潜在的零日和其他漏洞。'
- en: 'Alpine Linux, due both to its size, and how powerful it is, has become the
    default image base for the official container images supplied by Docker. Because
    of this, we will be using it throughout this book. To give you an idea of just
    how small the official image for Alpine Linux is, let''s compare it to some of
    the other distributions available at the time of writing:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Alpine Linux，由于其体积和强大的功能，已成为Docker官方容器镜像的默认基础。因此，在本书中我们将使用它。为了让你了解Alpine Linux官方镜像有多小，让我们将其与撰写时其他发行版进行比较：
- en: '![](Images/2105ef9d-b875-4566-8cab-73e416e7fd93.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2105ef9d-b875-4566-8cab-73e416e7fd93.png)'
- en: As you can see from the Terminal output, Alpine Linux weighs in at only 4.41
    MB, as opposed to the biggest image, which is Fedora, at 253 MB. A bare-metal
    installation of Alpine Linux comes in at around 130 MB, which is still almost
    half the size of the Fedora container image.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从终端输出可以看出，Alpine Linux的体积仅为4.41 MB，而最大的镜像Fedora则为253 MB。Alpine Linux的裸机安装体积约为130
    MB，仍然几乎是Fedora容器镜像的一半大小。
- en: Reviewing the Dockerfile in depth
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入审查Dockerfile
- en: 'Let''s take a look at the instructions used in the Dockerfile example. We will
    look at them in the order in which they appear:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Dockerfile示例中使用的指令。我们将按照它们出现的顺序来看：
- en: '`FROM   `'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM   `'
- en: '`LABEL`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`'
- en: '`RUN`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`'
- en: '`COPY` and `ADD`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY` 和 `ADD`'
- en: '`EXPOSE`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`'
- en: '`ENTRYPOINT` and `CMD`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 和 `CMD`'
- en: Other Dockerfile instructions
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他Dockerfile指令
- en: FROM
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM
- en: The `FROM` instruction tells Docker which base you would like to use for your
    image; as already mentioned, we are using Alpine Linux, so we simply have to put
    the name of the image and the release tag we wish to use. In our case, to use
    the latest official Alpine Linux image, we simply need to add `alpine:latest`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM`指令告诉Docker你想要使用哪个基础镜像；如前所述，我们使用的是Alpine Linux，所以我们只需输入镜像的名称和我们希望使用的发布标签。在我们的情况下，要使用最新的官方Alpine
    Linux镜像，我们只需要添加`alpine:latest`。'
- en: LABEL
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LABEL
- en: The `LABEL` instruction can be used to add extra information to the image. This
    information can be anything from a version number to a description. It's also
    recommended that you limit the number of labels you use. A good label structure
    will help others who have to use our image later on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL`指令可用于向镜像添加额外信息。这些信息可以是版本号或描述等任何内容。同时建议限制使用标签的数量。良好的标签结构将有助于以后使用我们的镜像的其他人。'
- en: 'However, using too many labels can cause the image to become inefficient as
    well, so I would recommend using the label schema detailed at [http://label-schema.org/](http://label-s%20chema.org/).
    You can view the containers'' labels with the following Docker `inspect` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用太多标签也会导致镜像效率低下，因此我建议使用[http://label-schema.org/](http://label-s%20chema.org/)中详细介绍的标签模式。你可以使用以下Docker
    `inspect`命令查看容器的标签：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Alternatively, you can use the following to filter just the labels:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以使用以下内容来过滤标签：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In our example Dockerfile, we add two labels:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例Dockerfile中，我们添加了两个标签：
- en: '`maintainer="Russ McKendrick <russ@mckendrick.io>"` adds a label which helps identify,
    to the end user of the image, who is maintaining it'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`maintainer="Russ McKendrick <russ@mckendrick.io>"` 添加了一个标签，帮助镜像的最终用户识别谁在维护它'
- en: '`description="This example Dockerfile installs NGINX."` adds a brief description
    of what the image is.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`description="This example Dockerfile installs NGINX."` 添加了一个简要描述镜像的标签。'
- en: Generally, it is better to define your labels when you create a container from
    your image, rather than at build time, so it is best to keep labels down to just
    metadata about the image and nothing else.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好在从镜像创建容器时定义标签，而不是在构建时，因此最好将标签限制在关于镜像的元数据上，而不是其他内容。
- en: RUN
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUN
- en: 'The `RUN` instruction is where we interact with our image to install software
    and run scripts, commands, and other tasks. As you can see from our `RUN` instruction,
    we are actually running three commands:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN`指令是我们与镜像交互以安装软件和运行脚本、命令和其他任务的地方。从我们的`RUN`指令中可以看到，实际上我们运行了三个命令：'
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first of our three commands is the equivalent of running the following
    command if we had a shell on an Alpine Linux host:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们三个命令中的第一个相当于在Alpine Linux主机上有一个shell时运行以下命令：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command installs nginx using Alpine Linux's package manager.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令使用Alpine Linux的软件包管理器安装nginx。
- en: We are using the `&&` operator to move on to the next command if the previous
    command was successful. To make it more obvious which commands we are running,
    we are also using `\` so that we can split the command over multiple lines, making
    it easy to read.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`&&`运算符来在前一个命令成功时继续执行下一个命令。为了更清晰地显示我们正在运行的命令，我们还使用`\`来将命令分成多行，使其易于阅读。
- en: 'The next command in our chain removes any temporary files and so on to keep
    the size of our image to a minimum:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链中的下一个命令删除任何临时文件等，以使我们的镜像尺寸最小化：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The final command in our chain  creates a folder with a path of `/tmp/nginx/`,
    so that nginx will start correctly when we run the container:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们链中的最后一个命令创建了一个路径为`/tmp/nginx/`的文件夹，这样当我们运行容器时，nginx将能够正确启动：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We could have also used the following in our Dockerfile to achieve the same
    results:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在Dockerfile中使用以下内容来实现相同的结果：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: However, much like adding multiple labels, this is considered to be considered
    inefficient as it can add to the overall size of the image, which for the most
    part we should try to avoid. There are some valid use cases for this, which we
    will look at later in the chapter. For the most part, this approach to running
    commands should be avoided when your image is being built.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像添加多个标签一样，这被认为是低效的，因为它会增加镜像的总体大小，大多数情况下我们应该尽量避免这种情况。当然也有一些有效的用例，我们将在本章后面进行讨论。在大多数情况下，构建镜像时应避免这种命令的运行。
- en: COPY and ADD
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY和ADD
- en: 'At first glance, `COPY` and `ADD` look like they are doing the same task; however,
    there are some important differences. The `COPY` instruction is the more straightforward
    of the two:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，`COPY`和`ADD`看起来像是在执行相同的任务；然而，它们之间有一些重要的区别。`COPY`指令是两者中更为直接的：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you have probably guessed, we are copying two files from the files folder
    on the host we are building our image on. The first file is `nginx.conf`, which
    contains a basic nginx configuration file:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经猜到的那样，我们正在从构建镜像的主机上的文件夹中复制两个文件。第一个文件是`nginx.conf`，其中包含一个基本的nginx配置文件：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will overwrite the NGINX configuration that was installed as part of the
    APK installation in the `RUN` instruction. The next file, `default.conf`, is the
    most simple virtual host that we can configure, and has the following content:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这将覆盖作为APK安装的一部分安装的NGINX配置在`RUN`指令中。接下来的文件`default.conf`是我们可以配置的最简单的虚拟主机，并且具有以下内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Again, this will overwrite any existing files. So far, so good, so why might
    we use the `ADD` instruction? In our case, it looks like the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这将覆盖任何现有文件。到目前为止，一切都很好，那么为什么我们要使用`ADD`指令呢？在我们的情况下，看起来像是以下的样子：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, we are adding a file called `html.tar.gz`, but we are not actually
    doing anything with the archive to uncompress it in our Dockerfile. This is because
    `ADD` automatically uploads, uncompresses, and puts the resulting folders and
    files at the path we tell it to, which in our case is `/usr/share/nginx/`. This
    gives us our web root of `/usr/share/nginx/html/`, as we defined in the virtual
    host block in the `default.conf` file that we copied to the image.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在添加一个名为`html.tar.gz`的文件，但实际上我们在Dockerfile中并没有对存档进行任何操作。这是因为`ADD`会自动上传、解压缩并将生成的文件夹和文件放置在我们告诉它的路径上，而在我们的情况下是`/usr/share/nginx/`。这给了我们我们在`default.conf`文件中定义的虚拟主机块中的web根目录`/usr/share/nginx/html/`。
- en: 'The `ADD` instruction can also be used to add content from remote sources.
    For example, consider the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADD`指令也可以用于从远程源添加内容。例如，考虑以下情况：'
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding command line would download `html.tar.gz` from `http://www.myremotesource.com/files/`
    and place the file in the `/usr/share/nginx/` folder on the image. Archive files
    from a remote source are treated as files and are not uncompressed, which you
    will have to take into account when using them, meaning that the file would have
    to be added before the `RUN` instruction, so that we could manually unarchive
    the folder and also remove the `html.tar.gz`file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令行将从`http://www.myremotesource.com/files/`下载`html.tar.gz`并将文件放置在镜像的`/usr/share/nginx/`文件夹中。来自远程源的存档文件被视为文件，不会被解压缩，这在使用它们时需要考虑到，这意味着文件必须在`RUN`指令之前添加，这样我们就可以手动解压缩文件夹并删除`html.tar.gz`文件。
- en: EXPOSE
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: EXPOSE
- en: The `EXPOSE` instruction lets Docker know that when the image is executed, the
    port and protocol defined will be exposed at runtime. This instruction does not
    map the port to the host machine, but instead, opens the port to allow access
    to the service on the container network.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令让Docker知道当镜像被执行时，定义的端口和协议将在运行时暴露。这个指令不会将端口映射到主机机器，而是打开端口以允许在容器网络上访问服务。'
- en: 'For example, in our Dockerfile, we are telling Docker to open port `80` every
    time the image runs:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的Dockerfile中，我们告诉Docker在每次运行镜像时打开端口`80`：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ENTRYPOINT and CMD
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENTRYPOINT和CMD
- en: The benefit of using `ENTRYPOINT` over `CMD`, which we will look at next, is
    that you can use them in conjunction with each other. `ENTRYPOINT` can be used
    by itself, but remember that you would want to use `ENTRYPOINT` by itself only
    if you wanted to have your container be executable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENTRYPOINT`而不是`CMD`的好处是，你可以将它们结合使用。`ENTRYPOINT`可以单独使用，但请记住，只有在想要使容器可执行时才会单独使用`ENTRYPOINT`。
- en: For reference, if you think of some of the CLI commands you might use, you have
    to specify more than just the CLI command. You might have to add extra parameters
    that you want the command to interpret. This would be the use case for using `ENTRYPOINT`
    only.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 作为参考，如果你考虑一些你可能使用的CLI命令，你必须指定不仅仅是CLI命令。你可能还需要添加你希望命令解释的额外参数。这将是仅使用`ENTRYPOINT`的用例。
- en: 'For example, if you want to have a default command that you want to execute
    inside a container, you could do something similar to the following example, but
    be sure to use a command that keeps the container alive. In our case, we are using
    the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想要一个默认命令在容器内执行，你可以做类似以下示例的事情，但一定要使用一个保持容器活动的命令。在我们的情况下，我们使用以下命令：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'What this means is that whenever we launch a container from our image, the
    nginx binary is executed, as we have defined that as our `ENTRYPOINT`, and then
    whatever we have as the `CMD` is executed, giving us the equivalent of running
    the following command:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每当我们从我们的镜像启动一个容器时，nginx二进制文件都会被执行，因为我们已经将其定义为我们的`ENTRYPOINT`，然后我们定义的`CMD`也会被执行，这相当于运行以下命令：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Another example of how `ENTRYPOINT` can be used is the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`的另一个用法示例如下：'
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This would be the equivalent of running the following command on our host:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于在我们的主机上运行以下命令：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that we didn't have to tell Docker to use nginx. As we have the nginx
    binary as our entry point, any command we pass overrides the `CMD` that had been
    defined in the Dockerfile.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不必告诉Docker使用nginx。因为我们将nginx二进制文件作为我们的入口点，我们传递的任何命令都会覆盖Dockerfile中定义的`CMD`。
- en: This would display the version of nginx we have installed, and our container
    would stop, as the nginx binary would only be executed to display the version
    information and then the process would stop. We will look at this example later
    in this chapter, once we have built our image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们安装的nginx版本，并且我们的容器将停止，因为nginx二进制文件只会被执行以显示版本信息，然后进程将停止。我们将在本章后面看一下这个示例，一旦我们构建了我们的镜像。
- en: Other Dockerfile instructions
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他Dockerfile指令
- en: There are some instructions that we have not included in our example Dockerfile.
    Let's take a look at them here.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例Dockerfile中还有一些指令没有包括在内。让我们在这里看一下它们。
- en: USER
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: USER
- en: The `USER` instruction lets you specify the username to be used when a command
    is run. The `USER` instruction can be used on the `RUN` instruction, the `CMD`
    instruction, or the `ENTRYPOINT` instruction in the Dockerfile. Also, the user
    defined in the `USER` instruction has to exist, or your image will fail to build.
    Using the `USER` instruction can also introduce permission issues, not only on
    the container itself, but also if you mount volumes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER`指令允许您在运行命令时指定要使用的用户名。`USER`指令可以在Dockerfile中的`RUN`指令、`CMD`指令或`ENTRYPOINT`指令上使用。此外，`USER`指令中定义的用户必须存在，否则您的镜像将无法构建。使用`USER`指令还可能引入权限问题，不仅在容器本身上，还在挂载卷时也可能出现权限问题。'
- en: WORKDIR
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WORKDIR
- en: The `WORKDIR` instruction sets the working directory for the same set of instructions
    that the `USER` instruction can use (`RUN`, `CMD`, and `ENTRYPOINT`). It will
    allow you to use the `CMD` and `ADD` instructions as well.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`指令为`USER`指令可以使用的相同一组指令（`RUN`、`CMD`和`ENTRYPOINT`）设置工作目录。它还允许您使用`CMD`和`ADD`指令。'
- en: ONBUILD
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ONBUILD
- en: The `ONBUILD` instruction lets you stash a set of commands to be used when the
    image is used in future, as a base image for another container image.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令允许您存储一组命令，以便在将来使用该镜像作为另一个容器镜像的基础镜像时使用。'
- en: For example, if you want to give an image to developers and they all have a
    different code base that they want to test, you can use the `ONBUILD` instruction
    to lay the groundwork ahead of the fact of needing the actual code. Then, the
    developers will simply add their code to the directory you tell them, and when
    they run a new Docker build command, it will add their code to the running image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想要向开发人员提供一个镜像，他们都有不同的代码库要测试，您可以使用`ONBUILD`指令在实际需要代码之前先打好基础。然后，开发人员只需将他们的代码添加到您告诉他们的目录中，当他们运行新的Docker构建命令时，它将把他们的代码添加到运行中的镜像中。
- en: 'The `ONBUILD` instruction can be used in conjunction with the `ADD` and `RUN`
    instructions, such as in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`ONBUILD`指令可以与`ADD`和`RUN`指令一起使用，例如以下示例：'
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This would run an update and package upgrade every time our image is used as
    a base for another container image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的镜像作为另一个容器镜像的基础时运行更新和软件包升级。
- en: ENV
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ENV
- en: The `ENV` instruction sets environment variables within the image both when
    it is built and when it is executed. These variables can be overridden when you
    launch your image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV`指令在构建镜像时和执行镜像时设置环境变量。这些变量在启动镜像时可以被覆盖。'
- en: Dockerfiles – best practices
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile - 最佳实践
- en: 'Now that we have covered Dockerfile instructions, let''s take a look at the
    best practices of writing our own Dockerfiles:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Dockerfile指令，让我们来看看编写我们自己的Dockerfile的最佳实践：
- en: You should try to get into the habit of using a `.dockerignore` file. We will
    cover the `.dockerignore` file in the next section; it will seem very familiar
    if you are used to using a `.gitignore` file. It will essentially ignore the items
    you have specified in the file during the build process.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该养成使用`.dockerignore`文件的习惯。我们将在下一节介绍`.dockerignore`文件；如果你习惯使用`.gitignore`文件，它会让你感到非常熟悉。它在构建过程中将忽略你在文件中指定的项目。
- en: Remember to only have one Dockerfile per folder to help you organize your containers.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住每个文件夹只有一个Dockerfile，以帮助你组织你的容器。
- en: Use a version control system, such as Git, for your Dockerfile; just like any
    other text-based document, version control will help you move not only forward,
    but also backward, as necessary.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的Dockerfile使用版本控制系统，比如Git；就像任何其他基于文本的文档一样，版本控制将帮助你不仅向前，还可以向后移动，如果有必要的话。
- en: Minimize the number of packages you install per image. One of the biggest goals
    you want to achieve while building your images is to keep them as small as possible.
    Not installing unnecessary packages will greatly help in achieving this goal.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量减少每个镜像安装的软件包数量。在构建镜像时，你想要实现的最大目标之一就是尽量保持镜像尽可能小。不安装不必要的软件包将极大地帮助实现这一目标。
- en: Make sure there is only one application process per container. Every time you
    need a new application process, it is best practice to use a new container to
    run that application in.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保每个容器只有一个应用程序进程。每次需要一个新的应用程序进程时，最佳实践是使用一个新的容器来运行该应用程序。
- en: Keep things simple; over-complicating your Dockerfile will add bloat and also
    potentially cause you issues further down the line.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简单；过度复杂化你的Dockerfile会增加臃肿，也可能在后续过程中引发问题。
- en: Learn by example! Docker themselves have quite a detailed style guide for publishing
    the official images they host on Docker Hub. You can find a link to this in the
    further reading section at the end of this chapter.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以实例学习！Docker自己为在Docker Hub上托管的官方镜像发布制定了相当详细的风格指南。你可以在本章末尾的进一步阅读部分找到相关链接。
- en: Building container images
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建容器镜像
- en: In this section, we will cover the `docker image build` command. This is where
    the rubber meets the road, as they say. It's time for us to build the base upon
    which we will start building our future images. We will be looking at different
    ways to accomplish this goal. Consider this as a template that you may have created
    earlier with virtual machines. This will help save time by completing the hard
    work; you will just have to create the application that needs to be added to the
    new images.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将介绍`docker image build`命令。这就是所谓的关键时刻。现在是时候构建我们未来镜像的基础了。我们将探讨不同的方法来实现这一目标。可以将其视为您之前使用虚拟机创建的模板。这将通过完成艰苦的工作来节省时间；您只需创建需要添加到新镜像中的应用程序。
- en: 'There are a lot of switches that you could use while using the `docker build`
    command. So, let''s use the always handy `--help` switch on the `docker image
    build` command to view all that we can do:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`docker build`命令时，有很多开关可以使用。因此，让我们在`docker image build`命令上使用非常方便的`--help`开关，查看我们可以做的一切。
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There are then a lot of different flags listed that you can pass when building
    your image. Now, it may seem like a lot to digest, but out of all of these options,
    we only need to use `-- tag`, or its shorthand `-t`, to name our image.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后列出了许多不同的标志，您可以在构建映像时传递这些标志。现在，这可能看起来很多，但在所有这些选项中，我们只需要使用`--tag`或其简写`-t`来命名我们的映像。
- en: You can use the other options to limit how much CPU and memory the build process
    will use. In some cases, you may not want the `build` command to take as much
    CPU or memory as it can have. The process may run a little slower, but if you
    are running it on your local machine or a production server and it's a long build
    process, you may want to set a limit. There are also options that affect the networking
    configuration of the container launched to build our image.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他选项来限制构建过程将使用多少CPU和内存。在某些情况下，您可能不希望`build`命令占用尽可能多的CPU或内存。该过程可能会运行得慢一些，但如果您在本地计算机或生产服务器上运行它，并且构建过程很长，您可能希望设置一个限制。还有一些选项会影响启动以构建我们的映像的容器的网络配置。
- en: Typically, you don't use the `--file` or `-f` switch, as you run the `docker
    build` command from the same folder that the Dockerfile is in. Keeping the Dockerfile
    in separate folders helps sort the files and keeps the naming convention of the
    files the same.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您不会使用`--file`或`-f`开关，因为您是从包含Dockerfile的同一文件夹运行`docker build`命令。将Dockerfile放在单独的文件夹中有助于整理文件，并保持文件的命名约定相同。
- en: It also worth mentioning that, while you are able to pass additional environment
    variables as arguments at build time, they are used at build time and your container
    image does not inherit them. This is useful for passing information such as proxy
    settings, which may only be applicable to your initial build/test environment.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，虽然您可以在构建时作为参数传递额外的环境变量，但它们仅在构建时使用，您的容器映像不会继承它们。这对于传递诸如代理设置之类的信息非常有用，这些信息可能仅适用于您的初始构建/测试环境。
- en: The `.dockerignore` file, as we discussed earlier, is used to exclude those
    files or folders we don't want to be included in the `docker build` as, by default,
    all files in the same folder as the Dockerfile will be uploaded. We also discussed
    placing the Dockerfile in a separate folder, and the same applies to `.dockerignore`.
    It should go in the folder where the Dockerfile was placed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`.dockerignore`文件用于排除我们不希望包含在`docker build`中的文件或文件夹，默认情况下，与Dockerfile相同文件夹中的所有文件都将被上传。我们还讨论了将Dockerfile放在单独的文件夹中，对`.dockerignore`也适用。它应该放在放置Dockerfile的文件夹中。
- en: Keeping all the items you want to use in an image in the same folder will help
    you keep the number of items, if any, in the `.dockerignore` file to a minimum.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将要在映像中使用的所有项目放在同一个文件夹中，这将有助于将`.dockerignore`文件中的项目数量（如果有的话）保持在最低限度。
- en: Using a Dockerfile to build a container image
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建容器映像
- en: 'The first method that we are going to look at for use in building your base
    container images is by creating a Dockerfile. In fact, we will be using the Dockerfile
    from the previous section and then executing a `docker image build` command against
    it to get ourselves an nginx image. So, let''s start off by looking at the Dockerfile
    once more:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的第一种用于构建基本容器映像的方法是创建一个Dockerfile。实际上，我们将使用上一节中的Dockerfile，然后针对它执行`docker
    image build`命令，以获得一个nginx映像。因此，让我们再次开始查看Dockerfile：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Don't forget that you will also need the `default.conf`, `html.tar.gz`,and `nginx.conf` files
    in the files folder. You can find these in the accompanying GitHub repository.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记您还需要在文件夹中的`default.conf`、`html.tar.gz`和`nginx.conf`文件。您可以在附带的GitHub存储库中找到这些文件。
- en: 'So, there are two ways we can go about building this image. The first way would
    be by specifying the `-f` switch when we use the `docker image build` command.
    We will also utilize the `-t` switch to give the new image a unique name:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过两种方式构建此图像。第一种方式是在使用`docker image build`命令时指定`-f`开关。我们还将利用`-t`开关为新图像指定一个唯一名称：
- en: '[PRE21]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, `<REPOSITORY>` is typically the username you signed up for on Docker Hub.
    We will look at this in more detail in [Chapter 3](1a34f1f1-0e97-4973-bce1-c9750afd5c0a.xhtml)*,
    Storing and Distributing Images*; for now, we will be using `local`, and `<TAG>`
    is the unique container value you want to provide. Typically, this will be a version
    number or other descriptor:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`<REPOSITORY>`通常是您在Docker Hub上注册的用户名。我们将在[第3章](1a34f1f1-0e97-4973-bce1-c9750afd5c0a.xhtml)*存储和分发图像*中更详细地讨论这一点；目前，我们将使用`local`，而`<TAG>`是您想要提供的唯一容器值。通常，这将是一个版本号或其他描述符：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Typically, the `--file` switch isn''t used, and it can be a little tricky when
    you have other files that need to be included with the new image. An easier way
    to do the build is to place the Dockerfile in a separate folder by itself, along
    with any other file that you will be injecting into your image using the `ADD`
    or `COPY` instructions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，不使用`--file`开关，当您需要将其他文件包含在新图像中时，可能会有些棘手。进行构建的更简单的方法是将Dockerfile单独放在一个文件夹中，以及使用`ADD`或`COPY`指令将任何其他文件注入到图像中：
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The most important thing to remember is the dot (or period) at the very end.
    This is to tell the `docker image build` command to build in the current folder.
    When you build your image, you should see something similar to the following Terminal
    output:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要记住最后的句点（或周期）。这是告诉`docker image build`命令在当前文件夹中构建的指示。构建图像时，您应该看到类似以下终端输出：
- en: '![](Images/6e1391b3-78b9-41bb-be22-c2da8c578d51.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6e1391b3-78b9-41bb-be22-c2da8c578d51.png)'
- en: 'Once it''s built, you should be able to run the following command to check
    whether the image is available, and also the size of your image:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 构建完成后，您应该能够运行以下命令来检查图像是否可用，以及图像的大小：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see from the following Terminal output, my image size is 5.98 MB:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下终端输出中所见，我的图像大小为5.98 MB：
- en: '![](Images/32a631a1-77f7-461d-8248-8080e5641502.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/32a631a1-77f7-461d-8248-8080e5641502.png)'
- en: 'You can launch a container with your newly built image by running this command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行此命令启动一个包含您新构建的图像的容器：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will launch a container called `dockerfile-example`, you can check it
    is running using the following command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个名为`dockerfile-example`的容器，您可以使用以下命令检查它是否正在运行：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Opening your browser and going to `http://localhost:8080/` should show you
    an extremely simple webpage that looks like the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 打开浏览器并转到`http://localhost:8080/`应该会显示一个非常简单的网页，看起来像以下内容：
- en: '![](Images/7eb0d970-366a-4736-89e2-9d1a482d4161.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/7eb0d970-366a-4736-89e2-9d1a482d4161.png)'
- en: 'Next up, we can quickly run a few of the commands mentioned in the previous
    section of the chapter, starting with the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以快速运行本章前一节提到的一些命令，首先是以下命令：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see from the following Terminal output, we are currently running
    nginx version 1.14.0:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下终端输出中所见，我们目前正在运行nginx版本1.14.0：
- en: '![](Images/c6575287-1cf9-45d9-8d35-d1a8125cc814.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c6575287-1cf9-45d9-8d35-d1a8125cc814.png)'
- en: 'The next command we can look at running, now that we have our first image built,
    displays the labels that we embedded at build time. To view this information run
    the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看一下要运行的下一个命令，现在我们已经构建了第一个图像，显示了我们在构建时嵌入的标签。要查看此信息，请运行以下命令：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see from the following output, this displays the information we
    entered:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下输出中所见，这显示了我们输入的信息：
- en: '![](Images/27e551d4-99ed-4040-800e-986df10b1958.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/27e551d4-99ed-4040-800e-986df10b1958.png)'
- en: 'Before we move on, you can stop and remove the containers we launched with
    the following commands:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，你可以使用以下命令停止和删除我们启动的容器：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We will go into more detail about Docker container commands in Chapter 4, *Managing
    Containers*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第4章“管理容器”中更详细地介绍Docker容器命令。
- en: Using an existing container
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用现有容器
- en: The easiest way to build a base image is to start off by using one of the official
    images from the Docker Hub. Docker also keeps the Dockerfile for these official
    builds in their GitHub repositories. So there are at least two choices you have
    for using existing images that others have already created. By using the Dockerfile,
    you can see exactly what is included in the build and add what you need. You can
    then version control that Dockerfile if you want to change or share it later.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 构建基础镜像的最简单方法是从Docker Hub中的官方镜像之一开始。Docker还将这些官方构建的Dockerfile保存在它们的GitHub存储库中。因此，你至少有两种选择可以使用其他人已经创建的现有镜像。通过使用Dockerfile，你可以准确地看到构建中包含了什么，并添加你需要的内容。然后，如果你想以后更改或共享它，你可以对该Dockerfile进行版本控制。
- en: There is another way to achieve this; however, it is not recommended or considered
    to be good practice, and I would strongly discourage you from using it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种实现这一点的方法；然而，这并不被推荐或认为是良好的做法，我强烈不建议你使用它。
- en: I would only use this method during a prototyping phase to check that the commands
    I am running work as expected in an interactive shell before putting them in a
    Dockerfile. You should always use a Dockerfile.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我只会在原型阶段使用这种方法，以检查我运行的命令是否在交互式shell中按预期工作，然后再将它们放入Dockerfile中。你应该总是使用Dockerfile。
- en: 'First, we should download the image we want to use as our base; as before,
    we will be using Alpine Linux:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该下载我们想要用作基础的镜像；和以前一样，我们将使用Alpine Linux：
- en: '[PRE30]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, we need to run a container in the foreground so that we can interact
    with it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在前台运行一个容器，这样我们就可以与它进行交互：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Once the container runs, you can add the packages as necessary using the `apk`
    command in this case, or whatever the package management commands are for your
    Linux flavour.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 容器运行后，你可以使用`apk`命令（在这种情况下）或者你的Linux版本的软件包管理命令来添加必要的软件包。
- en: 'For example, the following commands would install nginx:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下命令将安装nginx：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After you have installed the packages you require, you need to save the container.
    The `exit` command at the end of the preceding set of commands will stop the running
    container, since the shell process we are detaching ourselves from just happens
    to be the process keeping the container running in the foreground. You can see
    this in the Terminal output as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完所需的软件包后，你需要保存容器。在前面一组命令的末尾使用`exit`命令将停止运行的容器，因为我们正在从中分离的shell进程恰好是保持容器在前台运行的进程。你可以在终端输出中看到这一点，如下所示：
- en: '![](Images/8dd37ad8-124e-4bdd-99da-053fe0af7dfe.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8dd37ad8-124e-4bdd-99da-053fe0af7dfe.png)'
- en: It is at this point that you should really stop; I do not recommend you use
    the preceding commands to create and distribute images, apart from the one use
    case we will cover in the next part of this section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你应该真的停下来；我不建议你使用前面的命令来创建和分发镜像，除了我们将在本节的下一部分中涵盖的一个用例之外。
- en: 'So, to save our stopped container as an image, you need to do something similar
    to the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要将我们停止的容器保存为镜像，你需要执行类似以下的操作：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'For example, I ran the following command to save a copy of the container we
    launched and customized:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我运行了以下命令来保存我们启动和自定义的容器的副本：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice how I called my image `broken-container`? As one of the use cases for
    taking this approach is that if, for some reason, you have a problem with a container,
    then it is extremely useful to save the failed container as an image, or even
    export it as a TAR file to share with others if you need some assistance in getting
    to the root of the problem.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我如何称呼我的镜像为`broken-container`？采用这种方法的一个用例是，如果由于某种原因您的容器出现问题，那么将失败的容器保存为镜像非常有用，甚至将其导出为TAR文件与他人分享，以便在解决问题时获得一些帮助。
- en: 'To save the image file, simply run the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存镜像文件，只需运行以下命令：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So, for our example, I ran the following command:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的示例，我运行了以下命令：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This gave me a 6.6 MB file called `broken-container.tar`. While we have this
    file, you can uncompress it and have a look around, as you can see from the following
    structure:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我一个名为`broken-container.tar`的6.6 MB文件。虽然我们有这个文件，您可以解压它并查看一下，就像您可以从以下结构中看到的那样：
- en: '![](Images/b9291bbe-f356-443c-a892-c4198c3c5695.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b9291bbe-f356-443c-a892-c4198c3c5695.png)'
- en: The image is made up of a collection of JSON files, folders, and other TAR files.
    All images follow this structure, so you may be thinking to yourself, *Why is
    this method so bad*?
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像由一组JSON文件、文件夹和其他TAR文件组成。所有镜像都遵循这个结构，所以您可能会想，*为什么这种方法如此糟糕*？
- en: The biggest reason is trust—as already mentioned, your end user will not be
    able to easily see what is in the image they are running. Would you randomly download
    a prepackaged image from an unknown source to run your workload, without checking
    how the image was built? Who knows how it was configured and what packages have
    been installed? With a Dockerfile, you can see exactly what was executed to create
    the image, but with the method described here, you have zero visibility of this.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的原因是信任——如前所述，您的最终用户将无法轻松地看到他们正在运行的镜像中有什么。您会随机下载一个来自未知来源的预打包镜像来运行您的工作负载吗，而不检查镜像是如何构建的？谁知道它是如何配置的，安装了什么软件包？使用Dockerfile，您可以看到创建镜像时执行了什么，但使用此处描述的方法，您对此一无所知。
- en: Another reason is that it is difficult for you to build in a good set of defaults;
    for example, if you were to build your image this way, then you would not really
    be able to take advantage of features such as `ENTRYPOINT` and `CMD`, or even
    the most basic instructions, such as `EXPOSE`. Instead, the user would have to
    define everything required during their `docker container run` command.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因是很难为您构建一个良好的默认设置；例如，如果您以这种方式构建您的镜像，那么您实际上将无法充分利用诸如`ENTRYPOINT`和`CMD`等功能，甚至是最基本的指令，比如`EXPOSE`。相反，用户将不得不在其`docker
    container run`命令期间定义所需的一切。
- en: In the early days of Docker, distributing images that had been prepared in this
    way was common practice. In fact, I was guilty of it myself, as coming from an
    operations background, it made perfect sense to launch a "machine," bootstrap
    it, and then create a gold master. Luckily, over the last few years, Docker has
    extended the build functionality to the point where this option is not even a
    consideration anymore.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker早期，分发以这种方式准备的镜像是常见做法。事实上，我自己也有过这样的行为，因为作为一名运维人员，启动一个“机器”，引导它，然后创建一个黄金镜像是完全合理的。幸运的是，在过去的几年里，Docker已经将构建功能扩展到了这一点，以至于这个选项根本不再被考虑。
- en: Building a container image from scratch
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从头开始构建容器镜像
- en: So far, we have been using prepared images from the Docker Hub as our base image.
    It is possible to avoid this altogether (sort of) and roll out your own image
    from scratch.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用Docker Hub上准备好的镜像作为我们的基础镜像。完全可以避免这一点（在某种程度上），并从头开始创建自己的镜像。
- en: Now, when you usually hear the phrase *from **scratch*, it literally means that
    you start from nothing. That's what we have here—you get absolutely nothing and
    have to build upon it. Now, this can be a benefit, because it will keep the image
    size very small, but it can also be detrimental if you are fairly new to Docker,
    as it can get complicated.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您通常听到短语*from **scratch*时，它的字面意思是从零开始。这就是我们在这里所做的——您什么都没有，必须在此基础上构建。这可能是一个好处，因为它将使镜像大小非常小，但如果您对Docker还比较新，这也可能是有害的，因为它可能会变得复杂。
- en: Docker has done some of the hard work for us already, and created an empty TAR
    file on the Docker Hub named `scratch`; you can use it in the `FROM` section of
    your Dockerfile. You can base your entire Docker build on this, and then add parts
    as needed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已经为我们做了一些艰苦的工作，并在Docker Hub上创建了一个名为`scratch`的空TAR文件；您可以在Dockerfile的`FROM`部分中使用它。您可以基于此构建整个Docker构建，然后根据需要添加部分。
- en: Again, let's look at using Alpine Linux as our base operating system for the
    image. The reasons for doing this include not only the fact that it is distributed
    as an ISO, Docker image, and various virtual machine images, but also that the
    entire operating system is available as a compressed TAR file. You can find the
    download in the repository, or on the Alpine Linux download page.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们以Alpine Linux作为镜像的基本操作系统。这样做的原因不仅包括它被分发为ISO、Docker镜像和各种虚拟机镜像，还包括整个操作系统作为压缩的TAR文件可用。您可以在存储库或Alpine
    Linux下载页面上找到下载链接。
- en: To download a copy, just select the appropriate download from the downloads
    page, which can be found at [https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads/).
    The one I used was **x86_64** from the **MINI ROOT FILESYSTEM** section.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要下载副本，只需从下载页面中选择适当的下载，该页面位于[https://www.alpinelinux.org/downloads/](https://www.alpinelinux.org/downloads)。我使用的是**x86_64**，来自**MINI
    ROOT FILESYSTEM**部分。
- en: 'Once it''s downloaded, you need to create a Dockerfile that uses `scratch`
    and then add the `tar.gz` file, making sure to use the correct file, as in the
    following example:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载完成，您需要创建一个使用`scratch`的Dockerfile，然后添加`tar.gz`文件，确保使用正确的文件，就像下面的例子一样：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that you have your Dockerfile and operating system in a TAR file, you can
    build your image as you would any other Docker image by running the following
    command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了Dockerfile和操作系统的TAR文件，您可以通过运行以下命令构建您的镜像，就像构建任何其他Docker镜像一样：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You can compare the image size to the other container images we have built
    by running the following command:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令来比较镜像大小与我们构建的其他容器镜像：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As you can see in the following screenshot, the image I built is exactly the
    same size as the Alpine Linux image we have been using from Docker Hug:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在以下截图中所看到的，我构建的镜像与我们从Docker Hub使用的Alpine Linux镜像的大小完全相同：
- en: '![](Images/743714e2-4da6-4fe1-a592-85dfe819b8cb.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/743714e2-4da6-4fe1-a592-85dfe819b8cb.png)'
- en: 'Now that our own image has been built, we can test it by running this command:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了自己的镜像，可以通过运行以下命令来测试它：
- en: '[PRE40]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: If you get an error, then you may already have a container called alpine-test
    created or running . Remove it by running `docker` `container stop alpine-test`,
    followed by `docker container rm alpine-test`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，则可能已经创建或正在运行名为alpine-test的容器。通过运行`docker container stop alpine-test`，然后运行`docker
    container rm alpine-test`来删除它。
- en: 'This should launch into a shell on the Alpine Linux image. You can check this
    by running the following command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动到Alpine Linux镜像的shell中。您可以通过运行以下命令来检查：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will display information on the release the container is running. To get
    an idea of what this entire process looks like, see the following Terminal output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示容器正在运行的版本信息。要了解整个过程的样子，请参见以下终端输出：
- en: '![](Images/357eb630-d8aa-4d78-b99e-17ca4fa62f75.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/357eb630-d8aa-4d78-b99e-17ca4fa62f75.png)'
- en: While everything appears straightforward, this is only thanks to the way Alpine
    Linux packages their operating system. It can start to get more complicated when
    you choose to use other distributions who package their operating systems in a who
    package their operating systems in a different way.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切看起来都很简单，这只是因为Alpine Linux包装他们的操作系统的方式。当你选择使用其他分发版包装他们的操作系统时，情况可能会变得更加复杂。
- en: There are several tools that can be used to generate a bundle of an operating
    system. We are not going to go into any detail on how to use any of these tools
    here because, if you have to consider this approach, you probably have some pretty
    specific requirements. There is a list of tools in the further reading section
    at the end of this chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种工具可以用来生成操作系统的捆绑包。我们不会在这里详细介绍如何使用这些工具，因为如果你必须考虑这种方法，你可能有一些非常具体的要求。在本章末尾的进一步阅读部分有一些工具的列表。
- en: So what could those requirements be? For most people, it will be legacy applications;
    for example, what happens if you have an application that requires an operating
    system that is no longer supported or available from Docker Hub, but you need
    a more modern platform to support the application? Well, you should be able to
    spin your image and install the application there, allowing you to host your old
    legacy application on a modern, supportable operating system/architecture.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这些要求可能是什么呢？对于大多数人来说，这将是遗留应用程序；例如，如果你有一个需要不再受支持或在Docker Hub上不再可用的操作系统的应用程序，但你需要一个更现代的平台来支持该应用程序，那么怎么办？嗯，你应该能够启动你的镜像并在那里安装应用程序，从而使你能够在现代、可支持的操作系统/架构上托管你的旧遗留应用程序。
- en: Using environmental variables
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境变量
- en: In this section, we will cover the very powerful **environmental variables**
    (**ENVs**), as you will be seeing a lot of them. You can use ENVs for a lot of
    things in your Dockerfile. If you are familiar with coding, these will probably
    be familiar to you.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍非常强大的**环境变量**（**ENVs**），因为你将经常看到它们。你可以在Dockerfile中使用ENVs来做很多事情。如果你熟悉编码，这些可能对你来说很熟悉。
- en: For others like myself, at first they seemed intimidating, but don't get discouraged.
    They will become a great resource once you get the hang of them. They can be used
    to set information when running the container, which means that you don't have
    to go and update lots of the commands in your Dockerfile or in scripts that you
    run on the server.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我这样的其他人，起初它们似乎令人生畏，但不要灰心。一旦你掌握了它们，它们将成为一个很好的资源。它们可以用于在运行容器时设置信息，这意味着你不必去更新Dockerfile中的许多命令或在服务器上运行的脚本。
- en: 'To use ENVs in your Dockerfile, you can use the `ENV` instruction. The structure
    of the `ENV` instruction is as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Dockerfile中使用ENVs，你可以使用`ENV`指令。`ENV`指令的结构如下：
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can always use an equals sign between the two:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以在两者之间使用等号：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, the question is, why are there two ways that you can define them, and
    what are the differences? With the first example, you can only set one `ENV` per
    line; however, it is easy to read and follow. With the second `ENV` example, you
    can set multiple environmental variables on the same line, as shown here:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题是，为什么有两种定义它们的方式，它们有什么区别？在第一个例子中，你只能在一行上设置一个`ENV`；然而，它很容易阅读和理解。在第二个`ENV`示例中，你可以在同一行上设置多个环境变量，如下所示：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can view which ENVs are set on an image using the Docker `inspect` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Docker `inspect`命令查看镜像上设置了哪些ENVs：
- en: '[PRE45]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we know how they need to be set in our Dockerfile, let''s take a look
    at them in action. So far we have been using a Dockerfile to build a simple image
    with just nginx installed. Let''s look at building something a little more dynamic.
    Using Alpine Linux, we will do the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道它们在Dockerfile中需要如何设置，让我们看看它们的实际操作。到目前为止，我们一直在使用Dockerfile构建一个只安装了nginx的简单镜像。让我们来构建一些更加动态的东西。使用Alpine
    Linux，我们将执行以下操作：
- en: Set an `ENV` to define which version of PHP we would like to install.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`ENV`来定义我们想要安装的PHP版本。
- en: Install Apache2 and our chosen PHP version.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Apache2和我们选择的PHP版本。
- en: Set up the image so Apache2 starts without issue.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置镜像，使Apache2无问题启动。
- en: Remove the default `index.html` and add an `index.php` file that displays the
    results of the `phpinfo` command.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除默认的`index.html`并添加一个显示`phpinfo`命令结果的`index.php`文件。
- en: Expose port `80` on the container.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器上暴露端口`80`。
- en: Set Apache so it is the default process.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Apache设置为默认进程。
- en: 'Our Dockerfile looks like the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Dockerfile如下所示：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As you can see, we have chosen to install PHP7; we can build the image by running
    the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们选择安装了PHP7；我们可以通过运行以下命令构建镜像：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice how we have changed the command slightly. This time, we are calling
    the image `local/apache-php` and tagging the version as `7`. The full output obtained
    by running the preceding command can be found here:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已经稍微改变了命令。这次，我们将镜像称为`local/apache-php`，并将版本标记为`7`。通过运行上述命令获得的完整输出可以在这里找到：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can check whether everything ran as expected by running the following command
    to launch a container using the image:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来检查一切是否按预期运行，以使用该镜像启动一个容器：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Once it''s launched, open a browser and go to `http://localhost:8080/` and
    you should see a page showing that PHP7 is being used:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它启动，打开浏览器并转到`http://localhost:8080/`，您应该看到一个显示正在使用PHP7的页面：
- en: '![](Images/c5500d90-2c9c-4f4e-bfeb-f768b2c031b2.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c5500d90-2c9c-4f4e-bfeb-f768b2c031b2.png)'
- en: Don't be confused by the next part; there is no PHP6\. For an explanation of
    why not, go to [https://wiki.php.net/rfc/php6](https://wiki.php.net/rfc/php6).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被接下来的部分所困惑；没有PHP6。要了解为什么没有，请访问[https://wiki.php.net/rfc/php6](https://wiki.php.net/rfc/php6)。
- en: 'Now, in your Dockerfile, change `PHPVERSION` from `7` to `5` and then run the
    following command to build a new image:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在您的Dockerfile中，将`PHPVERSION`从`7`更改为`5`，然后运行以下命令构建新镜像：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see from the following Terminal output, the majority of the output
    is the same, apart from the packages that are being installed:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下终端输出中所见，大部分输出都是相同的，除了正在安装的软件包：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can launch a container, this time on port `9090`, by running the following
    command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令在端口`9090`上启动一个容器：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Opening your browser again, but this time going to `http://localhost:9090/`, should
    show that we are running PHP5:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 再次打开您的浏览器，但这次转到`http://localhost:9090/`，应该显示我们正在运行PHP5：
- en: '![](Images/41bd2e7e-8182-4035-be75-312200013d41.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/41bd2e7e-8182-4035-be75-312200013d41.png)'
- en: 'Finally, you can compare the size of the images by running this command:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以通过运行此命令来比较镜像的大小：
- en: '[PRE53]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You should see the following Terminal output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下终端输出：
- en: '![](Images/47fc018c-fd1e-4dd5-bc96-1c3d87281a7c.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/47fc018c-fd1e-4dd5-bc96-1c3d87281a7c.png)'
- en: This shows that the PHP7 image is a lot smaller than the PHP5 one. Let's discuss
    what actually happened when we built the two different container images.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明PHP7镜像比PHP5镜像要小得多。让我们讨论当我们构建了两个不同的容器镜像时实际发生了什么。
- en: So what happened? Well, when Docker launched the Alpine Linux image to create
    our image, the first thing it did was set the ENVs we defined, making them available
    to all of the shells within the container.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 那么发生了什么？嗯，当 Docker 启动 Alpine Linux 镜像来创建我们的镜像时，它首先做的是设置我们定义的 ENV，使它们对容器内的所有
    shell 可用。
- en: 'Luckily for us, the naming scheme for PHP in Alpine Linux simply substitutes
    the version number and maintains the same name for the packages we need to install,
    meaning that we run the following command:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Alpine Linux 中 PHP 的命名方案只是替换版本号并保持我们需要安装的软件包的相同名称，这意味着我们运行以下命令：
- en: '[PRE54]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'But it is actually interpreted as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上它被解释为以下内容：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Or, for PHP5, it is interpreted as the following instead:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，对于 PHP5，它被解释为以下内容：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This means that we do not have to go through the whole Dockerfile, manually
    substituting version numbers. This approach is especially useful when installing
    packages from remote URLs, such as software release pages.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不必手动替换版本号来浏览整个 Dockerfile。当从远程 URL 安装软件包时，这种方法特别有用，比如软件发布页面。
- en: 'What follows is a more advanced example—a Dockerfile that installs and configures
    Consul by HashiCorp. In this Dockerfile, we are using environment variables to
    define the version numbers and the SHA256 hash of the file we downloaded:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个更高级的示例——一个安装和配置 HashiCorp 的 Consul 的 Dockerfile。在这个 Dockerfile 中，我们使用环境变量来定义文件的版本号和
    SHA256 哈希：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, Dockerfiles can get quite complex, and use of ENVs can help
    with the maintenance. Whenever a new version of Consul is released, I simply need
    to update the `ENV` line and commit it to GitHub, which will trigger the building
    of a new image—well, it would do if we had configured it to do so; we will be
    looking at this in the next chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Dockerfiles 可以变得非常复杂，使用 ENV 可以帮助维护。每当 Consul 的新版本发布时，我只需要更新 `ENV` 行并将其提交到
    GitHub，这将触发构建新镜像——如果我们配置了的话；我们将在下一章中讨论这个问题。
- en: You might have also noticed we are using an instruction within the Dockerfile
    we have not covered. Don't worry, we will look at the `VOLUME` instruction in
    [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml), *Managing Containers*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也注意到我们在 Dockerfile 中使用了一个我们还没有涉及的指令。别担心，我们将在[第4章](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)中讨论
    `VOLUME` 指令，*管理容器*。
- en: Using multi-stage builds
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多阶段构建
- en: In this, the final part of our journey into using Dockerfiles and building container
    images, we will look at using a relatively new method for building an image. In
    the previous sections of this part of the chapter, we looked at adding binaries
    directly to our images either via a package manager, such as Alpine Linux's APK,
    or, in the last example, by downloading a precompiled binary from the software
    vendor.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 Dockerfiles 和构建容器镜像的旅程的最后部分，我们将看看使用一种相对新的构建镜像的方法。在本章的前几节中，我们看到直接通过包管理器（例如
    Alpine Linux 的 APK）或者在最后一个示例中，通过从软件供应商下载预编译的二进制文件将二进制文件添加到我们的镜像。
- en: 'What if we wanted to compile our own software as part of the build? Historically,
    we would have had to use a container image containing a full build environment,
    which can be very big. This means that we probably would have had to cobble together
    a script that ran through something like the following process:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要在构建过程中编译我们自己的软件怎么办？从历史上看，我们将不得不使用包含完整构建环境的容器镜像，这可能非常庞大。这意味着我们可能不得不拼凑一个运行类似以下过程的脚本：
- en: Downloading the build environment container image and starting a "build" container
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载构建环境容器镜像并启动“构建”容器
- en: Copying the source code to the "build" container
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源代码复制到“构建”容器中
- en: Compiling the source code on the "build" container
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“构建”容器上编译源代码
- en: Copying the compiled binary outside of the "build" container
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译的二进制文件复制到“build”容器之外
- en: Removing the "build" container
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除“build”容器
- en: Using a pre-written Dockerfile to build an image and copy the binary to it
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用预先编写的Dockerfile构建镜像并将二进制文件复制到其中
- en: That is a lot of logic—in an ideal world, it should be part of Docker. Luckily,
    the Docker community thought so, and the functionality to achieve this, called
    a multi-stage build, was introduced in Docker 17.05.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多逻辑——在理想的世界中，它应该是Docker的一部分。幸运的是，Docker社区也这样认为，并在Docker 17.05中引入了实现这一功能的多阶段构建。
- en: 'The Dockerfile contains two different build stages. The first, named `builder`,
    uses the official Go container image from the Docker Hub. Here, we are installing
    a prerequisite, downloading the source code directly from GitHub, and then compiling
    it into a static binary:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile包含两个不同的构建阶段。第一个名为`builder`，使用来自Docker Hub的官方Go容器镜像。在这里，我们正在安装先决条件，直接从GitHub下载源代码，然后将其编译成静态二进制文件：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As our static binary has a built-in web server, we do not really need anything
    else to be present from an operating system point of view. Because of this, we
    are able to use `scratch` as the base image, meaning that all our image will contain
    is the static binary that we have copied from the builder image, and won't contain
    any of the `builder` environment at all.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的静态二进制文件具有内置的Web服务器，从操作系统的角度来看，我们实际上不需要其他任何东西。因此，我们可以使用`scratch`作为基础镜像，这意味着我们的镜像将只包含我们从构建镜像中复制的静态二进制文件，不会包含任何`builder`环境。
- en: 'To build the image, we just need to run the following command:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像，我们只需要运行以下命令：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output of the command can be found in the following code block—the interesting
    bits happen between steps 5 and 6:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的输出可以在以下代码块中找到——有趣的部分发生在第5步和第6步之间：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As you can see, between steps 5 and 6, our binary has been compiled and the
    container that contains the `builder` environment is removed, leaving us with
    an image storing our binary. Step 7 copies the binary to a fresh container which
    has been launched using scratch, leaving us with just the content we need.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在第5步和第6步之间，我们的二进制文件已经被编译，包含`builder`环境的容器已被移除，留下了存储我们二进制文件的镜像。第7步将二进制文件复制到使用scratch启动的新容器中，只留下我们需要的内容。
- en: 'If you were to run the following command, you would get an idea of why it is
    a good idea not to ship an application with its build environment intact:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行以下命令，你会明白为什么不应该将应用程序与其构建环境一起发布是个好主意：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The following screenshot of our output shows that the `golang` image is `794MB`;
    with our source code and prerequisites added, the size increases to `832MB`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的输出截图显示，`golang`镜像为`794MB`；加上我们的源代码和先决条件后，大小增加到`832MB`：
- en: '![](Images/c73e731e-21c0-461b-9e40-0ef64d69cfb5.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c73e731e-21c0-461b-9e40-0ef64d69cfb5.png)'
- en: However, the final image is just `6.56MB`. I am sure you will agree that this
    is quite a dramatic saving of space. It also adheres to the best practices, discussed
    earlier in the chapter, by only having content relevant to our application shipped
    within the image, as well as being really, really small.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终镜像只有`6.56MB`。我相信您会同意这是相当大的空间节省。它还遵循了本章前面讨论的最佳实践，只在镜像中包含与我们应用程序相关的内容，并且非常小。
- en: 'You can test the application by launching a container with the following command:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用以下命令启动一个容器来测试该应用程序：
- en: '[PRE62]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The application is accessible over a browser and simply increments a counter
    each time the page is loaded. To test it on macOS and Linux, you can use the `curl`
    command, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序可以通过浏览器访问，并在每次加载页面时简单地递增计数器。要在macOS和Linux上进行测试，可以使用`curl`命令，如下所示：
- en: '[PRE63]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This should give you something like the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给您类似以下的东西：
- en: '![](Images/0dd95dc9-af1e-401b-82c8-567ecff6abee.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0dd95dc9-af1e-401b-82c8-567ecff6abee.png)'
- en: 'Windows users can simply visit `http://localhost:8000/` in a browser. To stop
    and remove the running container, use the following commands:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户可以在浏览器中简单地访问`http://localhost:8000/`。要停止和删除正在运行的容器，请使用以下命令：
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As you can see, using a multi-stage build is a relatively simple process and
    is in keeping with the instructions that should already be starting to feel familiar.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用多阶段构建是一个相对简单的过程，并且符合应该已经开始感到熟悉的指令。
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at an in-depth view of Dockerfiles, the best practices
    for writing them, the docker image build command, and the various ways we can
    build containers. We also learned about the environmental variables that you can
    use to pass from your Dockerfile to the various items inside your containers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入了解了Dockerfiles，编写它们的最佳实践，docker image build命令以及我们可以构建容器的各种方式。我们还了解了可以从Dockerfile传递到容器内各个项目的环境变量。
- en: In the next chapter, now that we know how to build images using Dockerfiles,
    we will be taking a look at the Docker Hub and all of the advantages that using
    a registry service brings. We will also look at the Docker registry, which is
    open source, so you can roll your own place to store images without the fees of
    Docker Enterprise, as well as third-party registry services.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，现在我们知道如何使用Dockerfiles构建镜像，我们将看看Docker Hub以及使用注册表服务带来的所有优势。我们还将看看Docker注册表，它是开源的，因此您可以自己创建一个存储镜像的地方，而无需支付Docker
    Enterprise的费用，也可以使用第三方注册表服务。
- en: Questions
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True or false: The `LABEL` instruction tags your image once it has been built?'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：`LABEL`指令在构建完图像后会给图像打标签？
- en: What's the difference between the `ENTRYPOINT` and `CMD` instructions?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`和`CMD`指令之间有什么区别？'
- en: 'True or false: when using the `ADD` instruction, you can’t download and automatically
    uncompress an externally hosted archive?'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：使用`ADD`指令时，无法下载并自动解压外部托管的存档？
- en: What is a valid use for using an existing container as the base of your image?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用现有容器作为图像基础的有效用途是什么？
- en: What does the `EXPOSE` instruction expose?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`EXPOSE`指令暴露了什么？'
- en: Further reading
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find the guidelines for the official Docker container images at:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下位置找到官方Docker容器图像的指南：
- en: '[https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/)'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/docker-library/official-images/](https://github.com/docker-library/official-images/)'
- en: 'Some of the tools to help you create containers from existing installations
    are the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 一些帮助您从现有安装创建容器的工具如下：
- en: Debootstrap: [https://wiki.debian.org/Debootstrap/](https://wiki.debian.org/Debootstrap/)
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Debootstrap: [https://wiki.debian.org/Debootstrap/](https://wiki.debian.org/Debootstrap/)
- en: Yumbootstrap: [https://github.com/dozzie/yumbootstrap/](https://github.com/dozzie/yumbootstrap/)
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Yumbootstrap: [https://github.com/dozzie/yumbootstrap/](https://github.com/dozzie/yumbootstrap/)
- en: Rinse: [https://salsa.debian.org/debian/rinse/](https://salsa.debian.org/debian/rinse/)
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rinse: [https://salsa.debian.org/debian/rinse/](https://salsa.debian.org/debian/rinse/)
- en: Docker contrib scripts: [https://github.com/moby/moby/tree/master/contrib/](https://github.com/moby/moby/tree/master/contrib/)
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker contrib scripts: [https://github.com/moby/moby/tree/master/contrib/](https://github.com/moby/moby/tree/master/contrib/)
- en: 'Finally, the full GitHub repository for the Go HTTP Hello World application
    can be found at:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Go HTTP Hello World应用程序的完整GitHub存储库可以在以下位置找到：
- en: '[https://github.com/geetarista/go-http-hello-world/](https://github.com/geetarista/go-http-hello-world/)'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/geetarista/go-http-hello-world/](https://github.com/geetarista/go-http-hello-world/)'
