- en: '*Chapter 15*: Stateful Workloads on Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：Kubernetes上的有状态工作负载'
- en: This chapter details the current state of the industry when it comes to running
    stateful workloads in databases. We will discuss the use of Kubernetes (and popular
    open source projects) for running databases, storage, and queues on Kubernetes.
    Case study tutorials will include running object storage, a database, and a queue
    system on Kubernetes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了在数据库中运行有状态工作负载时行业的当前状态。我们将讨论在Kubernetes上运行数据库、存储和队列时使用Kubernetes（和流行的开源项目）。案例研究教程将包括在Kubernetes上运行对象存储、数据库和队列系统。
- en: In this chapter, we will first understand how stateful applications run on Kubernetes
    and then learn how to use Kubernetes storage for stateful applications. We will
    then learn how to run databases on Kubernetes, as well as covering messaging and
    queues. Let's start with a discussion of why stateful applications are much more
    complex than stateless applications on Kubernetes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解有状态应用在Kubernetes上的运行方式，然后学习如何使用Kubernetes存储来支持有状态应用。然后，我们将学习如何在Kubernetes上运行数据库，并涵盖消息传递和队列。让我们从讨论为什么有状态应用在Kubernetes上比无状态应用复杂得多开始。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding stateful applications on Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上理解有状态应用
- en: Using Kubernetes storage for stateful applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes存储支持有状态应用
- en: Running databases on Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行数据库
- en: Implementing messaging and queues on Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kubernetes上实现消息传递和队列
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods for getting up and running with Kubernetes
    quickly, and for instructions on how to install the kubectl tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章中详细介绍的命令，您需要一台支持`kubectl`命令行工具以及一个正常运行的Kubernetes集群的计算机。请参阅[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)，*与Kubernetes通信*，了解快速启动和安装kubectl工具的几种方法。
- en: 'The code used in this chapter can be found in the book''s GitHub repository:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在该书的GitHub存储库中找到：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter15)'
- en: Understanding stateful applications on Kubernetes
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上理解有状态应用
- en: Kubernetes provides excellent primitives for running both stateless and stateful
    applications, but stateful workloads have taken longer to mature on Kubernetes.
    However, in recent years, some high-profile Kubernetes-based stateful application
    frameworks and projects have proven the increasing maturity of stateful applications
    on Kubernetes. Let's review some of these first in order to set the stage for
    the rest of the chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为运行无状态和有状态应用提供了出色的基元，但有状态工作负载在Kubernetes上的成熟度要花更长时间。然而，近年来，一些基于Kubernetes的高调有状态应用框架和项目已经证明了Kubernetes上有状态应用日益成熟。让我们首先回顾其中一些，以便为本章的其余部分做铺垫。
- en: Popular Kubernetes-native stateful applications
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流行的Kubernetes原生有状态应用
- en: There are many types of stateful applications. Though most applications are
    stateful, only certain components in those applications store *state* data. We
    can remove these specific stateful components from applications and focus on those
    components in our review. In this book, we'll talk about databases, queues, and
    object storage, leaving out persistent storage components such as those we reviewed
    in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage on
    Kubernetes*. We'll also go over a few, less generic components as honorable mentions.
    Let's start with databases!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的有状态应用程序。虽然大多数应用程序都是有状态的，但只有其中某些组件存储*状态*数据。我们可以从应用程序中移除这些特定的有状态组件，并专注于我们审查的这些组件。在本书中，我们将讨论数据库、队列和对象存储，略过像我们在[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)中审查的持久存储组件，*Kubernetes上的存储*。我们还将介绍一些不太通用的组件作为荣誉提及。让我们从数据库开始！
- en: Kubernetes-compatible databases
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Kubernetes兼容的数据库
- en: 'In addition to typical **databases** (**DBs**) and key-value stores such as
    **Postgres**, **MySQL**, and **Redis** that can be deployed on Kubernetes with
    StatefulSets or community operators, there are some major made-for-Kubernetes
    options:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了典型的**数据库**（**DBs**）和可以使用StatefulSets或社区操作员部署在Kubernetes上的键值存储，如**Postgres**、**MySQL**和**Redis**，还有一些专为Kubernetes设计的重要选项：
- en: '**CockroachDB**: A distributed SQL database that can be deployed seamlessly
    on Kubernetes'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CockroachDB**：可以无缝部署在Kubernetes上的分布式SQL数据库'
- en: '**Vitess**: A MySQL sharding orchestrator that allows global scalability for
    MySQL, also installable on Kubernetes via an operator'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vitess**：一个MySQL分片编排器，允许MySQL全球可扩展性，也可以通过操作员在Kubernetes上安装'
- en: '**YugabyteDB**: A distributed SQL database similar to **CockroachDB** that
    also supports Cassandra-like querying'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YugabyteDB**：类似于**CockroachDB**的分布式SQL数据库，还支持类似Cassandra的查询'
- en: Next, let's look at queuing and messaging on Kubernetes.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Kubernetes上的排队和消息传递。
- en: Queues, streaming, and messaging on Kubernetes
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes上的队列、流和消息传递
- en: 'Again, there are industry-standard options such as **Kafka** and **RabbitMQ**
    that can be deployed on Kubernetes using community Helm charts and operators,
    in addition to some purpose-made open- and closed-source options:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，有一些行业标准选项，如**Kafka**和**RabbitMQ**，可以使用社区Helm图表和操作员部署在Kubernetes上，另外还有一些专门开源和闭源选项：
- en: '**NATS**: Open source messaging and streaming system'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NATS**：开源消息传递和流系统'
- en: '**KubeMQ**: Kubernetes-native message broker'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**KubeMQ**：Kubernetes本地消息代理'
- en: Next, let's look at object storage on Kubernetes.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看Kubernetes上的对象存储。
- en: Object storage on Kubernetes
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes上的对象存储
- en: 'Object storage takes volume-based persistent storage from Kubernetes and adds
    on an object storage layer, similar to (and in many cases compatible with the
    API of) Amazon S3:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储从Kubernetes获取基于卷的持久存储，并添加一个对象存储层，类似于（在许多情况下与Amazon S3的API兼容）：
- en: '**Minio**: S3-compatible object storage built for high performance.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minio**：为高性能而构建的与S3兼容的对象存储。'
- en: '**Open IO**: Similar to *Minio*, this has high performance and supports S3
    and Swift storage.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Open IO**：类似于*Minio*，具有高性能并支持S3和Swift存储。'
- en: Next, let's look at a few honorable mentions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看一些荣誉提及。
- en: Honorable mentions
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 荣誉提及
- en: 'In addition to the preceding generic components, there are some more specialized
    (but still categorical) stateful applications that can be run on Kubernetes:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前述的通用组件，还有一些更专业（但仍然分类的）有状态应用程序可以在Kubernetes上运行：
- en: '**Key and auth management**: **Vault**, **Keycloak**'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥和认证管理**：**Vault**、**Keycloak**'
- en: '**Container registries**: **Harbor**, **Dragonfly**, **Quay**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器注册表**：**Harbor**、**Dragonfly**、**Quay**'
- en: '**Workflow management**: **Apache Airflow** with a Kubernetes Operator'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流管理**：带有Kubernetes操作员的**Apache Airflow**'
- en: Now that we've reviewed a few categories of stateful applications, let's talk
    about how these state-heavy applications are typically implemented on Kubernetes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经回顾了一些有状态应用程序的类别，让我们谈谈这些状态密集型应用程序在Kubernetes上通常是如何实现的。
- en: Understanding strategies for running stateful applications on Kubernetes
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解在Kubernetes上运行有状态应用程序的策略
- en: Though there is nothing inherently wrong with deploying a stateful application
    on Kubernetes with a ReplicaSet or Deployment, you will find that the majority
    of stateful applications on Kubernetes use StatefulSets. We talked about StatefulSets
    in [*Chapter 4*](B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106), *Scaling and
    Deploying Your Application*, but why are they so useful for applications? We will
    review and answer this question in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用ReplicaSet或Deployment在Kubernetes上部署有状态应用程序并没有本质上的问题，但你会发现大多数在Kubernetes上的有状态应用程序使用StatefulSets。我们在[*第4章*](B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106)中讨论了StatefulSets，*扩展和部署您的应用程序*，但为什么它们对应用程序如此有用？我们将在本章中回顾并回答这个问题。
- en: The main reason is Pod identity. Many distributed stateful applications have
    their own clustering mechanism or consensus algorithm. In order to smooth over
    the process for these types of applications, StatefulSets provide static Pod naming
    based on an ordinal system, starting from `0` to `n`. This, in combination with
    a rolling update and creation method, makes it much easier for applications to
    cluster themselves, which is extremely important for cloud-native databases such
    as CockroachDB.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是Pod身份。许多分布式有状态应用程序都有自己的集群机制或共识算法。为了简化这些类型应用程序的流程，StatefulSets提供了基于顺序系统的静态Pod命名，从`0`到`n`。这个特性，再加上滚动更新和创建方法，使得应用程序更容易集群化，这对于像CockroachDB这样的云原生数据库非常重要。
- en: To illustrate how and why StatefulSets can help run stateful applications on
    Kubernetes, let's look at how we might run MySQL on Kubernetes with StatefulSets.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明StatefulSets如何帮助在Kubernetes上运行有状态应用程序，让我们看看如何使用StatefulSets在Kubernetes上运行MySQL。
- en: Now, to be clear, running a single Pod of MySQL on Kubernetes is extremely simple.
    All we need to do is find a MySQL container image and ensure that it has the proper
    configuration and `startup` command.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要明确一点，在Kubernetes上运行单个MySQL Pod非常简单。我们只需要找到一个MySQL容器镜像，并确保它具有适当的配置和`startup`命令。
- en: However, when we look to scale our database, we start to run into issues. Unlike
    a simple stateless application, where we can scale our deployment without creating
    new state, MySQL (like many other DBs) has its own method of clustering and consensus.
    Each member of a MySQL cluster knows about the other members, and most importantly,
    it knows which member of the cluster is the leader. This is how databases like
    MySQL can offer consistency guarantees and **Atomicity, Consistency, Isolation,
    Durability** (**ACID**) compliance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们试图扩展我们的数据库时，我们开始遇到问题。与简单的无状态应用程序不同，我们可以在不创建新状态的情况下扩展我们的部署，MySQL（像许多其他数据库一样）有自己的集群和共识方法。MySQL集群的每个成员都知道其他成员，最重要的是，它知道集群的领导者是哪个成员。这就是像MySQL这样的数据库可以提供一致性保证和**原子性、一致性、隔离性、持久性**（**ACID**）合规性的方式。
- en: Therefore, since each member in a MySQL cluster needs to know about the other
    members (and most importantly, the master), we need to run our DB Pods in a way
    that means they have a common way to find and communicate with the other members
    of the DB cluster.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于MySQL集群中的每个成员都需要知道其他成员（最重要的是主节点），我们需要以一种方式运行我们的DB Pods，以便它们有一个共同的方式来找到并与DB集群的其他成员进行通信。
- en: The way that StatefulSets offer this is, as we mentioned at the beginning of
    the section, via ordinal Pod numbering. This way, applications that need to self-cluster
    while running on Kubernetes know that a common naming scheme starting from `0`
    to `n` will be used. In addition, when a Pod at a specific ordinal restarts –
    for instance, `mysql-pod-2` – the same PersistentVolume will be mounted to the
    new Pod that starts in that ordinal spot. This allows for stateful consistency
    between restarts for a single Pod in a StatefulSet, which makes it much easier
    for applications to form a stable cluster.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets提供这种功能的方式，正如我们在本节开头提到的，是通过Pod的序数编号。这样，运行在Kubernetes上需要自我集群的应用程序就知道，将使用从`0`到`n`开始的常见命名方案。此外，当特定序数的Pod重新启动时，例如`mysql-pod-2`，相同的PersistentVolume将被挂载到在该序数位置启动的新Pod上。这允许在StatefulSet中单个Pod重新启动时保持状态的一致性，这使得应用程序更容易形成稳定的集群。
- en: To see how this works in practice, let's look at a StatefulSet specification
    for MySQL.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这在实践中是如何工作的，让我们看一下MySQL的StatefulSet规范。
- en: Running MySQL on StatefulSets
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在StatefulSets上运行MySQL
- en: The following YAML spec is adapted from the Kubernetes documentation version.
    It shows how we can run MySQL clusters on StatefulSets. We will review each part
    of the YAML spec separately, so we can understand exactly how the mechanisms interact
    with StatefulSet guarantees.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的YAML规范是从Kubernetes文档版本中调整的。它展示了我们如何在StatefulSets上运行MySQL集群。我们将分别审查YAML规范的每个部分，以便我们可以准确理解这些机制如何与StatefulSet的保证相互作用。
- en: 'Let''s start with the first part of the spec:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从规范的第一部分开始：
- en: statefulset-mysql.yaml
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: statefulset-mysql.yaml
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, we are going to be creating a MySQL cluster with three `replicas`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们将创建一个具有三个`replicas`的MySQL集群。
- en: 'There isn''t much else exciting about this piece, so let''s move onto the start
    of `initContainers`. There will be quite a few containers running in this Pod
    between `initContainers` and regular containers, so we will explain each separately.
    What follows is the first `initContainer` instance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段内容没有太多其他令人兴奋的地方，所以让我们继续讨论`initContainers`的开始。在`initContainers`和常规容器之间，将有相当多的容器在此Pod中运行，因此我们将分别解释每个容器。接下来是第一个`initContainer`实例：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This first `initContainer`, as you can see, is the MySQL container image. Now,
    this doesn't mean that we won't have the MySQL container running constantly in
    the Pod. This is a pattern you will tend to see fairly often with complex applications.
    Sometimes the same container image is used as both an `initContainer` instance
    and a normally running container in a Pod. This is because that container has
    the correct embedded scripts and tools to do common setup tasks programmatically.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个`initContainer`，正如你所看到的，是MySQL容器镜像。现在，这并不意味着我们不会在Pod中持续运行MySQL容器。这是一个你会经常在复杂应用中看到的模式。有时相同的容器镜像既用作`initContainer`实例，又用作Pod中正常运行的容器。这是因为该容器具有正确的嵌入式脚本和工具，可以以编程方式执行常见的设置任务。
- en: In this example, the MySQL `initContainer` creates a file, `/mnt/conf.d/server-id.cnf`,
    and adds a `server` ID, corresponding to the Pod's `ordinal` ID in the StatefulSet,
    to the file. When writing the `ordinal` ID, it adds `100` as an offset, to get
    around the reserved value in MySQL of a `server-id` ID of `0`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，MySQL的`initContainer`创建一个文件`/mnt/conf.d/server-id.cnf`，并向文件中添加一个`server`
    ID，该ID对应于StatefulSet中Pod的`ordinal` ID。在写入`ordinal` ID时，它添加了`100`作为偏移量，以避免MySQL中`server-id`
    ID的保留值为`0`。
- en: Then, depending on whether the Pod `ordinal` D is `0` or not, it copies configuration
    for either a master or slave MySQL server to the volume.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，根据Pod的`ordinal` D是否为`0`，它将配置复制到卷中，用于主MySQL服务器或从MySQL服务器。
- en: 'Next, let''s look at the second `initContainer` in the following section (we''ve
    left out some code with volume mount information for brevity, but the full code
    is available in the GitHub repository of the book):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下下一节中的第二个`initContainer`（为了简洁起见，我们省略了一些卷挂载信息的代码，但完整的代码可以在本书的GitHub存储库中找到）：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this `initContainer` isn't MySQL at all! Instead, the container
    image is a tool called Xtra Backup. Why do we need this container?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个`initContainer`根本不是MySQL！相反，容器镜像是一个叫做Xtra Backup的工具。为什么我们需要这个容器呢？
- en: Consider a situation where a brand-new Pod, with a brand-new, empty PersistentVolume
    joins the cluster. In this scenario, the data replication processes will need
    to copy all of the data via replication from the other members in the MySQL cluster.
    With large databases, this process could be exceedingly slow.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况：一个全新的Pod，带有全新的空的持久卷加入了集群。在这种情况下，数据复制过程将需要通过从MySQL集群中的其他成员进行复制来复制所有数据。对于大型数据库来说，这个过程可能会非常缓慢。
- en: For this reason, we have an `initContainer` instance that loads in data from
    another MySQL Pod in the StatefulSet, so that the data replication capabilities
    of MySQL have something to start with. In a case where there is already data in
    the MySQL Pod, this loading of data does not occur. The `[[ -d /var/lib/mysql/mysql
    ]] && exit 0` line is the one that checks to see whether there is existing data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有一个`initContainer`实例，它从StatefulSet中的另一个MySQL Pod中加载数据，以便MySQL的数据复制功能有一些数据可供使用。如果MySQL
    Pod中已经有数据，则不会加载数据。`[[ -d /var/lib/mysql/mysql ]] && exit 0`这一行是用来检查是否存在现有数据的。
- en: Once these two `initContainer` instances have successfully completed their tasks,
    we have all our MySQL configuration courtesy of the first `initContainer`, and
    we have a somewhat recent set of data from another member in the MySQL StatefulSet.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这两个`initContainer`实例成功完成了它们的任务，我们就有了所有MySQL配置，这得益于第一个`initContainer`，并且我们从MySQL
    StatefulSet的另一个成员那里得到了一组相对较新的数据。
- en: 'Now, let''s move on to the actual containers in the StatefulSet definition,
    starting with MySQL itself:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论StatefulSet定义中的实际容器，从MySQL本身开始：
- en: '[PRE3]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this MySQL container setup is fairly basic. In addition to an
    environment variable, we mount the previously created configuration. This pod
    also has some liveness and readiness probe configuration – check the GitHub repository
    of this book for those.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个MySQL容器设置相当基本。除了环境变量外，我们还挂载了之前创建的配置。这个Pod还有一些存活和就绪探针配置 - 请查看本书的GitHub存储库了解详情。
- en: 'Now, let''s move on and check out our final container, which will look familiar
    – it''s actually another instance of Xtra Backup! Let''s see how it is configured:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续查看我们的最终容器，这看起来很熟悉 - 实际上是另一个Xtra Backup的实例！让我们看看它是如何配置的：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This container setup is a bit complex, so let's review it section by section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器设置有点复杂，所以让我们逐节审查一下。
- en: We know from our `initContainers` that Xtra Backup loads in data from another
    Pod in the StatefulSet in order to get the Pod somewhat ready for replicating,
    to and from other members in the StatefulSet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`initContainers`知道，Xtra Backup会从StatefulSet中的另一个Pod中加载数据，以便为复制到StatefulSet中的其他成员做好准备。
- en: The Xtra Backup container in this case is the one that actually starts that
    replication! This container will first check to see whether the Pod it is running
    on is supposed to be a slave Pod in the MySQL cluster. If so, it will start a
    data replication process from the master.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Xtra Backup容器实际上启动了复制！这个容器首先会检查它所在的Pod是否应该是MySQL集群中的从属Pod。如果是，它将从主节点开始数据复制过程。
- en: Finally, the Xtra Backup container will also open a listener on port `3307`,
    which will send a clone of the data in the Pod, if requested. This is the setup
    that sends clone data to the other Pods in the StatefulSet when they request a
    clone. Remember that the first `initContainer` looks at other Pods in the StatefulSet,
    in order to get a clone. In the end, each Pod in the StatefulSet is able to request
    clones in addition to running a process that can send data clones to other Pods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Xtra Backup容器还将在端口`3307`上打开一个监听器，如果请求，将向Pod中的数据发送一个克隆。这是在其他StatefulSet中的Pod请求克隆时发送克隆数据的设置。请记住，第一个`initContainer`查看StatefulSet中的其他Pod，以便获取克隆。最后，StatefulSet中的每个Pod都能够请求克隆，以及运行一个可以向其他Pod发送数据克隆的进程。
- en: 'Finally, to wrap up our spec, let''s look at `volumeClaimTemplate`. This section
    of the spec also lists volume mounts for the previous container and the volume
    setup for the Pod (but we''ve left that out for brevity. Check the GitHub repository
    of this book for the rest):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下`volumeClaimTemplate`。规范的这一部分还列出了先前容器的卷挂载和Pod的卷设置（但出于简洁起见，我们将其省略。请查看本书的GitHub存储库以获取其余部分）：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, there's nothing especially interesting about the volume setup
    for the last container or the volume list. However, it's worthwhile to note the
    `volumeClaimTemplates` section, because the data will remain the same as long
    as a Pod restarts at the same ordinal spot. A new Pod added to the cluster will
    instead start with a blank PersistentVolume, which will trigger the initial data
    clone.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，最后一个容器或卷列表的卷设置并没有什么特别有趣的地方。然而，值得注意的是`volumeClaimTemplates`部分，因为只要Pod在相同的序数位置重新启动，数据就会保持不变。集群中添加的新Pod将以空白的PersistentVolume开始，这将触发初始数据克隆。
- en: All together, these features of StatefulSets, in combination with the correct
    configuration of Pods and tooling, allow for the easy scaling of a stateful DB
    on Kubernetes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些StatefulSets的特性，再加上Pods和工具的正确配置，都可以让在Kubernetes上轻松扩展有状态的数据库。
- en: Now that we've talked about why stateful Kubernetes applications may use StatefulSets,
    let's go ahead and implement some to prove it! We'll start with an object storage
    application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了为什么有状态的Kubernetes应用程序可能会使用StatefulSets，让我们继续实施一些来证明它！我们将从一个对象存储应用程序开始。
- en: Deploying object storage on Kubernetes
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署对象存储
- en: Object storage is different from filesystem or block storage. It presents a
    higher-level abstraction that encapsulates a file, gives it an identifier, and
    often includes versioning. The file can then be accessed via its specific identifier.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储与文件系统或块存储不同。它提供了一个封装文件的更高级抽象，给它一个标识符，并经常包括版本控制。然后可以通过其特定标识符访问文件。
- en: The most popular object storage service is probably AWS S3, but Azure Blob Storage
    and Google Cloud Storage are similar alternatives. In addition, there are several
    self-hosted object storage technologies that can be run on Kubernetes, which we
    reviewed in the previous section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的对象存储服务可能是AWS S3，但Azure Blob Storage和Google Cloud Storage是类似的替代方案。此外，还有几种可以在Kubernetes上运行的自托管对象存储技术，我们在上一节中进行了审查。
- en: For this book, we will review the configuration and usage of **Minio** on Kubernetes.
    Minio is an object storage engine that emphasizes high performance and can be
    deployed on Kubernetes, in addition to other orchestration technologies such as
    **Docker Swarm** and **Docker Compose**.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将回顾在Kubernetes上配置和使用Minio。Minio是一个强调高性能的对象存储引擎，可以部署在Kubernetes上，除了其他编排技术，如Docker
    Swarm和Docker Compose。
- en: Minio supports Kubernetes deployments using both an operator and a Helm chart.
    In this book, we will focus on the operator, but for more information on the Helm
    chart, check out the Minio docs at [https://docs.min.io/docs](https://docs.min.io/docs).
    Let's get started with the Minio Operator, which will let us review some cool
    community extensions to kubectl.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Minio支持使用运算符和Helm图表进行Kubernetes部署。在本书中，我们将专注于运算符，但有关Helm图表的更多信息，请查看Minio文档[https://docs.min.io/docs](https://docs.min.io/docs)。让我们开始使用Minio
    Operator，这将让我们审查一些很酷的社区扩展到kubectl。
- en: Installing the Minio Operator
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Minio Operator
- en: Installing the Minio Operator will be quite different from anything we have
    done so far. Minio actually provides a `kubectl` plugin in order to manage the
    installation and configuration of the operator and Minio as a whole.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Minio Operator将与我们迄今为止所做的任何事情都大不相同。实际上，Minio提供了一个`kubectl`插件，以便管理运算符和整个Minio的安装和配置。
- en: We haven't spoken much about `kubectl` plugins in this book, but they are a
    growing part of the Kubernetes ecosystem. `kubectl` plugins can provide additional
    functionality in the form of new `kubectl` commands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们并没有多谈`kubectl`插件，但它们是Kubernetes生态系统中不断增长的一部分。`kubectl`插件可以提供额外的功能，以新的`kubectl`命令的形式。
- en: In order to install the `minio` kubectl plugin, we use Krew, which is a plugin
    manager for `kubectl` that makes it easy to search and add `kubectl` plugins with
    a single command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装`minio` kubectl插件，我们使用Krew，这是一个`kubectl`的插件管理器，可以通过一个命令轻松搜索和添加`kubectl`插件。
- en: Installing Krew and the Minio kubectl plugin
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Krew和Minio kubectl插件
- en: 'So first, let''s install Krew. The installation process varies depending on
    your OS and environment, but for macOS, it looks like the following (check out
    the Krew docs at [https://krew.sigs.k8s.io/docs](https://krew.sigs.k8s.io/docs)
    for more information):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所以首先，让我们安装Krew。安装过程取决于您的操作系统和环境，但对于macOS，它看起来像以下内容（查看[Krew文档](https://krew.sigs.k8s.io/docs)以获取更多信息）：
- en: 'First, let''s install the Krew CLI tool with the following Terminal commands:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下终端命令安装Krew CLI工具：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can add Krew to our `PATH` variable with the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下命令将Krew添加到我们的`PATH`变量中：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In a new shell, we can now start using Krew! Krew is accessed using `kubectl
    krew` commands.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的shell中，我们现在可以开始使用Krew！Krew可以使用`kubectl krew`命令访问。
- en: 'To install the Minio kubectl plugin, you can run the following `krew` command:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装Minio kubectl插件，您可以运行以下`krew`命令：
- en: '[PRE8]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, with the Minio kubectl plugin installed, let's look at getting Minio set
    up on our cluster.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，安装了Minio kubectl插件，让我们看看如何在我们的集群上设置Minio。
- en: Starting the Minio Operator
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动Minio Operator
- en: 'First off, we need to actually install the Minio Operator on our cluster. This
    deployment will control all the Minio tasks that we need to do later:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的集群上安装Minio Operator。这个部署将控制我们以后需要做的所有Minio任务：
- en: 'We can install the Minio Operator using the following command:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装Minio Operator：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will result in the following output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To check whether the Minio Operator is ready to go, let''s check on our Pods
    with the following command:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查Minio Operator是否准备就绪，让我们用以下命令检查我们的Pods：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see the Minio Operator Pod running in the output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在输出中看到Minio Operator Pod正在运行：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now have the Minio Operator running properly on Kubernetes. Next up, we can
    create a Minio tenant.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在Kubernetes上正确运行Minio Operator。接下来，我们可以创建一个Minio租户。
- en: Creating a Minio tenant
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个Minio租户
- en: The next step is to create a **tenant**. Since Minio is a multi-tenant system,
    each tenant has its own namespace separation for buckets and objects, in addition
    to separate PersistentVolumes. Additionally, the Minio Operator starts Minio in
    Distributed Mode with a highly available setup and data replication.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个**租户**。由于Minio是一个多租户系统，每个租户都有自己的命名空间，用于存储桶和对象，另外还有单独的持久卷。此外，Minio Operator以高可用设置和数据复制的方式启动Minio分布式模式。
- en: Before creating our Minio tenant, we need to install a **Container Storage Interface**
    (**CSI**) driver for Minio. CSI is a standardized way to interface between storage
    providers and containers – and Kubernetes implements CSI in order to allow third-party
    storage providers to write their own drivers for seamless integration to Kubernetes.
    Minio recommends the Direct CSI driver in order to manage PersistentVolumes for
    Minio.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Minio租户之前，我们需要为Minio安装一个**容器存储接口**（**CSI**）驱动程序。CSI是存储提供商和容器之间的标准化接口方式，Kubernetes实现了CSI，以允许第三方存储提供商编写自己的驱动程序，以便无缝集成到Kubernetes中。Minio建议使用Direct
    CSI驱动程序来管理Minio的持久卷。
- en: 'To install the Direct CSI driver, we need to run a `kubectl apply` command
    with Kustomize. However, the Direct CSI driver installation requires some environment
    variables to be set in order to create the Direct CSI configuration with the proper
    configuration, as shown:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Direct CSI驱动程序，我们需要使用Kustomize运行`kubectl apply`命令。然而，Direct CSI驱动程序的安装需要设置一些环境变量，以便根据正确的配置创建Direct
    CSI配置，如下所示：
- en: 'First, let''s go ahead and create this environment file based on the Minio
    recommendations:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们根据Minio的建议来创建这个环境文件：
- en: default.env
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 默认.env
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this environment file determines where the Direct CSI driver
    will mount volumes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个环境文件确定了Direct CSI驱动程序将挂载卷的位置。
- en: 'Once we''ve created `default.env`, let''s load these variables into memory
    using the following command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们创建了`default.env`，让我们使用以下命令将这些变量加载到内存中：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, let''s install the Direct CSI driver with the following command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令安装Direct CSI驱动程序：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should result in the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Before we go ahead and create our Minio tenant, let''s check to see whether
    our CSI Pods started up properly. Run the following command to check:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续创建Minio租户之前，让我们检查一下我们的CSI Pods是否已经正确启动。运行以下命令进行检查：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see output similar to the following if the CSI Pods have started:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CSI Pods已经启动，你应该会看到类似以下的输出：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now with our CSI driver installed, let''s create our Minio tenant – but first,
    let''s take a look at the YAML that the `kubectl minio tenant create` command
    generates:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的CSI驱动程序已安装，让我们创建Minio租户 - 但首先，让我们看一下`kubectl minio tenant create`命令生成的YAML：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you want to directly create the Minio tenant without examining the YAML,
    use the following command instead:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想直接创建Minio租户而不检查YAML，可以使用以下命令：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command will just create the tenant without showing you the YAML first.
    However, since we are using the Direct CSI implementation, we will need to update
    the YAML. So, using just the command will not work. Let's take a look at the generated
    YAML file now.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令只会创建租户，而不会先显示YAML。然而，由于我们使用的是Direct CSI实现，我们需要更新YAML。因此，仅使用命令是行不通的。现在让我们来看一下生成的YAML文件。
- en: 'We won''t look at the file in its entirety for space reasons, but let''s look
    at some parts of the `Tenant` **Custom Resource Definition** (**CRD**), which
    the Minio Operator will use to create the necessary resources to host our Minio
    tenant. First, let''s look at the upper portion of the spec, which should look
    like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 出于空间原因，我们不会完整查看文件，但让我们看一下`Tenant`**自定义资源定义**（**CRD**）的一些部分，Minio Operator将使用它来创建托管我们的Minio租户所需的资源。首先，让我们看一下规范的上部分，应该是这样的：
- en: my-minio-tenant.yaml
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: my-minio-tenant.yaml
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this file specifies an instance of the `Tenant` CRD. This first
    part of our spec has two containers specified, a container for the Minio console
    and one for the Minio `server` itself. In addition, the `replicas` value mirrors
    what we specified in our `kubectl minio tenant create` command. Finally, it specifies
    the name of a secret for the Minio `console`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，此文件指定了`Tenant` CRD的一个实例。我们的规范的第一部分指定了两个容器，一个用于Minio控制台，另一个用于Minio `server`本身。此外，`replicas`值反映了我们在`kubectl
    minio tenant create`命令中指定的内容。最后，它指定了Minio`console`的秘钥的名称。
- en: 'Next, let''s look at the bottom portion of the Tenant CRD:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下Tenant CRD的底部部分：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, the `Tenant` resource specifies a number of servers (also specified
    by the `creation` command) that matches the number of replicas. It also specifies
    the name of the internal Minio Service, as well as a `volumeClaimTemplate` instance
    to be used.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Tenant`资源指定了一些服务器（也由`creation`命令指定），与副本的数量相匹配。它还指定了内部Minio服务的名称，以及要使用的`volumeClaimTemplate`实例。
- en: 'This spec, however, does not work for our purposes, since we are using the
    Direct CSI. Let''s update the `zones` key with a new `volumeClaimTemplate` that
    uses the Direct CSI, as follows (save this file as `my-updated-minio-tenant.yaml`).
    Here''s just the `zones` portion of that file, which we updated:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规范对我们的目的不起作用，因为我们正在使用Direct CSI。让我们使用一个使用Direct CSI的新`volumeClaimTemplate`来更新`zones`密钥，如下所示（将此文件保存为`my-updated-minio-tenant.yaml`）。这里只是该文件的`zones`部分，我们已经更新了：
- en: my-updated-minio-tenant.yaml
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: my-updated-minio-tenant.yaml
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s now go ahead and create our Minio tenant! We can do this using the following
    command:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续创建我们的Minio租户！我们可以使用以下命令来完成：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should result in the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致以下输出：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point, the Minio Operator will start creating the necessary resources
    for our new Minio tenant, and after a couple of minutes, you should see some Pods
    start up in addition to the operator, which will look similar to the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Minio Operator将开始为我们的新Minio租户创建必要的资源，几分钟后，除了运算符之外，您应该看到一些Pods启动，类似于以下内容：
- en: '![Figure 15.1 – Minio Pods output'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 – Minio Pods 输出'
- en: '](image/B14790_15_001.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B14790_15_001.jpg)'
- en: Figure 15.1 – Minio Pods output
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 – Minio Pods 输出
- en: We now have our Minio tenant completely up and running! Next, let's take a look
    at the Minio console to see how our tenant looks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的Minio租户已经完全运行起来了！接下来，让我们看一下Minio控制台，看看我们的租户是什么样子的。
- en: Accessing the Minio console
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Minio控制台
- en: First, in order to get the login information for the console, we will need to
    fetch the content of two keys, which are kept in the autogenerated `<TENANT NAME>-console-secret`
    secret.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了获取控制台的登录信息，我们需要获取两个密钥的内容，这些密钥保存在自动生成的`<TENANT NAME>-console-secret`秘钥中。
- en: 'To fetch the `access` key and the `secret` key (which in our case will be autogenerated)
    for the console, let''s use the two following commands. In our case, we use our
    `my-tenant` tenant to get the `access` key:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取控制台的`access`密钥和`secret`密钥（在我们的情况下将是自动生成的），让我们使用以下两个命令。在我们的情况下，我们使用我们的`my-tenant`租户来获取`access`密钥：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And to get the `secret` key, we use this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取`secret`密钥，我们使用以下命令：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now, our Minio console will be available on a service, `<TENANT NAME>-console`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的Minio控制台将在一个名为`<TENANT NAME>-console`的服务上可用。
- en: 'Let''s access this console using a `port-forward` command. In our case, this
    will be as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`port-forward`命令访问这个控制台。在我们的情况下，这将是如下所示：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Our Minio console will then be available at `https://localhost:8081` on your
    browser. You will need to accept the browser security warning since we haven't
    set up TLS certificates for the console for localhost in this example. Put in
    the `access` key and `secret` key you got from the previous steps to log in!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们的Minio控制台将在浏览器上的`https://localhost:8081`上可用。您需要接受浏览器的安全警告，因为在这个示例中，我们还没有为本地主机的控制台设置TLS证书。输入从前面步骤中获得的`access`密钥和`secret`密钥来登录！
- en: Now that we're logged into the console, we can start adding to our Minio tenant.
    First, let's create a bucket. To do this, click **Buckets** on the left sidebar,
    then click the **Create Bucket** button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经登录到控制台，我们可以开始向我们的Minio租户添加内容。首先，让我们创建一个存储桶。要做到这一点，点击左侧边栏上的**存储桶**，然后点击**创建存储桶**按钮。
- en: 'In the popup, enter the name of the bucket (in our case, we will use `my-bucket`)
    and submit the form. You should see a new bucket in the list – see the following
    screenshot for an example:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹出窗口中，输入存储桶的名称（在我们的情况下，我们将使用`my-bucket`）并提交表单。您应该在列表中看到一个新的存储桶 - 请参阅以下截图以获取示例：
- en: '![Figure 15.2 – Bucket](image/B14790_15_002.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图15.2 - 存储桶](image/B14790_15_002.jpg)'
- en: Figure 15.2 – Bucket
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 存储桶
- en: We now have our distributed Minio setup ready, together with a bucket to upload
    to. Let's wrap this example up by uploading a file to our brand-new object storage
    system!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的分布式Minio设置已经准备就绪，还有一个要上传的存储桶。让我们通过向我们全新的对象存储系统上传文件来结束这个示例！
- en: We're going to do this upload using the Minio CLI, which makes the process of
    interacting with S3-compatible storage such as Minio much easier. Instead of using
    the Minio CLI from our local machine, we will run a container image preloaded
    with the Minio CLI from within Kubernetes, since the TLS setup will only work
    when accessing Minio from within the cluster.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Minio CLI进行上传，这使得与Minio等兼容S3存储进行交互的过程变得更加容易。我们将在Kubernetes内部运行一个预加载了Minio
    CLI的容器镜像，而不是从我们的本地机器使用Minio CLI，因为只有在集群内访问Minio时TLS设置才能生效。
- en: 'First, we''ll need to fetch the Minio `access` key and `secret`, which are
    different from the console `access` key and `secret` we fetched earlier. To get
    these keys, run the following console commands (in our case, our tenant is `my-tenant`).
    First, get the `access` key:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要获取Minio的`access`密钥和`secret`，这与我们之前获取的控制台`access`密钥和`secret`不同。要获取这些密钥，运行以下控制台命令（在我们的情况下，我们的租户是`my-tenant`）。首先，获取`access`密钥：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, get the `secret` key:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，获取`secret`密钥：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s start up that pod with the Minio CLI. To do this, let''s use this
    Pod spec:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动带有Minio CLI的Pod。为此，让我们使用以下Pod规范：
- en: minio-mc-pod.yaml
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: minio-mc-pod.yaml
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Create this Pod using this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建这个Pod：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, to `exec` into this `minio-mc` Pod, we run the usual `exec` command:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要`exec`进入这个`minio-mc` Pod，我们运行通常的`exec`命令：
- en: '[PRE33]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now, let''s configure access for our newly created Minio distributed cluster
    in the Minio CLI. We can do this with the following command (the `--insecure`
    flag is required in this config):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Minio CLI中为我们新创建的Minio分布式集群配置访问。我们可以使用以下命令来完成这个操作（在这个配置中，`--insecure`标志是必需的）：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The Pod IP for this command can be the IP for either of our tenant Minio Pods
    – in our case, these are `my-tenant-zone-0-0` and `my-tenant-zone-0-1`. Once you
    run this command, you will be prompted for the access key and secret key. Enter
    them, and you will see a confirmation message if successful, which will look like
    this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的Pod IP可以是我们的任一租户Minio Pods的IP - 在我们的情况下，这些是`my-tenant-zone-0-0`和`my-tenant-zone-0-1`。运行此命令后，系统将提示您输入访问密钥和秘密密钥。输入它们，如果成功，您将看到一个确认消息，看起来像这样：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, to test that the CLI configuration is working, we can create another test
    bucket using the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了测试CLI配置是否正常工作，我们可以使用以下命令创建另一个测试存储桶：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should result in the following output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE37]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As a final test of our setup, let's upload a file to our Minio bucket!
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们设置的最后一个测试，让我们将一个文件上传到我们的Minio存储桶！
- en: First, still on the `minio-mc` Pod, create a text file named `test.txt`. Fill
    the file with whatever text you'd like.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，仍然在`minio-mc` Pod上，创建一个名为`test.txt`的文本文件。用任何您喜欢的文本填充文件。
- en: 'Now, let''s upload it to our recently created bucket using this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令将其上传到我们最近创建的存储桶中：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You should see a loading bar with the upload, which should end with the entire
    file size as uploaded.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该会看到一个带有上传进度的加载栏，最终显示整个文件大小已上传。
- en: 'As one last check, go to the **Dashboard** page on the Minio console and see
    whether the object shows up, as shown in the following figure:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的检查，转到Minio控制台上的**仪表板**页面，查看对象是否显示出来，如下图所示：
- en: '![Figure 15.3 – Dashboard](image/B14790_15_003.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图15.3 – 仪表板](image/B14790_15_003.jpg)'
- en: Figure 15.3 – Dashboard
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 – 仪表板
- en: As you can see, our file was successfully uploaded!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的文件已成功上传！
- en: That's it for Minio – there is a lot more you can do in terms of configuration,
    but that is outside the scope of this book. Check the docs at [https://docs.min.io/](https://docs.min.io/)
    for more information.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些关于Minio的内容 - 在配置方面还有很多事情可以做，但这超出了本书的范围。请查看[https://docs.min.io/](https://docs.min.io/)上的文档以获取更多信息。
- en: Next up, let's look at running DBs on Kubernetes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看在Kubernetes上运行数据库。
- en: Running DBs on Kubernetes
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行数据库
- en: Now that we've taken a look at object storage workloads on Kubernetes, we can
    move on to databases. As we've discussed previously in this chapter and elsewhere
    in the book, many databases support running on Kubernetes, with varying levels
    of maturity.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了Kubernetes上的对象存储工作负载，我们可以继续进行数据库的讨论。正如我们在本章和本书其他地方讨论过的那样，许多数据库支持在Kubernetes上运行，具有不同程度的成熟度。
- en: First off, there are several legacy and existing DB engines that support deploying
    to Kubernetes. Often, these engines will have supported Helm charts or operators.
    For instance, SQL databases such as PostgreSQL and MySQL have Helm charts and
    operators supported by various different organizations. NoSQL databases such as
    MongoDB also have supported ways to deploy to Kubernetes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有几个传统和现有的数据库引擎支持部署到Kubernetes。通常，这些引擎将有受支持的Helm图表或操作员。例如，诸如PostgreSQL和MySQL之类的SQL数据库有受各种不同组织支持的Helm图表和操作员。诸如MongoDB之类的NoSQL数据库也有支持的部署到Kubernetes的方式。
- en: In addition to these previously existing database engines, container orchestrators
    such as Kubernetes have lead to the creation of a new category – the **NewSQL**
    database.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些先前存在的数据库引擎之外，诸如Kubernetes之类的容器编排器已经导致了一个新类别的创建 - **NewSQL**数据库。
- en: These databases offer the incredible scalability of NoSQL databases in addition
    to SQL-compliant APIs. They can be thought of as a way to easily scale SQL on
    Kubernetes (and other orchestrators). CockroachDB is a popular choice here, as
    is **Vitess**, which isn't so much a replacement NewSQL database as it is a way
    to easily scale the MySQL engine.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据库提供了NoSQL数据库的令人难以置信的可扩展性，还具有符合SQL标准的API。它们可以被视为一种在Kubernetes（和其他编排器）上轻松扩展SQL的方式。CockroachDB在这里是一个受欢迎的选择，**Vitess**也是如此，它不仅仅是一个替代NewSQL数据库，而且还可以轻松扩展MySQL引擎。
- en: In this chapter, we will focus on deploying CockroachDB, which is a modern NewSQL
    database built for distributed environments and perfect for Kubernetes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于部署CockroachDB，这是一个为分布式环境构建的现代NewSQL数据库，非常适合Kubernetes。
- en: Running CockroachDB on Kubernetes
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kubernetes上运行CockroachDB
- en: 'To run CockroachDB on our cluster, we will use the official CockroachDB Helm
    chart:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的集群上运行CockroachDB，我们将使用官方的CockroachDB Helm图表：
- en: 'The first thing we need to do is to add the CockroachDB Helm chart repository,
    using the following command:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是添加CockroachDB Helm图表存储库，使用以下命令：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This should result in the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生以下输出：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Before we install the chart, let''s create a custom `values.yaml` file in order
    to tweak some of the default settings for CockroachDB. Our file for this demo
    looks like the following:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装图表之前，让我们创建一个自定义的`values.yaml`文件，以便调整一些CockroachDB的默认设置。我们的演示文件如下所示：
- en: Cockroach-db-values.yaml
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Cockroach-db-values.yaml
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, we are specifying a PersistentVolume size of `2` GB, Pod memory
    limits and requests of `1` GB, and the contents of a configuration file for CockroachDB.
    This configuration file includes settings for `cache` and max `memory`, which
    are set to 25% of the size of the memory limits at `256` MB. This ratio is a CockroachDB
    best practice. Keep in mind that these are not all production-ready settings,
    but they will work for our demo.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们指定了`2`GB的PersistentVolume大小，`1`GB的Pod内存限制和请求，以及CockroachDB的配置文件内容。此配置文件包括`cache`和最大`memory`的设置，它们设置为内存限制大小的25%，为`256`MB。这个比例是CockroachDB的最佳实践。请记住，这些并不是所有生产就绪的设置，但它们对我们的演示来说是有效的。
- en: 'At this point, let''s go ahead and create our CockroachDB cluster using the
    following Helm command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，让我们继续使用以下Helm命令创建我们的CockroachDB集群：
- en: '[PRE42]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If successful, you will see a lengthy deploy message from Helm, which we will
    not reproduce here. Let''s check to see exactly what was deployed on our cluster
    using the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，您将看到来自Helm的冗长部署消息，我们将不在此重现。让我们使用以下命令检查在我们的集群上到底部署了什么：
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You will see output similar to the following:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, we have three Pods in a StatefulSet in addition to a setup Pod
    that was used for some initialization tasks.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们在一个StatefulSet中有三个Pods，另外还有一个用于一些初始化任务的设置Pod。
- en: 'In order to check to see whether our cluster is functional, we can use a command
    that is handily given to us in the CockroachDB Helm chart output (it will vary
    depending on your Helm release name):'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查我们的集群是否正常运行，我们可以使用CockroachDB Helm图表输出中方便给出的命令（它将根据您的Helm发布名称而变化）：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'If successful, a console will be opened with a prompt similar to the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，将打开一个类似以下的提示符的控制台：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In the next section, we will test CockroachDB with SQL.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用SQL测试CockroachDB。
- en: Testing CockroachDB with SQL
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SQL测试CockroachDB
- en: Now, we can run SQL commands to our new CockroachDB database!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对我们的新CockroachDB数据库运行SQL命令了！
- en: 'First, let''s create a database with the following command:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们使用以下命令创建一个数据库：
- en: '[PRE47]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, let''s create a simple table:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个简单的表：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, let''s add some data with this command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用这个命令添加一些数据：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, let''s confirm the data using this:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们使用以下命令确认数据：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'That should give you the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给您以下输出：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Success!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: 'As you can see, we have a fully functional distributed SQL database. Let''s
    move on to the final stateful workload type that we will review: messaging.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有一个完全功能的分布式SQL数据库。让我们继续进行最后一个我们将审查的有状态工作负载类型：消息传递。
- en: Implementing messaging and queues on Kubernetes
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Kubernetes上实现消息传递和队列
- en: For messaging, we will be implementing RabbitMQ, an open source message queue
    system that supports Kubernetes. Messaging systems are typically used in applications
    to decouple various components of the application in order to support the scale
    and throughput, as well as asynchronous patterns such as retries and service worker
    fleets. For instance, instead of one service calling another service directly,
    a service could place a message onto a persistent message queue, at which point
    it would be picked up by a worker container that is listening to the queue. This
    allows for easy horizontal scaling and greater tolerance of entire component downtime
    as compared to a load balancing approach.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于消息传递，我们将实现RabbitMQ，这是一个支持Kubernetes的开源消息队列系统。消息系统通常用于应用程序中，以解耦应用程序的各个组件，以支持规模和吞吐量，以及异步模式，如重试和服务工作器群。例如，一个服务可以将消息放入持久消息队列，然后由监听队列的工作容器接收。这允许轻松的水平扩展，并且相对于负载均衡方法，更容忍整个组件的停机。
- en: RabbitMQ is one of many options for message queues. As we mentioned in the first
    section of the chapter, RabbitMQ is an industry-standard option for message queues,
    not necessarily a queue system built for Kubernetes specifically. However, it's
    still a great choice and very easy to deploy, as we will see shortly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ是消息队列的众多选项之一。正如我们在本章的第一节中提到的，RabbitMQ是消息队列的行业标准选项，不一定是专为Kubernetes构建的队列系统。然而，它仍然是一个很好的选择，并且非常容易部署，我们很快就会看到。
- en: Let's start with implementing RabbitMQ on Kubernetes!
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在Kubernetes上实现RabbitMQ开始！
- en: Deploying RabbitMQ on Kubernetes
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Kubernetes上部署RabbitMQ
- en: 'Installing RabbitMQ on Kubernetes can be easily done via an operator or via
    a Helm chart. For the purposes of this tutorial, we will use the Helm chart:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes上安装RabbitMQ可以通过运算符或Helm图轻松完成。出于本教程的目的，我们将使用Helm图：
- en: 'First, let''s add the proper `helm` repository (provided by **Bitnami**):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加适当的`helm`存储库（由**Bitnami**提供）：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let''s create a custom values file to tweak some parameters:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个自定义值文件来调整一些参数：
- en: Values-rabbitmq.yaml
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Values-rabbitmq.yaml
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As you can see, in this case, we are disabling persistence, which is great for
    a quick demo.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，在这种情况下，我们正在禁用持久性，这对于快速演示非常有用。
- en: 'Then, RabbitMQ can easily be installed on the cluster using the following command:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，RabbitMQ可以通过以下命令轻松安装到集群中：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Once successful, you will see a confirmation message from Helm. The RabbitMQ
    Helm chart also includes a management UI, so let's use that to validate that our
    installation worked.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 成功后，您将看到来自Helm的确认消息。RabbitMQ Helm图还包括管理UI，让我们使用它来验证我们的安装是否成功。
- en: 'First, let''s start a port forward to the `rabbitmq` service:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们开始将端口转发到`rabbitmq`服务：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Then, we should be able to access the RabbitMQ management UI on `http://localhost:15672`.
    It will look like the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们应该能够在`http://localhost:15672`上访问RabbitMQ管理UI。它将如下所示：
- en: '![Figure 15.4 – RabbitMQ management console login](image/B14790_15_004.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![图15.4 - RabbitMQ管理控制台登录](image/B14790_15_004.jpg)'
- en: Figure 15.4 – RabbitMQ management console login
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 - RabbitMQ管理控制台登录
- en: Now, we should be able to log in to the dashboard using the username and password
    specified in the values file. Upon login, you will see the RabbitMQ dashboard
    main view.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该能够使用值文件中指定的用户名和密码登录到仪表板。登录后，您将看到RabbitMQ仪表板的主视图。
- en: 'Importantly, you will see a list of the nodes in your RabbitMQ cluster. In
    our case, we only have a single node, which will display as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，您将看到RabbitMQ集群中节点的列表。在我们的案例中，我们只有一个单一节点，显示如下：
- en: '![Figure 15.5 – RabbitMQ management console node item](image/B14790_15_005.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图15.5 - RabbitMQ管理控制台节点项目](image/B14790_15_005.jpg)'
- en: Figure 15.5 – RabbitMQ management console node item
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 - RabbitMQ管理控制台节点项目
- en: For each node, you can see the name and some metadata, including memory, uptime,
    and more.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，您可以看到名称和一些元数据，包括内存、正常运行时间等。
- en: In order to add a new queue navigate to **Queues** on the top bar, click **Add
    a new queue** toward the bottom of the screen. Fill out the form as follows, then
    click **Add queue**:![Figure 15.6 – RabbitMQ management console queue creation](image/B14790_15_006.jpg)
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了添加新队列，导航到屏幕顶部的**队列**，然后点击屏幕底部的**添加新队列**。填写表单如下，然后点击**添加队列**：![图15.6 - RabbitMQ管理控制台队列创建](image/B14790_15_006.jpg)
- en: Figure 15.6 – RabbitMQ management console queue creation
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 - RabbitMQ管理控制台队列创建
- en: If successful, the screen should refresh with your new queue added to the list.
    This means our RabbitMQ setup is working properly!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果成功，屏幕应该会刷新，您的新队列将添加到列表中。这意味着我们的RabbitMQ设置正常工作！
- en: Finally, now that we have a queue, we can publish a message to it. To do this,
    click on your newly created queue on the **Queues** page, then click **Publish
    Message**.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，现在我们有了一个队列，我们可以向其发布消息。要做到这一点，点击**队列**页面上新创建的队列，然后点击**发布消息**。
- en: Write any text in the **Payload** text box and click **Publish Message**. You
    should see a confirmation popup telling you that your message has been published
    successfully, and the screen should refresh, showing your message on the queue,
    as shown in the following figure:![Figure 15.7 – RabbitMQ management console queue
    status](image/B14790_15_007.jpg)
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**有效载荷**文本框中写入任何文本，然后点击**发布消息**。您应该会看到一个确认弹出窗口，告诉您您的消息已成功发布，并且屏幕应该会刷新，显示您的消息在队列中，如下图所示：![图15.7
    - RabbitMQ管理控制台队列状态](image/B14790_15_007.jpg)
- en: Figure 15.7 – RabbitMQ management console queue status
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 - RabbitMQ管理控制台队列状态
- en: Finally, to emulate fetching messages from the queue, click on **Get messages**
    near the bottom of the page, which should expand to show a new section, and then
    click the **Get Message(s)** button. You should see an output of the message you
    sent, proving that the queue system works!
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了模拟从队列中获取消息，点击页面底部附近的**获取消息**，这将展开显示一个新部分，然后点击**获取消息**按钮。您应该看到您发送的消息的输出，证明队列系统正常工作！
- en: Summary
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about running stateful workloads on Kubernetes.
    First, we reviewed a high-level overview of some of the types of stateful workloads
    and some examples of each. Then, we moved on to actually deploying one of these
    workloads – an object storage system – on Kubernetes. Next, we did the same with
    a NewSQL database, CockroachDB, showing you how to easily deploy a CockroachDB
    cluster on Kubernetes.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Kubernetes上运行有状态的工作负载。首先，我们回顾了一些有状态工作负载的高级概述以及每种工作负载的一些示例。然后，我们继续实际在Kubernetes上部署这些工作负载之一
    - 对象存储系统。接下来，我们使用NewSQL数据库CockroachDB做了同样的事情，向您展示了如何在Kubernetes上轻松部署CockroachDB集群。
- en: Finally, we showed you how to deploy the RabbitMQ message queue on Kubernetes
    using a Helm chart. The skills you used in this chapter will help you deploy and
    use popular stateful application patterns on Kubernetes.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们向您展示了如何使用Helm图表在Kubernetes上部署RabbitMQ消息队列。本章中使用的技能将帮助您在Kubernetes上部署和使用流行的有状态应用程序模式。
- en: If you've made it this far, thanks for sticking with us through all 15 chapters
    of this book! I hope that you have learned how to use a broad spectrum of Kubernetes
    functionality and that you now have all the tools you need in order to build and
    deploy complex applications on Kubernetes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经读到这里，感谢你一直陪伴我们阅读完这本书的所有15章！我希望你已经学会了如何使用广泛的Kubernetes功能，现在你已经拥有了构建和部署复杂应用程序所需的所有工具。
- en: Questions
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What cloud storage offering is Minio's API compatible with?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Minio的API兼容哪种云存储提供？
- en: What are the benefits of a StatefulSet for a distributed database?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于分布式数据库，StatefulSet有哪些好处？
- en: In your words, what makes stateful applications difficult to run on Kubernetes?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用你自己的话来说，什么让有状态的应用在Kubernetes上运行变得困难？
- en: Further reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Minio Quickstart Documentation: [https://docs.min.io/docs/minio-quickstart-guide.html](https://docs.min.io/docs/minio-quickstart-guide.html)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Minio快速入门文档：[https://docs.min.io/docs/minio-quickstart-guide.html](https://docs.min.io/docs/minio-quickstart-guide.html)
- en: 'CockroachDB Kubernetes Guide: [https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes](https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CockroachDB Kubernetes指南：[https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes](https://www.cockroachlabs.com/docs/v20.2/orchestrate-a-local-cluster-with-kubernetes)
