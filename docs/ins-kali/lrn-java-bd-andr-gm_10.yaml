- en: Appendix A. Self-test Questions and Answers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录A. 自测问题和答案
- en: Here, we have included some questions you could ask yourself to see whether
    you have understood each chapter. Don't worry! The answers are also included.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了一些你可以问自己的问题，看看你是否理解了每一章。不要担心！答案也包括在内。
- en: Chapter 2
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章
- en: Q1) What should you do if all this talk of life cycles, classes, and methods
    is a bit confusing?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 如果所有这些关于生命周期、类和方法的讨论让你有点困惑，你应该怎么办？
- en: A) Don't worry about them. Understanding comes a bit at a time, and if they
    are not entirely clear at this stage, it will not hold you back from thoroughly
    learning Java, and all will become clearer as we progress.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: A) 不要担心它们。理解是一点点来的，如果在这个阶段它们不是完全清楚的，它不会阻碍你彻底学习Java，随着我们的进展，一切都会变得更清晰。
- en: Q2) What exactly is a Java class?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 什么是Java类？
- en: A) Classes are a fundamental building block of Java programs. They are like
    containers for our Java code, and we can even use other people's classes to simplify
    the programs we write, even without seeing or understanding the code contained
    within those classes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: A) 类是Java程序的基本构建块。它们就像我们Java代码的容器，我们甚至可以使用其他人的类来简化我们编写的程序，即使没有看到或理解这些类中包含的代码。
- en: Q3) What is the difference between a method and a class?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 方法和类之间有什么区别？
- en: A) Methods are contained within classes and represent the specific functionality
    of the class, like another container within a container. As an example from a
    game, we might have a `Tank` class with `shoot`, `drive`, and `selfDestruct` methods.
    We can use a class and its methods by making our own class, as we will in [Chapter
    6](ch06.xhtml "Chapter 6. OOP – Using Other People's Hard Work"), *OOP – Using
    Other People's Hard Work*, or by using the `@import` statement as we did earlier
    in this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: A) 方法包含在类中，代表类的特定功能，就像容器中的另一个容器。例如，从游戏中，我们可能有一个`Tank`类，其中包括`shoot`，`drive`和`selfDestruct`方法。我们可以通过制作我们自己的类来使用类及其方法，就像我们将在[第6章](ch06.xhtml
    "第6章。OOP – Using Other People's Hard Work")中所做的那样，或者通过使用`@import`语句，就像我们在本章早些时候所做的那样。
- en: Q4) Take a look at the Android developer site and its more technical explanation
    of the lifecycle phases, at [http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html).
    Can you see the phase and its related method that we haven't discussed? When would
    it be triggered in an app? What is the precise pathway an activity takes from
    creation to destruction?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 查看Android开发者网站及其有关生命周期阶段的更多技术解释，网址为[http://developer.android.com/reference/android/app/Activity.html](http://developer.android.com/reference/android/app/Activity.html)。你能看到我们没有讨论过的阶段及其相关的方法吗？在应用程序中它会在什么时候被触发？从创建到销毁，活动会经历怎样的确切路径？
- en: A) It's the restarting phase. Its corresponding method is `onRestart`. It is
    triggered when an app has been stopped and then restarted. We won't need the `onRestart`
    method in this book, but this exercise hopefully helped clarify the concept of
    life cycles. The precise pathway will vary; we just need to handle the phases
    that are relevant to our game. So far, we have just tinkered with `onCreate`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: A) 这是重新启动阶段。它对应的方法是`onRestart`。当应用程序停止然后重新启动时，它会被触发。我们在本书中不需要`onRestart`方法，但这个练习有望帮助澄清生命周期的概念。确切的路径会有所不同；我们只需要处理与我们的游戏相关的阶段。到目前为止，我们只是尝试了`onCreate`。
- en: Chapter 3
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章
- en: Q1) What does this code do?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 这段代码是做什么的？
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A) Nothing, because it is commented out with //.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: A) 什么都没有，因为它被//注释掉了。
- en: Q2) Which of these lines causes an error?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 这些行中哪一行会导致错误？
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A) The fourth line, `a = a + b`, has no semicolon, so it will cause an error.
    The last line, `c = c + a;`, will also cause an error because you cannot assign
    a string to an `int` value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: A) 第四行`a = a + b`没有分号，所以会导致错误。最后一行`c = c + a;`也会导致错误，因为你不能将字符串赋给`int`值。
- en: Q3) We talked a lot about operators and how different operators can be used
    together to build complicated expressions. Expressions, at a glance, can sometimes
    make code look complicated. However, when looked at closely, they are not as tough
    as they seem. Usually, it is just a case of splitting the expressions into smaller
    pieces to work out what is going on. Here is an expression that is more convoluted
    than anything else you will ever meet in this book. As a challenge, can you work
    out what `x` will be?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我们谈了很多关于运算符以及如何将不同的运算符组合在一起构建复杂的表达式。表达式乍一看有时会让代码看起来复杂。然而，仔细看时，它们并不像看起来那么难。通常，只是将表达式分成较小的部分来弄清楚发生了什么。这里有一个比本书中你会遇到的任何其他东西都更加复杂的表达式。作为挑战，你能计算出`x`会是什么吗？
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A) You can run the `SelfTestC3Q3` project in the `Chapter3` folder of the code
    bundle to check out the answer in the console, but `isTrueOrFalse` evaluates to
    true; here's why.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: A) 你可以在代码包的`Chapter3`文件夹中运行`SelfTestC3Q3`项目来在控制台中查看答案，但`isTrueOrFalse`会评估为true；原因如下。
- en: 'First, let''s break down the nasty line into manageable sections defined by
    the brackets:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们把这个糟糕的行分解成由括号定义的可管理的部分：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Previously, we were asking the question, "is `x` less than or equal to `y` or
    is `x` exactly equal to `10`?". Clearly, `x` is not equal to or less than `y`
    but `x` is exactly equal to `10`, so our use of the logical OR operator, `||`,
    in the middle causes the entire part of the expression to evaluate to `true`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们问的问题是，“`x`是否小于或等于`y`，或者`x`是否恰好等于`10`？”。显然，`x`既不等于也不小于`y`，但`x`恰好等于`10`，所以我们在中间使用的逻辑或运算符`||`导致整个表达式评估为`true`。
- en: '&&'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '&&'
- en: 'Both sides of an `&&` operator must evaluate to `true` for the overall expression
    to be true. So let''s look at the other side:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`运算符的两侧必须都为`true`，整个表达式才为`true`。所以让我们看看另一边：'
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Well, `isTrueOrFalse` is a Boolean. It can only be true or false so this part
    of the expression must be true because we are essentially asking, "is `isTrueOrFalse`
    false or is `isTrueOrFalse` true?". It must be one or the other. So, regardless
    of how we initialized `isTrueOrFalse`, the last part of the expression will be
    true.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，`isTrueOrFalse`是一个布尔值。它只能是真或假，所以表达式的这一部分必须是真，因为我们实质上是在问，“`isTrueOrFalse`是假还是`isTrueOrFalse`是真？”。它必须是其中之一。因此，无论我们如何初始化`isTrueOrFalse`，表达式的最后一部分都将是真。
- en: So the overall expression evaluates to `true`, and `true` is assigned to `isTrueOrFalse`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，整个表达式评估为`true`，并且`true`被分配给`isTrueOrFalse`。
- en: Chapter 4
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: Q1) What is wrong with this method?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）这个方法有什么问题？
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A) It returns a value but has a `void` return type.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: A）它返回一个值，但具有`void`返回类型。
- en: Q2) What will `x` be equal to at the end of this code snippet?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）在这段代码片段结束时，`x`将等于多少？
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A) Okay, this was a slightly tricky question. Regardless of the value of `x`,
    the `do` block always executes at least once. Then `x` is set to `11`, and after
    that, it is incremented to `12`. So when the `while` expression is evaluated,
    it is true and the `do` block executes again. Once more, `x` is set to `11` and
    then incremented to `12`. The program is stuck in a never-ending (infinite) loop.
    This code is most likely a bug.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: A）好吧，这是一个稍微棘手的问题。无论`x`的值如何，`do`块总是至少执行一次。然后`x`设置为`11`，之后递增为`12`。因此，当评估`while`表达式时，它是真的，`do`块再次执行。再一次，`x`设置为`11`，然后递增为`12`。程序陷入了一个永无止境（无限）的循环。这段代码很可能是一个错误。
- en: Chapter 5
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章
- en: Q1) Suppose we wanted to have a quiz where the question could be about naming
    the president, the capital city, and so on. How would we do this with multidimensional
    arrays?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）假设我们想要进行一个测验，问题可能是关于总统的名字、首都等。我们如何使用多维数组来实现这一点？
- en: 'A) We would just make the inner array hold three strings, perhaps like this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: A）我们只需使内部数组保存三个字符串，可能是这样：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Q2) In our persistence example, we saved a continually updating string to a
    file so that it persisted after the app had been shut down and restarted. This
    is like asking the user to click on a **Save** button. Summoning all your knowledge
    of [Chapter 2](ch02.xhtml "Chapter 2. Getting Started with Android"), *Getting
    Started with Android*, can you think of a way to save the string without saving
    it by the button click but just when the user quits the app?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）在我们的持久性示例中，我们将一个不断更新的字符串保存到文件中，以便在应用程序关闭和重新启动后保持。这就像要求用户单击**保存**按钮。在您对[第2章](ch02.xhtml
    "第2章。开始使用Android")的所有知识的基础上，您能想出一种在用户退出应用程序时保存字符串而不是通过按钮点击保存它的方法吗？
- en: 'A) Override the `onPause` life cycle method and put the code to save the string
    in there, like this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: A）覆盖`onPause`生命周期方法，并将保存字符串的代码放在其中，就像这样：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Q3) Other than increasing the difficulty level, how could we make the memory
    game harder?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Q3）除了增加难度级别，我们如何使记忆游戏更难？
- en: 'A) We could simply alter the pause in our thread execution to mention a lower
    number, giving the player less thinking time, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: A）我们可以简单地修改线程执行中的暂停时间，将数字降低，给玩家更少的思考时间，就像这样：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Q4) Using the plain Android UI with the dull grey buttons isn't very exciting.
    Take a look at the UI elements in the visual designer. Can you work out how to
    use an image for our button background?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Q4）使用普通的Android UI和沉闷的灰色按钮并不是很令人兴奋。看看可视化设计师中的UI元素。您能想出如何在我们的按钮背景中使用图像吗？
- en: A) Simply add some `.png` graphics to the `drawable-mdpi` folder and then find
    the background property in the **Properties** window while your button is selected.
    Click to edit the property in the usual way and choose the graphic you added to
    the `drawable-mdpi` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: A）只需向`drawable-mdpi`文件夹添加一些`.png`图形，然后在选择按钮时在**属性**窗口中找到背景属性。单击以通常的方式编辑属性，并选择您添加到`drawable-mdpi`文件夹的图形。
- en: Chapter 6
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章
- en: Q1) What is encapsulation?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）什么是封装？
- en: A) Encapsulation is the way we pack our variables, code, and methods in a manner
    that exposes just the parts and functionality we want to the parts of our app
    (or any app that uses our classes) that we want.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: A）封装是我们以一种方式打包我们的变量、代码和方法，使得我们只向我们想要的应用程序部分（或使用我们类的任何应用程序）公开部分和功能。
- en: Q2) I don't get all this, and actually, I have more questions now than I had
    at the start of the chapter. What should I do?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）我不太明白这一切，实际上，我现在比章节开始时还有更多问题。我该怎么办？
- en: A) You know enough about OOP to make significant progress with games and any
    other type of Java programming. If you are desperate to know more OOP right now,
    there are plenty of highly rated books that discuss nothing but OOP. However,
    practice and familiarity with the syntax will go a long way to achieving the same
    thing and will probably be more fun. The deciding factor in whether you rush off
    and learn the intricate details of OOP now will really depend on your personal
    goals and what you want to do with your programming skills in the future. Read
    the last few pages of [Chapter 9](ch09.xhtml "Chapter 9. Making Your Game the
    Next Big Thing"), *Making Your Game the Next Big Thing*, for more discussion.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: A）您已经了解足够的面向对象编程知识，可以在游戏和任何其他类型的Java编程中取得重大进展。如果您现在急于了解更多面向对象编程知识，那么有很多评价很高的书籍专门讨论面向对象编程。然而，练习和熟悉语法将对实现相同目标产生很大帮助，并且可能更有趣。现在是否急于学习面向对象编程的复杂细节，实际上取决于您的个人目标以及将来想要用编程技能做什么。阅读[第9章](ch09.xhtml
    "第9章。使您的游戏成为下一个大事件")的最后几页，*使您的游戏成为下一个大事件*，以获取更多讨论。
- en: Chapter 7
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章
- en: Q1) The speed of the ball is calculated in pixels. Different devices have different
    numbers of pixels. Can you explain how to make the ball speed approximately the
    same on different screen resolutions?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）球的速度是以像素为单位计算的。不同的设备具有不同数量的像素。您能解释如何使不同屏幕分辨率上的球速度大致相同吗？
- en: 'A) A simple way to accommodate different screen resolutions would be to devise
    a system that that takes into account the number of pixels the screen has. We
    have already done this for the racket and ball sizes. We could declare a member
    variable like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: A) 适应不同屏幕分辨率的一个简单方法是设计一个系统，考虑屏幕的像素数量。我们已经为球拍和球的大小做到了这一点。我们可以声明一个成员变量，如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We could then initialize these variables in `onCreate` after we have obtained
    the screen dimensions:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在我们获得屏幕尺寸之后，在`onCreate`中初始化这些变量：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we can move our ball a bit, like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以稍微移动我们的球，就像这样：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Chapter 8
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: Q1) What about a visual improvement for our game screen, perhaps a nice, light
    green grassy background instead of just black?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 我们的游戏屏幕有什么视觉改进，也许是一个漂亮的浅绿色草地背景，而不仅仅是黑色？
- en: 'A) You can use most graphics programs such as Gimp or Photoshop to get the
    RGB value of a nice, light green grassy color. Alternatively, you can use an online
    color picker such as [http://www.colorpicker.com/](http://www.colorpicker.com/).
    Then look at this line in our `drawGame` method:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: A) 您可以使用大多数图形程序（如Gimp或Photoshop）获取漂亮的浅绿色草地的RGB值。或者，您可以使用在线颜色选择器，例如[http://www.colorpicker.com/](http://www.colorpicker.com/)。然后查看我们`drawGame`方法中的这一行：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Change it to the following line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下行：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Q2) How about adding some nice flowers to the background?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 在背景中添加一些漂亮的花怎么样？
- en: A) Here is the way to do this. Create a flower bitmap (or use mine), load it,
    and scale it in the usual way, in the `configureDisplay` method. Decide how many
    flowers to draw. Choose and store locations on the board in the `SnakeView` constructor
    (or write and call a special method, perhaps `plantFlowers`).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: A) 这是做到这一点的方法。创建一个花位图（或使用我的），在`configureDisplay`方法中加载并按照通常的方式进行缩放。决定绘制多少朵花。在`SnakeView`构造函数中选择并存储板上的位置（或编写并调用一个特殊的方法，也许是`plantFlowers`）。
- en: Draw them before the snake and the apple in the `drawGame` method. This will
    ensure that they can never hide an apple or a part of the snake. You can see my
    specific implementation in the methods mentioned and a copy of the flower bitmap
    in the `EnhancedSnakeGame` project in the `Chapter8` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`drawGame`方法中的蛇和苹果之前绘制它们。这将确保它们永远不会隐藏苹果或蛇的一部分。您可以在提到的方法中看到我的具体实现，并在`Chapter8`文件夹的`EnhancedSnakeGame`项目中复制花的位图。
- en: Q3) If you're feeling brave, make the flowers sway. Think of sprite sheets.
    The theory is exactly the same as that of the animated snake head. We just need
    a few lines of code to control the frame rate separately from the game frame rate.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 如果您感到勇敢，可以让花摇摆。想想精灵表。理论上与动画蛇头的理论完全相同。我们只需要几行代码来控制帧速率，与游戏帧速率分开。
- en: A) Take a look at the new code in the `controlFPS` method. We simply set up
    a new counter for flower animations to switch flower frames once every six game
    frames. You can also copy the sprite sheet from the `EnhancedSnakeGame` project
    in the `Chapter8` folder.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: A) 查看`controlFPS`方法中的新代码。我们只需为花动画设置一个新的计数器，以便在每六个游戏帧中切换花帧。您还可以从`Chapter8`文件夹中的`EnhancedSnakeGame`项目中复制精灵表。
- en: Q4) We could set up another counter and use our snake head animation, but it
    wouldn't be that useful because the subtle tongue movements would be barely visible
    due to the smaller size. Nevertheless, we could quite easily swish the tail segment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Q4) 我们可以设置另一个计数器并使用我们的蛇头动画，但这并不是很有用，因为由于尺寸较小，细微的舌头运动几乎不可见。尽管如此，我们可以相当容易地摆动尾部段。
- en: A) There is a two-frame tail bitmap in the `EnhancedSnakeGame` project in the
    `Chapter8` folder. As this is also two frames, we could use the same frame timer
    as that used for the flower. Take a look at the implementation in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. The only required changes are in `configureDisplay`
    and `drawGame`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: A) 在`Chapter8`文件夹的`EnhancedSnakeGame`项目中有一个两帧尾部位图。由于这也是两帧，我们可以使用与花相同的帧定时器。查看`Chapter8`文件夹中`EnhancedSnakeGame`项目中的实现。唯一需要更改的是`configureDisplay`和`drawGame`。
- en: Q5) Here is a slightly trickier enhancement. You can't help notice that when
    the snake sprites are headed in three out of the four possible directions, they
    don't look right. Can you fix this?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Q5) 这是一个稍微棘手的增强。您可能已经注意到，当蛇精灵朝着四个可能的方向中的三个方向时，它们看起来不正确。您能修复这个问题吗？
- en: A) We need to rotate them depending upon the way they are heading. Android has
    a `Matrix` class, which allows us to easily rotate Bitmaps, and the `Bitmap` class
    has an overloaded version of the `createBitmap` method that takes a `Matrix` object
    as an argument.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: A) 我们需要根据它们的前进方向进行旋转。Android有一个`Matrix`类，它允许我们轻松旋转位图，而`Bitmap`类有一个重载版本的`createBitmap`方法，它以`Matrix`对象作为参数。
- en: 'So we can create a matrix for each angle we need to handle, like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以为我们需要处理的每个角度创建一个矩阵，如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we can rotate a bitmap using the following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用以下代码旋转位图：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Another problem is that as the snake twists and turns, how do we keep track
    of the individual orientation of each segment? We already have a direction finding
    scheme: 0 is up, 1 is right, and so on. So we can just create another array for
    the orientation of each segment that corresponds to a body segment in the `snakeX`
    and `snakeY` arrays. Then all we need to do is to ensure that the head has the
    correct direction, and update from the back on each frame just as we do for the
    snake''s coordinates. You can see this implemented in the `EnhancedSnakeGame`
    project in the `Chapter8` folder.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是，当蛇扭曲和转弯时，我们如何跟踪每个部分的个体方向？我们已经有了一个方向查找方案：0是向上，1是向右，依此类推。因此，我们可以为`snakeX`和`snakeY`数组中的身体部分创建另一个方向数组。然后，我们所需要做的就是确保头部有正确的方向，并且在每一帧上从后面更新，就像我们为蛇的坐标所做的那样。您可以在`Chapter8`文件夹的`EnhancedSnakeGame`项目中看到这一实现。
- en: The finished project with a few more enhancements is in the `EnhancedSnakeGame`
    project in the `Chapter8` folder. This is the version we will be using as a starting
    point in the next and final chapter. You can also download the game from Google
    Play at [https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter8`文件夹的`EnhancedSnakeGame`项目中有一些更多的增强功能的完成项目。这是我们将在下一章和最后一章中使用的起点版本。您还可以从Google
    Play下载游戏[https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame](https://play.google.com/store/apps/details?id=com.packtpub.enhancedsnakegame.enhancedsnakegame)。
- en: '![Chapter 8](img/8859OS_Appendix_01.jpg)![Chapter 8](img/8859OS_Appendix_02.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![第8章](img/8859OS_Appendix_01.jpg)![第8章](img/8859OS_Appendix_02.jpg)'
- en: Chapter 9
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: Q1) Try to implement the local high scores on the device.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Q1）尝试在设备上实现本地高分。
- en: A) You already know how to do this. Just go back to [Chapter 5](ch05.xhtml "Chapter 5. Gaming
    and Java Essentials"), *Gaming and Java Essentials* in case you are unsure. The
    implementation is in the code for this chapter's project as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: A）你已经知道如何做到这一点。如果不确定，只需返回[第5章](ch05.xhtml "第5章。游戏和Java基础")，*游戏和Java基础*。该实现也在本章项目的代码中。
- en: Q2) How many eminent computer scientists have made cameo appearances in the
    code throughout this book?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Q2）有多少著名的计算机科学家在整本书中的代码中客串出现？
- en: A) 9
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: A）9
- en: Ada Lovelace
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 阿达·洛芙莱斯
- en: Charles Babbage
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 查尔斯·巴贝奇
- en: Alan Turing
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 艾伦·图灵
- en: Vinton Cerf
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 文顿·瑟夫
- en: Jeff Minter
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 杰夫·明特
- en: Corrine Yu
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 科琳娜·于
- en: André LaMothe
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 安德烈·拉莫特
- en: Gabe Newell
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 盖布·纽维尔
- en: Sid Meier
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 西德·梅尔
- en: Why not search on the Web for some of these names? There are some interesting
    stories about each of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在网上搜索一下这些名字？每个人都有一些有趣的故事。
