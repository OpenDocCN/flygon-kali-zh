["```kt\n    package com.packtpub.store;\n\n    public interface StoreListener {\n        void onSuccess(int pValue);\n\n        void onSuccess(String pValue);\n\n        void onSuccess(Color pValue);\n    }\n    ```", "```kt\n        Public class Store implements StoreListener {\n         private StoreListener mListener;\n            public Store(StoreListener pListener) {\n                mListener = pListener;\n            }\n            ...\n        ```", "```kt\n            ...\n         public void onSuccess(int pValue) {\n         mListener.onSuccess(pValue);\n         }\n\n         public void onSuccess(String pValue) {\n         mListener.onSuccess(pValue);\n         }\n\n         public void onSuccess(Color pValue) {\n         mListener.onSuccess(pValue);\n            }\n        }\n        ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment\n     implements StoreListener {\n     private Store mStore = new Store(this);\n            ...\n    ```", "```kt\n            ...\n     public void onSuccess(int pValue) {\n     displayMessage(String.format(\n     \"Integer '%1$d' successfuly saved!\", pValue));\n     }\n\n     public void onSuccess(String pValue) {\n     displayMessage(String.format(\n     \"String '%1$s' successfuly saved!\", pValue));\n     }\n\n     public void onSuccess(Color pValue) {\n     displayMessage(String.format(\n     \"Color '%1$s' successfuly saved!\", pValue));\n            }\n        }\n    }\n    ```", "```kt\n    javap \u2013s -classpath bin/classes com.packtpub.store.Store\n    ```", "```kt\n(<Parameter 1 Type Code>[<Parameter 1 Class>];...)<Return Type Code>\n```", "```kt\n    ...\n    static Store gStore;\n\n    static jclass StringClass;\n    static jclass ColorClass;\n\n    static jmethodID MethodOnSuccessInt;\n    static jmethodID MethodOnSuccessString;\n    static jmethodID MethodOnSuccessColor;\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n        JNIEnv *env;\n        if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {\n            abort();\n        }\n        ...\n        // Caches methods.\n     jclass StoreClass = env->FindClass(\"com/packtpub/store/Store\");\n     if (StoreClass == NULL) abort();\n\n     MethodOnSuccessInt = env->GetMethodID(StoreClass, \"onSuccess\",\n     \"(I)V\");\n     if (MethodOnSuccessInt == NULL) abort();\n\n     MethodOnSuccessString = env->GetMethodID(StoreClass, \"onSuccess\",\n     \"(Ljava/lang/String;)V\");\n     if (MethodOnSuccessString == NULL) abort();\n\n     MethodOnSuccessColor = env->GetMethodID(StoreClass, \"onSuccess\",\n     \"(Lcom/packtpub/store/Color;)V\");\n     if (MethodOnSuccessColor == NULL) abort();\n     env->DeleteLocalRef(StoreClass);\n\n        // Store initialization.\n        gStore.mLength = 0;\n        return JNI_VERSION_1_6;\n    }\n    ...\n    ```", "```kt\n        ...\n        JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setInteger\n          (JNIEnv* pEnv, jobject pThis, jstring pKey, jint pInteger) {\n            StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n            if (entry != NULL) {\n                entry->mType = StoreType_Integer;\n                entry->mValue.mInteger = pInteger;\n\n         pEnv->CallVoidMethod(pThis, MethodOnSuccessInt,\n         (jint) entry->mValue.mInteger);\n            }\n        }\n        ...\n        ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setString\n      (JNIEnv* pEnv, jobject pThis, jstring pKey, jstring pString) {\n        // Turns the Java string into a temporary C string.\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            entry->mType = StoreType_String;\n            ...\n\n            pEnv->CallVoidMethod(pThis, MethodOnSuccessString,\n     (jstring) pEnv->NewStringUTF(entry->mValue.mString));\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_setColor\n      (JNIEnv* pEnv, jobject pThis, jstring pKey, jobject pColor) {\n        // Save the Color reference in the store.\n        StoreEntry* entry = allocateEntry(pEnv, &gStore, pKey);\n        if (entry != NULL) {\n            entry->mType = StoreType_Color;\n            entry->mValue.mColor = pEnv->NewGlobalRef(pColor);\n\n            pEnv->CallVoidMethod(pThis, MethodOnSuccessColor,\n     (jstring) entry->mValue.mColor);\n        }\n    }\n    ...\n    ```", "```kt\n    jclass StoreClass = env->FindClass(\"com/packtpub/store/Store\");\n    ```", "```kt\n    jmethodID MethodOnSuccessInt = env->GetMethodID(StoreClass,\n                                                    \"onSuccess\", \"(I)V\");\n    ```", "```kt\n    env->CallVoidMethod(pThis, MethodOnSuccessInt, (jint) myInt); \n    ```", "```kt\n    jclass FindClass(const char* name)\n    ```", "```kt\n    jclass GetObjectClass(jobject obj)\n    ```", "```kt\n    jmethodID GetMethodID(jclass clazz, const char* name,\n                          const char* sig) \n    jmethodID GetStaticMethodID(jclass clazz, const char* name,\n                                const char* sig)\n\n    jfieldID GetStaticFieldID(jclass clazz, const char* name,\n                              const char* sig)\n    jfieldID GetFieldID(jclass clazz, const char* name, const char* sig)\n    ```", "```kt\n    jobject GetObjectField(jobject obj, jfieldID fieldID)\n    <primitive> Get<Primitive>Field(jobject obj, jfieldID fieldID)\n\n    void SetObjectField(jobject obj, jfieldID fieldID, jobject value)\n    void Set<Primitive>Field(jobject obj, jfieldID fieldID,\n                             <jprimitive> value)\n    ```", "```kt\n    jobject CallObjectMethod(JNIEnv*, jobject, jmethodID, ...)\n\n    <jprimitive> Call<Primitive>Method(JNIEnv*, jobject, jmethodID, ...);\n    ```", "```kt\n    jobject CallObjectMethodV(JNIEnv*, jobject, jmethodID, va_list);\n    jobject CallObjectMethodA(JNIEnv*, jobject, jmethodID, jvalue*);\n    ```", "```kt\nadb shell setprop debug.checkjni 1\n\n```", "```kt\nadb shell stop\nadb shell setprop dalvik.vm.checkjni true\nadb shell start\n\n```", "```kt\n    public class Store implements StoreListener {\n        ...\n        public native long startWatcher();\n     public native void stopWatcher(long pPointer);\n    }\n    ```", "```kt\n    package com.packtpub.store;\n\n    import com.packtpub.exception.InvalidTypeException;\n    import com.packtpub.exception.NotExistingKeyException;\n\n    public class StoreThreadSafe extends Store {\n        protected static Object LOCK;\n\n        public StoreThreadSafe(StoreListener pListener) {\n            super(pListener);\n        }\n        ...\n    ```", "```kt\n        ...\n        @Override\n        public int getCount() {\n            synchronized (LOCK) {\n                return super.getCount();\n            }\n        }\n        ...\n        @Override\n        public int getInteger(String pKey)\n            throws NotExistingKeyException, InvalidTypeException\n        {\n            synchronized (LOCK) {\n                return super.getInteger(pKey);\n            }\n        }\n\n        @Override\n        public void setInteger(String pKey, int pInt) {\n            synchronized (LOCK) {\n                super.setInteger(pKey, pInt);\n            }\n        }\n        ...\n    ```", "```kt\n        ...\n        @Override\n        public void stopWatcher(long pPointer) {\n            synchronized (LOCK) {\n                super.stopWatcher(pPointer);\n            }\n        }\n    }\n    ```", "```kt\n    public class StoreActivity extends Activity {\n        ...\n        public static class PlaceholderFragment extends Fragment\n        implements StoreListener {\n            private StoreThreadSafe mStore = new StoreThreadSafe(this);\n     private long mWatcher;\n            private EditText mUIKeyEdit, mUIValueEdit;\n            private Spinner mUITypeSpinner;\n            private Button mUIGetButton, mUISetButton;\n            private Pattern mKeyPattern;\n\n            ...\n     @Override\n     public void onResume() {\n     super.onResume();\n     mWatcher = mStore.startWatcher();\n     }\n     @Override\n     public void onPause() {\n     super.onPause();\n     mStore.stopWatcher(mWatcher);\n            }\n            ...\n        }\n    }\n    ```", "```kt\n    #ifndef _STORE_H_\n    #define _STORE_H_\n\n    #include <cstdint>\n    #include <pthread.h>\n    #include \"jni.h\"\n    ```", "```kt\n        ...\n        typedef struct { \n         Store* mStore; \n         JavaVM* mJavaVM; \n         jobject mLock; \n         pthread_t mThread; \n         int32_t mRunning; \n        } StoreWatcher;\n        ...\n        ```", "```kt\n    ...\n    StoreWatcher* startWatcher(JavaVM* pJavaVM, Store* pStore, \n     jobject pLock); \n    void stopWatcher(StoreWatcher* pWatcher); \n    void* runWatcher(void* pArgs); \n    void processEntry(StoreEntry* pEntry);\n    #endif\n    ```", "```kt\n    ...\n    static Store gStore;\n    static jobject gLock;\n    ...\n    ```", "```kt\n        JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n            JNIEnv *env;\n            if (pVM->GetEnv((void**) &env, JNI_VERSION_1_6) != JNI_OK) {\n                abort();\n            }\n            ...\n         jclass ObjectClass = env->FindClass(\"java/lang/Object\");\n         if (ObjectClass == NULL) abort();\n         jmethodID ObjectConstructor = env->GetMethodID(ObjectClass,\n         \"<init>\", \"()V\");\n         if (ObjectConstructor == NULL) abort();\n         jobject lockTmp = env->NewObject(ObjectClass, ObjectConstructor);\n         env->DeleteLocalRef(ObjectClass);\n         gLock = env->NewGlobalRef(lockTmp);\n         env->DeleteLocalRef(lockTmp);\n            ...\n        ```", "```kt\n            ...\n         jclass StoreThreadSafeClass = env->FindClass(\n         \"com/packtpub/store/StoreThreadSafe\");\n         if (StoreThreadSafeClass == NULL) abort();\n         jfieldID lockField = env->GetStaticFieldID(StoreThreadSafeClass,\n         \"LOCK\", \"Ljava/lang/Object;\");\n         if (lockField == NULL) abort();\n         env->SetStaticObjectField(StoreThreadSafeClass, lockField, gLock);\n         env->DeleteLocalRef(StoreThreadSafeClass);\n\n            return JNI_VERSION_1_6;\n        }\n        ...\n        ```", "```kt\n    ...\n    JNIEXPORT jlong JNICALL Java_com_packtpub_store_Store_startWatcher\n      (JNIEnv *pEnv, jobject pThis) {\n        JavaVM* javaVM;\n        // Caches the VM.\n        if (pEnv->GetJavaVM(&javaVM) != JNI_OK) abort();\n\n        // Launches the background thread.\n        StoreWatcher* watcher = startWatcher(javaVM, &gStore, gLock);\n        return (jlong) watcher;\n    }\n    ...\n    ```", "```kt\n    ...\n    JNIEXPORT void JNICALL Java_com_packtpub_store_Store_stopWatcher\n      (JNIEnv *pEnv, jobject pThis, jlong pWatcher) {\n        stopWatcher((StoreWatcher*) pWatcher);\n    }\n    ```", "```kt\n    jobject NewObject(jclass clazz, jmethodID methodID, ...)\n    ```", "```kt\n    jobject NewObjectV(jclass clazz, jmethodID methodID, va_list args)\n    jobject NewObjectA(jclass clazz, jmethodID methodID, jvalue* args)\n    ```", "```kt\n    jobject AllocObject(jclass clazz)\n    ```", "```kt\n    #include \"Store.h\"\n    #include <cstdlib>\n    #include <cstring>\n    #include <unistd.h>\n    ...\n    ```", "```kt\n    StoreWatcher* startWatcher(JavaVM* pJavaVM, Store* pStore,\n            jobject pLock) {\n        StoreWatcher* watcher = new StoreWatcher();\n        watcher->mJavaVM = pJavaVM;\n        watcher->mStore = pStore;\n        watcher->mLock = pLock;\n        watcher->mRunning = true;\n    ...\n    ```", "```kt\n        ...\n            pthread_attr_t lAttributes;\n            if (pthread_attr_init(&lAttributes)) abort();\n            if (pthread_create(&watcher->mThread, &lAttributes,\n                                    runWatcher, watcher)) abort();\n            return watcher;\n        }\n        ...\n        ```", "```kt\n    ...\n    void stopWatcher(StoreWatcher* pWatcher) { \n        pWatcher->mRunning = false; \n    } \n    ...\n    ```", "```kt\n        ...\n        void* runWatcher(void* pArgs) {\n            StoreWatcher* watcher = (StoreWatcher*) pArgs;\n            Store* store = watcher->mStore;\n\n            JavaVM* javaVM = watcher->mJavaVM;\n            JavaVMAttachArgs javaVMAttachArgs;\n            javaVMAttachArgs.version = JNI_VERSION_1_6;\n            javaVMAttachArgs.name = \"NativeThread\";\n            javaVMAttachArgs.group = NULL;\n\n            JNIEnv* env;\n            if (javaVM->AttachCurrentThreadAsDaemon(&env,\n                    &javaVMAttachArgs) != JNI_OK) abort();\n            // Runs the thread loop.\n            while (true) {\n                sleep(5); // In seconds.\n                    ...\n        ```", "```kt\n                    ...\n                // Critical section beginning, one thread at a time.\n                // Entries cannot be added or modified.\n                env->MonitorEnter(watcher->mLock);\n                if (!watcher->mRunning) break;\n                StoreEntry* entry = watcher->mStore->mEntries;\n                StoreEntry* entryEnd = entry + watcher->mStore->mLength;\n                while (entry < entryEnd) {\n                    processEntry(entry);\n                    ++entry;\n                }\n                // Critical section end.\n                env->MonitorExit(watcher->mLock);\n            }\n            ...\n        ```", "```kt\n        ...\n        javaVM->DetachCurrentThread();\n        delete watcher;\n        pthread_exit(NULL);\n    }\n    ...\n    ```", "```kt\n    ...\n    void processEntry(StoreEntry* pEntry) {\n        switch (pEntry->mType) {\n        case StoreType_Integer:\n            if (pEntry->mValue.mInteger > 100000) {\n                pEntry->mValue.mInteger = 100000;\n            } else if (pEntry->mValue.mInteger < -100000) {\n                pEntry->mValue.mInteger = -100000;\n            }\n            break;\n        }\n    }\n    ```", "```kt\npublic class MyNativeClass {\n public native synchronized int doSomething();\n    ...\n}\n```", "```kt\n    jint MonitorEnter(jobject obj)\n    ```", "```kt\n    jint MonitorExit(jobject obj)\n    ```", "```kt\n    jint AttachCurrentThread(JNIEnv** p_env, void* thr_args)\n    ```", "```kt\n    jint AttachCurrentThreadAsDaemon(JNIEnv** p_env, void* thr_args)\n    ```", "```kt\n    jint DetachCurrentThread()\n    ```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <manifest \n      package=\"com.packtpub.livecamera\"\n      android:versionCode=\"1\" android:versionName=\"1.0\" >\n      <uses-sdk android:minSdkVersion=\"14\" android:targetSdkVersion=\"19\"/>\n     <uses-permission android:name=\"android.permission.CAMERA\" />\n      <application\n        android:allowBackup=\"false\"\n        android:icon=\"@drawable/ic_launcher\"\n        android:label=\"@string/app_name\" >\n        <activity\n          android:name=\".LiveCameraActivity\"\n          android:label=\"@string/app_name\"\n          android:screenOrientation=\"landscape\"\n     android:theme=\"@android:style/Theme.NoTitleBar.Fullscreen\" >\n          <intent-filter>\n            <action android:name=\"android.intent.action.MAIN\" />\n            <category android:name=\"android.intent.category.LAUNCHER\" />\n          </intent-filter>\n        </activity>\n      </application>\n    </manifest>\n    ```", "```kt\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout \n\n      a:baselineAligned=\"true\" a:orientation=\"horizontal\"\n      a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\" >\n      <LinearLayout\n        a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\"\n        a:layout_weight=\"1\" a:orientation=\"vertical\" >\n        <TextureView\n          a:id=\"@+id/preview\" a:layout_weight=\"1\"\n          a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\" />\n        <ImageView\n          a:id=\"@+id/imageViewR\" a:layout_weight=\"1\"\n          a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\" />\n      </LinearLayout>\n      <LinearLayout\n        a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\"\n        a:layout_weight=\"1\" a:orientation=\"vertical\" >\n        <ImageView\n          a:id=\"@+id/imageViewG\" a:layout_weight=\"1\"\n          a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\" />\n        <ImageView\n          a:id=\"@+id/imageViewB\" a:layout_weight=\"1\"\n          a:layout_width=\"fill_parent\" a:layout_height=\"fill_parent\" />\n      </LinearLayout>\n    </LinearLayout>\n    ```", "```kt\n    package com.packtpub.livecamera;\n    ...\n    public class LiveCameraActivity extends Activity implements\n    TextureView.SurfaceTextureListener, Camera.PreviewCallback {\n        static {\n            System.loadLibrary(\"livecamera\");\n        }\n        ...\n    ```", "```kt\n            ...\n            private Camera mCamera;\n            private TextureView mTextureView;\n            private byte[] mVideoSource;\n            private ImageView mImageViewR, mImageViewG, mImageViewB;\n            private Bitmap mImageR, mImageG, mImageB;\n            ...\n        ```", "```kt\n        ...\n        @Override\n        protected void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n            setContentView(R.layout.activity_livecamera);\n            mTextureView = (TextureView) findViewById(R.id.preview);\n            mImageViewR = ((ImageView)findViewById(R.id.imageViewR));\n            mImageViewG = ((ImageView)findViewById(R.id.imageViewG));\n            mImageViewB = ((ImageView)findViewById(R.id.imageViewB));\n\n            mTextureView.setSurfaceTextureListener(this);\n        }\n        @Override\n        public void onSurfaceTextureSizeChanged(SurfaceTexture pSurface,\n           int pWidth, int pHeight) {}\n\n        @Override\n        public void onSurfaceTextureUpdated(SurfaceTexture pSurface) {}\n        ...\n    ```", "```kt\n        ...\n        @Override\n        public void onSurfaceTextureAvailable(SurfaceTexture pSurface,\n                                              int pWidth, int pHeight) {\n            mCamera = Camera.open();\n            try {\n                mCamera.setPreviewTexture(pSurface);\n                mCamera.setPreviewCallbackWithBuffer(this);\n                // Sets landscape mode to avoid complications related to\n                // screen orientation handling.\n                mCamera.setDisplayOrientation(0);\n                ...\n    ```", "```kt\n                ...\n                Size size = findBestResolution(pWidth, pHeight);\n                PixelFormat pixelFormat = new PixelFormat();\n                PixelFormat.getPixelFormatInfo(mCamera.getParameters()\n                                .getPreviewFormat(), pixelFormat);\n                int sourceSize = size.width * size.height\n                                * pixelFormat.bitsPerPixel / 8;\n                // Set-up camera size and video format.\n                // should be the default on Android anyway.\n                Camera.Parameters parameters = mCamera.getParameters();\n                parameters.setPreviewSize(size.width, size.height);\n                parameters.setPreviewFormat(PixelFormat.YCbCr_420_SP);\n                mCamera.setParameters(parameters);\n                ...\n    ```", "```kt\n                ...\n                mVideoSource = new byte[sourceSize];\n                mImageR = Bitmap.createBitmap(size.width, size.height,\n                                              Bitmap.Config.ARGB_8888);\n                mImageG = Bitmap.createBitmap(size.width, size.height,\n                                              Bitmap.Config.ARGB_8888);\n                mImageB = Bitmap.createBitmap(size.width, size.height,\n                                              Bitmap.Config.ARGB_8888);\n                mImageViewR.setImageBitmap(mImageR);\n                mImageViewG.setImageBitmap(mImageG);\n                mImageViewB.setImageBitmap(mImageB);\n                ...\n    ```", "```kt\n                ...\n                mCamera.addCallbackBuffer(mVideoSource);\n                mCamera.startPreview();\n            } catch (IOException ioe) {\n                mCamera.release();\n                mCamera = null;\n                throw new IllegalStateException();\n            }\n        }\n        ...\n    ```", "```kt\n        ...\n        private Size findBestResolution(int pWidth, int pHeight) {\n            List<Size> sizes = mCamera.getParameters()\n                            .getSupportedPreviewSizes();\n            // Finds the biggest resolution which fits the screen.\n            // Else, returns the first resolution found.\n            Size selectedSize = mCamera.new Size(0, 0);\n            for (Size size : sizes) {\n                if ((size.width <= pWidth)\n                 && (size.height <= pHeight)\n                 && (size.width >= selectedSize.width)\n                 && (size.height >= selectedSize.height)) {\n                    selectedSize = size;\n                }\n            }\n            // Previous code assume that there is a preview size smaller\n            // than screen size. If not, hopefully the Android API\n            // guarantees that at least one preview size is available.\n            if ((selectedSize.width == 0) || (selectedSize.height == 0)) {\n                selectedSize = sizes.get(0);\n            }\n            return selectedSize;\n        }\n    ...\n    ```", "```kt\n    ...\n        @Override\n        public boolean onSurfaceTextureDestroyed(SurfaceTexture pSurface)\n        {\n            // Releases camera which is a shared resource.\n            if (mCamera != null) {\n                mCamera.stopPreview();\n                mCamera.release();\n                // These variables can take a lot of memory. Get rid of\n                // them as fast as we can.\n                mCamera = null;\n                mVideoSource = null;\n                mImageR.recycle(); mImageR = null;\n                mImageG.recycle(); mImageG = null;\n                mImageB.recycle(); mImageB = null;\n            }\n            return true;\n        }\n    ...\n    ```", "```kt\n    ...\n        @Override\n        public void onPreviewFrame(byte[] pData, Camera pCamera) {\n            // New data has been received from camera. Processes it and\n            // requests surface to be redrawn right after.\n            if (mCamera != null) {\n                decode(mImageR, pData, 0xFFFF0000);\n                decode(mImageG, pData, 0xFF00FF00);\n                decode(mImageB, pData, 0xFF0000FF);\n                mImageViewR.invalidate();\n                mImageViewG.invalidate();\n                mImageViewB.invalidate();\n\n                mCamera.addCallbackBuffer(mVideoSource);\n            }\n        }\n\n        public native void decode(Bitmap pTarget, byte[] pSource,\n                                  int pFilter);\n    }\n    ```", "```kt\n    #include <android/bitmap.h>\n    #include <stdlib.h>\n    ...\n    ```", "```kt\n        ...\n        #define toInt(pValue) \\\n            (0xff & (int32_t) pValue)\n        #define max(pValue1, pValue2) \\\n            (pValue1 < pValue2) ? pValue2 : pValue1\n        #define clamp(pValue, pLowest, pHighest) \\\n            ((pValue < 0) ? pLowest : (pValue > pHighest) ? pHighest : pValue)\n        #define color(pColorR, pColorG, pColorB) \\\n            (0xFF000000 | ((pColorB << 6)  & 0x00FF0000) \\\n                        | ((pColorG >> 2)  & 0x0000FF00) \\\n                        | ((pColorR >> 10) & 0x000000FF))\n        ...\n        ```", "```kt\n    ...\n    void JNICALL decode(JNIEnv * pEnv, jclass pClass, jobject pTarget,\n            jbyteArray pSource, jint pFilter) {\n        // Retrieves bitmap information and locks it for drawing.\n        AndroidBitmapInfo bitmapInfo;\n        uint32_t* bitmapContent;\n        if (AndroidBitmap_getInfo(pEnv,pTarget, &bitmapInfo) < 0) abort();\n        if (bitmapInfo.format != ANDROID_BITMAP_FORMAT_RGBA_8888) abort();\n        if (AndroidBitmap_lockPixels(pEnv, pTarget,\n                (void**)&bitmapContent) < 0) abort();\n\n        // Accesses source array data.\n        jbyte* source = (*pEnv)->GetPrimitiveArrayCritical(pEnv,\n                pSource, 0);\n        if (source == NULL) abort();\n        ...\n    ```", "```kt\n        ...\n            int32_t frameSize = bitmapInfo.width * bitmapInfo.height;\n            int32_t yIndex, uvIndex, x, y;\n            int32_t colorY, colorU, colorV;\n            int32_t colorR, colorG, colorB;\n            int32_t y1192;\n\n            // Processes each pixel and converts YUV to RGB color.\n            // Algorithm originates from the Ketai open source project.\n            // See http://ketai.googlecode.com/.\n            for (y = 0, yIndex = 0; y < bitmapInfo.height; ++y) {\n                colorU = 0; colorV = 0;\n                // Y is divided by 2 because UVs are subsampled vertically.\n                // This means that two consecutives iterations refer to the\n                // same UV line (e.g when Y=0 and Y=1).\n                uvIndex = frameSize + (y >> 1) * bitmapInfo.width;\n\n                for (x = 0; x < bitmapInfo.width; ++x, ++yIndex) {\n                    // Retrieves YUV components. UVs are subsampled\n                    // horizontally too, hence %2 (1 UV for 2 Y).\n                    colorY = max(toInt(source[yIndex]) - 16, 0);\n                    if (!(x % 2)) {\n                        colorV = toInt(source[uvIndex++]) - 128;\n                        colorU = toInt(source[uvIndex++]) - 128;\n                    }\n\n                    // Computes R, G and B from Y, U and V.\n                    y1192 = 1192 * colorY;\n                    colorR = (y1192 + 1634 * colorV);\n                    colorG = (y1192 - 833  * colorV - 400 * colorU);\n                    colorB = (y1192 + 2066 * colorU);\n\n                    colorR = clamp(colorR, 0, 262143);\n                    colorG = clamp(colorG, 0, 262143);\n                    colorB = clamp(colorB, 0, 262143);\n\n                    // Combines R, G, B and A into the final pixel color.\n                    bitmapContent[yIndex] = color(colorR,colorG,colorB);\n                    bitmapContent[yIndex] &= pFilter;\n                }\n            }\n            ...\n        ```", "```kt\n        ...\n        (*pEnv)-> ReleasePrimitiveArrayCritical(pEnv,pSource,source,0);\n        if (AndroidBitmap_unlockPixels(pEnv, pTarget) < 0) abort();\n    }\n    ...\n    ```", "```kt\n    ...\n    static JNINativeMethod gMethodRegistry[] = {\n      { \"decode\", \"(Landroid/graphics/Bitmap;[BI)V\", (void *) decode }\n    };\n    static int gMethodRegistrySize = sizeof(gMethodRegistry)\n                                   / sizeof(gMethodRegistry[0]);\n\n    JNIEXPORT jint JNI_OnLoad(JavaVM* pVM, void* reserved) {\n        JNIEnv *env;\n        if ((*pVM)->GetEnv(pVM, (void**) &env, JNI_VERSION_1_6) != JNI_OK)\n        { abort(); }\n\n        jclass LiveCameraActivity = (*env)->FindClass(env,\n                \"com/packtpub/livecamera/LiveCameraActivity\");\n        if (LiveCameraActivity == NULL) abort();\n        (*env)->RegisterNatives(env, LiveCameraActivity,\n                gMethodRegistry, 1);\n        (*env)->DeleteLocalRef(env, LiveCameraActivity);\n\n        return JNI_VERSION_1_6;\n    }\n    ```", "```kt\n    APP_PLATFORM := android-14\n    APP_ABI := all\n    ```", "```kt\n    LOCAL_PATH := $(call my-dir)\n\n    include $(CLEAR_VARS)\n\n    LOCAL_MODULE    := livecamera\n    LOCAL_SRC_FILES := CameraDecoder.c\n    LOCAL_LDLIBS    := -ljnigraphics\n\n    include $(BUILD_SHARED_LIBRARY)\n    ```", "```kt\n    int AndroidBitmap_getInfo(JNIEnv* env, jobject jbitmap,\n                              AndroidBitmapInfo* info);\n    ```", "```kt\n    typedef struct {\n        uint32_t    width;  // Width in pixels\n        uint32_t    height; // Height in pixels\n        uint32_t    stride; // Number of bytes between each line\n        int32_t     format; // Pixel structure (see AndroidBitmapFormat)\n        uint32_t    flags;  // Unused for now\n    } AndroidBitmapInfo;\n    ```", "```kt\n    int AndroidBitmap_lockPixels(JNIEnv* env, jobject jbitmap, void** addrPtr);\n    ```", "```kt\n    int AndroidBitmap_unlockPixels(JNIEnv* env, jobject jbitmap);\n    ```", "```kt\njint RegisterNatives(jclass clazz, const JNINativeMethod* methods,\n                     jint nMethods)\n```", "```kt\ntypedef struct {\n    const char* name;\n    const char* signature;\n    void*       fnPtr;\n} JNINativeMethod;\n```", "```kt\nJNIEnv *env = ...;\n(*env)->RegisterNative(env, ...); \n```", "```kt\nJNIEnv *env = ...;\nenv->RegisterNative(env, ...); \n```"]