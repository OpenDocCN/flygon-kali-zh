- en: '*Chapter 8*: Advanced Topics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：高级主题'
- en: In the previous chapters, we learned about the language syntax, data types,
    working with classes and structures, generics, collections, and other topics that
    have equipped you with the knowledge necessary to write at least simple C# programs.
    However, there's more to the language than that and in this chapter, we will explore
    more advanced concepts. This will include delegates, which are key for functional
    and asynchronous programming that we cover later in this book, as well as various
    forms of pattern matching including regular expressions for texts.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们学习了语言语法、数据类型、类和结构的使用、泛型、集合等主题，这些知识使你能够编写至少简单的C#程序。然而，语言还有更多内容，本章中我们将探讨更高级的概念。这将包括委托，它对于我们后面在本书中涵盖的函数式和异步编程至关重要，以及各种形式的模式匹配，包括用于文本的正则表达式。
- en: 'The topics that we will discuss are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的主题如下：
- en: Delegates and events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托和事件
- en: Anonymous types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型
- en: Tuples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Pattern matching
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Regular expressions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Extension methods
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展方法
- en: After completing this chapter, you will understand how to use delegates to respond
    to events that occur in your application, how to use tuples to handle multiple
    values without introducing new types, how to perform pattern matching in code
    with `is` and `switch` expressions as well as search and replace texts using regular
    expressions. Last, but not least, you will learn how to extend types without modifying
    their actual source code with the help of extension methods.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将了解如何使用委托来响应应用程序中发生的事件，如何使用元组处理多个值而不引入新类型，如何在代码中执行模式匹配，以及如何使用正则表达式搜索和替换文本。最后但同样重要的是，你将学会如何使用扩展方法在不修改其实际源代码的情况下扩展类型。
- en: Let's begin this chapter by learning about delegates and events.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过学习委托和事件来开始本章。
- en: Delegates and events
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托和事件
- en: A **callback** is a function (or more generally, any executable code) that is
    passed as a parameter to another function in order to be called immediately (**synchronous
    callbacks**) or at a later time (**asynchronous callbacks**). Operating systems
    (such as Windows) use callbacks extensively to allow applications to respond to
    events such as mouse events or key presses. Another typical example for callbacks
    is general purpose algorithms that use callbacks for processing elements from
    a collection, such as comparing them in order to sort them or filter them out.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是一个函数（或更一般地说，任何可执行代码），它作为参数传递给另一个函数，以便立即调用（**同步回调**）或在以后的某个时间调用（**异步回调**）。操作系统（如Windows）广泛使用回调来允许应用程序响应鼠标事件或按键事件等事件。回调的另一个典型例子是通用算法，它使用回调来处理来自集合的元素，例如比较它们以对其进行排序或筛选。'
- en: In languages such as C and C++, a callback is simply a *function pointer* (that
    is, the address of a function). However, in .NET, callbacks are *strongly-typed
    objects* that hold not only the reference to one or more methods but also the
    information about their parameters and return type. In .NET and C#, callbacks
    are represented by delegates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如C和C++之类的语言中，回调只是一个*函数指针*（即函数的地址）。然而，在.NET中，回调是*强类型对象*，它不仅保存了一个或多个方法的引用，还保存了关于它们的参数和返回类型的信息。在.NET和C#中，回调由委托表示。
- en: Delegates
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委托
- en: A `delegate` keyword. The declaration looks like a function signature, but the
    compiler actually introduces a class that can hold references to methods whose
    signatures match the signature of the delegate. A delegate can hold references
    to either *static* or *instance methods*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`delegate`关键字。声明看起来像一个函数签名，但编译器实际上引入了一个类，该类可以保存与委托签名匹配的方法的引用。委托可以保存对*静态*或*实例方法*的引用。'
- en: To better understand the way delegates are defined and used, we will consider
    the following example.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解委托的定义和使用方式，我们将考虑以下例子。
- en: 'We have a class that represents an engine. There can be different things the
    engine can do but we will focus on starting and stopping this engine. When these
    events happen, we want to let the clients using the engine to know about this
    and give them the chance to do something. For simplicity, the client will only
    log the event to the console. In this simple model, the engine can be in any of
    these two states: `StatusChange`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个表示引擎的类。引擎可以做不同的事情，但我们将专注于启动和停止这个引擎。当这些事件发生时，我们希望让使用引擎的客户端知道这一点，并给他们机会做一些事情。简单起见，客户端只会将事件记录到控制台。在这个简单的模型中，引擎可以处于这两种状态中的任何一种：`StatusChange`：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`StatusChange` is not a function but a *type*. We will use this for declaring
    a variable in the engine that will hold a reference to a callback method. The
    class that represents the engine is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusChange`不是一个函数，而是一个*类型*。我们将用它来声明引擎中保存回调方法引用的变量。表示引擎的类如下：'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are several things to notice here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几件事情需要注意：
- en: First, the `RegisterStatusChangeHandler()` method takes an argument of the delegate
    type (`StatusChange`) and assigns it to the `statusChangeHandler` member field.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`RegisterStatusChangeHandler()` 方法接受委托类型（`StatusChange`）的参数，并将其分配给`statusChangeHandler`成员字段。
- en: Second, the `Start()` and `Stop()` methods do not actually do much (for simplicity
    only), but you can imagine they are performing a start and a stop of the engine.
    However, after this, they invoke the callback, just like a regular function, passing
    all the necessary arguments.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，`Start()`和`Stop()`方法实际上并没有做太多事情（仅为简单起见），但你可以想象它们正在启动和停止引擎。然而，在此之后，它们调用回调函数，就像普通函数一样，传递所有必要的参数。
- en: In this example, the delegate does not return any value, but a delegate can
    return anything. However, before invoking the callback method, a *null check*
    is performed. If the delegate was not assigned a reference to a method, invoking
    the delegate results in `NullReferenceException`.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，委托不返回任何值，但委托可以返回任何东西。然而，在调用回调方法之前，会执行*空引用检查*。如果委托没有被分配到一个方法的引用，调用委托会导致`NullReferenceException`。
- en: 'The client code creates an instance of the `Engine` class, registers a handler
    for status changes, and then starts and stops its. The code is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码创建了`Engine`类的一个实例，注册了状态更改的处理程序，然后启动和停止它。代码如下：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The static method, `OnEngineStatusChanged()`, is used as a callback for the
    engine start and stop events. Its signature matches the type of the delegate.
    Executing this program results in the following output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法`OnEngineStatusChanged()`用作引擎启动和停止事件的回调。其签名与委托的类型匹配。执行此程序将产生以下输出：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: An important aspect of .NET delegates is that they support *multicasting*. This
    means that you can actually set references to as many methods you want to be called;
    the delegate will then invoke them in the order they are added. Multicast delegates
    are represented by the `System.MulticastDelegate` class. This class has, internally,
    a linked list of delegates that is called an *invocation list*. This list can
    have any number of elements. When the multicast delegate is invoked, all of the
    delegates in the invocation list are called in the order they appear in the list
    (which is the order in which they were added). This operation is synchronous and
    if any error appears during the execution of the invocation list, an exception
    is thrown.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: .NET委托的一个重要方面是它们支持*多播*。这意味着您实际上可以设置对要调用的任意多个方法的引用；然后委托将按照它们被添加的顺序调用它们。多播委托由`System.MulticastDelegate`类表示。该类在内部具有称为*调用列表*的委托链表。此列表可以有任意数量的元素。当调用多播委托时，调用列表中的所有委托按照它们在列表中出现的顺序（即它们被添加的顺序）被调用。此操作是同步的，如果在调用列表的执行过程中出现任何错误，将抛出异常。
- en: 'On the other hand, you can remove a reference to a method from the delegate
    when you no longer want it to be called. Both of these aspects will be exemplified
    in the following example where we change the `Engine` class to allow multiple
    callbacks to be not only registered but also unregistered:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当您不再希望调用某个方法时，可以从委托中移除对该方法的引用。这两个方面将在以下示例中得到说明，其中我们改变了`Engine`类以允许多个回调不仅被注册，而且还可以被注销：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Again, there are two things to notice here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这里有两件事需要注意：
- en: First, the `RegisterStatusChangeHandler()` method no longer simply assigns its
    argument to the `statusChangeHandler` field, but actually uses the `+=` operator
    to add a new reference to the list the delegate is holding internally. Consequently,
    the `UnregisterStatusChangeHandler()` method is using the `-=` operator to remove
    a reference from the delegate. The `+=` and `-=` operators are overloaded for
    the delegate types.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`RegisterStatusChangeHandler()`方法不再简单地将其参数分配给`statusChangeHandler`字段，而是实际上使用`+=`运算符向委托内部持有的列表添加一个新引用。因此，`UnregisterStatusChangeHandler()`方法使用`-=`运算符从委托中移除一个引用。`+=`和`-=`运算符已被委托类型重载。
- en: Second, the code in `Start()` and `Stop()` has slightly changed. The null-conditional
    operator (`?.`) is used to call the `Invoke()` method only if the object is not
    `null`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，`Start()`和`Stop()`中的代码略有改变。使用空值条件运算符（`?.`）仅在对象不为`null`时调用`Invoke()`方法。
- en: 'On the other hand, the changes in the main program are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，主程序中的更改如下：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This time, we register two callbacks:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们注册了两个回调：
- en: One that records the event on the *console*.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个在*控制台*上记录事件。
- en: One that records to a *file*.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个记录到*文件*的回调。
- en: 'We start and stop the engine and then we unregister the callback that logs
    to the file on disk. Last, we start the engine again. As a result, the output
    on the console will be the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动和停止引擎，然后注销记录到磁盘文件的回调函数。最后，我们再次启动引擎。因此，控制台上的输出将如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, only the first two lines also appear on the file on disk, because the
    second callback was removed before restarting the engine.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，只有前两行也出现在磁盘文件上，因为在重新启动引擎之前已经移除了第二个回调函数。
- en: In this second example, we used the `Invoke()` method to call the methods referred
    by the delegate. Where did the `Invoke()` method come from? Behind the scenes,
    when you declare a delegate type, the compiler generates a sealed class derived
    from `System.MulticastDelegate` that in turn is derived from `System.Delegate`.
    These are system types that you are not allowed to derive explicitly from. However,
    they provide all of the functionalities we have seen so far, such as the ability
    to add and remove methods from the delegate's invocation list.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第二个示例中，我们使用`Invoke()`方法调用委托引用的方法。`Invoke()`方法是从哪里来的呢？在幕后，当您声明委托类型时，编译器会生成一个从`System.MulticastDelegate`派生的密封类，该类又从`System.Delegate`派生。这些都是您不允许显式派生的系统类型。但是，它们提供了我们迄今为止看到的所有功能，例如能够向委托的调用列表中添加和移除方法的能力。
- en: The class created by the compiler contains three methods—`Invoke()` (used to
    invoke the callbacks in a *synchronous manner*), `BeginInvoke()`, and `EndInvoke()`
    (used to invoke the callbacks in an *asynchronous manner*). For examples of asynchronous
    delegates, consult additional references. You can actually check the compiler-generated
    code by opening the assembly in a disassembler such as **ildasm.exe** or **ILSpy**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器创建的类包含三种方法——`Invoke()`（用于以*同步方式*调用回调函数）、`BeginInvoke()`和`EndInvoke()`（用于以*异步方式*调用回调函数）。有关异步委托的示例，请参考其他参考资料。您实际上可以通过在反汇编器（如**ildasm.exe**或**ILSpy**）中打开程序集来检查编译器生成的代码。
- en: Events
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: The code we have written so far is a little too *explicit*. We had to create
    methods for registering and unregistering references to callback methods. That
    was because the delegate that held those references was private in the class.
    We could make it public, but then we break encapsulation and risk allowing the
    clients to erroneously overwrite the delegate's invocation list. To help with
    these aspects, .NET and C# offer *events*, which are simply syntactic sugar for
    the explicit code we wrote earlier for registering and unregistering callbacks.
    Events are introduced with the `event` keyword.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们编写的代码有点太*显式*了。我们不得不创建方法来注册和取消注册对回调方法的引用。这是因为在类中，持有这些引用的委托是私有的。我们可以将其设为公共的，但这样会破坏封装性，并有风险允许客户端错误地覆盖委托的调用列表。为了帮助处理这些方面，.NET和C#提供了*事件*，它们只是我们之前为注册和取消注册回调编写的显式代码的语法糖。事件是用`event`关键字引入的。
- en: 'The last implementation of the engine will change to the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎的最后一个实现将更改为以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we no longer have the methods for registering and unregistering
    callbacks, only an event object called `StatusChanged`. These are done in the
    client code on the event object, using the `+=` (to add a reference to a method)
    and `-=` (to remove a reference to a method) operators. We can see the client
    code in the following code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再有用于注册和取消注册回调的方法，只有一个名为`StatusChanged`的事件对象。这些是在客户端代码中在事件对象上完成的，使用`+=`（添加对方法的引用）和`-=`（删除对方法的引用）操作符。我们可以在以下代码中看到客户端代码。
- en: 'In this example, we create an `Engine` object and register to callbacks for
    the `StatusChanged` event—one is a reference to the `OnEngineStatusChanged()`
    method (that logs the event to a file) and the other one is a lambda expression
    (that logs the event to the console):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个`Engine`对象，并为`StatusChanged`事件注册了回调函数——一个是对`OnEngineStatusChanged()`方法的引用（将事件记录到文件中），另一个是一个lambda表达式（将事件记录到控制台）：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: After starting and stopping the engine, we unregister the reference to `OnEngineStatusChanged()`
    and then restart the engine. The result of executing this program is identical
    to the previous one.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和停止引擎后，我们取消对`OnEngineStatusChanged()`的引用，然后重新启动引擎。执行此程序的结果与先前的程序相同。
- en: 'In all of the examples so far, the delegate type had a single argument that
    was the status of the engine. However, proper implementation of the event''s pattern
    (used throughout the entire .NET Framework) is to have two arguments:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的例子中，委托类型都有一个参数，即引擎的状态。然而，事件模式的正确实现（在整个.NET Framework中都使用）是有两个参数：
- en: The first argument is `System.Object`, which holds a reference to the object
    that generated the event. It is up to the client being called to use this reference
    or not.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个参数是`System.Object`，它保存了生成事件的对象的引用。由调用的客户端决定是否使用此引用。
- en: The second argument is of a type derived from `System.EventArgs`, which holds
    all of the event-related information.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是从`System.EventArgs`派生的类型，其中包含与事件相关的所有信息。
- en: 'To comply with this pattern, our implementation of `Engine` will change to
    the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了符合这种模式，我们的`Engine`的实现将更改为以下内容：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will leave it as an exercise to the reader to make the necessary changes
    to the main program to use the new implementation of the `Engine` class.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将留给读者练习对主程序进行必要的更改，以使用`Engine`类的新实现。
- en: 'The key takeaways about delegates and events are the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关委托和事件的关键要点如下：
- en: Delegates allow methods to be passed as arguments to be called later, either
    synchronously or asynchronously.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托允许将方法作为参数传递，以便稍后调用，可以同步或异步调用。
- en: Delegates support multicasting, that is, the invocation of multiple callback
    methods.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托支持多播，即调用多个回调方法。
- en: Static methods, instance methods, anonymous methods, and lambda expressions
    can be used as callbacks with delegates.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态方法、实例方法、匿名方法和lambda表达式都可以作为委托的回调使用。
- en: Delegates can be generic.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托可以是泛型的。
- en: Events are syntactic sugar that help with registration and removal of callbacks.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件是一种语法糖，有助于注册和移除回调。
- en: The next topic to discuss in this chapter are anonymous types.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论的下一个主题是匿名类型。
- en: Anonymous types
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类型
- en: It is sometimes necessary to construct temporary objects that hold some values,
    usually a subset of some larger object. To avoid creating a specific type for
    this purpose only, the language provides so-called *anonymous types*. These are
    a sort of use-and-forget types typically used in query expressions with **Language
    Integrated Query** (**LINQ**). This topic will be discussed in [*Chapter 10*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184),
    *Lambdas, LINQ, and Functional Programming*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时需要构造临时对象来保存一些值，通常是某个较大对象的子集。为了避免仅为此目的创建特定类型，语言提供了所谓的*匿名类型*。这些是一种使用后即忘记的类型，通常与**语言集成查询**（**LINQ**）一起在查询表达式中使用。这个主题将在[*第10章*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184)中讨论，*Lambda、LINQ和函数式编程*。
- en: These types are called anonymous because you do not specify a name in the source
    code. The name is assigned by the compiler. They consist of read-only properties
    only; any other member type is not allowed. The type of the read-only properties
    cannot be explicitly specified and is inferred by the compiler.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型被称为匿名，因为在源代码中没有指定名称。名称由编译器分配。它们只包含只读属性；不允许任何其他成员类型。只读属性的类型不能显式指定，而是由编译器推断。
- en: 'An anonymous type is introduced with the `new` keyword followed by a list of
    properties in angle-brackets (an object initializer). The following code snippet
    shows an example:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`new`关键字引入匿名类型，后面跟着一系列属性（对象初始化器）的尖括号。以下代码片段显示了一个例子：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have defined an anonymous type with three properties: `Name`, `Capacity`,
    and `Power`. The types of these properties are inferred by the compiler from their
    initialization value. In this case, they are `string` for `Name`, `int` for `Capacity`,
    and `double` for `Power`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个具有三个属性`Name`、`Capacity`和`Power`的匿名类型。这些属性的类型由编译器从它们的初始化值中推断出来。在这种情况下，它们分别是`Name`的`string`，`Capacity`的`int`和`Power`的`double`。
- en: 'It is mandatory to specify a name for a property when it is initialized from
    an expression. However, if it is initialized from a field or property of another
    object, the name is optional. In this case, the compiler uses the same name as
    that of the member used to initialize it. To show an example, let''s consider
    the following type:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当从表达式初始化属性时，必须指定属性的名称。但是，如果它是从另一个对象的字段或属性初始化的，名称是可选的。在这种情况下，编译器使用与用于初始化它的成员相同的名称。举个例子，让我们考虑以下类型：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Having this, we can write the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以写如下：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have created an instance of the `Engine` class. From this instance, we have
    created another object of an anonymous type that has two properties, which the
    compiler calls `Name` and `Power` because they are initialized from the `Name`
    and `Power` properties of the `Engine` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了`Engine`类的一个实例。从这个实例中，我们创建了另一个匿名类型的对象，它有两个属性，编译器称之为`Name`和`Power`，因为它们是从`Engine`类的`Name`和`Power`属性初始化的。
- en: 'Anonymous types have the following properties:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型具有以下属性：
- en: They are implemented as sealed classes and are, therefore, reference types.
    The CLI does not make any difference between anonymous types and other reference
    types.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被实现为密封类，因此是引用类型。CLI不会区分匿名类型和其他引用类型。
- en: They are directly derived from `System.Object` and can only be cast to `System.Object`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们直接派生自`System.Object`，只能转换为`System.Object`。
- en: They can only contain read-only properties. No other members are allowed.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能包含只读属性。不允许其他成员。
- en: They cannot be used as the type of a field, property, event, the return type
    of a method, or the type of a parameter of a method, constructor, or indexer.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能用作字段、属性、事件、方法的返回类型或方法、构造函数或索引器的参数类型。
- en: You can specify names for the read-only properties of an anonymous type. This
    is mandatory when initializing from an expression, but optional when initializing
    from a field or property. In this case, the compiler uses the name of the member
    for the property's name.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以为匿名类型的只读属性指定名称。这在从表达式初始化时是强制性的，但在从字段或属性初始化时是可选的。在这种情况下，编译器使用成员的名称作为属性的名称。
- en: The expression used to initialize a property cannot be null, an anonymous function,
    or a pointer type.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于初始化属性的表达式不能为null、匿名函数或指针类型。
- en: The scope of an anonymous type is the method in which it is defined.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匿名类型的作用域是定义它的方法。
- en: When you declare a variable of an anonymous type, you must use `var` as a placeholder
    for the type name.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当声明匿名类型的变量时，必须使用`var`作为类型名称的占位符。
- en: A similar concept of ad hoc types but with different semantics is presented
    by tuples, which is the topic of the next section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 元组提供了一种类似的临时类型概念，但具有不同的语义，这是下一节的主题。
- en: Tuples
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: '`out` or `ref` parameters or when you want to pass multiple values to a method
    as a single object.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`out`或`ref`参数，或者当您想要将多个值作为单个对象传递给方法时。'
- en: This aspect represents the key difference between anonymous types and tuples.
    The former is meant for use within the scope of a single method and cannot be
    passed as an argument or returned from a method. The latter are intended for this
    exact purpose.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方面代表了匿名类型和元组之间的关键区别。前者用于在单个方法的范围内使用，不能作为参数传递或从方法返回。后者则是为了这个确切的目的而设计的。
- en: 'In C#, there are two kinds of tuples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有两种类型的元组：
- en: '`System.Tuple` class'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.Tuple`类'
- en: '`System.ValueTuple` structure'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`System.ValueTuple`结构'
- en: In the next subsection, we will look at both of these types.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一小节中，我们将看看这两种类型。
- en: The Tuple class
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组类
- en: 'Reference tuples were introduced in .NET Framework 4.0\. The generic class,
    `System.Tuple`, can hold up to eight values of different types. Should you need
    tuples with more than eight values, you will have to create nested tuples. Tuples
    can be instantiated in either of two ways:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 引用元组是在.NET Framework 4.0中引入的。泛型类`System.Tuple`可以容纳最多八个不同类型的值。如果需要超过八个值的元组，您将不得不创建嵌套元组。元组可以通过以下两种方式实例化：
- en: By using the *constructor* of `Tuple<T>`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`Tuple<T>`的*构造函数*
- en: By using the *helper method*, `Tuple.Create()`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用*辅助方法*，`Tuple.Create()`
- en: 'The following two lines are equivalent:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行是等价的：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second line here is preferred because it is simpler as you do not have to
    specify the type of each value. This is because it is inferred by the compiler
    from the arguments.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的第二行更好，因为它更简单，你不必指定每个值的类型。这是因为编译器从参数中推断出类型。
- en: 'The elements of the tuple are accessible through properties called `Item1`,
    `Item2`, `Item3`, `Item4`, `Item5`, `Item6`, `Item7`, and `Rest`. In the following
    example, we use the `Item1`, `Item2`, and `Item3` properties to print the engine
    name, capacity, and power to the console:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的元素可以通过名为`Item1`、`Item2`、`Item3`、`Item4`、`Item5`、`Item6`、`Item7`和`Rest`的属性访问。在下面的示例中，我们使用`Item1`、`Item2`和`Item3`属性将引擎名称、容量和功率打印到控制台上：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Nested tuples can be used when you need more than eight elements. In this case,
    it makes sense to put the nested tuple as the last element. The following example
    creates a tuple with 10 values, the last three of them (representing various engine
    powers in kW) being grouped in a second, nested tuple:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要超过八个元素时，可以使用嵌套元组。在这种情况下，将嵌套元组放在最后一个元素是有意义的。以下示例创建了一个具有10个值的元组，其中最后三个值（表示不同功率的发动机功率，单位为千瓦）被分组在第二个嵌套元组中：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Notice here that we used `Rest.Item1` and not simply `Rest`. The output of
    this program is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意这里我们使用的是`Rest.Item1`而不是简单的`Rest`。该程序的输出如下：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The reason for this is that the inferred type for the variable engine is `Tuple<string,
    int, int, double, int, string, int, Tuple<Tuple<int, int, int>>>`. Consequently,
    `Rest` represents a tuple that holds a single value that is also a tuple that
    holds three `int` values. To access the elements of the nested tuple, you must
    use, for this case, `Rest.Item1.Item1`, `Rest.Item1.Item2`, and `Rest.Item1.Item3`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为变量 engine 的推断类型是 `Tuple<string, int, int, double, int, string, int, Tuple<Tuple<int,
    int, int>>>`。因此，`Rest` 表示一个包含单个值的元组，该值也是包含三个 `int` 值的元组。要访问嵌套元组的元素，您必须使用，对于这种情况，`Rest.Item1.Item1`、`Rest.Item1.Item2`
    和 `Rest.Item1.Item3`。
- en: 'To create a tuple of the type, `Tuple<string, int, int, double, int, string,
    int, Tuple<int, int, int>>`, you must use the explicit syntax using constructors:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建类型为 `Tuple<string, int, int, double, int, string, int, Tuple<int, int, int>>`
    的元组，必须使用构造函数的显式语法：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`System.Tuple` is a reference type and therefore objects of this type are allocated
    on the heap. If many allocations of small objects occur during the execution of
    a program, it can impact performance.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Tuple` 是一个引用类型，因此此类型的对象分配在堆上。如果在程序执行过程中发生许多小对象的分配，可能会影响性能。'
- en: This adds to the limitations we have seen earlier—the number of elements and
    the unnamed properties. To overcome these problems, C# 7.0, .NET Framework 4.7,
    and .NET Standard 2.0 have introduced value type tuples, which we will explore
    in the following section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了我们之前看到的限制——元素数量和未命名属性。为了克服这些问题，C# 7.0、.NET Framework 4.7 和 .NET Standard
    2.0 引入了值类型元组，我们将在下一节中探讨。
- en: Value tuples
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值元组
- en: These are represented by the `System.ValueTuple` structure. If your project
    does not target .NET Framework 4.7 or higher or .NET Standard 2.0 or higher, you
    can still use `ValueTuple` by installing it as a NuGet package.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由 `System.ValueTuple` 结构表示。如果您的项目不针对 .NET Framework 4.7 或更高版本，或 .NET Standard
    2.0 或更高版本，您仍然可以通过将其安装为 NuGet 包来使用 `ValueTuple`。
- en: Various value tuple features have been added in the several 7.x releases of
    the languages. The functionalities described here are aligned with C# 8.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个 7.x 版本的语言中添加了各种值元组功能。这里描述的功能与 C# 8 对齐。
- en: 'Apart from the value semantics, value tuples differ from the reference tuples
    in several important ways:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 除了值语义之外，值元组在几个重要方面与引用元组不同：
- en: They can hold a sequence of any number of elements, but at least two are required.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以容纳任意数量的元素序列，但至少需要两个。
- en: They may have compile-time named fields.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能具有编译时命名字段。
- en: They have a simpler, yet richer syntax for creating, assigning, deconstructing,
    and comparing values.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们具有更简单但更丰富的语法，用于创建、赋值、解构和比较值。
- en: 'Creating a value tuple is done using *parentheses syntax* with values specified
    in between. The following three declarations are equivalent:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*括号语法*和指定的值来创建值元组。以下三个声明是等价的：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In all these cases, the type of the variable engine is `ValueTuple<string,
    int, double>` and the tuple is said to be *unnamed*. In this case, its values
    are available in the public fields—`Item1`, `Item2`, and `Item3`, which are implicit
    names assigned by the compiler:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，变量 engine 的类型是 `ValueTuple<string, int, double>`，元组被称为*未命名*。在这种情况下，它的值可以在公共字段中访问——`Item1`、`Item2`
    和 `Item3`，这些是编译器隐式分配的名称：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However, when creating a value tuple, you can choose to give names to the values
    and therefore create synonyms for the fields, `Item1`, `Item2`, and so on. Such
    value tuples are called **named tuples**. You can see an example of a named tuple
    in the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在创建值元组时，您可以选择为值指定名称，从而为字段创建同义词，如 `Item1`、`Item2` 等。这种值元组称为**命名元组**。您可以在以下代码片段中看到一个命名元组的示例：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These synonyms are only available at compile time because IDEs leverage the
    Roslyn APIs to make them available for you from the source code, but in the compiler
    intermediate language code, they are not available, only the unnamed fields—`Item1`,
    `Item2`, and so on.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些同义词仅在编译时可用，因为 IDE 利用 Roslyn API 从源代码中为您提供它们，但在编译器中间语言代码中，它们不可用，只有未命名字段——`Item1`、`Item2`
    等。
- en: 'The name of a field can appear on either side of the assignment; moreover,
    they can appear on both sides, in which case the *left name* will take *precedence*
    and the *right name* will be *ignored*. The following two declarations will produce
    a named value tuple identical to the one seen in the preceding code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的名称可以出现在赋值的任一侧；此外，它们可以同时出现在两侧，在这种情况下，*左侧名称* 将*优先*，*右侧名称* 将*被忽略*。以下两个声明将产生一个与前面代码中看到的命名值元组相同的命名值元组：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The names for the fields can also be inferred from variables used to initialize
    the value tuple (as for C# 7.1). In the following example, the value tuple will
    have fields called `name`, `capacity` (lowercase), and `Item3` because the last
    value is a literal without an explicitly specified name:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 字段的名称也可以从用于初始化值元组的变量中推断出（如 C# 7.1）。在以下示例中，值元组将具有名为 `name`、`capacity`（小写）和 `Item3`
    的字段，因为最后一个值是一个没有明确指定名称的文字：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Returning value tuples from a method is very simple. In the following example,
    the `GetEngine()` function returns an unnamed value type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 从方法返回值元组非常简单。在以下示例中，`GetEngine()` 函数返回一个未命名的值类型：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, you can choose to return a named value type, in which case, you need
    to specify the names of the fields, as shown here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可以选择返回一个命名值类型，在这种情况下，您需要指定字段的名称，如下所示：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Beginning with C# 7.3, value tuples can be tested for *equality* and *inequality*
    using the `==` and `!=` operators. These operators work by comparing, in order,
    each element from the left side with each element on the right side. The comparison
    stops when the first pair is not equal. However, this only happens when the shape
    of the tuples is the same, that is, the number of fields and their type. The names
    do not participate in the test of equality or inequality. The next example does
    a comparison of two value tuples:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从C# 7.3开始，可以使用`==`和`!=`运算符测试值元组的*相等性*和*不相等性*。这些运算符通过按顺序比较左侧的每个元素与右侧的每个元素来工作。当第一对不相等时，比较停止。但是，这仅在元组的形状相同时发生，即字段的数量和它们的类型。名称不参与相等性或不相等性的测试。下一个示例比较了两个值元组：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Tuple equality** performs a *lifted conversion* if one tuple is a nullable
    tuple, as well as *implicit conversions* on each member of both tuples. The latter
    include lifted conversions, widening conversions, or other implicit conversions.
    As an example, the following tuples are equal:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组相等**如果一个元组是可空元组，则执行*提升转换*，以及对两个元组的每个成员进行*隐式转换*。后者包括提升转换、扩展转换或其他隐式转换。例如，以下元组是相等的：'
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It is possible to deconstruct the value of a tuple. You can do so either by
    explicitly specifying the type of the variables or using `var`. The following
    declarations are all equivalent. In the following and last example, the use of
    `var` is combined with explicit type names:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解构元组的值。可以通过显式指定变量的类型或使用`var`来实现。以下声明都是等效的。在以下和最后一个示例中，`var`的使用与显式类型名称相结合：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If there are values that you are not interested in, you can ignore them by
    using the `_` placeholder like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有您不感兴趣的值，可以使用`_`占位符来忽略它们，如下所示：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It is possible to deconstruct any .NET type provided that a method called `Deconstruct`
    with `out` parameters for every value that you want to retrieve is available.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对任何.NET类型进行解构，只要提供了一个名为`Deconstruct`的方法，该方法具有您想要检索的每个值的`out`参数。
- en: 'In the following example, the `Engine` class has three properties: `Name`,
    `Capacity`, and `Power`. The `Deconstruct()` public method takes three out arguments
    matching these properties. This makes it possible for objects of this type to
    be deconstructed using tuple syntax. The following listing shows an implementation
    of the `Engine` class that provides tuple deconstruction:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，`Engine`类有三个属性：`Name`，`Capacity`和`Power`。`Deconstruct()`公共方法使用三个输出参数匹配这些属性。这使得可以使用元组语法对此类型的对象进行解构。以下清单显示了提供元组解构的`Engine`类的实现：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Deconstruct` method can be made available as an extension method, enabling
    you to provide deconstruction semantics even for types you did not author, provided
    that you only need to deconstruct values accessible through the public interface
    of the type. Such an example is shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deconstruct`方法可以作为扩展方法提供，使您能够为您没有编写的类型提供解构语义，前提是您只需要解构通过类型的公共接口可访问的值。这里展示了一个示例：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you have a hierarchy of classes and you provide `Deconstruct()` methods,
    then you must make sure you do not introduce ambiguities, such as in cases where
    different overloads have the same number of arguments. It should be noted that
    deconstruction operators do not participate in testing equality. Therefore, the
    following sample will generate a compiler error:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个类的层次结构，并且提供了`Deconstruct()`方法，则必须确保不会引入歧义，例如在不同重载具有相同数量的参数的情况下。应该注意，解构运算符不参与测试相等性。因此，以下示例将生成编译器错误：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Summarizing on this topic, the support for value tuples in C# 7 makes it much
    easier to work with tuples in key scenarios such as holding temporary values or
    records from a database. This can be done without introducing new types or returning
    multiple values from a method without the use of `out` or `ref` parameters. With
    the performance benefit of value semantics and the improvements on element access
    based on names, as well as other key features, named values are an important improvement
    on the reference type tuples that we saw at the beginning of this section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，C# 7中对值元组的支持使得在关键场景中更容易使用元组，比如保存临时值或来自数据库的记录。这可以在不引入新类型或返回多个值的情况下完成，而不使用`out`或`ref`参数。通过值语义的性能优势以及基于名称的元素访问的改进，以及其他关键特性，命名值是本节开始时看到的引用类型元组的重要改进。
- en: Pattern matching
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: '`if` and `switch` statements when we check whether an object has some value
    and then proceed to extract information from it. However, this is a rudimentary
    form of pattern matching.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`和`switch`语句中，我们检查对象是否具有某个值，然后继续从中提取信息。然而，这是一种基本形式的模式匹配。
- en: In C# 7, new capabilities are added to `is` and `switch` statements to enable
    pattern matching capabilities that drive a better separation of data and code
    and lead to more concise and readable code. The pattern matching capabilities
    are extended with new features in C# 8\. You will learn about these in [*Chapter
    15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271), *New Features of C# 8*.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7中，对`is`和`switch`语句添加了新的功能，以实现模式匹配功能，从而更好地分离数据和代码，并导致更简洁和可读的代码。C# 8中的新功能扩展了模式匹配功能。您将在[*第15章*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271)中了解这些内容，*C#
    8的新功能*。
- en: The is expression
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: is表达式
- en: 'At runtime, the `is` operator checks that an object is compatible with a given
    type (the general form, `expr is type`). However, in C# 7, this was extended to
    include several forms of pattern matching:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，`is`运算符检查对象是否与给定类型兼容（一般形式为`expr is type`）。然而，在C# 7中，这被扩展为包括几种形式的模式匹配：
- en: '`expr is type varname` form, checks whether an expression can be converted
    to the specified type and, if so, casts it to a variable of that specified type.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr is type varname`形式，检查表达式是否可以转换为指定类型，如果可以，则将其转换为指定类型的变量。'
- en: '`expr is constant` form, checks whether the expression evaluates to a specified
    constant. A particular constant is `null`, for which the pattern is `expr is null`.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr is constant`形式，检查表达式是否评估为指定的常量。特定常量是`null`，其模式为`expr is null`。'
- en: '`expr is var varname` form, that always succeeds and binds the value to a new
    local variable. A key difference from the type pattern is that `null` is always
    matched and the new variable is assigned `null`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expr is var varname`形式，总是成功并将值绑定到一个新的局部变量。与类型模式的一个关键区别是`null`总是匹配，并且新变量被赋值为`null`。'
- en: 'To understand how these work, we will use several classes representing vehicles:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这些工作原理，我们将使用几个代表车辆的类：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'These vehicle classes are not a part of a hierarchy of classes, but they have
    public methods that set the vehicle in motion, according to its type. For example,
    the airplane flies, the bike rides, and the car drives. The next code listing
    shows a function that uses several forms of pattern matching:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些车辆类不是类层次结构的一部分，但它们有设置车辆运动的公共方法，根据其类型。例如，飞机飞行，自行车骑行，汽车驾驶。下一个代码清单显示了使用几种形式的模式匹配的函数：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This function sets the vehicle in motion according to its specific way of doing
    so. A statement like `if(vehicle is Airplane a)` tests whether the variable vehicle
    can be converted to the `Airplane` type, and if that is true, then it assigns
    it to a new variable of the `Airplane` type (in this example, `a`). This works
    with both value types and reference types.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数根据其特定的方式使车辆运动起来。像`if(vehicle is Airplane a)`这样的语句测试变量vehicle是否可以转换为`Airplane`类型，如果是，则将其分配给`Airplane`类型的新变量（在本例中为`a`）。这适用于值类型和引用类型。
- en: The variables seen here—`a`, `b`, and `c`—have a local scope to the `if` or
    `else` statement. However, these variables are in scope and definitely assigned
    only when the match was successful. This prevents you from accessing the result
    of a pattern-matching expression when the pattern was not matched.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里看到的变量`a`、`b`和`c`只在`if`或`else`语句的局部范围内。然而，只有在匹配成功时，这些变量才在范围内并被赋值。这可以防止您在模式匹配表达式未匹配时访问结果。
- en: 'As well as the type pattern, a constant pattern is also used here. The `if
    (vehicle is null)` statement is a test to see whether the reference is actually
    set to the instance of an object or not; if not, an exception is thrown. However,
    as already mentioned, constant pattern matching can be used with anything that
    is a constant—a literal value, a variable declared with the const specifier, or
    an enumeration value. The way constant expressions are evaluated is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类型模式，这里还使用了常量模式。`if (vehicle is null)`语句是一个测试，用于查看引用是否实际设置为对象的实例；如果没有，就会抛出异常。然而，如前所述，常量模式匹配可以与任何常量一起使用——文字值、用const修饰符声明的变量，或者枚举值。常量表达式的评估方式如下：
- en: If both `expr` and constant are of integral types, it basically evaluates the
    `expr == constant` expression.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`expr`和常量都是整数类型，它基本上评估`expr == constant`表达式。
- en: Otherwise, it invokes the static method, `Object.Equals(expr, constant)`.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，它调用静态方法`Object.Equals(expr, constant)`。
- en: 'The following function shows more examples of constant pattern matching. The
    `IsTrue()` function converts the supplied argument to a Boolean value. The Boolean
    value (`true`), the integral value (`1`), the string (`"1"`), and the string (`"true"`)
    are converted to `true`; everything else including `null` is converted to `false`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数显示了更多的常量模式匹配示例。`IsTrue()`函数将提供的参数转换为布尔值。布尔值（`true`），整数值（`1`），字符串（`"1"`）和字符串（`"true"`）都转换为`true`；包括`null`在内的其他所有内容都转换为`false`：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The switch expression
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: switch表达式
- en: The more patterns you need to check, the more cumbersome it is to write these
    sorts of `if-else` statements. Naturally, you would want to replace them with
    a `switch`. Pattern matching of the same nature is supported for `switch` statements
    with a similar syntax.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要检查的模式越多，编写这些`if-else`语句就越繁琐。自然地，您会想用`switch`替换它们。相同类型的模式匹配也支持`switch`语句，具有类似的语法。
- en: Until C# 7.0, the `switch` statement supported constant pattern matching with
    integral types and strings. Since C# 7.0, the type pattern seen earlier is also
    supported in a `switch` statement.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 直到C# 7.0，`switch`语句支持整数类型和字符串的常量模式匹配。自C# 7.0以来，前面看到的类型模式也支持在`switch`语句中。
- en: 'The `SetInMotion()` function shown in the previous section can be modified
    as follows using a `switch` statement:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中显示的`SetInMotion()`函数可以修改为使用`switch`语句：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `switch` statements that use constant pattern matching can only have one
    case label that matches the value of the `switch` expressions. Moreover, `switch`
    sections must not fall through the next section but must end with `break`, `return`,
    or `goto`. However, they can be arranged in any order without affecting the behavior
    of the program semantics and execution.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用常量模式匹配的`switch`语句只能有一个与`switch`表达式的值匹配的情况标签。此外，`switch`部分不能穿过下一个部分，而必须以`break`、`return`或`goto`结束。然而，它们可以以任何顺序排列，而不会影响程序语义和执行的行为。
- en: With type pattern matching, the rules change. The `switch` section can fall
    through the next and `goto` is no longer supported as a jump mechanism. The case
    label expressions are evaluated in the order they appear in the text and the default
    case is only executed if none of the case labels match the pattern. The default
    case can appear anywhere in `switch` but it is always evaluated last.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型模式匹配，规则会发生变化。`switch`部分可以穿过下一个，`goto`不再支持作为跳转机制。情况标签表达式按照它们在文本中出现的顺序进行评估，只有在没有任何情况标签与模式匹配时才执行默认情况。默认情况可以出现在`switch`的任何位置，但始终在最后执行。
- en: If a default case is missing and none of the existing case labels match the
    pattern, the execution continues after the `switch` statement without any code
    in any case label executing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果默认情况缺失，并且没有任何现有的情况标签与模式匹配，执行将在`switch`语句之后继续，而不会执行任何情况标签中的代码。
- en: 'Another feature of type pattern matching with the `switch` expression is the
    support for `when` clauses. The following example shows another version of the
    `SetInMotion()` method that uses two case labels to match the `Car` type, but
    one of them with a condition—that the `HasAutoDrive` property of the `Car` object
    is set to `true`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`表达式的类型模式匹配还支持`when`子句。以下示例展示了`SetInMotion()`方法的另一个版本，它使用了两个case标签来匹配`Car`类型，但其中一个带有条件——即`Car`对象的`HasAutoDrive`属性设置为`true`：'
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It is important to note that matching a type pattern guarantees a *non-null
    value*, so there is no need for further tests for `null`. There are special rules
    for matching `null` in the language. A `null` value does not match a type pattern,
    regardless of the type of the variable. A case label with a pattern matching for
    `null` can be added in a switch expression with a type pattern matching to specifically
    handle `null` values. Such an example is seen in the preceding implementation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，匹配类型模式保证了*非空值*，因此不需要进一步测试`null`。对于在语言中匹配`null`有特殊规则。`null`值不匹配类型模式，无论变量的类型如何。可以在具有类型模式匹配的switch表达式中添加一个用于特别处理`null`值的模式匹配的case标签。在前面的实现中就有这样的例子。
- en: A special form of type pattern matching is using `var`. The rules are similar
    to `is` expressions—the type is inferred from the static type of the switch expression
    and a `null` value always matches. Therefore, when using the `var` pattern, you
    must add an explicit `null` check because the value may actually be `null`. A
    `var` declaration may match the same condition as the default case; in this situation,
    a default case, even if present, would never execute.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊的类型模式匹配形式是使用`var`。规则与`is`表达式相似——类型是从switch表达式的静态类型中推断出来的，而`null`值总是匹配的。因此，在使用`var`模式时，您必须添加显式的`null`检查，因为值实际上可能是`null`。`var`声明可能与默认情况匹配相同的条件；在这种情况下，即使存在默认情况，它也永远不会执行。
- en: 'Let''s look at the following function that executes a command received as a
    string argument:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下函数，它执行作为字符串参数接收的命令：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This function tries to match the `add`, `del`, and `exit` commands and execute
    them appropriately. However, if the argument is `null` or empty or has only white
    spaces, it will do nothing. But this is a different case than an actual command
    that is either not supported or not recognized. The `var` pattern match helps
    to differentiate between the two in a simple and elegant manner.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数尝试匹配`add`、`del`和`exit`命令，并适当地执行它们。但是，如果参数是`null`、空或只包含空格，它将不执行任何操作。但这与不支持或无法识别的实际命令是不同的情况。`var`模式匹配有助于以简单而优雅的方式区分这两种情况。
- en: 'The following are the key takeaways for you for this topic:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本主题的关键要点：
- en: Pattern matching functionalities added in C# 7.0 are an incremental update of
    already existing simple pattern matching capabilities.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 7.0中添加的模式匹配功能是对已有简单模式匹配能力的增量更新。
- en: The new supported patterns are the constant pattern, the type pattern, and the
    `var` pattern.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新支持的模式包括常量模式、类型模式和`var`模式。
- en: Pattern matching works with `is` expressions and case blocks in `switch` statements.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配与`is`表达式和`switch`语句中的case块一起工作。
- en: The `switch` expression pattern matching supports `where` clauses.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`表达式模式匹配支持`where`子句。'
- en: The `var` pattern always matches any value including `null` and, therefore,
    a test for `null` is necessary.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`模式始终匹配任何值，包括`null`，因此需要进行`null`测试。'
- en: 'C# 8.0 has introduced even more capabilities to the switch expression pattern
    matching: property patterns, tuple patterns, and positional patterns. You can
    learn about these in [*Chapter 15*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271),
    *New Features on C# 8*.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8.0还为switch表达式模式匹配引入了更多功能：属性模式、元组模式和位置模式。您可以在[*第15章*](B12346_15_Final_JC_ePub.xhtml#_idTextAnchor271)中了解这些内容，*C#
    8的新功能*。
- en: Regular expressions
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Another form of pattern matching is represented by regular expressions. A `System.Text.RegularExpressions`
    namespace. In the following pages, we will look at how you can use this class
    to match an input text, find parts of it, or replace portions of the text.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种模式匹配形式是正则表达式。`System.Text.RegularExpressions`命名空间。在接下来的页面中，我们将看看如何使用这个类来匹配输入文本，找到其中的部分，或替换文本的部分。
- en: Regular expressions are composed of constants (that represent sets of strings)
    and operator symbols (that represent operations on these sets). The actual language
    for building regular expressions is more complex than what can be described in
    the scope of this chapter. If you are not familiar with regular expressions, we
    recommend using additional resources for learning them. You can also build and
    test your regul[ar expressions using](https://regex101.com/) onli[ne tools such
    as ht](https://regexr.com/)tps://regex101.com/ or https://regexr.com/.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式由常量（代表字符串集合）和操作符号（代表对这些集合进行操作的操作符）组成。构建正则表达式的实际语言比本章节的范围所能描述的更加复杂。如果您对正则表达式不熟悉，我们建议您使用其他资源来学习。您也可以使用在线工具（例如https://regex101.com/或https://regexr.com/）构建和测试您的正则表达式。
- en: Overview
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Regular expressions in .NET are built based on the Perl 5 regular expressions.
    As such, most of Perl 5 regular expressions are compatible with .NET regular expressions.
    On the other hand, the framework supports another flavor of expressions, called
    **ECMAScript**, which is basically another name for JavaScript (**ECMAScript**
    is actually an ECMA standard for scripting-languages, and JavaScript is its best-known
    implementation). However, when using regular expressions, you must explicitly
    specify this flavor instead. The implementation of the .NET regular expressions
    has remained the same since .NET 2.0 and is the same in .NET Core.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的正则表达式是基于Perl 5正则表达式构建的。因此，大多数Perl 5正则表达式与.NET正则表达式兼容。另一方面，该框架支持另一种表达式风格，称为**ECMAScript**，这基本上是JavaScript的另一个名称（**ECMAScript**实际上是脚本语言的ECMA标准，JavaScript是其最著名的实现）。但是，在使用正则表达式时，您必须明确指定此风格。自.NET
    2.0以来，.NET正则表达式的实现保持不变，在.NET Core中也是如此。
- en: 'The following are some of the features supported by this implementation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此实现支持的一些功能：
- en: Case-insensitive matching
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不区分大小写匹配
- en: Right-to-left searching (for languages such as Arabic, Hebrew, or Persian that
    have a right-to-left writing system)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从右到左搜索（用于具有从右到左书写系统的语言，如阿拉伯语、希伯来语或波斯语）
- en: Multi-line or single-line searching modes that change the meaning of some symbols,
    such as `ˆ`, `$` or `.` (dot)
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行或单行搜索模式，改变一些符号的含义，如`ˆ`、`$`或`.`（点）
- en: The possibility to compile a regular expression to an assembly and to increase
    performance when a pattern is used to search a large number of strings
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将正则表达式编译为程序集，并在使用模式搜索大量字符串时提高性能的可能性
- en: Infinite-width look-behind that enables us to step back to any length and check
    in the string whether the text inside the look-behind can be matched there
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限宽度的后行断言使我们能够向后移动到任意长度，并在字符串中检查后行断言内的文本是否可以在那里匹配
- en: Character class subtraction that allows you to specify one character class to
    subtract from another character class
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符类减法允许您从另一个字符类中指定一个字符类来减去
- en: Balancing groups that allow you to ensure that a subexpression is matched to
    an equal number of types as another one
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡组允许您确保子表达式与另一个子表达式匹配的类型数量相等
- en: 'Some of these functionalities are enabled with a flag provided as an argument
    to the constructor of the `Regex` class. The `RegexOptions` enumeration provides
    the following flags, which can be combined:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些功能是通过作为`Regex`类构造函数参数提供的标志来启用的。`RegexOptions`枚举提供以下标志，可以组合使用：
- en: '![](img/Chapter_8_Table_1_01.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_8_Table_1_01.jpg)'
- en: 'Before we move to the next section to look at how to actually use regular expressions
    in C#, there are two more important things to mention:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转到下一节来看如何在C#中实际使用正则表达式之前，还有两件重要的事情要提到：
- en: First, regular expressions have a set of special characters. One of them is
    `\` (backslash). In combination with another literal character, this creates a
    new token with a special meaning. For instance, `\d` matches any single digit
    from 0 to 9\. Since the backslash is also a special character in C# used for introducing
    character escape sequences, when you write a regular expression in a string, you
    need to use double backslashes, such as `"(\\d+)"`. However, you can use verbatim
    strings to avoid this and keep the regular expression in its natural form. The
    previous example can be written as `@"(\d+)"`.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，正则表达式具有一组特殊字符。其中之一是`\`（反斜杠）。与另一个文字字符结合使用时，这将创建一个具有特殊含义的新标记。例如，`\d`匹配0到9之间的任何单个数字。由于反斜杠在C#中也是一个特殊字符，用于引入字符转义序列，因此在字符串中编写正则表达式时，您需要使用双反斜杠，例如`"(\\d+)"`。但是，您可以使用逐字字符串来避免这种情况，并保持正则表达式的自然形式。前面的示例可以写成`@"(\d+)"`。
- en: The other important thing to notice is that the `Regex` class implicitly assumes
    UTF-8 encoding of the string to match. That means the `\w`, `\d`, and `\s` tokens
    match any UTF-8 codepoint that is a valid character, digit, or whitespace character
    in any language. As an example, if you use `\d+` to match any positive number
    of digits, you might be surprised to discover that it will match not just 0-9
    but also the following characters:![](img/Figure_8.1_B12346.jpg)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个重要的事情是`Regex`类隐式假定要匹配的字符串采用UTF-8编码。这意味着`\w`、`\d`和`\s`标记匹配任何UTF-8代码点，该代码点是任何语言中的有效字符、数字或空白字符。例如，如果您使用`\d+`来匹配任意数量的数字，您可能会惊讶地发现它不仅匹配0-9，还匹配以下字符：![](img/Figure_8.1_B12346.jpg)
- en: If you want to restrict matching to English digits for `\d`, English digits
    and letters and underscore for `\w`, and standard whitespace characters for `\s`,
    then you need to use the `RegexOptions.ECMAScript` option.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将匹配限制为`\d`的英文数字，`\w`的英文数字和字母以及下划线，以及`\s`的标准空白字符，则需要使用`RegexOptions.ECMAScript`选项。
- en: Let's now see how to define regular expressions and use them to figure out whether
    some text matches an expression.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何定义正则表达式并使用它们来确定某些文本是否与表达式匹配。
- en: Matching input text
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配输入文本
- en: The simplest functionality that regular expressions provide is checking whether
    an input string has a required format. This is useful for performing validation
    such as checking whether a string is a valid email address, IP address, date,
    and so on.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式提供的最简单功能是检查输入字符串是否具有所需的格式。这对于执行验证非常有用，例如检查字符串是否是有效的电子邮件地址、IP地址、日期等。
- en: To understand how this works, we will validate whether an input text is a valid
    ISO 8061 date. For simplicity, we will only consider the form *YYYY-MM-DD*, but
    as an exercise, you can extend this to support other formats. The regular expression
    we will use for this is `(\d{4})-(1[0-2]|0[1-9]|[0-9]{1})-(3[01]|[12][0-9]|0[1-9]|[1-9]{1})`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这是如何工作的，我们将验证输入文本是否是有效的ISO 8061日期。为简单起见，我们只考虑*YYYY-MM-DD*的形式，但是作为练习，您可以扩展此以支持其他格式。我们将用于此的正则表达式是`(\d{4})-(1[0-2]|0[1-9]|[0-9]{1})-(3[01]|[12][0-9]|0[1-9]|[1-9]{1})`。
- en: 'Broken down into parts, the sub-expressions are as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 分解成部分，子表达式如下：
- en: '![](img/Chapter_8_Table_2_01.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Chapter_8_Table_2_01.jpg)'
- en: 'The following two examples are equivalent. The `Regex` class has both static
    and non-static overloads for `IsMatch()`, and you can use any of the two with
    the same results. This is also the case for other methods, which we will see in
    the following sections, such as `Match()`, `Matches()`, `Replace()`, and `Split()`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个例子是等价的。`Regex`类对于`IsMatch()`有静态和非静态的重载，你可以使用任何一个得到相同的结果。其他方法也是如此，我们将在接下来的章节中看到，比如`Match()`、`Matches()`、`Replace()`和`Split()`：
- en: '[PRE38]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you need to match a pattern only once or a few times, then you could use
    the static methods as they are simpler. However, if you match the same pattern
    tens of thousands of times or more, using an instance of the class and calling
    the non-static members is potentially faster. For most common usage, this is not
    the case. In the following examples, we will only use the static methods.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要匹配一个模式一次或几次，那么你可以使用静态方法，因为它们更简单。然而，如果你需要匹配数万次或更多次相同的模式，使用类的实例并调用非静态成员可能更快。对于大多数常见的用法，情况并非如此。在下面的例子中，我们将只使用静态方法。
- en: 'The `IsMatch()` method has overloads that enable us to specify options for
    the regular expression and a timeout interval. This is useful when the regular
    expression is too complicated, or the input text is too long, and the parsing
    takes more than the desired amount of time. Take a look at the following example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsMatch()`方法有一些重载，使我们能够为正则表达式指定选项和超时时间间隔。当正则表达式过于复杂，或者输入文本过长，解析所需的时间超过了期望的时间时，这是很有用的。看下面的例子：'
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we enable ECMAScript-compliant behavior of the regular expression and
    set a timeout value of one millisecond.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们启用了正则表达式的ECMAScript兼容行为，并设置了一毫秒的超时值。
- en: Now that we've seen how to match text, let's learn how you can search for substrings
    and multiple occurrences of a pattern.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何匹配文本，让我们学习如何搜索子字符串和模式的多次出现。
- en: Finding substrings
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查找子字符串
- en: In the examples so far, we only checked whether the input text was of a specific
    pattern. But it is also possible to get information about the result. This includes,
    for instance, the text matched in each caption group, the entire matched value,
    the position in the input text, and so on. To do this, another set of overloads
    must be used.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的例子中，我们只检查了输入文本是否符合特定的模式。但也可以获取有关结果的信息。例如，每个标题组中匹配的文本、整个匹配值、输入文本中的位置等。为了做到这一点，必须使用另一组重载。
- en: 'The `Match()` methods check an input string for substrings that match a regular
    expression and return the first match. The `Matches()` methods do the same search
    but return all of the matches. The return type is `System.Text.RegularExpressions.Match`
    (that represents a single match) for the former and `System.Text.RegularExpressions.MatchCollection`
    (that represents a collection of matches) for the latter. Let''s consider the
    following example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Match()`方法检查输入字符串中与正则表达式匹配的子字符串，并返回第一个匹配项。`Matches()`方法也进行相同的搜索，但返回所有匹配项。前者的返回类型是`System.Text.RegularExpressions.Match`（表示单个匹配项），后者的返回类型是`System.Text.RegularExpressions.MatchCollection`（表示匹配项的集合）。考虑下面的例子：'
- en: '[PRE40]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The first value printed to the console is `2019-12-25` because that is the value
    of the entire match. The second is a value composed of the individual values of
    each capture group, but with a dot (`.`) as the separator. Consequently, the output
    text is `2019.12.25`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台打印的第一个值是`2019-12-25`，因为这是整个匹配的值。第二个值是由每个捕获组的单独值组成的，但是用点(`.`)作为分隔符。因此，输出文本是`2019.12.25`。
- en: 'Capture groups may have names; the form is `(?<name>...)`. In the following
    example, we call the three capture groups of the regular expression, `year`, `month`,
    and `day`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组可能有名称；形式为`(?<name>...)`。在下面的例子中，我们称正则表达式的三个捕获组为`year`、`month`和`day`：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Should the input text have multiple substrings that match the pattern, we can
    get all of them using the `Matches()` function. In the following example, dates
    are provided one per line, but the last two are not valid (`2019-13-21` and `2019-1-32`);
    therefore, these are not found in the results. To parse the string, we use the
    multiline option, so that `^` and `$` refer to the beginning and the end of each
    line and not to the entire string, as shown in the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入文本有多个与模式匹配的子字符串，我们可以使用`Matches()`函数获取所有这些子字符串。在下面的例子中，日期每行提供一个，但最后两个日期不合法（`2019-13-21`和`2019-1-32`）；因此，这些在结果中找不到。为了解析字符串，我们使用了多行选项，这样`^`和`$`就分别指向每行的开头和结尾，而不是整个字符串，如下面的例子所示：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the program is as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Sometimes, we don't just want to find substrings of an input text; we also want
    to replace them with something else. This topic is discussed in the following
    section.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们不仅想要找到输入文本的子字符串；我们还想用其他东西替换它们。这个主题在下一节中讨论。
- en: Replacing parts of a text
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换文本的部分
- en: 'Regular expressions can also be used to replace parts of a string that match
    the regular expression with another string. The `Replace()` method has a set of
    overloads, and you can specify either a string or a so-called `Match` argument
    and returns a string. In the following example, we will use this to change the
    format of date from *YYYY-MM-DD* to *MM/DD/YYYY*:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式也可以用来用另一个字符串替换匹配正则表达式的字符串的部分。`Replace()`方法有一组重载，你可以指定一个字符串或一个所谓的`Match`参数，并返回一个字符串。在下面的例子中，我们将使用这个方法将日期的格式从*YYYY-MM-DD*改为*MM/DD/YYYY*：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As a further exercise, you can write a program that converts an input date of
    the form 2019-12-25 to the form Dec 25, 2019.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的练习，你可以编写一个程序，将形式为2019-12-25的输入日期转换为Dec 25, 2019的形式。
- en: As a conclusion to this section, regular expressions offer rich pattern matching
    capabilities. .NET provides the `Regex` class that represents a regular expression
    engine with plenty of functionalities. In this section, we have seen how to match,
    search, and replace texts based on a pattern. These are common operations that
    you will encounter in a large variety of applications. You can choose between
    static and instance overloads of these methods and customize the way they work
    with various options.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本节的总结，正则表达式提供了丰富的模式匹配功能。.NET 提供了代表具有丰富功能的正则表达式引擎的 `Regex` 类。在本节中，我们已经看到了如何基于模式匹配、搜索和替换文本。这些是您将在各种应用程序中遇到的常见操作。您可以选择这些方法的静态和实例重载，并使用各种选项自定义它们的工作方式。
- en: Extension methods
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展方法
- en: 'It is sometimes useful to add functionality to a type without changing the
    implementation, creating a derived type, or recompiling code in general. We can
    do that by creating methods in helper classes. Let''s say we want to have a function
    that reverses the content of a string because `System.String` does not have one.
    Such a function can be implemented as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，向类型添加功能而不改变实现、创建派生类型或重新编译代码是很有用的。我们可以通过在辅助类中创建方法来实现这一点。假设我们想要一个函数来颠倒字符串的内容，因为
    `System.String` 没有这样的函数。这样的函数可以实现如下：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This can be invoked as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按以下方式调用：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The C# language allows us to define this function in a way that enables us
    to call it as if it was an actual member of `System.String`. Such functions are
    called `Reverse()` method to make it an extension method. The new implementation
    is shown in the following code:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言允许我们以一种使我们能够调用它就像它是 `System.String` 的实际成员的方式来定义这个函数。这样的函数被称为 `Reverse()`
    方法，使其成为扩展方法。新的实现如下所示：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that the only change to the implementation is the `this` keyword in
    front of the function parameter. With these changes, the function can be invoked
    as if it was part of the string class:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，实现的唯一变化是在函数参数前面加上了 `this` 关键字。通过这些变化，函数可以被调用，就好像它是字符串类的一部分：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following rules apply to the definition and the behavior of extension methods:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法的定义和行为适用以下规则：
- en: They can extend classes, structures, and enumerations.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以扩展类、结构和枚举。
- en: They must be declared as a static method of a static, non-nested, non-generic
    class.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们必须声明为静态、非嵌套、非泛型类的静态方法。
- en: Their first parameter is the type they add functionality to. This parameter
    is preceded by the `this` keyword.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的第一个参数是它们要添加功能的类型。该参数前面带有 `this` 关键字。
- en: They can only invoke public members of the type they extend.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能调用它们扩展的类型的公共成员。
- en: They are only available when the namespace in which they are declared is brought
    into the current scope with a `using` directive.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当它们声明的命名空间通过 `using` 指令引入到当前范围时，扩展方法才可用。
- en: If an extension method (that is available in the current scope) has the same
    signature as an instance method of the class, the compiler will always prefer
    the instance member and the extension method will never be called.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个扩展方法（在当前范围内可用）与类的实例方法具有相同的签名，编译器将始终优先选择实例成员，扩展方法将永远不会被调用。
- en: 'The following example shows an extension method called `AllMessages()` that
    extends the functionality of the `System.Exception` type. This represents an exception
    and has a message but can also contain an inner exception. This extension method
    returns a string composed by concatenating all of the messages of all of the nested
    exceptions. The Boolean argument indicates whether the messages should be concatenated
    from the main exception to the most inner one or in reverse order:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了一个名为 `AllMessages()` 的扩展方法，它扩展了 `System.Exception` 类型的功能。这代表了一个异常，有一个消息，但也可能包含内部异常。这个扩展方法返回一个由所有嵌套异常的所有消息连接而成的字符串。布尔参数指示是否应该从主异常到最内部异常连接消息，还是以相反的顺序：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The extension method can be then invoked as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以按以下方式调用扩展方法：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The most common extension methods from .NET are the LINQ standard operators
    that extend the `IEnumerable` and `IEnumerable<T>` types. We will explore LINQ
    in [*Chapter 10*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184), *Lambdas, LINQ,
    and Functional Programming*. If you implement extension methods to extend a type
    you cannot change, you must keep in mind that future changes to the type may break
    the extension method.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 来自.NET的最常见的扩展方法是扩展 `IEnumerable` 和 `IEnumerable<T>` 类型的LINQ标准运算符。我们将在[*第10章*](B12346_10_Final_JC_ePub.xhtml#_idTextAnchor184)
    *Lambdas, LINQ, and Functional Programming*中探讨LINQ。如果您实现扩展方法来扩展无法更改的类型，您必须牢记将来对类型的更改可能会破坏扩展方法。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we addressed a series of advanced language features. We started
    with delegates and events that implement callbacks in a strongly-typed manner.
    We continued anonymous types and with tuples, which are lightweight types that
    can hold any value and help us to avoid defining new explicit types. We then looked
    at pattern matching, which is the process of checking whether a value has a particular
    shape as well as extracting information about it. We continued with regular expressions,
    which are patterns with a well-defined grammar that can be matched against a text.
    Lastly, we learned about extension methods that make it possible to add functionality
    to types without changing their implementation, such as when we don't own the
    source code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一系列高级语言特性。我们从实现强类型回调的委托和事件开始。我们继续讨论了匿名类型和元组，这些是轻量级类型，可以保存任何值，并帮助我们避免定义新的显式类型。然后我们看了模式匹配，这是检查值是否具有特定形状以及提取有关它的信息的过程。我们继续讨论了正则表达式，这是具有明确定义的语法的模式，可以与文本匹配。最后，我们学习了扩展方法，它使我们能够向类型添加功能，而不改变它们的实现，比如当我们不拥有源代码时。
- en: In the next chapter, we will discuss garbage collection and resource management.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论垃圾回收和资源管理。
- en: Test what you learned
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你学到的知识
- en: What are callbacks and how are these related to delegates?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是回调函数，它们与委托有什么关系？
- en: How do you define delegates? What about events?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何定义委托？事件又是什么？
- en: How many types of tuples exist? What are the key differences between them?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少种类型的元组？它们之间的主要区别是什么？
- en: What are named tuples and how do you create them?
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是命名元组，如何创建它们？
- en: What is pattern matching and what statements can it be used with?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是模式匹配，它可以与哪些语句一起使用？
- en: What are the rules for pattern matching null?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式匹配空值的规则是什么？
- en: What class implements regular expressions and what encoding does it use by default?
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个类实现了正则表达式，它默认使用什么编码？
- en: What is the difference between the `Match()` and `Matches()` methods of this
    class?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的`Match()`和`Matches()`方法有什么区别？
- en: What are extension methods and why are they helpful?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是扩展方法，它们为什么有用？
- en: How do you define an extension method?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何定义一个扩展方法？
