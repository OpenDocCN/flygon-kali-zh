["```js\n mkdir <project-name>\n```", "```js\n cd <project-name>\n npm init\n```", "```js\n npm install express body-parser lodash --save\n```", "```js\n var express = require('express');\n var app = express();\n var bodyParser = require('body-parser');\n\n // middleware to parse the body of input requests app.use(bodyParser.json());\n\n // test url app.get('/', function (req, res) {\n           res.status(200).send('OK!')\n        });\n\n // start server app.listen(3000, function () {\n           console.log('Application listening on port 3000!')\n        });\n```", "```js\n {\n\n        ...\n\n        \"scripts\": {\n          \"start\": \"node server.js\",\n          \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"        },\n\n        ...\n\n        }\n```", "```js\nvar _ = require('lodash');\n\nclass Graph {\n\n   constructor(users) {\n      // initialize edges\n  this.edges = {};\n\n      // save users for later access\n  this.users = users;\n\n      // add users and edges of each\n  _.forEach(users, (user) => {\n         this.edges[user.id] = user.friends;\n      });\n   }\n}\n\nmodule.exports = Graph;\n```", "```js\n[\n   {\n      id: 1,\n      name: 'Adam',\n      company: 'Facebook',\n      friends: [2, 3, 4, 5, 7]\n   },\n   {\n      id: 2,\n      name: 'John',\n      company: 'Google',\n      friends: [1, 6, 8]\n   },\n   {\n      id: 3,\n      name: 'Bill',\n      company: 'Twitter',\n      friends: [1, 4, 5, 8]\n   },\n   {\n      id: 4,\n      name: 'Jose',\n      company: 'Apple',\n      friends: [1, 3, 6, 8]\n   },\n   {\n      id: 5,\n      name: 'Jack',\n      company: 'Samsung',\n      friends: [1, 3, 7]\n   },\n   {\n      id: 6,\n      name: 'Rita',\n      company: 'Toyota',\n      friends: [2, 4, 7, 8]\n   },\n   {\n      id: 7,\n      name: 'Smith',\n      company: 'Matlab',\n      friends: [1, 5, 6, 8]\n   },\n   {\n      id: 8,\n      name: 'Jane',\n      company: 'Ford',\n      friends: [2, 3, 4, 6, 7]\n   }\n]\n```", "```js\nINITIALIZE tail to 0 for subsequent iterations\n\nMARK source node as visited\n\nWHILE result not found\n\n    GET neighbors of latest visited node (extracted using tail)\n\n    FOR each of the node\n\n        IF node already visited\n\n            RETURN\n\n        Mark node as visited\n\n        IF node is our expected result\n\n            INITIALIZE result with current neighbor node\n\n            WHILE not source node\n\n               BACKTRACK steps by popping users \n               from previously visited path until\n               the source user\n\n            ADD source user to the result\n\n            CREATE and format result variable\n\n        IF result found return control\n\n        NO result found, add user to previously visited path\n\n        ADD friend to queue for BFS in next iteration\n\n    INCREMENT tail for next loop\n\nRETURN NO_RESULT\n```", "```js\nvar _ = require('lodash');\n\nclass Graph {\n\n   constructor(users) {\n      // initialize edges\n  this.edges = {};\n\n      // save users for later access\n  this.users = users;\n\n      // add users and edges of each\n  _.forEach(users, (user) => {\n         this.edges[user.id] = user.friends;\n      });\n   }\n\n   shortestPath(sourceUser, targetCompany) {\n      // final shortestPath\n  var shortestPath;\n\n      // for iterating along the breadth\n  var tail = 0;\n\n      // queue of users being visited\n  var queue = [ sourceUser ];\n\n      // mark visited users\n  var visitedNodes = [];\n\n      // previous path to backtrack steps when shortestPath is found\n  var prevPath = {};\n\n      // request is same as response\n  if (_.isEqual(sourceUser.company, targetCompany)) {\n         return;\n      }\n\n      // mark source user as visited so\n // next time we skip the processing  visitedNodes.push(sourceUser.id);\n\n      // loop queue until match is found\n // OR until the end of queue i.e no match  while (!shortestPath && tail < queue.length) {\n\n         // take user breadth first\n  var user = queue[tail];\n\n         // take nodes forming edges with user\n  var friendsIds = this.edges[user.id];\n\n         // loop over each node\n  _.forEach(friendsIds, (friendId) => {\n            // result found in previous iteration, so we can stop\n            if (shortestPath) return;\n\n            // get all details of node\n  var friend = _.find(this.users, ['id', friendId]);\n\n            // if visited already,\n // nothing to recheck so return  if (_.includes(visitedNodes, friendId)) {\n               return;\n            }\n\n            // mark as visited\n  visitedNodes.push(friendId);\n\n            // if company matched\n  if (_.isEqual(friend.company, targetCompany)) {\n\n               // create result path with the matched node\n  var path = [ friend ];\n\n               // keep backtracking until source user and add to path\n  while (user.id !== sourceUser.id) {\n\n                  // add user to shortest path\n  path.unshift(user);\n\n                  // prepare for next iteration\n  user = prevPath[user.id];\n               }\n\n               // add source user to the path\n  path.unshift(user);\n\n               // format and return shortestPath\n  shortestPath = _.map(path, 'name').join(' -> ');\n            }\n\n            // break loop if shortestPath found\n  if (shortestPath) return;\n\n            // no match found at current user,\n // add it to previous path to help backtracking later  prevPath[friend.id] = user;\n\n            // add to queue in the order of visit\n // i.e. breadth wise for next iteration  queue.push(friend);\n         });\n\n         // increment counter\n  tail++;\n      }\n\n      return shortestPath ||\n            `No path between ${sourceUser.name} & ${targetCompany}`;\n   }\n\n}\n\nmodule.exports = Graph;\n```", "```js\n// if company matched if (_.isEqual(friend.company, targetCompany)) {\n\n   // create result path with the matched node\n  var path = [ friend ];\n\n   // keep backtracking until source user and add to path\n  while (user.id !== sourceUser.id) {\n\n      // add user to shortest path\n  path.unshift(user);\n\n      // prepare for next iteration\n  user = prevPath[user.id];\n   }\n\n   // add source user to the path\n  path.unshift(user);\n\n   // format and return shortestPath\n  shortestPath = _.map(path, 'name').join(' -> ');\n}\n```", "```js\nstarting the shortest path determination added 3 to the queue marked 3 as visited\n shortest path not found, moving on to next node in queue: 3 extracting neighbor nodes of node 3 (1,4,5,8) accessing neighbor 1 mark 1 as visited result not found, mark our path from 3 to 1 result not found, add 1 to queue for next iteration current queue content : 3,1 accessing neighbor 4 mark 4 as visited result not found, mark our path from 3 to 4 result not found, add 4 to queue for next iteration current queue content : 3,1,4 accessing neighbor 5 mark 5 as visited result not found, mark our path from 3 to 5 result not found, add 5 to queue for next iteration current queue content : 3,1,4,5 accessing neighbor 8 mark 8 as visited result not found, mark our path from 3 to 8 result not found, add 8 to queue for next iteration current queue content : 3,1,4,5,8 increment tail to 1 shortest path not found, moving on to next node in queue: 1 extracting neighbor nodes of node 1 (2,3,4,5,7) accessing neighbor 2 mark 2 as visited result not found, mark our path from 1 to 2 result not found, add 2 to queue for next iteration current queue content : 3,1,4,5,8,2 accessing neighbor 3 neighbor 3 already visited, return control to top accessing neighbor 4 neighbor 4 already visited, return control to top accessing neighbor 5 neighbor 5 already visited, return control to top accessing neighbor 7 mark 7 as visited result not found, mark our path from 1 to 7 result not found, add 7 to queue for next iteration current queue content : 3,1,4,5,8,2,7 increment tail to 2 shortest path not found, moving on to next node in queue: 4 extracting neighbor nodes of node 4 (1,3,6,8) accessing neighbor 1 neighbor 1 already visited, return control to top accessing neighbor 3 neighbor 3 already visited, return control to top accessing neighbor 6 mark 6 as visited result found at 6, add it to result path ([6]) backtracking steps to 3 we got to 6 from 4 update path accordingly: ([4,6]) add source user 3 to result form result [3,4,6] return result increment tail to 3 return result Bill -> Jose -> Rita\n```", "```js\nvar express = require('express');\nvar app = express();\nvar bodyParser = require('body-parser');\n\n// register endpoints var references = require('./routes/references');\n\n// middleware to parse the body of input requests app.use(bodyParser.json());\n\n// route middleware app.use('/references', references);\n\n// start server app.listen(3000, function () {\n   console.log('Application listening on port 3000!');\n});\n```", "```js\nvar express = require('express');\nvar router = express.Router();\nvar Graph = require('../utils/graph');\nvar _ = require('lodash');\nvar userGraph;\n\n// sample set of users with friends \n// same as list shown earlier var users = [...];\n\n// middleware to create the users graph router.use(function(req) {\n   // form graph\n  userGraph = new Graph(users);\n\n   // continue to next step\n  req.next();\n});\n\n// create the route for generating reference path // this can also be a get request with params based // on developer preference router.route('/')\n   .post(function(req, res) {\n\n      // take user Id\n  const userId = req.body.userId;\n\n      // target company name\n  const companyName = req.body.companyName;\n\n      // extract current user info\n  const user = _.find(users, ['id', userId]);\n\n      // get shortest path\n  const path = userGraph.shortestPath(user, companyName);\n\n      // return\n  res.send(path);\n   });\n\nmodule.exports = router;\n```", "```js\nSTART at root node\n\n    assign it a probability of 1 in the probabilityMap\n\n    trigger CALC_PPR with current node, probabilityMap and iterations count\n\nFUNCTION CALC_PPR\n\n    IF number of iteration left is 0\n\n        remove target and its neighbors from probabilityMap\n\n        return rest of probabilityMap\n\n    ELSE\n\n        determine an ALPHA\n\n        extract all nodes at the current degree\n\n        FOR each nodes at current degree\n\n            extract neighbors\n\n            calculate the probability to propagate to neighbor\n\n            IF neighbor already has a probability\n\n                add to existing probability\n\n            ELSE\n\n               assign new probability\n\n        CALC_PPR with decreased iteration count                 \n```", "```js\nconst express = require('express');\nconst router = express.Router();\nconst _ = require('lodash');\n\n// sample set of users with friends extracted from some grapgh db const users = {\n   A: { neighbors: [ 'B', 'D' ] },\n   B: { neighbors: [ 'A', 'C', 'E' ] },\n   C: { neighbors: [ 'B', 'D', 'E' ] },\n   D: { neighbors: [ 'A', 'C' ] },\n   E: { neighbors: [ 'B', 'C' ] }\n};\n\n// middleware router.use(function(req) {\n   // intercept, modify and then continue to next step\n  req.next();\n});\n\n// route router.route('/:userId')\n   .get(function(req, res) {\n      var suggestions;\n\n      // take user Id\n  const userId = req.params.userId;\n\n      // generate suggestions   // return suggestions  res.send(userId);\n   });\n\nmodule.exports = router;\n```", "```js\nvar express = require('express');\nvar app = express();\nvar bodyParser = require('body-parser');\n\n// suggestion endpoints var suggestions = require('./routes/suggestions');\n\n// middleware to parse the body of input requests app.use(bodyParser.json());\n\n// route middleware app.use('/suggestions', suggestions);\n\n// start server app.listen(3000, function () {\n   console.log('Application listening on port 3000!');\n});\n```", "```js\nconst users = {\n   A: { neighbors: [ 'B', 'D' ] },\n   B: { neighbors: [ 'A', 'C', 'E' ] },\n   C: { neighbors: [ 'B', 'D', 'E' ] },\n   D: { neighbors: [ 'A', 'C' ] },\n   E: { neighbors: [ 'B', 'C' ] }\n};\n```", "```js\nconst _ = require('lodash');\n\nclass PPR {\n\n   constructor(data) {\n      this.data = data;\n   }\n\n   getSuggestions(nodeId) {\n      return this.personalizedPageRankGenerator(nodeId);\n   };\n}\n\nmodule.exports = PPR;\n```", "```js\npersonalizedPageRankGenerator(nodeId) {\n   // Set Probability of the starting node as 1\n // because we will start from that node  var initProbabilityMap = {};\n\n   initProbabilityMap[nodeId] = 1;\n\n   // call helper to iterate thrice\n  return this.pprHelper(nodeId, initProbabilityMap, 3);\n};\n```", "```js\npprHelper(nodeId, currentProbabilitiesMap, iterationCount) {\n   // iterations done\n  if (iterationCount === 0) {\n\n      // get root nodes neighbors\n  var currentNeighbors = this.getNeighbors(nodeId);\n\n      // omit neighbors and self node from calculated probabilities\n  currentProbabilitiesMap = _.omit(currentProbabilitiesMap,\n      currentNeighbors.concat(nodeId));\n\n      // format data and sort by probability of final suggestions\n  return _.chain(currentProbabilitiesMap)\n         .map((val, key) => ({ name: key, score: val }))\n         .orderBy('score', 'desc')\n         .valueOf();\n\n   } else {\n      // Holds the updated set of probabilities for the next iteration\n  var nextIterProbabilityMap = {};\n\n      // set alpha\n  var alpha = 0.5;\n\n      // With probability alpha, we teleport to the start node again\n  nextIterProbabilityMap[nodeId] = alpha;\n\n      // extract nodes within current loop\n  var parsedNodes = _.keys(currentProbabilitiesMap);\n\n      // go to next degree nodes of each of the currently parsed nodes\n  _.forEach(parsedNodes, (parsedId) => {\n\n         // get current probability of each node\n  var prob = currentProbabilitiesMap[parsedId];\n\n         // get connected nodes\n  var neighbors = this.getNeighbors(parsedId);\n\n         // With probability 1 - alpha, we move to a connected node...\n // And at each node we distribute its current probability\n         equally to // its neighbors    var probToPropagate = (1 - alpha) * prob / neighbors.length;\n\n         // spreading the probability equally to neighbors   _.forEach(neighbors, (neighborId) => {\n            nextIterProbabilityMap[neighborId] =\n         (nextIterProbabilityMap[neighborId] || 0) + probToPropagate;\n         });\n      });\n\n      // next iteration\n  return this.pprHelper(nodeId, nextIterProbabilityMap, iterationCount - 1);\n   }\n}\n\ngetNeighbors(nodeId) {\n   return _.get(this.data, [nodeId, 'neighbors'], []);\n}\n```", "```js\nconst express = require('express');\nconst router = express.Router();\nconst _ = require('lodash');\nconst PPR = require('../utils/ppr');\n\n// sample set of users with friends extracted from some grapgh db const users = .... // from previous example\n\n....\n\n// route router.route('/:userId')\n   .get(function(req, res) {\n      var suggestions;\n\n      // take user Id\n  const userId = req.params.userId;\n\n----> // generate suggestions ----> suggestions = new PPR(users).getSuggestions(userId);\n\n      // return suggestions\n  res.send(suggestions);\n   });\n\nmodule.exports = router;\n```", "```js\nApplication listening on port 3000!\n```", "```js\n.....\n\nconsole.log(`End of Iteration ${ 4 - iterationCount} : ${JSON.stringify(nextIterProbabilityMap)}`);\n // next iteration return this.pprHelper(nodeId, nextIterProbabilityMap, iterationCount - 1);\n```"]