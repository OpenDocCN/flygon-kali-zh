["```js\n    var a; \n    var thisIsAVariable;  \n    var _and_this_too;  \n    var mix12three; \n\n```", "```js\n    var 2three4five; \n\n```", "```js\n    var a = 1; \n\n```", "```js\n    var v1, v2, v3 = 'hello', v4 = 4, v5; \n\n```", "```js\n    var v1,  \n        v2,  \n        v3 = 'hello',  \n        v4 = 4,  \n        v5; \n\n```", "```js\n    var case_matters = 'lower'; \n    var CASE_MATTERS = 'upper';  \n    case_matters; \n    CASE_MATTER; \n\n```", "```js\n    > var case_matters = 'lower'; \n    > var CASE_MATTERS = 'upper'; \n    > case_matters; \n    \"lower\" \n    > CASE_MATTERS; \n    \"upper\" \n\n```", "```js\n    > 1 + 2; \n    3 \n\n```", "```js\n    > var a = 1; \n    > var b = 2; \n    > a + 1; \n    2 \n    > b + 2; \n    4 \n    > a + b; \n    3 \n    > var c = a + b; \n    > c; \n    3 \n\n```", "```js\n> 1 + 2;   \n3   \n\n```", "```js\n> 99.99 - 11;   \n88.99   \n\n```", "```js\n> 2 * 3;   \n6   \n\n```", "```js\n> 6 / 4;   \n1.5   \n\n```", "```js\n> 6 % 3;   \n0   \n> 5 % 3;   \n2   \n\n```", "```js\n> 4 % 2;   \n0   \n> 5 % 2;   \n1   \n\n```", "```js\n> var a = 123;    \n> var b = a++;   \n> b;   \n123   \n> a;   \n124   \n\n```", "```js\n> var a = 123;    \n> var b = ++a;   \n> b;   \n124   \n> a;   \n124   \n\n```", "```js\n> var a = 123;    \n> var b = a--;   \n> b;   \n123   \n> a;   \n122   \n\n```", "```js\n> var a = 123;    \n> var b = --a;   \n> b;   \n122   \n> a;   \n122   \n\n```", "```js\n    > var a = 5; \n    > a += 3; \n    8 \n\n```", "```js\n    > a -= 3; \n    5 \n\n```", "```js\n    > a *= 2; \n    10 \n    > a /= 5; \n    2 \n    > a %= 2; \n    0 \n\n```", "```js\n    > var n = 1; \n    > typeof n; \n    \"number\" \n    > n = 1234; \n    > typeof n; \n    \"number\" \n\n```", "```js\n    > var n2 = 1.23; \n    > typeof n; \n    \"number\" \n\n```", "```js\n    > typeof 123; \n    \"number\" \n\n```", "```js\n    > var n3 = 0377; \n    > typeof n3; \n    \"number\" \n    > n3; \n    255 \n\n```", "```js\n    console.log(0o776); //510 \n\n```", "```js\n    > var n4 = 0x00; \n    > typeof n4; \n    \"number\" \n    > n4; \n    0 \n    > var n5 = 0xff; \n    > typeof n5; \n    \"number\" \n    > n5; \n    255 \n\n```", "```js\n    console.log(parseInt('111',2)); //7 \n\n```", "```js\n    console.log(0b111); //7 \n\n```", "```js\n    > 1e1; \n    10 \n    > 1e+1; \n    10 \n    > 2e+3; \n    2000 \n    > typeof 2e+3; \n    \"number\" \n\n```", "```js\n    > 2e-3; \n    0.002 \n    > 123.456E-3; \n    0.123456 \n    > typeof 2e-3; \n    \"number\" \n\n```", "```js\n    > Infinity; \n    Infinity \n    > typeof Infinity; \n    \"number\" \n    > 1e309; \n    Infinity \n    > 1e308; \n    1e+308 \n\n```", "```js\n    > var a = 6 / 0; \n    > a; \n    Infinity \n\n```", "```js\n    > var i = -Infinity; \n    > i; \n    -Infinity \n    > typeof i; \n    \"number\" \n\n```", "```js\n    > Infinity - Infinity; \n    NaN \n    > -Infinity + Infinity; \n    NaN \n\n```", "```js\n    > Infinity - 20; \n    Infinity \n    > -Infinity * 3; \n    -Infinity \n    > Infinity / 2; \n    Infinity \n    > Infinity - 99999999999999999; \n    Infinity \n\n```", "```js\n    > typeof NaN; \n    \"number\" \n    > var a = NaN; \n    > a; \n    NaN \n\n```", "```js\n    > var a = 10 * \"f\"; \n    > a;   \n    NaN \n\n```", "```js\n    > 1 + 2 + NaN; \n    NaN \n\n```", "```js\n    console.log(Number.isNaN('test')); //false : Strings are not NaN \n    console.log(Number.isNaN(123)); //false : integers are not NaN \n    console.log(Number.isNaN(NaN)); //true : NaNs are NaNs \n    console.log(Number.isNaN(123/'abc')); //true : 123/'abc' results in an NaN \n\n```", "```js\n    console.log(isNaN('test')); //true \n\n```", "```js\n    function isNumber(value) { \n      return typeof value==='number' && !Number.isNaN(value); \n    } \n\n```", "```js\n    console.log(Number.isInteger('test')); //false \n    console.log(Number.isInteger(Infinity)); //false \n    console.log(Number.isInteger(NaN)); //false \n    console.log(Number.isInteger(123)); //true \n    console.log(Number.isInteger(1.23)); //false \n\n```", "```js\n    > var s = \"some characters\"; \n    > typeof s; \n    \"string\" \n    > var s = 'some characters and numbers 123 5.87'; \n    > typeof s; \n    \"string\" \n\n```", "```js\n    > var s = '1'; \n    > typeof s; \n    \"string\" \n\n```", "```js\n    > var s = \"\"; typeof s; \n    \"string\" \n\n```", "```js\n    > var s1 = \"web\";  \n    > var s2 = \"site\";  \n    > var s = s1 + s2;  \n    > s; \n    \"website\" \n    > typeof s; \n    \"string\" \n\n```", "```js\n    > var s = '1';  \n    > s = 3 * s;  \n    > typeof s; \n    \"number\" \n    > s; \n    3 \n    > var s = '1'; \n    > s++; \n    > typeof s; \n    \"number\" \n    > s; \n    2 \n\n```", "```js\n    > var s = \"100\"; typeof s; \n    \"string\" \n    > s = s * 1; \n    100 \n    > typeof s; \n    \"number\" \n\n```", "```js\n    > var movie = '101 dalmatians'; \n    > movie * 1; \n    NaN \n\n```", "```js\n    > var n = 1; \n    > typeof n; \n    \"number\" \n    > n = \"\" + n; \n    \"1\" \n    > typeof n; \n    \"string\" \n\n```", "```js\n> var s = 'I don't know';   \n> var s = \"I don't know\";   \n> var s = \"I don't know\";   \n> var s = '\"Hello\",   he said.';   \n> var s = \"\"Hello\",   he said.\";   \nEscaping the escape:   \n> var s = \"1\\\\2\"; s;   \n\"1\\2\"   \n\n```", "```js\n> var s = '\\n1\\n2\\n3\\n';   \n> s;   \n\"   \n1   \n2   \n3   \n\"   \n\n```", "```js\n> var s = '1\\r2';   \n> var s = '1\\n\\r2';   \n> var s = '1\\r\\n2';   \n\n```", "```js\n> s;   \n\"1   \n2\"   \n\n```", "```js\n> var s = \"1\\t2\";   \n> s;   \n\"1 2\"   \n\n```", "```js\n> \"\\u0421\\u0442\\u043E\\u044F\\u043D\";   \n\"\u0421\u0442o\u044f\u043d\"   \n\n```", "```js\n    var log_level=\"debug\"; \n    var log_message=\"meltdown\"; \n    console.log(\"Log level: \"+ log_level + \n      \" - message : \" + log_message); \n    //Log level: debug - message : meltdown \n\n```", "```js\n    console.log(`Log level: ${log_level} - message: ${log_message}`) \n\n```", "```js`) (grave accent) character instead of the usual double or single quotes. Template literal place holders are indicated by the dollar sign and curly braces (`${expression}`). By default, they are concatenated to form a single string. The following example shows a template literal with a slightly complex expression:\n\n```", "```js\n\nHow about embedding a function call?\n\n```", "```js\n\nTemplate literals also simplify multiline string syntax. Instead of writing the following line of code:\n\n```", "```js\n\nYou can have a much cleaner syntax using template literals, which is as follows:\n\n```", "```js\n\nES6 has another interesting literal type called **Tagged Template Literals**. Tagged templates allow you to modify the output of template literals using a function. If you prefix an expression to a template literal, that prefix is considered to be a function to be invoked. The function needs to be defined before we can use the tagged template literal. For example, the following expression:\n\n```", "```js\n\nThe preceding expression is converted into a function call:\n\n```", "```js\n\nThe tag function, 'transform', gets two parameters-template strings like `Name is` and substitutions defined by `${}`. The substitutions are only known at runtime. Let's expand the `transform` function:\n\n```", "```js\n\nWhen template strings (`Name is`) are passed to the tag function, there are two forms of each template string, as follows:\n\n*   The raw form where the backslashes are not interpreted\n*   The cooked form where the backslashes has special meaning\n\nYou can access the raw string form using raw property, as the following example shows:\n\n```", "```js\n\n## Booleans\n\nThere are only two values that belong to the Boolean data type-the `true` and `false` values used without quotes:\n\n```", "```js\n\nIf you quote `true` or `false`, they become strings, as shown in the following example:\n\n```", "```js\n\n### Logical operators\n\nThere are three operators, called logical operators, that work with Boolean values. These are as follows:\n\n```", "```js\n\nYou know that when something is not true, it must be false. Here's how this is expressed using JavaScript and the logical `!` operator:\n\n```", "```js\n\nIf you use the logical `NOT` twice, you will get the original value, which is as follows:\n\n```", "```js\n\nIf you use a logical operator on a non-Boolean value, the value is converted to Boolean behind the scenes, as follows:\n\n```", "```js\n\nIn the preceding case, the string value `\"one\"` is converted to a Boolean, `true`, and then negated. The result of negating `true` is `false`. In the following example, there's a double negation, so the result is `true`:\n\n```", "```js\n\nYou can convert any value to its Boolean equivalent using a double negation. Understanding how any value converts to a Boolean is important. Most values convert to `true` with the exception of the following, which convert to `false`:\n\n*   The empty string `\"\"`\n*   null\n*   undefined\n*   The number `0`\n*   The number `NaN`\n*   The Boolean `false`\n\nThese six values are referred to as falsy, while all others are truthy, (including, for example, the strings `\"0\"`, `\" \"`, and `\"false\"`).\n\nLet's see some examples of the other two operators-the logical `AND` (`&&`) and the logical `OR` (`||`). When you use `&&`, the result is `true` only if all of the operands are `true`. When you use `||`, the result is `true` if at least one of the operands is `true`:\n\n```", "```js\n\nHere's a list of the possible operations and their results:\n\n| **Operation** | **Result** |\n| `true && true` | `true` |\n| `true && false` | `false` |\n| `false && true` | `false` |\n| `false && false` | `false` |\n| `true &#124;&#124; true` | `true` |\n| `true &#124;&#124; false` | `true` |\n| `false &#124;&#124; true` | `true` |\n| `false &#124;&#124; false` | `false` |\n\nYou can use several logical operations one after the other, as follows:\n\n```", "```js\n\nYou can also mix `&&` and `||` in the same expression. In such cases, you should use parentheses to clarify how you intend the operation to work. Consider the following example:\n\n```", "```js\n\n### Operator precedence\n\nYou might wonder why the previous expression (`false && false || true && true`) returned `true`. The answer lies in the operator precedence, as you know from mathematics:\n\n```", "```js\n\nThis is because multiplication has a higher precedence over addition, so `2 * 3` is evaluated first, as if you typed:\n\n```", "```js\n\nSimilarly for logical operations, `!` has the highest precedence and is executed first, assuming there are no parentheses that demand otherwise. Then, in the order of precedence, comes `&&` and finally, `||`. In other words, the following two code snippets are the same. The first one is as follows:\n\n```", "```js\n\nAnd the second one is as follows:\n\n```", "```js\n\n### Note\n\n**Best practice**\n\nUse parentheses instead of relying on operator precedence. This makes your code easier to read and understand.\n\nThe ECMAScript standard defines the precedence of operators. While it may be a good memorization exercise, this book doesn't offer it. First of all, you'll forget it, and second, even if you manage to remember it, you shouldn't rely on it. The person reading and maintaining your code will likely be confused.\n\n### Lazy evaluation\n\nIf you have several logical operations one after the other, but the result becomes clear at some point before the end, the final operations will not be performed because they don't affect the end result. Consider the following line of code as an example:\n\n```", "```js\n\nAs these are all `OR` operations and have the same precedence, the result will be `true` if at least, one of the operands is `true`. After the first operand is evaluated, it becomes clear that the result will be `true`, no matter what values follow. So, the JavaScript engine decides to be lazy (OK, efficient) and avoids unnecessary work by evaluating code that doesn't affect the end result. You can verify this short-circuiting behavior by experimenting in the console, as shown in the following code block:\n\n```", "```js\n\nThis example also shows another interesting behavior-if JavaScript encounters a non-Boolean expression as an operand in a logical operation, the non-Boolean is returned as a result:\n\n```", "```js\n\nThis behavior is not something you should rely on because it makes the code harder to understand. It's common to use this behavior to define variables when you're not sure whether they were previously defined. In the next example, if the `mynumber` variable is defined, its value is kept; otherwise, it's initialized with the value `10`:\n\n```", "```js\n\nThis is simple and looks elegant, but be aware that it's not completely foolproof. If `mynumber` is defined and initialized to `0`, or to any of the six falsy values, this code might not behave as you expect, as shown in the following piece of code:\n\n```", "```js\n\n### Comparison\n\nThere's another set of operators that all return a Boolean value as a result of the operation. These are the comparison operators. The following table lists them together with example uses:\n\n| **Operator symbol** | **Description** | **Example** |\n| `==` | **Equality comparison**: This returns `true` when both operands are equal. The operands are converted to the same type before being compared. They're also called loose comparison. |  \n```", "```js\n\n |\n| `===` | **Equality and type comparison**: This returns `true` if both operands are equal and of the same type. It's better and safer to compare this way because there's no behind-the-scenes type conversions. It is also called strict comparison. |  \n```", "```js\n\n |\n| `!=` | **Non-equality comparison**: This returns `true` if the operands are not equal to each other (after a type conversion). |  \n```", "```js\n\n |\n| `!==` | **Non-equality comparison without type conversion**: Returns `true` if the operands are not equal or if they are of different types. |  \n```", "```js\n\n |\n| `>` | This returns `true` if the left operand is greater than the right one. |  \n```", "```js\n\n |\n| `>=` | This returns `true` if the left operand is greater than or equal to the right one. |  \n```", "```js\n\n |\n| `<` | This returns `true` if the left operand is less than the right one. |  \n```", "```js\n\n |\n| `<=` | This returns `true` if the left operand is less than or equal to the right one. |  \n```", "```js\n\n |\n\nNote that `NaN` is not equal to anything, not even itself. Take a look at the following line of code:\n\n```", "```js\n\n## Undefined and null\n\nIf you try to use a non-existing variable, you'll get the following error:\n\n```", "```js\n\nUsing the `typeof` operator on a non-existing variable is not an error. You will get the `\"undefined\"` string back, as follows:\n\n```", "```js\n\nIf you declare a variable without giving it a value, this is, of course, not an error. But, the `typeof` still returns `\"undefined\"`:\n\n```", "```js\n\nThis is because, when you declare a variable without initializing it, JavaScript automatically initializes it with the `undefined` value, as shown in the following lines of code:\n\n```", "```js\n\nThe `null` value, on the other hand, is not assigned by JavaScript behind the scenes; it's assigned by your code, which is as follows:\n\n```", "```js\n\nAlthough the difference between `null` and `undefined` is small, it can be critical at times. For example, if you attempt an arithmetic operation, you will get different results:\n\n```", "```js\n\nThis is because of the different ways `null` and `undefined` are converted to the other primitive types. The following examples show the possible conversions:\n\n*   Conversion to a number:\n\n    ```", "```js\n\n*   Conversion to NaN:\n\n    ```", "```js\n\n*   Conversion to a Boolean:\n\n    ```", "```js\n\n*   Conversion to a string:\n\n    ```", "```js\n\n## Symbols\n\nES6 introduced a new primitive type-symbols. Several languages have a similar notion. Symbols look very similar to regular strings, but they are very different. Let's see how these symbols are created:\n\n```", "```js\n\nNotice that we don't use `new` operator while creating symbols. You will get an error when you do use it:\n\n```", "```js\n\nYou can describe `Symbol` as well:\n\n```", "```js\n\nDescribing symbols comes in very handy while debugging large programs where there are lots of symbols scattered across.\n\nThe most important property of `Symbol` (and hence the reason of their existence) is that they are unique and immutable:\n\n```", "```js\n\nFor now, we will have to pause this discussion on symbols. Symbols are used as property keys and places where you need unique identifiers. We will discuss symbols in a later part of this book.\n\n# Primitive data types recap\n\nLet's quickly summarize some of the main points discussed so far:\n\n*   There are five primitive data types in JavaScript:\n\n    *   Number\n    *   String\n    *   Boolean\n    *   Undefined\n    *   Null\u00a0\n\n*   Everything that is not a primitive data type is an object.\n\n    The primitive number data type can store positive and negative integers or floats, hexadecimal numbers, octal numbers, exponents, and the special numbers-`NaN`, `Infinity`, and `-Infinity`.\n\n*   The string data type contains characters in quotes. Template literals allow embedding of expressions inside a string.\n*   The only values of the Boolean data type are `true` and `false`.\n*   The only value of the null data type is the `null` value.\n*   The only value of the undefined data type is the `undefined` value.\n*   All values become `true` when converted to a Boolean, with the exception of the following six falsy values:\n\n    *   `\"\"`\n    *   `null`\n    *   `undefined`\n    *   `0`\n    *   `NaN`\n    *   `false`\n\n# Arrays\n\nNow that you know about the basic primitive data types in JavaScript, it's time to move to a more powerful data structure-the array.\n\nSo, what is an array? It's simply a list (a sequence) of values. Instead of using one variable to store one value, you can use one array variable to store any number of values as elements of the array.\n\nTo declare a variable that contains an empty array, you can use square brackets with nothing between them, as shown in the following line of code:\n\n```", "```js\n\nTo define an array that has three elements, you can write the following line of code:\n\n```", "```js\n\nWhen you simply type the name of the array in the console, you can get the contents of your array:\n\n```", "```js\n\nNow the question is how to access the values stored in these array elements. The elements contained in an array are indexed with consecutive numbers, starting from zero. The first element has index (or position) 0, the second has index 1, and so on. Here's the three-element array from the previous example:\n\n| **Index** | **Value** |\n| 0 | 1 |\n| 1 | 2 |\n| 2 | 3 |\n\nTo access an array element, you can specify the index of that element inside square brackets. So, `a[0]` gives you the first element of the array `a`, `a[1]` gives you the second, and so on, as shown in the following example:\n\n```", "```js\n\n## Adding/updating array elements\n\nUsing the index, you can also update the values of the elements of the array. The next example updates the third element (index 2) and prints the contents of the new array, as follows:\n\n```", "```js\n\nYou can add more elements by addressing an index that didn't exist before, as shown in the following lines of code:\n\n```", "```js\n\nIf you add a new element but leave a gap in the array, those elements in between don't exist and return the `undefined` value if accessed. Check out the following example:\n\n```", "```js\n\n## Deleting elements\n\nTo delete an element, you can use the `delete` operator. However, after the deletion, the length of the array does not change. In a sense, you may get a hole in the array:\n\n```", "```js\n\n## Arrays of arrays\n\nArrays can contain all types of values, including other arrays:\n\n```", "```js\n\nThe `Array[3]` in the result is clickable in the console and it expands the array values. Let's look at an example where you have an array of two elements, both of them being other arrays:\n\n```", "```js\n\nThe first element of the array is `[0]`, and it's also an array:\n\n```", "```js\n\nTo access an element in the nested array, you can refer to the element index in another set of square brackets, as follows:\n\n```", "```js\n\nNote that you can use the array notation to access individual characters inside a string, as shown in the following code block:\n\n```", "```js\n\n### Note\n\nArray access to strings was supported by many browsers for a while (not older IEs), but it was officially recognized only as late as ECMAScript 5.\n\nThere are more ways to have fun with arrays (and we get to those in [Chapter 4](ch04.html \"Chapter\u00a04.\u00a0Objects\"), *Objects*), but let's stop here for now, remembering the following points:\n\n*   An array is a data store\n*   An array contains indexed elements\n*   Indexes start from zero and increment by one for each element in the array\n*   To access an element of an array, you can use its index in square brackets\n*   An array can contain any type of data, including other arrays\n\n# Conditions and loops\n\nConditions provide a simple but powerful way to control the flow of code execution. Loops allow you to perform repetitive operations with less code. Let's take a look at:\n\n*   `if` conditions\n*   `switch` statements\n*   `while`, `do...while`, `for`, and `for...in` loops\n\n### Note\n\nThe examples in the following sections require you to switch to the multiline Firebug console. Or, if you use the WebKit console, press *Shift* + *Enter* instead of *Enter* to add a new line.\n\n## Code blocks\n\nIn the preceding examples, you saw the use of code blocks. Let's take a moment to clarify what a block of code is, because you will use blocks extensively when constructing conditions and loops.\n\nA block of code consists of zero or more expressions enclosed in curly brackets, which is shown in the following lines of code:\n\n```", "```js\n\nYou can nest blocks within each other indefinitely, as shown in the following example:\n\n```", "```js\n\n### Note\n\n**Best practice tips**\n\nUse end-of-line semicolons, as discussed previously in the chapter. Although the semicolon is optional when you have only one expression per line, it's good to develop the habit of using them. For best readability, the individual expressions inside a block should be placed one per line and separated by semicolons.\n\nIndent any code placed within curly brackets. Some programmers like one tab indentation, some use four spaces, and some use two spaces. It really doesn't matter, as long as you're consistent. In the preceding example, the outer block is indented with two spaces, the code in the first nested block is indented with four spaces, and the innermost block is indented with six spaces.\n\nUse curly brackets. When a block consists of only one expression, the curly brackets are optional, but for readability and maintainability, you should get into the habit of always using them, even when they're optional.\n\n### The if condition\n\nHere's a simple example of an `if` condition:\n\n```", "```js\n\nThe parts of the `if` condition are as follows:\n\n*   The `if` statement\n*   A condition in parentheses-`is a greater than 2`?\n*   A block of code wrapped in `{}` that executes if the condition is satisfied\n\nThe condition (the part in parentheses) always returns a Boolean value, and may also contain the following:\n\n*   A logical operation-`!`, `&&`, or `||`\n*   A comparison, such as `===`, `!=`, `>`, and so on\n*   Any value or variable that can be converted to a Boolean\n*   A combination of the above\n\n### The else clause\n\nThere can also be an optional else part of the `if` condition. The `else` statement is followed by a block of code that runs if the condition evaluates to `false`:\n\n```", "```js\n\nIn between the `if` and the `else` statements, there can also be an unlimited number of `else...if` conditions. Here's an example:\n\n```", "```js\n\nYou can also nest conditions by putting new conditions within any of the blocks, as shown in the following piece of code:\n\n```", "```js\n\n### Checking if a variable exists\n\nLet's apply the new knowledge about conditions for something practical. It's often necessary to check whether a variable exists. The laziest way to do this is to simply put the variable in the condition part of the `if` statement, for example, `if (somevar) {...}`. But, this is not necessarily the best method. Let's take a look at an example that tests whether a variable called `somevar` exists, and if so, sets the `result` variable to `yes`:\n\n```", "```js\n\nThis code obviously works because the end result was not `yes`. But firstly, the code generated an error-`somevar` is not defined, and you don't want your code to behave like that. Secondly, just because `if (somevar)` returns `false`, it doesn't mean that `somevar` is not defined. It could be that `somevar` is defined and initialized but contains a falsy value like `false` or `0`.\n\nA better way to check if a variable is defined is to use `typeof`:\n\n```", "```js\n\nThe `typeof` operator always returns a string, and you can compare this string with the string `\"undefined\"`. Note that the `somevar` variable may have been declared but not assigned a value yet and you'll still get the same result. So, when testing with `typeof` like this, you're really testing whether the variable has any value other than the `undefined` value:\n\n```", "```js\n\nIf a variable is defined and initialized with any value other than `undefined`, its type returned by `typeof` is no longer `\"undefined\"`, as shown in the following piece of code:\n\n```", "```js\n\n### Alternative if syntax\n\nWhen you have a simple condition, you can consider using an alternative `if` syntax. Take a look at this:\n\n```", "```js\n\nYou can also write this as:\n\n```", "```js\n\nYou should only use this syntax for simple conditions. Be careful not to abuse it, as it can easily make your code unreadable. Here's an example.\n\nLet's say you want to make sure a number is within a certain range, say between `50` and `100`:\n\n```", "```js\n\nIt may not be clear how this code works exactly because of the multiple ?. Adding parentheses makes it a little clearer, as shown in the following code block:\n\n```", "```js\n\n`?:` is called a ternary operator because it takes three operands.\n\n### Switch\n\nIf you find yourself using an `if` condition and having too many `else...if` parts, you can consider changing the `if` to a `switch`, as follows:\n\n```", "```js\n\nThe result after executing this is `\"String 1\"`. Let's see what the parts of a `switch` are:\n\n*   The `switch` statement.\n*   An expression in parentheses. The expression most often contains a variable, but can be anything that returns a value.\n*   A number of `case` blocks enclosed in curly brackets.\n*   Each `case` statement is followed by an expression. The result of the expression is compared to the expression found after the `switch` statement. If the result of the comparison is `true`, the code that follows the colon after the `case` is executed.\n*   There is an optional `break` statement to signal the end of the `case` block. If this `break` statement is reached, the `switch` statement is all done. Otherwise, if the `break` is missing, the program execution enters the next `case` block.\n*   There's an optional default case marked with the `default` statement and followed by a block of code. The `default` case is executed if none of the previous cases evaluated to `true`.\n\nIn other words, the step-by-step procedure to execute a `switch` statement is as follows:\n\n1.  Evaluate the `switch` expression found in parentheses; remember it.\n2.  Move to the first case and compare its value with the one from Step 1.\n3.  If the comparison in Step 2 returns `true`, execute the code in the `case` block.\n4.  After the `case` block is executed, if there's a `break` statement at the end of it, exit `switch`.\n5.  If there's no `break` or Step 2 returned `false`, move on to the next `case` block.\n6.  Repeat steps 2 to 5.\n7.  If you are still here (no exit in Step 4), execute the code following the `default` statement.\n\n### Tip\n\nIndent the code that follows the case lines. You can also indent case from the switch, but that doesn't give you much in terms of readability.\n\n#### Don't forget to break\n\nSometimes, you may want to omit the break intentionally, but that's rare. It's called a fall-through and should always be documented because it may look like an accidental omission. On the other hand, sometimes you may want to omit the whole code block following a case and have two cases sharing the same code. This is fine, but it doesn't change the rule that if there's code that follows a case statement, this code should end with a break. In terms of indentation, aligning the break with the case or with the code inside the case is a personal preference; again, being consistent is what matters.\n\nUse the default case. This helps you make sure that you always have a meaningful result after the switch statement, even if none of the cases matches the value being switched.\n\n## Loops\n\nThe `if...else` and `switch` statements allow your code to take different paths, as if you're at a crossroad, and decide which way to go depending on a condition. Loops, on the other hand, allow your code to take a few roundabouts before merging back into the main road. How many repetitions? That depends on the result of evaluating a condition before (or after) each iteration.\n\nLet's say you are (your program execution is) traveling from **A** to **B**. At some point, you will reach a place where you have to evaluate a condition, **C**. The result of evaluating **C** tells you whether you should go into a loop, **L**. You make one iteration and arrive at **C** again. Then, you evaluate the condition once again to see if another iteration is needed. Eventually, you move on your way to **B**:\n\n![Loops](graphics/image_02_003.jpg)\n\nAn infinite loop is when the condition is always `true`, and your code gets stuck in the loop forever. This is, of course, a logical error, and you should look out for such scenarios.\n\nIn JavaScript, the following are the four types of loops:\n\n*   `while` loops\n*   `do-while` loops\n*   `for` loops\n*   `for-in` loops\n\n### While loops\n\nThe `while` loops are the simplest type of iteration. They look like the following:\n\n```", "```js\n\nThe `while` statement is followed by a condition in parentheses and a code block in curly brackets. As long as the condition evaluates to `true`, the code block is executed over and over again.\n\n### Do-while loops\n\nThe `do...while` loops are a slight variation of `while` loops. An example is shown as follows:\n\n```", "```js\n\nHere, the `do` statement is followed by a code block and a condition after the block. This means that the code block is always executed, at least once, before the condition is evaluated.\n\nIf you initialize `i` to `11` instead of `0` in the last two examples, the code block in the first example (the `while` loop) will not be executed, and `i` will still be `11` at the end, while in the second (the `do...while` loop), the code block will be executed once and `i` will become `12`.\n\n### For loops\n\nThe `for` loop is the most widely used type of loop, and you should make sure you're comfortable with this one. It requires just a little bit more in terms of syntax:\n\n![For loops](graphics/image_02_004.jpg)\n\nIn addition to the **C** condition and the **L** code block, you have the following:\n\n*   **Initialization**: This is the code that is executed before you even enter the loop (marked with **0** in the diagram)\n*   **Increment**: This is the code that is executed after every iteration (marked with **++** in the diagram)\n\nThe following is the most widely used `for` loop pattern:\n\n*   In the initialization part, you can define a variable (or set the initial value of an existing variable), most often called `i`\n*   In the condition part, you can compare `i` to a boundary value, such as `i < 100`\n*   In the increment part, you can increase `i` by `1`, such as `i++`\n\nHere's an example:\n\n```", "```js\n\nAll three parts (initialization, condition, and increment) can contain multiple expressions separated by commas. Say you want to rewrite the example and define the variable `punishment` inside the initialization part of the loop:\n\n```", "```js\n\nCan you move the body of the loop inside the increment part? Yes, you can, especially as it's a one-liner. This gives you a loop that looks a little awkward, as it has no body. Note that this is just an intellectual exercise; it's not recommended that you write awkward-looking code:\n\n```", "```js\n\nThese three parts are all optional. Here's another way of rewriting the same example:\n\n```", "```js\n\nAlthough the last rewrite works exactly the same way as the original, it's longer and harder to read. It's also possible to achieve the same result using a `while` loop. But, the `for` loops make the code tighter and more robust because the mere syntax of the `for` loop makes you think about the three parts (initialization, condition, and increment), and thus helps you reconfirm your logic and avoid situations such as being stuck in an infinite loop.\n\nThe `for` loops can be nested within each other. Here's an example of a loop that is nested inside another loop and assembles a string containing ten rows and ten columns of asterisks. Think of `i` being the row and `j` being the column of an image:\n\n```", "```js\n\nThe result is a string, as shown here:\n\n```", "```js\n\nHere's another example that uses nested loops and a modulo operation to draw a snowflake-like result:\n\n```", "```js\n\nThe result is as follows:\n\n```", "```js\n\n### For...in loops\n\nThe `for...in` loop is used to iterate over the elements of an array, or an object, as you'll see later. This is its only use; it cannot be used as a general-purpose repetition mechanism to replace\u00a0`for` or `while`. Let's see an example of using a `for-in` to loop through the elements of an array. But, bear in mind that this is for informational purposes only, as `for...in` is mostly suitable for objects and the regular `for` loop should be used for arrays.\n\nIn this example, you can iterate over all of the elements of an array and print out the index (the key) and the value of each element, for example:\n\n```", "```js\n\n# Comments\n\nOne last thing for this chapter-comments. Inside your JavaScript program, you can put comments. These are ignored by the JavaScript engine and don't have any effect on how the program works. But they can be invaluable when you revisit your code after a few months, or transfer the code to someone else for maintenance.\n\nThe following two types of comments are allowed:\n\n*   Single line comments start with `//` and end at the end of the line.\n*   Multiline comments start with `/*` and end with `*/` on the same line or any subsequent line. Note that any code in between the comment start and the comment end is ignored.\n\nSome examples are as follows:\n\n```", "```js\n\nThere are even utilities, such as JSDoc and YUIDoc, that can parse your code and extract meaningful documentation based on your comments.\n\n# Exercises\n\n1.  What is the result of executing each of these lines in the console? Why?\n\n    ```", "```js\n\n2.  What is the value of v after the following?\n\n    ```"]