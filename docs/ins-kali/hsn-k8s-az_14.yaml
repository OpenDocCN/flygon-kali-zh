- en: 11\. Serverless functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11\. 无服务器函数
- en: Serverless and serverless functions have gained tremendous traction over the
    past few years. Cloud services such as Azure Functions, AWS Lambda, and GCP Cloud
    Run have made it very easy for developers to run their code as serverless functions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，无服务器和无服务器函数已经获得了巨大的发展。Azure Functions、AWS Lambda和GCP Cloud Run等云服务使开发人员非常容易地将其代码作为无服务器函数运行。
- en: The word *serverless* refers to any solution where you don't need to manage
    servers. Serverless functions refer to a subset of serverless computing, where
    you can run your code as a function on-demand. This means that your code in the
    function will only run and be executed when there is a *demand*. This architectural
    style is called event-driven architecture. In an event-driven architecture, the
    event consumers are triggered when there is an event. In the case of serverless
    functions, the event consumers will be these serverless functions. An event can
    be anything from a message on a queue to a new object uploaded to storage, or
    even an HTTP call.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: “无服务器”一词指的是您无需管理服务器的任何解决方案。无服务器函数是指无服务器计算的子集，您可以按需将代码作为函数运行。这意味着函数中的代码只有在有“需求”时才会运行和执行。这种架构风格称为事件驱动架构。在事件驱动架构中，事件消费者在有事件发生时被触发。在无服务器函数的情况下，事件消费者将是这些无服务器函数。事件可以是从队列上的消息到上传到存储的新对象，甚至是HTTP调用的任何内容。
- en: Serverless functions are frequently used for backend processing. A common example
    of serverless functions is creating thumbnails of a picture that is uploaded to
    storage. Since you cannot predict how many pictures will be uploaded and when
    they will be uploaded, it is hard to plan traditional infrastructure and how many
    servers you should have available for this process. If you implement the creation
    of that thumbnail as a serverless function, this function will be called on each
    picture that is uploaded. You don't have to plan the number of functions since
    each new picture will trigger a new function to be executed.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数经常用于后端处理。无服务器函数的一个常见示例是创建上传到存储的图片的缩略图。由于无法预测将上传多少图片以及它们何时上传，很难规划传统基础设施以及为此过程应该准备多少服务器。如果将缩略图的创建实现为无服务器函数，该函数将在上传的每张图片上被调用。您无需规划函数的数量，因为每张新图片都将触发执行一个新函数。
- en: This automatic scaling is just one benefit of using serverless functions. As
    you saw in the previous example, functions will automatically scale to meet increased
    or decreased demand. Additionally, each function can scale independently from
    other functions. Another benefit of serverless functions is the ease of use for
    developers. Serverless functions allow code to be deployed without worrying about
    managing servers and middleware. Finally, in public cloud serverless functions,
    you pay per execution of the function. This means that you pay each time your
    functions is run, and you are charged nothing for the idle time when your function
    is not run.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动扩展只是使用无服务器函数的一个好处。正如您在前面的示例中看到的，函数将自动扩展以满足增加或减少的需求。此外，每个函数可以独立于其他函数进行扩展。无服务器函数的另一个好处是对开发人员的易用性。无服务器函数允许代码部署而无需担心管理服务器和中间件。最后，在公共云无服务器函数中，您按照函数的执行付费。这意味着每次运行函数时都要付费，并且在函数不运行时不收取任何费用。
- en: 'The popularity of public cloud serverless functions platforms has caused multiple
    open-source frameworks to be created to enable users to create serverless functions
    on top of Kubernetes. In this chapter, you will learn how to deploy serverless
    functions on **Azure Kubernetes Services** (**AKS**) directly using the open-source
    version of Azure Functions. You will start by running a simple function that is
    triggered based on an HTTP message. Afterward, you will install a function''s
    autoscaler feature on your cluster. You will also integrate AKS-deployed applications
    with Azure storage queues. We will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 公共云无服务器函数平台的流行导致了多个开源框架的创建，使用户能够在Kubernetes之上创建无服务器函数。在本章中，您将学习如何使用Azure Functions的开源版本直接在**Azure
    Kubernetes Services** (**AKS**)上部署无服务器函数。您将首先运行一个简单的函数，该函数是基于HTTP消息触发的。之后，您将在集群上安装函数的自动缩放功能。您还将把AKS部署的应用程序与Azure存储队列集成。我们将涵盖以下主题：
- en: Overview of different functions platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同函数平台的概述
- en: Deploying an HTTP-triggered function
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署基于HTTP触发的函数
- en: Deploying a queue-triggered function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署队列触发的函数
- en: Let's start this chapter by exploring the multiple function platforms that are
    available for Kubernetes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索适用于Kubernetes的多个函数平台开始这一章。
- en: Multiple functions platforms
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多个函数平台
- en: Functions platforms, such as Azure Functions, AWS Lambda, and Google Cloud Functions,
    have gained tremendously in popularity. The ability to run code without thinking
    about servers and having virtually limitless scale is very popular. The downside
    of using a cloud provider's functions implementation is that you are locked into
    their infrastructure and their programming model. Also, you can only run your
    functions in the public cloud and not in your own datacenter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如Azure Functions、AWS Lambda和Google Cloud Functions之类的函数平台在流行度上获得了巨大的增长。无需考虑服务器即可运行代码并且具有几乎无限的扩展性非常受欢迎。使用云提供商的函数实现的缺点是您被锁定在他们的基础设施和编程模型中。此外，您只能在公共云中运行函数，而不能在自己的数据中心中运行。
- en: 'A number of open-source functions frameworks have been launched to solve these
    downsides. There are a number of popular frameworks:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 已经推出了许多开源函数框架来解决这些缺点。有许多流行的框架：
- en: '**Serverless** ([https://serverless.com/](https://serverless.com/)): A Node.js-based
    serverless application framework that can deploy and manage functions on multiple
    cloud providers, including Azure. Kubernetes support is provided via Kubeless.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Serverless** ([https://serverless.com/](https://serverless.com/)): 基于Node.js的无服务器应用程序框架，可以在多个云提供商上部署和管理函数，包括Azure。通过Kubeless提供Kubernetes支持。'
- en: '**OpenFaaS** ([https://www.openfaas.com/](https://www.openfaas.com/)): OpenFaaS
    is a serverless framework that is Kubernetes-native. It can run on either managed
    Kubernetes environments such as AKS, or on a self-hosted cluster. OpenFaaS is
    also available as a managed cloud service using OpenFaaSCloud. The platform is
    written in the Go language.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenFaaS** ([https://www.openfaas.com/](https://www.openfaas.com/)): OpenFaaS是一个Kubernetes原生的无服务器框架。它可以在托管的Kubernetes环境（如AKS）或自托管集群上运行。OpenFaaS也作为OpenFaaSCloud的托管云服务提供。该平台是用Go语言编写的。'
- en: '**Fission.io** ([https://fission.io/](https://fission.io/)): Fission is written
    in the Go language and is Kubernetes-native. It is a serverless framework backed
    by the company Platform9\.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Fission.io** ([https://fission.io/](https://fission.io/)): Fission是用Go语言编写的，是Kubernetes原生的。这是一个由Platform9公司支持的无服务器框架。'
- en: '**Apache OpenWhisk** ([https://openwhisk.apache.org/](https://openwhisk.apache.org/)):
    OpenWhisk is an open-source, distributed serverless platform maintained by the
    Apache organization. It can be run on Kubernetes, Mesos, and Docker Compose. It
    is primarily written in the Scala language.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache OpenWhisk（[https://openwhisk.apache.org/](https://openwhisk.apache.org/)）：OpenWhisk是一个由Apache组织维护的开源分布式无服务器平台。它可以在Kubernetes、Mesos和Docker
    Compose上运行。它主要用Scala语言编写。
- en: '**Knative** ([https://cloud.google.com/knative/](https://cloud.google.com/knative/)):
    Knative is a serverless functions platform written in the Go language and developed
    by Google. You can run Knative functions either fully managed on Google Cloud
    or on your own Kubernetes cluster.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Knative**（[https://cloud.google.com/knative/](https://cloud.google.com/knative/)）：Knative是由Google开发的用Go语言编写的无服务器函数平台。您可以在Google
    Cloud上完全托管Knative函数，也可以在自己的Kubernetes集群上运行。'
- en: Microsoft has taken an interesting strategy with its functions platform. Microsoft
    operates Azure Functions as a managed service on Azure and has open-sourced the
    complete solution and made it available to run on any system ([https://github.com/Azure/azure-functions-host](https://github.com/Azure/azure-functions-host)).
    This also makes the Azure Functions programming model available on top of Kubernetes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 微软采取了一种有趣的策略来处理其函数平台。微软在Azure上作为托管服务运行Azure Functions，并已开源了完整解决方案，并可在任何系统上运行（[https://github.com/Azure/azure-functions-host](https://github.com/Azure/azure-functions-host)）。这也使得Azure
    Functions编程模型可以在Kubernetes上运行。
- en: Microsoft has also released an additional open-source project in partnership
    with Red Hat called **Kubernetes Event-driven Autoscaling** (**KEDA**) to make
    scaling functions on top of Kubernetes easier. **KEDA** is a custom autoscaler
    that can allow Deployments to scale to and from 0 Pods. Scaling from 0 to 1 Pod
    is important so that your application can start processing events. Scaling down
    to 0 instances is useful for preserving resources in your cluster. Scaling to
    and from 0 Pods is not possible using the default **Horizontal Pod Autoscaler
    (HPA)** in Kubernetes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还与红帽合作发布了一个名为**Kubernetes事件驱动自动缩放**（**KEDA**）的额外开源项目，以使在Kubernetes上扩展函数更加容易。**KEDA**是一个自定义自动缩放器，可以允许部署从0个Pod缩放到1个Pod。从0扩展到1个Pod很重要，这样您的应用程序就可以开始处理事件。缩减到0个实例对于保留集群中的资源很有用。使用Kubernetes中的默认**水平Pod自动缩放器（HPA）**无法实现从0到1个Pod的扩展。
- en: KEDA also makes additional metrics available to the Kubernetes HPA to make scaling
    decisions based on metrics from outside the cluster (for example, the number of
    messages in a queue).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: KEDA还可以提供额外的指标给Kubernetes HPA，以便根据集群外部的指标（例如队列中的消息数量）做出扩展决策。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We introduced and explained the HPA in *Chapter 4*, *Scaling your application*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第4章*中介绍和解释了HPA，*扩展您的应用程序*。
- en: 'In this chapter, we will deploy Azure Functions to Kubernetes in two examples:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在两个示例中将Azure Functions部署到Kubernetes：
- en: An HTTP-triggered function
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个HTTP触发的函数
- en: A queue-triggered function
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个队列触发的函数
- en: Before we start, we need to set up an **Azure Container Registry** (**ACR**)
    and a development machine. The ACR will be used to store custom Docker images
    that contain the functions we will develop. We will use a development machine
    to build the functions and create Docker images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们需要设置一个**Azure容器注册表**（**ACR**）和一个开发机器。ACR将用于存储包含我们将开发的函数的自定义Docker映像。我们将使用开发机器构建函数并创建Docker映像。
- en: Setting up prerequisites
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置先决条件
- en: In this section, we will set up the prerequisites we need in order to build
    and run functions. We need a container registry and a development machine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置我们构建和运行函数所需的先决条件。我们需要一个容器注册表和一个开发机器。
- en: We introduced container images and a container registry in *Chapter 1*, *Introduction
    to Docker and Kubernetes*, in the section on *Docker images*. A container image
    contains all the software required to start an actual running container. In this
    chapter, we will build custom Docker images that contain our functions. We need
    a place to store these images so that Kubernetes can pull these images and run
    the containers at scale. We will use the Azure Container Registry for this. Azure
    Container Registry is a private container registry that is fully managed by Azure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*，*Docker和Kubernetes简介*中的*Docker镜像*部分，我们介绍了容器镜像和容器注册表。容器镜像包含启动实际运行容器所需的所有软件。在本章中，我们将构建包含我们函数的自定义Docker镜像。我们需要一个地方来存储这些镜像，以便Kubernetes可以拉取这些镜像并以规模运行容器。我们将使用Azure容器注册表来实现这一点。Azure容器注册表是由Azure完全管理的私有容器注册表。
- en: Up to now in this book, we have run all the examples on the Azure Cloud Shell.
    For the example in this chapter, we need a separate development machine because
    the Azure Cloud Shell doesn't allow you to build Docker images. We will create
    a new development machine on Azure to do these tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中，我们已经在Azure Cloud Shell上运行了所有的示例。对于本章的示例，我们需要一个单独的开发机器，因为Azure Cloud
    Shell不允许您构建Docker镜像。我们将在Azure上创建一个新的开发机器来执行这些任务。
- en: Let's begin by creating an ACR.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建一个ACR。
- en: Azure Container Registry
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Azure容器注册表
- en: 'Azure Functions on Kubernetes needs an image registry to store its container
    images. In this section, we will create an ACR and configure our Kubernetes cluster
    to have access to this cluster:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes上的Azure函数需要一个镜像注册表来存储其容器镜像。在本节中，我们将创建一个ACR并配置我们的Kubernetes集群以访问此注册表：
- en: In the Azure search bar, look for `container registry` and click on **Container
    registries**:![Entering the keyword "container registry" in the Azure search bar
    to find and select container registries.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure搜索栏中，搜索`容器注册表`，然后单击**容器注册表**：![在Azure搜索栏中输入关键词“容器注册表”以查找并选择容器注册表。
- en: '](image/Figure_11.1.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_11.1.jpg)'
- en: 'Figure 11.1: Looking for Container registries in the search bar'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.1：在搜索栏中查找容器注册表
- en: Click the **Add** button on the top to create a new registry. Provide the details
    to create the registry. The registry name needs to be globally unique, so consider
    adding your initials to the registry name. It is recommended to create the registry
    in the same location as your cluster. Select the **Create** button to create the
    registry:![Entering details such as registry name, subscription, resource group,
    location, and SKU in the Create container registry window.](image/Figure_11.2.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击顶部的**添加**按钮以创建一个新的注册表。提供创建注册表的详细信息。注册表名称需要全局唯一，因此考虑在注册表名称中添加您的缩写。建议在与您的集群相同的位置创建注册表。选择**创建**按钮以创建注册表：![在创建容器注册表窗口中输入注册表名称、订阅、资源组、位置和SKU等详细信息。](image/Figure_11.2.jpg)
- en: 'Figure 11.2: Providing the details to create the registry'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.2：提供创建注册表的详细信息
- en: 'When your registry is created, open up Cloud Shell so that we can configure
    our AKS cluster to get access to our container registry. Use the following command
    to give AKS permissions on your registry:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的注册表创建好后，打开Cloud Shell，这样我们就可以配置我们的AKS集群以访问我们的容器注册表。使用以下命令为您的注册表授予AKS权限：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We now have an ACR that is integrated with AKS. In the next section, we will
    create a development machine that will be used to build the Azure functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个与AKS集成的ACR。在下一节中，我们将创建一个开发机器，用于构建Azure函数。
- en: Creating a development machine
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建开发机器
- en: 'In this section, we will create a development machine and install the tools
    necessary to run Azure functions on this machine:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个开发机器并安装在该机器上运行Azure函数所需的工具：
- en: Docker runtime
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker运行时
- en: Azure CLI
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure CLI
- en: Azure Functions
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Functions
- en: Kubectl
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubectl
- en: Note
  id: totrans-48
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: To ensure a consistent experience, we will be creating a virtual machine (VM)
    on Azure that will be used for development. If you prefer to run the sample on
    your local machine, you can install all the required tools locally.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保一致的体验，我们将在Azure上创建一个将用于开发的虚拟机（VM）。如果您希望在本地机器上运行示例，可以在本地安装所有所需的工具。
- en: 'Let''s get started with creating the machine:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建这台机器：
- en: 'To start, we will generate a set of ssh keys that will be used to connect to
    the VM:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将生成一组用于连接到VM的SSH密钥：
- en: '[PRE1]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You will be prompted for a location and a passphrase. Keep the default location
    and input an empty passphrase.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示您输入位置和密码。保持默认位置并输入空密码。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you followed the example in *Chapter 10*, *Securing your AKS cluster*, where
    we created an Azure AD integrated cluster, you can skip step 1 as you will already
    have a set of SSH keys.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照*第10章*中的示例*保护您的AKS集群*，在那里我们创建了一个Azure AD集成的集群，您可以跳过第1步，因为您已经有了一组SSH密钥。
- en: If you prefer to reuse the SSH keys that you already have, you can do that as
    well.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望重用已有的SSH密钥，也可以这样做。
- en: 'We will now create our development machine. We will create an Ubuntu VM using
    the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建我们的开发机器。我们将使用以下命令创建一个Ubuntu VM：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will take a couple of minutes to complete. Once the VM is created, Cloud
    Shell should show you its public IP, as displayed in *Figure 11.3*:![Output displaying
    details such as Location, MAC address, power state, private IP and the public
    IP of the Ubuntu VM. The output shows the public IPaddress of the VM.](image/Figure_11.3.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将需要几分钟的时间才能完成。创建VM后，Cloud Shell应该会显示其公共IP，如*图11.3*中所示：![显示位置、MAC地址、电源状态、私有IP和Ubuntu
    VM的公共IP等详细信息的输出。输出显示VM的公共IP地址。](image/Figure_11.3.jpg)
- en: 'Figure 11.3: Connecting to the machine''s public IP'
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.3：连接到机器的公共IP
- en: 'Connect to the VM using the following command:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令连接到VM：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will be prompted whether you trust the machine's identity. Type `yes` to
    confirm.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会询问您是否信任该机器的身份。输入`yes`以确认。
- en: 'You''re now connected to a new machine on Azure. On this machine, we will begin
    by installing Docker:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在已连接到Azure上的一台新机器。在这台机器上，我们将开始安装Docker：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To verify that Docker is installed and running, you can run the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证Docker是否已安装并运行，可以运行以下命令：
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should show you the `hello-world` message from Docker:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该向您显示来自Docker的“hello-world”消息：
- en: '![Output of the sudodocker run hello-world command displaying the message "Hello!
    from Docker".](image/Figure_11.4.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![sudodocker run hello-world命令的输出显示消息“Hello! from Docker”。](image/Figure_11.4.jpg)'
- en: 'Figure 11.4: Running hello-world with Docker'
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.4：使用Docker运行hello-world
- en: 'To make the operation smoother, we will add our user to the Docker group, which
    will no longer require `sudo` in front of the Docker commands:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使操作更加顺畅，我们将把我们的用户添加到Docker组，这样在Docker命令前将不再需要`sudo`：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You should now be able to run the `hello-world` command without `sudo`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够在不使用`sudo`的情况下运行`hello-world`命令：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we will install the Azure CLI on this development machine. You can install
    the CLI using the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在开发机器上安装Azure CLI。您可以使用以下命令安装CLI：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Verify that the CLI was installed successfully by logging in:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过登录验证安装了CLI：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will display a login code that you need to enter at [https://microsoft.com/devicelogin](https://microsoft.com/devicelogin):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个登录代码，您需要在[https://microsoft.com/devicelogin](https://microsoft.com/devicelogin)输入：
- en: '![Output of the az CLI command instructing the user to enter the code using
    a web browser.](image/Figure_11.5.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![az CLI命令的输出指示用户使用Web浏览器输入代码。](image/Figure_11.5.jpg)'
- en: 'Figure 11.5: Logging in to the az CLI'
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.5：登录到az CLI
- en: Browse to that website and paste in the login code that was provided to you
    to enable you to log in to Cloud Shell. Make sure to do this in a browser you
    are logged into with the user who has access to your Azure subscription.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览到该网站，并粘贴提供给您的登录代码，以使您能够登录到Cloud Shell。请确保在您已登录的浏览器中进行此操作，该浏览器具有访问您的Azure订阅的用户权限。
- en: 'We can now use the CLI to authenticate our machine to ACR. This can be done
    using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用CLI将我们的机器认证到ACR。可以使用以下命令完成：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will show you a warning that the password will be stored unencrypted. You
    can ignore that for the purpose of this demonstration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示一个警告，指出密码将以未加密的形式存储。您可以忽略这一点，以便进行演示。
- en: 'The credentials to ACR expire after a certain time. If you run into the following
    error during this demonstration, you can log in to ACR again using the preceding
    command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ACR的凭据在一定时间后会过期。如果在此演示过程中遇到以下错误，您可以使用前面的命令重新登录ACR：
- en: '![Error message stating that there was failure pushing the Docker image and
    that authentication is required.](image/Figure_11.6.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![错误消息指出推送Docker镜像失败，并且需要进行身份验证。](image/Figure_11.6.jpg)'
- en: 'Figure 11.6: If this error is encountered, you can resolve this by logging
    into ACR again'
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.6：如果遇到此错误，您可以通过重新登录ACR来解决此问题
- en: 'Next, we''ll install `kubectl` on our machine. The `az` CLI has a shortcut
    to install the CLI, which we will use:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在我们的机器上安装`kubectl`。`az` CLI有一个安装CLI的快捷方式，我们将使用它：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s verify that `kubectl` can connect to our cluster. For this, we''ll first
    get the credentials and then execute a `kubectl` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证`kubectl`是否可以连接到我们的集群。为此，我们首先获取凭据，然后执行一个`kubectl`命令：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can install the Azure Functions tools on this machine. To do this,
    run the following commands:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在这台机器上安装Azure Functions工具。要做到这一点，请运行以下命令：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you are running a newer version of Ubuntu than 18.04, please make sure that
    you download the correct `dpkg` package by changing the URL in the first step
    to reflect your Ubuntu version.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的Ubuntu版本比18.04更新，请确保通过更改第一步中的URL来下载正确的`dpkg`软件包以反映您的Ubuntu版本。
- en: We now have the prerequisites to start our work with functions on Kubernetes.
    We created an ACR to store our custom Docker images, and we have a development
    machine that we will use to create and build Azure functions. In the next section,
    we will build a first function that is HTTP triggered.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经具备了在Kubernetes上使用函数的先决条件。我们创建了一个ACR来存储我们的自定义Docker镜像，并且有一台开发机器，我们将用它来创建和构建Azure函数。在下一节中，我们将构建一个首个HTTP触发的函数。
- en: Creating an HTTP-triggered Azure function
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个HTTP触发的Azure函数
- en: 'In this first example, we will create an HTTP-triggered Azure function. This
    means that you can browse to the page hosting the actual function:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个示例中，我们将创建一个HTTP触发的Azure函数。这意味着您可以浏览到托管实际函数的页面：
- en: 'To begin, we will create a new directory and navigate to that directory:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新目录并导航到该目录：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we will initialize a function using the following command. The `--docker`
    parameter specifies that we will build our function as a Docker container. This
    will result in a Dockerfile being created for us. We will select the Python language,
    option `3` in the following screenshot:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下命令初始化一个函数。`--docker`参数指定我们将构建我们的函数作为Docker容器。这将导致为我们创建一个Dockerfile。我们将在以下截图中选择Python语言，选项`3`：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will create the required files for our function to work:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的函数所需的文件：
- en: '![After running the funcinit --docker command,four options are provided: dotnet,
    node, python, and powershell. We select option 3.](image/Figure_11.7.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![运行funcinit --docker命令后，提供了四个选项：dotnet、node、python和powershell。我们选择选项3。](image/Figure_11.7.jpg)'
- en: 'Figure 11.7: Creating a Python function'
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.7：创建一个Python函数
- en: 'Next, we will create the actual function. Enter the following code and select
    the fifth option, `HTTP trigger`, and name the function `python-http`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建实际的函数。输入以下代码，并选择第五个选项，`HTTP触发器`，并将函数命名为`python-http`：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should result in an output like *Figure 11.8*:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生一个类似*图11.8*的输出：
- en: '![The output of the func new command returns nine options. We select the option
    5: HTTP trigger.](image/Figure_11.8.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![func new命令的输出返回九个选项。我们选择选项5：HTTP触发器。](image/Figure_11.8.jpg)'
- en: 'Figure 11.8: Creating an HTTP-triggered function'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.8：创建一个HTTP触发函数
- en: 'The code of the function is stored in the directory called `python-http`. We
    are not going to make code changes to the function. If you want to check out the
    source code of the function, you can run the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的代码存储在名为`python-http`的目录中。我们不打算对函数进行代码更改。如果您想查看函数的源代码，可以运行以下命令：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will need to make one change to a function''s configuration file. By default,
    functions require an authenticated request. We will change this to anonymous for
    our demo. We will make the change in `vi` by executing the following command:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对函数的配置文件进行一次更改。默认情况下，函数需要经过身份验证的请求。我们将在演示中将其更改为匿名。我们将通过执行以下命令在`vi`中进行更改：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We will replace the `authLevel` on line 5 with `anonymous`. To make that change,
    execute the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第5行将`authLevel`替换为`anonymous`。要进行此更改，请执行以下步骤：
- en: Press *I* to go into insert mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 按*I*进入插入模式。
- en: 'Remove `function` and replace it with `anonymous`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`function`并替换为`anonymous`：
- en: '![In the python-http/function.json file, we change authlevel to anonymous.](image/Figure_11.9.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![在python-http/function.json文件中，我们将authlevel更改为anonymous。](image/Figure_11.9.jpg)'
- en: 'Figure 11.9: Changing the function to anonymous'
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.9：将函数更改为匿名
- en: Hit *Esc*, type `:wq!`, and then *Enter* to save and quit `vi`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*Esc*，输入`:wq!`，然后按*Enter*保存并退出`vi`。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We changed the authentication requirement for our function to `anonymous`. This
    will make our demo easier to execute. If you plan to release functions to production,
    you need to carefully consider this setting, since this controls who has access
    to your function.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更改函数的身份验证要求为`anonymous`。这将使我们的演示更容易执行。如果您计划将函数发布到生产环境，您需要仔细考虑此设置，因为这控制着谁可以访问您的函数。
- en: 'We are now ready to deploy our function to AKS. We can deploy the function
    using the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备将函数部署到AKS。我们可以使用以下命令部署函数：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This will cause the function''s runtime to do a couple of steps. First, it
    will build a container image, then it will push that image to our registry, and
    finally it will deploy the function to Kubernetes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致函数的运行时执行一些步骤。首先，它将构建一个容器映像，然后将该映像推送到我们的注册表，最后将函数部署到Kubernetes：
- en: '![Output of the funckubernetes deploy command showing docker build, docker
    push, and the creation of a secret, a service, and a deployment.](image/Figure_11.10.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![funckubernetes deploy命令的输出显示docker build，docker push以及创建一个secret，一个service和一个deployment。](image/Figure_11.10.jpg)'
- en: 'Figure 11.10: Deploying the function to AKS'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.10：将函数部署到AKS
- en: 'This will create a regular Pod on top of Kubernetes. To check the Pods, you
    can run the following command:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在Kubernetes之上创建一个常规Pod。要检查Pods，您可以运行以下命令：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once that Pod is in a running state, you can get the public IP of the Service
    that was deployed and connect to it:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦该Pod处于运行状态，您可以获取部署的Service的公共IP并连接到它：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open a web browser and browse to `http://<external-ip>/api/python-http?name=handsonaks`.
    You should see a web page showing you *Hello handsonaks!*, which is what our function
    is supposed to show:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器，浏览到`http://<external-ip>/api/python-http?name=handsonaks`。您应该会看到一个网页，上面显示着*Hello
    handsonaks!*，这就是我们的函数应该显示的内容。
- en: '![Browser printing the message "Hello handsonaks!"](image/Figure_11.11.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![浏览器打印消息“Hello handsonaks！”](image/Figure_11.11.jpg)'
- en: 'Figure 11.11: Our function is working correctly'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.11：我们的函数正在正常工作
- en: 'We have now created a function with an HTTP trigger. Let''s clean up this Deployment
    before moving to the next section:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个带有HTTP触发器的函数。在转到下一部分之前，让我们清理一下这个部署：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this section, we created a sample function using an HTTP trigger. Let's take
    that one step further and integrate a new function with storage queues and set
    up an autoscaler.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们使用HTTP触发器创建了一个示例函数。让我们进一步将一个新函数与存储队列集成并设置自动缩放。
- en: Creating a queue-triggered function
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建队列触发的函数
- en: In the previous section, we created a sample HTTP function. In a real-world
    use case, queues are often used to pass messages between different components
    of an application. A function can be triggered based on messages in a queue to
    then perform additional processing on these messages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，我们创建了一个示例HTTP函数。在实际应用中，队列通常用于在应用程序的不同组件之间传递消息。可以根据队列中的消息触发函数，然后对这些消息进行额外处理。
- en: In this section, we'll create a function that is integrated with storage queues
    to consume events. We will also configure KEDA to allow scaling to/from 0 Pods
    in case of low traffic.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个与存储队列集成以消耗事件的函数。我们还将配置KEDA以允许在低流量情况下从0个Pod进行扩展/缩减。
- en: We still start by creating a queue in Azure.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然首先在Azure中创建一个队列。
- en: Creating a queue
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建队列
- en: In this section, we will create a new storage account and a new queue in that
    storage account. We will connect functions to that queue in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将创建一个新的存储帐户和一个新的队列。我们将在下一部分将函数连接到该队列。
- en: To begin, we will create a storage account. Look for `storage` in the Azure
    search bar and select **Storage accounts**:![Searching for storage accounts by
    entering "storage" in the Azure search bar.](image/Figure_11.12.jpg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个存储帐户。在Azure搜索栏中搜索“存储”并选择**存储帐户**：![通过在Azure搜索栏中输入“存储”来搜索存储帐户。](image/Figure_11.12.jpg)
- en: 'Figure 11.12: Looking for storage in the Azure search bar'
  id: totrans-146
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.12：在Azure搜索栏中寻找存储
- en: Click the **Add** button on the top to create a new account. Provide the details
    to create the storage account. The storage account name has to be globally unique,
    so consider adding your initials. It is recommended to create the storage account
    in the same region as your AKS cluster. Finally, to save on costs, you are recommended
    to downgrade the replication setting to **Locally-redundant storage (LRS)**:![Entering
    the storage account details,such as Subscription, resource group, storage account
    name, location, performance, account kind, replication, and access tier within
    the Basics tab.](image/Figure_11.13.jpg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部的**添加**按钮创建新帐户。提供详细信息以创建存储帐户。存储帐户名称必须是全局唯一的，因此考虑添加您的缩写。建议在与您的AKS集群相同的区域创建存储帐户。最后，为了节约成本，建议将复制设置降级为**本地冗余存储（LRS）**：![在基本选项卡中输入存储帐户详细信息，例如订阅、资源组、存储帐户名称、位置、性能、帐户类型、复制和访问层。](image/Figure_11.13.jpg)
- en: 'Figure 11.13: Providing the details to create the storage account'
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.13：提供创建存储帐户的详细信息
- en: If you're ready, click the **Review and Create** button at the bottom. In the
    review screen, select **Create** to start the creation process.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您准备好了，请点击底部的**审阅和创建**按钮。在审阅屏幕上，选择**创建**开始创建过程。
- en: It will take about a minute to create the storage account. Once it is created,
    open the account by clicking on the **go to resource** button. In the storage
    account blade, go to **Access keys**, and copy the primary connection string.
    Note down this string for now:![Navigating to the Access keys tab in the left
    panel and copying the primary connection string.](image/Figure_11.14.jpg)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建存储账户大约需要一分钟。创建完成后，点击**转到资源**按钮打开账户。在存储账户刀片中，转到**访问密钥**，并复制主连接字符串。暂时记下这个字符串：![在左侧面板中导航到访问密钥选项卡并复制主连接字符串。](image/Figure_11.14.jpg)
- en: 'Figure 11.14: Copying the primary connection string'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.14：复制主连接字符串
- en: Note
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: For production use cases, it is not recommended to connect to Azure storage
    using the access key. Any user with that access key has full access to the storage
    account and can read and delete all files on it. It is recommended to either generate
    a **shared access signatures** (**SAS**) token to connect to storage or to use
    Azure AD-integrated security. To learn more about SAS token authentication to
    storage, refer to [https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature](https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature).
    To learn more about Azure AD authentication to Azure storage, please refer to
    [https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory](https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产用例，不建议使用访问密钥连接到Azure存储。拥有该访问密钥的任何用户都可以完全访问存储账户，并且可以读取和删除其中的所有文件。建议要么生成一个**共享访问签名**（**SAS**）令牌来连接到存储，要么使用Azure
    AD集成安全性。要了解有关使用SAS令牌对存储进行身份验证的更多信息，请参阅[https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature](https://docs.microsoft.com/rest/api/storageservices/delegate-access-with-shared-access-signature)。要了解有关Azure
    AD对Azure存储进行身份验证的更多信息，请参阅[https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory](https://docs.microsoft.com/rest/api/storageservices/authorize-with-azure-active-directory)。
- en: The final step is to create our queue in the storage account. Look for `queue`
    in the left-hand navigation, click the **+Queue** button to adda queue, and provide
    it with a name. To follow along with this demo, call the queue `function`:![Creating
    a new queue within the storage account.](image/Figure_11.15.jpg)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在存储账户中创建我们的队列。在左侧导航中查找`queue`，点击**+Queue**按钮添加一个队列，并为其提供一个名称。要跟随这个演示，请将队列命名为`function`：![在存储账户中创建一个新队列。](image/Figure_11.15.jpg)
- en: 'Figure 11.15: Creating a new queue'
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.15：创建一个新队列
- en: We have now created a storage account in Azure and have its connection string.
    We created a queue in this storage account. In the next section, we will create
    a function that will consume messages from the queue.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在Azure中创建了一个存储账户并获得了它的连接字符串。我们在这个存储账户中创建了一个队列。在下一节中，我们将创建一个将从队列中消耗消息的函数。
- en: Creating a queue-triggered function
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个队列触发的函数
- en: 'In the previous section, we created a queue on Azure. In this section, we will
    create a new function that will watch this queue. We will need to configure this
    function with the connection string to this queue:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在Azure上创建了一个队列。在本节中，我们将创建一个新的函数，用于监视这个队列。我们需要使用这个队列的连接字符串来配置这个函数：
- en: 'We will begin by creating a new directory and navigating to it:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从创建一个新目录并导航到它开始：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can create the function. We will start with the initialization:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建函数。我们将从初始化开始：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This should result in the output shown in *Figure 11.16*:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该导致*图11.16*中显示的输出：
- en: '![The output of the funcinit --docker command asks for two configuration settings.
    We answer the first with 2 (node) and the second with 1 (JavaScript).](image/Figure_11.16.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![funcinit --docker命令的输出要求设置两个配置设置。我们用2（node）回答第一个，用1（JavaScript）回答第二个。](image/Figure_11.16.jpg)'
- en: 'Figure 11.16: Initializing a new function'
  id: totrans-165
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.16：初始化新函数
- en: 'Following the initialization, we can create the actual function:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们可以创建实际的函数：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should result in the output shown in *Figure 11.17*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生*图11.17*中显示的输出：
- en: '![Creating the actual function with the func new command and then selecting
    option 10, Azure queue storage trigger for the template.](image/Figure_11.17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用func new命令创建实际函数，然后选择选项10，Azure队列存储触发器作为模板。](image/Figure_11.17.jpg)'
- en: 'Figure 11.17: Creating a new function'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.17：创建新函数
- en: 'We will now need to make a couple of configuration changes. We need to provide
    functions with the connection string to Azure storage and provide the queue name.
    First, open the `local.settings.json` file to configure the connection strings
    for storage:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要进行一些配置更改。我们需要为函数提供连接到Azure存储的连接字符串，并提供队列名称。首先，打开`local.settings.json`文件以配置存储的连接字符串：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To make the changes, follow these instructions:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更改，请按照以下说明操作：
- en: Hit *I* to go into insert mode.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*I*进入插入模式。
- en: On the line of `AzureWebJobsStorage` (line 6), replace the value with the connection
    string you copied earlier. Add a comma to the end of this line.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`AzureWebJobsStorage`（第6行）的行上，用之前复制的连接字符串替换该值。在该行的末尾添加逗号。
- en: 'Add a new line and then add the following text on that line:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一行，然后在该行上添加以下文本：
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![Changing the value for the AzureWebJobsStorageparameter and adding QueueConnString
    by editing the local.settings.json file.](image/Figure_11.18.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![通过编辑local.settings.json文件更改AzureWebJobsStorage参数的值并添加QueueConnString。](image/Figure_11.18.jpg)'
- en: 'Figure 11.18: Editing the local.settings.json file'
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.18：编辑local.settings.json文件
- en: Save and close the file by hitting the *Esc* key, type `:wq!`, and then press
    *Enter*.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并关闭文件，按下*Esc*键，输入`:wq!`，然后按*Enter*键。
- en: 'The next file we need to edit is the function configuration itself. Here, we
    will refer to the connection string from earlier, and provide the queue name.
    To do that, use the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编辑的下一个文件是函数配置本身。在这里，我们将引用之前的连接字符串，并提供队列名称。为此，请使用以下命令：
- en: '[PRE28]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To make the changes, follow these instructions:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行更改，请按照以下说明操作：
- en: Hit *I* to go into insert mode.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按*I*进入插入模式。
- en: On line7, change the queue name to the name of the queue we created (`function`).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7行，将队列名称更改为我们创建的队列的名称（`function`）。
- en: On line 8, add `QueueConnString` to the connection field:![Editing the js-queue/function.json
    file to enter the queueName and pointing the connection to QueueConnString.](image/Figure_11.19.jpg)
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第8行，将`QueueConnString`添加到连接字段中：![通过编辑js-queue/function.json文件输入queueName并将连接指向QueueConnString。](image/Figure_11.19.jpg)
- en: 'Figure 11.19: Editing the js-queue/function.json file'
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.19：编辑js-queue/function.json文件
- en: Save and close the file by hitting the *Esc* key, type `:wq!`, and then press
    *Enter*.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存并关闭文件，按下*Esc*键，输入`:wq!`，然后按*Enter*键。
- en: 'We are now ready to publish our function to Kubernetes. We will start the publishing
    by setting up KEDA on our Kubernetes cluster:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备将我们的函数发布到Kubernetes。我们将通过在Kubernetes集群上设置KEDA来开始发布：
- en: '[PRE29]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will set up KEDA on our cluster. The installation doesn''t take long.
    To verify that installation was successful, make sure that the KEDA Pod is running:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的集群上设置KEDA。安装过程不会花费很长时间。要验证安装是否成功，请确保KEDA Pod正在运行：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now deploy our function to Kubernetes. We will configure KEDA to look
    at the number of queue messages every 5 seconds (`polling-interval=5`) to have
    a maximum of 15 replicas (`max-replicas=15`), and to wait 15 seconds before removing
    Pods (`cooldown-period=15`). To deploy and configure KEDA, use the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的函数部署到Kubernetes。我们将配置KEDA每5秒查看一次队列消息数量（`polling-interval=5`），最多有15个副本（`max-replicas=15`），并在删除Pod之前等待15秒（`cooldown-period=15`）。要部署和配置KEDA，请使用以下命令：
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify the Deployment, you can run the following command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证部署，可以运行以下命令：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will show you all the resources that were deployed. As you can see in
    *Figure 11.20*, this Deployment creates a Deployment, ReplicaSet, and an HPA.
    In the HPA, you should see that there are no replicas currently running:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示部署的所有资源。正如您在*图11.20*中所看到的，此部署创建了一个部署、ReplicaSet和HPA。在HPA中，您应该看到当前没有副本在运行：
- en: '![Output of the kubectl get all command showing that three objects were created,
    and highlighting that the horizontal pod autoscaler has zero replicas running
    currently.](image/Figure_11.20.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get all命令的输出显示创建了三个对象，并突出显示水平Pod自动缩放器当前没有运行副本。](image/Figure_11.20.jpg)'
- en: 'Figure 11.20: The Deployment created three objects, and we have zero replicas
    running now'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.20：部署创建了三个对象，现在我们没有运行副本
- en: 'We will create a message in the queue now to wake up the Deployment and create
    a Pod. To see the scaling event, run the following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在队列中创建一条消息，以唤醒部署并创建一个Pod。要查看扩展事件，请运行以下命令：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To create a message in the queue, we are going to open a new cloud shell session.
    To open a new session, select the *Open new session* button in the cloud shell:![Selecting
    the Open new session button in the Bash window.](image/Figure_11.21.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在队列中创建一条消息，我们将打开一个新的云shell会话。要打开新会话，请在云shell中选择*打开新会话*按钮：![在Bash窗口中选择打开新会话按钮。](image/Figure_11.21.jpg)
- en: 'Figure 11.21: Opening a new cloud shell instance'
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.21：打开一个新的云shell实例
- en: On this new shell, run the following command to create a message in the queue.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个新的shell中，运行以下命令在队列中创建一条消息。
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After creating this message, switch back to the previous shell. It might take
    a couple of seconds, but soon enough, your HPA should scale to 1 replica. Afterward,
    it should also scale back down to 0 replicas:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完这条消息后，切换回到之前的shell。可能需要几秒钟，但很快，您的HPA应该会扩展到1个副本。之后，它还应该缩减到0个副本：
- en: '![Executing the kubectl get hpa -w command and verifying that KEDA scaled our
    Pods from 0 to 1 when we created a message in the queue, and back down to 0 when
    there were no messages left.](image/Figure_11.22.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get hpa -w命令并验证KEDA在我们在队列中创建消息时将我们的Pod从0扩展到1，并在没有消息时缩减到0。](image/Figure_11.22.jpg)'
- en: 'Figure 11.22: With one message in the queue, KEDA scales from 0 to 1 and back
    to 0 replicas'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.22：在队列中有一条消息时，KEDA从0扩展到1，然后再次缩减到0个副本
- en: We have now created a function that is triggered on the number of messages in
    a queue. We were able to verify that KEDA scaled our Pods from 0 to 1 when we
    created a message in the queue, and back down to 0 when there were no messages
    left. In the next section, we will execute a scale test, and we will create multiple
    messages in the queue and see how the functions react.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经创建了一个根据队列中消息数量触发的函数。我们能够验证KEDA在我们在队列中创建消息时将我们的Pod从0扩展到1，并在没有消息时缩减到0。在下一节中，我们将执行一个规模测试，并创建多条消息在队列中，看看函数的反应。
- en: Scale testing functions
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规模测试函数
- en: 'In the previous section, we saw how functions reacted when there was a single
    message in the queue. In this example, we are going to send 1,000 messages into
    the queue and see how KEDA will first scale out our function, and then scale back
    in, and eventually scale back down to zero:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们看到了当队列中有单个消息时函数的反应。在这个例子中，我们将向队列中发送1,000条消息，看看KEDA如何首先扩展我们的函数，然后缩小，最终缩减到零：
- en: 'In the current cloud shell, watch the HPA using the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在当前的云shell中，使用以下命令观察HPA：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To start pushing the messages, we are going to open a new cloud shell session.
    To open a new session, select the *Open new session* button in the cloud shell:![Hitting
    the Open new session button to open a new Cloud Shell instance.](image/Figure_11.23.jpg)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始推送消息，我们将打开一个新的云shell会话。要打开新会话，请在云shell中选择“打开新会话”按钮：
- en: 'Figure 11.23: Opening a new cloud shell instance'
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.23：打开一个新的云shell实例
- en: 'To send the 1,000 messages into the queue, we have provided a Python script
    called `sendMessages.py`, in the code bundle. Cloud Shell already has Python and
    pip (the Python package manager) installed. To be able to run this script, you
    will first need to install two dependencies:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将1,000条消息发送到队列中，我们提供了一个名为`sendMessages.py`的Python脚本，在代码包中。Cloud Shell已经安装了Python和pip（Python包管理器）。要运行此脚本，您首先需要安装两个依赖项：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When those are installed, open the `sendMessages.py` file:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完毕后，打开`sendMessages.py`文件：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Edit the storage connection string on line 4 to your connection string:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑第4行的存储连接字符串为您的连接字符串：
- en: '![In the sendMessages.py file, editing the storage connection string on line
    4 to our connection string.](image/Figure_11.24.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: 在sendMessages.py文件中，将第4行的存储连接字符串编辑为我们的连接字符串。
- en: 'Figure 11.24: Pasting in your connection string for your storage account on
    line 4'
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.24：在第4行粘贴您的存储账户的连接字符串
- en: 'Once you have pasted in your connection string, you can execute the Python
    script and send 1,000 messages to your queue:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您粘贴了连接字符串，您就可以执行Python脚本，向您的队列发送1,000条消息：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: While the messages are being sent, switch back to the previous cloud shell instance
    and watch KEDA scale from 0 to 1, and then watch the HPA scale to the maximum
    of 15 replicas. The HPA uses metrics provided by KEDA to take the scaling decisions.
    Kubernetes, by default, doesn't know about the number of messages in an Azure
    storage queue that KEDA provides to the HPA.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在消息发送的同时，切换回到之前的云shell实例，并观察KEDA从0扩展到1，然后观察HPA扩展到最大的15个副本。HPA使用KEDA提供的指标来做出扩展决策。默认情况下，Kubernetes不知道KEDA提供给HPA的Azure存储队列中的消息数量。
- en: 'Once the queue is empty, KEDA will scale back down to 0 replicas:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦队列为空，KEDA将缩减到0个副本：
- en: '![Executing the kubectl get hpa -w command shows that the HPA will scale replicas
    from 0 to first 1, then to 4, 8, and 15, and finally back to 0.](image/Figure_11.25.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: 执行kubectl get hpa -w命令显示HPA将从0扩展副本到1，然后到4，8和15，最后回到0。
- en: 'Figure 11.25: KEDA will scale from 0 to 1, and the HPA will scale to 15 Pods'
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11.25：KEDA将从0扩展到1，HPA将扩展到15个Pod
- en: 'This concludes our examples of running serverless functions on top of Kubernetes.
    Let''s make sure to clean up our Deployments. Run the following command from within
    the development machine we created (the final step will delete this VM. If you
    want to keep the VM, don''t run the final step):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们在Kubernetes上运行无服务器函数的示例。让我们确保清理我们的部署。从我们创建的开发机器中运行以下命令（最后一步将删除此虚拟机。如果您想保留虚拟机，请不要运行最后一步）：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The deletion of KEDA will show a couple of errors. That is because we only installed
    a subset of KEDA on top of our cluster, and the removal process tries to delete
    all components.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 删除KEDA将显示一些错误。这是因为我们只在我们的集群上安装了KEDA的一个子集，而删除过程尝试删除所有组件。
- en: In this section, we ran a function that was triggered by messages on a storage
    queue on top of Kubernetes. We used a component called KEDA to achieve scaling
    in our cluster. We saw how KEDA can scale from 0 to 1 and back down to 0\. We
    also saw how the HPA can use metrics provided by KEDA to scale out a Deployment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们运行了一个在Kubernetes上由存储队列上的消息触发的函数。我们使用了一个名为KEDA的组件来实现我们集群中的扩展。我们看到了KEDA如何从0扩展到1，然后再缩减到0。我们还看到了HPA如何使用KEDA提供的指标来扩展部署。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we deployed serverless functions on top of our Kubernetes cluster.
    To achieve this, we first created a development machine and an Azure Container
    Registry.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们在我们的Kubernetes集群上部署了无服务器函数。为了实现这一点，我们首先创建了一个开发机器和一个Azure容器注册表。
- en: We started our functions Deployments by deploying a function that used an HTTP
    trigger. The Azure Functions core tools were used to create that function and
    to deploy it to Kubernetes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过部署使用HTTP触发器的函数来开始我们的函数部署。使用Azure函数核心工具创建该函数并将其部署到Kubernetes。
- en: 'Afterward, we installed an additional component on our Kubernetes cluster called
    KEDA. KEDA allows serverless scaling in Kubernetes: it allows Deployments to and
    from 0 Pods, and it also provides additional metrics to the **Horizontal Pod Autoscaler**
    (**HPA**). We used a function that was triggered on messages in an Azure storage
    queue.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们在我们的Kubernetes集群上安装了一个名为KEDA的附加组件。KEDA允许Kubernetes中的无服务器扩展：它允许部署到0个Pod，并提供额外的指标给**水平Pod自动缩放器**（**HPA**）。我们使用了一个在Azure存储队列中的消息触发的函数。
- en: This chapter also concludes the book. Throughout this book, we've introduced
    AKS through multiple hands-on examples. The first part of the book focused on
    getting applications up and running. We created an AKS cluster, deployed multiple
    applications and learned how to scale those applications.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 本章也总结了本书。在整本书中，我们通过多个实际操作的例子介绍了AKS。书的第一部分侧重于启动应用程序。我们创建了一个AKS集群，部署了多个应用程序，并学习了如何扩展这些应用程序。
- en: The second part of the book focused on the operational aspects of running AKS.
    We discussed common failures and how to solve them, integrated applications with
    Azure AD, and looked into the monitoring of the cluster.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 书的第二部分侧重于运行AKS的操作方面。我们讨论了常见的故障以及如何解决它们，将应用程序集成到Azure AD，并研究了集群的监控。
- en: In the final part of the book, we looked into advanced integration of AKS with
    other Azure services. We integrated our AKS cluster with Azure databases and Azure
    Event Hubs, we secured our cluster, and finally, we developed Azure Functions
    on top of our AKS cluster.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在书的最后部分，我们深入研究了AKS与其他Azure服务的高级集成。我们将我们的AKS集群与Azure数据库和Azure事件中心集成，保护了我们的集群，最后，在我们的AKS集群上开发了Azure函数。
- en: As a result of finishing this book, you should now be ready to build and run
    your applications at scale on top of AKS.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成这本书，您现在应该准备好在AKS上构建和运行您的应用程序。
