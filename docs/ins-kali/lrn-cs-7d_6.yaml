- en: Day 06 - Deep Dive with Advanced Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第06天-深入探讨高级概念
- en: Today is day six of our seven-day learning series. On day five, we discussed
    important concepts of the C# language and went through reflection, collections,
    delegates, and events. We explored these concepts using a code snippet, where
    we discussed non-generic collections. Today, we will discuss the main power of
    collections using generic types, and then, we will cover preprocessor directives
    and attributes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 今天是我们七天学习系列的第六天。在第五天，我们讨论了C#语言的重要概念，并通过反射、集合、委托和事件进行了探讨。我们使用了代码片段来探讨非泛型集合。今天，我们将讨论使用泛型类型的集合的主要功能，然后我们将涵盖预处理指令和属性。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Playing with collections and generics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩转集合和泛型
- en: Beautifying code using attributes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性美化代码
- en: Leveraging Preprocessor Directives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用预处理指令
- en: Getting started with LINQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用LINQ
- en: Writing unsafe code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写不安全的代码
- en: Writing asynchronous code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: Revisiting Day 6
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重温第六天
- en: Hands-on exercise
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际练习
- en: Playing with collections and generics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩转集合和泛型
- en: Collections are not new for us, as we went through and discussed non-generic
    collections on day five. So, we also have generic collections. In this section,
    we will discuss all about collections and generics with the use of code examples.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，集合并不新鲜，因为我们在第五天已经讨论了非泛型集合。因此，我们也有泛型集合。在本节中，我们将讨论使用代码示例的集合和泛型的所有内容。
- en: Understanding collection classes and their usage
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解集合类及其用法
- en: As discussed on day five, collection classes are specialized classes and are
    meant for data interaction (storage and retrieval). We have already discussed
    various collection classes, namely
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如第五天讨论的那样，集合类是专门的类，用于数据交互（存储和检索）。我们已经讨论了各种集合类，包括
- en: 'stacks, queues, lists, and hash tables, and we have written code using the
    `System.Collections.NonGeneric` namespace. The following table provides us an
    overview of the usage and meaning of non-generic collection classes:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 栈、队列、列表和哈希表，并且我们已经使用了`System.Collections.NonGeneric`命名空间编写了代码。以下表格为我们提供了非泛型集合类的用法和含义的概述：
- en: '| **Property** | **Description** | **Usage** |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** | **用法** |'
- en: '| `ArrayList` | The name itself describes that this contains a collection of
    ordered collection that can be accessed using index.We can declare `ArrayList`
    as follows: `ArrayList arrayList = new ArrayList();` | On day two, we discussed
    arrays and went through how to access the individual elements of an array. In
    the case of `ArrayList`, we can get the benefits of various methods to add or
    remove elements of collections, as discussed on day five. |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `ArrayList` | 名称本身描述了它包含一个可以使用索引访问的有序集合。我们可以这样声明`ArrayList`：`ArrayList arrayList
    = new ArrayList();` | 在第二天，我们讨论了数组，并学习了如何访问数组的各个元素。在`ArrayList`的情况下，我们可以获得各种方法来添加或移除集合元素的好处，就像在第五天讨论的那样。
    |'
- en: '| `HashTable` | `HashTable` is nothing but a representation of collections
    of a key-value-pair and are organized on the basis of a key, which is nothing
    more than a hash code. The use of `HashTable` is advisable when we need to access
    data on the basis of a key.We can declare `HashTable` as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '| `HashTable` | `HashTable`只是键值对集合的表示，并且根据键进行组织，键实际上就是哈希码。当我们需要根据键访问数据时，建议使用`HashTable`。我们可以这样声明`HashTable`：'
- en: '`Hashtable hashtable = new Hashtable();` | `HashTable` is very useful when
    we need to access elements with the use of a key. In such scenarios, we have a
    key and need to find values in the collection on the basis of a key. |'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hashtable hashtable = new Hashtable();` | 当我们需要使用键访问元素时，`HashTable`非常有用。在这种情况下，我们有一个键，需要根据键在集合中找到值。
    |'
- en: '| `SortedList` | The `SortedList` class is nothing but a representation of
    collections of a key-value-pair and are organized on the basis of a key and are
    sorted by key. `SortedList` classes are a combination of `ArrayList` and `HashTable`.
    So, we can access the elements using the key or the index.We can declare `SortedList`
    as follows: `SortedList sortedList = new SortedList();` | As stated, a sorted
    list is a combination of an array and a hash table.Items can be accessed using
    a key or an index. This is `ArrayList` when items are accessed using an index;
    on the other hand, it is `HashTable` when items are accessed using a hash key.
    The main thing in `SortedList` is that the collection of items is always sorted
    by the key value. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `SortedList` | `SortedList`类只是键值对集合的表示，并且根据键进行组织并按键排序。`SortedList`类是`ArrayList`和`HashTable`的组合。因此，我们可以使用键或索引访问元素。我们可以这样声明`SortedList`：`SortedList
    sortedList = new SortedList();` | 如所述，排序列表是数组和哈希表的组合。可以使用键或索引访问项目。当使用索引访问项目时，它是`ArrayList`；另一方面，当使用哈希键访问项目时，它是`HashTable`。`SortedList`的主要特点是项目的集合始终按键值排序。
    |'
- en: '| `Stack` | Stack represents a collection of objects; the objects are accessible
    in the order of **Last In First Out** (**LIFO**).It contains two main operations:
    push and pop. Whenever we insert an item to the list, it is called pushing, and
    when we extract/remove an item from the list, it is called popping. When we get
    an object without removing the item from the list, it is called peeking.We can
    declare it as follows: `Stack stackList = new Stack();` | This is important to
    use when items that were inserted last need to be retrieved first. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `Stack` | 栈表示对象的集合；对象按照**后进先出**（**LIFO**）的顺序可访问。它包含两个主要操作：push和pop。每当我们向列表中插入一个项目时，称为push，当我们从列表中提取/移除一个项目时，称为pop。当我们从列表中获取一个对象而不移除该项目时，称为peeking。我们可以这样声明它：`Stack
    stackList = new Stack();` | 当需要首先检索插入的项目时，这是很重要的。 |'
- en: '| `Queue` | Queue represents a **First In First Out**(**FIFO**) collection
    of objects.There are two main actions in queue--adding an item is called enqueue
    and removing an item is called deque.We can declare a Queue as follows: `Queue
    queue = new Queue();` | This is important when items that were inserted first
    need to be retrieved first. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `Queue` | 队列代表一个**先进先出**（FIFO）的对象集合。队列中有两个主要的操作--添加一个项目称为入队，移除一个项目称为出队。我们可以声明一个队列如下：`Queue
    queue = new Queue();` | 当需要首先检索插入的项目时，这一点很重要。'
- en: '| `BitArray` | `BitArray` is nothing but an array that manages an array of
    bit values. These values are represented as Boolean. True means *ON* (1) and False
    means *OFF*(0).We can declare `BitArray` as follows: `BitArray bitArray = new
    BitArray(8);` | This non-generic collection class is important when we need to
    store the bits. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `BitArray` | `BitArray`只是一个管理位值数组的数组。这些值被表示为布尔值。True表示*ON*（1），False表示*OFF*（0）。我们可以这样声明`BitArray`：`BitArray
    bitArray = new BitArray(8);` | 当我们需要存储位时，这个非泛型的集合类很重要。'
- en: The preceding table only shows non-generic collection classes. With the use
    of generics, we can also implement generic collection classes by taking the help
    of the `System.Collections` namespace. In the coming sections, we will discuss
    generic collection classes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的表只显示了非泛型的集合类。借助泛型，我们还可以通过使用`System.Collections`命名空间来实现泛型集合类。在接下来的部分，我们将讨论泛型集合类。
- en: Performance - BitArray versus boolArray
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能 - BitArray与boolArray
- en: In the previous table, we discussed that `BitArray` is just an array that manages
    true or false values (*0* or *1*). But internally, `BitArray` performed round
    eight per element for a Byte and undergoes in various logical operations and need
    more CPU cycles. On the other hand, a `boolArray` (`bool[]`) stores each element
    as 1-byte, so it takes more memory but requires fewer CPU cycles. `BitArray` over
    `bool[]` is memory optimizer.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表中，我们讨论了`BitArray`只是一个管理true或false值（*0*或*1*）的数组。但在内部，`BitArray`对每个元素执行了大约8次的Byte操作，并进行了各种逻辑操作，需要更多的CPU周期。另一方面，`boolArray`（`bool[]`）将每个元素存储为1字节，因此它占用更多的内存，但需要更少的CPU周期。`BitArray`优于`bool[]`是内存优化器。
- en: 'Let''s consider the following performance test and see how `BitArray` performs:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下性能测试，并看看`BitArray`的表现如何：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On my machine, `BitArrayTest` took six seconds and `BoolArrayTest` took 15 seconds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的机器上，`BitArrayTest`花费了6秒，而`BoolArrayTest`花费了15秒。
- en: From the preceding tests we can conclude that bool arrays consume eight times
    the size/space that could represent the values. In simpler words, bool arrays
    require 1 byte per element.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的测试中，我们可以得出结论，布尔数组占用了可以表示这些值的8倍大小/空间。简单来说，布尔数组需要每个元素1字节的空间。
- en: Understanding generics and their usage
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解泛型及其用法
- en: 'In simple words, with the help of generics, we can create or write code for
    a class that is meant to accept different data types for which it is written.
    Let''s say if a generic class is written in a way to accept a structure, then
    it will accept int, string, or custom structures. This class is also known as
    a generic class. This works more magically when it allows us to define the data
    type when we declare an instance of this generic class. Let''s study the following
    code snippet, where we define a generic class and provide data types on the creation
    of its instance:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话来说，借助泛型，我们可以创建或编写一个类的代码，该类旨在接受为其编写的不同数据类型。比如说，如果一个泛型类被编写成接受一个结构，那么它将接受int、string或自定义结构。这个类也被称为泛型类。当我们声明这个泛型类的实例时，它更加神奇地允许我们定义数据类型。让我们来学习下面的代码片段，我们在其中定义了一个泛型类，并在创建其实例时提供了数据类型：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get the following output after running the preceding code snippet:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的代码片段后，我们将得到以下输出：
- en: '![](img/00085.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: 'We can create a generic list to a strongly typed list, which can accept types
    other than `Person`. For this, we just need to create a list like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个泛型列表到一个强类型的列表，它可以接受`Person`以外的类型。为此，我们只需要创建一个这样的列表：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Collections and generics
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合和泛型
- en: On day two, you learned about arrays of a fixed size. You can use fixed-size
    arrays for strongly typed list objects. But what if we want to use or organize
    these objects into other data structures, such as queue, list, stack, and so on?
    We can achieve all these with the use of collections (`System.Collections`).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，你学习了固定大小的数组。你可以使用固定大小的数组来创建强类型的列表对象。但是，如果我们想要将这些对象用或组织到其他数据结构中，比如队列、列表、栈等，该怎么办？我们可以通过使用集合（`System.Collections`）来实现所有这些。
- en: '`System.Collections` ([https://www.nuget.org/packages/System.Collections/](https://www.nuget.org/packages/System.Collections/)
    ) is a NuGet package that provides all the generic types, and the following are
    the frequently used types:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections` ([https://www.nuget.org/packages/System.Collections/](https://www.nuget.org/packages/System.Collections/)
    )是一个NuGet包，提供了所有泛型类型，以下是经常使用的类型：'
- en: '| **Generic collection types** | **Description** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **泛型集合类型** | **描述** |'
- en: '| `System.Collections.Generic.List<T>` | A strongly typed generic list |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.List<T>` | 一个强类型的泛型列表 |'
- en: '| `System.Collections.Generic.Dictionary<TKey, TValue>` | A strongly typed
    generic dictionary with a key-value pair |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.Dictionary<TKey, TValue>` | 一个带有键值对的强类型泛型字典 |'
- en: '| `System.Collections.Generic.Queue<T>` | A generic `Queue` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.Queue<T>` | 一个泛型`Queue` |'
- en: '| `System.Collections.Generic.Stack<T>` | A generic `Stack` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.Stack<T>` | 一个泛型`Stack` |'
- en: '| `System.Collections.Generic.HashSet<T>` | A generic `HashSet` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.HashSet<T>` | 一个泛型`HashSet` |'
- en: '| `System.Collections.Generic.LinkedList<T>` | A generic `LinkedList` |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.LinkedList<T>` | 一个泛型`LinkedList` |'
- en: '| `System.Collections.Generic.SortedDictionary<TKey, TValue>` | A generic `SortedDictionary`
    with a key-value pair collection and sorted on key. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `System.Collections.Generic.SortedDictionary<TKey, TValue>` | 一个带有键值对集合并按键排序的泛型`SortedDictionary`。
    |'
- en: The preceding table is just an overview of generic classes of the `System.Collections.Generics`
    namespace. In the coming sections, we will discuss generic collections in detail
    with the help of code examples.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格只是`System.Collections.Generics`命名空间的泛型类的概述。在接下来的部分中，我们将通过代码示例详细讨论泛型集合。
- en: For a complete list of classes, structures, and interfaces of the `System.Collections.Generics`
    namespace, visit the official documentations link at [https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`System.Collections.Generics`命名空间的完整类、结构和接口列表，请访问官方文档链接[https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic?view=netcore-2.0)。
- en: Why should we use generics?
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们为什么要使用泛型？
- en: 'For non-generic lists, we use collections from the universal base of the object
    type [[https://docs.microsoft.com/en-us/dotnet/api/system.object](https://docs.microsoft.com/en-us/dotnet/api/system.object)],
    which is not type-safe at compile time. Let''s assume that we are using a non-generic
    collection of `ArrayList;` see the following code snippet for more details:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非泛型列表，我们使用来自对象类型的通用基类的集合[[https://docs.microsoft.com/en-us/dotnet/api/system.object](https://docs.microsoft.com/en-us/dotnet/api/system.object)]，这在编译时不是类型安全的。假设我们正在使用一个`ArrayList`的非泛型集合；请参考以下代码片段以了解更多详情：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have an `ArrayList` with string values. Here, we have the age as a
    string which actually should be int. Let''s take another ArrayList, which has
    the age as an int:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个包含字符串值的`ArrayList`。在这里，我们将年龄作为字符串，实际上应该是int。让我们再拿一个ArrayList，其中年龄是int：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, our code compiles, but it will throw an exception of typecast
    at runtime. So, our `ArrayList` does not have compile-time type checking:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们的代码可以编译，但它会在运行时抛出类型转换异常。因此，我们的`ArrayList`没有编译时类型检查：
- en: '![](img/00086.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: After digging through the preceding code, we can easily understand why there
    is no error at compile time; this is because, `ArrayList` accepts any type (both
    value and reference) and then casts it to a universal base type of .NET, which
    is nothing but object. But when we run the code at that time, it requires the
    actual type, for example, if it is defined as string, then it should be of the
    string type at runtime and not of the object type. Hence, we get a runtime exception.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看上述代码，我们可以很容易地理解为什么在编译时没有错误；这是因为`ArrayList`接受任何类型（值和引用），然后将其转换为.NET的通用基本类型，即对象。但是当我们运行代码时，它需要实际类型，例如，如果它被定义为字符串，那么在运行时它应该是字符串类型而不是对象类型。因此，我们会得到运行时异常。
- en: The activity of casting, boxing, and unboxing of an object in `ArrayList` hits
    the performance, and it depends upon the size of `ArrayList` and how large the
    data that you're iterating through is.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ArrayList`中对象的转换、装箱和拆箱活动会影响性能，这取决于`ArrayList`的大小以及您正在迭代的数据有多大。
- en: 'With the help of the preceding code example, we came to know two drawbacks
    of a non-generic `ArrayList`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述代码示例，我们知道了非泛型`ArrayList`的两个缺点：
- en: It is not compile-time type-safe.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不是编译时类型安全的。
- en: Impacts the performance while dealing with large data.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在处理大数据时会影响性能。
- en: '`ArrayList` casts everything to object, so there is no way to stop adding any
    type of items at compile time. For example, in the preceding code snippet, we
    can enter int and/or string type items.'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ArrayList`将所有内容转换为对象，因此无法在编译时阻止添加任何类型的项目。例如，在上述代码片段中，我们可以输入int和/或字符串类型的项目。'
- en: 'To overcome such issues/drawbacks, we have generic collections, which prevent
    us from supplying anything other than the expected type. Consider the following
    code snippet:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题/缺点，我们有通用集合，它们阻止我们提供除了预期类型之外的任何内容。考虑以下代码片段：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have a `List`, which is defined to get only string type items. So, we can
    add only string type values here. Now consider the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`List`，它被定义为只获取字符串类型的项目。因此，我们只能在这里添加字符串类型的值。现在考虑以下内容：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we''re trying to supply an item of the int type (remember that we did
    the same thing in the case of `ArrayList`). Now, we get a compile-time error that
    is related to casting, so a generic list that is defined to accept only string
    type items has the capability to stop the client from entering items of any type
    other than string. If we hover the mouse on the `43`, it shows the complete error;
    refer to the following image:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们试图提供一个int类型的项目（记住我们在`ArrayList`的情况下也做了同样的事情）。现在，我们得到了一个与转换相关的编译时错误，因此，一个定义为只接受字符串类型项目的泛型列表具有阻止客户端输入除字符串以外的任何类型项目的能力。如果我们将鼠标悬停在`43`上，它会显示完整的错误；请参考以下图片：
- en: '![](img/00087.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: 'In the preceding code snippet, we resolved our one problem by declaring a list
    of string, which only allows us to enter string values, so in the case of authors,
    we can only enter author names but not author age. You may be thinking that if
    we need another list of type int that provides us a way to enter the author''s
    age, that is, if we need a separate list for a new type, then why should we use
    generic collections? At the moment, we need only two items--name and age--so we
    are creating two different lists of the string and int type on this node. If we
    need another item of a different type, then will we be going for another new list.
    This is the time when we have things of multiple types, such as string, int, decimal,
    and so on. We can create our own types. Consider the following declaration of
    a generic list:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们通过声明一个字符串列表解决了一个问题，它只允许我们输入字符串值，因此在作者的情况下，我们只能输入作者的姓名而不是作者的年龄。您可能会认为，如果我们需要另一个类型为int的列表，它可以让我们输入作者的年龄，那么为什么我们要使用泛型集合？目前，我们只需要两个项目--姓名和年龄--因此我们在此节点上创建了两个不同类型的列表，一个是字符串类型，一个是int类型。如果我们需要另一种类型的项目，那么我们会再创建一个新的列表。这是当我们有多种类型的事物时，例如字符串、int、decimal等。我们可以创建我们自己的类型。考虑以下泛型列表的声明：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have a `List` of type `Person`. This generic list will allow all types of
    items that are defined in this type. The following is our `Person` class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个`Person`类型的`List`。这个泛型列表将允许所有在这个类型中定义的项目。以下是我们的`Person`类：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our `Person` class contains three properties, two of type string and one is
    of type int. Here, we have a complete solution for the problems we discussed in
    the previous section. With the help of this List, which is of the `Person` type,
    we can enter an item of the string and/or int type. The following code snippet
    shows this in action:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Person`类包含三个属性，两个是字符串类型，一个是整数类型。在这里，我们有了解决前一节中讨论的问题的完整解决方案。借助于这个`Person`类型的`List`，我们可以输入字符串和/或整数类型的项目。以下代码片段展示了这一点：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After running this code, the following will be our output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，我们的输出将如下所示：
- en: '![](img/00088.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.jpeg)'
- en: Our `List` of the `Person` type will be more performant than `ArrayList`, as
    in our generic class, there is not implicit typecast to object; the items are
    rather of their expected types.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Person`类型的`List`将比`ArrayList`更高效，因为在我们的泛型类中，没有隐式类型转换为对象；项目实际上是它们期望的类型。
- en: Discussing constraints
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论约束
- en: 'In the previous section, we discussed how a `List` of the `Person` type accepts
    all the items of their defined types. In our example code, we only use the string
    and int data types, but in generics, you can use any data type, including int,
    float, double, and so on. On the other hand, there may be scenarios where we want
    to restrict our use to a few data types or only a specific data type in generics.
    To achieve this, there are generic constraints. Consider the following code snippet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了`Person`类型的`List`如何接受其定义类型的所有项目。在我们的示例代码中，我们只使用了字符串和整数数据类型，但在泛型中，您可以使用任何数据类型，包括整数、浮点数、双精度等。另一方面，可能存在一些情况，我们希望在泛型中将我们的使用限制在少数数据类型或特定数据类型。为了实现这一点，有泛型约束。考虑以下代码片段：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, our class is a generic class. GenericConstraint, of type `T`, which is
    nothing but a reference type; hence, we created this class to accept only the
    reference type. No value type will be accepted by this class. This class has an
    `ImplementIt` method, which accepts a parameter of type `T` and returns a value
    of type `T`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的类是一个泛型类。GenericConstraint，类型为`T`，实际上是一个引用类型；因此，我们创建了这个类来仅接受引用类型。这个类有一个`ImplementIt`方法，它接受一个`T`类型的参数，并返回一个`T`类型的值。
- en: Check [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters)
    to know more about Generic Type Parameter Guidelines.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-type-parameters)以了解有关泛型类型参数指南的更多信息。
- en: 'The following declarations are valid as these are of the reference types:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明是有效的，因为这些是引用类型：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is an invalid declaration, as this is of the value type, which
    is not meant for the current generic class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个无效声明，因为这是值类型，不适用于当前的泛型类：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On day two, we learned that int is a value type and not a reference type. The
    preceding declaration gives a compile-time error. In Visual Studio, you will see
    the following error:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第二天，我们学到int是一个值类型，而不是引用类型。前面的声明会导致编译时错误。在Visual Studio中，您将看到以下错误：
- en: '![](img/00089.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00089.jpeg)'
- en: So, with the help of generic constraints, we restrict our class to not accept
    any types other than reference types.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，借助泛型约束，我们限制了我们的类不接受除引用类型之外的任何类型。
- en: '**Constraints** are basically an act by which you safeguard your generic class
    to prevent the client from using any other type while the class is instantiated.
    It results in a compile-time error if the client code tries to provide a type
    that is not allowed. The contextual where keyword helps us in defining constraints.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**约束**基本上是一种行为，通过它您可以保护您的泛型类，防止客户端在实例化类时使用任何其他类型。如果客户端代码尝试提供不允许的类型，这将导致编译时错误。上下文关键字`where`帮助我们定义约束。'
- en: 'In the real world, you can define various type of constraints and these would
    restrict client code to create any unwanted situation. Let''s discuss these types
    with examples:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，您可以定义各种类型的约束，这些约束将限制客户端代码创建任何不需要的情况。让我们通过示例讨论这些类型：
- en: The value type
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: 'This constraint is defined with the contextual keyword, `where T: struct`.
    With this constraint, the client''s code should contain an argument of the value
    type; here, any value except Nullable can be specified.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '此约束是使用上下文关键字`where T: struct`定义的。有了这个约束，客户端的代码应该包含一个值类型的参数；在这里，除了Nullable之外的任何值都可以指定。'
- en: '**Example**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following is a code snippet declaring a generic class with a value type
    constraint:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是声明带有值类型约束的泛型类的代码片段：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Usage**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'The following is a code snippet that describes the client code of a generic
    class declared with a value type constraint:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述带有值类型约束的泛型类的客户端代码的代码片段：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The reference type
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: This constraint is defined with the contextual keyword, `where T:class`. Using
    this constraint, the client code is bound to not provide any types other than
    reference types. Valid types are class, interface, delegate, and array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此约束是使用上下文关键字`where T:class`定义的。使用这个约束，客户端代码被限制不能提供除引用类型之外的任何类型。有效类型包括类、接口、委托和数组。
- en: '**Example**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following code snippet declares a generic class with a reference type constraint:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个带有引用类型约束的泛型类：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Usage**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'The following code snippet describes the client code of a generic class declared
    with a reference type constraint:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了带有引用类型约束的泛型类的客户端代码：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The default constructor
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: 'This constraint is defined with the contextual keyword, `where T: new()`, and
    it restricts generic type parameters from defining default constructors. It is
    also compulsory that an argument of type `T` must have a public parameterless
    constructor. The `new()` constraint must be specified in the end, when used with
    other constraints.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '这个约束是用上下文关键字`where T: new()`定义的，它限制了泛型类型参数不能定义默认构造函数。还有一个必须的条件是类型`T`的参数必须有一个公共的无参数构造函数。当与其他约束一起使用时，`new()`约束必须在最后指定。'
- en: '**Example**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following code snippet declares a generic class with a default constructor
    constraint:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个带有默认构造函数约束的通用类：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**Usage**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'The following code snippet describes the client code of a generic class declared
    with a default constructor constraint:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了带有默认构造函数约束的通用类的客户端代码：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The base class constraint
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基类约束
- en: 'This constraint is defined with the contextual keyword, `where T: <BaseClass>`.
    This constraint restricts all the client code where the supplied arguments are
    not of, or not derived from, the specified base class.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '这个约束是用上下文关键字`where T: <BaseClass>`定义的。这个约束限制了所有客户端代码，其中提供的参数不是指定基类的或不是派生自指定基类的。'
- en: '**Example**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following code snippet declares a generic class with the base class constraint:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个带有基类约束的通用类：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '**Usage**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'The following is a code snippet describes the client code of a generic class
    declared with a base class constraint:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码片段，描述了带有基类约束的通用类的客户端代码：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The interface constraint
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口约束
- en: This constraint is defined with the contextual keyword, `where T:<interface
    name>`. The client code must supply a parameter of the type that implements the
    specified parameter. There may be multiple interfaces defined in this constraint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个约束是用上下文关键字`where T:<interface name>`定义的。客户端代码必须提供一个实现指定参数的类型的参数。在这个约束中可能定义多个接口。
- en: '**Example**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following code snippet declares a generic class with an interface constraint:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段声明了一个带有接口约束的通用类：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Usage**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**用法**'
- en: 'The following code snippet describes the client code of a generic class declared
    with the interface constraint:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了带有接口约束的通用类的客户端代码：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, we discussed generics and collections, including the various
    types of generics, and we also mentioned why we should use generics.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了泛型和集合，包括各种类型的泛型，我们还提到了为什么应该使用泛型。
- en: For more details on generics, visit the official documentation at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关泛型的更多详细信息，请访问官方文档[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/)。
- en: Beautifying code using attributes
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性美化代码
- en: 'Attributes provide a way to associate information with code. This information
    could be as simple as a message/warning or can contain a complex operation or
    code itself. These are declared simply with the help of tags. These also help
    us to beautify our code by supplying inbuilt or custom attributes. Consider the
    following code:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 属性提供了一种将信息与代码关联起来的方式。这些信息可以是简单的消息/警告，也可以包含复杂的操作或代码本身。这些只需用标签声明即可。这些还可以通过提供内置或自定义属性来美化我们的代码。考虑以下代码：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this method, we show an informational message to notify the peer. The preceding
    method will be decorated with the help of an attribute. Consider the following
    code:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种方法中，我们显示一个信息消息来通知对等方。前面的方法将通过属性的帮助进行装饰。考虑以下代码：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we can see that we just decorated our method with the help of an attribute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以看到我们只是用属性装饰了我们的方法。
- en: According to the official documentation [[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes)],
    attributes provide a way of associating information with code in a declarative
    way. They can also provide a reusable element that can be applied to a variety
    of targets.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档[[https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes](https://docs.microsoft.com/en-us/dotnet/csharp/tutorials/attributes)]，属性提供了一种以声明方式将信息与代码关联起来的方式。它们还可以提供一个可重用的元素，可以应用于各种目标。
- en: 'Attributes can be used for the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 属性可以用于以下目的：
- en: To add meta data information
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加元数据信息
- en: To add comments, description, compiler instructions, and so on
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加注释、描述、编译器指令等
- en: In the coming sections, we will discuss attributes in detail, with code examples.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将详细讨论属性，包括代码示例。
- en: Types of attributes
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性的类型
- en: In the previous section, we discussed attributes, which help us to decorate
    and beautify our code. In this section, we will discuss the various types of attributes
    in detail.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，我们讨论了属性，这些属性帮助我们装饰和美化我们的代码。在本节中，我们将详细讨论各种类型的属性。
- en: AttributeUsage
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AttributeUsage
- en: 'This is a pre-defined attribute in a framework. This restricts the usage of
    attributes; in other words, it tells the type of items on which an attribute can
    be used, also known as attribute targets. These can be all or one of the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在框架中预定义的属性。它限制了属性的使用；换句话说，它告诉属性可以用于哪种类型的项目，也就是属性目标。这些可以是以下中的所有或一个：
- en: Assembly
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序集
- en: Class
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Constructor
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Delegate
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托
- en: Enum
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Event
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件
- en: Field
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段
- en: GenericParameter
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GenericParameter
- en: Interface
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Method
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Module
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块
- en: Parameter
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数
- en: Property
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: ReturnValue
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值
- en: Struct
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构
- en: By default, attributes are of any type of targets, unless you specify explicitly.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，属性可以是任何类型的目标，除非你明确指定。
- en: '**Example**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'The following attribute is created to be used only for a class:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下属性被创建用于仅用于类：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In preceding code, we defined attributes for the only use with class. If you
    try to use this attribute to other than class, then it will give you a compile-time
    error. See the following image, which shows an error for an attribute on method
    that is actually written solely for a class:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们为类的唯一使用定义了属性。如果您尝试将此属性用于类以外的其他内容，则会收到编译时错误。请参阅以下图像，显示了一个为方法上的属性显示错误的图像，实际上该属性仅用于类：
- en: '![](img/00090.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.jpeg)'
- en: Obsolete
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过时
- en: There may be circumstances when you want to raise a warning for a specific code
    so that it is conveyed on the client side. The `Obsolete` attribute is a predefined
    attribute that does the same and warns the calling user that a specific part is
    `obsolete`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望为特定代码引发警告，以便在客户端传达。`Obsolete`属性是一个预定义属性，执行相同的操作并警告调用用户特定部分已经`过时`。
- en: '**Example**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following image shows a warning message saying not to use the `Author`
    class, as it is `Obsolete`. But the client can still compile and run the code
    (we did not ask this attribute to throw error on usage):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了一个警告消息，表示不要使用`Author`类，因为它是`Obsolete`。但是客户端仍然可以编译和运行代码（我们没有要求此属性在使用时抛出错误）：
- en: '![](img/00091.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.jpeg)'
- en: 'The following will throw an error message on usage along with the warning message:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将在使用时显示错误消息以及警告消息：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Consider the following image, where the user gets an exception after using
    the attribute, which is written to throw an error on usage:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下图像，用户在使用属性后出现异常，该属性被写入以在使用时抛出错误：
- en: '![](img/00092.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.jpeg)'
- en: Conditional
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件
- en: The conditional attribute that is a predefined attribute, restricts the execution
    on the basis of condition applied to the code that is being processed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 条件属性是一个预定义属性，根据应用于正在处理的代码的条件限制执行。
- en: '**Example**'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例**'
- en: 'Consider the following code snippet, which restricts the conditional execution
    of a method for a defined debug preprocessor (we will discuss preprocessors in
    detail in the coming section):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，它限制了在定义的调试预处理器下方法的条件执行（我们将在接下来的部分详细讨论预处理器）：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Remember one thing while defining preprocessor symbols; you define it on the
    very first line of the file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义预处理器符号时，请记住一件事；您要在文件的第一行上定义它。
- en: Creating and implementing a custom attribute
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和实现自定义属性
- en: In the previous section, we discussed the available or predefined attributes
    and we noticed that these are very limited, and in a real-world application, our
    requirements will demand more complex attributes. In such a case, we can create
    our own custom attributes; these attributes are similar to predefined attributes
    but with our custom operational code and target types. All custom attributes should
    be inherited from the `System.Attribute` class.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了可用的或预定义的属性，并注意到这些属性非常有限，在实际应用中，我们的需求将需要更复杂的属性。在这种情况下，我们可以创建自己的自定义属性；这些属性类似于预定义属性，但具有我们自定义的操作代码和目标类型。所有自定义属性都应继承自`System.Attribute`类。
- en: 'In this section, we will create a simple custom attribute as per the following
    requirements:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将根据以下要求创建一个简单的自定义属性：
- en: Create an `ErrorLogger` attribute
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`ErrorLogger`属性
- en: This attribute will handle all the available environments, that is, debug, development,
    production, and so on
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此属性将处理所有可用的环境，即调试、开发、生产等
- en: This method should be restricted only for methods
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法应仅限于方法
- en: It should show custom or supplied exception/exception messages
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该显示自定义或提供的异常/异常消息
- en: By default, it should consider the environment as `DEBUG`
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，它应将环境视为`DEBUG`
- en: It should show and throw exceptions if decorated for the development and `DEBUG`
    environment
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果为开发和`DEBUG`环境装饰，则应显示并抛出异常
- en: Prerequisites
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'To create and run custom attributes, we should have the following prerequisites:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建和运行自定义属性，我们应该具备以下先决条件：
- en: Visual Studio 2017 or later
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 2017或更高版本
- en: .NET Core 1.1 or later
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core 1.1或更高版本
- en: 'Here is the code snippet that creates our expected attribute:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建我们期望的属性的代码片段：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we simply write to console whatever exceptions are supplied
    from the client code. In the case of the `DEBUG` or `Dev` environment, the exception
    is thrown further.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只是向控制台写入客户端代码提供的任何异常。在`DEBUG`或`Dev`环境的情况下，进一步抛出异常。
- en: 'The following code snippet shows the simple usage of this attribute:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了此属性的简单用法：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the preceding code, we have different methods that are marked for different
    environments. Out attributes will trigger and write the exceptions supplied for
    individual methods.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们有不同的方法，标记为不同的环境。我们的属性将触发并编写为各个方法提供的异常。
- en: Leveraging preprocessor directives
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用预处理器指令
- en: As is clear from the name, preprocessor directives are the processes undertaken
    before the actual compilation starts. In other words, these preprocessors give
    instructions to the compiler to preprocess the information, and this works before
    the compiler compiles the code.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 从名称上可以清楚地看出，预处理器指令是在实际编译开始之前进行的处理过程。换句话说，这些预处理器向编译器发出指令，对信息进行预处理，这是在编译器编译代码之前进行的。
- en: Important points
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重要点
- en: 'There are the following points to note for preprocessors while you''re working
    with them:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用预处理器时，请注意以下几点：
- en: Preprocessor directives are actually conditions for the compiler
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器指令实际上是编译器的条件
- en: Preprocessor directives must start with the `#` symbol
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器指令必须以`#`符号开头
- en: Preprocessor directives should not be terminated with a semi colon (`;`) like
    a statement terminates
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器指令不应以分号（`;`）结尾，就像语句结束一样
- en: Preprocessors are not used to create macros
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器不用于创建宏
- en: Preprocessors should be declared line by line
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预处理器应逐行声明
- en: Preprocessor directives in action
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预处理器指令的作用
- en: 'Consider the following preprocessor directive:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下预处理器指令：
- en: '[PRE36]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This directive is a conditional directive, code executes whenever this directive
    is applied to the code, you can also use `#elseif` and/or `#else` directives.
    As this is a conditional directive and `#if` condition in C# is Boolean, these
    operators can be applied to check equality (`==`) and inequality (`!=`), and between
    multiple symbols, and (`&&`), or (`||`), and not (`!`) operators could also be
    applied to evaluate the condition.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个指令是一个条件指令，当这个指令应用到代码时，代码会执行，你也可以使用`#elseif`和/或`#else`指令。由于这是一个条件指令，C#中的`#if`条件是布尔值，这些运算符可以用来检查相等（`==`）和不相等（`!=`），以及多个符号之间的关系，以及（`&&`），或（`||`），和非（`!`）运算符也可以用来评估条件。
- en: You should define a symbol on the very first line of the file where it is being
    applied with the use of `#define`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在文件的第一行上定义一个符号，使用`#define`指令。
- en: 'Consider the following code snippet, which lets us know the conditional compilation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，它让我们了解条件编译：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![](img/00093.jpeg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.jpeg)'
- en: '**#define and #undef**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**#define和#undef**'
- en: The `#define` directive basically defines a symbol for us that would be used
    in a conditional pre-processor directive.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define`指令基本上为我们定义了一个将在条件预处理器指令中使用的符号。'
- en: '`#define` cannot be used to declare constant values.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`#define`不能用于声明常量值。'
- en: 'The following should be kept in mind while declaring a symbol with the use
    of `#define`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`#define`声明符号时应该记住以下几点：
- en: It cannot be used to declare constant
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不能用于声明常量
- en: It can define a symbol but cannot assign a value to these symbols
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以定义一个符号，但不能为这些符号赋值
- en: Any instructions on the symbol should come after its definition of the symbol
    in the file that means `#define` directive always come before its usage
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对符号的任何指令都应该在文件中定义符号之后，这意味着`#define`指令总是在使用之前出现
- en: Scope of the symbol defined or created with the help of `#define` directive
    is within the file where it is declared/defined
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`#define`指令定义或创建的符号的作用域在它被声明/定义的文件中
- en: 'Recall the code example we discussed in the `#if` directive where we defined
    two symbols. So, it''s very easy to define a symbol like: `#define DEBUG`.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们在`#if`指令中讨论的代码示例，我们在那里定义了两个符号。所以，定义一个符号很容易，比如：`#define DEBUG`。
- en: 'The `#undef` directive lets us undefine the earlier defined symbol. This pre-processor
    should come before any non-directive statement. Consider the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`#undef`指令让我们取消之前定义的符号。这个预处理器应该出现在任何非指令语句之前。考虑以下代码：'
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding code, we are undefining the `DEBUG` symbol and the code will
    produce the following output:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们取消了`DEBUG`符号，代码将产生以下输出：
- en: '![](img/00094.jpeg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: '**The #region and #endregion directives**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**#region和#endregion指令**'
- en: 'These directives are very helpful while working with long code-based files.
    Sometimes, while we are working on a long code base, let''s say, an enterprise
    application, this kind of application will have 1000 lines of code and these lines
    will be part of different functions/methods or business logics. So, for better
    readability, we can manage these sections within the region. In a region, we can
    name and give short descriptions of the code that the region holds. Let''s consider
    the following image:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理长代码文件时，这些指令非常有用。有时候，当我们在处理一个长代码库时，比如一个企业应用，这种应用会有1000行代码，并且这些行会是不同函数/方法或业务逻辑的一部分。因此，为了更好地可读性，我们可以在区域内管理这些部分。在一个区域中，我们可以为区域包含的代码命名并给出简短的描述。让我们看一下以下图像：
- en: '![](img/00095.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: In the preceding image, the left-hand side portion shows the expanded view of
    the `#region` ... `#endregion` directives, which tells us how we can apply these
    directives to our long code base files. The right-hand side of the image shows
    the collapsed view, and when you hover the mouse on the collapsed region text,
    you can see that a rectangular block appears in Visual Studio, which says what
    all these regions contain. So, you need not expand the region to check what code
    is written under this region.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图像中，左侧部分显示了`#region`...`#endregion`指令的扩展视图，告诉我们如何将这些指令应用到我们的长代码文件中。图像的右侧显示了折叠视图，当你将鼠标悬停在折叠区域文本上时，你会看到在Visual
    Studio中出现了一个矩形块，它显示了这些区域包含的内容。因此，你无需展开区域来检查这个区域下写了什么代码。
- en: '**The #line directive**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**#line指令**'
- en: The `#line` directive provides a way to modify the actual line number of compilers.
    You can also provide the output `FileName` for errors and warnings, which is optional.
    This directive may be useful in automated intermediate steps in the build process.
    In scenarios where the line numbers have been removed from the original source
    code, however you would require to generate the output based on the original file
    with numbering.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`#line`指令提供了一种修改编译器实际行号的方式。你还可以为错误和警告提供输出`FileName`，这是可选的。这个指令在构建过程中的自动化中可能会有用。在原始源代码中删除了行号的情况下，你需要基于原始文件生成输出。'
- en: Additionally, the `#line` default directive returns the line numbering to its
    default value, and it counts a line where it was renumbered earlier.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`#line`默认指令将行号返回到默认值，并且它会计算之前重新编号的行。
- en: The `#line` hidden directive does not affect the filename or line numbers in
    error reporting.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`#line`隐藏指令不会影响错误报告中的文件名或行号。'
- en: The `#line` filename directive profiles a way to name a file you want to appear
    in the compiler output. In this, the default value is the actual filename in use;
    you can provide a new name in double quotes, and this must be preceded by the
    line number.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`#line`文件名指令定义了一个在编译器输出中想要出现的文件名的方式。在这里，默认值是实际使用的文件名；你可以在双引号中提供一个新的名字，并且这个名字必须在行号之前。'
- en: 'Consider the following code snippet:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE39]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**The #warning directive**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**#warning指令**'
- en: 'The `#warning` directive provides a way to generate a warning in any part of
    code and usually work within the conditional directives. Consider the following
    code snippet:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`#warning`指令提供了一种在代码的任何部分生成警告的方式，并通常在条件指令内工作。考虑以下代码片段：'
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code will warn at compile time, and the warning message will
    be what you provided with the `#warning` directive:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在编译时发出警告，并且警告消息将是您使用`#warning`指令提供的内容：
- en: '![](img/00096.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00096.jpeg)'
- en: '**#error**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**#error**'
- en: 'The `#error` directive provides a way to generate an error in any part of code.
    Consider the following code snippet:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`#error`指令提供了一种在代码的任何部分生成错误的方式。考虑以下代码片段：'
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will throw an error, and due to this error your code will not be built
    properly; it fails the build with the error message that you provided with `#error`
    directive. Let''s have a look at the following image:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发错误，由于这个错误，您的代码将无法正确构建；它将以您使用`#error`指令提供的错误消息失败构建。让我们看一下以下图片：
- en: '![](img/00097.jpeg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00097.jpeg)'
- en: In this section, we discussed all about preprocessor directives and their usage
    with code examples.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了预处理指令及其在代码示例中的使用。
- en: 'For a complete reference of C# preprocessor directives, please refer to the
    official documentation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有关C#预处理指令的完整参考，请参考官方文档：
- en: '[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/preprocessor-directives/)'
- en: Getting started with LINQ
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用LINQ
- en: LINQ is nothing but an acronym of Language Integrated Query that is part of
    programming language. LINQ provides an easy way to write or query data with a
    specified syntax like we would use the where clause when trying to query data
    for some specific criteria. So, we can say that LINQ is a syntax that is used
    to query data.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ只是语言集成查询的缩写，是编程语言的一部分。LINQ提供了一种使用指定语法编写或查询数据的简单方法，就像我们在尝试为某些特定条件查询数据时使用where子句一样。因此，我们可以说LINQ是一种用于查询数据的语法。
- en: 'In this section, we will see a simple example to query data. We have `Person`
    list and the following code snippet provides us a various way to query data:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到一个简单的示例来查询数据。我们有`Person`列表，以下代码片段为我们提供了各种查询数据的方式：
- en: '[PRE42]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![](img/00098.jpeg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00098.jpeg)'
- en: 'Complete discussion of LINQ is beyond the scope of this book. For complete
    LINQ functionality refer to: [https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ的完整讨论超出了本书的范围。有关完整的LINQ功能，请参考：[https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b](https://code.msdn.microsoft.com/101-LINQ-Samples-3fb9811b)
- en: Writing unsafe code
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写不安全代码
- en: 'In this section, we will discuss introduction to how to write unsafe code using
    Visual Studio. Language C# provides a way to write code which compiles and creates
    the objects and these objects under the root are managed by the garbage collector
    [refer to [day 01](part0021.html#K0RQ0-cd07d0bec7404d1cb3fdb41e48e5618f) for more
    details on garbage collector]. In simple words, C# is not like C, C++ language
    which use concept of function pointer to access references. But there is a situation
    when it is necessary to use function-pointers in C# language similar to languages
    that support function-pointers like C or C++ but C# language does not support
    it. To overcome such situations, we have unsafe code in C# language. There is
    modifier unsafe which tells that this code is not controlled by Garbage collector
    and within that block we can use function pointers and other unsafe stuffs. To
    use unsafe code, we first inform compiler to set on unsafe compilation from Visual
    Studio 2017 or later just go to project properties and on Build tab, select the
    option Allow unsafe code, refer following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何使用Visual Studio编写不安全代码的介绍。语言C#提供了一种编写代码的方式，该代码编译并创建对象，这些对象在根下由垃圾收集器管理[有关垃圾收集器的更多详细信息，请参考[第01天](part0021.html#K0RQ0-cd07d0bec7404d1cb3fdb41e48e5618f)]。简而言之，C#不像使用函数指针访问引用的C、C++语言。但是在某些情况下，有必要在C#语言中使用函数指针，类似于支持函数指针的语言如C或C++，但C#语言不支持它。为了克服这种情况，我们在C#语言中有不安全代码。有一个修饰符不安全，告诉编译器这段代码不受垃圾收集器控制，在该块内我们可以使用函数指针和其他不安全的东西。要使用不安全代码，我们首先要求编译器从Visual
    Studio 2017或更高版本开始设置不安全编译，只需转到项目属性，在“生成”选项卡上，选择“允许不安全代码”选项，参考以下截图：
- en: '![](img/00099.jpeg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00099.jpeg)'
- en: 'You would not be able to continue with unsafe code if this option is not selected,
    please refer following screenshot:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未选择此选项，您将无法继续使用不安全代码，请参考以下截图：
- en: '![](img/00100.jpeg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00100.jpeg)'
- en: 'After setting unsafe compilation, let''s write code to swap two numbers using
    pointers, consider the following code snippet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 设置不安全编译后，让我们编写代码使用指针交换两个数字，考虑以下代码片段：
- en: '[PRE43]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Previous is a very simple swap function which is just swapping two numbers
    with the help of pointers. Let''s make a call to this function to see the actual
    results:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 上面是一个非常简单的交换函数，它只是使用指针交换两个数字。让我们调用这个函数来看看实际结果：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the preceding code snippet, we are taking input of two numbers and then
    showing the results before and after swaps, this produces the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们输入了两个数字，然后显示交换前后的结果，这产生了以下输出：
- en: '![](img/00101.jpeg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00101.jpeg)'
- en: In this section, we have discussed how to deal with unsafe code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何处理不安全代码。
- en: 'For more details on unsafe code, refer to official documentations of language
    specifications: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有关不安全代码的更多详细信息，请参考语言规范的官方文档：[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code)
- en: Writing asynchronous code
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写异步代码
- en: 'Before we discuss the code in async way, lets first discuss our normal code
    that is nothing but a synchronous code, let''s consider following code snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论异步方式的代码之前，让我们先讨论一下我们的普通代码，即同步代码，让我们考虑以下代码片段：
- en: '[PRE45]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding code snippet is short and sweet. It tells us it is polling to
    a specific file. Here system has to wait to complete the operation of poling a
    file before it start next. This is what synchronous code is. Now, consider a scenario
    where we need not wait to complete the operation of this function to start another
    operation or function. To meet such scenarios, we have asynchronous coding, this
    is possible with the keyword, async.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段简短而简洁。它告诉我们它正在轮询一个特定的文件。在这里，系统必须等待完成轮询文件的操作，然后才能开始下一个操作。这就是同步代码。现在，考虑一种情况，我们不需要等待完成这个函数的操作就开始另一个操作或函数。为了满足这样的情况，我们有异步编码，这是可能的关键字是async。
- en: 'Consider following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE46]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Just with the help of the `async` keyword our code is able to make asynchronous
    calls.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅通过`async`关键字，我们的代码就能够进行异步调用。
- en: In the view of previous code we can say that asynchronous programming is one
    that let not wait client code to execute another function or operation during
    any async operation. In simple word, we can say that asynchronous code can't hold
    another operation that need to be called.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的代码来看，我们可以说异步编程是一种不让客户端代码等待执行另一个函数或操作的任何异步操作的编程。简单地说，我们可以说异步代码不能阻止需要调用的另一个操作。
- en: 'In this chapter, we discussed asynchronous coding. A complete discussion on
    this topic is beyond the scope of our book. For complete details refer to official
    documentation: [https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了异步编码。关于这个主题的完整讨论超出了我们书的范围。有关完整详情，请参阅官方文档：[https://docs.microsoft.com/en-us/dotnet/csharp/async](https://docs.microsoft.com/en-us/dotnet/csharp/async)
- en: Hands-on exercises
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手练习
- en: 'Define generic classes by creating generic code of `StringCalculator`: [https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建`StringCalculator`的泛型代码来定义泛型类：[https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)
- en: Create a generic and non-generic collection and test which one is better as
    per performance.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个泛型和非泛型集合，并测试哪一个在性能上更好。
- en: We have discussed code snippets in the section-*Why one should use Generics?*
    that tells about run-time compilation exceptions. In this regard, why should we
    not use the same code in the following way?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在“为什么应该使用泛型？”一节中讨论了代码片段，其中讲述了运行时编译异常。在这方面，为什么我们不应该以以下方式使用相同的代码？
- en: '[PRE47]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: What is the use of the `default` keyword in generic code, elaborate with the
    help of a real-world example.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在泛型代码中，“default”关键字的用途是什么，通过一个现实世界的例子加以阐述。
- en: Write simple code by using all 3-types of predefined attributes.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有3种预定义属性编写简单代码。
- en: What is the default restriction type for an attribute? Write a program to showcase
    all restriction types.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性的默认限制类型是什么？编写一个程序来展示所有限制类型。
- en: Create a custom attribute with name - *LogFailuresAttribute* that log all exceptions
    in a text file.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为*LogFailuresAttribute*的自定义属性，用于记录所有异常到文本文件中。
- en: Why pre-processor directive `#define` cannot be used to declare constant values?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么预处理器指令`#define`不能用于声明常量值？
- en: Write a program to create a `List` of `Authors` and apply LINQ functionality
    on it.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来创建一个`作者`的`列表`，并在其上应用LINQ功能。
- en: Write a program to sort an array
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序来对数组进行排序
- en: Write a complete program to write a sync and async methods to write a file.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个完整的程序来编写同步和异步方法来写一个文件。
- en: Revisiting Day 6
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温第6天
- en: Today, we discussed advanced concepts such as generics, attributes, preprocessors,
    LINQ, unsafe code, and asynchronous programming.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们讨论了泛型、属性、预处理器、LINQ、不安全代码和异步编程等高级概念。
- en: Our day started with generics, where you learned about generic classes with
    the help of code snippets. Then, we dived into attributes and learned how to decorate
    our C# code with predefined attributes. We have created one custom attribute and
    used it in our code example. We discussed preprocessor directives with complete
    examples and learned the usage of these directives in our coding. Other concepts
    discussed are LINQ, unsafe code, and asynchronous programming.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的一天从泛型开始，您通过代码片段了解了泛型类。然后，我们深入了解了属性，并学习了如何使用预定义属性装饰我们的C#代码。我们创建了一个自定义属性，并在我们的代码示例中使用了它。我们讨论了预处理器指令，并学习了这些指令在我们编码中的用法。其他讨论的概念包括LINQ、不安全代码和异步编程。
- en: Tomorrow, that is, day seven will be the concluding day of our seven-day learning
    series. We will cover OOP concepts and their implementation in the C# language.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 明天，也就是第七天将是我们七天学习系列的结束日。我们将介绍OOP概念及其在C#语言中的实现。
