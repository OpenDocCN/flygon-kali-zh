- en: Simplifying Testing With Advanced JUnit Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级JUnit功能简化测试
- en: Simplicity is the ultimate sophistication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 简单是终极的复杂。
- en: '- Leonardo da Vinci'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '- 列奥纳多·达·芬奇'
- en: 'So far, we have discovered the basics of Jupiter, the brand-new programming
    model provided by the JUnit 5 framework. Moreover, Jupiter provides a rich range
    of possibilities which allows to create different types of test cases. In this
    chapter, we review these advanced features. To that aim, this chapter is structured
    as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Jupiter的基础知识，这是JUnit 5框架提供的全新编程模型。此外，Jupiter提供了丰富的可能性，可以创建不同类型的测试用例。在本章中，我们将回顾这些高级功能。为此，本章结构如下：
- en: '**Dependency injection**: This section first takes a look at dependency injection
    for constructors and methods in test classes. Then, it reviews the three parameter
    resolvers provided out of the box in Jupiter. These resolvers allow to inject
    objects of `TestInfo`, `RepetitionInfo`, and `TestReporter` inside tests.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖注入**：本节首先介绍了测试类中构造函数和方法的依赖注入。然后，它回顾了Jupiter中提供的三个参数解析器。这些解析器允许在测试中注入`TestInfo`、`RepetitionInfo`和`TestReporter`对象。'
- en: '**Dynamic tests**: This section discusses how dynamic tests are implemented
    in JUnit 5, using the methods `dynamicTest` and `stream`.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态测试**：本节讨论了如何在JUnit 5中实现动态测试，使用`dynamicTest`和`stream`方法。'
- en: '**Test interfaces**: The section reviews the Jupiter annotations that can be
    declared on test interfaces and default methods.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试接口**：本节介绍了可以在测试接口和默认方法上声明的Jupiter注解。'
- en: '**Test templates**: JUnit 5 introduces the concept of a template for tests
    cases. These templates will be invoked multiple times, depending on the invocation
    contexts.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试模板**：JUnit 5引入了测试用例的模板概念。这些模板将根据调用上下文多次调用。'
- en: '**Parameterized tests**: In the same way as JUnit 4, JUnit 5 provides capabilities
    to create tests driven by different input data, that is, a parametrized test.
    We will discover that the support for this kind of test has been significantly
    enhanced in the Jupiter programming model.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数化测试**：与JUnit 4一样，JUnit 5提供了创建由不同输入数据驱动的测试的功能，即参数化测试。我们将发现，对这种测试的支持在Jupiter编程模型中得到了显着增强。'
- en: '**Java 9**: On September 21, 2017, Java 9 released. As we will discover, JUnit
    5 has been implemented to be compatible with Java 9, with special emphasis on
    the modularity feature of Java 9.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java 9**：2017年9月21日，Java 9发布。正如我们将发现的那样，JUnit 5已经实现为与Java 9兼容，特别强调了Java 9的模块化特性。'
- en: Dependency injection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入
- en: In former JUnit versions, test constructors and methods were not allowed to
    have parameters. One of the major changes in JUnit 5 is that both test constructors
    and methods are now allowed to include parameters. This feature enables the dependency
    injection for constructors and methods.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的JUnit版本中，不允许测试构造函数和方法带有参数。JUnit 5的一个主要变化是现在允许测试构造函数和方法都包含参数。这个特性使得构造函数和方法可以进行依赖注入。
- en: As introduced in [Chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What's New In JUnit 5* of this book, the extension model has an extension that
    provides dependency injections for Jupiter tests, called `ParameterResolver`,
    which defines an API for test extensions that wish to dynamically resolve parameters
    at runtime.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本书的[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中介绍的，JUnit
    5的扩展模型具有一个扩展，为Jupiter测试提供依赖注入，称为`ParameterResolver`，它定义了希望在运行时动态解析参数的测试扩展的API。
- en: 'If a test constructor or a method annotated with `@Test,` `@TestFactory`, `@BeforeEach`,
    `@AfterEach`, `@BeforeAll`, or `@AfterAll` accepts a parameter, that parameter
    is resolved at runtime by a resolver (object with parent class `ParameterResolver`).
    There are three built-in resolvers registered automatically in JUnit 5: `TestInfoParameterResolver`,
    and `RepetitionInfoParameterResolver`, `TestReporterParameterResolver`. We review
    each one of these resolvers in this section.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试构造函数或方法带有`@Test`、`@TestFactory`、`@BeforeEach`、`@AfterEach`、`@BeforeAll`或`@AfterAll`注解，并接受一个参数，那么这个参数将由解析器（具有父类`ParameterResolver`的对象）在运行时解析。在JUnit
    5中，有三个内置的解析器自动注册：`TestInfoParameterResolver`、`RepetitionInfoParameterResolver`和`TestReporterParameterResolver`。我们将在本节中回顾这些解析器中的每一个。
- en: TestInfoParameterResolver
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestInfoParameterResolver
- en: Given a test class, if a method parameter is of type `TestInfo`, the JUnit 5
    resolver `TestInfoParameterResolver` supplies an instance of `TestInfo` corresponding
    to the current test as the value for the declared parameter. The `TestInfo` object
    is used to retrieve information about the current test, such as the test display
    name, the test class, the test method, or associated tags.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个测试类，如果方法参数的类型是`TestInfo`，则JUnit 5解析器`TestInfoParameterResolver`会提供一个与声明的参数对应的`TestInfo`实例，该实例对应于当前测试。`TestInfo`对象用于检索有关当前测试的信息，例如测试显示名称、测试类、测试方法或关联的标签。
- en: '`TestInfo` acts as a drop-in replacement for the `TestName` rule from JUnit
    4.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestInfo`充当JUnit 4的`TestName`规则的替代品。'
- en: 'The class `TestInfo` is placed in the package `org.junit.jupiter.api` and offers
    the following API:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestInfo`类位于`org.junit.jupiter.api`包中，并提供以下API：'
- en: '`String getDisplayName()` : This returns the display name of the test or container.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String getDisplayName()`：这会返回测试或容器的显示名称。'
- en: '`Set<String> getTags()` : This gets the set of all tags for the current test
    or container.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set<String> getTags()`：这会获取当前测试或容器的所有标签集。'
- en: '`Optional<Class<?>> getTestClass()` : This gets the class associated with the
    current test or container, if available.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<Class<?>> getTestClass()`：如果可用，这会获取与当前测试或容器关联的类。'
- en: '`Optional<Method> getTestMethod()` : This gets the method associated with the
    current test, if available.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional<Method> getTestMethod()`：如果可用，这会获取与当前测试关联的方法。'
- en: '![](img/00067.jpeg)*TestInfo* API'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00067.jpeg)*TestInfo* API'
- en: 'Let''s see an example. Notice that in the following class, both the methods
    annotated with `@BeforeEach` and `@Test` accepts a parameter of `TestInfo`. This
    parameter is injected by `TestInfoParameterResolver`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。请注意，在以下类中，使用`@BeforeEach`和`@Test`注解的两个方法都接受`TestInfo`参数。这个参数是由`TestInfoParameterResolver`注入的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Therefore, in the body of each method, we are able to use the `TestInfo` API
    to get the test information at runtime, as the following screenshot demonstrates:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在每个方法的主体中，我们能够在运行时使用`TestInfo` API来获取测试信息，如下面的屏幕截图所示：
- en: '![](img/00068.gif)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.gif)'
- en: Console output of dependency injection of *TestInfo* objects
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*TestInfo*对象的依赖注入的控制台输出'
- en: RepetitionInfoParameterResolver
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RepetitionInfoParameterResolver
- en: The second resolver provided out of the box in JUnit 5 is called `RepetitionInfoParameterResolver`.
    Given a test class, if a method parameter in a `@RepeatedTest`, `@BeforeEach`,
    or `@AfterEach` method is of type `RepetitionInfo`, the `RepetitionInfoParameterResolver`
    will supply an instance of `RepetitionInfo`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5中提供的第二个内置解析器称为`RepetitionInfoParameterResolver`。给定一个测试类，如果`@RepeatedTest`、`@BeforeEach`或`@AfterEach`方法的方法参数是`RepetitionInfo`类型，`RepetitionInfoParameterResolver`将提供`RepetitionInfo`的实例。
- en: '`RepetitionInfo` can be used to retrieve information about the current repetition
    and the total number of repetitions for the corresponding `@RepeatedTest`. The
    API of `RepetitionInfo` offers two methods, as shown in the screenshot after the
    list:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`RepetitionInfo`可用于检索有关当前重复和相应`@RepeatedTest`的总重复次数的信息。`RepetitionInfo`的API提供了两种方法，如列表后的屏幕截图所示：'
- en: '`int getCurrentRepetition()`: Gets the current repetition of the corresponding
    `@RepeatedTest` method'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getCurrentRepetition()`: 获取相应`@RepeatedTest`方法的当前重复次数'
- en: '`int getTotalRepetitions()`: Gets the total number of repetitions of the corresponding
    `@RepeatedTest` method'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int getTotalRepetitions()`: 获取相应`@RepeatedTest`方法的总重复次数'
- en: '![](img/00069.jpeg)*RepetitionInfo* API'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00069.jpeg)*RepetitionInfo* API'
- en: 'The class here contains a simple example for the use of `RepetitionInfo`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的类包含了对`RepetitionInfo`的简单示例：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As can be seen in the test output, we are able to read the information about
    the repeated test at runtime:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在测试输出中所看到的，我们能够在运行时读取有关重复测试的信息：
- en: '![](img/00070.gif)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.gif)'
- en: The console output of dependency injection of *RepetitionInfo* objects.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*RepetitionInfo*对象的依赖注入的控制台输出。'
- en: TestReporterParameterResolver
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestReporterParameterResolver
- en: The last built-in resolver in JUnit 5 is `TestReporterParameterResolver`. Again,
    given a test class, if a method parameter is of type `TestReporter`, the `TestReporterParameterResolver` 
    supplies an instance of `TestReporter`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5中的最后一个内置解析器是`TestReporterParameterResolver`。同样，给定一个测试类，如果方法参数的类型是`TestReporter`，`TestReporterParameterResolver`将提供`TestReporter`的实例。
- en: '`TestReporter` is used to publish additional data about the test execution.
    The data can be consumed through the method `reportingEntryPublished`, and then,
    it can be requested by IDEs or included in test reports. Each `TestReporter` object
    stores information as a map, that is, a key-value collection:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestReporter`用于发布有关测试执行的附加数据。数据可以通过`reportingEntryPublished`方法进行消耗，然后可以被IDE请求或包含在测试报告中。每个`TestReporter`对象都将信息存储为一个映射，即键值对集合：'
- en: '![](img/00071.jpeg)*TestReporter* API'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00071.jpeg)*TestReporter* API'
- en: 'This test provides a simple example of `TestReporter`. As we can see, we use
    the injected `testReporter` object to add custom information using key-value pairs:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试提供了`TestReporter`的一个简单示例。正如我们所看到的，我们使用注入的`testReporter`对象使用键值对添加自定义信息：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Dynamic tests
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态测试
- en: 'As we know, in JUnit 3, we identified tests by parsing method names and checking
    whether they started with the word test. Then, in JUnit 4, we identified tests
    by collecting methods annotated with `@Test`. Both of these techniques share the
    same approach: tests are defined at compile time. This concept is what we call
    static testing.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，在JUnit 3中，我们通过解析方法名称并检查它们是否以单词test开头来识别测试。然后，在JUnit 4中，我们通过收集带有`@Test`注解的方法来识别测试。这两种技术共享相同的方法：测试在编译时定义。这个概念就是我们所说的静态测试。
- en: 'Static tests are considered a limited approach, especially for the common scenario
    in which the same test is supposed to be executed for a variety of input data.
    In JUnit 4, this limitation was addressed in several ways. A very simple solution
    to the problem is to loop the input test data and exercising the same test logic
    (JUnit 4 example here). Following this approach, one test is executed until the
    first assertion fails:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 静态测试被认为是一种有限的方法，特别是对于同一个测试应该针对各种输入数据执行的常见情况。在JUnit 4中，这个限制以几种方式得到解决。解决这个问题的一个非常简单的解决方案是循环输入测试数据并练习相同的测试逻辑（这里是JUnit
    4的示例）。按照这种方法，一个测试会一直执行，直到第一个断言失败：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A more elaborate solution is to use the JUnit 4 support for parameterized tests,
    using the parameterized runner. This approach does not create tests at runtime
    either, it simply repeats the same test several times depending on the parameters:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的解决方案是使用JUnit 4支持参数化测试，使用参数化运行器。这种方法也不会在运行时创建测试，它只是根据参数多次重复相同的测试：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can see the execution of the preceding example in the Eclipse IDE:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Eclipse IDE中看到前面示例的执行：
- en: '![](img/00072.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: Execution of JUnit 4’s parameterized test in Eclipse
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse中执行JUnit 4的参数化测试
- en: On the other hand, JUnit 5 allows to generate test at runtime by a factory method
    that is annotated with `@TestFactory`. In contrast to `@Test`, a `@TestFactory`
    method is not a test but a factory. A `@TestFactory` method must return a `Stream`,
    `Collection`, `Iterable`, or `Iterator` of `DynamicTest` instances. These `DynamicTest`
    instances are executed lazily, enabling dynamic generation of test cases.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，JUnit 5允许通过一个使用`@TestFactory`注释的工厂方法在运行时生成测试。与`@Test`相比，`@TestFactory`方法不是一个测试，而是一个工厂。`@TestFactory`方法必须返回`DynamicTest`实例的`Stream`、`Collection`、`Iterable`或`Iterator`。这些`DynamicTest`实例是惰性执行的，可以动态生成测试用例。
- en: In order to create a dynamic test, we can use the static method `dynamicTest`
    of the class `DynamicTest` located in the `org.junit.jupiter.api` package. If
    we inspect the source code of this class, we can see that a `DynamicTest` is composed
    of a display name in form of the String and one executable object, which can be
    provided as lambda expressions or as method references.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建动态测试，我们可以使用位于`org.junit.jupiter.api`包中的`DynamicTest`类的静态方法`dynamicTest`。如果我们检查这个类的源代码，我们可以看到`DynamicTest`由一个字符串形式的显示名称和一个可执行对象组成，可以提供为lambda表达式或方法引用。
- en: 'Let''s see several examples of dynamic tests. In the following example, the
    first dynamic test will fail, due to the fact we are not returning the expected
    collection of `DynamicTests`. The next three methods are very simple examples
    that demonstrate the generation of `Collection`, `Iterable`, and `Iterator` of
    `DynamicTest` instances:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些动态测试的例子。在下面的例子中，第一个动态测试将失败，因为我们没有返回预期的`DynamicTests`集合。接下来的三个方法是非常简单的例子，演示了`DynamicTest`实例的`Collection`、`Iterable`和`Iterator`的生成：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These examples do not really exhibit dynamic behavior, but merely demonstrate
    the supported return types. Note that the first test is going to fail due to `JUnitException`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例并没有真正展示动态行为，而只是演示了支持的返回类型。请注意，第一个测试将由于`JUnitException`而失败：
- en: '![](img/00073.gif)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00073.gif)'
- en: Console output of the first example for dynamic test execution
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个动态测试示例的控制台输出
- en: 'The following example demonstrates how easy it is to generate dynamic tests
    for a given set of input data:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了为给定的输入数据集生成动态测试有多么容易：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Notice that, in the end, three tests were executed, and these three tests were
    created at runtime by JUnit 5:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最终执行了三个测试，并且这三个测试是由JUnit 5在运行时创建的：
- en: '![](img/00074.gif)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00074.gif)'
- en: Console output of the second example for dynamic test execution
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个动态测试示例的控制台输出
- en: There is another possibility to create dynamic tests in JUnit 5, using the static
    method `stream` of the class `DynamicTest`. This method needs an input generator,
    a function that generates a display name based on an input value, and a test executor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 5中，还有另一种创建动态测试的可能性，使用`DynamicTest`类的`stream`静态方法。这个方法需要一个输入生成器，一个根据输入值生成显示名称的函数，以及一个测试执行器。
- en: 'Let''s see another example. We create a test factory, providing the input data
    as an `Iterator`, a display name function using a lambda expression, and finally,
    a test executor implemented with another lambda expression. In this example, the
    test executor basically asserts whether or not the input integer is even or odd:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我们创建一个测试工厂，提供输入数据作为`Iterator`，使用lambda表达式作为显示名称函数，最后，使用另一个lambda表达式实现的测试执行器。在这个例子中，测试执行器基本上断言输入的整数是偶数还是奇数：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The test will fail for odd inputs. As we can see, two out of three tests will
    fail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 奇数输入的测试将失败。我们可以看到，三个测试中有两个会失败：
- en: '![](img/00075.gif)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00075.gif)'
- en: Console output of dynamic test execution (example three)
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 动态测试执行的控制台输出（第三个示例）
- en: Test interfaces
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试接口
- en: In JUnit 5, there are different rules relative to the use of annotations in
    Java interfaces. First of all, we need to be aware that `@Test`, `@TestFactory`,
    `@BeforeEach`, and `@AfterEach` can be declared on interface default methods.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 5中，有关Java接口中注解使用的规则是不同的。首先，我们需要意识到`@Test`、`@TestFactory`、`@BeforeEach`和`@AfterEach`可以在接口默认方法上声明。
- en: Default methods is a feature of Java introduced in version 8\. These methods
    (declared using the reserve keyword `default`) allows to define a default implementation
    for a given method within a Java interface. This capability can be useful for
    backward compatibility with existing interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认方法是Java 8版本引入的一个特性。这些方法（使用保留关键字`default`声明）允许在Java接口中为给定方法定义默认实现。这种能力对于与现有接口的向后兼容性可能很有用。
- en: The second rule regarding JUnit 5 and interfaces is that `@BeforeAll` and `@AfterAll`
    can be declared on `static` methods in a test interface. Moreover, if the test
    class, which implements a given interface, is annotated with `@TestInstance(Lifecycle.PER_CLASS)`,
    the methods `@BeforeAll` and `@AfterAll` declared on the interface do not need
    to be `static`, but `default` methods.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JUnit 5和接口的第二条规则是，`@BeforeAll`和`@AfterAll`可以在测试接口中的`static`方法上声明。此外，如果实现给定接口的测试类被注解为`@TestInstance(Lifecycle.PER_CLASS)`，则接口上声明的`@BeforeAll`和`@AfterAll`方法不需要是`static`，而是`default`方法。
- en: The third and final rule concerning interfaces in JUnit 5 is `@ExtendWith` and
    `@Tag` can be declared on test interfaces to configure extensions and tags.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JUnit 5中接口的第三条和最后一条规则是，可以在测试接口上声明`@ExtendWith`和`@Tag`来配置扩展和标签。
- en: 'Let''s see some simple examples. In the following class, we are creating an
    interface, not a class. In this interface, we use the annotations `@BeforeAll`,
    `@AfterAll`, `@BeforeEach`, and `@AfterEach`. On the one hand, we define `@BeforeAll`,
    `@AfterAll` as static methods. On the other hand, we are defining `@BeforeEach`
    and `@AfterEach` as Java 8 default methods:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些简单的例子。在下面的类中，我们创建的是一个接口，而不是一个类。在这个接口中，我们使用了注解`@BeforeAll`、`@AfterAll`、`@BeforeEach`和`@AfterEach`。一方面，我们将`@BeforeAll`、`@AfterAll`定义为静态方法。另一方面，我们将`@BeforeEach`和`@AfterEach`定义为Java
    8默认方法：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are using the library Simple Logging Facade for Java (SLF4J) in this example.
    Take a look at the code on GitHub ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5))
    for details on the declaration of dependencies.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了Simple Logging Facade for Java (SLF4J)库。请查看GitHub上的代码（[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)）以获取有关依赖声明的详细信息。
- en: 'In this example, we are using the annotation `TestFactory` to define a default
    method in a Java interface:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用注解`TestFactory`来定义Java接口中的默认方法：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, we use the annotation `@Tag` and `@ExtendWith` in another interface:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在另一个接口中使用注解`@Tag`和`@ExtendWith`：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'All in all, we can use these interfaces in our Jupiter tests:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们可以在我们的Jupiter测试中使用这些接口：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this test, the fact of implementing all the previously defined interfaces
    will provide the logging capabilities implemented in the default methods:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，实现所有先前定义的接口将提供默认方法中实现的日志记录功能：
- en: '![](img/00076.gif)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00076.gif)'
- en: Console output of test implementing several interfaces
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多个接口的测试的控制台输出
- en: Test templates
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试模板
- en: A `@TestTemplate` method is not a regular test case but a template for test
    cases. Method annotated like this will be invoked multiple times, depending on
    the invocation context returned by the registered providers. Thus, test templates
    are used together with a registered `TestTemplateInvocationContextProvider` extension.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`@TestTemplate` 方法不是一个常规的测试用例，而是测试用例的模板。像这样注释的方法将根据注册的提供程序返回的调用上下文多次调用。因此，测试模板与注册的
    `TestTemplateInvocationContextProvider` 扩展一起使用。'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The required provided implements the Jupiter interface `TestTemplateInvocationContextProvider`.
    Inspecting the code of this class, we can see how two `String` parameters are
    provided to the test template (in this case, the value for these parameters are
    `parameter-1` and `parameter-2`):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的提供程序实现了 Jupiter 接口 `TestTemplateInvocationContextProvider`。检查这个类的代码，我们可以看到如何为测试模板提供了两个
    `String` 参数（在这种情况下，这些参数的值为 `parameter-1` 和 `parameter-2`）：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the test is executed, each invocation of the test template behaves like
    a regular `@Test`. In this example, the test is only writing the parameter in
    the standard output.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试被执行时，测试模板的每次调用都会像常规的 `@Test` 一样行为。在这个例子中，测试只是将参数写入标准输出。
- en: '![](img/00077.gif)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00077.gif)'
- en: Console output of test template example
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模板示例的控制台输出
- en: Parameterized tests
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化测试
- en: Parameterized tests are a special kinds of tests in which the data input is
    injected in the test in order to reuse the same test logic. This concept was already
    addressed in JUnit 4, as explained in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective On Software Quality And Java Testing*. As we would expect, parameterized
    tests are also implemented in JUnit 5.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 参数化测试是一种特殊类型的测试，其中数据输入被注入到测试中，以便重用相同的测试逻辑。这个概念在 JUnit 4 中已经讨论过，如 [第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)
    *关于软件质量和Java测试的回顾* 中所解释的。正如我们所期望的，参数化测试也在 JUnit 5 中实现了。
- en: 'First of all, in order to implement a parameterized test in Jupiter, we need
    to add the `junit-jupiter-params` to our project. When using Maven, that means
    adding the following dependency:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了在Jupiter中实现参数化测试，我们需要将 `junit-jupiter-params` 添加到我们的项目中。在使用Maven时，这意味着添加以下依赖项：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As usual, as a general rule, it is recommended to use the latest version of
    the artifacts. To find out that, we can check out the Maven central repository
    ([http://search.maven.org/](http://search.maven.org/)).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，建议使用最新版本的构件。我们可以通过 Maven 中央仓库 ([http://search.maven.org/](http://search.maven.org/))
    找到最新版本。
- en: 'When using Gradle, the `junit-jupiter-params dependency` can be declared as
    follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Gradle 时，可以声明 `junit-jupiter-params` 依赖项如下：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, we need to use the annotation `@ParameterizedTest` (located in the package
    `org.junit.jupiter.params`) to declare a method within a Java class as a parameterized
    test. This type of test behaves exactly the same as a regular `@Test`, meaning
    that all the life cycle callbacks (`@BeforeEach`, `@AfterEach`, and so on) and
    extensions continue working in the same way.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要使用注解 `@ParameterizedTest`（位于包 `org.junit.jupiter.params` 中）来声明一个Java类中的方法作为参数化测试。这种类型的测试行为与常规的
    `@Test` 完全相同，意味着所有的生命周期回调（`@BeforeEach`、`@AfterEach` 等）和扩展都会以相同的方式工作。
- en: 'Nevertheless, the use of `@ParameterizedTest` is not enough to implement a
    parameterized test. Together with `@ParameterizedTest`, we need to specify at
    least one argument provider. As we will discover in this section, JUnit 5 implements
    different annotations to provide data input (that is, parameters for tests) from
    different sources. These argument providers (implemented as annotations in JUnit
    5) are summarized in the following table (each of these annotations are located
    in the package `org.junit.jupiter.params.provider`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用 `@ParameterizedTest` 还不足以实现参数化测试。与 `@ParameterizedTest` 一起，我们需要至少指定一个参数提供程序。正如我们将在本节中发现的那样，JUnit
    5 实现了不同的注解，以从不同的来源提供数据输入（即测试的参数）。这些参数提供程序（在JUnit 5中作为注解实现）总结在下表中（这些注解中的每一个都位于包
    `org.junit.jupiter.params.provider` 中）：
- en: '| **Arguments provider annotation** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **参数提供程序注解** | **描述** |'
- en: '| `@ValueSource` | Used to specify an array of literal values of `String`,
    `int`, `long`, or `double` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `@ValueSource` | 用于指定 `String`、`int`、`long` 或 `double` 的字面值数组 |'
- en: '| `@EnumSource` | Argument source for constants of a specified enumeration
    (`java.lang.Enum`) |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `@EnumSource` | 用于指定指定枚举类型（`java.lang.Enum`）的常量的参数源 |'
- en: '| `@MethodSource` | Provides access to values returned by static methods of
    the class in which this annotation is declared |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `@MethodSource` | 提供对声明此注解的类的静态方法返回的值的访问权限 |'
- en: '| `@CsvSource` | Argument source which reads comma-separated values (CSV) from
    its attribute |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `@CsvSource` | 从其属性读取逗号分隔值（CSV）的参数源 |'
- en: '| `@CsvFileSource` | Argument source which is used to load CSV files from one
    or more classpath resources |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `@CsvFileSource` | 用于从一个或多个类路径资源加载CSV文件的参数源 |'
- en: '| `@ArgumentsSource` | Used to specify a custom argument provider (that is,
    a Java class that implements the interface) `org.junit.jupiter.params.provider.ArgumentsProvider`)
    |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@ArgumentsSource` | 用于指定自定义参数提供程序（即实现接口 `org.junit.jupiter.params.provider.ArgumentsProvider`
    的Java类） |'
- en: '@ValueSource'
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ValueSource'
- en: 'The annotation `@ValueSource` is used in conjunction with `@ParameterizedTest`
    to specify a parameterized test in which the argument source is an array of literal
    values of `String`, `int`, `long`, or `double`. These values are specified inside
    the annotation, using the elements `strings`, `ints`, `longs`, or `doubles`. Consider
    the following example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ValueSource`注解与`@ParameterizedTest`结合使用，用于指定一个参数化测试，其中参数源是`String`，`int`，`long`或`double`的文字值数组。这些值在注解中指定，使用`strings`，`ints`，`longs`或`doubles`元素。考虑以下示例：'
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The method of this class (`testWithStrings`) defines a parameterized test in
    which an array of String is specified. Due to the fact that two String arguments
    are specified in the annotation `@ValueSource` (in this example `"Hello"` and
    `"World"`), the test logic will be exercised twice, once per value. This data
    is injected in the test method using the argument of the method, in this case
    through the `String` variable named argument. All in all, when executing this
    test class, the output will be as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的方法（`testWithStrings`）定义了一个参数化测试，其中指定了一个String数组。由于在`@ValueSource`注解中指定了两个String参数（在本例中为`"Hello"`和`"World"`），测试逻辑将被执行两次，每次一个值。这些数据通过方法的参数注入到测试方法中，这里是通过名为argument的`String`变量。总的来说，当执行此测试类时，输出将如下所示：
- en: '![](img/00078.gif)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.gif)'
- en: Execution of a parameterized test using *@ValueSource* and String argument provider
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@ValueSource*和String参数提供程序执行参数化测试
- en: 'We can also use integer primitive types (`int`, `long`, and `double`) within
    the `@ValueSource` annotation. The following example demonstrates how. The methods
    of this example class (named `testWithInts`, `testWithLongs`, and `testWithDoubles`)
    use the annotation `@ValueSource` to define the arguments in the form of integer
    values, using the primitive types int, long, and double, respectively. To that
    aim, the elements `ints`, `longs`, and `doubles` of `@ValueSource` need to be
    specified:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在`@ValueSource`注解中使用整数原始类型（`int`，`long`和`double`）。以下示例演示了如何使用。此示例类的方法（命名为`testWithInts`，`testWithLongs`和`testWithDoubles`）使用`@ValueSource`注解以整数值的形式定义参数，分别使用原始类型int，long和double。为此，需要指定`@ValueSource`的`ints`，`longs`和`doubles`元素：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As can be seen in the picture here, each test is executed twice, since in each
    `@ValueSource` annotation we specify two different input parameters (type `int`,
    `long`, and `double`, respectively).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如图中所示，每个测试都会执行两次，因为在每个`@ValueSource`注解中，我们指定了两个不同的输入参数（类型为`int`，`long`和`double`）。
- en: '![](img/00079.gif)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.gif)'
- en: Execution of a parameterized test using *@ValueSource* and primitive types
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@ValueSource*和原始类型执行参数化测试
- en: '@EnumSource'
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@EnumSource'
- en: The annotation `@EnumSource` allows to specify a parameterized test in which
    the argument source is a Java enumeration class. By default, each value of the
    enumeration will be used to feed the parameterized test, one at a time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`@EnumSource`注解允许指定一个参数化测试，其中参数源是一个Java枚举类。默认情况下，枚举的每个值将被用来提供参数化测试，依次进行测试。'
- en: 'For example, in the following test class, the method `testWithEnum` is annotated
    with `@ParameterizedTest` in conjunction with `@EnumSource`. As we can see, the
    value of this annotation is `TimeUnit.class`, which is a standard Java annotation
    (package java.util.concurrent) used to represent time duration. The possible values
    defined in this enumeration are `NANOSECONDS`, `MICROSECONDS`, `MILLISECONDS`,
    `SECONDS`, `MINUTES`, `HOURS`, and `DAYS`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在以下测试类中，方法`testWithEnum`使用`@ParameterizedTest`与`@EnumSource`一起进行注释。正如我们所看到的，此注解的值是`TimeUnit.class`，这是一个标准的Java注解（java.util.concurrent包），用于表示时间持续。此枚举中定义的可能值是`NANOSECONDS`，`MICROSECONDS`，`MILLISECONDS`，`SECONDS`，`MINUTES`，`HOURS`和`DAYS`：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Therefore, the execution of this test will be carried out seven times, that
    is, one per `TimeUnit` enumeration value. We can check this in the trace of the
    output console when executing the test:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，此测试的执行将进行七次，即每个`TimeUnit`枚举值一次。在执行测试时，可以在输出控制台的跟踪中检查到这一点：
- en: '![](img/00080.gif)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00080.gif)'
- en: Execution of parameterized test using *@EnumSource* and *TimeUnit.class*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@EnumSource*和*TimeUnit.class*执行参数化测试
- en: 'Moreover, the `@EnumSource` annotation allows to filter the members of the
    enumeration in several ways. To implement this selection, the following elements
    can be specified within a `@EnumSource` annotation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`@EnumSource`注解允许以多种方式过滤枚举的成员。为了实现这种选择，可以在`@EnumSource`注解中指定以下元素：
- en: '`mode`: Constant value which determines the type of filtering. This is defined
    as an enumeration in the inner class `org.junit.jupiter.params.provider.EnumSource.Mode`,
    and the possible values are:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mode`：常量值，确定过滤的类型。这在内部类`org.junit.jupiter.params.provider.EnumSource.Mode`中定义为枚举，并且可能的值是：'
- en: '`INCLUDE`: Used to select those values whose names are supplied via the `names`
    element. This is the default option.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INCLUDE`：用于选择那些名称通过`names`元素提供的值。这是默认选项。'
- en: '`EXCLUDE`: Used to select all values except those supplied with the `names`
    element.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXCLUDE`：用于选择除了通过`names`元素提供的所有值之外的所有值。'
- en: '`MATCH_ALL`: Used to select those values whose names match the patterns in
    `names` element.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MATCH_ALL`：用于选择那些名称与`names`元素中的模式匹配的值。'
- en: '`MATCH_ANY`: Used to select those values whose names match any pattern in the
    `names` element.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MATCH_ANY`：用于选择那些名称与`names`元素中的任何模式匹配的值。'
- en: '`names`: The array of string which allows to select a group of `enum` constants.
    The criteria for inclusion/exclusion is directly linked to the value of mode.
    In addition, this element also allows to define regular expressions to select
    the names of `enum` constants to be matched.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`names`：字符串数组，允许选择一组`enum`常量。包含/排除的标准与mode的值直接相关。此外，该元素还允许定义正则表达式来选择要匹配的`enum`常量的名称。'
- en: 'Consider the following example. In this class, there are three parameterized
    tests. First one, named `testWithFilteredEnum`, uses the class `TimeUnit` to feed
    the `@EnumSource` argument provider. Moreover, the enum constant set is filtered
    using the element names. As we can see, only the constant `"DAYS"` and `"HOURS"`
    will be used to feed this test (take into account that the default mode is `INCLUDE`):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下例子。在这个类中，有三个参数化测试。第一个，名为`testWithFilteredEnum`，使用`TimeUnit`类来提供`@EnumSource`参数提供程序。此外，枚举常量集使用元素名称进行过滤。正如我们所看到的，只有常量`“DAYS”`和`“HOURS”`将用于提供这个测试（请注意，默认模式是`INCLUDE`）：
- en: '[PRE20]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Thus, when executing this class in the console, the output we obtain is the
    following. Regarding the first test, we can see that only traces for `"DAYS"`
    and `"HOURS"` are present:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在控制台中执行这个类时，我们得到的输出如下。关于第一个测试，我们可以看到只有`“DAYS”`和`“HOURS”`的迹象：
- en: '![](img/00081.gif)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.gif)'
- en: Execution of parameterized test using *@EnumSource* using filtering capabilities
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@EnumSource*使用过滤功能执行参数化测试
- en: 'Consider now the second test method, named `testWithExcludeEnum.` This test
    is exactly the same as before with a difference: the mode here is `EXCLUSION`
    (instead of `INCLUSION`, chosen by default in the previous test). All in all,
    in the execution (see screenshot before) when can see that this test is executed
    five times, per one of the enum constant different to `DAYS` and `HOURS`. To check
    that, track the traces with the sentence `"Parameterized test with excluded (TimeUnit)
    argument"`.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑第二个测试方法，名为`testWithExcludeEnum`。这个测试与之前完全相同，唯一的区别是这里的模式是`EXCLUSION`（而不是之前测试中默认选择的`INCLUSION`）。总的来说，在执行中（见之前的截图）我们可以看到这个测试被执行了五次，每次都是使用一个不同于`DAYS`和`HOURS`的枚举常量。要检查这一点，可以跟踪带有句子“使用排除（TimeUnit）参数的参数化测试”的迹象。
- en: 'The third and last method of this class (called `testWithRegexEnum`) defines
    an inclusion mode, `MATCH_ALL`, using a regular expression to filter the enumeration
    (in this case, it is also `TimeUnit`). The concrete regular expression used in
    this example is `^(M|N).+SECONDS$`, which means that only will be included in
    those enum constants starting with `M` or `N` and ending with `SECONDS`. As can
    be checked in the execution screenshot, there are three `TimeUnit` constants matching
    these conditions: `NANOSECONDS`, `MICROSECONDS`, and `MILISECONDS`.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的第三个也是最后一个方法（名为`testWithRegexEnum`）定义了一个包含模式，`MATCH_ALL`，使用正则表达式来过滤枚举（在这种情况下，也是`TimeUnit`）。在这个例子中使用的具体正则表达式是`^(M|N).+SECONDS$`，这意味着只有以`M`或`N`开头并以`SECONDS`结尾的枚举常量将被包含在内。正如在执行截图中可以看到的，有三个`TimeUnit`常量符合这些条件：`NANOSECONDS`、`MICROSECONDS`和`MILISECONDS`。
- en: '@MethodSource'
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@MethodSource'
- en: 'The annotation `@MethodSource` allows to define the name of the static method
    in which the arguments for the test are provided as a Java 8 `Stream.` For instance,
    in the following example, we can see a parameterized test in which the argument
    provider is a static method called `stringProvider`. In this example, this method
    returns a `Stream` of `String`''s and therefore the argument of the test method
    (callled `testWithStringProvider`) accepts one `String` argument:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注解`@MethodSource`允许定义静态方法的名称，该方法提供测试的参数作为Java 8的`Stream`。例如，在下面的例子中，我们可以看到一个参数化测试，其中参数提供程序是一个名为`stringProvider`的静态方法。在这个例子中，这个方法返回一个`String`的`Stream`，因此测试方法的参数（名为`testWithStringProvider`）接受一个`String`参数：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When running the example, we can see how the test is execute twice, once per
    `String` contained in the `Stream`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行示例时，我们可以看到测试被执行两次，每次都是使用`Stream`中包含的`String`。
- en: '![](img/00082.gif)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.gif)'
- en: Execution of a parameterized test using *@MethodSource* and String argument
    provider
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@MethodSource*和String参数提供程序执行参数化测试
- en: The type of the objects contained in the `Stream` is not required to be `String`.
    In fact, this type can be anything. Let's consider another example, in which `@MethodSource`
    is linked to a static method, which returns as `Stream` of custom objects. In
    this example, this type is named `Person`, and here it is implemented as an inner
    class with two properties (`name` and `surname`).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`中包含的对象的类型不需要是`String`。实际上，这种类型可以是任何类型。让我们考虑另一个例子，其中`@MethodSource`与一个静态方法关联，该方法返回自定义对象的`Stream`。在这个例子中，这种类型被命名为`Person`，并且在这里它被实现为一个内部类，具有两个属性（`name`和`surname`）。'
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the following screenshot shows, when executing this example, the parameterized
    test is exercise twice, once per `Person` objects contained in the `Stream` (`"John
    Doe"` and `"Jane Roe"`).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下面的截图所示，在执行这个例子时，参数化测试被执行两次，每次都是使用`Stream`中包含的`Person`对象（`“John Doe”`和`“Jane
    Roe”）。
- en: '![](img/00083.gif)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.gif)'
- en: Execution of parameterized test using *@MethodSource* and custom object argument
    provider
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@MethodSource*和自定义对象参数提供程序执行参数化测试
- en: 'We can also use `@MethodSource` to specify argument providers which contain
    integer primitive types, concretely of `int`, `double`, and `long`. The following
    class contains an example. We can see three parameterized tests. The first one
    (named `testWithIntProvider`) uses the annotation `@MethodSource` to link with
    the static method `intProvider`. In the body of this method, we use the standard
    Java class `IntStream` to return an Stream of `int` values. The second and third
    test (called `testWithDoubleProvider` and `testWithLongProvider`) are quite similar,
    but using a `Stream` of `double` and `long` values, respectively:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@MethodSource`来指定包含整数原始类型的参数提供程序，具体来说是`int`、`double`和`long`。以下的类包含了一个例子。我们可以看到三个参数化测试。第一个（名为`testWithIntProvider`）使用注解`@MethodSource`与静态方法`intProvider`关联。在这个方法的主体中，我们使用标准的Java类`IntStream`来返回一个`int`值的`Stream`。第二个和第三个测试（名为`testWithDoubleProvider`和`testWithLongProvider`）非常相似，但分别使用`double`和`long`值的`Stream`：
- en: '[PRE23]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Thus, when executing this class, there will be six tests executed (three parameterized
    tests with two arguments each).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在执行这个类时，将执行六个测试（三个参数化测试，每个测试有两个参数）。
- en: 'In the following screenshot, we can check this by following the traces written
    by each test to the standard output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以通过跟踪每个测试写入标准输出的迹象来检查这一点：
- en: '![](img/00084.gif)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.gif)'
- en: Execution of parameterized test using *@MethodSource* and primitive types argument
    provider
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@MethodSource*和原始类型参数提供程序执行参数化测试
- en: 'Finally, with regards to `@MethodSource` parameterized tests, it is worth it
    to know that the method providers are allowed to return a Stream of different
    types (objects or primitive types). This is very convenient for real-world test
    cases. For example, the following class implements a parameterized test in which
    the argument provider is a method returning arguments of mixed types: `String`
    and `int`. These parameters are injected in the test as method arguments (called
    first and second in the example).'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，关于`@MethodSource`参数化测试，值得知道的是，方法提供程序允许返回不同类型（对象或原始类型）的流。这对于真实世界的测试用例非常方便。例如，下面的类实现了一个参数化测试，其中参数提供程序是一个返回混合类型（`String`和`int`）参数的方法。这些参数作为方法参数（在示例中称为first和second）注入到测试中。
- en: '[PRE24]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As usual, there will be test executions as entries contained in the Stream.
    In this case, there are two: `"Mastertering"` and `10`, and then `"JUnit 5"` and
    `20`.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，测试执行将作为流中包含的条目。在这种情况下，有两个条目："Mastertering"和10，然后是"JUnit 5"和20。
- en: '![](img/00085.gif)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.gif)'
- en: Execution of parameterized test using *@MethodSource* with different types of
    arguments
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@MethodSource*执行参数化测试，使用不同类型的参数
- en: '@CsvSource and @CsvFileSource'
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@CsvSource和@CsvFileSource'
- en: Another way to specify the source of arguments for parameterized tests is using
    comma-separated values (CSV). This can be done using the annotation `@CsvSource`,
    which allows to embed CSV content as String in the value of the annotation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用逗号分隔的值（CSV）指定参数化测试参数的另一种方法。这可以通过注解`@CsvSource`来实现，它允许将CSV内容嵌入到注解的值中作为字符串。
- en: Consider the following example. It contains a Jupiter parameterized test (named
    `testWithCsvSource`), which is using the annotation `@CsvSource`. This annotation
    contains an array of Strings. In each element of the array, we can see there is
    a different value separated by commas.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。它包含了一个Jupiter参数化测试（名为`testWithCsvSource`），该测试使用了注解`@CsvSource`。该注解包含一个字符串数组。在数组的每个元素中，我们可以看到由逗号分隔的不同值。
- en: The content of the CSV is automatically converted to String and int. To find
    out more about the implicit type conversion made in parameters by JUnit 5, take
    a look to the section *Argument conversion* in this chapter.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CSV的内容会自动转换为字符串和整数。要了解JUnit 5在参数中进行的隐式类型转换的更多信息，请查看本章节中的*参数转换*部分。
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All in all, when executing this test class, there will be three single tests,
    each per entry in the array. Each execution will be invoked, passing two arguments
    to the test. The first one is named `first` and its type is `String`, and second
    one is called `second` and its type is `int`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当执行这个测试类时，将会有三个单独的测试，每个测试对应数组中的一个条目。每次执行都会传递两个参数给测试。第一个参数名为`first`，类型为`String`，第二个参数名为`second`，类型为`int`。
- en: '![](img/00086.gif)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.gif)'
- en: Execution of parameterized test using *@CsvSource*
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@CsvSource*执行参数化测试
- en: 'If the amount of CSV data is big, it might be more convenient using the annotation
    `@CsvFileSource` instead. This annotation allows to feed the parameterized test
    with a CSV file located in the classpath of the project. In the following example,
    we use the file `input.csv`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CSV数据量很大，使用注解`@CsvFileSource`可能更方便。该注解允许使用项目类路径中的CSV文件来为参数化测试提供数据。在下面的示例中，我们使用文件`input.csv`：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Internally, the annotation `@CsvFileSource` locates the file using the method
    `getResourceAsStream()` of the standard Java class `java.lang.Class`. Therefore,
    the path of the file is interpreted as a path local to the package class we are
    calling it from. Since our resource is located in the root of the classpath (in
    the example it is located in the folder `src/test/resources`), we need to locate
    it as `/input.csv`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，注解`@CsvFileSource`使用标准Java类`java.lang.Class`的`getResourceAsStream()`方法来定位文件。因此，文件的路径被解释为相对于我们调用它的包类的本地路径。由于我们的资源位于类路径的根目录（在示例中位于文件夹`src/test/resources`中），我们需要将其定位为`/input.csv`。
- en: '![](img/00087.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: Location and content of input.csv in the example with *@CsvFileSource*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在*@CsvFileSource*示例中的input.csv的位置和内容
- en: 'The following screenshot shows the output of the test when it is executed with
    Maven. Since the CSV has three rows of data, there are three test executions,
    each one with two parameters (first one as `String` and second one as `int`):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了使用Maven执行测试时的输出。由于CSV有三行数据，因此有三个测试执行，每个执行有两个参数（第一个为`String`，第二个为`int`）：
- en: '![](img/00088.gif)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00088.gif)'
- en: Execution of parameterized test using *@CsvFileSource*
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@CsvFileSource*执行参数化测试
- en: '@ArgumentsSource'
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@ArgumentsSource'
- en: The last annotation aimed to specify the source of arguments for parameterized
    tests in JUnit 5 is `@ArgumentsSource`. With this annotation, we can specify a
    custom (and reusable in different tests) class, which will contain the parameters
    for the test. This class must implement the interface `org.junit.jupiter.params.provider.ArgumentsProvider`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5中用于指定参数化测试参数来源的最后一个注解是`@ArgumentsSource`。使用此注解，我们可以指定一个自定义的（并且可以在不同测试中重用）类，该类将包含测试的参数。该类必须实现接口`org.junit.jupiter.params.provider.ArgumentsProvider`。
- en: 'Let’s see an example. The following class implements a Jupiter parameterized
    test, in which the arguments source will be defined in the class `CustomArgumentsProvider1`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。下面的类实现了一个Jupiter参数化测试，其中参数来源将在类`CustomArgumentsProvider1`中定义：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This class (named `CustomArgumentsProvider1`) has been implemented on our side,
    and due to the fact that it implements the interface `ArgumentsProvider`, must
    override the method `provideArguments`, in which the actual definition of parameters
    for the test is implemented. Looking at the code of the example, we can see that
    this method returns a `Stream` of `Arguments`. In this example, we are returning
    a couple of entries in the `Stream`, each one with two arguments (`String` and
    `int`, respectively):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类（名为`CustomArgumentsProvider1`）已经在我们这边实现了，由于它实现了`ArgumentsProvider`接口，必须重写`provideArguments`方法，在这个方法中实现了测试参数的实际定义。从例子的代码中可以看出，这个方法返回一个`Arguments`的`Stream`。在这个例子中，我们返回了一个`Stream`中的一对条目，每个条目分别有两个参数（`String`和`int`）：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice also that this argument has an argument of type `ExtensionContext` (package
    `org.junit.jupiter.api.extension`). This argument is very useful to know the context
    in which the test is executed. As illustrated in the screenshot here, `ExtensionContext`
    API offers different methods to find out different attributes of the test instance
    (test method name, display name, tags, and so on).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这个参数有一个`ExtensionContext`类型的参数（包`org.junit.jupiter.api.extension`）。这个参数非常有用，可以知道测试执行的上下文。正如这里的截图所示，`ExtensionContext`
    API提供了不同的方法来找出测试实例的不同属性（测试方法名称、显示名称、标签等）。
- en: 'In our example (`CustomArgumentsProvider1`), the context is used to write the
    test method name in the standard output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子（`CustomArgumentsProvider1`）中，上下文被用来将测试方法名称写入标准输出：
- en: '![](img/00089.jpeg)*ExtensionContext* API'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00089.jpeg)*ExtensionContext* API'
- en: 'Thus, when executing this example, we can see two tests being executed. Moreover,
    we can check the log trace with the test method, thanks to the `ExtensionContext`
    object inside, out `ArgumentsProvider` instance:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当执行这个例子时，我们可以看到两个测试被执行。此外，我们可以通过`ExtensionContext`对象内部的`ArgumentsProvider`实例来检查测试方法的日志跟踪：
- en: '![](img/00090.gif)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00090.gif)'
- en: Execution of parameterized test using *@ArgumentsSource*
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@ArgumentsSource*执行参数化测试
- en: 'Several argument sources can be applied to the same parameterized test. In
    fact, this can be done in two different ways in the Jupiter programming model:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数来源可以应用于同一个参数化测试。事实上，在Jupiter编程模型中可以通过两种不同的方式来实现这一点：
- en: Using several annotation of `@ArgumentsSource` together with the same `@ParameterizedTest`.
    This can be done since `@ArgumentsSource` is a `java.lang.annotation.Repeatable`
    annotation.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个`@ArgumentsSource`注解与相同的`@ParameterizedTest`。这可以通过`@ArgumentsSource`是一个`java.lang.annotation.Repeatable`注解来实现。
- en: 'Using the annotation `@ArgumentsSources` (notice the source is plural here).
    This annotation is simply a container for one or more `@ArgumentsSource`. The
    following class shows a simple example:'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注解`@ArgumentsSources`（注意这里的来源是复数）。这个注解只是一个容器，用于一个或多个`@ArgumentsSource`。下面的类展示了一个简单的例子：
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Supposing that the second argument provider (`CustomArgumentsProvider2.**class**`)
    specifies two or more sets of argument, when executing the test class there will
    be four test executions:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第二个参数提供程序（`CustomArgumentsProvider2.**class**`）指定了两个或更多组参数，当执行测试类时，将有四个测试执行：
- en: '![](img/00091.gif)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00091.gif)'
- en: Execution of parameterized test using *@ArgumentsSources*
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*@ArgumentsSources*执行参数化测试
- en: Argument conversion
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数转换
- en: To support use cases such as `@CsvSource` and `@CsvFileSource`, Jupiter provides
    a number of built-in implicit converters. Moreover, these converters can be implemented
    based on specific needs by means of explicit converters. This section covers both
    types of conversions.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`@CsvSource`和`@CsvFileSource`等用例，Jupiter提供了一些内置的隐式转换器。此外，这些转换器可以根据特定需求实现显式转换器。本节涵盖了两种类型的转换。
- en: Implicit conversion
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式转换
- en: 'Internally, JUnit 5 handles a set of rules for the conversion of parameters
    from `String` to the actual argument type. For example, if `@ParameterizedTests`
    declares a parameter of type `TimeUnit`, but the declared source is a `String`,
    internally this `String` will be converted to `TimeUnit`. The following table
    summarizes the rules of implicit conversions in JUnit 5 for parameterized test
    arguments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，JUnit 5处理了一组规则，用于将参数从`String`转换为实际的参数类型。例如，如果`@ParameterizedTests`声明了一个`TimeUnit`类型的参数，但声明的来源是一个`String`，那么这个`String`将被转换为`TimeUnit`。下表总结了JUnit
    5中参数化测试参数的隐式转换规则：
- en: '| **Target Type** | **Example** |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| **目标类型** | **示例** |'
- en: '| `boolean/Boolean` | `"false"` -> `false` |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `boolean/Boolean` | `"false"` -> `false` |'
- en: '| `byte/Byte` | `"1"` -> `(byte) 1` |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `byte/Byte` | `"1"` -> `(byte) 1` |'
- en: '| `char/Character` | `"a"` -> `''a''` |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `char/Character` | `"a"` -> `''a''` |'
- en: '| `short/Short` | `"2"` -> `(short) 2` |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `short/Short` | `"2"` -> `(short) 2` |'
- en: '| `int/Integer` | `"3"` -> `3` |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `int/Integer` | `"3"` -> `3` |'
- en: '| `long/Long` | `"4"` -> `4L` |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `long/Long` | `"4"` -> `4L` |'
- en: '| `float/Float` | `"5.0"` -> `5.0f` |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `float/Float` | `"5.0"` -> `5.0f` |'
- en: '| `double/Double` | `"6.0"` -> `6.0d` |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `double/Double` | `"6.0"` -> `6.0d` |'
- en: '| `Enum subclass` | `"SECONDS"` -> `TimeUnit.SECONDS` |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `Enum子类` | `"SECONDS"` -> `TimeUnit.SECONDS` |'
- en: '| `java.time.Instant` | `"1970-01-01T00:00:00Z"` -> `Instant.ofEpochMilli(0)`
    |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.Instant` | `"1970-01-01T00:00:00Z"` -> `Instant.ofEpochMilli(0)`
    |'
- en: '| `java.time.LocalDate` | `"2017-10-24"` -> `LocalDate.of(2017, 10, 24)` |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.LocalDate` | `"2017-10-24"` -> `LocalDate.of(2017, 10, 24)` |'
- en: '| `java.time.LocalDateTime` | `"2017-03-14T12:34:56.789"` -> `LocalDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000)` |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.LocalDateTime` | `"2017-03-14T12:34:56.789"` -> `LocalDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000)` |'
- en: '| `java.time.LocalTime` | `"12:34:56.789"` -> `LocalTime.of(12, 34, 56, 789_000_000)`
    |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.LocalTime` | `"12:34:56.789"` -> `LocalTime.of(12, 34, 56, 789_000_000)`
    |'
- en: '| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"` -> `OffsetDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.OffsetDateTime` | `"2017-03-14T12:34:56.789Z"` -> `OffsetDateTime.of(2017,
    3, 14, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
- en: '| `java.time.OffsetTime` | `"12:34:56.789Z"` -> `OffsetTime.of(12, 34, 56,
    789_000_000, ZoneOffset.UTC)` |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.OffsetTime` | `"12:34:56.789Z"` -> `OffsetTime.of(12, 34, 56,
    789_000_000, ZoneOffset.UTC)` |'
- en: '| `java.time.Year` | `"2017"` -> `Year.of(2017)` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.Year` | `"2017"` -> `Year.of(2017)` |'
- en: '| `java.time.YearMonth` | `"2017-10"` -> `YearMonth.of(2017, 10)` |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.YearMonth` | `"2017-10"` -> `YearMonth.of(2017, 10)` |'
- en: '| `java.time.ZonedDateTime` | `"2017-10-24T12:34:56.789Z"` -> `ZonedDateTime.of(2017,
    10, 24, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `java.time.ZonedDateTime` | `"2017-10-24T12:34:56.789Z"` -> `ZonedDateTime.of(2017,
    10, 24, 12, 34, 56, 789_000_000, ZoneOffset.UTC)` |'
- en: 'The following example shows several examples of implicit conversion. The first
    test (`testWithImplicitConversionToBoolean`) declares a `String` source as `"true"`,
    but then, the expected argument type is `Boolean`. Similarly, the second test
    (`"testWithImplicitConversionToInteger"`) makes an implicit conversion from `String`
    to `Integer`. The third test (`testWithImplicitConversionToEnum`) converts the
    input `String` to `TimeUnit` (enumeration), and finally the fourth test (`testWithImplicitConversionToLocalDate`)
    produces a conversion to `LocalDate`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子展示了隐式转换的几个例子。第一个测试（`testWithImplicitConversionToBoolean`）声明了一个`String`源为`"true"`，但预期的参数类型是`Boolean`。类似地，第二个测试（`"testWithImplicitConversionToInteger"`）对`String`进行了隐式转换为`Integer`。第三个测试（`testWithImplicitConversionToEnum`）将输入的`String`转换为`TimeUnit`（枚举），最后第四个测试（`testWithImplicitConversionToLocalDate`）进行了转换为`LocalDate`：
- en: '[PRE30]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can check the actual type of the argument in the console. Each test writes
    a line in the standard output with the value and the type of each argument:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在控制台中检查参数的实际类型。每个测试都会在标准输出中写入一行，显示每个参数的值和类型：
- en: '![](img/00092.gif)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00092.gif)'
- en: Execution of parameterized tests using implicit argument conversion
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用隐式参数转换执行参数化测试
- en: Explicit conversion
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式转换
- en: 'If the implicit conversion provided by JUnit 5 is not enough to cover our needs,
    we can use the explicit conversion capability. Thanks to this feature, we can
    specify a class which is going to make the custom conversion of parameter types.
    This custom converter is identified with the annotation `@ConvertWith`, referring
    to the argument to be converted with. Consider the following example. This parameterized
    test declares a custom converter for its test method argument:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JUnit 5提供的隐式转换不足以满足我们的需求，我们可以使用显式转换功能。有了这个功能，我们可以指定一个类来对参数类型进行自定义转换。这个自定义转换器使用`@ConvertWith`注释进行标识，指定要进行转换的参数。考虑下面的例子。这个参数化测试为其测试方法参数声明了一个自定义转换器：
- en: '[PRE31]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Our custom converted is a class that extends the JUnit 5's `SimpleArgumentConverter`.
    This class overrides the method convert, in which the actual conversion takes
    place. In the example, we simply transform whatever argument source to `String`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的自定义转换器是一个扩展了JUnit 5的`SimpleArgumentConverter`的类。这个类重写了convert方法，在这个方法中进行了实际的转换。在这个例子中，我们简单地将任何参数源转换为`String`。
- en: '[PRE32]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'All in all, when the test is executed, the seven enumeration constants defined
    in `TimeUnit` will be passed as arguments to the test, prior conversion to `String`
    in `CustomArgumentsConverter`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当测试被执行时，`TimeUnit`中定义的七个枚举常量将作为参数传递给测试，然后在`CustomArgumentsConverter`中转换为`String`：
- en: '![](img/00093.gif)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00093.gif)'
- en: Execution of parameterized tests using explicit argument conversion
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式参数转换执行参数化测试
- en: Custom names
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义名称
- en: The last feature related with parameterized tests in JUnit 5 has to do with
    the display name of each execution of tests. As we learned, a parameterized test
    is usually executed as several single tests. Therefore, for the shake of traceability,
    it is good practice to link each test execution with the argument source.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5中与参数化测试相关的最后一个特性与每次测试执行的显示名称有关。正如我们所学到的，参数化测试通常被执行为多个单独的测试。因此，为了追踪性，将每个测试执行与参数源关联起来是一个好的做法。
- en: 'To that aim, the annotation `@ParameterizedTest` accepts an element called
    name in which we can specify a custom name (`String`) for the test execution.
    Moreover, in this String, we can use several built-in placeholders, as described
    in the following table:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，注释`@ParameterizedTest`接受一个名为name的元素，在其中我们可以为测试执行指定自定义名称（`String`）。此外，在这个字符串中，我们可以使用几个内置的占位符，如下表所述：
- en: '| **Placeholder** | **Description** |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| **占位符** | **描述** |'
- en: '| `{index}` | Current invocation index (first one is 1, second is 2, …) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `{index}` | 当前调用索引（第一个为1，第二个为2，...） |'
- en: '| `{arguments}` | Comma-separated arguments complete list |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `{arguments}` | 逗号分隔的参数完整列表 |'
- en: '| `{0}, {1}, …` | Value for an individual argument (first one is 0, second
    is 2, …) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `{0}, {1}, …` | 一个单独参数的值（第一个为0，第二个为2，...） |'
- en: 'Let’s see a simple example. The following class contains a parameterized test
    whose arguments are defined using a `@CsvSource` annotation. The test method accepts
    two arguments (`String` and `int`). In addition, we are specifying the element
    name of the annotation `@ParameterizedTest` with a custom message, using the placeholders
    for the current test invocation (`{index}`) and also for the values of each argument:
    the first one (`{0}`) and the second one (`{1}`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。下面的类包含一个参数化测试，其参数是使用`@CsvSource`注释定义的。测试方法接受两个参数（`String`和`int`）。此外，我们使用占位符为注释`@ParameterizedTest`的元素名称指定了一个自定义消息，用于当前测试调用的占位符（`{index}`）以及每个参数的值：第一个（`{0}`）和第二个（`{1}`）：
- en: '[PRE33]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When executing this test in an IDE (IntelliJ in the following screenshot),
    we can see how the display name is different for each test execution:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在IDE（如下面的IntelliJ截图）中执行此测试时，我们可以看到每个测试执行的显示名称是不同的：
- en: '![](img/00094.jpeg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00094.jpeg)'
- en: Execution of parameterized tests using custom names in IntelliJ IDE
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在IntelliJ IDE中使用自定义名称执行参数化测试
- en: Java 9
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 9
- en: Java 9 was released for **General Availability** (**GA**) on September 21, 2017\.
    There are many new features shipped with Java 9\. Among them, modularity is the
    defining feature for Java 9.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9于2017年9月21日发布为**通用可用性**（**GA**）。Java 9中有许多新功能。其中，模块化是Java 9的主要特性。
- en: 'So far, there has been a problem of modularity in Java, especially significant
    for large codebases. Every public class can be accessed by any other class in
    the classpath, leading to inadvertent usage of classes. In addition, the classpath
    presents potential problems, such as the inability to know whether or not there
    are duplicated JARs. To solve these problems, Java 9 provides the Java Platform
    Module System, which allows to create modular JAR files. This type of modules
    contains an additional module descriptor called `module-info.java`. The content
    of such files is quite simple: it declares dependencies to other modules using
    the keyword requires, and exports its own packages with the keyword `exports`.
    All non-exported packages are encapsulated in the module by default, for example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Java中存在模块化问题，特别是对于大型代码库来说非常重要。每个公共类都可以被类路径中的任何其他类访问，导致意外使用类。此外，类路径存在潜在问题，例如无法知道是否存在重复的JAR。为了解决这些问题，Java
    9提供了Java平台模块系统，允许创建模块化的JAR文件。这种类型的模块包含一个额外的模块描述符，称为`module-info.java`。这些文件的内容非常简单：它使用关键字requires声明对其他模块的依赖，并使用关键字`exports`导出自己的包。所有未导出的包默认情况下都被模块封装，例如：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We can represent the relationship between these modules as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以表示这些模块之间的关系如下：
- en: '![](img/00095.jpeg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00095.jpeg)'
- en: Example of relationship between modules in Java 9
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9中模块之间的关系示例
- en: 'Other new capabilities of Java 9 are summarized in the following list:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9的其他新功能总结如下：
- en: The use modules allow to create a minimal runtime JDK optimized for the given
    application, instead of using a fully JDK installation. This can be achieve using
    the tool the *jlink* shipped with JDK 9.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块允许创建一个针对特定应用程序进行了优化的最小运行时JDK，而不是使用完整的JDK安装。这可以通过使用JDK 9附带的工具*jlink*来实现。
- en: Java 9 provides an interactive environment to execute Java code, directly from
    the shell. This type of utility is commonly known as **Read-Eval-Print-Loop**
    (**REPL**), which is called **JShell** in JDK 9.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9提供了一个交互式环境，可以直接从shell中执行Java代码。这种类型的实用程序通常被称为**Read-Eval-Print-Loop**（**REPL**），在JDK
    9中称为**JShell**。
- en: 'Collection factory methods, Java 9 provides the capability of creating collections
    (for example, lists or sets) and populates them in a single line:'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合工厂方法，Java 9提供了创建集合（例如列表或集合）并在一行中填充它们的能力：
- en: '[PRE35]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Stream API improvements**: Streams was introduced in Java 8, and they allow
    to create declarative pipelines of transformations on collections. In Java 9,
    the methods `dropWhile`, `takeWhile`, and `ofNullable` are added to the Stream
    API.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Stream API改进**：流是在Java 8中引入的，它们允许在集合上创建声明性转换管道。在Java 9中，Stream API添加了`dropWhile`、`takeWhile`和`ofNullable`方法。'
- en: '**Private interface methods**: Java 8 provides default methods on interfaces.
    The limitation so far is that default methods in Java 8 must be public. Now, in
    Java 9, these default methods can be also private, helping to structure better
    their implementation.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有接口方法**：Java 8在接口上提供了默认方法。到目前为止，Java 8中默认方法的限制是默认方法必须是公共的。现在，在Java 9中，这些默认方法也可以是私有的，有助于更好地结构化它们的实现。'
- en: '**HTTP/2**: Java 9 supports out of the box, version 2 of HTTP and also WebSockets.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTP/2**：Java 9支持开箱即用的HTTP版本2和WebSockets。'
- en: '**Multi release JARs**: This feature allows to create alternative versions
    of classes, depending on the version of the JRE executing the JAR. To that aim,
    under the folder `META-INF/versions/<java-version>`, we can specify different
    versions of compiled classes, which will used only when the JRE version matches
    the version.'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多版本JAR**：此功能允许根据执行JAR的JRE版本创建类的替代版本。为此，在文件夹`META-INF/versions/<java-version>`下，我们可以指定不同版本的已编译类，仅当JRE版本与该版本匹配时才使用。'
- en: '**Improved Javadoc**: Last but not least, Java 9 allows to create HTML5 compliant
    Javadoc with an integrated search capability.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进的Javadoc**：最后但并非最不重要的是，Java 9允许创建具有集成搜索功能的HTML5兼容Javadoc。'
- en: JUnit 5 and Java 9 compatibility
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5和Java 9的兼容性
- en: 'Since M5, all JUnit 5 artifacts are shipped with compiled module descriptors
    for Java 9, declared in its JAR manifest (file `MANIFEST.MF`). For example, the
    content of the manifest for the artifact `junit-jupiter-api` M6 is the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 自M5以来，所有JUnit 5构件都附带了为Java 9编译的模块描述符，在其JAR清单（文件`MANIFEST.MF`）中声明。例如，构件`junit-jupiter-api`
    M6的清单内容如下：
- en: '[PRE36]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With regards to Java 9, the interesting thing is the declaration `Automatic-Module-Name`.
    This allows to test modules to require the JUnit 5 module simply by adding the
    following lines to its module descriptor file (`module-info.java`):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Java 9，有趣的是声明`Automatic-Module-Name`。这允许测试模块通过将以下行添加到其模块描述符文件（`module-info.java`）来要求JUnit
    5模块：
- en: '[PRE37]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Beyond JUnit 5.0
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit 5.0之后
- en: 'JUnit 5.0 GA (General Availability) was released on September 10, 2017\. Furthermore,
    JUnit is a living project, and new features are planned for the next release,
    that is, 5.1 (with no release agenda scheduled at the time of writing). The backlog
    for the next release of JUnit 5 can be seen on GitHub: [https://github.com/junit-team/junit5/milestone/3](https://github.com/junit-team/junit5/milestone/3).
    Among other, the following features are planned for JUnit 5.1:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5.0 GA（正式版本）于2017年9月10日发布。此外，JUnit是一个不断发展的项目，新功能计划在下一个版本5.1中发布（目前尚未安排发布日程）。JUnit
    5的下一个版本的待办事项可以在GitHub上查看：[https://github.com/junit-team/junit5/milestone/3](https://github.com/junit-team/junit5/milestone/3)。其中，计划为JUnit
    5.1添加以下功能：
- en: 'Scenario tests: This feature has to do with the capability of ordering different
    test methods within a class. To do that, the following annotations are planned:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景测试：这个功能涉及在一个类中对不同的测试方法进行排序的能力。为了做到这一点，计划使用以下注释：
- en: '`@ScenarioTest`: A class-level annotation used to denote that a test class
    contains steps that make up a single scenario test.'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@ScenarioTest`：用于表示测试类包含组成单个场景测试的步骤的类级别注释。'
- en: '`@Step`: A method-level annotation used to denote that a test method is a single
    step within the scenario test.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Step`：用于表示测试方法是场景测试中的单个步骤的方法级别注释。'
- en: 'Support for parallel tests execution: Concurrency is one of the main aspects
    to be improved in JUnit 5.1, and therefore the support of out of the box concurrent
    test execution is planned.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持并行测试执行：并发是JUnit 5.1中需要改进的主要方面之一，因此计划支持开箱即用的并发测试执行。
- en: 'Mechanism for terminating dynamic tests early: This is an enhancement of the
    JUnit 5.0 support for dynamic tests, introducing a timeout to stop the execution
    before it terminates itself (to avoid uncontrolled non-deterministic executions).'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提前终止动态测试的机制：这是对JUnit 5.0对动态测试的增强支持，引入了超时以在测试自行终止之前停止执行（以避免不受控制的非确定性执行）。
- en: Several improvements in test reporting, such as capturing `stdout`/`stderr`
    and include in test reports, provide reliable way to get the class (classname)
    of executed test methods, or specify the order of tests in test reports, among
    others.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试报告方面的几项改进，比如捕获`stdout`/`stderr`并包含在测试报告中，提供了可靠的方式来获取执行测试方法的类（类名），或者在测试报告中指定测试的顺序，等等。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter contains a comprehensive summary of the advance capabilities to
    write rich Jupiter tests driven by examples. First, we have learned that parameters
    can be injected in constructor and methods in test classes. JUnit 5 provides three
    parameter resolvers out of the box, namely resolver for parameters of the type
    `TestInfo` (to retrieve information about the current test), resolver for parameters
    of the type `RepetitionInfo` (to retrieve information about the current repetition),
    and resolver for parameters of the type `TestReporter` (to publish additional
    data about the current test run).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了一个全面的摘要，介绍了编写丰富的Jupiter测试的先进能力。首先，我们已经了解到参数可以被注入到测试类的构造函数和方法中。JUnit 5提供了三个参数解析器，分别是用于类型为`TestInfo`的参数（用于检索有关当前测试的信息），用于类型为`RepetitionInfo`的参数（用于检索有关当前重复的信息），以及用于类型为`TestReporter`的参数（用于发布有关当前测试运行的附加数据）。
- en: Another new feature implemented in Jupiter is the concept of dynamic tests.
    So far in JUnit 3 and 4, tests are defined at compile time (that is static tests).
    Jupiter introduces the annotation `@TestFactory` that allows to generate test
    at runtime. Another new concept provided by the Jupiter programming model are
    the test templates. These templates re defined using the annotation `@TestTemplate` and
    are not regular test cases but rather a template for test cases.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Jupiter中实现的另一个新功能是动态测试的概念。到目前为止，在JUnit 3和4中，测试是在编译时定义的（即静态测试）。Jupiter引入了`@TestFactory`注解，允许在运行时生成测试。Jupiter编程模型提供的另一个新概念是测试模板。这些模板使用`@TestTemplate`注解定义，不是常规的测试用例，而是测试用例的模板。
- en: 'JUnit 5 implements an enhancement support for parameterized tests. In order
    to implement this type of tests, the annotation `@ParameterizedTest` must be used.
    Together with this annotation, an argument provider should be also specified.
    To that aim, several annotations are provided in Jupiter: `@ValueSource`, `@EnumSource`,
    `@MethodSource`, `@CsvSource`, `@CsvFileSource`, and `@ArgumentSource`.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit 5实现了对参数化测试的增强支持。为了实现这种类型的测试，必须使用`@ParameterizedTest`注解。除了这个注解，还应该指定一个参数提供者。为此，Jupiter提供了几个注解：`@ValueSource`、`@EnumSource`、`@MethodSource`、`@CsvSource`、`@CsvFileSource`和`@ArgumentSource`。
- en: In the [chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb), *Integration
    Of JUnit 5 With External Frameworks*, we are going to learn how JUnit 5 interacts
    with external frameworks. Concretely, we are going to review several JUnit 5 extension,
    which provides capabilities to use Mockito, Spring, Selenium, Cucumber, or Docker.
    Moreover, we present a Gradle plugin, which allows to execute tests within an
    Android project. Finally, we find out how to use several REST libraries (for example,
    REST Assured or WireMock) to test RESTful services.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)中，*JUnit 5与外部框架的集成*，我们将学习JUnit
    5如何与外部框架交互。具体来说，我们将回顾几个JUnit 5扩展，它们提供了使用Mockito、Spring、Selenium、Cucumber或Docker的能力。此外，我们还介绍了一个Gradle插件，允许在Android项目中执行测试。最后，我们将了解如何使用几个REST库（例如REST
    Assured或WireMock）来测试RESTful服务。
