- en: Chapter 9. Animations and Moving the Camera
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。动画和移动相机
- en: 'In the previous chapters, we have seen some simple animations, but nothing
    too complex. In [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene
    with Three.js"), *Creating Your First 3D Scene with Three.js*, we introduced the
    basic rendering loop, and in the chapter following that, we used that to rotate
    some simple objects and show a couple of other basic animation concepts. In this
    chapter, we''re going to look in more detail at how animation is supported by
    Three.js. We will look in detail at the following four subjects:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们看到了一些简单的动画，但没有太复杂的。在[第1章](ch01.html "第1章。使用Three.js创建您的第一个3D场景")中，*使用Three.js创建您的第一个3D场景*，我们介绍了基本的渲染循环，在接下来的章节中，我们使用它来旋转一些简单的对象，并展示了一些其他基本的动画概念。在本章中，我们将更详细地了解Three.js如何支持动画。我们将详细讨论以下四个主题：
- en: Basic animation
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本动画
- en: Moving the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动相机
- en: Morphing and skinning
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变形和皮肤
- en: Loading external animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载外部动画
- en: We start with the basic concepts behind animations.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从动画背后的基本概念开始。
- en: Basic animations
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本动画
- en: 'Before we look at the examples, let''s do a quick recap of what was shown in
    [Chapter 1](ch01.html "Chapter 1. Creating Your First 3D Scene with Three.js"),
    *Creating Your First 3D Scene with Three.js*, on the render loop. To support animations,
    we need to tell Three.js to render the scene every so often. For this, we use
    the standard HTML5 `requestAnimationFrame` functionality, as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看例子之前，让我们快速回顾一下在[第1章](ch01.html "第1章。使用Three.js创建您的第一个3D场景")中展示的渲染循环。为了支持动画，我们需要告诉Three.js每隔一段时间渲染一次场景。为此，我们使用标准的HTML5
    `requestAnimationFrame`功能，如下所示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With this code, we only need to call the `render()` function once when were
    done initializing the scene. In the `render()` function itself, we use `requestAnimationFrame`
    to schedule the next rendering. This way, the browser will make sure the `render()`
    function is called at the correct interval (usually around 60 times a second).
    Before `requestAnimationFrame` was added to browsers, `setInterval(function, interval)`
    or `setTimeout(function, interval)` were used. These would call the specified
    function once every set interval. The problem with this approach is that it doesn't
    take into account what else is going on. Even if your animation isn't shown or
    is in a hidden tab, it is still called and is still using resources. Another issue
    is that these functions update the screen whenever they are called, not when it
    is the best time for the browser, which means higher CPU usage. With `requestAnimationFrame`,
    we don't tell the browser when it needs to update the screen; we ask the browser
    to run the supplied function when it's most opportune. Usually, this results in
    a frame rate of about 60 fps. With `requestAnimationFrame`, your animations will
    run more smoothly and will be more CPU- and GPU-friendly, and you don't have to
    worry about timing issues yourself.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们只需要在初始化场景完成后一次调用`render()`函数。在`render()`函数本身中，我们使用`requestAnimationFrame`来安排下一次渲染。这样，浏览器会确保`render()`函数以正确的间隔被调用（通常大约每秒60次）。在`requestAnimationFrame`添加到浏览器之前，使用`setInterval(function,
    interval)`或`setTimeout(function, interval)`。这些会在每个设置的间隔调用指定的函数。这种方法的问题在于它不考虑其他正在进行的事情。即使您的动画没有显示或在隐藏的标签中，它仍然被调用并且仍在使用资源。另一个问题是，这些函数在被调用时更新屏幕，而不是在浏览器最佳时机，这意味着更高的CPU使用率。使用`requestAnimationFrame`，我们不告诉浏览器何时需要更新屏幕；我们要求浏览器在最合适的时机运行提供的函数。通常，这会导致大约60fps的帧速率。使用`requestAnimationFrame`，您的动画将运行得更顺畅，对CPU和GPU更友好，而且您不必担心自己的时间问题。
- en: Simple animations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单动画
- en: 'With this approach, we can very easily animate objects by changing their rotation,
    scale, position, material, vertices, faces, and anything else you can imagine.
    In the next render loop, Three.js will render the changed properties. A very simple
    example, based on the one we already saw in [Chapter 1](ch01.html "Chapter 1. Creating
    Your First 3D Scene with Three.js"), *Creating Your First 3D Scene with Three.js*,
    is available in `01-basic-animation.html`. The following screenshot shows this
    example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以通过改变它们的旋转、缩放、位置、材质、顶点、面和您能想象到的任何其他东西来非常容易地对对象进行动画处理。在下一个渲染循环中，Three.js将渲染更改的属性。一个非常简单的例子，基于我们在[第1章](ch01.html
    "第1章。使用Three.js创建您的第一个3D场景")中已经看到的一个例子，可以在`01-basic-animation.html`中找到。以下截图显示了这个例子：
- en: '![Simple animations](graphics/2215OS_09_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![简单动画](graphics/2215OS_09_01.jpg)'
- en: 'The render loop for this is very simple. Just change the properties of the
    involved meshes, and Three.js handles the rest. Here''s how we do this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个渲染循环非常简单。只需改变相关网格的属性，Three.js会处理其余的。我们是这样做的：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Nothing spectacular here, but it nicely shows the concept behind the basic animations
    we discuss in this book. In the next section, we'll take a quick sidestep. Besides
    animations, an important aspect, which you'll quickly run into when working with
    Three.js in more complex scenes, is the ability to select objects on screen using
    the mouse.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的，但它很好地展示了我们在本书中讨论的基本动画背后的概念。在下一节中，我们将快速地进行一个侧步。除了动画，另一个重要的方面是，当在更复杂的场景中使用Three.js时，您将很快遇到的一个方面是使用鼠标在屏幕上选择对象的能力。
- en: Selecting objects
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择对象
- en: 'Even though not directly related to animations, since we''ll be looking into
    cameras and animations in this chapter, it is a nice addition to the subjects
    explained in this chapter. What we''ll show here is how you can select an object
    from the scene using the mouse. We''ll first look at the code required for this
    before we look at the example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与动画没有直接关系，但由于我们将在本章中研究相机和动画，这是对本章中解释的主题的一个很好的补充。我们将展示如何使用鼠标从场景中选择对象。在我们查看示例之前，我们将首先看看所需的代码：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, we use `THREE.Projector` together with `THREE.Raycaster` to determine
    whether we''ve clicked on a specific object. What happens when we click on the
    screen is the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用`THREE.Projector`和`THREE.Raycaster`来确定我们是否点击了特定的对象。当我们点击屏幕时会发生以下情况：
- en: First, `THREE.Vector3` is created based on the position where we've clicked
    on the screen.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，根据我们在屏幕上点击的位置创建了`THREE.Vector3`。
- en: Next, with the `vector.unproject` function, we convert the clicked position
    on screen to coordinates in our Three.js scene. In other words, we unproject from
    screen coordinates to world coordinates.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用`vector.unproject`函数，我们将屏幕上的点击位置转换为我们Three.js场景中的坐标。换句话说，我们从屏幕坐标转换为世界坐标。
- en: Next, we create `THREE.Raycaster`. With `THREE.Raycaster`, we can cast rays
    into our scene. In this case, we emit a ray from the position of the camera (`camera.position`)
    to the position we clicked on in the scene.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`THREE.Raycaster`。使用`THREE.Raycaster`，我们可以在场景中发射射线。在这种情况下，我们从相机的位置（`camera.position`）发射射线到我们在场景中点击的位置。
- en: Finally, we use the `raycaster.intersectObjects` function to determine whether
    any of the supplied objects are hit by this ray.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`raycaster.intersectObjects`函数来确定射线是否击中了提供的任何对象。
- en: 'The result from this final step contains information on any object that is
    hit by this ray. The following information is provided:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最终步骤的结果包含了被射线击中的任何对象的信息。提供了以下信息：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The mesh that was clicked on is the object, and `face` and `faceIndex` point
    to the face of the mesh that was selected. The `distance` value is measured from
    the camera to the clicked object, and `point` is the exact position on the mesh
    where it was clicked. You can test this out in the `02-selecting-objects.html`
    example. Any object you click on will become transparent and the details of the
    selection will be printed to the console.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 被点击的网格是对象，`face`和`faceIndex`指向被选中的网格的面。`distance`值是从相机到点击对象的距离，`point`是点击网格的确切位置。您可以在`02-selecting-objects.html`示例中测试这一点。您点击的任何对象都将变为透明，并且选择的详细信息将被打印到控制台。
- en: 'If you want to see the path of the ray that is cast, you can enable the `showRay`
    property from the menu. The following screenshot shows the ray that was used to
    select the blue sphere:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看到发射的射线路径，可以从菜单中启用`showRay`属性。以下屏幕截图显示了用于选择蓝色球体的射线：
- en: '![Selecting objects](graphics/2215OS_09_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![选择对象](graphics/2215OS_09_02.jpg)'
- en: Now that we've finished this small intermission, let's get back to our animations.
    Until now, we've changed the properties in our render loop to animate an object.
    In the next section, we'll look at a small library that makes defining animations
    a lot easier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了这个小插曲，让我们回到我们的动画中。到目前为止，我们已经在渲染循环中改变了属性以使对象动画化。在下一节中，我们将看一下一个小型库，它可以更轻松地定义动画。
- en: Animating with Tween.js
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Tween.js进行动画
- en: Tween.js is a small JavaScript library that you can download from [https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)
    and that you can use to easily define the transition of a property between two
    values. All the intermediate points between the start and end values are calculated
    for you. This process is called **tweening**.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Tween.js是一个小型的JavaScript库，您可以从[https://github.com/sole/tween.js/](https://github.com/sole/tween.js/)下载，并且您可以使用它来轻松定义属性在两个值之间的过渡。所有开始和结束值之间的中间点都为您计算。这个过程称为**缓动**。
- en: 'For instance, you can use this library to change the *x* position of a mesh
    from 10 to 3 in 10 seconds, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用这个库来在10秒内将网格的*x*位置从10改变为3，如下所示：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we've created `TWEEN.Tween`. This tween will make sure that
    the *x* property is changed from 10 to 3 over a period of 10,000 milliseconds.
    Tween.js also allows you to define how this property is changed over time. This
    can be done using linear, quadratic, or any of the other possibilities (see [http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)
    for a complete overview). The way the value is changed over time is called **easing**.
    With Tween.js, you configure this using the `easing()` function.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了`TWEEN.Tween`。这个缓动将确保*x*属性在10,000毫秒的时间内从10改变为3。Tween.js还允许您定义属性随时间如何改变。这可以使用线性、二次或其他任何可能性来完成（请参阅[http://sole.github.io/tween.js/examples/03_graphs.html](http://sole.github.io/tween.js/examples/03_graphs.html)获取完整的概述）。随时间值的变化方式称为**缓动**。使用Tween.js，您可以使用`easing()`函数进行配置。
- en: 'Using this library from Three.js is very simple. If you open up the `03-animation-tween.html`
    example, you can see the Tween.js library in action. The following screenshot
    shows a still image of the example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从Three.js中使用这个库非常简单。如果您打开`03-animation-tween.html`示例，您可以看到Tween.js库的实际效果。以下屏幕截图显示了示例的静态图像：
- en: '![Animating with Tween.js](graphics/2215OS_09_03.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![使用Tween.js进行动画](graphics/2215OS_09_03.jpg)'
- en: 'In this example, we''ve taken a particle cloud from [Chapter 7](ch07.html "Chapter 7. Particles,
    Sprites, and the Point Cloud"), *Particles, Sprites, and the Point Cloud*, and
    animated all the particles down to the ground. The position of these particles
    is based on a tween created with the Tween.js library, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们从[第7章](ch07.html "第7章. 粒子、精灵和点云")中取了一个粒子云，*粒子、精灵和点云*，并将所有粒子动画化到地面上。这些粒子的位置是基于使用Tween.js库创建的缓动动画，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With this piece of code, we create two tweens: `tween` and `tweenBack`. The
    first one defines how the position property transitions from 1 to 0, and the second
    one does the opposite. With the `chain()` function, we chain these two tweens
    to each other, so these tweens will start looping when started. The final thing
    we define here is the `onUpdate` method. In this method, we walk through all the
    vertices of the particle system and change their position according to the position
    provided by the tween (`this.pos`).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这段代码，我们创建了两个缓动：`tween`和`tweenBack`。第一个定义了位置属性从1过渡到0的方式，第二个则相反。通过`chain()`函数，我们将这两个缓动链接在一起，因此这些缓动在启动时将开始循环。我们在这里定义的最后一件事是`onUpdate`方法。在这个方法中，我们遍历粒子系统的所有顶点，并根据缓动提供的位置（`this.pos`）来改变它们的位置。
- en: 'We start the tween when the model is loaded, so at the end of the following
    function, we call the `tween.start()` function:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模型加载时启动缓动，因此在以下函数的末尾，我们调用了`tween.start()`函数：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the tween is started, we need to tell the Tween.js library when we want
    it to update all the tweens it knows about. We do this by calling the `TWEEN.update()`
    function:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓动开始时，我们需要告诉Tween.js库何时更新它所知道的所有缓动。我们通过调用`TWEEN.update()`函数来实现这一点：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With these steps in place, the tween library will take care of positioning the
    various points of the point cloud. As you can see, using this library is much
    easier than having to manage the transitions yourself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些步骤，缓动库将负责定位点云的各个点。正如你所看到的，使用这个库比自己管理过渡要容易得多。
- en: Besides animating and changing objects, we can also animate a scene by moving
    the camera around. In the previous chapters, we already did this a couple of times
    by manually updating the position of the camera. Three.js also provides a number
    of additional ways of updating the camera.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通过动画和更改对象来动画场景，我们还可以通过移动相机来动画场景。在前几章中，我们已经多次通过手动更新相机的位置来实现这一点。Three.js还提供了许多其他更新相机的方法。
- en: Working with the camera
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与相机一起工作
- en: 'Three.js has a number of camera controls you can use to control the camera
    throughout a scene. These controls are located in the Three.js distribution and
    can be found in the `examples/js/controls` directory. In this section, we''ll
    look in more detail at the following controls:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js有许多相机控件可供您在整个场景中控制相机。这些控件位于Three.js发行版中，可以在`examples/js/controls`目录中找到。在本节中，我们将更详细地查看以下控件：
- en: '| Name | Description |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `FirstPersonControls` | These are controls that behave like those in first-person
    shooters. Move around with the keyboard and look around with the mouse. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `FirstPersonControls` | 这些控件的行为类似于第一人称射击游戏中的控件。使用键盘四处移动，用鼠标四处张望。 |'
- en: '| `FlyControls` | These are flight simulator-like controls. Move and steer
    with the keyboard and the mouse. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `FlyControls` | 这些是类似飞行模拟器的控件。使用键盘和鼠标进行移动和转向。 |'
- en: '| `RollControls` | This is a simpler version of `FlyControls`. Allows you to
    move around and roll around the *z* axis. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `RollControls` | 这是`FlyControls`的简化版本。允许您在*z*轴周围移动和翻滚。 |'
- en: '| `TrackBallControls` | These are the most used controls, allowing you to use
    the mouse (or the trackball) to easily move, pan, and zoom around the scene. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `TrackBallControls` | 这是最常用的控件，允许您使用鼠标（或轨迹球）轻松地在场景中移动、平移和缩放。 |'
- en: '| `OrbitControls` | This simulates a satellite in orbit around a specific scene.
    This allows you to move around with the mouse and keyboard. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `OrbitControls` | 这模拟了围绕特定场景轨道上的卫星。这允许您使用鼠标和键盘四处移动。 |'
- en: 'These controls are the most useful controls available. Besides these, Three.js
    also provides a number of additional controls you can use (but which aren''t explained
    in this book). Using these controls, however, is done in the same manner as the
    ones explained in the previous table:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控件是最有用的控件。除此之外，Three.js还提供了许多其他控件可供使用（但本书中未进行解释）。但是，使用这些控件的方式与前表中解释的方式相同：
- en: '| Name | Description |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DeviceOrientationControls` | This controls the movement of the camera based
    on the orientation of the device. It internally uses the HTML device orientation
    API ([http://www.w3.org/TR/orientation-event/](http://www.w3.org/TR/orientation-event/)).
    |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `DeviceOrientationControls` | 根据设备的方向控制摄像机的移动。它内部使用HTML设备方向API ([http://www.w3.org/TR/orientation-event/](http://www.w3.org/TR/orientation-event/))。
    |'
- en: '| `EditorControls` | These are controls that are specifically created for online
    3D editors. This is used by the Three.js online editor, which you can find at
    [http://threejs.org/editor/](http://threejs.org/editor/). |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `EditorControls` | 这些控件是专门为在线3D编辑器创建的。这是由Three.js在线编辑器使用的，您可以在[http://threejs.org/editor/](http://threejs.org/editor/)找到。
    |'
- en: '| `OculusControls` | These are controls that allow you to use an Oculus Rift
    device to look around in your scene. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `OculusControls` | 这些是允许您使用Oculus Rift设备在场景中四处张望的控件。 |'
- en: '| `OrthographicTrackballControls` | This is the same control as `TrackBallControls`
    but specifically created to be used with `THREE.OrthographicCamera`. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `OrthographicTrackballControls` | 这与`TrackBallControls`相同，但专门用于与`THREE.OrthographicCamera`一起使用。
    |'
- en: '| `PointerLockControls` | This is a simple control that locks the mouse using
    the DOM element on which the scene is rendered. This provides basic functionality
    for a simple 3D game. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `PointerLockControls` | 这是一个简单的控制，可以使用渲染场景的DOM元素锁定鼠标。这为简单的3D游戏提供了基本功能。 |'
- en: '| `TransformControls` | This is an internal control used by the Three.js editor.
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `TransformControls` | 这是Three.js编辑器使用的内部控件。 |'
- en: '| `VRControls` | This is a control that uses the `PositionSensorVRDevice` API
    to control the scene. More information on this standard can be found at [https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices).
    |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `VRControls` | 这是一个使用`PositionSensorVRDevice` API来控制场景的控制器。有关此标准的更多信息，请访问[https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices](https://developer.mozilla.org/en-US/docs/Web/API/Navigator.getVRDevices)。
    |'
- en: Besides using these camera controls, you can of course also move the camera
    yourself by setting `position` and change where it is pointed to using the `lookAt()`
    function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这些相机控制，您当然也可以通过设置`position`来自行移动相机，并使用`lookAt()`函数更改其指向的位置。
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you've worked with an older version of Three.js, you might be missing a specific
    camera control named `THREE.PathControls`. With this control, it was possible
    to define a path (for example using `THREE.Spline`) and move the camera along
    that path. In the last version of Three.js, this control was removed because of
    code complexity. The people behind Three.js are currently working on a replacement,
    but one isn't available yet.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经使用过较旧版本的Three.js，您可能会错过一个名为`THREE.PathControls`的特定相机控件。使用此控件，可以定义路径（例如使用`THREE.Spline`）并沿该路径移动相机。在最新版本的Three.js中，由于代码复杂性，此控件已被移除。Three.js背后的人目前正在开发替代方案，但目前还没有可用的替代方案。
- en: The first of the controls we'll look at is `TrackballControls`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看一下`TrackballControls`控件。
- en: TrackballControls
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TrackballControls
- en: 'Before you can use `TrackballControls`, you first need to include the correct
    JavaScript file into your page:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`TrackballControls`之前，您首先需要将正确的JavaScript文件包含到您的页面中：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this included, we can create the controls and attach them to the camera,
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 包括这些内容后，我们可以创建控件并将其附加到相机上，如下所示：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Updating the position of the camera is something we do in the render loop,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 更新相机的位置是我们在渲染循环中做的事情，如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code snippet, we see a new Three.js object, `THREE.Clock`.
    The `THREE.Clock` object can be used to exactly calculate the elapsed time that
    a specific invocation or rendering loop takes to complete. You can do this by
    calling the `clock.getDelta()` function. This function will return the elapsed
    time between this call and the previous call to `getDelta()`. To update the position
    of the camera, we call the `trackballControls.update()` function. In this function,
    we need to provide the time that has passed since the last time this update function
    was called. For this, we use the `getDelta()` function from the `THREE.Clock`
    object. You might wonder why we don't just pass in the frame rate (1/60 seconds)
    to the `update` function. The reason is that with `requestAnimationFrame`, we
    can expect 60 fps, but this isn't guaranteed. Depending on all kinds of external
    factors, the frame rate might change. To make sure the camera turns and rotates
    smoothly, we need to pass in the exact elapsed time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，我们看到了一个新的Three.js对象，`THREE.Clock`。`THREE.Clock`对象可用于精确计算特定调用或渲染循环完成所需的经过时间。您可以通过调用`clock.getDelta()`函数来实现这一点。此函数将返回此调用和上一次调用`getDelta()`之间的经过时间。要更新相机的位置，我们调用`trackballControls.update()`函数。在此函数中，我们需要提供自上次调用此更新函数以来经过的时间。为此，我们使用`THREE.Clock`对象的`getDelta()`函数。您可能想知道为什么我们不只是将帧速率（1/60秒）传递给`update`函数。原因是，使用`requestAnimationFrame`，我们可以期望60
    fps，但这并不是保证的。根据各种外部因素，帧速率可能会发生变化。为了确保相机平稳转动和旋转，我们需要传递确切的经过时间。
- en: 'A working example for this can be found in `04-trackball-controls-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的工作示例可以在`04-trackball-controls-camera.html`中找到。以下截图显示了此示例的静态图像：
- en: '![TrackballControls](graphics/2215OS_09_04.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![TrackballControls](graphics/2215OS_09_04.jpg)'
- en: 'You can control the camera in the following manner:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以以下方式控制相机：
- en: '| Control | Action |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse button and move | Rotate and roll the camera around the scene
    |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 左键并移动 | 围绕场景旋转和滚动相机 |'
- en: '| Scroll wheel | Zoom in and zoom out |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮 | 放大和缩小 |'
- en: '| Middle mouse button and move | Zoom in and zoom out |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 中键并移动 | 放大和缩小 |'
- en: '| Right mouse button and move | Pan around the scene |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 右键并移动 | 在场景中移动 |'
- en: There are a couple of properties that you can use to fine-tune how the camera
    acts. For instance, you can set how fast the camera rotates with the `rotateSpeed`
    property and disable zooming by setting the `noZoom` property to `true`. In this
    chapter, we won't go into detail on what each property does as they are pretty
    much self-explanatory. For a complete overview of what is possible, look at the
    source of the `TrackballControls.js` file where these properties are listed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些属性可以用来微调相机的行为。例如，您可以通过设置`rotateSpeed`属性来设置相机旋转的速度，并通过将`noZoom`属性设置为`true`来禁用缩放。在本章中，我们不会详细介绍每个属性的作用，因为它们几乎是不言自明的。要了解可能性的完整概述，请查看`TrackballControls.js`文件的源代码，其中列出了这些属性。
- en: FlyControls
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FlyControls
- en: 'The next control we''ll look at is `FlyControls`. With `FlyControls`, you can
    fly around a scene using controls also found in flight simulators. An example
    can be found in `05-fly-controls-camera.html`. The following screenshot shows
    a still image of this example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的下一个控件是`FlyControls`。使用`FlyControls`，您可以使用在飞行模拟器中找到的控件在场景中飞行。示例可以在`05-fly-controls-camera.html`中找到。以下截图显示了此示例的静态图像：
- en: '![FlyControls](graphics/2215OS_09_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![FlyControls](graphics/2215OS_09_05.jpg)'
- en: 'Enabling `FlyControls` works in the same manner as `TrackballControls.` First,
    load the correct JavaScript file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 启用`FlyControls`的方式与`TrackballControls`相同。首先，加载正确的JavaScript文件：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we configure the controls and attach it to the camera, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置控件并将其附加到相机上，如下所示：
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once again, we won''t look into all the specific properties. Look at the source
    of the `FlyControls.js` file for that. Let''s just pick out the properties you
    need to configure to get this control working. The property that needs to be set
    correctly is the `domElement` property. This property should point to the element
    in which we render the scene. For the examples in this book, we use the following
    element for our output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们不会深入研究所有具体的属性。查看`FlyControls.js`文件的源代码。让我们只挑选出需要配置的属性来使控制器工作。需要正确设置的属性是`domElement`属性。该属性应指向我们渲染场景的元素。在本书的示例中，我们使用以下元素作为输出：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We set the property like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置属性如下：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If we don't set this property correctly, moving the mouse around will result
    in strange behavior.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有正确设置这个属性，鼠标移动会导致奇怪的行为。
- en: 'You can control the camera with `THREE.FlyControls` in the following manner:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用`THREE.FlyControls`来控制相机：
- en: '| Control | Action |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left and middle mouse button | Start moving forward |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 左键和中键 | 开始向前移动 |'
- en: '| Right mouse button | Move backwards |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 右鼠标按钮 | 向后移动 |'
- en: '| Mouse movement | Look around |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标移动 | 四处看看 |'
- en: '| W | Start moving forward |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| W | 开始向前移动 |'
- en: '| S | Move backwards |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| A | Move left |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| D | Move right |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| R | Move up |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: '| Left, right, up, and down arrows | Look left, right, up, and down |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 向左、向右、向上、向下看 |'
- en: '| G | Roll left |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| G | 向左翻滚 |'
- en: '| E | Roll right |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| E | 向右翻滚 |'
- en: The next control we'll look at is `THREE.RollControls`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的下一个控制是`THREE.RollControls`。
- en: RollControls
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RollControls
- en: '`RollControls` behaves much the same as `FlyControls`, so we won''t go into
    detail here. `RollControls` can be created like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`RollControls`的行为与`FlyControls`基本相同，所以我们在这里不会详细介绍。`RollControls`可以这样创建：'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you want to play around with this control, look at the `06-roll-controls-camera.html`
    example. Note that if you only see a black screen, move the mouse to the bottom
    of your browser, and the cityscape will pan into view. This camera can be moved
    around with the following controls:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩玩这个控制，看看`06-roll-controls-camera.html`的例子。请注意，如果你只看到一个黑屏，把鼠标移到浏览器底部，城市景观就会出现。这个相机可以用以下控制移动：
- en: '| Control | Action |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse button | Move forward |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| 左鼠标按钮 | 向前移动 |'
- en: '| Right mouse button | Move backwards |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 右鼠标按钮 | 向后移动 |'
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 向左、向右、向前、向后移动 |'
- en: '| W | Move forward |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| W | 向前移动 |'
- en: '| A | Move left |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| S | Move backwards |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| D | Move right |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| Q | Roll left |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Q | 向左翻滚 |'
- en: '| E | Roll right |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| E | 向右翻滚 |'
- en: '| R | Move up |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: The last of the basic controls we'll look at is `FirstPersonControls`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的基本控制的最后一个是`FirstPersonControls`。
- en: FirstPersonControls
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FirstPersonControls
- en: 'As the name implies, `FirstPersonControls` allows you to control the camera
    just like in a first-person shooter. The mouse is used to look around and the
    keyboard is used to walk around. You can find an example in `07-first-person-camera.html`.
    The following screenshot shows a still image of this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`FirstPersonControls`允许你像第一人称射击游戏一样控制相机。鼠标用来四处看看，键盘用来四处走动。你可以在`07-first-person-camera.html`中找到一个例子。以下截图显示了这个例子的静态图像：
- en: '![FirstPersonControls](graphics/2215OS_09_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![FirstPersonControls](graphics/2215OS_09_06.jpg)'
- en: 'Creating these controls follows the same principles as the ones followed for
    other controls we''ve seen until now. The example we''ve just shown uses the following
    configuration:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些控制遵循了我们到目前为止看到的其他控制所遵循的相同原则。我们刚刚展示的例子使用了以下配置：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The only properties that you should carefully look at when using this control
    for yourself are the last two: the `lon` and `lat` properties. These two properties
    define where the camera is pointed at when the scene is rendered for the first
    time.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你自己使用这个控制时，你应该仔细看看的唯一属性是最后两个：`lon`和`lat`属性。这两个属性定义了当场景第一次渲染时相机指向的位置。
- en: 'The controls for this control are pretty straightforward:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制的控制非常简单：
- en: '| Control | Action |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mouse movement | Look around |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 鼠标移动 | 四处看看 |'
- en: '| Left, right, up, and down arrows | Move left, right, forward, and backwards
    |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 向左、向右、向前、向后移动 |'
- en: '| W | Move forward |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| W | 向前移动 |'
- en: '| A | Move left |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| A | 向左移动 |'
- en: '| S | Move backwards |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| S | 向后移动 |'
- en: '| D | Move right |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| D | 向右移动 |'
- en: '| R | Move up |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| R | 向上移动 |'
- en: '| F | Move down |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| F | 向下移动 |'
- en: '| Q | Stop all movement |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| Q | 停止所有移动 |'
- en: For the next control, we'll move on from this first-person perspective to the
    perspective from space.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个控制，我们将从第一人称视角转向太空视角。
- en: OrbitControl
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OrbitControl
- en: 'The `OrbitControl` control is a great way to rotate and pan around an object
    in the center of the scene. With `08-controls-orbit.html`, we''ve included an
    example that shows how this control works. The following screenshot shows a still
    image of this example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrbitControl`控制是围绕场景中心的物体旋转和平移的好方法。在`08-controls-orbit.html`中，我们包含了一个展示这个控制如何工作的例子。以下截图显示了这个例子的静态图像：'
- en: '![OrbitControl](graphics/2215OS_09_07.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![OrbitControl](graphics/2215OS_09_07.jpg)'
- en: 'Using `OrbitControl` is just as simple as using the other controls. Include
    the correct JavaScript file, set up the control with the camera, and use `THREE.Clock`
    again to update the control:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`OrbitControl`和使用其他控制一样简单。包括正确的JavaScript文件，设置控制与相机，再次使用`THREE.Clock`来更新控制：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The controls for `THREE.OrbitControls` are focused on using the mouse, as shown
    in the following table:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.OrbitControls`的控制集中在使用鼠标上，如下表所示：'
- en: '| Control | Action |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 控制 | 动作 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Left mouse click + move | Rotate the camera around the center of the scene
    |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 左鼠标点击+移动 | 围绕场景中心旋转相机 |'
- en: '| Scroll wheel or middle mouse click + move | Zoom in and zoom out |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 滚轮或中键点击+移动 | 放大和缩小 |'
- en: '| Right mouse click + move | Pan around the scene |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 右鼠标点击+移动 | 在场景中四处移动 |'
- en: '| Left, right, up, and down arrows | Pan around the scene |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 左、右、上、下箭头 | 在场景中四处移动 |'
- en: 'That''s it for the camera and moving it around. In this part, we''ve seen a
    lot of controls that allow you to create interesting camera actions. In the next
    section, we''ll look at a more advanced way of animation: morphing and skinning.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 摄像机和移动已经介绍完了。在这一部分，我们已经看到了许多控制，可以让你创建有趣的摄像机动作。在下一节中，我们将看一下更高级的动画方式：变形和蒙皮。
- en: Morphing and skeletal animation
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变形和骨骼动画
- en: 'When you create animations in external programs (for instance, Blender), you
    usually have two main options to define animations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在外部程序（例如Blender）中创建动画时，通常有两种主要选项来定义动画：
- en: '**Morph targets**: With morph targets, you define a deformed version, that
    is, a key position, of the mesh. For this deformed target, all vertex positions
    are stored. All you need to do to animate the shape is move all the vertices from
    one position to another key position and repeat that process. The following screenshot
    shows various morph targets used to show facial expressions (the following image
    has been provided by the Blender foundation):![Morphing and skeletal animation](graphics/2215OS_09_09.jpg)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变形目标**：使用变形目标，您定义了网格的变形版本，即关键位置。对于这个变形目标，存储了所有顶点位置。要使形状动画化，您需要将所有顶点从一个位置移动到另一个关键位置并重复该过程。以下屏幕截图显示了用于显示面部表情的各种变形目标（以下图像由Blender基金会提供）：![变形和骨骼动画](graphics/2215OS_09_09.jpg)'
- en: '**Skeletal animation**: An alternative is using skeletal animation. With skeletal
    animation, you define the skeleton, that is, the bones, of the mesh and attach
    vertices to the specific bones. Now, when you move a bone, any connected bone
    is also moved appropriately, and the attached vertices are moved and deformed
    based on the position, movement, and scaling of the bone. The following screenshot,
    once again provided by the Blender foundation, shows an example of how bones can
    be used to move and deform an object:![Morphing and skeletal animation](graphics/2215OS_09_10.jpg)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**骨骼动画**：另一种选择是使用骨骼动画。使用骨骼动画，您定义网格的骨架，即骨骼，并将顶点附加到特定的骨骼上。现在，当您移动一个骨骼时，任何连接的骨骼也会适当移动，并且根据骨骼的位置、移动和缩放移动和变形附加的顶点。下面再次由Blender基金会提供的屏幕截图显示了骨骼如何用于移动和变形对象的示例：![变形和骨骼动画](graphics/2215OS_09_10.jpg)'
- en: Three.js supports both modes, but generally you'll probably get better results
    with morph targets. The main problem with skeletal animation is getting a good
    export from a 3D program like Blender that can be animated in Three.js. It's much
    easier to get a good working model with morph targets than it is with bones and
    skins.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js支持这两种模式，但通常使用变形目标可能会获得更好的结果。骨骼动画的主要问题是从Blender等3D程序中获得可以在Three.js中进行动画处理的良好导出。使用变形目标比使用骨骼和皮肤更容易获得良好的工作模型。
- en: In this section, we'll look at both options and additionally look at a couple
    of external formats supported by Three.js in which animations can be defined.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究这两种选项，并另外查看Three.js支持的一些外部格式，其中可以定义动画。
- en: Animation with morph targets
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用变形目标的动画
- en: Morph targets are the most straightforward way of defining an animation. You
    define all the vertices for each important position (also called key frames) and
    tell Three.js to move the vertices from one position to the other. The disadvantage
    of this approach, though, is that for large meshes and large animations, the model
    files will become very large. The reason is that for each key position, all the
    vertex positions are repeated.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 变形目标是定义动画的最直接方式。您为每个重要位置（也称为关键帧）定义所有顶点，并告诉Three.js将顶点从一个位置移动到另一个位置。然而，这种方法的缺点是，对于大型网格和大型动画，模型文件将变得非常庞大。原因是对于每个关键位置，所有顶点位置都会重复。
- en: We'll show you how to work with morph targets using two examples. In the first
    example, we'll let Three.js handle the transition between the various key frames
    (or morph targets as we'll call them from now on), and in the second one, we'll
    do this manually.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向您展示如何使用两个示例处理变形目标。在第一个示例中，我们将让Three.js处理各个关键帧（或我们从现在开始称之为变形目标）之间的过渡，在第二个示例中，我们将手动完成这个过程。
- en: Animation with MorphAnimMesh
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MorphAnimMesh的动画
- en: 'For our first morphing example, we''ll use a model that is also available from
    the Three.js distribution—the horse. The easiest way to understand how a morph-targets-based
    animation works is by opening up the `10-morph-targets.html` example. The following
    screenshot shows a still image of this example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个变形示例中，我们将使用Three.js分发的模型之一——马。了解基于变形目标的动画如何工作的最简单方法是打开`10-morph-targets.html`示例。以下屏幕截图显示了此示例的静态图像：
- en: '![Animation with MorphAnimMesh](graphics/2215OS_09_11.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![使用MorphAnimMesh的动画](graphics/2215OS_09_11.jpg)'
- en: In this example, the horse on the right-hand side is animated and running, and
    the horse on the left-hand side is standing still. This second horse (the left-hand
    side one) is rendered from the basic model, that is, the original set of vertices.
    With the menu in the top-right corner, you can browse through all the morph targets
    that are available and see the different positions the left-hand side horse can
    take.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，右侧的马正在进行动画和奔跑，而左侧的马站在原地。左侧的这匹马是从基本模型即原始顶点集渲染的。在右上角的菜单中，您可以浏览所有可用的变形目标，并查看左侧马可以采取的不同位置。
- en: 'Three.js provides a way to move from one position to the next, but this would
    mean we have to manually keep track of the current position we''re in and the
    target we want to morph into, and once we''ve reached the target position, repeat
    this for the other positions. Luckily, Three.js also provides a specific mesh,
    that is, `THREE.MorphAnimMesh`, that takes care of the details for us. Before
    we continue, here''s a quick note on another animation-related mesh provided by
    Three.js called `THREE.MorphBlendMesh`. If you look through the objects provided
    by Three.js, you might notice this object. With this specific mesh, you can do
    pretty much the same things you can do with `THREE.MorphAnimMesh`, and when you
    look at the source code, you can even see that much of it is duplicated between
    these two objects. `THREE.MorphBlendMesh`, however, seems to be deprecated and
    isn''t used in any of the official Three.js examples. Everything you could do
    with `THREE.MorhpBlendMesh` can be done with `THREE.MorphAnimMesh`, so use `THREE.MorphAnimMesh`
    for this kind of functionality. The following piece of code shows you how to load
    the model and create `THREE.MorphAnimMesh` from it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一种从一个位置移动到另一个位置的方法，但这意味着我们必须手动跟踪我们所在的当前位置和我们想要变形成的目标，并且一旦达到目标位置，就要重复这个过程以达到其他位置。幸运的是，Three.js还提供了一个特定的网格，即`THREE.MorphAnimMesh`，它会为我们处理这些细节。在我们继续之前，这里有关于Three.js提供的另一个与动画相关的网格`THREE.MorphBlendMesh`的快速说明。如果您浏览Three.js提供的对象，您可能会注意到这个对象。使用这个特定的网格，您可以做的事情几乎与`THREE.MorphAnimMesh`一样多，当您查看源代码时，甚至可以看到这两个对象之间的许多内容是重复的。然而，`THREE.MorphBlendMesh`似乎已经被弃用，并且在任何官方的Three.js示例中都没有使用。您可以使用`THREE.MorphAnimMesh`来完成`THREE.MorhpBlendMesh`可以完成的所有功能，因此请使用`THREE.MorphAnimMesh`来进行这种功能。以下代码片段显示了如何从模型加载并创建`THREE.MorphAnimMesh`：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This is the same approach we saw when loading other models. This time, however,
    the external model also contains the morph targets. Instead of creating a normal
    `THREE.Mesh` object, we create `THREE.MorphAnimMesh`. There are a couple of things
    you need to take into account when loading animations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们加载其他模型时看到的方法相同。然而，这次外部模型还包含了变形目标。我们创建`THREE.MorphAnimMesh`而不是创建普通的`THREE.Mesh`对象。加载动画时需要考虑几件事情：
- en: Make sure the material you use has `THREE.morphTargets` set to `true`. If it's
    not set, your mesh won't animate.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您使用的材质将`THREE.morphTargets`设置为`true`。如果没有设置，您的网格将不会动画。
- en: Before creating `THREE.MorphAnimMesh`, make sure to call `computeMorphNormals`
    on the geometry so that all the normal vectors for the morph targets are calculated.
    This is required for correct lighting and shadow effects.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建`THREE.MorphAnimMesh`之前，请确保在几何体上调用`computeMorphNormals`，以便计算所有变形目标的法线向量。这对于正确的光照和阴影效果是必需的。
- en: It's also possible to define colors for faces of a specific morph target. These
    are available from the `morphColors` property. You can use this to morph not just
    the shape of a geometry, but also the colors of the individual faces. With the
    `morphColorsToFaceColors` helper method, we just fix the colors of the faces to
    the first set of colors in the `morphColors` array.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还可以为特定变形目标的面定义颜色。这些可以从`morphColors`属性中获得。您可以使用这个来变形几何体的形状，也可以变形各个面的颜色。使用`morphColorsToFaceColors`辅助方法，我们只需将面的颜色固定为`morphColors`数组中的第一组颜色。
- en: The default setting is to play the complete animation in one go. If there are
    multiple animations defined for the same geometry, you can use the `parseAnimations()`
    function together with `playAnimation(name,fps)` to play one of the defined animations.
    We'll use this approach in the last section of this chapter, where we load animations
    from an MD2 model.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认设置是一次性播放完整的动画。如果为同一几何体定义了多个动画，您可以使用`parseAnimations()`函数和`playAnimation(name,fps)`来播放其中一个定义的动画。我们将在本章的最后一节中使用这种方法，从MD2模型中加载动画。
- en: 'All that is left to do is update the animation in the render loop. For this,
    we once again use `THREE.Clock` to calculate the delta and use it to update the
    animation, as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是在渲染循环中更新动画。为此，我们再次使用`THREE.Clock`来计算增量，并用它来更新动画，如下所示：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This approach is the easiest and allows you to quickly set up an animation from
    a model that has morph targets defined. An alternative approach is to set up the
    animation manually as we show in the next section.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是最简单的，可以让您快速设置来自具有定义变形目标的模型的动画。另一种方法是手动设置动画，我们将在下一节中展示。
- en: Creating an animation by setting the morphTargetInfluence property
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过设置morphTargetInfluence属性创建动画
- en: 'We''ll create a very simple example where we morph a cube from one shape to
    another. This time, we''ll manually control which target we will morph to. You
    can find the example in `11-morph-targets-manually.html`. The following screenshot
    shows a still image of this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个非常简单的示例，其中我们将一个立方体从一个形状变形为另一个形状。这一次，我们将手动控制我们将变形到哪个目标。您可以在`11-morph-targets-manually.html`中找到这个示例。以下截图显示了这个示例的静态图像：
- en: '![Creating an animation by setting the morphTargetInfluence property](graphics/2215OS_09_12.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![通过设置morphTargetInfluence属性创建动画](graphics/2215OS_09_12.jpg)'
- en: 'In this example, we''ve manually created two morph targets for a simple cube,
    as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们手动为一个简单的立方体创建了两个变形目标，如下所示：
- en: '[PRE20]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you open up this example, you''ll see a simple cube. With the sliders in
    the top-right corner, you can set `morphTargetInfluences`. In other words, you
    can determine how much the initial cube should morph into the cube specified as
    `mt1` and how much it should morph into `mt2`. When you create your morph targets
    by hand, you need to take into account the fact that the morph target has the
    same number of vertices as the source geometry. You can set the influence using
    the `morphTargetInfluences` property of the mesh:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开这个示例时，您会看到一个简单的立方体。在右上角的滑块中，您可以设置`morphTargetInfluences`。换句话说，您可以确定初始立方体应该变形成指定为`mt1`的立方体的程度，以及它应该变形成`mt2`的程度。当您手动创建变形目标时，您需要考虑到变形目标与源几何体具有相同数量的顶点。您可以使用网格的`morphTargetInfluences`属性来设置影响：
- en: '[PRE21]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the initial geometry can be influenced by multiple morph targets at
    the same time. These two examples show the most important concepts behind morph
    target animations. In the next section, we'll have a quick look at animation using
    bones and skinning.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，初始几何图形可以同时受多个形态目标的影响。这两个例子展示了形态目标动画背后的最重要的概念。在下一节中，我们将快速查看使用骨骼和蒙皮进行动画。
- en: Animation using bones and skinning
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用骨骼和蒙皮进行动画
- en: 'Morph animations are very straightforward. Three.js knows all the target vertex
    positions and only needs to transition each vertex from one position to the next.
    For bones and skinning, it becomes a bit more complex. When you use bones for
    animation, you move the bone, and Three.js has to determine how to translate the
    attached skin (a set of vertices) accordingly. For this example, we use a model
    that was exported from Blender to the Three.js format (`hand-1.js` in the `models`
    folder). This is a model of a hand, complete with a set of bones. By moving the
    bones around, we can animate the complete model. Let''s first look at how we loaded
    the model:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 形态动画非常直接。Three.js知道所有目标顶点位置，只需要将每个顶点从一个位置过渡到下一个位置。对于骨骼和蒙皮，情况会变得有点复杂。当您使用骨骼进行动画时，您移动骨骼，Three.js必须确定如何相应地转换附加的皮肤（一组顶点）。在这个例子中，我们使用从Blender导出到Three.js格式（`models`文件夹中的`hand-1.js`）的模型。这是一个手的模型，包括一组骨骼。通过移动骨骼，我们可以对整个模型进行动画。让我们首先看一下我们如何加载模型：
- en: '[PRE22]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Loading a model for bone animation isn''t that different from any of the other
    models. We just specify the model file, which contains the definition of vertices,
    faces, and also bones, and based on that geometry, we create a mesh. Three.js
    also provides a specific mesh for skinned geometries like this called `THREE.SkinnedMesh`.
    The one thing you need to specify to make sure the model is updated is set the
    `skinning` property of the material you use to `true`. If you don''t set this
    to `true`, you won''t see any bone movement. The last thing we do here is that
    we set the `useQuaternion` property of all the bones to `false`. In this example,
    we''ll use a `tween` object to handle the animation. This `tween` instance is
    defined like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 加载用于骨骼动画的模型与加载任何其他模型并无太大不同。我们只需指定包含顶点、面和骨骼定义的模型文件，然后基于该几何图形创建一个网格。Three.js还提供了一个特定的用于这样的蒙皮几何的网格，称为`THREE.SkinnedMesh`。确保模型得到更新的唯一一件事是将您使用的材质的`skinning`属性设置为`true`。如果不将其设置为`true`，则不会看到任何骨骼移动。我们在这里做的最后一件事是将所有骨骼的`useQuaternion`属性设置为`false`。在这个例子中，我们将使用一个`tween`对象来处理动画。这个`tween`实例定义如下：
- en: '[PRE23]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this tween, we transition the `pos` variable from `-1` to `0`. We've also
    set the `yoyo` property to `true`, which causes our animation to run in reverse
    the next time it is run. To make sure our animation keeps running, we set `repeat`
    to `Infinity`. You can also see that we specify an `onUpdate` method. This method
    is used to position the individual bones, and we'll look at this next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个Tween，我们将`pos`变量从`-1`过渡到`0`。我们还将`yoyo`属性设置为`true`，这会导致我们的动画在下一次运行时以相反的方式运行。为了确保我们的动画保持运行，我们将`repeat`设置为`Infinity`。您还可以看到我们指定了一个`onUpdate`方法。这个方法用于定位各个骨骼，接下来我们将看一下这个方法。
- en: 'Before we move the bones, let''s look at the `12-bones-manually.html` example.
    The following screenshot shows a still image of this example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们移动骨骼之前，让我们先看一下`12-bones-manually.html`示例。以下屏幕截图显示了这个示例的静态图像：
- en: '![Animation using bones and skinning](graphics/2215OS_09_13.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![使用骨骼和蒙皮进行动画](graphics/2215OS_09_13.jpg)'
- en: 'When you open this example, you see the hand making a grab-like motion. We
    did this by setting the *z* rotation of the finger bones in the `onUpdate` method
    that is called from our tween animation, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打开此示例时，您会看到手做出抓取的动作。我们通过在从我们的Tween动画调用的`onUpdate`方法中设置手指骨骼的*z*旋转来实现这一点，如下所示：
- en: '[PRE24]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Whenever this update method is called, the relevant bones are set to the `pos`
    position. To determine which bone you need to move, it is a good idea to print
    out the `mesh.skeleton` property to the console. This will list all the bones
    and their names.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当调用此更新方法时，相关的骨骼都设置为`pos`位置。要确定需要移动哪根骨骼，最好打印出`mesh.skeleton`属性到控制台。这将列出所有骨骼及其名称。
- en: Tip
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Three.js provides a simple helper you can use to show the bones of the models.
    Add the following to the code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了一个简单的辅助工具，您可以用它来显示模型的骨骼。将以下内容添加到代码中：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The bones are highlighted. You can see an example of this by enabling the `showHelper`
    property shown in the `12-bones-manually.html` example.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 骨骼被突出显示。您可以通过启用`12-bones-manually.html`示例中显示的`showHelper`属性来查看此示例。
- en: As you can see, working with bones takes a bit more effort but is much more
    flexible than the fixed morph targets. In this example, we've only moved the rotation
    of the bones; you can also move the position or change the scale. In the next
    section, we look at loading animations from external models. In that section,
    we'll revisit this example, but now, we'll run a predefined animation from the
    model instead of manually moving the bones around.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，使用骨骼需要更多的工作，但比固定的形态目标更灵活。在这个例子中，我们只移动了骨骼的旋转；您还可以移动位置或更改比例。在下一节中，我们将看一下从外部模型加载动画。在该部分，我们将重新访问这个例子，但现在，我们将从模型中运行预定义的动画，而不是手动移动骨骼。
- en: Creating animations using external models
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部模型创建动画
- en: 'In [Chapter 8](ch08.html "Chapter 8. Creating and Loading Advanced Meshes and
    Geometries"), *Creating and Loading Advanced Meshes and Geometries*, we looked
    at a number of 3D formats that are supported by Three.js. A couple of those formats
    also support animations. In this chapter, we''ll look at the following examples:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](ch08.html "第8章。创建和加载高级网格和几何体")*创建和加载高级网格和几何体*中，我们看了一些Three.js支持的3D格式。其中一些格式也支持动画。在本章中，我们将看一下以下示例：
- en: '**Blender with the JSON exporter**: We''ll start with an animation created
    in Blender and exported to the Three.js JSON format.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用JSON导出器的Blender**：我们将从Blender中创建的动画开始，并将其导出到Three.js JSON格式。'
- en: '**Collada model**: The Collada format has support for animations. For this
    example, we''ll load an animation from a Collada file and render it with Three.js.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collada模型**：Collada格式支持动画。在此示例中，我们将从Collada文件加载动画，并在Three.js中呈现它。'
- en: '**MD2 model**: The MD2 model is a simple format used in the older Quake engines.
    Even though the format is a bit dated, it is still a very good format for storing
    character animations.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MD2模型**：MD2模型是旧版Quake引擎中使用的简单格式。尽管该格式有点过时，但仍然是存储角色动画的非常好的格式。'
- en: We'll start with the Blender model.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Blender模型开始。
- en: Creating a bones animation using Blender
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Blender创建骨骼动画
- en: 'To get started with animations from Blender, you can load the example we''ve
    included in the models folder. You can find the `hand.blend` file there, which
    you can load into Blender. The following screenshot shows a still image of this
    example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Blender中的动画，您可以加载我们在models文件夹中包含的示例。您可以在那里找到`hand.blend`文件，然后将其加载到Blender中。以下截图显示了这个示例的静态图像：
- en: '![Creating a bones animation using Blender](graphics/2215OS_09_14.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender创建骨骼动画](graphics/2215OS_09_14.jpg)'
- en: 'There isn''t room in this book to go into much detail on how to create animations
    in Blender, but there are a couple of things you need to keep in mind:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，没有足够的空间详细介绍如何在Blender中创建动画，但有一些事情需要记住：
- en: Every vertex from your model must at least be assigned to a vertex group.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的模型中的每个顶点至少必须分配给一个顶点组。
- en: The name of the vertex groups you use in Blender must correspond to the name
    of the bone that controls it. That way, Three.js can determine which vertices
    it needs to modify when moving the bones.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您在Blender中使用的顶点组的名称必须对应于控制它的骨骼的名称。这样，Three.js可以确定移动骨骼时需要修改哪些顶点。
- en: Only the first "action" is exported. So make sure the animation you want to
    export is the first one.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有第一个“动作”被导出。因此，请确保要导出的动画是第一个。
- en: When creating key frames, it is a good idea to select all the bones even if
    they don't change.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建关键帧时，最好选择所有骨骼，即使它们没有改变。
- en: When exporting the model, make sure the model is in its rest pose. If this is
    not the case, you'll see a very deformed animation.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在导出模型时，请确保模型处于静止姿势。如果不是这种情况，您将看到一个非常畸形的动画。
- en: 'For more information on creating and exporting animations from Blender and
    the reasons for the aforementioned pointers, you can look at the following great
    resource: [http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/](http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关在Blender中创建和导出动画以及上述要点的原因的更多信息，您可以查看以下优秀资源：[http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/](http://devmatrix.wordpress.com/2013/02/27/creating-skeletal-animation-in-blender-and-exporting-it-to-three-js/)。
- en: 'When you''ve created the animation in Blender, you can export the file using
    the Three.js exporter we used in the previous chapter. When exporting the file
    using the Three.js exporter, you have to make sure that the following properties
    are checked:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在Blender中创建动画时，可以使用我们在上一章中使用的Three.js导出器导出文件。在使用Three.js导出器导出文件时，您必须确保检查以下属性：
- en: '![Creating a bones animation using Blender](graphics/2215OS_09_15.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender创建骨骼动画](graphics/2215OS_09_15.jpg)'
- en: This will export the animation you've specified in Blender as a skeletal animation
    instead of a morph animation. With a skeletal animation, the movements of the
    bones are exported, which we can replay in Three.js.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导出您在Blender中指定的动画作为骨骼动画，而不是形变动画。使用骨骼动画，骨骼的移动被导出，我们可以在Three.js中重放。
- en: 'Loading the model in Three.js is the same as we did for our previous example;
    however, now that the model is loaded, we will also create an animation, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中加载模型与我们之前的示例相同；但是，现在模型加载后，我们还将创建一个动画，如下所示：
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To run this animation, all we have to do is create a `THREE.Animation` instance
    and call the `play` method on this animation. Before we see the animation, we
    still need to take one additional step. In our render loop, we call the `THREE.AnimationHandler.update(clock.getDelta())`
    function to update the animation, and Three.js will use the bones to set the model
    in the correct position. The result of this example (`13-animation-from-blender.html`)
    is a simple waving hand.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此动画，我们只需创建一个`THREE.Animation`实例，并在此动画上调用`play`方法。在看到动画之前，我们还需要执行一个额外的步骤。在我们的渲染循环中，我们调用`THREE.AnimationHandler.update(clock.getDelta())`函数来更新动画，Three.js将使用骨骼来设置模型的正确位置。这个示例(`13-animation-from-blender.html`)的结果是一个简单的挥手。
- en: 'The following screenshot shows a still image of this example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这个示例的静态图像：
- en: '![Creating a bones animation using Blender](graphics/2215OS_09_16.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![使用Blender创建骨骼动画](graphics/2215OS_09_16.jpg)'
- en: Besides Three.js' own format, we can use a couple of other formats to define
    animations. The first one we'll look at is loading a Collada model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Three.js自己的格式，我们还可以使用其他几种格式来定义动画。我们将首先看一下加载Collada模型。
- en: Loading an animation from a Collada model
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Collada模型加载动画
- en: 'Loading a model from a Collada file works in the same manner as for the other
    formats. First, you have to include the correct loader JavaScript file:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从Collada文件加载模型的工作方式与其他格式相同。首先，您必须包含正确的加载器JavaScript文件：
- en: '[PRE27]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we create a loader and use it to load the model file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个加载器并使用它来加载模型文件：
- en: '[PRE28]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A Collada file can contain much more than just a single mode; it can store
    complete scenes, including cameras, lights, animations, and more. A good way to
    work with a Collada model is to print out the result from the `loader.load` function
    to the console and determine which components you want to use. In this case, there
    was a single `THREE.SkinnedMesh` in the scene (`child`). To render and animate
    this model, all we have to do is set up the animation just like we did for the
    Blender-based model; even the render loop stays the same. Here''s how we render
    and animate the model:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Collada文件不仅可以包含单个模型，还可以存储完整的场景，包括摄像机、灯光、动画等。使用Collada模型的一个好方法是将`loader.load`函数的结果打印到控制台，并确定要使用的组件。在这种情况下，场景中只有一个`THREE.SkinnedMesh`（`child`）。要渲染和动画化这个模型，我们所要做的就是设置动画，就像我们为基于Blender的模型所做的那样；甚至渲染循环保持不变。以下是我们如何渲染和动画化模型的方法：
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And the result for this specific Collada file looks like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 而这个特定Collada文件的结果看起来像这样：
- en: '![Loading an animation from a Collada model](graphics/2215OS_09_17.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![从Collada模型加载动画](graphics/2215OS_09_17.jpg)'
- en: Another example of an external model, one that uses morph targets, is the MD2
    file format.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用变形目标的外部模型的例子是MD2文件格式。
- en: Animation loaded from a Quake model
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Quake模型加载的动画
- en: 'The MD2 format was created to model characters from Quake, a great game from
    1996\. Even though the newer engines use a different format, you can still find
    a lot of interesting models in the MD2 format. To use files in this format, we
    first have to convert them to the Three.js JavaScript format. You can do this
    online using the following site:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: MD2格式是为了对Quake中的角色进行建模而创建的，Quake是一款1996年的伟大游戏。尽管新的引擎使用了不同的格式，但你仍然可以在MD2格式中找到许多有趣的模型。要使用这种格式的文件，我们首先必须将它们转换为Three.js的JavaScript格式。你可以在以下网站上在线进行转换：
- en: '[http://oos.moxiecode.com/js_webgl/md2_converter/](http://oos.moxiecode.com/js_webgl/md2_converter/)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://oos.moxiecode.com/js_webgl/md2_converter/](http://oos.moxiecode.com/js_webgl/md2_converter/)'
- en: 'After conversion, you''ll get a JavaScript file in the Three.js format that
    you can load and render using `MorphAnimMesh`. Since we''ve already seen how to
    do this in the previous sections, we''ll skip the code where the model is loaded.
    One interesting thing though is happening in the code. Instead of playing the
    complete animation, we provide the name of the animation that needs to be played:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后，你会得到一个以Three.js格式的JavaScript文件，你可以使用`MorphAnimMesh`加载和渲染。由于我们已经在前面的章节中看到了如何做到这一点，我们将跳过加载模型的代码。不过代码中有一件有趣的事情。我们不是播放完整的动画，而是提供需要播放的动画的名称：
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The reason is that an MD2 file usually contains a number of different character
    animations. Luckily, though, Three.js provides functionality to determine the
    available animations and play them using the `playAnimation` function. The first
    thing we need to do is tell Three.js to parse the animations:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是MD2文件通常包含许多不同的角色动画。不过，Three.js提供了功能来确定可用的动画并使用`playAnimation`函数播放它们。我们需要做的第一件事是告诉Three.js解析动画：
- en: '[PRE31]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This results in a list of names for the animations that can be played using
    the `playAnimation` function. In our example, you can select the name of the animation
    from the menu in the top-right corner. The available animations are determined
    like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个动画名称列表，可以使用`playAnimation`函数播放。在我们的例子中，你可以在右上角的菜单中选择动画的名称。可用的动画是这样确定的：
- en: '[PRE32]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Whenever an animation from the menu is selected, the `mesh.playAnimation` function
    is called with the specified animation name. The example that demonstrates this
    can be found in `15-animation-from-md2.html`. The following screenshot shows us
    a still image of this example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每当从菜单中选择一个动画时，都会使用指定的动画名称调用`mesh.playAnimation`函数。演示这一点的例子可以在`15-animation-from-md2.html`中找到。以下截图显示了这个例子的静态图像：
- en: '![Animation loaded from a Quake model](graphics/2215OS_09_18.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![从Quake模型加载的动画](graphics/2215OS_09_18.jpg)'
- en: Summary
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at different ways that you can animate your scene.
    We started with some basic animation tricks, moved on to camera movement and control,
    and ended with animation models using morph targets and skeleton/bones animations.
    When you have the render loop in place, adding animations is very easy. Just change
    a property of the mesh, and in the next rendering step, Three.js will render the
    updated mesh.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了一些不同的方法，你可以为你的场景添加动画。我们从一些基本的动画技巧开始，然后转移到摄像机的移动和控制，最后使用变形目标和骨骼/骨骼动画来动画模型。当你有了渲染循环后，添加动画就变得非常容易。只需改变网格的属性，在下一个渲染步骤中，Three.js将渲染更新后的网格。
- en: In previous chapters, we looked at the various materials you can use to skin
    your objects. For instance, we saw how you can change the color, shininess, and
    opacity of these materials. What we haven't discussed in detail yet, however,
    is how you can use external images (also called textures) together with these
    materials. With textures, you can easily create objects that look like they are
    made of wood, metal, stone, and much more. In the next chapter, we'll explore
    all the different aspects of textures and how they are used in Three.js.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们看了一下你可以用来皮肤化你的物体的各种材料。例如，我们看到了如何改变这些材料的颜色、光泽和不透明度。然而，我们还没有详细讨论过的是如何使用外部图像（也称为纹理）与这些材料一起。使用纹理，你可以轻松地创建看起来像是由木头、金属、石头等制成的物体。在下一章中，我们将探讨纹理的各个方面以及它们在Three.js中的使用方式。
