- en: Unit Testing – Focusing on What You Do and Not on What Has Been Done
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试-关注您正在做的事情，而不是已经完成的事情
- en: '"To create something exceptional, your mindset must be relentlessly focused
    on the smallest detail."'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “要创造出非凡的东西，你的心态必须专注于最小的细节。”
- en: – Giorgio Armani
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: -乔治·阿玛尼
- en: As promised, each chapter will explore a different Java testing framework and
    this one is no exception. We'll use TestNG to build our specifications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 正如承诺的那样，每一章都将探讨不同的Java测试框架，这一章也不例外。我们将使用TestNG来构建我们的规范。
- en: In the previous [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*, we practiced the Red-Green-Refactor
    procedure. We used unit tests without going deeper into how unit testing works
    in the context of TDD. We'll build on the knowledge from the last chapter and
    go into more detail by trying to explain what unit tests really are and how they
    fit into the TDD approach to building software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)中，我们练习了红-绿-重构的过程。我们使用了单元测试，但并没有深入探讨单元测试在TDD背景下的工作原理。我们将在上一章的知识基础上进行更详细的讨论，试图解释单元测试到底是什么，以及它们如何适用于TDD构建软件的方法。
- en: The goal of this chapter is to learn how to focus on the unit we're currently
    working on and how to ignore or isolate those that were done before.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是学习如何专注于我们当前正在处理的单元，并学会忽略或隔离那些已经完成的单元。
- en: Once we're comfortable with TestNG and unit testing, we'll dive right into the
    requirements of our next application and start coding.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们熟悉了TestNG和单元测试，我们将立即开始进入下一个应用程序的需求并开始编码。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Unit testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing with TDD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD进行单元测试
- en: TestNG
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TestNG
- en: Remote-controlled ship requirements
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遥控船的要求
- en: Developing the remote-controlled ship
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发遥控船
- en: Unit testing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: Frequent manual testing is too impractical for any but the smallest systems.
    The only way around this is the use of automated tests. They are the only effective
    method to reduce the time and cost of building, deploying, and maintaining applications.
    In order to effectively manage applications, it is of the utmost importance that
    both the implementation and test codes are as simple as possible. Simplicity is
    one of the core **extreme programming** (**XP**) values ([http://www.extremeprogramming.org/rules/simple.html](http://www.extremeprogramming.org/rules/simple.html))
    and the key to TDD and programming in general. It is most often accomplished through
    division into small units. In Java, units are methods. Being the smallest, the
    feedback loop they provide is the fastest so we spend most of our time thinking
    and working on them. As a counterpart to implementation methods, unit tests should
    constitute by far the biggest percentage of all tests.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 频繁的手动测试对于除了最小的系统之外都太不切实际了。唯一的解决办法是使用自动化测试。它们是减少构建、部署和维护应用程序的时间和成本的唯一有效方法。为了有效地管理应用程序，实施和测试代码尽可能简单至关重要。简单是**极限编程**（**XP**）价值观之一（[http://www.extremeprogramming.org/rules/simple.html](http://www.extremeprogramming.org/rules/simple.html)），也是TDD和编程的关键。这通常是通过分成小单元来实现的。在Java中，单元是方法。作为最小的单元，它们提供的反馈循环是最快的，因此我们大部分时间都在思考和处理它们。作为实施方法的对应物，单元测试应该占所有测试的绝大部分比例。
- en: What is unit testing?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单元测试？
- en: '**Unit testing** is a practice that forces us to test small, individual, and
    isolated units of code. They are usually methods, even though in some cases classes
    or even whole applications can be considered to be units, as well. In order to
    write unit tests, code under tests needs to be isolated from the rest of the application.
    Preferably, that isolation is already ingrained in the code or it can be accomplished
    with the use of **mocks** (more on mocks will be covered in [Chapter 6](97f02bdf-43f8-4862-a3b7-600e3b963f5e.xhtml),
    *Mocking – Removing External Dependencies*). If unit tests of a particular method
    cross the boundaries of that unit, then they become integration tests. As such,
    it becomes less clear what is under the tests. In case of a failure, the scope
    of a problem suddenly increases and finding the cause becomes more tedious.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是一种实践，它迫使我们测试小的、独立的、孤立的代码单元。它们通常是方法，尽管在某些情况下，类甚至整个应用程序也可以被视为单元。为了编写单元测试，需要将测试代码与应用程序的其余部分隔离开来。最好是代码中已经融入了这种隔离，或者可以通过使用**模拟对象**来实现（有关模拟对象的更多内容将在[第6章](97f02bdf-43f8-4862-a3b7-600e3b963f5e.xhtml)中介绍，*模拟-消除外部依赖*）。如果特定方法的单元测试跨越了该单元的边界，那么它们就变成了集成测试。这样一来，测试的范围就变得不那么清晰了。在出现故障的情况下，问题的范围突然增加，找到原因变得更加费力。'
- en: Why unit testing?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么进行单元测试？
- en: A common question, especially within organizations that rely heavily on manual
    testing, is *Why should we use unit instead of functional and integration testing?*
    This question in itself is flawed. Unit testing does not replace other types of
    testing. Instead, unit testing reduces the scope of other types of tests. By its
    nature, unit testing is easier and faster to write than any other type of tests,
    thus reducing the cost and **time to market** (**TTM**). Due to the reduced time
    to write and run them, they tend to detect problems much sooner. The faster we
    detect problems, the cheaper it is to fix them. A bug that was detected minutes
    after it was created is much easier to fix than if that same bug was found days,
    weeks, or even months after it was made.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的问题，特别是在严重依赖手动测试的组织中，是*为什么我们应该使用单元测试而不是功能和集成测试？*这个问题本身是有缺陷的。单元测试并不取代其他类型的测试。相反，单元测试减少了其他类型测试的范围。由于其性质，单元测试比任何其他类型的测试更容易和更快地编写，从而降低了成本和**上市时间**（**TTM**）。由于编写和运行它们的时间减少，它们往往更早地检测到问题。我们越快地检测到问题，修复问题的成本就越低。在创建后几分钟就被检测到的错误比在创建后几天、几周甚至几个月后被发现的错误要容易得多。
- en: Code refactoring
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码重构
- en: '**Code refactoring** is the process of changing the structure of an existing
    code without changing its external behavior. The purpose of refactoring is to
    improve an existing code. This improvement can be made for many different reasons.
    We might want to make the code more readable, less complex, easier to maintain,
    cheaper to extend, and so on. No matter what the reason for refactoring is, the
    ultimate goal is always to make it better in one way or another. The effect of
    this goal is a reduction in technical debt; a reduction in pending work that needs
    to be done due to suboptimal design, architecture, or coding.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码重构**是在不改变现有代码的外部行为的情况下改变现有代码结构的过程。重构的目的是改进现有的代码。这种改进可以出于许多不同的原因。我们可能希望使代码更易读，更简单，更易于维护，更廉价扩展等等。无论重构的原因是什么，最终目标总是以某种方式使其更好。这个目标的效果是减少技术债务；减少由于次优设计、架构或编码而需要完成的未决工作。'
- en: Typically, we approach refactoring by applying a set of small changes without
    modifying intended behavior. Reducing the scope of refactoring changes allows
    us continuously to confirm that those changes did not break any existing functionality.
    The only way to effectively obtain this confirmation is through the use of automated
    tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们通过应用一系列小的更改来进行重构，而不修改预期的行为。减少重构变化的范围允许我们持续确认这些变化没有破坏任何现有功能。有效获得这种确认的唯一方法是通过使用自动化测试。
- en: One of the great benefits of unit tests is that they are the best refactoring
    enablers. Refactoring is too risky when there are no automated tests to confirm
    that the application still behaves as expected. While any type of test can be
    used to provide the code coverage required for refactoring, in most cases only
    unit tests can provide the required level of details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的一个巨大好处是它们是最好的重构促进者。当没有自动化测试来确认应用程序仍然按预期行为时，重构就太冒险了。虽然任何类型的测试都可以用来提供重构所需的代码覆盖率，但在大多数情况下，只有单元测试可以提供所需的细节级别。
- en: Why not use unit tests exclusively?
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不只使用单元测试？
- en: At this moment, you might be wondering whether unit testing could provide a
    solution for all your testing needs. Unfortunately, that is not the case. While
    unit tests usually cover the biggest percentage of your testing needs, functional
    and integration tests should be an integral part of your testing toolbox.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，你可能会想知道单元测试是否能够满足你所有的测试需求。不幸的是，情况并非如此。虽然单元测试通常涵盖了大部分的测试需求，但功能测试和集成测试应该是测试工具箱的一个重要部分。
- en: 'We''ll cover other types of tests in more detail in later chapters. For now,
    a few important distinctions between them are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地介绍其他类型的测试。目前，它们之间的一些重要区别如下：
- en: Unit tests try to verify small units of functionality. In the Java world, those
    units are methods. All external dependencies, such as invocations of other classes
    and methods or database calls, should be done in memory with the use of mocks,
    stubs, spies, fakes, and dummies. Gerard Meszaros coined a more general term, **test
    doubles***,* that envelops all those ([http://en.wikipedia.org/wiki/Test_double](http://en.wikipedia.org/wiki/Test_double)).
    Unit tests are simple, easy to write, and fast to run. They are usually the biggest
    percentage of a testing suite.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试试图验证小的功能单元。在Java世界中，这些单元是方法。所有外部依赖，如调用其他类和方法或数据库调用，应该在内存中使用模拟、存根、间谍、伪造和虚拟对象来完成。Gerard
    Meszaros创造了一个更一般的术语，**测试替身**，它包括了所有这些（[http://en.wikipedia.org/wiki/Test_double](http://en.wikipedia.org/wiki/Test_double)）。单元测试简单易写，运行速度快。它们通常是测试套件中最大的部分。
- en: '**Functional** and **acceptance** tests have a job to verify that the application
    we''re building works as expected, as a whole. While those two differ in their
    purpose, both share a similar goal. Unlike unit tests that are verifying the internal
    quality of the code, functional and acceptance tests are trying to ensure that
    the system is working correctly from the customer''s or user''s point of view.
    Those tests are usually smaller in number when compared with unit tests due to
    the cost and effort needed to both write and run them.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能**和**验收**测试的工作是验证我们正在构建的应用程序作为一个整体是否按预期工作。虽然这两者在目的上有所不同，但都有一个相似的目标。与验证代码的内部质量的单元测试不同，功能和验收测试试图确保系统从客户或用户的角度正确地工作。由于编写和运行这些测试所需的成本和工作量，这些测试通常比单元测试少。'
- en: '**Integration** tests intend to verify that separate units, modules, applications,
    or even whole systems are properly integrated with each other. You might have
    a frontend application that uses backend APIs that, in turn, communicate with
    a database. The job of integration tests would be to verify that all three of
    those separate components of the system are indeed integrated and can communicate
    with each other. Since we already know that all the units are working and all
    functional and acceptance tests are passed, integration tests are usually the
    smallest of all three as their job is only to confirm that all the pieces are
    working well together:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**测试旨在验证单独的单元、模块、应用程序，甚至整个系统是否正确地相互集成。你可能有一个使用后端API的前端应用程序，而这些API又与数据库进行通信。集成测试的工作就是验证系统的这三个独立组件确实是集成的，并且能够相互通信。由于我们已经知道所有的单元都在工作，所有功能和验收测试都通过了，集成测试通常是这三种测试中最小的，因为它们的工作只是确认所有的部件能够良好地协同工作：'
- en: '![](img/a224c9c4-bee4-445c-9b8f-4c353dc040d6.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a224c9c4-bee4-445c-9b8f-4c353dc040d6.png)'
- en: The testing pyramid states that you should have many more unit tests than higher-level
    tests (UI tests, integration tests, and so on). Why is that? Unit tests are much
    cheaper to write, faster to run, and, at the same time, provide much bigger coverage.
    Take, for example, registration functionality. We should test what happens when
    a username is empty, when a password is empty, when a username or password is
    not in the correct format, when the user already exists, and so on. Only for this
    single functionality there can be tens, if not hundreds of tests. Writing and
    running all those tests from the UI can be very expensive (time-consuming to write
    and slow to run). On the other hand, unit testing a method that does this validation
    is easy, fast to write, and fast to run. If all those cases are covered with unit
    tests, we could be satisfied with a single integration test that checks whether
    our UI is calling the correct method on the backend. If it is, details are irrelevant
    from an integration point of view since we know that all cases are already covered
    on the unit level.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 测试金字塔表明，你应该有比高级测试（UI测试，集成测试等）更多的单元测试。为什么呢？单元测试的编写成本更低，运行速度更快，并且同时提供更大的覆盖范围。以注册功能为例。我们应该测试当用户名为空时会发生什么，当密码为空时会发生什么，当用户名或密码不符合正确格式时会发生什么，当用户已经存在时会发生什么，等等。仅针对这个单一功能，可能会有数十甚至数百个测试。从UI编写并运行所有这些测试可能非常昂贵（编写耗时且运行缓慢）。另一方面，对执行此验证的方法进行单元测试很容易，编写快速，运行迅速。如果所有这些情况都通过单元测试覆盖，我们可以满意地进行单一集成测试，检查我们的UI是否在后端调用了正确的方法。如果是的话，从集成的角度来看，细节是无关紧要的，因为我们知道所有情况已经在单元级别上得到了覆盖。
- en: Unit testing with TDD
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TDD的单元测试
- en: What is the difference in the way we write unit tests in the context of TDD?
    The major differentiator is in *when*. While traditionally unit tests are written
    after the implementation code is done, in TDD we write tests before—the order
    of things is inverted. Without TDD, the purpose of unit tests is to validate an
    existing code. TDD teaches us that unit tests should drive our development and
    design. They should define the behavior of the smallest possible unit. They are
    micro-requirements pending development. A test tells you what to do next and when
    you're done doing it. Depending on the type of tests (unit, functional, integration,
    and so on), the scope of what should be done next differs. In the case of TDD
    with unit tests, this scope is the smallest possible, meaning a method or, more
    often, a part of it. Moreover, with TDD driven by unit tests, we are forced to
    comply to some design principles, such as **keep it simple, stupid** (**KISS**).
    By writing simple tests with a very small scope, the implementation of those tests
    tends to be simple as well. By forcing tests not to use external dependencies,
    we are forcing the implementation code to have a separation of concerns that is
    well-designed. There are many other examples of how TDD helps us to write better
    code. Those same benefits cannot be accomplished with unit testing alone. Without
    TDD, unit tests are forced to work with an existing code and have no influence
    on the design.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在TDD的环境中，我们编写单元测试的方式有何不同？主要的区别在于*何时*。传统上，单元测试是在实现代码完成后编写的，而在TDD中，我们在此之前编写测试—事情的顺序被颠倒了。没有TDD，单元测试的目的是验证现有代码。TDD教导我们，单元测试应该驱动我们的开发和设计。它们应该定义最小可能单元的行为。它们是待开发的微需求。一个测试告诉你接下来该做什么，以及何时完成它。根据测试的类型（单元测试、功能测试、集成测试等），下一步应该做什么的范围不同。在使用TDD进行单元测试的情况下，这个范围是最小可能的，意味着一个方法或者更常见的是其中的一部分。此外，通过由单元测试驱动的TDD，我们被迫遵守一些设计原则，比如**保持简单，愚蠢**（**KISS**）。通过编写简单的测试，范围很小，这些测试的实现也往往很简单。通过强制测试不使用外部依赖，我们迫使实现代码具有良好设计的关注点分离。TDD如何帮助我们编写更好的代码还有许多其他例子。这些好处无法仅通过单元测试实现。没有TDD，单元测试被迫使用现有代码，并且对设计没有影响。
- en: To summarize, the main goal of unit testing without TDD is the validation of
    the existing code. Unit testing written in advance using the TDD procedure has
    the main objective specification and design, with validation being a side product.
    This side product is often of a higher quality than when tests are written after
    the implementation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，没有TDD的单元测试的主要目标是验证现有代码。使用TDD程序提前编写的单元测试的主要目标是规范和设计，验证只是一个附带产品。这个附带产品通常比在实现之后编写测试时的质量要高。
- en: TDD forces us to think through our requirements and design, write clean code
    that works, create executable requirements, and refactor safely and often. On
    top of all that, we end up with high test code coverage that is used to regression-test
    all our code whenever some change is introduced. Unit testing without TDD gives
    us only tests and, often, with doubtful quality.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: TDD迫使我们深思熟虑我们的需求和设计，编写能够运行的干净代码，创建可执行的需求，并安全而频繁地进行重构。最重要的是，我们最终得到了高测试代码覆盖率，用于在引入变更时对我们的所有代码进行回归测试。没有TDD的单元测试只给我们测试，而且通常质量存疑。
- en: TestNG
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestNG
- en: JUnit and TestNG are two major Java testing frameworks. You already wrote tests
    with JUnit in the previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*,  and, hopefully, got a good understanding
    of how it works. How about TestNG? It was born out of a desire to make JUnit better.
    Indeed, it contains some functionalities that JUnit doesn't have.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG是两个主要的Java测试框架。在上一章中，您已经使用JUnit编写了测试，*Red-Green-Refactor – 从失败到成功直至完美*，并且希望您对其工作原理有了很好的理解。那TestNG呢？它诞生于对JUnit进行改进的愿望。事实上，它包含了一些JUnit没有的功能。
- en: The following subsections summarize some of the differences between the two
    of them. We'll try not only to provide an explanation of the differences, but
    also their evaluation in the context of unit testing with TDD.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节总结了它们之间的一些区别。我们不仅会尝试解释这些区别，还会在TDD的单元测试环境中对它们进行评估。
- en: The @Test annotation
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test注释'
- en: 'Both JUnit and TestNG use the `@Test` annotation to specify which method is
    considered to be a test. Unlike JUnit, which requires every method to be annotated
    with `@Test`, TestNG allows us to use this annotation on a class level, as well.
    When used in this way, all public methods are considered tests unless specified
    otherwise:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG都使用`@Test`注释来指定哪个方法被视为测试。与JUnit不同，后者要求每个方法都要有`@Test`注释，而TestNG允许我们在类级别上使用这个注释。当以这种方式使用时，除非另有规定，否则所有公共方法都被视为测试：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, we put the `@Test` annotation above the `DirectionSpec` class.
    As a result, both the `whenGetFromShortNameNThenReturnDirectionN` and `whenGetFromShortNameWThenReturnDirectionW`
    methods are considered tests.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`@Test`注释放在`DirectionSpec`类的上面。结果，`whenGetFromShortNameNThenReturnDirectionN`和`whenGetFromShortNameWThenReturnDirectionW`方法都被视为测试。
- en: If that code was written using JUnit, both the methods would need to have the `@Test`
    annotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果该代码是使用JUnit编写的，那么这两个方法都需要有`@Test`注释。
- en: The @BeforeSuite, @BeforeTest, @BeforeGroups, @AfterGroups, @AfterTest, and
    @AfterSuite annotations
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeSuite，@BeforeTest，@BeforeGroups，@AfterGroups，@AfterTest和@AfterSuite注释'
- en: Those six annotations do not have their equivalents in JUnit. TestNG can group
    tests into suites, using XML configuration. Methods annotated with `@BeforeSuite`
    and `@AfterSuite` are run before and after all the tests in the specified suite
    have run. Similarly, the `@BeforeTest` and `@AfterTest` annotated methods are
    run before any test method belonging to the test classes has run. Finally, TestNG
    tests can be organized into groups. The `@BeforeGroups` and `@AfterGroups` annotations
    allow us to run methods before the first test and after the last test, in specified
    groups, are run.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个注释在JUnit中没有对应的。TestNG可以使用XML配置将测试分组为套件。使用`@BeforeSuite`和`@AfterSuite`注释的方法在指定套件中的所有测试运行之前和之后运行。类似地，使用`@BeforeTest`和`@AfterTest`注释的方法在测试类的任何测试方法运行之前运行。最后，TestNG测试可以组织成组。`@BeforeGroups`和`@AfterGroups`注释允许我们在指定组中的第一个测试之前和最后一个测试之后运行方法。
- en: While those annotations can be very useful when tests are written after the
    implementation code, they do not provide much usage in the context of TDD. Unlike
    traditional testing, which is often planned and written as a separate project,
    TDD teaches us to write one test at a time and keep everything simple. Most importantly,
    unit tests are supposed to run quickly so there is no need to group them into
    suites or groups. When tests are fast, running anything less than everything is
    a waste. If, for example, all tests are run in less than 15 seconds, there is
    no need to run only a part of them. On the other hand, when tests are slow, it
    is often a sign that external dependencies are not isolated. No matter what the
    reason is behind slow tests, the solution is not to run only a part of them, but
    to fix the problem.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些注释在编写实现代码后的测试时可能非常有用，但在TDD的上下文中并没有太多用处。与通常的测试不同，通常是计划并作为一个独立项目编写的，TDD教导我们一次编写一个测试并保持一切简单。最重要的是，单元测试应该快速运行，因此没有必要将它们分组到套件或组中。当测试快速运行时，运行除了全部之外的任何内容都是浪费。例如，如果所有测试在15秒内运行完毕，就没有必要只运行其中的一部分。另一方面，当测试很慢时，通常是外部依赖没有被隔离的迹象。无论慢测试背后的原因是什么，解决方案都不是只运行其中的一部分，而是解决问题。
- en: Moreover, functional and integration tests do tend to be slower and require
    us to have some kind of separation. However, it is better to separate them in,
    for example, `build.gradle` so that each type of test is run as a separate task.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，功能和集成测试往往会更慢，并且需要我们进行某种分离。然而，最好是在`build.gradle`中将它们分开，以便每种类型的测试作为单独的任务运行。
- en: The @BeforeClass and @AfterClass annotations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeClass和@AfterClass注释'
- en: These annotations have the same function in both JUnit and TestNG. Annotated
    methods will be run before the first test and after the last test, in a current
    class. The only difference is that TestNG does not require those methods to be
    static. The reason behind this can be found in the different approaches those
    two frameworks take when running test methods. JUnit isolates each test into its
    own instance of the test class, forcing us to have those methods defined as static
    and, therefore, reusable across all test runs. TestNG, on the other hand, executes
    all test methods in the context of a single test class instance, eliminating the
    need for those methods to be static.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这些注释在JUnit和TestNG中具有相同的功能。在当前类中的第一个测试之前和最后一个测试之后运行带注释的方法。唯一的区别是TestNG不要求这些方法是静态的。这背后的原因可以在这两个框架运行测试方法时采取的不同方法中找到。JUnit将每个测试隔离到其自己的测试类实例中，迫使我们将这些方法定义为静态的，因此可以在所有测试运行中重复使用。另一方面，TestNG在单个测试类实例的上下文中执行所有测试方法，消除了这些方法必须是静态的需要。
- en: The @BeforeMethod and @AfterMethod annotations
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@BeforeMethod和@AfterMethod注释'
- en: The `@Before` and `@After` annotations are equivalent to JUnit. Annotated methods
    are run before and after each test method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Before`和`@After`注释等同于JUnit。带注释的方法在每个测试方法之前和之后运行。'
- en: The @Test(enable = false) annotation argument
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test(enable = false)注释参数'
- en: Both JUnit and TestNG can disable tests. While JUnit uses a separate `@Ignore`
    annotation, TestNG uses the `@Test` annotation Boolean argument, `enable`. Functionally,
    both work in the same way and the difference is only in the way we write them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JUnit和TestNG都可以禁用测试。虽然JUnit使用单独的`@Ignore`注释，但TestNG使用`@Test`注释的布尔参数`enable`。在功能上，两者的工作方式相同，区别只在于我们编写它们的方式。
- en: The @Test(expectedExceptions = SomeClass.class) annotation argument
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@Test(expectedExceptions = SomeClass.class)注释参数'
- en: This is the case where JUnit has the advantage. While both provide the same
    way to specify the expected exception (in the case of JUnit, the argument is called
    simply `expected`), JUnit introduces rules that are a more elegant way to test
    exceptions (we already worked with them in [Chapter 2](2b33a0f7-c645-4266-891b-8572251f083e.xhtml),
    *Tools, Frameworks, and Environment*).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JUnit占优势的情况。虽然两者都提供了相同的指定预期异常的方式（在JUnit的情况下，参数简单地称为`expected`），JUnit引入了规则，这是一种更优雅的测试异常的方式（我们在[第2章](2b33a0f7-c645-4266-891b-8572251f083e.xhtml)，*工具、框架和环境*中已经使用过它们）。
- en: TestNG versus JUnit summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestNG与JUnit的总结
- en: There are many other differences between those two frameworks. For brevity,
    we do not cover all of them in this book. Consult their documentation for further
    information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个框架之间还有许多其他的区别。为了简洁起见，我们在本书中没有涵盖所有内容。请查阅它们的文档以获取更多信息。
- en: More information about JUnit and TestNG can be found at [http://junit.org/](http://junit.org/)
    and [http://testng.org/](http://testng.org/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JUnit和TestNG的更多信息可以在[http://junit.org/](http://junit.org/)和[http://testng.org/](http://testng.org/)找到。
- en: TestNG provides more features and is more advanced than JUnit. We'll work with
    TestNG throughout this chapter, and you'll get to know it better. One thing that
    you'll notice is that we won't use any of those advanced features. The reason
    is that, with TDD, we rarely need them when working with unit tests. Functional
    and integration tests are of a different kind and would serve as a better demonstration
    of TestNG's superiority. However, there are tools that are more suited for those
    types of tests, as you'll see in the following chapters.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: TestNG提供了比JUnit更多的功能和更先进的功能。我们将在本章节中使用TestNG，并且你会更好地了解它。你会注意到的一件事是，我们不会使用任何那些高级功能。原因是，在使用TDD时，当进行单元测试时，我们很少需要它们。功能和集成测试是不同类型的，它们会更好地展示TestNG的优势。然而，有一些工具更适合这些类型的测试，你会在接下来的章节中看到。
- en: Which one should you use? I'll leave that choice up to you. By the time you
    finish this chapter, you'll have hands-on knowledge of both JUnit and TestNG.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用哪一个？这个选择留给你。当你完成本章时，你将对JUnit和TestNG有实际的了解。
- en: Remote-controlled ship requirements
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 远程控制船只的要求
- en: We'll work on a variation of a well-known kata called **Mars Rover**, originally
    published in *Dallas Hack Club* ([http://dallashackclub.com/rover](http://dallashackclub.com/rover)).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一个名为**Mars Rover**的著名kata的变体上进行工作，最初发表在*达拉斯黑客俱乐部*（[http://dallashackclub.com/rover](http://dallashackclub.com/rover)）。
- en: Imagine that a naval ship is placed somewhere on Earth's seas. Since this is
    the 21^(st) century, we can control that ship remotely.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一艘海军舰船被放置在地球的某个海域。由于这是21世纪，我们可以远程控制那艘船。
- en: Our job will be to create a program that can move the ship around the seas.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工作是创建一个可以在海上移动船只的程序。
- en: Since this is a TDD book and the subject of this chapter is unit tests, we'll
    develop an application using a TDD approach with the focus on unit tests. In the
    previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor
    – From Failure Through Success until Perfection*, you learned the theory and had
    practical experience with the Red-Green-Refactor procedure. We'll build on top
    of that and try to learn how to employ unit testing effectively. Specifically,
    we'll try to concentrate on a unit we're developing and learn how to isolate and
    ignore dependencies that a unit might use. Not only that, but we'll try to concentrate
    on one requirement at a time. For this reason, you were presented only with high-level
    requirements; we should be able to move the remote-controlled ship, located somewhere
    on the planet, around.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一本TDD书籍，本章的主题是单元测试，我们将使用TDD方法开发一个应用程序，重点放在单元测试上。在上一章中，[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)，*红-绿-重构-从失败到成功直至完美*，你学习了理论并且有了红-绿-重构过程的实际经验。我们将在此基础上继续，并尝试学习如何有效地使用单元测试。具体来说，我们将尝试集中精力在我们正在开发的一个单元上，并学习如何隔离和忽略一个单元可能使用的依赖项。不仅如此，我们还将尝试集中精力解决一个需求。因此，你只被呈现了高层次的需求；我们应该能够移动位于地球某处的远程控制船只。
- en: To make things easier, all the supporting classes have been already made and
    tested. This will allow us to concentrate on the main task at hand and, at the
    same time, keep this exercise concise.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，所有支持类已经被创建和测试过。这将使我们能够集中精力处理手头的主要任务，并且同时保持这个练习简洁。
- en: Developing the remote-controlled ship
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发远程控制船只
- en: Let's start by importing the existing Git repository.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入现有的Git存储库开始。
- en: Project setup
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: 'Let''s start setting up the project:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始设置项目：
- en: Open IntelliJ IDEA. If an existing project is already opened, select File|Close
    Project.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IntelliJ IDEA。如果已经打开了现有项目，请选择文件|关闭项目。
- en: 'You will be presented with a screen similar to the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个类似于以下的屏幕：
- en: '![](img/8b78ff11-66a4-4ad7-8a8e-bb57a01a0e65.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b78ff11-66a4-4ad7-8a8e-bb57a01a0e65.png)'
- en: 'To import the project from the Git repository, click on Check out from Version
    Control and select Git. Type `https://bitbucket.org/vfarcic/tdd-java-ch04-ship.git`
    in to the Git Repository URL field and click on Clone:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从Git存储库导入项目，请点击从版本控制检出，然后选择Git。在Git存储库URL字段中输入`https://bitbucket.org/vfarcic/tdd-java-ch04-ship.git`，然后点击克隆：
- en: '![](img/fdadac00-35ba-452f-af9b-18e0d3ea84d9.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fdadac00-35ba-452f-af9b-18e0d3ea84d9.png)'
- en: Answer Yes when asked whether you would like to open the project.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当被问及是否要打开项目时，请选择是。
- en: 'Next you will be presented with the Import Project from Gradle dialog. Click
    on OK:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将看到导入Gradle对话框。点击确定：
- en: '![](img/ed6a55a5-96b3-4dca-8d65-00ef75210725.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed6a55a5-96b3-4dca-8d65-00ef75210725.png)'
- en: 'IDEA will need to spend some time downloading the dependencies specified in
    the `build.gradle` file. Once that is done, you''ll see that some classes and
    corresponding tests are already created:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: IDEA需要一些时间来下载`build.gradle`文件中指定的依赖项。一旦完成，你会看到一些类和相应的测试已经创建：
- en: '![](img/75ac992a-edaf-42a6-a088-3dd628a59ce9.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75ac992a-edaf-42a6-a088-3dd628a59ce9.png)'
- en: Helper classes
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 辅助类
- en: 'Imagine that a colleague of yours started working on this project. He''s a
    good programmer and a TDD practitioner, and you trust his abilities to have good
    test code coverage. In other words, you can rely on his work. However, that colleague
    did not finish the application before he left for his vacations and it''s up to
    you to continue where he stopped. He created all the helper classes: `Direction`,
    `Location`, `Planet`, and `Point`. You''ll notice that the corresponding test
    classes are there as well. They have the same name as the class they''re testing
    with the `Spec` suffix (that is, `DirectionSpec`). The reason for using this suffix
    is to make clear that tests are not only intended to validate the code, but also
    to serve as an executable specification.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你的一个同事开始了这个项目的工作。他是一个优秀的程序员和TDD实践者，你相信他有良好的测试代码覆盖率。换句话说，你可以依赖他的工作。然而，这位同事在离开度假之前没有完成应用程序，现在轮到你继续他停下的地方。他创建了所有的辅助类：`Direction`、`Location`、`Planet`和`Point`。你会注意到相应的测试类也在那里。它们的名称与它们测试的类相同，都带有`Spec`后缀（即`DirectionSpec`）。使用这个后缀的原因是为了明确测试不仅用于验证代码，还用作可执行规范。
- en: On top of the helper classes, you'll find the `Ship` (implementation) and `ShipSpec`
    (specifications/tests) classes. We'll spend most of our time in those two classes.
    We'll write tests in `ShipSpec` and then we'll write the implementation code in
    the `Ship` class (just as we did before).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在辅助类的顶部，你会找到`Ship`（实现）和`ShipSpec`（规范/测试）类。我们将在这两个类中花费大部分时间。我们将在`ShipSpec`中编写测试，然后在`Ship`类中编写实现代码（就像以前一样）。
- en: Since we already learned that tests are not only used as a way to validate the
    code, but also as executable documentation, from this moment on, we'll use the
    phrase specification or spec instead of test.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经学到了测试不仅用作验证代码的方式，还可以作为可执行文档，从现在开始，我们将使用规范或规范代替测试。
- en: 'Every time we finish writing a specification or the code that implements it,
    we''ll run `gradle test` either from the command prompt or by using the Gradle
    projects IDEA Tool Window:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们完成编写规范或实现它的代码时，我们都会从命令提示符中运行`gradle test`，或者使用Gradle项目IDEA工具窗口：
- en: '![](img/f2f9ca0b-3bb2-4db0-a208-d913811f1e0a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2f9ca0b-3bb2-4db0-a208-d913811f1e0a.png)'
- en: With the project set up, we're ready to dive into the first requirement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 项目设置好后，我们就可以开始进行第一个需求了。
- en: Requirement – starting point and orientation
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求-起点和方向
- en: 'We need to know what the current location of the ship is in order to be able
    to move it. Moreover, we should also know which direction it is facing: north,
    south, east, or west. Therefore, the first requirement is the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道船的当前位置，以便能够移动它。此外，我们还应该知道它面向的方向：北、南、东或西。因此，第一个需求如下：
- en: You are given the initial starting point (*x*, *y*) of a ship and the direction
    (*N*, *S*, *E*, or *W*) it is facing.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经得到了船的初始起点（*x*，*y*）和它所面对的方向（*N*，*S*，*E*，或*W*）。
- en: 'Before we start working on this requirement, let''s go through the helper classes
    that can be used. The `Point` class holds the `x` and `y` coordinates. It has
    the following constructor:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理这个需求之前，让我们先看看可以使用的辅助类。`Point`类保存了`x`和`y`坐标。它有以下构造函数：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, we have the `Direction enum` class with the following values:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有`Direction enum`类，其中包含以下值：
- en: '[PRE2]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, there is the `Location` class that requires both of those classes
    to be passed as constructor arguments:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个`Location`类，需要将这两个类作为构造函数参数传递：
- en: '[PRE3]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Knowing this, it should be fairly easy to write a test for this first requirement.
    We should work in the same way as we did in the previous chapter, [Chapter 3](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml), *Red-Green-Refactor –
    From Failure Through Success until Perfection*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 知道这一点，应该很容易为这个第一个需求编写测试。我们应该以与上一章相同的方式工作，[第3章](80748be2-41bd-4ee8-bdff-ce9260cd1225.xhtml)，*红-绿-重构-从失败到成功直至完美*。
- en: Try to write specs by yourself. When done, compare them with the solution in
    this book. Repeat the same process with the code that implements specs. Try to
    write it by yourself and, once done, compare it with the solution we're proposing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试自己编写规范。完成后，将其与本书中的解决方案进行比较。然后用实现规范的代码进行相同的过程。尝试自己编写，完成后再与我们提出的解决方案进行比较。
- en: Specification – keeping position and direction in memory
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-保持位置和方向在内存中
- en: 'The specification for this requirement can be the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求的规范可以是以下内容：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This was an easy one. We're just checking whether the `Location` object we're
    passing as the `Ship` constructor is stored and can be accessed through the `location`
    getter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易。我们只是检查我们作为`Ship`构造函数传递的`Location`对象是否被存储，并且可以通过`location` getter进行访问。
- en: The `@Test` annotation—When TestNG has the `@Test` annotation set on the class
    level, there is no need to specify which methods should be used as tests. In this
    case, all public methods are considered to be TestNG tests.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Test`注解-当TestNG在类级别上设置了`@Test`注解时，不需要指定哪些方法应该用作测试。在这种情况下，所有公共方法都被认为是TestNG测试。'
- en: Implementation
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'The implementation of this specification should be fairly easy. All we need
    to do is set the constructor argument to the `location` variable:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范的实现应该相当容易。我们所需要做的就是将构造函数参数设置为`location`变量：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The full source can be found in the `req01-location` branch of the `tdd-java-ch04-ship`
    repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location)).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可以在`tdd-java-ch04-ship`存储库的`req01-location`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req01-location)）。
- en: Refactoring
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'We know that we''ll need to instantiate `Ship` for every spec, so we might
    as well refactor the specification class by adding the `@BeforeMethod` annotation.
    The code can be the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们需要为每个规范实例化`Ship`，所以我们可以通过添加`@BeforeMethod`注解来重构规范类。代码可以如下：
- en: '[PRE6]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No new behavior has been introduced. We just moved part of the code to the `@BeforeMethod`
    annotation in order to avoid duplication, which would be produced by the rest
    of the specifications that we are about to write. Now, every time a test is run,
    the `ship` object will be instantiated with `location` as the argument.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 没有引入新的行为。我们只是将代码的一部分移动到`@BeforeMethod`注解中，以避免重复，这将由我们即将编写的其余规范产生。现在，每次运行测试时，`ship`对象将以`location`作为参数实例化。
- en: Requirement – forward and backward moves
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求-向前和向后移动
- en: Now that we know where our ship is, let's try to move it. To begin with, we
    should be able to go both forwards and backwards.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了我们的飞船在哪里，让我们试着移动它。首先，我们应该能够向前和向后移动。
- en: Implement commands that move the ship forwards and backwards (*f* and *b*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将飞船向前和向后移动的命令（*f*和*b*）。
- en: 'The `Location` helper class already has the `forward` and `backward` methods
    that implement this functionality:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: “位置”辅助类已经有了实现这一功能的“向前”和“向后”方法：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Specification – moving forward
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-向前移动
- en: What should happen when, for example, we are facing north and we move the ship
    forwards? Its location on the *y*-axis should decrease. Another example would
    be that when the ship is facing east, it should increase its *x*-axis location
    by 1.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们面向北方并向前移动飞船时，它在*y*轴上的位置应该减少。另一个例子是，当飞船面向东方时，它应该将*x*轴位置增加1。
- en: 'The first reaction can be to write specifications similar to the following
    two:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个反应可能是编写类似以下两个规范：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We should create at least two more specifications related to cases where a ship
    is facing south and west.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该创建至少另外两个与飞船面向南方和西方的情况相关的规范。
- en: However, this is not how unit tests should be written. Most people new to unit
    testing fall into the trap of specifying the end result that requires the knowledge
    of the inner workings of methods, classes, and libraries used by the method that
    is being specified. This approach is problematic on many levels.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这不是编写单元测试的方式。大多数刚开始进行单元测试的人会陷入指定需要了解方法、类和库的内部工作知识的最终结果的陷阱。这种方法在许多层面上都存在问题。
- en: When including external code in the unit that is being specified, we should
    take into account, at least in our case, the fact that the external code is already
    tested. We know that it is working since we're running all the tests every time
    any change to the code is made.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在将外部代码包含在被指定的单元中时，我们应该考虑到，至少在我们的情况下，外部代码已经经过测试。我们知道它是有效的，因为我们每次对代码进行更改时都会运行所有测试。
- en: Rerun all the tests every time the implementation code changes.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 每次实现代码更改时重新运行所有测试。
- en: This ensures that there is no unexpected side-effect caused by code changes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了代码更改不会引起意外的副作用。
- en: Every time any part of the implementation code changes, all tests should be
    run. Ideally, tests are fast to execute and can be run by a developer locally.
    Once code is submitted to the version control, all tests should be run again to
    ensure that there was no problem due to code merges. This is especially important
    when more than one developer is working on the code. CI tools, such as Jenkins,
    Hudson, Travind, Bamboo, and Go-CD should be used to pull the code from the repository,
    compile it, and run tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每当实现代码的任何部分发生更改时，都应该运行所有测试。理想情况下，测试执行速度快，可以由开发人员在本地运行。一旦代码提交到版本控制，应该再次运行所有测试，以确保由于代码合并而出现问题。当有多个开发人员在代码上工作时，这一点尤为重要。CI工具，如Jenkins、Hudson、Travind、Bamboo和Go-CD，应该用于从存储库中拉取代码、编译代码并运行测试。
- en: Another problem with this approach is that if an external code changes, there
    will be many more specifications to change. Ideally, we should be forced to change
    only specifications directly related to the unit that will be modified. Searching
    for all other places where that unit is called from might be very time-consuming
    and error-prone.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个问题是，如果外部代码发生更改，将有更多的规范需要更改。理想情况下，我们应该只被迫更改与将要修改的单元直接相关的规范。搜索所有其他调用该单元的地方可能非常耗时且容易出错。
- en: 'A much easier, faster, and better way to write specifications for this requirement
    would be the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为此要求编写规范的另一个更简单、更快、更好的方法是：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since `Location` already has the `forward` method, all we'd need to do is to
    make sure that the proper invocation of that method is performed. We created a
    new `Location` object called `expected`, invoked the `forward` method, and compared
    that object with the location of the ship after its `moveForward` method is called.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“位置”已经有“向前”方法，我们只需要确保执行该方法的适当调用。我们创建了一个名为“expected”的新“位置”对象，调用了“向前”方法，并将该对象与飞船在调用其“moveForward”方法后的位置进行了比较。
- en: Note that specifications are not only used to validate the code, but are also
    used as executable documentation and, most importantly, as a way to think and
    design. This second attempt specifies more clearly what the intent is behind it.
    We should create a `moveForward` method inside the `Ship` class and make sure
    that the `location.forward` is called.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，规范不仅用于验证代码，而且还用作可执行文档，更重要的是，作为一种思考和设计的方式。这第二次尝试更清楚地指定了其背后的意图。我们应该在`Ship`类内创建一个`moveForward`方法，并确保调用`location.forward`。
- en: Implementation
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'With such a small and clearly defined specification, it should be fairly easy
    to write the code that implements it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这样一个小而明确定义的规范，编写实现它的代码应该相当容易：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Specification – moving backward
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-向后移动
- en: 'Now that we have a forward movement specified and implemented, the backward
    movement should almost be the same:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定并实现了向前移动，向后移动应该几乎相同：
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Implementation
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Just like the specification, the backward movement implementation is just as
    easy:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与规范一样，向后移动的实现同样简单：
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The full source code for this requirement can be found in the `req02-forward-backward`
    branch of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此要求的完整源代码可以在`tdd-java-ch04-ship`存储库的`req02-forward-backward`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req02-forward-backward)）。
- en: Requirement – rotating the ship
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求 - 旋转船只
- en: Moving the ship only back and forth won't get us far. We should be able to change
    the direction by rotating the ship to the left or right as well.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只是前后移动船只不会让我们走得太远。我们应该能够通过将船只向左或向右旋转来改变方向。
- en: Implement commands that turn the ship left and right (*l* and *r*).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实现转向左和右的命令（*l*和*r*）。
- en: After implementing the previous requirement, this one should be very easy since
    it can follow the same logic. The `Location` helper class already contains the
    `turnLeft` and `turnRight` methods that perform exactly what is required by this
    requirement. All we need to do is integrate them into the `Ship` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了前面的要求之后，这个要求应该很容易，因为它可以遵循相同的逻辑。`Location`辅助类已经包含了执行这个要求所需的`turnLeft`和`turnRight`方法。我们需要做的就是将它们整合到`Ship`类中。
- en: Specification – turning left
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范 - 向左转
- en: 'Using the same guidelines as those we have used so far, the specification for
    turning left can be the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用迄今为止我们所使用的相同指导方针，向左转的规范可以是以下内容：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Implementation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'You probably did not have a problem writing the code to pass the previous specification:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能没有问题编写代码来通过先前的规范：
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Specification – turning right
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范 - 向右转
- en: 'Turning right should be almost the same as turning left:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 向右转应该几乎与向左转相同：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Implementation
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Finally, let''s finish this requirement by implementing the specification for
    turning right:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们通过实现向右转的规范来完成这个要求：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The full source for this requirement can be found in the `req03-left-right`
    branch of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此要求的完整源代码可以在`tdd-java-ch04-ship`存储库的`req03-left-right`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req03-left-right)）。
- en: Requirement – commands
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求 - 命令
- en: Everything we have done so far was fairly easy since there were helper classes
    that provided all the functionality. This exercise was to learn how to stop attempting
    to test the end outcome and focus on a unit we're working on. We are building
    trust; we had to trust the code done by others (the helper classes).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的一切都相当容易，因为有提供所有功能的辅助类。这个练习是为了学习如何停止尝试测试最终结果，而是专注于我们正在处理的一个单元。我们正在建立信任；我们必须相信其他人编写的代码（辅助类）。
- en: Starting from this requirement, you'll have to trust the code you wrote by yourself.
    We'll continue in the same fashion. We'll write specifications, run tests, and
    see them fail; we'll write implementations, run tests, and see them succeed; finally,
    we'll refactor if we think the code can be improved. Continue thinking how to
    test a unit (method) without going deeper into methods or classes that the unit
    will be invoking.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个要求开始，你将不得不相信你自己写的代码。我们将以同样的方式继续。我们将编写规范，运行测试，看到它们失败；我们将编写实现，运行测试，看到它们成功；最后，如果我们认为代码可以改进，我们将进行重构。继续思考如何测试一个单元（方法）而不深入到单元将要调用的方法或类中。
- en: Now that we have individual commands (forwards, backwards, left, and right)
    implemented, it's time to tie it all together. We should create a method that
    will allow us to pass any number of commands as a single string. Each command
    should be a character with *f* meaning forwards, *b* being backwards, *l* for
    turning left, and *r* for turning right.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了单独的命令（向前、向后、向左和向右），是时候把它们全部联系起来了。我们应该创建一个方法，允许我们将任意数量的命令作为单个字符串传递。每个命令都应该是一个字符，*f*表示向前，*b*表示向后，*l*表示向左，*r*表示向右。
- en: The ship can receive a string with commands (`lrfb`, which are equivalent to
    left, right, forwards, and backwards).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 船只可以接收一个包含命令的字符串（`lrfb`，它们分别等同于左、右、向前和向后）。
- en: Specification – single commands
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范 - 单个命令
- en: 'Let''s start with the command argument, that only has the `f` (forwards) character:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从只有`f`（向前）字符的命令参数开始：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This specification is almost the same as the `whenMoveForwardThenForward` specification
    except that, this time, we're invoking the `ship.receiveCommands("f")` method.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范几乎与`whenMoveForwardThenForward`规范相同，只是这一次，我们调用了`ship.receiveCommands("f")`方法。
- en: Implementation
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: We already spoke about the importance of writing the simplest possible code
    that passes the specification.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了编写尽可能简单的代码以通过规范的重要性。
- en: Write the simplest code to pass the test. This ensures a cleaner and clearer
    design and avoids unnecessary features
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 编写最简单的代码来通过测试。这确保了更清洁和更清晰的设计，并避免了不必要的功能。
- en: The idea is that the simpler the implementation, the better and easier it is
    to maintain the product. The idea adheres to the KISS principle. It states that
    most systems work best if they are kept simple rather than made complex; therefore,
    simplicity should be a key goal in design and unnecessary complexity should be
    avoided.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，实现越简单，产品就越好、维护就越容易。这个想法符合KISS原则。它指出，大多数系统如果保持简单而不是复杂，就能发挥最佳作用；因此，在设计中，简单性应该是一个关键目标，不必要的复杂性应该被避免。
- en: 'This is a good opportunity to apply this rule. You might be inclined to write
    a piece of code similar to the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个应用这一规则的好机会。你可能倾向于编写类似以下的代码：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In this example code, we are verifying whether the first character is `f` and,
    if it is, invoking the `moveForward` method. There are many other variations that
    we can do. However, if we stick to the simplicity principle, a better solution
    would be the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码中，我们正在验证第一个字符是否为`f`，如果是的话，就调用`moveForward`方法。我们还可以做很多其他变化。然而，如果我们坚持简单原则，一个更好的解决方案是以下内容：
- en: '[PRE19]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the simplest and shortest possible code that will make the specification
    pass. Later on, we might end up with something closer to the first version of
    the code; we might use some kind of a loop or come up with some other solution
    when things become more complicated. As for now, we are concentrating on one specification
    at a time and trying to make things simple. We are attempting to clear our mind
    by focusing only on the task at hand.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单和最短的可能使规范通过的代码。以后，我们可能会得到与代码的第一个版本更接近的东西；当事情变得更加复杂时，我们可能会使用某种循环或想出其他解决方案。就目前而言，我们只专注于一次规范，并试图使事情简单化。我们试图通过只专注于手头的任务来清空我们的头脑。
- en: For brevity, the rest of the combinations (`b`, `l`, and `r`) are not presented
    here (continue to implement them by yourself). Instead, we'll jump to the last
    specification for this requirement.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，其余组合（`b`，`l`和`r`）在这里没有呈现（继续自己实现它们）。相反，我们将跳到此需求的最后一个规范。
- en: Specification – combined commands
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-组合命令
- en: 'Now that we are able to process one command (whatever that the command is),
    it is time to add the option to send a string of commands. The specification can
    be the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够处理一个命令（无论命令是什么），是时候添加发送一系列命令的选项了。规范可以是以下内容：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is a bit longer, but is still not an overly complicated specification.
    We're passing commands `rflb` (right, forwards, left, and backwards) and expecting
    that the `Location` changes accordingly. As before, we're not verifying the end
    result (seeing whether the if coordinates have changed), but checking whether
    we are invoking the correct calls to helper methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点长，但仍然不是一个过于复杂的规范。我们传递命令`rflb`（右，前进，左，后退），并期望`Location`相应地改变。与以前一样，我们不验证最终结果（看坐标是否已更改），而是检查我们是否调用了正确的辅助方法。
- en: Implementation
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'The end result can be the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果可能是以下内容：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you tried to write specifications and the implementation by yourself and
    if you followed the simplicity rule, you probably had to refactor your code a
    couple of times in order to get to the final solution. Simplicity is the key and
    refactoring is often a welcome necessity. When refactoring, remember that all
    specifications must be passing all the time.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试自己编写规范和实施，并且遵循简单规则，您可能不得不多次重构代码才能得到最终解决方案。简单是关键，重构通常是一个受欢迎的必要性。重构时，请记住所有规范必须始终通过。
- en: Refactor only after all the tests have passed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在所有测试都通过之后才进行重构。
- en: 'Benefits: refactoring is safe.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 好处：重构是安全的。
- en: If all the implementation code that can be affected has tests and if they are
    all passing, it is relatively safe to refactor. In most cases, there is no need
    for new tests; small modifications to existing tests should be enough. The expected
    outcome of refactoring is to have all the tests passing both before and after
    the code is modified.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有可能受到影响的实施代码都经过测试，并且它们都通过了，那么重构是相对安全的。在大多数情况下，不需要新的测试；对现有测试的小修改应该足够了。重构的预期结果是在修改代码之前和之后都使所有测试通过。
- en: The full source for this requirement can be found in the `req04-commands` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands)).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求的完整源代码可以在`tdd-java-ch04-ship`存储库的`req04-commands`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req04-commands)）。
- en: Requirement – representing spheric maps
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求-表示球形地图
- en: Earth is a sphere, as is any other planet. When Earth is presented as a map,
    reaching one edge wraps us to another; for example, when we move east and reach
    the furthest point in the Pacific Ocean, we are wrapped to the west side of the
    map and we continue moving towards America. Furthermore, to make the movement
    easier, we can define the map as a grid. That grid should have length and height
    expressed as an *x*-axis and *y*-axis. That grid should have maximum length (x)
    and height (y).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 地球是一个球体，就像任何其他行星一样。当地球被呈现为地图时，到达一个边缘会将我们包装到另一个边缘；例如，当我们向东移动并到达太平洋的最远点时，我们被包装到地图的西侧，然后继续向美洲移动。此外，为了使移动更容易，我们可以将地图定义为一个网格。该网格的长度和高度应该表示为*x*轴和*y*轴。该网格应该具有最大长度（x）和高度（y）。
- en: Implement wrapping from one edge of the grid to another.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 实现从网格的一边包装到另一边。
- en: Specification – planet information
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范-行星信息
- en: 'The first thing we can do is pass the `Planet` object with the maximum `X`
    and `Y` axis coordinates to the `Ship` constructor. Fortunately, `Planet` is one
    more of the helper classes that have already been made (and tested). All we need
    to do is instantiate it and pass it to the `Ship` constructor:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的第一件事是将最大`X`和`Y`轴坐标的`Planet`对象传递给`Ship`构造函数。幸运的是，`Planet`是另一个已经制作（并测试过）的辅助类。我们需要做的就是实例化它并将其传递给`Ship`构造函数：
- en: '[PRE22]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We're defining the size of the planet as 50 x 50 and passing that to the `Planet`
    class. In turn, that class is afterwards passed to the `Ship` constructor. You
    might have noticed that the constructor needs an extra argument. In the current
    code, our constructor requires only `location`. To implement this specification,
    it should accept `planet`, as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将行星的大小定义为50 x 50，并将其传递给`Planet`类。然后，该类随后传递给`Ship`构造函数。您可能已经注意到构造函数需要一个额外的参数。在当前代码中，我们的构造函数只需要`location`。为了实现这个规范，它应该接受`planet`。
- en: How would you implement this specification without breaking any of the existing
    specifications?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何在不违反任何现有规范的情况下实施此规范？
- en: Implementation
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'Let''s take a bottom-up approach. An `assert` requires us to have a `planet`
    getter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取自下而上的方法。一个`assert`要求我们有一个`planet`的getter：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, the constructor should accept `Planet` as a second argument and assign
    it to the previously added `planet` variable. The first attempt might be to add
    it to the existing constructor, but that would break many existing specifications
    that are using a single argument constructor. This leaves us with only one option—a
    second constructor:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，构造函数应该接受`Planet`作为第二个参数，并将其分配给先前添加的`planet`变量。第一次尝试可能是将其添加到现有的构造函数中，但这将破坏许多使用单参数构造函数的现有规范。这让我们只有一个选择
    - 第二个构造函数：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run all the specifications and confirm that they are all successful.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有的规范，并确认它们都成功。
- en: Refactoring
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: 'Our specifications forced us to create the second constructor, since changing
    the original one would break the existing tests. However, now that everything
    is green, we can do some refactoring and get rid of the single argument constructor.
    The specification class already has the `beforeTest` method that is run before
    each test. We can move everything, but the `assert` itself to this method:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的规范迫使我们创建第二个构造函数，因为改变原始构造函数会破坏现有的测试。然而，现在一切都是绿色的，我们可以进行一些重构，并摆脱单参数构造函数。规范类已经有了`beforeTest`方法，它在每个测试之前运行。我们可以将除了`assert`本身之外的所有内容都移到这个方法中：
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With this change, we effectively removed the usage of the `Ship` single argument
    constructor. By running all specifications, we should confirm that this change
    worked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个改变，我们有效地移除了`Ship`的单参数构造函数的使用。通过运行所有的规范，我们应该确认这个改变是有效的。
- en: 'Now, with a single argument constructor that is not in use anymore, we can
    remove it from the implementation class, as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于不再使用单参数构造函数，我们可以将其从实现类中删除：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: By using this approach, all specifications were green all the time. Refactoring
    did not change any existing functionality, nothing got broken, and the whole process
    was done quickly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，所有的规范一直都是绿色的。重构没有改变任何现有功能，没有出现任何问题，整个过程进行得很快。
- en: Now, let's move into wrapping itself.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进入包装本身。
- en: Specification – dealing with map boundaries
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范 - 处理地图边界
- en: 'Like in other cases, the helper classes already provide all the functionality
    that we need. So far, we used the `location.forward` method without arguments.
    To implement wrapping, there is the overloaded `location.forward(Point max)` method
    that will wrap the location when we reach the end of the grid. With the previous
    specification, we made sure that `Planet` is passed to the `Ship` class and that
    it contains `Point max`. Our job is to make sure that `max` is used when moving
    forward. The specification can be the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 和其他情况一样，辅助类已经提供了我们需要的所有功能。到目前为止，我们使用了没有参数的`location.forward`方法。为了实现包装，有重载的`location.forward(Point
    max)`方法，当我们到达网格的末端时会包装位置。通过之前的规范，我们确保`Planet`被传递给`Ship`类，并且它包含`Point max`。我们的工作是确保在向前移动时使用`max`。规范可以是以下内容：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Implementation
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: 'By now, you should be getting used to focusing on one unit at a time and to
    trust that those that were done before are working as expected. This implementation
    should be no different. We just need to make sure that the maximum coordinates
    are used when the `location.forward` method is called:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经习惯了一次只关注一个单位，并相信之前完成的工作都按预期工作。这个实现应该也不例外。我们只需要确保在调用`location.forward`方法时使用最大坐标：
- en: '[PRE28]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The same specification and implementation should be done for the `backward`
    method. For brevity, it is excluded from this book, but it can be found in the
    source code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`backward`方法，应该做相同的规范和实现。出于简洁起见，它被排除在本书之外，但可以在源代码中找到。
- en: The full source for this requirement can be found in the `req05-wrap` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap)).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求的完整源代码可以在`tdd-java-ch04-ship`仓库的`req05-wrap`分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req05-wrap)）。
- en: Requirement – detecting obstacles
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需求 - 检测障碍物
- en: We're almost done. This is the last requirement.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。这是最后一个需求。
- en: Even though most of the Earth is covered in water (approximately 70%), there
    are continents and islands that can be considered as obstacles for our remotely-controlled
    ship. We should have a way to detect whether our next move would hit one of those
    obstacles. If such a thing happens, the move should be aborted and the ship should
    stay on the current position and report the obstacle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管地球大部分被水覆盖（约70%），但也有大陆和岛屿可以被视为我们远程控制船只的障碍物。我们应该有一种方法来检测下一步移动是否会碰到这些障碍物。如果发生这种情况，移动应该被中止，船只应该停留在当前位置并报告障碍物。
- en: Implement surface detection before each move to a new position. If a command
    encounters a surface, the ship aborts the move, stays on the current position,
    and reports the obstacle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次移动到新位置之前实现表面检测。如果命令遇到表面，船只将中止移动，停留在当前位置，并报告障碍物。
- en: The specifications and the implementation of this requirement are very similar
    to those we did previously, and we'll leave that to you.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个需求的规范和实现与我们之前做的非常相似，我们将留给你来完成。
- en: 'Here are a few tips that can be useful:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些可能有用的提示：
- en: The `Planet` object has the constructor that accepts a list of obstacles.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Planet`对象有一个接受障碍物列表的构造函数。'
- en: Each obstacle is an instance of the `Point` class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 每个障碍物都是`Point`类的一个实例。
- en: The `location.foward` and `location.backward` methods have overloaded versions
    that accept a list of obstacles. They return `true` if a move was successful and
    `false` if it failed. Use this Boolean to construct a status report required for
    the `Ship.receiveCommands` method.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`location.foward`和`location.backward`方法有重载版本，接受障碍物列表。如果移动成功则返回`true`，失败则返回`false`。使用这个布尔值来构建`Ship.receiveCommands`方法所需的状态报告。'
- en: The `receiveCommands` method should return a string with the status of each
    command. `0` can represent OK and `X` can be for a failure to move (`00X0` = OK,
    OK, Failure, OK).
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`receiveCommands` 方法应返回一个包含每个命令状态的字符串。`0` 可以表示 OK，`X` 可以表示移动失败（`00X0` = OK,
    OK, 失败, OK）。'
- en: The full source for this requirement can be found in the `req06-obstacles` branch
    of the `tdd-java-ch04-ship` repository ([https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此要求的完整源代码可以在 `tdd-java-ch04-ship` 仓库的 `req06-obstacles` 分支中找到（[https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles](https://bitbucket.org/vfarcic/tdd-java-ch04-ship/branch/req06-obstacles)）。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we used TestNG as our testing framework of choice. There wasn't
    much difference when compared to JUnit, simply because we didn't use any of the
    more advanced features of TestNG (for example, data providers, factories, and
    so on). With TDD, it is questionable whether we'll ever have a need for those
    features.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们选择了 TestNG 作为我们的测试框架。与 JUnit 相比，没有太大的区别，因为我们没有使用 TestNG 的更高级功能（例如数据提供者、工厂等）。在
    TDD 中，我们是否真的需要这些功能是值得怀疑的。
- en: Visit [http://testng.org/](http://testng.org/), explore it, and decide for yourself
    which framework best suits your needs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://testng.org/](http://testng.org/)，探索它，并自行决定哪个框架最适合您的需求。
- en: The main objective of this chapter was to learn how to focus on one unit at
    a time. We already had a lot of helper classes and we tried our best to ignore
    their internal workings. In many cases, we did not write specifications that verified
    that the end result was correct, but we checked whether the method we were working
    on invoked the correct method from those helper classes. In the real-world, you
    will be working on projects together with other team members, and it is important
    to learn how to focus on your tasks and trust that what others do works as expected.
    The same can be said for third-party libraries. It would be too expensive to test
    all inner processes that can happen when we invoke them. There are other types
    of tests that will try to cover those possibilities. When working with unit tests,
    the focus should only be on the unit we're currently working on.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是学习如何一次只专注于一个单元。我们已经有了许多辅助类，并且我们尽力忽略它们的内部工作。在许多情况下，我们并没有编写验证最终结果是否正确的规范，但我们检查了我们正在处理的方法是否调用了这些辅助类的正确方法。在现实世界中，您将与其他团队成员一起工作在项目上，学会专注于自己的任务并相信其他人的工作符合预期是很重要的。对于第三方库也是一样的。测试所有内部过程的成本太高了。有其他类型的测试将尝试覆盖这些可能性。在进行单元测试时，焦点应该只放在我们当前正在处理的单元上。
- en: Now that you have a better grasp of how to use unit tests effectively in the
    context of TDD, it is time to dive into some other advantages that TDD provides.
    Specifically, we'll explore how to design our applications better.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对如何在 TDD 的上下文中有效使用单元测试有了更好的理解，是时候深入了解 TDD 提供的其他优势了。具体来说，我们将探讨如何更好地设计我们的应用程序。
