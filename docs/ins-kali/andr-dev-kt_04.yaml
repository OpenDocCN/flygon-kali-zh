- en: Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: The Kotlin language provides full support for OOP programming. We will review
    powerful structures that allow us to simplify data model definition and operate
    on it in an easy and flexible way. We'll learn how Kotlin simplifies and improves
    implementations of many concepts known from Java. We will take a look at different
    type of classes, properties, initializer blocks, and constructors. We will learn
    about **operator overloading** and interface default implementations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin语言为面向对象编程提供了全面的支持。我们将审查强大的结构，这些结构使我们能够简化数据模型的定义，并以一种简单灵活的方式对其进行操作。我们将了解Kotlin如何简化和改进许多从Java中已知的概念的实现。我们将看看不同类型的类、属性、初始化块和构造函数。我们将学习**运算符重载**和接口默认实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Class declaration
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类声明
- en: Properties
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Property access syntax
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问语法
- en: Constructors and initializers blocks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数和初始化块
- en: Constructors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: Inheritance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Data classes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类
- en: Destructive declarations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏性声明
- en: Operator overloading
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Object declaration
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象声明
- en: Object expression
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象表达式
- en: Companion objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伴生对象
- en: Enum classes
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举类
- en: Sealed classes
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密封类
- en: Nested classes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套类
- en: Classes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes are a fundamental building block of OOP. In fact, Kotlin classes are
    very similar to Java classes. Kotlin, however, allows more functionality together
    with simpler and much more concise syntax.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类是面向对象编程的基本构建块。事实上，Kotlin类与Java类非常相似。然而，Kotlin允许更多的功能，以及更简单和更简洁的语法。
- en: Class declaration
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类声明
- en: 'Classes in Kotlin are defined using the `class` keyword*.* The following is
    the simplest class declaration--an empty class named `Person` :'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，使用`class`关键字定义类。以下是最简单的类声明--一个名为`Person`的空类：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Definition of `Person` does not contain any body. Still, it can be instantiated
    using a default constructor:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`的定义不包含任何主体。尽管如此，它可以使用默认构造函数进行实例化：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Even such a simple task as class instantiation is simplified in Kotlin. Unlike
    Java, Kotlin does not require the `new` keyword to create a class instance. Due
    to strong Kotlin interoperability with Java, we can instantiate classes defined
    in Java and Kotlin exactly the same way (without the `new` keyword). The syntax
    used to instantiate a class depends on the actual language used to create class
    instance (Kotlin or Java), not the language the class was declared in:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是类实例化这样简单的任务在Kotlin中也得到了简化。与Java不同，Kotlin不需要`new`关键字来创建类实例。由于Kotlin与Java的强大互操作性，我们可以以完全相同的方式实例化在Java和Kotlin中定义的类（不需要`new`关键字）。用于实例化类的语法取决于创建类实例的实际语言（Kotlin或Java），而不是声明类的语言：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is the rule of thumb to use the `new` keyword inside a Java file and never
    use the `new` keyword inside a Kotlin file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java文件中使用`new`关键字而在Kotlin文件中永远不要使用`new`关键字是一个经验法则。
- en: Properties
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Property is just a combination of a *backing field* and its accessors. It could
    be a *backing field* with both a getter and a setter or a backing field with only
    one of them. Properties can be defined at the top-level (directly inside file)
    or as a member (for example, inside class, interface, and so on).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 属性只是*支持字段*及其访问器的组合。它可以是具有getter和setter的*支持字段*，也可以是只有其中一个的*支持字段*。属性可以在顶层（直接在文件内部）或作为成员（例如，在类、接口等内部）进行定义。
- en: 'In general, it is advisable to define properties (private fields with getters/setters)
    instead of accessing public fields directly (According to *Effective Java, by
    Joshua Bloch,* book''s item 14: in public classes, use accessor methods, not public
    fields).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，建议定义属性（具有getter/setter的私有字段）而不是直接访问公共字段（根据*Effective Java, by Joshua Bloch,*书中的第14项建议：在公共类中，使用访问器方法，而不是公共字段）。
- en: '**Java getter and setter conventions for private fields'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java私有字段的getter和setter约定'
- en: 'Getter** : A parameterless method with a name that corresponds to property
    name and a `get` prefix (for a `Boolean` property there might be an `is` prefix
    used instead)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Getter**：一个无参数方法，其名称对应于属性名称，并带有`get`前缀（对于`Boolean`属性，可能会使用`is`前缀）
- en: '**Setter** : Single-argument methods with names starting with `set` : for example,
    `setResult(String resultCode)`'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Setter**：以`set`开头的单参数方法：例如，`setResult(String resultCode)`'
- en: 'Kotlin guards this principle by language design, because this approach provides
    various encapsulation benefits:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin通过语言设计来保护这一原则，因为这种方法提供了各种封装的好处：
- en: Ability to change internal implementation without changing an external API
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在不改变外部API的情况下改变内部实现
- en: Enforces invariants (call methods that validate objects state)
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制不变量（调用验证对象状态的方法）
- en: Ability to perform additional actions when accessing member (for example, log
    operation)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在访问成员时执行附加操作（例如，记录操作）
- en: 'To define a top-level property, we simply define it in the Kotlin file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义顶级属性，我们只需在Kotlin文件中定义它：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s imagine that we need a class to store basic data regarding a person.
    This data may be downloaded from an external API (backend) or retrieved from a
    local database. Our class will have to define two (member) properties, `name`
    and `age` . Let''s look at the Java implementation first:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要一个类来存储有关人员的基本数据。这些数据可以从外部API（后端）下载，也可以从本地数据库中检索。我们的类将需要定义两个（成员）属性，`name`和`age`。让我们先看一下Java的实现：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This class contains only two properties. Since we can make the Java IDE generate
    accessors code for us, at least we don't have to write the code by ourselves.
    However, the problem with this approach is that we cannot get along without these
    automatically generated chunks, and that makes the code very verbose. We (developers)
    spend most of our time just reading the code, not writing it, so reading redundant
    code wastes a lot of valuable time. Also a simple task such as refactoring the
    property name becomes a little bit trickier, because the IDE might not update
    constructor parameter names.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只包含两个属性。由于我们可以让Java IDE为我们生成访问器代码，至少我们不必自己编写代码。然而，这种方法的问题在于我们无法摆脱这些自动生成的代码块，这使得代码非常冗长。我们（开发人员）大部分时间都在阅读代码，而不是编写代码，因此阅读冗余的代码浪费了大量宝贵的时间。而且，像重构属性名称这样的简单任务变得有点棘手，因为IDE可能不会更新构造函数参数名称。
- en: 'Fortunately, boilerplate code can be decreased significantly by using Kotlin.
    Kotlin solves this problem by introducing the concept of *properties* that is
    built into the language. Let''s look at a Kotlin equivalent of the preceding Java
    class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，使用Kotlin可以显著减少样板代码。Kotlin通过引入内置于语言中的*属性*的概念来解决这个问题。让我们看一下前面的Java类的Kotlin等价物：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is an exact equivalent of the preceding Java class:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面的Java类的确切等价物：
- en: The `constructor` method is equivalent of the Java constructor that is called
    when an object instance is created
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constructor`方法相当于在创建对象实例时调用的Java构造函数'
- en: Getters and setters are generated by the Kotlin compiler
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin编译器生成getter和setter
- en: We can still define custom implementations of getters and setters. We will discuss
    this in more detail in the *Custom getters/setters section* .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以定义getter和setter的自定义实现。我们将在*自定义getter/setter部分*中更详细地讨论这一点。
- en: 'All the constructors that we have already defined are called *secondary* *constructors.*
    Kotlin also provides alternative, very concise syntax for defining constructors.
    We can define a constructor (with all parameters) as part of the class header.
    This kind of constructor is called a *primary constructor* . Let''s move a property
    declaration from the secondary constructor into the primary constructor to make
    our code a little bit shorter:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义的所有构造函数都被称为*次要构造函数*。Kotlin还提供了另一种非常简洁的语法来定义构造函数。我们可以将构造函数（带有所有参数）定义为类头的一部分。这种类型的构造函数被称为*主构造函数*。让我们将属性声明从次要构造函数移动到主构造函数，以使我们的代码变得更短：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In Kotlin, the primary constructor, as opposed to the secondary constructor,
    can't contain any code, so all initialization code must be placed inside the initializer
    block (`init` ). An initializer block will be executed during class creation,
    so we can assign constructor parameters to fields inside it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，与次要构造函数相反，主构造函数不能包含任何代码，因此所有初始化代码必须放在初始化块（`init`）中。初始化块将在类创建期间执行，因此我们可以在其中将构造函数参数赋值给字段。
- en: 'To simplify code, we can remove the initializer block and access constructor
    parameters directly in property initializers. This allows us to assign constructor
    parameters to a field:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化代码，我们可以删除初始化块，并直接在属性初始化程序中访问构造函数参数。这使我们能够将构造函数参数赋值给字段：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We managed to make the code shorter, but it still contains a lot of boilerplate,
    because type declarations and property names are duplicated (constructor parameter,
    field assignment, and field itself). When properties does not have any custom
    getters or setters we can define them directly inside primary constructor by adding
    val or var modifier:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设法使代码变得更短，但仍然包含大量样板，因为类型声明和属性名称被重复（构造函数参数、字段赋值和字段本身）。当属性没有任何自定义的getter或setter时，我们可以通过在主构造函数中直接添加val或var修饰符来定义它们：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, if the primary constructor does not have any annotations (`@Inject`
    , and so on) or visibility modifiers (`public` , `private` , and so on), then
    the `constructor` keyword can be omitted:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果主构造函数没有任何注解（`@Inject`等）或可见性修饰符（`public`，`private`等），那么可以省略`constructor`关键字：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the constructor takes a few parameters, it is good practice to define
    each parameter in a new line to improve code readability and decrease chance of
    potential merge conflicts (when merging branches from source code repository):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数接受几个参数时，最好将每个参数定义在新的一行中，以提高代码可读性并减少潜在合并冲突的机会（当从源代码存储库合并分支时）：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Summing up, the preceding example is equivalent of the Java class presented
    at the beginning of this section--both properties are defined directly in the
    class primary constructor and Kotlin compiler does all the work for us--it generates
    appropriate fields and accessors (getters/setters).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，前面的例子等同于本节开头呈现的Java类--两个属性都直接在类主构造函数中定义，Kotlin编译器为我们做了所有工作--它生成了适当的字段和访问器（getter/setter）。
- en: Note that this notation contains only the most important information about this
    data model class--its name, parameter names, types, and mutability (`val` /`var`
    ) information. Implementation has nearly zero boilerplate. This makes the class
    very easy to read, understand, and maintain.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此表示法仅包含有关此数据模型类的最重要信息--其名称、参数名称、类型和可变性（`val`/`var`）信息。实现几乎没有样板。这使得类非常易于阅读、理解和维护。
- en: Read-write versus read-only property
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写属性与只读属性
- en: 'All the properties in the previous examples were defined as read-write (a setter
    and a getter are generated). To define read-only properties we need to use the
    `val` keyword, so only getter will be generated. Let''s look at a simple example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有属性都被定义为读写（生成了setter和getter）。要定义只读属性，我们需要使用`val`关键字，这样只会生成getter。让我们看一个简单的例子：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Kotlin does not support write-only properties (properties of which only setter
    is generated).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin不支持只写属性（只生成setter的属性）。
- en: '| **Keyword** | **Read** | **Write** |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **关键字** | **读** | **写** |'
- en: '| `var` | Yes | Yes |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `var` | 是 | 是 |'
- en: '| `val` | Yes | No |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `val` | 是 | 否 |'
- en: '| (unsupported) | No | Yes |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|（不支持）| 否 | 是 |'
- en: Property access syntax between Kotlin and Java
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin和Java之间的属性访问语法
- en: 'Another big improvement introduced by Kotlin is the way of accessing properties.
    In Java, we would access property using the corresponding method (`setSpeed` /`getSpeed`
    ). Kotlin promotes *property access syntax* , which is a more expressive way of
    accessing properties. Let''s compare both approaches, assuming we have a simple
    `Car` class that has a single `speed` property:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin引入的另一个重大改进是访问属性的方式。在Java中，我们会使用相应的方法（`setSpeed`/`getSpeed`）来访问属性。Kotlin提倡*属性访问*语法，这是一种更具表现力的访问属性的方式。让我们比较这两种方法，假设我们有一个简单的`Car`类，它有一个名为`speed`的属性：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As we can see, in Kotlin there is no need to add `get` , `set` prefixes and
    parentheses to access or modify an object property. Using property access syntax
    allows for direct usage of increment (++) and decrement (--) operators together
    with property access:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，在Kotlin中，访问或修改对象属性时不需要添加`get`、`set`前缀和括号。使用属性访问语法允许直接使用增量（++）和减量（--）运算符与属性访问一起使用：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Increment and decrement operators
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增量和减量运算符
- en: 'There are two kinds of increment (++ ) and decrement(--) operators: pre-increment/pre-decrement
    where the operator is defined before the expression, and post-increment/post-decrement
    where the operator is defined after the expression:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的增量（++）和减量（--）运算符：前增量/前减量，其中运算符在表达式之前定义，和后增量/后减量，其中运算符在表达式之后定义：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, using post- versus pre-increment/decrement would change
    nothing because those operations are executed in sequence. But this makes a huge
    difference when the increment/decrement operator is combined with a function call.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，使用后增量/减量与前增量/减量不会改变任何东西，因为这些操作是按顺序执行的。但是当增量/减量运算符与函数调用结合时，这将产生很大的差异。
- en: 'In the pre-increment operator, speed is retrieved, incremented, and passed
    to a function as an argument:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在预增量运算符中，速度被检索，增加，并作为参数传递给函数：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In post-increment operator speed is retrieved, passed to a function as an argument,
    and then it is incremented, so the old value is passed to a function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在后增量运算符中，速度被检索，作为参数传递给函数，然后增加，所以旧值被传递给函数：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This works in an analogical way for pre-decrement and post-decrement operators.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于预减量和后减量运算符也是类似的。
- en: Property access syntax is not limited only to classes defined in Kotlin. Each
    method that follows the Java conventions for getters and setters is represented
    as a property in Kotlin.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问语法不仅限于在Kotlin中定义的类。遵循Java约定的getter和setter的每个方法在Kotlin中表示为属性。
- en: 'This means that we can define a class in Java and access its properties in
    Kotlin using *property access* syntax. Let''s define a Java `Fish` class with
    two properties, `size` and `isHungry` , and let''s instantiate this class in Kotlin
    and access the properties:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在Java中定义一个类，并使用*属性访问*语法在Kotlin中访问其属性。让我们定义一个Java `Fish`类，有两个属性，`size`和`isHungry`，然后在Kotlin中实例化这个类并访问这些属性：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This works both ways, so we can define the `Fish` class in Kotlin using very
    concise syntax and access it in a usual Java way, because the Kotlin compiler
    will generate all the required getters and setters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式都可以，所以我们可以使用非常简洁的语法在Kotlin中定义`Fish`类，并以通常的Java方式访问它，因为Kotlin编译器将生成所有必需的getter和setter：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we can see, syntax used to access the class property depends on the actual
    language that the class uses, not the language that the class was declared in.
    This allows for more idiomatic usage of many classes defined in the Android framework.
    Let''s see some examples:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，用于访问类属性的语法取决于类使用的实际语言，而不是声明类的语言。这允许更多地使用在Android框架中定义的许多类的习惯用法。让我们看一些例子：
- en: '| **Java method access syntax** | **Kotlin property access syntax** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **Java方法访问语法** | **Kotlin属性访问语法** |'
- en: '| `activity.getFragmentManager()` | `activity.fragmentManager` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `activity.getFragmentManager()` | `activity.fragmentManager` |'
- en: '| `view.setVisibility(Visibility.GONE)` | `view.visibility = Visibility.GONE`
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `view.setVisibility(Visibility.GONE)` | `view.visibility = Visibility.GONE`
    |'
- en: '| `context.getResources().getDisplayMetrics().density` | `context.resources.displayMetrics.density`
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `context.getResources().getDisplayMetrics().density` | `context.resources.displayMetrics.density`
    |'
- en: Property access syntax results in more concise code that decreases the original
    Java language complexity. Notice that it is still possible to use method access
    syntax with Kotlin although property access syntax is often the better alternative.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问语法导致更简洁的代码，减少了原始Java语言的复杂性。请注意，虽然在Kotlin中仍然可以使用方法访问语法，但属性访问语法通常是更好的选择。
- en: 'There are some methods in the Android framework that use the `is` prefix for
    their name; in this cases Boolean properties also have the `is` prefix:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android框架中有一些方法的名称使用`is`前缀；在这种情况下，布尔属性也有`is`前缀：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Kotlin marks overridden members using the `override` modifier, not `@Override`
    annotation like Java.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin使用`override`修饰符标记重写的成员，而不是像Java那样使用`@Override`注解。
- en: Although using `finishing` would be the most natural and consistent approach,
    it's impossible to use it by default due to potential conflicts.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用`finishing`可能是最自然和一致的方法，但由于潜在的冲突，无法默认使用它。
- en: 'Another case where we can''t use the property access syntax is when the property
    defines only setter without getter, because Kotlin does not support write-only
    properties, as in this example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况下，我们无法使用属性访问语法的是当属性只定义了setter而没有getter时，因为Kotlin不支持只写属性，就像这个例子：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Custom getters/setters
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义getter/setter
- en: 'Sometimes we want to have more control about property usage. We may want to
    perform other auxiliary operations when using property; for example, verify a
    value before it''s assigned to a field, log the whole operation, or invalidate
    an instance state. We can do it by specifying custom setters and/or getters. Let''s
    add the `ecoRating` property to our `Fruit` class. In most cases, we would add
    this property to the class declaration header like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望对属性的使用有更多的控制。我们可能希望在使用属性时执行其他辅助操作；例如，在将值分配给字段之前验证值，记录整个操作，或使实例状态无效。我们可以通过指定自定义setter和/或getter来实现。让我们将`ecoRating`属性添加到我们的`Fruit`类中。在大多数情况下，我们会像这样将此属性添加到类声明头中：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we want to define custom getters and setters, we need to define a property
    in the class body instead of the class declaration header. Let''s move the `ecoRating`
    property into the class body:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想定义自定义的getter和setter，我们需要在类体中定义属性，而不是在类声明头中。让我们将`ecoRating`属性移到类主体中：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When the property is defined inside the body of a class, we have to initialize
    it with value (even nullable properties need to be initialized with a null value).
    We can provide the default value instead of filling a property with the constructor
    argument:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性在类的主体内部定义时，我们必须用值初始化它（即使可空属性也需要用空值初始化）。我们可以提供默认值，而不是用构造函数参数填充属性：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also compute default values based on some other properties:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以基于其他属性计算默认值：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Different values will be set for different weight constructor arguments.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的值将为不同的权重构造函数参数设置。
- en: 'When a property is defined in a class body, the type declaration can be omitted,
    because it can be inferred from the context:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性在类体中定义时，类型声明可以省略，因为它可以从上下文中推断出来：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s define a custom getter and setter with the default behavior that will
    be the equivalent of the preceding property:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个具有默认行为的自定义getter和setter，该行为将等同于前面的属性：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inside the `get` and `set` block, we can have access to a special variable called
    `field` *,* which refers to the corresponding backing field of the property. Notice
    that the Kotlin property declaration is closely positioned to a custom getter/setter.
    This contradicts with Java and solves the issue where the field declaration is
    usually at the top of the file containing class and corresponding getter/setter
    is at the bottom of this file, so we can't really see them on a single screen
    and thus code is more difficult to read. Apart from that location, Kotlin property
    behavior is quite similar to Java. Each time we retrieve, value from the `ecoRating`
    property, a `get` block will be executed, and each time we assign a new value
    to the `ecoRating` property, a `set` block will be executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`get`和`set`块内，我们可以访问一个名为`field`的特殊变量，它指的是属性的对应后备字段。请注意，Kotlin属性声明与自定义getter/setter紧密相关。这与Java相矛盾，并解决了字段声明通常位于包含类和相应getter/setter的文件顶部的问题，因此我们无法在单个屏幕上看到它们，因此代码更难阅读。除了位置之外，Kotlin属性行为与Java非常相似。每次从`ecoRating`属性中检索值时，都会执行`get`块，每次将新值分配给`ecoRating`属性时，都会执行`set`块。
- en: This is a read-write property (`var` ), so it may contain both corresponding
    getters and setters. In case we explicitly define only one of them, the default
    implementation will be used for another.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个读写属性（`var`），因此它可能包含相应的getter和setter。如果我们只显式定义其中一个，另一个将使用默认实现。
- en: 'To make a value computed each time when a property value is retrieved, we need
    to explicitly define getter:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要使属性值在检索属性值时每次计算，我们需要显式定义getter：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since Kotlin 1.1 type can be omitted (it is to be inferred).
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自Kotlin 1.1开始，类型可以省略（它将被推断）。
- en: The getter versus property default value
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: getter与属性默认值
- en: 'In the preceding example, we used getter, so the property value is calculated
    each time the value is retrieved. By omitting getter we can create a default value
    for the property. This value will be computed only once during class creation
    and it will never change (changing the `weight` property will have no effect on
    the `isHeavy` property value):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用了getter，因此每次检索值时都会计算属性值。通过省略getter，我们可以为属性创建默认值。这个值将在类创建期间仅计算一次，永远不会改变（改变`weight`属性不会影响`isHeavy`属性的值）：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This type of property does have a backing field, because its value is always
    computed during object creation. We can also create read-write properties without
    a backing field:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的属性有后备字段，因为它的值始终在对象创建期间计算。我们还可以创建没有后备字段的读写属性：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This type of property does not have a backing field, because its value is always
    computed using another property.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的属性没有后备字段，因为它的值始终使用另一个属性计算。
- en: Late-initialized properties
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟初始化属性
- en: 'Sometimes we know that a property won''t be null, but it won''t be initialized
    with the value at declaration time. Let''s look at common Android examples--retrieving
    reference to a layout element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们知道属性不会为空，但它不会在声明时初始化值。让我们看看常见的Android示例--检索布局元素的引用：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `button` variable can't be initialized at declaration time, because the
    `MainActivity` layout is not yet initialized. We can retrieve reference to the
    button defined in the layout inside the `onCreate` method, but to do it we need
    to declare a variable as nullable (`Button?` ).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`button`变量不能在声明时初始化，因为`MainActivity`布局尚未初始化。我们可以在`onCreate`方法中检索定义在布局中的按钮的引用，但为了做到这一点，我们需要将变量声明为可空（`Button?`）。'
- en: Such an approach seems quite impractical, because after the `onCreate` method
    is called a `button` instance is available all the time. However, the client still
    needs to use the safe call operator or other nullity checks to access it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法似乎相当不实用，因为在调用`onCreate`方法后，`button`实例始终可用。然而，客户端仍然需要使用安全调用运算符或其他空值检查来访问它。
- en: 'To avoid nullity checks when accessing a property, we need a way to inform
    the Kotlin compiler that this variable will be filled before usage, but its initialization
    will be delayed in time. To do this, we can use the `lateinit` modifier:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在访问属性时进行空值检查，我们需要一种方法来告诉Kotlin编译器，这个变量将在使用之前填充，但它的初始化将被延迟。为此，我们可以使用`lateinit`修饰符：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, with the property marked as `lateinit` *,* we can access our application
    instance without performing nullity checks.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过将属性标记为`lateinit`，我们可以在不执行空值检查的情况下访问我们的应用程序实例。
- en: The `lateinit` modifier tells the compiler that this property is non-nullable,
    but its initialization is delayed in time. Naturally, when we try to access the
    property before it is initialized, the application will throw `UninitializedPropertyAccessException`
    . This is fine, because we assume that this scenario should not happen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`lateinit`修饰符告诉编译器，这个属性是非空的，但它的初始化被延迟了。当我们在初始化之前尝试访问属性时，应用程序会抛出`UninitializedPropertyAccessException`。这没关系，因为我们假设这种情况不应该发生。'
- en: A scenario where a variable initialization is not possible at declaration time
    is quite common and it is not always related to views. Properties can be initialized
    through Dependency Injection, or via the `setup` method of a unit test. In such
    scenarios, we cannot supply a non-nullable value in the constructor, but we still
    want to avoid nullity checks.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明时无法初始化变量的情况非常普遍，而且并不总是与视图有关。属性可以通过依赖注入或单元测试的`setup`方法进行初始化。在这种情况下，我们无法在构造函数中提供非空值，但仍希望避免空值检查。
- en: '**The lateinit property and frameworks**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**lateinit属性和框架**'
- en: 'The `lateinit` property is also helpful when a property is injected by the
    Dependency Injection framework. The popular Android Dependency Injection framework,
    **Dagger** , uses the `@Inject` annotation to mark properties that need to be
    injected:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`lateinit`属性在属性由依赖注入框架注入时也很有帮助。流行的Android依赖注入框架**Dagger**使用`@Inject`注解来标记需要注入的属性：'
- en: '`@Inject lateinit var locationManager: LocationManager`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Inject lateinit var locationManager: LocationManager`'
- en: We know that the property will never be null (because it will be injected),
    but the Kotlin compiler does not understand this annotation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道属性永远不会为空（因为它将被注入），但Kotlin编译器不理解这个注释。
- en: 'Similar scenarios happen with the popular framework, **Mockito** *:* `@Mock
    lateinit var mockEventBus: EventBus`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '类似的情况也发生在流行的框架**Mockito**中：`@Mock lateinit var mockEventBus: EventBus`'
- en: The variable will be mocked, but it will happen sometime later, after test class
    creation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 变量将被模拟，但这将在测试类创建后的某个时候发生。
- en: Annotating properties
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性注释
- en: 'Kotlin generates multiple JVM bytecode elements from a single property (`private`
    field, getter, setter). Sometimes the framework annotation processor or the reflection-based
    library requires a particular element to be defined as a public field. A good
    example of such behavior is the JUnit test framework. It requires rules to be
    provided through a test class field or a getter method. We may encounter this
    problem when defining `ActivityTestRule` or Mockito''s (mocking framework for
    unit tests) `Rule` annotation:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin从单个属性生成多个JVM字节码元素（`private`字段，getter，setter）。有时框架注解处理器或基于反射的库需要将特定元素定义为公共字段。这种行为的一个很好的例子是JUnit测试框架。它要求通过测试类字段或getter方法提供规则。当定义`ActivityTestRule`或Mockito的（用于单元测试的模拟框架）`Rule`注解时，我们可能会遇到这个问题：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code annotates the Kotlin property that JUnit won''t recognize,
    so `ActivityTestRule` can''t be properly initialized. The JUnit annotation processor
    expects the `Rule` annotation on the field or getter. There are a few ways to
    solve this problem. We can expose the Kotlin property as a Java field by annotating
    it with the `@JvmField` annotation:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码注释了JUnit无法识别的Kotlin属性，因此无法正确初始化`ActivityTestRule`。JUnit注解处理器期望在字段或getter上有`Rule`注解。有几种方法可以解决这个问题。我们可以通过使用`@JvmField`注释将Kotlin属性公开为Java字段：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The field will have the same visibility as the underlying property. There are
    a few limitations regarding `@JvmField` annotation usage. We can annotate a property
    with `@JvmField` if it has a backing field, it is not private, does not have open,
    override, or const modifiers, and is not a delegated property.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段将具有与基础属性相同的可见性。关于`@JvmField`注释的使用有一些限制。如果属性具有支持字段，不是私有的，没有open，override或const修饰符，并且不是委托属性，我们可以使用`@JvmField`注释属性。
- en: 'We can also annotate getter by adding an annotation directly to getter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过直接向getter添加注释来注释getter：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we don''t want to define getter, we can still add an annotation to getter
    using the use-site target (`get` ). By doing so, we simply specify which element
    generated by the Kotlin compiler will be annotated:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想定义getter，我们仍然可以使用使用地点目标（`get`）向getter添加注释。通过这样做，我们只需指定由Kotlin编译器生成的哪个元素将被注释：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Inline properties
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联属性
- en: 'We can optimize property calls by using the `inline` modifier. During compilation
    each property call will be optimized. Instead of really calling a property, the
    call will be replaced with the property body:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`inline`修饰符来优化属性调用。在编译期间，每个属性调用都将被优化。调用属性时，调用将被替换为属性体：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With inline property, we are using the `inline` modifier. The preceding code
    will be compiled to:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内联属性时，我们使用`inline`修饰符。前面的代码将被编译为：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inlining improves performance, because there is no need to create additional
    objects. No getter will be invoked, because the body would replace the property
    usage. Inlining has one limitation--it can be only applied to properties that
    do not have a backing field.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 内联可以提高性能，因为不需要创建额外的对象。不会调用getter，因为体会替换属性的使用。内联有一个限制——它只能应用于没有支持字段的属性。
- en: Constructors
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'Kotlin allows us to define classes without any constructors. We can also define
    a primary constructor and one or more secondary constructors:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许我们定义没有任何构造函数的类。我们还可以定义一个主构造函数和一个或多个次要构造函数：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Declaring properties is not allowed for secondary constructors. If we need
    a property that is initialized by secondary constructors, we must declare it in
    the class body, and we can initialize it in the secondary constructor body. Let''s
    define the `fresh` property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 不允许为次要构造函数声明属性。如果我们需要一个由次要构造函数初始化的属性，我们必须在类体中声明它，并且可以在次要构造函数体中初始化它。让我们定义`fresh`属性：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice that we defined our `fresh` property as nullable, because when an instance
    of the object will be created using a primary constructor the `fresh` property
    will be null:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将`fresh`属性定义为可空，因为当使用主构造函数创建对象实例时，`fresh`属性将为null：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can also assign the default value to the `fresh` property to make it non-nullable:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`fresh`属性分配默认值，使其成为非空：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When a primary constructor is defined, every secondary constructor must call
    the primary constructor implicitly or explicitly. An implicit call means that
    we call the primary constructor directly. An explicit call means that we call
    another secondary constructor that calls primary constructor. To call another
    constructor, we use the `this` keyword:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义主构造函数时，每个次要构造函数都必须隐式或显式调用主构造函数。隐式调用意味着我们直接调用主构造函数。显式调用意味着我们调用另一个调用主构造函数的次要构造函数。要调用另一个构造函数，我们使用`this`关键字：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Call to primary constructor
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用主构造函数
- en: Call to secondary constructor
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用次要构造函数
- en: 'If the class has no primary constructor and the super class has a non-empty
    constructor, then each secondary constructor has to initialize the base class
    using the `super` keyword or call another constructor that does that:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类没有主构造函数，并且超类具有非空构造函数，则每个次要构造函数都必须使用`super`关键字初始化基类或调用另一个执行此操作的构造函数：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A view example can be greatly simplified by using the `@JvmOverloads` annotation
    that will be described in the `@JvmOverloads` section.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`@JvmOverloads`注释，可以大大简化视图示例，该注释将在`@JvmOverloads`部分中描述。
- en: 'By default, this generated constructor will be public. If we want to prevent
    the generation of such an implicit `public` constructor, we have to declare an
    empty primary constructor with a `private` or `protected` visibility modifier:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，此生成的构造函数将是公共的。如果我们想要阻止生成这样的隐式`public`构造函数，我们必须声明一个带有`private`或`protected`可见性修饰符的空主构造函数：
- en: '[PRE44]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To change the constructor visibility, we need to explicitly use the `constructor`
    keyword in the class definition header. The `constructor` keyword is also required
    when we want to annotate a constructor. A common example is to annotate a class
    constructor using the Dagger (Dependency Injection framework) `@Inject` annotation:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改构造函数的可见性，我们需要在类定义头部显式使用`constructor`关键字。当我们想要注释构造函数时，也需要`constructor`关键字。一个常见的例子是使用Dagger（依赖注入框架）`@Inject`注释注释类构造函数：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Both the visibility modifier and annotation can be applied at the same time:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以同时应用可见性修饰符和注释：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Property versus constructor parameter
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性与构造函数参数
- en: 'The important thing to notice is the fact that if we remove the `var` /`val`
    keyword from constructor property declaration, we''ll end up with a constructor
    parameter declaration. This means that the property will be changed into constructor
    parameter, so no accessors will be generated and we will not be able to access
    the property on the class instance:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事情是，如果从构造函数属性声明中删除`var`/`val`关键字，我们将得到一个构造函数参数声明。这意味着属性将被更改为构造函数参数，因此不会生成访问器，我们将无法在类实例上访问属性：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding example, we have an error because `fresh` is missing a `val`
    or `var` keyword, so it is a constructor parameter, not a class property such
    as `weight` . The following table summarizes the compiler accessor generation:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们有一个错误，因为`fresh`缺少`val`或`var`关键字，所以它是一个构造函数参数，而不是类属性，如`weight`。以下表总结了编译器访问器生成：
- en: '| **Class declaration** | **Getter generated** | **Setter generated** | **Type**
    |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **类声明** | **生成的Getter** | **生成的Setter** | **类型** |'
- en: '| `class Fruit (name:String)` | No | No | Constructor parameter |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `class Fruit (name:String)` | 否 | 否 | 构造函数参数 |'
- en: '| `class Fruit (val name:String)` | Yes | No | Property |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `class Fruit (val name:String)` | 是 | 否 | 属性 |'
- en: '| `class Fruit (var name:String)` | Yes | Yes | Property |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `class Fruit (var name:String)` | 是 | 是 | 属性 |'
- en: 'Sometimes we may wonder when we should use a property and when we should use
    a method. A good guideline to follow is to use property instead of method when:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们可能会想知道何时应该使用属性，何时应该使用方法。遵循的一个好的指导原则是在以下情况下使用属性而不是方法：
- en: It does not throw an exception
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不会抛出异常
- en: It is cheap to calculate (or cached on the first run)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算便宜（或在第一次运行时缓存）
- en: It returns the same result over multiple invocations
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在多次调用时返回相同的结果
- en: Constructor with default arguments
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有默认参数的构造函数
- en: Since the early days of Java, there was a serious flaw with object creation.
    It is difficult to create an object instance when an object requires multiple
    parameters and some of those parameters are optional. There are a few ways to
    solve this problem, such as, the Telescoping constructor pattern, the JavaBeans
    pattern, and even the Builder pattern. Each of them have their pros and cons.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java早期以来，对象创建存在严重缺陷。当对象需要多个参数并且其中一些参数是可选时，很难创建对象实例。有几种方法可以解决这个问题，例如，Telescoping构造函数模式，JavaBeans模式，甚至Builder模式。它们各有利弊。
- en: Patterns
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式
- en: 'The patterns solve the issue of object creation. Each of them is explained
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模式解决了对象创建的问题。每个模式的解释如下：
- en: '**Telescoping constructor pattern** : Class with a list of constructors where
    each one adds a new parameter. Now a days it''s considered an anti-pattern, but
    Android framework still uses it in a few places; for example, the `android.view.View`
    class:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Telescoping构造函数模式**：具有一系列构造函数的类，其中每个构造函数都添加一个新参数。现在被认为是一种反模式，但Android框架仍在一些地方使用它；例如，`android.view.View`类：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '**JavaBeans pattern** : Parameterless constructor plus one or more setters
    methods to configure objects. The main problem with this pattern is that we can''t
    say whether or not all the required methods have been called on an object, so
    it may be only partially constructed:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaBeans模式**：无参数构造函数加上一个或多个设置器方法来配置对象。这种模式的主要问题是我们无法确定对象上是否已调用了所有必需的方法，因此它可能只是部分构造的：'
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Builder pattern** : Uses another object, a builder, that receives initialization
    arguments step by step and then returns the resulting constructed object at once
    when the build method is called; for example, `android.app.Notification.Builder`
    , or `android.app.AlertDialog.Builder` :'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建器模式**：使用另一个对象，即构建器，逐步接收初始化参数，然后在调用构建方法时一次性返回生成的对象；例如，`android.app.Notification.Builder`或`android.app.AlertDialog.Builder`：'
- en: '[PRE50]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For a long time, `builder` was most widely used, but a combination of *default
    arguments* and *named argument syntax* is an even more concise option. Let''s
    define some default value:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，`builder`是最广泛使用的，但*默认参数*和*命名参数语法*的组合是更简洁的选项。让我们定义一些默认值：
- en: '[PRE51]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'By defining default parameter values, we can create objects in multiple ways,
    without a need to pass all arguments:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义默认参数值，我们可以以多种方式创建对象，而无需传递所有参数：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Using arguments syntax with default parameters gives us much more flexibility
    in objects creation. We can pass only required parameters in any order that we
    want without defining multiple methods and constructors, as in the following example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有默认参数的参数语法可以在对象创建时给我们更多的灵活性。我们可以按任何顺序传递所需的参数，而无需定义多个方法和构造函数，就像以下示例中所示：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Inheritance
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: 'As we already know, a supertype of all Kotlin types is `Any` . It is the equivalent
    of the Java `Object` type. Each Kotlin class explicitly or implicitly extends
    the `Any` class. If we do not specify the parent class, the `Any` will be used
    implicitly set as parent for the class:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的那样，所有Kotlin类型的超类型都是`Any`。它相当于Java的`Object`类型。每个Kotlin类都显式或隐式地扩展了`Any`类。如果我们没有指定父类，`Any`将被隐式设置为类的父类：
- en: '[PRE54]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Kotlin, like Java, promotes single inheritance, so a class can have only one
    parent class, but it can implement multiple interfaces.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin像Java一样，提倡单一继承，所以一个类只能有一个父类，但可以实现多个接口。
- en: 'In contrast to Java, every class and every method in Kotlin is final by default.
    This plays along with the *Effective Java Item 17: Design and document for inheritance
    or else prohibit it* rule. This is used to prevent unexpected behavior from a
    subclass altering. Modification of a base class can cause the incorrect behavior
    of subclasses, because the changed code of the base class no longer matches the
    assumptions in its subclasses.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '与Java相比，Kotlin中的每个类和每个方法默认都是final的。这符合*Effective Java Item 17: Design and document
    for inheritance or else prohibit it*规则。这用于防止子类修改基类的意外行为。修改基类的代码可能会导致子类的不正确行为，因为基类的更改代码不再符合其子类的假设。'
- en: This means that a class cannot be extended and a method cannot be overridden
    until it's explicitly declared as open using the `open` keyword. This is the exact
    opposite of the Java `final` keyword.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在使用`open`关键字显式声明之前，类和方法都不能被扩展或覆盖。这与Java的`final`关键字完全相反。
- en: Let's say we want to declare a base class `Plant` and subclass `Tree` *:*
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想声明一个基类`Plant`和子类`Tree`*：*
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code will not compile, because the class `Plant` is final by
    default. Let''s make it `open` :'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不会编译，因为`Plant`类默认是final的。让我们将其改为`open`：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Notice that we define inheritance in Kotlin simply by using the colon character
    (:). There is no `extends` or `implements` keywords known from Java.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在Kotlin中通过使用冒号字符（:）来简单地定义继承。没有Java中的`extends`或`implements`关键字。
- en: 'Now let''s add some methods and properties to our `Plant` class, and try to
    override it in the `Tree` class:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在`Plant`类中添加一些方法和属性，并尝试在`Tree`类中覆盖它：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This code will also not compile. We have said already that all methods are
    also closed by default, so each method we want to override must be explicitly
    marked as `open` . Let''s fix the code by marking the `grow` method as open:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也不会编译。我们已经说过，默认情况下所有方法也是关闭的，因此我们想要覆盖的每个方法都必须显式标记为`open`。让我们通过将`grow`方法标记为open来修复代码：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In a similar way, we could open and override the `height` property:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以打开并覆盖`height`属性：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: To quickly override any member, go to a class where a member is declared, add
    the `open` modifier, and then go to a class where we want to override member,
    run the `override` members (the shortcut for Windows is *Ctrl* + *O* , and for
    macOS, it is *Command* + *O* ) action, and select all the members you want to
    override. This way all the required code will be generated by Android Studio.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速覆盖任何成员，转到声明成员的类，添加`open`修饰符，然后转到要覆盖成员的类，运行`override`成员（Windows的快捷键是*Ctrl*
    + *O*，macOS的快捷键是*Command* + *O*）操作，并选择要覆盖的所有成员。这样所有必需的代码将由Android Studio生成。
- en: 'Let''s assume that all trees grow in the same way (the same computation of
    growing algorithm is applicable for all trees). We want to allow creating new
    subclasses of the `Tree` class to have more control over trees, but at the same
    time we want to preserve our growing algorithm--not allowing any subclasses of
    the `Tree` class to override this behavior. To achieve this, we need to explicitly
    mark the `grow` method in the `Tree` class as `final` :'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有树都以相同的方式生长（相同的生长算法适用于所有树）。我们想允许创建`Tree`类的新子类以更好地控制树，但同时我们希望保留我们的生长算法--不允许`Tree`类的任何子类覆盖此行为。为了实现这一点，我们需要将`Tree`类中的`grow`方法显式标记为`final`：
- en: '[PRE60]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It's not possible to override grow method here because it's `final`
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里不可能覆盖grow方法，因为它是`final`
- en: Let's sum up all this `open` and final behavior. To make a method overridable
    in a subclass, we needed to explicitly mark it as open in the superclass. To make
    sure that overridden method will not be overridden again by any subclass, we need
    to mark it as `final` .
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下所有这些`open`和`final`行为。为了使子类中的方法可以被重写，我们需要在父类中明确将其标记为`open`。为了确保重写的方法不会被任何子类再次重写，我们需要将其标记为`final`。
- en: 'In the preceding example, the grow method in the `Plant` class does not really
    provide any functionality (it has an empty body). This is a sign that maybe we
    don''t want to instantiate the `Plant` class at all, but treat it as a base class
    and only instantiate various classes such as `Tree` that extends the `Plant` class.
    We should mark the `Plant` class as `abstract` to disallow its instantiation:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Plant`类中的grow方法实际上并没有提供任何功能（它的主体为空）。这表明也许我们根本不想实例化`Plant`类，而是将其视为基类，只实例化诸如扩展`Plant`类的`Tree`等各种类。我们应该将`Plant`类标记为`abstract`以禁止其实例化：
- en: '[PRE61]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Marking the class as abstract will also make the method class open by default,
    so we don't have to explicitly mark each member as `open` . Notice that when we
    are defining the `grow` method as abstract, we have to remove its body, because
    the `abstract` method can't have a body.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将类标记为抽象也会使方法默认为开放状态，因此我们不必将每个成员显式标记为`open`。请注意，当我们将`grow`方法定义为抽象时，我们必须删除其主体，因为`abstract`方法不能有主体。
- en: The JvmOverloads annotation
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JvmOverloads注解
- en: 'Some classes in the Android platform use Telescoping constructors, which is
    considered as an anti-pattern. A good example of such a class is the `android.view.View
    class` . There may be a case when only a single constructor is used (inflating
    the custom view from Kotlin code), but it is much safer to override all three
    constructors when the subclassing subclass `android.view.View` , because the class
    will work correctly in all scenarios. Normally our custom view class would look
    like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Android平台中的一些类使用Telescoping构造函数，这被认为是一种反模式。这样的类的一个很好的例子是`android.view.View类`。可能会有一种情况，只使用一个构造函数（从Kotlin代码中膨胀自定义视图），但是在子类化子类`android.view.View`时，最好重写所有三个构造函数，因为类将在所有场景中正确工作。通常我们的自定义视图类会像这样：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This case introduces a lot of boilerplate code just for constructors that delegate
    calls to other constructors. Kotlin''s solution to this problem is to use the
    `@JvmOverload` annotation:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况引入了大量样板代码，只是为了将构造函数委托给其他构造函数。Kotlin解决这个问题的方法是使用`@JvmOverload`注解：
- en: '[PRE63]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Annotating a constructor with the `@JvmOverload` annotation informs the compiler
    to generate in JVM bytecode additional constructor overload for every parameter
    with a default value. In this case, all the required constructors will be generated:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@JvmOverload`注解注释构造函数会告诉编译器在JVM字节码中为每个具有默认值的参数生成额外的构造函数重载。在这种情况下，将生成所有必需的构造函数：
- en: '[PRE64]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Interfaces
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: 'Kotlin interfaces are similar to Java 8 interfaces and in contrast to interfaces
    from previous Java versions. An interface is defined using the `interface` keyword.
    Let''s define an `EmailProvider` interface:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin接口类似于Java 8接口，与以前的Java版本的接口相反。使用`interface`关键字定义接口。让我们定义一个`EmailProvider`接口：
- en: '[PRE65]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'To implement the preceding interface in Kotlin, use the same syntax as for
    extending classes--a single colon character (`:` ). There is no `implements` keyword
    like in Java:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kotlin中实现前面的接口，使用与扩展类相同的语法--一个冒号字符（`:`）。与Java不同，没有`implements`关键字：
- en: '[PRE66]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The question may arise of how to extend a class and implement an interface
    at the same time. Simply place the class name after the colon, and use comma character
    to add one or more interfaces. It''s not required to place the super class at
    the first position although it''s considered good practice:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会产生一个问题，如何同时扩展一个类并实现一个接口。只需在冒号后面放置类名，并使用逗号字符添加一个或多个接口。虽然不要求将超类放在第一个位置，但这被认为是一个良好的做法：
- en: '[PRE67]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As with Java, the Kotlin class can extend only one class, but it can implement
    one or more interfaces. We can also declare properties in the interfaces:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java一样，Kotlin类只能扩展一个类，但可以实现一个或多个接口。我们还可以在接口中声明属性：
- en: '[PRE68]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'All methods and properties have to be overridden in a class implementing interface:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 所有方法和属性都必须在实现接口的类中被重写：
- en: '[PRE69]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Also, properties defined in a primary constructor can be used to override parameters
    from an interface:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用主构造函数中定义的属性来重写接口中的参数：
- en: '[PRE70]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: All methods and properties defined in an interface that does not have default
    implementation are treated by default as abstract, so we don't have to explicitly
    define them as abstract. All abstract methods and properties must be implemented
    (overridden) by a concrete (non-abstract) class that implements an interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中定义的所有没有默认实现的方法和属性默认被视为抽象，因此我们不必显式地将它们定义为抽象。所有抽象方法和属性必须由实现接口的具体（非抽象）类实现（重写）。
- en: 'There is, however, another way to define methods and properties in the interface.
    Kotlin, similar to Java 8, introduces major improvement to interfaces. An interface
    cannot only define behavior, but also implements it. This means that the default
    method of property implementation can be provided by an interface. The only limitation
    is that an interface cannot reference any backing fields--store a state (because
    there is no good place to store it). This is a differing factor between interface
    and abstract class. Interfaces are stateless (they can''t have a state), while
    abstract classes are stateful (they can have a state). Let''s see an example:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在接口中定义方法和属性的另一种方式。Kotlin与Java 8类似，引入了对接口的重大改进。接口不仅可以定义行为，还可以实现它。这意味着接口可以提供默认的方法或属性实现。唯一的限制是接口不能引用任何后备字段--存储状态（因为没有好的存储位置）。这是接口和抽象类之间的不同因素。接口是无状态的（它们不能有状态），而抽象类是有状态的（它们可以有状态）。让我们看一个例子：
- en: '[PRE71]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The `EmailProvider` interface provides the default implementation for the `nickname`
    property, so we don''t have to define it in the `User` class, and we can still
    use the property as any other property defined in the class:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailProvider`接口为`nickname`属性提供了默认实现，因此我们不必在`User`类中定义它，我们仍然可以像类中定义的任何其他属性一样使用该属性：'
- en: '[PRE72]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The same applies for methods. Simply define a method with the body in the interface,
    so the `User` class will take all default implementation from the interface, and
    will have to override only the `email` member--the only member in the inference
    without default implementation:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 方法也是一样。只需在接口中定义一个带有方法体的方法，因此`User`类将从接口中获取所有默认实现，并且只需要覆盖`email`成员--这是唯一一个没有默认实现的推断成员：
- en: '[PRE73]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'There is one interesting case related to default implementations. A class can''t
    inherit from multiple classes, but it can implement multiple interfaces. We can
    have two interfaces containing methods with the same signature and default implementations:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 与默认实现相关的一个有趣的案例是，一个类不能继承自多个类，但可以实现多个接口。我们可以有两个包含具有相同签名和默认实现方法的接口：
- en: '[PRE74]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In such cases, conflict must be resolved explicitly by overriding the `foo`
    method in a class implementing the interfaces:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，冲突必须通过在实现接口的类中覆盖`foo`方法来显式解决：
- en: '[PRE75]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can still call both default interface implementations by qualifying `super`
    using angle brackets and specifying the parent interface type name:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以通过使用尖括号限定`super`并指定父接口类型名称来调用默认接口实现：
- en: '[PRE76]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Data classes
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: 'Often we create a class whose only purpose is to store data; for example, data
    retrieved from a server or local database. Those classes are building blocks of
    application data models:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们创建一个唯一目的是存储数据的类；例如，从服务器或本地数据库检索的数据。这些类是应用程序数据模型的构建块：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In Java, we need to generate a lot of redundant getters/setters together with
    `hashCode` and `equals` methods. Android Studio can generate most of the code
    for us, but maintaining this code is still an issue. In Kotlin, we can define
    a special kind of class called the data class by adding the `data` keyword to
    a class declaration header:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们需要生成大量冗余的getter/setter以及`hashCode`和`equals`方法。Android Studio可以为我们生成大部分代码，但是维护这些代码仍然是一个问题。在Kotlin中，我们可以通过在类声明头部添加`data`关键字来定义一种特殊类型的类，称为数据类：
- en: '[PRE78]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: A data class adds additional capabilities to a class in the form of methods
    generated by the Kotlin compiler. Those methods are `equals` , `hashCode` , `toString`
    , `copy` , and multiple `componentN` methods. The limitation is that data classes
    can't be marked as *abstract* , *inner,* and *sealed* . Let's discuss methods
    added by a data modifier in more detail.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类通过Kotlin编译器生成的方法为类添加了额外的功能。这些方法包括`equals`、`hashCode`、`toString`、`copy`和多个`componentN`方法。限制是数据类不能标记为*abstract*、*inner*和*sealed*。让我们更详细地讨论数据修饰符添加的方法。
- en: The equals and hashCode method
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: equals和hashCode方法
- en: 'When dealing with data classes, there is often a need to compare two instances
    for structural equality (that they contain the same data, but not necessarily
    are the same instance). We many simply want to check if one instance of the `User`
    class equals another `User` instance or if two product instances represent the
    same product. A common pattern used to check if objects are equal is to use an
    `equals` method that uses the `hashCode` method internally:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据类时，通常需要比较两个实例的结构相等性（它们包含相同的数据，但不一定是相同的实例）。我们可能只是想检查`User`类的一个实例是否等于另一个`User`实例，或者两个产品实例是否代表相同的产品。用于检查对象是否相等的常见模式是使用一个使用`hashCode`方法内部的`equals`方法：
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The general contract for overridden implementations of `hashCode` is that two
    equal objects (according to `equals` implementation) need to have the same hash
    code. The reason behind it is that `hashCode` is often compared before `equals`
    , because of its performance--it's much cheaper to compare hash code than every
    field in the object.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 对于重写`hashCode`的实现，通用约定是两个相等的对象（根据`equals`实现）需要具有相同的哈希码。背后的原因是`hashCode`经常在`equals`之前进行比较，因为它的性能更好--比较哈希码比对象中的每个字段要便宜得多。
- en: 'If `hashCode` is the same then the `equals` method checks if two objects are
    the same instance, the same type, and then verifies equality by comparing all
    significant fields. If at least one of the fields of the first object is not equal
    to a corresponding field of a second object then the objects are not considered
    as equal. Another way around--two objects are equal when they have the same `hashCode`
    and all significant (compared) fields have the same value. Let''s check an example
    of the Java product class containing two fields, `name` and `price` :'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`hashCode`相同，那么`equals`方法会检查两个对象是否是相同实例，相同类型，然后通过比较所有重要字段来验证它们是否相等。如果第一个对象的至少一个字段不等于第二个对象的相应字段，则这些对象不被视为相等。另一种情况是，当两个对象具有相同的`hashCode`并且所有重要（比较的）字段具有相同的值时，两个对象是相等的。让我们来看一个包含两个字段`name`和`price`的Java产品类的例子：
- en: '[PRE80]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This approach is widely used in Java and other OOP programming languages. In
    the early days, programmers had to write this code manually for every class that
    needed to be compared and maintained the code making sure that it was correct
    and it compares every significant value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在Java和其他面向对象编程语言中被广泛使用。在早期，程序员们不得不为每个需要进行比较的类手动编写这段代码，并确保代码正确并比较每个重要的值。
- en: 'Nowadays, modern IDEs such as Android Studio can generate this code and update
    the appropriate methods. We don''t have to write the code, but we still have to
    maintain it by making sure that all the required fields are compared by the `equals`
    method. Sometimes we don''t know if it is a standard code generated by the IDE
    or it is a tweaked version. For each Kotlin data class*,* those methods are automatically
    generated by a compiler, so this problem does not exist. Here is a definition
    of `Product` in Kotlin, which contains all methods defined in the previous Java
    classes:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，像Android Studio这样的现代IDE可以生成这段代码并更新适当的方法。我们不必编写代码，但我们仍然必须通过确保所有必需的字段通过`equals`方法进行比较来维护它。有时我们不知道这是否是IDE生成的标准代码，还是经过调整的版本。对于每个Kotlin数据类，这些方法都是由编译器自动生成的，因此这个问题不存在。以下是Kotlin中`Product`的定义，其中包含了之前Java类中定义的所有方法：
- en: '[PRE81]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The preceding class contains all methods defined in previous Java classes, but
    there is no massive boilerplate code to maintain.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类包含了之前Java类中定义的所有方法，但没有大量的样板代码需要维护。
- en: 'In [Chapter 2](text00035.html) , *Laying a Foundation* , we mentioned that,
    in Kotlin, using the structural equality operator (==) will always call the `equals`
    method under the hood, so it means that we can easily and safely compare instances
    of our `Product` data class:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](text00035.html)，*奠定基础*中，我们提到，在Kotlin中，使用结构相等运算符（==）将始终在幕后调用`equals`方法，这意味着我们可以轻松而安全地比较我们的`Product`数据类的实例：
- en: '[PRE82]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: By default, the `hashCode` and `equals` methods are generated based on every
    property declared in the primary constructor. In most scenarios this is enough,
    but if we need more control we are still allowed to override these methods by
    ourselves in the data class. In this case, the default implementation won't be
    generated by the compiler.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`hashCode`和`equals`方法是基于主构造函数中声明的每个属性生成的。在大多数情况下，这已经足够了，但如果我们需要更多的控制，我们仍然可以在数据类中自己重写这些方法。在这种情况下，编译器不会生成默认实现。
- en: The toString method
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: toString方法
- en: 'Generated methods contain names and values of all properties declared in the
    primary constructor:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的方法包含主构造函数中声明的所有属性的名称和值：
- en: '[PRE83]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We can actually log meaningful data to a console or log file, instead of class
    name and memory address like in Java (`Person@a4d2e77` ). This makes the debugging
    process much simpler, because we have a proper, human readable format.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以将有意义的数据记录到控制台或日志文件中，而不是像Java中那样记录类名和内存地址（`Person@a4d2e77`）。这使得调试过程变得简单得多，因为我们有一个适当的、人类可读的格式。
- en: The copy method
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制方法
- en: 'By default, the Kotlin compiler will also generate an appropriate `copy` method
    that will allow us to easily create a copy of an object:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kotlin编译器还会生成一个适当的`copy`方法，允许我们轻松创建对象的副本：
- en: '[PRE84]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Java does not have named argument syntax, so when calling the `copy` method
    Java code we need to pass all arguments (the order of the arguments corresponds
    to the order of properties defined in the primary constructor). In Kotlin, this
    approach decreases the need for `copy` constructors or `copy` factories:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Java没有命名参数语法，因此在调用`copy`方法的Java代码时，我们需要传递所有参数（参数的顺序对应于主构造函数中定义的属性的顺序）。在Kotlin中，这种方法减少了对`copy`构造函数或`copy`工厂的需求：
- en: 'The `copy` constructor takes a single argument and type is the class containing
    the constructor and returns the `newInstance` of this class:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`构造函数接受一个参数，类型是包含构造函数的类，并返回这个类的`newInstance`：'
- en: '[PRE85]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The `copy` factory is the static factory that takes a single argument whose
    type is the class containing the factory and returns a new instance of this class:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy`工厂是一个静态工厂，它接受一个参数，其类型是包含工厂的类，并返回这个类的新实例：'
- en: '[PRE86]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `copy` method takes arguments that correspond to all properties declared
    in the primary constructor. When combined with the default arguments syntax, we
    can provide all or only some of the properties to create a modified instance copy:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy`方法接受与主构造函数中声明的所有属性相对应的参数。与默认参数语法结合使用时，我们可以提供所有或只有一些属性来创建修改后的实例副本：'
- en: '[PRE87]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This is a very flexible way of creating copy of the object where we can easily
    say if, and how, copy should differ from original instances. On the other hand,
    the programming approach promotes concept of immutability, which can be easily
    implemented with an argumentless call of the `copy` method:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建对象副本的一种非常灵活的方式，我们可以很容易地说出副本应该如何与原始实例不同。另一方面，编程方法提倡不可变性的概念，可以通过无参数调用`copy`方法轻松实现：
- en: '[PRE88]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Instead of defining mutable properties (`var` ) and modifying the object state,
    we can define immutable properties (`val` ), make an object immutable, and operate
    on it by getting its copy with the changed values. This approach reduces the need
    of data synchronization in multithreading applications and the number of potential
    errors related with it, because immutable objects can be freely shared across
    threads.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义不可变属性（`val`）而不是定义可变属性（`var`）并修改对象状态，使对象不可变，并通过获取具有更改值的副本来对其进行操作。这种方法减少了多线程应用程序中数据同步的需求，以及与之相关的潜在错误的数量，因为不可变对象可以在线程之间自由共享。
- en: Destructive declarations
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 破坏性声明
- en: 'Sometimes it makes sense to restructure objects into multiple variables. This
    syntax is called a **destructuring declaration** :'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将对象重构为多个变量是有意义的。这种语法称为**解构声明**：
- en: '[PRE89]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'A destructuring declaration allows us to create multiple variables at once.
    The preceding code will result in creating values the `firstName` , `lastName`
    *,* and `height` variables. Under the hood, the compiler will generate code like
    this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 解构声明允许我们一次创建多个变量。前面的代码将导致创建`firstName`、`lastName`和`height`变量的值。在幕后，编译器将生成以下代码：
- en: '[PRE90]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: For every property declared in the primary constructor of the data class, the
    Kotlin compiler generates a single `componentN` method. The suffix of the component
    function corresponds to the order of properties declared in the primary constructor,
    so the `firstName` corresponds to `component1` , `lastName` corresponds to `component2`
    , and `height` corresponds to `component3` . In fact, we could invoke those methods
    directly on the `Person` class to retrieve a property value, but there is no point
    of doing so, because their names are meaningless and code would be very difficult
    to read and maintain. We should leave those methods for the compiler for destructuring
    the object and use property access syntax such as `person.firstName` .
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据类的主构造函数中声明的每个属性，Kotlin编译器将生成一个`componentN`方法。组件函数的后缀对应于主构造函数中声明的属性的顺序，因此`firstName`对应于`component1`，`lastName`对应于`component2`，`height`对应于`component3`。实际上，我们可以直接在`Person`类上调用这些方法来检索属性值，但这样做没有意义，因为它们的名称是无意义的，代码会非常难以阅读和维护。我们应该将这些方法留给编译器来解构对象，并使用属性访问语法，如`person.firstName`。
- en: 'We can also omit one or more properties using an underscore:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用下划线省略一个或多个属性：
- en: '[PRE91]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In this case, we want only to create two variables, `firstName` and `height`
    ; the `lastName` is ignored. The code generated by the compiler will look as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只想创建两个变量，`firstName`和`height`；`lastName`被忽略。编译器生成的代码如下所示：
- en: '[PRE92]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can also destructure simple types like `String` :'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以解构简单类型，如`String`：
- en: '[PRE93]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Destructive declarations can also be used together with the `for` loop:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 破坏性声明也可以与`for`循环一起使用：
- en: '[PRE94]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Operator overloading
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'Kotlin has a predefined set of operators with fixed symbolic representation
    (`+, *` , and so on) and fixed precedence. Most of the operators are translated
    directly into method calls; some are translated into more complex expressions.
    The following table contains a list of all the operators available in Kotlin:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin具有一组预定义的具有固定符号表示（`+，*`等）和固定优先级的运算符。大多数运算符直接转换为方法调用；有些转换为更复杂的表达式。以下表格包含Kotlin中所有可用运算符的列表：
- en: '| **Operator token** | **Corresponding method/expression** |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| **运算符标记** | **对应的方法/表达式** |'
- en: '| `a + b` | `a.plus(b)` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| `a + b` | `a.plus(b)` |'
- en: '| `a - b` | `a.minus(b)` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| `a - b` | `a.minus(b)` |'
- en: '| `a * b` | `a.times(b)` |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| `a * b` | `a.times(b)` |'
- en: '| `a / b` | `a.div(b)` |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| `a / b` | `a.div(b)` |'
- en: '| `a % b` | `a.rem(b)` |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| `a % b` | `a.rem(b)` |'
- en: '| `a..b` | `a.rangeTo(b)` |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| `a..b` | `a.rangeTo(b)` |'
- en: '| `a += b` | `a.plusAssign(b)` |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| `a += b` | `a.plusAssign(b)` |'
- en: '| `a -= b` | `a.minusAssign(b)` |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `a -= b` | `a.minusAssign(b)` |'
- en: '| `a *= b` | `a.timesAssign(b)` |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `a *= b` | `a.timesAssign(b)` |'
- en: '| `a /= b` | `a.divAssign(b)` |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `a /= b` | `a.divAssign(b)` |'
- en: '| `a %= b` | `a.remAssign(b)` |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `a %= b` | `a.remAssign(b)` |'
- en: '| `a++` | `a.inc()` |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `a++` | `a.inc()` |'
- en: '| `a--` | `a.dec()` |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `a--` | `a.dec()` |'
- en: '| `a in b` | `b.contains(a)` |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `a in b` | `b.contains(a)` |'
- en: '| `a !in b` | `!b.contains(a)` |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `a !in b` | `!b.contains(a)` |'
- en: '| `a[i]` | `a.get(i)` |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| `a[i]` | `a.get(i)` |'
- en: '| `a[i, j]` | `a.get(i, j)` |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| `a[i, j]` | `a.get(i, j)` |'
- en: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| `a[i_1, ..., i_n]` | `a.get(i_1, ..., i_n)` |'
- en: '| `a[i] = b` | `a.set(i, b)` |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| `a[i] = b` | `a.set(i, b)` |'
- en: '| `a[i, j] = b` | `a.set(i, j, b)` |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| `a[i, j] = b` | `a.set(i, j, b)` |'
- en: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| `a[i_1, ..., i_n] = b` | `a.set(i_1, ..., i_n, b)` |'
- en: '| `a()` | `a.invoke()` |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| `a()` | `a.invoke()` |'
- en: '| `a(i)` | `a.invoke(i)` |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| `a(i)` | `a.invoke(i)` |'
- en: '| `a(i, j)` | `a.invoke(i, j)` |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| `a(i, j)` | `a.invoke(i, j)` |'
- en: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| `a(i_1, ..., i_n)` | `a.invoke(i_1, ..., i_n)` |'
- en: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| `a == b` | `a?.equals(b) ?: (b === null)` |'
- en: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| `a != b` | `!(a?.equals(b) ?: (b === null))` |'
- en: '| `a > b` | `a.compareTo(b) > 0` |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| `a > b` | `a.compareTo(b) > 0` |'
- en: '| `a < b` | `a.compareTo(b) < 0` |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| `a < b` | `a.compareTo(b) < 0` |'
- en: '| `a >= b` | `a.compareTo(b) >= 0` |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `a >= b` | `a.compareTo(b) >= 0` |'
- en: '| `a <= b` | `a.compareTo(b) <= 0` |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `a <= b` | `a.compareTo(b) <= 0` |'
- en: The Kotlin compiler translates tokens that represent specific operations (left
    column) to corresponding methods or expressions that will be invoked (right column).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin编译器将表示特定操作的标记（左列）转换为将被调用的相应方法或表达式（右列）。
- en: 'We can provide custom implementations for each operator by using them in class
    `operator` method corresponding with an `operator` token. Let''s define a simple
    `Point` class containing `x` and `y` properties together with two operators, `plus`
    and `times` :'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过在类`operator`方法中使用它们来为每个运算符提供自定义实现。让我们定义一个简单的`Point`类，其中包含`x`和`y`属性以及两个运算符，`plus`和`times`： '
- en: '[PRE95]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'By defining `plus` and `times` operators, we can perform addition and multiplication
    operations on any `Point` instance. Each time `+` or `*` operations are called,
    Kotlin calls corresponding operator method `plus` or `times` *.* Under the hood,
    the compiler will generate method calls:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义`plus`和`times`运算符，我们可以对任何`Point`实例执行加法和乘法操作。每次调用`+`或`*`操作时，Kotlin都会调用相应的运算符方法`plus`或`times`。在幕后，编译器将生成方法调用：
- en: '[PRE96]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In our example, we are passing the other `point` instance to the `plus` operator
    method, but this type is not mandatory. Operator method does not actually override
    any method from the super class, so it has no fixed declaration with fixed parameters
    and fixed types. We don''t have to inherit from a particular Kotlin type to be
    able to overload operators. All we need to have is a method with proper signature
    marked as `operator` . The Kotlin compiler will do the rest by the running method
    that corresponds to the operator. In fact, we can define multiple operators with
    the same name and different parameter types:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将另一个`point`实例传递给`plus`运算符方法，但这种类型并不是强制的。运算符方法实际上并没有覆盖超类中的任何方法，因此它没有固定参数和固定类型的固定声明。我们不必从特定的Kotlin类型继承才能重载运算符。我们需要的只是一个具有适当签名的方法，标记为`operator`。Kotlin编译器将通过运行与运算符对应的方法来完成其余工作。实际上，我们可以定义多个具有相同名称但不同参数类型的运算符：
- en: '[PRE97]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Both operators are working fine, because the Kotlin compiler can select proper
    overload of the operator. Many basic operators have corresponding compound assign
    operator (`plus` has `plusAssign` , times has `timesAssign` , and so on), so when
    we define an operator such as the `+` operator, Kotlin supports the `+` operation
    and `+=` operation as well:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 两个运算符都工作正常，因为Kotlin编译器可以选择正确的运算符重载。许多基本运算符都有相应的复合赋值运算符（`plus`有`plusAssign`，`times`有`timesAssign`等），因此当我们定义诸如`+`运算符时，Kotlin也支持`+`操作和`+=`操作：
- en: '[PRE98]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Notice the important difference that in some scenarios it may be performance
    critical. A compound assign operator (for example, the `+=` operator) has the
    `Unit` return type, so it just modifies the state of the existing object, while
    the basic operator (for example, the `+` operator) always returns a new instance
    of an object:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意重要的区别，在某些情况下可能是性能关键。复合赋值运算符（例如，`+=`运算符）具有`Unit`返回类型，因此它只是修改现有对象的状态，而基本运算符（例如，`+`运算符）总是返回对象的新实例：
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'When we define both `plus` and `plusAssign` operators with the same parameter
    types, when we try to use the `plusAssign` (compound) operator, the compiler will
    throw an error, because it does not know which method should be invoked:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义具有相同参数类型的`plus`和`plusAssign`运算符时，当我们尝试使用`plusAssign`（复合）运算符时，编译器会抛出错误，因为它不知道应该调用哪个方法：
- en: '[PRE100]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Operator overloading works also for classes defined in Java. All we need is
    a method with the proper signature and name that corresponds to the operator''s
    method name. The Kotlin compiler will translate operator usage to this method.
    Operator modifier is not present in Java, so it''s not required in the Java class:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符重载也适用于在Java中定义的类。我们所需要的是一个具有与运算符方法名称对应的适当签名和名称的方法。Kotlin编译器将运算符的使用转换为此方法。Java中不存在运算符修饰符，因此在Java类中不需要它：
- en: '[PRE101]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Object declaration
  id: totrans-366
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象声明
- en: 'There are a few ways to declare singletons in Java. Here is the most common
    way to define the class that has a private constructor and retrieves instances
    via a static factory method:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中有几种声明单例的方法。以下是定义具有私有构造函数并通过静态工厂方法检索实例的类的最常见方法：
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The preceding code works fine for a single thread, but it''s not thread safe,
    so in some cases two instances of `Singleton` can be created. There are a few
    ways to fix it. We can use the `synchronized` block presented as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码对于单个线程来说运行良好，但它不是线程安全的，因此在某些情况下可能会创建两个`Singleton`实例。有几种方法可以解决这个问题。我们可以使用如下所示的`synchronized`块：
- en: '[PRE103]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'This solution, however, is very verbose. In Kotlin, there is a special language
    construct for creating singletons called **object declaration** , so we can achieve
    the same result in a much simpler way. Defining objects is similar to defining
    classes; the only difference is that we use the `object` keyword instead of the
    `class` keyword:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种解决方案非常冗长。在Kotlin中，有一种特殊的语言构造用于创建称为**对象声明**的单例，因此我们可以以更简单的方式实现相同的结果。定义对象类似于定义类；唯一的区别是我们使用`object`关键字而不是`class`关键字：
- en: '[PRE104]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'We can add methods and properties to an object declaration exactly the same
    way as in a class:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在类中一样向对象声明添加方法和属性：
- en: '[PRE105]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This method is accessed the same way as any Java static method:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的访问方式与任何Java静态方法相同：
- en: '[PRE106]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Object declarations are initialized lazily and they can be nested inside other
    object declarations or non-inner classes. Also, they cannot be assigned to a variable.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对象声明是延迟初始化的，它们可以嵌套在其他对象声明或非内部类中。此外，它们不能分配给变量。
- en: Object expression
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象表达式
- en: 'An object expression is equivalent to Java''s anonymous class. It is used to
    instantiate objects that might inherit from some class or implements an interface.
    A classic use-case is when we need to define objects that are implementing some
    interface. This is how in Java we could implement the `ServiceConnection` interface
    and assign it to a variable:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式等效于Java的匿名类。它用于实例化可能继承自某个类或实现接口的对象。一个经典的用例是当我们需要定义实现某个接口的对象时。这就是在Java中我们如何实现`ServiceConnection`接口并将其分配给一个变量的方式：
- en: '[PRE107]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The closest Kotlin equivalent of the preceding implementation is the following:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 前面实现的最接近Kotlin等效的是以下内容：
- en: '[PRE108]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The preceding example is using an object expression, which creates instance
    of anonymous class that implements `ServiceConnection` interface. An object expression
    can also extend classes. Here is how we can create an instance of the abstract
    class `BroadcastReceiver` *:*
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了对象表达式，它创建了一个实现`ServiceConnection`接口的匿名类的实例。对象表达式也可以扩展类。以下是我们如何创建抽象类`BroadcastReceiver`的实例的方式：
- en: '[PRE109]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: While object expressions allow us to create objects of an anonymous type that
    can implement some interface and extend some class, we can use them to easily
    solve interesting problems related to the Adapter pattern.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对象表达式允许我们创建一个匿名类型的对象，该对象可以实现某个接口并扩展某个类，但我们可以使用它们轻松解决与适配器模式相关的有趣问题。
- en: The Adapter design pattern allows otherwise incompatible classes to work together
    by converting the interface of one class into an interface expected by the clients.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器设计模式允许通过将一个类的接口转换为客户端期望的接口，使本来不兼容的类一起工作。
- en: 'Let''s say that we have a `Player` interface and function that requires `Player`
    as a parameter:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个`Player`接口和一个需要`Player`作为参数的函数：
- en: '[PRE110]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Also, we have `VideoPlaye*r*` class from a public library that has the `play`
    method defined, but it is not implementing our `Player` interface:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们从一个公共库中有一个`VideoPlayer`类，该类定义了`play`方法，但它没有实现我们的`Player`接口：
- en: '[PRE111]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The `VideoPlayer` class meets all the interface requirements, but it cannot
    be passed as `Player` because it is not implementing the interface. To use it
    as a player, we need to make an Adapter. In this example, we will implement it
    as an object of an anonymous type that implements the `Player` interface:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`VideoPlayer`类满足所有接口要求，但不能作为`Player`传递，因为它没有实现该接口。要将其用作播放器，我们需要创建一个适配器。在这个例子中，我们将其实现为一个匿名类型的对象，该对象实现了`Player`接口：'
- en: '[PRE112]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We were able to solve our problem without defining the `VideoPlayer` subclass.
    We can also define custom methods and properties in the object expression:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够解决问题而不定义`VideoPlayer`子类。我们还可以在对象表达式中定义自定义方法和属性：
- en: '[PRE113]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This is a very easy way to define custom anonymous objects that are not present
    in Java. To define similar types in Java, we need to define the custom interface.
    We can now add a behavior to our `VideoPlayer` class to fully implement the `Player`
    interface:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的方法来定义在Java中不存在的自定义匿名对象。要在Java中定义类似的类型，我们需要定义自定义接口。现在我们可以为`VideoPlayer`类添加行为，以完全实现`Player`接口：
- en: '[PRE114]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In the preceding code, we can call on anonymous object (`player` ) methods defined
    in the `VideoPlayer` class and expression object.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以调用在`VideoPlayer`类中定义的匿名对象（`player`）方法和表达对象。
- en: Companion objects
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象
- en: 'Kotlin, as opposed to Java, lacks the ability to define static members, but
    instead it allows us to define *objects* that are associated with a class. In
    other words, an object is initialized only once; therefore only one instance of
    an object exists, sharing its state across all instances of a particular class.
    When a singleton object is associated with a class of the same name, it is called
    the **companion object** of the class, and the class is called the **companion
    class** of the object:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 与Java相反，Kotlin缺乏定义静态成员的能力，但它允许我们定义与类相关联的*对象*。换句话说，对象只初始化一次；因此只存在一个对象实例，跨特定类的所有实例共享其状态。当一个单例对象与同名类相关联时，它被称为该类的**伴生对象**，而该类被称为该对象的**伴生类**：
- en: '![](img/Image00034.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00034.jpg)'
- en: The preceding diagram presents three instances of the `Car` class sharing a
    single instance of an object.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 上图展示了`Car`类的三个实例共享一个对象实例。
- en: 'Members, such as methods and properties, defined inside a companion object
    may be accessed similarly to the way we access static fields and methods in Java.
    The main purpose of a companion object is to have code that is related to class,
    but not necessary to any particular instance of this class. It is a good way to
    define members that would be defined as static in Java; for example, factory,
    which creates a class instance method converting some units, activity request
    code, shared preferences key, and so on. To define the simplest companion object,
    we need to define a single block of code:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴生对象内定义的成员，如方法和属性，可以类似于我们在Java中访问静态字段和方法的方式进行访问。伴生对象的主要目的是拥有与类相关但不一定与该类的任何特定实例相关的代码。这是定义在Java中将被定义为静态的成员的一个很好的方式；例如，工厂，它创建一个类实例方法转换一些单位，活动请求代码，共享首选项键等。要定义最简单的伴生对象，我们需要定义一个代码块：
- en: '[PRE115]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Now let''s define a `start` method that will allow us to start an activity
    in an easy way:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个`start`方法，这将允许我们以一种简单的方式启动一个活动：
- en: '[PRE116]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Only single instance of `key` exists
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只存在一个`key`的单个实例
- en: Method start can be invoked without creating object instance. Just like Java
    static method.
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法`start`可以在不创建对象实例的情况下调用。就像Java静态方法一样。
- en: Retreive value after instance is created.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例创建后检索值。
- en: 'Notice that we are able to call `start` prior to the activity instance creation.
    Let''s use the companion object to track how many instances of the `Car` class
    were created. To achieve this we need to define that `count` property with a private
    setter. It could be also defined as a top-level property, but it is better to
    place it inside a companion object, because we don''t want to allow counter modification
    outside of this class:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们能够在活动实例创建之前调用`start`。让我们使用伴生对象来跟踪`Car`类的实例数量。为了实现这一点，我们需要定义具有私有setter的`count`属性。它也可以定义为顶级属性，但最好将其放在伴生对象内部，因为我们不希望在类外部允许计数器修改：
- en: '[PRE117]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The class can access all the methods and properties defined in the companion
    object, but the companion object can''t access any of the class content. The companion
    object is assigned to a specific class, but not to a particular instance:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以访问伴生对象中定义的所有方法和属性，但伴生对象无法访问任何类内容。伴生对象分配给特定类，但不分配给特定实例：
- en: '[PRE118]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: To access an instance of the companion object directly, we can use the class
    name.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接访问伴生对象的实例，我们可以使用类名。
- en: We can also access the companion object by using more verbose syntax, `Car.Companion.count`
    , but in most cases there is no point of doing so, unless we want to access `companion`
    from Java code.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过更冗长的语法`Car.Companion.count`访问伴生对象，但在大多数情况下没有必要这样做，除非我们想从Java代码中访问`companion`。
- en: Companion object instantiation
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴生对象实例化
- en: A companion object is a singleton created by a companion class and kept in its
    static property. The instantiation of a `companion` object is lazy. This means
    that `companion` object will be instantiated when it is needed for the first time--when
    its members are accessed, or instance of a class containing the `companion` object
    is created. To mark up when the `Car` class instance and its corresponding `companion`
    object are created, we need to add two initializer blocks--one for the `Car` class,
    another for the companion object.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 伴生对象是由伴生类创建并保存在其静态属性中的单例。`companion`对象的实例化是懒惰的。这意味着`companion`对象将在首次需要时实例化--当访问其成员或创建包含`companion`对象的类的实例时。要标记`Car`类实例及其对应的`companion`对象何时创建，我们需要添加两个初始化块--一个用于`Car`类，另一个用于伴生对象。
- en: 'The initializer block inside the `companion` object works exactly the same
    way as in the class--it''s executed when an instance is created:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion`对象内的初始化块与类中的初始化块完全相同--它在实例创建时执行：'
- en: '[PRE119]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'While the class initialization block is equivalent of the Java constructor
    body, the compilation object initialization block is the equivalent of the Java
    static initialization block in Kotlin. For now, the `count` property can be updated
    by any client, because it''s accessible from outside of the `Car` class. We will
    fix this issue later in this chapter in the `Visibility` modifiers section. Now
    let''s access the `Car` companion object class member:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类初始化块相当于Java构造函数体，但编译对象初始化块相当于Kotlin中的Java静态初始化块。目前，`count`属性可以被任何客户端更新，因为它可以从`Car`类的外部访问。我们将在本章的`Visibility`修饰符部分解决这个问题。现在让我们访问`Car`的`companion`对象类成员：
- en: '[PRE120]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'By accessing the `count` property defined in the companion object, we trigger
    its creation, but notice that an instance of `Car` class is not created. Later
    when we create a `Car` class instance `companion` object is already created. Now
    let''s instantiate the `Car` class before accessing the `companion` object:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问`companion`对象中定义的`count`属性，我们触发了它的创建，但请注意，`Car`类的实例并没有被创建。稍后当我们创建`Car`类的实例时，`companion`对象已经被创建。现在让我们在访问`companion`对象之前实例化`Car`类：
- en: '[PRE121]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Companion object is created together with first instance of `Car` class, so
    when we create some other instances of the user class, the `companion` object
    for the class already exists, so it's not created.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion`对象与`Car`类的第一个实例一起创建，因此当我们创建用户类的其他实例时，该类的`companion`对象已经存在，因此不会被创建。'
- en: Keep in mind that the preceding instantiation describes two separate examples.
    Both could not be true in a single program, because only a single instance of
    class `companion` object can exist and it is created the first time when it is
    needed.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，前面的实例描述了两个不同的示例。两者不能同时在一个程序中成立，因为类的`companion`对象只能存在一个实例，并且它是在需要时第一次创建的。
- en: 'The `companion` objects can also contain functions, implement interfaces, and
    even extend classes. We can define a companion object that will include a static
    constriction method with the additional possibility to override implementation
    for testing purposes:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion`对象也可以包含函数、实现接口，甚至扩展类。我们可以定义一个`companion`对象，其中包括一个静态构造方法，还可以覆盖实现以供测试目的使用：'
- en: '[PRE122]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Provider is a generic class.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Provider是一个泛型类。
- en: Abstract function used to create instance.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建实例的抽象函数。
- en: Field used to keep created instance.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于保存已创建实例的字段。
- en: Field used to in tests, to provide alternative implementation of instance.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于测试的字段，提供实例的替代实现。
- en: Function that is returning override instance if it was set, instance if it was
    created, or it is creating instance using the create method and filling instance
    field with it.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回覆盖实例（如果已设置），创建实例（如果已创建），或者使用create方法创建实例并将实例字段填充的函数。
- en: 'With such implementation, we can define the interface with a default static
    constructor:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样的实现，我们可以定义一个带有默认静态构造函数的接口：
- en: '[PRE123]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'To get instance, we need to use:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取实例，我们需要使用：
- en: '[PRE124]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'If we need to specify some other instance for testing purposes (for example,
    in Espresso tests) then we can always specify them using object expression:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要为测试目的指定其他实例（例如，在Espresso测试中），那么我们总是可以使用对象表达式来指定它们：
- en: '[PRE125]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Companion objects are really popular in the Kotlin Android world. They are mostly
    used to define all elements that were static in Java (constant fields, static
    creators, and so on), but they also provide additional capabilities.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '`companion`对象在Kotlin Android世界中非常受欢迎。它们主要用于定义在Java中是静态的所有元素（常量字段、静态创建者等），但它们还提供了额外的功能。'
- en: Enum classes
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举类
- en: Enumerated type (`enum` ) is a data type consisting of a set of named values.
    To define an enum type, we need to add the `enum` keyword to the class declaration
    header*:*
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型（`enum`）是由一组命名值组成的数据类型。要定义枚举类型，我们需要在类声明头部添加`enum`关键字：
- en: '[PRE126]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'To parse string into `enum` , use the `valueOf` method (like in Java):'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串解析为`enum`，使用`valueOf`方法（就像在Java中一样）：
- en: '[PRE127]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Or the Kotlin helper method:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用Kotlin辅助方法：
- en: '[PRE128]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'To display all values in the `Color` enum, use values function (like in Java):'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示`Color`枚举中的所有值，使用values函数（就像在Java中一样）：
- en: '[PRE129]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Or the Kotlin `enumerateValues` helper method:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用Kotlin的`enumerateValues`辅助方法：
- en: '[PRE130]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The `enum` type can also have its constructor and there can be custom data
    associated to each `enum` constant. Let''s add properties with values of `red`
    , `green` *,* and `blue` color components:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型也可以有自己的构造函数，并且可以为每个`enum`常量关联自定义数据。让我们添加具有`red`、`green`和`blue`颜色分量值的属性：'
- en: '[PRE131]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Having these values, we can define a function that will calculate RGB value
    for each color.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些值，我们可以定义一个函数，用于计算每种颜色的RGB值。
- en: 'Notice that the last constant (`VIOLET` ) is followed by a semicolon. This
    is a rare situation where a semicolon is actually required in Kotlin code. It
    separates the constant definitions from the member definitions:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一个常量（`VIOLET`）后面跟着一个分号。这是Kotlin代码中实际需要分号的罕见情况。它将常量定义与成员定义分开：
- en: '[PRE132]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `rgb()` method accesses the `r` , `g` , and `b` variable data for a particular
    enum and calculates the value for each `enum` element separately. We can also
    add a validation for the enum constructor arguments using the `init` block and
    the Kotlin standard library `require` function:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '`rgb()`方法访问特定枚举的`r`、`g`和`b`变量数据，并分别计算每个`enum`元素的值。我们还可以使用`init`块和Kotlin标准库的`require`函数为枚举构造函数参数添加验证：'
- en: '[PRE133]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Defining an incorrect enum will result in an exception:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 定义不正确的枚举将导致异常：
- en: '[PRE134]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'There are cases where we want to associate fundamentally different behavior
    with each constant. To do this we can define an abstract method or property and
    override it in each enum block. Let''s define the enum `Temperature` and `temperature`
    property:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们希望将与每个常量基本不同的行为关联起来。为此，我们可以在每个枚举块中定义一个抽象方法或属性，并在其中重写它。让我们定义枚举`Temperature`和`temperature`属性：
- en: '[PRE135]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Now, each color contains not only RGB information, but also an additional enum
    describing its temperature. We have added a property, but in an analogical way
    we could add custom methods to each enum element.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每种颜色不仅包含RGB信息，还包含描述其温度的额外枚举。我们已经添加了一个属性，但以类似的方式，我们可以为每个枚举元素添加自定义方法。
- en: Infix calls for named methods
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名方法的中缀调用
- en: 'Infix calls are one of Kotlin''s features that allow us to create more fluid
    and readable code. It allows us to write code that is closer to natural human
    language. We have already seen usage of the infix method in [Chapter 2](text00035.html)
    *, Laying a Foundation,* which allowed us to easily create an instance of a `Pair`
    class. Here is a quick reminder:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 中缀调用是Kotlin的一个特性，它允许我们创建更流畅和可读的代码。它允许我们编写更接近自然人类语言的代码。我们已经在[第2章](text00035.html)中看到了中缀方法的用法，它允许我们轻松地创建`Pair`类的实例。这里是一个快速提醒：
- en: '[PRE136]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The `Pair` class represents a generic pair of two values. There is no meaning
    attached to values in this class, so it can be used for any purpose. `Pair` is
    a data class, so it contains all data class methods (`equals` , `hashCode` , `component1`
    , and so on). Here is a definition of the `Pair` class from the Kotlin standard
    library:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pair`类表示两个值的通用对。在这个类中，值没有附加的含义，因此它可以用于任何目的。`Pair`是一个数据类，因此它包含所有数据类方法（`equals`，`hashCode`，`component1`等）。以下是来自Kotlin标准库的`Pair`类的定义：'
- en: '[PRE137]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Meaning of this `out` modifier used behind a generic type will be described
    in [Chapter 6](text00153.html) , Generic are your friends.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在泛型类型后面使用的`out`修饰符的含义将在[第6章](text00153.html)中描述，泛型是你的朋友。
- en: Pairs have a custom `toString` method. This is implemented to make printed syntax
    more readable while first and second names are not meaningful in most usage contexts.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对有自定义`toString`方法的对。这是为了使打印语法更可读，而第一个和第二个名称在大多数使用情况下都没有意义。
- en: 'Before we dive deeper and learn how to define our own infix method, let''s
    translate just the presented code into a more familiar form. Each infix method
    can be used like any other method:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入学习如何定义我们自己的中缀方法之前，让我们将所提供的代码翻译成更熟悉的形式。每个中缀方法都可以像任何其他方法一样使用：
- en: '[PRE138]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'In its essence, the infix notation is simply the ability to call a method without
    using the dot operator and call operator (parentheses). The infix notation only
    looks different, but it''s still a regular method call underneath. In both foregoing
    examples, we simply call the *to* method on the `String` class instance. *to*
    is an extension function and it will be explained in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* , but we can imagine as if it is a method
    of the `String` class, in this case, which is just returning an instance of `Pair`
    containing itself and the passed argument. We can operate on the returned `Pair`
    like on any data class object:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，中缀表示法只是调用方法而不使用点运算符和调用运算符（括号）的能力。中缀表示法看起来不同，但在底层仍然是常规方法调用。在上述两个例子中，我们只是在`String`类实例上调用*to*方法。*to*是一个扩展函数，将在[第7章](text00171.html)中解释，*扩展函数和属性*，但我们可以想象它是`String`类的方法，在这种情况下，它只是返回一个包含自身和传递的参数的`Pair`实例。我们可以像对待任何数据类对象一样操作返回的`Pair`：
- en: '[PRE139]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'In Kotlin, this method is allowed to be infix only when it has a single parameter.
    Also, an infix notation does not happen automatically--we need to explicitly mark
    the method as infix. Let''s define our `Point` class with the infix method:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，当方法只有一个参数时，才允许使用中缀方法。此外，中缀表示法不会自动发生——我们需要显式地将方法标记为中缀。让我们用中缀方法定义我们的`Point`类：
- en: '[PRE140]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Usage example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 用法示例：
- en: '[PRE141]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Notice that we are creating a new `Point` instance, but we could also modify
    an existing one (if the type was mutable). This decision is for the developer
    to make, but infix is more often used together with immutable types.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在创建一个新的`Point`实例，但我们也可以修改现有的实例（如果类型是可变的）。这个决定是开发人员做出的，但中缀更常用于不可变类型。
- en: 'We can use `infix` methods combined with enums to achieve very fluent syntax.
    Let''s implement natural syntax that will allow us to define cards from a classic
    playing card deck. It includes 52:13 ranks of each of the four suits: clubs, diamonds,
    hearts, and spades.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`infix`方法与枚举结合使用，实现非常流畅的语法。让我们实现自然语法，以便从经典扑克牌中定义卡片。它包括52张牌：每种四种花色的13张牌：梅花、方块、红桃和黑桃。
- en: '![](img/Image00035.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image00035.jpg)'
- en: 'Source for the preceding image: [https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data](https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data)'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像的来源：[https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data](https://mathematica.stackexchange.com/questions/16108/standard-deck-of-52-playing-cards-in-curated-data)
- en: 'The goal is to define the syntax that will allow us to define a card from its
    suit and rank it this way:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是定义语法，使我们能够以这种方式定义卡片的花色和等级：
- en: '[PRE142]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'First of all, we need two enums to represent all the ranks and suits:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要两个枚举来表示所有的等级和花色：
- en: '[PRE143]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Then we need a class that will represent a card composed of a particular rank
    and particular suite:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要一个类来表示由特定等级和特定套房组成的卡片：
- en: '[PRE144]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Now we can instantiate a `Card` class like this:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像这样实例化一个`Card`类：
- en: '[PRE145]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'To simplify the syntax, we introduce a new infix method into the `Rank` enum:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化语法，我们在`Rank`枚举中引入了一个新的中缀方法：
- en: '[PRE146]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This will allow us to create a `Card` call like this:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们创建一个像这样的`Card`调用：
- en: '[PRE147]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Because the method is marked as infix, we can remove the dot call operator
    and parentheses:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 因为该方法被标记为中缀，所以我们可以删除点调用运算符和括号：
- en: '[PRE148]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Usage of static imports will allow us to shorten the syntax even more and achieve
    our final result:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 使用静态导入将允许我们缩短语法，甚至实现我们的最终结果：
- en: '[PRE149]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Besides being super simple, this code is also 100% type-safe. We can only define
    cards using predefined enums of `Rank` and `Suit` , so we are unable to define
    some fictional card by mistake.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非常简单之外，这段代码还是100%类型安全的。我们只能使用预定义的`Rank`和`Suit`枚举来定义卡片，因此我们无法错误地定义一些虚构的卡片。
- en: Visibility modifiers
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性修饰符
- en: 'Kotlin supports four types of visibility modifiers (access modifiers)--`private`
    , `protected` , `public` , and `internal` . Kotlin does not support package-`private`
    Java modifiers. The main difference is that the default visibility modifier in
    Kotlin is `public` , and it''s not required to specify it explicitly, so it can
    be omitted for a particular declaration. All of the modifiers can be applied to
    various elements divided into two main groups based on their declaration site:
    top-level elements and nested members.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin支持四种类型的可见性修饰符（访问修饰符）--`private`、`protected`、`public`和`internal`。Kotlin不支持包私有Java修饰符。主要区别在于，Kotlin中的默认可见性修饰符是`public`，不需要显式指定，因此可以省略特定声明。所有修饰符都可以应用于基于其声明位置分为两个主要组的各种元素：顶层元素和嵌套成员。
- en: A quick reminder from [Chapter 3](text00073.html) , *Playing with Functions*
    , top level elements are elements declared directly inside the Kotlin file, as
    opposed to elements nested inside a class, object, interface, or function. In
    Java, we could declare only classes and interfaces at the top level, while Kotlin
    also allows functions, objects, properties, and extensions there.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第3章](text00073.html)的快速提醒，*玩转函数*，顶层元素是直接在Kotlin文件内声明的元素，而不是嵌套在类、对象、接口或函数内的元素。在Java中，我们只能在顶层声明类和接口，而Kotlin还允许在那里声明函数、对象、属性和扩展。
- en: 'First we have top-level elements visibility modifiers:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有顶层元素的可见性修饰符：
- en: '`public` (default): Element is visible everywhere.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`（默认）：元素在任何地方可见。'
- en: '`private` : Element is visible inside the file containing the declaration.'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：元素在包含声明的文件内可见。'
- en: '`protected` : Not available at top level.'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：在顶层不可用。'
- en: '`internal` : Element is visible everywhere in the same module. It is public
    for elements in the same module.'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal`：元素在同一模块中随处可见。对于同一模块中的元素，它是公共的。'
- en: '**What is a module in Java and Kotlin?**'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java和Kotlin中的模块是什么？**'
- en: A module is just a set of Kotlin files compiled together; for example, IntelliJ
    IDEA module, Gradle project. The modular structure of applications allows for
    better distributed responsibilities and speeds up build time, because only changed
    modules are recompiled.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 模块只是一组一起编译的Kotlin文件；例如，IntelliJ IDEA模块、Gradle项目。应用程序的模块化结构允许更好地分布责任，并加快构建时间，因为只重新编译了更改的模块。
- en: 'Let''s look at an example:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE150]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '`version` property is public, so it is accessible in all files.'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`version`属性是公共的，因此可以在所有文件中访问。'
- en: '`UnitConveter` is accessible in the branch.kt file, while it is in the same
    module, but not in `main.kt` because it is located in another module.'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UnitConveter`在branch.kt文件中可访问，因为它在同一模块中，但在`main.kt`中不可访问，因为它位于另一个模块中。'
- en: The `printSomething` function is accessible only in the same file where it is
    defined.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`printSomething`函数只能在定义它的同一文件中访问。'
- en: Note that the package in Kotlin is not giving any extra visibility privileges.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kotlin中的包不会提供任何额外的可见性特权。
- en: 'The second group consists of members--elements, declared inside a top level
    element. Mainly those will be methods, properties, constructors, sometimes objects,
    companion objects, getters and setters, and occasionally nested classes and nested
    interfaces. Here are the obligatory rules:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 第二组成员包括在顶层元素内声明的元素。主要是方法、属性、构造函数，有时是对象、伴生对象、getter和setter，偶尔是嵌套类和嵌套接口。以下是必须遵守的规则：
- en: '`public` (default): Client who sees the declaring class sees its public members.'
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`（默认）：看到声明类的客户端可以看到其公共成员。'
- en: '`private` : Element is visible only inside the class or interface containing
    the member.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：元素仅在包含成员的类或接口内部可见。'
- en: '`protected` : Visible inside the class containing the declaration and subclasses.
    It is not applicable inside an object, because an object cannot be opened.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：在包含声明的类和子类内可见。它不适用于对象内部，因为对象无法被打开。'
- en: '`internal` : Any client inside this module who sees the declaring class sees
    its internal members.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal`：在此模块内看到声明类的任何客户端都可以看到其内部成员。'
- en: 'Let''s define a top level element. In this example, we will define class, but
    the same logic is applied to any top level element that has nested members:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个顶层元素。在这个例子中，我们将定义类，但相同的逻辑适用于任何具有嵌套成员的顶层元素：
- en: '[PRE151]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'When we create an instance of the `Person` class, we can access only the `name`
    property marked with a public modifier and the `learn` method marked with `internal`
    modifier:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Person`类的实例时，我们只能访问用public修饰符标记的`name`属性和用internal修饰符标记的`learn`方法：
- en: '[PRE152]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '`client` who can access the `Person` instance, can also access the `name` property.'
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以访问`Person`实例的`client`也可以访问`name`属性。
- en: '`speak` method is accessible only inside the `Person` class.'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`speak`方法只能在`Person`类内部访问。'
- en: '`age` property is accessible inside the `Person` class and its subclasses.'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`age`属性在`Person`类及其子类内部可访问。'
- en: '`client` inside the module that can access the `Person` class instance can
    also access its `public` members.'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可以访问`Person`类实例的模块内的`client`也可以访问其`public`成员。
- en: 'Inheritance accessibility is similar to external access accessibility, but
    the main difference is that the member marked with the `protected` modifier is
    also visible inside the subclasses:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 继承可访问性类似于外部访问可访问性，但主要区别在于，标记为`protected`修饰符的成员也在子类内可见：
- en: '[PRE153]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: In the `Student` subclass we can access members marked with public, protected,
    and internal, but not members marked with private modifier.
  id: totrans-529
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student`子类中，我们可以访问标记为public、protected和internal的成员，但不能访问标记为private修饰符的成员。
- en: Internal modifier and Java bytecode
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部修饰符和Java字节码
- en: 'It is pretty obvious how `public` , `private` , and `protected` modifiers are
    compiled to Java while they have direct analogs. But there is a problem with the
    internal modifier because it has no direct analog in Java so there is also no
    support on Java bytecode. This is why the internal modifier is actually compiled
    to the `public` modifier, and to communicate that it shouldn''t be used in Java,
    its name is mashed (changed so that it is not usable anymore). For example, when
    we have the `Foo` class:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`public`，`private`和`protected`修饰符在编译为Java时是如何直接对应的。但是，内部修饰符存在问题，因为它在Java中没有直接对应，因此在Java字节码上也没有支持。这就是为什么内部修饰符实际上被编译为`public`修饰符，并且为了表明它不应该在Java中使用，它的名称被改变（改变以使其不再可用）。例如，当我们有`Foo`类时：
- en: '[PRE154]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'It could be possible to use it from Java this way:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式从Java中使用它：
- en: '[PRE155]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: It is pretty controversial that internal visibility is guarded by Kotlin and
    it can be bypassed using a Java adapter, but there is no other possibility to
    implement it.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 内部可见性受到Kotlin的保护，可以通过Java适配器绕过，这是相当有争议的，但没有其他可能性来实现它。
- en: 'Besides defining visibility modifiers in a class, we are also able to override
    them while overriding a member. This gives us the ability to weaken access restrictions
    in the inheritance hierarchy:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在类中定义可见性修饰符，我们还能够在覆盖成员时覆盖它们。这使我们能够在继承层次结构中减弱访问限制：
- en: '[PRE156]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Error speak method is not accessible because it's protected.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误，speak方法不可访问，因为它是受保护的。
- en: Visibility of the speak method was changed to public so we can access it.
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: speak方法的可见性已更改为public，以便我们可以访问它。
- en: 'Defining modifiers for members and their visibility scope is quite straightforward,
    so let''s see how to define class and constructor visibility. As we know, primary
    constructor definition is in the class header, so two visibility modifiers are
    required in a single line:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 定义成员和它们的可见性范围的修饰符非常简单，所以让我们看看如何定义类和构造函数的可见性。正如我们所知，主构造函数定义在类头中，因此在一行中需要两个可见性修饰符：
- en: '[PRE157]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Assuming the preceding class is defined at the top level, it will be visible
    inside the module, but it can be only instantiated from within the file containing
    the class declaration:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 假设前面的类是在顶层定义的，它将在模块内可见，但只能在包含类声明的文件内实例化：
- en: '[PRE158]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Getter and setters by default have the same visibility modifier as the property,
    but we can modify it. Kotlin allows us to place a visibility modifier before the
    `get` /`set` keyword:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: getter和setter默认具有与属性相同的可见性修饰符，但我们可以修改它。Kotlin允许我们在`get`/`set`关键字之前放置可见性修饰符：
- en: '[PRE159]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In the preceding example, we have changed the getter visibility. Notice that
    this approach allows us to change the visibility modifier without changing its
    default implementation (generated by the compiler). Now, our instance counter
    is safe, because it's read-only external clients, but we can still modify the
    property value from inside the `Car` class.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们已更改了getter的可见性。请注意，这种方法允许我们更改可见性修饰符，而不更改其默认实现（由编译器生成）。现在，我们的实例计数器是安全的，因为它是只读的外部客户端，但我们仍然可以从`Car`类内部修改属性值。
- en: Sealed classes
  id: totrans-547
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封闭类
- en: 'A sealed class is a class with limited number of subclasses (sealed subtyping
    hierarchy). Prior to Kotlin 1.1, those subclasses had to be defined inside a sealed
    class body. Kotlin 1.1 weakened this restriction and allowed us to define sealed
    class subclasses in the same file as a sealed class declaration. All the classes
    are declared close to each other, so we can easily see all possible subclasses
    by simply looking at one file:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭类是具有有限子类的类（封闭子类型层次结构）。在Kotlin 1.1之前，这些子类必须在封闭类主体内定义。Kotlin 1.1放宽了这一限制，并允许我们在同一文件中定义封闭类的子类声明。所有类都在彼此附近声明，因此我们可以通过简单地查看一个文件来轻松看到所有可能的子类：
- en: '[PRE160]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: To mark a class as sealed, simply add a `sealed` modifier to the class declaration
    header. The preceding declaration means that the `Vehicle` class can be only extended
    by three classes `Car` , `Truck` , and `Bus` because they are declared inside
    the same file. We could add a fourth class in our `vehicle.kt` file, but it would
    not be possible to define such a class in another file.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类标记为封闭类，只需在类声明头部添加`sealed`修饰符。前面的声明意味着`Vehicle`类只能由三个类`Car`，`Truck`和`Bus`扩展，因为它们在同一个文件中声明。我们可以在`vehicle.kt`文件中添加第四个类，但不可能在另一个文件中定义这样的类。
- en: 'The `sealed` subtyping restriction applies only to direct inheritors of the
    `Vehicle` class. This means that `Vehicle` can be extended only by classes defined
    in the same file (`Car` , `Truck` , or `Bus` ), but assuming that `Car` , `Truck`
    , or `Bus` classes would be open then they can be extended by a class declared
    inside any file:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`子类型限制仅适用于`Vehicle`类的直接继承者。这意味着`Vehicle`只能由在同一文件中定义的类（`Car`，`Truck`或`Bus`）扩展，但假设`Car`，`Truck`或`Bus`类是开放的，那么它们可以由在任何文件中声明的类扩展：'
- en: '[PRE161]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'To prevent this behavior, we would need to also mark `Car` , `Truck` , or `Bus`
    classes as sealed:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止这种行为，我们还需要将`Car`，`Truck`或`Bus`类标记为sealed：
- en: '[PRE162]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The sealed classes work really well with the `when` expression. There is no
    need for an `else` clause, because a compiler can verify that each subclass of
    a sealed class has a corresponding clause inside the `when` block:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 封闭类与`when`表达式非常配合。无需`else`子句，因为编译器可以验证封闭类的每个子类在`when`块内有相应的子句：
- en: '[PRE163]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '*W* e can safely add a new subclass to the `Vehicle` class, because if somewhere
    in the application the corresponding clause of the `when` expression is missing,
    the application will not compile. This fixes problems with the Java `switch` statement,
    where programmers often forget to add proper capsules, which leads to program
    crashes at runtime or undetected bugs.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地将一个新的子类添加到`Vehicle`类中，因为如果应用程序中的`when`表达式的相应子句缺失，应用程序将无法编译。这修复了Java `switch`语句的问题，程序员经常忘记添加适当的封装，导致运行时程序崩溃或未检测到的错误。
- en: 'Sealed classes are abstract by default, so a abstract modifier is redundant.
    Sealed classes can never be `open` or `final` . We can also substitute a subclass
    with objects in case we need to make sure that only a single instance exists:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 密封类默认是抽象的，因此抽象修饰符是多余的。密封类永远不能是`open`或`final`。我们还可以用对象替换子类，以确保只存在一个实例：
- en: '[PRE164]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The preceding declaration not only protects the inheritance hierarchy, but
    also limits CEO to a single instance. There are a few interesting applications
    for sealed classes that exceed the scope of this book, but it''s good to be aware
    of them:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的声明不仅保护了继承层次结构，还限制了CEO只能有一个实例。密封类有一些有趣的应用超出了本书的范围，但了解它们是很好的：
- en: Define data types such as a linked list or binary tree ([https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)
    ).
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义诸如链表或二叉树（[https://en.wikipedia.org/wiki/Algebraic_data_type](https://en.wikipedia.org/wiki/Algebraic_data_type)）之类的数据类型。
- en: Protect inheritance hierarchy when building an application module or library
    by disallowing clients to extend our class and still keep the ability to extend
    it by ourselves
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过禁止客户端扩展我们的类来保护应用程序模块或库的继承层次结构，并仍然保持我们扩展它的能力。
- en: State machine where some states contain data that makes no sense in other states
    ([https://en.wikipedia.org/wiki/Finite-state_machine](https://en.wikipedia.org/wiki/Finite-state_machine)
    )
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态机，其中一些状态包含在其他状态中没有意义的数据（[https://en.wikipedia.org/wiki/Finite-state_machine](https://en.wikipedia.org/wiki/Finite-state_machine)）
- en: List of possible tokens types for lexical analysis
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 词法分析的可能标记类型列表
- en: Nested classes
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套类
- en: 'A nested class is a class defined inside another class. Nesting small classes
    within top-level classes places the code closer to where it is used, and allows
    a better way of grouping classes. Typical examples are `Tree` /`Leaf` listeners
    or presenter states. Kotlin similar to Java allows us to define a *nested class*
    and there are two main ways to do so. We can define class as a member inside a
    class:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套类是在另一个类内部定义的类。将小类嵌套在顶级类中可以使代码更接近其使用位置，并允许更好地对类进行分组。典型的例子是`Tree`/`Leaf`监听器或演示状态。Kotlin与Java类似，允许我们定义*嵌套类*，有两种主要方法可以这样做。我们可以将类定义为类的成员：
- en: '[PRE165]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: The preceding example allows us to create an instance of a `Nested` class without
    creating instances of an `Outer` class. In this case, a class cannot refer directly
    to instance variables or methods defined in its enclosing class (it can use them
    only through an object reference). This is equivalent of a Java static nested
    class and in general static members.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子允许我们创建一个`Nested`类的实例，而不创建`Outer`类的实例。在这种情况下，一个类不能直接引用其封闭类中定义的实例变量或方法（它只能通过对象引用来使用它们）。这相当于Java的静态嵌套类和一般静态成员。
- en: 'To be able to access members of an outer class, we must create a second kind
    of class by marking a nested class as `inner` :'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问外部类的成员，我们必须通过将嵌套类标记为`inner`来创建第二种类：
- en: '[PRE166]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Now to instantiate the `inner` class we must first instantiate the `Outer`
    class. In this case, the `Inner` class can access all the methods and properties
    defined in the outer class and share state with outer class. Only a single instance
    of Inner class can exist per instance of the `Outer` class. Let''s sum up the
    differences:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要实例化`inner`类，我们必须首先实例化`Outer`类。在这种情况下，`Inner`类可以访问外部类中定义的所有方法和属性，并与外部类共享状态。每个`Outer`类的实例只能存在一个`Inner`类的实例。让我们总结一下区别：
- en: '| **Behavior** | **Class (member)** | **Inner class (member)** |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
  zh: '| **行为**| **类（成员）**| **内部类（成员）**|'
- en: '| Behave as a Java static member | Yes | No |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 表现为Java的静态成员| 是| 否|'
- en: '| Instance of this class can exist without an instance of enclosing class |
    Yes | No |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 此类的实例可以存在而不需要封闭类的实例| 是| 否|'
- en: '| Has Reference to outer class | No | Yes |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 有对外部类的引用| 否| 是|'
- en: '| Share state with outer class (can access outer class members) | No | Yes
    |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| 与外部类共享状态（可以访问外部类成员）| 否| 是|'
- en: '| Number of instances | Unlimited | One per outer class instance |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 实例数量| 无限| 每个外部类实例一个|'
- en: When deciding whether we should define `inner` class or top-level class we should
    think about potential class usage. If the class is only useful for a single class
    instance we should declare it as *inner* . If an *inner* class at some point would
    be useful in another context than serving its *outer class,* then we should declare
    it as a top-level class.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否应该定义`inner`类或顶级类时，我们应该考虑潜在的类使用情况。如果该类只对单个类实例有用，我们应该将其声明为*inner*。如果*inner*类在某个时刻对除了为其*外部类*服务之外的其他上下文有用，那么我们应该将其声明为顶级类。
- en: Import aliases
  id: totrans-579
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入别名
- en: An alias is a way to introduce new names for types. If the type name is already
    used in the file, is inappropriate, or too long, you can introduce a different
    name and use it instead of the original type name. Alias does not introduce a
    new type and it is available only before compile time (when writing code). The
    compiler replaces a class alias with an actual class, so it does not exist at
    runtime.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 别名是引入类型的新名称的一种方式。如果类型名称已在文件中使用，不合适或太长，可以引入不同的名称并在编写代码时使用它而不是原始类型名称。别名不会引入新类型，它只在编译时（编写代码时）可用。编译器将类别名替换为实际类，因此在运行时它不存在。
- en: 'Sometimes we need to use a few classes with the same name in a single file.
    For example, InterstitialAd type is defined both in the Facebook and Google advertising
    libraries. Let''s suppose that we want to use them both in a single file. This
    situation is common in projects where we need both ad providers implemented to
    allow for a profit comparison between them. The problem is that using both data
    types in a single file would mean that we need to access one or both of them by
    a fully qualified class name (namespace + class name):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要在单个文件中使用几个同名类。例如，InterstitialAd类型在Facebook和Google广告库中都有定义。假设我们想在单个文件中同时使用它们。这种情况在需要实现两个广告提供商以允许它们之间的利润比较的项目中很常见。问题是在单个文件中使用两种数据类型意味着我们需要通过完全限定的类名（命名空间+类名）访问其中一个或两个。
- en: '[PRE167]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '**Qualified versus unqualified class name**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**限定与未限定的类名**'
- en: The unqualified class name is simply the name of the class; for example, `Box`
    . A qualified class name is a namespace combined with a class name; for example,
    `com.test.Box` .
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 未限定的类名只是类的名称；例如，`Box`。限定的类名是命名空间与类名的组合；例如，`com.test.Box`。
- en: 'In these situations, people often say that the best fix is to rename one of
    the classes, but sometimes this may not be possible (the class is defined in an
    external library) or desirable (class name is consistent with backend database
    table). In this situation, where both the classes are located in an external library,
    the solution for class naming conflict is to use an `import` alias. We can use
    it to rename Google `InterstitialAd` to `GoogleAd` , and Facebook `InterstitialAd`
    to `FbAd` :'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，人们经常说最好的解决方法是重命名其中一个类，但有时这可能不可行（类是在外部库中定义的）或不可取（类名与后端数据库表一致）。在这种情况下，当两个类都位于外部库中时，解决类命名冲突的方法是使用`import`别名。我们可以使用它将Google的`InterstitialAd`重命名为`GoogleAd`，将Facebook的`InterstitialAd`重命名为`FbAd`：
- en: '[PRE168]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'And now we can use these aliases around the file as if they were actual types:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在文件中使用这些别名，就好像它们是实际的类型一样：
- en: '[PRE169]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Using the `import` alias, we can explicitly redefine names of a class that are
    imported into a file. In this situation, we didn't have to use two aliases, but
    this serves to improve readability--it's better to have `FbAd` and `GoogleAd`
    than `InterstitialAd` and `GoogleAd` . We don't have to use fully qualified class
    names any more, because we simply said to the compiler "each time when you encounter
    `GoogleAd` alias translate it to `com.google.android.gms.ads.InterstitialAd` during
    compilation and each time when you encounter `FbAdalias` translate it to `com.facebook.ads.InterstitialAd`
    . Import alias works only inside a file where alias is defined.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import`别名，我们可以明确地重新定义导入文件中的类的名称。在这种情况下，我们不必使用两个别名，但这有助于提高可读性--拥有`FbAd`和`GoogleAd`要比`InterstitialAd`和`GoogleAd`更好。我们不再需要使用完全限定的类名，因为我们只是告诉编译器"每当你遇到`GoogleAd`别名时，在编译期间将其转换为`com.google.android.gms.ads.InterstitialAd`，每当你遇到`FbAd`别名时，将其转换为`com.facebook.ads.InterstitialAd`。导入别名仅在定义别名的文件内起作用。
- en: Summary
  id: totrans-590
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed constructs, which are buildings blocks for
    object-oriented programming. We've learned how to define interfaces and various
    classes and the difference between `inner` , `sealed` , `enum` , and data classes.
    We learned that all elements are public by default and all classes/interfaces
    are `final` *(* by default*)* , so we need to explicitly open them to allow inheritance
    and members overriding.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了面向对象编程的构造，这些构造是对象导向编程的基础。我们学会了如何定义接口和各种类，以及`inner`、`sealed`、`enum`和数据类之间的区别。我们了解到所有元素默认都是公共的，所有类/接口默认都是`final`（*默认情况下*），因此我们需要明确地打开它们以允许继承和成员重写。
- en: We discussed how to define proper data models using very concise data classes
    combined with even more powerful properties. We know how to properly operate on
    data using various methods generated by the compiler and how to overload operators.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了如何使用非常简洁的数据类结合更强大的属性来定义适当的数据模型。我们知道如何使用编译器生成的各种方法来正确操作数据，以及如何重载运算符。
- en: We learned how to create singletons by using object declarations and how to
    define objects of an anonymous type that may extend some class and/or implement
    some interface using object expressions. We also presented usage of the `lateinit`
    modifier that allows us to define non-nullable data types with initialization
    delayed in time.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了如何使用对象声明创建单例，以及如何使用对象表达式定义匿名类型的对象，这些对象可以扩展某个类和/或实现某个接口。我们还介绍了`lateinit`修饰符的用法，它允许我们延迟初始化非空数据类型。
- en: In the next chapter, we will cover the more functional side of Kotlin by looking
    into concepts related to **functional programming** (**FP** ). We will discuss
    functional types, lambdas, and higher-order functions.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过研究与**函数式编程**（**FP**）相关的概念来讨论Kotlin更加功能性的一面。我们将讨论函数类型、lambda和高阶函数。
