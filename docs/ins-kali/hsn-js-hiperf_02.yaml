- en: Immutability versus Mutability - The Balance between Safety and Speed
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性与可变性-安全与速度之间的平衡
- en: In recent years, development practices have moved to a more functional style
    of programming. This means less focus on mutable programming (changing variables
    instead of creating new ones when we want to modify something). Mutability happens
    when we change a variable from one thing to another. This could be updating a
    number, changing what the message says, or even changing the item from a string
    to a number. A mutable state leads to quite a few areas of programming pitfalls,
    such as undetermined state, deadlocking in multithreaded environments, and even
    the changing of data types when we did not mean to (also known as side effects).
    Now, we have many libraries and languages that help us curtail this behavior.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，开发实践已经转向更加功能化的编程风格。这意味着更少关注可变编程（在修改某些东西时改变变量而不是创建新变量）。当我们将变量从一种东西改变为另一种东西时，就会发生可变性。这可能是更新数字，改变消息内容，甚至将项目从字符串更改为数字。可变状态会导致编程陷阱的许多领域，例如不确定状态，在多线程环境中死锁，甚至在我们不希望的情况下更改数据类型（也称为副作用）。现在，我们有许多库和语言可以帮助我们遏制这种行为。
- en: All of this has caused a push toward the use of immutable data structures and
    functions that create new objects based on the input. While this leads to fewer
    errors in terms of mutable state, it presents a host of other issues, predominantly,
    higher memory usage and lower speeds. Most JavaScript runtimes do not have optimizations
    that allow for this style of programming. When we are concerned with memory and
    speed, we need to have as much of an advantage as possible, and this is the advantage
    mutable programming gives us.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了对使用不可变数据结构和基于输入创建新对象的函数的推动。虽然这会减少可变状态的错误，但它也带来了一系列其他问题，主要是更高的内存使用和更低的速度。大多数JavaScript运行时都没有优化，允许这种编程风格。当我们关注内存和速度时，我们需要尽可能多地获得优势，这就是可变编程给我们带来的优势。
- en: 'In this chapter, we are going to focus on the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注以下主题：
- en: Current trends with immutability on the web
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前网络上的不可变性趋势
- en: Writing safe mutable code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写安全的可变代码
- en: Functional-like programming on the web
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络上的类似功能的编程
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: A web browser, preferably Chrome
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个网络浏览器，最好是Chrome
- en: An editor; VS Code is preferred
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器；首选VS Code
- en: Knowledge of current state libraries such as Redux or Vuex
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Redux或Vuex等当前状态库
- en: The relevant code can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter02)找到。
- en: The current fascination with immutability
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当前对不可变性的迷恋
- en: A look at current web trends shows the fascination with utilizing immutability.
    Libraries such as React can be used without their immutable state counterparts,
    but they are usually used along with Redux or Facebook's Flow library. Any of
    these libraries will showcase how immutability can lead to safer code and fewer
    bugs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当前网络趋势显示了对利用不可变性的迷恋。诸如React之类的库可以在没有其不可变状态的情况下使用，但它们通常与Redux或Facebook的Flow库一起使用。这些库中的任何一个都将展示不可变性如何可以导致更安全的代码和更少的错误。
- en: For those of you who do not know, immutability means that we cannot change the
    variable once it has been set with data. This means that once we assign something
    to a variable, we can no longer change that variable. This helps prevent unwanted
    changes from happening, and can also lead to a concept called **pure functions**.
    We will not be going into what pure functions are, but just be aware that it is
    a concept that many functional programmers have been bringing to JavaScript.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不了解的人，不可变性意味着一旦设置了数据，就无法更改变量。这意味着一旦我们给变量分配了某些内容，我们就不能再更改该变量。这有助于防止不必要的更改发生，并且还可以导致一个称为**纯函数**的概念。我们不会深入讨论纯函数是什么，但要知道这是许多函数式程序员一直在引入JavaScript的概念。
- en: But, does that mean we need it and does it lead to a faster system? In the case
    of JavaScript, it can depend. A well-managed project with documentation and testing
    can easily showcase how we would possibly not need these libraries. On top of
    this, we may need to actually mutate the state of an object. We may write to an
    object in one location, but have many other parts read from that object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这是否意味着我们需要它，它是否会导致更快的系统？在JavaScript的情况下，这可能取决于情况。一个管理良好的项目，有文档和测试，可以很容易地展示出我们可能不需要这些库。除此之外，我们可能需要实际改变对象的状态。我们可能在一个位置写入对象，但有许多其他部分从该对象中读取。
- en: There are many patterns of development that can give us similar benefits to
    what immutability can without the overhead of creating a lot of temporary objects
    or even going into a fully pure functional style of programming. We can utilize
    systems such as **Resource Acquisition Is Initialization** (**RAII**). We may
    find that we want to use some immutability, and in this case, we can utilize built-in
    browser tools such as `Object.freeze()` or `Object.seal()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多开发模式可以给我们带来与不可变性相似的好处，而不需要创建大量临时对象或者甚至进入完全纯粹的功能化编程风格。我们可以利用诸如**资源获取即初始化**（**RAII**）的系统。我们可能会发现自己想要使用一些不可变性，在这种情况下，我们可以利用内置的浏览器工具，如`Object.freeze()`或`Object.seal()`。
- en: However, we are getting ahead of ourselves. Let's take a look at a couple of
    the libraries mentioned and see how they handle immutable states and how it could
    potentially lead to problems when we are coding.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在走得太快了。让我们来看看其中提到的一些库，看看它们如何处理不可变状态，以及在编码时可能会导致问题。
- en: A dive into Redux
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入Redux
- en: '**Redux** is a great state management system. When we are developing complex
    systems such as Google Docs or a reporting system that lets us look up various
    user statistics in real time, it can manage the state of our application. However,
    it can lead to some overly complicated systems that may not need the state management
    that it represents.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Redux**是一个很好的状态管理系统。当我们开发诸如Google Docs或者一个报告系统这样的复杂系统时，它可以管理我们应用程序的状态。然而，它可能会导致一些过于复杂的系统，这些系统可能并不需要它所代表的状态管理。'
- en: Redux takes the philosophy that no one object should be able to mutate the state
    of an application. All of that state needs to be hosted in a single location and
    there should be functions that handle state changes. This would mean a single
    location for writes, and multiple locations able to read the data. This is similar
    to some concepts that we will want to utilize later.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Redux的理念是没有一个对象应该能够改变应用程序的状态。所有的状态都需要托管在一个单一的位置，并且应该有处理状态变化的函数。这意味着写入的单一位置，以及多个位置能够读取数据。这与我们以后想要利用的一些概念类似。
- en: However, it does take things a step further and many articles will want us to
    pass back brand-new objects. There is a reason for this. Many objects, especially
    those that have multiple layers, are not easy to copy off. Simple copy operations,
    such as using `Object.assign({}, obj)` or utilizing the spread operator for arrays,
    will just copy the references that they hold inside. Let's take a look at an example
    of this before we write a Redux-based application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它会进一步进行许多文章都希望我们传回全新的对象。这是有原因的。许多对象，特别是那些具有多层的对象，不容易复制。简单的复制操作，比如使用`Object.assign({},
    obj)`或者利用数组的扩展运算符，只会复制它们内部持有的引用。在我们编写基于Redux的应用程序之前，让我们看一个例子。
- en: 'If we open up `not_deep_copy.html` from our repository, we will see that the
    console prints the same thing. If we take a look at the code, we will see a very
    common case of copying objects and arrays:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从我们的存储库中打开`not_deep_copy.html`，我们将看到控制台打印相同的内容。如果我们看一下代码，我们将看到一个非常常见的复制对象和数组的情况：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we make this only a single layer deep, we will see that it actually executes
    a copy. The following code will showcase this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只将其复制一层深，我们将看到它实际上执行了一次复制。以下代码将展示这一点：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will go into more detail regarding this case and how to truly execute a
    deep copy, but we can begin to see how Redux may hide problems that are still
    in our system. Let''s build out a simple Todo application to at least showcase
    Redux and what it is capable of. So, let''s begin:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地讨论这个案例，以及如何真正执行深层复制，但我们可以开始看到Redux可能隐藏了仍然存在于我们系统中的问题。让我们构建一个简单的Todo应用程序，至少展示Redux及其能力。所以，让我们开始：
- en: First, we will need to pull down Redux. We can do this by utilizing **Node Package
    Manager** (**npm**) and installing it in our system. It is as simple as `npm install
    redux`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要拉取Redux。我们可以通过**Node Package Manager**（**npm**）来做到这一点，并在我们的系统中安装它。只需简单地`npm
    install redux`。
- en: We will now go into the newly created folder and grab the `redux.min.js` file
    and put it into our working directory.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将进入新创建的文件夹，获取`redux.min.js`文件并将其放入我们的工作目录中。
- en: We now will create a file called `todo_redux.html`. This will house all of our
    main logic.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个名为`todo_redux.html`的文件。这将包含我们的所有主要逻辑。
- en: At the top of it, we will add the Redux library as a dependency.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部，我们将将Redux库作为依赖项添加进来。
- en: We will then add in the actions that we are going to perform on our store.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加我们要在存储库上执行的操作。
- en: We will then set up the reducers that we want to use for our application.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置我们想要在应用程序中使用的reducers。
- en: We will then set up the store and prepare it for data changes.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将设置存储并准备好进行数据更改。
- en: We will then subscribe to those data changes and make updates to the UI.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将订阅这些数据变化并更新UI。
- en: The example that we are working on is a slightly modified version of the Todo
    application from the Redux example. The one nice thing is that we will be utilizing
    the vanilla DOM and not utilizing another library such as React, so we can see
    how Redux can fit into any application if the need arises.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在处理的示例是Redux示例中Todo应用程序的略微修改版本。其中一个好处是我们将利用原始DOM，而不是使用其他库，比如React，所以我们可以看到Redux如何适用于任何应用程序，如果需要的话。
- en: 'So, our actions are going to be adding a `todo` element, toggling a `todo`
    element to complete or not complete, and setting the `todo` elements that we want
    to see. This code appears as follows:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我们的操作将是添加一个`todo`元素，切换一个`todo`元素以完成或未完成，并设置我们想要看到的`todo`元素。这段代码如下所示：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, the reducers will be separated, with one for our visibility filter and
    another for the actual `todo` elements.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，reducers将被分开，一个用于我们的可见性过滤器，另一个用于实际的`todo`元素。
- en: 'The visibility reducer is quite simple. It checks the type of action and, if
    it is a type of `SET_VISIBILITY_FILTER`*,* we will handle it, otherwise, we just
    pass the state object on. For our `todo` reducer, if we see an action of `ADD_TODO`,
    we will return a new list of items with our item at the bottom. If we toggle one
    of the items, we return a new list with that item set to the opposite of what
    it was set to. Otherwise, we just pass the state object on. All of this looks
    like the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性reducer非常简单。它检查操作的类型，如果是`SET_VISIBILITY_FILTER`类型，我们将处理它，否则，我们只是传递状态对象。对于我们的`todo`
    reducer，如果我们看到一个`ADD_TODO`操作，我们将返回一个新的项目列表，其中我们的项目位于底部。如果我们切换其中一个项目，我们将返回一个将该项目设置为与其原来设置相反的新列表。否则，我们只是传递状态对象。所有这些看起来像下面这样：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After this, we put both reducers into a single reducer and set up the `state`
    object.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将两个reducer放入一个单一的reducer中，并设置`state`对象。
- en: 'The heart of our logic lies in UI implementation. Notice that we set this up
    to work off the data. This means that data could be passed into our function and
    the UI would update accordingly. We could make it the other way around, but making
    the UI be driven by data is a good paradigm to live by. We first have a previous
    state store. We can utilize this further by only updating what was actually updated,
    but we only use it for the first check. We grab the current state and check the
    differences between the two. If we see that the length has changed, we know that
    we should add a `todo` item. If we see that the visibility filter was changed,
    we will update the UI accordingly. Finally, if neither of these is true, we will
    go through and check which item was checked or unchecked. The code looks like
    the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逻辑的核心在于UI实现。请注意，我们设置了这个工作基于数据。这意味着数据可以传递到我们的函数中，UI会相应地更新。我们也可以反过来，但是让UI由数据驱动是一个很好的范例。我们首先有一个先前的状态存储。我们可以进一步利用它，只更新实际更新的内容，但我们只在第一次检查时使用它。我们获取当前状态并检查两者之间的差异。如果我们看到长度已经改变，我们知道应该添加一个`todo`项目。如果我们看到可见性过滤器已更改，我们将相应地更新UI。最后，如果这两者都不是真的，我们将检查哪个项目被选中或取消选中。代码如下所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run this, we should get a simple UI that we can interact with in the
    following ways:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，我们应该得到一个简单的UI，我们可以以以下方式进行交互：
- en: Add `todo` items.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`todo`项目。
- en: Mark existing `todo` items as complete.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将现有的`todo`项目标记为已完成。
- en: We are also able to have a different view of it by clicking on one of the three
    buttons at the bottom as seen in the following screenshot. If we only want to
    see all of our completed tasks, we can click the Update button.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过点击底部的三个按钮之一来查看不同的视图，如下面的截图所示。如果我们只想看到我们所有已完成的任务，我们可以点击“更新”按钮。
- en: '![](assets/a46cdc61-ccb1-453c-a5e8-ed9318b16997.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a46cdc61-ccb1-453c-a5e8-ed9318b16997.png)'
- en: 'Now, we are able to save the state for offline storage if we wanted to, or
    we could send the state back to a server for constant updates. This is what makes
    Redux quite nice. However, there are some caveats when working with Redux that
    relate to what we stated previously:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以保存状态以进行离线存储，或者我们可以将状态发送回服务器进行常规更新。这就是使Redux非常好的地方。但是，在使用Redux时也有一些注意事项，与我们之前所述的相关：
- en: 'First, we are going to need to add something to our Todo application to be
    able to handle nested objects in our state. A piece of information that has been
    left out of this Todo application is setting a date by when we want to complete
    that item. So, let''s add some fields for us to fill out to set a completion date.
    We will add in three new number inputs like so:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的Todo应用程序中添加一些内容，以便能够处理我们状态中的嵌套对象。这个Todo应用程序中遗漏的一部分信息是设置一个截止日期。因此，让我们添加一些字段供我们填写以设置完成日期。我们将添加三个新的数字输入，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we will add in another filter type of `Overdue`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加另一种`Overdue`的过滤器类型：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Make sure to add this to the `visibilityFilters` object. Now, we need to update
    our `addTodo` action. We are also going to pass on a `Date` object. This also
    means we will need to update our `ADD_TODO` case to add the `action.date` to our
    new `todo` object. We will then update our `onclick` handler for our Add button
    and adjust it with the following:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将其添加到`visibilityFilters`对象中。现在，我们需要更新我们的`addTodo`操作。我们还将传递一个`Date`对象。这也意味着我们需要更新我们的`ADD_TODO`情况，以将`action.date`添加到我们的新`todo`对象中。然后，我们将更新我们的Add按钮的`onclick`处理程序，并调整为以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could hold the date as a `Date` object (this would make more sense), but
    to showcase the issue that can arise, we are just going to hold a new object with
    `year`, `month`, and `day` fields. We will then showcase this date on the Todo
    application by adding another `span` element and populating it with the values
    from these fields. Finally, we will need to update our `setVisibility` method
    with the logic to show our overdue items. It should look like the following:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将日期保存为`Date`对象（这样更有意义），但为了展示可能出现的问题，我们将只保存一个带有`year`、`month`和`day`字段的新对象。然后，我们将通过添加另一个`span`元素并用这些字段的值填充它来在Todo应用程序上展示这个日期。最后，我们需要更新我们的`setVisibility`方法，以便显示我们过期的项目。它应该如下所示：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With all of this, we should now have a working Todo application, along with
    showcasing our overdue items. Now, this is where it can get messy working with
    state management systems such as Redux. What happens when we want to make modifications
    to an already created item and it is not a simple flat object? Well, we could
    just get that item and update it in the state system. Let''s add the code for
    this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些，我们现在应该有一个可工作的Todo应用程序，同时展示我们的过期项目。现在，这就是在处理Redux等状态管理系统时可能变得混乱的地方。当我们想要对已创建的项目进行修改，而它不是一个简单的扁平对象时会发生什么？好吧，我们可以只获取该项目并在状态系统中对其进行更新。让我们添加这段代码：
- en: 'First, we are going to create a new button and input that will change the year
    of the last entry. We will add a click handler for the Update button:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的按钮和输入，用于更改最后一个条目的年份。我们将为“更新”按钮添加一个点击处理程序：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We will then add in this new action handler for the `todo` system:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将为`todo`系统添加这个新的操作处理程序：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, if we run our code with our system, we will notice something. Our code
    is not getting past the check object condition in our subscription:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的系统，我们会注意到一些情况。我们的代码在订阅中的检查对象条件中没有通过：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We updated the state directly, and so Redux never created a new object because
    it did not detect a change (we updated an object''s value that we do not have
    a reducer on directly). Now, we could create another reducer specifically for
    the date, but we can also just recreate the array and pass it through:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接更新了状态，因此Redux从未创建新对象，因为它没有检测到更改（我们直接更新了一个对象的值，而我们没有一个reducer）。现在，我们可以创建另一个专门用于日期的reducer，但我们也可以重新创建数组并将其传递：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, our system detects that there was a change and we are able to go through
    our methods to update the code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的系统检测到有变化，我们能够通过我们的方法来更新代码。
- en: The better implementation would be to split out our `todo` reducer into two
    separate reducers. But, since we are working on an example, it was made as simple
    as possible.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现方式是将我们的`todo` reducer拆分为两个单独的reducer。但是，由于我们正在进行示例，所以尽可能简单。
- en: With all of this, we can see how we need to play by the rules that Redux has
    laid out for us. While this tool can be of great benefit for us in large-scale
    applications, for smaller state systems or even componentized systems, we may
    find it better to have a true mutable state and work on it directly. As long as
    we control access to that mutable state, then we are able to fully utilize a mutable
    state to our advantage.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过所有这些，我们可以看到我们需要遵守Redux为我们制定的规则。虽然这个工具在大规模应用中可能会带来巨大的好处，但对于较小的状态系统甚至组件化系统，我们可能会发现直接使用真正的可变状态更好。只要我们控制对可变状态的访问，我们就能充分利用可变状态的优势。
- en: This is not to take anything away from Redux. It is a wonderful library and
    it performs well even under heavier loads. But, there are times when we want to
    work directly with a dataset and mutate it directly. Redux can do this and gives
    us its event system, but we are able to build this ourselves without all of the
    other pieces that Redux gives us. Remember that we want to slim the codebase down
    as much as possible and make it as efficient as possible. Extra methods and extra
    calls can add up when we are working with tens to hundreds of thousands of data
    items.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是要贬低Redux。它是一个很棒的库，即使在更重的负载下也能表现良好。但是，有时我们想直接使用数据集并直接进行变异。Redux可以做到这一点，并为我们提供其事件系统，但是我们可以在不使用Redux提供的所有其他部分的情况下自己构建这个。记住，我们希望尽可能地精简代码库，并使其尽可能高效。当我们处理成千上万的数据项时，额外的方法和额外的调用会累积起来。
- en: 'With this introduction into Redux and state management systems complete, we
    should also take a look at a library that makes immutable systems a requirement:
    Immutable.js.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个对Redux和状态管理系统的介绍，我们还应该看一下一个使不可变系统成为必需的库：Immutable.js。
- en: Immutable.js
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Immutable.js
- en: Again, utilizing immutability, we can code in an easier-to-understand fashion.
    However, it will usually mean we can't scale to the levels that we need for truly
    high-performance applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 再次利用不可变性，我们可以以更易于理解的方式编写代码。然而，这通常意味着我们无法满足真正高性能应用所需的规模。
- en: First, Immutable.js takes a great stab at the functional-style data structures
    and methods needed to create a functional system in JavaScript. This usually leads
    to cleaner code and cleaner architecture. But, what we get in terms of these advantages
    leads to a decrease in speed and/or an increase in memory.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Immutable.js在JavaScript中提供了一种很好的函数式数据结构和方法，这通常会导致更清晰的代码和更清晰的架构。但是，我们在这些优势方面得到的东西会导致速度的降低和/或内存的增加。
- en: Remember, when we're working with JavaScript, we have a single-threaded environment.
    This means that we do not really have deadlocks, race conditions, or read/write
    access problems.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当我们使用JavaScript时，我们处于一个单线程环境。这意味着我们实际上没有死锁、竞争条件或读/写访问问题。
- en: We can actually run into these issues when utilizing something like `SharedArrayBuffers`
    between workers or different tabs, but that is a discussion for later chapters.
    For now, we are working in a single-threaded environment where the issues of multi-core
    systems do not really crop up.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用诸如`SharedArrayBuffers`之类的东西在工作线程或不同的标签之间可能会遇到这些问题，但这是以后章节的讨论。现在，我们正在一个单线程环境中工作，多核系统的问题并不会真正出现。
- en: 'Let''s take a real-world example of a use case that can come up. We want to
    turn a list of lists into a list of objects (think of a CSV). What might the code
    look like to build this data structure in plain old JavaScript, and another one
    utilizing the Immutable.js library? Our Vanilla JavaScript version may appear
    as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个现实生活中可能出现的用例的例子。我们想将一个列表的列表转换为对象列表（想象一下CSV）。在普通的JavaScript中构建这种数据结构的代码可能如下所示：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We construct a new array of the size of the input list minus one (the first
    row is the keys). We then store the row size instead of computing that each time
    for the inner loop later. Then, we create another array to hold the keys and we
    grab those from the first index of the input array. Next, we loop through the
    rest of the entries in the input and create objects. We then loop through each
    inner array and set the key to the value and location `j`, and set the value to
    the input's `i` and `j` values.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建一个新的数组，大小为输入列表的大小减一（第一行是键）。然后，我们存储行大小，而不是每次在内部循环中计算。然后，我们创建另一个数组来保存键，并从输入数组的第一个索引中获取它们。接下来，我们循环遍历输入中的其余条目并创建对象。然后，我们循环遍历每个内部数组，并将键设置为值和位置`j`，并将值设置为输入的`i`和`j`值。
- en: Reading in data through nested arrays and loops can be confusing, but results
    in fast read times. On a dual-core processor with 8 GB of RAM, this code took
    83 ms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 通过嵌套数组和循环读取数据可能会令人困惑，但可以获得快速的读取时间。在一个双核处理器和8GB RAM的计算机上，这段代码花了83毫秒。
- en: 'Now, let''s build something similar in Immutable.js. It should look like the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在Immutable.js中构建类似的东西。它应该看起来像下面这样：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is much easier to interpret if we understand functional concepts. First,
    we want to create a list based on our input. We then create another temporary
    list for the keys called `_k`*.* For our temporary final list, we utilize the
    `map` function. If we are at the `0` index, we just `return` from the function
    (since this is the keys). Otherwise, we return a new map that is created by zipping
    the keys list with the current value. Finally, we remove the front of the final
    list since it will be undefined.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们理解函数式概念，这将更容易解释。首先，我们想要根据我们的输入创建一个列表。然后我们创建另一个临时列表用于存储键称为`_k`*.*。对于我们的临时最终列表，我们利用`map`函数。如果我们在`0`索引处，我们就从函数中`return`（因为这是键）。否则，我们返回一个通过将键列表与当前值进行zip的新映射。最后，我们移除最终列表的前部，因为它将是未定义的。
- en: This code is wonderful in terms of readability, but what are the performance
    characteristics of this? On a current machine, this ran in around 1 second. This
    is a big difference in terms of speed. Let's see how they compare in terms of
    memory usage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在可读性方面很棒，但它的性能特征如何？在当前的机器上，它运行大约需要1秒。这在速度方面有很大的差异。让我们看看它们在内存使用方面的比较。
- en: Settled memory (what the memory goes back to after running the code) appears
    to be the same, settling back to around 1.2 MB. However, the peak memory for the
    immutable version is around 110 MB, whereas the Vanilla JavaScript version only
    gets to 48 MB, so a little under half the memory usage. Let's take a look at another
    example and see the results that transpire.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 已解决的内存（运行代码后内存返回的状态）似乎是相同的，回到了大约1.2 MB。然而，不可变版本的峰值内存约为110 MB，而Vanilla JavaScript版本只达到了48
    MB，所以内存使用量略低于一半。让我们看另一个例子并看看发生的结果。
- en: 'We are going to create an array of values, except we want one of the values
    to be incorrect. So, we will set the 50,000th index to be `wrong` with the following
    code:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个值数组，除了我们希望其中一个值是不正确的。因此，我们将使用以下代码将第50,000个索引设置为`wrong`：
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we will loop over a new array with a simple `for` loop like so:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将使用简单的`for`循环遍历一个新数组，如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will also test the built-in `map` function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将测试内置的`map`函数：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, here''s the immutable version:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是不可变版本：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we run these instances, we will see that the fastest will go between the
    basic `for` loop and the built-in `map` function. The immutable version is still
    eight times slower than the others. What happens when we increase the number of
    incorrect values? Let''s add a random number generator for building our temporary
    array to give a random number of errors and see how they perform. The code should
    appear as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这些实例，我们会发现最快的将在基本的`for`循环和内置的`map`函数之间切换。不可变版本仍然比其他版本慢8倍。当我们增加不正确值的数量时会发生什么？让我们添加一个随机数生成器来构建我们的临时数组，以便产生随机数量的错误，并看看它们的表现。代码应该如下所示：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the same test, we get roughly an average of a tenfold slowdown with
    the immutable version. Now, this is not to say that the immutable version will
    not run faster in certain cases since we only touched on the map and list features
    of it, but it does bring up the point that immutability comes at a cost in terms
    of memory and speed when applying it to JavaScript libraries.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 运行相同的测试，我们发现不可变版本大约会慢十倍。现在，这并不是说不可变版本在某些情况下不会运行得更快，因为我们只涉及了它的map和list功能，但这确实提出了一个观点，即在将其应用于JavaScript库时，不可变性在内存和速度方面是有代价的。
- en: We will look in the next section at why mutability can lead to some issues,
    but also at how we can handle it by utilizing similar ideas to how Redux works
    with data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中看到为什么可变性可能会导致一些问题，但也会看到我们如何通过利用类似Redux处理数据的想法来处理它。
- en: There is always a time and a place for different libraries, and this is not
    to say that Immutable.js or libraries like it are bad. If we find that our datasets
    are small or other considerations come into play, Immutable.js might work for
    us. But, when we are working on high-performance applications, this usually means
    two things. One, we will get a large amount of data in a single hit or second,
    and second, we will get a bunch of events that lead to a lot of data build-up.
    We need to use the most efficient means possible and these are usually built into
    the runtime that we are utilizing.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的库总是有其适用的时间和场合，并不是说Immutable.js或类似的库是不好的。如果我们发现我们的数据集很小或其他考虑因素起作用，Immutable.js可能适合我们。但是，当我们在高性能应用程序上工作时，这通常意味着两件事。一是我们将一次性获得大量数据，二是我们将获得大量导致数据积累的事件。我们需要尽可能使用最有效的方法，而这些通常内置在我们正在使用的运行时中。
- en: Writing safe mutable code
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写安全的可变代码
- en: 'Before we move on to writing safe mutable code, we need to discuss references
    and values. A value can be considered anything that is a primitive type. Primitive
    types, in JavaScript, are anything that are not considered objects. To put it
    simply, numbers, strings, Booleans, null, and undefined are values. This means
    that if you create a new variable and assign it to the original, it will actually
    give it a new value. What does this mean for our code then? Well, we saw earlier
    with Redux that it was not able to see that we updated a property in our state
    system, so our previous state and current state showed they were the same. This
    is due to a shallow equality test. This basic test tests whether the two variables
    that were passed in are pointing to the same object. A simple example of this
    is seen with the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续编写安全的可变代码之前，我们需要讨论引用和值。值可以被认为是任何原始类型。在JavaScript中，原始类型是指不被视为对象的任何内容。简单来说，数字、字符串、布尔值、null和undefined都是值。这意味着如果你创建一个新变量并将其分配给原始变量，它实际上会给它一个新值。那么这对我们的代码意味着什么呢？嗯，我们之前在Redux中看到，它无法看到我们更新了状态系统中的属性，因此我们的先前状态和当前状态显示它们是相同的。这是由于浅相等测试。这个基本测试测试传入的两个变量是否指向同一个对象。一个简单的例子是在以下代码中看到的：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will see that the first version says that the two items are equal. But, when
    we create a copy of the object, it states that they are not equal. `y` now has
    a brand-new object and this means that it points to a new location in memory.
    While a deeper understanding of *pass by value* and *pass by reference* can be
    good, this should be sufficient to move on to mutable code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会发现第一个版本说这两个项目是相等的。但是，当我们创建对象的副本时，它会声明它们不相等。`y`现在有一个全新的对象，这意味着它指向内存中的一个新位置。虽然对*按值传递*和*按引用传递*的更深入理解可能有好处，但这应该足以继续使用可变代码。
- en: When writing safe mutable code, we want to give the illusion that we are writing
    immutable code. In other words, the interface should look like we are utilizing
    immutable systems, but we are instead utilizing mutable systems internally. Hence,
    there is a separation of the interface from the implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写安全的可变代码时，我们希望给人一种错觉，即我们正在编写不可变的代码。换句话说，接口应该看起来像我们在使用不可变的系统，但实际上我们在内部使用的是可变的系统。因此，接口与实现之间存在分离。
- en: 'We can make the implementation very fast by writing in a mutable way but give
    an interface that looks immutable. An example of this is as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以可变的方式编写代码来使实现变得非常快速，但提供一个看起来不可变的接口。一个例子如下：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have written a `_map` function on the array prototype so that every array
    gets it and we write a simple `map` function. If we now test run this code, we
    will see that some browsers perform better with this, while others perform better
    with the built-in option. As stated before, the built-ins will eventually get
    faster, but, more often than not, a simple loop is going to be faster. Let''s
    now look at another example of a mutable implementation, but with an immutable
    interface:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在数组原型上编写了一个`_map`函数，以便每个数组都可以使用它，并且我们编写了一个简单的`map`函数。如果我们现在测试运行这段代码，我们会发现一些浏览器使用这种方式更快，而其他浏览器使用内置选项更快。如前所述，内置选项最终会变得更快，但往往一个简单的循环会更快。现在让我们看另一个可变实现的例子，但具有不可变的接口：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We wrote a `reduce` function that performs better in every browser. Now, it
    does not have the same amount of type checking, which could lead to better performance,
    but it does showcase how we can write functions that can perform better but give
    the same type of interface that a user of our system expects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个`reduce`函数，在每个浏览器中都有更好的性能。现在，它没有相同数量的类型检查，这可能会导致更好的性能，但它展示了我们如何编写可以提供更好性能但给用户提供相同类型接口的函数。
- en: What we have talked about so far is if we were writing a library for someone
    to use to make their lives easier. What happens if we are writing something that
    we or an internal team is going to utilize, as is the case for most application
    developers?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的是，如果我们为别人编写一个库来使他们的生活更轻松。如果我们正在编写一些我们自己或内部团队将要使用的东西，这是大多数应用程序开发人员的情况，会发生什么呢？
- en: We have two options in this case. First, we may find that we are working on
    a legacy system and that we are going to have to try to program in a similar style
    to what has already been done, or we are developing something rather new and we
    are able to start off from scratch.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个选择。首先，我们可能会发现我们正在处理一个传统系统，并且我们将不得不尝试以与已有代码类似的风格进行编程，或者我们正在开发一些全新的东西，我们可以从头开始。
- en: Writing legacy code is a hard job and most people will usually get it wrong.
    While we should be aiming to improve on the code base, we are also trying to match
    the style. It is especially difficult for developers to walk through the code
    and see 10 different code choices used because 10 different developers have worked
    on the project over its lifespan. If we are working on something that someone
    else has written, it is usually better to match the code style than to come up
    with something completely different.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编写传统代码是一项艰巨的工作，大多数人通常会做错。虽然我们应该致力于改进代码库，但我们也在努力匹配风格。对于开发人员来说，尤其困难的是，他们需要浏览代码并看到使用了10种不同代码选择，因为在项目的整个生命周期中有10个不同的开发人员参与其中。如果我们正在处理其他人编写的东西，通常最好匹配代码风格，而不是提出完全不同的东西。
- en: With a new system, we are able to write how we want and, with proper documentation,
    we can write something that is quite fast but is also easy for someone else to
    pick up. In this case, we can write mutable code that may have side effects in
    the functions, but we are able to document these cases.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 有了一个新系统，我们可以按照自己的意愿编写代码，并且在适当的文档支持下，我们可以编写出非常快速的代码，同时也容易让其他人理解。在这种情况下，我们可以编写可变的代码，函数中可能会产生副作用，但我们可以记录这些情况。
- en: 'Side effects are conditions that occur when a function does not just return
    a new variable or even a reference that the variable passed in. It is when we
    update another variable that we do not have current scope over that this constitutes
    a side effect. An example of this is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 副作用是指当一个函数不仅返回一个新变量或者变量的引用时发生的情况。当我们更新另一个变量，而我们对其没有当前范围时，这构成了一个副作用。一个例子如下：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We have a global variable called `glob` that we are changing inside our function.
    Technically, this function has scope over `glob`, but we should try to define
    the scope of implement to be only what was passed into it and the temporary variables
    that implement have defined inside. Since we are mutating `glob`, we have introduced
    a side effect into our code base.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`glob`的全局变量，我们在函数内部对其进行更改。从技术上讲，这个函数对`glob`有范围，但我们应该尝试将实现的范围定义为仅限于传入的内容以及实现内部定义的临时变量。由于我们正在改变`glob`，我们在代码库中引入了一个副作用。
- en: Now, in some situations, side effects are needed. We may need to update a single
    point, or we may need to store something in a single location, but we should try
    to implement an interface that does this for us instead of us directly affecting
    the global item (this should start to sound a lot like Redux). By writing a function
    or two to affect the out-of-scope items, we can now diagnose where an issue may
    come in because we have those single points of entry.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在某些情况下，副作用是必需的。我们可能需要更新一个单一点，或者我们可能需要将某些东西存储在一个单一位置，但我们应该尝试实现一个接口来为我们完成这些操作，而不是直接影响全局项目（这听起来很像Redux）。通过编写一个或两个函数来影响超出范围的项目，我们现在可以诊断问题可能出现的地方，因为我们有这些单一的入口点。
- en: 'So what might this look like? We could create a state object just as a plain
    old object. Then, we could write a function on the global scope called `updateState`
    that would look like the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这会是什么样子呢？我们可以创建一个状态对象，就像一个普通的对象一样。然后，我们可以在全局范围内编写一个名为`updateState`的函数，如下所示：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, while this may be good, we are still vulnerable to someone updating our
    state object through the actual global property. Luckily, by making our state
    object and our function `const`, we can make sure that erroneous code cannot touch
    these actual names. Let''s update our code so our state is protected from being
    updated directly. There are two ways that we could do this. The first approach
    would be to code with modules and then our state objects which will be scoped
    to that module. We will look at modules and the import syntax further in the book.
    Instead, on this occasion, we are going to use the second method, code the **Immediately
    Invoked Function Expression** (**IIFE**) way. The following showcases this implementation:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然这可能是好的，但我们仍然容易受到通过实际全局属性更新我们的状态对象的影响。幸运的是，通过将我们的状态对象和函数设为`const`，我们可以确保错误的代码无法触及这些实际的名称。让我们更新我们的代码，以确保我们的状态受到直接更新的保护。我们可以通过两种方式来实现这一点。第一种方法是使用模块编码，然后我们的状态对象将被限定在该模块中。我们将在本书中进一步讨论模块和导入语法。在这种情况下，我们将使用第二种方法，即**立即调用函数表达式**（**IIFE**）的方式进行编码。以下展示了这种实现方式：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we create a constant state. We then IIFE and pass in the state object,
    setting a bunch of functions on it. It works on an internally `scoped _state`
    variable. We then have all the basic functions that we would expect for an internal
    state system. We also freeze the external state object so it can no longer be
    messed with. One question that may arise is why we are passing back a new object
    instead of a reference. If we are trying to make sure that we don't want anyone
    able to touch the internal state, then we cannot pass a reference out; we have
    to pass a new object.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个常量状态。然后我们使用IIFE并传入状态对象，在其上设置一堆函数。它在一个内部`scoped _state`变量上工作。我们还拥有所有我们期望的内部状态系统的基本函数。我们还冻结了外部状态对象，因此它不再能被操纵。可能会出现的一个问题是，为什么我们要返回一个新对象而不是一个引用。如果我们试图确保没有人能够触及内部状态，那么我们不能传递一个引用出去；我们必须传递一个新对象。
- en: We still have a problem. What happens if we want to update more than one layer
    deep? We will start running into reference issues again. That means that we will
    need to update our update function to perform a deep update. We can do this in
    a variety of ways, but one way would be to pass the value in as a string and we
    will split on the decimal point.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个问题。如果我们想要更新多层深度，会发生什么？我们将再次遇到引用问题。这意味着我们需要更新我们的更新函数以执行深度更新。我们可以用多种方式来做到这一点，但一种方法是将值作为字符串传递，然后在小数点上分割。
- en: This is not the best way to handle this since we could technically have a property
    of an object be named with decimal points, but it will allow us to write something
    quickly. Balancing between writing something that is functional, and what is considered
    a complete solution, are two different things and they have to be balanced when
    writing high-performance code bases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是处理这个问题的最佳方式，因为我们在技术上可以让对象的属性以小数点命名，但这将允许我们快速编写一些东西。在编写高性能代码库时，平衡编写功能性代码和被认为是完整解决方案的东西之间的平衡是两回事，必须在写作时加以平衡。
- en: 'So, we will have a method that will now look like the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在将有一个如下所示的方法：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What we are doing is breaking the key upon the decimal character. We are also
    grabbing a reference to the internal state object. While we still have items in
    the list, we move one level down in the object. If we find that it is undefined,
    then we will throw an error. Otherwise, once we are one level above where we want
    to be, we return an object with that reference and the final key. We will then
    use this in the getter and setter to replace those values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在通过小数点来分解键。我们还获取了对内部状态对象的引用。当列表中仍有项目时，我们会在对象中向下移动一级。如果我们发现它是未定义的，那么我们将抛出一个错误。否则，一旦我们在我们想要的位置的上一级，我们将返回一个具有该引用和最终键的对象。然后我们将在getter和setter中使用这个对象来替换这些值。
- en: 'Now, we still have a problem. What if we want to make a reference type be the
    property value for our internal state system? Well, we will run into the same
    issues that we saw before. We will have references outside the single state object.
    This means we will have to clone each step of the way to make sure that the external
    reference does not point to anything in the internal copy. We can create this
    system by adding a bunch of checks and making sure that when we get to a reference
    type, we clone it in a way that is efficient. This looks like the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们仍然有一个问题。如果我们想要使引用类型成为内部状态系统的属性值，会怎么样呢？嗯，我们将遇到之前看到的相同问题。我们将在单个状态对象之外有引用。这意味着我们将不得不克隆每一步，以确保外部引用不指向内部副本中的任何内容。我们可以通过添加一堆检查并确保当我们到达引用类型时，以一种高效的方式进行克隆来创建这个系统。代码如下所示：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: What we have done is write a simple clone system. Our `update` function will
    go through the keys and run the update. We will then check for various conditions,
    such as if we are a primitive type. If we are, we just copy the value, otherwise,
    we need to figure out the complex type we are. We first search to see whether
    we are a function; if we are, we just bind the value. If we are an array, we will
    run through all of the values and make sure that none of them are complex types.
    Finally, if we are an object, we will run through all of the keys and try to update
    these running the same checks.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是编写一个简单的克隆系统。我们的`update`函数将遍历键并运行更新。然后我们将检查各种条件，比如我们是否是原始类型。如果是，我们只需复制值，否则，我们需要弄清楚我们是什么复杂类型。我们首先搜索是否是一个函数；如果是，我们只需绑定值。如果是一个数组，我们将遍历所有的值，并确保它们都不是复杂类型。最后，如果是一个对象，我们将遍历所有的键，并尝试运行相同的检查来更新这些键。
- en: However, we have just done what we have been avoiding; we have created an immutable
    state system. We can add more bells and whistles to this centralized state system,
    such as eventing, or we can implement a coding standard that has been around for
    quite some time, called **Resource Allocation Is Initialization** (**RAII**).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们刚刚做了我们一直在避免的事情；我们已经创建了一个不可变的状态系统。我们可以为这个集中的状态系统添加更多的功能，比如事件，或者我们可以实现一个已经存在很长时间的编码标准，称为**Resource
    Allocation Is Initialization**（**RAII**）。
- en: There is a really nice built-in web API called **proxies**. These are essentially
    systems where we are able to do something when something happens on an object.
    At the time of writing, these are still quite slow and should not really be used
    unless it is on an object that we are not worried about for time-sensitive activities.
    We are not going to talk about them extensively, but they are available for those
    readers who want to check them out.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为**proxies**的内置Web API非常好。这些基本上是系统，我们能够在对象发生某些事情时执行某些操作。在撰写本文时，这些仍然相当慢，除非是在我们不担心时间敏感的对象上，否则不应该真正使用它们。我们不打算对它们进行详细讨论，但对于那些想要了解它们的读者来说，它们是可用的。
- en: Resource allocation is initialization (RAII)
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源分配即初始化（RAII）
- en: The idea of RAII comes from C++, where we have no such thing as a memory manager.
    We encapsulate logic where we potentially want to share resources that need to
    be freed after their use. This makes sure that we do not have memory leaks, and
    that objects that are utilizing the item are doing so in a safe manner. Another
    name for this is **scope-bound resource management** (**SBRM**), and is also utilized
    in another recent language called Rust.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: RAII的概念来自C++，在那里我们没有内存管理器。我们封装逻辑，可能希望共享需要在使用后释放的资源。这确保我们没有内存泄漏，并且正在使用该项的对象是以安全的方式进行的。这个概念的另一个名称是**scope-bound
    resource management**（**SBRM**），也在另一种最近的语言Rust中使用。
- en: We can apply the same types of ideas that C++ and Rust do in terms of RAII in
    our JavaScript code. There are a couple of ways that we can handle this and we
    are going to look at them. The first is the idea that when we pass an object into
    a function, we can then `null` out that object from our calling function.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JavaScript代码中应用与C++和Rust相同类型的RAII思想。我们可以处理这个问题的几种方法，我们将对它们进行讨论。第一种方法是，当我们将一个对象传递给一个函数时，我们可以从调用函数中将该对象`null`掉。
- en: Now, we will have to use `let` instead of `const` in most cases for this to
    work, but it is a useful paradigm to make sure that we are only holding on to
    objects that we need.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将不得不在大多数情况下使用`let`而不是`const`，但这是一种有用的范式，可以确保我们只保留我们需要的对象。
- en: 'This concept can be seen in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个概念可以在以下代码中看到：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we run the following code, we will notice that we are trying to append to
    a `null`. This is where this design can get us into a bit of trouble. We have
    an asynchronous method and we are trying to use a value that we have nullified
    even though we still need it. What is the best way to handle this situation? One
    way is to `null` it out once we are done using it. Hence, we can change the code
    to look like the following:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行以下代码，我们会注意到我们正在尝试追加到一个`null`。这就是这种设计可能会让我们陷入麻烦的地方。我们有一个异步方法，我们正在尝试使用一个我们已经使无效的值，尽管我们仍然需要它。处理这种情况的最佳方法是什么？一种方法是在使用完毕后将其`null`掉。因此，我们可以将代码更改为以下内容：
- en: '[PRE29]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We still have a problem. Before the next part of the `Promise` (the `then`
    method) runs, we could still modify the value. One final good idea would be to
    wrap this input to output in a new function. This will give us the safety that
    we are looking for, while also making sure we are following the principle behind
    RAII. The following code is what comes out of this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然有一个问题。在`Promise`的下一部分（`then`方法）运行之前，我们仍然可以修改值。一个最后的好主意是将此输入输出包装在一个新函数中。这将给我们所寻找的安全性，同时也确保我们遵循RAII背后的原则。以下代码是由此产生的：
- en: '[PRE30]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We can also get rid of some of the preceding nulls since the functions will
    take care of those temporary variables. While this example is rather trivial,
    it does showcase one way of handling RAII inside JavaScript.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以摆脱一些之前的null，因为函数将处理这些临时变量。虽然这个例子相当琐碎，但它展示了在JavaScript中处理RAII的一种方式。
- en: On top of this paradigm, we can also add properties to the item that we are
    passing to say that it is a read-only version. This would ensure that we are not
    modifying the item, but we also do not need to `null` out the element on the calling
    function if we still want to read from it. This gives us the benefit of making
    sure our objects can be utilized and maintained without the worry that they will
    be modified.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除此范式之外，我们还可以向传递的项目添加属性，以表明它是只读版本。这将确保我们不会修改该项目，但如果我们仍然想从中读取，我们也不需要在调用函数上将元素`null`掉。这使我们能够确保我们的对象可以被利用和维护，而不必担心它们会被修改。
- en: 'We will take out the previous code example and update it to utilize this read-only
    property. We first define a function that will add it to any object that comes
    in like so:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将删除以前的代码示例，并更新它以利用这个只读属性。我们首先定义一个函数，将其添加到任何传入的对象中，如下所示：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, in our `onclick` method, we pass our output into this method. This has
    now attached the `readonly` property to it. Finally, in our `showHashData` function,
    when we try to access it, we have put a guard on the `readonly` property. If we
    notice that the object has it, we will not try to append to it, like so:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在我们的`onclick`方法中，我们将输出传递给此方法。现在，它已经附加了`readonly`属性。最后，在我们的`showHashData`函数中，当我们尝试访问它时，我们已经在`readonly`属性上设置了保护。如果我们注意到对象具有它，我们将不会尝试追加到它，就像这样：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We have also set this property to not be writable, so if a nefarious actor decided
    to manipulate our object's `readonly` property, they will still notice that we
    are no longer appending to the DOM. The `defineProperty` method is very powerful
    for writing APIs and libraries that cannot be easily manipulated. Another way
    of handling this is to freeze the object. With the `freeze` method, we are able
    to make sure that the shallow copy of an object is read-only. Remember that this
    is only for the shallow instance, not any other properties that hold reference
    types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将此属性设置为不可写，因此如果一个恶意的行为者决定操纵我们对象的`readonly`属性，他们仍然会注意到我们不再向DOM追加内容。`defineProperty`方法非常适用于编写无法轻易操纵的API和库。另一种处理方法是冻结对象。使用`freeze`方法，我们可以确保对象的浅拷贝是只读的。请记住，这仅适用于浅实例，而不适用于持有引用类型的任何其他属性。
- en: 'Finally, we can utilize a counter to see whether we can set the data. We are
    essentially creating a read-side lock. This means that while we are reading the
    data, we do not want to set the data. This means we have to take many precautions
    that we are properly releasing the data once we have read what we want. This can
    look like the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以利用计数器来查看是否可以设置数据。我们基本上正在创建一个读取端锁。这意味着在读取数据时，我们不希望设置数据。这意味着我们必须采取许多预防措施，以确保我们在读取所需内容后正确释放数据。这可能看起来像下面这样：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What we have done is set up a constructor function. We hold the data, the number
    of readers, and a custom event as private variables. We then create three methods.
    First, `getData` will grab the data and also add a counter to someone that is
    utilizing it. Next, we have the `release` method. This will decrement the counter,
    and if we are at 0, we will dispatch an event to tell the `setData` event that
    it can finally write to the mutable state. Finally, we have the `setData` function.
    A promise will be the return value. If there is no one that is holding the data,
    we will set it and resolve it right away. Otherwise, we will set up an event listener
    for our custom event. Once it fires, we will set the data and resolve the promise.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是设置一个构造函数。我们将数据、读者数量和自定义事件作为私有变量保存。然后创建三种方法。首先，`getData`将获取数据，并为使用它的人添加一个计数器。接下来是`release`方法。这将递减计数器，如果计数器为0，我们将触发一个事件，告诉`setData`事件可以最终写入可变状态。最后是`setData`函数。返回值将是一个promise。如果没有人持有数据，我们将立即设置并解析它。否则，我们将为我们的自定义事件设置一个事件监听器。一旦触发，我们将设置数据并解析promise。
- en: Now, this final method of locking mutable data should not be utilized in most
    contexts. There may only be a handful of times when you will want to utilize this,
    such as a hot cache where we need to make sure that we do not overwrite something
    while a reader is reading from this (this can happen on the Node.js side of things
    especially).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种锁定可变数据的最终方法不应该在大多数情况下使用。可能只有少数情况下你会想要使用它，比如热缓存，我们需要确保在读者从中读取时不要覆盖某些东西（这在Node.js方面尤其可能发生）。
- en: All of these methods help create a safe mutable state. With each of these, we
    are able to mutate an object directly and share that memory space. Most of the
    time, good documentation and careful control over our data will make it so we
    do not need to go to the extremes that we have here, but it is good to have these
    methods of RAII in our back pocket when we find something crops up and we are
    mutating something that we should not be.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都有助于创建一个安全的可变状态。通过这些方法，我们能够直接改变对象并共享内存空间。大多数情况下，良好的文档和对数据的谨慎控制将使我们不需要采取我们在这里所做的极端措施，但是当我们发现某些问题出现并且我们正在改变不应该改变的东西时，拥有这些RAII方法是很好的。
- en: Most of the time, the immutable and highly functional code will be more readable
    in the end and, if something does not need to be highly optimized, it is suggested
    to go for being readable. But, in high optimization cases, such as encoding and
    decoding or decorating columns in a table, we will need to squeeze out as much
    performance as we can. This will be seen later in the book where we utilize a
    mixture of programming techniques.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，不可变和高度函数式的代码最终会更易读，如果某些东西不需要高度优化，建议以易读性为重。但是，在高度优化的情况下，例如编码和解码或装饰表中的列，我们需要尽可能地提高性能。这将在本书的后面部分看到，我们将利用各种编程技术的混合。
- en: Even though mutable programming can be fast, sometimes, we want to implement
    things in a functional manner. The following section will explore ways to implement
    programs in this functional manner.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可变编程可能很快，但有时我们希望以函数方式实现事物。接下来的部分将探讨以这种函数方式实现程序的方法。
- en: Functional style programming
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程风格
- en: Even after all of this talk about functional concepts not being the best in
    terms of raw speed, it can still be quite helpful to utilize them in JavaScript.
    There are many languages out there that are not purely functional and all of these
    give us the ability to utilize the best ideas from many paradigms. Languages such
    as F# and Scala come to mind. There are a few ideas that are great when it comes
    to this style of programming and we can utilize them in JavaScript with built-in
    concepts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们谈论了关于函数概念在原始速度方面不是最佳的，但在JavaScript中利用它们仍然可能非常有帮助。有许多语言不是纯函数式的，所有这些语言都给了我们利用许多范式的最佳思想的能力。例如F#和Scala等语言。在这种编程风格方面有一些很棒的想法，我们可以利用JavaScript中的内置概念。
- en: Lazy evaluation
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 惰性评估
- en: In JavaScript, we can perform what is called lazy evaluation. Lazy evaluation
    means that the program does not run what it does not need to. One way of thinking
    about this is when someone is given a list of answers to a problem and they are
    told to put the correct answer to the problem. If they see that the answer was
    the second item that they looked at, they are not going to keep going through
    the rest of the answers they were given; they are going to stop at the second
    item. The way we use lazy evaluation in JavaScript is with generators.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们可以进行所谓的惰性评估。惰性评估意味着程序不运行不需要的部分。一个思考这个问题的方式是，当有人得到一个问题的答案列表，并被告知把正确的答案放在问题的答案列表中。如果他们发现答案是他们查看的第二个项目，他们就不会继续查看他们得到的其他答案；他们会在第二个项目处停下来。我们在JavaScript中使用惰性评估的方式是使用生成器。
- en: 'Generators are functions that will pause execution until the `next` method
    is called on them. A simple example of this is shown as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是一种函数，它会暂停执行，直到在它们上调用`next`方法。一个简单的例子如下所示：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, we notice that `function` has a star next to it. This shows that this
    is a generator function. Next, we set up a simple variable to hold our value and
    then we have an infinite loop. Some may think that this will run continuously,
    but lazy evaluation shows that we will only run up to the `yield`. This `yield`
    means we will pause execution here and that we can grab the value that we send
    back.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们注意到`function`旁边有一个星号。这表明这是一个生成器函数。接下来，我们设置一个简单的变量来保存我们的值，然后我们有一个无限循环。有些人可能会认为这将持续运行，但惰性评估表明我们只会运行到`yield`。这个`yield`意味着我们将在这里暂停执行，并且我们可以获取我们发送回来的值。
- en: So, we start the function up. We have nothing to pass to it so we just simply
    start it. Next, we call `next` on the generator and grab the value. This gives
    us a single iteration and returns whatever was on the `yield` statement. Finally,
    we call `return` to say that we are done with this generator. If we wanted to,
    we can grab the final value here.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们启动函数。我们没有什么要传递给它，所以我们只是简单地启动它。接下来，我们在生成器上调用`next`并获取值。这给了我们一个单独的迭代，并返回`yield`语句上的任何内容。最后，我们调用`return`来表示我们已经完成了这个生成器。如果我们愿意，我们可以在这里获取最终值。
- en: Now, we will notice that when we call next and try to grab the value, it returns
    undefined. We can take a look at the generator and notice that it has a property
    called `done`. This can allow us to see with finite generators if they are finished.
    So, how can this be helpful when we want to do something? A rather trivial example
    is a timing function. What we will do is start off the timer before we want to
    time something and then we will call it another time to calculate the time it
    took for something to run (very similar to `console.time` and `timeEnd`, but it
    should showcase what is available with generators).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们会注意到当我们调用`next`并尝试获取值时，它返回了undefined。我们可以看一下生成器，并注意到它有一个叫做`done`的属性。这可以让我们看到有限生成器是否已经完成。那么当我们想要做一些事情时，这怎么会有帮助呢？一个相当琐碎的例子是一个计时函数。我们将在想要计时的东西之前启动计时器，然后我们将再次调用它来计算某个东西运行所花费的时间（与`console.time`和`timeEnd`非常相似，但它应该展示了生成器的可用性）。
- en: 'This generator could look like the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个生成器可能看起来像下面这样：
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We are now timing a simple summing function. All this does is seed the timing
    generator with the current time. Once the next function is called, it runs the
    statements up to the `yield` and returns the value held in the `yield`. This will
    give us a new time against the time that we passed in. We now have a simple function
    for timings. This can be especially useful for environments where we may not have
    access to the console and we are going to log this information somewhere else.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在计时一个简单的求和函数。所有这个函数做的就是用当前时间初始化计时生成器。一旦调用下一个函数，它就会运行到`yield`语句并返回`yield`中保存的值。这将给我们一个新的时间与我们传入的时间进行比较。现在我们有了一个用于计时的简单函数。这对于我们可能无法访问控制台并且需要在其他地方记录这些信息的环境特别有用。
- en: 'Just as shown in the preceding code block, we can also work with many different
    types of lazy loading. One of the best types that utilize this interface is streams.
    Streams have been available inside Node.js for quite some time, but the stream
    interface for browsers has a basic standardization and certain parts are still
    under debate. A simple example of this type of lazy loading or lazy reading can
    be seen in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前面的代码块所示，我们也可以使用许多不同类型的惰性加载。其中利用这个接口的最好类型之一是流。流在Node.js中已经有一段时间了，但是浏览器的流接口有一个基本的标准化，某些部分仍在讨论中。这种类型的惰性加载或惰性读取的一个简单例子可以在下面的代码中看到：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This example shows the concept of lazy evaluation along with a couple of concepts
    for streaming that we will see in a later chapter. First, we create a generator
    that can take in a function and can utilize it for our logic function in creating
    numbers. In our case, we are just going to use the default case and have it generate
    one number at a time. Next, we are going to run this through a `for/of` loop to
    generate numbers up to 101.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了惰性评估的概念，以及我们将在后面章节中看到的流的一些概念。首先，我们创建一个生成器，它可以接受一个函数，并可以利用它来创建我们的逻辑函数中的数字。在我们的例子中，我们只会使用默认情况，并且让它一次生成一个数字。接下来，我们将通过`for/of`循环运行这个生成器，以生成101个数字。
- en: Next, we create a `fakestream` generator that will chunk our data for us. This
    is similar to streams that allow us to work on a chunk of data at a time. We can
    transform this data if we want to (known as a `TransformStream`) or we can just
    let it pass through (a special type of `TransformStream` called a `PassThrough`).
    We create a fake chunk size at `10`. We then run another `for/of` loop over the
    data we had before and simply log it. However, we could decide to do something
    with this data if we wanted to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个`fakestream`生成器，它将为我们分块数据。这类似于流，允许我们一次处理一块数据。我们可以对这些数据进行转换（称为`TransformStream`），或者只是让它通过（称为`PassThrough`的一种特殊类型的`TransformStream`）。我们在`10`处创建一个假的块大小。然后我们再次对之前的数据运行另一个`for/of`循环，并简单地记录它。但是，如果我们愿意，我们也可以对这些数据做些什么。
- en: This is not the exact interface that streams utilize, but it does showcase how
    we can have lazy evaluation inside our code with generators and that it is also
    built into certain concepts such as streaming. There are many other potential
    uses for generators and lazy evaluation techniques that will not be covered here,
    but they are available to developers who are looking for a more functional-style
    approach to list and map comprehensions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是流使用的确切接口，但它展示了我们如何在生成器中实现惰性求值，并且这也内置在某些概念中，比如流。生成器和惰性求值技术还有许多其他潜在的用途，这里不会涉及，但对于寻求更功能式风格的列表和映射理解的开发人员来说，它们是可用的。
- en: Tail-end recursion optimization
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归优化
- en: 'This is another concept that many functional languages have, but most JavaScript
    engines do not have (WebKit being the exception). Tail-end recursion optimizations
    allow recursive functions that are built in a certain way to run just like a simple
    loop. In pure functional languages, there is no such thing as a loop, so the only
    method of working over a collection is to recursively go through it. We can see
    that if we build a function as a tail-recursive function, it will break our stack.
    The following code illustrates this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这是许多功能性语言具有的另一个概念，但大多数JavaScript引擎没有（WebKit是个例外）。尾递归优化允许以一定方式构建的递归函数运行得就像一个简单的循环一样。在纯函数语言中，没有循环这样的东西，所以处理集合的唯一方法是通过递归进行。我们可以看到，如果我们将一个函数构建为尾递归函数，它将破坏我们的堆栈。以下代码说明了这一点：
- en: '[PRE37]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We create an array of 100,000 items and assign them all the value that is at
    their index. We then try using a recursive function to sum all of the data in
    the array. Since the last call for the function is the function itself, some compilers
    are able to make an optimization here. If they notice that the last call is to
    the same function, they know that the current stack can be destroyed (there is
    nothing left for the function to do). However, non-optimized compilers (most JavaScript
    engines) will not make this optimization so we keep adding stacks to our call
    system. This leads to a call stack size exceedance and makes it so we cannot utilize
    this purely functional concept.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含100,000个项目的数组，并为它们分配了它们索引处的值。然后我们尝试使用递归函数来对数组中的所有数据进行求和。由于函数的最后一次调用是函数本身，一些编译器能够在这里进行优化。如果它们注意到最后一次调用是对同一个函数的调用，它们知道当前的堆栈可以被销毁（函数没有剩余工作要做）。然而，非优化的编译器（大多数JavaScript引擎）不会进行这种优化，因此我们不断向我们的调用系统添加堆栈。这导致调用堆栈大小超出限制，并使我们无法利用这个纯粹的功能概念。
- en: 'There is hope for JavaScript, however. A concept called trampolining can be
    utilized to make tail-end recursion possible by modifying the function a bit and
    how we call it. The following is the modified code to utilize trampolining and
    give us what we want:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，JavaScript还是有希望的。一个叫做trampolining的概念可以通过修改函数和我们调用它的方式来实现尾递归。以下是修改后的代码，以利用trampolining并得到我们想要的结果：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'What we are doing is wrapping our recursive function inside one that we run
    through in a simple loop. The `trampoline` function works like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是将我们的递归函数包装在一个我们通过简单循环运行的函数中。`trampoline`函数的工作方式如下：
- en: It takes in a function and returns a newly constructed function that will run
    our recursive function but loop through it, checking the return type.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接受一个函数，并返回一个新构造的函数，该函数将运行我们的递归函数，但通过循环进行检查返回类型。
- en: Inside this inner function, it starts the loop up by executing a first run of
    the function.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个内部函数中，它通过执行函数的第一次运行来启动循环。
- en: While we still see a function as our return type, it will continue looping.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们仍然将一个函数作为我们的返回类型时，它将继续循环。
- en: Once we finally do not get a function, we will return the results.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们最终得到了一个函数，我们将返回结果。
- en: 'We are now able to utilize tail-end recursion to do some of the things that
    we would do in a purely functional world. An example of this was seen previously
    (which could be seen as a simple reduce function). Another example is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够利用尾递归来做一些在纯粹的功能世界中会做的事情。之前看到的一个例子（可以看作是一个简单的reduce函数）是一个例子。
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: With this function, we are simulating what a filter-based operation may look
    like in a pure functional language. Again, if there is no length, we are at the
    end of the array and we return our filtered array. Otherwise, we return a new
    function that recursively calls itself with a new list, the function that we are
    going to filter with, and then the filtered list. There is a bit of weird syntax
    here. We have to pass back a single array with the new item if we have an empty
    list, otherwise, it will give us an empty array with the number of items that
    we pass in.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个函数，我们模拟了纯函数语言中基于过滤的操作可能是什么样子。同样，如果没有长度，我们就到达了数组的末尾，并返回我们过滤后的数组。否则，我们返回一个新函数，该函数用一个新列表、我们要进行过滤的函数以及过滤后的列表递归调用自身。这里有一些奇怪的语法。如果我们有一个空列表，我们必须返回一个带有新项的单个数组，否则，它将给我们一个包含我们传入的项目数量的空数组。
- en: We can see that both of these functions pass what is known as tail-end recursion
    and are also functions that could be written in a purely functional language.
    But, we will also see that these run a lot slower than simple `for` loops or even
    the built-in array methods for these types of functions. At the end of the day,
    if we wanted to write purely functional programming using tail-end recursion,
    we could, but it is wise not to do this in JavaScript.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这两个函数都通过了尾递归的检查，并且也是纯函数语言中可以编写的函数。但是，我们也会看到，这些函数运行起来比简单的`for`循环甚至这些类型函数的内置数组方法要慢得多。归根结底，如果我们想要使用尾递归来编写纯粹的函数式编程，我们可以，但在JavaScript中这样做是不明智的。
- en: Currying
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'The final concept that we will be looking at is currying. Currying is the ability
    of a function that takes multiple arguments to actually be a series of functions
    that takes a single argument and returns either another function or the final
    value. Let''s take a look at a simple example to see this concept in action:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要看的最后一个概念是柯里化。柯里化是一个接受多个参数的函数实际上是一系列接受单个参数并返回另一个函数或最终值的函数。让我们看一个简单的例子来看看这个概念是如何运作的：
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What we are doing is taking a function that accepts multiple arguments, such
    as the `add` function. We then return a function that takes a single argument,
    in this case, `b`. This function then adds the numbers `a` and `b` together. What
    this allows us to do is either use the function as we normally would (except we
    run the function that comes back to us and pass in the second argument) or we
    get the return value from running it on a single argument and then use that function
    to add whatever values come next. Each of these concepts can be seen in the following
    code:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接受一个接受多个参数的函数，比如`add`函数。然后我们返回一个接受单个参数的函数，这里是`b`。这个函数然后将数字`a`和`b`相加。这使我们能够像通常一样使用函数（除了我们运行返回给我们的函数并传入第二个参数），或者我们得到运行它的返回值，并使用该函数来添加接下来的任何值。这些概念中的每一个都可以在以下代码中看到：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are a couple of uses for currying and they also show off a concept that
    can be used quite frequently. First, it shows off the idea of partial application.
    What this does is set some of our arguments for us and return a function. We can
    then pass this function along in the chain of statements and eventually use it
    to fill in the remaining functions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化有一些用途，它们也展示了一个可以经常使用的概念。首先，它展示了部分应用的概念。这样做是为我们设置一些参数并返回一个函数。然后我们可以将这个函数传递到语句链中，并最终用它来填充剩下的函数。
- en: Just remember that all currying functions are partially applied functions, but
    not all partially applied functions are currying functions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，所有柯里化函数都是部分应用函数，但并非所有部分应用函数都是柯里化函数。
- en: 'An example of partial application can be seen in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的示例可以在以下代码中看到：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, we create a function that takes three arguments. We then create a new
    temporary function that binds `2` to the first argument of that function. `Bind`
    is an interesting function. It takes the scope that we want as the first argument
    (what `this` points to) and then takes an arbitrary length of arguments to fill
    in for the arguments of the function we are working on. In our case, we only bind
    the first variable to the number `2`. We then create a second temporary function
    where we bind the first variables of the first temporary function to `3`. Finally,
    we create a third and final temporary function where we bind the first argument
    of the second function to the number `5`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个接受三个参数的函数。然后我们创建一个新的临时函数，将`2`绑定到该函数的第一个参数。`Bind`是一个有趣的函数。它将我们想要的作用域作为第一个参数（`this`指向的内容），然后接受任意长度的参数来填充我们正在处理的函数的参数。在我们的例子中，我们只将第一个变量绑定到数字`2`。然后我们创建一个第二个临时函数，其中我们将第一个临时函数的第一个变量绑定到`3`。最后，我们创建一个第三个临时函数，其中我们将第二个函数的第一个参数绑定到数字`5`。
- en: We can see at each run that we are able to run each of these functions and that
    they take a different number of arguments depending on which version of the function
    we have used. `bind` is a very powerful tool and allows us to pass functions around
    that may get arguments filled in from other functions before the final function
    is used.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每次运行时看到，我们能够运行这些函数中的每一个，并且它们根据我们使用的函数版本不同而接受不同数量的参数。`bind`是一个非常强大的工具，它允许我们传递函数，这些函数可能会在最终使用函数之前从其他函数中获取参数填充。
- en: 'Currying is the idea that we will use partial application, but that we are
    going to compose a multi-argument function with multiple nested functions inside
    it. So what does currying give us that we cannot already do with other concepts?
    If we are in the pure functional world, we can actually get quite a bit. Take,
    for example, the `map` function on arrays. It wants a function definition of a
    single item (we are going to ignore the other parameters that we normally do not
    use) and wants the function to return a single item. What happens when we have
    a function such as the following one and it could be used inside the `map` function,
    but it has multiple arguments? The following code showcases what we are able to
    do with currying and this use case:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是我们将使用部分应用，但我们将用多个嵌套函数组成多参数函数的概念。那么柯里化给我们带来了什么，而其他概念无法做到呢？如果我们处于纯函数世界，实际上我们可以得到很多。例如，数组上的`map`函数。它希望一个单个项目的函数定义（我们将忽略通常不使用的其他参数），并希望函数返回一个单个项目。当我们有一个像下面这样的函数，并且它可以在`map`函数中使用，但它有多个参数时会发生什么？以下代码展示了我们可以用柯里化和这种用例做些什么：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: What we are doing is taking a generic function (an arbitrary one at that) and
    utilizing it in the map function by making it more specific, in this case by giving
    the precision two decimal places. This allows us to write very generic functions
    that can work over arbitrary data and make specific functions out of them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在接受一个通用函数（甚至是任意的），并通过使其更具体（在本例中是保留两位小数）在`map`函数中使用它。这使我们能够编写非常通用的函数，可以处理任意数据并从中制作特定的函数。
- en: We will utilize partial application a bit in our code and we may use currying.
    In general, however, we will not utilize currying as is seen in purely functional
    languages as this can lead to a slowdown and higher memory consumption. The main
    ideas to take away are partial application and the idea of how variables on the
    outer scope can be used in an inner scoped location.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们的代码中使用部分应用，并且可能会使用柯里化。然而，总的来说，我们不会像在纯函数式语言中那样使用柯里化，因为这可能会导致减速和更高的内存消耗。最重要的是要理解部分应用和外部作用域变量如何在内部作用域位置中使用的概念。
- en: 'These three concepts are quite crucial to the idea of pure functional programming,
    but we will not utilize most of them. In highly performant code, we need to squeeze
    out every ounce of speed and memory that we can and most of these constructs take
    up more than we care for. Certain concepts can be used to great lengths in high-performance
    code. The following will be used in later chapters: partial application, streaming/lazy
    evaluation, and possibly some recursion. Being comfortable with seeing functional
    code will help when working with libraries that utilize these concepts, but as
    we have talked about at length, they are not as performant as our iterative methods.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个概念对于纯函数式编程的理念非常关键，但我们将不会利用其中大部分。在高性能代码中，我们需要尽可能地提高速度和内存利用率，而其中大部分构造占用的资源超出了我们的承受范围。某些概念可以在高性能代码中大量使用。以下内容将在后续章节中使用：部分应用、流式/惰性求值，可能还有一些递归。熟悉函数式代码将有助于在使用利用这些概念的库时更加得心应手，但正如我们长时间讨论过的那样，它们并不像我们的迭代方法那样高性能。
- en: Summary
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have looked at the ideas of mutability and immutability.
    We have seen how immutability can lead to slowdowns and higher memory consumption
    and can be an issue when we are writing high-performance code. We have taken a
    look at mutability and how to make sure we write code that utilizes it, but also
    makes it safe. On top of this, we have performed performance comparisons between
    mutable and immutable code and have seen where speed and memory consumption increases
    for the immutable types. Finally, we took a look at functional-style programming
    in JavaScript and how we can utilize these concepts. Functional programming can
    help with many issues, such as lock-free concurrency, but we also know that the
    JavaScript runtimes are single-threaded and so this does not give us an advantage.
    Overall, there are many concepts that we can borrow from the different paradigms
    of programming and having all of these in our toolkit can make us better programmers
    and help us write clean, safe, and high-performance code.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了可变性和不可变性的概念。我们已经看到不可变性可能会导致减速和更高的内存消耗，并且在编写高性能代码时可能会成为一个问题。我们已经看了可变性以及如何确保我们编写的代码利用了它，但也使其安全。除此之外，我们还进行了可变和不可变代码的性能比较，并看到了不可变类型的速度和内存消耗增加的情况。最后，我们看了JavaScript中的函数式编程以及我们如何利用这些概念。函数式编程可以帮助解决许多问题，比如无锁并发，但我们也知道JavaScript运行时是单线程的，因此这并没有给我们带来优势。总的来说，我们可以从不同的编程范式中借鉴许多概念，拥有这些概念可以使我们成为更好的程序员，并帮助我们编写干净、安全和高性能的代码。
- en: In the next chapter, we will take a look at how JavaScript has evolved as a
    language. We will also take a look at how browsers have changed to meet the demands
    of developers, with new APIs that cover everything from accessing the DOM to long-term
    storage.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下JavaScript作为一种语言是如何发展的。我们还将看一下浏览器是如何改变以满足开发人员的需求的，新的API涵盖了从访问DOM到长期存储的所有内容。
