- en: Creating and Managing Container Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和管理容器镜像
- en: In the previous chapter, we learned what containers are and how to run, stop,
    remove, list, and inspect them. We extracted the logging information of some containers,
    ran other processes inside an already running container, and finally, we dived
    deep into the anatomy of containers. Whenever we ran a container, we created it
    using a container image. In this chapter, we will be familiarizing ourselves with
    these container images. We will learn in detail what they are, how to create them,
    and how to distribute them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了容器是什么，以及如何运行、停止、删除、列出和检查它们。我们提取了一些容器的日志信息，在已经运行的容器内运行其他进程，最后，我们深入研究了容器的解剖学。每当我们运行一个容器时，我们都是使用容器镜像创建它。在本章中，我们将熟悉这些容器镜像。我们将详细了解它们是什么，如何创建它们以及如何分发它们。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: What are images?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: Creating images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建镜像
- en: 'Lift and shift: Containerizing a legacy app'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 举起和转移：容器化传统应用程序
- en: Sharing or shipping images
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享或运输镜像
- en: 'After completing this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够执行以下操作：
- en: Name three of the most important characteristics of a container image.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列举容器镜像的三个最重要特征。
- en: Create a custom image by interactively changing the container layer and committing
    it.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过交互式更改容器层并提交来创建自定义镜像。
- en: Author a simple `Dockerfile` to generate a custom image.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的`Dockerfile`来生成自定义镜像。
- en: Export an existing image using `docker image save` and import it into another
    Docker host using `docker image load`.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker image save`导出现有的镜像，并使用`docker image load`将其导入到另一个Docker主机。
- en: Write a two-step Dockerfile that minimizes the size of the resulting image by
    only including the resulting artifacts in the final image.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个两步的Dockerfile，通过仅在最终镜像中包含生成的工件来最小化结果镜像的大小。
- en: What are images?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: In Linux, everything is a file. The whole operating system is basically a filesystem
    with files and folders stored on the local disk. This is an important fact to
    remember when looking at what container images are. As we will see, an image is
    basically a big tarball containing a filesystem. More specifically, it contains
    a layered filesystem.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，一切都是文件。整个操作系统基本上是一个存储在本地磁盘上的文件系统。当查看容器镜像时，这是一个重要的事实要记住。正如我们将看到的，镜像基本上是一个包含文件系统的大型tarball。更具体地说，它包含一个分层文件系统。
- en: The layered filesystem
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分层文件系统
- en: 'Container images are templates from which containers are created. These images are
    not made up of just one monolithic block but are composed of many layers. The
    first layer in the image is also called the base layer. We can see this in the
    following graphic:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是创建容器的模板。这些镜像不仅由一个单一的块组成，而是由许多层组成。镜像中的第一层也被称为基础层。我们可以在下面的图形中看到这一点：
- en: '![](assets/f648f501-f54d-4794-ae3f-c17ec8f78b6c.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f648f501-f54d-4794-ae3f-c17ec8f78b6c.png)'
- en: The image as a stack of layers
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像就像一堆层叠的图层
- en: Each individual layer contains files and folders. Each layer only contains the
    changes to the filesystem with respect to the underlying layers. Docker uses a
    Union filesystem—as discussed in [Chapter 3](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml), *Mastering
    Containers — *to create a virtual filesystem out of the set of layers. A storage
    driver handles the details regarding the way these layers interact with each other.
    Different storage drivers are available that have advantages and disadvantages
    in different situations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的图层都包含文件和文件夹。每个图层只包含相对于底层的文件系统的更改。Docker使用Union文件系统——如[第3章](d9bb597d-2b32-4144-b068-564d85bcdf68.xhtml)中所讨论的*掌握容器*——从一组图层中创建虚拟文件系统。存储驱动程序处理有关这些图层如何相互交互的详细信息。不同的存储驱动程序可在不同情况下具有优势和劣势。
- en: The layers of a container image are all immutable. Immutable means that once
    generated, the layer cannot ever be changed. The only possible operation affecting
    the layer is its physical deletion. This immutability of layers is important because
    it opens up a tremendous amount of opportunities, as we will see.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的层都是不可变的。不可变意味着一旦生成，该层就永远不能被改变。唯一可能影响层的操作是其物理删除。层的这种不可变性很重要，因为它为我们打开了大量的机会，我们将会看到。
- en: 'In the following screenshot, we can see what a custom image for a web application,
    using Nginx as a web server, could look like:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，我们可以看到一个基于Nginx作为Web服务器的Web应用程序的自定义镜像是什么样子的：
- en: '![](assets/48c83b9e-fef1-45d9-a084-c1076f3e396d.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/48c83b9e-fef1-45d9-a084-c1076f3e396d.png)'
- en: A sample custom image based on Alpine and Nginx
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Alpine和Nginx的示例自定义镜像
- en: Our base layer here consists of the **Alpine Linux** distribution. Then, on
    top of that, we have an **Add Nginx** layer where Nginx is added on top of Alpine.
    Finally, the third layer contains all the files that make up the web application,
    such as HTML, CSS, and JavaScript files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础层是**Alpine Linux**发行版。然后，在此基础上，我们有一个**添加Nginx**层，其中Nginx添加在Alpine之上。最后，第三层包含构成Web应用程序的所有文件，如HTML、CSS和JavaScript文件。
- en: As has been said previously, each image starts with a base image. Typically,
    this base image is one of the official images found on Docker Hub, such as a Linux
    distro, Alpine, Ubuntu, or CentOS. However, it is also possible to create an image
    from scratch.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，每个镜像都以基础镜像开始。通常，这个基础镜像是在Docker Hub上找到的官方镜像之一，比如Linux发行版、Alpine、Ubuntu或CentOS。然而，也可以从头开始创建一个镜像。
- en: Docker Hub is a public registry for container images. It is a central hub ideally
    suited for sharing public container images.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是一个用于容器镜像的公共注册表。它是一个中央枢纽，非常适合共享公共容器镜像。
- en: Each layer only contains the delta of changes in regard to the previous set
    of layers. The content of each layer is mapped to a special folder on the host
    system, which is usually a subfolder of `/var/lib/docker/`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个层只包含相对于前一组层的更改。每个层的内容都映射到主机系统上的一个特殊文件夹，通常是`/var/lib/docker/`的子文件夹。
- en: Since layers are immutable, they can be cached without ever becoming stale.
    This is a big advantage, as we will see.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于层是不可变的，它们可以被缓存而永远不会变得过时。这是一个很大的优势，我们将会看到。
- en: The writable container layer
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可写的容器层
- en: 'As we have discussed, a container image is made of a stack of immutable or
    read-only layers. When the Docker Engine creates a container from such an image,
    it adds a writable container layer on top of this stack of immutable layers. Our
    stack now looks as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，一个容器镜像由一堆不可变或只读的层组成。当Docker引擎从这样的镜像创建一个容器时，它会在这堆不可变层的顶部添加一个可写的容器层。我们的堆现在看起来是这样的：
- en: '![](assets/35fc8834-7fa6-42ad-bdd6-7979a1878438.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/35fc8834-7fa6-42ad-bdd6-7979a1878438.png)'
- en: The writable container layer
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可写的容器层
- en: 'The **Container Layer** is marked as read/write. Another advantage of the immutability
    of image layers is that they can be shared among many containers created from
    this image. All that is needed is a thin, writable container layer for each container,
    as shown in the following screenshot:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 容器层标记为可读/可写。镜像层的不可变性的另一个优点是它们可以在许多从该镜像创建的容器之间共享。所需的只是每个容器的一个薄的可写容器层，如下面的屏幕截图所示：
- en: '![](assets/0e32cfeb-d02b-4397-8ead-f1e066194ef3.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0e32cfeb-d02b-4397-8ead-f1e066194ef3.png)'
- en: Multiple containers sharing the same image layers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 共享相同镜像层的多个容器
- en: This technique, of course, results in a tremendous reduction in the resources
    that are consumed. Furthermore, this helps to decrease the loading time of a container
    since only a thin container layer has to be created once the image layers have
    been loaded into memory, which only happens for the first container.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种技术会大大减少资源的消耗。此外，这有助于减少容器的加载时间，因为一旦镜像层加载到内存中，只需创建一个薄容器层，这仅发生在第一个容器中。
- en: Copy-on-write
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写时复制
- en: 'Docker uses the copy-on-write technique when dealing with images. Copy-on-write
    is a strategy for sharing and copying files for maximum efficiency. If a layer
    uses a file or folder that is available in one of the low-lying layers, then it
    just uses it. If, on the other hand, a layer wants to modify, say, a file from
    a low-lying layer, then it first copies this file up to the target layer and then
    modifies it. In the following screenshot, we can see a glimpse of what this means:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Docker在处理镜像时使用写时复制技术。写时复制是一种用于最大效率共享和复制文件的策略。如果一个层使用了一个低层次层中可用的文件或文件夹，那么它就直接使用它。另一方面，如果一个层想要修改一个低层次层中的文件，那么它首先将该文件复制到目标层，然后进行修改。在下面的截图中，我们可以看到这意味着什么：
- en: '![](assets/7129ffa2-5290-455b-847a-1ae41c2aee0f.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/7129ffa2-5290-455b-847a-1ae41c2aee0f.png)'
- en: Docker image using copy-on-write
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用写时复制的Docker镜像
- en: The second layer wants to modify **File 2**, which is present in the **Base
    Layer**. Thus, it copies it up and then modifies it. Now, let's say that we're sitting in
    the top layer of the preceding screenshot. This layer will use **File 1** from
    the **Base Layer** and **File 2** and **File 3** from the second layer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第二层想要修改**文件2**，它存在于**基础层**中。因此，它将其复制并进行修改。现在，假设我们正处于前面截图的顶层。这一层将使用**基础层**中的**文件1**，以及第二层中的**文件2**和**文件3**。
- en: Graph drivers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形驱动程序
- en: Graph drivers are what enable the Union filesystem. Graph drivers are also called
    storage drivers and are used when dealing with layered container images. A graph
    driver consolidates multiple image layers into a root filesystem for the mount
    namespace of the container. Or, put differently, the driver controls how images
    and containers are stored and managed on the Docker host.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图形驱动程序是启用联合文件系统的东西。图形驱动程序也称为存储驱动程序，在处理分层容器镜像时使用。图形驱动程序将多个镜像层合并为容器的挂载命名空间的根文件系统。换句话说，驱动程序控制着镜像和容器在Docker主机上的存储和管理方式。
- en: Docker supports several different graph drivers using a pluggable architecture.
    The preferred driver is `overlay2`, followed by `overlay`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持使用可插拔架构的多种不同的图形驱动程序。首选驱动程序是`overlay2`，其次是`overlay`。
- en: Creating images
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建镜像
- en: There are three ways to create a new container image on your system. The first
    one is by interactively building a container that contains all the additions and
    changes one desires, and then committing those changes into a new image. The second,
    and most important, way is to use a `Dockerfile` to describe what's in the new
    image, and then build the image using that `Dockerfile` as a manifest. Finally,
    the third way of creating an image is by importing it into the system from a tarball.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的系统上有三种方法可以创建一个新的容器镜像。第一种方法是通过交互式地构建一个包含所有所需的添加和更改的容器，然后将这些更改提交到一个新的镜像中。第二种，也是最重要的方法是使用`Dockerfile`描述新镜像中的内容，然后使用该`Dockerfile`构建镜像作为清单。最后，创建镜像的第三种方法是通过从tarball导入到系统中。
- en: Now, let's look at these three ways in detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细看看这三种方式。
- en: Interactive image creation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式镜像创建
- en: The first way we can create a custom image is by interactively building a container.
    That is, we start with a base image that we want to use as a template and run
    a container of it interactively. Let's say that this is the Alpine image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自定义镜像的第一种方式是通过交互式构建容器。也就是说，我们从要用作模板的基本镜像开始，并以交互方式运行一个容器。假设这是Alpine镜像。
- en: 'To interactively create an image follow along:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要交互式地创建一个镜像，请按照以下步骤进行：
- en: 'The command to run the container would be as follows:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行容器的命令应该如下所示：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding command runs a container based on the `alpine:3.10` image.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令基于`alpine:3.10`镜像运行一个容器。
- en: We run the container interactively with an attached **teletypewriter** (**TTY**)
    using the `-it` parameter, name it `sample` with the `--name` parameter, and—finally—run
    a shell inside the container using `/bin/sh`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`-it`参数交互式运行附加了**电传打字机**（**TTY**）的容器，使用`--name`参数将其命名为`sample`，最后在容器内部使用`/bin/sh`运行一个shell。
- en: 'In the Terminal window where you run the preceding command, you should see
    something similar to this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行上述命令的终端窗口中，您应该看到类似于这样的内容：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By default, the `alpine` container does not have the `ping` tool installed.
    Let's assume we want to create a new custom image that has `ping` installed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`alpine`容器没有安装`ping`工具。假设我们想要创建一个新的自定义镜像，其中安装了`ping`。
- en: 'Inside the container, we can then run the following command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内部，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This uses the `apk` Alpine package manager to install the `iputils` library,
    of which `ping` is a part. The output of the preceding command should look approximately
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`apk` Alpine软件包管理器来安装`iputils`库，其中包括`ping`。上述命令的输出应该大致如下：
- en: '![](assets/7095041c-9ad2-4bfc-bc0e-940fd1351b23.png)Installing `ping` on Alpine'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/7095041c-9ad2-4bfc-bc0e-940fd1351b23.png)在Alpine上安装`ping`'
- en: 'Now, we can indeed use `ping`, as the following code snippet shows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们确实可以使用`ping`，如下面的代码片段所示：
- en: '![](assets/914c8ee9-964b-49b0-afe2-e1b0dd28d57b.png)Using ping from within
    the container'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/914c8ee9-964b-49b0-afe2-e1b0dd28d57b.png)在容器内部使用ping'
- en: Once we have finished our customization, we can quit the container by typing `exit` at
    the prompt.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成自定义后，我们可以通过在提示符处键入`exit`退出容器。
- en: 'If we now list all containers with the `ls -a` Docker container, we can see
    that our sample container has a status of `Exited`, but still exists on the system,
    as shown in the following code block:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用`ls -a` Docker容器列出所有容器，我们可以看到我们的示例容器的状态为`Exited`，但仍然存在于系统中，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we want to see what has changed in our container in relation to the base
    image, we can use the `docker container diff` command, as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要查看容器相对于基本镜像的变化，我们可以使用`docker container diff`命令，如下所示：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should present a list of all modifications done on the filesystem
    of the container, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该呈现出容器文件系统上的所有修改列表，如下所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have shortened the preceding output for better readability. In the list, `A` stands
    for *added*, and `C` stands for *changed*. If we had any deleted files, then those
    would be prefixed with a **`D`**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经缩短了上述输出以便更好地阅读。在列表中，`A`代表*添加*，`C`代表*更改*。如果有任何已删除的文件，那么它们将以**`D`**为前缀。
- en: 'We can now use the `docker container commit` command to persist our modifications
    and create a new image from them, like this:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`docker container commit`命令来保存我们的修改并从中创建一个新的镜像，如下所示：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the preceding command, we have specified that the new image will be called `my-alpine`.
    The output generated by the preceding command corresponds to the ID of the newly
    generated image.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述命令，我们指定了新镜像将被称为`my-alpine`。上述命令生成的输出对应于新生成的镜像的ID。
- en: 'We can verify this by listing all images on our system, as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过列出系统上的所有镜像来验证这一点，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see this image ID (shortened) as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个图像ID（缩短）如下：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see that the image named `my-alpine` has the expected ID of `44bca4141130` and
    automatically got a `latest` tag assigned. This happens since we did not explicitly
    define a tag ourselves. In this case, Docker always defaults to the `latest` tag.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到名为`my-alpine`的图像具有预期的ID`44bca4141130`，并自动分配了`latest`标签。这是因为我们没有明确定义标签。在这种情况下，Docker总是默认为`latest`标签。
- en: 'If we want to see how our custom image has been built, we can use the `history `command
    as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要查看我们的自定义图像是如何构建的，我们可以使用`history`命令如下：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will print a list of the layers our image consists of, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出我们的图像包含的层的列表，如下所示：
- en: '![](assets/c399a38d-20a1-48b9-8210-4831f035b78e.png)History of the my-alpine Docker
    image'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c399a38d-20a1-48b9-8210-4831f035b78e.png)my-alpine Docker图像的历史'
- en: The first layer in the preceding output is the one that we just created by adding
    the `iputils` package.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，第一层是我们刚刚通过添加`iputils`包创建的层。
- en: Using Dockerfiles
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dockerfile
- en: 'Manually creating custom images, as shown in the previous section of this chapter,
    is very helpful when doing exploration, creating prototypes, or authoring feasibility
    studies. But it has a serious drawback: it is a manual process and thus is not
    repeatable or scalable. It is also as error-prone as any other task executed manually
    by humans. There must be a better way.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建自定义图像，如本章的前一节所示，当进行探索、创建原型或进行可行性研究时非常有帮助。但它有一个严重的缺点：这是一个手动过程，因此不可重复或可扩展。它也像人类手动执行的任何其他任务一样容易出错。必须有更好的方法。
- en: This is where the so-called `Dockerfile` comes into play. A `Dockerfile` is
    a text file that is usually literally called `Dockerfile`. It contains instructions
    on how to build a custom container image. It is a declarative way of building
    images.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的`Dockerfile`发挥作用的地方。`Dockerfile`是一个文本文件，通常被称为`Dockerfile`。它包含了构建自定义容器映像的指令。这是一种声明性构建图像的方式。
- en: '**De****clarative versus imperative**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式与命令式：
- en: In computer science, in general, and with Docker specifically, one often uses
    a declarative way of defining a task. One describes the expected outcome and lets
    the system figure out how to achieve this goal, rather than giving step-by-step
    instructions to the system on how to achieve this desired outcome. The latter
    is an imperative approach.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，通常情况下，特别是在Docker中，人们经常使用声明性的方式来定义任务。人们描述期望的结果，让系统找出如何实现这个目标，而不是给系统提供逐步实现所需结果的指令。后者是一种命令式的方法。
- en: 'Let''s look at a sample `Dockerfile`, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例`Dockerfile`，如下所示：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a `Dockerfile` as it is used to containerize a Python 2.7 application.
    As we can see, the file has six lines, each starting with a keyword such as `FROM`, `RUN`,
    or `COPY`. It is a convention to write the keywords in all caps, but that is not
    a must.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Dockerfile`，用于容器化Python 2.7应用程序。正如我们所看到的，文件有六行，每行以关键字开头，如`FROM`、`RUN`或`COPY`。习惯上将关键字写成大写，但这不是必须的。
- en: 'Each line of the `Dockerfile` results in a layer in the resulting image. In
    the following screenshot, the image is drawn upside down compared to the previous
    illustrations in this chapter, showing an image as a stack of layers. Here, the
    **Base Layer** is shown on top. Don''t let yourself be confused by this. In reality,
    the base layer is always the lowest layer in the stack:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的每一行都会导致结果图像中的一个层。在下面的截图中，与本章前面的插图相比，图像被颠倒过来，显示为一堆层。在这里，**基础层**显示在顶部。不要被这个搞混了。实际上，基础层始终是堆栈中最低的层：'
- en: '![](assets/3f4c11dd-4fed-478b-b229-cdc834633c62.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3f4c11dd-4fed-478b-b229-cdc834633c62.png)'
- en: The relation of Dockerfile and layers in an image
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中Dockerfile和层的关系
- en: Now, let's look at the individual keywords in more detail.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看各个关键字。
- en: The FROM keyword
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FROM关键字
- en: 'Every `Dockerfile` starts with the `FROM` keyword. With it, we define which
    base image we want to start building our custom image from. If we want to build
    starting with CentOS 7, for example, we would have the following line in the `Dockerfile`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Dockerfile`都以`FROM`关键字开始。通过它，我们定义了要从哪个基础镜像开始构建我们的自定义镜像。例如，如果我们想从CentOS 7开始构建，我们会在`Dockerfile`中有以下行：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: On Docker Hub, there are curated or official images for all major Linux distros,
    as well as for all important development frameworks or languages, such as Python,
    Node.js, Ruby, Go, and many more. Depending on our needs, we should select the
    most appropriate base image.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Hub上，有所有主要Linux发行版的精选或官方镜像，以及所有重要的开发框架或语言，比如Python、Node.js、Ruby、Go等等。根据我们的需求，我们应该选择最合适的基础镜像。
- en: For example, if I want to containerize a Python 3.7 application, I might want
    to select the relevant official `python:3.7` image.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想容器化一个Python 3.7应用程序，我可能会选择相关的官方`python:3.7`镜像。
- en: 'If we really want to start from scratch, we can also use the following statement:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想从头开始，我们也可以使用以下语句：
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is useful in the context of building super-minimal images that only—for
    example—contain a single binary: the actual statically linked executable, such
    as `Hello-World`. The `scratch` image is literally an empty base image.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这在构建超小型镜像的情况下非常有用，比如只包含一个二进制文件的情况：实际的静态链接可执行文件，比如`Hello-World`。`scratch`镜像实际上是一个空的基础镜像。
- en: '`FROM scratch` is a `no-op` in the `Dockerfile`, and as such does not generate
    a layer in the resulting container image.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`FROM scratch`在`Dockerfile`中是一个`no-op`，因此不会在生成的容器镜像中生成一个层。'
- en: The RUN keyword
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RUN关键字
- en: 'The next important keyword is `RUN`. The argument for `RUN` is any valid Linux
    command, such as the following:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的关键字是`RUN`。`RUN`的参数是任何有效的Linux命令，比如以下内容：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command is using the `yum` CentOS package manager to install
    the `wget` package into the running container. This assumes that our base image
    is CentOS or **Red Hat Enterprise Linux** (**RHEL**). If we had Ubuntu as our
    base image, then the command would look similar to the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用`yum` CentOS包管理器来在运行的容器中安装`wget`包。这假设我们的基础镜像是CentOS或Red Hat Enterprise
    Linux（RHEL）。如果我们的基础镜像是Ubuntu，那么命令会类似于以下内容：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'It would look like this because Ubuntu uses `apt-get` as a package manager.
    Similarly, we could define a line with `RUN`, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Ubuntu使用`apt-get`作为包管理器。同样，我们可以定义一行`RUN`命令，如下所示：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We could also do this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以这样做：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, the former creates an `/app` folder in the container and navigates to
    it, and the latter untars a file to a given location. It is completely fine, and even recommended,
    for you to format a Linux command using more than one physical line, such as this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，前者在容器中创建了一个`/app`文件夹并导航到它，后者将一个文件解压到指定位置。完全可以，甚至建议你使用多于一行的物理行来格式化Linux命令，比如这样：
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If we use more than one line, we need to put a backslash (`\`) at the end of
    the lines to indicate to the shell that the command continues on the next line.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用多行，需要在行尾加上反斜杠（`\`）来指示shell命令在下一行继续。
- en: Try to find out what the preceding command does.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试找出前面的命令是做什么的。
- en: The COPY and ADD keywords
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: COPY和ADD关键字
- en: The `COPY` and `ADD` keywords are very important since, in the end, we want to
    add some content to an existing base image to make it a custom image. Most of
    the time, these are a few source files of—say—a web application, or a few binaries
    of a compiled application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`和`ADD`关键字非常重要，因为最终我们希望向现有的基础镜像添加一些内容，使其成为自定义镜像。大多数情况下，这些是一些源文件，比如Web应用程序，或者一些已编译应用程序的二进制文件。'
- en: These two keywords are used to copy files and folders from the host into the
    image that we're building. The two keywords are very similar, with the exception
    that the `ADD` keyword also lets us copy and unpack TAR files, as well as providing
    a URL as a source for the files and folders to copy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个关键字用于将文件和文件夹从主机复制到正在构建的镜像中。 这两个关键字非常相似，唯一的区别是`ADD`关键字还允许我们复制和解压缩TAR文件，并提供URL作为要复制的文件和文件夹的来源。
- en: 'Let''s look at a few examples of how these two keywords can be used, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些如何使用这两个关键字的示例，如下所示：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the preceding lines of code, the following applies:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的前几行中，适用以下内容：
- en: The first line copies all files and folders from the current directory recursively
    to the `app` folder inside the container image.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行将当前目录中的所有文件和文件夹递归地复制到容器镜像内的`app`文件夹中。
- en: The second line copies everything in the `web` subfolder to the target folder, `/app/web`.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二行将`web`子文件夹中的所有内容复制到目标文件夹`/app/web`。
- en: The third line copies a single file, `sample.txt`, into the target folder, `/data`,
    and at the same time, renames it to `my-sample.txt`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行将单个文件`sample.txt`复制到目标文件夹`/data`中，并同时将其重命名为`my-sample.txt`。
- en: The fourth statement unpacks the `sample.tar `file into the target folder, `/app/bin`
    .
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第四个语句将`sample.tar`文件解压缩到目标文件夹`/app/bin`中。
- en: Finally, the last statement copies the remote file, `sample.txt`, into the target
    file, `/data`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，最后一个语句将远程文件`sample.txt`复制到目标文件`/data`中。
- en: 'Wildcards are allowed in the source path. For example, the following statement
    copies all files starting with `sample` to the `mydir` folder inside the image:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 源路径中允许使用通配符。 例如，以下语句将所有以`sample`开头的文件复制到镜像内的`mydir`文件夹中：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From a security perspective, it is important to know that, by default, all
    files and folders inside the image will have a **user ID** (**UID**) and a **group
    ID** (**GID**) of `0`. The good thing is that for both `ADD` and `COPY`, we can
    change the ownership that the files will have inside the image using the optional `--chown` flag,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，重要的是要知道，默认情况下，镜像内的所有文件和文件夹都将具有`0`的**用户ID**（**UID**）和**组ID**（**GID**）。
    好处是，对于`ADD`和`COPY`，我们可以使用可选的`--chown`标志更改镜像内文件的所有权，如下所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding statement will copy all files starting with the name `web` and
    put them into the `/app/data` folder in the image, and at the same time assign
    user `11` and group `22` to these files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将复制所有以`web`开头的文件并将它们放入镜像中的`/app/data`文件夹，并同时为这些文件分配用户`11`和组`22`。
- en: Instead of numbers, one could also use names for the user and group, but then
    these entities would have to be already defined in the root filesystem of the
    image at `/etc/passwd` and `/etc/group` respectively; otherwise, the build of
    the image would fail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字之外，用户和组也可以使用名称，但是这些实体必须已在镜像的根文件系统中的`/etc/passwd`和`/etc/group`中定义； 否则，镜像的构建将失败。
- en: The WORKDIR keyword
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WORKDIR关键字
- en: 'The `WORKDIR` keyword defines the working directory or context that is used
    when a container is run from our custom image. So, if I want to set the context
    to the `/app/bin` folder inside the image, my expression in the `Dockerfile` would
    have to look as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`WORKDIR`关键字定义了在从我们的自定义镜像运行容器时使用的工作目录或上下文。 因此，如果我想将上下文设置为镜像内的`/app/bin`文件夹，则我的`Dockerfile`中的表达式必须如下所示：'
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'All activity that happens inside the image after the preceding line will use
    this directory as the working directory. It is very important to note that the
    following two snippets from a `Dockerfile` are not the same:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一行之后发生的所有活动都将使用此目录作为工作目录。 非常重要的一点是要注意，`Dockerfile`中以下两个片段不同：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Compare the preceding code with the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码与以下代码进行比较：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The former will create the file in the root of the image filesystem, while the
    latter will create the file at the expected location in the `/app/bin` folder.
    Only the `WORKDIR` keyword sets the context across the layers of the image. The `cd` command
    alone is not persisted across layers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将在图像文件系统的根目录中创建文件，而后者将在`/app/bin`文件夹中的预期位置创建文件。只有`WORKDIR`关键字设置了图像层之间的上下文。`cd`命令本身不会跨层持久存在。
- en: The CMD and ENTRYPOINT keywords
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CMD和ENTRYPOINT关键字
- en: The `CMD` and `ENTRYPOINT` keywords are special. While all other keywords defined for
    a `Dockerfile` are executed at the time the image is built by the Docker builder,
    these two are actually definitions of what will happen when a container is started
    from the image we define. When the container runtime starts a container, it needs
    to know what the process or application will be that has to run inside that container.
    That is exactly what `CMD` and `ENTRYPOINT` are used for—to tell Docker what the
    start process is and how to start that process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`和`ENTRYPOINT`关键字是特殊的。虽然`Dockerfile`为图像定义的所有其他关键字都是由Docker构建器在构建图像时执行的，但这两个关键字实际上是定义了当从我们定义的图像启动容器时会发生什么。当容器运行时启动一个容器，它需要知道在该容器内部将运行的进程或应用程序是什么。这正是`CMD`和`ENTRYPOINT`用于告诉Docker启动进程是什么以及如何启动该进程。'
- en: Now, the differences between `CMD` and `ENTRYPOINT` are subtle, and honestly,
    most users don't fully understand them or use them in the intended way. Luckily,
    in most cases, this is not a problem and the container will run anyway; it's just
    the handling of it that is not as straightforward as it could be.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`CMD`和`ENTRYPOINT`之间的区别微妙，老实说，大多数用户并不完全理解它们，也不按照预期的方式使用它们。幸运的是，在大多数情况下，这不是问题，容器仍然会运行；只是处理它的方式不像可能那么直接。
- en: 'To better understand how to use the two keywords, let''s analyze what a typical
    Linux command or expression looks like. Let''s take the `ping` utility as an example,
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解如何使用这两个关键字，让我们分析一下典型的Linux命令或表达式是什么样的。让我们以`ping`实用程序为例，如下所示：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the preceding expression, `ping` is the command and `-c 3 8.8.8.8` are the
    parameters to this command. Let''s look at another expression here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述表达式中，`ping`是命令，`-c 3 8.8.8.8`是这个命令的参数。让我们再看一个表达式：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Again, in the preceding expression, `wget` is the command and `-O - http://example.com/downloads/script.sh `are
    the parameters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在上述表达式中，`wget`是命令，`-O - http://example.com/downloads/script.sh`是参数。
- en: 'Now that we have dealt with this, we can get back to `CMD` and `ENTRYPOINT`. `ENTRYPOINT` is
    used to define the command of the expression, while `CMD` is used to define the
    parameters for the command. Thus, a `Dockerfile` using Alpine as the base image
    and defining `ping` as the process to run in the container could look like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经处理了这个问题，我们可以回到`CMD`和`ENTRYPOINT`。`ENTRYPOINT`用于定义表达式的命令，而`CMD`用于定义命令的参数。因此，使用Alpine作为基础镜像并在容器中定义`ping`作为要运行的进程的`Dockerfile`可能如下所示：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For both `ENTRYPOINT` and `CMD`, the values are formatted as a JSON array of
    strings, where the individual items correspond to the tokens of the expression
    that are separated by whitespace. This is the preferred way of defining `CMD` and `ENTRYPOINT`.
    It is also called the *exec* form.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ENTRYPOINT`和`CMD`，值被格式化为一个字符串的JSON数组，其中各个项对应于表达式的标记，这些标记由空格分隔。这是定义`CMD`和`ENTRYPOINT`的首选方式。它也被称为*exec*形式。
- en: 'Alternatively, one can also use what''s called the shell form, as shown here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，也可以使用所谓的shell形式，如下所示：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now build an image called `pinger` from the preceding `Dockerfile`,
    as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从上述`Dockerfile`构建一个名为`pinger`的镜像，如下所示：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we can run a container from the `pinger` image we just created, like
    this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从我们刚刚创建的`pinger`镜像中运行一个容器，就像这样：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The beauty of this is that I can now override the `CMD` part that I have defined
    in the `Dockerfile` (remember, it was `["-c", "3","8.8.8.8"]`) when I create a
    new container by adding the new values at the end of the `docker container run` expression,
    like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的美妙之处在于，我现在可以通过在`docker container run`表达式的末尾添加新值来覆盖我在`Dockerfile`中定义的`CMD`部分（记住，它是`["-c",
    "3","8.8.8.8"]`），就像这样：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This will now cause the container to ping the loopback for 5 seconds.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致容器现在对环回进行ping操作，持续5秒。
- en: 'If we want to override what''s defined in the `ENTRYPOINT` in the `Dockerfile`,
    we need to use the `--entrypoint` parameter in the `docker container run` expression.
    Let''s say we want to execute a shell in the container instead of the `ping` command.
    We could do so by using the following command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要覆盖`Dockerfile`中定义的`ENTRYPOINT`，我们需要在`docker container run`表达式中使用`--entrypoint`参数。假设我们想要在容器中执行shell而不是`ping`命令。我们可以通过使用以下命令来实现：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We will then find ourselves inside the container. Type `exit` to leave the container.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将发现自己在容器内部。键入`exit`离开容器。
- en: 'As I already mentioned, we do not necessarily have to follow best practices
    and define the command through `ENTRYPOINT` and the parameters through `CMD`;
    we can instead enter the whole expression as a value of `CMD` and it will work,
    as shown in the following code block:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我已经提到的，我们不一定要遵循最佳实践，并通过`ENTRYPOINT`定义命令和通过`CMD`定义参数；相反，我们可以将整个表达式作为`CMD`的值输入，它将起作用，如下面的代码块所示：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Here, I have even used the shell form to define the `CMD`. But what does really
    happen in this situation where `ENTRYPOINT` is undefined? If you leave `ENTRYPOINT` undefined,
    then it will have the default value of `/bin/sh -c`, and whatever the value of `CMD`
    is will be passed as a string to the shell command. The preceding definition would
    thereby result in entering the following code to run the process inside the container:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我甚至使用了shell形式来定义`CMD`。但是在`ENTRYPOINT`未定义的情况下会发生什么？如果您未定义`ENTRYPOINT`，那么它将具有默认值`/bin/sh
    -c`，并且`CMD`的任何值都将作为字符串传递给shell命令。因此，前面的定义将导致输入以下代码来运行容器内的进程：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Consequently, `/bin/sh` is the main process running inside the container, and
    it will start a new child process to run the `wget` utility.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`/bin/sh`是在容器内运行的主要进程，并且它将启动一个新的子进程来运行`wget`实用程序。
- en: A complex Dockerfile
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个复杂的Dockerfile
- en: 'We have discussed the most important keywords commonly used in Dockerfiles.
    Let''s look at a realistic, and somewhat complex example of a `Dockerfile`. The
    interested reader might note that it looks very similar to the first `Dockerfile`
    that we presented in this chapter. Here is the content:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Dockerfile中常用的最重要的关键字。让我们看一个现实的，有些复杂的`Dockerfile`的例子。感兴趣的读者可能会注意到，它看起来与我们在本章中呈现的第一个`Dockerfile`非常相似。以下是内容：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: OK; so, what is happening here? Evidently, this is a `Dockerfile` that is used
    to build an image for a Node.js application; we can deduce this from the fact
    that the `node:12.5-stretch` base image is used. Then, the second line is an instruction
    to create an `/app` folder in the filesystem of the image. The third line defines
    the working directory or context in the image to be this new `/app` folder. Then,
    on line four, we copy a `package.json` file into the `/app` folder inside the
    image. After this, on line five, we execute the `npm install` command inside the
    container; remember, our context is the `/app` folder, and thus, `npm` will find
    the `package.json` file there that we copied on line four.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这里发生了什么？显然，这是一个用于构建Node.js应用程序的`Dockerfile`；我们可以从使用`node:12.5-stretch`基础镜像这一事实推断出来。然后，第二行是一个指令，在镜像的文件系统中创建一个/app文件夹。第三行定义了镜像中的工作目录或上下文为这个新的/app文件夹。然后，在第四行，我们将一个`package.json`文件复制到镜像内的/app文件夹中。之后，在第五行，我们在容器内执行`npm
    install`命令；请记住，我们的上下文是/app文件夹，因此npm会在那里找到我们在第四行复制的package.json文件。
- en: After all the Node.js dependencies are installed, we copy the rest of the application
    files from the current folder of the host into the `/app` folder of the image.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装了所有Node.js依赖项之后，我们将应用程序的其余文件从主机的当前文件夹复制到镜像的/app文件夹中。
- en: Finally, on the last two lines, we define what the startup command will be when
    a container is run from this image. In our case, it is `npm start`, which will
    start the Node.js application.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在最后两行，我们定义了当从这个镜像运行容器时启动命令将是什么。在我们的情况下，它是`npm start`，这将启动Node.js应用程序。
- en: Building an image
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建镜像
- en: 'Let''s look at a concrete example and build a simple Docker image, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个具体的例子并构建一个简单的Docker镜像，如下所示：
- en: 'In your home directory, create a `fod `folder (short for **Fundamentals of
    Docker**) with a  `ch04` subfolder in it, and navigate to this folder, like this:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的主目录中，创建一个名为`fod`（代表Docker基础知识）的文件夹，其中包含一个名为`ch04`的子文件夹，并导航到这个文件夹，就像这样：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding folder, create a `sample1` subfolder and navigate to it, like
    this:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上述文件夹中，创建一个`sample1`子文件夹并导航到它，就像这样：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use your favorite editor to create a file called `Dockerfile` inside this sample
    folder, with the following content:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你喜欢的编辑器在这个示例文件夹中创建一个名为`Dockerfile`的文件，并包含以下内容：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 4\. Save the file and exit your editor.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 保存文件并退出编辑器。
- en: '5\. Back in the Terminal window, we can now build a new container image using
    the preceding `Dockerfile` as a manifest or construction plan, like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 回到终端窗口，我们现在可以使用上述`Dockerfile`作为清单或构建计划构建一个新的容器镜像，就像这样：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Please note that there is a period at the end of the preceding command. This
    command means that the Docker builder is creating a new image called `my-centos` using
    the `Dockerfile` that is present in the current directory. Here, the period at
    the end of the command stands for *current directory*. We could also write the
    preceding command as follows, with the same result:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，上述命令末尾有一个句点。这个命令意味着Docker构建器正在使用当前目录中存在的`Dockerfile`创建一个名为`my-centos`的新镜像。这里，命令末尾的句点代表*当前目录*。我们也可以将上述命令写成如下形式，结果是一样的：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: But we can omit the `-f ` parameter, since the builder assumes that the `Dockerfile`
    is literally called `Dockerfile`. We only ever need the `-f` parameter if our
    `Dockerfile` has a different name or is not located in the current directory.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们可以省略`-f`参数，因为构建器假设`Dockerfile`的确切名称为`Dockerfile`。只有当我们的`Dockerfile`具有不同的名称或不位于当前目录时，我们才需要`-f`参数。
- en: 'The preceding command gives us this (shortened) output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令给出了这个（缩短的）输出：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s analyze this output, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个输出，如下所示：
- en: 'First, we have the following line:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有以下一行：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing the builder does is package the files in the current build context,
    excluding the files and folder mentioned in the `.dockerignore` file (if present),
    and sends the resulting `.tar` file to the `Docker daemon`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器的第一件事是打包当前构建上下文中的文件，排除了`.dockerignore`文件中提到的文件和文件夹（如果存在），然后将生成的`.tar`文件发送给`Docker守护程序`。
- en: 'Next, we have the following lines:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有以下几行：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line tells us which step of the `Dockerfile` the builder is currently
    executing. Here, we only have two statements in the `Dockerfile`, and we are on
    S*tep 1* of *2*. We can also see what the content of that section is. Here, it
    is the declaration of the base image, on top of which we want to build our custom
    image. What the builder then does is pull this image from Docker Hub, if it is
    not already available in the local cache. The last line of the preceding code
    snippet indicates which ID the just-built image layer gets assigned by the builder.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 构建器的第一行告诉我们当前正在执行`Dockerfile`的哪个步骤。在这里，我们的`Dockerfile`中只有两个语句，我们正在执行第*2*步中的*步骤
    1*。我们还可以看到该部分的内容是什么。在这里，它是基础镜像的声明，我们要在其上构建自定义镜像。然后构建器会从Docker Hub拉取这个镜像，如果本地缓存中没有的话。前面代码片段的最后一行指示了构建器分配给刚构建的镜像层的ID。
- en: 'Now, follow the next step. I have shortened it even more than the preceding
    one to concentrate on the essential part:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续下一步。我将它比前面的部分更加简短，以便集中在关键部分上：
- en: '[PRE43]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, again, the first line indicates to us that we are in S*tep 2* of *2*.
    It also shows us the respective entry from the `Dockerfile`. On line two, we can
    see `Running in bb726903820c`, which tells us that the builder has created a container
    with ID `bb726903820c`, inside which it executes the `RUN `command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行再次告诉我们，我们正在*步骤 2*中的*步骤 2*。它还向我们显示了`Dockerfile`中的相应条目。在第二行，我们可以看到`Running
    in bb726903820c`，这告诉我们构建器已创建了一个ID为`bb726903820c`的容器，在其中执行了`RUN`命令。
- en: We have omitted the output of the `yum install -y wget `command in the snippet
    since it is not important in this section. When the command is finished, the builder
    stops the container, commits it to a new layer, and then removes the container.
    The new layer has ID `bc070cc81b87`, in this particular case.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在片段中省略了`yum install -y wget`命令的输出，因为在这一部分并不重要。当命令完成时，构建器停止容器，将其提交到一个新层，然后删除容器。在这种特殊情况下，新层的ID是`bc070cc81b87`。
- en: 'At the very end of the output, we encounter the following two lines:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在输出的最后，我们遇到以下两行：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This tells us that the resulting custom image has been given the ID `bc070cc81b87`,
    and has been tagged with the name `my-centos:latest`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，生成的自定义镜像已被赋予ID`bc070cc81b87`，并且已被标记为名称`my-centos:latest`。
- en: 'So, how does the builder work, exactly? It starts with the base image. From
    this base image, once downloaded into the local cache, the builder creates a container
    and runs the first statement of the `Dockerfile` inside this container. Then,
    it stops the container and persists the changes made in the container into a new
    image layer. The builder then creates a new container from the base image and the
    new layer and runs the second statement inside this new container. Once again,
    the result is committed to a new layer. This process is repeated until the very
    last statement in the `Dockerfile` is encountered. After having committed the
    last layer of the new image, the builder creates an ID for this image and tags
    the image with the name we provided in the `build `command, as shown in the following
    screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，构建器的工作原理是什么？它从基本图像开始。一旦将基本图像下载到本地缓存中，构建器就会创建一个容器，并在该容器中运行“Dockerfile”中的第一个语句。然后，它停止容器，并将容器中所做的更改持久化到一个新的图像层中。然后，构建器从基本图像和新层创建一个新的容器，并在该新容器中运行第二个语句。再次，结果被提交到一个新的层中。这个过程重复进行，直到“Dockerfile”中遇到最后一个语句。在提交了新图像的最后一层之后，构建器为该图像创建一个ID，并使用我们在“build”命令中提供的名称对图像进行标记，如下面的屏幕截图所示。
- en: '![](assets/13c9e699-35e5-40dc-b064-d64472d15f03.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/13c9e699-35e5-40dc-b064-d64472d15f03.png)'
- en: The image build process visualized
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化的图像构建过程
- en: Now that we have analyzed how the build process of a Docker image works and
    what steps are involved, let's talk about how to further improve this by introducing
    multi-step builds.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经分析了Docker图像的构建过程以及涉及的步骤，让我们谈谈如何通过引入多步构建来进一步改进这一过程。
- en: Multi-step builds
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多步构建
- en: 'To demonstrate why a `Dockerfile` with multiple build steps is useful, let''s
    make an example `Dockerfile`. Let''s take a Hello World application written in
    C. Here is the code found inside the `hello.c` file:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示为什么具有多个构建步骤的“Dockerfile”是有用的，让我们制作一个示例“Dockerfile”。让我们以C语言编写的“Hello World”应用程序为例。以下是“hello.c”文件中的代码：
- en: '[PRE45]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Follow along to experience the advantages of a multi-step build:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着来体验多步构建的优势：
- en: 'To containerize this application we first write a `Dockerfile` with the following
    content:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将此应用程序容器化，我们首先编写一个带有以下内容的“Dockerfile”：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, let''s build this image:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们构建这个图像：
- en: '[PRE47]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This gives us a fairly long output since the builder has to install the Alpine
    **Software Development Kit** (**SDK**), which, among other tools, contains the
    C++ compiler we need to build the application.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们带来了相当长的输出，因为构建器必须安装Alpine软件开发工具包（SDK），其中包含我们需要构建应用程序的C++编译器等工具。
- en: 'Once the build is done, we can list the image and see its size shown, as follows:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，我们可以列出图像并查看其大小，如下所示：
- en: '[PRE48]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With a size of 176 MB, the resulting image is way too big. In the end, it is
    just a Hello World application. The reason for it being so big is that the image
    not only contains the Hello World binary but also all the tools to compile and
    link the application from the source code. But this is really not desirable when
    running the application, say, in production. Ideally, we only want to have the
    resulting binary in the image and not a whole SDK.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的图像大小为176 MB，太大了。最后，它只是一个“Hello World”应用程序。它如此之大的原因是图像不仅包含“Hello World”二进制文件，还包含从源代码编译和链接应用程序所需的所有工具。但是当在生产环境中运行应用程序时，这确实是不可取的。理想情况下，我们只希望图像中有生成的二进制文件，而不是整个SDK。
- en: 'It is precisely for this reason that we should define Dockerfiles as multi-stage.
    We have some stages that are used to build the final artifacts, and then a final
    stage, where we use the minimal necessary base image and copy the artifacts into
    it. This results in very small Docker images. Have a look at this revised `Dockerfile`:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，我们应该将Dockerfiles定义为多阶段。我们有一些阶段用于构建最终的构件，然后有一个最终阶段，在这个阶段我们使用最小必要的基础镜像，并将构件复制到其中。这样可以得到非常小的Docker镜像。看一下这个修改后的`Dockerfile`：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we have the first stage with a `build` alias that is used to compile
    the application, and then the second stage uses the same `alpine:3.7` base image
    but does not install the SDK, and only copies the binary from the `build` stage,
    using the `--from` parameter, into this final image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有第一个阶段使用`build`别名来编译应用程序，然后第二个阶段使用相同的`alpine:3.7`基础镜像，但不安装SDK，只是使用`--from`参数将二进制文件从`build`阶段复制到最终镜像中：
- en: 'Let''s build the image again, as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再次构建镜像，如下所示：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'When we compare the sizes of the images, we get the following output:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们比较镜像的大小时，得到以下输出：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We have been able to reduce the size from 176 MB down to 4 MB. This is a reduction
    in size by a factor of 40\. A smaller image has many advantages, such as a smaller
    attack surface area for hackers, reduced memory and disk consumption, faster startup
    times of the corresponding containers, and a reduction of the bandwidth needed
    to download the image from a registry, such as Docker Hub.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功将大小从176MB减小到4MB。这是大小减小了40倍。较小的镜像有许多优点，比如对黑客来说攻击面积更小，内存和磁盘消耗更少，相应容器的启动时间更快，以及从Docker
    Hub等注册表下载镜像所需的带宽减少。
- en: Dockerfile best practices
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile最佳实践
- en: 'There are a few recommended best practices to consider when authoring a `Dockerfile`,
    which are as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`Dockerfile`时，有一些推荐的最佳实践需要考虑，如下所示：
- en: First and foremost, we need to consider that containers are meant to be ephemeral.
    By ephemeral, we mean that a container can be stopped and destroyed, and a new
    one built and put in place with an absolute minimum of setup and configuration.
    That means that we should try hard to keep the time that is needed to initialize
    the application running inside the container at a minimum, as well as the time
    needed to terminate or clean up the application.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们需要考虑容器是短暂的。所谓短暂，意味着容器可以停止和销毁，然后新建一个并以绝对最少的设置和配置放置在原位。这意味着我们应该努力将容器内运行的应用程序初始化所需的时间保持在最低限度，以及终止或清理应用程序所需的时间也要尽量减少。
- en: The next best practice tells us that we should order the individual commands
    in the `Dockerfile` so that we leverage caching as much as possible. Building
    a layer of an image can take a considerable amount of time—sometimes many seconds,
    or even minutes. While developing an application, we will have to build the container
    image for our application multiple times. We want to keep the build times at a
    minimum.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个最佳实践告诉我们应该按照尽可能利用缓存的方式来排序`Dockerfile`中的各个命令。构建镜像的一层可能需要相当长的时间，有时甚至需要几秒钟，甚至几分钟。在开发应用程序时，我们将不得不多次为我们的应用程序构建容器镜像。我们希望将构建时间保持在最低限度。
- en: 'When we''re rebuilding a previously built image, the only layers that are rebuilt
    are the ones that have changed, but if one layer needs to be rebuilt, all subsequent
    layers also need to be rebuilt. This is very important to remember. Consider the
    following example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新构建之前构建过的镜像时，只有发生了变化的层才会被重新构建，但如果需要重新构建一个层，所有后续的层也需要重新构建。这一点非常重要。考虑以下例子：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In this example, the `npm install` command on line five of the `Dockerfile`
    usually takes the longest. A classical Node.js application has many external dependencies,
    and those are all downloaded and installed in this step. This can take minutes
    until it is done. Therefore, we want to avoid running `npm install `each time
    we rebuild the image, but a developer changes their source code all the time during
    the development of an application. That means that line four, the result of the `COPY `command,
    changes every time, and thus this layer has to be rebuilt. But as we discussed
    previously, that also means that all subsequent layers have to be rebuilt, which—in
    this case—includes the `npm install` command. To avoid this, we can slightly modify
    the `Dockerfile` and have the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Dockerfile`的第五行上的`npm install`命令通常需要最长的时间。经典的Node.js应用程序有许多外部依赖项，这些依赖项都会在这一步骤中下载和安装。这可能需要几分钟才能完成。因此，我们希望避免在重建图像时每次运行`npm
    install`，但是开发人员在应用程序开发过程中经常更改其源代码。这意味着第四行的`COPY`命令的结果每次都会更改，因此必须重新构建该图层。但正如我们之前讨论的，这也意味着所有后续的图层都必须重新构建，而在这种情况下，包括`npm
    install`命令。为了避免这种情况，我们可以稍微修改`Dockerfile`，并采用以下方式：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: What we have done here is, on line four, we only copied the single file that
    the `npm install` command needs as a source, which is the `package.json `file.
    This file rarely changes in a typical development process. As a consequence, the `npm
    install `command also has to be executed only when the `package.json` file changes.
    All the remaining, frequently changed content is added to the image after the `npm
    install` command.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是，在第四行，我们只复制了`npm install`命令需要的单个文件，即`package.json`文件。在典型的开发过程中，这个文件很少更改。因此，`npm
    install`命令也只有在`package.json`文件更改时才需要执行。所有其余经常更改的内容都是在`npm install`命令之后添加到图像中的。
- en: A further best practice is to keep the number of layers that make up your image
    relatively small. The more layers an image has, the more the graph driver needs
    to work to consolidate the layers into a single root filesystem for the corresponding
    container. Of course, this takes time, and thus the fewer layers an image has,
    the faster the startup time for the container can be.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步的最佳实践是保持构成图像的图层数量相对较少。图像的图层越多，图形驱动程序就需要更多的工作来将这些图层合并为相应容器的单一根文件系统。当然，这需要时间，因此图像的图层数量越少，容器的启动时间就越快。
- en: 'But how can we keep our number of layers low? Remember that in a `Dockerfile`,
    each line that starts with a keyword such as `FROM`, `COPY`, or `RUN` creates
    a new layer. The easiest way to reduce the number of layers is to combine multiple
    individual `RUN` commands into a single one. For example, say that we had the
    following in a `Dockerfile`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何保持图层数量较少呢？请记住，在`Dockerfile`中，每一行以`FROM`、`COPY`或`RUN`等关键字开头的命令都会创建一个新的图层。减少图层数量的最简单方法是将多个单独的`RUN`命令合并为一个。例如，假设我们在`Dockerfile`中有以下内容：
- en: '[PRE54]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We could combine these into a single concatenated expression, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些内容合并为一个单一的连接表达式，如下所示：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The former will generate three layers in the resulting image, while the latter
    only creates a single layer.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 前者将在生成的图像中生成三个图层，而后者只创建一个单一的图层。
- en: 'The next three best practices all result in smaller images. Why is this important?
    Smaller images reduce the time and bandwidth needed to download the image from
    a registry. They also reduce the amount of disk space needed to store a copy locally
    on the Docker host and the memory needed to load the image. Finally, smaller images
    also mean a smaller attack surface for hackers. Here are the best practices mentioned:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三种最佳实践都会导致更小的图像。为什么这很重要？更小的图像减少了从注册表下载图像所需的时间和带宽。它们还减少了在Docker主机上本地存储副本所需的磁盘空间和加载图像所需的内存。最后，更小的图像也意味着对黑客的攻击面更小。以下是提到的最佳实践：
- en: The first best practice that helps to reduce the image size is to use a `.dockerignore` file.
    We want to avoid copying unnecessary files and folders into an image, to keep
    it as lean as possible. A `.dockerignore` file works in exactly the same way as
    a `.gitignore` file, for those who are familiar with Git. In a `.dockerignore` file,
    we can configure patterns to exclude certain files or folders from being included
    in the context when building the image.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个最佳实践有助于减小图像大小的方法是使用`.dockerignore`文件。我们希望避免将不必要的文件和文件夹复制到图像中，以使其尽可能精简。`.dockerignore`文件的工作方式与熟悉Git的人所熟悉的`.gitignore`文件完全相同。在`.dockerignore`文件中，我们可以配置模式来排除某些文件或文件夹在构建图像时包含在上下文中。
- en: The next best practice is to avoid installing unnecessary packages into the
    filesystem of the image. Once again, this is to keep the image as lean as possible.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个最佳实践是避免将不必要的软件包安装到图像的文件系统中。再次强调，这是为了使图像尽可能精简。
- en: Last but not least, it is recommended that you use multi-stage builds so that
    the resulting image is as small as possible and only contains the absolute minimum
    needed to run your application or application service.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，建议您使用多阶段构建，以使生成的图像尽可能小，并且仅包含运行应用程序或应用程序服务所需的绝对最小内容。
- en: Saving and loading images
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存和加载图像
- en: 'The third way to create a new container image is by importing or loading it
    from a file. A container image is nothing more than a tarball. To demonstrate
    this, we can use the `docker image save ` command to export an existing image
    to a tarball, like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新容器图像的第三种方法是通过从文件导入或加载它。容器图像只不过是一个tarball。为了证明这一点，我们可以使用`docker image save`命令将现有图像导出为tarball，就像这样：
- en: '[PRE56]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The preceding command takes our `my-alpine` image that we previously built and
    exports it into a file called  `./backup/my-alpine.tar`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将我们之前构建的`my-alpine`图像导出到名为`./backup/my-alpine.tar`的文件中。
- en: 'If, on the other hand, we have an existing tarball and want to import it as
    an image into our system, we can use the `docker image load` command, as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们有一个现有的tarball并希望将其导入为图像到我们的系统中，我们可以使用`docker image load`命令，如下所示：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the next section, we will discuss how we can create Docker images for existing
    legacy applications, and thus run them in a container, and profit from this.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何为现有的传统应用程序创建Docker图像，并在容器中运行它们，并从中获利。
- en: 'Lift and shift: Containerizing a legacy app'
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 举起和转移：容器化传统应用程序
- en: We can't always start from scratch and develop a brand new application. More
    often than not, we find ourselves with a huge portfolio of traditional applications
    that are up and running in production and provide mission-critical value to the
    company or the customers of the company. Often, those applications are organically
    grown and very complex. Documentation is sparse, and nobody really wants to touch
    such an application. Often, the saying *Never touch a running system* applies.
    Yet, market needs change, and with that arises the need to update or rewrite those
    apps. Often, a complete rewrite is not possible due to the lack of resources and
    time, or due to the excessive cost. What are we going to do about those applications?
    Could we possibly Dockerize them and profit from benefits introduced by containers?
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不总是能够从零开始开发全新的应用程序。往往情况是，我们手头有一大批传统应用程序，它们已经在生产环境中运行，并为公司或客户提供了至关重要的价值。这些应用程序往往是有机发展而来，非常复杂。文档稀缺，没有人真的愿意去碰这样的应用程序。通常情况下，有句话叫做“不要碰正在运行的系统”。然而，市场需求在变化，因此需要更新或重写这些应用程序。由于资源和时间的缺乏，或者成本过高，通常情况下完全重写是不可能的。那么我们该怎么办呢？我们是否可以将它们Docker化，并从容器引入的好处中获益呢？
- en: It turns out we can. In 2017, Docker introduced a program called **Modernize
    Traditional Apps** (**MTA**) to their enterprise customers, which in essence promised
    to help those customers to take their existing or traditional Java and .NET applications
    and containerize them, without the need to change a single line of code. The focus
    of MTA was on Java and .NET applications since those made up the lion's share
    of the traditional applications in a typical enterprise. But the same is possible
    for any application that was written in—say—C, C++, Python, Node.js, Ruby, PHP,
    or Go, to just name a few other languages and platforms.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明我们可以。2017年，Docker为企业客户推出了一个名为“现代化传统应用程序”（MTA）的计划，该计划本质上承诺帮助这些客户将他们现有的或传统的Java和.NET应用程序进行容器化，而无需改变一行代码。MTA的重点是Java和.NET应用程序，因为它们在典型企业中占据了绝大部分传统应用程序的份额。但对于任何使用其他语言和平台编写的应用程序，比如C、C++、Python、Node.js、Ruby、PHP或Go等，也是可能的。
- en: Let's imagine such a legacy application for a moment. Assume we have an old
    Java application written 10 years ago, and continuously updated during the following
    5 years. The application is based on Java SE 6, which came out in December 2006\.
    It uses environment variables and property files for configuration. Secrets such
    as username and passwords used in the database connection strings are pulled from
    a secrets keystore, such as HashiCorp's Vault.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下这样一个遗留应用程序。假设我们有一个10年前编写的旧Java应用程序，并在接下来的5年中不断更新。该应用程序基于2006年12月发布的Java
    SE 6。它使用环境变量和属性文件进行配置。数据库连接字符串中使用的用户名和密码等机密信息是从诸如HashiCorp的Vault之类的机密存储库中提取的。
- en: Analysis of external dependencies
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对外部依赖关系的分析。
- en: One of the first steps in the modernization process is to discover and list
    all external dependencies of the legacy application.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现代化过程中的第一步之一是发现和列出遗留应用程序的所有外部依赖关系。
- en: 'We need to ask ourselves questions like the following:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要问自己一些类似以下的问题：
- en: Does it use a database? If yes, which one? What does the connection string look
    like?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否使用数据库？如果是，是哪种数据库？连接字符串是什么样的？
- en: Does it use external APIs such as credit card approval or geo-mapping APIs?
    What are the API keys and key secrets?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否使用外部API，比如信用卡批准或地理映射API？API密钥和密钥机密是什么？
- en: Is it consuming from or publishing to an **Enterprise Service Bus** (**ESB**)?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它是否从企业服务总线（ESB）中消费或发布？
- en: These are just a few possible dependencies that come to mind. Many more exist.
    These are the seams of the application to the outer world, and we need to be aware
    of them and create an inventory.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是我想到的一些可能的依赖关系。还有更多存在。这些是应用程序与外部世界的接缝，我们需要意识到它们并创建清单。
- en: Source code and build instructions
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 源代码和构建说明
- en: The next step is to locate all the source code and other assets, such as images
    and CSS and HTML files that are part of the application. Ideally, they should
    be located in a single folder. This folder will be the root of our project and
    can have as many subfolders as needed. This project root folder will be the context
    during the build of the container image we want to create for our legacy application.
    Remember, the Docker builder only includes files in the build that are part of
    that context; in our case, that is the root project folder.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定位所有源代码和其他资产，例如应用程序的图像、CSS和HTML文件。理想情况下，它们应该位于一个单独的文件夹中。这个文件夹将是我们项目的根目录，可以有许多子文件夹。这个项目根文件夹将在构建我们想要为我们的遗留应用程序创建的容器映像时成为上下文。请记住，Docker构建器只包括构建中的上下文中的文件；在我们的情况下，这是根项目文件夹。
- en: There is, though, an option to download or copy files during the build from
    different locations, using the `COPY` or `ADD` commands. Please refer to the online
    documentation for the exact details on how to use these two commands. This option
    is useful if the sources for your legacy application cannot be easily contained
    in a single, local folder.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一个选项可以在构建过程中从不同位置下载或复制文件，使用`COPY`或`ADD`命令。有关如何使用这两个命令的确切细节，请参考在线文档。如果您的遗留应用程序的源不能轻松地包含在一个单独的本地文件夹中，这个选项是有用的。
- en: Once we are aware of all the parts that are contributing to the final application,
    we need to investigate how the application is built and packaged. In our case,
    this is most probably done by using Maven. Maven is the most popular build automation
    tool for Java, and has been—and still is—used in most enterprises that are developing
    Java applications. In the case of a legacy .NET application, it is most probably
    done by using the MSBuild tool; and in the case of a C/C++ application, Make would
    most likely be used.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们意识到所有部分都对最终应用程序有贡献，我们需要调查应用程序是如何构建和打包的。在我们的情况下，这很可能是通过使用Maven来完成的。Maven是Java最流行的构建自动化工具，并且在大多数开发Java应用程序的企业中一直被使用。对于遗留的.NET应用程序，很可能是通过使用MSBuild工具来完成；对于C/C++应用程序，可能会使用Make。
- en: Once again, let's extend our inventory and write down the exact build commands
    used. We will need this information later on when authoring the `Dockerfile`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们扩展我们的库存并记录使用的确切构建命令。以后在编写`Dockerfile`时，我们将需要这些信息。
- en: Configuration
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: Applications need to be configured. Information provided during configuration
    can be—for example— the type of application logging to use, connection strings
    to databases, hostnames to services such as ESBs or URIs to external APIs, to
    name just a few.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序需要进行配置。在配置过程中提供的信息可以是，例如，要使用的应用程序日志记录类型、连接到数据库的连接字符串、到诸如ESB的服务的主机名或到外部API的URI等。
- en: 'We can differentiate a few types of configurations, as follows:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种类型的配置，如下所示：
- en: '**Build time**: This is the information needed during the build of the application
    and/or its Docker image. It needs to be available when we create the Docker images.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建时间**：这是在构建应用程序和/或其Docker映像时需要的信息。在我们创建Docker映像时，它需要可用。'
- en: '**Environment**: This is configuration information that varies with the environment
    in which the application is running—for example, DEVELOPMENT versus STAGING or
    PRODUCTION. This kind of configuration is applied to the application when a container
    with the app starts—for example, in production.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境：这是随着应用程序运行环境的不同而变化的配置信息，例如开发环境与暂存或生产环境。这种配置在应用程序启动时被应用，例如在生产环境中。
- en: '**Runtime**: This is information that the application retrieves during runtime,
    such as secrets to access an external API.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时：这是应用程序在运行时检索的信息，例如访问外部API的秘钥。
- en: Secrets
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘钥
- en: Every mission-critical enterprise application needs to deal with secrets in
    some form or another. The most familiar secrets are part of the connection information
    needed to access databases that are used to persist the data produced by or used
    by the application. Other secrets include the credentials needed to access external
    APIs, such as a credit score lookup API. It is important to note that, here, we
    are talking about secrets that have to be provided by the application itself to
    the service providers the application uses or depends on, and not secrets provided
    by the users of the application. The actor here is our application, which needs
    to be authenticated and authorized by external authorities and service providers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 每个关键的企业应用程序都需要以某种形式处理秘钥。最熟悉的秘钥是访问数据库所需的连接信息，这些数据库用于保存应用程序产生或使用的数据。其他秘钥包括访问外部API所需的凭据，例如信用评分查询API。重要的是要注意，这里我们谈论的是应用程序必须提供给应用程序使用或依赖的服务提供商的秘钥，而不是应用程序用户提供的秘钥。这里的主体是我们的应用程序，它需要被外部机构和服务提供商进行认证和授权。
- en: There are various ways traditional applications got their secrets. The worst
    and most insecure way of providing secrets is by hardcoding them or reading them
    from configuration files or environment variables, where they are available in
    cleartext. A much better way is to read the secrets during runtime from a special
    secrets store that persists the secrets encrypted and provides them to the application
    over a secure connection, such as **Transport Layer Security** (**TLS**).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 传统应用程序获取秘钥的方式有很多种。最糟糕和最不安全的提供秘钥的方式是将它们硬编码或从配置文件或环境变量中读取，这样它们就以明文形式可用。一个更好的方式是在运行时从特殊的秘钥存储中读取秘钥，该存储将秘钥加密并通过安全连接（如传输层安全性（TLS））提供给应用程序。
- en: Once again, we need to create an inventory of all secrets that our application
    uses and the way it procures them. Is it through environment variable or configuration
    files, or is it by accessing an external keystore, such as HashiCorp's Vault?
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们需要创建一个清单，列出我们的应用程序使用的所有秘钥以及它们获取秘钥的方式。是通过环境变量或配置文件，还是通过访问外部密钥存储，例如HashiCorp的Vault？
- en: Authoring the Dockerfile
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Dockerfile
- en: 'Once we have a complete inventory of all the items discussed in the previous
    few sections, we are ready to author our `Dockerfile`. But I want to warn you:
    don''t expect this to be a one-shot-and-go task. You may need several iterations
    until you have crafted your final `Dockerfile`. The `Dockerfile` may be rather
    long and ugly-looking, but that''s not a problem, as long as we get a working
    Docker image. We can always fine-tune the `Dockerfile` once we have a working
    version.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了前面几节讨论的所有项目清单，我们就可以开始编写我们的`Dockerfile`。但我想警告你：不要期望这是一个一次性的任务。你可能需要多次迭代，直到你制定出最终的`Dockerfile`。`Dockerfile`可能会相当长，看起来很丑陋，但这并不是问题，只要我们得到一个可用的Docker镜像。一旦我们有了可用的版本，我们总是可以微调`Dockerfile`。
- en: The base image
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础镜像
- en: Let's start by identifying the base image we want to use and build our image
    from. Is there an official Java image available that is compatible with our requirements?
    Remember that our imaginary application is based on Java SE 6\. If such a base
    image is available, then let's use that one. Otherwise, we want to start with
    a Linux distro such as Red Hat, Oracle, or Ubuntu. In the latter case, we will
    use the appropriate package manager of the distro (`yum`, `apt`, or another) to
    install the desired versions of Java and Maven. For this, we use the `RUN` keyword
    in the `Dockerfile`. Remember, `RUN` gives us the possibility to execute any valid
    Linux command in the image during the build process.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先确定我们想要使用和构建图像的基本图像。是否有官方的Java图像可用，符合我们的要求？请记住，我们的虚构应用程序是基于Java SE 6。如果有这样的基本图像可用，那么让我们使用那个。否则，我们想要从Red
    Hat、Oracle或Ubuntu等Linux发行版开始。在后一种情况下，我们将使用发行版的适当软件包管理器（`yum`、`apt`或其他）来安装所需版本的Java和Maven。为此，我们在`Dockerfile`中使用`RUN`关键字。请记住，`RUN`关键字使我们有可能在构建过程中执行图像中的任何有效的Linux命令。
- en: Assembling the sources
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组装源代码
- en: 'In this step, we make sure all source files and other artifacts needed to successfully
    build the application are part of the image. Here, we mainly use the two keywords
    of the `Dockerfile`: `COPY` and `ADD`. Initially, the structure of the source
    inside the image should look exactly the same as on the host, to avoid any build
    problems. Ideally, you would have a single `COPY` command that copies all of the
    root project folder from the host into the image. The corresponding `Dockerfile`
    snippet could then look as simple as this:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们确保所有构建应用程序所需的源文件和其他工件都是图像的一部分。在这里，我们主要使用`Dockerfile`的两个关键字：`COPY`和`ADD`。最初，图像中的源结构应该与主机上的完全相同，以避免任何构建问题。理想情况下，您将有一个单独的`COPY`命令，将主机上的根项目文件夹全部复制到图像中。然后，相应的`Dockerfile`片段可能看起来就像这样简单：
- en: '[PRE58]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Don't forget to also provide a `.dockerignore` file located in the project root
    folder, which lists all the files and (sub-) folders of the project root folder
    that should not be part of the build context.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记还要提供一个位于项目根文件夹中的`.dockerignore`文件，其中列出了项目根文件夹中不应成为构建上下文一部分的所有文件和（子）文件夹。
- en: 'As mentioned earlier, you can also use the `ADD` keyword to download sources
    and other artifacts into the Docker image that are not located in the build context
    but somewhere reachable by a URI, as shown here:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您还可以使用`ADD`关键字将不位于构建上下文中但可以通过URI访问的源代码和其他工件下载到Docker图像中，如下所示：
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This would create a `foobar` folder in the image's working folder and copy all
    the contents from the URI.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在图像的工作文件夹中创建一个`foobar`文件夹，并从URI中复制所有内容。
- en: Building the application
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序
- en: 'In this step, we make sure to create the final artifacts that make up our executable
    legacy application. Often, this is a JAR or WAR file, with or without some satellite
    JARs. This part of the `Dockerfile` should exactly mimic the way you traditionally
    used to build an application before containerizing them. Thus, if using Maven
    as the build automation tool, the corresponding snippet of the `Dockerfile` could
    look as simple as this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们确保创建组成我们可执行的遗留应用程序的最终工件。通常，这是一个JAR或WAR文件，有或没有一些附属的JAR文件。`Dockerfile`的这部分应该完全模仿您在将应用程序容器化之前传统用于构建应用程序的方式。因此，如果使用Maven作为构建自动化工具，`Dockerfile`的相应片段可能看起来就像这样简单：
- en: '[PRE60]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this step, we may also want to list the environment variables the application
    uses, and provide sensible defaults. But never provide default values for environment
    variables that provide secrets to the application such as the database connection
    string! Use the `ENV` keyword to define your variables, like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们可能还想列出应用程序使用的环境变量，并提供合理的默认值。但是永远不要为提供给应用程序的秘密环境变量提供默认值，比如数据库连接字符串！使用`ENV`关键字来定义你的变量，就像这样：
- en: '[PRE61]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, declare all ports that the application is listening on and that need
    to be accessible from outside of the container via the `EXPOSE` keyword, like
    this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 还要声明应用程序正在侦听的所有端口，并且需要通过`EXPOSE`关键字从容器外部访问，就像这样：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Defining the start command
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义启动命令
- en: 'Usually, a Java application is started with a command such as `java -jar <main
    application jar>` if it is a standalone application. If it is a WAR file, then
    the start command may look a bit different. We can thus either define the `ENTRYPOINT`
    or the `CMD` to use this command. Thus, the final statement in our `Dockerfile`
    could look like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Java应用程序是通过诸如`java -jar <主应用程序jar>`这样的命令启动的，如果它是一个独立的应用程序。如果是WAR文件，那么启动命令可能看起来有点不同。因此，我们可以定义`ENTRYPOINT`或`CMD`来使用这个命令。因此，我们的`Dockerfile`中的最终语句可能是这样的：
- en: '[PRE63]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Often, though, this is too simplistic, and we need to execute a few pre-run
    tasks. In this case, we can craft a script file that contains the series of commands
    that need to be executed to prepare the environment and run the application. Such
    a file is often called `docker-entrypoint.sh`, but you are free to name it however
    you want. Make sure the file is executable— for example, with the following:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常情况下这太过简单，我们需要执行一些预运行任务。在这种情况下，我们可以编写一个包含需要执行以准备环境并运行应用程序的一系列命令的脚本文件。这样的文件通常被称为`docker-entrypoint.sh`，但你可以自由地命名它。确保文件是可执行的—例如，使用以下命令：
- en: '[PRE64]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The last line of the `Dockerfile` would then look like this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的最后一行将如下所示：'
- en: '[PRE65]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now that you have been given hints on how to containerize a legacy application,
    it is time to recap and ask ourselves: *Is it really worth the whole effort?*'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经得到了如何将传统应用程序容器化的提示，是时候进行总结并问自己：*真的值得花这么大的努力吗？*
- en: Why bother?
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么费这个劲呢？
- en: 'At this point, I can see you scratching your head and asking yourself: *Why
    bother?* Why should you take on all this seemingly huge effort just to containerize
    a legacy application? What are the benefits?'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我可以看到你正在挠头，问自己：*为什么要费这个劲呢？* 为什么你要花这么大的力气来容器化一个传统应用程序？有什么好处呢？
- en: 'It turns out that the **return on investment** (**ROI**) is huge. Enterprise
    customers of Docker have publicly disclosed at conferences such as DockerCon 2018
    and 2019 that they are seeing these two main benefits of Dockerizing traditional
    applications:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明**投资回报率**（**ROI**）是巨大的。Docker的企业客户在DockerCon 2018和2019等会议上公开披露，他们看到了Docker化传统应用程序的这两个主要好处：
- en: More than a 50% saving in maintenance costs.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护成本节约超过50%。
- en: Up to a 90% reduction in the time between the deployments of new releases.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新版本发布之间的时间减少了90%。
- en: The costs saved by reducing the maintenance overhead can be directly reinvested
    and used to develop new features and products. The time saved during new releases
    of traditional applications makes a business more agile and able to react to changing
    customer or market needs more quickly.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过减少维护开销节省的成本可以直接再投资，并用于开发新功能和产品。在传统应用程序的新版本发布期间节省的时间使企业更具敏捷性，能够更快地对客户或市场需求的变化做出反应。
- en: Now that we have discussed at length how to build Docker images, it is time
    to learn how we can ship those images through the various stages of the software
    delivery pipeline.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细讨论了如何构建Docker图像，是时候学习如何通过软件交付流程的各个阶段来部署这些图像了。
- en: Sharing or shipping images
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享或部署图像
- en: To be able to ship our custom image to other environments, we need to first
    give it a globally unique name. This action is often called *tagging* an image.
    We then need to publish the image to a central location from which other interested
    or entitled parties can pull it. These central locations are called *image registries*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够将我们的自定义图像部署到其他环境中，我们需要首先为其指定一个全局唯一的名称。这个操作通常被称为给图像打标签。然后我们需要将图像发布到一个中央位置，其他感兴趣或有权限的方可以从中拉取。这些中央位置被称为*图像注册表*。
- en: Tagging an image
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 给图像打标签
- en: 'Each image has a so-called *tag*. A tag is often used to version images, but
    it has a broader reach than just being a version number. If we do not explicitly
    specify a tag when working with images, then Docker automatically assumes we''re
    referring to the `latest` tag. This is relevant when pulling an image from Docker
    Hub, as in the following example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像都有一个所谓的*标签*。标签通常用于对图像进行版本控制，但它的作用远不止于版本号。如果在使用图像时没有明确指定标签，那么Docker会自动假定我们指的是`latest`标签。这在从Docker
    Hub拉取图像时很重要，就像下面的例子一样：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The preceding command will pull the `alpine:latest` image from Docker Hub.
    If we want to explicitly specify a tag, we do so like this:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将从Docker Hub拉取`alpine:latest`图像。如果我们想要明确指定一个标签，可以这样做：
- en: '[PRE67]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This will now pull the `alpine `image that has been tagged with `3.5`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将拉取已标记为`3.5`的`alpine`图像。
- en: Image namespaces
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像命名空间
- en: So far, we have been pulling various images and haven't been worrying so much
    about where those images originated from. Your Docker environment is configured
    so that, by default, all images are pulled from Docker Hub. We also only pulled
    so-called official images from Docker Hub, such as `alpine` or `busybox`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在拉取各种图像，并没有太在意这些图像的来源。您的Docker环境配置为，默认情况下所有图像都是从Docker Hub拉取的。我们还只从Docker
    Hub拉取了所谓的官方图像，比如`alpine`或`busybox`。
- en: 'Now, it is time to widen our horizon a bit and learn about how images are namespaced.
    The most generic way to define an image is by its fully qualified name, which
    looks as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候稍微扩大一下视野，了解图像的命名空间是如何工作的了。定义图像最通用的方式是通过其完全限定名称，如下所示：
- en: '[PRE68]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Let''s look at this in a bit more detail:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下：
- en: '`<registry URL>`: This is the URL to the registry from which we want to pull
    the image. By default, this is `docker.io`. More generally, this could be `https://registry.acme.com`.'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<registry URL>`：这是我们想要从中拉取图像的注册表的URL。默认情况下，这是`docker.io`。更一般地说，这可能是`https://registry.acme.com`。'
- en: 'Other than Docker Hub, there are quite a few public registries out there that
    you could pull images from. The following is a list of some of them, in no particular
    order:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Docker Hub，还有很多公共注册表可以从中拉取图像。以下是其中一些的列表，没有特定顺序：
- en: Google, at [https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
  id: totrans-332
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google，在[https://cloud.google.com/container-registry](https://cloud.google.com/container-registry)
- en: Amazon AWS **Amazon Elastic Container Registry** (**ECR**), at [https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon AWS **Amazon Elastic Container Registry** (**ECR**)，在[https://aws.amazon.com/ecr/](https://aws.amazon.com/ecr/)
- en: Microsoft Azure, at [https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure，在[https://azure.microsoft.com/en-us/services/container-registry/](https://azure.microsoft.com/en-us/services/container-registry/)
- en: Red Hat, at [https://access.redhat.com/containers/](https://access.redhat.com/containers/)
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Red Hat，在[https://access.redhat.com/containers/](https://access.redhat.com/containers/)
- en: Artifactory, at [https://jfrog.com/integration/artifactory-docker-registry/](https://jfrog.com/integration/artifactory-docker-registry/)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artifactory，网址为[https://jfrog.com/integration/artifactory-docker-registry/](https://jfrog.com/integration/artifactory-docker-registry/)
- en: '`<User or Org>`: This is the private Docker ID of either an individual or an
    organization defined on Docker Hub—or any other registry, for that matter—such
    as `microsoft` or `oracle`.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<用户或组织>`：这是在Docker Hub上定义的个人或组织的私有Docker ID，或者其他注册表，比如`microsoft`或`oracle`。'
- en: '`<name>`: This is the name of the image, which is often also called a repository.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<名称>`：这是镜像的名称，通常也称为存储库。'
- en: '`<tag>`: This is the tag of the image.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<tag>`：这是镜像的标签。'
- en: 'Let''s look at an example, as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，如下：
- en: '[PRE69]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we have an image, `web-app`, that is tagged with version `1.0` and belongs
    to the `engineering` organization on the private registry at `https://registry.acme.com`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个带有版本`1.0`标签的`web-app`镜像，属于`https://registry.acme.com`上的`engineering`组织的私有注册表。
- en: 'Now, there are some special conventions:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一些特殊的约定：
- en: If we omit the registry URL, then Docker Hub is automatically taken.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们省略了注册表URL，那么Docker Hub会自动被使用。
- en: If we omit the tag, then `latest` is taken.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们省略了标签，那么将使用`latest`。
- en: If it is an official image on Docker Hub, then no user or organization namespace
    is needed.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它是Docker Hub上的官方镜像，那么不需要用户或组织命名空间。
- en: 'Here are a few samples in tabular form:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些以表格形式呈现的示例：
- en: '| **Image** | **Description** |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| **镜像** | **描述** |'
- en: '| `alpine` | Official alpine image on Docker Hub with the latest tag. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `alpine` | Docker Hub上的官方`alpine`镜像，带有`latest`标签。 |'
- en: '| `ubuntu:19.04` | Official `ubuntu` image on Docker Hub with the `19.04` tag
    or version. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `ubuntu:19.04` | Docker Hub上的官方`ubuntu`镜像，带有`19.04`标签或版本。 |'
- en: '| `microsoft/nanoserver` | `nanoserver` image of Microsoft on Docker Hub with
    the `latest` tag. |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `microsoft/nanoserver` | Microsoft在Docker Hub上的`nanoserver`镜像，带有`latest`标签。
    |'
- en: '| `acme/web-api:12.0` | `web-api` image version `12.0` associated with the `acme` org.
    The image is on Docker Hub. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `acme/web-api:12.0` | 与`acme`组织相关联的`web-api`镜像版本`12.0`。该镜像在Docker Hub上。 |'
- en: '| `gcr.io/gnschenker/sample-app:1.1` | `sample-app` image with the `1.1` tag belonging
    to an individual with the `gnschenker` ID on Google''s container registry. |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `gcr.io/gnschenker/sample-app:1.1` | `sample-app`镜像，带有`1.1`标签，属于Google容器注册表上的`gnschenker`ID。
    |'
- en: Now that we know how the fully qualified name of a Docker image is defined and
    what its parts are, let's talk about some special images we can find on Docker
    Hub.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Docker镜像的完全限定名称是如何定义的，以及它的组成部分是什么，让我们来谈谈在Docker Hub上可以找到的一些特殊镜像。
- en: Official images
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 官方镜像
- en: In the preceding table, we mentioned *official image* a few times. This needs an
    explanation. Images are stored in repositories on the Docker Hub registry. Official
    repositories are a set of repositories hosted on Docker Hub that are curated by
    individuals or organizations that are also responsible for the software packaged
    inside the image. Let's look at an example of what that means. There is an official
    organization behind the Ubuntu Linux distro. This team also provides official
    versions of Docker images that contain their Ubuntu distros.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，我们多次提到了*官方镜像*。这需要解释。镜像存储在Docker Hub注册表上的存储库中。官方存储库是由个人或组织策划的一组存储库，他们还负责镜像内打包的软件。让我们看一个例子来解释这意味着什么。Ubuntu
    Linux发行版背后有一个官方组织。该团队还提供包含他们Ubuntu发行版的官方版本的Docker镜像。
- en: Official images are meant to provide essential base OS repositories, images
    for popular programming language runtimes, frequently used data storage, and other
    important services.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 官方镜像旨在提供基本的操作系统存储库、流行编程语言运行时的镜像、经常使用的数据存储以及其他重要服务。
- en: Docker sponsors a team whose task it is to review and publish all those curated
    images in public repositories on Docker Hub. Furthermore, Docker scans all official
    images for vulnerabilities.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Docker赞助一个团队，他们的任务是审查并发布Docker Hub上公共存储库中的所有精选图像。此外，Docker还扫描所有官方图像以查找漏洞。
- en: Pushing images to a registry
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像推送到注册表
- en: Creating custom images is all well and good, but at some point, we want to actually
    share or ship our images to a target environment, such as a test, **quality assurance**
    (**QA**), or production system. For this, we typically use a container registry.
    One of the most popular and public registries out there is Docker Hub. It is configured
    as a default registry in your Docker environment, and it is the registry from
    which we have pulled all our images so far.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义图像当然很好，但在某个时候，我们希望实际上将我们的图像共享或发布到目标环境，比如测试、质量保证（QA）或生产系统。为此，我们通常使用容器注册表。其中最受欢迎和公共的注册表之一是Docker
    Hub。它在您的Docker环境中配置为默认注册表，并且是我们迄今为止拉取所有图像的注册表。
- en: On a registry, one can usually create personal or organizational accounts. For
    example, my personal account at Docker Hub is `gnschenker`. Personal accounts
    are good for personal use. If we want to use the registry professionally, then
    we'll probably want to create an organizational account, such as `acme`, on Docker
    Hub. The advantage of the latter is that organizations can have multiple teams.
    Teams can have differing permissions.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册表上，通常可以创建个人或组织帐户。例如，我的Docker Hub个人帐户是`gnschenker`。个人帐户适用于个人使用。如果我们想专业使用注册表，那么我们可能会想在Docker
    Hub上创建一个组织帐户，比如`acme`。后者的优势在于组织可以拥有多个团队。团队可以具有不同的权限。
- en: 'To be able to push an image to my personal account on Docker Hub, I need to
    tag it accordingly:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够将图像推送到Docker Hub上的个人帐户，我需要相应地对其进行标记：
- en: 'Let''s say I want to push the latest version of Alpine to my account and give
    it a tag of `1.0`. I can do this in the following way:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我想将Alpine的最新版本推送到我的帐户并给它打上`1.0`的标签。我可以通过以下方式做到这一点：
- en: '[PRE70]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Now, to be able to push the image, I have to log in to my account, as follows:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了能够推送图像，我必须登录到我的帐户，如下所示：
- en: '[PRE71]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After a successful login, I can then push the image, like this:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功登录后，我可以像这样推送图像：
- en: '[PRE72]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'I will see something similar to this in the Terminal:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在终端中看到类似于这样的内容：
- en: '[PRE73]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For each image that we push to Docker Hub, we automatically create a repository.
    A repository can be private or public. Everyone can pull an image from a public
    repository. From a private repository, an image can only be pulled if one is logged
    in to the registry and has the necessary permissions configured.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们推送到Docker Hub的每个图像，我们会自动创建一个存储库。存储库可以是私有的或公共的。每个人都可以从公共存储库中拉取图像。从私有存储库中，只有在登录到注册表并配置了必要的权限后，才能拉取图像。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have discussed in detail what container images are and how
    we can build and ship them. As we have seen, there are three different ways that
    an image can be created—either manually, automatically, or by importing a tarball
    into the system. We also learned some of the best practices commonly used when
    building custom images.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细讨论了容器图像是什么以及我们如何构建和发布它们。正如我们所见，图像可以通过三种不同的方式创建——手动、自动或通过将tarball导入系统。我们还学习了构建自定义图像时通常使用的一些最佳实践。
- en: In the next chapter, we're going to introduce Docker volumes that can be used
    to persist the state of a container. We'll also show how to define individual
    environment variables for the application running inside the container, as well
    as how to use files containing whole sets of configuration settings.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍Docker卷，用于持久化容器的状态。我们还将展示如何为容器内运行的应用程序定义单独的环境变量，以及如何使用包含整套配置设置的文件。
- en: Questions
  id: totrans-375
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题以评估您的学习进度：
- en: How would you create a Dockerfile that inherits from Ubuntu version `19.04`,
    and that installs `ping` and runs `ping` when a container starts? The default
    address to `ping` will be `127.0.0.1`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个继承自Ubuntu版本`19.04`的Dockerfile，安装`ping`并在容器启动时运行`ping`？`ping`的默认地址将是`127.0.0.1`。
- en: How would you create a new container image that uses `alpine:latest` and installs `curl`?
    Name the new image `my-alpine:1.0`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个使用`alpine:latest`并安装`curl`的新容器镜像？将新镜像命名为`my-alpine:1.0`。
- en: Create a `Dockerfile` that uses multiple steps to create an image of a Hello
    World app of minimal size, written in C or Go.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Dockerfile`，使用多个步骤创建一个用C或Go编写的`Hello World`应用程序的最小尺寸镜像。
- en: Name three essential characteristics of a Docker container image.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出三个Docker容器镜像的基本特征。
- en: You want to push an image named `foo:1.0` to your `jdoe` personal account on
    Docker Hub. Which of the following is the right solution?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您想将名为`foo:1.0`的镜像推送到Docker Hub上的`jdoe`个人账户。以下哪个是正确的解决方案？
- en: A. `$ docker container push foo:1.0` B. `$ docker image tag foo:1.0 jdoe/foo:1.0`
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: A. `$ docker container push foo:1.0` B. `$ docker image tag foo:1.0 jdoe/foo:1.0`
- en: '`$ docker image push jdoe/foo:1.0` C. `$ docker login -u jdoe -p <your password>`'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push jdoe/foo:1.0` C. `$ docker login -u jdoe -p <your password>`'
- en: '`$ docker image tag foo:1.0 jdoe/foo:1.0`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image tag foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker image push jdoe/foo:1.0` D. `$ docker login -u jdoe -p <your password>`'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push jdoe/foo:1.0` D. `$ docker login -u jdoe -p <your password>`'
- en: '`$ docker container tag foo:1.0 jdoe/foo:1.0`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker container tag foo:1.0 jdoe/foo:1.0`'
- en: '`$ docker container push jdoe/foo:1.0` E. `$ docker login -u jdoe -p <your
    password>`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker container push jdoe/foo:1.0` E. `$ docker login -u jdoe -p <your
    password>`'
- en: '`$ docker image push foo:1.0 jdoe/foo:1.0`'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker image push foo:1.0 jdoe/foo:1.0`'
- en: Further reading
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following list of references gives you some material that dives more deeply
    into the topic of authoring and building container images:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下参考资料列表提供了一些更深入探讨容器镜像创作和构建主题的材料：
- en: Best practices for writing Dockerfiles, at[http://dockr.ly/22WiJiO](http://dockr.ly/22WiJiO)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Dockerfile的最佳实践，网址为[http://dockr.ly/22WiJiO](http://dockr.ly/22WiJiO)
- en: Using multi-stage builds, at[http://dockr.ly/2ewcUY3](http://dockr.ly/2ewcUY3)
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建，网址为[http://dockr.ly/2ewcUY3](http://dockr.ly/2ewcUY3)
- en: About storage drivers, at[http://dockr.ly/1TuWndC](http://dockr.ly/1TuWndC)
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于存储驱动程序，网址为[http://dockr.ly/1TuWndC](http://dockr.ly/1TuWndC)
- en: Graphdriver plugins, at[http://dockr.ly/2eIVCab](http://dockr.ly/2eIVCab)
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Graphdriver插件，网址为[http://dockr.ly/2eIVCab](http://dockr.ly/2eIVCab)
- en: User-guided caching in Docker for Mac, at[http://dockr.ly/2xKafPf](http://dockr.ly/2xKafPf)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker for Mac中进行用户引导缓存，网址为[http://dockr.ly/2xKafPf](http://dockr.ly/2xKafPf)
