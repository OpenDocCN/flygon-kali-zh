- en: Chapter 3. Interfaces, Classes and Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。接口、类和泛型
- en: 'We have already seen how TypeScript uses basic types, inferred types, and function
    signatures to bring a strongly typed development experience to JavaScript. TypeScript
    also introduces three concepts borrowed from other object-oriented languages:
    interfaces, classes and generics. In this chapter, we will look at these object-oriented
    concepts, how they are used in TypeScript, and what benefits they bring to JavaScript
    programmers.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到TypeScript如何使用基本类型、推断类型和函数签名来为JavaScript带来强类型的开发体验。TypeScript还引入了从其他面向对象语言借鉴的三个概念：接口、类和泛型。在本章中，我们将看看这些面向对象的概念在TypeScript中的使用，以及它们为JavaScript程序员带来的好处。
- en: The first section of this chapter is intended for readers that are using TypeScript
    for the first time, and covers interfaces, classes and inheritance from the ground
    up. The second section of this chapter builds on this knowledge, and shows how
    to create and use the Factory Design Pattern. The third section of this chapter
    deals with generics.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分适用于首次使用TypeScript的读者，并从基础开始介绍接口、类和继承。本章的第二部分建立在这些知识之上，展示如何创建和使用工厂设计模式。本章的第三部分涉及泛型。
- en: If you have experience with TypeScript, are actively using interfaces and classes,
    understand inheritance, and are comfortable with the lexical scoping rules as
    applied to the `this` parameter, then you may be more interested in the later
    sections on the Factory Design Pattern, or generics.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有TypeScript的经验，正在积极使用接口和类，了解继承，并且对应用于`this`参数的词法作用域规则感到满意，那么您可能对后面关于工厂设计模式或泛型的部分更感兴趣。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Interfaces
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Closures
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: The Factory Design Pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂设计模式
- en: Class modifiers, static functions and properties
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类修饰符、静态函数和属性
- en: Generics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Runtime type checking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时类型检查
- en: Interfaces
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: An interface provides us with a mechanism to define what properties and methods
    an object must implement. If an object adheres to an interface, it is said that
    the object implements the interface. TypeScript will generate compile errors earlier
    in our code if an object does not implement an interface properly. The interface
    is also another way of defining a custom type, and gives us, among other things,
    an early indication—at the time we are constructing an object—that the object
    does not have the properties and methods that we require.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接口为我们提供了一种机制来定义对象必须实现的属性和方法。如果一个对象遵循一个接口，那么就说该对象实现了该接口。如果一个对象没有正确实现接口，TypeScript会在我们的代码中更早地生成编译错误。接口也是定义自定义类型的另一种方式，除其他外，它在我们构造对象时提供了一个早期指示，即对象没有我们需要的属性和方法。
- en: 'Consider the following TypeScript code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下TypeScript代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We start with an interface named `IComplexType` that has an `id` and a `name`
    property. The `id` property is strongly typed to be of type `number`, and the
    `name` property is of type `string`. We then create a variable named `complexType`,
    and use the `:` type syntax to indicate that this variable is of type `IComplexType`.
    The next variable, named `complexType_2`, also strongly types this variable to
    be of type `IComplexType`. We then compare the `complexType` and `complexType_2`
    variables, and log a message to the console if these objects are the same. This
    code, however, will generate a compile error:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`IComplexType`的接口开始，该接口具有`id`和`name`属性。`id`属性被强类型为`number`类型，`name`属性为`string`类型。然后我们创建一个名为`complexType`的变量，并使用`:`类型语法来指示该变量的类型为`IComplexType`。下一个变量名为`complexType_2`，也将该变量强类型为`IComplexType`类型。然后我们比较`complexType`和`complexType_2`变量，并在控制台中记录一条消息，如果这些对象相同。然而，这段代码将生成一个编译错误：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This compile error tells us that the `complexType_2` variable must conform
    to the `IComplexType` interface. The `complexType_2` variable has an `id` property,
    but it does not have a `name` property. To fix this error, and to ensure that
    the variable implements the `IComplexType` interface, we simply need to add a
    `name` property, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这个编译错误告诉我们`complexType_2`变量必须符合`IComplexType`接口。`complexType_2`变量有一个`id`属性，但它没有一个`name`属性。为了解决这个错误，并确保变量实现了`IComplexType`接口，我们只需要添加一个`name`属性，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Even though we have an extra `description` property, the `IComplexType` interface
    only mentions the `id` and `name` properties—so as long as we have those, the
    object is said to be implementing the `IComplexType` interface.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们有额外的`description`属性，`IComplexType`接口只提到了`id`和`name`属性，所以只要我们有这些属性，对象就被认为是实现了`IComplexType`接口。
- en: Interfaces are a compile-time language feature of TypeScript, and the compiler
    does not generate any JavaScript code from interfaces that you include in your
    TypeScript projects. Interfaces are only used by the compiler for type checking
    during the compilation step.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是TypeScript的一个编译时语言特性，编译器不会从您在TypeScript项目中包含的接口生成任何JavaScript代码。接口仅在编译步骤期间由编译器用于类型检查。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this book, we will be sticking to a simple naming convention for interfaces,
    and that is to prefix the interface name with the letter `I`. Using this naming
    scheme helps when dealing with large projects where code is spread across multiple
    files. Seeing anything prefixed with `I` in your code helps you distinguish it
    as an interface immediately. You can, however, call your interfaces anything.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将坚持使用一个简单的接口命名约定，即在接口名称前加上字母`I`。使用这种命名方案有助于处理代码分布在多个文件的大型项目。在代码中看到任何以`I`为前缀的东西，可以立即将其识别为接口。但是，您可以随意命名您的接口。
- en: Classes
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A class is a definition of an object, what data it holds, and what operations
    it can perform. Classes and interfaces form a cornerstone of the principles of
    object-oriented programming, and often work together in design patterns. A design
    pattern is a simple programming structure that has been proven to be the best
    way of tackling a specific programming task. More on design patterns later.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 类是对象的定义，它持有什么数据，以及可以执行什么操作。类和接口是面向对象编程原则的基石，并且通常在设计模式中一起工作。设计模式是一种简单的编程结构，已被证明是解决特定编程任务的最佳方式。稍后会详细介绍设计模式。
- en: 'Let''s recreate our previous code sample using classes:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用类重新创建我们之前的代码示例：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Firstly, we have our interface definition (`IComplexType`), which has an `id`
    and a `name` property, as well as a `print` function. We then define a class named
    `ComplexType` that implements the `IComplexType` interface. In other words, the
    class definition for `ComplexType` must match the `IComplexType` interface definition.
    Note that the class definition does not create a variable—it simply defines the
    structure of the class. We then create a variable named `complexType`, and then
    assign to this variable a new instance of the `ComplexType` class. This line is
    said to be creating an instance of the class. Once we have an instance of the
    class, we can set the values of the class properties. The last section of the
    code simply calls the `print` function of each class inside a `window.onload`
    function. The output of this code is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有我们的接口定义（`IComplexType`），它有一个 `id` 和一个 `name` 属性，以及一个 `print` 函数。然后我们定义了一个名为
    `ComplexType` 的类，该类实现了 `IComplexType` 接口。换句话说，`ComplexType` 的类定义必须与 `IComplexType`
    接口定义相匹配。请注意，类定义不会创建一个变量——它只是定义了类的结构。然后我们创建了一个名为 `complexType` 的变量，然后将一个 `ComplexType`
    类的新实例分配给这个变量。这行代码被称为创建类的实例。一旦我们有了类的实例，我们就可以设置类属性的值。代码的最后部分只是在 `window.onload`
    函数中调用每个类的 `print` 函数。这段代码的输出如下：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Class constructors
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类构造函数
- en: 'Classes can accept parameters during their initial construction. If we look
    at the previous code sample, our calls to create an instance of a `ComplexType`
    class, and then set its properties, can be streamlined into a single line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以在初始构造时接受参数。如果我们看一下之前的代码示例，我们对 `ComplexType` 类的实例进行调用，然后设置其属性的调用可以简化为一行代码：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This version of the code is passing the `id` and `name` properties as parts
    of the class constructor. Our class definition, however, will need to include
    a new function, named `constructor`, in order to accept this syntax. Our updated
    class definition would then become:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的代码将 `id` 和 `name` 属性作为类构造函数的一部分进行传递。然而，我们的类定义需要包括一个新的函数，名为 `constructor`，以接受这种语法。我们更新后的类定义将变成：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the `constructor` function. It is a normal function definition, but uses
    the `constructor` keyword and accepts an `idArg`, and `nameArg` as parameters.
    These arguments are strongly typed to be of type `number` and `string` respectively.
    The internal `id` property of the `ComplexType` class is then assigned the `idArg`
    parameter value. Note the syntax used to reference the `id` property: `this.id`.
    Classes use the same `this` syntax that objects do to access internal properties.
    If we attempt to use an internal class property without using the `this` keyword,
    TypeScript will generate compile errors.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `constructor` 函数。它是一个普通的函数定义，但使用了 `constructor` 关键字，并接受 `idArg` 和 `nameArg`
    作为参数。这些参数被强类型为 `number` 和 `string` 类型。然后将 `ComplexType` 类的内部 `id` 属性赋值为 `idArg`
    参数值。注意用于引用 `id` 属性的语法：`this.id`。类使用与对象相同的 `this` 语法来访问内部属性。如果我们尝试在不使用 `this` 关键字的情况下使用内部类属性，TypeScript
    将生成编译错误。
- en: Class functions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类函数
- en: 'All functions within a class adhere to the syntax and rules that we covered
    in the previous chapter on functions. As a refresher of these rules, all class
    functions can:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的所有函数都遵循我们在上一章关于函数中涵盖的语法和规则。作为这些规则的复习，所有类函数都可以：
- en: Be strongly typed
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强类型
- en: Use the `any` keyword to relax strong typing
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `any` 关键字来放宽强类型
- en: Have optional parameters
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可选参数
- en: Have default parameters
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有默认参数
- en: Use argument arrays, or the rest parameter syntax
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用参数数组或剩余参数语法
- en: Allow function callbacks and specify the function callback signature
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许函数回调并指定函数回调签名
- en: Allow function overloads
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许函数重载
- en: 'Let''s modify our `ComplexType` class definition, and include an example of
    each of these rules:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的 `ComplexType` 类定义，并包括这些规则的示例：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first thing to note is the `constructor` function. Our class definition
    is using function overloading for the `constructor` function, allowing the class
    to be constructed using either a `number` and a `string`, or two strings. The
    following code shows how we would use each of these `constructor` definitions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意的第一件事是 `constructor` 函数。我们的类定义正在使用函数重载来定义 `constructor` 函数，允许使用一个 `number`
    和一个 `string` 或两个字符串来构造类。以下代码展示了如何使用这些 `constructor` 定义：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `complexType` variable uses the `number,` `string` variant of the constructor
    function, and the `complexType_2` variable uses the `string,string` variant. The
    `complexType_3` variable will generate a compile error, as we are not allowing
    a constructor to use a `boolean,boolean` variant. You may argue, however, that
    the last constructor function specifies an `any,any` variant, and this should
    allow for our `boolean,boolean` usage. Just remember that when using constructor
    overloads, the actual constructor implementation must use types that are compatible
    with any variant of the constructor overloads. Our constructor implementation,
    then, must use an `any,any` variant. Because we are using constructor overloads,
    however, this `any,any` variant is hidden by the compiler in favor of our overloaded
    signatures.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`complexType`变量使用构造函数的`number,` `string`变体，`complexType_2`变量使用`string,string`变体。`complexType_3`变量将生成编译错误，因为我们不允许构造函数使用`boolean,boolean`变体。然而，您可能会争辩说，最后一个构造函数指定了`any,any`变体，这应该允许我们使用`boolean,boolean`。只要记住，使用构造函数重载时，实际的构造函数实现必须使用与构造函数重载的任何变体兼容的类型。然后，我们的构造函数实现必须使用`any,any`变体。然而，由于我们使用构造函数重载，这个`any,any`变体被编译器隐藏，以支持我们的重载签名。'
- en: 'The following code samples show how we would use the rest of the functions
    that we have defined for this class. Let''s start with the `usingTheAnyKeyword`
    function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了我们如何使用我们为这个类定义的其余函数。让我们从`usingTheAnyKeyword`函数开始：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first call in this sample is using a boolean value to call the `usingTheAnyKeyword`
    function, and the second is using an arbitrary object. Both of these function
    calls are valid, as the parameter `arg1` is defined with the `any` type. Next,
    the `usingOptionalParameters` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的第一个调用使用布尔值调用`usingTheAnyKeyword`函数，第二个调用使用任意对象。这两个函数调用都是有效的，因为参数`arg1`定义为`any`类型。接下来是`usingOptionalParameters`函数：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we are calling the `usingOptionalParameters` function firstly with a
    single argument, and then without any arguments. Again, these calls are valid,
    as the `optionalArg1` argument is marked as optional. Now for the `usingDefaultParameters`
    function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先使用单个参数调用`usingOptionalParameters`函数，然后再次调用时不使用任何参数。同样，这些调用都是有效的，因为`optionalArg1`参数被标记为可选。现在是`usingDefaultParameters`函数：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Both of these calls to the `usingDefaultParameters` function are valid. The
    first call will override the default value of 0, and the second call—without an
    argument—will use the default value of 0\. Next up is the `usingRestSyntax` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对`usingDefaultParameters`函数的这两个调用都是有效的。第一个调用将覆盖默认值0，而第二个调用——没有参数——将使用默认值0。接下来是`usingRestSyntax`函数：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our rest function, `usingRestSyntax`, can be called with any number of arguments,
    as we are using the rest parameter syntax to hold these arguments in an array.
    Both of these calls are valid. Finally, let''s look at the `usingFunctionCallbacks`
    function:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的剩余函数`usingRestSyntax`可以使用任意数量的参数进行调用，因为我们使用剩余参数语法将这些参数保存在一个数组中。这两个调用都是有效的。最后，让我们看一下`usingFunctionCallbacks`函数：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This snippet shows the definition of a function named `myCallbackFunction`.
    It matches the callback signature required by the `usingFunctionCallbacks` function,
    allowing us to pass in the `myCallbackFunction` as a parameter to the `usingFunctionCallbacks`
    function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了一个名为`myCallbackFunction`的函数的定义。它匹配了`usingFunctionCallbacks`函数所需的回调签名，允许我们将`myCallbackFunction`作为参数传递给`usingFunctionCallbacks`函数。
- en: Note that if you face any difficulty understanding these various function signatures,
    then please re-view the relevant sections in [Chapter 2](ch02.html "Chapter 2. Types,
    Variables and Function Techniques"), *Types, Variables, and Function Techniques*,
    regarding functions, where each of these concepts is explained in detail.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在理解这些不同的函数签名时遇到任何困难，请重新查看[第2章](ch02.html "第2章。类型、变量和函数技术")中有关函数的相关部分，*类型、变量和函数技术*，其中详细解释了这些概念。
- en: Interface function definitions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口函数定义
- en: 'Interfaces, like classes, follow the same rules when dealing with functions.
    To update our `IComplexType` interface definition to match the `ComplexType` class
    definition, we need to write a function definition for each of the new functions,
    as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接口与类一样，在处理函数时遵循相同的规则。要更新我们的`IComplexType`接口定义以匹配`ComplexType`类定义，我们需要为每个新函数编写一个函数定义，如下所示：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Lines 1 to 4 form our existing interface definition, and include the `id` and
    `name` properties and the `print` function we have been using until now. Line
    5 shows how to define a function signature for the `usingTheAnyKeyword` function.
    It looks surprisingly like our actual class function, but does not have a function
    body. Line 6 shows how to use an optional parameter for the `usingOptionalParameters`
    function. Line 7, however, is slightly different from our class definition of
    the `usingDefaultParameters` function. Remember that an interface defines the
    shape of our class or object, and therefore cannot contain variables or values.
    We have therefore defined the `defaultArg1` parameter as optional, and left the
    assignment of the default value up to the class implementation itself. Line 8
    shows the definition of the `usingRestSyntax` function that contains the rest
    parameter syntax, and line 9 shows the definition of the `usingFunctionCallbacks`
    function, with a callback function signature. They are pretty much identical to
    the class function signatures.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第1到4行构成了我们现有的接口定义，包括`id`和`name`属性以及我们一直在使用的`print`函数。第5行显示了如何为`usingTheAnyKeyword`函数定义一个函数签名。它看起来非常像我们实际的类函数，但没有函数体。第6行显示了如何为`usingOptionalParameters`函数使用可选参数。然而，第7行与我们的`usingDefaultParameters`函数的类定义略有不同。请记住，接口定义了我们的类或对象的形状，因此不能包含变量或值。因此，我们已将`defaultArg1`参数定义为可选的，并将默认值的赋值留给了类实现本身。第8行显示了包含剩余参数语法的`usingRestSyntax`函数的定义，第9行显示了带有回调函数签名的`usingFunctionCallbacks`函数的定义。它们与类函数签名几乎完全相同。
- en: 'The only thing missing from this interface is the signature for the `constructor`
    function. TypeScript will generate an error if we include a `constructor` signature
    in an interface. Suppose we were to include a definition for the `constructor`
    function in the `IComplexType` interface:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口唯一缺少的是`constructor`函数的签名。如果我们在接口中包含`constructor`签名，TypeScript会生成一个错误。假设我们在`IComplexType`接口中包含`constructor`函数的定义：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The TypeScript compiler would then generate an error:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器会生成一个错误：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This error show us that when we use a `constructor` function, the return type
    of the constructor is implicitly typed by the TypeScript compiler. Therefore,
    the return type of the `IComplexType` constructor would be `IComplexType`, and
    the return type of the `ComplexType` constructor would be `ComplexType`. Even
    though the `ComplexType` function implements the `IComplexType` interface, they
    are actually two different types—and therefore the `constructor` signatures will
    always be incompatible—hence the compile error.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，当我们使用`constructor`函数时，构造函数的返回类型会被TypeScript编译器隐式地确定。因此，`IComplexType`构造函数的返回类型将是`IComplexType`，而`ComplexType`构造函数的返回类型将是`ComplexType`。即使`ComplexType`函数实现了`IComplexType`接口，它们实际上是两种不同的类型，因此`constructor`签名将始终不兼容，因此会出现编译错误。
- en: Inheritance
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: Inheritance is another paradigm that is one of the cornerstones of object-oriented
    programming. Inheritance means that an object uses another object as its base
    type, thereby "inheriting" all of the base object's characteristics, including
    both properties and functions. Both interfaces and classes can use inheritance.
    An interface or class that is "inherited" from is known as the base interface,
    or base class, and the interface or class that does the inheritance is known as
    the derived interface, or derived class. TypeScript implements inheritance using
    the `extends` keyword.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是面向对象编程的基石之一。继承意味着一个对象使用另一个对象作为其基本类型，从而“继承”了基本对象的所有特征，包括属性和函数。接口和类都可以使用继承。被继承的接口或类称为基接口或基类，进行继承的接口或类称为派生接口或派生类。TypeScript使用`extends`关键字实现继承。
- en: Interface inheritance
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口继承
- en: 'As an example of interface inheritance, consider the following TypeScript code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 作为接口继承的例子，考虑以下TypeScript代码：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We start with an interface called `IBase` that defines an `id` property, of
    type number. Our second interface definition, `IDerivedFromBase`, extends (or
    inherits) from `IBase`, and therefore automatically includes the `id` property.
    The `IDerivedFromBase` interface then defines a `name` property, of type string.
    As the `IDerivedFromBase` interface inherits from `IBase`, it therefore actually
    has two properties: `id` and `name`. The class definition for `DerivedClass` implements
    this `IDerivedFromBase` interface, and therefore must include both the `id` and
    `name` properties—in order to successfully implement all of the properties of
    the `IDerivedFromBase` interface. Although we have only shown properties in this
    example, the same rules apply for functions.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`IBase`的接口开始，该接口定义了一个类型为数字的`id`属性。我们的第二个接口定义`IDerivedFromBase`从`IBase`继承，并因此自动包含`id`属性。然后，`IDerivedFromBase`接口定义了一个类型为字符串的`name`属性。由于`IDerivedFromBase`接口继承自`IBase`，因此它实际上有两个属性：`id`和`name`。`DerivedClass`的类定义实现了`IDerivedFromBase`接口，因此必须包含`id`和`name`属性，以成功实现`IDerivedFromBase`接口的所有属性。虽然在这个例子中我们只展示了属性，但是函数也适用相同的规则。
- en: Class inheritance
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类继承
- en: 'Classes can also use inheritance in the same manner as interfaces. Using our
    definitions of the `IBase` and `IDerivedFromBase` interfaces, the following code
    shows an example of class inheritance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类也可以像接口一样使用继承。使用我们对`IBase`和`IDerivedFromBase`接口的定义，以下代码展示了类继承的一个例子：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first class, named `BaseClass`, implements the `IBase` interface, and as
    such, is only required to define a property of `id`, of type `number`. The second
    class, `DerivedFromBaseClass`, inherits from the `BaseClass` class (using the
    `extends` keyword), but also implements the `IDerivedFromBase` interface. As `BaseClass`
    already defines the `id` property required in the `IDerivedFromBase` interface,
    the only other property that the `DerivedFromBaseClass` class needs to implement
    is the `name` property. We therefore only need to include the definition of the
    `name` property in the `DerivedFromBaseClass` class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个类名为`BaseClass`，实现了`IBase`接口，因此只需要定义一个类型为`number`的`id`属性。第二个类`DerivedFromBaseClass`继承自`BaseClass`类（使用`extends`关键字），同时实现了`IDerivedFromBase`接口。由于`BaseClass`已经定义了`IDerivedFromBase`接口中需要的`id`属性，`DerivedFromBaseClass`类需要实现的唯一其他属性是`name`属性。因此，我们只需要在`DerivedFromBaseClass`类中包含`name`属性的定义。
- en: Function and constructor overloading with super
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用super进行函数和构造函数重载
- en: 'When using inheritance, it is often necessary to create a base class with a
    defined constructor. Then, in the constructor for any derived class, we will need
    to call through to the base class constructor and pass through these parameters.
    This is called constructor overloading. In other words, the constructor of a derived
    class overloads, or "supersedes", the constructor of the base class. TypeScript
    includes the `super` keyword to enable calling a base class''s function with the
    same name. This is best explained with the following code snippet:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用继承时，通常需要创建一个具有定义构造函数的基类。然后，在任何派生类的构造函数中，我们需要调用基类的构造函数并传递这些参数。这称为构造函数重载。换句话说，派生类的构造函数重载了基类的构造函数。TypeScript包括`super`关键字，以便使用相同名称调用基类的函数。以下代码片段最好解释了这一点：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this code snippet, we define a class named `BaseClassWithConstructor` that
    holds a private `_id` property. This class has a `constructor` function that requires
    an `id` argument. Our second class, named `DerivedClassWithConstructor`, inherits
    from, or extends, the `BaseClassWithConstructor` class. The constructor of `DerivedClassWithConstructor`
    takes an `id` argument and a `name` argument, but it needs to pass the `id` argument
    through to the base class. This is where the `super` call comes in. The `super`
    keyword calls the function in the base class that has the same name as the function
    in the derived class. The last line of the constructor function for `DerivedClassWithConstructor`
    shows the call using the `super` keyword, passing the `id` argument it received
    through to the base class constructor.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们定义了一个名为`BaseClassWithConstructor`的类，它拥有一个私有的`_id`属性。这个类有一个需要`id`参数的`constructor`函数。我们的第二个类，名为`DerivedClassWithConstructor`，继承自`BaseClassWithConstructor`类。`DerivedClassWithConstructor`的构造函数接受一个`id`参数和一个`name`参数，但它需要将`id`参数传递给基类。这就是`super`调用的作用。`super`关键字调用了基类中与派生类中函数同名的函数。`DerivedClassWithConstructor`的构造函数的最后一行显示了使用`super`关键字的调用，将接收到的`id`参数传递给基类构造函数。
- en: 'This technique is called function overloading. In other words, the derived
    class has a function name that is the same name as that of a base class function,
    and it "overloads" this function definition. We can use this technique on any
    function in a class—not only on constructors. Consider the following code snippet:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技术被称为函数重载。换句话说，派生类有一个与基类函数同名的函数，并且"重载"了这个函数的定义。我们可以在类中的任何函数上使用这个技术，不仅仅是在构造函数上。考虑以下代码片段：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `BaseClassWithConstructor` class now has a function named `getProperties`,
    which just returns a string representation of the properties of the class. Our
    `DerivedClassWithConstructor` class, however, also includes a function called
    `getProperties`. This function is a function override of the `getProperties` base
    class function. In order to call through to the base class function, we need to
    include the `super` keyword, as shown in the call to `super`.`getProperties()`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseClassWithConstructor`类现在有一个名为`getProperties`的函数，它只是返回类的属性的字符串表示。然而，我们的`DerivedClassWithConstructor`类还包括一个名为`getProperties`的函数。这个函数是对`getProperties`基类函数的函数重写。为了调用基类函数，我们需要包括`super`关键字，就像在调用`super`.`getProperties()`中所示的那样。'
- en: 'Here is an example usage of the preceding code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的一个示例用法：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code creates a variable named `myDerivedClass` and passes in the required
    arguments of `id` and `name`. We then simply log the result of the call to the
    `getProperties` function to the console. This code snippet will result in the
    following console output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`myDerivedClass`的变量，并传入了`id`和`name`的必需参数。然后我们简单地将对`getProperties`函数的调用结果记录到控制台上。这段代码片段将导致以下控制台输出：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The results show that the `getProperties` function of the `myDerivedClass` variable
    will call through to the base class `getProperties` function, as expected.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示，`myDerivedClass`变量的`getProperties`函数将按预期调用基类的`getProperties`函数。
- en: JavaScript closures
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript闭包
- en: 'Before we continue with this chapter, let''s take a quick look at how TypeScript
    implements classes in the generated JavaScript through a technique called closures.
    As we mentioned in [Chapter 1](ch01.html "Chapter 1. TypeScript – Tools and Framework
    Options"), *TypeScript – Tools and Framework Options*, a closure is a function
    that refers to independent variables. These variables essentially remember the
    environment in which they were created. Consider the following JavaScript code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续本章之前，让我们快速看一下TypeScript是如何通过闭包技术在生成的JavaScript中实现类的。正如我们在[第1章](ch01.html
    "第1章。TypeScript - 工具和框架选项")中提到的，闭包是指引用独立变量的函数。这些变量本质上记住了它们被创建时的环境。考虑以下JavaScript代码：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have a function named `TestClosure` that takes a single parameter,
    named `value`. The body of the function first assigns the `value` argument to
    an internal property named `this._value`, and then defines an inner function named
    `printValue`, that logs the value of the `this._value` property to the console.
    The interesting bit is the last line in the `TestClosure` function—we are returning
    the `printValue` function.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`TestClosure`的函数，它接受一个名为`value`的参数。函数的主体首先将`value`参数赋给一个名为`this._value`的内部属性，然后定义了一个名为`printValue`的内部函数，它将`this._value`属性的值记录到控制台上。有趣的是`TestClosure`函数的最后一行
    - 我们返回了`printValue`函数。
- en: Now take a look at the last two lines of the code snippet. We create a variable
    named `myClosure` and assign to it the result of calling the `TestClosure` function.
    Note that because we are returning the `printValue` function from inside the `TestClosure`
    function, this essentially also makes the `myClosure` variable a function. When
    we execute this function on the last line of the snippet, it will execute the
    inner `printValue` function, but remember the initial value of `12` that was used
    when creating the `myClosure` variable. The output of the last line of the code
    will log the value of `12` to the console.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看一下代码片段的最后两行。我们创建了一个名为`myClosure`的变量，并将调用`TestClosure`函数的结果赋给它。请注意，因为我们从`TestClosure`函数内部返回了`printValue`函数，这实质上也使得`myClosure`变量成为了一个函数。当我们在片段的最后一行执行这个函数时，它将执行内部的`printValue`函数，但会记住创建`myClosure`变量时使用的初始值`12`。代码的最后一行的输出将会将值`12`记录到控制台上。
- en: This is the essential nature of closures. A closure is a special kind of object
    that combines a function with the initial environment in which it was created.
    In our preceding sample, since we stored whatever was passed in via the `value`
    argument into a local variable named `this._value`, JavaScript remembers the environment
    in which the closure was created, in other words, whatever was assigned to the
    `this._value` property at the time of creation will be remembered, and can be
    reused later.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是闭包的本质。闭包是一种特殊类型的对象，它将函数与创建它的初始环境结合在一起。在我们之前的示例中，由于我们将通过`value`参数传入的任何内容存储到名为`this._value`的局部变量中，JavaScript会记住创建闭包时的环境，换句话说，创建时分配给`this._value`属性的任何内容都将被记住，并且可以在以后重复使用。
- en: 'With this in mind, let''s take a look at the JavaScript that is generated by
    the TypeScript compiler for the `BaseClassWithConstructor` class we were just
    working with:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，让我们来看一下TypeScript编译器为我们刚刚使用的`BaseClassWithConstructor`类生成的JavaScript：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Our closure starts with `function () {` on the first line, and ends with `}`
    on the last line. This closure first defines a function to be used as a constructor
    : `BaseClassWithConstructor(id)`. Bear in mind that when a JavaScript object is
    constructed, it inherits, or copies the `prototype` property of the original object
    into the new instance. In our sample, then, any object that is created using the
    `BaseClassWithConstructor` function will inherit the `getProperties` function
    as well – as it is part of the `prototype` property. Also, because the functions
    that are defined on the `prototype` property are also within the closure, they
    will remember the original execution environment, and variable values.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的闭包从第一行开始是`function () {`，并以最后一行的`}`结束。这个闭包首先定义了一个用作构造函数的函数：`BaseClassWithConstructor(id)`。请记住，当构造一个JavaScript对象时，它会继承或复制原始对象的`prototype`属性到新实例中。在我们的示例中，使用`BaseClassWithConstructor`函数创建的任何对象也将继承`getProperties`函数，因为它是`prototype`属性的一部分。此外，因为在`prototype`属性上定义的函数也在闭包内，它们将记住原始的执行环境和变量值。
- en: This closure is then surrounded with an opening bracket, `(`, on the first line,
    and a closing bracket, `)`, on the last line—defining what is known as a JavaScript
    function expression. This function expression is then immediately executed by
    the last two braces, `();`. This technique of immediately executing a function
    is known as an **Immediately Invoked Function Expression** (**IIFE**). Our IIFE
    above is then assigned to a variable named `BaseClassWithConstructor`, making
    it a first-class JavaScript object, and one that can be created with the `new`
    keyword. This is how TypeScript implements classes in JavaScript.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个闭包被包围在第一行的开括号`(`和最后一行的闭括号`)`中——定义了一个被称为JavaScript函数表达式的东西。然后，这个函数表达式立即被最后两个大括号`();`执行。这种立即执行函数的技术被称为**立即调用函数表达式**（**IIFE**）。我们上面的IIFE然后被赋值给一个名为`BaseClassWithConstructor`的变量，使它成为一个一流的JavaScript对象，并且可以使用`new`关键字创建它。这就是TypeScript在JavaScript中实现类的方式。
- en: The implementation of the underlying JavaScript code that TypeScript uses for
    class definitions is actually a well-known JavaScript pattern—known as the **module**
    pattern. It uses closures to capture an execution environment, and also provides
    a way to expose a public API for classes, as seen by the use of the `prototype`
    property.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript用于类定义的底层JavaScript代码实际上是一个众所周知的JavaScript模式——称为**模块**模式。它使用闭包来捕获执行环境，并提供了一种公开类的公共API的方式，正如使用`prototype`属性所见。
- en: The good news is that an in-depth knowledge of closures, how to write them,
    and how to use the module pattern for defining classes—will all be taken care
    of by the TypeScript compiler—allowing us to focus on object-oriented principles
    without having to write JavaScript closures using this sort of boilerplate code.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，TypeScript编译器将处理闭包的深入知识，如何编写它们以及如何使用模块模式来定义类，从而使我们能够专注于面向对象的原则，而无需编写JavaScript闭包使用这种样板代码。
- en: The Factory Design Pattern
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂设计模式
- en: To illustrate how we can use interfaces and classes in a large TypeScript project,
    we will have a quick look at a very well-known object-oriented design pattern—the
    Factory Design Pattern.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们如何在一个大型的TypeScript项目中使用接口和类，我们将快速地看一下一个非常著名的面向对象设计模式——工厂设计模式。
- en: Business requirements
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 业务需求
- en: 'As an example, let''s assume that our business analyst gives us the following
    requirements:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们的业务分析师给了我们以下要求：
- en: You are required to categorize people, given their date of birth, and indicate
    with a `true` or `false` flag whether they are of a legal age to sign a contract.
    A person is deemed to be an infant if they are less than 2 years old. Infants
    cannot sign contracts. A person is deemed to be a child if they are less than
    18 years old. Children cannot sign contracts either. A person is deemed to be
    an adult if they are more than 18 years of age, and only adults can sign contracts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 根据出生日期，您需要对人进行分类，并用`true`或`false`标志表示他们是否具有签署合同的法定年龄。如果一个人不到2岁，则被视为婴儿。婴儿不能签署合同。如果一个人不到18岁，则被视为儿童。儿童也不能签署合同。如果一个人超过18岁，则被视为成年人，只有成年人才能签署合同。
- en: What the Factory Design Pattern does
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂设计模式的作用
- en: The Factory Design Pattern uses a Factory class to return an instance of one
    of several possible classes based on the information provided to it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式使用一个工厂类来根据提供的信息返回多个可能类中的一个实例。
- en: The essence of this pattern is to place the decision-making logic for what type
    of class to create, in a separate class—the Factory class. The Factory class will
    then return one of several classes that are all subtle variations of each other,
    and which will do slightly different things based on their specialty. In order
    for our logic to work, any code that consumes one of these classes must have a
    common contract (or list of properties and methods) that all the variations of
    a class implement. This is the perfect scenario for an interface.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的本质是将决策逻辑放在一个单独的类——工厂类中，用于创建哪种类型的类。工厂类然后返回几个微妙变化的类中的一个，它们根据其专业领域会做稍微不同的事情。为了使我们的逻辑工作，任何使用这些类之一的代码必须有一个所有类的变化都实现的公共契约（或属性和方法列表）。这是接口的完美场景。
- en: To implement our required business functionality, we will create an `Infant`
    class, a `Child` class, and an `Adult` class. The `Infant` and `Child` classes
    will return `false` when asked whether they can sign contracts, and the `Adult`
    class will return `true`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们需要的业务功能，我们将创建一个`Infant`类、一个`Child`类和一个`Adult`类。`Infant`和`Child`类在被问及是否能签署合同时会返回`false`，而`Adult`类会返回`true`。
- en: The IPerson interface and the Person base class
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IPerson接口和Person基类
- en: 'According to our requirements, the class instance that is returned by the Factory
    must be able to do two things: print the category of the person in the required
    format, and tell us whether they can sign contracts or not. For completeness,
    we will include a third function that prints the date of birth. Let''s define
    an interface to satisfy this requirement:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的要求，工厂返回的类实例必须能够做两件事：以所需格式打印人的类别，并告诉我们他们是否能签署合同。为了完整起见，我们将包括一个第三个函数，打印出生日期。让我们定义一个接口来满足这个要求：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our `IPerson` interface has a `getPersonCategory` method that will return a
    string representation of their category: either "Infant", "Child", or "Adult".
    The `canSignContracts` method will return either `true` or `false`, and the `getDateOfBirth`
    method will simply return a printable version of their date of birth. To simplify
    our code, we will create a base class called `Person` that implements this interface,
    and will handle the common data and functions of all types of `Person`: storing
    and returning the date of birth. Our base class is defined as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`IPerson`接口有一个`getPersonCategory`方法，它将返回他们类别的字符串表示：`"Infant"`、`"Child"`或`"Adult"`。`canSignContracts`方法将返回`true`或`false`，`getDateOfBirth`方法将简单地返回他们的出生日期的可打印版本。为了简化我们的代码，我们将创建一个名为`Person`的基类，它实现了这个接口，并处理所有类型的`Person`的通用数据和函数：存储和返回出生日期。我们的基类定义如下：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `Person` class definition is the base class for each of our specialist
    types of person. As each one of our specialist classes will require a `getDateOfBirth`
    function, we can extract this common code into a base class. The constructor function
    requires a date, which is stored in the internal variable `_dateOfBirth`, and
    the `getDateOfBirth` function returns this `_dateOfBirth` converted into a string.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Person`类定义是我们专业人员类型的基类。由于我们的每一个专业类都需要一个`getDateOfBirth`函数，我们可以将这个通用代码提取到一个基类中。构造函数需要一个日期，它存储在内部变量`_dateOfBirth`中，`getDateOfBirth`函数返回这个`_dateOfBirth`转换为字符串的值。
- en: Specialist classes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专业类
- en: 'Now for the three types of specialist classes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看三种专业类的类型：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: All of the classes in this snippet use inheritance to extend the `Person` class.
    Our `Infant`, `Child`, and `Adult` classes do not specify a `constructor` method,
    but instead inherit this `constructor` from their base class, `Person`. Each class
    implements the `IPerson` interface, and must therefore provide implementations
    of all three functions required by the `IPerson` interface definition. The `getDateOfBirth`
    function is defined in the `Person` base class, however, so each of these derived
    classes only needs to implement the `getPersonCategory` and `canSignContracts`
    functions to be valid. We can see that our `Infant` and `Child` classes return
    `false` for `canSignContracts`, and our `Adult` class returns `true`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段中的所有类都使用继承来扩展`Person`类。我们的`Infant`、`Child`和`Adult`类没有指定`constructor`方法，而是从它们的基类`Person`继承了这个`constructor`。每个类都实现了`IPerson`接口，因此必须提供`IPerson`接口定义所需的所有三个函数的实现。`getDateOfBirth`函数在`Person`基类中定义，因此这些派生类只需要实现`getPersonCategory`和`canSignContracts`函数即可。我们可以看到我们的`Infant`和`Child`类在`canSignContracts`上返回`false`，而我们的`Adult`类返回`true`。
- en: The Factory class
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂类
- en: 'Now, let''s move on to the Factory class itself. This class is responsible
    for holding all of the logic required to make decisions, and returns an instance
    of either an `Infant`, `Child`, or `Adult` class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向工厂类本身。这个类负责保存所有需要做出决定的逻辑，并返回`Infant`、`Child`或`Adult`类的实例：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `PersonFactory` class has only one function, `getPerson`, which returns
    an object of type `IPerson`. This function creates a variable named `dateNow`,
    that is set to the current date. This `dateNow` variable is then used to calculate
    two more variables, `dateTwoYearsAgo`, and `dateEighteenYearsAgo`. The decision
    logic then takes over, comparing the incoming `dateOfBirth` variable against these
    dates. This logic satisfies our requirements, and returns a new instance of either
    a new `Infant`, `Child`, or `Adult` class based on their date of birth.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonFactory`类只有一个函数`getPerson`，它返回一个`IPerson`类型的对象。这个函数创建一个名为`dateNow`的变量，它被设置为当前日期。然后使用这个`dateNow`变量来计算另外两个变量，`dateTwoYearsAgo`和`dateEighteenYearsAgo`。然后决策逻辑接管，比较传入的`dateOfBirth`变量与这些日期。这个逻辑满足了我们的要求，并根据他们的出生日期返回一个新的`Infant`、`Child`或`Adult`类的实例。'
- en: Using the Factory class
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工厂类
- en: 'To illustrate how to use this `PersonFactory` class, we will use the following
    code, wrapped in a `window.onload` function so that we can run it inside a browser:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何使用这个`PersonFactory`类，我们将使用以下代码，包装在`window.onload`函数中，以便我们可以在浏览器中运行它：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In line 2, we start with the creation of a variable, `personFactory`, to hold
    a new instance of the `PersonFactory` class. Line 4 creates a new array, named
    `personArray`, that is strongly typed to only hold objects that implement the
    `IPerson` interface. Lines 5 to 7 then add values to this array, by using the
    `getPerson` function of the `PersonFactory` class, passing in the date of birth.
    Note that the `PersonFactory` class will make all the decisions regarding which
    type of object to return, based on the date of birth we are passing in.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们开始创建一个变量`personFactory`，用于保存`PersonFactory`类的一个新实例。第4行创建一个名为`personArray`的新数组，它被强类型化为只能容纳实现`IPerson`接口的对象。然后第5到7行通过使用`PersonFactory`类的`getPerson`函数向这个数组添加值，传入出生日期。请注意，`PersonFactory`类将根据我们传入的出生日期做出所有关于返回哪种类型对象的决定。
- en: 'Line 8 starts a `for` loop to loop through the `personArray` array, and lines
    9 to 14 use the interface definition of `IPerson` to call the relevant functions
    for printing. The output of this code is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行开始一个`for`循环来遍历`personArray`数组，第9到14行使用`IPerson`接口定义来调用相关的打印函数。这段代码的输出如下：
- en: '![Using the Factory class](img/9665OS_03_01.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![使用Factory类](img/9665OS_03_01.jpg)'
- en: We have satisfied our business requirements, and implemented a very common design
    pattern at the same time. If you find yourself repeating the same sort of logic
    in many places, trying to figure out whether an object falls under one or more
    categories, then chances are that you can refactor your code to use the Factory
    Design Pattern - and avoid repeating the same decision-making logic all over your
    code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们满足了业务需求，并同时实现了一个非常常见的设计模式。如果你发现自己在许多地方重复相同的逻辑，试图弄清楚一个对象是否属于一个或多个类别，那么很有可能你可以重构你的代码来使用工厂设计模式——避免在整个代码中重复相同的决策逻辑。
- en: Class modifiers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类修饰符
- en: As we discussed briefly in the opening chapter, TypeScript introduces the `public`
    and `private` access modifiers to mark variables and functions as either public
    or private. Traditionally, JavaScript programmers have used a simple naming convention
    of prefixing variables with an underscore (`_`) to indicate that they are private
    variables. This naming convention, however, does not stop anyone from actually
    modifying such variables inadvertently.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在开头章节简要讨论的那样，TypeScript引入了`public`和`private`访问修饰符，用于标记变量和函数是公共的还是私有的。传统上，JavaScript程序员使用下划线(`_`)作为变量的前缀来表示它们是私有变量。然而，这种命名约定并不能阻止任何人无意中修改这些变量。
- en: 'Let''s take a look at a TypeScript code sample to illustrate this point:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个TypeScript代码示例来说明这一点：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We start with a class named `ClassWithModifiers`, which has two properties,
    `_id` and `_name`. We have marked these properties with the `private` keyword
    to protect them from being modified by mistake. Our `constructor` takes an incoming
    `id` and `name` parameter, and assigns the values to the internal, private properties
    of `_id` and `_name` respectively. The next function that we define is called
    `modifyId`, which will allow us to update the internal `_id` variable with a new
    value. The `modifyId` function then calls an internal function named `updateNameFromId`.
    This function has been marked as `private`, and therefore calls to it are only
    allowed within the body of the class definition. The `updateNameFromId` function
    simply uses the new `_id` value to set the private `_name` value.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`ClassWithModifiers`的类开始，它有两个属性，`_id`和`_name`。我们用`private`关键字标记了这些属性，以防止它们被错误修改。我们的`constructor`接受一个传入的`id`和`name`参数，并将这些值分配给内部的私有属性`_id`和`_name`。我们定义的下一个函数叫做`modifyId`，它允许我们用新值更新内部的`_id`变量。`modifyId`函数然后调用一个名为`updateNameFromId`的内部函数。这个函数被标记为`private`，因此只允许在类定义的内部调用它。`updateNameFromId`函数简单地使用新的`_id`值来设置私有的`_name`值。
- en: 'The last four lines of code show us how we would use this class. The first
    line creates a variable named `myClass`, and assigns it to a new instance of the
    `ClassWithModifiers` class. The second line is legal, and calls the `modifyId`
    function. The third and fourth lines, however, will generate compile time errors:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后四行展示了我们如何使用这个类。第一行创建了一个名为`myClass`的变量，并将其赋值为`ClassWithModifiers`类的一个新实例。第二行是合法的，并调用了`modifyId`函数。然而，第三行和第四行将生成编译时错误：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The TypeScript compiler warns us that both the `_id` property and `updateNameFromId`
    function are inaccessible—in other words, `private`—and are not designed to be
    used outside the class definition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器警告我们，`_id`属性和`updateNameFromId`函数都是不可访问的——换句话说，是`private`的，并且不打算在类定义之外使用。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Class functions are `public` by default. Not specifying an access modifier of
    `private` for either properties or functions will cause their access level to
    default to `public`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类函数默认是`public`的。如果不为属性或函数指定`private`的访问修饰符，它们的访问级别将默认为`public`。
- en: Constructor access modifiers
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数访问修饰符
- en: 'TypeScript also introduces a shorthand version of the previous constructor
    function, allowing you to specify parameters with access modifiers directly in
    the constructor. This is best described in code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript还引入了前一个构造函数的简写版本，允许你直接在构造函数中指定带有访问修饰符的参数。这最好用代码来描述：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code snippet defines a class named `ClassWithAutomaticProperties`. The
    `constructor` function uses two arguments - an `id` of type `number`, and a `name`
    of type `string`. Notice, however, the access modifiers of `public` for `id` and
    `private` for `name`. This shorthand automatically creates a public `id` property
    on the `ClassWithAutomaticProperties` class, and a private `name` property.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段定义了一个名为`ClassWithAutomaticProperties`的类。`constructor`函数使用两个参数——一个类型为`number`的`id`和一个类型为`string`的`name`。然而，请注意，`id`的访问修饰符是`public`，而`name`的访问修饰符是`private`。这个简写自动创建了`ClassWithAutomaticProperties`类的一个公共`id`属性和一个私有`name`属性。
- en: The `print` function on line 4 uses these automatic properties in the `console.log`
    function. We are referring to `this.id` and `this.name` in the `console.log` function,
    just as in our previous code samples.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第4行的`print`函数在`console.log`函数中使用了这些自动属性。我们在`console.log`函数中引用了`this.id`和`this.name`，就像我们之前的代码示例中一样。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This shorthand syntax is available only within the `constructor` function.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写语法仅在`constructor`函数内部可用。
- en: 'We can see on line 9 that we have created a variable named `myAutoClass` and
    assigned a new instance of the `ClassWithAutomaticProperties` class to it. Once
    this class is instantiated, it automatically has two properties: an `id` property
    of type number, which is `public`; and a `name` property of type string, which
    is `private`. Compiling the previous code, however, will produce a TypeScript
    compile error:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到第9行我们创建了一个名为`myAutoClass`的变量，并将`ClassWithAutomaticProperties`类的一个新实例分配给它。一旦这个类被实例化，它就自动拥有两个属性：一个类型为数字的`public`的`id`属性；和一个类型为字符串的`private`的`name`属性。然而，编译前面的代码将产生一个TypeScript编译错误：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This error is telling us that the automatic property `name` is declared as `private`,
    and it is therefore unavailable to code outside the class itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们，自动属性`name`被声明为`private`，因此在类外部不可用。
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this shorthand technique of creating automatic member variables is available,
    I believe that it makes the code more difficult to read. Personally, I prefer
    the more verbose class definitions that do not use this shorthand technique. With
    a list of properties at the top of the class, it becomes immediately visible to
    someone reading the code what variables this class uses, and whether they are
    `public` or `private`. Using the constructor's automatic property syntax hides
    these parameters somewhat, forcing developers to sometimes reread the code to
    understand it. Whichever syntax you choose, however, try to make it a coding standard,
    and use the same syntax throughout your code base.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种简写创建自动成员变量的技术是可用的，但我认为它使代码更难阅读。就我个人而言，我更喜欢不使用这种简写技术的更冗长的类定义。在类的顶部列出属性列表，使得阅读代码的人立即看到这个类使用了哪些变量，以及它们是`public`还是`private`。使用构造函数的自动属性语法有时会隐藏这些参数，迫使开发人员有时需要重新阅读代码以理解它。无论你选择哪种语法，都要尽量将其作为编码标准，并在整个代码库中使用相同的语法。
- en: Class property accessors
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性访问器
- en: 'ECMAScript 5 introduces the concept of property accessors. This allows a pair
    of `get` and `set` functions (with the same function name) to be seen by the calling
    code as simple properties. This concept is best understood with some simple code
    samples:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 5引入了属性访问器的概念。这允许一对`get`和`set`函数（具有相同的函数名）被调用代码视为简单的属性。这个概念最好通过一些简单的代码示例来理解：
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Here, we have a class named `SimpleClass`, and it has a single public `id`
    property. When we create an instance of this class, we can directly modify this
    `id` property. Now let''s use the ECMAScript 5 `get` and `set` functions to accomplish
    the same result:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`SimpleClass`的类，它有一个公共的`id`属性。当我们创建这个类的一个实例时，我们可以直接修改这个`id`属性。现在让我们使用ECMAScript
    5的`get`和`set`函数来实现相同的结果：
- en: '[PRE35]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This class has a private `_id` property and two functions, both called `id`.
    The first of these functions is prefixed by the `get` keyword and simply returns
    the value of the internal `_id` property. The second of these functions is prefixed
    with the `set` keyword and accepts a `value` parameter. The internal `_id` property
    is then set to this `value` parameter.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个私有的`_id`属性和两个函数，都叫做`id`。这些函数中的第一个是由`get`关键字前缀的，简单地返回内部`_id`属性的值。这些函数中的第二个是由`set`关键字前缀的，并接受一个`value`参数。然后将内部`_id`属性设置为这个`value`参数。
- en: At the bottom of the class definition, we create a variable, named `mySimpleAccClass`,
    which is an instance of the `SimpleClassWithAccessors` class. Anyone using an
    instance of this class will not see two separate functions named `get` and `set`.
    They will simply see an `id` property. When we assign a value to this property,
    the ECMAScript 5 runtime will call the `set id(value)` function, and when we retrieve
    this property, the runtime will call the `get id()` function.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义的底部，我们创建了一个名为`mySimpleAccClass`的变量，它是`SimpleClassWithAccessors`类的一个实例。使用这个类的实例的人不会看到两个名为`get`和`set`的单独函数。他们只会看到一个`id`属性。当我们给这个属性赋值时，ECMAScript
    5运行时将调用`set id(value)`函数，当我们检索这个属性时，运行时将调用`get id()`函数。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some browsers do not support ECMAScript 5 (such as Internet Explorer 8), and
    will cause a JavaScript runtime error when this code is run.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器不支持ECMAScript 5（如Internet Explorer 8），当运行这段代码时会导致JavaScript运行时错误。
- en: Static functions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态函数
- en: 'Static functions are functions that can be called on a class without having
    to create an instance of the class first. These functions are almost global in
    their nature, but must be called by prefixing the function name with the class
    name. Consider the following TypeScript code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 静态函数是可以在不必先创建类的实例的情况下调用的函数。这些函数在其性质上几乎是全局的，但必须通过在函数名前加上类名来调用。考虑以下TypeScript代码：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We start with a simple class, named `ClassWithFunction`, which has a single
    function, `printOne`. The `printOne` function does not really do anything useful,
    other than logging the string `"1"` to the console. In order to use this function,
    though, we need to first create an instance of the class, assign it to a variable,
    and then call the function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的类开始，名为`ClassWithFunction`，它有一个名为`printOne`的函数。`printOne`函数实际上并没有做任何有用的事情，除了将字符串`"1"`记录到控制台。然而，为了使用这个函数，我们需要首先创建一个类的实例，将其赋给一个变量，然后调用这个函数。
- en: 'With static functions, however, we can call functions or properties directly:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用静态函数，我们可以直接调用函数或属性：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The class definition of `StaticClass` includes a single function, named `printTwo`,
    that is marked as `static`. As we can see from the last line of the code, we can
    call this function without "newing" up an instance of the `StaticClass` class.
    We can just call the function directly, as long as we prefix it with the class
    name.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticClass`的类定义包括一个名为`printTwo`的函数，标记为`static`。从代码的最后一行可以看出，我们可以在不创建`StaticClass`类的实例的情况下调用这个函数。只要我们在函数前面加上类名，就可以直接调用这个函数。'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Both functions and properties of a class can be marked as static.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 类的函数和属性都可以标记为静态的。
- en: Static properties
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态属性
- en: 'Static properties come in handy when dealing with so-called "magic strings"
    throughout your code base. If you are relying on a string to contain a particular
    value in various parts of your code, then the time has come to replace this "magic
    string" with a static property. In the Factory Design Pattern that we discussed
    earlier, we created specialist `Person` objects that returned either "Infant",
    "Child" or "Adult" as a string value. If we were writing code later on that checked
    whether the string returned was equal to "Infant" or "Child", we could inadvertently
    break our logic if we misspelled "Infant" as "Infent":'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 静态属性在处理代码库中的所谓“魔术字符串”时非常方便。如果你在代码的各个部分依赖于一个字符串包含特定的值，那么现在是时候用静态属性替换这个“魔术字符串”了。在我们之前讨论的工厂设计模式中，我们创建了返回字符串值"Infant"、"Child"或"Adult"的专门的`Person`对象。如果我们后来编写的代码检查返回的字符串是否等于"Infant"或"Child"，如果我们将"Infant"拼错成"Infent"，就可能无意中破坏我们的逻辑：
- en: '[PRE38]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following is an example of static properties that we could use instead
    of those "magic strings":'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以使用的静态属性的示例，而不是那些“魔术字符串”：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, in our code base, instead of checking values against the string "Infant",
    we compare them against the static property:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在我们的代码库中，我们不再检查值是否等于字符串"Infant"，而是将它们与静态属性进行比较：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This code is not relying on a "magic string" anymore. The string "Infant" is
    now recorded in a single place. As long as all code uses the static property `PersonType.Infant`,
    it will be more stable and resistant to change.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不再依赖于“魔术字符串”。字符串"Infant"现在记录在一个地方。只要所有的代码都使用静态属性`PersonType.Infant`，它就会更加稳定，更加抗变化。
- en: Generics
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics are a way of writing code that will deal with any type of object but
    still maintain the object type integrity. So far, we have used interfaces, classes
    and TypeScript's basic types to ensure strongly typed (and less error-prone) code
    in our samples. But what happens if a block of code needs to work with any type
    of object?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是一种编写代码的方式，可以处理任何类型的对象，但仍然保持对象类型的完整性。到目前为止，我们已经在示例中使用了接口、类和TypeScript的基本类型来确保我们的代码是强类型的（并且更不容易出错）。但是如果一段代码需要处理任何类型的对象会发生什么呢？
- en: As an example, suppose we wanted to write some code that could iterate over
    an array of objects and return a concatenation of their values. So, given a list
    of numbers, say `[1,2,3]`, it should return the string `"1,2,3"`. Or, given a
    list of strings, say `["first","second","third"]`, return a string `"first,second,third"`.
    We could write some code that accepted values of type `any`, but this might introduce
    bugs in our code – remember S.F.I.A.T.? We want to ensure that all elements of
    the array are of the same type. This is where generics come in to play.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设我们想要编写一些代码，可以迭代一个对象数组并返回它们值的连接。所以，给定一个数字列表，比如`[1,2,3]`，它应该返回字符串`"1,2,3"`。或者，给定一个字符串列表，比如`["first","second","third"]`，返回字符串`"first,second,third"`。我们可以编写一些接受`any`类型值的代码，但这可能会在我们的代码中引入错误
    - 记得S.F.I.A.T.吗？我们想要确保数组的所有元素都是相同类型。这就是泛型发挥作用的地方。
- en: Generic syntax
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型语法
- en: Let's write a class called `Concatenator` that will work with any type of object,
    but still ensure that type integrity is kept in place. All JavaScript objects
    have a `toString` function, which is called whenever a string is needed by the
    runtime, so let's use this `toString` function to create a generic class that
    outputs all values held within an array.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个名为`Concatenator`的类，它可以处理任何类型的对象，但仍然确保类型完整性得到保持。所有JavaScript对象都有一个`toString`函数，每当运行时需要一个字符串时，它就会被调用，所以让我们使用这个`toString`函数来创建一个泛型类，输出数组中包含的所有值。
- en: 'A generic implementation of this `Concatenator` class is as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Concatenator`类的泛型实现如下：'
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first thing we notice is the syntax of the class declaration, `Concatenator
    < T >`. This `< T >` syntax is the syntax used to indicate a generic type, and
    the name used for this generic type in the rest of our code is `T`. The `concatenateArray`
    function also uses this generic type syntax, `Array < T >`. This indicates that
    the `inputArray` argument must be an array of the type that was originally used
    to construct an instance of this class.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第一件事是类声明的语法，`Concatenator < T >`。这个`< T >`语法是用来表示泛型类型的语法，而在我们代码的其余部分中用于这个泛型类型的名称是`T`。`concatenateArray`函数也使用了这个泛型类型的语法，`Array
    < T >`。这表示`inputArray`参数必须是最初用于构造此类实例的类型的数组。
- en: Instantiating generic classes
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化泛型类
- en: 'To use an instance of this generic class, we need to construct the class and
    tell the compiler via the `< >` syntax what the actual type of `T` is. We can
    use any type for the type of `T` in this generic syntax, including base JavaScript
    types, TypeScript classes, or even TypeScript interfaces:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个泛型类的实例，我们需要构造这个类，并通过`< >`语法告诉编译器`T`的实际类型是什么。我们可以在这个泛型语法中使用任何类型作为`T`的类型，包括基本的JavaScript类型、TypeScript类，甚至TypeScript接口：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Notice the syntax that we have used to instantiate the `Concatenator` class.
    In our first sample, we create an instance of the `Concatenator` generic class,
    and specify that it should substitute the generic type, `T`, with the type `string`
    in every place where `T` is being used within the code. Similarly, the second
    example creates an instance of the `Concatenator` class, and specifies that the
    type `number` should be used wherever the code encounters the generic type `T`.
    Our last sample shows the use of the `IPerson` interface for the generic type
    `T`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们用来实例化 `Concatenator` 类的语法。在我们的第一个示例中，我们创建了 `Concatenator` 泛型类的一个实例，并指定它应该在代码中使用
    `T` 的地方用类型 `string` 替代 `T`。类似地，第二个示例创建了 `Concatenator` 类的一个实例，并指定在代码遇到泛型类型 `T`
    时应该使用类型 `number`。我们的最后一个示例展示了使用 `IPerson` 接口作为泛型类型 `T`。
- en: 'If we use this simple substitution principle, then for the `stringConcatenator`
    instance (which uses strings), the `inputArray` argument must be of type `Array<string>`.
    Similarly, the `numberConcatenator` instance of this generic class uses numbers,
    and so the `inputArray` argument must be an array of numbers. To test this theory,
    let''s generate an array of strings and an array of numbers, and see what the
    compiler says if we try to break this rule:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个简单的替换原则，那么对于使用字符串的 `stringConcatenator` 实例，`inputArray` 参数必须是 `Array<string>`
    类型。同样，这个泛型类的 `numberConcatenator` 实例使用数字，所以 `inputArray` 参数必须是一个数字数组。为了测试这个理论，让我们生成一个字符串数组和一个数字数组，看看如果我们试图违反这个规则编译器会报什么错误：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Our first two lines define our `stringArray` and `numberArray` variables to
    hold the relevant arrays. We then pass in the `stringArray` variable to the `stringConcatenator`
    function—no problems there. On our next line, we pass the `numberArray` to the
    `numberConcatenator`—still okay.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前两行定义了我们的 `stringArray` 和 `numberArray` 变量来保存相关的数组。然后我们将 `stringArray` 变量传递给
    `stringConcatenator` 函数——没有问题。在下一行，我们将 `numberArray` 传递给 `numberConcatenator`——仍然可以。
- en: 'Our problems, however, start when we attempt to pass an array of numbers to
    the `stringConcatenator`, which has been configured to only use strings. Again,
    if we attempt to pass an array of strings to the `numberConcatenator`, which has
    been configured to allow only numbers, TypeScript will generate errors as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们试图将一个数字数组传递给只能使用字符串的 `stringConcatenator` 时，问题就开始了。同样，如果我们试图将一个只允许数字的
    `numberConcatenator` 配置为使用的字符串数组，TypeScript 将生成以下错误：
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `pop` property is the first nonmatching property between a `string[]` and
    a `number[]`, so clearly, we are attempting to pass an array of numbers where
    we should have used strings, and vice versa. Again, the compiler warns us that
    we are not using the code correctly, and forces us to resolve these issues before
    continuing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop` 属性是 `string[]` 和 `number[]` 之间的第一个不匹配的属性，所以很明显，我们试图传递一个数字数组，而应该使用字符串，反之亦然。同样，编译器警告我们没有正确使用代码，并强制我们在继续之前解决这些问题。'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These constraints on generics are a compile-time-only feature of TypeScript.
    If we look at the generated JavaScript, we will not see any reams of code that
    jumps through hoops to ensure that these rules are carried through into the resultant
    JavaScript. All of these type constraints and generic syntax are simply compiled
    away. In the case of generics, the generated JavaScript is actually a very simplified
    version of our code, with no type constraints in sight.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的这些约束是 TypeScript 的编译时特性。如果我们查看生成的 JavaScript，我们将看不到任何大量的代码，通过各种方式确保这些规则被传递到生成的
    JavaScript 中。所有这些类型约束和泛型语法都会被简单地编译掉。在泛型的情况下，生成的 JavaScript 实际上是我们代码的一个非常简化的版本，看不到任何类型约束。
- en: Using the type T
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类型 T
- en: 'When we use generics, it is important to note that all of the code within the
    definition of a generic class or a generic function must respect the properties
    of `T` as if it were any type of object. Let''s take a closer look at the implementation
    of the `concatenateArray` function in this light:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用泛型时，重要的是要注意泛型类或泛型函数定义中的所有代码都必须尊重 `T` 的属性，就好像它是任何类型的对象一样。让我们更仔细地看一下在这种情况下
    `concatenateArray` 函数的实现：
- en: '[PRE45]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `concatenateArray` function strongly types the `inputArray` argument so
    that it should be of type `Array <T>` . This means that any code that uses the
    `inputArray` argument can use only those functions and properties that are common
    to all arrays, no matter what type the array holds. In this code sample, we used
    `inputArray` in two places.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`concatenateArray` 函数强类型化了 `inputArray` 参数，所以它应该是 `Array <T>` 类型。这意味着使用 `inputArray`
    参数的任何代码都只能使用所有数组共有的函数和属性，无论数组保存的是什么类型的对象。在这个代码示例中，我们在两个地方使用了 `inputArray`。'
- en: Firstly, in our for loop, note where we have used the `inputArray.length` property.
    All arrays have a `length` property to indicate how many items the array has,
    so using `inputArray.length` will work on any array, no matter what type of object
    the array holds. Secondly, we reference an object within the array when we use
    the `inputArray[i]` syntax. This reference actually returns a single object of
    type `T`. Remember that whenever we use `T` in our code, we must use only those
    functions and properties that are common to any object of type `T`. Luckily for
    us, we are using only the `toString` function, and all JavaScript objects, no
    matter what type they are, have a valid `toString` function. So this generic code
    block will compile cleanly.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们的 for 循环中，注意我们使用了 `inputArray.length` 属性。所有数组都有一个 `length` 属性来表示数组有多少项，所以使用
    `inputArray.length` 在任何数组上都可以工作，无论数组保存的是什么类型的对象。其次，当我们使用 `inputArray[i]` 语法引用数组中的对象时，我们实际上返回了一个类型为
    `T` 的单个对象。记住，无论我们在代码中使用 `T`，我们只能使用所有类型为 `T` 的对象共有的函数和属性。幸运的是，我们只使用了 `toString`
    函数，而所有 JavaScript 对象，无论它们是什么类型，都有一个有效的 `toString` 函数。所以这个泛型代码块将编译通过。
- en: 'Lets test this type `T` theory by creating a class of our own to pass into
    the `Concatenator` class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个自己的类来测试这个 `T` 类型理论，然后将其传递给 `Concatenator` 类：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This sample starts with a class, named `MyClass`, that has a `constructor`
    accepting a number. It then assigns an internal variable called `_name` to a value
    of `arg1` , concatenated with the `"_MyClass"` string. Next, we create an array
    called `myArray`, and construct some instances of `MyClass` within this array.
    We then create an instance of the `Concatenator` class, specifying that this generic
    instance will only work with objects that are of type `MyClass`. We then call
    the `concatenateArray` function and store the result in a variable named `myArrayResult`.
    Finally, we print the result on the console. Running this code in the browser
    will produce the following output:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例以一个名为`MyClass`的类开始，该类有一个接受数字的`constructor`。然后，它将一个名为`_name`的内部变量赋值为`arg1`的值，与`"_MyClass"`字符串连接在一起。接下来，我们创建了一个名为`myArray`的数组，并在这个数组中构造了一些`MyClass`的实例。然后，我们创建了一个`Concatenator`类的实例，指定这个泛型实例只能与`MyClass`类型的对象一起使用。然后，我们调用`concatenateArray`函数，并将结果存储在一个名为`myArrayResult`的变量中。最后，我们在控制台上打印结果。在浏览器中运行这段代码将产生以下输出：
- en: '[PRE47]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Hmmm, not quite what we were expecting! This strange output is because the
    string representation of an object - that is not one of the basic JavaScript types
    - resolves to `[object type]`. Any custom object that you write may need to override
    the `toString` function to provide human-readable output. We can fix this code
    quite easily by providing an override of the `toString` function within our class,
    as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不太符合我们的预期！这个奇怪的输出是因为对象的字符串表示形式 - 不是基本JavaScript类型之一 - 解析为`[object type]`。您编写的任何自定义对象可能需要重写`toString`函数以提供人类可读的输出。我们可以通过在我们的类中提供`toString`函数的重写来很容易地修复这段代码，如下所示：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the code above, we have replaced the default `toString` function that all
    JavaScript objects inherit, with our own implementation. Within this function,
    we simply returned the value of the `_name` private variable. Running this sample
    now produces the expected result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们用自己的实现替换了所有JavaScript对象继承的默认`toString`函数。在这个函数中，我们只是返回了`_name`私有变量的值。现在运行这个示例会产生预期的结果：
- en: '[PRE49]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Constraining the type of T
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制T的类型
- en: 'When using generics, it is sometimes desirable to constrain the type of `T`
    to be only a specific type, or subset of types. In these cases, we don''t want
    our generic code to be available for any type of object, we only want it to be
    available for a specific subset of objects. TypeScript uses inheritance to accomplish
    this with generics. As an example, let''s refactor our earlier Factory Design
    Pattern code to use a generic `PersonPrinter` class, that is specifically designed
    to work with classes that implement the `IPerson` interface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用泛型时，有时希望限制`T`的类型只能是特定类型或类型的子集。在这些情况下，我们不希望我们的泛型代码对任何类型的对象都可用，我们只希望它对特定的对象子集可用。TypeScript使用继承来实现这一点。例如，让我们重构我们之前的工厂设计模式代码，使用一个特定设计为与实现`IPerson`接口的类一起工作的泛型`PersonPrinter`类：
- en: '[PRE50]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this code snippet, we define a class called `PersonPrinter`, that uses the
    generic syntax. Note that the `T` generic type has been derived from the `IPerson`
    interface, as indicated by the `extends` keyword in `< T extents IPerson >`. This
    indicates that any usage of the type `T` will substitute the interface `IPerson`,
    and can therefore, only allow functions or properties that are defined in the
    `IPerson` interface to be used wherever `T` is used. The `print` function accepts
    an argument named `arg`, which is of type `T`. Using our rules of generics, we
    know that any usage of the variable `arg` is only allowed to use available functions
    from the `IPerson` interface.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，我们定义了一个名为`PersonPrinter`的类，它使用了泛型语法。请注意，`T`泛型类型是从`IPerson`接口派生的，如`<
    T extents IPerson >`中的`extends`关键字所示。这表示`T`类型的任何使用都将替代`IPerson`接口，并且因此，只允许在使用`T`的任何地方使用`IPerson`接口中定义的函数或属性。`print`函数接受一个名为`arg`的参数，其类型为`T`。根据我们的泛型规则，我们知道`arg`变量的任何使用只允许使用`IPerson`接口中可用的函数。
- en: The `print` function builds up a string to log to the console, and only uses
    functions that are defined in the `IPerson` interface. These include the functions
    `getDateOfBirth` and `getPersonCategory`. In order to generate a grammatically
    correct sentence, we have introduced another function called `getPermissionString`
    that accepts an argument of type `T`, or the `IPerson` interface. This function
    simply uses the `canSignContracts()` function of the `IPerson` interface to return
    either a blank string or the string `"NOT "`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`函数构建一个字符串以记录到控制台，并且只使用`IPerson`接口中定义的函数。这些函数包括`getDateOfBirth`和`getPersonCategory`。为了生成一个语法正确的句子，我们引入了另一个名为`getPermissionString`的函数，它接受一个`T`类型或`IPerson`接口的参数。这个函数简单地使用`IPerson`接口的`canSignContracts()`函数来返回一个空字符串或字符串`"NOT"`。'
- en: 'To illustrate the usage of this class, consider the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个类的用法，考虑以下代码：
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: First, we create a new instance of the `PersonFactory` class. We then create
    an instance of the generic `PersonPrinter` class, and set the type of the argument
    `T` to be of type `IPerson`. This means that any class that is passed into the
    instance of `PersonPrinter` must implement the `IPerson` interface. We know from
    our previous examples that the `PersonFactory` will return an instance of either
    an `Infant`, `Child`, or `Adult` class, and each of these classes implement the
    `IPerson` interface. We know therefore, that any class returned by the `PersonFactory`
    will be accepted by the `personPrinter` generic class instance.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了`PersonFactory`类的一个新实例。然后我们创建了泛型`PersonPrinter`类的一个实例，并将参数`T`的类型设置为`IPerson`类型。这意味着传递给`PersonPrinter`实例的任何类都必须实现`IPerson`接口。我们从之前的例子中知道，`PersonFactory`将返回`Infant`、`Child`或`Adult`类的一个实例，而这些类都实现了`IPerson`接口。因此，我们知道`PersonFactory`返回的任何类都将被`personPrinter`泛型类实例接受。
- en: Next, we instantiate variables named `child`, `adult`, and `infant`, and rely
    on the `PersonFactory` to return us the correct class based on their date of birth.
    The last three lines of this sample simply log to the console the sentence that
    is generated by the `personPrinter` generic class instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实例化了名为`child`、`adult`和`infant`的变量，并依靠`PersonFactory`根据他们的出生日期返回正确的类。这个示例的最后三行简单地将`personPrinter`泛型类实例生成的句子记录到控制台上。
- en: 'The output of this code is as we expected:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出和我们预期的一样：
- en: '![Constraining the type of T](img/9665OS_03_02.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![限制T的类型](img/9665OS_03_02.jpg)'
- en: Generics PersonFactory output
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型PersonFactory输出
- en: Generic interfaces
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型接口
- en: 'We can also use interfaces with the generic type syntax. For our `PersonPrinter`
    class, the matching interface definition would be:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用泛型类型语法与接口一起使用。对于我们的`PersonPrinter`类，匹配的接口定义将是：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This interface looks identical to our class definition, the only difference
    being that the `print` and the `getPermissionString` functions do not have an
    implementation. We have kept the generic type syntax using `< T >`, and further
    specified that the type `T` must implement the `IPerson` interface. To use this
    interface with the `PersonPrinter` class, we modify the class definition, as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口看起来和我们的类定义一样，唯一的区别是`print`和`getPermissionString`函数没有实现。我们保留了使用`< T >`的泛型类型语法，并进一步指定类型`T`必须实现`IPerson`接口。为了将这个接口用于`PersonPrinter`类，我们修改类定义如下：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This syntax seems pretty straightforward. As we have seen before, we use the
    `implements` keyword following the class definition, and then use the interface
    name. Note, however, that we pass the type `T` into the interface definition of
    `IPersonPrinter` as a generic type `IPersonPrinter<T>`. This satisfies the `IPersonPrinter`
    generic interface definition.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来很简单。和之前一样，我们使用`implements`关键字跟在类定义后面，然后使用接口名。但是需要注意的是，我们将类型`T`传递到`IPersonPrinter`接口定义中作为泛型类型`IPersonPrinter<T>`。这满足了`IPersonPrinter`泛型接口定义的要求。
- en: 'An interface that defines our generic classes further protects our code from
    being modified inadvertently. As an example of this, suppose that we tried to
    redefine the class definition of `PersonPrinter` so that `T` is not constrained
    to be of type `IPerson`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 定义我们的泛型类的接口进一步保护了我们的代码，防止它被无意中修改。举个例子，假设我们试图重新定义`PersonPrinter`类的类定义，使得`T`不再被限制为`IPerson`类型：
- en: '[PRE54]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here, we have removed the constraint on the type `T` for the `PersonPrinter`
    class. TypeScript will automatically generate an error:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经移除了`PersonPrinter`类中对类型`T`的约束。TypeScript会自动生成一个错误：
- en: '[PRE55]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This error points us to our erroneous class definition; the type `T`, as used
    in the code (`PersonPrinter<T>`), must use a type `T` that extends from `IPerson`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误指向了我们错误的类定义；代码中使用的`T`类型（`PersonPrinter<T>`）必须使用一个从`IPerson`继承的类型`T`。
- en: Creating new objects within generics
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在泛型中创建新对象
- en: 'From time to time, generic classes may need to create an object of the type
    that is passed in as the generic type `T`. Consider the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，泛型类可能需要创建一个作为泛型类型`T`传入的类型的对象。考虑以下代码：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we have two class definitions, `FirstClass` and `SecondClass`. `FirstClass`
    just has a public `id` property, and `SecondClass` has a public `name` property.
    We then have a generic class that accepts a type `T` and has a single function,
    named `create`. This `create` function attempts to create a new instance of the
    type `T`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个类定义，`FirstClass`和`SecondClass`。`FirstClass`只有一个公共的`id`属性，`SecondClass`有一个公共的`name`属性。然后我们有一个接受类型`T`的泛型类，并有一个名为`create`的函数。这个`create`函数试图创建一个类型`T`的新实例。
- en: 'The last four lines of the sample show us how we would like to use this generic
    class. The `creator1` variable creates a new instance of the `GenericCreator`
    class using the correct syntax for creating variables of type `FirstClass`. The
    `creator2` variable is a new instance of the `GenericCreator` class, but this
    time is using `SecondClass`. Unfortunately, the preceding code will generate a
    TypeScript compile error:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的最后四行展示了我们如何使用这个泛型类。`creator1`变量使用正确的语法创建了`FirstClass`类型的新实例。`creator2`变量是`GenericCreator`类的一个新实例，但这次使用的是`SecondClass`。不幸的是，前面的代码会生成一个TypeScript编译错误：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'According to the TypeScript documentation, in order to enable a generic class
    to create objects of type `T`, we need to refer to type `T` by its `constructor`
    function. We also need to pass in the class definition as an argument. The `create`
    function will need to be rewritten as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 根据TypeScript文档，为了使泛型类能够创建类型为`T`的对象，我们需要通过它的`constructor`函数引用类型`T`。我们还需要将类定义作为参数传递。`create`函数需要重写如下：
- en: '[PRE58]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s break this `create` function down into its component parts. First, we
    pass an argument, named `arg1`. This argument is then defined to be of type `{
    new(): T }`. This is the little trick that allows us to refer to `T` by its `constructor`
    function. We are defining a new anonymous type that overloads the `new()` function
    and returns a type `T`. This means that the `arg1` argument is a function that
    is strongly typed to have a single `constructor` that returns a type `T`. The
    implementation of this function simply returns a new instance of the `arg1` variable.
    Using this syntax removes the compile error that we encountered before.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们把这个`create`函数分解成它的组成部分。首先，我们传递一个名为`arg1`的参数。然后，定义这个参数的类型为`{ new(): T }`。这是一个小技巧，允许我们通过它的`constructor`函数来引用`T`。我们定义了一个新的匿名类型，重载了`new()`函数并返回了一个类型`T`。这意味着`arg1`参数是一个被强类型化的函数，它具有返回类型为`T`的单个`constructor`。这个函数的实现简单地返回`arg1`变量的一个新实例。使用这种语法消除了我们之前遇到的编译错误。'
- en: 'This change, however, means that we must pass the class definition to the create
    function, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个改变意味着我们必须将类定义传递给`create`函数，如下所示：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note the change in usage of the `create` function on lines 2 and 5\. We are
    now required to pass in the class definition for our type of `T`: `create(FirstClass)`
    and `create(SecondClass)` as our first argument. Try running this code in your
    browser and see what happens. The generic class will, in fact, create new objects
    of types `FirstClass` and `SecondClass`, as we expected.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在第2行和第5行上`create`函数的用法的变化。我们现在需要传入我们的`T`类型的类定义作为第一个参数：`create(FirstClass)`和`create(SecondClass)`。尝试在浏览器中运行这段代码，看看会发生什么。泛型类实际上会创建`FirstClass`和`SecondClass`类型的新对象，正如我们所期望的。
- en: Runtime type checking
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时类型检查
- en: Although the TypeScript compiler generates compilation errors for incorrectly
    typed code, this type checking is compiled away in the generated JavaScript. This
    means that the JavaScript runtime engine knows nothing about TypeScript interfaces
    or generics. So how can we tell at runtime whether a class implements an interface?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管TypeScript编译器对类型不正确的代码生成编译错误，但这种类型检查在生成的JavaScript中被编译掉了。这意味着JavaScript运行时引擎对TypeScript接口或泛型一无所知。那么我们如何在运行时告诉一个类是否实现了一个接口呢？
- en: JavaScript has some functions that we can use when dealing with objects, that
    will tell us what type an object is, or if one object is an instance of another.
    For type information, we can use the JavaScript `typeof` keyword, and for instance
    information, we can use `instanceof`. Let's have a look at what these functions
    return, given some simple TypeScript classes, and see if we can use these to tell
    whether a class implements an interface.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript有一些函数，当处理对象时可以告诉我们对象的类型，或者一个对象是否是另一个对象的实例。对于类型信息，我们可以使用JavaScript的`typeof`关键字，对于实例信息，我们可以使用`instanceof`。让我们看看在给定一些简单的TypeScript类时，这些函数返回什么，并看看我们是否可以使用它们来判断一个类是否实现了一个接口。
- en: 'First, a simple base class:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个简单的基类：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This `TcBaseClass` class has an `id` property, and a `constructor` that sets
    this property based on the argument passed to it.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TcBaseClass`类有一个`id`属性和一个根据传递给它的参数设置这个属性的`constructor`。
- en: 'Then, a class that is derived from `TcBaseClass`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个从`TcBaseClass`派生的类：
- en: '[PRE61]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This `TcDerivedClass` class derives (or extends) from the `TcBase` class, and
    adds a `name` property and a `print` function. The constructor of this derived
    class must call the constructor of the base class, passing in the `idArg` argument
    via the `super` function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`TcDerivedClass`类派生（或扩展）自`TcBase`类，并添加了一个`name`属性和一个`print`函数。这个派生类的构造函数必须调用基类的构造函数，通过`super`函数传递`idArg`参数。
- en: 'Now, let''s construct a variable named `base` that is a new instance of `TcBaseClass`,
    and then construct a variable named `derived` that is a new instance of `TcDerivedClass`,
    as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构造一个名为`base`的变量，它是`TcBaseClass`的一个新实例，然后构造一个名为`derived`的变量，它是`TcDerivedClass`的一个新实例，如下所示：
- en: '[PRE62]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now for some tests; let''s see what the `typeof` function returns for each
    of these classes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行一些测试；让我们看看对于这些类，`typeof`函数返回什么：
- en: '[PRE63]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This code will return:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回：
- en: '[PRE64]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This tells us that the JavaScript runtime engine sees an instance of a class
    as an object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们JavaScript运行时引擎将一个类的实例视为一个对象。
- en: 'Let''s now switch over to the `instanceof` keyword, and use it to check whether
    an object is derived from another:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到`instanceof`关键字，并使用它来检查一个对象是否是从另一个对象派生的：
- en: '[PRE65]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This code will return:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回：
- en: '[PRE66]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'So far so good. Now let''s have a look at what the `typeof` keyword returns
    when we use it on a class''s properties:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。现在让我们看看当我们在一个类的属性上使用`typeof`关键字时它返回什么：
- en: '[PRE67]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code will return:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回：
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As we can see, the JavaScript runtime correctly identifies the `id` property
    of our base type as a number, the `name` property as a string, and the `print`
    property as a function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，JavaScript运行时正确地将我们的基本类型的`id`属性识别为数字，`name`属性为字符串，`print`属性为函数。
- en: So how can we tell at runtime what the type of an object is? The simple answer
    is that we can't easily tell. We can only tell whether an object is an instance
    of another object, or if a property is one of the basic JavaScript types. If we
    were trying to us the `instanceof` function to implement a type checking algorithm,
    we would need to check the incoming object against every known type in our object
    tree, which is certainly not ideal. We also can't use `instanceof` to check whether
    a class implements an interface, as TypeScript interfaces are compiled away.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在运行时告诉对象的类型是什么？简单的答案是我们不能轻易地告诉。我们只能告诉一个对象是否是另一个对象的实例，或者一个属性是否是基本的JavaScript类型之一。如果我们试图使用`instanceof`函数来实现类型检查算法，我们需要检查传入的对象是否与对象树中的每个已知类型匹配，这显然不是理想的。我们也不能使用`instanceof`来检查一个类是否实现了一个接口，因为TypeScript接口被编译掉了。
- en: Reflection
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反射
- en: Other statically typed languages allow the runtime engine to query an object,
    determine what type the object is, and also query what interfaces an object implements.
    This process is called reflection.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其他静态类型的语言允许运行时引擎查询对象，确定对象的类型，并查询对象实现了哪些接口。这个过程称为反射。
- en: As we have seen, using the `typeof` or `instanceof` JavaScript functions, we
    can glean some information from the runtime about an object. On top of these abilities,
    we could also use the `getPrototypeOf` function to return some information about
    the class constructor. The `getPrototypeOf` function returns a string, so we could
    then parse this string to determine the class name. Unfortunately, the implementation
    of the `getPrototypeOf` function returns slightly different strings, depending
    on what browser is being used. It is also only implemented in ECMAScript 5.1 and
    above, which again, may introduce problems when running on older browsers or mobile
    browsers.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，使用`typeof`或`instanceof` JavaScript函数，我们可以从运行时获取一些关于对象的信息。除了这些能力之外，我们还可以使用`getPrototypeOf`函数来返回有关类构造函数的一些信息。`getPrototypeOf`函数返回一个字符串，所以我们可以解析这个字符串来确定类名。不幸的是，`getPrototypeOf`函数的实现返回的字符串略有不同，这取决于使用的浏览器。它也只在ECMAScript
    5.1及以上版本中实现，这可能在旧版浏览器或移动浏览器上运行时引入问题。
- en: Another JavaScript function we could use to find runtime information about an
    object is the `hasOwnProperty` function. This has been a part of JavaScript since
    ECMAScript 3, and so is compatible with just about every browser, both desktop
    and mobile. The `hasOwnProperty` function will return `true` or `false`, indicating
    whether an object has the property that you are looking for.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`hasOwnProperty`函数来查找关于对象的运行时信息。这是自ECMAScript 3以来JavaScript的一部分，因此与几乎所有桌面和移动浏览器兼容。`hasOwnProperty`函数将返回`true`或`false`，指示对象是否具有您正在寻找的属性。
- en: 'The TypeScript compiler helps us program JavaScript in an object-oriented way
    using interfaces, but these interfaces are "compiled away", and do not appear
    in the generated JavaScript. As an example of this, let''s have a look at the
    following TypeScript code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器帮助我们以面向对象的方式使用接口来编写JavaScript，但这些接口被“编译掉”，并不会出现在生成的JavaScript中。例如，让我们看一下以下TypeScript代码：
- en: '[PRE69]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is a simple example of defining an interface and implementing it in a
    class. The `IBasicObject` interface has an `id` of type `number`, a `name` of
    type `string`, and a `print` function. The class definition `BasicObject` implements
    all the required properties and parameters. Now let''s have a look at the compiled
    JavaScript that TypeScript generates:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，定义一个接口并在一个类中实现它。`IBasicObject`接口具有一个类型为`number`的`id`，一个类型为`string`的`name`，以及一个`print`函数。类定义`BasicObject`实现了所有必需的属性和参数。现在让我们来看一下TypeScript生成的编译后的JavaScript：
- en: '[PRE70]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The TypeScript compiler has not included any JavaScript for the `IBasicObject`
    interface. All we have here is a closure pattern for the `BasicObject` class definition.
    The `IBasicObject` interface, although used by the TypeScript compiler, does not
    exist in the generated JavaScript. Hence, we say that it has been "compiled away".
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器没有包含`IBasicObject`接口的任何JavaScript。这里我们只有一个`BasicObject`类定义的闭包模式。虽然TypeScript编译器使用了`IBasicObject`接口，但在生成的JavaScript中并不存在。因此，我们说它已经被“编译掉”了。
- en: 'This therefore presents us with a few problems when implementing reflection-like
    capabilities within JavaScript:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在JavaScript中实现类似反射的能力时，这给我们带来了一些问题：
- en: We cannot tell at runtime whether an object implements a TypeScript interface
    because TypeScript interfaces are compiled away
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们无法在运行时确定对象是否实现了TypeScript接口，因为TypeScript接口被编译掉了
- en: We cannot loop through an object's properties using the `getOwnPropertyNames`
    function on older ECMAScript 3 browsers
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在旧的ECMAScript 3浏览器上，我们不能使用`getOwnPropertyNames`函数来循环遍历对象的属性
- en: We cannot use the `getPrototypeOf` function on older ECMAScript 3 browsers to
    determine a class name
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能在旧的ECMAScript 3浏览器上使用`getPrototypeOf`函数来确定类名
- en: The implementation of the `getPrototypeOf` function is not consistent across
    browsers
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPrototypeOf`函数的实现在不同的浏览器中并不一致'
- en: We cannot use the `instanceof` keyword to determine a class type without comparing
    it with known types
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能使用`instanceof`关键字来确定类类型，而不是与已知类型进行比较
- en: Checking an object for a function
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查对象是否具有一个函数
- en: So how do we tell at runtime whether an object implements an interface?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何在运行时确定对象是否实现了一个接口？
- en: In their book, *Pro JavaScript Design Patterns* ([http://jsdesignpatterns.com/](http://jsdesignpatterns.com/)),
    Ross Harmes and Dustin Diaz discuss this quandary, and come up with a rather simple
    solution. We can invoke a function on an object using a string which contains
    the function name, and then check whether the result is valid, or `undefined`.
    In their book, they build a utility function using this principle, to check at
    runtime whether an object has a set of defined properties and methods. These defined
    properties and methods are kept within the JavaScript code as simple string arrays.
    These string arrays therefore act as object "metadata" for our code that we can
    then pass through to a function checking utility.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的书*Pro JavaScript Design Patterns* ([http://jsdesignpatterns.com/](http://jsdesignpatterns.com/))中，Ross
    Harmes和Dustin Diaz讨论了这个困境，并提出了一个相当简单的解决方案。我们可以使用包含函数名称的字符串在对象上调用一个函数，然后检查结果是否有效，或者是`undefined`。在他们的书中，他们使用这个原则构建了一个实用函数，用于在运行时检查对象是否具有一组定义的属性和方法。这些定义的属性和方法被保存在JavaScript代码中作为简单的字符串数组。因此，这些字符串数组充当了我们的代码的对象“元数据”，我们可以将其传递给一个函数检查工具。
- en: 'Their `FunctionChecker` utility class can be written in TypeScript as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 他们的`FunctionChecker`实用类可以在TypeScript中编写如下：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This `FunctionChecker` class has a single static function, named `implementsFunction`,
    that will return either `true` or `false`. The `implementsFunction` function takes
    an argument named `objectToCheck` and a string named `functionName`. Note that
    the type of `objectToCheck` is specifically set to `any`. This is one of the rare
    circumstances where the use of the `any` type is actually the correct TypeScript
    type.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`FunctionChecker`类有一个名为`implementsFunction`的静态函数，它将返回`true`或`false`。`implementsFunction`函数接受一个名为`objectToCheck`的参数和一个名为`functionName`的字符串。请注意，`objectToCheck`的类型被明确定义为`any`。这是`any`类型实际上是正确的TypeScript类型的罕见情况之一。
- en: 'Within the `implementsFunction` function, we use a special kind of JavaScript
    syntax that reads the function itself from the object, using the `[ ]` syntax
    on an instance of the object, and referencing it by name : `objectToCheck[functionName]`.
    If the object we are interrogating has this attribute, then invoking it will return
    something other than `undefined`. We can then use the `typeof` keyword to check
    the type of the attribute. If the `typeof` instance returns "function", then we
    know that this object implements this function. Let''s have a look at some quick
    usages:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在`implementsFunction`函数中，我们使用一种特殊的JavaScript语法，使用`[]`语法从对象的实例中读取函数本身，并通过名称引用它：`objectToCheck[functionName]`。如果我们正在查询的对象具有这个属性，那么调用它将返回除`undefined`之外的东西。然后我们可以使用`typeof`关键字来检查属性的类型。如果`typeof`实例返回“function”，那么我们知道这个对象实现了这个函数。让我们来看一些快速的用法：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Line 1, simply creates an instance of the `BasicObject` class, and assigns
    it to the `myClass` variable. Line 2 then invokes our `implementsFunction` function,
    passing in the instance of the class and the string "print". Line 3 logs the result
    to the console. Line 4 and 5 repeat the process, but check whether the `myClass`
    instance implements the function "alert". The results of this code would be the
    following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第1行，简单地创建了`BasicObject`类的一个实例，并将其赋给`myClass`变量。然后第2行调用我们的`implementsFunction`函数，传入类的实例和字符串“print”。第3行将结果记录到控制台。第4行和第5行重复这个过程，但是检查`myClass`实例是否实现了函数“alert”。这段代码的结果将是以下内容：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This `implementsFunction` function allows us to interrogate an object and check
    whether it has a specific function by name. Extending this concept slightly, brings
    us to a simple way of carrying out runtime type checking. All we need is a list
    of functions (or properties) that a JavaScript object should implement. This list
    of functions (or properties) can be described as class "metadata".
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`implementsFunction`函数允许我们询问一个对象，并检查它是否具有特定名称的函数。稍微扩展这个概念，就可以简单地进行运行时类型检查。我们只需要一个JavaScript对象应该实现的函数（或属性）列表。这个函数（或属性）列表可以被描述为类的“元数据”。
- en: Interface checking with generics
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用泛型进行接口检查
- en: This technique that Ross and Dustin describe, of holding "metadata" information
    about interfaces, is easily implemented in TypeScript. If we define classes that
    hold this "metadata" for each of our interfaces, we can then use them to check
    objects at runtime. Let's put together an interface that holds an array of method
    names to check an object against, as well as a list of property names.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 罗斯和达斯汀描述的这种持有接口“元数据”信息的技术在TypeScript中很容易实现。如果我们定义了为每个接口持有这些“元数据”的类，我们就可以在运行时使用它们来检查对象。让我们组合一个接口，其中包含一个方法名称数组，用于检查对象，以及一个属性名称列表。
- en: '[PRE74]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This `IInterfaceChecker` interface is very simple—an optional array of `methodNames`,
    and an optional array of `propertyNames`. Now let''s implement this interface
    to describe the necessary properties and methods of the TypeScript `IBasicObject`
    interface:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`IInterfaceChecker`接口非常简单——一个可选的`methodNames`数组，和一个可选的`propertyNames`数组。现在让我们实现这个接口，描述TypeScript的`IBasicObject`接口的必要属性和方法：
- en: '[PRE75]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We start off with a class definition that implements the `IInterfaceChecker`
    interface. This class has been named `IIBasicObject`, with a double `I` prefix
    in the class name. This is a simple naming convention that indicates that the
    `IIBasicObject` class holds "metadata" for the `IBasicObject` interface that we
    defined earlier. The `methodNames` array specifies that this interface must implement
    the `print` method, and the `propertyNames` array specifies that this interface
    also includes an `id` and a `name` property.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从实现`IInterfaceChecker`接口的类定义开始。这个类被命名为`IIBasicObject`，类名前缀有两个`I`。这是一个简单的命名约定，表示`IIBasicObject`类持有我们之前定义的`IBasicObject`接口的“元数据”。`methodNames`数组指定了这个接口必须实现`print`方法，`propertyNames`数组指定了这个接口还包括`id`和`name`属性。
- en: This method of defining metadata for an object is a very simple solution to
    our problem, and is both browser agnostic and ECMAScript version agnostic. While
    this may require us to keep "metadata" objects in sync with TypeScript interfaces,
    we now have what we need in order to check whether an object implements a defined
    interface.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 为对象定义元数据的这种方法是我们问题的一个非常简单的解决方案，而且既不依赖于浏览器，也不依赖于ECMAScript的版本。虽然这可能需要我们将“元数据”对象与TypeScript接口保持同步，但现在我们已经有了必要的东西来检查一个对象是否实现了一个定义好的接口。
- en: 'We can also use what we know about generics to implement an `InterfaceChecker`
    class that uses these object "metadata" classes:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用我们对泛型的了解来实现一个使用这些对象“元数据”类的`InterfaceChecker`类：
- en: '[PRE76]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We start off with a generic class, named `InterfaceChecker`, that accepts any
    object `T` that implements the `IInterfaceChecker` class. Again, the definition
    of the `IInterface` class is just an array of `methodNames` and an array of `propertyNames`.
    This class only has a single function named `implementsInterface` that returns
    a boolean—true if the class implements all properties and methods, and false if
    it does not. The first parameter, `classToCheck`, is the class instance that we
    are interrogating against the interface "metadata". Our second parameter uses
    the generic syntax that we discussed earlier to be able to create a new instance
    of the type `T`— which in this case is any type that implements the `IInterfaceChecker`
    interface.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从一个泛型类`InterfaceChecker`开始，它接受任何实现`IInterfaceChecker`类的对象`T`。同样，`IInterface`类的定义只是一个`methodNames`数组和一个`propertyNames`数组。这个类只有一个名为`implementsInterface`的函数，它返回一个布尔值——如果类实现了所有属性和方法，则返回true，否则返回false。第一个参数`classToCheck`是我们正在对接口“元数据”进行询问的类实例。我们的第二个参数使用了我们之前讨论过的泛型语法，可以创建类型`T`的一个新实例——在这种情况下，是任何实现了`IInterfaceChecker`接口的类型。
- en: The body of the code is an extension of the `FunctionChecker` class that we
    discussed earlier. We first need to create an instance of the type `T`, which
    is assigned to the variable `targetInterface`. We then simply loop through all
    the strings in the `methodNames` array, and check whether our `classToCheck` object
    implements these functions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的主体是我们之前讨论过的`FunctionChecker`类的扩展。我们首先需要创建类型`T`的一个实例，赋给变量`targetInterface`。然后我们简单地循环遍历`methodNames`数组中的所有字符串，并检查我们的`classToCheck`对象是否实现了这些函数。
- en: We then repeat this process, checking the given strings in the `propertyNames`
    array.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们重复这个过程，检查`propertyNames`数组中给定的字符串。
- en: The last lines of this code sample show us how we would use this `InterfaceChecker`
    class. First, we create an instance of `BasicObject` and assign it to the variable
    `myClass`. We then create an instance of the `InterfaceChecker` class and assign
    it to the variable `interfaceChecker`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码示例的最后几行展示了我们如何使用这个`InterfaceChecker`类。首先，我们创建了`BasicObject`的一个实例，并将其赋给变量`myClass`。然后我们创建了`InterfaceChecker`类的一个实例，并将其赋给变量`interfaceChecker`。
- en: The second last line of this snippet calls the `implementsInterface` function,
    passing in the `myClass` instance, and `IIBasicObject`. Note that we are not passing
    in an instance of the `IIBasicObject` class, we are just passing in the class
    definition. Our generic code will create an internal instance of the `IIBasicObject`
    class.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段的倒数第二行调用`implementsInterface`函数，传入`myClass`实例和`IIBasicObject`。请注意，我们并没有传入`IIBasicObject`类的实例，而是只传入了类定义。我们的通用代码将创建`IIBasicObject`类的内部实例。
- en: 'The last line of this code simply logs a `true` or `false` message to the console.
    The output of this line would be:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的最后一行只是将一个`true`或`false`消息记录到控制台。这行的输出将是：
- en: '[PRE77]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Let''s now run the code with an invalid object:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用一个无效的对象运行代码：
- en: '[PRE78]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The variable `noPrintFunction` has both an `id` and a `name` property, but
    it does not implement a `print` function. The output of this code would be:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`noPrintFunction`既有`id`属性又有`name`属性，但它没有实现`print`函数。这段代码的输出将是：
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: We now have a way of determining at runtime whether or not an object implements
    a defined interface. This technique can be used on external JavaScript libraries
    that you do not control—or even in larger teams where the API for a particular
    library is agreed in principle, before the libraries are written. In these cases,
    once a new version of the library is delivered, the consumers can quickly and
    easily ensure that the API conforms to the design specification.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种在运行时确定对象是否实现了定义的接口的方法。这种技术可以用于您无法控制的外部JavaScript库，甚至可以用于更大的团队，在这些团队中，特定库的API在库编写之前原则上已经达成一致。在这些情况下，一旦交付了库的新版本，消费者就可以迅速轻松地确保API符合设计规范。
- en: Interfaces are used in a number of design patterns, and even though we can implement
    these patterns using TypeScript, we may want to further solidify our code by doing
    runtime checking of an object's interface. This technique also opens up the possibility
    of writing an **Inversion of Control** (**IOC**) container in TypeScript, or an
    implementation of the Domain Events Pattern. We will explore these two design
    patterns in more detail in [Chapter 8](ch08.html "Chapter 8. Object-oriented Programming
    with TypeScript"), *Object-oriented Programming with TypeScript*.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 接口在许多设计模式中使用，即使我们可以使用TypeScript实现这些模式，我们可能还想通过运行时检查对象的接口来进一步巩固我们的代码。这种技术还打开了在TypeScript中编写**控制反转**（**IOC**）容器或领域事件模式的实现的可能性。我们将在[第8章](ch08.html
    "第8章 TypeScript面向对象编程")中更详细地探讨这两种设计模式，*TypeScript面向对象编程*。
- en: Summary
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the object-oriented concepts of interfaces, classes
    and generics. We discussed both interface inheritance and class inheritance, and
    used our knowledge on interfaces, classes and inheritance to create a Factory
    Design Pattern implementation in TypeScript. We then moved on to generics and
    their syntax, generic interfaces and generic constructor functions. We finished
    the chapter off with a discussion on reflection, and implemented a TypeScript
    version of an `InterfaceChecker` pattern using generics. In the next chapter,
    we will look at the mechanism that TypeScript uses to integrate with existing
    JavaScript libraries—definition files.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了接口、类和泛型的面向对象概念。我们讨论了接口继承和类继承，并利用我们对接口、类和继承的知识在TypeScript中创建了工厂设计模式的实现。然后我们转向泛型及其语法，泛型接口和泛型构造函数。最后，我们在反射方面进行了讨论，并使用泛型实现了TypeScript版本的`InterfaceChecker`模式。在下一章中，我们将看一下TypeScript用于与现有JavaScript库集成的机制——定义文件。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
