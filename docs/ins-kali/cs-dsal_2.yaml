- en: Arrays and Lists
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和列表
- en: As a developer, you have certainly stored various collections within your applications,
    such as user data, books, and logs. One of the natural ways of storing such data
    is by using arrays and lists. However, have you ever thought about their variants?
    Have you heard about jagged arrays or circular-linked lists? In this chapter you
    will see such data structures in action, together with examples and detailed descriptions.
    That is not all, because the chapter is related to many topics regarding arrays
    and lists, suitable for developers with various levels of programming skills.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员，您肯定在应用程序中存储了各种集合，例如用户数据、书籍和日志。存储这些数据的一种自然方式是使用数组和列表。但是，您是否曾想过它们的变体？您是否听说过交错数组或循环链表？在本章中，您将看到这些数据结构的实际应用，以及示例和详细描述。这还不是全部，因为本章涉及许多关于数组和列表的主题，适合具有不同编程技能水平的开发人员。
- en: At the start of the chapter, the arrays will be presented and divided into single-dimensional,
    multi-dimensional, and jagged arrays. You will also get to know four sorting algorithms,
    namely selection, insertion, bubble sort, and quicksort. For each of them, you
    will see an illustration-based example, the implementation code, and a step-by-step
    explanation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，将介绍并将数组分为单维、多维和交错数组。您还将了解四种排序算法，即选择、插入、冒泡排序和快速排序。对于每一种算法，您将看到基于示例的说明、实现代码和逐步解释。
- en: The arrays have a lot of possibilities. However, generic lists available while
    developing in the C# language are even more powerful. In the remaining part of
    the chapter, you will see how to use a few variants of lists, such as simple,
    sorted, double-linked, and circular-linked. For each of them, the C# code of an
    example will be shown with a detailed description.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有很多可能性。然而，在使用C#语言开发时可用的通用列表更加强大。在本章的剩余部分，您将看到如何使用几种列表的变体，例如简单、排序、双向和循环链表。对于每一个，都将展示一个示例的C#代码，并附有详细描述。
- en: 'You will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Arrays
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组
- en: Sorting algorithms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序算法
- en: Simple lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单列表
- en: Sorted lists
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序列表
- en: Linked lists
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链表
- en: Circular-linked lists
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环链表
- en: Arrays
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Let''s start with the array data structure. You can use it to store many variables
    of the same type, such as `int`, `string`, or a user-defined class. As mentioned
    in the introduction, while developing applications in the C# language, you can
    benefit from a few variants of arrays, as presented in the following diagram.
    You have access not only to single-dimensional arrays (indicated as **a**), but
    also multi-dimensional (**b**), and jagged (**c**). Examples of all of them are
    shown in the following diagram:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从数组数据结构开始。您可以使用它来存储许多相同类型的变量，例如`int`，`string`或用户定义的类。正如在介绍中提到的，在使用C#语言开发应用程序时，您可以从以下图表中看到数组的几种变体。您不仅可以访问单维数组（表示为**a**），还可以访问多维（**b**）和交错（**c**）数组。所有这些的示例都在下图中显示：
- en: '![](img/9fefe52c-959d-4887-aa69-dfc748aab7a9.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fefe52c-959d-4887-aa69-dfc748aab7a9.png)'
- en: What is important is that the number of elements in an array cannot be changed
    after initialization. For this reason, you will not be able to easily add a new
    item at the end of the array or insert it in a given position within the array.
    If you need such features, you can use other data structures described in this
    chapter, such as generic lists.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，数组中的元素数量在初始化后无法更改。因此，您将无法轻松地在数组末尾添加新项或在数组中的特定位置插入新项。如果需要这样的功能，可以使用本章中描述的其他数据结构，例如通用列表。
- en: You can find more information about arrays at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接找到有关数组的更多信息：[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/)。
- en: After this short description, you should be ready to learn more about particular
    variants of arrays and to take a look at some C# code. Thus, let's proceed to
    the simplest variant of arrays, namely single-dimensional ones.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简短的描述，您应该已经准备好了解更多关于数组的特定变体，并查看一些C#代码。因此，让我们继续学习数组的最简单变体，即单维数组。
- en: Single-dimensional arrays
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单维数组
- en: A single-dimensional array stores a collection of items of the same type, which
    are accessible by an index. It is important to remember that indices of arrays
    in C# are zero-based. This means that the first element has an index equal to
    **0**, while the last one—length of the array minus one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 单维数组存储相同类型的项目集合，可以通过索引访问。重要的是要记住，在C#中，数组的索引是从零开始的。这意味着第一个元素的索引等于**0**，而最后一个元素的索引等于数组长度减一。
- en: 'The example array is shown in the preceding diagram (on the left, indicated
    by **a**). It contains five elements with the following values: **9**, **-11**,
    **6**, **-12**, and **1**. The first element has an index equal to **0**, while
    the last one has an index equal to **4**.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中显示了一个示例数组（在左侧，表示为**a**）。它包含五个元素，其值分别为**9**，**-11**，**6**，**-12**和**1**。第一个元素的索引等于**0**，而最后一个元素的索引等于**4**。
- en: 'To use a single-dimensional array, you need to declare and initialize it. The
    declaration is very simple, because you just need to specify a type of element
    and a name, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用单维数组，您需要声明和初始化它。声明非常简单，因为您只需要指定元素类型和名称，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The declaration of an array with integer values is shown in the following line:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了具有整数值的数组的声明：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now you know how to declare an array, but what about the initialization? To
    initialize the array elements to default values, you can use the `new` operator,
    as shown here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何声明数组了，但初始化呢？要将数组元素初始化为默认值，可以使用`new`运算符，如下所示：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Of course, you can combine a declaration and initialization in the same line,
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在同一行中组合声明和初始化，如下所示：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Unfortunately, all the elements currently have default values, that is, zeros
    in the case of integer values. Thus, you need to set the values of particular
    elements. You can do this using the `[]` operator and an index of an element,
    as shown in the following code snippet:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，所有元素目前都具有默认值，即整数值的情况下为零。因此，您需要设置特定元素的值。您可以使用`[]`运算符和元素的索引来做到这一点，就像下面的代码片段中所示的那样：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Moreover, you can combine a declaration and initialization of array elements
    to specific values using one of the following variants:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用以下一种变体将数组元素的声明和初始化组合为特定值：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When you have the proper values of elements within an array, you can get values
    using the `[]` operator and by specifying the index, as shown in the following
    line of code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在数组中有正确的元素值时，可以使用`[]`运算符并指定索引来获取值，就像下面的代码行所示的那样：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, you get a value of the third element (the index equal to `2`) from the
    array named `numbers` and store it as a value of the `middle` variable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，从名为`numbers`的数组中获取第三个元素（索引等于`2`）的值，并将其存储为`middle`变量的值。
- en: More information about single-dimensional arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有关单维数组的更多信息可在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/single-dimensional-arrays)找到。
- en: Example – month names
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-月份名称
- en: To summarize the information you have learned about single-dimensional arrays,
    let's take a look at a simple example, where the array is used to store names
    of months in English. Such names should be obtained automatically, not by hardcoding
    them in the code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下您所学到的关于单维数组的信息，让我们看一个简单的例子，其中数组用于存储英文月份的名称。这些名称应该是自动获取的，而不是在代码中硬编码的。
- en: 'The implementation is shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 实现如下所示：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At the start, a new single-dimensional array is declared and initialized with
    default values. It contains `12` elements to store names of months in a year.
    Then, the `for` loop is used to iterate through the numbers of all months, that
    is, from `1` to `12`. For each of them, the `DateTime` instance representing the
    first day in a particular month is created.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明一个新的单维数组，并用默认值初始化。它包含`12`个元素，用于存储一年中的月份名称。然后，使用`for`循环来迭代所有月份的数字，即从`1`到`12`。对于每个月，创建表示特定月份第一天的`DateTime`实例。
- en: The name of the month is obtained by calling the `ToString` method on the `DateTime`
    instance, passing the proper format of the date (`MMMM`), as well as specifying
    the culture (`en` in the example). Then, the name is stored in the array using
    the `[]` operator and an index of the element. It is worth noting that the index
    is equal to the current value of the `month` variable minus one. Such subtraction
    is necessary, because the first element in the array has an index equal to zero,
    not one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`DateTime`实例上调用`ToString`方法，传递日期的正确格式（`MMMM`），以及指定文化（例如`en`），来获取月份的名称。然后，使用`[]`运算符和元素的索引将名称存储在数组中。值得注意的是，索引等于当前`month`变量的值减一。这种减法是必要的，因为数组中的第一个元素的索引等于零，而不是一。
- en: 'The next interesting part of the code is the `foreach` loop, which iterates
    through all elements of the array. For each of them, one line is shown in the
    console, namely the name of the month after `->`. The result is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一个有趣部分是`foreach`循环，它遍历数组的所有元素。对于每个元素，在控制台中显示一行，即`->`后面的月份名称。结果如下：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As mentioned earlier, single-dimensional arrays are not the only available variant.
    You will learn more about multi-dimensional arrays in the following section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，单维数组并非唯一可用的变体。您将在下一节中了解更多关于多维数组的信息。
- en: Multi-dimensional arrays
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'The arrays in the C# language do not need to have only one dimension. It is
    also possible to create two-dimensional or even three-dimensional arrays. To start
    with, let''s take a look at an example regarding the declaration and initialization
    of a two-dimensional array with `5` rows and `2` columns:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言中的数组不一定只有一维。也可以创建二维甚至三维数组。首先，让我们看一个关于声明和初始化具有`5`行和`2`列的二维数组的例子：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to create a three-dimensional array, the following code can be
    used:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建一个三维数组，可以使用以下代码：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, you can also combine a declaration with an initialization, as shown
    in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以将声明与初始化结合起来，就像下面的例子中所示的那样：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Some small explanation is necessary for the way you access particular elements
    from a multi-dimensional array. Let''s take a look at the following example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从多维数组中访问特定元素的方式需要一些解释。让我们看下面的例子：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the first line of code, the value from the third row (index equal to `2`)
    and second column (index equal to `1`) is obtained (that is, `115`) and set as
    a value of the `number` variable. The other line replaces `-11` with `11` in the
    second row and first column.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一行中，获取了第三行（索引等于`2`）和第二列（索引等于`1`）的值（即`115`），并将其设置为`number`变量的值。另一行将第二行和第一列中的`-11`替换为`11`。
- en: More information about multi-dimensional arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有关多维数组的更多信息可在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/multidimensional-arrays)找到。
- en: Example – multiplication table
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-乘法表
- en: 'The first example shows basic operations on a two-dimensional array with the
    purpose of presenting a multiplication table. It writes the results of the multiplication
    of all integer values in the range from `1` to `10`, as shown in the following
    output:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例展示了对二维数组进行基本操作，目的是呈现一个乘法表。它写入了从`1`到`10`范围内所有整数值的乘法结果，如下所示：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s take a look at the method of declaration and initialization of the array:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下数组的声明和初始化方法：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, a two-dimensional array with `10` rows and `10` columns is created and
    its elements are initialized to default values, that is, to zeros.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了一个有`10`行和`10`列的二维数组，并将其元素初始化为默认值，即零。
- en: 'When the array is ready, you should fill it with the results of the multiplication.
    Such a task can be performed using two `for` loops:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组准备好后，您应该用乘法的结果填充它。这样的任务可以使用两个`for`循环来执行：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding code, you can find the `GetLength` method, which is called
    on an array object. The method returns the number of elements in a particular
    dimension, that is, the first (when passing `0` as the parameter) and the second
    (`1` as the parameter). In both cases, a value of `10` is returned, according
    to the values specified during the array initialization.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可以找到在数组对象上调用的`GetLength`方法。该方法返回特定维度中的元素数量，即第一个（当参数为`0`时）和第二个（参数为`1`时）。在两种情况下，根据数组初始化时指定的值，都返回了`10`。
- en: Another important part of the code is the way of setting a value of an element
    in a two-dimensional array. To do so, you need to provide two indices, such as
    `results[i, j]`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的另一个重要部分是设置二维数组中元素的值的方式。为此，您需要提供两个索引，例如`results[i, j]`。
- en: 'At the end, you just need to present the results. You can do so using two `for`
    loops, as in the case of filling the array. This part of the code is shown here:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您只需要呈现结果。您可以使用两个`for`循环来做到这一点，就像填充数组一样。代码的这一部分如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The multiplication results, after conversion to `string` values, have different
    lengths, from one character (as in the case of `4` as a result of `2*2`) to three
    (`100` from `10*10`). To improve the presentation, you need to write each result
    always on `4` chars. Therefore, if the integer value takes less space, the leading
    spaces should be added. As an example, the result 1 will be shown with three leading
    spaces (`___1`, where `_` is a space), while `100` with only one (`_100`). You
    can achieve this goal by using the proper composite format string (namely `{0,4}`)
    while calling the `Write` method from the `Console` class.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法结果在转换为`string`值后，长度不同，从一个字符（如`2*2`的结果`4`）到三个字符（`10*10`的`100`）。为了改善显示效果，需要始终在`4`个字符上写入每个结果。因此，如果整数值占用的空间较小，就应该添加前导空格。例如，结果1将显示为三个前导空格（`___1`，其中`_`是空格），而`100`只有一个（`_100`）。您可以通过在调用`Console`类的`Write`方法时使用适当的复合格式字符串（即`{0,4}`）来实现这个目标。
- en: Example – game map
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-游戏地图
- en: 'Another example of the application of a two-dimensional array is a program
    that presents a map of a game. The map is a rectangle with 11 rows and 10 columns.
    Each element of the array specifies a type of terrain as grass, sand, water, or
    wall. Each place on the map should be shown in a particular color (such as green
    for grass), as well as using a custom character that depicts the terrain type
    (such as `≈` for water), as shown in the screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用二维数组的例子是一个呈现游戏地图的程序。地图是一个有11行和10列的矩形。数组的每个元素指定了草地、沙地、水域或墙壁等类型的地形。地图上的每个位置都应该以特定的颜色显示（例如草地为绿色），并使用一个自定义字符来描述地形类型（例如水域为`≈`），如截图所示：
- en: '![](img/dd73ef8b-693e-4a5d-b14c-2af5879f2233.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd73ef8b-693e-4a5d-b14c-2af5879f2233.png)'
- en: 'At the start, let''s declare the enumeration value, named `TerrainEnum`, with
    four constants, namely `GRASS`, `SAND`, `WATER`, and `WALL`, as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们声明枚举值`TerrainEnum`，其中包括四个常量，即`GRASS`、`SAND`、`WATER`和`WALL`，如下所示：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To improve the readability of the whole project, it is recommended to declare
    the `TerrainEnum` type in a separate file, named `TerrainEnum.cs`. This rule should
    also be applied to all user-defined types, including classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高整个项目的可读性，建议在一个单独的文件中声明`TerrainEnum`类型，命名为`TerrainEnum.cs`。这个规则也应该适用于所有用户定义的类型，包括类。
- en: 'Then, you create two extension methods that make it possible to get a particular
    color and character depending on the terrain type (`GetColor` and `GetChar`, respectively).
    Such extension methods are declared within the `TerrainEnumExtensions` class,
    as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您创建了两个扩展方法，可以根据地形类型（分别是`GetColor`和`GetChar`）获取特定的颜色和字符。这些扩展方法在`TerrainEnumExtensions`类中声明，如下所示：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It is worth mentioning that the `GetChar` method returns a proper Unicode character
    depending on the `TerrainEnum` value. For example, in the case of the `WATER`
    constant, the `'\u2248'` value is returned, which is a representation of the `≈`
    character.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，`GetChar`方法根据`TerrainEnum`值返回适当的Unicode字符。例如，在`WATER`常量的情况下，返回了`'\u2248'`值，这是`≈`字符的表示。
- en: Have you heard about the **extension methods**? If not, think of them as methods
    that are "added" to a particular existing type (both built-in or user-defined),
    which can be called in the same way as when they are defined directly as instance
    methods. The declaration of an extension method requires you to specify it within
    a static class as a static method with the first parameter indicating the type,
    to which you want to "add" this method, with the `this` keyword. You can find
    more information at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您听说过**扩展方法**吗？如果没有，可以将其视为“添加”到特定现有类型（内置或用户定义）的方法，可以像定义实例方法一样调用它们。扩展方法的声明要求您在静态类中指定它作为带有第一个参数指示要“添加”此方法的类型的静态方法，并使用`this`关键字。您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)找到更多信息。
- en: 'Let''s take a look at the body of the `Main` method in the `Program` class.
    Here, you configure the map, as well as present it in the console. The code is
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`Program`类中`Main`方法的主体。在这里，您配置地图，并在控制台中呈现它。代码如下：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some comment can be useful regarding the way of getting a color and obtaining
    a character for a particular map place. Both these operations are performed using
    the extension methods "added" to the `TerrainEnum` user-defined type. For this
    reason, you first obtain the `TerrainEnum` value for a particular map place (using
    the `[]` operator and two indices) and then you call a suitable extension method,
    either `GetChar` or `GetColor`. To use Unicode values, you should not forget to
    choose the UTF-8 encoding by setting the `UTF8Encoding.UTF8` value for the `OutputEncoding`
    property.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于获取颜色和获取特定地图位置的字符的方式可能会有所帮助。这两个操作都是使用“添加”到`TerrainEnum`用户定义类型的扩展方法执行的。因此，您首先获取特定地图位置的`TerrainEnum`值（使用`[]`运算符和两个索引），然后调用适当的扩展方法，即`GetChar`或`GetColor`。要使用Unicode值，您不应忘记通过将`UTF8Encoding.UTF8`值设置为`OutputEncoding`属性来选择UTF-8编码。
- en: So far, you have learned about both single- and multi-dimensional arrays, but
    one more variant remains to be presented in this book. Let's continue reading
    to get to know more about it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经了解了单维和多维数组，但本书还有一个变体需要介绍。让我们继续阅读，以了解更多信息。
- en: Jagged arrays
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交错数组
- en: The last variant of arrays described in this book is a jagged array, which is
    also referred to as an **array of arrays**. It sounds complicated, but fortunately,
    it is very simple. A jagged array could be understood as a single-dimensional
    array, where each element is another array. Of course, such inner arrays can have
    different lengths or they can even be not initialized.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的数组的最后一种变体是交错数组，也称为**数组的数组**。听起来很复杂，但幸运的是，它非常简单。交错数组可以理解为单维数组，其中每个元素都是另一个数组。当然，这样的内部数组可以具有不同的长度，甚至可以未初始化。
- en: 'If you take a look at the following diagram, you will see an example of a jagged
    array with four elements. The first element has an array with three elements (`9`,
    `5`, `-9`), the second element has an array with five elements (`0`, `-3`, `12`,
    `51`, `-3`), the third is not initialized (`NULL`), while the last one is an array
    with only one element (`54`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下以下图表，您将看到一个具有四个元素的交错数组的示例。第一个元素有一个具有三个元素（`9`，`5`，`-9`）的数组，第二个元素有一个具有五个元素（`0`，`-3`，`12`，`51`，`-3`）的数组，第三个未初始化（`NULL`），而最后一个是一个只有一个元素（`54`）的数组：
- en: '![](img/949bdc78-43f5-4477-8bb5-b25ab8b1d35c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/949bdc78-43f5-4477-8bb5-b25ab8b1d35c.png)'
- en: 'Before proceeding to the example, it is worth mentioning the way of declaring
    and initializing a jagged array, because it is a bit different to the arrays already
    described. Let''s take a look at the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续示例之前，值得一提的是声明和初始化交错数组的方式，因为它与已经描述的数组有些不同。让我们看一下以下代码片段：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the first line, you can see the declaration of a single-dimensional array
    with four elements. Each element is another single-dimensional array of integer
    values. When the first line is executed, the `numbers` array is initialized with
    default values, namely `NULL`. For this reason, you need to manually initialize
    particular elements, as shown in the following three lines of codes. It is worth
    noting that the third element is not initialized.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，您可以看到具有四个元素的单维数组的声明。每个元素都是另一个整数值的单维数组。当执行第一行时，`numbers`数组将用默认值`NULL`初始化。因此，您需要手动初始化特定元素，如代码的下面三行所示。值得注意的是，第三个元素未初始化。
- en: 'You can also write the preceding code in a different way, as shown here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以以不同的方式编写前面的代码，如下所示：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A small comment is also necessary for the method of accessing a particular
    element from a jagged array. You can do this in the following way:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于访问交错数组中的特定元素的方法也需要一些说明。您可以按以下方式执行此操作：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line of code sets the value of the `number` variable to `12`, that
    is, to the value of the third element (index equal to `2`) from the array, which
    is the second element of the jagged array. The other line changes the value of
    the fourth element within the array, which is the second element of the jagged
    array, from `51` to `50`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的第一行将`number`变量的值设置为`12`，即数组中的第三个元素（索引等于`2`）的值，这是交错数组的第二个元素。另一行将数组中的第四个元素的值更改为`50`，这是交错数组的第二个元素，从`51`更改为`50`。
- en: More information about jagged arrays is available at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有关交错数组的更多信息，请访问[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/arrays/jagged-arrays)。
- en: Example – yearly transport plan
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-年度交通计划
- en: 'After the introduction of jagged arrays, let''s proceed with an example. You
    will see how to develop a program that creates a plan of transportation for the
    whole year. For each day of each month, the application draws one of the available
    means of transport. At the end, the program presents the generated plan, as shown
    in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入了交错数组之后，让我们继续举个例子。您将看到如何开发一个程序，为整年的交通制定一个计划。对于每个月的每一天，应用程序会绘制出一种可用的交通工具。最后，程序会呈现生成的计划，如下面的屏幕截图所示：
- en: '![](img/e50a99c3-cd6f-42d8-bd1b-2a0d736a2b2b.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e50a99c3-cd6f-42d8-bd1b-2a0d736a2b2b.png)'
- en: 'To start with, let''s declare the enumeration type with constants representing
    available types of transport, namely a car, a bus, a subway, a bike, or on foot,
    as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们声明一个枚举类型，其中包含代表可用交通类型的常量，即汽车、公共汽车、地铁、自行车或步行，如下所示：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the next step, you create two extension methods that return a character
    and a color for the representation of a given mean of transport in the console.
    The code is shown here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建两个扩展方法，它们返回控制台中给定交通工具的表示的字符和颜色。代码如下所示：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code should not require additional clarification, because it is
    very similar to the one already presented in this chapter. Now let's proceed to
    the code from the `Main` method from the `Program` class, which will be shown
    and described in parts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码不需要额外的解释，因为它与本章中已经呈现的代码非常相似。现在让我们继续到`Program`类的`Main`方法中的代码，它将分部分显示和描述。
- en: 'In the first part, a jagged array is created and filled with proper values.
    It is assumed that the jagged array has 12 elements, representing months from
    the current year. Each element is a single-dimensional array with `TransportEnum`
    values. The length of such an inner array depends on the number of days in a given
    month. For instance, it is set to 31 elements for January and 30 elements for
    April. The code is shown here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分中，创建了一个交错数组，并用适当的值填充。假设交错数组有12个元素，代表当前年份的月份。每个元素都是一个具有`TransportEnum`值的单维数组。这样的内部数组的长度取决于给定月份的天数。例如，对于一月，它设置为31个元素，对于四月，它设置为30个元素。代码如下所示：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's analyze the preceding code. At the beginning, a new instance of the `Random`
    class is created. It will be later used for drawing a suitable mean of transport
    from the available ones. In the next line, you get the number of constants from
    the `TransportEnum` enumeration type, that is, the number of available transport
    types. Then, the jagged array is created and the `for` loop is used to iterate
    through all months within the year. In each iteration, the number of days is obtained
    (using the `DaysInMonth` static method of `DateTime`) and an array (as an element
    from the jagged array) is initialized with zeros. In the following line of code,
    you can see the next `for` loop that iterates through all days of the month. Within
    this loop, you draw a transport type, and set it as a value of a suitable element
    within an array that is an element of the jagged array.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码。首先，创建了`Random`类的一个新实例。稍后将用于从可用的交通工具中选择合适的交通工具。接下来，获取了`TransportEnum`枚举类型中的常量数量，即可用交通类型的数量。然后，创建了交错数组，并使用`for`循环来遍历一年中的所有月份。在每次迭代中，使用`DateTime`的`DaysInMonth`静态方法获取天数，并使用零初始化一个数组（作为交错数组的一个元素）。在下一行代码中，您可以看到下一个`for`循环，它遍历月份的所有天。在此循环中，您会绘制一种交通类型，并将其设置为交错数组的一个元素的适当值。
- en: 'The next part of the code is related to the process of presenting the plan
    in the console:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分与在控制台中呈现计划的过程有关：
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At the beginning, a single-dimensional array with month names is created using
    the `GetMonthNames` method, which will be described later. Then, a value of the
    `monthNamesPart` variable is set to the maximum necessary length of text for storing
    the month name. To do so, the LINQ expression is used to find the maximum length
    of text from the collection with names of months. The obtained result is increased
    by 2 for reserving the place for a colon and a space.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`GetMonthNames`方法创建一个包含月份名称的单维数组，稍后将对其进行描述。然后，将`monthNamesPart`变量的值设置为存储月份名称的文本的最大必要长度。为此，使用LINQ表达式来从月份名称集合中找到文本的最大长度。获得的结果增加2，以保留冒号和空格的位置。
- en: One of the great features of the C# language is its ability to use LINQ. Such
    a mechanism makes it possible to get data not only from various collections, but
    also from **Structured Query Language** (**SQL**) databases and **Extensible Markup
    Language** (**XML**) documents in a consistent way. You can read more at [https://docs.microsoft.com/dotnet/csharp/linq/index](https://docs.microsoft.com/dotnet/csharp/linq/index).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: C#语言的一个伟大特性是其使用LINQ的能力。这样的机制使得不仅可以从各种集合中获取数据，还可以以一致的方式从**结构化查询语言**（**SQL**）数据库和**可扩展标记语言**（**XML**）文档中获取数据。您可以在[https://docs.microsoft.com/dotnet/csharp/linq/index](https://docs.microsoft.com/dotnet/csharp/linq/index)上阅读更多内容。
- en: Then, the `for` loop is used to iterate through all elements of the jagged array,
    that is, through all months. In each iteration, the name of the month is presented
    in the console. Later, the next `for` loop is used to iterate through all the
    elements of the current element of the jagged array, that is, through all days
    of the month. For each of them, proper colors are set (for background and foreground),
    and a suitable character is presented.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`for`循环来遍历交错数组的所有元素，即遍历所有月份。在每次迭代中，在控制台中呈现月份的名称。然后，使用下一个`for`循环来遍历交错数组当前元素的所有元素，即遍历月份的所有天。对于每个元素，设置适当的颜色（用于背景和前景），并呈现适当的字符。
- en: 'At the end, let''s take a look at the implementation of the `GetMonthNames`
    method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们来看一下`GetMonthNames`方法的实现：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code does not require additional explanation, because it is based on the
    code already described in the example for single-dimensional arrays.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码不需要额外的解释，因为它是基于已经在单维数组示例中描述的代码。
- en: Sorting algorithms
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序算法
- en: There are many algorithms that perform various operations on arrays. However,
    one of the most common tasks is sorting an array to arrange its elements in the
    correct order, either ascending or descending. The topic of sorting algorithms
    involves many approaches, including selection sort, insertion sort, bubble sort,
    and quicksort, which will be explained in detail in this part of the chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多算法对数组执行各种操作。然而，最常见的任务之一是对数组进行排序，以便将其元素按正确的顺序排列，无论是升序还是降序。排序算法的主题涉及许多方法，包括选择排序、插入排序、冒泡排序和快速排序，这些将在本章的这一部分中详细解释。
- en: Selection sort
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择排序
- en: Let's start with the **selection sort**, which is one of the simplest sorting
    algorithms. The algorithm divides the array into two parts, namely sorted and
    unsorted. In the following iterations, the algorithm finds the smallest element
    in the unsorted part and exchanges it with the first element in the unsorted part.
    It sounds very simple, doesn't it?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从**选择排序**开始，这是最简单的排序算法之一。该算法将数组分为已排序和未排序两部分。在接下来的迭代中，算法找到未排序部分中的最小元素，并将其与未排序部分中的第一个元素交换。听起来很简单，不是吗？
- en: 'To better understand the algorithm, let''s take a look at the following iterations
    for an array with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**,
    **68**, **6**, **-9**), as shown in the following diagram:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解算法，让我们看一下具有九个元素的数组的以下迭代（**-11**，**12**，**-42**，**0**，**1**，**90**，**68**，**6**，**-9**）的情况，如下图所示：
- en: '![](img/81e1a940-e7ad-41b1-bb26-870264d29f34.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/81e1a940-e7ad-41b1-bb26-870264d29f34.png)'
- en: To simplify the analysis, the bold line is used to present the border between
    the sorted and unsorted parts of the array. At the beginning (*Step 1*), the border
    is located just at the top of the array, which means that the sorted part is empty.
    Thus, the algorithm finds the smallest value in the unsorted part (**-42**) and
    swaps it with the first element in this part (**-11**). The result is shown in
    *Step 2*, where the sorted part contains one element (**-42**), while the unsorted
    part consists of eight elements. The afore mentioned steps are performed a few
    times until only one element is left in the unsorted part. The final result is
    shown in *Step 9*.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化分析，使用粗体线来表示数组的已排序和未排序部分之间的边界。在开始（*步骤1*）时，边界位于数组顶部，这意味着已排序部分为空。因此，算法找到未排序部分中的最小值（**-42**）并将其与该部分中的第一个元素（**-11**）交换。结果显示在*步骤2*中，其中已排序部分包含一个元素（**-42**），而未排序部分包含八个元素。上述步骤重复执行几次，直到未排序部分只剩下一个元素。最终结果显示在*步骤9*中。
- en: Now you know how the selection sort algorithm works, but what role is performed
    by the `i` and `m` indicators shown on the left of the following steps in the
    preceding diagram? They are related to the variables used in the implementation
    of this algorithm. Thus, it is time to see the code in the C# language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了选择排序算法的工作原理，但在前面的图表中显示的步骤左侧的 `i` 和 `m` 指示器扮演了什么角色？它们与该算法的实现中使用的变量有关。因此，现在是时候看看
    C# 语言中的代码了。
- en: 'The algorithm implementation is created as the `SelectionSort` static class
    with the `Sort` generic static method, which is shown in the following code snippet:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 算法实现为 `SelectionSort` 静态类，具有 `Sort` 通用静态方法，如下代码片段所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `Sort` method takes one parameter, namely the array that should be sorted
    (`array`). Within the method, the `for` loop is used to iterate through the elements
    until only one item is left in the unsorted part. Thus, the number of iterations
    of the loop is equal to the length of the array minus one (`array.Length-1`).
    In each iteration, another `for` loop is used to find the smallest value in the
    unsorted part (`minValue`, from the `i+1` index until the end of array), as well
    as to store an index of the smallest value (`minIndex`, referred to as the `m`
    indicator in the preceding diagram). Then, the smallest element in the unsorted
    part (with an index equal to `minIndex`) is swapped with the first element in
    the unsorted part (`i` index), using the `Swap` auxiliary method, the implementation
    of which is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort` 方法接受一个参数，即应该排序的数组（`array`）。在方法内部，使用 `for` 循环来迭代元素，直到未排序部分只剩下一个项目。因此，循环的迭代次数等于数组长度减一（`array.Length-1`）。在每次迭代中，另一个
    `for` 循环用于找到未排序部分中的最小值（`minValue`，从 `i+1` 索引到数组末尾），并存储最小值的索引（`minIndex`，在前面的图表中称为
    `m` 指示器）。然后，未排序部分中的最小元素（索引为 `minIndex`）与未排序部分中的第一个元素（索引为 `i`）进行交换，使用 `Swap` 辅助方法，其实现如下：'
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you want to test the implementation of the selection sort algorithm, you
    can place the following code in the `Main` method of the `Program` class:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测试选择排序算法的实现，可以将以下代码放入 `Program` 类的 `Main` 方法中：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the preceding code, a new array is declared and initialized. Then, the `Sort`
    static method is called, passing the array as a parameter. At the end, the `string`
    value is created by joining elements of the array (separated by the `|` character)
    and is shown in the console, as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，声明并初始化了一个新数组。然后调用 `Sort` 静态方法，传递数组作为参数。最后，通过连接数组元素（以 `|` 字符分隔）创建了一个
    `string` 值，并在控制台中显示，如下所示：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By using the generic method, you can easily use the created class for sorting
    various arrays, such as with floating point numbers or strings. The example code
    is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用通用方法，你可以轻松地使用创建的类来对各种数组进行排序，例如浮点数或字符串。示例代码如下：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As a result, you will receive the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将收到以下输出：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: While talking about various algorithms, one of the most important topics is
    **computational complexity**, especially **time complexity**. There are a few
    of its variants, such as for the worst or average case. The complexity can be
    interpreted as the number of basic operations that need to be performed by the
    algorithm, depending on the input size (*n*). The time complexity can be specified
    using the **Big O notation**, for example, as *O(n)*, *O(n²)* or *O(n log(n))*.
    However, what does this mean? The *O(n)* notation indicates that the number of
    operations increases linearly with the input size (*n*). The *O(n²)* variant is
    named **quadratic**, while *O(n log(n))* is named**linearithmic**. There are other
    variants as well, such as *O(1),* which is **constant**.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论各种算法时，最重要的话题之一是**计算复杂性**，特别是**时间复杂性**。它有一些变体，例如最坏或平均情况。复杂性可以解释为算法在输入大小（*n*）上需要执行的基本操作数量。时间复杂性可以使用**大O表示法**来指定，例如*O(n)*、*O(n²)*或*O(n
    log(n))*。但是，这是什么意思呢？*O(n)*表示操作数量与输入大小（*n*）呈线性增长。*O(n²)*变体称为**二次**，而*O(n log(n))*称为**线性对数**。还有其他变体，例如*O(1)*，它是**常数**。
- en: In the case of the selection sort, both the worst and average time complexity
    is *O(n²)*. Why? Let's take a look at the code to answer this question. There
    are two loops (one within the other), each iterating through many elements of
    the array. For this reason, the complexity is indicated as *O(n²)*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择排序的情况下，最坏和平均时间复杂度都是*O(n²)*。为什么？让我们看一下代码来回答这个问题。有两个循环（一个在另一个内部），每个循环都遍历数组的许多元素。因此，复杂性被表示为*O(n²)*。
- en: 'More information about the selection sort and its implementations can be found
    at:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有关选择排序及其实现的更多信息可以在以下网址找到：
- en: '[https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Selection_sort](https://en.wikipedia.org/wiki/Selection_sort)'
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Selection_sort)'
- en: You have just learned about the first sorting algorithm! If you are interested
    in the next approach to sorting, let's proceed to the next section, where the
    insertion sort is presented.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚了解了第一个排序算法！如果您对下一个排序方法感兴趣，请继续阅读下一节，介绍插入排序。
- en: Insertion sort
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入排序
- en: The **insertion sort** is another algorithm that makes it possible to sort a
    single-dimensional array in a simple way, as shown in the following diagram. Similarly,
    as in the case of the selection sort, the array is divided into two parts, namely
    sorted and unsorted. However, at the beginning, the first element is included
    in the sorted part. In each iteration, the algorithm takes the first element from
    the unsorted part and places it in a suitable location within the sorted part,
    to leave the sorted part in the correct order. Such operations are repeated until
    the unsorted part is empty.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入排序**是另一种算法，可以简单地对单维数组进行排序，如下图所示。与选择排序类似，数组被分为两部分，即排序和未排序。但是，一开始，第一个元素包括在排序部分中。在每次迭代中，算法从未排序部分中取出第一个元素，并将其放在排序部分的适当位置，以使排序部分保持正确的顺序。这样的操作重复，直到未排序部分为空。'
- en: 'Let''s take a look at an example of sorting an array with nine elements (**-11**,
    **12**, **-42**, **0**, **1**, **90**, **68**, **6**, **-9**) using the insertion
    sort, which is presented in the following diagram:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用插入排序对包含九个元素（**-11**、**12**、**-42**、**0**、**1**、**90**、**68**、**6**、**-9**）的数组进行排序的例子，如下图所示：
- en: '![](img/0fa22285-42f2-4cdb-a20b-e5d9907d95e6.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0fa22285-42f2-4cdb-a20b-e5d9907d95e6.png)'
- en: At the beginning, only one element (**-11**) is located in the sorted part (*Step
    1*). Then, the smallest element is found in the unsorted part (**-42**) and is
    moved to the correct location in the sorted part, that is, to the beginning of
    the array, performing a set of swap operations (*Steps 2* and *3*). Thus, the
    length of the sorted part is increased to two elements, namely **-42** and **-11**.
    Such operations are repeated until the unsorted part is empty (*Step 22*).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，排序部分中只有一个元素（**-11**）（*步骤1*）。然后，在未排序部分中找到最小的元素（**-42**），并将其移动到排序部分的正确位置，即数组的开头，执行一系列交换操作（*步骤2*和*3*）。因此，排序部分的长度增加到两个元素，即**-42**和**-11**。这样的操作重复，直到未排序部分为空（*步骤22*）。
- en: 'The implementation code for the insertion sort is very simple:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 插入排序的实现代码非常简单：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Similarly, as in the case of the selection sort, the implementation is provided
    in a new class, namely `InsertionSort`. The static generic `Sort` method performs
    operations regarding sorting and takes an array as the parameter. Within this
    method, the `for` loop is used to iterate through all elements in the unsorted
    part. Thus, the initial value of the `i` variable is set to `1`, instead of `0`.
    In each iteration of the `for` loop, the `while` loop is executed to move the
    first element from the unsorted part of the array (with the index equal to a value
    of the `i` variable) to the correct location within the sorted part, using the
    `Swap` auxiliary method with the same implementation as shown in the case of the
    selection sort. The way of testing the insertion sort is also very similar, but
    another class name should be used, that is, `InsertionSort` instead of `SelectionSort`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与选择排序类似，实现是在一个新类中提供的，即`InsertionSort`。静态泛型`Sort`方法执行有关排序的操作，并将数组作为参数。在这个方法中，使用`for`循环来迭代未排序部分中的所有元素。因此，`i`变量的初始值设置为`1`，而不是`0`。在`for`循环的每次迭代中，执行`while`循环，将数组的未排序部分中的第一个元素（索引等于`i`变量的值）移动到排序部分的正确位置，使用与选择排序中所示的相同实现的`Swap`辅助方法。测试插入排序的方式也非常相似，但应该使用另一个类名，即`InsertionSort`而不是`SelectionSort`。
- en: 'More information about the insertion sort and its implementations can be found
    at:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有关插入排序及其实现的更多信息可以在以下网址找到：
- en: '[https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Insertion_sort](https://en.wikipedia.org/wiki/Insertion_sort)'
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Insertion_sort)'
- en: At the end, it is worth mentioning the time complexity of the insertion sort.
    Similarly, as in the case of the selection sort, both worst and average time complexity
    is *O(n²)*. If you take a look at the code, you will also see two loops (`for`
    and `while`) placed one within the other, which could iterate multiple times,
    depending on the input size.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得一提的是插入排序的时间复杂度。与选择排序类似，最坏和平均时间复杂度均为*O(n²)*。如果你看一下代码，你还会看到两个循环（`for`和`while`）嵌套在一起，这取决于输入大小，可能会迭代多次。
- en: Bubble sort
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冒泡排序
- en: The third sorting algorithm presented in the book is **bubble sort**. Its way
    of operation is very simple, because the algorithm just iterates through the array
    and compares adjacent elements. If they are located in an incorrect order, they
    are swapped. It sounds very easy, but the algorithm is not very efficient and
    its usage with large collections could cause performance-related problems.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 书中介绍的第三种排序算法是**冒泡排序**。它的操作方式非常简单，因为算法只是遍历数组并比较相邻元素。如果它们的位置不正确，就交换它们。听起来很简单，但这个算法并不是很高效，使用大型集合可能会导致性能问题。
- en: 'To better understand how the algorithm works, let''s take a look at the following
    diagram that shows how the algorithm operates in the case of sorting a single-dimensional
    array with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**, **68**,
    **6**, **-9**):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解算法的工作原理，让我们看一下以下图表，展示了算法在对一个包含九个元素（**-11**，**12**，**-42**，**0**，**1**，**90**，**68**，**6**，**-9**）的单维数组进行排序时的操作：
- en: '![](img/2a67b8b0-b786-4aa5-8744-a1dd41b7bdf8.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a67b8b0-b786-4aa5-8744-a1dd41b7bdf8.png)'
- en: As you can see, in each step the algorithm compares two adjacent elements in
    the array and swaps them, if necessary. For example, in *Step 1*, **-11** and
    **12** are compared, but they are placed in the correct order, so it is not necessary
    to swap such elements. In *Step 2*, the next adjacent elements are compared (namely
    **12** and **-42**). This time, such elements are not placed in the correct order,
    thus they are swapped. The afore mentioned operations are performed several times.
    At the end, the array will be sorted, as shown in *Step 72*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在每一步中，算法比较数组中的两个相邻元素并在必要时交换它们。例如，在*步骤1*中，比较了**-11**和**12**，但它们已经按正确顺序排列，因此不需要交换这些元素。在*步骤2*中，比较了下一个相邻元素（即**12**和**-42**）。这次，这些元素没有按正确顺序排列，因此它们被交换了。上述操作被执行了多次。最后，数组将被排序，如*步骤72*所示。
- en: 'The algorithm seems to be very easy, but what about the implementation? Is
    it also so simple? Fortunately, yes! You just need to use two loops, compare adjacent
    elements, and swap them if necessary. That''s all! Let''s take a look at the following
    code snippet:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法看起来很简单，但实现呢？它也是如此简单吗？幸运的是，是的！你只需要使用两个循环，比较相邻元素，并在必要时交换它们。就是这样！让我们看一下以下代码片段：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `Sort` static generic method, declared in the `BubbleSort` class, contains
    the implementation of the bubble sort algorithm. As already mentioned, two `for`
    loops are used, together with a comparison and a call of the `Swap` method (with
    the same implementation as shown in the case of the previously described sorting
    algorithms). What is more, you can use similar code for testing the implementation,
    but do not forget to replace the name of the class to `BubbleSort`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`BubbleSort`类中声明的`Sort`静态泛型方法包含了冒泡排序算法的实现。如前所述，使用了两个`for`循环，以及一个比较和调用`Swap`方法（与先前描述的排序算法的情况相同）。此外，你可以使用类似的代码来测试实现，但不要忘记将类的名称替换为`BubbleSort`。'
- en: 'It is also possible to use a more optimized version of the bubble sort algorithm
    by introducing a simple modification in the implementation. It is based on the
    assumption that comparisons should be stopped when no changes are discovered during
    one iteration through the array. The modified code is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过在实现中引入简单的修改来使用冒泡排序算法的更优化版本。这是基于这样的假设：当在数组的一次迭代中未发现任何更改时，比较应该停止。修改后的代码如下：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By introducing such a simple modification, the number of comparisons could decrease
    significantly. In the preceding example, it decreases from 72 steps to 56 steps.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入这样一个简单的修改，比较的次数可以显著减少。在前面的例子中，它从72步减少到56步。
- en: 'More information about the bubble sort and its implementations can be found
    at:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有关冒泡排序及其实现的更多信息可以在以下网址找到：
- en: '[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Bubble_sort](https://en.wikipedia.org/wiki/Bubble_sort)'
- en: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Bubble_sort)'
- en: Before moving to the next sorting algorithm, it is worth mentioning the time
    complexity of the bubble sort. As you may have already guessed, both worst and
    average cases are the same as in the case of the selection and insertion sort,
    that is, *O(n²)*.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向下一个排序算法之前，值得一提的是冒泡排序的时间复杂度。你可能已经猜到，最坏和平均情况都与选择和插入排序相同，即*O(n²)*。
- en: Quicksort
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速排序
- en: The last sorting algorithm described in this book is named **quicksort**. It
    is one of the popular **divide and conquer algorithms**, which divide a problem
    into a set of smaller ones. Moreover, such an algorithm provides developers with
    an efficient way of sorting. Does this mean that its idea and implementation are
    very complicated? Fortunately, no! You will learn how the algorithm works, as
    well as what its implementation code can look like in this section. Let's start!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的最后一个排序算法名为**快速排序**。它是一种流行的**分而治之算法**之一，将问题分解为一组较小的问题。此外，这种算法为开发人员提供了一种有效的排序方式。这是否意味着它的思想和实现非常复杂？幸运的是，不是！您将在本节中了解算法的工作原理，以及它的实现代码是什么样子的。让我们开始吧！
- en: How does the algorithm work? At the beginning, it picks some value (such as
    from the first or the middle element of the array) as a **pivot**. Then, it reorders
    the array in such a way that values lower than or equal to the pivot are placed
    before it (forming the lower subarray), while values greater than the pivot are
    placed after it (the higher subarray). Such a process is called **partitioning**.
    In this book, the **Hoare partition scheme** is used. Next, the algorithm recursively
    sorts each of the afore mentioned subarrays. Of course, each subarray is further
    divided into the next two subarrays, and so on. The recursive calls stop when
    there are one or zero elements in a subarray, because in such a case there is
    nothing to sort.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 算法是如何工作的？首先，它选择某个值（例如来自数组的第一个或中间元素）作为**枢轴**。然后，它重新排列数组，使得小于或等于枢轴的值放在它之前（形成较低的子数组），而大于枢轴的值放在它之后（较高的子数组）。这个过程称为**分区**。本书中使用**霍尔分区方案**。接下来，算法递归地对上述每个子数组进行排序。当然，每个子数组进一步分成下一个两个子数组，依此类推。当子数组中有一个或零个元素时，递归调用停止，因为在这种情况下没有需要排序的内容。
- en: 'The preceding description may sound a bit complicated, so let''s take a look
    at an example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述可能听起来有点复杂，所以让我们看一个例子：
- en: '![](img/16a55dc5-bea8-4a05-9b5a-93482f5e6c3b.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16a55dc5-bea8-4a05-9b5a-93482f5e6c3b.png)'
- en: The example shows how the quicksort algorithm sorts a single-dimensional array
    with nine elements (**-11**, **12**, **-42**, **0**, **1**, **90**, **68**, **6**,
    **-9**). In this scenario, it is assumed that the pivot is chosen as a value of
    the first element of the subarray that is currently being sorted. In *Step 1*,
    value **-11** is chosen as the pivot. Then, it is necessary to reorder the array.
    Therefore, **-11** is swapped with **-42**, as well as **12** with **-11**, to
    ensure that only values lower than or equal to the pivot (**-42**, **-11**) are
    in the lower subarray and only values greater than the pivot (**12**, **0**, **1**,
    **90**, **68**, **6**, **-9**) are placed in the higher subarray. Then, the algorithm
    is called recursively for both afore mentioned subarrays, namely (**-42**, **11**)
    and (**12**, **0**, **1**, **90**, **68**, **6**, **-9**), so they are analyzed
    in the same way as the input array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 示例展示了快速排序算法如何对一个具有九个元素的一维数组（**-11**, **12**, **-42**, **0**, **1**, **90**,
    **68**, **6**, **-9**）进行排序。在这种情况下，假设枢轴被选择为当前正在排序的子数组的第一个元素的值。在*步骤1*中，值**-11**被选择为枢轴。然后，需要重新排列数组。因此，**-11**与**-42**交换，**12**与**-11**交换，以确保只有小于或等于枢轴的值（**-42**,
    **-11**）在较低的子数组中，而大于枢轴的值（**12**, **0**, **1**, **90**, **68**, **6**, **-9**）放在较高的子数组中。然后，对上述两个子数组，即(**-42**,
    **11**)和(**12**, **0**, **1**, **90**, **68**, **6**, **-9**)递归调用算法，因此它们以与输入数组相同的方式进行分析。
- en: As an example, *Step 5* shows that value **12** is chosen as the pivot. After
    partitioning, the subarray is divided into two other subarrays, namely (**-9**,
    **0**, **1**, **6**, **12**) and (**68**, **90**). For both, other pivot elements
    are chosen, namely **-9** and **68**. After performing such operations for all
    remaining parts of the array, you will receive the final result, as shown on the
    right-hand side of the diagram (*Step 15*).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*步骤5*显示值**12**被选择为枢轴。分区后，子数组分为两个其他子数组，即(**-9**, **0**, **1**, **6**, **12**)和(**68**,
    **90**)。对于这两个子数组，选择其他的枢轴元素，即**-9**和**68**。对数组的所有剩余部分执行这样的操作后，你将得到最终结果，如图中右侧所示(*步骤15*)。
- en: 'It is worth mentioning that the pivot can be selected variously in other implementations
    of this algorithm. As an example, let''s take a look at how the following steps
    will change in the case when a value of the middle element of the array is chosen:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，在该算法的其他实现中，枢轴可以以不同的方式选择。例如，让我们看看在选择数组的中间元素的值时，以下步骤将如何改变：
- en: '![](img/34991257-e59f-4dbc-868d-2422d64a303b.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34991257-e59f-4dbc-868d-2422d64a303b.png)'
- en: 'If you understand how the algorithm works, let''s proceed to the implementation.
    It is more complicated than the examples shown earlier, and it uses **recursion**
    to call the sorting method for subarrays. The code is placed in the `QuickSort`
    class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你理解算法的工作原理，让我们继续实现。这比之前展示的例子更复杂，它使用**递归**来调用子数组的排序方法。代码放在`QuickSort`类中：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `QuickSort` class contains two variants of the `Sort` method. The first
    takes only one parameter, namely the array that should be sorted, and is shown
    in the preceding code snippet. It just calls another variant of the `Sort` method,
    which makes it possible to specify the lower and upper indices that indicate which
    part of the array should be sorted. The other version of the `Sort` method is
    shown here:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuickSort`类包含`Sort`方法的两个变体。第一个只接受一个参数，即应该排序的数组，并且在前面的代码片段中显示。它只调用`Sort`方法的另一个变体，这使得可以指定指示应该排序数组的哪一部分的下限和上限索引。`Sort`方法的另一个版本在这里显示：'
- en: '[PRE38]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Sort` method checks whether the array (or subarray) has at least two elements,
    by comparing the values of the `lower` and `upper` variables. In such a case,
    it calls the `Partition` method, which is responsible for the partitioning phase,
    and then calls the `Sort` method recursively for two subarrays, namely lower (indices
    from `lower` to `p`) and higher (from `p+1` to `upper`).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Sort`方法通过比较`lower`和`upper`变量的值来检查数组（或子数组）是否至少有两个元素。在这种情况下，它调用`Partition`方法，该方法负责分区阶段，然后递归调用`Sort`方法以获得两个子数组，即较低（从`lower`到`p`的索引）和较高（从`p+1`到`upper`的索引）。'
- en: 'The code regarding the partitioning is shown here:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有关分区的代码显示在这里：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: At the beginning, the pivot value is chosen and stored as a value of the `pivot`
    variable. As already mentioned, it can be chosen in various ways, such as by taking
    a value of the first element (shown in the preceding code snippet), a value of
    the middle element (as shown in the preceding code as the comment), or even as
    a random value. Then, the `do-while` loop is used to rearrange the array according
    to the Hoare partition scheme, using comparisons and by swapping elements. At
    the end, the current value of the `j` variable is returned.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择枢轴值并将其存储为`pivot`变量的值。如前面的代码片段所示，可以以各种方式选择它，例如取第一个元素的值（如前面的代码片段所示），取中间元素的值（如前面的代码中的注释所示），甚至取随机值。然后，使用`do-while`循环根据Hoare分区方案重新排列数组，使用比较并交换元素。最后，返回`j`变量的当前值。
- en: The presented implementation is based on the Hoare partition scheme, the pseudocode
    and explanation of which are presented at [https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort).
    There are various possible ways in which to implement quicksort. You can find
    more information at [https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的实现是基于Hoare分区方案的，其伪代码和解释在[https://en.wikipedia.org/wiki/Quicksort](https://en.wikipedia.org/wiki/Quicksort)中呈现。有各种可能的实现快速排序的方式。您可以在[https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort](https://en.wikibooks.org/wiki/Algorithm_Implementation/Sorting/Quicksort)中找到更多信息。
- en: What about the time complexity? Do you think that it differs in comparison with
    the selection, insertion, and bubble sort? If so, you are right! It has *O(n log(n))*
    average time complexity, despite having *O(n²)* worst time complexity.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 时间复杂度呢？您认为它与选择、插入和冒泡排序相比有所不同吗？如果是这样，你是对的！它的平均时间复杂度为*O(n log(n))*，尽管最坏时间复杂度为*O(n²)*。
- en: Simple lists
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单列表
- en: Arrays are really useful data structures and they are applied in many algorithms.
    However, in some cases their application could be complicated due to their nature,
    which does not allow to increase or decrease the length of the already-created
    array. What should you do if you do not know the total number of elements to store
    in the collection? Do you need to create a very big array and just not use unnecessary
    elements? Such a solution does not sound good, does it? A much better approach
    is to use a data structure that makes it possible to dynamically increase the
    size of the collection if it is necessary.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 数组真的是非常有用的数据结构，它们应用于许多算法中。然而，在某些情况下，由于其性质，它们的应用可能会变得复杂，这不允许增加或减少已创建数组的长度。如果您不知道要存储在集合中的元素的总数，该怎么办？您需要创建一个非常大的数组，然后只是不使用不必要的元素吗？这样的解决方案听起来不好，对吧？一个更好的方法是使用数据结构，如果有必要，可以动态增加集合的大小。
- en: Array list
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组列表
- en: The first data structure that meets this requirement is the **array list**,
    which is represented by the `ArrayList` class from the `System.Collections` namespace.
    You can use this class to store big collections of data, to which you can easily
    add new elements when necessary. Of course, you can also remove them, count items,
    and find an index of a particular value stored within the array list.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 满足此要求的第一个数据结构是**数组列表**，它由`System.Collections`命名空间中的`ArrayList`类表示。您可以使用此类存储大量数据，必要时可以轻松添加新元素。当然，您也可以删除它们，计算项目数，并找到存储在数组列表中的特定值的索引。
- en: 'How can you do this? Let''s take a look at the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你怎么做到的？让我们看看以下代码：
- en: '[PRE40]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the first line, a new instance of the `ArrayList` class is created. Then,
    you use the `Add`, `AddRange`, and `Insert` methods to add new elements to the
    array list. The first (namely, `Add`) allows you to add a new item at the end
    of the list. The `AddRange` method adds a collection of elements at the end of
    the array list, while `Insert` can be used to place an element in a specified
    location within the collection. When the preceding code is executed, the array
    list will contain the following elements: `5`, `6`, `-7`, `8`, `"Marcin"`, `7.8`,
    and `"Mary"`. As you can see, all items stored within the array list are of the
    type `object`. Thus, you can place in the same collection data of various types
    at the same time.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，创建了`ArrayList`类的一个新实例。然后，您可以使用`Add`，`AddRange`和`Insert`方法向数组列表添加新元素。第一个（即`Add`）允许您在列表末尾添加新项目。`AddRange`方法在数组列表末尾添加一系列元素，而`Insert`可以用于将元素放置在集合中的指定位置。当执行前面的代码时，数组列表将包含以下元素：`5`，`6`，`-7`，`8`，`"Marcin"`，`7.8`和`"Mary"`。正如您所看到的，数组列表中存储的所有项目都是`object`类型。因此，您可以同时在同一集合中放置各种类型的数据。
- en: If you want to specify a type of each element stored within the list, you can
    use the generic `List` class, described just after `ArrayList`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要指定列表中存储的每个元素的类型，可以使用泛型`List`类，该类在`ArrayList`之后描述。
- en: 'It is worth mentioning that you can easily access a particular element within
    the array list using the index, as shown in the following two lines of code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，您可以使用索引轻松访问数组列表中的特定元素，如下面两行代码所示：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Let's take a look at casting to `int` in the second line. Such casting is necessary,
    because the array list stores `object` values. As in the case of arrays, the zero-based
    indices are used while accessing particular elements within the collection.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第二行中的`int`转换。这种转换是必要的，因为数组列表存储`object`值。与数组的情况一样，在访问集合中的特定元素时使用基于零的索引。
- en: 'Of course, you can use the `foreach` loop to iterate through all items, as
    follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以使用`foreach`循环来遍历所有项目，如下所示：
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'That is not all! The `ArrayList` class has a set of properties and methods
    which you can use while developing applications utilizing the afore mentioned
    data structure. To start with, let''s take a look at the `Count` and `Capacity`
    properties:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不是全部！`ArrayList`类有一组属性和方法，您可以在开发应用程序时使用这些属性和方法利用上述数据结构。首先，让我们看一下`Count`和`Capacity`属性：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The first (`Count`) returns the number of elements stored in the array list,
    while the other (`Capacity`) indicates how many elements can be stored within
    it. If you check a value of the `Capacity` property after adding new elements
    to the array list, you will see that this value is automatically increased to
    prepare a place for new items. This is shown in the following diagram, presenting
    the difference between `Count` (as **A**) and `Capacity` (**B**):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个(`Count`)返回存储在数组列表中的元素数量，而另一个(`Capacity`)指示可以存储多少元素。如果在向数组列表添加新元素后检查`Capacity`属性的值，您将看到该值会自动增加以准备新项目的位置。这在下图中显示了`Count`（作为**A**）和`Capacity`（**B**）之间的差异：
- en: '![](img/a89f3497-53bd-4728-a403-765f66143602.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a89f3497-53bd-4728-a403-765f66143602.png)'
- en: 'The next common and important task is checking whether the array list contains
    an element with a particular value. You can perform this operation by calling
    the `Contains` method, as shown in the following line of code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个常见且重要的任务是检查数组列表是否包含具有特定值的元素。您可以通过调用`Contains`方法来执行此操作，如下面的代码行所示：
- en: '[PRE44]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the specified value is found in the array list, the `true` value is returned.
    Otherwise, `false` is returned. Using this method, you can check whether the element
    exists in the collection. However, how can you find an index of this element?
    To do so, you can use the `IndexOf` or `LastIndexOf` method, as shown in the following
    line of code:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数组列表中找到指定的值，则返回`true`值。否则，返回`false`。使用此方法，您可以检查元素是否存在于集合中。但是，如何找到此元素的索引？为此，您可以使用`IndexOf`或`LastIndexOf`方法，如下面的代码行所示：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `IndexOf` method returns an index of the first occurrence of the element
    in the array list, while `LastIndexOf` returns an index of the last occurrence.
    If a value is not found, `-1` is returned by the method.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`IndexOf`方法返回数组列表中元素的第一次出现的索引，而`LastIndexOf`返回最后一次出现的索引。如果未找到值，则该方法返回`-1`。'
- en: 'Apart from adding some items to the array list, you can also easily remove
    added elements, as shown in the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 除了向数组列表添加一些项目之外，您还可以轻松地删除添加的元素，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: For removing items from the array list, you can use more than one method, namely
    `Remove`, `RemoveAt`, and `RemoveRange`. The first (`Remove`) removes the first
    occurrence of the value provided as the parameter. The `RemoveAt` method removes
    an item with the index equal to the value passed as the parameter, while the other
    (`RemoveRange`) makes it possible to remove the specified number of elements starting
    from the provided index. What is more, if you want to remove all elements, you
    can use the `Clear` method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数组列表中删除项目，可以使用多种方法，即`Remove`，`RemoveAt`和`RemoveRange`。第一个(`Remove`)删除作为参数提供的值的第一次出现。`RemoveAt`方法删除具有与作为参数传递的值相等的索引的项目，而另一个(`RemoveRange`)使您可以从提供的索引开始删除指定数量的元素。而且，如果要删除所有元素，可以使用`Clear`方法。
- en: Among other methods, it is worth mentioning `Reverse`, which reverses the order
    of the elements within the array list, as well as `ToArray`, which returns an
    array with all items stored in the `ArrayList` instance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他方法中，值得一提的是`Reverse`，它可以颠倒数组列表中元素的顺序，以及`ToArray`，它返回存储在`ArrayList`实例中的所有项目的数组。
- en: More information about the `ArrayList` class is available at [https://msdn.microsoft.com/library/system.collections.arraylist.aspx](https://msdn.microsoft.com/library/system.collections.arraylist.aspx).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`ArrayList`类的更多信息可在[https://msdn.microsoft.com/library/system.collections.arraylist.aspx](https://msdn.microsoft.com/library/system.collections.arraylist.aspx)找到。
- en: Generic list
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用列表
- en: As you can see, the `ArrayList` class contains a broad range of features, but
    it has a significant drawback—it is not a strongly typed list. If you want to
    benefit from a strongly typed list, you can use the generic `List` class representing
    the collection, whose size can be increased or decreased, whenever necessary.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`ArrayList`类包含广泛的功能，但它有一个重大缺点——它不是强类型列表。如果要从强类型列表中受益，可以使用泛型`List`类，该类表示集合，其大小可以根据需要增加或减少。
- en: The generic `List` class contains many properties and methods that are very
    useful while developing applications that store data. You will see that many members
    are named exactly the same as in the `ArrayList` class, such as `Count` and `Capacity`
    properties, as well as the `Add`, `AddRange`, `Clear`, `Contains`, `IndexOf`,
    `Insert`, `InsertRange`, `LastIndexOf`, `Remove`, `RemoveAt`, `RemoveRange`, `Reverse`,
    and `ToArray` methods. You can also get a particular element from the list using
    the index and the `[]` operator.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型`List`类包含许多在存储数据时开发应用程序时非常有用的属性和方法。您将看到许多成员的名称与`ArrayList`类完全相同，例如`Count`和`Capacity`属性，以及`Add`，`AddRange`，`Clear`，`Contains`，`IndexOf`，`Insert`，`InsertRange`，`LastIndexOf`，`Remove`，`RemoveAt`，`RemoveRange`，`Reverse`和`ToArray`方法。您还可以使用索引和`[]`运算符从列表中获取特定元素。
- en: Apart from the already-described features, you can also use the comprehensive
    set of extension methods from the `System.Linq` namespace, such as for finding
    the minimum or maximum value (`Min` or `Max`), calculating the average (`Average`),
    ordering in an ascending or descending order (`OrderBy` or `OrderByDescending`),
    as well as checking whether all the elements in the list satisfy a condition (`All`).
    Of course, these are not the only features available for developers while creating
    applications using generic lists in the C# language.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 除了已经描述的功能之外，您还可以使用`System.Linq`命名空间中的全面扩展方法集，例如查找最小值或最大值（`Min`或`Max`），计算平均值（`Average`），按升序或降序排序（`OrderBy`或`OrderByDescending`），以及检查列表中的所有元素是否满足条件（`All`）。当然，这些并不是在使用C#语言中的通用列表创建应用程序时开发人员可用的唯一功能。
- en: More information about the generic `List` class is available at [https://msdn.microsoft.com/library/6sh2ey19.aspx](https://msdn.microsoft.com/library/6sh2ey19.aspx).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有关通用`List`类的更多信息，请访问[https://msdn.microsoft.com/library/6sh2ey19.aspx](https://msdn.microsoft.com/library/6sh2ey19.aspx)。
- en: Let's take a look at two examples that show how to use the generic list in practice.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看两个示例，展示如何在实践中使用通用列表。
- en: Example – average value
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-平均值
- en: The first example utilizes the generic `List` class for storing floating point
    values (of the `double` type) entered by the user. After typing a number, the
    average value is calculated and presented in the console. The program stops the
    operation when an incorrect value is entered by the user.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个示例利用通用`List`类存储用户输入的浮点值（`double`类型）。输入数字后，将计算平均值并在控制台中呈现。当用户输入不正确的值时，程序停止操作。
- en: 'The code from the `Main` method in the `Program` class is as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program`类中`Main`方法中的代码如下：'
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At the beginning, an instance of the `List` class is created. Then, within the
    infinite loop (`do-while`), the program waits until the user enters the number.
    If it is correct, the entered value is added to the list (by calling the `Add`
    method), and the average value from elements of the list is calculated (by calling
    the `Average` method) and shown in the console.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建`List`类的一个实例。然后，在无限循环（`do-while`）中，程序等待用户输入数字。如果正确，输入的值将被添加到列表中（通过调用`Add`方法），并计算列表元素的平均值（通过调用`Average`方法）并显示在控制台中。
- en: 'As a result, you could receive output similar to the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能会收到类似以下的输出：
- en: '[PRE48]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the current example, you have seen how to use the list that stores `double`
    values. However, can it also store instances of user-defined classes? Of course!
    You will see how to achieve this goal in the next example.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，您已经看到了如何使用存储`double`值的列表。但是，它也可以存储用户定义类的实例吗？当然可以！您将在下一个示例中看到如何实现这一目标。
- en: Example – list of people
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-人员列表
- en: The second example regarding the `List` class shows how to use this data structure
    to create a very simple database of people. For each of them, a name, a country,
    and an age are stored. When the program is launched, some data of people are added
    to the list. Then, the data is sorted (using the LINQ expression) and presented
    in the console.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`List`类的第二个示例展示了如何使用这个数据结构来创建一个非常简单的人员数据库。为每个人存储姓名、国家和年龄。启动程序时，将一些人的数据添加到列表中。然后，使用LINQ表达式对数据进行排序，并在控制台中呈现。
- en: 'Let''s start with declaration of the `Person` class, as shown in the following
    code:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Person`类的声明开始，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The class contains three public properties, namely `Name`, `Age`, and `Country`.
    It is worth noting that the `Country` property is of the `CountryEnum` type, which
    defines three constants, that is, `PL` (Poland), `UK` (United Kingdom), and `DE`
    (Germany), as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个公共属性，即`Name`、`Age`和`Country`。值得注意的是，`Country`属性是`CountryEnum`类型，它定义了三个常量，即`PL`（波兰）、`UK`（英国）和`DE`（德国），如下面的代码所示：
- en: '[PRE50]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following part of the code should be added in the `Main` method within
    the `Program` class. It creates a new instance of the `List` class, and adds data
    of a few people with different names, countries, and ages, as shown here:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的以下部分应该添加在`Program`类中`Main`方法中。它创建`List`类的一个新实例，并添加一些人的数据，这些人具有不同的姓名、国家和年龄，如下所示：
- en: '[PRE51]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the next line, the LINQ expression is used to sort the list by names of
    people in ascending order, and convert the results into the list:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，使用LINQ表达式按人名升序对列表进行排序，并将结果转换为列表：
- en: '[PRE52]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, you can easily iterate through all the results using the `foreach` loop:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以使用`foreach`循环轻松遍历所有结果：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'After running the program, the following result is presented:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，呈现以下结果：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: That's all! Let's now talk a bit more about the LINQ expressions, which can
    be used not only to order elements, but also to perform the filtering of items
    based on the provided criteria, and even more.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在让我们再多谈一些LINQ表达式，它不仅可以用于对元素进行排序，还可以根据提供的条件执行筛选，并且更多。
- en: 'As an example, let''s take a look at the following query using the **method
    syntax**:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们来看一下使用**方法语法**的以下查询：
- en: '[PRE55]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It selects the names (the `Select` clause) of all people whose age is lower
    than or equal to `30` years (the `Where` clause), ordered by names (the `OrderBy`
    clause). The query is then executed and the results are returned as a list.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 它选择所有年龄低于或等于`30`岁的人的姓名（`Select`子句）（`Where`子句），按姓名排序（`OrderBy`子句）。然后执行查询，并将结果作为列表返回。
- en: 'The same task could be accomplished using the **query syntax**, as shown in
    the following example, combined with calling the `ToList` method:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用**查询语法**完成相同的任务，如下例所示，结合调用`ToList`方法：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this part of the chapter, you have seen how to use the `ArrayList` class
    and the generic `List` class for storing data in collections, the size of which
    could be dynamically adjusted. However, this is not the end of list-related topics
    within this chapter. Are you ready to get to know another data structure, which
    maintains the elements in the sorted order? If so, let's proceed to the next section,
    which is focused on sorted lists.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的这一部分，您已经了解了如何使用`ArrayList`类和泛型`List`类来存储可以动态调整大小的集合中的数据。但这并不是本章中与列表相关主题的结束。您准备好了解另一个数据结构了吗？它可以保持元素的排序顺序。如果是这样，让我们继续到下一节，重点介绍排序列表。
- en: Sorted lists
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序列表
- en: In this chapter, you have already learned how to store data using arrays and
    lists. However, do you know that you can even use a data structure that ensures
    that the elements are sorted? If not, let's get to know the `SortedList` generic
    class (from the `System.Collections.Generic` namespace), which is a collection
    of **key-value pairs**, sorted by keys, without the necessity of sorting them
    on your own. It is worth mentioning that all keys must be unique and cannot be
    equal to `null`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学会了如何使用数组和列表存储数据。但是，您知道您甚至可以使用一种确保元素排序的数据结构吗？如果不知道，让我们来了解一下`SortedList`泛型类（来自`System.Collections.Generic`命名空间），它是一个按键排序的**键值对**集合，无需自行排序。值得一提的是，所有键必须是唯一的，且不能等于`null`。
- en: You can easily add an element to the collection using the `Add` method, and
    remove a specified item using the `Remove` method. Among other methods, it is
    worth noting `ContainsKey` and `ContainsValue` for checking whether the collection
    contains an item with a given key or value, as well as `IndexOfKey` and `IndexOfValue`
    for returning an index of a given key or value within the collection. As the sorted
    list stores the key-value pairs, you have also access to the `Keys` and `Values`
    properties. Particular keys and values can be easily obtained using the index
    and the `[]` operator.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`Add`方法轻松地向集合中添加元素，并使用`Remove`方法删除指定的项目。值得注意的是，除了其他方法之外，还有`ContainsKey`和`ContainsValue`用于检查集合是否包含具有给定键或值的项目，以及`IndexOfKey`和`IndexOfValue`用于返回集合中给定键或值的索引。由于排序列表存储键值对，因此您还可以访问`Keys`和`Values`属性。可以使用索引和`[]`运算符轻松获取特定的键和值。
- en: More information about the `SortedList` generic class is available at [https://msdn.microsoft.com/library/ms132319.aspx](https://msdn.microsoft.com/library/ms132319.aspx).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`SortedList`泛型类的更多信息，请访问[https://msdn.microsoft.com/library/ms132319.aspx](https://msdn.microsoft.com/library/ms132319.aspx)。
- en: After this short introduction, let's take a look at an example that will show
    you how to use this data structure, and will also indicate some significant differences
    in the code compared with the previously-described `List` class.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，让我们看一个示例，它将向您展示如何使用这种数据结构，并且还将指出与先前描述的`List`类相比的代码中的一些重要差异。
- en: Example – address book
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 通讯录
- en: 'This example uses the `SortedList` class to create a very simple address book,
    which is sorted by names of people. For each person, the following data is stored:
    `Name`, `Age`, and `Country`. The declaration of the `Person` class is shown in
    the following code:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用`SortedList`类创建了一个非常简单的按人名排序的通讯录。对于每个人，存储了以下数据：`Name`，`Age`和`Country`。`Person`类的声明如下所示：
- en: '[PRE57]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'A value of the `Country` property can be set to one of the constants from `CountryEnum`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`Country`属性的值可以设置为`CountryEnum`中的常量之一：'
- en: '[PRE58]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The most interesting part of code is placed in the `Main` method within the
    `Program` class. Here, a new instance of the `SortedList` generic class is created,
    specifying types for keys and values, namely `string` and `Person`, as presented
    in the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分放在`Program`类中的`Main`方法中。在这里，创建了`SortedList`泛型类的新实例，为键和值指定了类型，即`string`和`Person`，如下所示：
- en: '[PRE59]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, you can easily add data to the sorted list by calling the `Add` method,
    passing two parameters, namely a key (that is, a name), and a value (that is,
    an instance of the `Person` class), as shown in the following code snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过调用`Add`方法轻松地向排序列表中添加数据，传递两个参数，即键（即名称）和值（即`Person`类的实例），如下面的代码片段所示：
- en: '[PRE60]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'When all the data are stored within the collection, you can easily iterate
    through its elements (key-value pairs) using the `foreach` loop. It is worth mentioning
    that a type of the variable used in the loop is `KeyValuePair<string, Person>`.
    Thus, you need to use the `Key` and `Value` properties to get access to a key
    and a value, respectively, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有数据都存储在集合中时，您可以轻松地使用`foreach`循环迭代其元素（键值对）。值得一提的是，循环中使用的变量类型是`KeyValuePair<string,
    Person>`。因此，您需要使用`Key`和`Value`属性分别访问键和值，如下所示：
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When the program is launched, you will receive the following results in the
    console:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动后，您将在控制台中收到以下结果：
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the collection is automatically sorted by names, which are used
    as keys for the sorted list. However, you need to remember that keys must be unique,
    so you cannot add more than one person with the same name in this example.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，集合会根据名称自动排序，这些名称被用作排序列表的键。但是，您需要记住键必须是唯一的，因此在这个示例中不能添加多个具有相同名称的人。
- en: Linked lists
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链表
- en: While using the `List` generic class, you can easily get access to particular
    elements of the collection using indices. However, when you get a single element,
    how can you move to the next element of the collection? Is it possible? To do
    so, you may consider the `IndexOf` method to get an index of the element. Unfortunately,
    it returns an index of the first occurrence of a given value in the collection,
    so it will not always work as expected in this scenario.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`List`泛型类时，您可以轻松地使用索引访问集合的特定元素。但是，当您获取单个元素时，如何移动到集合的下一个元素呢？这可能吗？为此，您可以考虑使用`IndexOf`方法来获取元素的索引。不幸的是，它返回给定值在集合中的第一次出现的索引，因此在这种情况下它不总是按预期工作。
- en: 'It would be great to have some kind of *pointer* to the next element, as shown
    in the following diagram:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种*指针*指向下一个元素将会很好，如下图所示：
- en: '![](img/bbd7ff01-046f-41d1-99b1-1ae4c7116212.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbd7ff01-046f-41d1-99b1-1ae4c7116212.png)'
- en: 'With this approach, you can easily navigate from one element to the next one
    using the `Next` property. Such a structure is named the **single-linked list**.
    However, can it be further expanded by adding the `Previous` property to allow
    navigating in forward and backward directions? Of course! Such a data structure
    is named the **double-linked list** and is presented in the following diagram:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，您可以轻松地使用`Next`属性从一个元素导航到下一个元素。这样的结构被称为**单向链表**。但是，通过添加`Previous`属性，可以进一步扩展它以允许向前和向后导航吗？当然可以！这样的数据结构被称为**双向链表**，并在下图中显示：
- en: '![](img/b3e08b82-fb00-4983-b030-17f397830457.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3e08b82-fb00-4983-b030-17f397830457.png)'
- en: As you can see, the double-linked list contains the `First` property that indicates
    the first element in the list. Each item has two properties that point to the
    previous and next element (`Previous` and `Next`, respectively). If there is no
    previous element, the `Previous` property is equal to `null`. Similarly, when
    there is no next element, the `Next` property is set to `null`. Moreover, the
    double-linked list contains the `Last` property that indicates the last element.
    When there are no items in the list, both the `First` and `Last` properties are
    set to `null`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，双向链表包含`First`属性，指示列表中的第一个元素。每个项目都有两个属性，指向前一个和后一个元素（分别为`Previous`和`Next`）。如果没有前一个元素，则`Previous`属性等于`null`。同样，当没有下一个元素时，`Next`属性设置为`null`。此外，双向链表包含`Last`属性，指示最后一个元素。当列表中没有项目时，`First`和`Last`属性都设置为`null`。
- en: However, do you need to implement such a data structure on your own if you want
    to use it in your C#-based applications? Fortunately, no, because it is available
    as the `LinkedList` generic class in the `System.Collections.Generic` namespace.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想在基于C#的应用程序中使用它，是否需要自己实现这样的数据结构？幸运的是，不需要，因为它作为`System.Collections.Generic`命名空间中的`LinkedList`泛型类可用。
- en: While creating an instance of the class, you need to specify the type parameter
    that indicates a type of a single element within the list, such as `int` or `string`.
    However, a type of a single node is not just `int` or `string`, because in such
    a case you will not have access to any additional properties related to the double-linked
    list, such as `Previous` or `Next`. To solve this problem, each node is an instance
    of the `LinkedListNode` generic class, such as `LinkedListNode<int>` or `LinkedListNode<string>`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建类的实例时，您需要指定类型参数，指示列表中单个元素的类型，例如`int`或`string`。但是，单个节点的类型不仅仅是`int`或`string`，因为在这种情况下，您将无法访问与双向链表相关的任何其他属性，例如`Previous`或`Next`。为了解决这个问题，每个节点都是`LinkedListNode`泛型类的实例，例如`LinkedListNode<int>`或`LinkedListNode<string>`。
- en: 'Some additional explanation is necessary for the methods of adding new nodes
    to the double-linked list. For this purpose, you can use a set of methods, namely:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于向双向链表添加新节点的方法需要一些额外的解释。为此，您可以使用一组方法，即：
- en: '`AddFirst`: For adding an element at the beginning of the list'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddFirst`：用于在列表的开头添加元素'
- en: '`AddLast`: For adding an element at the end of the list'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddLast`：用于在列表的末尾添加元素'
- en: '`AddBefore`: For adding an element before the specified node in the list'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddBefore`：用于在列表中指定节点之前添加元素'
- en: '`AddAfter`: For adding an element after the specified node in the list'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddAfter`：用于在列表中指定节点之后添加元素'
- en: All these methods return an instance of the `LinkedListNode` class. Moreover,
    there are also other methods, such as `Contains` for checking whether the specified
    value exists in the list, `Clear` for removing all elements from the list, and `Remove`
    for removing a node from the list.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都返回`LinkedListNode`类的实例。此外，还有其他方法，例如`Contains`用于检查列表中是否存在指定的值，`Clear`用于从列表中删除所有元素，`Remove`用于从列表中删除节点。
- en: More information about the `LinkedList` generic class is available at [https://msdn.microsoft.com/library/he2s3bh7.aspx](https://msdn.microsoft.com/library/he2s3bh7.aspx).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`LinkedList`泛型类的更多信息，请访问[https://msdn.microsoft.com/library/he2s3bh7.aspx](https://msdn.microsoft.com/library/he2s3bh7.aspx)。
- en: After this short introduction, you should be ready to take a look at an example
    that shows how to apply the double-linked list, implemented as the `LinkedList`
    class, in practice.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，您应该准备好查看一个示例，展示如何在实践中应用双向链表，实现为`LinkedList`类。
- en: Example – book reader
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 书籍阅读器
- en: 'As an example, you will prepare a simple application that allows a user to
    read a book by changing the pages. One should be able to move to the next page
    (if it exists) after pressing the *N* key, and go back to the previous page (if
    it exists) after pressing the *P* key. The content of the current page, together
    with the page number, should be shown in the console, as presented in the following
    screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您将准备一个简单的应用程序，允许用户通过更改页面来阅读书籍。按下*N*键后，应能够转到下一页（如果存在），按下*P*键后，应能够返回到上一页（如果存在）。当前页面的内容以及页码应该显示在控制台中，如下面的屏幕截图所示：
- en: '![](img/6b53b23c-4fd4-4102-a08f-8ba0a5a9ff04.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6b53b23c-4fd4-4102-a08f-8ba0a5a9ff04.png)'
- en: 'Let''s start with the declaration of the `Page` class, as shown in the following
    code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Page`类的声明开始，如下面的代码所示：
- en: '[PRE63]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This class represents a single page and contains the `Content` property. You
    should create a few instances of the `Page` class, representing six pages of the
    book, in the `Main` method in the `Program` class, as presented in the following
    code snippet:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类表示一个单独的页面，包含`Content`属性。您应该在`Program`类的`Main`方法中创建`Page`类的几个实例，表示书的六页，如下面的代码片段所示：
- en: '[PRE64]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When the instances are created, let''s proceed to constructing the linked list,
    using a few addition-related methods, as shown in the following lines of code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 创建实例后，让我们继续使用一些与添加相关的方法来构建链表，如下面的代码行所示：
- en: '[PRE65]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the first line, a new list is created. Then, the following operations are
    performed:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个新列表。 然后执行以下操作：
- en: Adding the data of the second page at the end of the list (`[2]`)
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将第二页的数据添加到列表的末尾（`[2]`）
- en: Adding the data of the fourth page at the end of the list (`[2, 4]`)
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的末尾添加第四页的数据（`[2, 4]`）
- en: Adding the data of the sixth page at the end of the list (`[2, 4, 6]`)
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的末尾添加第六页的数据（`[2, 4, 6]`）
- en: Adding the data of the first page at the beginning of the list (`[1, 2, 4, 6]`)
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的开头添加第一页的数据（`[1, 2, 4, 6]`）
- en: Adding the data of the third page before the node of the fourth page (`[1, 2,
    3, 4, 6]`)
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四页的节点之前添加第三页的数据（`[1, 2, 3, 4, 6]`）
- en: Adding the data of the fifth page after the node of the fourth page (`[1, 2,
    3, 4, 5, 6]`)
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第四页的节点后添加第五页的数据（`[1, 2, 3, 4, 5, 6]`）
- en: 'The next part of the code is responsible for presenting the page in the console,
    as well as for navigating between pages after pressing the appropriate keys. The
    code is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分负责在控制台中呈现页面，以及在按下适当的键后在页面之间导航。 代码如下：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Some explanation may be useful for this part of the code. In the first line,
    a value of the `current` variable is set to the first node in the linked list.
    Generally speaking, the `current` variable represents the page which is currently
    presented in the console. Then, the initial value for the page number is set to
    `1` (the `number` variable). However, the most interesting and complicated part
    of the code is shown in the `while` loop.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分代码可能需要一些解释。 在第一行，将`current`变量的值设置为链表中的第一个节点。 一般来说，`current`变量表示当前在控制台中呈现的页面。
    然后，将页面编号的初始值设置为`1`（`number`变量）。 但是，代码中最有趣和复杂的部分在`while`循环中显示。
- en: Within the loop, the current content of the console is cleared and the string
    for presenting the page number is properly formatted to display. Before and after
    it, the `-` characters are added. Moreover, leading spaces are inserted (using
    the `PadLeft` method) to prepare the string that is centered horizontally.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，清除控制台的当前内容，并正确格式化用于显示页面编号的字符串。 在其前后添加`-`字符。 此外，插入前导空格（使用`PadLeft`方法）以准备水平居中的字符串。
- en: Then, the content of the page is divided into lines of no more than 90 characters
    and written in the console. For dividing the string, the `Substring` method and
    the `Length` properties are used. In a similar way, additional information (about
    quotations from another book) is presented in the console. It is worth mentioning
    the `Environment.NewLine` property that inserts the line break in a specified
    place of the string. Then, the `PREVIOUS` and `NEXT` captions are shown, if the
    previous or the next page is available.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将页面的内容分成不超过90个字符的行，并写入控制台。 为了分割字符串，使用了`Substring`方法和`Length`属性。 类似地，控制台中呈现了有关另一本书的引用的其他信息。
    值得一提的是，`Environment.NewLine`属性会在字符串的指定位置插入换行符。 然后，如果上一页或下一页可用，则显示`PREVIOUS`和`NEXT`标题。
- en: In the following part of the code, the program waits until the user presses
    any key and does not present it in the console (by passing the `true` value as
    the parameter). When the user presses the *N* key, the `current` variable is set
    to the next node, using the `Next` property. Of course, the operation should not
    be performed when the next page is unavailable. In a similar way, the *P* key
    is handled, which causes the user to be navigated to the previous page. It is
    worth mentioning that the number of the page (the `number` variable) is modified
    together with changing a value of the `current` variable.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的下一部分中，程序会等待用户按下任意键，然后不在控制台中呈现它（通过将`true`值作为参数传递）。 当用户按下*N*键时，使用`Next`属性将`current`变量设置为下一个节点。
    当下一页不可用时，当然不应执行此操作。 类似地，处理*P*键，这会导致用户导航到上一页。 值得一提的是，页面的编号（`number`变量）会随着`current`变量的值的改变而修改。
- en: 'At the end, the code of the auxiliary `GetSpaces` method is shown:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，显示了辅助`GetSpaces`方法的代码：
- en: '[PRE67]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This just prepares and returns the `string` variable with the specified number
    of spaces.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是准备并返回具有指定空格数的`string`变量。
- en: Circular-linked lists
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环链表
- en: In the previous section, you have learned about the double-linked list. As you
    can see, the implementation of such a data structure allows for navigating between
    the nodes using the `Previous` and `Next` properties. However, the `Previous`
    property of the first node is set to `null`, as is the `Next` property of the
    last node. Do you know that you can easily expand this approach to create the
    **circular-linked list**?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一部分，您已经了解了双向链表。 正如您所看到的，这种数据结构的实现允许使用`Previous`和`Next`属性在节点之间导航。 但是，第一个节点的`Previous`属性设置为`null`，最后一个节点的`Next`属性也是如此。
    您知道您可以轻松扩展此方法以创建**循环链表**吗？
- en: 'Such a data structure is presented in the following diagram:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数据结构在下图中呈现：
- en: '![](img/7329d090-98aa-4bc7-a60e-442040f75443.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7329d090-98aa-4bc7-a60e-442040f75443.png)'
- en: Here, the `Previous` property of the first node navigates to the last one, while
    the `Next` property of the last node navigates to the first. This data structure
    can be useful in some specific cases, as you will see while developing a real-world
    example.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个节点的`Previous`属性导航到最后一个节点，而最后一个节点的`Next`属性导航到第一个节点。 在某些特定情况下，这种数据结构可能会很有用，就像您在开发真实世界示例时所看到的那样。
- en: It is worth mentioning that the way of navigating between nodes does not need
    to be implemented as properties. It can also be replaced with methods, as you
    will see in the example within the following section.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，节点之间导航的方式不需要实现为属性。 它也可以用方法替换，正如您将在以下部分的示例中看到的。
- en: Implementation
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实施
- en: 'After the short introduction to the topic of circular-linked lists, it is time
    to take a look at the implementation code. Let''s start with the following code
    snippet:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在对循环链表主题进行简短介绍之后，是时候看一下实现代码了。 让我们从以下代码片段开始：
- en: '[PRE68]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The implementation of the circular-linked list can be created as a generic class
    that extends `LinkedList`, as shown in the preceding code. It is worth mentioning
    the implementation of the `GetEnumerator` method, which uses the `CircularLinkedListEnumerator`
    class. By creating it, you will be able to indefinitely iterate through all the
    elements of the circular-linked list, using the `foreach` loop.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 循环链表的实现可以创建为一个扩展`LinkedList`的通用类，如前面的代码所示。值得一提的是`GetEnumerator`方法的实现，它使用`CircularLinkedListEnumerator`类。通过创建它，您将能够使用`foreach`循环无限迭代循环链表的所有元素。
- en: 'The code of the `CircularLinkedListEnumerator` class is as follows:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircularLinkedListEnumerator`类的代码如下：'
- en: '[PRE69]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `CircularLinkedListEnumerator` class implements the `IEnumerator` interface.
    The class declares the `private` field representing the current node (`_current`)
    in the iteration over the list. It also contains two properties, namely `Current`
    and `IEnumerator.Current`, which are required by the `IEnumerator` interface.
    The constructor just sets a value of the `_current` variable, based on an instance
    of the `LinkedList` class, passed as the parameter.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`CircularLinkedListEnumerator`类实现了`IEnumerator`接口。该类声明了表示列表迭代中当前节点（`_current`）的`private`字段。它还包含两个属性，即`Current`和`IEnumerator.Current`，这是`IEnumerator`接口所需的。构造函数只是根据作为参数传递的`LinkedList`类的实例设置了`_current`变量的值。'
- en: One of the most important parts of code is the `MoveNext` method. It stops iterating
    when the `_current` variable is set to `null`, that is, if there are no items
    in the list. Otherwise, it changes the current element to the next one or to the
    first node in the list, if the next node is unavailable. In the `Reset` method,
    you just set a value of the `_current` field to the first node in the list.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最重要的部分之一是`MoveNext`方法。当`_current`变量设置为`null`时，即列表中没有项目时，它停止迭代。否则，它将当前元素更改为下一个元素，或者更改为列表中的第一个节点，如果下一个节点不可用。在`Reset`方法中，只需将`_current`字段的值设置为列表中的第一个节点。
- en: 'At the end, you need to create two extension methods that make it possible
    to navigate to the first element while trying to get the next element from the
    last item in the list, as well as to navigate to the last element while trying
    to get the previous element from the first item in the list. To simplify the implementation,
    such features will be available as `Next` and `Previous` methods, instead of `Next`
    and `Previous` properties, as shown in the preceding diagram. The code is shown
    here:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要创建两个扩展方法，使得在尝试从列表中的最后一个项目获取下一个元素时，可以导航到第一个元素，以及在尝试从列表中的第一个项目获取上一个元素时，可以导航到最后一个元素。为了简化实现，这些功能将作为`Next`和`Previous`方法而不是`Next`和`Previous`属性提供，如前面的图所示。代码如下所示：
- en: '[PRE70]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The first extension method, namely `Next`, checks whether the node exists and
    whether the list is available. In such a case, it returns a value of the `Next`
    property of the node (if such a value is not equal to `null`) or returns a reference
    to the first element in the list, using the `First` property. The `Previous` method
    operates in a similar way.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个扩展方法，即`Next`，检查节点是否存在以及列表是否可用。在这种情况下，它返回节点的`Next`属性的值（如果这个值不等于`null`），或者使用`First`属性返回列表中的第一个元素的引用。`Previous`方法以类似的方式操作。
- en: That's all! You have just completed the C#-based implementation of the circular-linked
    list, which can be used later in various applications. But how? Let's take a look
    at the following example that uses this data structure.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止！您刚刚完成了基于C#的循环链表的实现，这可以在以后的各种应用中使用。但是如何呢？让我们看一下下面使用这种数据结构的示例。
- en: Example – spin the wheel
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 旋转轮子
- en: 'This example simulates a game in which the user spins a wheel with random speed.
    The wheel rotates slower and slower until it stops. Then the user can spin it
    again, from the previous stop position, as shown in the following diagram:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例模拟了一个游戏，用户以随机速度旋转轮子。轮子的旋转速度越来越慢，直到停止。然后用户可以再次旋转它，从上一次停止的位置开始，如下图所示：
- en: '![](img/75f72d77-a896-4392-94ac-61d6771fef43.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![](img/75f72d77-a896-4392-94ac-61d6771fef43.png)'
- en: 'Let''s proceed to the first part of code of the `Main` method in the `Program`
    class:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续`Program`类中`Main`方法的代码的第一部分：
- en: '[PRE71]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: At the beginning, a new instance of the `CircularLinkedList` class is created,
    which represents the circular-linked list with `string` elements. Then, eight
    values are added, namely `Sport`, `Culture`, `History`, `Geography`, `People`,
    `Technology`, `Nature`, and `Science`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建了`CircularLinkedList`类的新实例，它表示具有`string`元素的循环链表。然后添加了八个值，即`Sport`，`Culture`，`History`，`Geography`，`People`，`Technology`，`Nature`和`Science`。
- en: 'The following part of the code performs the most important operations:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分执行了最重要的操作：
- en: '[PRE72]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: First, three variables are declared, namely for drawing random values (`random`),
    the total drawn time of spinning of the wheel in milliseconds (`totalTime`), as
    well as the remaining time of spinning of the wheel in milliseconds (`remainingTime`).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先声明了三个变量，即用于生成随机值的变量（`random`），旋转轮子的总时间（以毫秒为单位）（`totalTime`），以及旋转轮子的剩余时间（以毫秒为单位）（`remainingTime`）。
- en: Then, the `foreach` loop is used to iterate through all the elements within
    the circular-linked list. If there are no `break` or `return` instructions within
    such a loop, it will execute indefinitely due to the nature of the circular-linked
    list. If the last item is reached, the first element in the list is taken automatically
    in the next iteration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`foreach`循环来迭代循环链表中的所有元素。如果在这样的循环中没有`break`或`return`指令，它将由于循环链表的特性而无限执行。如果到达最后一个项目，下一个迭代将自动获取列表中的第一个元素。
- en: In the loop, the remaining time is checked. If it is less than or equal to zero,
    that is, the wheel has stopped or has not been started yet, the message is presented
    to the user and the program waits until the *Enter* key is pressed. In such a
    situation, the new spinning operation is configured by drawing the total time
    of spinning and setting the remaining time. When the user presses any other key,
    the program stops the execution.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，检查剩余时间。如果剩余时间小于或等于零，即车轮已停止或尚未启动，将向用户显示消息，并等待*Enter*键被按下。在这种情况下，通过绘制旋转的总时间和设置剩余时间来配置新的旋转操作。当用户按下其他键时，程序将停止执行。
- en: In the next step, the time for one iteration of the loop is calculated. The
    formula makes it possible to provide smaller times at the beginning (the wheel
    spins faster) and bigger times at the end (the wheel spins slower). Then, the
    remaining time decreases and the program waits for the specified number of milliseconds,
    using the `Sleep` method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，计算了循环的一次迭代时间。该公式使得在开始时可以提供较小的时间（车轮旋转更快），在结束时可以提供较大的时间（车轮旋转更慢）。然后，剩余时间减少，程序使用`Sleep`方法等待指定的毫秒数。
- en: At the end, the foreground color is changed to red, if the final result is shown,
    and the currently-chosen category on the spinning wheel is presented in the console.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果显示了最终结果，则将前景色更改为红色，并在控制台中显示当前选择的旋转轮上的类别。
- en: 'When you run the application, you can get the following result:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行应用程序时，您可以得到以下结果：
- en: '[PRE73]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You have already completed the example that uses the circular-linked list. It
    is one of the data structures that have been described in this chapter. If you
    want to briefly summarize the information you have learned, let's proceed to the
    short summary of this topic.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经完成了使用循环链表的示例。这是本章中描述的数据结构之一。如果您想简要总结您所学到的信息，让我们继续对这个主题进行简要总结。
- en: Summary
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Arrays and lists are among the most common data structures used while developing
    various kinds of applications. However, this topic is not as easy as it seems
    to be, because even arrays can be divided into a few variants, namely single-dimensional,
    multi-dimensional, and jagged arrays, also referred to as arrays of arrays.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和列表是开发各种应用程序时最常用的数据结构之一。然而，这个主题并不像看起来那么简单，因为即使数组也可以分为几个变体，即单维数组、多维数组和交错数组，也称为数组的数组。
- en: In the case of lists, the differences are even more visible, as you could see
    in the case of simple, generic, sorted, single-linked, double-linked, and circular-linked
    lists. Fortunately, the built-in implementation is available for the array list,
    as well as the generic, sorted, and double-linked lists. Furthermore, you can
    quite easily extend the double-linked list to behave as the circular-linked list.
    Therefore, you can benefit from the features of suitable structures without the
    significant development effort.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表的情况下，差异更加明显，正如您在简单、通用、排序、单链、双链和循环链列表的情况下所看到的。幸运的是，数组列表、通用、排序和双链列表都有内置的实现。此外，您可以相当容易地扩展双链表以表现为循环链表。因此，您可以在不需要显著开发工作的情况下从适当的结构特性中受益。
- en: The available types of data structures can sound quite complicated, but in this
    chapter you have seen detailed descriptions of particular data structures, together
    with the implementation code of C#-based examples. They should simplify things
    for you and could be used as the base for your future projects.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可用的数据结构类型听起来可能相当复杂，但在本章中，您已经看到了特定数据结构的详细描述，以及基于C#的示例的实现代码。它们应该为您简化事情，并可以作为您未来项目的基础。
- en: Are you ready to learn other data structures? If so, let's proceed to the next
    chapter and read about stacks and queues!
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您准备好学习其他数据结构了吗？如果是这样，让我们继续到下一章，了解关于栈和队列的内容！
