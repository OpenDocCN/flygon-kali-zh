- en: Introduction to Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker简介
- en: The first thing we will do in this chapter will be to explain the reasoning
    behind Docker and its architecture. We will cover Docker concepts such as images,
    layers, and containers. Next, we will install Docker and learn how to pull a sample,
    basic Java application image from the `remote` registry and run it on the local
    machine.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将首先解释Docker及其架构背后的推理。我们将涵盖Docker概念，如镜像、层和容器。接下来，我们将安装Docker，并学习如何从“远程”注册表中拉取一个示例基本的Java应用程序镜像，并在本地机器上运行它。
- en: 'Docker was created as the internal tool in the platform as a service company,
    dotCloud. In March 2013, it was released to the public as open source. Its source
    code is freely available to everyone on GitHub at: [h](https://github.com/docker/docker)
    [t](https://github.com/docker/docker) [t](https://github.com/docker/docker) [p](https://github.com/docker/docker)
    [s](https://github.com/docker/docker) [://g](https://github.com/docker/docker)
    [i](https://github.com/docker/docker) [t](https://github.com/docker/docker) [h](https://github.com/docker/docker)
    [u](https://github.com/docker/docker) [b](https://github.com/docker/docker) [.](https://github.com/docker/docker)
    [c](https://github.com/docker/docker) [o](https://github.com/docker/docker) [m](https://github.com/docker/docker)
    [/d](https://github.com/docker/docker) [o](https://github.com/docker/docker) [c](https://github.com/docker/docker)
    [k](https://github.com/docker/docker) [e](https://github.com/docker/docker) [r](https://github.com/docker/docker)
    [/d](https://github.com/docker/docker) [o](https://github.com/docker/docker) [c](https://github.com/docker/docker)
    [k](https://github.com/docker/docker) [e](https://github.com/docker/docker) [r](https://github.com/docker/docker)
    . Not only do the core Docker Inc. team work on the development of Docker, there
    are also a lot of big names sponsoring their time and effort to enhance and contribute
    to Docker such as Google, Microsoft, IBM, Red Hat, Cisco systems, and many others.
    Kubernetes is a tool developed by Google for deploying containers across clusters
    of computers based on best practices learned by them on Borg (Google''s homemade
    container system). It compliments Docker when it comes to orchestration, automating
    deployment, managing, and scaling containers; it manages workloads for Docker
    nodes by keeping container deployments balanced across a cluster. Kubernetes also
    provides ways for containers to communicate with each other, without the need
    for opening network ports. Kubernetes is also an open source project, living on
    the GitHub at [h](https://github.com/kubernetes/kubernetes) [t](https://github.com/kubernetes/kubernetes)
    [t](https://github.com/kubernetes/kubernetes) [p](https://github.com/kubernetes/kubernetes)
    [s](https://github.com/kubernetes/kubernetes) [://g](https://github.com/kubernetes/kubernetes)
    [i](https://github.com/kubernetes/kubernetes) [t](https://github.com/kubernetes/kubernetes)
    [h](https://github.com/kubernetes/kubernetes) [u](https://github.com/kubernetes/kubernetes)
    [b](https://github.com/kubernetes/kubernetes) [.](https://github.com/kubernetes/kubernetes)
    [c](https://github.com/kubernetes/kubernetes) [o](https://github.com/kubernetes/kubernetes)
    [m](https://github.com/kubernetes/kubernetes) [/k](https://github.com/kubernetes/kubernetes)
    [u](https://github.com/kubernetes/kubernetes) [b](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [r](https://github.com/kubernetes/kubernetes)
    [n](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [t](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [s](https://github.com/kubernetes/kubernetes) [/k](https://github.com/kubernetes/kubernetes)
    [u](https://github.com/kubernetes/kubernetes) [b](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [r](https://github.com/kubernetes/kubernetes)
    [n](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [t](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [s](https://github.com/kubernetes/kubernetes) . Everyone can contribute. Let''s
    begin our journey with Docker first. The following will be covered in:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是作为平台即服务公司dotCloud的内部工具创建的。 2013年3月，它作为开源软件向公众发布。 它的源代码可以在GitHub上免费获得：[h](https://github.com/docker/docker)
    [t](https://github.com/docker/docker) [t](https://github.com/docker/docker) [p](https://github.com/docker/docker)
    [s](https://github.com/docker/docker) [://g](https://github.com/docker/docker)
    [i](https://github.com/docker/docker) [t](https://github.com/docker/docker) [h](https://github.com/docker/docker)
    [u](https://github.com/docker/docker) [b](https://github.com/docker/docker) [.](https://github.com/docker/docker)
    [c](https://github.com/docker/docker) [o](https://github.com/docker/docker) [m](https://github.com/docker/docker)
    [/d](https://github.com/docker/docker) [o](https://github.com/docker/docker) [c](https://github.com/docker/docker)
    [k](https://github.com/docker/docker) [e](https://github.com/docker/docker) [r](https://github.com/docker/docker)
    [/d](https://github.com/docker/docker) [o](https://github.com/docker/docker) [c](https://github.com/docker/docker)
    [k](https://github.com/docker/docker) [e](https://github.com/docker/docker) [r](https://github.com/docker/docker)
    。不仅Docker Inc.的核心团队致力于Docker的开发，还有许多大公司赞助他们的时间和精力来增强和贡献Docker，如谷歌、微软、IBM、红帽、思科系统等。
    Kubernetes是谷歌开发的一个工具，用于根据他们在Borg（谷歌自制的容器系统）上学到的最佳实践在计算机集群上部署容器。 在编排、自动化部署、管理和扩展容器方面，它与Docker相辅相成；它通过在集群中保持容器部署的平衡来管理Docker节点的工作负载。
    Kubernetes还提供了容器之间通信的方式，无需打开网络端口。 Kubernetes也是一个开源项目，存放在GitHub上[h](https://github.com/kubernetes/kubernetes)
    [t](https://github.com/kubernetes/kubernetes) [t](https://github.com/kubernetes/kubernetes)
    [p](https://github.com/kubernetes/kubernetes) [s](https://github.com/kubernetes/kubernetes)
    [://g](https://github.com/kubernetes/kubernetes) [i](https://github.com/kubernetes/kubernetes)
    [t](https://github.com/kubernetes/kubernetes) [h](https://github.com/kubernetes/kubernetes)
    [u](https://github.com/kubernetes/kubernetes) [b](https://github.com/kubernetes/kubernetes)
    [.](https://github.com/kubernetes/kubernetes) [c](https://github.com/kubernetes/kubernetes)
    [o](https://github.com/kubernetes/kubernetes) [m](https://github.com/kubernetes/kubernetes)
    [/k](https://github.com/kubernetes/kubernetes) [u](https://github.com/kubernetes/kubernetes)
    [b](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [r](https://github.com/kubernetes/kubernetes) [n](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [t](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [s](https://github.com/kubernetes/kubernetes)
    [/k](https://github.com/kubernetes/kubernetes) [u](https://github.com/kubernetes/kubernetes)
    [b](https://github.com/kubernetes/kubernetes) [e](https://github.com/kubernetes/kubernetes)
    [r](https://github.com/kubernetes/kubernetes) [n](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [t](https://github.com/kubernetes/kubernetes)
    [e](https://github.com/kubernetes/kubernetes) [s](https://github.com/kubernetes/kubernetes)
    。每个人都可以贡献。 让我们首先从Docker开始我们的旅程。 以下内容将被覆盖：
- en: We will start with the basic idea behind this wonderful tool and show the benefits
    gained from using it, in comparison to traditional virtualization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将从这个神奇工具背后的基本理念开始，并展示使用它所获得的好处，与传统虚拟化相比。
- en: 'We will install Docker on three major platforms: macOS, Linux, and Windows'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在三个主要平台上安装Docker：macOS、Linux和Windows
- en: The idea behind Docker
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker的理念
- en: The idea behind Docker is to pack an application with all the dependencies it
    needs into a single, standardized unit for the deployment. Those dependencies
    can be binaries, libraries, JAR files, configuration files, scripts, and so on.
    Docker wraps up all of it into a complete filesystem that contains everything
    your Java application needs to run the virtual machine itself, the application
    server such as Wildfly or Tomcat, the application code, and `runtime` libraries,
    and basically everything you would install and deploy on the server to make your
    application run. Packaging all of this into a complete image guarantees that it
    is portable; it will always run in the same way, no matter what environment it
    is deployed in. With Docker, you can run Java applications without having to install
    a Java runtime on the host machine. All the problems related to incompatible JDK
    or JRE, wrong version of the application server, and so on are gone. Upgrades
    are also easy and effortless; you just run the new version of your container on
    the host.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的理念是将应用程序及其所有依赖项打包成一个单一的标准化部署单元。这些依赖项可以是二进制文件、库文件、JAR文件、配置文件、脚本等。Docker将所有这些内容打包成一个完整的文件系统，其中包含了Java应用程序运行所需的一切，包括虚拟机本身、诸如Wildfly或Tomcat之类的应用服务器、应用程序代码和运行时库，以及服务器上安装和部署的一切内容，以使应用程序运行。将所有这些内容打包成一个完整的镜像可以保证其可移植性；无论部署在何种环境中，它都将始终以相同的方式运行。使用Docker，您可以在主机上运行Java应用程序，而无需安装Java运行时。与不兼容的JDK或JRE、应用服务器的错误版本等相关的所有问题都将消失。升级也变得简单而轻松；您只需在主机上运行容器的新版本。
- en: If you need to do some cleanup, you can just destroy the Docker image and it's
    as though nothing ever happened. Think about Docker, not as a programming language
    or a framework, but rather as a tool that helps in solving the common problems
    such as installing, distributing, and managing the software. It allows developers
    and DevOps to build, ship, and run their code anywhere. Anywhere means also on
    more than one machine, and this is where Kubernetes comes in handy; we will shortly
    get back to it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要进行一些清理，您只需销毁Docker镜像，就好像什么都没有发生过一样。不要将Docker视为一种编程语言或框架，而应将其视为一种有助于解决安装、分发和管理软件等常见问题的工具。它允许开发人员和DevOps在任何地方构建、发布和运行其代码。任何地方也包括在多台机器上，这就是Kubernetes派上用场的地方；我们很快将回到这一点。
- en: Having all of your application code and runtime dependencies packaged as a single
    and complete unit of software may seem the same as a virtualization engine, but
    it's far from that, as we will explain now. To fully get to know what Docker really
    is, first we need to understand the difference between traditional virtualization
    and containerization. Let's compare those two technologies now.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有应用程序代码和运行时依赖项打包为单个完整的软件单元可能看起来与虚拟化引擎相同，但实际上远非如此，我们将在下面解释。要完全了解Docker的真正含义，首先我们需要了解传统虚拟化和容器化之间的区别。现在让我们比较这两种技术。
- en: Virtualization and containerization compared
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化和容器化的比较
- en: A traditional virtual machine represents the hardware-level virtualization.
    In essence, it's a complete, virtualized physical machine with BIOS and an operating
    system installed. It runs on top of the host operating system. Your Java application
    runs in the virtualized environment as it would normally do on your own machine.
    There are a lot of advantages from using virtual machines for your applications.
    Each virtual machine can have a totally different operating system; those can
    be different Linux flavors, Solaris, or Windows, for example. Virtual machines
    are also very secure by definition; they are totally isolated, complete operating
    systems in a box.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 传统虚拟机代表硬件级虚拟化。实质上，它是一个完整的、虚拟化的物理机器，具有BIOS和安装了操作系统。它运行在主机操作系统之上。您的Java应用程序在虚拟化环境中运行，就像在您自己的机器上一样。使用虚拟机为您的应用程序带来了许多优势。每个虚拟机可以拥有完全不同的操作系统；例如，这些可以是不同的Linux版本、Solaris或Windows。虚拟机也是非常安全的；它们是完全隔离的、完整的操作系统。
- en: 'However, nothing comes without a price. Virtual machines contain all the features
    that an operating system needs to have to be operational: core system libraries,
    device drivers, and so on. Sometimes they can be resource hungry and heavyweight.
    Virtual machines require full installation, which sometimes can be cumbersome
    and not so easy to set up. Last, but not least, you will need more compute power
    and resources to execute your application in the virtual machine the hypervisor
    needs to first import the virtual machine and then power it up and this takes
    time. However, I believe, when it comes to running Java applications, having the
    complete virtualized environment is not something that we would want very often.
    Docker comes to the rescue with the concept of containerization. Java applications
    (but of course, it''s not limited to Java) run on Docker in an isolated environment
    called a container. A container is not a virtual machine in the popular sense.
    It behaves as a kind of operating system virtualization, but there''s no emulation
    at all. The main difference is that while each traditional virtual machine image
    runs on an independent guest operating system, the Docker containers run within
    the same kernel running on the host machine. A container is self-sufficient and
    isolated not only from the underlying OS, but from other containers as well. It
    has its own separated filesystem and environment variables. Naturally, containers
    can communicate with each other (as an application and a database container for
    example) and also can share the files on disk. Here comes the main difference
    when comparing to traditional virtualization because the containers run within
    the same kernel they utilize fewer system resources. All the operating system
    core software is removed from the Docker image. The base container can be, and
    usually is, very lightweight. There is no overhead related to a classic virtualization
    hypervisor and a guest operating system. This way you can achieve almost bare
    metal, core performance for your Java applications. Also, the startup time of
    a containerized Java application is usually very low due to the minimal overhead
    of the container. You can also roll-out hundreds of application containers in
    seconds to reduce the time needed for provisioning your software. We will do this
    using Kubernetes in one of the coming chapters. Although Docker is quite different
    from the traditional virtualization engines. Be aware that containers cannot substitute
    virtual machines for all use cases; a thoughtful evaluation is still required
    to determine what is best for your application. Both solutions have their advantages.
    On the one hand, we have the fully isolated secure virtual machine with average
    performance. On the other hand, we have the containers that are missing some of
    the key features, but are equipped with high performance that can be provisioned
    very fast. Let''s see what other benefits you will get when using Docker containerization.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有什么是不需要付出代价的。虚拟机包含操作系统运行所需的所有功能：核心系统库、设备驱动程序等。有时它们可能会占用资源并且很重。虚拟机需要完整安装，有时可能会很繁琐，设置起来也不那么容易。最后但并非最不重要的是，您需要更多的计算能力和资源来在虚拟机中执行您的应用程序，虚拟机监视程序需要首先导入虚拟机，然后启动它，这需要时间。然而，我相信，当涉及到运行Java应用程序时，拥有完整的虚拟化环境并不是我们经常想要的。Docker通过容器化的概念来拯救。Java应用程序（当然，不仅限于Java）在Docker上运行在一个被称为容器的隔离环境中。容器在流行意义上不是虚拟机。它表现为一种操作系统虚拟化，但根本没有仿真。主要区别在于，每个传统虚拟机镜像都在独立的客户操作系统上运行，而Docker容器在主机上运行的相同内核内部运行。容器是自给自足的，不仅与底层操作系统隔离，而且与其他容器隔离。它有自己独立的文件系统和环境变量。当然，容器可以相互通信（例如应用程序和数据库容器），也可以共享磁盘上的文件。与传统虚拟化相比的主要区别在于，由于容器在相同的内核内部运行，它们利用更少的系统资源。所有操作系统核心软件都从Docker镜像中删除。基础容器通常非常轻量级。与经典虚拟化监视程序和客户操作系统相关的开销都没有了。这样，您可以为Java应用程序实现几乎裸金属的核心性能。此外，由于容器的最小开销，容器化Java应用程序的启动时间通常非常短。您还可以在几秒钟内部署数百个应用程序容器，以减少软件配置所需的时间。我们将在接下来的章节中使用Kubernetes来实现这一点。尽管Docker与传统虚拟化引擎有很大不同。请注意，容器不能替代所有用例的虚拟机；仍然需要深思熟虑的评估来确定对您的应用程序最好的是什么。两种解决方案都有其优势。一方面，我们有性能一般的完全隔离安全的虚拟机。另一方面，我们有一些关键功能缺失的容器，但配备了可以非常快速配置的高性能。让我们看看在使用Docker容器化时您将获得的其他好处。
- en: Benefits from using Docker
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker的好处
- en: As we have said before, the major visible benefit of using Docker will be very
    fast performance and short provisioning time. You can create or destroy containers
    quickly and easily. Containers share resources such as the operating system's
    kernel and the needed libraries efficiently with other Docker containers. Because
    of that, multiple versions of an application running in containers will be very
    lightweight. The result is faster deployment, easier migration, and startup times.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，使用Docker的主要可见好处将是非常快的性能和短的配置时间。您可以快速轻松地创建或销毁容器。容器与其他Docker容器有效地共享操作系统的内核和所需的库等资源。因此，在容器中运行的应用程序的多个版本将非常轻量级。结果是更快的部署、更容易的迁移和启动时间。
- en: Docker can be especially useful when deploying Java microservices. We will get
    back to microservices in detail in one of the coming chapters. A microservices
    application is composed of a series of discrete services, communicating with others
    via an API. Microservices break an app into a large number of small processes.
    They are the opposite of the monolithic applications, which run all operations
    as a single process or a set of large processes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署Java微服务时，Docker尤其有用。我们将在接下来的章节中详细讨论微服务。微服务应用由一系列离散的服务组成，通过API与其他服务通信。微服务将应用程序分解为大量的小进程。它们与单体应用相反，单体应用将所有操作作为单个进程或一组大进程运行。
- en: 'Using Docker containers enables you to deploy ready-to-run software, which
    is portable and extremely easy to distribute. Your containerized application simply
    runs within its container; there''s no need for installation. The lack of an installation
    process has a huge advantage; it eliminates problems such as software and library
    conflicts or even driver compatibility issues. Docker containers are portable;
    they can be run from anywhere: your local machine, a remote server, and private
    or public cloud. All major cloud computing providers, such as **Amazon Web Services**
    (**AWS** ) and Google''s compute platform support Docker now. A container running
    on, let''s say, an Amazon EC2 instance, can easily be transferred to some other
    environment, achieving exactly the same consistency and functionality. The additional
    level of abstraction Docker provides on the top of your infrastructure layer is
    an indispensable feature. Developers can create the software without worrying
    about the platform it will later be run on. Docker has the same promise as Java;
    write once, run anywhere; except instead of code, you configure your server exactly
    the way you want it (by picking the operating system, tuning the configuration
    files, installing dependencies) and you can be certain that your server template
    will run exactly the same on any host that runs Docker.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker容器可以让您部署即插即用的软件，具有可移植性和极易分发的特点。您的容器化应用程序只需在其容器中运行；无需安装。无需安装过程具有巨大的优势；它消除了诸如软件和库冲突甚至驱动兼容性问题等问题。Docker容器是可移植的；它们可以从任何地方运行：您的本地机器、远程服务器以及私有或公共云。所有主要的云计算提供商，如亚马逊网络服务（AWS）和谷歌的计算平台现在都支持Docker。在亚马逊EC2实例上运行的容器可以轻松转移到其他环境，实现完全相同的一致性和功能。Docker在基础架构层之上提供的额外抽象层是一个不可或缺的特性。开发人员可以创建软件而不必担心它将在哪个平台上运行。Docker与Java有着相同的承诺；一次编写，到处运行；只是不是代码，而是配置您想要的服务器的方式（选择操作系统，调整配置文件，安装依赖项），您可以确信您的服务器模板将在运行Docker的任何主机上完全相同。
- en: Because of Docker's reproducible build environment, it's particularly well suited
    for testing, especially in your continuous integration or continuous delivery
    flow. You can quickly boot up identical environments to run the tests. And because
    the container images are all identical each time, you can distribute the workload
    and run tests in parallel without a problem. Developers can run the same image
    on their machine that will be run in production later, which again has a huge
    advantage in testing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker的可重复构建环境，它特别适用于测试，特别是在持续集成或持续交付流程中。您可以快速启动相同的环境来运行测试。而且由于容器镜像每次都是相同的，您可以分发工作负载并并行运行测试而不会出现问题。开发人员可以在他们的机器上运行与后来在生产中运行的相同的镜像，这在测试中又有巨大的优势。
- en: The use of Docker containers speeds up continuous integration. There are no
    more endless build-test-deploy cycles; Docker containers ensure that applications
    run identically in development, test, and production environments. The code grows
    over time and becomes more and more troublesome. That's why the idea of an immutable
    infrastructure becomes more and more popular nowadays and the concept of containerization
    has become so popular. By putting your Java applications into containers, you
    can simplify the process of deployment and scaling. By having a lightweight Docker
    host that needs almost no configuration management, you manage your applications
    simply by deploying and redeploying containers to the host. And again, because
    the containers are very lightweight, it takes only seconds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker容器可以加快持续集成的速度。不再有无休止的构建-测试-部署循环；Docker容器确保应用程序在开发、测试和生产环境中运行完全相同。随着时间的推移，代码变得越来越麻烦。这就是为什么不可变基础设施的概念如今变得越来越受欢迎，容器化的概念也变得如此流行。通过将Java应用程序放入容器中，您可以简化部署和扩展的过程。通过拥有一个几乎不需要配置管理的轻量级Docker主机，您可以通过部署和重新部署容器来简单地管理应用程序。而且，由于容器非常轻量级，所以只需要几秒钟。
- en: We have been talking a lot about images and containers, without getting much
    into the details. Let's do it now and see what Docker images and containers are.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在谈论镜像和容器，但没有深入了解细节。现在让我们来看看Docker镜像和容器是什么。
- en: Docker concepts - images and containers
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker概念-镜像和容器
- en: When dealing with Kubernetes, we will be working with Docker containers; it
    is an open source container cluster manager. To run our own Java application,
    we will need to create an image first. Let's begin with the concept of Docker
    images.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理Kubernetes时，我们将使用Docker容器；它是一个开源的容器集群管理器。要运行我们自己的Java应用程序，我们首先需要创建一个镜像。让我们从Docker镜像的概念开始。
- en: Images
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像
- en: 'Think of an image as a read-only template which is a base foundation to create
    a container from. It''s same as a recipe containing the definition of everything
    your application needs to operate. It can be Linux with an application server
    (such as Tomcat or Wildfly, for example) and your Java application itself. Every
    image starts from a base image; for example, Ubuntu; a Linux image. Although you
    can begin with a simple image and build your application stack on top of it, you
    can also pick an already prepared image from the hundreds available on the Internet.
    There are a lot of images especially useful for Java developers: `openjdk` , `tomcat`
    , `wildfly` , and many others. We will use them later as a foundation for our
    own images. It''s a lot easier to have, let''s say, Wildfly installed and configured
    properly as a starting point for your own image. You can then just focus on your
    Java application. If you''re a novice in building images, downloading a specialized
    base image is a great way to get a serious speed boost in comparison to developing
    one by yourself.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像视为只读模板，它是创建容器的基础。这就像一个包含应用程序运行所需的所有定义的食谱。它可以是带有应用服务器（例如Tomcat或Wildfly）和Java应用程序本身的Linux。每个图像都是从基本图像开始的；例如Ubuntu；一个Linux图像。虽然您可以从简单的图像开始，并在其上构建应用程序堆栈，但您也可以从互联网上提供的数百个图像中选择一个已经准备好的图像。有许多图像对于Java开发人员特别有用：`openjdk`，`tomcat`，`wildfly`等等。我们稍后将使用它们作为我们自己图像的基础。拥有，比如说，已经安装和配置正确的Wildfly作为您自己图像的起点要容易得多。然后您只需专注于您的Java应用程序。如果您是构建图像的新手，下载一个专门的基础图像是与自己开发相比获得严重速度提升的好方法。
- en: Images are created using a series of commands, called instructions. Instructions
    are placed in the Dockerfile. The Dockerfile is just a plain text file, containing
    an ordered collection of `root` filesystem changes (the same as running a command
    that starts an application server, adding a file or directory, creating environmental
    variables, and so on.) and the corresponding execution parameters for use within
    a container runtime later on. Docker will read the Dockerfile when you start the
    process of building an image and execute the instructions one by one. The result
    will be the final image. Each instruction creates a new layer in the image. That
    image layer then becomes the parent for the layer created by the next instruction.
    Docker images are highly portable across hosts and operating systems; an image
    can be run in a Docker container on any host that runs Docker. Docker is natively
    supported in Linux, but has to be run in a VM on Windows and macOS. It's important
    to know that Docker uses images to run your code, not the Dockerfile. The Dockerfile
    is used to create the image when you run the `docker build` command. Also, if
    you publish your image to the Docker Hub, you publish a resulting image with its
    layers, not a source Dockerfile itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图像是使用一系列命令创建的，称为指令。指令被放置在Dockerfile中。Dockerfile只是一个普通的文本文件，包含一个有序的`root`文件系统更改的集合（与运行启动应用程序服务器的命令相同，添加文件或目录，创建环境变量等），以及稍后在容器运行时使用的相应执行参数。当您开始构建图像的过程时，Docker将读取Dockerfile并逐个执行指令。结果将是最终图像。每个指令在图像中创建一个新的层。然后该图像层成为下一个指令创建的层的父层。Docker图像在主机和操作系统之间具有高度的可移植性；可以在运行Docker的任何主机上的Docker容器中运行图像。Docker在Linux中具有本地支持，但在Windows和macOS上必须在虚拟机中运行。重要的是要知道，Docker使用图像来运行您的代码，而不是Dockerfile。Dockerfile用于在运行`docker
    build`命令时创建图像。此外，如果您将图像发布到Docker Hub，您将发布一个带有其层的结果图像，而不是源Dockerfile本身。
- en: We have said before that every instruction in a Dockerfile creates a new layer.
    Layers are the internal nature of an image; Docker images are composed from them.
    Let's explain now what they are and what their characteristics are.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，Dockerfile中的每个指令都会创建一个新的层。层是图像的内在特性；Docker图像是由它们组成的。现在让我们解释一下它们是什么，以及它们的特点是什么。
- en: Layers
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 层
- en: 'Each image consists of a series of layers which are stacked, one on top of
    the another. In fact, every layer is an intermediate image. By using the **union
    filesystem** , Docker combines all these layers into a single image entity. The
    union filesystem allows transparent overlaying files and directories of separate
    filesystems, giving a single, consistent filesystem as a result, as you can see
    the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图像由一系列堆叠在一起的层组成。实际上，每一层都是一个中间图像。通过使用**联合文件系统**，Docker将所有这些层组合成单个图像实体。联合文件系统允许透明地覆盖单独文件系统的文件和目录，从而产生一个统一的文件系统，如下图所示：
- en: '![](Image00004.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00004.jpg)'
- en: 'Contents and structure of directories which have the same path within these
    separate filesystems will be seen together in a single merged directory, within
    the new, virtual-like filesystem. In other words, the filesystem structure of
    the top layer will merge with the structure of the layer beneath. Files and directories
    which have the same path as in the previous layer will cover those beneath. Removing
    the upper layer will again reveal and expose the previous directory content. As
    we have mentioned earlier, layers are placed in a stack, one on the top of another.
    To maintain the order of layers, Docker utilizes the concept of layer IDs and
    pointers. Each layer contains the ID and a pointer to its parent layer. A layer
    without a pointer referencing the parent is the first layer in the stack, a base.
    You can see the relation in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同路径的目录的内容和结构在这些单独的文件系统中将在一个合并的目录中一起显示，在新的虚拟文件系统中。换句话说，顶层的文件系统结构将与下面的层的结构合并。具有与上一层相同路径的文件和目录将覆盖下面的文件和目录。删除上层将再次显示和暴露出先前的目录内容。正如我们之前提到的，层被堆叠放置，一层叠在另一层之上。为了保持层的顺序，Docker利用了层ID和指针的概念。每个层包含ID和指向其父层的指针。没有指向父层的指针的层是堆栈中的第一层，即基础层。您可以在下图中看到这种关系：
- en: '![](Image00005.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00005.jpg)'
- en: 'Layers have some interesting features. First, they are reusable and cacheable.
    The pointer to a parent layer you can see in the previous diagram is important.
    As Docker is processing your Dockerfile it''s looking at two things: the Dockerfile
    instruction being executed and the parent image. Docker will scan all of the children
    of the parent layer and look for one whose command matches the current instruction.
    If a match is found, Docker skips to the next Dockerfile instruction and repeats
    the process. If a matching layer is not found in the cache, a new one is created.
    For the instructions that add files to your image (we will get to know them later
    in detail), Docker creates a checksum for each file contents. During the building
    process, this checksum is compared against the checksum of the existing images
    to check if the layer can be reused from the cache. If two different images have
    a common part, let''s say a Linux shell or Java runtime for example, Docker, which
    tracks all of the pulled layers, will reuse the shell layer in both of the images.
    It''s a safe operation; as you already know, layers are read-only. When downloading
    another image, the layer will be reused and only the difference will be pulled
    from the Docker Hub. This saves time, bandwidth, and disk space of course, but
    it has another great advantage. If you modify your Docker image, for example by
    modifying your containerized Java application, only the application layer gets
    modified. After you''ve successfully built an image from your Dockerfile, you
    will notice that subsequent builds of the same Dockerfile finish a lot faster.
    Once Docker caches an image layer for an instruction, it doesn''t need to be rebuilt.
    Later on, instead of distributing the whole image, you push just the updated part.
    It makes the process simpler and faster. This is especially useful if you use
    Docker in your continuous deployment flow: pushing a Git branch will trigger building
    an image and then publishing the application for users. Due to the layer-reuse
    feature, the whole process is a lot faster.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图层具有一些有趣的特性。首先，它们是可重用和可缓存的。你可以在前面的图表中看到指向父图层的指针是很重要的。当Docker处理Dockerfile时，它会查看两件事：正在执行的Dockerfile指令和父映像。Docker将扫描父图层的所有子图层，并寻找其命令与当前指令匹配的图层。如果找到匹配的图层，Docker将跳过下一个Dockerfile指令并重复该过程。如果在缓存中找不到匹配的图层，则会创建一个新的图层。对于向图像添加文件的指令（我们稍后将详细了解它们），Docker为每个文件内容创建一个校验和。在构建过程中，将此校验和与现有图像的校验和进行比较，以检查是否可以从缓存中重用该图层。如果两个不同的图像有一个共同的部分，比如Linux
    shell或Java运行时，Docker将在这两个图像中重用shell图层，Docker跟踪所有已拉取的图层，这是一个安全的操作；正如你已经知道的，图层是只读的。当下载另一个图像时，将重用该图层，只有差异将从Docker
    Hub中拉取。这当然节省了时间、带宽和磁盘空间，但它还有另一个巨大的优势。如果修改了Docker图像，例如通过修改容器化的Java应用程序，只有应用程序图层会被修改。当你成功从Dockerfile构建了一个图像后，你会注意到同一Dockerfile的后续构建会快得多。一旦Docker为一条指令缓存了一个图像图层，它就不需要重新构建。后来，你只需推送更新的部分，而不是整个图像。这使得流程更简单、更快速。如果你在持续部署流程中使用Docker，这将特别有用：推送一个Git分支将触发构建一个图像，然后发布应用程序给用户。由于图层重用的特性，整个流程会快得多。
- en: 'The concept of reusable layers is also a reason why Docker is so lightweight
    in comparison to full virtual machines, which don''t share anything. It is thanks
    to layers that when you pull an image, you eventually don''t have to download
    all of its filesystem. If you already have another image that has some of the
    layers of the image you pull, only the missing layers are actually downloaded.
    There is a word of warning though, related to another feature of layers: apart
    from being reusable, layers are also additive. If you create a large file in the
    container, then make a commit (we will get to that in a while), then delete the
    file, and do another commit; this file will still be present in the layer history.
    Imagine this scenario: you pull the base Ubuntu image, and install the Wildfly
    application server. Then you change your mind, uninstall the Wildfly and install
    Tomcat instead. All those files removed from the Wildfly installation will still
    be present in the image, although they have been deleted. Image size will grow
    in no time. Understanding of Docker''s layered filesystem can make a big difference
    in the size of your images. Size can become a problem when you publish your images
    to a registry; it takes more requests and is longer to transfer.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用层的概念也是Docker比完整虚拟机轻量的原因之一，虚拟机不共享任何内容。多亏了层，当你拉取一个图像时，最终你不必下载其整个文件系统。如果你已经有另一个图像包含了你拉取的图像的一些层，那么只有缺失的层会被实际下载。不过，需要注意的是，层的另一个特性：除了可重用，层也是可加的。如果在容器中创建了一个大文件，然后进行提交（我们稍后会讲到），然后删除该文件，再进行另一个提交；这个文件仍然会存在于层历史中。想象一下这种情况：你拉取了基础的Ubuntu图像，并安装了Wildfly应用服务器。然后你改变主意，卸载了Wildfly并安装了Tomcat。所有从Wildfly安装中删除的文件仍然会存在于图像中，尽管它们已经被删除。图像大小会迅速增长。理解Docker的分层文件系统可以在图像大小上产生很大的差异。当你将图像发布到注册表时，大小可能会成为一个问题；它需要更多的请求和更长的传输时间。
- en: Large images become an issue when thousands of containers need to be deployed
    across a cluster, for example. You should always be aware of the additivity of
    layers and try to optimize the image at every step of your Dockerfile, the same
    as using the command chaining, for example. We will be using the command chaining
    technique later on, when creating our Java application images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在集群中部署数千个容器时，大型图像就会成为一个问题。例如，你应该始终意识到层的可加性，并尝试在Dockerfile的每一步优化图像，就像使用命令链接一样。在创建Java应用程序图像时，我们将使用命令链接技术。
- en: 'Because layers are additive, they provide a full history of how a specific
    image was built. This gives you another great feature: the possibility to make
    a rollback to a certain point in the image''s history. Since every image contains
    all of its building steps, we can easily go back to a previous step if we want
    to. This can be done by tagging a certain layer. We will cover image tagging later
    in our book.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因为层是可加的，它们提供了特定图像是如何构建的完整历史记录。这给了你另一个很棒的功能：可以回滚到图像历史中的某个特定点。由于每个图像包含了所有构建步骤，我们可以很容易地回到以前的步骤。这可以通过给某个层打标签来实现。我们将在本书的后面介绍图像标记。
- en: Layers and images are closely related to each other. As we have said before,
    Docker images are stored as a series of read-only layers. This means that once
    the container image has been created, it does not change. But having all the filesystem
    read-only would not make a lot of sense. What about modifying an image? Or adding
    your software to a base web server image? Well, when we start a container, Docker
    actually takes the read-only image (with all its read-only layers) and adds a
    writable layer on top of the layers stack. Let's focus on the containers now.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 层和镜像是密切相关的。正如我们之前所说，Docker镜像被存储为一系列只读层。这意味着一旦容器镜像被创建，它就不会改变。但是，如果整个文件系统都是只读的，这就没有太多意义了。那么如何修改一个镜像？或者将您的软件添加到基本Web服务器镜像中？嗯，当我们启动一个容器时，Docker实际上会取出只读镜像（以及所有只读层），并在层堆栈顶部添加一个可写层。现在让我们专注于容器。
- en: Containers
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: A running instance of an image is called a container. Docker launches them using
    the Docker images as read-only templates. If you start an image, you have a running
    container of this image. Naturally, you can have many running containers of the
    same image. In fact, we will do it very often a little bit later, using Kubernetes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的运行实例称为容器。Docker使用Docker镜像作为只读模板来启动它们。如果您启动一个镜像，您将得到这个镜像的一个运行中的容器。当然，您可以有许多相同镜像的运行容器。实际上，我们将经常使用Kubernetes稍后做这件事。
- en: 'To run a container, we use the `docker run` command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行一个容器，我们使用`docker run`命令：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There are a lot of `run` command options and switches that can be used; we will
    get to know them later on. Some of the options include the network configuration,
    for example (we will explain Docker's networking concepts in [Chapter 2](text00037.html)
    , *Networking and Persistent Storage* ). Others, the same as the `-it` (from interactive),
    tell the Docker engine to behave differently; in this case, to make the container
    interactive and to attach a terminal to its output and input. Let's just focus
    on the idea of the container to better understand the whole picture. We are going
    to use the `docker run` command in a short while to test our setup.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多可以使用的`run`命令选项和开关；我们稍后会了解它们。一些选项包括网络配置，例如（我们将在[第2章](text00037.html) *Networking
    and Persistent Storage*中解释Docker的网络概念）。其他选项，比如`-it`（来自交互式），告诉Docker引擎以不同的方式运行；在这种情况下，使容器变得交互，并附加一个终端到其输出和输入。让我们专注于容器的概念，以更好地理解整个情况。我们将很快使用`docker
    run`命令来测试我们的设置。
- en: 'So, what happens under the hood when we run the `docker run` command? Docker
    will check if the image that you would like to run is available on your local
    machine. If not, it will be pulled down from the `remote` repository. The Docker
    engine takes the image and adds a writable layer on top of the image''s layers
    stack. Next, it initializes the image''s name, ID, and resource limits, such as
    CPU and memory. In this phase, Docker will also set up a container''s IP address
    by finding and attaching an available IP address from a pool. The last step of
    the execution will be the actual command, passed as the last parameter of the
    `docker run` command. If the `it` option has been used, Docker will capture and
    provide the container output, it will be displayed in the console. You can now
    do things you would normally do when preparing an operating system to run your
    applications. This can be installing packages (via `apt-get` , for example), pulling
    source code with Git, building your Java application using Maven, and so on. All
    of these actions will modify the filesystem in the top, writable layer. If you
    then execute the `commit` command, a new image containing all of your changes
    will be created, kind of frozen, and ready to be run later. To stop a container,
    use the `docker stop` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们运行`docker run`命令时，在幕后会发生什么呢？Docker将检查您想要运行的镜像是否在本地计算机上可用。如果没有，它将从“远程”存储库中拉取下来。Docker引擎会获取镜像并在镜像的层堆栈顶部添加一个可写层。接下来，它会初始化镜像的名称、ID和资源限制，如CPU和内存。在这个阶段，Docker还将通过从池中找到并附加一个可用的IP地址来设置容器的IP地址。执行的最后一步将是实际的命令，作为`docker
    run`命令的最后一个参数传递。如果使用了`it`选项，Docker将捕获并提供容器输出，它将显示在控制台上。现在，您可以做一些通常在准备操作系统运行应用程序时会做的事情。这可以是安装软件包（例如通过`apt-get`），使用Git拉取源代码，使用Maven构建您的Java应用程序等。所有这些操作都将修改顶部可写层中的文件系统。然后，如果执行`commit`命令，将创建一个包含所有更改的新镜像，类似于冻结，并准备随后运行。要停止容器，请使用`docker
    stop`命令：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A container when stopped will retain all settings and filesystem changes (in
    the top layer that is writeable). All processes running in the container will
    be stopped and you will lose everything in memory. This is what differentiates
    a stopped container from a Docker image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 停止容器时，将保留所有设置和文件系统更改（在可写的顶层）。在容器中运行的所有进程都将停止，并且内存中的所有内容都将丢失。这就是停止容器与Docker镜像的区别。
- en: 'To list all containers you have on your system, either running or stopped,
    execute the `docker ps` command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出系统上所有容器，无论是运行还是停止的，执行`docker ps`命令：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As a result, the Docker client will list a table containing container IDs (a
    unique identifier you can use to refer to the container in other commands), creation
    date, the command used to start a container, status, exposed ports, and a name,
    either assigned by you or the funny name Docker has picked for you. To remove
    a container, you can just use the `docker rm` command. If you want to remove a
    couple of them at once, you can use the list of containers (given by the `docker
    ps` command) and a filter:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，Docker客户端将列出一个包含容器ID（您可以用来在其他命令中引用容器的唯一标识符）、创建日期、用于启动容器的命令、状态、暴露端口和名称的表格，可以是您分配的名称，也可以是Docker为您选择的有趣的名称。要删除容器，只需使用`docker
    rm`命令。如果要一次删除多个容器，可以使用容器列表（由`docker ps`命令给出）和一个过滤器：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have said that a Docker image is always read-only and immutable. If it did
    not have the possibility to change the image, it would not be very useful. So
    how''s the image modification possible except by, of course, altering a Dockerfile
    and doing a rebuild? When the container is started, the writable layer on top
    of the layers stack is for our disposal. We can actually make changes to a running
    container; this can be adding or modifying files, the same as installing a software
    package, configuring the operating system, and so on. If you modify a file in
    the running container, the file will be taken out of the underlying (parent) read-only
    layer and placed in the top, writable layer. Our changes are only possible in
    the top layer. The union filesystem will then cover the underlying file. The original,
    underlying file will not be modified; it still exists safely in the underlying,
    read-only layer. By issuing the `docker commit` command, you create a new read-only
    image from a running container (and all it changes in the writable layer):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，Docker图像始终是只读且不可变的。如果它没有改变图像的可能性，那么它就不会很有用。那么除了通过修改Dockerfile并进行重建之外，图像修改如何可能呢？当容器启动时，层堆栈顶部的可写层就可以使用了。我们实际上可以对运行中的容器进行更改；这可以是添加或修改文件，就像安装软件包、配置操作系统等一样。如果在运行的容器中修改文件，则该文件将从底层（父级）只读层中取出，并放置在顶部的可写层中。我们的更改只可能存在于顶层。联合文件系统将覆盖底层文件。原始的底层文件不会被修改；它仍然安全地存在于底层的只读层中。通过发出`docker
    commit`命令，您可以从运行中的容器（以及可写层中的所有更改）创建一个新的只读图像。
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `docker commit` command saves changes you have made to the container in
    the writable layer. To avoid data corruption or inconsistency, Docker will pause
    a container you are committing changes into. The result of the `docker commit`
    command is a brand new, read-only image, which you can create new containers from:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker commit`命令会将您对容器所做的更改保存在可写层中。为了避免数据损坏或不一致，Docker将暂停您要提交更改的容器。`docker
    commit`命令的结果是一个全新的只读图像，您可以从中创建新的容器：'
- en: '![](Image00006.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00006.jpg)'
- en: In response to a successful commit, Docker will output the full ID of a newly
    generated image. If you remove the container without issuing a `commit` first
    and then relaunch the same image again, Docker will start a fresh container without
    any of the changes made in the previously running container. In either case, with
    or without a `commit` , your changes to the filesystem will never affect the base
    image. Creating images by altering the top writable layer in the container is
    useful when debugging and experimenting, but it's usually better to use a Dockerfile
    to manage your images in a documented and maintainable way.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对成功提交的回应，Docker将输出新生成图像的完整ID。如果您在没有首先发出`commit`的情况下删除容器，然后再次启动相同的图像，Docker将启动一个全新的容器，而不会保留先前运行容器中所做的任何更改。无论哪种情况，无论是否有`commit`，对文件系统的更改都不会影响基本图像。通过更改容器中的顶部可写层来创建图像在调试和实验时很有用，但通常最好使用Dockerfile以文档化和可维护的方式管理图像。
- en: We have now learned about the build (Dockerfile and the image) and runtime (container)
    pieces of our containerization world. We are still missing the last element, the
    distribution component. The distribution component of Docker consists of the Docker
    registry, index, and repository. Let's focus on them now to have a complete picture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了容器化世界中构建（Dockerfile和图像）和运行时（容器）部分。我们还缺少最后一个元素，即分发组件。Docker的分发组件包括Docker注册表、索引和存储库。现在让我们专注于它们，以便有一个完整的图片。
- en: Docker registry, repository, and index
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker注册表、存储库和索引
- en: 'The first component in Docker''s distribution system is the registry. Docker
    utilizes a hierarchical system for storing images, shown in the following screenshot:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Docker分发系统中的第一个组件是注册表。Docker利用分层系统存储图像，如下面的屏幕截图所示：
- en: '![](Image00007.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00007.jpg)'
- en: Images which you build can be stored in a `remote` registry for others to use.
    The `Docker` registry is a service (an application, in fact) that is storing your
    Docker images. The Docker Hub is an example of the publicly available registry;
    it's free and serves a huge, constantly growing collection of existing images.
    The repository, on the other hand, is a collection (namespace) of related images,
    usually providing different versions of the same application or service. It's
    a collection of different Docker images with the same name and different tags.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您构建的图像可以存储在`远程`注册表中供他人使用。`Docker`注册表是一个存储Docker图像的服务（实际上是一个应用程序）。Docker Hub是公开可用注册表的一个例子；它是免费的，并提供不断增长的现有图像的庞大集合。而存储库则是相关图像的集合（命名空间），通常提供相同应用程序或服务的不同版本。它是具有相同名称和不同标记的不同Docker图像的集合。
- en: 'If your app is named `hello-world-java` and your username (or namespace) for
    the Registry is `dockerJavaDeveloper` then your image will be placed in the `dockerJavaDeveloper/hello-world-java`
    repository. You can tag an image and store multiple versions of that image with
    different IDs in a single named repository and access different tagged versions
    of an image with a special syntax such as `username/image_name:tag` . The `Docker`
    repository is quite similar to a Git repository. For example, `Git` , a `Docker`
    repository is identified by a URI and can either be public or private. The URI
    looks the same as the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序命名为`hello-world-java`，并且您的注册表的用户名（或命名空间）为`dockerJavaDeveloper`，那么您的图像将放在`dockerJavaDeveloper/hello-world-java`存储库中。您可以给图像打标签，并在单个命名存储库中存储具有不同ID的多个版本的图像，并使用特殊语法访问图像的不同标记版本，例如`username/image_name:tag`。`Docker`存储库与Git存储库非常相似。例如，`Git`，`Docker`存储库由URI标识，并且可以是公共的或私有的。URI看起来与以下内容相同：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The Docker Hub is the default registry and Docker will pull images from the
    Docker Hub if you do not specify a registry address. To search an image in the
    registry, execute the `docker search` command; for example:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub是默认注册表，如果不指定注册表地址，Docker将从Docker Hub拉取图像。要在注册表中搜索图像，请执行`docker search`命令；例如：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Without specifying the `remote` registry, Docker will conduct a search on the
    Docker Hub and output the list of images matching your search criteria:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不指定`远程`注册表，Docker将在Docker Hub上进行搜索，并输出与您的搜索条件匹配的图像列表：
- en: '![](Image00008.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00008.jpg)'
- en: 'The difference between the registry and repository can be confusing at the
    beginning, so let''s describe what will happen if you execute the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表和存储库之间的区别可能在开始时令人困惑，因此让我们描述一下如果执行以下命令会发生什么：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The command downloads the image tagged `16.04` within the `ubuntu` repository
    from the Docker Hub registry. The official `ubuntu` repository doesn't use a username,
    so the namespace part is omitted in this example.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令从Docker Hub注册表中的`ubuntu`存储库中下载标记为`16.04`的镜像。官方的`ubuntu`存储库不使用用户名，因此在这个例子中省略了命名空间部分。
- en: Although the Docker Hub is public, you get one private repository for free with
    your Docker Hub user account. Last, but not least, the component you should be
    aware of is an index. An index manages searching and tagging and also user accounts
    and permissions. In fact, the registry delegates authentication to the index.
    When executing remote commands, such as `push` or `pull` , the index first will
    look at the name of the image and then check to see if it has a corresponding
    repository. If so, the index verifies if you are allowed to access or modify the
    image. If you are, the operation is approved and the registry takes or sends the
    image.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker Hub是公开的，但您可以通过Docker Hub用户帐户免费获得一个私有仓库。最后，但并非最不重要的是，您应该了解的组件是索引。索引管理搜索和标记，还管理用户帐户和权限。实际上，注册表将身份验证委托给索引。在执行远程命令，如“推送”或“拉取”时，索引首先会查看图像的名称，然后检查是否有相应的仓库。如果有，索引会验证您是否被允许访问或修改图像。如果允许，操作将获得批准，注册表将获取或发送图像。
- en: 'Let''s summarize what we have learned so far:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们到目前为止学到的东西：
- en: The Dockerfile is the recipe to build an image. It's a text file containing
    ordered instructions. Each Dockerfile has a base image you build upon
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile是构建图像的配方。它是一个包含有序指令的文本文件。每个Dockerfile都有一个基本图像，您可以在其上构建
- en: 'An image is a specific state of a filesystem: a read-only, frozen immutable
    snapshot of a live container'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像是文件系统的特定状态：一个只读的、冻结的不可变的快照
- en: An image is composed of layers representing changes in the filesystem at various
    points in time; layers are a bit same as the commit history of a Git repository.
    Docker uses the layers cache
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像由代表文件系统在不同时间点的更改的层组成；层与Git仓库的提交历史有些相似。Docker使用层缓存
- en: Containers are runtime instances of an image. They can be running or stopped.
    You can have multiple containers of the same image running
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是图像的运行时实例。它们可以运行或停止。您可以运行多个相同图像的容器
- en: You can make changes to the filesystem on a container and commit them to make
    them persisted. Commit always creates a new image
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以对容器上的文件系统进行更改并提交以使其持久化。提交总是会创建一个新的图像
- en: Only the filesystem changes can be committed, memory changes will be lost
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有文件系统更改可以提交，内存更改将丢失
- en: 'A registry holds a collection of named repositories, which themselves are a
    collection of images tracked by their IDs. The registry is same as a Git repository:
    you can `push` and `pull` images'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表保存了一系列命名的仓库，这些仓库本身是由它们的ID跟踪的图像的集合。注册表与Git仓库相同：您可以“推送”和“拉取”图像
- en: You should now have an understanding of the nature of images with their layers
    and containers. But Docker is not just a Dockerfile processor and the runtime
    engine. Let's look at what else is available.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该对具有层和容器的图像的性质有所了解。但Docker不仅仅是一个Dockerfile处理器和运行时引擎。让我们看看还有什么其他可用的东西。
- en: Additional tools
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加工具
- en: It's a complete package with a wide selection of tools and APIs that are helpful
    during the developer's and DevOp's daily work. There's a Kinematic, for example,
    a desktop developer environment for using Docker on Windows and macOS X.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完整的软件包，其中包含了许多有用的工具和API，可以帮助开发人员和DevOp在日常工作中使用。例如，有一个Kinematic，它是一个用于在Windows和macOS
    X上使用Docker的桌面开发环境。
- en: From a Java developer's perspective, there are tools available, which are especially
    useful in a programmer's daily job, such as the IntelliJ IDEA Docker integration
    plugin (we will be using this add-on heavily in the coming chapters). Eclipse
    fans can use the Docker tooling for Eclipse, which is available starting with
    Eclipse Mars. NetBeans also supports Docker commands. No matter which development
    environment you pick, these add-ons let you download and build Docker images,
    create and start containers, and carry out other related tasks straight from your
    favorite IDE.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java开发者的角度来看，有一些工具特别适用于程序员日常工作，比如IntelliJ IDEA的Docker集成插件（我们将在接下来的章节中大量使用这个插件）。Eclipse的粉丝可以使用Eclipse的Docker工具，该工具从Eclipse
    Mars版本开始可用。NetBeans也支持Docker命令。无论您选择哪种开发环境，这些插件都可以让您从您喜爱的IDE直接下载和构建Docker镜像，创建和启动容器，以及执行其他相关任务。
- en: Docker is so popular these days, no wonder hundreds of third-party tools have
    been developed to make Docker even more useful. The most prominent of them is
    Kubernetes, which we are going to focus on in this book. But apart from Kubernetes,
    there are many others. They will support you with Docker-related operations, such
    as continuous integration/continuous delivery, deployment and infrastructure,
    or optimizing images. Tens of hosting services now support running and managing
    Docker containers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Docker如今非常流行，难怪会有数百种第三方工具被开发出来，以使Docker变得更加有用。其中最突出的是Kubernetes，这是我们在本书中将要重点关注的。但除了Kubernetes，还有许多其他工具。它们将支持您进行与Docker相关的操作，如持续集成/持续交付、部署和基础设施，或者优化镜像。数十个托管服务现在支持运行和管理Docker容器。
- en: As Docker captures more attention, more and more Docker-related tools pop-up
    almost every month. You can find a very well-crafted list of Docker-related tools
    and services on the GitHub awesome Docker list, available at [h](https://github.com/veggiemonk/awesome-docker)
    [t](https://github.com/veggiemonk/awesome-docker) [t](https://github.com/veggiemonk/awesome-docker)
    [p](https://github.com/veggiemonk/awesome-docker) [s](https://github.com/veggiemonk/awesome-docker)
    [://g](https://github.com/veggiemonk/awesome-docker) [i](https://github.com/veggiemonk/awesome-docker)
    [t](https://github.com/veggiemonk/awesome-docker) [h](https://github.com/veggiemonk/awesome-docker)
    [u](https://github.com/veggiemonk/awesome-docker) [b](https://github.com/veggiemonk/awesome-docker)
    [.](https://github.com/veggiemonk/awesome-docker) [c](https://github.com/veggiemonk/awesome-docker)
    [o](https://github.com/veggiemonk/awesome-docker) [m](https://github.com/veggiemonk/awesome-docker)
    [/v](https://github.com/veggiemonk/awesome-docker) [e](https://github.com/veggiemonk/awesome-docker)
    [g](https://github.com/veggiemonk/awesome-docker) [g](https://github.com/veggiemonk/awesome-docker)
    [i](https://github.com/veggiemonk/awesome-docker) [e](https://github.com/veggiemonk/awesome-docker)
    [m](https://github.com/veggiemonk/awesome-docker) [o](https://github.com/veggiemonk/awesome-docker)
    [n](https://github.com/veggiemonk/awesome-docker) [k](https://github.com/veggiemonk/awesome-docker)
    [/a](https://github.com/veggiemonk/awesome-docker) [w](https://github.com/veggiemonk/awesome-docker)
    [e](https://github.com/veggiemonk/awesome-docker) [s](https://github.com/veggiemonk/awesome-docker)
    [o](https://github.com/veggiemonk/awesome-docker) [m](https://github.com/veggiemonk/awesome-docker)
    [e](https://github.com/veggiemonk/awesome-docker) [-](https://github.com/veggiemonk/awesome-docker)
    [d](https://github.com/veggiemonk/awesome-docker) [o](https://github.com/veggiemonk/awesome-docker)
    [c](https://github.com/veggiemonk/awesome-docker) [k](https://github.com/veggiemonk/awesome-docker)
    [e](https://github.com/veggiemonk/awesome-docker) [r](https://github.com/veggiemonk/awesome-docker)
    .
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Docker越来越受到关注，几乎每个月都会涌现出更多与Docker相关的工具。您可以在GitHub的awesome Docker列表上找到一个非常精心制作的Docker相关工具和服务列表，网址为https://github.com/veggiemonk/awesome-docker。
- en: But there are not only tools available. Additionally, Docker provides a set
    of APIs that can be very handy. One of them is the Remote API for the management
    of the images and containers. Using this API, you will be able to distribute your
    images to the runtime Docker engine. There's also the Stats API that will expose
    live resource usage information (such as CPU, memory, network I/O, and block I/O)
    for your containers. This API endpoint can be used create tools that show how
    your containers behave; for example, on a production system.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅有可用的工具。此外，Docker提供了一组非常方便的API。其中之一是用于管理图像和容器的远程API。使用此API，您将能够将图像分发到运行时Docker引擎。还有统计API，它将公开容器的实时资源使用信息（如CPU、内存、网络I/O和块I/O）。此API端点可用于创建显示容器行为的工具；例如，在生产系统上。
- en: As we now know the idea behind Docker, the differences between virtualization
    and containerization, and the benefits of using Docker, let's get to the action.
    We are going to install Docker first.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了Docker背后的理念，虚拟化和容器化之间的区别，以及使用Docker的好处，让我们开始行动吧。我们将首先安装Docker。
- en: Installing Docker
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: In this section, we will find out how to install Docker on Windows, macOS, and
    Linux operating systems. Next, we will run a sample `hello-world` image to verify
    the setup and check if everything works fine after the installation process.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何在Windows、macOS和Linux操作系统上安装Docker。接下来，我们将运行一个示例`hello-world`图像来验证设置，并在安装过程后检查一切是否正常运行。
- en: Docker installation is quite straightforward, but there are some things you
    will need to focus on to make it run smoothly. We will point them out to make
    the installation process painless. You should know that Linux is the natural environment
    for Docker. If you run the container, it will run on a Linux kernel. If you run
    your container on Docker running on Linux, it will use the kernel of your own
    machine. This is not the case in macOS and Windows; that's the reason why the
    Linux kernel needs to be virtualized if you want to run a Docker container on
    these operating systems. The Docker engine, when running on macOS or MS Windows,
    will use the lightweight Linux distribution, made specifically to run Docker containers.
    It runs completely from RAM, using only several megabytes, and boots in a couple
    of seconds. After the installation of the main Docker package on macOS and Windows,
    the OS built-in virtualization engine will be used by default. Therefore, there
    are some special requirements for your machine. For the newest, native Docker
    setup, which is deeply integrated into native virtualization engines present in
    your operating system, you will need to have 64-bit Windows 10 professional or
    enterprise. For macOS, the newest Docker for Mac is a native Mac application developed
    from scratch, with a native user interface, integrated with OS X native virtualization,
    hypervisor framework, networking, and filesystem. The mandatory requirement will
    be Yosemite 10.10.3 or newer. Let's begin with installing on macOS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的安装非常简单，但有一些事情需要注意，以使其顺利运行。我们将指出这些问题，以使安装过程变得轻松。您应该知道，Linux是Docker的自然环境。如果您运行容器，它将在Linux内核上运行。如果您在运行Linux上的Docker上运行容器，它将使用您自己机器的内核。这在macOS和Windows上并非如此；这就是为什么如果您想在这些操作系统上运行Docker容器，就需要虚拟化Linux内核的原因。当Docker引擎在macOS或MS
    Windows上运行时，它将使用轻量级的Linux发行版，专门用于运行Docker容器。它完全运行于RAM中，仅使用几兆字节，并在几秒钟内启动。在macOS和Windows上安装了主要的Docker软件包后，默认情况下将使用操作系统内置的虚拟化引擎。因此，您的机器有一些特殊要求。对于最新的本地Docker设置，它深度集成到操作系统中的本地虚拟化引擎中，您需要拥有64位的Windows
    10专业版或企业版。对于macOS，最新的Docker for Mac是一个全新开发的本地Mac应用程序，具有本地用户界面，集成了OS X本地虚拟化、hypervisor框架、网络和文件系统。强制要求是Yosemite
    10.10.3或更新版本。让我们从在macOS上安装开始。
- en: Installing on macOS
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在macOS上安装
- en: 'To get the native Docker version for your Mac, head to the [h](http://www.docker.com)
    [t](http://www.docker.com) [t](http://www.docker.com) [p](http://www.docker.com)
    [://w](http://www.docker.com) [w](http://www.docker.com) [w](http://www.docker.com)
    [.](http://www.docker.com) [d](http://www.docker.com) [o](http://www.docker.com)
    [c](http://www.docker.com) [k](http://www.docker.com) [e](http://www.docker.com)
    [r](http://www.docker.com) [.](http://www.docker.com) [c](http://www.docker.com)
    [o](http://www.docker.com) [m](http://www.docker.com) and then the Get Docker
    macOS section. Docker for Mac is a standard, native `dmg` package you can mount.
    You will find just a single application inside the package:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Mac的本地Docker版本，请转到[h](http://www.docker.com) [t](http://www.docker.com) [t](http://www.docker.com)
    [p](http://www.docker.com) [://w](http://www.docker.com) [w](http://www.docker.com)
    [w](http://www.docker.com) [.](http://www.docker.com) [d](http://www.docker.com)
    [o](http://www.docker.com) [c](http://www.docker.com) [k](http://www.docker.com)
    [e](http://www.docker.com) [r](http://www.docker.com) [.](http://www.docker.com)
    [c](http://www.docker.com) [o](http://www.docker.com) [m](http://www.docker.com)，然后转到获取Docker
    macOS部分。Docker for Mac是一个标准的本地`dmg`软件包，您可以挂载。您将在软件包中找到一个单一的应用程序：
- en: '![](Image00009.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00009.jpg)'
- en: 'Now just move the `Docker.app` into your `Applications` folder, and you are
    all set. Couldn''t be easier. If you run Docker, it will sit as a small whale
    icon in your macOS menu. The icon will animate during the Docker startup process
    and stabilize after it finishes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需将`Docker.app`移动到您的`Applications`文件夹中，就可以了。再也没有更简单的了。如果您运行Docker，它将作为macOS菜单中的一个小鲸鱼图标。该图标将在Docker启动过程中进行动画显示，并在完成后稳定下来：
- en: 'If you now click the icon , it will give you a handy menu with the Docker status
    and some additional options:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您现在点击图标，它将为您提供一个方便的菜单，其中包含Docker状态和一些附加选项：
- en: '![](Image00010.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00010.jpg)'
- en: 'Docker for Mac has an auto-update capability, which is great for keeping your
    installation up to date. The first Preferences... pane gives you the possibility
    to automatically check for updates; it''s marked by default:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker for Mac具有自动更新功能，这对于保持安装程序最新非常有用。首选项...窗格为您提供了自动检查更新的可能性；它默认标记为：
- en: '![](Image00011.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00011.jpg)'
- en: 'If you are a brave soul, you can also switch to the beta channel for getting
    updates. This way you can always have the latest and greatest Docker features,
    with the risk of decreased stability, as is always the case with beta software.
    Also take note that switching to the beta channel will uninstall your current
    stable version of Docker and destroy all of your settings and containers. Docker
    will warn you about this, to make sure you really want to do it:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您是一个勇敢的人，您还可以切换到beta频道以获取更新。这样，您就可以始终拥有最新和最棒的Docker功能，但也会面临稳定性降低的风险，就像使用beta软件一样。还要注意，切换到beta频道将卸载当前稳定版本的Docker并销毁所有设置和容器。Docker会警告您，以确保您真的想这样做：
- en: '![](Image00012.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00012.jpg)'
- en: 'The File Sharing pane of the Preferences ... will give you an option to mark
    macOS directories on your machine to be bind mounted into Docker containers you
    are going to run later. We will explain mounting directories in detail later on
    in the book. For the time being, let''s just have the default set of selected
    directories:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首选项...的文件共享窗格将为您提供一个选项，可以将您的macOS目录标记为将来要运行的Docker容器中的绑定挂载。我们将在本书的后面详细解释挂载目录。目前，让我们只使用默认的一组选定目录：
- en: '![](Image00013.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00013.jpg)'
- en: 'The Advanced pane has some options to adjust the resources of your computer
    that will be available for Docker, it will be the number of processors and memory
    amount. The default settings are usually a good start if you begin with Docker
    on macOS:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级窗格有一些选项，可以调整您的计算机为Docker提供的资源，包括处理器数量和内存量。如果您在macOS上开始使用Docker，通常默认设置是一个很好的开始：
- en: '![](Image00014.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00014.jpg)'
- en: 'The Proxies pane gives you the possibility to setup a proxy, if you need it
    on your machine. You can opt for using system or manual settings, as you can see
    in the following screenshot:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理窗格为您提供了在您的计算机上设置代理的可能性。您可以选择使用系统或手动设置，如下面的屏幕截图所示：
- en: '![](Image00015.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00015.jpg)'
- en: 'On the next page, you can edit some Docker daemon settings. This will include
    adding registries and registry mirrors. Docker will use them when pulling the
    image. The Advanced tab contains a text field, in which you can enter the JSON
    text containing the daemon config:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一页，您可以编辑一些Docker守护程序设置。这将包括添加注册表和注册表镜像。Docker在拉取镜像时将使用它们。高级选项卡包含一个文本字段，您可以在其中输入包含守护程序配置的JSON文本：
- en: '![](Image00016.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00016.jpg)'
- en: In the Daemon pane, you can also turn off Docker Experimental features . For
    some time now, Experimental features have been enabled by default. From time to
    time, a new version of Docker comes with new Experimental features . At the time
    of writing this book, they will include, for example, Checkpoint & Restore (a
    feature that allows you to freeze a running container by checkpointing it), Docker
    graph driver plugins (to use an external/out-of-process graph driver for use with
    the Docker engine as an alternative to using the built-in storage drivers), and
    some others. It's always interesting to see what new features are included in
    the new version of Docker. Clicking the link in the Daemon page will take you
    to the GitHub page which lists and explains all the new experimental features.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在守护程序窗格中，您还可以关闭Docker实验功能。有段时间以来，默认情况下已启用实验功能。不时，新版本的Docker会带来新的实验功能。在撰写本书时，它们将包括例如Checkpoint
    & Restore（允许您通过对其进行检查点来冻结运行中的容器的功能），Docker图形驱动程序插件（用于使用外部/独立进程图形驱动程序与Docker引擎一起使用的功能，作为使用内置存储驱动程序的替代方案），以及其他一些功能。了解新版本Docker中包含了哪些新功能总是很有趣。单击守护程序页面中的链接将带您转到GitHub页面，该页面列出并解释了所有新的实验功能。
- en: 'The last Preferences... pane is the Reset. If you find that your Docker won''t
    start or behaves badly, you can try to reset the Docker installation to the factory
    defaults:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个“首选项...”窗格是“重置”。如果您发现您的Docker无法启动或表现不佳，您可以尝试将Docker安装重置为出厂默认设置：
- en: '![](Image00017.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00017.jpg)'
- en: You should be warned though, that resetting Docker to the factory state will
    also remove all downloaded images and containers you may have on your machine.
    If you have images that have not been pushed anywhere yet, having a backup first
    is always a good idea.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您应该注意，将Docker重置为出厂状态也将删除您可能在计算机上拥有的所有已下载的镜像和容器。如果您有尚未推送到任何地方的镜像，首先备份总是一个好主意。
- en: 'The Open Kitematic in the Docker menu is a handy shortcut to open the Kitematic
    application we have mentioned earlier. It''s a desktop utility for using Docker
    on Windows and Mac OS X. If you do not have Kitematic installed already, Docker
    will give you a link with the installation package:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker菜单中打开Kitematic是打开我们之前提到的Kitematic应用程序的便捷快捷方式。这是一个用于在Windows和Mac OS X上使用Docker的桌面实用程序。如果您尚未安装Kitematic，Docker将为您提供安装包的链接：
- en: '![](Image00018.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00018.jpg)'
- en: 'If you run Kitematic , it will present you the Docker Hub login screen first.
    You can now Sign up to the Docker Hub and then log in providing your username
    and password :'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您运行Kitematic，它将首先呈现Docker Hub登录屏幕。您现在可以注册Docker Hub，然后提供用户名和密码登录：
- en: '![](Image00019.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00019.jpg)'
- en: 'Clicking on Skip For Now will take you to the images list without logging into
    the Docker Hub. Let''s test our installation by pulling and running an image.
    Let''s search for `hello-java-world` , as seen on the following screenshot:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“暂时跳过”将带您到图像列表，而无需登录到Docker Hub。让我们通过拉取和运行图像来测试我们的安装。让我们搜索“hello-java-world”，如下面的屏幕截图所示：
- en: '![](Image00020.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00020.jpg)'
- en: 'After pulling the image from the registry, start it. Kitematic will present
    the running Container logs, which will be the famous `hello world` message, coming
    from a containerized Java application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从注册表中拉取图像后，启动它。Kitematic将呈现正在运行的容器日志，其中将是来自容器化的Java应用程序的著名“hello world”消息：
- en: '![](Image00021.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00021.jpg)'
- en: 'That''s it for running the container in Kitematic . Let''s try to do the same
    from the shell. Execute the following in the terminal:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在Kitematic中运行容器的全部内容。让我们尝试从shell中执行相同的操作。在终端中执行以下操作：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As a result, you will see the same greeting, coming from a containerized Java
    application, this time in the macOS terminal:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您将看到来自容器化的Java应用程序的相同问候，这次是在macOS终端中：
- en: '![](Image00022.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00022.jpg)'
- en: That's it, we have a native Docker up and running on our macOS. Let's install
    it on Linux, as well.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们在macOS上有一个本地的Docker正在运行。让我们在Linux上安装它。
- en: Installing on Linux
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux上安装
- en: 'There are a lot of various Linux distributions out there and the installation
    process can be a little bit different for each Linux distribution. I''m going
    to install Docker on the latest, 16.04 Ubuntu desktop:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的Linux发行版，每个Linux发行版的安装过程可能会有所不同。我将在最新的16.04 Ubuntu桌面上安装Docker：
- en: 'First, we need to allow the `apt` package manager to use a repository over
    the HTTPS protocol. Execute from the shell:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要允许`apt`软件包管理器使用HTTPS协议的存储库。从shell中执行：
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next thing we are going to do is add Docker''s `apt` repository `gpg` key
    to our `apt` sources list:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要做的事情是将Docker的`apt`存储库`gpg`密钥添加到我们的`apt`源列表中：
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A simple `OK` will be the response if succeeded. Use the following command
    to set up the stable repository:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功后，简单的“OK”将是响应。使用以下命令设置稳定的存储库：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we need to update the `apt` packages index:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`apt`软件包索引：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we need to make sure the `apt` installer will use the official Docker repository
    instead of the default Ubuntu repository (which may contain the older version
    of Docker):'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要确保`apt`安装程序将使用官方的Docker存储库，而不是默认的Ubuntu存储库（其中可能包含较旧版本的Docker）：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use this command to install the latest version of Docker:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令安装最新版本的Docker：
- en: '[PRE14]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `apt` package manager will download a lot of packages; those will be the
    needed dependencies and the `docker-engine` itself:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`apt`软件包管理器将下载许多软件包；这些将是所需的依赖项和`docker-engine`本身：'
- en: '![](Image00023.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00023.jpg)'
- en: 'That''s it, you should be all set. Let''s verify if Docker works on our Linux
    box:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样，您应该已经准备好了。让我们验证一下Docker是否在我们的Linux系统上运行：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, the Docker engine will pull the `milkyway/java-hello-world`
    image with all its layers from the Docker Hub and respond with a greeting:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如您所看到的，Docker引擎将从Docker Hub拉取`milkyway/java-hello-world`镜像及其所有层，并以问候语作出响应：
- en: '![](Image00024.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00024.jpg)'
- en: 'But do we need to run Docker commands with `sudo?` The reason for that is the
    Docker daemon always runs as the `root` user, and since Docker version 0.5.2,
    the Docker daemon binds to a Unix socket instead of a TCP port. By default, that
    Unix socket is owned by the user `root` , and so, by default, you can access it
    with sudo. Let''s fix it to be able to run the `Docker` command as a normal user:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们需要用`sudo`运行Docker命令吗？原因是Docker守护程序始终以`root`用户身份运行，自Docker版本0.5.2以来，Docker守护程序绑定到Unix套接字而不是TCP端口。默认情况下，该Unix套接字由用户`root`拥有，因此，默认情况下，您可以使用sudo访问它。让我们修复它，以便能够以普通用户身份运行`Docker`命令：
- en: 'First, add the `Docker` group if it doesn''t already exist:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果还不存在`Docker`组，请添加它：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add your own user to the Docker group. Change the username to match your
    preferred user:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将您自己的用户添加到Docker组。将用户名更改为与您首选的用户匹配：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Restart the Docker daemon:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动Docker守护程序：
- en: '[PRE18]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now let''s log out and log in again, and execute the `docker run` command one
    more time, without `sudo` this time. As you can see, you are now able to work
    with Docker as a normal, non-`root` user:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们注销并再次登录，并且再次执行`docker run`命令，这次不需要`sudo`。正如您所看到的，您现在可以像普通的非`root`用户一样使用Docker了：
- en: '![](Image00025.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00025.jpg)'
- en: That's it. Our Linux Docker installation is ready to play with. Let's do an
    installation on the Windows box now.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样。我们的Linux Docker安装已准备就绪。现在让我们在Windows上进行安装。
- en: Installing on Windows
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: 'The native Docker package can be run on 64-bit Windows 10 Professional or Enterprise.
    It uses the Windows 10 virtualization engine to virtualize the Linux kernel. This
    is the reason that the installation package does no longer contain the VirtualBox
    setup, as with the previous versions of Docker for Windows. The native application
    comes in a typical `.msi` installation package. If you run it, it will greet you
    with a friendly message, saying that it is going to live in your task bar tray,
    under the small whale icon, from now on:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 本机Docker软件包可在64位Windows 10专业版或企业版上运行。它使用Windows 10虚拟化引擎来虚拟化Linux内核。这就是安装包不再包含VirtualBox设置的原因，就像以前的Docker
    for Windows版本一样。本机应用程序以典型的`.msi`安装包提供。如果你运行它，它会向你打招呼，并说它将从现在开始生活在你的任务栏托盘下，小鲸鱼图标下：
- en: '![](Image00026.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00026.jpg)'
- en: 'The Docker''s icon in the tray informs you about the Docker engine state. It
    also contains a small but useful context menu:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 托盘中的Docker图标会告诉你Docker引擎的状态。它还包含一个小但有用的上下文菜单：
- en: '![](Image00027.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00027.jpg)'
- en: 'Let''s explore the preferences settings and see what''s available. The first
    tab, General , allows you to set Docker to run automatically when you log in.
    If you use Docker daily that may be the recommended setting. You can also mark
    to check for updates automatically and send usage statistics. Sending usage statistics
    will help the Docker team improve the tool in future versions; unless you have
    some mission critical, secure work to be done, I recommend turning this option
    on. This is a great way to contribute to future versions of this magnificent tool:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索偏好设置，看看有什么可用的。第一个选项卡，常规，允许你设置Docker在你登录时自动运行。如果你每天使用Docker，这可能是推荐的设置。你也可以标记自动检查更新并发送使用统计信息。发送使用统计信息将帮助Docker团队改进未来版本的工具；除非你有一些关键任务、安全工作要完成，我建议打开这个选项。这是为未来版本贡献的好方法：
- en: '![](Image00028.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00028.jpg)'
- en: 'The second tab, Shared Drives , allows you to select the local Windows drives
    which will be available to the Docker containers you will be running:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项卡，共享驱动器，允许你选择本地Windows驱动器，这些驱动器将可用于你将要运行的Docker容器：
- en: '![](Image00029.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00029.jpg)'
- en: 'We are going to cover Docker volumes in [Chapter 2](text00037.html) , *Networking
    and Persistent Storage* . Selecting a drive here means that you can map a directory
    from your local system and read that as a Windows host machine to your Docker
    container. The next preferences page, Advanced , allows us to make some restrictions
    on the Docker engine running on our Windows PC and also select the location of
    the virtual machine image with the Linux kernel:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第2章](text00037.html)中介绍Docker卷，*网络和持久存储*。在这里选择一个驱动器意味着你可以映射本地系统的一个目录，并将其作为Windows主机机器读取到你的Docker容器中。下一个偏好设置页面，高级，允许我们对在我们的Windows
    PC上运行的Docker引擎进行一些限制，并选择Linux内核的虚拟机镜像的位置：
- en: '![](Image00030.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00030.jpg)'
- en: 'The default values are usually good out of the box and unless you experience
    problems during the development process, I would recommend leaving them as they
    are. The Network lets you configure the way Docker works with the network, the
    same as subnet address and mask or DNS server. We are going to cover Docker networking
    in [Chapter 2](text00037.html) , *Networking and Persistent Storage* :'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值通常是开箱即用的，除非在开发过程中遇到问题，我建议保持它们不变。网络让你配置Docker与网络的工作方式，与子网地址和掩码或DNS服务器一样。我们将在[第2章](text00037.html)中介绍Docker网络，*网络和持久存储*：
- en: '![](Image00031.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00031.jpg)'
- en: 'If you''re behind a proxy in your network and would like Docker to access the
    Internet, you can set up the proxy settings in the Proxies tab:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在网络中使用代理，并希望Docker访问互联网，你可以在代理选项卡中设置代理设置：
- en: '![](Image00032.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00032.jpg)'
- en: 'The dialog is similar to what you find in other applications where you can
    define proxy settings. It can accept no proxy, system proxy settings, or manual
    settings (with a different proxy for HTPP and HTTPS communication). The next pane
    can be useful to configure the Docker daemon:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框类似于您在其他应用程序中找到的，您可以在其中定义代理设置。它可以接受无代理、系统代理设置或手动设置（使用不同的代理进行HTPP和HTTPS通信）。下一个窗格可以用来配置Docker守护程序：
- en: '![](Image00033.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00033.jpg)'
- en: The Basic switch means that Docker uses the basic configuration. You can switch
    it to Advanced and provide a customized setting in a form of JSON structure. The
    Experimental features are the same as we have already mentioned during the Docker
    setup on macOS, this will be Checkpoint & Restore or enabling Docker graph driver
    plugins, for example. You can also specify a list of remote registries. Docker
    will be pulling images from insecure registries using just plain HTTP instead
    of HTTPS.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 基本开关意味着Docker使用基本配置。您可以将其切换到高级，并以JSON结构的形式提供自定义设置。实验性功能与我们在macOS上进行Docker设置时已经提到的相同，这将是Checkpoint
    & Restore或启用Docker图形驱动程序插件，例如。您还可以指定远程注册表的列表。Docker将从不安全的注册表中拉取图像，而不是使用纯粹的HTTP而不是HTTPS。
- en: 'Using the Reset options on the last pane lets you restart or reset Docker to
    its factory settings:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个窗格上使用重置选项可以让您重新启动或将Docker重置为出厂设置：
- en: '![](Image00034.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00034.jpg)'
- en: Be aware though, that resetting Docker to its initial settings will also remove
    all images and containers currently present on your machine.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，将Docker重置为其初始设置也将删除当前在您的计算机上存在的所有镜像和容器。
- en: 'The Open Kitematic... option, which is also present in the Docker tray icon
    context menu, is a quick shortcut to launch Kitematic . If you do it for the first
    time and don''t have Kitematic installed, Docker will ask if you would like to
    download it first:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: “打开Kitematic...”选项也出现在Docker托盘图标上下文菜单中，这是启动Kitematic的快捷方式。如果您是第一次这样做，并且没有安装Kitematic，Docker会询问您是否想要先下载它：
- en: '![](Image00035.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00035.jpg)'
- en: 'That''s it for installing Docker for Windows. It''s a pretty painless process.
    As a last step of the installation process, let''s check if Docker can be run
    from the command prompt, because it''s probably the way you will be launching
    it in the future. Execute the following command in the command prompt or in the
    PowerShell:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker for Windows就是这样。这是一个相当轻松的过程。在安装过程的最后一步，让我们检查一下Docker是否可以从命令提示符中运行，因为这可能是您将来启动它的方式。在命令提示符或PowerShell中执行以下命令：
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![](Image00036.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](Image00036.jpg)'
- en: As you can see on the previous screenshot, we have a Hello World message coming
    from the Java application started as a Docker container.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上一个屏幕截图中所看到的，我们有一个来自作为Docker容器启动的Java应用程序的Hello World消息。
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: That's it. Our Docker for Windows installation is fully functional. In this
    chapter, we have learned about the idea behind Docker and the main differences
    between traditional virtualization and containerization. We know a lot about Docker
    core concepts such as images, layers, containers, and registries. We should have
    Docker installed already on our local machine; it's now time to move on and learn
    about more advanced Docker features, such as networking and persistent storage.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们的Docker for Windows安装已经完全可用。在本章中，我们已经了解了Docker背后的理念以及传统虚拟化和容器化之间的主要区别。我们对Docker的核心概念，如镜像、层、容器和注册表，了解很多。我们应该已经在本地计算机上安装了Docker；现在是时候继续学习更高级的Docker功能，比如网络和持久存储了。
