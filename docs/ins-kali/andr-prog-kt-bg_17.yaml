- en: Chapter 17. Data Persistence and Sharing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章。数据持久性和共享
- en: In this chapter, we will look at a couple of different ways to save data to
    an Android device's permanent storage. Also, for the first time, we will add a
    second `Activity` instance to our app. It often makes sense when implementing
    a separate "screen", such as a "Settings" screen, in our app to do so in a new
    `Activity` instance. We could go to the trouble of hiding the original UI and
    then showing the new UI in the same `Activity`, as we did in [Chapter 4](ch04.html
    "Chapter 4. Getting Started with Layouts and Material Design"), *Getting Started
    with Layouts and Material Design*, but this would quickly lead to confusing and
    error-prone code. So, we will see how to add another `Activity` instance and navigate
    the user between them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨将数据保存到Android设备的永久存储的几种不同方法。此外，我们还将首次向我们的应用程序添加第二个`Activity`实例。在我们的应用程序中实现一个单独的“屏幕”，比如“设置”屏幕时，这通常是有意义的，可以在一个新的`Activity`实例中这样做。我们可以通过在同一个`Activity`中隐藏原始UI然后显示新UI的方式来做到这一点，就像我们在[第4章](ch04.html
    "第4章。开始使用布局和材料设计")中所做的那样，*开始使用布局和材料设计*，但这很快会导致混乱和容易出错的代码。因此，我们将看到如何添加另一个`Activity`实例并在它们之间导航用户。
- en: 'In this chapter, we will do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将执行以下操作：
- en: Learn about the Android `Intent` class to switch `Activity` instances and pass
    data between them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Android `Intent`类以在`Activity`实例之间切换并在它们之间传递数据
- en: Create a very simple settings screen in a new `Activity` instance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个新的`Activity`实例中创建一个非常简单的设置屏幕
- en: Persist the settings screen data using the `SharedPreferences` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SharedPreferences`类持久保存设置屏幕数据
- en: Learn about **JavaScript Object Notation** (**JSON**) for serialization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**JavaScript对象表示**（**JSON**）进行序列化
- en: Explore `try`-`catch`-`finally`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`try`-`catch`-`finally`
- en: Implement saving data in our Note to self app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的备忘录应用程序中实现数据保存
- en: The Android Intent class
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android Intent类
- en: The `Intent` class is appropriately named. It is a class that demonstrates the
    intent of an `Activity` instance from our app. It makes intent clear and it also
    facilitates it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类的命名恰如其分。它是一个展示我们应用程序的`Activity`实例意图的类。它使意图清晰并且也促进了它。'
- en: All our apps so far have had just one `Activity` instance but many Android apps
    comprise more than one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的所有应用程序都只有一个`Activity`实例，但许多Android应用程序包含多个。
- en: In perhaps its most common use, an `Intent` object allows us to switch between
    `Activity` instances. But, of course, `Activity` instances are made from classes.
    So, what happens to the data when we switch between these classes? The `Intent`
    class handles this problem for us as well by allowing us to pass data between
    them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在它可能最常见的用法中，`Intent`对象允许我们在`Activity`实例之间切换。但是，当我们在这些类之间切换时，数据会发生什么？`Intent`类也通过允许我们在它们之间传递数据来解决了这个问题。
- en: '`Intent` classes aren''t just about wiring up the Activities of our app. They
    also make it possible to interact with other apps, too. For example, we could
    provide a link in our app for the user to send an email, make a phone call, interact
    with social media, or open a web page in a browser, and have the email, dialer,
    web browser, or relevant social media app do all the work.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类不仅仅是关于连接我们应用程序的活动。它们还使与其他应用程序进行交互成为可能。例如，我们可以在我们的应用程序中提供一个链接，让用户发送电子邮件，打电话，与社交媒体互动，或在浏览器中打开网页，并让电子邮件、拨号器、网络浏览器或相关的社交媒体应用程序完成所有工作。'
- en: There aren't enough pages to really dig deep into interacting with other apps,
    and so we will mainly focus on switching between Activities and passing data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 没有足够的页面来深入了解与其他应用程序的交互，因此我们主要将专注于在活动之间切换和传递数据。
- en: Switching Activity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换Activity
- en: 'Let''s say we have an app with two `Activity`-based classes, and we will soon.
    We can assume that, as usual, we have an `Activity` instance called `MainActivity`,
    which is where the app starts, and a second `Activity` instance called `SettingsActivity`.
    This is how we can swap from `MainActivity` to `SettingsActivity`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个基于两个`Activity`的类的应用程序，很快我们就会有。我们可以假设，像往常一样，我们有一个名为`MainActivity`的`Activity`实例，这是应用程序的起点，以及一个名为`SettingsActivity`的第二个`Activity`实例。这是我们如何从`MainActivity`切换到`SettingsActivity`的方法：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Look carefully at how we initialized the `Intent` object. `Intent` has a constructor
    that takes two arguments. The first is a reference to the current `Activity` instance,
    `this`. The second parameter is the name of the `Activity` instance that we want
    to open, `SettingsActivity::class`. The `class` on the end of `SettingsActivity`
    makes it the full name of the `Activity` instance as declared in the `AndroidManifest.xml`
    file, and we will peek at that when we experiment with `Intent` shortly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细查看我们如何初始化`Intent`对象。`Intent`有一个构造函数，它接受两个参数。第一个是对当前`Activity`实例`this`的引用。第二个参数是我们要打开的`Activity`实例的名称，`SettingsActivity::class`。`SettingsActivity`末尾的`class`使其成为`AndroidManifest.xml`文件中声明的`Activity`实例的完整名称，我们将在不久的将来尝试`Intent`时窥探一下。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The odd-looking `.java` on the end is because all the Kotlin code is turned
    into Java byte code, and `SettingsActivity::class.java` is its fully qualified
    name.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来奇怪的`.java`是因为所有的Kotlin代码都被转换为Java字节码，`SettingsActivity::class.java`是它的完全限定名称。
- en: The only problem is that `SettingsActivity` doesn't share any of the data of
    `MainActivity`. In a way, this is a good thing, because if you need all the data
    from `MainActivity`, then it is a reasonable indication that switching `Activity`
    instances might not be the best way of proceeding with your app's design. It is,
    however, unreasonable to have encapsulation so thorough that the two `Activity`
    instances know absolutely nothing about each other.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的问题是`SettingsActivity`不共享`MainActivity`的任何数据。在某种程度上，这是一件好事，因为如果您需要从`MainActivity`获取所有数据，那么这合理地表明切换`Activity`实例可能不是处理应用程序设计的最佳方式。然而，让两个`Activity`实例封装得如此彻底，以至于它们彼此完全不知道，这是不合理的。
- en: Passing data between Activities
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Activity之间传递数据
- en: What if we have a sign-in screen for the user, and we want to pass the login
    credentials to each `Activity` instance of our app? We could do so using the `Intent`
    class.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为用户创建一个登录屏幕，并且我们希望将登录凭据传递给我们应用程序的每个`Activity`实例，我们可以使用`Intent`类来实现。
- en: 'We can add data to an `Intent` instance like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样向`Intent`实例添加数据：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `SettingsActivity`, we could then retrieve the `String` value like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SettingsActivity`中，我们可以像这样检索`String`值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the previous two blocks of code, we switched `Activity` instances in the
    same way as we have already seen. But, before we called `startActivity`, we used
    the `putExtra` function to load a `String` value into `myIntent`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个代码块中，我们以与我们已经看到的相同方式切换了`Activity`实例。但是，在调用`startActivity`之前，我们使用`putExtra`函数将一个`String`值加载到`myIntent`中。
- en: We add data using **key-value pairs**. Each piece of data needs to be accompanied
    by an **identifier** that can be used in the retrieving `Activity` instance to
    identify and then retrieve the data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用**键值对**添加数据。每个数据都需要伴随一个**标识符**，以便在检索`Activity`实例中识别并检索数据。
- en: The identifier name is arbitrary, but useful/memorable values should be used.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符名称是任意的，但应该使用有用/易记的值。
- en: 'Then, in the receiving `Activity` instance, we simply create an `Intent` object
    using the default constructor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在接收的`Activity`实例中，我们只需使用默认构造函数创建一个`Intent`对象：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can then retrieve the data using the `extras.getString` function and the
    appropriate identifier from the key-value pair.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`extras.getString`函数和键值对中的适当标识符来检索数据。
- en: The `Intent` class can help us send more complex data than this, but the `Intent`
    class has its limits. For example, we wouldn't be able to send a `Note` object.
    Once we want to start sending more than a few values, it is worth considering
    different tactics.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类可以帮助我们发送比这更复杂的数据，但`Intent`类有其限制。例如，我们将无法发送`Note`对象。一旦我们想要开始发送多个值，就值得考虑不同的策略。'
- en: Adding a settings page to Note to self
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向“Note to self”添加设置页面
- en: 'Now we are armed with all this knowledge about the Android `Intent` class,
    we can add another screen (`Activity`) to our Note to self app: a "Settings" screen.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了关于Android `Intent`类的所有知识，我们可以向我们的“Note to self”应用程序添加另一个屏幕（`Activity`）：一个“设置”屏幕。
- en: We will first create a new `Activity` instance for our new screen and see what
    effect that has on the `AndroidManifest.xml` file. We will then create a very
    simple layout for our settings screen and add the Kotlin code to switch from `MainActivity`
    to the new one. We will, however, defer wiring up our settings screen layout with
    Kotlin until we have learned how to save the users preferred settings to disk.
    We will do this later on in this chapter and then come back to the settings screen
    to make its data persist.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为新屏幕创建一个新的`Activity`实例，并查看这对`AndroidManifest.xml`文件的影响。然后，我们将为设置屏幕创建一个非常简单的布局，并添加Kotlin代码以从`MainActivity`切换到新的布局。然而，我们将推迟将设置屏幕布局与Kotlin连接，直到我们学会如何将用户首选设置保存到磁盘。我们将在本章后面做这个，然后回到设置屏幕以使其数据持久化。
- en: First, let's code that new `Activity` class. We will call it `SettingsActivity`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写新的`Activity`类。我们将其称为`SettingsActivity`。
- en: Creating the SettingsActivity
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SettingsActivity
- en: 'SettingsActivity will be a screen where the user can turn on or off the decorative
    divider between each note in the `RecyclerView` widget. This will not be a very
    comprehensive settings screen, but it will be a useful exercise, and we will see
    switching between the two `Activity` instances in action as well as save data
    to disk. Follow these steps to get started:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SettingsActivity将是一个屏幕，用户可以在其中打开或关闭`RecyclerView`小部件中每个笔记之间的装饰分隔线。这不会是一个非常全面的设置屏幕，但这将是一个有用的练习，并且我们将看到在两个`Activity`实例之间切换以及将数据保存到磁盘的操作。按照以下步骤开始：
- en: In the project explorer window, right-click the folder that contains all your
    `.kt` files and has the same name as your package. From the pop-up context menu,
    select **New | Activity | Empty Activity**.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目资源管理器窗口中，右键单击包含所有`.kt`文件并与您的包具有相同名称的文件夹。从弹出的上下文菜单中，选择**新建|Activity|空白Activity**。
- en: In the **Activity Name:** field, enter `SettingsActivity`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Activity Name:**字段中输入`SettingsActivity`。
- en: Leave all the other options at their defaults and left-click **Finish**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他选项保持默认值，然后单击**完成**。
- en: Android Studio has created a new `Activity` class for us and its associated
    `.kt` file. Let's take a quick peek at some of the work that was done behind the
    scenes for us, because it is useful to know what is going on.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio为我们创建了一个新的`Activity`类及其关联的`.kt`文件。让我们快速查看一些在幕后为我们完成的工作，因为了解发生了什么是很有用的。
- en: 'Open the `AndroidManifest.xml` file from within the `manifests` folder in the
    project explorer. Notice the following new line of code near the end of this file:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从项目资源管理器中的`manifests`文件夹中打开`AndroidManifest.xml`文件。注意文件末尾附近的以下新代码行：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is how an `Activity` class is **registered** with the operating system.
    If an `Activity` class is not registered, then an attempt to run it will crash
    the app. We could create an `Activity` class simply by creating a class that extends
    `Activity` (or `AppCompatActivity`) in a new `.kt` file. However, we would then
    have had to add the preceding code ourselves. Also, by using the new activity
    wizard, we got a layout XML file (`activity_settings.xml`) automatically generated
    for us.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Activity`类与操作系统**注册**的方式。如果`Activity`类未注册，则尝试运行它将使应用程序崩溃。我们可以通过在新的`.kt`文件中创建一个扩展`Activity`（或`AppCompatActivity`）的类来创建`Activity`类。但是，我们将不得不自己添加前面的代码。此外，通过使用新的Activity向导，我们自动生成了一个布局XML文件（`activity_settings.xml`）。
- en: Designing the settings screen layout
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计设置屏幕布局
- en: 'We will quickly build a user interface for our settings screen; the following
    steps and screenshot should make this straightforward:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将快速为我们的设置屏幕构建用户界面；以下步骤和屏幕截图应该使这变得简单：
- en: Open the `activity_settings.xml` file and switch to the **Design** tab, where
    we will quickly lay out our settings screen.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_settings.xml`文件，并切换到**Design**选项卡，在那里我们将快速布置我们的设置屏幕。
- en: Use this next screenshot as a guide while following the rest of the steps:![Designing
    the settings screen layout](img/B12806_17_01.jpg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在遵循其余步骤时，请使用下一个截图作为指南：![设计设置屏幕布局](img/B12806_17_01.jpg)
- en: Drag and drop a **Switch** widget onto the center-top of the layout. I stretched
    mine by dragging the edges to make it larger and clearer.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个**Switch**小部件拖放到布局的中上部。我通过拖动边缘来拉伸它，使其更大更清晰。
- en: Add an `id` attribute of `switch1` (if it isn't already) so that we can interact
    with it using Kotlin.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`id`属性为`switch1`（如果还没有的话），以便我们可以使用Kotlin与其交互。
- en: Use the constraint handles to fix the position of the switch, or click the **Infer
    Constraints** button to fix it automatically.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用约束处理程序来固定开关的位置，或者点击**推断约束**按钮来自动固定它。
- en: We now have a nice (and very simple) new layout for our settings screen, and
    the `id` property is in place, ready for when we wire it up with our code later
    in the chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在为我们的设置屏幕有了一个漂亮（而且非常简单）的新布局，并且`id`属性已经就位，准备在本章后面的代码中与其连接。
- en: Enabling the user to switch to the "Settings" screen
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用户能够切换到“设置”屏幕
- en: We already know how to create and switch to a `SettingsActivity` instance. Also,
    as we won't be passing any data to it or from it, we can get this working with
    just a few lines of Kotlin code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何创建和切换到`SettingsActivity`实例。另外，由于我们不会向其传递任何数据，也不会从中获取任何数据，我们可以只用几行Kotlin代码就可以让其工作。
- en: 'You might have noticed in the action bar of our app there is the menu icon.
    It is indicated in this next screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们的应用程序的操作栏中有菜单图标。在下一个截图中指示了它：
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![使用户能够切换到“设置”屏幕](img/B12806_17_02.jpg)'
- en: 'If you tap it, there is already a menu option in there for **Settings**, provided
    by default when we first created the app. This is what you will see when you tap
    the menu icon:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击它，您会发现其中已经有一个**设置**菜单选项，这是我们在创建应用程序时默认提供的。当您点击菜单图标时，您将看到以下内容：
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![使用户能够切换到“设置”屏幕](img/B12806_17_03.jpg)'
- en: All we need to do is place our code to create and switch to the `SettingsActivity`
    instance within the `onOptionsItemSelected` function in the `MainActivity.kt`
    file. Android Studio even provides a `when` block by default for us to paste our
    code into, on the assumption that we would one day want to add a settings menu.
    How thoughtful.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是将创建和切换到`SettingsActivity`实例的代码放在`MainActivity.kt`文件的`onOptionsItemSelected`函数中。Android
    Studio甚至默认为我们提供了一个`when`块，以便我们将来有一天想要添加设置菜单时将我们的代码粘贴进去。多么体贴。
- en: 'Switch to `MainActivity.kt` in the editor window and find the following block
    of code in the `onOptionsItemSelected` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到编辑器窗口中的`MainActivity.kt`，并找到`onOptionsItemSelected`函数中的以下代码块：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Edit the `when` block shown previously to match the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑前面显示的`when`块以匹配以下代码：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to import the `Intent` class using your preferred technique to
    add this line of code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用您喜欢的技术导入`Intent`类以添加以下代码：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can now run the app and visit the new settings screen by tapping the **Settings**
    menu option. This screenshot shows the settings screen running on the emulator:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以运行应用程序，并通过点击**设置**菜单选项来访问新的设置屏幕。此截图显示了模拟器上运行的设置屏幕：
- en: '![Enabling the user to switch to the "Settings" screen](img/B12806_17_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用户能够切换到“设置”屏幕](img/B12806_17_04.jpg)'
- en: To return from `SettingsActivity` screen to the `MainActivity` screen, you can
    tap the back button on the device.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要从`SettingsActivity`屏幕返回到`MainActivity`屏幕，您可以点击设备上的返回按钮。
- en: Persisting data with SharedPreferences
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences持久化数据
- en: In Android, there are a few ways to make data persist. By persist, I mean that
    if the user quits the app, then when they come back to it their data will still
    be available. Which technique is the correct one to use is dependent upon the
    app and the type of data.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，有几种方法可以使数据持久化。持久化的意思是，如果用户退出应用程序，然后再次打开应用程序，他们的数据仍然可用。使用哪种技术取决于应用程序和数据类型。
- en: In this book, we will look at three ways to make data persist. For saving our
    user's settings, we only need a simple method. After all, we just need to know
    whether they want the decorative divider between each of the notes in the `RecyclerView`
    widget.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将介绍三种使数据持久化的方法。对于保存用户的设置，我们只需要一个简单的方法。毕竟，我们只需要知道他们是否希望在`RecyclerView`小部件的每个笔记之间有装饰性分隔符。
- en: 'Let''s look at how we can make our apps save and reload variables to the internal
    storage of the device. We need to use the `SharedPreferences` class. `SharedPreferences`
    is a class that provides access to data that can be accessed and edited by all
    the classes of an app. Let''s look at how we can use it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使我们的应用程序将变量保存和重新加载到设备的内部存储器中。我们需要使用`SharedPreferences`类。`SharedPreferences`是一个提供对数据访问和编辑的类，可以被应用程序的所有类访问和编辑。让我们看看如何使用它：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We initialized the `prefs` object by using the `getSharedPreferences` function
    and passing in a `String` value that will be used to refer to all the data read
    and written using this object. Typically, we could use the name of the app as
    this String value. In the next code, `Mode_Private` means that any class can access
    it, but only from this app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用`getSharedPreferences`函数并传入一个`String`值来初始化`prefs`对象，该值将用于引用使用该对象读取和写入的所有数据。通常，我们可以使用应用的名称作为此字符串值。在下一段代码中，`Mode_Private`表示任何类都可以访问它，但只能从此应用程序访问。
- en: We then used our newly initialized `prefs` object to initialize our `editor`
    object by calling the `edit` function.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用我们新初始化的`prefs`对象通过调用`edit`函数来初始化我们的`editor`对象。
- en: 'Let''s say we wanted to save the user''s name, which we have in a `String`
    instance called `username`. We can then write the data to the internal memory
    of the device like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们想要保存用户的名字，我们在一个名为`username`的`String`实例中拥有。然后我们可以像这样将数据写入设备的内部存储器：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The first argument used in the `putString` function is a label that can be
    used to refer to the data, the second argument is the actual variable that holds
    the data we want to save. The second line in the previous code initiates the saving
    process. So, we could write multiple variables to disk like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “putString”函数中使用的第一个参数是一个标签，可用于引用数据，第二个参数是保存我们要保存的数据的实际变量。前面代码的第二行启动了保存过程。因此，我们可以像这样将多个变量写入磁盘：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code demonstrates that you can save other variable types and it,
    of course, assumes that the `username`, `age`, and `subscribed` variables have
    previously been declared then initialized with appropriate values.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了您可以保存其他变量类型，并且假设“username”、“age”和“subscribed”变量已经被声明并使用适当的值进行了初始化。
- en: Once `editor.apply()` has executed, the data is stored. We can quit the app,
    even turn off the device, and the data will persist.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦“editor.apply()”执行，数据就被存储了。我们可以退出应用程序，甚至关闭设备，数据仍将持久存在。
- en: Reloading data with SharedPreferences
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SharedPreferences重新加载数据
- en: 'Let''s see how we can reload our data the next time the app is run. This code
    will reload the three values that the previous code saved. We could even declare
    our variables and initialize them with the stored values:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一次应用程序运行时如何重新加载我们的数据。这段代码将重新加载前一段代码保存的三个值。我们甚至可以声明变量并使用存储的值进行初始化：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous code, we load the data from disk using the function appropriate
    for the data type and the same label we used to save the data in the first place.
    What is less clear is the second argument to each of the function calls.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了适用于数据类型的函数从磁盘加载数据，并使用了与我们首次保存数据时使用的相同标签。不太清楚的是每个函数调用的第二个参数。
- en: The `getString`, `getInt`, and `getBoolean` functions require a default value
    as the second argument. If there is no data stored with that label, it will then
    return the default value.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: “getString”、“getInt”和“getBoolean”函数需要第二个参数作为默认值。如果没有存储带有该标签的数据，它将返回默认值。
- en: 'We could then check for these default values in our code and go about trying
    to obtain the required values or handling an error. For example, see the following
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在我们的代码中检查这些默认值，并尝试获取所需的值或处理错误。例如，参见以下代码：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We now know enough to save our user's settings in the Note to self app.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解足够的知识来保存用户的设置在Note to self应用程序中。
- en: Making the Note to self settings persist
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使自我备忘录设置持久化
- en: We have already learned how to save data to the device's memory. As we implement
    saving the user's settings, we will, again, see how we handle the `Switch` widget
    input and where exactly the code we have just seen will go to make our app work
    the way we want it to.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了如何将数据保存到设备的内存中。当我们实现保存用户的设置时，我们将再次看到我们如何处理“Switch”小部件的输入，以及我们刚刚看到的代码将如何使我们的应用程序按照我们想要的方式工作。
- en: Coding the SettingsActivity class
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写SettingsActivity类
- en: Most of the action will take place in the `SettingsActivity.kt` file. So, click
    on the appropriate tab and we will add the code a bit at a time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分操作将在“SettingsActivity.kt”文件中进行。因此，点击适当的选项卡，我们将逐步添加代码。
- en: First, we want a property to represent the user's option on the settings screen
    – whether they want decorative dividers or not.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望有一个属性来表示用户在设置屏幕上的选项 - 他们是否想要装饰性分隔线。
- en: 'Add the following to `SettingsActivity`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到“SettingsActivity”中：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, in `onCreate`, add the highlighted code to initialize `prefs`, which is
    inferred to be a `SharedPreferences` instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在“onCreate”中，添加突出显示的代码以初始化“prefs”，它被推断为“SharedPreferences”实例：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Import the `SharedPreferences` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 导入“SharedPreferences”类：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, still in `onCreate`, let''s load up the saved data, which represents
    our user''s previous choice for whether to show the dividers. We will set the
    switch to either on or off, as appropriate:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在“onCreate”中，让我们加载保存的数据，这些数据代表我们的用户以前选择是否显示分隔线。我们将根据需要将开关设置为打开或关闭：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we will create a lambda to handle changes to our `Switch` widget. We
    simply set the value of `showDividers` to be the same as the `isChecked` variable
    of the `Switch` widget. Add the following code to the `onCreate` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个lambda来处理我们的“Switch”小部件的更改。我们只需将“showDividers”的值设置为“Switch”小部件的“isChecked”变量相同。将以下代码添加到“onCreate”函数中：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You might have noticed that we did not write any values to the device storage
    at any point in any of that code. We could have placed it after we detected a
    change to the switch, but it is much simpler to put it where it is guaranteed
    to be called – but only once.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在任何代码中的任何时候，我们都没有将任何值写入设备存储。我们可以在检测到开关变化后放置它，但是将它放在保证被调用的地方要简单得多 -
    但只有一次。
- en: 'We will use our knowledge of the `Activity` lifecycle and override the `onPause`
    function. When the user leaves the `SettingsActivity` screen, either to go back
    to the `MainActivity` screen or to quit the app, `onPause` will be called and
    the settings will be saved. This way, the user can flip the switch as often as
    they like, and the app will save their final decision. Add this code to override
    the `onPause` function and save the user''s settings. Add the code just before
    the closing curly brace of the `SettingsActivity` class:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们对“Activity”生命周期的了解，并覆盖“onPause”函数。当用户离开“SettingsActivity”屏幕时，无论是返回“MainActivity”屏幕还是退出应用程序，“onPause”都将被调用，并且设置将被保存。这样，用户可以随意切换开关，应用程序将保存他们的最终决定。添加此代码以覆盖“onPause”函数并保存用户的设置。将此代码添加到“SettingsActivity”类的结束大括号之前：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding code declares and initializes a new `SharedPreferences` instance
    in private mode, using the name of the app. It also declares and initializes a
    new `SharedPreferences.Editor` instance. Finally, the value is entered into the
    `editor` object using `putBoolean`, and written to the disk using the `apply`
    function.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在私有模式下声明和初始化了一个新的“SharedPreferences”实例，使用了应用程序的名称。它还声明和初始化了一个新的“SharedPreferences.Editor”实例。最后，使用“putBoolean”将值输入到“editor”对象中，并使用“apply”函数写入磁盘。
- en: Now, we can add some code to `MainActivity` to load the settings when the app
    starts, or when the user switches back from the settings screen to the main screen.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以向`MainActivity`添加一些代码，在应用程序启动时或用户从设置屏幕切换回主屏幕时加载设置。
- en: Coding the MainActivity class
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写MainActivity类
- en: 'Add this highlighted code after the `NoteAdapter` declaration:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NoteAdapter`声明后添加这段突出显示的代码：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now we have a `Boolean` property to decide whether to show the dividers. We
    will override the `onResume` function and initialize our `Boolean` property. Add
    the overridden `onResume` function, as shown next to the `MainActivity` class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`Boolean`属性来决定是否显示分隔线。我们将重写`onResume`函数并初始化我们的`Boolean`属性。添加重写的`onResume`函数，如下所示，添加到`MainActivity`类旁边：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The user is now able to choose their settings. The app will both save and reload
    them as necessary, but we need to make `MainActivity` respond to the user's choice.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在能够选择他们的设置。应用程序将根据需要保存和重新加载它们，但我们需要让`MainActivity`响应用户的选择。
- en: 'Find this code in the `onCreate` function and delete it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数中找到这段代码并删除它：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The previous code is what set the dividers between each note in the list. Add
    this new code to the `onResume` function, which is the same line of code surrounded
    by an `if` statement, to selectively use dividers only when `showDividers` is
    `true`. Add the code after the previous code in `onResume`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的代码是设置列表中每个笔记之间的分隔线。将这段新代码添加到`onResume`函数中，这是相同的代码行，被一个`if`语句包围，只有在`showDividers`为`true`时才选择性地使用分隔线。在`onResume`中的先前代码之后添加这段代码：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Run the app and you''ll notice the dividers are gone; go to the settings screen,
    switch on the dividers, return to the main screen (with the back button), and
    behold: there are now separators. This next screenshot shows the list with and
    without separators, photoshopped side by side, to illustrate that the switch works,
    and that the settings persist between the two `Activity` instances:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你会注意到分隔线消失了；转到设置屏幕，打开分隔线，返回主屏幕（使用返回按钮），你会发现：现在有分隔符了。下一张截图显示了有和没有分隔符的列表，被并排合成一张照片，以说明开关的工作，并且设置在两个`Activity`实例之间持久保存：
- en: '![Coding the MainActivity class](img/B12806_17_05.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![编写MainActivity类](img/B12806_17_05.jpg)'
- en: Be sure to try quitting the app and restarting to verify that the settings are
    saved to disk. You can even turn the emulator off and back on again and the settings
    will persist.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要尝试退出应用程序并重新启动，以验证设置是否已保存到磁盘。甚至可以关闭模拟器，然后再次打开，设置将保持不变。
- en: Now we have a neat settings screen, and we can permanently save the users choices.
    Of course, the big missing link regarding persistence is that the user's fundamental
    data, their notes, still does not persist.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个整洁的设置屏幕，我们可以永久保存用户的选择。当然，关于持久性的一个重要缺失是用户的基本数据，他们的笔记，仍然无法持久保存。
- en: More advanced persistence
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的持久性
- en: Let's think about what we need to do. We want to save a bunch of notes to the
    internal storage. Being more specific, we want to store a selection of Strings
    and related Boolean values. These Strings and Boolean values represent the user's
    note title, the text, and whether it is a to-do, important, or an idea.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们需要做什么。我们想要将一堆笔记保存到内部存储器中。更具体地说，我们想要存储一些字符串和相关的布尔值。这些字符串和布尔值代表用户的笔记标题、文本，以及它是待办事项、重要事项还是想法。
- en: Given what we already know about the `SharedPreferences` class, at first glance,
    this might not seem especially challenging – until we dig a little deeper into
    our requirements. What if the user loves our app and ends up with 100 notes? We
    would need 100 identifiers for key-value pairs. Not impossible, but starting to
    get awkward.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们已经对`SharedPreferences`类有所了解，乍一看，这似乎并不特别具有挑战性 - 直到我们更深入地了解我们的需求。如果用户喜欢我们的应用程序并最终拥有100条笔记，我们将需要100个键值对的标识符。这并非不可能，但开始变得尴尬。
- en: Now, imagine that we wanted to enhance the app and give the user the ability
    to add dates to them. Android has a `Date` class that is perfect for this. It
    would be reasonably straightforward to then add neat features, such as reminders,
    to our app. But when it comes to saving data, things suddenly start to get complicated.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下，我们想增强应用程序并让用户能够为它们添加日期。Android有一个`Date`类非常适合这个用途。然后，添加一些整洁的功能，比如提醒，对我们的应用程序来说将是相当简单的。但是当涉及到保存数据时，事情突然变得复杂起来。
- en: How would we store a date using `SharedPreferences`? It wasn't designed for
    this. We could convert it to a String value when we save it, and then could convert
    it back again when we load it, but this is far from simple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用`SharedPreferences`存储日期？它并不是为此而设计的。我们可以在保存时将其转换为字符串值，然后在加载时再次转换回来，但这远非简单。
- en: And, as our app grows in features and our users get more and more notes, the
    whole persistence thing becomes a nightmare. What we need is a way to save and
    load actual Kotlin objects. If we can simply save and load objects, including
    their internal data (Strings, Booleans, dates, or anything else), our apps can
    have any kind of data we need to suit our users.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的应用程序功能的增加和用户拥有越来越多的笔记，整个持久性问题变得一团糟。我们需要一种方法来保存和加载实际的Kotlin对象。如果我们能简单地保存和加载对象，包括它们的内部数据（字符串、布尔值、日期或其他任何东西），我们的应用程序可以拥有我们需要适应用户的任何类型的数据。
- en: The process of converting data objects into bits and bytes to store on a disk
    is called **serialization**; the reverse process is called **de-serialization**.
    Serialization on its own is a vast topic and is far from straightforward. Fortunately,
    as we are coming to expect, there is a class to handle most of the complexity
    for us.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据对象转换为位和字节以存储在磁盘上的过程称为**序列化**；反向过程称为**反序列化**。单独的序列化是一个广泛的主题，远非简单。幸运的是，正如我们所期望的那样，有一个类来处理大部分复杂性。
- en: What is JSON?
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON是什么？
- en: '**JSON** stands for **JavaScript Object Notation**, and it is widely used in
    fields beyond Android programming. It is perhaps more frequently used for sending
    data between web applications and servers.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON**代表**JavaScript对象表示法**，它在Android编程之外的领域被广泛使用。它可能更经常用于在Web应用程序和服务器之间发送数据。'
- en: Fortunately, there are JSON classes available for Android that almost entirely
    hide the complexity of the serialization process. By learning about a few more
    Kotlin concepts, we can quickly begin to use these classes and start writing entire
    Kotlin objects to the device storage, rather than worry ourselves about what primitive
    types make up the objects.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Android上有可用的JSON类几乎完全隐藏了序列化过程的复杂性。通过学习一些更多的Kotlin概念，我们可以快速开始使用这些类，并开始将整个Kotlin对象写入设备存储，而不必担心构成对象的原始类型是什么。
- en: The JSON classes, when compared with other classes we have seen so far, undertake
    operations that have a higher than normal possibility of failure beyond their
    control. To find out why this is so and what can be done about it, let's look
    at **exceptions**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们迄今为止看到的其他类相比，JSON类进行的操作有比正常情况下更高的可能性失败。要了解为什么会这样以及可以采取什么措施，让我们看看**异常**。
- en: Exceptions – try, catch, and finally
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常 - try、catch和finally
- en: 'All this talk of JSON requires us to learn another Kotlin concept: **exceptions**.
    When we write a class that performs operations that have a possibility of failure,
    especially for reasons beyond our control, it is advisable to make this plain
    in our code so that anyone using our class is prepared for the possibility.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些关于JSON的讨论都要求我们学习另一个Kotlin概念：**异常**。当我们编写执行可能失败的操作的类时，特别是由于我们无法控制的原因，建议在我们的代码中明确说明这一点，以便任何使用我们的类的人都能为可能性做好准备。
- en: Saving and loading data is one such scenario where failure is possible beyond
    our control. Think about trying to load data when the SD card has been removed
    or has been corrupted. Another instance where code might fail is perhaps when
    we write code that relies on a network connection – what if the user goes offline
    part of the way through a data transfer?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 保存和加载数据是一个可能发生失败的情况。想想当SD卡已被移除或已损坏时尝试加载数据。另一个可能失败的情况是，当我们编写依赖网络连接的代码时，如果用户在数据传输的过程中离线了会怎么样？
- en: Kotlin exceptions are the solution, and the JSON classes use them, so it is
    a good time to learn about them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin异常是解决方案，JSON类使用它们，所以现在是学习它们的好时机。
- en: When we write a class that uses code with a chance of failure, we can prepare
    the users of our class by using exceptions with `try`, `catch`, and `finally`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写使用有可能失败的代码的类时，我们可以通过使用`try`、`catch`和`finally`来准备我们类的用户。
- en: 'We can write functions in our classes using the @`Throws` annotation before
    the signature; a bit like this, perhaps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的类中使用`@Throws`注解来写函数，就像这样，也许：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, any code that uses `somePrecariousFunction` will need to **handle** the
    exception. The way that we handle exceptions is by wrapping code in `try` and
    `catch` blocks; perhaps like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何使用`somePrecariousFunction`的代码都需要**处理**异常。我们处理异常的方式是将代码包装在`try`和`catch`块中；也许像这样：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Optionally, we can also add a `finally` block if we want to take any further
    action after the `try` and `catch` blocks:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，在`try`和`catch`块之后，我们还可以添加一个`finally`块来采取进一步的行动：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In our Note to self app, we will take the minimum of necessary action to handle
    exceptions, and simply output an error to the logcat window, but you could do
    things such as notify the user, retry the operation, or put into operation some
    clever back-up plan.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的备忘录应用中，我们将采取最少的必要行动来处理异常，并简单地将错误输出到logcat窗口，但您可以做一些事情，比如通知用户，重试操作，或者实施一些聪明的备用计划。
- en: Backing up user data in Note to self
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份用户数据到备忘录
- en: So, with our new-found insight into exceptions, let's modify our Note to self
    code, and then we can be introduced to `JSONObject` and `JSONException`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有了我们对异常的新认识，让我们修改一下我们的备忘录代码，然后我们可以介绍`JSONObject`和`JSONException`。
- en: First, let's make some minor modifications to our `Note` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们对我们的`Note`类进行一些小修改。
- en: 'Add some more properties that will act as the key in a key-value pair for each
    aspect of our `Note` class:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些更多的属性，它们将作为我们的`Note`类的每个方面的键值对中的键：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, add a constructor and an empty default constructor that receives a `JSONObject`
    reference and throws a `JSONException` error. The body of the first constructor
    initializes each of the members that define the properties of a single `Note`
    object by calling the `getString` or `getBoolean` function of the `JSONObject`
    class, passing in the key as an argument. We also provide an empty constructor,
    which is required so that we can also create a `Note` object with uninitialized
    properties:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加一个构造函数和一个接收`JSONObject`引用并抛出`JSONException`错误的空默认构造函数。第一个构造函数的主体通过调用`JSONObject`类的`getString`或`getBoolean`函数并传入键作为参数来初始化单个`Note`对象的每个属性的成员。我们还提供了一个空构造函数，这是必需的，以便我们也可以创建一个未初始化属性的`Note`对象：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to import the `JSONException` and `JSONObject` classes:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要导入`JSONException`和`JSONObject`类：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next code we will see will load the property values of a given `Note` object
    into a `JSONObject` instance. This is where the `Note` object's values are packed
    up ready for when the actual serialization takes place.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将看到的代码将给定`Note`对象的属性值加载到`JSONObject`实例中。这是`Note`对象的值被打包准备好进行实际序列化的地方。
- en: 'All we need to do is call `put` with the appropriate key and the matching property.
    This function returns `JSONObject` (we will see where to in a minute) and also
    throws a `JSONObject` exception. Add the code we have just discussed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要使用适当的键和匹配的属性调用`put`函数。这个函数返回`JSONObject`（我们马上会看到在哪里），并且抛出一个`JSONObject`异常。添加我们刚刚讨论过的代码：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Now, let's make a `JSONSerializer` class, which will perform the actual serialization
    and deserialization. Create a new Kotlin class and call it `JSONSerializer`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`JSONSerializer`类，它将执行实际的序列化和反序列化。创建一个新的Kotlin类，命名为`JSONSerializer`。
- en: Let's split up the coding into a few chunks and talk about what we are doing
    as we code each chunk.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将编码分成几个块，并在编写每个块时讨论我们正在做什么。
- en: 'First, the declaration and a couple of properties: a `String` instance to hold
    the filename where the data will be saved, and a `Context` instance, which is
    necessary in Android for writing data to a file. Edit the `JSONSerializer` class
    code to be the same as the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，声明和一些属性：一个`String`实例来保存数据的文件名，以及一个`Context`实例，在Android中写入数据到文件是必要的。编辑`JSONSerializer`类的代码如下所示：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to import the `Context` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要导入`Context`类：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now we can start coding the real guts of the class. The `save` function is next.
    It first creates a `JSONArray` object, which is a specialized `ArrayList` class
    for handling JSON objects.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写类的真正核心部分。接下来是`save`函数。它首先创建一个`JSONArray`对象，这是一个专门处理JSON对象的`ArrayList`类。
- en: Next, the code uses a `for` loop to go through all the `Note` objects in `notes`
    and convert them to JSON objects using the `convertToJSON` function from the `Note`
    class that we added previously. Then, we load these converted `JSONObjects` into
    `jArray`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用`for`循环遍历`notes`中的所有`Note`对象，并使用我们之前添加的`Note`类的`convertToJSON`函数将它们转换为JSON对象。然后，将这些转换后的`JSONObject`加载到`jArray`中。
- en: 'Next, the code uses a `Writer` instance and an `Outputstream` instance combined
    to write the data to an actual file. Notice that the `OutputStream` instance needed
    the `Context` object. Add the code we have just discussed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，代码使用`Writer`实例和`Outputstream`实例组合将数据写入实际文件。注意，`OutputStream`实例需要`Context`对象。添加我们刚刚讨论过的代码：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to add the following import statements for these new classes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要为这些新类添加以下导入语句：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now for the de-serialization – loading the data. This time, as we might expect,
    the function has no parameters, but instead returns `ArrayList`. An `InputStream`
    instance is created using `context.openFileInput`, and our file containing all
    our data is opened.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在进行反序列化 - 加载数据。这次，正如我们所期望的那样，该函数没有参数，而是返回`ArrayList`。使用`context.openFileInput`创建一个`InputStream`实例，并打开包含所有数据的文件。
- en: 'We use a `for` loop to append all the data to a `String` object and use our
    new `Note` constructor, which extracts JSON data to regular properties to unpack
    each `JSONObject` into a `Note` object and add it to `ArrayList`, which is finally
    returned to the calling code. Add the `load` function:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`循环将所有数据追加到一个`String`对象中，并使用我们的新`Note`构造函数，将每个`JSONObject`解包为`Note`对象并将其添加到`ArrayList`中，最后将其返回给调用代码。添加`load`函数：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'You will need to add these imports:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加这些导入：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, all we need to do is put our new class to work in the `MainActivity` class.
    Add a new property after the `MainActivity` declaration as shown next. Also, remove
    the initialization of `noteList` to leave just the declaration, as we will now
    initialize it with some new code in the `onCreate` function. I have commented
    out the line you need to delete:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要在`MainActivity`类中让我们的新类开始工作。在`MainActivity`声明之后添加一个新属性，如下所示。此外，删除`noteList`的初始化，只留下声明，因为我们现在将在`onCreate`函数中使用一些新代码进行初始化。我已经注释掉了你需要删除的那行：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, in the `onCreate` function, we initialize `mSerializer` by calling the
    `JSONSerializer` constructor with the filename and `getApplicationContext()`,
    which is the `Context` instance of the application and is required. We can then
    use the `JSONSerializer load` function to load any saved data. Add this new highlighted
    code after the code that handles the floating action button. This new code must
    come before the code where we initialize the `RecyclerView` instance:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`函数中，我们通过使用文件名和`getApplicationContext()`调用`JSONSerializer`构造函数来初始化`mSerializer`，这是应用程序的`Context`实例，是必需的。然后我们可以使用`JSONSerializer
    load`函数来加载任何保存的数据。在处理浮动操作按钮的代码之后添加这段新的突出代码。这段新代码必须出现在我们初始化`RecyclerView`实例的代码之前：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I have shown a great deal of context in the previous code because its correct
    positioning is necessary for it to work. If you are having any problems getting
    this to work, be sure to compare it to the code in the download bundle in the
    `Chapter17/Note to self` folder.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中，我展示了大量的上下文，因为它的正确位置对其工作是必要的。如果你在使用过程中遇到任何问题，请确保将其与“Chapter17/Note to
    self”文件夹中的下载包中的代码进行比较。
- en: 'Now, add a new function to our `MainActivity` class so that that we can call
    it to save all our user''s data. All that this new function does is call the `save`
    function of the `JSONSerializer` class, passing in the required list of `Note`
    objects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们的`MainActivity`类中添加一个新函数，以便我们可以调用它来保存所有用户的数据。这个新函数所做的就是调用`JSONSerializer`类的`save`函数，传入所需的`Note`对象列表：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, we will override the `onPause` function to save our user''s data just
    as we did when saving our user''s settings. Be sure to add this code in the `MainActivity`
    class:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将重写`onPause`函数，以保存我们用户的数据，就像我们保存用户设置时所做的那样。确保在`MainActivity`类中添加这段代码：
- en: '[PRE39]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That's it. We can now run the app and add as many notes as we like. The `ArrayList`
    instance will store them all in our running app, our `RecyclerAdapter` will manage
    displaying them in the `RecyclerView` widget, and now JSON will take care of loading
    them from disk and saving them back to disk as well.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在我们可以运行应用程序，并添加尽可能多的笔记。`ArrayList`实例将把它们全部存储在我们的运行应用程序中，我们的`RecyclerAdapter`将管理在`RecyclerView`小部件中显示它们，现在JSON将负责从磁盘加载它们，并将它们保存回磁盘。
- en: Frequently asked questions
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q.1) I didn't understand everything in this chapter, so am I cut out to be a
    programmer?
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Q.1)我并没有完全理解本章的所有内容，那我适合成为程序员吗？
- en: A) This chapter introduced many new classes, concepts, and functions. If your
    head is aching a little, that is to be expected. If some of the detail is unclear,
    don't let it hold you back. Proceed with the next couple of chapters (they are
    much more straightforward), then revisit this one, and especially examine the
    completed code files.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: A) 本章介绍了许多新的类、概念和函数。如果你感到有些头痛，这是可以预料的。如果一些细节不清楚，不要让它阻碍你。继续进行下一章（它们要简单得多），然后回顾这一章，特别是检查已完成的代码文件。
- en: Q.2) So, how does serialization work in detail?
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Q.2)那么，序列化的详细工作原理是什么？
- en: 'A) Serialization really is a vast topic. It is possible to write apps your
    whole life and never really need to understand it. It is the type of topic that
    would be the subject of a computer science degree. If you are curious to know
    more, have a look at this article: [https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: A）序列化确实是一个广阔的话题。你可以一辈子写应用程序，而不真正需要理解它。这是一种可能成为计算机科学学位课程主题的话题。如果你想了解更多，请看看这篇文章：[https://en.wikipedia.org/wiki/Serialization](https://en.wikipedia.org/wiki/Serialization)。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: At this point in our journey through the Android API, it is worth taking stock
    of what we know. We can lay out our own UI designs, and can choose from a wide
    and diverse range of widgets to allow the user to interact. We can create multiple
    screens, as well as pop-up dialogs, and we can capture comprehensive user data.
    Furthermore, we can now make this data persist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过Android API的旅程中，现在值得回顾一下我们所知道的。我们可以制定自己的UI设计，并可以从各种各样的小部件中进行选择，以便让用户进行交互。我们可以创建多个屏幕，以及弹出对话框，并且可以捕获全面的用户数据。此外，我们现在可以使这些数据持久化。
- en: Certainly, there is a lot more to the Android API still to learn, even beyond
    what this book will teach you, but the point is that we know enough now to plan
    and implement a working app. You could get started on your own app right now.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Android API还有很多东西需要学习，甚至超出了这本书会教给你的内容，但关键是我们现在知道足够的知识来规划和实施一个可工作的应用程序。你现在就可以开始自己的应用程序了。
- en: If you have the urge to start your own project right away, then my advice is
    to go ahead and do it. Don't wait until you consider yourself "expert" or more
    ready. Reading this book and, more importantly, implementing the apps will make
    you a better Android programmer, but nothing will teach you faster than designing
    and implementing your own app! It is perfectly possible to read this book and
    work on your own project simultaneously.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有立即开始自己的项目的冲动，那么我的建议是继续前进并去做。不要等到你认为自己是“专家”或更加准备好了。阅读这本书，更重要的是，实施这些应用程序将使你成为更好的Android程序员，但没有什么比设计和实施自己的应用程序更能让你更快地学会。完全可以阅读这本书并同时在自己的项目上工作。
- en: In the next chapter, we will add the finishing touches to this app by making
    it multilingual. This is quite quick and easy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使应用程序支持多语言来为这个应用程序添加最后的修饰。这是相当快速和简单的。
