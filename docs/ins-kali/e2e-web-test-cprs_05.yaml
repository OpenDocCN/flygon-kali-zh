- en: '*Chapter 4*: Writing Your First Test'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：编写您的第一个测试'
- en: Before you start this chapter, you need to have an understanding of how Cypress
    tests are run, different Cypress commands, how to set up Cypress, running Cypress
    on the command line, and how to use the test runner to open Cypress tests. This
    information was covered in the first three chapters, and will help you better
    understand the fundamentals that we will be building on in this chapter when writing
    our first test.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本章之前，您需要了解Cypress测试的运行方式，不同的Cypress命令，如何设置Cypress，在命令行上运行Cypress以及如何使用测试运行器打开Cypress测试。这些信息在前三章中已经涵盖，将帮助您更好地理解我们在本章中编写第一个测试时所要建立的基础知识。
- en: In this chapter, we will cover the basics of creating test files and writing
    a basic test, before we move on and write more complicated tests and assert various
    elements using Cypress.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍创建测试文件和编写基本测试的基础知识，然后我们将继续编写更复杂的测试，并使用Cypress断言各种元素。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Creating test files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建测试文件
- en: Writing your first test
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写您的第一个测试
- en: Writing practical tests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写实用测试
- en: Cypress' auto-reload feature
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress的自动重新加载功能
- en: Cypress assertions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cypress断言
- en: By completing this chapter, you will be ready to learn how to debug running
    tests using the test runner.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通过完成本章，您将准备好学习如何使用测试运行器调试运行中的测试。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The GitHub repository for this chapter can be found at the following link:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的GitHub存储库可以在以下链接找到：
- en: '[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress](https://github.com/PacktPublishing/End-to-End-Web-Testing-with-Cypress)'
- en: The source code for this chapter can be found in the `chapter-04` directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在`chapter-04`目录中找到。
- en: Creating test files
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建测试文件
- en: All tests within Cypress must be within a test file for them to run. For a test
    to be considered useful, it must validate all the conditions that we have defined
    in the test and return a response stating whether the conditions have been met.
    Cypress tests are no exception to the process of writing tests, and all the tests
    that are written in a test file must have a set of conditions to be validated.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress中的所有测试必须在测试文件中才能运行。要使测试被认为是有用的，它必须验证我们在测试中定义的所有条件，并返回一个响应，说明条件是否已满足。Cypress测试也不例外，所有在测试文件中编写的测试都必须有一组要验证的条件。
- en: In this section, we will go through the process of writing a test file, starting
    from where a test file should be located in Cypress, different extensions that
    Cypress supports, and the file structures that test files written in Cypress should
    follow.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍编写测试文件的过程，从Cypress中测试文件应该位于的位置开始，Cypress支持的不同扩展名，以及Cypress中编写的测试文件应该遵循的文件结构。
- en: Testfiles location
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件位置
- en: Cypress creates test files by default when it is initialized in the `cypress/integration/examples`
    directory. However, these can be deleted as they are intended to show the proper
    format of utilizing different Cypress test types and assertions. Cypress allows
    you to be flexible when it comes to locating different modules and folder structures.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress在初始化时默认在`cypress/integration/examples`目录中创建测试文件。但是，这些文件可以被删除，因为它们旨在展示利用不同的Cypress测试类型和断言的正确格式。Cypress允许您在定位不同模块和文件夹结构时具有灵活性。
- en: 'It is recommended that when you''re working on your first project, you use
    the location mentioned in the previous paragraph to write your Cypress tests.
    To reconfigure the Cypress folder structures, you can change the Cypress default
    configuration and pass the new configuration into the `cypress.json` file. A good
    example of changing the default Cypress configuration would be to change our test
    directory from being located in `cypress/integration/examples to cypress/tests/todo-app`
    to elsewhere. To change the default directory, all we would need to do is change
    our `cypress.json` configuration, as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在您第一次项目中工作时，使用前面段落中提到的位置来编写您的Cypress测试。要重新配置Cypress文件夹结构，您可以更改Cypress默认配置并将新配置传递到`cypress.json`文件中。更改默认Cypress配置的一个很好的例子是将我们的测试目录从`cypress/integration/examples`更改为`cypress/tests/todo-app`或其他位置。要更改默认目录，我们只需要更改我们的`cypress.json`配置，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code block shows the `integrationFolder` setting, which changes
    how the Cypress `tests` dictionary is configured.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块显示了`integrationFolder`设置，它改变了Cypress `tests`字典的配置方式。
- en: Testfiles extensions
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件扩展名
- en: 'Cypress accepts different file extensions, which allows us to write tests that
    go beyond the normal JavaScript default format. The following file extensions
    are acceptable in Cypress tests:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress接受不同的文件扩展名，这使我们能够编写超出正常JavaScript默认格式的测试。以下文件扩展名在Cypress测试中是可接受的：
- en: '`.js`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.js`'
- en: '`.jsx`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.jsx`'
- en: '`.coffee`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.coffee`'
- en: '`.cjsx`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.cjsx`'
- en: In addition to these, Cypress also supports ES2015 out of the box and CommonJS
    modules, which makes it possible for us to use keywords such as **import** and
    **require** without any additional configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，Cypress还原生支持ES2015和CommonJS模块，这使我们可以在没有任何额外配置的情况下使用**import**和**require**等关键字。
- en: Testfile structure
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试文件结构
- en: 'Testfile structures in Cypress are similar to most of the other structures
    used to write tests or even normal JavaScript code. The structure of Cypress tests
    takes module imports and declarations into consideration, as well as the test
    body, which contains the tests. This can be seen in the following sample test
    file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress中的测试文件结构与大多数其他用于编写测试或甚至普通JavaScript代码的结构类似。Cypress测试的结构考虑了模块导入和声明，以及包含测试的测试主体。这可以在以下示例测试文件中看到：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, every test file needs to have the declarations at the top-most
    part of the test file. By doing this, the tests can be nested in the `describe`
    blocks, which specify the scope and the type of tests that will be run.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，每个测试文件都需要在测试文件的最顶部进行声明。通过这样做，测试可以嵌套在`describe`块中，这些块指定了将要运行的测试的范围和类型。
- en: Creating our test file
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的测试文件
- en: 'Using the GitHub link located in the *Technical requirements* section, open
    the `chapter-04` folder. Follow these steps to create your first test file:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*技术要求*部分中的GitHub链接，打开`chapter-04`文件夹。按照以下步骤创建您的第一个测试文件：
- en: Navigate to the `integration` folder directory located inside the Cypress directory.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Cypress目录内的`integration`文件夹目录。
- en: Create an empty test file called `sample.spec.js`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`sample.spec.js`的空测试文件。
- en: For the purposes of this demonstration, we have created a `package.json` file
    in the `chapter-04` root directory for you. All you need to do is run the commands
    without worrying about how they work for now.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示目的，我们已经在`chapter-04`根目录中为您创建了一个`package.json`文件。您现在只需要运行命令，不用担心它们的工作原理。
- en: Launch the Cypress test runner with the `npm run cypress:run` command.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm run cypress:run`命令启动Cypress测试运行器。
- en: Check the test runner preview and confirm that the test file we added is visible.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查测试运行器预览，并确认我们添加的测试文件是否可见。
- en: Now, it's time for a quick recap.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是快速回顾的时候了。
- en: Recap – creating test files
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结-创建测试文件
- en: In this section, we learned how to create test files, how Cypress accepts different
    test file formats, and how to change the default directory of Cypress tests. We
    also learned the structure of a test and how Cypress borrows the format of tests
    from languages such as JavaScript. In the next section, you will focus on writing
    your first test.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何创建测试文件，Cypress如何接受不同的测试文件格式，以及如何更改Cypress测试的默认目录。我们还学习了测试的结构，以及Cypress如何借鉴诸如JavaScript等语言的测试格式。在下一节中，您将专注于编写您的第一个测试。
- en: Writing your first test
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写您的第一个测试
- en: Cypress tests are no different than any other tests. As in all other tests,
    Cypress tests should pass when the expected result is consistent with what the
    application under test expects; it should fail when the expected result is not
    consistent with what the application should do. In this section, we will explore
    different types of tests, the structure of a test, and how Cypress understands
    the changes in a test file and reruns the tests. This section will also cover
    how to write practical tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress测试与任何其他测试没有区别。与所有其他测试一样，当预期结果与被测试应用程序的预期一致时，Cypress测试应该通过；当预期结果与应用程序应该执行的操作不一致时，测试应该失败。在本节中，我们将探讨不同类型的测试、测试的结构以及Cypress如何理解测试文件中的更改并重新运行测试。本节还将介绍如何编写实用测试。
- en: Example test
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例测试
- en: 'In this section, we will look at the basic structure of a Cypress test. This
    remains standard in most of the tests that we will write during the course of
    this chapter. The following test checks that what we expect and what is returned
    are equal to `true`. It should pass when we run it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下Cypress测试的基本结构。这在本章的大部分测试中保持标准。以下测试检查我们期望的结果和返回的结果是否等于`true`。当我们运行它时，它应该通过：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see that the test has `describe()` and `it()` hooks. The hooks
    included in the Cypress tests come bundled by default from the **Chai** assertion
    library, which Cypress uses as its default assertion library. The hooks are used
    to help you to understand the different stages of the tests. The `describe` hook
    helps encapsulate different tests into one block, while the `it` hook helps us
    identify specific tests within a test block.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到测试中有`describe()`和`it()`钩子。Cypress测试中包含的钩子默认来自**Chai**断言库，Cypress将其用作默认断言库。这些钩子用于帮助您理解测试的不同阶段。`describe`钩子帮助将不同的测试封装到一个块中，而`it`钩子帮助我们在测试块中识别特定的测试。
- en: Important Note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The Chai assertion library is included in the Cypress framework as a package.
    It is the default assertion library that Cypress uses to verify the success or
    failure of tests.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Chai断言库作为一个包包含在Cypress框架中。这是Cypress用来验证测试成功或失败的默认断言库。
- en: Considering the test we saw in this section, we will now explore the different
    types of test classification in Cypress.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们在本节中看到的测试，我们现在将探讨Cypress中不同类型的测试分类。
- en: Test classification
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试分类
- en: 'Tests can be classified into the results they yield after they''ve been run.
    Cypress tests can also be classified according to their states. The tests can
    be in any of the following states:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试可以根据运行后产生的结果进行分类。Cypress测试也可以根据它们的状态进行分类。测试可以处于以下任何状态：
- en: Passing
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过
- en: Failed
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败
- en: Skipped
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过
- en: We'll take a detailed look at these three categories in the next few sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将详细了解这三个类别。
- en: Passing tests
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过测试
- en: 'A passing test is a test that correctly validates the input by matching it
    with the expected output. In Cypress, passing tests are clearly marked as passed,
    and this is visible on the command log and the Cypress test runner. Using the
    `sample.spec.js` file that we created earlier, we can create our first passing
    test, as shown in the following code block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测试是正确验证输入是否与预期输出匹配的测试。在Cypress中，通过测试会被清晰地标记为通过，并且这在命令日志和Cypress测试运行器上是可见的。使用我们之前创建的`sample.spec.js`文件，我们可以创建我们的第一个通过测试，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To run the test while using the `chapter-04` directory as a reference, we can
    run the following command on the command-line interface:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要在使用`chapter-04`目录作为参考时运行测试，我们可以在命令行界面上运行以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In this test, we are verifying that the input given, `true`, is similar to
    the test output that we expect, which is also `true`. This test might not be very
    useful, but its purpose is to show a passing test. The following screenshot shows
    a passing test:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们正在验证给定的输入`true`是否与我们期望的测试输出`true`相似。这个测试可能并不是非常有用，但它的目的是展示一个通过的测试。以下截图显示了一个通过的测试：
- en: '![Figure 4.1 – Passing test'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1-通过测试'
- en: '](image/Figure_4.1_B15616.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1_B15616.jpg)'
- en: Figure 4.1 – Passing test
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 通过的测试
- en: The preceding screenshot shows the result of passing the test in the command
    log. We can further verify that the test passes all the other conditions by looking
    at the green checkmark in the top-left corner.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的截图显示了在命令日志中通过测试的结果。我们可以通过查看左上角的绿色复选标记进一步验证测试是否通过了所有其他条件。
- en: Failing tests
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 失败的测试
- en: 'Just like a passing test, a failing test also validates the test input against
    the test expectations and compares it to the result. A test failure occurs in
    the event that the expected result and the test input do not evaluate to the same
    thing. Cypress does a good job of displaying failing tests and describing what
    failed in the test. Using the same `sample.spec.js` file we created earlier, create
    a failing test, as shown in the following code block:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过的测试一样，失败的测试也验证测试输入与测试期望，并将其与结果进行比较。如果预期结果和测试输入不相等，则测试失败。Cypress在显示失败的测试并描述测试失败方面做得很好。使用我们之前创建的`sample.spec.js`文件，创建一个失败的测试，如下面的代码块所示：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To run the test , we will use the `chapter-0`4 directory as a reference, and
    then run the following command in the terminal:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行测试，我们将使用`chapter-04`目录作为参考，然后在终端中运行以下命令：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this failing test, we are comparing a test input of `true` to a test expectation
    of `false`, which leads to a failing test set to `true`, which is not equal to
    `false`. The test automatically fails as it does not pass the validation that
    determines that our test passed. The following screenshot shows the result of
    our failing test in the command log:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个失败的测试中，我们将一个`true`的测试输入与一个`false`的测试期望进行比较，这导致了一个设置为`true`的失败测试，它不等于`false`。由于它未通过确定我们的测试是否通过的验证，测试自动失败。以下截图显示了我们失败测试的结果在命令日志中：
- en: '![Figure 4.2 – Failing test'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – 失败的测试'
- en: '](image/Figure_4.2_B15616.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2_B15616.jpg)'
- en: Figure 4.2 – Failing test
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 失败的测试
- en: 'Looking at the command log, we can see that we have two tests: one that passes
    and one that fails. On the failing test, the Cypress command log shows the assertions
    that failed to meet our expectations. The test runner, on the other hand, goes
    ahead and shows us one failing test as a summary of our test run. When the test
    fails, Cypress allows us to read the exact exception that occurred. In this case,
    we can clearly see that the test failed at the assertion level due to an incorrect
    assertion.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 查看命令日志，我们可以看到我们有两个测试：一个通过，一个失败。在失败的测试中，Cypress命令日志显示了未满足我们期望的断言。另一方面，测试运行器继续显示一个失败的测试，作为我们测试运行的摘要。当测试失败时，Cypress允许我们阅读发生的确切异常。在这种情况下，我们可以清楚地看到测试在断言级别失败，原因是断言不正确。
- en: Skipped tests
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳过的测试
- en: 'Skipped tests in Cypress are not executed. Skipped tests are used to omit tests
    that are either failing or that do not need to run when other tests are being
    executed. Skipped tests are suffixed with the`.skip` keyword after their test
    hook. We can skip tests that are in a whole block by skipping the test block with
    `describe.skip` , or just skip a single test by using `it.skip`. The following
    code block shows two tests in which the main `describe` block is skipped and another
    test that is skipped inside the `describe` block. The following code illustrates
    different ways of skipping Cypress tests:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress中的跳过测试不会被执行。跳过测试用于省略那些要么失败要么不需要在执行其他测试时运行的测试。跳过测试在其测试钩子后缀为`.skip`关键字。我们可以通过使用`describe.skip`跳过整个代码块中的测试，或者通过使用`it.skip`跳过单个测试。以下代码块显示了两个测试，其中主`describe`块被跳过，另一个测试在`describe`块内被跳过。以下代码说明了跳过Cypress测试的不同方法：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we can see that we can skip either the whole code block or specific tests
    when we add`.skip` to either the `it` or `describe` hook. The following screenshot
    shows a skipped test:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到当我们在`it`或`describe`钩子中添加`.skip`时，我们可以跳过整个代码块或特定测试。以下截图显示了一个跳过的测试：
- en: '![Figure 4.3 – Skipped test'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 – 跳过测试'
- en: '](image/Figure_4.3_B15616.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3_B15616.jpg)'
- en: Figure 4.3 – Skipped test
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 跳过测试
- en: Skipped tests are just shown as skipped in the command log and in the test runner;
    no activity takes place for a test block or a single test that has been skipped.
    The preceding screenshot shows the state of the skipped tests defined in our `sample.spec.js`
    file, which can be found in our `chapter-04` GitHub repository directory. Now
    that we know how to write different types of tests, we can dive into writing practical
    tests. But first, let's test our knowledge.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过的测试在命令日志和测试运行器中只显示为跳过；对于已跳过的测试块或单个测试，不会发生任何活动。前面的截图显示了我们在`sample.spec.js`文件中定义的跳过测试的状态，该文件可以在我们的`chapter-04`GitHub存储库目录中找到。现在我们知道如何编写不同类型的测试，我们可以开始编写实际的测试。但首先，让我们测试一下我们的知识。
- en: Exercise on tests classification
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试分类练习
- en: 'Using the knowledge you''ve gained by reading this section of this chapter,
    write tests that meet the following criteria:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您在本章节阅读中获得的知识，编写符合以下标准的测试：
- en: A passing test that asserts that a variable is of the `string` type
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个通过的测试，断言一个变量是`string`类型
- en: A failing test that asserts a valid variable is equal to `undefined`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个失败的测试，断言一个有效的变量等于`undefined`
- en: A skipped test that checks whether a Boolean variable is `true`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个跳过的测试，检查布尔变量是否为`true`
- en: Now, let's recap what we've covered in this section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回顾一下本节我们所涵盖的内容。
- en: Recap – writing your first test
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结 – 编写您的第一个测试
- en: In this section, we learned how to identify different types of tests and looked
    at how the Cypress framework treats them. We learned what passing tests, failing
    tests, and skipped tests are. We also learned how the Cypress test runner displays
    the states of tests that have either passed, failed, or been skipped. Finally,
    we went through an exercise to test our knowledge of classifying tests. Now, let's
    move on to writing a practical test.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何识别不同类型的测试，并了解了Cypress框架如何处理它们。我们学习了通过测试、失败测试和跳过测试。我们还学习了Cypress测试运行器如何显示已通过、失败或已跳过的测试状态。最后，我们进行了一项练习，以测试我们对测试分类的知识。现在，让我们继续撰写一个实际的测试。
- en: Writing practical tests
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 撰写实际测试
- en: In the previous section, we went through the basics of understanding different
    classifications for tests in Cypress and what the results of the classifications
    are. In this section, we will focus on writing tests that go beyond asserting
    that a Boolean value is equal to another Boolean value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了Cypress中不同测试分类的基础知识以及分类结果。在本节中，我们将专注于编写超越断言布尔值是否等于另一个布尔值的测试。
- en: 'For any test to have value, it needs to have three fundamental phases:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何测试都需要有价值，它需要有三个基本阶段：
- en: Setting up the desired state of the application
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置应用程序的期望状态
- en: Executing the action to be tested
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行要测试的操作
- en: Asserting the state of the application after executed actions
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在执行操作后断言应用程序的状态
- en: 'In our practical tests, we will use our **Todo** application to write tests
    that correspond to the three fundamental phases required to write a meaningful
    test. To do this, we will complete the following steps:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际测试中，我们将使用我们的**Todo**应用程序来编写与编写有意义的测试所需的三个基本阶段相对应的测试。为此，我们将完成以下步骤：
- en: Visit the Todo application page.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问Todo应用程序页面。
- en: Search for an element.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索元素。
- en: Interact with the element.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与元素交互。
- en: Make an assertion on the application state.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对应用程序状态进行断言。
- en: These steps will guide the practical tests that we are about to write and will
    help us in having a the holistic view of Cypress tests.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤将指导我们即将撰写的实际测试，并将帮助我们全面了解Cypress测试。
- en: Visiting the Todo application page
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Todo应用程序页面
- en: 'This step involves visiting the Todo application page, which is where we will
    run our test. Cypress provides a built-in `cy.visit()` command for navigating
    to web pages. The following code block shows the steps we need to follow to visit
    our Todo page. This code block can be found in the `chapter-04` folder of this
    book''s GitHub repository, in the `practical-tests.spec.js` file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步涉及访问Todo应用程序页面，这是我们将运行测试的地方。Cypress提供了一个内置的`cy.visit()`命令用于导航到网页。以下代码块显示了我们需要遵循的步骤来访问我们的Todo页面。这个代码块可以在本书的GitHub存储库的`chapter-04`文件夹中的`practical-tests.spec.js`文件中找到：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When this test runs, upon observing the command log, we will see the `visit`
    command, as well as the application that we just visited in the Cypress application
    preview on the right, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当此测试运行时，在观察命令日志时，我们将看到`visit`命令，以及我们刚刚访问的应用程序在右侧的Cypress应用程序预览中，如下图所示：
- en: '![Figure 4.4 – Visiting the Todo application'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 访问Todo应用程序'
- en: '](image/Figure_4.4_B15616.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4_B15616.jpg)'
- en: Figure 4.4 – Visiting the Todo application
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 访问Todo应用程序
- en: Even though our application does not have any assertions, our test still passes
    as no error leading to the failure of our test has caused Cypress to throw an
    exception. Cypress commands are built to fail by default if they encounter an
    error, and this adds to the confidence we have when writing our tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们的应用程序没有任何断言，我们的测试仍然通过，因为没有导致Cypress抛出异常从而导致测试失败的错误。Cypress命令默认会在遇到错误时失败，这增加了我们在编写测试时的信心。
- en: Searching for an element
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索元素
- en: 'To make sure that Cypress performs some action in our application, we need
    to perform an action that will cause the application state to change. Here, we
    will search for a Todo application input element that is used to *add a Todo*
    item to our application. The following code block will search for the element
    that''s responsible for adding a new Todo item and verify that it is present in
    the URL we just navigated to:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Cypress在我们的应用程序中执行某些操作，我们需要执行一个会导致应用程序状态改变的操作。在这里，我们将搜索一个Todo应用程序输入元素，该元素用于*添加一个Todo*项目到我们的应用程序中。以下代码块将搜索负责添加新Todo项目的元素，并验证它是否存在于我们刚刚导航到的URL中：
- en: '[PRE9]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When the Cypress `cy.get()` command does not find the input element, an error
    will be thrown; otherwise, Cypress will pass the test. To get the input element,
    we do not need to verify that the element exists as Cypress already handles this
    using the **default assertions** that are chained in most Cypress commands.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当Cypress的`cy.get()`命令找不到输入元素时，将抛出错误；否则，Cypress将通过测试。要获取输入元素，我们不需要验证元素是否存在，因为Cypress已经使用大多数Cypress命令中链接的**默认断言**来处理这个问题。
- en: Important Note
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Default assertions in Cypress are built-in mechanisms that will cause a command
    to fail without the need for explicit assertions to be declared by the user. With
    these commands, Cypress takes care of the behavior of an exception if it's encountered
    while executing the said command.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress中的默认断言是内置机制，将导致命令失败，而无需用户声明显式断言。通过这些命令，Cypress会处理异常的行为，如果在执行该命令时遇到异常。
- en: 'The following screenshot shows Cypress searching for the Todo input element
    that is responsible for adding Todo items to our Todo list:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了Cypress搜索负责向我们的Todo列表添加Todo项目的Todo输入元素：
- en: '![Figure 4.5 – Searching for the Todo input element'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 搜索Todo输入元素'
- en: '](image/Figure_4.5_B15616.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5_B15616.jpg)'
- en: Figure 4.5 – Searching for the Todo input element
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 搜索Todo输入元素
- en: Here, we can verify that Cypress visited the Todo application URL, then checked
    that the input element that adds Todo items exists.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以验证Cypress访问了Todo应用程序的URL，然后检查添加Todo项目的输入元素是否存在。
- en: Interacting with the Todo input element
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与待办事项输入元素交互
- en: 'Now that we have confirmed we have an input element in our Todo application,
    it is time to interact with the application and change its state. To change the
    state of the Todo application, we will add a Todo item using the input element
    that we verified exists. Cypress chains commands together. To interact with our
    element, we will use the Cypress`.type()` command to send a string to the element
    and add the Todo item to the application state. The following code block will
    add a new Todo using the Todo input element:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确认我们的待办事项应用程序中有一个输入元素，是时候与应用程序进行交互并改变其状态了。为了改变待办事项应用程序的状态，我们将使用我们验证存在的输入元素添加一个待办事项。Cypress将命令链接在一起。为了与我们的元素交互，我们将使用Cypress的`.type()`命令向元素发送一个字符串，并将待办事项添加到应用程序状态中。以下的代码块将使用待办事项输入元素添加一个新的待办事项：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code block builds on the previous code and uses the Cypress `type()`
    function to add a new Todo. Here, we also invoked the `{enter}` argument of the
    Cypress `type` method to simulate the *Enter* key functionality since the Todo
    application does not have a submit button to click for us to add a new Todo item.
    The following screenshot shows the added Todo item. With this item, we can verify
    that our test was successfully able to add a new Todo item. This item is visible
    on the Todo list:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码块建立在之前的代码基础上，使用了Cypress的`type()`函数来添加一个新的待办事项。在这里，我们还调用了Cypress `type`方法的`{enter}`参数来模拟*Enter*键的功能，因为待办事项应用程序没有提交按钮供我们点击来添加新的待办事项。以下的截图显示了添加的待办事项。通过这个项目，我们可以验证我们的测试成功地添加了一个新的待办事项。这个项目在待办事项列表上是可见的：
- en: '![Figure 4.6 – Interacting with the Todo input element'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 – 与待办事项输入元素交互'
- en: '](image/Figure_4.6_B15616.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.6_B15616.jpg)'
- en: Figure 4.6 – Interacting with the Todo input element
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 – 与待办事项输入元素交互
- en: Our test runner shows that a new Todo has been created. Again our test passes,
    even without an assertion, since the commands that have been run have passed the
    default Cypress assertions. Now, we need to assert that the application state
    has changed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试运行器显示已创建了一个新的待办事项。再次，我们的测试通过了，即使没有断言，因为已运行的命令已经通过了默认的Cypress断言。现在，我们需要断言应用程序状态已经改变。
- en: Asserting the application state
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言应用程序状态
- en: 'Now that we''ve added our Todo, we need to assert that our new Todo item has
    been added and that the application state has changed due to the addition of the
    Todo item. To do this, we need to add an assertion once we''ve added our Todo
    item. In the following code block, we will assert our changes to the application
    state. Here, we have added an assertion to check that the`.Todo-list` class, which
    holds the list items, is equal to `2`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了我们的待办事项，我们需要断言我们的新待办事项已经被添加，并且应用程序状态已经因为添加待办事项而改变。为了做到这一点，我们需要在添加待办事项后添加一个断言。在下面的代码块中，我们将断言我们对应用程序状态的更改。在这里，我们添加了一个断言来检查`.Todo-list`类，它包含了列表项，是否等于`2`：
- en: '[PRE11]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To further validate our state changes, we can add more Todo items to verify
    that the number of items increases as we add Todo items.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步验证我们的状态更改，我们可以添加更多的待办事项来验证随着我们添加待办事项，待办事项的数量是否增加。
- en: 'In Cypress, we can use assertion functions such as `.should()` and `expect()`,
    which are bundled within the tools that make up Cypress. By default, Cypress extends
    all the functions that are in the Chai library, which is the default Cypress assertion
    library. The following screenshot shows two added Todo items and a confirmation
    note on the Cypress preview stating that the two added Todo items exist in the
    Todo list:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在Cypress中，我们可以使用断言函数，比如`.should()`和`expect()`，它们都包含在构成Cypress的工具中。默认情况下，Cypress扩展了Chai库中的所有函数，这是默认的Cypress断言库。下面的截图显示了两个已添加的待办事项和Cypress预览中的确认说明，说明这两个已添加的待办事项存在于待办事项列表中：
- en: '![Figure 4.7 – Asserting the application state'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 – 断言应用程序状态'
- en: '](image/Figure_4.7_B15616.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.7_B15616.jpg)'
- en: Figure 4.7 – Asserting the application state
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 – 断言应用程序状态
- en: 'In this test, we can verify that all the added Todos are visible on the Cypress
    app''s preview page and that our assertion passes. We can now add more assertions,
    specifically to check that the name of the first Todo is `New Todo` and that the
    other added Todo is called `Another Todo`. To do this, we will add more assertions
    to our test and check specific details of our Todo items. In the following code
    block, we will verify that Cypress can check the names of the added Todo items;
    that is, *New Todo* and *Another Todo*:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们可以验证所有添加的待办事项是否在Cypress应用程序的预览页面上可见，并且我们的断言通过了。现在我们可以添加更多的断言，特别是检查第一个待办事项的名称是否为`New
    Todo`，而另一个添加的待办事项是否叫做`Another Todo`。为了做到这一点，我们将在我们的测试中添加更多的断言，并检查我们的待办事项的具体细节。在下面的代码块中，我们将验证Cypress是否能够检查已添加的待办事项的名称；即*New
    Todo*和*Another Todo*：
- en: '[PRE12]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In these assertions, we have used the Cypress `cy.get()` method to find the
    elements using their CSS classes and then identified the first and last added
    Todo items by their text.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些断言中，我们使用了Cypress的`cy.get()`方法通过它们的CSS类来查找元素，然后通过它们的文本标识了第一个和最后一个添加的待办事项。
- en: Exercise on practical testing
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实际测试练习
- en: Using the GitHub repository link mentioned in the *Technical requirements* section,
    write a test that navigates to the Todo application and add three new Todo items
    to it. Write tests that check that the Todo items that have been added exist by
    verifying their values and their quantity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*技术要求*部分提到的GitHub存储库链接，编写一个测试，导航到待办事项应用程序并向其添加三个新的待办事项。编写测试来检查已添加的待办事项是否存在，通过验证它们的值和数量。
- en: Recap – writing practical tests
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结 – 编写实际测试
- en: In this section, we wrote our first practical test. Here, we visited a page,
    checked that the page had an input element, interacted with the element, and asserted
    that the application state changes. Having understood the flow of tests in Cypress,
    we can now move on and look at the features that make test writing interesting
    in Cypress, such as auto-reload.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们编写了我们的第一个实际测试。在这里，我们访问了一个页面，检查页面是否有一个输入元素，与该元素进行交互，并断言应用程序状态是否发生了变化。在了解了Cypress中测试的流程之后，我们现在可以继续并了解Cypress中使测试编写变得有趣的功能，比如自动重新加载。
- en: Cypress' auto-reload feature
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cypress的自动重新加载功能
- en: By default, Cypress watches for file changes and reloads the tests immediately
    when a file change is detected. This only happens if Cypress is running. The Cypress
    auto-reload feature comes in handy because you do not need to rerun the tests
    once you've made changes to their test files.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Cypress会监视文件更改，并在检测到文件更改时立即重新加载测试。这仅在Cypress运行时发生。Cypress的自动重新加载功能非常方便，因为您无需在对测试文件进行更改后重新运行测试。
- en: With the auto-reload feature, it is possible to have instant feedback and understand
    whether their changes were successful or whether their tests are failing. Due
    to this, this feature allows you to save time that would have otherwise been used
    for debugging tests or checking whether the changes that were made fixed the problem.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通过自动重新加载功能，可以立即获得反馈，并了解他们的更改是否成功，或者他们的测试是否失败。因此，这个功能可以节省本来用于调试测试或检查所做更改是否修复问题的时间。
- en: 'While Cypress'' auto-reload feature is enabled by default, you may opt to turn
    it off and manually rerun the tests after making a change. Cypress allows you
    to stop watching for file changes. This can either be done by configuring the
    `cypress.json` file or by using Cypress'' command-line configuration options.
    When using the `cypress.json` configuration file, the setting you must use to
    disable watching for file changes is as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Cypress的自动重新加载功能默认启用，但您可以选择关闭它，并在进行更改后手动重新运行测试。Cypress允许您停止监视文件更改。这可以通过配置`cypress.json`文件或使用Cypress的命令行配置选项来完成。在使用`cypress.json`配置文件时，您必须使用以下设置来禁用监视文件更改：
- en: '[PRE13]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This setting will persist and permanently disable file changes as long as Cypress
    is running, unless the configuration is altered or changed to `true`. The other
    option when it comes to disabling Cypress watching for the file changes is to
    use the command-line configuration option shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此设置将持续并永久禁用文件更改，只要Cypress正在运行，除非配置被更改为`true`。在禁用Cypress监视文件更改方面的另一个选项是使用此处显示的命令行配置选项：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With this command, Cypress will temporarily stop watching for file changes,
    and will only change this behavior when we stop the execution of Cypress on our
    terminal window. Cypress will then continue to watch for file changes and auto-reload
    whenever changes are made to a test file.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，Cypress将暂时停止监视文件更改，并且只有在我们在终端窗口停止Cypress执行时才会改变这种行为。然后Cypress将继续监视文件更改，并在对测试文件进行更改时自动重新加载。
- en: Recap – Cypress' auto-reload feature
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结 - Cypress的自动重新加载功能
- en: In this section, we learned how Cypress utilizes the auto-reload feature to
    watch for file changes and immediately reload and rerun when any changes take
    place in our test files. We also learned how to easily turn off the auto-reload
    feature in Cypress either by permanently disabling it using the `cypress.json`
    file or by passing the command in the command-line configuration when running
    our tests. Next, we will be looking at Cypress assertions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了Cypress如何利用自动重新加载功能来监视文件更改，并在测试文件发生任何更改时立即重新加载和重新运行。我们还学习了如何通过永久禁用它使用`cypress.json`文件或在运行测试时通过命令行配置传递命令来轻松关闭Cypress的自动重新加载功能。接下来，我们将看看Cypress断言。
- en: Cypress assertions
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cypress断言
- en: As we learned in the previous section, when writing our first test, assertions
    exist to describe the desired state of the application. Assertions in Cypress
    behave like guards to the tests in that they validate that the desired state and
    the present state are the same. Cypress assertions are unique as they are retried
    when Cypress commands are running until a timeout is reached or until an element
    is found.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中学到的，当编写我们的第一个测试时，断言存在是为了描述应用程序的期望状态。Cypress中的断言就像是测试的守卫，它们验证期望状态和当前状态是否相同。Cypress断言是独特的，因为它们在Cypress命令运行时会重试，直到超时或找到元素为止。
- en: Cypress assertions originate from the **chai**, **chai-jquery** and **sinon-chai**
    modules, which come bundled with the Cypress installation. Cypress also allows
    you to write custom assertions using the Chai plugins. However, in this section,
    we will focus on the default assertions that come bundled with Cypress, and not
    on the custom assertions that can be extended as plugins.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Cypress断言源自**chai**、**chai-jquery**和**sinon-chai**模块，这些模块与Cypress安装捆绑在一起。Cypress还允许您使用Chai插件编写自定义断言。但是，在本节中，我们将重点放在Cypress捆绑的默认断言上，而不是可以扩展为插件的自定义断言。
- en: 'We can write Cypress assertions in two ways: either by explicitly defining
    subjects or by implicitly defining subjects. Cypress recommends implicitly defining
    subjects in assertions as they are immediate to the element that the Cypress commands
    are working on. The following are how assertions are classified in the Cypress
    framework:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以两种方式编写Cypress断言：要么显式定义主题，要么隐式定义主题。Cypress建议在断言中隐式定义主题，因为它们与Cypress命令正在处理的元素直接相关。以下是Cypress框架中断言的分类方式：
- en: 'Implicit subjects: `.should()` or `.and()`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式主题：`.should()`或`.and()`
- en: 'Explicit subjects: `expect()`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式主题：`expect()`
- en: Let's look at each of them in detail.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一个。
- en: Implicit subjects
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式主题
- en: 'The `should` or `and` commands are Cypress commands, which means they can directly
    act on the immediately yielded subjects from Cypress. The commands can also be
    chained with other Cypress commands, which makes them easy to work with while
    at the same time guaranteeing an immediate response when invoking them. The following
    code block demonstrates how to test implicit subjects. Here, we will use the output
    of the `cy.get` command to make assertions in our test:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`should`或`and`命令是Cypress命令，这意味着它们可以直接作用于Cypress立即产生的主题。这些命令也可以与其他Cypress命令链接，这使它们易于使用，同时在调用它们时保证立即响应。以下代码块演示了如何测试隐式主题。在这里，我们将使用`cy.get`命令的输出来对我们的测试进行断言：'
- en: '[PRE15]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here, we are using the `should()`command to assert that the input element for
    the Todo items has a placeholder value. The `should` command is chained from the
    `cy.get()` command. This not only makes it easy to work with, but also reduces
    the amount of code that is required to assert that the placeholder is what it
    is. In the following code block, we are combining different assertions of an implicit
    subject that will be returned by the `cy.get` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`should()`命令来断言Todo项目的输入元素是否具有占位符值。`should`命令是从`cy.get()`命令链接的。这不仅使其易于使用，而且还减少了断言占位符是什么的代码量。在以下代码块中，我们正在组合`cy.get`命令返回的隐式主题的不同断言：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we have used the `.and()` Cypress command to further verify that the
    element that was just yielded has both a placeholder and a CSS class called `new-todo`.
    With these implicit assertions, we can verify that by using implicit subjects,
    we can chain off multiple commands from the same yielded response from Cypress,
    and also assert different items. The following code block shows code assertions
    that have been made by using explicit subjects where we have to declare each subject
    that we are asserting:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`.and()`Cypress命令来进一步验证刚刚产生的元素既有一个占位符，又有一个名为`new-todo`的CSS类。通过这些隐式断言，我们可以验证通过隐式主题，我们可以从Cypress的相同产生的响应中链接多个命令，并且还可以断言不同的项目。以下代码块显示了使用显式主题进行的代码断言，其中我们必须声明我们正在断言的每个主题：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, when using implicit subjects, we can make cleaner assertions
    and reduce the amount of code we write. In this code block, every assertion has
    to be on the same line and acted upon individually.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当使用隐式主题时，我们可以进行更清晰的断言，并减少我们编写的代码量。在这个代码块中，每个断言都必须在同一行上并且单独执行。
- en: Explicit subjects
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式主题
- en: 'We use `expect()` when we want to assert specific subjects that we define when
    running a test. Explicit subjects are common in **unit tests** and are great when
    there is a need to perform some logic before we perform the assertion or even
    have several assertions for the same subject. The following code block shows explicit
    subject assertion using the `expect` method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要断言在运行测试时定义的特定主题时，我们使用`expect()`。显式主题在**单元测试**中很常见，在需要在执行断言之前执行一些逻辑或者对同一主题进行多个断言时非常有用。以下代码块显示了使用`expect`方法进行显式主题断言：
- en: '[PRE18]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code block shows an explicit comparison of the instantiated `string` to
    our expectations. The declared `string` is an explicit subject, which means it
    can be asserted more than once and also manipulated before it performs the assertions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码块显示了对实例化的`string`与我们的期望进行显式比较。声明的`string`是一个显式主题，这意味着它可以被断言多次，并且在执行断言之前也可以被操作。
- en: 'For complex assertions, we can use the `.should()` method to assert explicit
    subjects. This allows a callback function to be passed with the subject that has
    been yielded as the first argument. We can add assertions inside the `should`
    function like so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的断言，我们可以使用`.should()`方法来断言显式主题。这允许传递一个回调函数作为第一个参数，该回调函数具有作为第一个参数产生的主题。我们可以在`should`函数内添加断言，如下所示：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we have visited the URL, then used the yielded element from `cy.get('new-todo')`
    to assert that a CSS class with the name `new-todo` exists. This test allows us
    to query for an element and also write different assertions for the subject as
    the need arises.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们访问了URL，然后使用从`cy.get('new-todo')`产生的元素来断言名为`new-todo`的CSS类是否存在。这个测试允许我们查询一个元素，并且根据需要为主题编写不同的断言。
- en: Exercise–implicit and explicit subjects
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习-隐式和显式主题
- en: Using the knowledge you've obtained from this section and by using the GitHub
    repository link mentioned in the *Technical requirements* section as a reference
    point, complete the following exercise.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您从本节中获得的知识，并使用*技术要求*部分提到的GitHub存储库链接作为参考点，完成以下练习。
- en: 'Navigate to the Todo application URL ([http://todomvc.com/examples/react/#/](http://todomvc.com/examples/react/#/))
    and add a Todo:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 转到Todo应用程序URL（[http://todomvc.com/examples/react/#/](http://todomvc.com/examples/react/#/)）并添加一个Todo：
- en: Write a test using implicit subject assertions to assert that the Todo has been
    added, and that the name you entered is the same name that is displayed on the
    Todo items list.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用隐式主题断言编写一个测试，以断言Todo已添加，并且输入的名称与Todo项目列表上显示的名称相同。
- en: On the Todo app URL, mark a Todo as completed. Then, using the explicit subject's
    assertion, write a test to verify that the completed Todo has been marked as completed.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Todo应用程序URL上，将一个Todo标记为已完成。然后，使用显式主题的断言，编写一个测试来验证已完成的Todo是否已标记为已完成。
- en: Recap – Cypress assertions
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结- Cypress断言
- en: In this section, we learned how to assert both explicit and implicit subjects
    and looked at how different and similar they are. We also learned that different
    assertion types can be used for different subjects. We then had the chance to
    carry out an exercise to practice our skills of asserting implicit and explicit
    subjects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何断言显式和隐式主题，并看了它们之间的不同和相似之处。我们还了解到不同的断言类型可以用于不同的主题。然后我们有机会进行练习，以练习我们断言隐式和显式主题的技能。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Summary
- en: In this chapter, we learned how to classify tests in Cypress by understanding
    what passing, failing, and skipped tests mean and how Cypress views and represents
    tests in the test runner and command log. We also learned about the structure
    of the test file and the acceptable file extensions for Cypress tests. We then
    wrote our first practical tests, which tested that a Todo application can add,
    delete, and mark a Todo as completed. The highlight of this chapter was learning
    how Cypress watches for file changes and how we can carry out our assertions in
    Cypress either by explicitly asserting our test subjects or implicitly asserting
    them. By completing this chapter, you know how to write a basic test in Cypress
    by working with elements and understanding the assertions that are available.
    In the next chapter, we will learn how to debug running tests in Cypress and the
    tools that we can use for that purpose.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过理解Cypress中的通过、失败和跳过测试的含义以及Cypress在测试运行器和命令日志中查看和表示测试来对测试进行分类。我们还了解了测试文件的结构以及Cypress测试的可接受文件扩展名。然后，我们编写了我们的第一个实际测试，测试了一个待办事项应用程序能够添加、删除和标记待办事项为已完成。本章的重点是学习Cypress如何监视文件更改以及我们如何在Cypress中进行断言，无论是通过显式断言我们的测试对象还是隐式断言它们。通过完成本章，您将了解如何通过使用元素并理解可用的断言来在Cypress中编写基本测试。在下一章中，我们将学习如何在Cypress中调试运行测试以及我们可以用于此目的的工具。
