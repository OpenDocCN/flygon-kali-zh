- en: Building an ASP.NET Core Music Library
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个ASP.NET Core音乐库
- en: This chapter marks a change in direction for us. In previous chapters, we concentrated
    on using TypeScript as our main development language. In this chapter, we are
    going to look at how we can use TypeScript inside Microsoft's ASP.NET Core in
    order to learn how to mix ASP.NET Core, C#, and TypeScript to make an artist-search
    program where we can search for musicians and retrieve details about their music.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章标志着我们的方向发生了变化。在之前的章节中，我们集中使用TypeScript作为我们的主要开发语言。在这一章中，我们将看看如何在Microsoft的ASP.NET
    Core中使用TypeScript，以学习如何混合ASP.NET Core、C#和TypeScript，制作一个艺术家搜索程序，我们可以搜索音乐家并检索有关他们音乐的详细信息。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Installing Visual Studio
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Visual Studio
- en: Understanding why we have ASP.NET Core MVC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们有ASP.NET Core MVC
- en: Creating an ASP.NET Core application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个ASP.NET Core应用程序
- en: Understanding why we have `Program.cs` and `Startup.cs`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们有`Program.cs`和`Startup.cs`
- en: Adding TypeScript support to an ASP.NET application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向ASP.NET应用程序添加TypeScript支持
- en: Using the `fetch` promise in TypeScript
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在TypeScript中使用`fetch` promise
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires .NET Core Framework version 2.1 or higher. The easiest
    way to install this framework is to download and install Visual Studio; Microsoft
    provides a fully functional Community Edition, which you can get at [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要.NET Core Framework版本2.1或更高版本。安装这个框架的最简单方法是下载并安装Visual Studio；微软提供了一个功能齐全的社区版，你可以在[https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/)获取。
- en: The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/Chapter10)下载。
- en: .NET applications don't tend to use `npm` to download packages; instead, they
    use NuGet to manage .NET packages. Building the source code will download the
    packages automatically.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: .NET应用程序通常不使用`npm`来下载包；相反，它们使用NuGet来管理.NET包。构建源代码将自动下载包。
- en: Introducing ASP.NET Core MVC
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ASP.NET Core MVC
- en: 'Microsoft has a long and relatively chequered history with web frameworks.
    I first started developing server-based applications back in the late 1990s with
    their **Active Server Pages** technology, now known as classic **ASP**. This technology
    allowed the developer to create dynamic web pages based on user requests and send
    the resulting web pages back to the client. This technology required a special
    **Internet Information Services** (**IIS**) plugin for it to work, so it was entirely
    Windows-based and was a strange mix of the proprietary VBScript language and HTML.
    This meant that we often saw code that looked like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 微软在Web框架方面有着悠久而相对坎坷的历史。我在20世纪90年代末开始开发基于服务器的应用程序，使用的是他们的**Active Server Pages**技术，现在被称为经典的**ASP**。这项技术允许开发人员根据用户请求创建动态网页，并将生成的网页发送回客户端。这项技术需要一个特殊的**Internet
    Information Services**（**IIS**）插件才能工作，因此它完全基于Windows，并且是专有的VBScript语言和HTML的奇怪混合。这意味着我们经常看到这样的代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The fact that the language was so verbose for mixing dynamic content with HTML,
    and the underlying types were not type-safe, meant that developing with ASP was
    particularly error-prone, and debugging was challenging, to say the least.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 语言非常冗长，用于将动态内容与HTML混合，底层类型不安全，这意味着使用ASP进行开发特别容易出错，调试也具有挑战性，至少可以这么说。
- en: The next step in the evolution of ASP was formally released in 2002 and was
    known as ASP.NET (or ASP.NET Web Forms). This was based on Microsoft's new .NET
    Framework and radically changed the way that we built web applications. Using
    this, we could build applications using languages such as C# or VB.NET and combine
    user controls in our web pages in order to create small self-contained components
    that slotted into our web pages. This was a great move on Microsoft's part, but
    there were still some fundamental issues that people spent a lot of time working
    around. The biggest issue was the fact that the web page was inherently mixed
    with the logic because the actual server-side implementation was handled using
    code behind. There was also a strict page compilation cycle, so the default architecture
    was based on the idea that there would be a round trip between the client and
    the server. Again, this could be worked around (and frequently was), but as a
    default architecture, it left a lot to be desired. Also, this technology was tied
    into the Windows platform, so it didn't get the reach that it could have. Even
    though .NET and C# were standardized so that other implementations could be created,
    Web Forms was a proprietary technology.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ASP演变的下一步正式发布于2002年，被称为ASP.NET（或ASP.NET Web Forms）。这是基于微软的新.NET框架，彻底改变了我们构建Web应用程序的方式。使用这个，我们可以使用C#或VB.NET等语言构建应用程序，并在我们的网页中组合用户控件，以创建小型的独立组件，可以插入我们的网页中。这是微软的一个很大的进步，但仍然存在一些根本性的问题，人们花了很多时间来解决。最大的问题是网页本质上与逻辑混合在一起，因为实际的服务器端实现是使用代码后台处理的。还有一个严格的页面编译周期，所以默认的架构是基于客户端和服务器之间会有一个往返。同样，这可以被解决（并经常被解决），但作为默认的架构，它还有很多不足之处。此外，这项技术与Windows平台绑定，因此它没有达到它本应有的影响力。尽管.NET和C#被标准化，以便可以创建其他实现，但Web
    Forms是一项专有技术。
- en: 'Recognizing the limitations of the Web Forms model, a team inside Microsoft
    decided to work on a form of ASP that would no longer be bound by the code-behind
    limitations of Web Forms. This was a major step forward because it opened the
    architecture up to developers so that they could follow object-oriented best practices
    better, including separation of concerns. All of a sudden, Microsoft had given
    developers a fighting chance of developing applications that followed SOLID design
    principles. This framework, known as ASP.NET MVC, allows us to develop applications
    following the **Model View Controller** (**MVC**) pattern. This is a powerful
    pattern because it allows us to separate code out into separate logical areas.
    MVC stands for the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到Web Forms模型的局限性，微软内部的一个团队决定研究一种形式的ASP，它将不再受限于Web Forms的代码后端限制。这是一个重大进步，因为它使架构对开发者更加开放，使他们能够更好地遵循面向对象的最佳实践，包括关注点分离。突然之间，微软给开发者提供了一个开发遵循SOLID设计原则的应用程序的机会。这个框架被称为ASP.NET
    MVC，它允许我们开发遵循**模型视图控制器**（MVC）模式的应用程序。这是一个强大的模式，因为它允许我们将代码分离到单独的逻辑区域中。MVC代表以下内容：
- en: '**Model**: This is the business layer that represents the logic that drives
    the behavior of the application'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：这是代表驱动应用程序行为的逻辑的业务层'
- en: '**View**: This is the display that the user sees'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是用户看到的显示'
- en: '**Controller**: This handles the inputs and interactions'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：这处理输入和交互'
- en: 'The following diagram shows the interactions in the MVC pattern:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了MVC模式中的交互：
- en: '![](assets/dc31160f-78d5-4ae0-8cde-bd36722bc352.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dc31160f-78d5-4ae0-8cde-bd36722bc352.png)'
- en: This architecture represents yet another major step forward for us when we want
    to develop full-stack web applications; however, it still suffers from the problem
    that it relies on Windows to host it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构对于我们想要开发全栈Web应用程序又是又一个重大进步；然而，它仍然存在一个问题，即它依赖于Windows来托管。
- en: Indirectly, from this diagram, we can work out that ASP.NET represents code
    that runs both on the client and on the server. This means that we don't need
    a server-side instance of Node running, so we can leverage the power and features
    of the .NET stack with this architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 间接地，从这个图表中，我们可以得出ASP.NET代表在客户端和服务器上都运行的代码。这意味着我们不需要运行服务器端的Node实例，因此我们可以利用.NET堆栈的功能和特性来构建这个架构。
- en: Something that came as a surprise to a lot of people was the fact that Microsoft
    began to shift its focus away from Windows—long considered a cash cow for the
    company—and moved toward a more open model where the operating system their applications
    ran on became much less important. This has reflected a shift in its core priorities
    where cloud operations, through their superlative Azure offerings, have very much
    become the focus. If Microsoft stayed with its web architecture as it stood, then
    it would be missing out on a lot of the opportunities that were opening up; therefore,
    it started a multi-year rearchitecting of .NET Framework to remove its reliance
    on Windows and to make it platform-agnostic for developers using it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让很多人感到惊讶的是，微软开始将注意力从长期以来被视为公司摇钱树的Windows转向更开放的模式，应用程序运行的操作系统变得不那么重要。这反映了其核心优先事项的转变，云操作，通过其出色的Azure产品，已经成为了重点。如果微软继续沿着原有的Web架构发展，那么它将错失许多正在开放的机会；因此，它开始了一个多年的.NET
    Framework重新架构，以消除对Windows的依赖，并使其对使用者来说是平台无关的。
- en: This has resulted in Microsoft releasing ASP.NET Core MVC, which removes the
    reliance on Windows altogether. From one code base, we can now target Windows
    or Linux. All of a sudden, the number of servers that we can host our code on
    has gone through the roof, and the cost of running the servers has potentially
    gone down. At the same time, with each successive version of Core that Microsoft
    releases, they are tuning and honing the performance to give considerable boosts
    in the request server statistics. Also, the fact that we can develop these applications
    for free, and target Linux hosting as well, means that this technology is a lot
    more exciting for start-ups. I thoroughly expect the number of start-ups getting
    on the ASP.NET Core MVC bandwagon to grow significantly over the next couple of
    years as cost barriers are reduced.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致微软发布了ASP.NET Core MVC，它完全消除了对Windows的依赖。现在，我们可以从一个代码库中同时针对Windows或Linux进行目标设置。突然之间，我们可以托管我们的代码的服务器数量激增，运行服务器的成本可能会下降。与此同时，随着微软发布的每个连续版本的Core，他们都在调整和优化性能，以在请求服务器统计数据中提供相当大的提升。此外，我们可以免费开发这些应用程序，并且也可以针对Linux进行托管，这意味着这项技术对初创公司来说更加令人兴奋。我完全期待，在未来几年，随着成本障碍的降低，加入ASP.NET
    Core MVC阵营的初创公司数量将显著增加。
- en: Providing the project overview
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供项目概述
- en: The project we are building in this chapter is quite different from any of the
    ones we have written so far. This project sees us moving away from pure TypeScript
    and toward working with mixed programming languages, namely C# and TypeScript,
    as we see how to incorporate TypeScript into an ASP.NET Core web application.
    The application itself uses the Discogs music API so that our users can search
    for artists and retrieve details of their discography and artwork. The search
    part is accomplished using pure ASP.NET with C#, while the artwork retrieval is accomplished
    using TypeScript.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们正在构建的项目与我们迄今为止编写的任何项目都大不相同。这个项目让我们远离了纯TypeScript，转而使用混合编程语言，即C#和TypeScript，我们将看到如何将TypeScript整合到ASP.NET
    Core Web应用程序中。该应用程序本身使用Discogs音乐API，以便用户可以搜索艺术家并检索其唱片和艺术作品的详细信息。搜索部分使用纯ASP.NET和C#完成，而艺术品检索则使用TypeScript完成。
- en: 'As long as you work alongside the code in the GitHub repository, this chapter
    should take about 3 hours to complete, which will not seem like much as we try
    out the code together! The finished application will look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您在GitHub存储库中与代码一起工作，本章应该需要大约3小时才能完成，当我们一起尝试代码时，这看起来不会太多！完成的应用程序将如下所示：
- en: '![](assets/18c8afb1-0dc6-460b-9a92-d52982b833a8.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18c8afb1-0dc6-460b-9a92-d52982b833a8.png)'
- en: So, let's get on with it!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: Getting started creating a music library with ASP.NET Core, C#, and TypeScript
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core，C#和TypeScript创建音乐库的入门
- en: I'm a big music fan. I have played guitar for years, which has led to me listening
    to a lot of musicians. Keeping track of all the music they have produced can be
    a very complex task, so I have long been interested in publicly available APIs
    that let us search for all things musician-related. The public API that I think
    provides us with the widest set of choices for querying for albums, artists, tracks,
    and more is the Discog library.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我是一个音乐迷。我弹吉他已经很多年了，这导致我听了很多音乐家的音乐。跟踪他们所创作的所有音乐可能是一个非常复杂的任务，所以我一直对公开可用的API感兴趣，让我们可以搜索所有与音乐家相关的事物。我认为提供给我们最广泛选择的查询专辑、艺术家、曲目等的公共API是Discog库。
- en: In this chapter, we are going to take advantage of this API and write an application
    that leverages ASP.NET Core in order to show you how we can use C# and TypeScript
    cooperatively.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将利用这个API，并编写一个应用程序，利用ASP.NET Core来展示我们如何可以协同使用C#和TypeScript。
- en: 'In order to run this application, you will need to set up an account at Discogs,
    as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个应用程序，您需要在Discogs上设置一个账户，如下所示：
- en: Start off at [https://www.discogs.com/users/create](https://www.discogs.com/users/create)
    and sign up for an account.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://www.discogs.com/users/create](https://www.discogs.com/users/create)开始注册一个账户。
- en: 'While we could create a Discogs API application if we wanted to, especially
    if we wanted to take advantage of features such as authentication and having access
    to the full API, all we need for our purposes is to generate a personal access
    token by clicking the Generate token button, as shown in the following screenshot:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们可以创建一个Discogs API应用程序，特别是如果我们想要利用身份验证和访问完整API等功能，但我们只需要通过点击生成令牌按钮来生成个人访问令牌，如下面的截图所示：
- en: '![](assets/ae659752-6d91-4511-8b26-011bcd220084.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ae659752-6d91-4511-8b26-011bcd220084.png)'
- en: Now that we have signed up to Discogs and generated our token, we are ready
    to create our ASP.NET Core application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经注册了Discogs并生成了我们的令牌，我们准备创建我们的ASP.NET Core应用程序。
- en: Creating our ASP.NET Core application with Visual Studio
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Visual Studio创建我们的ASP.NET Core应用程序
- en: In previous chapters, we created our applications from the command line. With
    Visual Studio, however, the normal practice is to create our application visually.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们是通过命令行创建我们的应用程序的。然而，使用Visual Studio，通常的做法是通过可视化方式创建我们的应用程序。
- en: 'Let''s see how this is done:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是如何完成的：
- en: 'Open Visual Studio and select Create a New Project to start the wizard for
    creating new projects. We are going to create an ASP.NET Core Web Application,
    as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并选择创建新项目以开始创建新项目的向导。我们将创建一个ASP.NET Core Web应用程序，如下所示：
- en: '![](assets/5d736ebb-0268-4a52-b701-eb8f29c3ade3.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5d736ebb-0268-4a52-b701-eb8f29c3ade3.png)'
- en: Older versions of .NET were only capable of running on Windows platforms. While
    .NET is an excellent framework, and C# is a wonderful language, this lack of cross-platform
    capability meant that .NET was only ever favored by companies with Windows desktops
    or Windows servers available. A while back, Microsoft decided to address this
    deficiency by stripping .NET back and rearchitecting it from the ground up as
    something that could run cross-platform. This has broadened the reach of .NET
    immensely and is known as .NET Core. What this means to us is that we can develop
    on one platform and deploy our application to another platform. Internally, .NET
    Core applications have platform-specific code that gets hidden behind a single
    .NET API so, for example, we can do file access without worrying about how the
    underlying operating system handles files.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 较早版本的.NET只能在Windows平台上运行。虽然.NET是一个很好的框架，C#是一种很棒的语言，但这种缺乏跨平台能力意味着.NET只受到拥有Windows桌面或Windows服务器的公司的青睐。一段时间以前，微软决定解决这个缺陷，通过将.NET剥离并重新架构成可以跨平台运行的东西。这极大地扩展了.NET的影响力，被称为.NET
    Core。对我们来说，这意味着我们可以在一个平台上开发，并将我们的应用程序部署到另一个平台上。在内部，.NET Core应用程序有特定于平台的代码，这些代码被隐藏在一个单一的.NET
    API后面，所以，例如，我们可以进行文件访问而不必担心底层操作系统如何处理文件。
- en: 'We need to choose where we are going to put our code. My local Git repository
    is based under `E:\Packt\AdvancedTypeScript3`, so targeting that as my location
    tells Visual Studio to create the necessary files in a folder under that directory.
    In this case, Visual Studio will create a solution called `Chapter10`, which will
    contain all of our files. Click Create to create all the files we need:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要选择我们将放置代码的位置。我的本地Git仓库位于`E:\Packt\AdvancedTypeScript3`下，所以将其作为我的位置告诉Visual
    Studio在该目录下的一个文件夹中创建必要的文件。在这种情况下，Visual Studio将创建一个名为`Chapter10`的解决方案，其中包含我们所有的文件。点击创建以创建所有我们需要的文件：
- en: '![](assets/bcb4038d-155f-4f8b-bd39-055f3290fbaa.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bcb4038d-155f-4f8b-bd39-055f3290fbaa.png)'
- en: 'Once Visual Studio has finished creating our solution, it should have the following
    files available. As we develop our application, we will discuss the more important
    files and look at how we can use them:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦Visual Studio完成创建我们的解决方案，应该会有以下文件可用。在我们开发应用程序的过程中，我们将讨论更重要的文件，并看看我们如何使用它们：
- en: '![](assets/85a99675-de30-4783-accb-81050be3a5aa.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/85a99675-de30-4783-accb-81050be3a5aa.png)'
- en: 'We can also build and run our application (pressing *F5* will do this), resulting
    in the application starting up like this:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以构建和运行我们的应用程序（按下*F5*即可），应用程序会像这样启动：
- en: '![](assets/20bd92b9-ec72-4549-a592-7bdd61b87d62.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/20bd92b9-ec72-4549-a592-7bdd61b87d62.png)'
- en: Having created our application, in the next section, we are going to cover the
    important points of the generated code, starting with the startup and program
    files before we start to amend it and bring in our search functionality.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了我们的应用程序后，在下一节中，我们将涵盖生成的代码的重要点，首先从启动和程序文件开始，然后再开始修改它并引入我们的搜索功能。
- en: Understanding the application structure
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解应用程序结构
- en: Behavior-wise, the starting point for our application is the `Startup` class.
    The purpose of this file is to set up the system during the startup process, so
    we take care of features such as configuring how cookies will be handled by our
    application and adding HTTP support. While this class is largely boilerplate in
    terms of functionality, we will come back to it later on in order to add support
    for the Discogs client we are going to write. The questions are, where does this
    functionality get called from? What actually starts our physical application?
    The answer to these questions is the `Program` class. If we quickly break this
    code down, we will see how the startup functionality is brought in and how it
    helps to build our hosting application.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 行为方面，我们应用程序的起点是`Startup`类。这个文件的目的是在启动过程中设置系统，因此我们要处理配置应用程序如何处理cookie以及添加HTTP支持等功能。虽然这个类在功能上大部分是样板代码，但我们以后会回来添加对我们即将编写的Discogs客户端的支持。问题是，这个功能是从哪里调用的？实际上是什么启动了我们的物理应用程序？这些问题的答案是`Program`类。如果我们快速分解这段代码，我们会看到启动功能是如何引入的，以及它如何帮助构建我们的托管应用程序。
- en: '.NET-executable applications start with a `Main` method. Sometimes, this is
    hidden from developers, but there is always one somewhere. This is the standard
    entry point for executable applications, and our web application is no different.
    This static method simply calls the `CreateWebHostBuilder` method, passing in
    any command-line arguments before calling Build and Run to build the host and
    run it:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: .NET可执行应用程序以`Main`方法开始。有时，这对开发人员是隐藏的，但总会有一个。这是可执行应用程序的标准入口点，我们的Web应用程序也不例外。这个静态方法简单地调用`CreateWebHostBuilder`方法，传入任何命令行参数，然后调用Build和Run来构建主机并运行它：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The use of `=>` here is not the same as using the fat arrow. What this does,
    in this particular context, is replace the `return` keyword, so if you have a
    method with a single `return` operation, this can be simplified. The equivalent
    code, complete with the `return` statement, would look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`=>`的使用方式不同于使用fat arrow。在这个特定的上下文中，它所做的是替换`return`关键字，所以如果你有一个只有一个`return`操作的方法，这可以简化。等效的代码，包括`return`语句，看起来像这样：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`CreateDefaultBuilder` is used to configure our service host with options such
    as setting up the Kestrel web engine, loading configuration information, and setting
    up logging support. The `UseStartup` method tells the default builder that our
    `Startup` class is the one that it needs to use to start the service.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateDefaultBuilder`用于配置我们的服务主机，设置Kestrel web引擎、加载配置信息和设置日志支持等选项。`UseStartup`方法告诉默认构建器，我们的`Startup`类是需要用来启动服务的。'
- en: The Startup class
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动类
- en: 'So, what does our `Startup` class actually look like? Well, in a similar fashion
    to the way we have been developing with TypeScript, C# starts with the class definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的`Startup`类实际上是什么样子的呢？嗯，在与我们使用TypeScript开发的方式类似的方式中，C#从类定义开始：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Unlike JavaScript, C# does not have a special `constructor` keyword. Instead,
    C# uses the name of the class to represent the constructor. Note that, just like
    JavaScript when we create our constructor, we don''t give it a return type (we''ll
    see how C# deals with return types shortly). Our constructor is going to receive
    a configuration entry to allow us to read the configuration. We expose this as
    a C# property using the following `get;` property:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与JavaScript不同，C#没有特殊的`constructor`关键字。相反，C#使用类的名称来表示构造函数。请注意，就像JavaScript一样，当我们创建构造函数时，我们不给它一个返回类型（我们很快就会看到C#如何处理返回类型）。我们的构造函数将接收一个配置条目，以允许我们读取配置。我们使用以下`get;`属性将其公开为C#属性：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the runtime starts up our host process, the `ConfigureServices` method
    is called. This is the point where we would hook in any services that we need;
    in this code, I've added an `IDiscogsClient`/`DiscogsClient` registration, which
    adds this particular combination to the IoC container so that we can inject it
    into other classes later on. We have already seen an example of the dependency
    injection happening in this class with the configuration being supplied to the
    constructor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时启动我们的主机进程时，将调用`ConfigureServices`方法。这是我们需要挂接任何服务的地方；在这段代码中，我添加了一个`IDiscogsClient`/`DiscogsClient`注册，这将这个特定组合添加到IoC容器中，以便我们以后可以将其注入到其他类中。我们已经在这个类中看到了依赖注入的一个例子，配置被提供给构造函数。
- en: 'Don''t worry that we haven''t seen `IDiscogsClient` and `DiscogsClient` yet.
    We will soon be adding the class and interface to our code. Here, we are registering
    them with the service collection so that they can be injected into classes automatically.
    As you may remember from what we said earlier in this book, a singleton will only
    give one instance of a class, regardless of where it is used. This is very similar
    to when we generated services in Angular, where we were registering the services
    as singletons:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心我们还没有看到`IDiscogsClient`和`DiscogsClient`。我们很快就会在我们的代码中添加这个类和接口。在这里，我们正在将它们注册到服务集合中，以便它们可以自动注入到类中。正如你可能还记得我们在本书前面所说的，单例将只给出一个类的实例，无论它在哪里使用。这与我们在Angular中生成服务时非常相似，我们在那里将服务注册为单例：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Something to note here is that the place where we set the return type differs
    from TypeScript. Like we saw in our TypeScript, we set the return type at the
    very end of the method declaration. With C#, the return type is set before the
    name so we know that `ConfigureServices` has a `void` return type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，设置返回类型的位置与TypeScript不同。就像我们在TypeScript中看到的那样，我们在方法声明的最后设置返回类型。在C#中，返回类型在名称之前设置，所以我们知道`ConfigureServices`有一个`void`返回类型。
- en: The syntax on `AddSingleton` shows that C# also supports generics, so the syntax
    should not be scary to us. While there is a lot of parity in the language, TypeScript
    has some interesting differences here in that there aren't dedicated `any` or
    `never` types, for instance. If we wanted our C# type to do something similar
    to `any`, it would have to use the `object` type instead.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSingleton`上的语法显示了C#也支持泛型，所以这个语法对我们来说不应该是可怕的。虽然语言中有很多相似之处，但TypeScript在这里有一些有趣的差异，例如没有专门的`any`或`never`类型。如果我们想让我们的C#类型做类似于`any`的事情，它将不得不使用`object`类型。'
- en: 'Now that the underlying services have been configured, the last step for this
    class is to configure the HTTP request pipeline. This simply means that this tells
    the application how to respond to HTTP requests. In this code, we can see that
    we already have support for static files enabled. This is very important for us
    because we are going to rely on static file support to hook our TypeScript (well,
    the compiled JavaScript version) so that it coexists with our C# application.
    We can also see that routing has been set up for our requests:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在基础服务已经配置好，这个类的最后一步是配置HTTP请求管道。这只是告诉应用程序如何响应HTTP请求。在这段代码中，我们可以看到我们已经启用了静态文件的支持。这对我们非常重要，因为我们将依赖静态文件支持来连接我们的TypeScript（编译后的JavaScript版本）以便与我们的C#应用程序共存。我们还可以看到我们的请求已经设置了路由：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It's all very well creating the C# infrastructure to fire up our application,
    but if we don't have anything to display, then we are wasting our time. It is
    time for us to look at the base files that are going to be served up.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 创建C#基础设施来启动我们的应用程序是很好的，但如果我们没有任何东西可以显示，那么我们就是在浪费时间。现在是时候看看将要提供的基本文件了。
- en: The files that make up the base views
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组成基本视图的文件
- en: 'The entry point for our view is the special `_ViewStart.cshtml` file. This
    file defines the common layout that the application will display. Rather than
    adding the contents to this file directly, we place the contents in a file called
    `_Layout.cshtml` and refer to this (minus the file extension) when setting the `Layout`
    file, like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们视图的入口是特殊的`_ViewStart.cshtml`文件。这个文件定义了应用程序将显示的通用布局。我们不直接向这个文件添加内容，而是将内容放在一个名为`_Layout.cshtml`的文件中，并在设置`Layout`文件时引用这个文件（去掉文件扩展名）。
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Files that end with `.cshtml` have a special meaning to ASP.NET. This tells
    the application that these files are a combination of C# and HTML, which the underlying
    engine will have to compile before serving the result to the browser. We should
    be very familiar with this concept by now, having seen similar behavior with both
    React and Vue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以`.cshtml`结尾的文件对ASP.NET有特殊的意义。这告诉应用程序这些文件是C#和HTML的组合，底层引擎在将结果提供给浏览器之前必须编译。我们现在应该对这个概念非常熟悉了，因为我们在React和Vue中看到了类似的行为。
- en: 'Now that we have covered the view entry point, we need to consider `_Layout`
    itself. The default ASP.NET implementation currently uses Bootstrap 3.4.1 so,
    as we go through this file, we''re going to make the necessary changes for using
    Bootstrap 4\. Let''s start with the header as it currently stands:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了视图入口，我们需要考虑`_Layout`本身。默认的ASP.NET实现目前使用的是Bootstrap 3.4.1，因此在浏览这个文件时，我们将进行必要的更改以使用Bootstrap
    4。让我们从当前的标题开始：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This header looks like a fairly normal header, but there are a few little quirks
    in it. In the title, we are picking up `Title` from `@ViewData`. We use `@ViewData`
    to transfer data between the controller and the view, so if we looked in the `index.cshtml`
    file (for instance), the top part of the file would say this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个标题看起来像一个相当正常的标题，但它有一些小小的怪癖。在标题中，我们从`@ViewData`中获取`Title`。我们使用`@ViewData`在控制器和视图之间传输数据，所以如果我们查看`index.cshtml`文件（例如），文件的顶部部分会这样说：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: What this section does, in combination with our layout, is set our `title` tag
    to `Home Page - Chapter 10`. The `@` symbol tells the compiler that ASP.NET's
    templating engine, called Razor, will have to do something with that piece of
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分与我们的布局结合起来，将我们的`title`标签设置为`Home Page - Chapter 10`。`@`符号告诉编译器ASP.NET的模板引擎Razor将对那段代码进行处理。
- en: The next part of our header splits the logic of what style sheets to include
    based on whether or not we are in the development environment. If we are running
    a development build, we get one set of files, whereas the release version gets
    the minified versions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们标题的下一部分根据我们是否处于开发环境来决定包含哪些样式表的逻辑。如果我们运行开发构建，我们会得到一组文件，而发布版本会得到压缩版本。
- en: 'We are going to simplify our header by serving up Bootstrap from the CDN, regardless
    of whether or not we are in development mode, and change our title slightly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过从CDN提供Bootstrap来简化我们的标题，而不管我们是否处于开发模式，并稍微改变我们的标题：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next section of our page layout is the `body` element. We are going to
    break this down section by section. Starting with the `body` element, we are going
    to look at the `navigation` element first:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们页面布局的下一个部分是`body`元素。我们将逐个部分地分解这个部分。从`body`元素开始，我们首先要看的是`navigation`元素：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is, by and large, a familiar `navigation` component (albeit in Bootstrap
    3 format). Converting the `navigation` component into Bootstrap 4 gives us the
    following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是一个熟悉的`navigation`组件（尽管是在Bootstrap 3格式中）。将`navigation`组件转换为Bootstrap 4，我们得到以下结果：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, the unfamiliar areas lie inside the `a` links. The `asp-controller` class
    links the view to the `controller` class; by convention, these class names expand
    out into `<<name>>Controller`, so `Home` becomes `HomeController`. There is an
    associated `asp-action`, which relates to the method inside the controller class
    that we will call. Clicking the `About` link will call the `About` method inside
    `HomeController.cs`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，不熟悉的地方在于`a`链接内部。`asp-controller`类将视图链接到`controller`类；按照惯例，这些类名会扩展成`<<name>>Controller`，所以`Home`变成了`HomeController`。还有一个相关的`asp-action`，它与控制器类内的方法相关联，我们将调用这个方法。点击`About`链接将调用`HomeController.cs`内的`About`方法：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method sets a message that will be written onto the `About` page, and then
    returns that view. ASP.NET is smart enough to use `View()` to work out that it
    should return the `About.cshtml` page for this because this is the `About` action.
    This is where we start to see the controller part join to the view part in MVC.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法设置一个消息，将被写入`About`页面，然后返回该视图。ASP.NET足够聪明，可以使用`View()`来确定它应该返回`About.cshtml`页面，因为这是`About`操作。这是我们开始看到MVC中控制器部分与视图部分的连接的地方。
- en: 'Getting back to the `_Layout` file, the next section that we are interested
    in is the following section, where we render in the body contents using `@RenderBody`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`_Layout`文件，我们感兴趣的下一部分是以下部分，在这里我们使用`@RenderBody`来渲染主体内容：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The view that we have chosen to display from our controller will be rendered
    at the point that `@RenderBody` is declared, so we can assume that the purpose
    of this command is to act as the placeholder to put the relevant view in. We are
    going to change this slightly to use our Bootstrap knowledge properly and to add
    a more meaningful footer. Consider the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择从我们的控制器显示的视图将在声明`@RenderBody`的地方呈现，因此我们可以假设此命令的目的是充当放置相关视图的占位符。我们将稍微更改此内容，以正确使用我们的Bootstrap知识并添加一个更有意义的页脚。考虑以下代码：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We don't need to cover the rest of this file because we really need to start
    looking at the model and the view we're going to render in, but please read the
    source code from GitHub and make the relevant JavaScript changes in this file
    so that you are using Bootstrap 4 in place of Bootstrap 3.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要覆盖此文件的其余部分，因为我们真的需要开始查看我们将要渲染的模型和视图，但请从GitHub阅读源代码，并在此文件中进行相关的JavaScript更改，以便您使用Bootstrap
    4代替Bootstrap 3。
- en: We are now ready to start writing the model part of our MVC code base. We will
    do this by writing the model that will send the request to the Discogs API and
    get and transform the results into something that can be sent to the client.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备开始编写MVC代码库的模型部分。我们将通过编写将请求发送到Discogs API并将结果转换为可以发送到客户端的内容的模型来实现这一点。
- en: Creating a Discogs model
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Discogs模型
- en: 'You will remember that we added a registration for an `IDiscogsClient` model earlier
    on. We hadn''t actually added any code at that point, so our application would
    fail to compile. We are now going to create the interface and implementation.
    `IDiscogClient` is a model, so we are going to create it inside our model directory.
    To create the interface and model in Visual Studio, we need to right-click on
    the `Models` folder to bring up a context menu. Inside the menu, select Add >
    Class.... The following screenshot shows this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 您会记得我们之前添加了一个`IDiscogsClient`模型的注册。在那时我们实际上还没有添加任何代码，所以我们的应用将无法编译。现在我们将创建接口和实现。`IDiscogClient`是一个模型，所以我们将在我们的模型目录中创建它。要在Visual
    Studio中创建接口和模型，我们需要右键单击`Models`文件夹以显示上下文菜单。在菜单中，选择添加 > 类....以下截图显示了这一点：
- en: '![](assets/9198f088-be82-4206-8dca-79a048b9574b.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9198f088-be82-4206-8dca-79a048b9574b.png)'
- en: 'This brings up the following dialog, where we can create the class or associated
    interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将弹出以下对话框，我们可以在其中创建类或相关接口：
- en: '![](assets/ed01a66f-f3f1-4f3a-b827-7314dfbd50f9.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ed01a66f-f3f1-4f3a-b827-7314dfbd50f9.png)'
- en: 'For the sake of brevity, we can create both the interface and the class definition
    inside the same file. I''ve separated them out in the GitHub code, but there''s
    no need to do that for our classes here. First, we have the interface definition,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们可以在同一个文件中创建接口和类定义。我已经在GitHub代码中将它们分开，但是我们在这里的类不需要这样做。首先，我们有以下接口定义：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The use of `Task<Results>` in our definition is similar to specifying a promise
    that returns a particular type in TypeScript. What we are saying here is that
    our method will run asynchronously and, at some point, it will return a `Results`
    type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义中使用`Task<Results>`的用法类似于在TypeScript中指定返回特定类型的promise。我们在这里所说的是，我们的方法将以异步方式运行，并且在某个时候将返回`Results`类型。
- en: Setting up the Results type
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Results类型
- en: 'The data that we get back from Discogs comes back as a hierarchy of fields.
    Ultimately, we want to have code in place that will convert and return the results,
    similar to the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从Discogs获取的数据以字段的层次结构返回。最终，我们希望有一些代码可以转换并返回结果，类似于以下内容：
- en: '![](assets/a888d2d8-cfc3-400b-af8a-9ae253f752e7.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a888d2d8-cfc3-400b-af8a-9ae253f752e7.png)'
- en: 'Behind the scenes, we are going to convert the JSON result from our call into
    a set of types. The top-level type is the `Results` type, which we are going to
    return out of our `GetByArtist` call. This hierarchy is shown in the following
    diagram:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们将把我们的调用的JSON结果转换为一组类型。顶层类型是`Results`类型，我们将从我们的`GetByArtist`调用中返回它。此层次结构显示在以下图表中：
- en: '![](assets/b034ce2f-3325-4270-8b03-ccc4d47191f6.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/b034ce2f-3325-4270-8b03-ccc4d47191f6.png)'
- en: 'In order to see what the mappings look like, we are going to build the `CommunityInfo`
    type from scratch. This class will be used in our `SearchResult` class to provide
    the community fields that we selected in the previous QuickWatch screenshot. Create
    a class called `CommunityInfo` and add the following line at the top of the file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看映射的样子，我们将从头开始构建`CommunityInfo`类型。这个类将在我们的`SearchResult`类中使用，以提供我们在之前的QuickWatch截图中选择的社区字段。创建一个名为`CommunityInfo`的类，并在文件顶部添加以下行：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are adding this line because there are features from here that we want to
    use; specifically, we want to use `JsonProperty` to map the name of a C# property
    onto one that is present in the JSON result. We have two fields that `CommunityInfo`
    needs to return—one that identifies how many people `want` the music title, and
    another that identifies how many people `have` it. We are going to follow standard
    C# naming conventions and use Pascal casing for property names (this means that
    the first letter is capitalized). Since the property name uses Pascal casing,
    we are going to use the `JsonProperty` attribute to map that name to the appropriate
    REST property name, so the `Want` property will be mapped to `want` in the result:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加这一行是因为我们想要使用这里的一些功能；具体来说，我们想要使用`JsonProperty`将C#属性的名称映射到JSON结果中存在的属性。我们有两个字段需要`CommunityInfo`返回——一个用于标识有多少人“想要”音乐标题，另一个用于标识有多少人“拥有”它。我们将遵循标准的C#命名约定，并使用Pascal大小写来命名属性（这意味着首字母大写）。由于属性名称使用Pascal大小写，我们将使用`JsonProperty`属性将该名称映射到适当的REST属性名称，因此`Want`属性将映射到结果中的`want`：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We aren't going to go through all the classes and properties. I would definitely
    recommend reading the GitHub code for more details, but this should definitely
    help to clarify what the project structure is.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算逐个讨论所有的类和属性。我绝对建议阅读GitHub代码以获取更多细节，但这肯定会有助于澄清项目结构是什么。
- en: Writing our DiscogsClient class
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的DiscogsClient类
- en: 'When we write our `DiscogsClient` class, we already have the contract that
    it will be based on, along with the interface definition. This tells us that our
    class starts off like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写`DiscogsClient`类时，我们已经有了它将基于的合同，以及接口定义。这告诉我们，我们的类开始如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The definition of our class looks slightly different to our interface because
    we didn't have to say that `GetByArtist` was `public` or that the method was `async`.
    When we use `async` in a method declaration, we are setting a compilation expectation
    that the method will have the `await` keyword inside it. This should be very familiar
    to us from our TypeScript use of `async`/`await`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类的定义看起来与我们的接口略有不同，因为我们不必说明`GetByArtist`是`public`，或者该方法是`async`。当我们在方法声明中使用`async`时，我们正在设置一个编译期望，即该方法将在其中具有`await`关键字。这对我们来说应该非常熟悉，因为我们在TypeScript中使用了`async`/`await`。
- en: 'When we call the Discogs API, it always starts off with the `https://api.discogs.com/` URL. In
    order to make life a little bit easier for us in our code base, we are going to
    define this as a constant in the class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用Discogs API时，它总是以`https://api.discogs.com/` URL开头。为了在我们的代码库中使生活变得更容易，我们将在类中将其定义为常量：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our class is going to talk to a REST endpoint. This means that we must be able
    to access HTTP from our code. In order to do this, our constructor will have a
    class that implements the `IHttpClientFactory` interface that''s been injected
    into it. The client factory will implement a pattern called the factory pattern
    to build an appropriate `HttpClient` instance for us to use when we need it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类将与REST端点进行通信。这意味着我们必须能够从我们的代码中访问HTTP。为了做到这一点，我们的构造函数将具有一个实现了`IHttpClientFactory`接口的类，该接口已经被注入其中。客户端工厂将实现一个称为工厂模式的模式，为我们构建一个适当的`HttpClient`实例，以便在需要时使用：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This rather strange-looking syntax in the constructor simply states that we
    are going to set the member variable with the HTTP client factory that we pass
    in. If the client factory is null, `??` means that the code falls through to the
    next statement, which will throw an exception stating that the argument is null.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数中的这种看起来相当奇怪的语法只是说明我们将使用传入的HTTP客户端工厂设置成员变量。如果客户端工厂为空，`??`表示代码将继续执行下一个语句，该语句将抛出一个声明参数为空的异常。
- en: 'So, what does our `GetByArtist` method look like? The first thing we want to
    do is check whether or not we have passed an artist into the method. If we haven''t,
    then we''re going to return an empty `Results` instance:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们的`GetByArtist`方法是什么样子的？我们首先要做的是检查我们是否已经将艺术家传递给了该方法。如果没有，那么我们将返回一个空的`Results`实例：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to create our HTTP request, we need to build our request address up.
    While we are building our address, we are going to append the path from `GetByArtist`
    with the `BasePath` string we defined as a constant. Suppose we wanted to search
    for `Peter O''Hanlon` as the artist. We would build up our search string so that
    we would escape the text that the user has entered to prevent dangerous requests
    from being sent; therefore, we would end up building an HTTP request string that
    looks like that shown at [https://api.discogs.com/database/search?artist=Peter
    O%27Hanlon&per_page=10](https://api.discogs.com/database/search?artist=Peter%20O%27Hanlon&per_page=10).
    We have limited the number of results to 10 in order to keep well within the Discogs
    request limit. We start with the helper method that appends the two strings together:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的HTTP请求，我们需要构建我们的请求地址。在构建地址的同时，我们将使用我们定义为常量的`BasePath`字符串与`GetByArtist`的路径进行连接。假设我们想要搜索`Peter
    O'Hanlon`作为艺术家。我们将构建我们的搜索字符串，以便转义用户输入的文本，以防止发送危险的请求；因此，我们最终会构建一个类似于[https://api.discogs.com/database/search?artist=Peter
    O%27Hanlon&per_page=10](https://api.discogs.com/database/search?artist=Peter%20O%27Hanlon&per_page=10)所示的HTTP请求字符串。我们限制结果数量为10，以保持在Discogs请求限制范围内。我们从辅助方法开始，将这两个字符串连接在一起：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'With the helper in place, we can build up the `GET` request. As we discussed
    previously, we need to change the artist so that potentially dangerous search
    terms are sanitized. With `Uri.EscapeDataString`, we have replaced the apostrophe
    in my name with its equivalent ASCII value of `%27`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有了辅助程序，我们可以构建`GET`请求。正如我们之前讨论的，我们需要更改艺术家，以便对潜在危险的搜索词进行消毒。使用`Uri.EscapeDataString`，我们已经用其等效的ASCII值`%27`替换了我的名字中的撇号：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'With the request created, we need to add a couple of headers to it. We need
    to add an `Authorization` token and a `user-agent` because Discogs is expecting
    to receive them. The `Authorization` token takes the format of `Discogs token=<<token>>`,
    where `<<token>>` is the token we created earlier when we signed up. The `user-agent`
    just needs to be something meaningful, so we set it to `AdvancedTypeScript3Chapter10`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 创建请求后，我们需要向其添加一些标头。我们需要添加一个`Authorization`令牌和一个`user-agent`，因为Discogs希望收到它们。`Authorization`令牌采用`Discogs
    token=<<token>>`的格式，其中`<<token>>`是我们在注册时创建的令牌。`user-agent`只需要是有意义的东西，所以我们将其设置为`AdvancedTypeScript3Chapter10`：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The final part of our puzzle is to use the factory to create `HttpClient`.
    When this has been created, we call `SendAsync` to send our request to the Discogs
    server. When this comes back, we read the `Content` response and when this comes
    back, we need to convert the type using `DeserializeObject`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谜题的最后一部分是使用工厂来创建`HttpClient`。创建后，我们调用`SendAsync`将我们的请求发送到Discogs服务器。当这个请求返回时，我们读取`Content`响应，然后需要使用`DeserializeObject`来转换类型：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we put this all together, our class looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把所有这些放在一起时，我们的类看起来是这样的：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We mentioned that there was a rate limit. What does that actually mean, though?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到了有一个速率限制。不过，这实际上是什么意思呢？
- en: Discogs rate limitations
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Discogs速率限制
- en: Discog limits the number of requests that can be issued from a single IP. For
    authenticated requests, Discog limits the rate of requests to 60 per minute. For
    unauthenticated requests, for most cases, the number of requests that can be sent
    is 25 per minute. The number of requests is monitored using a moving window.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Discog限制了可以从单个IP发出的请求数量。对于经过身份验证的请求，Discog将请求速率限制为每分钟60次。对于未经身份验证的请求，在大多数情况下，可以发送的请求数量为每分钟25次。请求的数量使用移动窗口进行监控。
- en: We have our Discogs API model written; now, it's time for us to look at wiring
    our model to our controller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了我们的Discogs API模型；现在，是时候让我们来看看如何将我们的模型连接到我们的控制器。
- en: Wiring up our controller
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接我们的控制器
- en: 'We are going to use the power of dependency injection to pass the Discogs client
    model that we just wrote in:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用依赖注入的强大功能来传递我们刚刚编写的Discogs客户端模型：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you may remember, when we were setting up the navigation, we set `asp-action`
    to `Index`. When we perform a search, our view is going to pass the search string
    over to `Index` and call the `GetByArtist` method. When we get the result of the
    search back, we set `ViewBag.Result` with the results list. Finally, we serve
    up `View`, which will be the `Index` page:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能记得的，当我们设置导航时，我们将`asp-action`设置为`Index`。当我们执行搜索时，我们的视图将把搜索字符串传递给`Index`并调用`GetByArtist`方法。当我们得到搜索结果时，我们将使用结果列表设置`ViewBag.Result`。最后，我们提供`View`，这将是`Index`页面：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: But what does our view look like? We now need to set up the `Index` view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的视图是什么样的？我们现在需要设置`Index`视图。
- en: Adding the Index view
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Index视图
- en: 'At the top of the file, we set the `ViewData` to `Title`. We saw what this
    did back when we looked at `_Layout.cshtml`, but it''s worth repeating that the
    value that we set here is used to help build the title in our master layout page.
    When we run our application, this sets the title to `Home Page - AdvancedTypeScript
    3 - Discogs`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部，我们将`ViewData`设置为`Title`。我们在查看`_Layout.cshtml`时看到了这样做的效果，但值得重复的是，我们在这里设置的值用于帮助构建我们主要布局页面的标题。当我们运行应用程序时，这将把标题设置为`主页
    - AdvancedTypeScript 3 - Discogs`：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The user interacts with our application through a search control. It''s time
    for us to add it in. We are going to add a `div` ID, which we will call `pageRoot`,
    that will contain a `form` element:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过搜索控件与我们的应用程序进行交互。是时候为它添加了。我们将添加一个名为`pageRoot`的`div` ID，其中将包含一个`form`元素：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Again, we can see that we are using the full power of ASP.NET to our advantage
    here. Our form is MVC-aware, so we tell it that we are using `HomeController`
    (remembering the conventions for controllers) by using `asp-controller`. We set
    the action to `Index`, so we are going to call the same `Index` method that we
    do when we navigate to this page. The reason that we can do this is that we still
    want to show the current page when we have finished searching so that the user
    can search for a different artist if necessary. Our `Index` method is clever enough
    to know whether or not we have passed a search string to trigger the search, so
    when the user triggers a search inside our form, the search string will be provided
    and this will trigger the search itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到我们在这里充分利用了ASP.NET的全部功能。我们的表单是MVC感知的，所以我们告诉它我们正在使用`HomeController`（记住控制器的约定）通过`asp-controller`。我们将操作设置为`Index`，因此我们将调用与导航到此页面时相同的`Index`方法。我们之所以能够这样做，是因为当我们完成搜索时，我们仍然希望显示当前页面，以便用户在必要时可以搜索不同的艺术家。我们的`Index`方法足够聪明，可以知道我们是否已经传递了搜索字符串来触发搜索，因此当用户在我们的表单内触发搜索时，将提供搜索字符串，这将触发搜索本身。
- en: 'Inside the form, we need to add an input search field and a button that triggers
    the `submit` form when pressed. The class elements in here are just used to make
    our `button` and `input` fields into Bootstrap versions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单内，我们需要添加一个输入搜索字段和一个按钮，按下按钮时触发`submit`表单。这里的类元素只是用来将我们的`button`和`input`字段转换为Bootstrap版本：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With this in place, this is what our search section looks like:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们的搜索部分看起来是这样的：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we were to run the application right now, we would see the following. If
    we were to enter the details of an artist and press the Search button, the search
    would be triggered, but no data would be displayed on the screen:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行应用程序，我们会看到以下内容。如果我们输入艺术家的详细信息并按下搜索按钮，搜索将被触发，但屏幕上不会显示任何数据：
- en: '![](assets/526284b7-2120-4e9f-aecb-d84bc373a14e.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/526284b7-2120-4e9f-aecb-d84bc373a14e.png)'
- en: 'Now that we have search results coming back, we need to get the result out
    of the `ViewBag` that we added our result to. It''s easy to become confused by `ViewBag`
    and `ViewData`, so it''s worth talking about these for a second as they both serve
    the same purpose of bidirectionally passing data between the controller and the
    view, only slightly differently:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了搜索结果返回，我们需要从`ViewBag`中获取我们添加结果的结果。很容易被`ViewBag`和`ViewData`搞混，所以值得花点时间来谈谈它们，因为它们都有同样的目的，即在控制器和视图之间双向传递数据，只是略有不同：
- en: When we added the results of the search, we set this as `ViewBag.Result`. If
    we were to take a look at the source code for `ViewBag`, though, we wouldn't actually
    find a property called **Result**. The reason for this is down to the fact that `ViewBag`
    is dynamic; in other words, it allows us to create arbitrary values that can be
    shared between the controller and the view, which can be called anything. In general,
    using `ViewBag` is a reasonable option, but since it is dynamic, it does not have
    the benefit of the compiler detecting whether or not there are errors, so it's
    vital that you make sure that the property you set in the controller is given
    exactly the same name as the property you set in the view.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们添加搜索结果时，我们将其设置为`ViewBag.Result`。但是，如果我们看一下`ViewBag`的源代码，我们实际上找不到一个名为**Result**的属性。这是因为`ViewBag`是动态的；换句话说，它允许我们创建可以在控制器和视图之间共享的任意值，可以被称为任何东西。一般来说，使用`ViewBag`是一个合理的选择，但由于它是动态的，它没有编译器检测是否存在错误的好处，所以你必须确保在控制器中设置的属性与在视图中设置的属性完全相同。
- en: '`ViewData`, however, relies on the use of a dictionary (similar to `map` in
    TypeScript), where we potentially have a number of key/value pairs holding the
    data. Internally, the value is an object, so this would have implications if we
    were setting the value in the view and passing it back to the controller as we
    would have to cast the object to the appropriate type. The effect of this is that
    setting `ViewBag.Counter = 1` in the view means that we could treat `ViewBag.Counter`
    as an integer directly in our controller, but setting `ViewData["Counter"] = 1`
    in the view means we would have to cast `ViewData["Counter"]` to an integer before
    we could do anything with it. The cast would look something like this:'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewData`，然而，依赖于使用字典（类似于TypeScript中的`map`），在这里我们可能有许多键/值对持有数据。在内部，值是一个对象，所以如果我们在视图中设置值并将其传递回控制器，我们必须将对象转换为适当的类型。这样做的效果是，在视图中设置`ViewBag.Counter
    = 1`意味着我们可以直接在控制器中将`ViewBag.Counter`视为整数，但在视图中设置`ViewData["Counter"] = 1`意味着我们必须将`ViewData["Counter"]`转换为整数，然后才能对其进行任何操作。转换看起来像这样：'
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For our purposes, we could have used either approach because the responsibility
    for setting the result lies with our controller, but I''m happy going with `ViewBag`
    to set our result. So, how do we go about adding the data in? We know that our
    `Index` page is a `.cshtml` file, so we can mix C# and HTML together. The way
    we denote the C# section is to use `@{ }`, so in order to render out the results,
    we need to check that there is a value in `ViewBag.Result` (note that C# uses
    `!=`, instead of the JavaScript format of `!==`, to test that the result is not
    null). The code that we write to render our result out starts off like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们可以使用任一种方法，因为设置结果的责任在于我们的控制器，但我很高兴使用`ViewBag`来设置我们的结果。那么，我们如何添加数据呢？我们知道我们的`Index`页面是一个`.cshtml`文件，所以我们可以混合C#和HTML在一起。我们使用`@{
    }`来表示C#部分，所以为了呈现结果，我们需要检查`ViewBag.Result`中是否有值（请注意，C#使用`!=`，而不是JavaScript格式的`!==`，来测试结果是否为空）。我们编写的代码以这样开始呈现我们的结果：
- en: '[PRE35]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Inside our result, we are going to create a Bootstrap table, with `Title` and
    `Artwork` as two columns. The HTML markup of the table that we''re going to build
    starts off like this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的结果中，我们将创建一个Bootstrap表格，其中`Title`和`Artwork`作为两列。我们要构建的表的HTML标记从这里开始：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Inside our table body (`tbody`), we are going to have to loop over each item
    in our result and write the relevant value out. The first thing that we have to
    do is create a variable called `index`. We are going to put this in place now,
    in anticipation of the point where we need to add an image with a unique name
    (we'll cover that in the next section).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表体（`tbody`）中，我们将不得不循环遍历我们结果中的每一项，并将相关值写出。我们首先要做的是创建一个名为`index`的变量。我们现在要把这个放在这里，预期到需要添加一个带有唯一名称的图像的地方（我们将在下一节中介绍）。
- en: 'Next, we are going to use `foreach` to iterate over every item in `ViewBag.Result`.
    For each item, we are going to create a new table row using `<tr></tr>` and, inside
    the row, we will write out two table data cells (`<td></td>`) containing the title
    and the resource URL, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`foreach`来遍历`ViewBag.Result`中的每一项。对于每个项目，我们将创建一个新的表行使用`<tr></tr>`，在行内，我们将写出两个表数据单元（`<td></td>`）包含标题和资源URL，如下所示：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run our application now, we will get results back, and these results
    will be written to the table:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，我们将得到结果，并且这些结果将被写入表格：
- en: '![](assets/9d86fad7-40fa-4989-b355-9d11eec98f78.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9d86fad7-40fa-4989-b355-9d11eec98f78.png)'
- en: Obviously, the artwork element is wrong. That's not a picture, so we need to
    put something in place to go off and retrieve the pictures themselves, which requires
    our code to make another REST call for each result. We want this to happen when
    the results have been returned, so we are going to turn to client-side functionality
    now when we see how we can leverage TypeScript to get the image results for us.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，艺术品元素是错误的。那不是一张图片，所以我们需要放置一些东西去检索图片本身，这需要我们的代码为每个结果进行另一个REST调用。我们希望这发生在结果返回后，所以当我们看到如何利用TypeScript为我们获取图像结果时，我们现在将转向客户端功能。
- en: Adding TypeScript to our application
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的应用程序添加TypeScript
- en: 'The starting point for our TypeScript—pretty much as always—is our `tsconfig.json`
    file. We are going to create this to be as slimline as possible. We are going
    to set this particular `outDir` here because the creation of our project set a
    number of files in `wwwroot`. In the `wwwroot/js` folder, ASP.NET has already
    created a `site.js` file, so we are going to target our script to live alongside
    it:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们TypeScript的起点——几乎总是——是我们的`tsconfig.json`文件。我们将尽可能地使其精简。我们将在这里设置特定的`outDir`，因为我们的项目创建了一些文件在`wwwroot`中。在`wwwroot/js`文件夹中，ASP.NET已经创建了一个`site.js`文件，所以我们将把我们的脚本定位到与它并存：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We are going to use a single method to call the Discogs API to retrieve the
    relevant image. We aren't going to rely on any TypeScript packages loaded from
    an external source to make our API call because JavaScript provides us with the
    `fetch` API, which allows us to make REST calls without any dependencies.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个单一的方法调用Discogs API来检索相关的图像。我们不会依赖于从外部来源加载的任何TypeScript包来进行我们的API调用，因为JavaScript为我们提供了`fetch`
    API，允许我们在没有任何依赖关系的情况下进行REST调用。
- en: We start off by adding a file called `discogHelper.ts`, which will contain the
    function we are going to call from our ASP.NET application. The reason we are
    adding this as a TypeScript method is that we want this to run on the client,
    rather than on the server side. This decreases the time taken to get the initial
    results loaded onto the client screen because we are going to let the client fetch
    and asynchronously load the images for us.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个名为`discogHelper.ts`的文件，其中包含我们将从ASP.NET应用程序中调用的函数。我们添加这个作为TypeScript方法的原因是，我们希望它在客户端上运行，而不是在服务器端。这样可以减少将初始结果加载到客户端屏幕上所需的时间，因为我们将让客户端为我们获取并异步加载图像。
- en: 'The signature of our function looks like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的函数的签名看起来像这样：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `RequestInfo` parameter will accept the URL of the image request on the
    server. This follows the fact that Discog does not return full details about a
    particular music title, so the album artwork is not available at this point. Instead,
    it returns the REST call that we have to make to retrieve the full details, which
    we can then parse out to retrieve the artwork. For example, Steve Vai's Passion
    and Warfare album information returns the `ResourceUrl` of the [https://api.discogs.com/masters/44477](https://api.discogs.com/masters/44477) link.
    That becomes the URL that we pass in as our `request` to retrieve the full details,
    including the artwork.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestInfo`参数将接受服务器上图像请求的URL。这是因为Discog并不返回有关特定音乐标题的完整详细信息，因此在这一点上专辑封面不可用。相反，它返回了我们必须进行的REST调用，以检索完整详细信息，然后我们可以解析出来检索封面。例如，Steve
    Vai的Passion and Warfare专辑信息返回了[https://api.discogs.com/masters/44477](https://api.discogs.com/masters/44477)链接的`ResourceUrl`。这成为我们传递给`request`的URL，以检索包括封面在内的完整详细信息。'
- en: The second parameter that we accept is the `id` of the `img` object. When we
    iterate over our initial search results to build the table of results, as well
    as add the album title, we also include a uniquely identified image, which we
    pass into our function. This allows us to dynamically update `src` when we have
    finished retrieving details about the album. Sometimes, this can lead to an amusing
    effect in the client because some albums take longer to retrieve than others,
    so it is entirely possible that the list of images updates out of sequence, meaning
    that later images are populated sooner than earlier ones. This is nothing to worry
    about because we are deliberately doing this to show that our client code is truly
    asynchronous.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接受的第二个参数是`img`对象的`id`。当我们遍历初始搜索结果来构建结果表时，我们还包括一个唯一标识的图像，将其传递给我们的函数。这允许我们在完成检索有关专辑的详细信息后动态更新`src`。有时，这可能会导致客户端出现有趣的效果，因为有些专辑的检索时间比其他专辑长，所以很可能图像列表的更新顺序不一致，这意味着后面的图像比前面的图像更早地填充。这并不是什么大问题，因为我们故意这样做是为了显示我们的客户端代码确实是异步的。
- en: If we really wanted to worry about making our images display sequentially, we
    would change our function to accept an array of requests and image placeholders,
    issue our calls, and only update the images once all the REST calls had finished.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想要担心让我们的图像按顺序显示，我们会改变我们的函数来接受一个请求和图像占位符的数组，发出我们的调用，并且只有在所有REST调用完成后才更新图像。
- en: 'Unsurprisingly, the `fetch` API uses a promise called `fetch` for us to make
    our call. This accepts the request and, optionally, a `RequestInit` object that
    allows us to pass custom settings to our call, including the HTTP verb we want
    to apply and any headers we want to set:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`fetch` API使用了一个名为`fetch`的promise来进行我们的调用。这接受请求，以及一个`RequestInit`对象，允许我们传递自定义设置到我们的调用中，包括我们想要应用的HTTP动词和我们想要设置的任何标头：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Guess what? We are using the same `authorization` and `user-agent` headers here
    that we set in the C# code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜看？我们在这里使用了与C#代码中设置的相同的`authorization`和`user-agent`标头。
- en: 'We have already said that the `fetch` API is promise-based, so we can rightly
    expect that the `fetch` call waits to complete before it returns the result. In
    order to get our image, we are going to perform a couple of transformations. The
    first transformation is to convert the response into a JSON representation:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过`fetch` API是基于promise的，所以我们可以合理地期望`fetch`调用在返回结果之前等待完成。为了获取我们的图像，我们将执行一些转换。第一个转换是将响应转换为JSON表示：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The conversion operation is asynchronous, so the next stage of our transformation
    can occur in its own `then` block as well. At this point, if all has gone well,
    we should have a response body. We retrieve the `HTMLImageElement` using the image
    ID that we passed into our function. If this is a valid image, then we set `src`
    to the first `uri150` result we get back, which gives us the address of the 150
    x 150 px image from the server:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 转换操作是异步的，所以我们的转换的下一个阶段也可以在自己的`then`块中发生。此时，如果一切顺利，我们应该有一个响应主体。我们使用我们传递给函数的图像ID来检索`HTMLImageElement`。如果这是一个有效的图像，那么我们将`src`设置为我们收到的第一个`uri150`结果，这给我们了来自服务器的150
    x 150像素图像的地址：
- en: '[PRE42]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Putting this all together, our search function looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们的搜索函数看起来像这样：
- en: '[PRE43]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Discogs allows us to issue JSONP requests, which means that we have to pass
    a callback query string parameter. In order to issue a JSONP request, we would
    have to install the Fetch JSONP package from [https://github.com/camsong/fetch-jsonp](https://github.com/camsong/fetch-jsonp).
    This requires changing the signature of the `fetch` call to `fetchJsonp` instead.
    Apart from that, the rest of our functions look the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Discogs允许我们发出JSONP请求，这意味着我们必须传递一个回调查询字符串参数。为了发出JSONP请求，我们必须安装来自[https://github.com/camsong/fetch-jsonp](https://github.com/camsong/fetch-jsonp)的Fetch
    JSONP包。这需要将`fetch`调用的签名更改为`fetchJsonp`。除此之外，我们的其他函数看起来都一样。
- en: 'By now, we should be comfortable with the use of `async`/`await` inside promises.
    If we wanted a slightly less verbose function, we could change the code to this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经熟悉了在承诺中使用`async`/`await`。如果我们想要一个稍微不那么冗长的函数，我们可以将代码更改为这样：
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the next section, we are going to address how we call our TypeScript functionality
    from ASP.NET.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论如何从ASP.NET调用我们的TypeScript功能。
- en: Calling our TypeScript functionality from ASP.NET
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从ASP.NET调用我们的TypeScript功能
- en: 'Going back to our ASP.NET code, we can now hook up the `searchDiscog` function
    for retrieving our images. The first thing we need to do is include the reference
    to the search script:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的ASP.NET代码，我们现在可以连接`searchDiscog`函数来检索我们的图像。我们需要做的第一件事是包含对搜索脚本的引用：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'With this in place, we can now expand our image section to include the search
    script:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以扩展我们的图像部分以包括搜索脚本：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Putting this all together, our `Index` page now looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们的`Index`页面现在看起来像这样：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, when we run the application, both the title and the image will be returned
    after we have performed a search. Rerunning the same search now gives us this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们运行应用程序时，执行搜索后将返回标题和图像。重新运行相同的搜索现在给我们这个：
- en: '![](assets/949e84f9-4b2c-479f-8531-6cd20d4fe89c.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/949e84f9-4b2c-479f-8531-6cd20d4fe89c.png)'
- en: And that's it. We have an ASP.NET Core MVC application that we can use to search
    for artists and retrieve titles and artwork. All of this was achieved using a
    combination of ASP.NET MVC, HTML, Bootstrap, C#, and TypeScript.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们有一个ASP.NET Core MVC应用程序，可以用来搜索艺术家并检索标题和艺术品。所有这些都是使用ASP.NET MVC、HTML、Bootstrap、C#和TypeScript的组合实现的。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this, our last chapter, we moved over to developing an application using
    ASP.NET Core, C#, and TypeScript. We took this opportunity to learn about what
    Visual Studio generates for us when it creates an ASP.NET Core web application.
    We discovered that ASP.NET Core emphasizes the use of the MVC pattern to help
    us segregate the responsibilities of our code. In order to build this application,
    we signed up to the Discogs site and registered a token to let us start retrieving
    artists' details using C#. From the artist results, we created some TypeScript
    functionality that called out to the same site to retrieve album artwork.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们转向使用ASP.NET Core、C#和TypeScript开发应用程序。我们借此机会了解了在创建ASP.NET Core Web应用程序时，Visual
    Studio为我们生成了什么。我们发现ASP.NET Core强调使用MVC模式来帮助我们分离代码的责任。为了构建这个应用程序，我们注册了Discogs网站并注册了一个令牌，以便我们开始使用C#检索艺术家的详细信息。从艺术家的结果中，我们创建了一些调用同一网站检索专辑艺术品的TypeScript功能。
- en: While building the application, we covered how to mix C# and HTML code in the
    same `.cshtml` file, which constitutes the view. We wrote our own model to perform
    the artist search and we looked at how to update the controller to tie the model
    and the view together.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们介绍了如何在同一个`.cshtml`文件中混合C#和HTML代码，这构成了视图。我们编写了自己的模型来执行艺术家搜索，并学习了如何更新控制器以将模型和视图联系在一起。
- en: I hope you have enjoyed your journey with TypeScript and hope that we have enhanced
    your knowledge to the point where you want to use it more and more. TypeScript
    is a wonderful language and is always a joy to use, so please, go and have as
    much fun with it as I do. I look forward to seeing your work.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望您喜欢使用TypeScript的旅程，并希望我们已经增强了您的知识，以至于您想要更多地使用它。TypeScript是一种美妙的语言，总是很愉快地使用，所以，请尽情享受它，就像我一样。我期待着看到您的作品。
- en: Questions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why does TypeScript look similar to C#?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么TypeScript看起来与C#相似？
- en: What C# method starts our program?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么C#方法启动我们的程序？
- en: How does ASP.NET Core differ from ASP.NET?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core与ASP.NET有什么不同？
- en: What are the rate limitations of Discog?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Discog的速率限制是什么？
- en: Further reading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'ASP.NET Core is a huge topic and would take far more time to cover than we
    have in this short chapter. Bearing that in mind, I recommend the following books
    for you to continue your ASP.NET journey:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core是一个庞大的主题，需要覆盖的时间比我们在这个简短的章节中拥有的时间要多得多。考虑到这一点，我建议您阅读以下书籍，以继续您的ASP.NET之旅：
- en: '*ASP.NET Core 2 Fundamentals* ([https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals)):
    Build cross-platform apps and dynamic web services with this server-side web application
    framework by Onur Gumus and Mugilan T. S. Ragupathi. ISBN: 978-1789538915'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ASP.NET Core 2基础* ([https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals](https://www.packtpub.com/in/web-development/aspnet-core-2-fundamentals))：Onur
    Gumus和Mugilan T. S. Ragupathi撰写的使用这个服务器端Web应用程序框架构建跨平台应用程序和动态Web服务。ISBN：978-1789538915'
- en: '*Mastering ASP.NET Core 2.0* ([https://www.packtpub.com/in/application-development/mastering-aspnet-core](https://www.packtpub.com/in/application-development/mastering-aspnet-core)):
    MVC patterns, configuration, routing, deployment, and more by Ricardo Peres. ISBN:
    978-1787283688'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*掌握ASP.NET Core 2.0* ([https://www.packtpub.com/in/application-development/mastering-aspnet-core](https://www.packtpub.com/in/application-development/mastering-aspnet-core))：Ricardo
    Peres撰写的MVC模式、配置、路由、部署等内容。ISBN：978-1787283688'
- en: '*Building Microservices with .NET Core 2.0* ([https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition)):
    Transitioning monolithic architectures using microservices with .NET Core 2.0
    using C# 7.0 by Gaurav Aroraa. ISBN: 978-1788393331'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET Core 2.0构建微服务（[https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition](https://www.packtpub.com/in/application-development/building-microservices-net-core-20-second-edition)）：由Gaurav
    Aroraa编写，使用C# 7.0过渡单片架构，使用.NET Core 2.0构建微服务。ISBN：978-1788393331
- en: '*Learning ASP.NET Core 2.0* ([https://www.packtpub.com/application-development/learning-aspnet-core-20](https://www.packtpub.com/application-development/learning-aspnet-core-20)):
    Build modern web apps with ASP.NET Core 2.0, MVC, and EF Core 2 by Jason De Oliveira
    and Michel Bruchet. ISBN: 978-1788476638'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习ASP.NET Core 2.0（[https://www.packtpub.com/application-development/learning-aspnet-core-20](https://www.packtpub.com/application-development/learning-aspnet-core-20)）：由Jason
    De Oliveira和Michel Bruchet编写，使用ASP.NET Core 2.0，MVC和EF Core 2构建现代Web应用。ISBN：978-1788476638
