- en: What is Next?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: At last, we have come to our final chapter together. We've built a number of
    different types of application, attempting to highlight and demonstrate different
    parts of the Java platform, especially those new to Java 9\. As we've discussed,
    it's impossible to write something with **only** new-in-Java-9 technologies and
    APIs, so we also saw a variety of interesting items from Java 7 and 8\. As Java
    9 is finally shipping, it makes sense to look ahead to see what Java's future
    might hold for us, but it's also wise to look around and see what other languages
    are offering so that we can decide if our next Java will actually **be** Java.
    In this chapter, we'll do just that.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们终于来到了我们的最后一章。我们构建了许多不同类型的应用程序，试图突出和展示Java平台的不同部分，特别是Java 9中的新部分。正如我们所讨论的，仅使用Java
    9中的新技术和API编写是不可能的，所以我们还看到了一些有趣的Java 7和8中的项目。随着Java 9终于发布，我们有必要展望Java的未来可能会为我们带来什么，但也明智地环顾四周，看看其他语言提供了什么，以便我们可以决定我们的下一个Java实际上是否会是Java。在本章中，我们将做到这一点。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Recapping topics we previously covered
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回顾我们之前涵盖的主题
- en: What we can expect in the future
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未来可以期待的内容
- en: Looking back
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾过去
- en: 'Before looking forward to Java 10 and beyond, let''s quickly recap some of
    the things we''ve covered in this book:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 展望Java 10及更高版本之前，让我们快速回顾一下本书中涵盖的一些内容：
- en: The Java Platform Module System, perhaps the largest, most anticipated addition
    to the platform in this release. We saw how to create a module and discussed its
    implications on the runtime system.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java平台模块系统可能是这个版本中最大、最受期待的新增功能。我们看到了如何创建一个模块，并讨论了它对运行时系统的影响。
- en: We walked through the new process management APIs in Java 9 and learned how
    to view processes, and even kill them, if needed.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们走过了Java 9中的新进程管理API，并学习了如何查看进程，甚至在需要时终止它们。
- en: We looked at some of the major functional interfaces introduced in Java 8, discussing
    how they could be used, and showing how code might look with and without the lambdas
    that these interfaces support.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看了一些Java 8中引入的主要功能接口，讨论了它们的用途，并展示了这些接口支持的lambda表达式和不支持的代码可能是什么样子。
- en: We discussed Java 8's `Optional<T>` at length, showing how to create instances
    of the class, the various methods it exposes, and how one might use it.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们详细讨论了Java 8的`Optional<T>`，展示了如何创建该类的实例，它暴露的各种方法，以及如何使用它。
- en: We spent a good deal of time building JavaFX-based applications, demonstrating
    various tips and tricks, working around several **gotchas**, and so on.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们花了大量时间构建基于JavaFX的应用程序，展示了各种技巧，解决了一些问题，等等。
- en: Using the Java NIO File and Path APIs, we walked the filesystem, looking for
    duplicate files.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java NIO文件和路径API，我们遍历文件系统，寻找重复文件。
- en: We implemented data persistence using the Java Persistence API, demonstrating
    how to use the API in a Java SE environment, how to define entities, and so on.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Java持久性API实现了数据持久性，演示了如何在Java SE环境中使用API，如何定义实体等。
- en: We built a calculator using the Java 8 Date/Time APIs, exposing the functionality
    as both a library and a command-line utility.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Java 8的日期/时间API构建了一个计算器，将功能暴露为库和命令行实用程序。
- en: As part of that effort, we briefly compared a few command-line utility frameworks
    (specifically focusing on Crest and Airline), before settling on Crest and demonstrating
    how to create and consume command-line options.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为这一努力的一部分，我们简要比较了一些命令行实用程序框架（特别关注Crest和Airline），然后选择了Crest，并演示了如何创建和使用命令行选项。
- en: While we didn't focus on it in every chapter, we did take a break to discuss
    and demonstrate unit testing.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们并没有在每一章中都专注于它，但我们确实休息一下，讨论并演示了单元测试。
- en: We learned about **Service Provider Interfaces** (**SPIs**) as a means to provide
    multiple alternate implementations for an interface that can be loaded dynamically
    at runtime.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了**服务提供者接口**（**SPIs**）作为一种提供多个替代实现的接口的手段，可以在运行时动态加载。
- en: We implemented a couple of REST services, demonstrating not only the basic functionality
    of JAX-RS, how to deploy it in a Java SE environment, and POJO mapping, but also
    some more advanced features including server-sent events and securing endpoints
    using `Filter`.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了一些REST服务，不仅演示了JAX-RS的基本功能，如何在Java SE环境中部署它和POJO映射，还包括一些更高级的功能，包括服务器发送事件和使用`Filter`保护端点。
- en: We built a couple of Android applications and discussed and demonstrated activities,
    fragments, services, content providers, asynchronous messaging, and background
    tasks.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们构建了一些Android应用程序，并讨论和演示了活动、片段、服务、内容提供程序、异步消息传递和后台任务。
- en: We saw OAuth2 authentication flows in action, including how to set up credentials
    using the Google OAuth provider and the Java code necessary to drive the process.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了OAuth2认证流程的实际操作，包括如何使用Google OAuth提供程序设置凭据以及驱动该过程所需的Java代码。
- en: We discovered JSON Web Tokens, a cryptographically secure way to pass data back
    and forth between, for example, a client and a server, and saw their very basic
    use as part of an authentication system.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们发现了JSON Web Tokens，这是一种在客户端和服务器之间安全传递数据的加密方式，并看到了它们作为认证系统的基本使用。
- en: We toured the JavaMail API, learning a bit of the history and workings of common
    email protocols, such as POP3 and SMTP.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解了JavaMail API，学习了一些常见电子邮件协议的历史和工作原理，比如POP3和SMTP。
- en: We learned about job scheduling using the Quartz scheduler library.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了使用Quartz调度程序库进行作业调度。
- en: We saw how to specify constraints for our data in a declarative manner, then
    how to validate data in the light of those constraints using the Bean Validation
    API.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到了如何以声明方式指定数据的约束，然后如何使用Bean Validation API在这些约束的光线下验证数据。
- en: Changing gears completely, we built a moderately sophisticated application using
    the feature-rich NetBeans Rich Client Platform.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 彻底改变方向，我们使用功能丰富的NetBeans Rich Client Platform构建了一个相当复杂的应用程序。
- en: We looked briefly at world document databases with MongoDB.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们简要地看了一下使用MongoDB的全球文档数据库。
- en: And we learned about dependency injection and how to use it with the CDI specification.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还学习了依赖注入以及如何在CDI规范中使用它。
- en: That's quite a list, and that doesn't cover all of it. One of the stated purposes
    of the book is to discuss and demonstrate the new features of Java 9\. There are
    almost 100 **Java Enhancement Proposals** (**JEPs**) shipping with the release,
    making some of them difficult, at best, to demonstrate, but we've done our best.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的列表，还没有涵盖所有内容。本书的一个声明目的是讨论和演示Java 9的新特性。随着发布，将有近100个**Java增强提案**（**JEPs**），其中一些很难，甚至无法演示，但我们已经尽力了。
- en: Looking forward
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展望未来
- en: With Java 9 done, then, the natural question is, **What is next?** As you might
    expect, the engineers at companies such as Oracle, Red Hat, IBM, Azul Systems,
    and others have been thinking about this question even while Java 9 was being
    planned and developed. While it is next to impossible to say what Java 10 will
    hold with any certainty (remember it took three major releases to get the module
    system done), we do have several items that are currently being discussed and
    designed, with the hope of shipping them in the next release. Over the next few
    pages, we'll explore some of these to get an early look at what our life as Java
    developers might be like in a couple of years.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Java 9完成后，自然的问题是，**接下来是什么？**正如你所期望的，甲骨文、红帽、IBM、Azul Systems等公司的工程师们在Java
    9规划和开发期间就一直在思考这个问题。虽然几乎不可能确定Java 10会包含什么（记住，需要三个主要版本才能完成模块系统），但我们目前正在讨论和设计一些项目，希望能在下一个版本中发布。在接下来的几页中，我们将探讨其中一些，提前了解一下未来几年作为Java开发人员的生活可能会是什么样子。
- en: Project Valhalla
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 瓦哈拉项目
- en: Project Valhalla is an *incubation grounds for advanced language-VM co-development
    projects*. It is being led by Oracle engineer, Brian Goetz. As of this writing,
    there are three planned features for Valhalla. They are value types, generic specialization,
    and reified generics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 瓦哈拉项目是一个高级语言-虚拟机共同开发项目的孵化基地。它由甲骨文工程师Brian Goetz领导。截至目前，瓦哈拉计划有三个特性。它们是值类型、泛型特化和具体化泛型。
- en: Value types
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型
- en: The goal of this effort is to update the Java Virtual Machine, and, if possible,
    the Java language, to support small, immutable, **identity-less** value types.
    Currently, if you instantiate a new `Object`, it is given an identifier by the
    JVM, which allows the **variable** instance to be referenced.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这一努力的目标是更新Java虚拟机，如果可能的话，还有Java语言，以支持小型、不可变、无标识的值类型。目前，如果你实例化一个新的`Object`，JVM会为其分配一个标识符，这允许对**变量**实例进行引用。
- en: For example, if you create a new integer, `new Integer(42)`, a variable with
    the identity of `java.lang.Integer@68f29546`, but the value of `42`, the value
    of this variable will never change, and that's all we, as developers, typically
    care about. However, the JVM doesn't really know that, so it has to maintain the
    identity of the variable, with all of the overhead that entails. According to
    Goetz, that means every instance of this object will require up to 24 additional
    bytes to store the instance. If you have a large array of these, for example,
    that can be a significant amount of memory to manage and, eventually, to garbage-collect.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你创建一个新的整数，`new Integer(42)`，一个带有`java.lang.Integer@68f29546`标识的变量，但值为`42`，这个变量的值永远不会改变，这通常是我们作为开发人员关心的。然而，JVM并不真正知道这一点，所以它必须维护变量的标识，带来了所有的开销。根据Goetz的说法，这意味着这个对象的每个实例将需要多达24个额外字节来存储实例。例如，如果你有一个大数组，那么这可能是一个相当大的内存管理量，最终需要进行垃圾回收。
- en: What the JVM engineers hope to achieve, then, is a way to **gently extend**
    the Java Virtual Machine byte code and the Java language itself to support the
    notion of a small, immutable aggregate type (think of a class with 0 or more properties)
    that lacks identity, which will result, it is hoped, in "memory-and locality-efficient
    programming idioms without sacrificing encapsulation". Their hope is that Java
    developers will be able to create these new types and treat them as just another
    primitive. If they do their jobs correctly, Goetz says, the feature can be summarized
    as **Codes like a class, works like an int!**
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，JVM工程师们希望实现的是一种温和地扩展Java虚拟机字节码和Java语言本身的方式，以支持一个小型、不可变的聚合类型（想象一个具有0个或更多属性的类），它缺乏标识，这将带来“内存和局部性高效的编程习惯，而不会牺牲封装”。他们希望Java开发人员能够创建这些新类型并将它们视为另一种原始类型。如果他们做得正确，Goetz说，这个特性可以总结为**像类一样编码，像int一样工作！**
- en: 'The current proposal, as of April 2017 ([http://cr.openjdk.java.net/~jrose/values/shady-values.html](http://cr.openjdk.java.net/~jrose/values/shady-values.html)),
    offers the following code snippet as an example of how one might define a value
    type:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2017年4月（[http://cr.openjdk.java.net/~jrose/values/shady-values.html](http://cr.openjdk.java.net/~jrose/values/shady-values.html)），当前的提案提供了以下代码片段作为如何定义值类型的示例：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When instantiated, instances of this type could be created on the stack, rather
    than the heap, and use much less memory. This is a very low-level and technical
    discussion, which is far beyond the scope of this book, but if you are interested
    in more details, I would suggest reading the page linked earlier, or the effort's
    initial announcement at [http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，这种类型的实例可以在堆栈上创建，而不是在堆上，并且使用的内存要少得多。这是一个非常低级和技术性的讨论，远远超出了本书的范围，但如果你对更多细节感兴趣，我建议阅读之前链接的页面，或者在[http://cr.openjdk.java.net/~jrose/values/values-0.html](http://cr.openjdk.java.net/~jrose/values/values-0.html)上阅读该努力的初始公告。
- en: Generic specialization
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型特化
- en: 'Generic specialization is, perhaps, a bit easier to understand. Currently,
    generic type variables can hold only reference types. For example, you can create
    a `List<Integer>`, but not a `List<int>`. There are some pretty complex reasons
    why this is so, but being able to use primitives, and value types, would make
    collections more efficient in terms of memory and computation. You can read more
    about this feature in this document from, again, Brian Goetz--[http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html).
    Jesper de Jong also has a good write-up about the complexities of primitives in
    generic type variables here:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型特化可能更容易理解一些。目前，泛型类型变量只能持有引用类型。例如，你可以创建一个`List<Integer>`，但不能创建一个`List<int>`。为什么会这样有一些相当复杂的原因，但能够使用原始类型和值类型将使集合在内存和计算方面更有效率。你可以在这篇文章中了解更多关于这个特性的信息，再次是Brian
    Goetz的文章--[http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html](http://cr.openjdk.java.net/~briangoetz/valhalla/specialization.html)。Jesper
    de Jong在这里也有一篇关于泛型类型变量中原始类型复杂性的很好的文章：
- en: '[http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/](http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/](http://www.jesperdj.com/2015/10/12/project-valhalla-generic-specialization/)'
- en: Reified generics
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体化的泛型
- en: The term **reified generics** is one that, more often than not, it seems, causes
    very vocal, animated reactions. Currently, if you declare a variable to be of
    type `List<Integer>`, the byte code generated has no real notion of the parameterized
    type, so it's not discoverable at runtime. If you were to examine the variable
    at runtime, you would see no mention of `Integer`. You could, of course, look
    at the types of each element, but, even then, you can't be sure of the type of
    the `List`, as there is nothing enforcing that **only** the `Integer` can be added
    to the `List`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型化的具体化是一个经常引起非常响亮、生动反应的术语。目前，如果你声明一个变量的类型是`List<Integer>`，生成的字节码实际上并不知道参数化类型，因此在运行时无法发现。如果你在运行时检查变量，你将看不到`Integer`的提及。当然，你可以查看每个元素的类型，但即使这样，你也不能确定`List`的类型，因为没有强制要求**只有**`Integer`可以添加到`List`中。
- en: Java developers have been clamoring for reified generics, or, put simply, generics
    that retain their type information at runtime since generics were introduced in
    Java 5\. As you might guess, making Java's generics reified is no trivial task,
    but, finally, we have a formal effort to see if it can be done and, if it can
    be done, to find a backwards-compatible way that doesn't have, for example, negative
    performance characteristics.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Java 5引入泛型以来，Java开发人员一直在呼吁具体化的泛型，或者简单地说，保留泛型在运行时的类型信息。你可能会猜到，使Java的泛型具体化并不是一项微不足道的任务，但最终，我们有了一个正式的努力来看看是否可以做到，如果可以做到，是否可以找到一种向后兼容的方式，不会有负面的性能特征，例如。
- en: Project Panama
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Panama项目
- en: While not yet targeted for any particular Java release, Project Panama offers
    some hope for those who use, or hope to use, third-party, native libraries. Currently,
    the primary way of exposing native libraries (that is, OS-specific libraries written
    in, say, C or C++) to the JVM is via the **Java Native Interface** (**JNI**).
    The problem with JNI, or at least one of them, is that it requires that every
    Java programmer who wants to expose a native library to the JVM also become a
    C programmer, which means not only the C language itself, but also the related
    build tools for each supported platform.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管尚未针对任何特定的Java版本，Panama项目为那些使用或希望使用第三方本地库的人提供了一些希望。目前，将本地库（即，针对操作系统的库，比如C或C++编写的库）暴露给JVM的主要方式是通过**Java本地接口**（**JNI**）。JNI的问题之一，或者至少是其中之一，是它要求每个想要将本地库暴露给JVM的Java程序员也成为C程序员，这意味着不仅要了解C语言本身，还要了解每个支持的平台的相关构建工具。
- en: 'Project Panama hopes to ameliorate that issue by offering the Java developer
    a new means of exposing native libraries without needing a deep understanding
    of the library language''s ecosystem, or the JVM''s. The JEP for Project Panama
    ([http://openjdk.java.net/jeps/191](http://openjdk.java.net/jeps/191)) lists these
    design goals:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Panama项目希望通过提供一种新的方式来暴露本地库，而无需深入了解库语言的生态系统或JVM，来改善这个问题。Panama项目的JEP（[http://openjdk.java.net/jeps/191](http://openjdk.java.net/jeps/191)）列出了这些设计目标。
- en: A metadata system to describe native library calls (call protocol, argument
    list structure, argument types, return type) and the native memory structure (size,
    layout, typing, life cycle).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述本地库调用的元数据系统（调用协议、参数列表结构、参数类型、返回类型）和本地内存结构（大小、布局、类型、生命周期）。
- en: Mechanisms to discover and load native libraries. These capabilities may be
    provided by the current `System.loadLibrary` or may include additional enhancements
    for locating platform or version-specific binaries appropriate to the host system.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现和加载本地库的机制。这些功能可能由当前的`System.loadLibrary`提供，也可能包括额外的增强功能，用于定位适合主机系统的平台或特定版本的二进制文件。
- en: Mechanisms for binding, based on metadata, a given library/function coordinate
    to a Java endpoint, likely via a user-defined interface backed by plumbing to
    make the native downcall.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于元数据的机制，将给定库/函数坐标绑定到Java端点，可能通过由管道支持的用户定义接口。
- en: Mechanisms for binding, based on metadata, a specific memory structure (layout,
    endianness, logical types) to a Java endpoint, either via a user-defined interface
    or a user-defined class, in both cases backed by plumbing to manage a real block
    of native memory.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于元数据的机制，将特定的内存结构（布局、字节序、逻辑类型）绑定到Java端点，无论是通过用户定义的接口还是用户定义的类，在这两种情况下都由管道支持来管理真实的本地内存块。
- en: Appropriate support code to marshal Java data types to native data types and
    vice-versa. This will, in some cases, require the creation of FFI-specific types
    to support bit widths and numeric signs that Java can't represent.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适当的支持代码，将Java数据类型转换为本地数据类型，反之亦然。在某些情况下，这将需要创建特定于FFI的类型，以支持Java无法表示的位宽和数值符号。
- en: JNI has been available for quite some time, and it's finally getting some long
    overdue attention.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JNI已经可用了相当长一段时间，现在终于得到了一些早就该得到的关注。
- en: Project Amber
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Project Amber
- en: Project Amber's goal is to **explore and incubate smaller, productivity-oriented
    Java language features**. The current list includes local-variable type inference,
    enhanced enums, and lambda leftovers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Project Amber的目标是**探索和孵化更小、以提高生产力为导向的Java语言特性**。目前的列表包括局部变量类型推断、增强枚举和lambda遗留问题。
- en: Local-Variable Type Inference
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部变量类型推断
- en: 'As we have seen countless times in this book alone, when you declare a variable
    in Java, you have to declare the type twice, once on the left-hand and once on
    the right-hand side, plus a variable name:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中多次看到的那样，在Java中声明变量时，您必须在左侧和右侧各声明一次类型，再加上一个变量名：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The problem here is that this code is verbose and repetitive. The Local-Variable
    Type Inference effort hopes to fix that, enabling something like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于这段代码冗长而重复。局部变量类型推断工作希望解决这个问题，使得像这样的东西成为可能：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is more concise, making it more readable. Notice the addition of the
    `val` keyword. Typically, the compiler knows that a line of code, for example,
    is a variable declaration when it sees `<type> <name> = ...`. Since the effort
    would remove the need for a type on the left-hand side of the declaration, we
    need a cue for the compiler, which the authors of this JEP propose as `var`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码更加简洁，更易读。请注意`val`关键字的添加。通常，编译器知道代码行是变量声明时，例如`<type> <name> = ...`。由于这项工作将消除声明左侧的类型的需要，我们需要一个提示编译器的线索，这就是这个JEP的作者提出的`var`。
- en: There is also some discussion around simplifying the declaration of immutable,
    or `final`, variables. Among the proposals are `final var` as well as `val`, as
    seen in other languages such as Scala. At the time of writing, no decision that
    has been made on which proposal will make the final cut.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些关于简化不可变或`final`变量声明的讨论。提议中包括`final var`以及`val`，就像其他语言（如Scala）中所见的那样。在撰写本文时，尚未就哪项提议最终确定做出决定。
- en: Enhanced enums
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强枚举
- en: 'Enhanced enums will augment *the expressiveness of the enum construct in the
    Java Language by allowing type-variables in enums (generic enums), and performing
    sharper type-checking for enum constants.* ([http://openjdk.java.net/jeps/301](http://openjdk.java.net/jeps/301)).
    What this means is that enums will finally support a parameterized type, allowing
    something like this (taken from the JEP at the link mentioned previously):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 增强枚举将通过允许枚举中的类型变量（通用枚举）和对枚举常量进行更严格的类型检查来增强Java语言中枚举结构的表现力。([http://openjdk.java.net/jeps/301](http://openjdk.java.net/jeps/301))。这意味着枚举最终将支持参数化类型，允许像这样的东西（取自先前提到的JEP链接）：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that, in addition to specifying a generic type for each `enum` value, we
    can also define type-specific methods for each `enum` type. This will make it
    much easier to define a set of predefined constants, but also to define type-safe
    and type-aware methods for each of the constants.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了为每个`enum`值指定通用类型之外，我们还可以为每个`enum`类型定义特定于类型的方法。这将大大简化定义一组预定义常量，同时也可以为每个常量定义类型安全和类型感知的方法。
- en: Lambda leftovers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda遗留问题
- en: 'There are currently two items labeled as `leftovers` from the lambda work in
    Java 8\. The first is the use of the underscore for unused parameters in lambda
    declarations. For example, in this very contrived example, all we care about are
    the `Map` values:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 目前有两个项目被标记为Java 8中lambda工作的`leftovers`。第一个是在lambda声明中使用下划线表示未使用的参数。例如，在这个非常牵强的例子中，我们只关心`Map`的值：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That results in things like this in the IDE:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这在IDE中会产生这样的结果：
- en: '![](img/4e5a6dac-2f9b-4a04-a5b4-cdf4ba81addb.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4e5a6dac-2f9b-4a04-a5b4-cdf4ba81addb.png)'
- en: 'Once the use of the underscore is allowed, this code will look like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦允许使用下划线，这段代码将变成这样：
- en: '[PRE5]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This allows better static checking of unused variables, allowing tools (and
    developers) to more easily identify such parameters and either correct or mark
    them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许更好地静态检查未使用的变量，使工具（和开发人员）更容易识别这些参数并进行更正或标记。
- en: 'The other leftover is allowing lambda parameters to shadow variables from the
    enclosing scope. If you were to try that now, you would get the same error if
    you tried to redefine a variable inside a statement block--**variable is already
    defined**:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个遗留问题是允许lambda参数遮蔽来自封闭范围的变量。如果您现在尝试这样做，您将得到与尝试在语句块内重新定义变量相同的错误--**变量已经定义**：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With this change, the preceding code would compile and run just fine.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个改变，前面的代码将编译并正常运行。
- en: Looking around
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四处张望
- en: The JVM has supported alternative languages for years. Some of the better known
    ones include Groovy and Scala. Both of these languages have influenced Java in
    one way or another over the years, but, like any language, they are not without
    their problems. Many feel that Groovy doesn't perform as well as Java (though
    the `invokedynamic` bytecode instruction is supposed to have addressed that),
    and many find Groovy's more dynamic nature less appealing. Scala, on the other
    hand, suffers (fairly or not, depending on who you ask) from the perception that
    it's too complex. Compilation time is also a common complaint. Also, many organizations
    are quite happily using both, so they are definitely worth considering to see
    if they will work in your environment and for your needs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，JVM已经支持了替代语言。其中一些较为知名的包括Groovy和Scala。这两种语言多年来以某种方式影响了Java，但是像任何语言一样，它们也不是没有问题。许多人认为Groovy的性能不如Java（尽管`invokedynamic`字节码指令应该已经解决了这个问题），许多人发现Groovy更动态的特性不太吸引人。另一方面，Scala（公平与否取决于你问谁）受到了太过复杂的认知。编译时间也是一个常见的抱怨。此外，许多组织都很乐意同时使用这两种语言，因此绝对值得考虑它们是否适合您的环境和需求。
- en: While those may be great languages, we are taking some time here to see what's
    next, and there are at least two languages that seem to stand out from the crowd--Ceylon
    and Kotlin. We can't give each of these languages an exhaustive treatment, but,
    over the next few pages, we'll take a quick look at the languages to see what
    they offer JVM developers now, and, perhaps, see how they might influence future
    changes to the Java language.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些可能是很棒的语言，但我们在这里花点时间来看看接下来会发生什么，至少有两种语言似乎脱颖而出——锡兰语和Kotlin。我们无法对这些语言进行详尽的介绍，但在接下来的几页中，我们将快速浏览这些语言，看看它们现在为JVM开发人员提供了什么，也许还能看到它们如何影响未来对Java语言的改变。
- en: Ceylon
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锡兰
- en: Ceylon, a language sponsored by Red Hat, first appeared around 2011\. Led by
    Gavin King of the Hibernate and Seam Framework fame, the team set out to solve,
    at a language and library level, some of the pain points they had experienced
    over the years in developing their own frameworks and libraries. While they confess
    to being **unapologetic fans** of the Java language, they also readily acknowledge
    that the language is not perfect, especially with regard to some of the standard
    libraries, and aim to fix those flaws in Ceylon. The goals of the language include
    readability, predictability, toolability, modularity, and metaprogrammability
    ([https://ceylon-lang.org/blog/2012/01/10/goals](https://ceylon-lang.org/blog/2012/01/10/goals)).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 锡兰语是由红帽赞助的一种语言，最早出现在2011年左右。由Hibernate和Seam Framework的知名人物Gavin King领导，团队着手解决他们多年来在开发自己的框架和库时所经历的一些痛点，从语言和库的层面上解决这些问题。他们承认自己是Java语言的忠实粉丝，但也承认这种语言并不完美，特别是在一些标准库方面，他们希望在锡兰语中修复这些缺陷。该语言的目标包括可读性、可预测性、可工具化、模块化和元编程能力（https://ceylon-lang.org/blog/2012/01/10/goals）。
- en: 'One of the biggest differences you are likely to notice when getting started
    with Ceylon is that the idea of modules is already baked into the language. In
    many ways, it looks very similar to Java 9''s module declaration, which is as
    follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用锡兰时，您可能会注意到的最大的区别之一是模块的概念已经融入到了语言中。在许多方面，它看起来与Java 9的模块声明非常相似，如下所示：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is, however, a very obvious difference--Ceylon modules **do** have version
    information, which allows various modules to depend on different versions of a
    module that may already be in the system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个非常明显的区别——锡兰模块确实有版本信息，这允许各种模块依赖于系统中可能已经存在的模块的不同版本。
- en: 'There is at least one more rather significant difference between Ceylon and,
    say, Java--Ceylon has a build tool built in. While there is, for example, a Maven
    plugin, the preferred approach is to use Ceylon''s native tooling to build and
    run the project:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 锡兰和Java之间至少还有一个相当重要的区别——锡兰内置了构建工具。例如，虽然有Maven插件，但首选方法是使用锡兰的本机工具来构建和运行项目：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Other than the module system, what might Ceylon offer a Java developer? One
    of the more immediately useful and practical features is improved null-handling
    support. Just as we have to do in Java, we still have to check for null in Ceylon,
    but the language offers a much nicer approach, and it all starts with the type
    system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模块系统，锡兰可能为Java开发人员提供什么？其中一个立即有用和实用的功能是改进的空值处理支持。就像在Java中一样，我们仍然必须在锡兰中检查空值，但该语言提供了一种更好的方法，一切都始于类型系统。
- en: One of the complaints about Scala (whether its truly warranted or not) is that
    the type system is too complicated. Regardless of whether or not you agree, it
    seems clear that there's certainly room for improvement over what Java offers
    (even the Java language architects agree as evidenced by, for example, the proposed
    local variable type inference proposal). Ceylon offers a very powerful addition
    to the type system--union types and intersection types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Scala的一个抱怨（无论是否真正有根据）是其类型系统过于复杂。不管你是否同意，似乎很明显，相对于Java提供的内容，肯定有改进的空间（即使Java语言的设计者们也同意，例如提出的局部变量类型推断提案）。锡兰为类型系统提供了一个非常强大的补充——联合类型和交集类型。
- en: Union types allow a variable to have more than one type, but only one at a time.
    Where this comes into play in discussing nulls is that `String? foo = ...` , which
    declares a variable of type `String` that is nullable, is actually the same as
    `String|Null foo = ...`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型允许变量具有多种类型，但一次只能有一种。在讨论空值时，这就体现在`String? foo = ...`，它声明了一个可为空的`String`类型的变量，实际上与`String|Null
    foo = ...`是相同的。
- en: 'This declares a variable, foo, whose type is either `String` or `Null`, but
    not both. The `?` syntax is just syntactic sugar over the union type declaration
    (`A | B` or `A` or `B`). If we have a method, then that takes this union type;
    we know that the variable is nullable, so we need to check it using the following
    code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个名为foo的变量，其类型可以是`String`或`Null`，但不能同时是两者。`?`语法只是对联合类型声明（`A | B`或`A`或`B`）的一种语法糖。如果我们有一个方法，那么它接受这种联合类型；我们知道该变量是可空的，所以我们需要使用以下代码片段进行检查：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since this is a union type, we can also do this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个联合类型，我们也可以这样做：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that, once we've tested with `exists` or `is`, we can assume that the variable
    is not null and is a `String`. The compiler won't complain, and we won't have
    an unexpected `NullPointerException` at runtime (they actually don't exist in
    Ceylon as the compiler requires that you be very explicit in your handling of
    nullable variables). This type of compiler awareness of null and type checks is
    called **flow-sensitive** typing. Once you've verified the type of something,
    the compiler knows and remembers, so to speak, the results of that check for that
    remainder of that scope so you can write cleaner, more concise code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦我们使用`exists`或`is`进行测试，我们可以假定该变量不为空且为`String`。编译器不会抱怨，我们也不会在运行时遇到意外的`NullPointerException`（它们实际上在锡兰中不存在，因为编译器要求您对可空变量的处理非常明确）。这种对空值和类型检查的编译器感知称为**流敏感**类型。一旦您验证了某个东西的类型，编译器就知道并记住了这个检查的结果，这样说来，对于该范围的剩余部分，您可以编写更清晰、更简洁的代码。
- en: 'While union types are either A or B, intersection types are A **and** B. For
    a completely arbitrary example, let''s say you have a method whose parameter must
    be, say, `Serializable` **and** `Closeable`. In Java, you''d have to check manually
    by writing the following lines of code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型要么是A要么是B，而交集类型是A**和**B。举个完全随意的例子，假设您有一个方法，其参数必须是`Serializable`**和**`Closeable`。在Java中，您必须手动检查，编写以下代码：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With intersection types, Ceylon would let us write this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了交集类型，Ceylon可以让我们编写这样的代码：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to call that method with something that doesn't implement **both**
    interfaces, or, say, extends one class and implements the other interfaces, then
    we get an error at **compile time**. That's very powerful.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用未实现**两个**接口的内容调用该方法，或者说，扩展一个类并实现其他接口，那么我们将在**编译时**出现错误。这非常强大。
- en: Before adopting a new language, or even a library, in an enterprise, one often
    looks to see who else is using it. Are there notable adoption stories? Are there
    other companies confident enough in the technology to build a production system
    using it? Unfortunately, the Ceylon website (at the time of writing) is very thin
    on the details of adoption outside Red Hat, so it's hard to answer that question.
    However, Red Hat is spending a good deal of money designing the language and building
    tooling and a community around it, so it should be a safe bet. It is, of course,
    a decision your enterprise will have to make after careful consideration. You
    can find out more about Ceylon at [https://ceylon-lang.org](https://ceylon-lang.org).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业采用新语言或库之前，人们经常会查看谁还在使用它。是否有显著的采用案例？是否有其他公司足够自信地使用该技术构建生产系统？不幸的是，Ceylon网站（撰写时）在Red
    Hat之外的采用细节上非常匮乏，因此很难回答这个问题。但是，Red Hat正在花费大量资金设计语言并构建围绕它的工具和社区，因此这应该是一个安全的选择。当然，这是您的企业在经过慎重考虑后必须做出的决定。您可以在[https://ceylon-lang.org](https://ceylon-lang.org)了解更多关于Ceylon的信息。
- en: Kotlin
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin
- en: Another up-and-coming language is Kotlin. It is a statically-typed language
    from JetBrains, the makers of IntelliJ IDEA, that targets both the JVM and Javascript.
    It even has nascent support to compile directly to machine code via LLVM for those
    environments, such as iOS, embedded systems, and so on, where a virtual machine
    is not desired or allowed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新兴的语言是Kotlin。这是来自JetBrains的静态类型语言，他们是IntelliJ IDEA的制造商，旨在同时针对JVM和Javascript。它甚至具有初步支持，可以通过LLVM直接编译为机器代码，用于那些不希望或不允许使用虚拟机的环境，例如iOS、嵌入式系统等。
- en: Kotlin was started in 2010, and open sourced in 2012, as a means to address
    some common issues JetBrains was facing in large-scale Java development. Having
    surveyed the then-current language landscape, their engineers felt that none of
    those languages adequately addressed their concerns. Scala, considered for years
    now by many to be the **next Java**, was, for example, deemed to be too slow in
    compiling, despite having an acceptable feature set, so JetBrains began designing
    their own, eventually releasing 1.0 in February of 2016.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin于2010年开始，并于2012年开源，旨在解决JetBrains在大规模Java开发中面临的一些常见问题。在调查了当时的语言格局后，他们的工程师们认为这些语言都没有充分解决他们的问题。例如，被许多人认为是“下一个Java”的Scala，尽管具有可接受的功能集，但编译速度太慢，因此JetBrains开始设计他们自己的语言，并于2016年2月发布了1.0版本。
- en: The design goals of the Kotlin team include expressiveness, scalability, and
    interoperability. They aim to allow developers to write less code that does more
    in a clearer fashion via language and library features, and in a language that
    is 100% interoperable with Java. They have added features such as coroutines to
    enable Kotlin-based systems to scale quickly and easily.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin团队的设计目标包括表达性、可扩展性和互操作性。他们的目标是允许开发人员通过语言和库功能以更清晰的方式编写更少的代码，以及使用与Java完全互操作的语言。他们添加了诸如协程之类的功能，以使基于Kotlin的系统能够快速轻松地扩展。
- en: With all of that said, what does Kotlin look like and why should we, as Java
    developers, be interested? Let's start with variables.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，Kotlin是什么样的，为什么我们作为Java开发人员应该感兴趣呢？让我们从变量开始。
- en: As you'll recall, Java has both primitive (`int`, `double`, `float`, `char`,
    and so on) and reference, or **wrapper** types (`Integer`, `Double`, `Float`,
    `String`, and so on). As we've discussed in this chapter, the JVM engineers are
    working on ways to ameliorate some of the behavioral and capability differences
    this dichotomy brings. Kotlin avoids this altogether, as every value is an object,
    so there's no concern over `List<int>` versus `List<Integer>`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所记得的，Java既有原始类型（`int`、`double`、`float`、`char`等），也有引用或包装类型（`Integer`、`Double`、`Float`、`String`等）。正如我们在本章中讨论的那样，JVM工程师正在努力解决这种二分法带来的一些行为和能力差异。Kotlin完全避免了这一点，因为每个值都是一个对象，所以不必担心`List<int>`与`List<Integer>`之间的区别。
- en: 'Furthermore, Kotlin already supports local variable type inference, as well
    as immutablity. For example, consider the following Java code as an example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kotlin已经支持本地变量类型推断以及不可变性。例如，考虑以下Java代码作为示例：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding lines of code could be written like this in Kotlin:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice the use of the `var` and `val` keywords. As discussed earlier with regard
    to future Java language changes, these keywords allow us to declare mutable and
    immutable variables (respectively). Also notice that we need not declare the type
    of the variable, as the compiler handles that for us. In certain situations, we
    may need to explicitly declare the type, for example, in situations where the
    compiler might guess incorrectly or when it just does not have enough information
    to make a guess, at which point, it will stop compiling and present an error message.
    In those situations, we can declare the type this way:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`var`和`val`关键字的使用。正如我们之前讨论过的关于未来Java语言更改，这些关键字允许我们声明可变和不可变变量（分别）。还要注意，我们不需要声明变量的类型，因为编译器会为我们处理。在某些情况下，我们可能需要明确声明类型，例如在编译器可能猜测错误或者没有足够信息进行猜测的情况下，此时，它将停止编译并显示错误消息。在这些情况下，我们可以这样声明类型：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With Java 8, as we''ve seen, we have `Optional<T>` to help deal with null values.
    Kotlin has null support as well, but it''s built into the language. By default,
    all variables in Kotlin are **not** nullable. That is to say, if the compiler
    can tell that you are attempting to assign a null value to a variable, or if it
    can''t determine whether or not a value might be null (for example, a return value
    from a Java API), you''ll get a compiler error. To indicate that a value is null-capable,
    you add a `?` to the variable declaration as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Java 8中有`Optional<T>`来帮助处理空值。Kotlin也有空值支持，但它内置在语言中。默认情况下，Kotlin中的所有变量都**不**可为空。也就是说，如果编译器能够确定您试图将空值赋给变量，或者无法确定值是否可能为空（例如来自Java
    API的返回值），则会收到编译器错误。要指示值可以为空，您需要在变量声明中添加`?`，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Kotlin also offers improved null-handling support in method calls. Suppose,
    for example, you want to get a user''s city. In Java, you may do something like
    this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin还在方法调用中提供了改进的空值处理支持。例如，假设您想要获取用户的城市。在Java中，您可能会这样做：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In Kotlin, that can be expressed in a single line, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，可以用一行代码来表达如下：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If, at any point, one of the methods returns null, the method call chain ends,
    and null is assigned to the variable city. Kotlin doesn''t stop there with null
    handling. It provides, for an example, the `let` function that can serve as a
    shortcut for if-not-null checks. For example, consider the following lines of
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何时候，其中一个方法返回null，方法调用链就会结束，并且null会被赋给变量city。Kotlin在处理空值方面并不止于此。例如，它提供了`let`函数，可以作为if-not-null检查的快捷方式。例如，考虑以下代码行：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding lines of code become this in Kotlin:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，前面的代码行变成了这样：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This could, of course, be written as `city?.toUpperCase()`. What this should
    demonstrate, though, is the ability to safely use a nullable variable in an arbitrarily
    large, complex block of code. It's also worth noting that, inside the `let` block,
    the compiler knows that `city` is not null so no further null checks are necessary.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这可以写成`city?.toUpperCase()`。然而，这应该证明的是在任意大的复杂代码块中安全使用可空变量的能力。值得注意的是，在`let`块内，编译器知道`city`不为空，因此不需要进一步的空值检查。
- en: Hidden, perhaps, in the preceding example is Kotlin's support for lambdas, without
    which, it seems, no modern language is worth considering. Kotlin does, indeed,
    have full support for lambdas, higher order functions, underscores as lambda parameter
    names, and so on. Its support and syntax are very similar to Java's, so Java developers
    should be very comfortable with Kotlin's lambdas.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在前面的例子中隐藏着Kotlin对lambda的支持，没有lambda的话，似乎没有现代语言值得考虑。Kotlin确实完全支持lambda、高阶函数、下划线作为lambda参数名称等。它的支持和语法非常类似于Java，因此Java开发人员应该对Kotlin的lambda非常熟悉。
- en: The big question is, of course, **Is Kotlin ready for prime time?** JetBrains
    definitely thinks so, as they have it in use in many of their applications, both
    internal and external. Other notable users include Pinterest, Gradle, Evernote,
    Uber, Pivotal, Atlassian, and Basecamp. Kotlin is even officially supported by
    Google (in Android Studio) for Android development, so it's definitely a production-grade
    language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一个重要的问题是，**Kotlin准备好投入使用了吗？** JetBrains绝对认为是这样，因为他们在许多内部和外部应用程序中都在使用它。其他知名用户包括Pinterest、Gradle、Evernote、Uber、Pivotal、Atlassian和Basecamp。Kotlin甚至得到了Google的官方支持（在Android
    Studio中）用于Android开发，因此它绝对是一个生产级的语言。
- en: There's much, much more to this great new language, of course, and space won't
    allow us to discuss all of it, but you can browse through [https://kotlinlang.org](https://kotlinlang.org)
    to learn more and see if Kotlin is a good fit for your organization.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个伟大的新语言还有很多，空间不允许我们讨论所有，但您可以浏览[https://kotlinlang.org](https://kotlinlang.org)了解更多信息，看看Kotlin是否适合您的组织。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There is much more that can be discussed of course, about Java 10 and these
    two languages, and the myriad of other projects happening in and around the Java
    Virtual Machine. After over 20 years of development, Java--the language **and**
    the environment--is still going strong. In the pages of this book, I've tried
    to demonstrate some of these great advancements in the language, giving you a
    variety of starting points for your own projects, sample code to study and reuse,
    and explanations of various libraries, APIs, and technologies that may be helpful
    in your day-to-day work. I hope you've enjoyed the examples and explanations as
    much as I've enjoyed preparing them, and, more importantly, I hope they help you
    build the Next Big Thing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，关于Java 10和这两种语言，以及围绕Java虚拟机发生的众多其他项目，还有很多可以讨论的地方。经过20多年的发展，Java——语言和环境——仍然非常强大。在本书的页面中，我试图展示语言中的一些重大进展，为您自己的项目提供各种起点、可供学习和重用的示例代码，以及各种库、API和技术的解释，这些可能对您的日常工作有所帮助。我希望您喜欢这些示例和解释，就像我喜欢准备它们一样，更重要的是，我希望它们能帮助您构建下一个大事件。
- en: Good luck!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 祝你好运！
