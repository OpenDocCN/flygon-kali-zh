["```js\nmkdir <project-name>\n```", "```js\ncd <project-name>\nnpm init\n```", "```js\nnpm install --save lodash\n```", "```js\nINITIALIZE response\n\nFOR each node\n\n    extract child nodes\n\n    add current node info to serialized string\n\n    IF childNodes exist\n\n        repeat process for child nodes\n\n    ELSE\n\n        add ^ to indicate end of the level \n\nIF rootnode\n\n    return serialized string\n\nELSE\n\n   add ^ to indicate child node of root\n\n```", "```js\nvar _ = require('lodash');\n\nclass Recursion {\n   constructor(tree) {\n      this.tree = tree;\n   }\n\n   // serialize method which accepts list of nodes\n  serialize(nodes) {\n      // initialize response\n  this.currentState = this.currentState || '';\n\n      // loop over all nodes\n  _.forEach(nodes, (node) => {\n\n         // depth first traversal, extracting nodes at each level\n // traverse one level down  var childNodes = this.tree[node];\n\n         // add current node to list of serialized nodes\n  this.currentState += ` ${node}`;\n\n         // has child nodes\n  if (childNodes) {\n\n            // recursively repeat\n  this.serialize(childNodes);\n         } else {\n\n            // mark as last node, traverse up\n  this.currentState += ` ^`;\n         }\n      });\n\n      // loop complete, traverse one level up\n // unless already at root otherwise return response  if (!this.isRoot(nodes)) {\n         this.currentState += ` ^`;\n      } else {\n         return this.currentState.trim();\n      }\n   }\n\n   isRoot(nodes) {\n      return _.isEqual(this.tree.root, nodes);\n   }\n}\n\nmodule.exports = Recursion;\n```", "```js\nvar fs = require('fs');\nvar Recursion = require('./recursion');\n\n// set up data const tree = {\n   root: ['A'],\n   A: ['B', 'C', 'D'],\n   B: ['E', 'F'],\n   D: ['G', 'H', 'I', 'J'],\n   F: ['K']\n};\n\n// initialize var serializer = new Recursion(tree);\n\n// serialize var serializedData = serializer.serialize(tree.root);\n\nconsole.log(serializedData);\n```", "```js\nA B E ^ F K ^ ^ ^ C ^ D G ^ H ^ I ^ J ^ ^ ^\n```", "```js\nINITIALIZE Costs, Previous Paths, Visited Nodes\n\nADD each neighbor of start node to Previous Paths\n\nGET cheapest node from start node and set as current node\n\nWHILE node exists\n\n    GET cost of current node from costs\n\n    GET neighbors of current node\n\n    FOREACH neighbor\n\n        ADD cost of neighbor to current nodes cost as new cost\n\n        IF cost of neighbor not recorded OR cost of \n            neighbor is the lowest amongst all neighbors\n\n            SET cost of neighbor as new cost\n\n            SET the path of neighbor as current node\n\n    MARK current node as visited\n\n    GET cheapest node from start node and set as current node\n\nINITIALIZE response\n\nBACKTRACK path from end to start\n\nRETURN distance and path    \n```", "```js\nvar _ = require('lodash');\n\nclass Dijkstra {\n   solve (graph, start, end) {\n\n      // track costs of each node\n  const costs = graph[start];\n\n      // set end to infinite on 1st pass\n  costs[end] = Infinity;\n\n      // remember path from\n // which each node was visited  const paths = {};\n\n      // add path for the start nodes neighbors\n  _.forEach(graph[start], (dist, city) => {\n         // e.g. city SJ was visited from city SF\n  paths[city] = start;\n      });\n\n      // track nodes that have already been visited nodes\n  const visitedNodes = [];\n\n      ....\n```", "```js\n...\n\n// track nodes that have already been visited nodes const visitedNodes = [];\n\n// get current nodes cheapest neighbor let currentCheapestNode = this.getNextLowestCostUnvisitedNode(costs, visitedNodes);\n\n// while node exists while (currentCheapestNode) {\n\n   // get cost of reaching current cheapest node\n  let costToReachCurrentNode = costs[currentCheapestNode];\n\n   // access neighbors of current cheapest node\n  let neighbors = graph[currentCheapestNode];\n\n   // loop over neighbors\n  _.forEach(neighbors, (dist, neighbor) => {\n\n      // generate new cost to reach each neighbor\n  let newCost = costToReachCurrentNode + dist;\n\n      // if not already added\n // or if it is lowest cost amongst the neighbors  if (!costs[neighbor] || costs[neighbor] > newCost) {\n\n         // add cost to list of costs\n  costs[neighbor] = newCost;\n\n         // add to paths\n  paths[neighbor] = currentCheapestNode;\n\n      }\n\n   });\n\n   // mark as visited\n  visitedNodes.push(currentCheapestNode);\n\n   // get cheapest node for next node\n  currentCheapestNode = this.getNextLowestCostUnvisitedNode(costs, visitedNodes);\n}\n\n...\n```", "```js\n....\n\n        // get cheapest node for next node\n  currentCheapestNode = \n this.getNextLowestCostUnvisitedNode(costs, visitedNodes);\n       }\n\n       // generate response\n  let finalPath = [];\n\n       // recursively go to the start\n  let previousNode = paths[end];\n\n       while (previousNode) {\n          finalPath.unshift(previousNode);\n          previousNode = paths[previousNode];\n       }\n\n       // add end node at the end\n  finalPath.push(end);\n\n       // return response\n  return {\n          distance: costs[end],\n          path: finalPath\n  };\n    }\n getNextLowestCostUnvisitedNode(costs, visitedNodes) {\n       //extract the costs of all non visited nodes\n  costs = _.omit(costs, visitedNodes);\n\n       // return the node with minimum cost\n  return _.minBy(_.keys(costs), (node) => {\n          return costs[node];\n       });\n    }\n}\n\nmodule.exports = Dijkstra;\n```", "```js\nvar Dijkstra = require('./dijkstra');\n\nconst graph = {\n   'SF': { 'SB': 326, 'MT': 118, 'SJ': 49 },\n   'SJ': { 'MT': 72, 'FR': 151, 'BK': 241 },\n   'MT': { 'SB': 235, 'LA': 320 },\n   'SB': { 'LA': 95 },\n   'LA': { 'SD': 120 },\n   'SD': { 'PX': 355 },\n   'FR': { 'LV': 391 },\n   'BK': { 'LA': 112, 'SD': 232, 'PX': 483, 'LV': 286 },\n   'LV': { 'PX': 297 },\n   'PX': {}\n};\n\nconsole.log(new Dijkstra().solve(graph, 'SF', 'PX'));\n```", "```js\nnode dijkstra/shortest-path.js \n```", "```js\n{ distance: 773, path: [ 'SF', 'SJ', 'BK', 'PX' ] } \n```", "```js\n[\n  {\n    \"name\": \"A\",\n    \"connections\": [\n      {\n        \"name\": \"E\",\n        \"relation\": \"Brother\"\n  },\n      {\n        \"name\": \"F\",\n        \"relation\": \"Sister\"\n  },\n      {\n        \"name\": \"B\",\n        \"relation\": \"Wife\"\n  },\n      {\n        \"name\": \"D\",\n        \"relation\": \"Son\"\n  },\n      {\n        \"name\": \"C\",\n        \"relation\": \"Daughter\"\n  }\n    ]\n  },\n  {\n    \"name\": \"B\",\n    \"connections\": [\n      {\n        \"name\": \"A\",\n        \"relation\": \"Husband\"\n  },\n      {\n        \"name\": \"D\",\n        \"relation\": \"Son\"\n  },\n      {\n        \"name\": \"C\",\n        \"relation\": \"Daughter\"\n  }\n    ]\n  },\n  {\n    \"name\": \"C\",\n    \"connections\": [\n      {\n        \"name\": \"A\",\n        \"relation\": \"Father\"\n  },\n      {\n        \"name\": \"B\",\n        \"relation\": \"Mother\"\n  },\n      {\n        \"name\": \"D\",\n        \"relation\": \"Brother\"\n  }\n    ]\n  },\n  {\n    \"name\": \"D\",\n    \"connections\": [\n      {\n        \"name\": \"A\",\n        \"relation\": \"Father\"\n  },\n      {\n        \"name\": \"B\",\n        \"relation\": \"Mother\"\n  },\n      {\n        \"name\": \"C\",\n        \"relation\": \"Sister\"\n  }\n    ]\n  },\n  {\n    \"name\": \"E\",\n    \"connections\": [\n      {\n        \"name\": \"A\",\n        \"relation\": \"Brother\"\n  },\n      {\n        \"name\": \"F\",\n        \"relation\": \"Sister\"\n  }\n    ]\n  },\n  {\n    \"name\": \"F\",\n    \"connections\": [\n      {\n        \"name\": \"E\",\n        \"relation\": \"Brother\"\n  },\n      {\n        \"name\": \"A\",\n        \"relation\": \"Brother\"\n  },\n      {\n        \"name\": \"G\",\n        \"relation\": \"Son\"\n  }\n    ]\n  },\n  {\n    \"name\": \"G\",\n    \"connections\": [\n      {\n        \"name\": \"F\",\n        \"relation\": \"Mother\"\n  }\n    ]\n  }\n]\n```", "```js\nINITIALIZE paths, nodes to visit (queue), visited nodes\n\nSET start node as visited\n\nWHILE nodes to visit exist\n\n    GET the next node to visit as current node from top of queue\n\n    IF current node is target\n\n        INITIALIZE result with target node\n\n        WHILE path retrieval not at source\n\n            EXTRACT how we got to this node\n\n            PUSH to result\n\n        FORMAT and return relationship\n\n    ELSE\n\n        LOOP over the entire graph\n\n            IF node is connected to current node\n\n                SET its path as current node\n\n                MARK node as visited\n\n                PUSH it to queue for visiting breadth wise\n\nRETURN Null that is no result\n\n```", "```js\nvar _ = require('lodash');\nvar BFS = require('./bfs');\nvar familyNodes = require('./family.json');\n\n// transform familyNodes into shorter format for simplified BFS var transformedFamilyNodes = _.transform(familyNodes, (reduced, currentNode) => {\n\n      reduced[currentNode.name] = _.map(currentNode.relations, 'name');\n\n      return reduced;\n}, {});\n```", "```js\n{ \n    A: [ 'E', 'F', 'B', 'D', 'C' ],\n    B: [ 'A', 'D', 'C' ],\n    C: [ 'A', 'B', 'D' ],\n    D: [ 'A', 'B', 'C' ],\n    E: [ 'A', 'F' ],\n    F: [ 'E', 'A', 'G' ],\n    G: [ 'F' ] \n}\n```", "```js\nvar _ = require('lodash');\n\nclass BFS {\n\n   constructor(familyNodes) {\n      this.familyNodes = familyNodes;\n   }\n\n   search (graph, startNode, targetNode) {\n\n   }\n\n}\n\nmodule.exports = BFS;\n```", "```js\nsearch (graph, startNode, targetNode) {\n   // initialize the path to traverse\n  var travelledPath = [];\n\n   // mark the nodes that need to be visited breadthwise\n  var nodesToVisit = [];\n\n   // mark all visited nodes\n  var visitedNodes = {};\n\n   // current node being visited\n  var currentNode;\n\n   // add start node to the to be visited path\n  nodesToVisit.push(startNode);\n\n   // mark starting node as visited node\n  visitedNodes[startNode] = true;\n\n   // while there are more nodes to go\n  while (nodesToVisit.length) {\n\n      // get the first one in the list to visit\n  currentNode = nodesToVisit.shift();\n\n      // if it is the target\n  if (_.isEqual(currentNode, targetNode)) {\n\n         // add to result, backtrack steps based on path taken\n  var result = [targetNode];\n\n         // while target is not source\n  while (!_.isEqual(targetNode, startNode)) {\n\n            // extract how we got to this node\n  targetNode = travelledPath[targetNode];\n\n            // add it to result\n  result.push(targetNode);\n         }\n\n         // extract the relationships between the edges and return\n         // value\n  return this.getRelationBetweenNodes(result.reverse());\n      }\n\n      // if result not found, set the next node to visit by traversing\n // breadth first  _.forOwn(graph, (connections, name) => {\n\n         // if not current node, is connected to current node \n         // and not already visited\n  if (!_.isEqual(name, currentNode)\n            && _.includes(graph[name], currentNode)\n            && !visitedNodes[name]) {\n\n            // we will be visiting the new node from current node\n  travelledPath[name] = currentNode;\n\n            // set the visited flag\n  visitedNodes[name] = true;\n\n            // push to nodes to visit\n  nodesToVisit.push(name);\n         }\n      });\n   }\n\n   // nothing found\n  return null;\n}\n```", "```js\ngetRelationBetweenNodes(relationship) {\n   // extract start and end from result\n  var start = relationship.shift();\n   var end = relationship.pop();\n\n   // initialize loop variables\n  var relation = '';\n   var current = start;\n   var next;\n   var relationWithNext;\n\n   // while end not found\n  while (current != end) {\n      // extract the current node and its relationships\n  current = _.find(this.familyNodes, { name: current });\n\n      // extract the next node, if nothing then set to end node\n  next = relationship.shift() || end;\n\n      // extract relationship between the current and the next node\n  relationWithNext = _.find(current.relations, {name : next });\n\n      // add it to the relation with proper grammar\n  relation += `${relationWithNext.relation}${next === end ? '' : \n '\\'s'} `;\n\n      // set next to current for next iteration\n  current = next;\n   }\n\n   // return result\n  return `${start}'s ${relation}is ${end}`;\n}\n```", "```js\nvar _ = require('lodash');\nvar BFS = require('./bfs');\nvar familyNodes = require('./family.json');\n\n// transform familyNodes into shorter format for simplified BFS var transformedFamilyNodes = _.transform(familyNodes, (reduced, currentNode) => {\n\n      reduced[currentNode.name] = _.map(currentNode.relations, 'name');\n\n      return reduced;\n}, {});\n\nvar relationship = new BFS(familyNodes).search(transformedFamilyNodes, 'C', 'G');\n\nconsole.log(relationship);\n```", "```js\nC's Father's Sister's Son is G \n```", "```js\nlet expenses = [\n   {\n      type: 'rent',\n      cost: 5\n  },\n   {\n      type: 'food',\n      cost: 3\n  },\n   {\n      type: 'entertainment',\n      cost: 2\n  },\n   {\n      type: 'car and gas',\n      cost: 2\n  },\n   {\n      type: 'ski-trip',\n      cost: 5\n  }\n];\n let total = 10;\n```", "```js\nCREATE empty 2d array with based on input data\n\nIF expected total 0, any element can achieve this, so set [i][0] to true\n\nIF cost of first row is less than total, set [0][cost] to true\n\nLOOP over each row from the second row\n\n    LOOP over each column\n\n        IF current row cost is less than the current column total\n\n            COPY from the row above, the value of the current column if\n            it is true\n                or else offset the column by current rows cost\n\n        ELSE\n\n            Copy value from the row above for the same column\n\nIF last element of the array is empty\n\n   No results found\n\ngenerate_possible_outcomes()\n\nFUNCTION generate_possible_outcomes\n\n    IF reached the end and sum is non 0\n\n       ADD cost as an option and return options\n\n    IF reached the end and sum is 0\n\n        return option\n\n    IF sum can be derived without current row cost\n\n        generate_possible_outcomes() from the previous row\n\n    IF sum cannot be derived without current row\n\n        ADD current row as an option\n\n        generate_possible_outcomes() from the previous row\n```", "```js\nvar _ = require('lodash');\n\nclass Planner {\n\n   constructor(rows, cols) {\n      // create a 2d array of rows x cols\n // all with value false  this.planner = _.range(rows).map(() => {\n         return _.range(cols + 1).map(()=> false);\n      });\n // holds the response\n      this.outcomes = [];\n   }\n}\n\nmodule.exports = Planner;\n```", "```js\nanalyze(expenses, sum) {\n   // get size of expenses\n  const size = _.size(expenses);\n\n   // if sum 0, result can be done with 0 elements so\n // set col 0 of all rows as true  _.times(size, (i)=> {\n      this.planner[i] = this.planner[i] || [];\n      this.planner[i][0] = true;\n   });\n\n   // for the first row, if the first cost in the expenses\n // is less than the requested total, set its column value // to true  if(expenses[0].cost <= sum) {\n      this.planner[0][expenses[0].cost] = true;\n   }\n\n```", "```js\n // start from row #2 and loop over all other rows  for(let i = 1; i < size; i++) {\n\n      // take each column\n  _.times(sum + 1, (j) => {\n\n         // if the expenses cost for the current row\n // is less than or equal to the sum assigned to the // current column  if (expenses[i].cost <= j) {\n\n            // copy value from above row in the same column if true\n // else look at the value offset by the current rows cost  this.planner[i][j] =  this.planner[i - 1][j] \n                                || this.planner[i - 1][j -\n                                expenses[i].cost];\n         } else {\n            // copy value from above row in the same column\n  this.planner[i][j] =  this.planner[i - 1][j];\n         }\n      });\n   }\n\n   // no results found\n  if (!this.planner[size - 1][sum]) {\n      return [];\n   }\n\n   // generate the outcomes from the results found\n  this.generateOutcomes(expenses, size - 1, sum, []);\n\n   return this.outcomes;\n}\n```", "```js\ngenerateOutcomes(expenses, i, sum, p) {\n   // reached the end and the sum is non zero\n  if(i === 0 && sum !== 0 && this.planner[0][sum]) {\n      p.push(expenses[i]);\n      this.outcomes.push(_.cloneDeep(p));\n      p = [];\n      return;\n   }\n\n   // reached the end and the sum is zero\n // i.e. reached the origin  if(i === 0 && sum === 0) {\n      this.outcomes.push(_.cloneDeep(p));\n      p = [];\n      return;\n   }\n\n   // if the sum can be generated\n // even without the current value  if(this.planner[i - 1][sum]) {\n      this.generateOutcomes(expenses, i - 1, sum, _.cloneDeep(p));\n   }\n\n   // if the sum can be derived\n // only by including the the current value  if(sum >= expenses[i].cost && this.planner[i - 1][sum -\n   expenses[i].cost]) {\n      p.push(expenses[i]);\n      this.generateOutcomes(expenses, i - 1, sum - expenses[i].cost,\n      p);\n   }\n}\n```", "```js\nvar Planner = require('./dp');\n\nlet expenses = [\n   {\n      type: 'rent',\n      cost: 5\n  },\n   {\n      type: 'food',\n      cost: 3\n  },\n   {\n      type: 'entertainment',\n      cost: 2\n  },\n   {\n      type: 'car and gas',\n      cost: 2\n  },\n   {\n      type: 'ski-trip',\n      cost: 5\n  }\n];\nlet total = 10;\n\nvar options = new Planner(expenses.length, total).analyze(expenses, total);\n\nconsole.log(options);\n```", "```js\n[ \n    [ { type: 'entertainment', cost: 2 },\n      { type: 'food', cost: 3 },\n      { type: 'rent', cost: 5 } \n    ],\n    [ { type: 'car and gas', cost: 2 },\n      { type: 'food', cost: 3 },\n      { type: 'rent', cost: 5 } \n    ],\n    [ { type: 'ski-trip', cost: 5 }, \n      { type: 'rent', cost: 5 } \n    ],\n    [ { type: 'ski-trip', cost: 5 },\n      { type: 'entertainment', cost: 2 },\n      { type: 'food', cost: 3 } \n    ],\n    [ { type: 'ski-trip', cost: 5 },\n      { type: 'car and gas', cost: 2 },\n      { type: 'food', cost: 3 } \n    ] \n]\n```", "```js\nconst graph = {\n   'SF': { 'SB': 326, 'MT': 118, 'SJ': 49 },\n   'SJ': { 'MT': 72, 'FR': 151, 'BK': 241 },\n   'MT': { 'SB': 235, 'LA': 320 },\n   'SB': { 'LA': 95 },\n   'LA': { 'SD': 120 },\n   'SD': { 'PX': 355 },\n   'FR': { 'LV': 391 },\n   'BK': { 'LA': 112, 'SD': 232, 'PX': 483, 'LV': 286 },\n   'LV': { 'PX': 297 },\n   'PX': {}\n};\n```", "```js\n[ \n  { from: 'SF', to: 'SB', weight: 326 },\n  { from: 'SF', to: 'MT', weight: 118 },\n  { from: 'SF', to: 'SJ', weight: 49 },\n  { from: 'SJ', to: 'MT', weight: 72 },\n  { from: 'SJ', to: 'FR', weight: 151 },\n  { from: 'SJ', to: 'BK', weight: 241 },\n  { from: 'MT', to: 'SB', weight: 235 },\n  { from: 'MT', to: 'LA', weight: 320 },\n  { from: 'SB', to: 'LA', weight: 95 },\n  { from: 'LA', to: 'SD', weight: 120 },\n  { from: 'SD', to: 'PX', weight: 355 },\n  { from: 'FR', to: 'LV', weight: 391 },\n  { from: 'BK', to: 'LA', weight: 112 },\n  { from: 'BK', to: 'SD', weight: 232 },\n  { from: 'BK', to: 'PX', weight: 483 },\n  { from: 'BK', to: 'LV', weight: 286 },\n  { from: 'LV', to: 'PX', weight: 297 } \n]\n```", "```js\nSORT all edges by weight in increasing order\n\nDIVIDE all nodes into their own subsets whose parent is the node iteself\n\nWHILE more edges are required\n\n    EXTRACT the first edge from the list of edges\n\n    FIND the parent nodes of the from and to nodes of that edge\n\n    IF start and end nodes do not have same parent\n\n        ADD edge to results\n\n        GET parent of from node and to node\n\n        IF parent nodes of from and to are the same rank\n\n            SET one node as the parent of the other and increment rank \n            of parent\n\n        ELSE\n\n            SET parent of element with lesser rank            \n\nRETURN Results\n```", "```js\nFIND_PARENT(all_subsets, currentNode)\n\n    IF parent of currentNode is NOT currentNode\n\n        FIND_PARENT(all_subsets, currentNode.parent)\n\n    RETURN currentNode.parent\n```", "```js\nconst _ = require('lodash');\nconst MST = require('./mst');\n\nconst graph = {\n   'SF': { 'SB': 326, 'MT': 118, 'SJ': 49 },\n   'SJ': { 'MT': 72, 'FR': 151, 'BK': 241 },\n   'MT': { 'SB': 235, 'LA': 320 },\n   'SB': { 'LA': 95 },\n   'LA': { 'SD': 120 },\n   'SD': { 'PX': 355 },\n   'FR': { 'LV': 391 },\n   'BK': { 'LA': 112, 'SD': 232, 'PX': 483, 'LV': 286 },\n   'LV': { 'PX': 297 },\n   'PX': {}\n};\n\nconst edges= [];\n\n_.forEach(graph, (values, node) => {\n   _.forEach(values, (weight, city) => {\n      edges.push({\n         from: node,\n         to: city,\n         weight: weight\n      });\n   });\n});\n\nvar mst = new MST(edges, _.keys(graph)).getNodes();\n\nconsole.log(mst);\n```", "```js\nconst _ = require('lodash');\n\nclass MST {\n\n   constructor(edges, vertices) {\n      this.edges = _.sortBy(edges, 'weight');\n      this.vertices = vertices;\n   }\n\n   getNodes () {\n      let result = [];\n\n      // subsets to track the parents and ranks\n  var subsets = {};\n\n      // split each vertex into its own subset\n // with each of them initially pointing to themselves  _.each(this.vertices, (val)=> {\n         subsets[val] = {\n            parent: val,\n            rank: 0\n  };\n      });\n\n      // loop over each until the size of the results\n // is 1 less than the number of vertices  while(!_.isEqual(_.size(result), _.size(this.vertices) - 1)) {\n\n         // get next edge\n  var selectedEdge = this.edges.shift();\n\n         // find parent of start and end nodes of selected edge\n  var x = this.find(subsets, selectedEdge.from);\n         var y = this.find(subsets, selectedEdge.to);\n\n         // if the parents nodes are not the same then\n // the nodes belong to different subsets and can be merged  if (!_.isEqual(x, y)) {\n\n            // add to result\n  result.push(selectedEdge);\n\n            // push is resultant tree as new nodes\n  this.union(subsets, x, y);\n         }\n      }\n\n      return result;\n   }\n\n   // find parent with path compression\n  find(subsets, i) {\n      let subset = subsets[i];\n\n      // until the parent is not itself, keep updating the\n // parent of the current node  if (subset.parent != i) {\n         subset.parent = this.find(subsets, subset.parent);\n      }\n\n      return subset.parent;\n   }\n\n   // union by rank\n  union(subsets, x, y) {\n      // get the root nodes of each of the nodes\n  let xRoot = this.find(subsets, x);\n\n      let yRoot = this.find(subsets, y);\n\n      // ranks equal so it doesnt matter which is the parent of which\n      node\n  if (_.isEqual(subsets[xRoot].rank, subsets[yRoot].rank)) {\n\n         subsets[yRoot].parent = xRoot;\n\n         subsets[xRoot].rank++;\n\n      } else {\n         // compare ranks and set parent of the subset\n  if(subsets[xRoot].rank < subsets[yRoot].rank) {\n\n            subsets[xRoot].parent = yRoot;\n         } else {\n\n            subsets[yRoot].parent = xRoot;\n         }\n      }\n   }\n\n}\n\nmodule.exports = MST;\n```", "```js\n[ { from: 'SF', to: 'SJ', weight: 49 },\n  { from: 'SJ', to: 'MT', weight: 72 },\n  { from: 'SB', to: 'LA', weight: 95 },\n  { from: 'BK', to: 'LA', weight: 112 },\n  { from: 'LA', to: 'SD', weight: 120 },\n  { from: 'SJ', to: 'FR', weight: 151 },\n  { from: 'MT', to: 'SB', weight: 235 },\n  { from: 'BK', to: 'LV', weight: 286 },\n  { from: 'LV', to: 'PX', weight: 297 } ]\n```", "```js\nconst list = [\n   {\n      name: 'vegetables',\n      value: 12,\n      cost: 4   },\n   {\n      name: 'candy',\n      value: 1,\n      cost: 1   },\n   {\n      name: 'magazines',\n      value: 4,\n      cost: 2   },\n   {\n      name: 'dvd',\n      value: 6,\n      cost: 2   },\n   {\n      name: 'earphones',\n      value: 6,\n      cost: 3   },\n   {\n      name: 'shoes',\n      value: 4,\n      cost: 2   },\n   {\n      name: 'supplies',\n      value: 9,\n      cost: 3   }\n];\n```", "```js\nconst costs = [4, 1, 2, 2, 3, 2, 3];\nconst value = [12, 1, 4, 6, 6, 4, 9];\nconst v2c = [12/4, 1/1, 4/2, 6/2, 6/3, 4/2, 9/3];\nconst maxCost = 10\n```", "```js\nconst costs = [4, 2, 3, 3, 2, 2, 1];\nconst value = [12, 6, 9, 6, 4, 4, 1];\nconst v2c = [3, 3, 3, 2, 2, 2, 1];\nconst maxCost = 10;\n```", "```js\nconst _ = require('lodash');\n\nclass BranchAndBound {\n\n   constructor(list, maxCost) {\n      // sort the costs in descending order for greedy calculation of \n      upper bound\n  var sortedList = _.orderBy(list, \n                     (option) => option.value/option.cost,\n                     'desc');\n\n      // original list\n  this.list = list;\n\n      // max allowed cost\n  this.maxCost = maxCost;\n\n      // all costs\n  this.costs = _.map(sortedList, 'cost');\n\n      // all values\n  this.values = _.map(sortedList, 'value');\n   }\n}\n\nmodule.exports = BranchAndBound;\n```", "```js\nconst _ = require('lodash');\n\nclass BranchAndBound {\n\n   constructor(list, maxCost) {\n      // sort the costs in descending order for greedy calculation of\n      upper bound\n  var sortedList = _.orderBy(list,\n                     (option) => option.value/option.cost,\n                     'desc');\n\n      // original list\n  this.list = list;\n\n      // max allowed cost\n  this.maxCost = maxCost;\n\n      // all costs\n  this.costs = _.map(sortedList, 'cost');\n\n      // all values\n  this.values = _.map(sortedList, 'value');\n   }\n\n   calculate() {\n      // size of the input data set\n  var size = _.size(this.values);\n\n      // create a queue for processing nodes\n  var queue = [];\n\n      // add dummy root node\n  queue.push({\n         depth: -1,\n         value: 0,\n         cost: 0,\n         upperBound: 0\n  });\n\n      // initialize result\n  var maxValue = 0;\n\n      // initialize path to the result\n  var finalIncludedItems = [];\n\n      // while queue is not empty\n // i.e leaf node not found  while(!_.isEmpty(queue)) {\n\n         // initialize next node\n  var nextNode = {};\n\n         // get selected node from queue\n  var currentNode = queue.shift();\n\n         // if leaf node, no need to check for child nodes\n  if (currentNode.depth !== size - 1) {\n\n            // increment depth of the node\n  nextNode.depth = currentNode.depth + 1;\n\n            /*\n * *  We need to calculate the cost and value when the next\n               item *  is included and when it is not * * *  First we check for when it is included */   // increment cost of the next node by adding current nodes\n            cost to it // adding current nodes cost is indicator that it is\n            included  nextNode.cost =  currentNode.cost +\n            this.costs[nextNode.depth];\n\n            // increment value of the next node similar to cost\n  nextNode.value =  currentNode.value +\n            this.values[nextNode.depth];\n\n            // if cost of next node is below the max and the value\n            provided\n // by including it is more than the currently accrued value // i.e. bounds and constrains satisfied  if (nextNode.cost <= this.maxCost && nextNode.value >\n            maxValue) {\n\n               // add node to results\n  finalIncludedItems.push(nextNode.depth);\n\n               // update maxValue accrued so far\n  maxValue = nextNode.value;\n            }\n\n            // calculate the upper bound value that can be\n // generated from the new node  nextNode.upperBound = this.upperBound(nextNode, size,\n                              this.maxCost, this.costs, this.values);\n\n            // if the node is still below the upper bound\n  if (nextNode.upperBound > maxValue) {\n\n               // add to queue for further consideration\n  queue.push(_.cloneDeep(nextNode));\n            }\n\n            /*\n *  Then we check for when the node is not included */   // copy over cost and value from previous state  nextNode.cost = currentNode.cost;\n            nextNode.value = currentNode.value;\n\n            // recalculate upper bound\n  nextNode.upperBound = this.upperBound(nextNode, size,\n                              this.maxCost, this.costs, this.values);\n\n            // if max value is still not exceeded,\n // add to queue for processing later  if (nextNode.upperBound > maxValue) {\n\n               // add to queue for further consideration\n  queue.push(_.cloneDeep(nextNode));\n            }\n         }\n      }\n\n      // return results\n  return { val: maxValue, items: _.pullAt(this.list,\n      finalIncludedItems) };\n   }\n\n   upperBound(node, size, maxCost, costs, values) {\n      // if nodes cost is over the max allowed cost\n  if (node.cost > maxCost) {\n         return 0;\n      }\n\n      // value of current node\n  var valueBound = node.value;\n\n      // increase depth\n  var nextDepth = node.depth + 1;\n\n      // init variable for cost calculation\n // starting from current node  var totCost = node.cost;\n\n      // traverse down the upcoming branch of the tree to see what\n // cost would be at the leaf node  while ((nextDepth < size) && (totCost + costs[nextDepth] <=\n      maxCost)) {\n         totCost += costs[nextDepth];\n         valueBound += values[nextDepth];\n         nextDepth++;\n      }\n\n      // allow fractional value calculations\n // for the last node  if (nextDepth < size) {\n         valueBound += (maxCost - totCost) * values[nextDepth] / \n         costs[nextDepth];\n      }\n\n      // return final value at leaf node\n  return valueBound;\n   }\n}\n\nmodule.exports = BranchAndBound;\n```", "```js\nconst _ = require('lodash');\nconst BnB = require('./bnb');\n\nconst list = [\n   {\n      name: 'vegetables',\n      value: 12,\n      cost: 4\n  },\n   {\n      name: 'candy',\n      value: 1,\n      cost: 1\n  },\n   {\n      name: 'magazines',\n      value: 4,\n      cost: 2\n  },\n   {\n      name: 'dvd',\n      value: 6,\n      cost: 2\n  },\n   {\n      name: 'earphones',\n      value: 6,\n      cost: 3\n  },\n   {\n      name: 'shoes',\n      value: 4,\n      cost: 2\n  },\n   {\n      name: 'supplies',\n      value: 9,\n      cost: 3\n  }\n];\n\nconst budget = 10;\n\nvar result = new BnB(list, budget).calculate();\n\nconsole.log(result);\n```", "```js\n{ \n  val: 28,\n  items:[ \n     { name: 'vegetables', value: 12, cost: 4 },\n     { name: 'candy', value: 1, cost: 1 },\n     { name: 'magazines', value: 4, cost: 2 },\n     { name: 'supplies', value: 9, cost: 3 } \n  ] \n}\n```", "```js\nvar _ = require('lodash');\n\nvar count = 10;\n\nbruteForceFibonacci(count);\n\nfunction bruteForceFibonacci(count) {\n   var prev = 0;\n   var next = 1;\n   var res = '';\n\n   res += prev;\n   res += ',' + next;\n\n   _.times(count, ()=> {\n      var tmp = next;\n      next = prev + next;\n      prev = tmp;\n\n      res += ',' + next;\n   });\n\n   console.log(res);\n}\n```", "```js\nfunction recursiveFibonacci(num) {\n   if (num == 0) {\n      return 0;\n   } else if (num == 1 || num == 2) {\n      return 1;\n   } else {\n      return recursiveFibonacci(num - 1) + recursiveFibonacci(num - 2);\n   }\n}\n```", "```js\nfunction memoizedFibonacci(num) {\n   if (num == 0) {\n      memory[num] = 0;\n      return 0;\n   } else if (num == 1 || num == 2) {\n      memory[num] = 1;\n      return 1;\n   } else {\n      if (!memory[num]) {\n         memory[num] = memoizedFibonacci(num - 1) +\n         memoizedFibonacci(num - 2);\n      }\n\n      return memory[num];\n   }\n}\n```"]