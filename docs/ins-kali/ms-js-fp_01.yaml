- en: Becoming Functional – Several Questions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为函数式编程者——几个问题
- en: '–Functional Programming (or FP, as it''s usually shortened) has been around
    since the earliest times and is going through a sort of revival, due to its increased
    use with several frameworks and libraries, and most particularly in JavaScript.
    In this chapter, we shall:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '- 函数式编程（通常缩写为FP）自古以来就存在，并且由于它在几个框架和库中的广泛使用，尤其是在JavaScript中的增加使用，它正在经历一种复兴。在本章中，我们将：'
- en: Introduce some concepts of FP, to give a small taste of what it means
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些函数式编程的概念，给出一点点它的意义
- en: Show benefits (and problems) implied by the usage of FP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示使用函数式编程所暗示的好处（和问题）
- en: Start thinking about why **JavaScript** (**JS**) can be considered to be an
    appropriate language for FP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始思考为什么**JavaScript**（**JS**）可以被认为是适合函数式编程的语言
- en: Go over the language features and tools that you should be aware of, to fully
    take advantage of everything in this book
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解你应该注意的语言特性和工具，以充分利用本书中的一切
- en: So, let's get started by asking ourselves *What is FP?* and start working on
    that topic.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始问自己*什么是函数式编程？*并开始研究这个主题。
- en: What is Functional Programming?
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式编程？
- en: If you go back in computer history, you'll find that the second–oldest programming
    language still in use, LISP, has its bases in Functional Programming. Since then
    there have been many more functional languages, and FP has been applied more widely.
    But even so, if you ask around what FP is, you'll probably get two widely dissimilar
    answers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾计算机历史，你会发现仍在使用的第二古老的编程语言LISP，它的基础就是函数式编程。从那时起，出现了许多更多的函数式语言，并且函数式编程得到了更广泛的应用。但即便如此，如果你询问函数式编程是什么，你可能会得到两种截然不同的答案。
- en: Depending on whom you ask, you'll either learn that it's a modern, advanced,
    enlightened approach to programming that leaves every other paradigm behind, or
    you'll be told that it's mainly a theoretical thing, with more complications than
    benefits, practically impossible to implement in the real world. And, as usual, the
    real answer is not in the extremes, but somewhere within.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你问的人，你要么会得知它是一种现代的、先进的、开明的编程方法，超越了其他范式，要么会被告知它主要是一个理论上的东西，比好处更多的是复杂性，在实际世界中几乎不可能实现。而且，通常情况下，真正的答案不在极端之间，而是在其中某个地方。
- en: 'For Trivia buffs, the oldest language still in use is FORTRAN, which appeared
    in 1957, a year before LISP. Quite shortly after LISP came another long–lived
    language: COBOL, for business–oriented programming.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于琐事迷来说，仍在使用的最古老的语言是FORTRAN，它于1957年出现，比LISP早了一年。LISP之后不久又出现了另一种长寿的语言：面向业务编程的COBOL。
- en: Theory versus practice
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理论与实践
- en: 'In this book, we won''t be going about FP in a theoretical way: our point is,
    rather, to show how some of its techniques and tenets can be successfully applied
    for common, everyday JavaScript programming. But, and this is important, we won''t
    be going about this in a dogmatic fashion, but rather in a very practical way.
    We won''t dismiss useful JS constructs, only because they don''t happen to fulfill
    the academic expectations of FP. We won''t avoid practical JS features just to
    fit the FP paradigm. In fact, we could almost say we''ll be doing *SFP—**Sorta
    Functional Programming*because our code will be a mixture of FP features and more
    classical imperative and **Object Oriented Programming** (**OOP**).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们不会以理论的方式来讨论函数式编程：我们的观点是，相反地，要展示一些函数式编程的技术和原则如何成功地应用于日常的JavaScript编程。但是，这很重要，我们不会以教条的方式来做这件事，而是以非常实际的方式。我们不会因为它们不符合函数式编程的学术期望而放弃有用的JS构造。我们也不会避免实际的JS特性，只是为了符合函数式编程的范式。事实上，我们几乎可以说我们将会做*SFP—**有点函数式编程*，因为我们的代码将是函数式编程特性和更经典的命令式和**面向对象编程**（**OOP**）的混合。
- en: (This doesn't mean that we'll be leaving all the theory by the side. We'll be
    picky, and just touch the main theoretical points, give some vocabulary and definitions,
    and explain core FP concepts... but we'll always be keeping in sight the idea
    of helping to produce actual, useful, JS code, and not to try to achieve some
    mystical, dogmatic FP criteria.)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: （这并不意味着我们会把所有的理论都丢在一边。我们会挑剔，只触及主要的理论要点，给一些词汇和定义，并解释核心的函数式编程概念...但我们始终会牢记帮助产生实际有用的JS代码的想法，而不是试图达到某种神秘的、教条式的函数式编程标准。）
- en: OOP has been a way to solve the inherent complexity of writing large programs
    and systems, and developing clean, extensible, scalable application architectures.
    However, because of the scale of today's web applications, the complexity of all
    codebases is continuously growing. Also, the newer features of JS make it possible
    to develop applications that wouldn't even have been possible just a few years
    ago; think of mobile (hybrid) apps done with Ionic, Apache Cordova, or React Native,
    or desktop apps done with Electron or NW.js, for example. JS has also migrated
    to the backend with Node.js, so today the scope of usage for the language has
    grown in a serious way, and dealing with all the added complexity taxes all designs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OOP一直是解决编写大型程序和系统的固有复杂性，以及开发清洁、可扩展、可伸缩的应用架构的一种方式。然而，由于今天的Web应用规模不断增长，所有代码库的复杂性也在不断增加。此外，JS的新特性使得开发几年前甚至不可能的应用成为可能；例如，使用Ionic、Apache
    Cordova或React Native开发的移动（混合）应用，或者使用Electron或NW.js开发的桌面应用。JS也已经迁移到了后端，使用Node.js，因此今天语言的使用范围已经严重扩大，处理所有增加的复杂性对所有设计都是一种负担。
- en: A different way of thinking
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一种不同的思维方式
- en: 'FP implies a different way of writing programs, which can sometimes be difficult
    to learn. In most languages, programming is done in imperative fashion: a program
    is a sequence of statements, executed in a prescribed fashion, and the desired
    result is achieved by creating objects and doing manipulations on them, which
    usually modify the objects themselves. FP is based on producing the desired result
    by evaluating expressions, built out of functions composed together. In FP, it''s
    usual to pass functions around (as parameters to other functions, or returned
    as the result of some calculation), to not use loops (opting for recursion instead),
    and to skip side effects (such as modifying objects or global variables).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: FP意味着一种不同的编程方式，有时可能很难学习。在大多数语言中，编程是以命令式的方式进行的：程序是一系列语句，按照规定的方式执行，并通过创建对象并对它们进行操作来实现所需的结果，通常会修改对象本身。FP是基于通过评估表达式来产生所需的结果，这些表达式由组合在一起的函数构建而成。在FP中，通常会传递函数（作为其他函数的参数，或作为某些计算的结果返回），不使用循环（而是选择递归），并且跳过副作用（例如修改对象或全局变量）。
- en: Another way of saying this, is that FP focuses on *what*should be done, rather
    than on *how*. Instead of worrying about loops or arrays, you work at a higher
    level, considering what you need to be done. After getting accustomed to this
    style, you'll find that your code becomes simpler, shorter, more elegant, and
    can be easily tested and debugged. However, don't fall into the trap of considering
    FP as a goal! Think of FP only as a means towards an end, as with all software
    tools. Functional code isn't good just for being functional... and writing bad
    code is just as possible with FP as with any other techniques!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种说法是，FP关注的是*应该*做什么，而不是*如何*做。你不必担心循环或数组，而是在更高的层次上工作，考虑需要完成的任务。适应了这种风格之后，你会发现你的代码变得更简单、更短、更优雅，并且可以轻松进行测试和调试。然而，不要陷入将FP视为目标的陷阱！将FP仅视为达到目的的手段，就像所有软件工具一样。功能性代码并不仅仅因为是功能性的而好...使用FP编写糟糕的代码与使用其他技术一样可能！
- en: What Functional Programming is not
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程不是什么
- en: 'Since we have been saying some things about what FP is, let''s also clear some
    common misconceptions, and consider some things that FP is *not*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经说了一些关于FP是什么的事情，让我们也澄清一些常见的误解，并考虑一些FP*不是*的事情：
- en: '**FP isn''t just an academic ivory tower thing**: It is true that the *lambda
    calculus*upon which it is based, was developed by Alonzo Church in 1936, as a
    tool in order to prove an important result in theoretical computer science. (This
    work preceded modern computer languages by more than 20 years!). However, FP languages
    are being used today for all kinds of systems.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FP不仅仅是学术的象牙塔之物**：它是真实的，基于它的*lambda演算*是由阿隆佐·邱奇在1936年开发的，作为证明理论计算机科学中重要结果的工具。（这项工作比现代计算机语言早了20多年！）然而，FP语言今天被用于各种系统。'
- en: '**FP isn''t the opposite of object–oriented programming (OOP)**: Also, it isn''t
    either a case of choosing declarative or imperative ways of programming. You can
    mix and match as it best suits you, and we''ll be doing that sort of thing in
    this book, bringing together the best of all worlds.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FP不是面向对象编程（OOP）的对立面**：它也不是选择声明式或命令式编程的情况。你可以根据自己的需要混合使用，我们将在本书中进行这种混合，汇集所有最好的东西。'
- en: '**FP isn''t overly complex to learn**: Some of the FP languages are rather
    different from JS, but the differences are mostly syntactic. Once you learn the
    basic concepts, you''ll see you can get the same results in JS as with FP languages.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习FP并不是过于复杂**：一些FP语言与JS相比相当不同，但区别主要是语法上的。一旦你学会了基本概念，你会发现你可以在JS中获得与FP语言相同的结果。'
- en: It may also be relevant to mention that several modern frameworks, such as the
    React+Redux combination, include FP ideas. For example, in React it's said that
    the view (whatever the user gets to see at a given moment) is a function of the
    current state. You use a function to compute what HTML and CSS must be produced
    at each moment, thinking in *black box* fashion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的是，一些现代框架，如React+Redux组合，包含了FP的思想。例如，在React中，视图（用户在某一时刻看到的内容）被认为是当前状态的函数。你使用函数来计算每个时刻必须生成的HTML和CSS，以*黑盒*的方式思考。
- en: Similarly, in Redux you get the concept of *actions*that are processed by *reducers*.
    An action provides some data, and a reducer is a function that produces the new
    state for the application in a functional way out of the current state and the
    provided data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在Redux中，你会得到*actions*的概念，这些*actions*由*reducers*处理。一个*action*提供一些数据，而*reducer*是一个函数，以一种功能性的方式从当前状态和提供的数据中产生应用程序的新状态。
- en: So, both because of theoretical advantages (we'll be getting to those in the
    following section) and of practical ones (such as getting to use the latest frameworks
    and libraries) it makes sense to consider FP coding; let's get on with it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论是因为理论上的优势（我们将在接下来的部分中介绍这些优势）还是实际上的优势（比如能够使用最新的框架和库），考虑使用FP编码都是有意义的；让我们开始吧。
- en: Why use Functional Programming?
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数式编程？
- en: Throughout the years, there have been many programming styles and fads. However,
    FP has proved quite resilient and is of great interest today. Why would you care
    to use FP? The question should rather first be, *What do you want to get?*and
    only then *Does FP get you that?*
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，出现了许多编程风格和潮流。然而，FP已经被证明相当有韧性，并且今天非常有趣。你为什么要关心使用FP？问题应该首先是，*你想得到什么？*然后才是*FP能帮你实现吗？*
- en: What we need
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要的
- en: 'We can certainly agree that the following list of concerns are universal. Our
    code should be:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以同意以下关注点是普遍的。我们的代码应该是：
- en: '**Modular**: The functionality of your program should be divided into independent
    modules, each of which contains what it needs to perform one aspect of the program
    functionality. Changes in a module or function shouldn''t affect the rest of the
    code.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块化**：程序的功能应该被划分为独立的模块，每个模块包含执行程序功能的一个方面所需的内容。对模块或函数的更改不应影响代码的其余部分。'
- en: '**Understandable**: a reader of your program should be able to discern its
    components, their functions, and understand their relationships without undue
    effort. This is highly correlated with *maintainability*: your code will have
    to be maintained at some time in the future, to change or add some new functionality.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可理解性**：程序的读者应该能够辨别其组件、它们的功能，并理解它们之间的关系，而不需要过多的努力。这与*可维护性*高度相关：你的代码将来必须进行维护，以改变或添加一些新功能。'
- en: '**Testable**: *unit tests*try out small parts of your program, verifying their
    behavior with independence of the rest of the code. Your programming style should
    favor writing code that simplifies the job of writing unit tests. Also, unit tests
    are like documentation, insofar that they can help readers understand what the
    code is supposed to do.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：*单元测试*尝试测试程序的小部分，验证它们的行为与其余代码的独立性。你的编程风格应该有利于编写简化编写单元测试工作的代码。此外，单元测试就像文档，因为它们可以帮助读者理解代码应该做什么。'
- en: '**Extensible**: it''s a fact that your program will someday require maintenance,
    possibly to add new functionality. Those changes should impact only minimally
    (if at all) the structure and data flow of the original code. Small changes shouldn''t
    imply large, serious refactorings of your code.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：事实上，你的程序总有一天会需要维护，可能是为了添加新功能。这些更改应该对原始代码的结构和数据流只有最小的影响（如果有的话）。小的更改不应该意味着对代码进行大规模、严重的重构。'
- en: '**Reusable**: *code reuse* has the goal of saving resources, time, money, and
    reducing redundancy, by taking advantage of previously written code. There are
    some characteristics that help this goal, such as *modularity* (which we already
    mentioned), plus *high cohesion* (all the pieces in a module do belong together),
    *low coupling* (modules are independent of each other), *separation of concerns*
    (the parts of a program should overlap in functionality as little as possible),
    and *information hiding* (internal changes in a module shouldn''t affect the rest
    of the system).'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：*代码重用*的目标是通过利用先前编写的代码来节省资源、时间、金钱，并减少冗余。有一些特征有助于实现这一目标，比如*模块化*（我们已经提到过），再加上*高内聚*（模块中的所有部分都是相关的）、*低耦合*（模块之间相互独立）、*关注点分离*（程序的各部分应该尽可能少地重叠功能）、以及*信息隐藏*（模块内部的变化不应该影响系统的其余部分）。'
- en: What we get
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们得到了什么
- en: So, now, does FP get you these five characteristics?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，FP是否能满足这五个特点呢？
- en: In FP, the goal is writing separate independent functions, which are joined
    together to produce the final results.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在FP中，目标是编写独立的函数，它们被组合在一起以产生最终结果。
- en: Programs written in functional style usually tend to be cleaner, shorter, and
    easier to understand.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数式风格编写的程序通常更加清晰、更短、更容易理解。
- en: Functions can be tested on its own, and FP code has advantages for that.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数可以单独进行测试，FP代码在这方面有优势。
- en: You can reuse functions in other programs, because they stand on their own,
    not depending on the rest of the system. Most functional programs share common
    functions, several of which we'll be considering in this book.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在其他程序中重用函数，因为它们是独立的，不依赖于系统的其他部分。大多数函数式程序共享常见的函数，其中我们将在本书中考虑其中的一些。
- en: Functional code is free from side effects, which means you can understand the
    objective of a function by studying it, without having to consider the rest of
    the program.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式代码没有副作用，这意味着你可以通过研究函数来理解其目的，而不必考虑程序的其余部分。
- en: Finally, once you get used to FP ways, code becomes more understandable and
    easier to extend. So, it seems that all five characteristics can be ensured with
    FP!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦你习惯了FP的方式，代码就会变得更容易理解和扩展。因此，似乎所有五个特点都可以通过FP来实现！
- en: For a well balanced look at reasons for FP, I'd suggest reading *Why Functional
    Programming Matters*, by John Hughes; it's available online at [www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf.).
    It's not geared towards JS, but the arguments are easily understandable, anyway.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于FP的原因，我建议阅读约翰·休斯的《为什么函数式编程很重要》（Why Functional Programming Matters）；它可以在网上找到[www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf](http://www.cs.kent.ac.uk/people/staff/dat/miranda/whyfp90.pdf)。虽然它不是针对JS的，但这些论点仍然很容易理解。
- en: Not all is gold...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并非所有都是金子……
- en: However, let's strive for a bit of balance. Using FP isn't a *silver bullet*that
    will *automagically*make your code better. Some FP solutions are actually tricky
    — and there are developers who show much glee in writing code and then asking
    *What does this do?*If you aren't careful, your code may become *write–only*,
    practically impossible to maintain... and there go *Understandable*, *Extensible*,
    and *Reusable* out of the door!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，让我们努力追求一点平衡。使用FP并不是一个能够自动使你的代码变得更好的“灵丹妙药”。一些FP解决方案实际上是棘手的，有些开发人员在编写代码后会兴高采烈地问“这段代码是做什么用的？”如果你不小心，你的代码可能会变得“只能写”，几乎不可能维护……这样就会失去“可理解性”、“可扩展性”和“可重用性”！
- en: 'Another disadvantage: you may find it harder to find FP*–*savvy developers.
    (Quick question: how many *Functional Programmer Sought* job ads have you ever
    seen?) The vast majority of today''s JS code is written in imperative, non*–*functional
    ways, and most coders are used to that way of working. For some, having to switch
    gears and start writing programs in a different way, may prove an unpassable barrier.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个缺点是：你可能会发现很难找到精通FP的开发人员。（快问：你见过多少招聘“寻找函数式编程员”的工作广告？）今天绝大多数的JS代码都是用命令式、非函数式的方式编写的，大多数编程人员习惯于这种工作方式。对于一些人来说，不得不转变思路，开始以不同的方式编写程序，可能会成为一个无法逾越的障碍。
- en: Finally, if you try to go *fully functional*, you may find yourself at odds
    with JS, and simple tasks may become hard to do. As we said at the beginning,
    we'll rather opt for *Sorta FP*, so we won't be drastically rejecting any JS features
    that aren't 100% functional. We want to use FP to simplify our coding, not to
    make it more complex!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你试图完全采用函数式方法，你可能会发现自己与JS不合拍，简单的任务可能会变得难以完成。正如我们在开始时所说的，我们更愿意选择“有点函数式”，因此我们不会彻底拒绝任何不是100%函数式的JS特性。我们希望使用FP来简化我们的编码，而不是使其更加复杂！
- en: So, while I'll strive to show you the advantages of going functional in your
    code, as with any change, there will always be some difficulties. However, I'm
    fully convinced that you'll be able to surmount them and that your organization
    will develop better code by applying FP. Dare to change!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，虽然我会努力向你展示在你的代码中采用功能性的优势，但与任何改变一样，总会有一些困难。然而，我完全相信你能够克服这些困难，并且你的组织将通过应用FP开发出更好的代码。敢于改变！
- en: Is JavaScript functional?
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript是功能性的吗？
- en: 'About this time, another important question that you should be asking: *Is
    JS a functional language?*Usually, when thinking about FP, the mentioned languages
    do not include JS, but do listless common options, such as Clojure, Erlang, Haskell,
    or Scala. However, there is no precise definition for FP languages or a precise
    set of features that such languages should include. The main point is that you
    can consider a language to be functional if it supports the common programming
    style associated with FP.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在这个时候，你应该问另一个重要的问题：*JS是一种功能性语言吗？*通常，在考虑FP时，提到的语言不包括JS，但列出了一些常见的选项，比如Clojure、Erlang、Haskell或Scala。然而，对于FP语言没有明确的定义，也没有一组确切的特性。主要的观点是，如果一种语言支持与FP相关的常见编程风格，那么你可以认为它是功能性的。
- en: JavaScript as a tool
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript作为一种工具
- en: What is JS? If you consider *popularity indices*such as the ones at [www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/)
    or[http://pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html), you'll find
    that JS consistently is in the *top ten*of popularity. From a more academic point
    of view, the language is sort of a mixture, with features from several different
    languages. Several libraries helped the growth of the language, by providing features
    that weren't so easily available, as classes and inheritance (today's version
    of JS does support classes, but that was not the case not too long ago) that otherwise
    had to be simulated by doing some *prototype* tricks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JS是什么？如果你考虑像[www.tiobe.com/tiobe-index/](http://www.tiobe.com/tiobe-index/)或[http://pypl.github.io/PYPL.html](http://pypl.github.io/PYPL.html)这样的*流行指数*，你会发现JS一直处于*十大*流行之列。从更学术的角度来看，这种语言有点像混合体，具有来自几种不同语言的特性。几个库帮助了语言的发展，通过提供一些不那么容易获得的特性，比如类和继承（今天的JS版本确实支持类，但不久前还不是这样），否则必须通过一些*原型*技巧来模拟。
- en: The name *JavaScript*was chosen to take advantage of the popularity of Java
    — just as a marketing ploy! Its first name was *Mocha*; then, *LiveScript*, and
    only then, *JavaScript*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*JavaScript*这个名字是为了利用Java的流行而选择的——只是作为一种营销策略！它的第一个名字是*Mocha*；然后是*LiveScript*，然后才是*JavaScript*。'
- en: JS has grown to be incredibly powerful. But, as with all power tools, it gives
    you a way to produce great solutions, and also to do great harm. FP could be considered
    to be a way to reduce or leave aside some of the worst parts of the language and
    focus on working in a safer, better way. However, due to the immense amount of
    existing JS code, you cannot expect large reworkings of the language that would
    cause most sites to fail. You must learn to live on with the good and the bad,
    and simply avoid the latter parts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JS已经发展成为非常强大的工具。但是，就像所有强大的工具一样，它可以帮助你产生出色的解决方案，也可以造成巨大的伤害。FP可以被认为是一种减少或放弃语言中一些最糟糕部分的方式，并专注于以更安全、更好的方式工作。然而，由于现有的大量JS代码，你不能期望对语言进行大规模的重构，这将导致大多数网站失败。你必须学会接受好的和坏的，并简单地避免后者。
- en: In addition, JS has a broad variety of available libraries that complete or
    extend the language in many ways. In this book, we'll be focusing on using JS
    on its own, but we will make references to existing, available code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JS有各种各样的可用库，以许多方式完善或扩展语言。在本书中，我们将专注于单独使用JS，但我们将参考现有的可用代码。
- en: If we ask if JS is actually functional, the answer will be, once again, *sorta*.
    JS can be considered to be functional, because of several features such as first*–*class
    functions, anonymous functions, recursion, and closures -- we'll get back to this
    later. On the other hand, JS has plenty of *non–FP* aspects, such as side effects
    (*impurity*), mutable objects, and practical limits to recursion. So, when programming
    in a functional way, we'll be taking advantage of all the relevant JS language
    features, and we'll try to minimize the problems caused by the more conventional
    parts of the language. In this sense, JS will or won't be functional, depending
    on *your* programming style!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们问JS是否实际上是功能性的，答案将是，再一次，有点。由于一些特性，如一流函数，匿名函数，递归和闭包，JS可以被认为是功能性的——我们稍后会回到这个问题。另一方面，JS有很多非函数式的方面，比如副作用（不纯性），可变对象和递归的实际限制。因此，当以一种功能性的方式编程时，我们将利用所有相关的JS语言特性，并尽量减少语言更传统部分造成的问题。从这个意义上讲，JS将或不将是功能性的，取决于你的编程风格！
- en: 'If you want to use FP, you should decide upon which language to use. However,
    opting for fully functional languages may not be so wise. Today, developing code
    isn''t as simple as just using a language: you will surely require frameworks,
    libraries, and other sundry tools. If we can take advantage of all the provided
    tools, but at the same time introduce FP ways of working in our code, we''ll be
    getting the best of both worlds — and never mind if JS is or isn''t functional!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用FP，你应该决定使用哪种语言。然而，选择完全功能性的语言可能并不明智。今天，开发代码并不像只是使用一种语言那么简单：你肯定需要框架、库和其他各种工具。如果我们可以利用所有提供的工具，同时在我们的代码中引入FP工作方式，我们将得到最好的两种世界——不管JS是不是功能性！
- en: Going functional with JavaScript
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JavaScript进行功能性编程
- en: 'JS has evolved through the years, and the version we''ll be using is (informally)
    called JS8, and (formally) ECMAScript 2017, usually shortened to ES2017 or ES8;
    this version was finalized in June 2017. The previous versions were:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: JS经过多年的发展，我们将使用的版本（非正式地）称为JS8，（正式地）称为ECMAScript 2017，通常缩写为ES2017或ES8；这个版本于2017年6月完成。之前的版本有：
- en: ECMAScript 1, June 1997
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 1，1997年6月
- en: ECMAScript 2, June 1998, basically the same as the previous version
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 2，1998年6月，基本上与上一个版本相同
- en: ECMAScript 3, December 1999, with several new functionalities
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 3，1999年12月，带有几个新功能
- en: ECMAScript 5 appeared only in December 2009 (and no, there never was an ECMAScript
    4, because it was abandoned)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5只在2009年12月出现（不，从来没有ECMAScript 4，因为它被放弃了）
- en: ECMAScript 5.1 was out in June 2011
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 5.1于2011年6月发布
- en: ECMAScript 6 (or ES6; later renamed ES2015) in June 2015
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 6（或ES6；后来更名为ES2015）于2015年6月发布
- en: ECMAScript 7 (also ES7, or ES2016) was finalized in June 2016
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 7（也是ES7，或ES2016）于2016年6月最终确定
- en: ECMAScript 8 (ES8 or ES2017) was finalized in June 2017
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECMAScript 8（ES8或ES2017）于2017年6月最终确定
- en: ECMA originally stood for European Computer Manufacturers Association, but nowadays
    the name isn't considered an acronym anymore. The organization is responsible
    for more standards other than JS, including JSON, C#, Dart, and others. See its
    site at [www.ecma-international.org/](http://www.ecma-international.org/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: ECMA最初代表欧洲计算机制造商协会，但现在这个名字不再被认为是一个首字母缩写。该组织负责的标准不仅仅是JS，还包括JSON、C#、Dart等。请参阅其网站[www.ecma-international.org/](http://www.ecma-international.org/)。
- en: You can read the standard language specification at [www.ecma-international.org/ecma-262/7.0/](http://www.ecma-international.org/ecma-262/7.0/).
    Whenever we refer to JS in the text without further specification, ES8 (ES2017)
    is meant. However, in terms of the language features that are used in the book,
    if your were just to use ES2015, you'd have no problems with this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[www.ecma-international.org/ecma-262/7.0/](http://www.ecma-international.org/ecma-262/7.0/)上阅读标准语言规范。每当我们在文本中提到JS而没有进一步的规定时，指的是ES8（ES2017）。然而，在本书中使用的语言特性方面，如果您只使用ES2015，您不会在本书中遇到问题。
- en: No browsers fully implement ES8; most provide an older version, JavaScript 5
    (from 2009), with a (always growing) smattering of ES6, ES7, and ES8 features.
    This will prove to be a problem, but fortunately, a solvable one; we'll get to
    this shortly, and we'll be using ES8 throughout the book.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 没有浏览器完全实现ES8；大多数提供较旧版本的JavaScript 5（从2009年开始），其中包含ES6、ES7和ES8的一些功能。这将成为一个问题，但幸运的是，这是可以解决的；我们很快就会解决这个问题，并且在整本书中我们将使用ES8。
- en: In fact, there are only a little differences between ES2016 and ES2015, such
    as the `Array.prototype.includes` method and the exponentiation operator `**`.
    There are more differences between ES2017 and ES2016 *– *such as `async` and `await`,
    some string padding functions, and more *– *but they won't impact our code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，ES2016和ES2015之间只有一点点区别，比如`Array.prototype.includes`方法和指数运算符`**`。ES2017和ES2016之间有更多的区别，比如`async`和`await`，一些字符串填充函数等，但它们不会影响我们的代码。
- en: Key features of JavaScript
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript的主要特点
- en: 'JS isn''t a functional language, but it has all the features we need to work
    as if it were. The main features of the language that we will be using are:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: JS不是一种函数式语言，但它具有我们需要的所有功能，可以像函数式语言一样工作。我们将使用的语言的主要特点是：
- en: Functions as first*–*class objects
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: Recursion
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Arrow functions
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 箭头函数
- en: Closures
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: Spread
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开
- en: Let's see some examples of each one, to explain why they will be useful to us.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些每一个的例子，解释为什么它们对我们有用。
- en: Functions as First Class Objects
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为一等对象
- en: 'Saying that functions are *first class objects*(also: *first class* *citizens*)
    means that you can do everything with functions, that you can do with other objects.
    For example, you can store a function in a variable, you can pass it to a function,
    you can print it out, and so on. This is really the key to doing FP: we will often
    be passing functions as parameters (to other functions) or returning a function
    as the result of a function call.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 说函数是*一等对象*（也可以说是*一等公民*）意味着您可以对函数做任何其他对象可以做的事情。例如，您可以将函数存储在变量中，将其传递给函数，将其打印出来等等。这确实是进行FP的关键：我们经常会将函数作为参数（传递给其他函数）或将函数作为函数调用的结果返回。
- en: 'If you have been doing async Ajax calls, you have already been using this feature:
    a *callback* is a functionthat will be called after the Ajax call finishes and
    is passed as a parameter. Using jQuery, you could write something like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直在进行异步Ajax调用，您已经在使用这个功能：*回调*是一个在Ajax调用完成后被调用并作为参数传递的函数。使用jQuery，您可以写出类似以下的代码：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `$.get()` function receives a callback function as a parameter, and calls
    it after the result is obtained.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`$.get()`函数接收一个回调函数作为参数，并在获得结果后调用它。'
- en: 'This is better solved, in a more modern way, by using promises or async/await,
    but for, but for the sake of our example, the older way is enough. We''ll be getting
    back to promises, though, in section *Building Better Containers,* of[chapter
    12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better Containers –
    Functional Data Types*, when we discuss Monads; in particular, see section *Unexpected
    Monads: Promises*.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题可以更现代化地通过使用promises或async/await来解决，但是为了我们的例子，旧的方法已经足够了。不过，我们将在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)的*构建更好的容器-功能数据类型*中讨论单子时，会回到promises；特别是看看*意外的单子：promises*一节。
- en: 'Since functions can be stored in variables, you could also write:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以存储在变量中，您也可以这样写：
- en: '[PRE1]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We'll be seeing more examples of this in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions – Higher–Order Functions*, when we consider Higher*–*Order
    Functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中我们会看到更多的例子，*生成函数-高阶函数*，当我们考虑高阶函数时。
- en: Recursion
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'This is a most potent tool for developing algorithms and a great aid for solving
    large classes of problems. The idea is that a function can at a certain point
    call *itself*, and when *that* call is done, continue working with whatever result
    it has received. This is usually quite helpful for certain classes of problems
    or definitions. The most often quoted example is the factorial function (the factorial
    of *n* is written *n!*) as defined for non-negative integer values:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是开发算法的最有效工具，也是解决大类问题的重要辅助工具。其思想是一个函数在某一点可以调用*自身*，当*那个*调用完成后，继续使用它接收到的任何结果。这通常对某些类的问题或定义非常有帮助。最常引用的例子是阶乘函数（*n*的阶乘写作*n!*）对非负整数值的定义：
- en: If *n* is 0, then *n!=1*
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*为0，则*n!=1*
- en: If *n* is greater than 0, then *n! = n * (n-1)!*
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*大于0，则*n!=n*(n-1)!
- en: The value of *n!* is the number of ways you can order n different elements in
    a row. For example, if you want to place five books in line, you can pick any
    of the five for the first place, and then order the other four in every possible
    way, so *5! = 5*4!*. If you continue to work this example, you'll get that *5!
    = 5*4*3*2*1=120*, so *n!* is the product of all numbers up to *n*.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*n!*的值是你可以按顺序排列n个不同元素的方式数。例如，如果你想把五本书排成一行，你可以选择其中任意一本放在第一位，然后以每种可能的方式排列其他四本，所以*5!=5*4!*。如果你继续处理这个例子，你会得到*5!=5*4*3*2*1=120*，所以*n!*是所有小于*n*的所有数字的乘积。'
- en: 'This can be immediately turned into JS code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以立即转换为JS代码：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Recursion will be a great aid for the design of algorithms. By using recursion
    you could do without any `while` or `for` loops -- not that we *want* to do that,
    but it's interesting that we *can*! We'll be devoting the complete [chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing
    Functions - Recursion*, to designing algorithms and writing functions recursively.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 递归将是算法设计的重要辅助工具。通过使用递归，您可以不使用任何`while`或`for`循环——虽然我们*不想*这样做，但有趣的是我们*能*！我们将把完整的[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)，*设计函数-递归*，用于设计算法和递归编写函数。
- en: Closures
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are a way to implement data hiding (with private variables), which
    leads to modules and other nice features. The key concept is that when you define
    a function, it can refer to not only its own local variables, but also to everything
    outside of the context of the function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是实现数据隐藏（使用私有变量）的一种方式，这导致了模块和其他很好的特性。关键概念是，当你定义一个函数时，它不仅可以引用自己的局部变量，还可以引用函数上下文之外的所有东西：
- en: '[PRE3]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Even after `newCounter` exits, the inner function still has access to `count`,
    but that variable is not accessible to any other parts of your code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`newCounter`退出后，内部函数仍然可以访问`count`，但该变量对您代码的任何其他部分都不可访问。
- en: This isn't a very good example of FP -- a function (`nc()`, in this case) isn't
    expected to return different results when called with the same parameters!
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是FP的一个很好的例子——一个函数（在这种情况下是`nc()`）不应该在使用相同参数调用时返回不同的结果！
- en: 'We''ll find several uses for closures: among others, *memoization* (see [chapter
    4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving Properly - Pure Functions*,
    and [chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*) and the *module* pattern (see [chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*, and [chapter 11,](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)
    *Implementing Design Patterns - The Functional Way*).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现闭包有几种用途：包括*记忆化*（见[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)，*行为良好-纯函数*，和[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)，*生成函数-高阶函数*）和*模块*模式（见[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)，*从函数开始-核心概念*，和[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)，*实现设计模式-函数式方法*）。
- en: Arrow functions
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Arrow functions are just a shorter, more succinct way of creating an (unnamed)
    function. Arrow functions can be used almost everywhere a classical function can
    be used, except that they cannot be used as constructors. The syntax is either
    (`parameter, anotherparameter, ...etc) => { *statements* }` or`(parameter, anotherparameter,
    ...etc) => *expression*`. The first one allows you to write as much code as you
    want; the second is short for `{ return *expression* }`. We could rewrite our
    earlier Ajax example as:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数只是创建（无名）函数的一种更简洁的方式。箭头函数几乎可以在几乎任何地方使用经典函数，除了它们不能用作构造函数。语法要么是（`参数，另一个参数，...等）=>
    { *语句* }`，要么是（`参数，另一个参数，...等）=> *表达式*。第一种允许您编写尽可能多的代码；第二种是`{ return *表达式* }`的简写。我们可以将我们之前的Ajax示例重写为：
- en: '[PRE4]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A new version of the factorial code could be:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘代码的新版本可能是：
- en: '[PRE5]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Arrow functions are usually called *anonymous*functions, because of their lack
    of a name. If you need to refer to an arrow function, you'll have to assign it
    to a variable or object attribute, as we did here; otherwise, you won't be able
    to use it. We'll see more in section *Arrow Functions* of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out with Functions - A Core Concept*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数通常被称为*匿名*函数，因为它们没有名称。如果您需要引用箭头函数，您必须将其分配给变量或对象属性，就像我们在这里做的那样；否则，您将无法使用它。我们将在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*箭头函数*部分中看到更多内容，*从函数开始-核心概念*。
- en: You would probably write the latter as a one-liner -- can you see the equivalence?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会将后者写成一行代码——你能看到等价吗？
- en: '[PRE6]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this shorter form, you don''t have to write `return` -- it''s implied.
    A short comment: when the arrow function has a single parameter, you can omit
    the parentheses around it. I usually prefer leaving them, but I''ve applied a
    JS beautifier, *prettier*, to the code, and it removes them. It''s really up to
    you whether to include them or not! (For more on this tool, check out [https://github.com/prettier/prettier](https://github.com/prettier/prettier).)
    By the way, my options for formatting were `--print-width 75 --tab-width 4 --no-bracket-spacing`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种更短的形式，您不必写`return`--它是暗示的。简短的评论：当箭头函数只有一个参数时，您可以省略括号。我通常更喜欢留下它们，但我已经应用了一个JS美化程序*prettier*到代码中，它会删除它们。是否包括它们取决于您！（有关此工具的更多信息，请查看[https://github.com/prettier/prettier](https://github.com/prettier/prettier)。）顺便说一句，我格式化的选项是`--print-width
    75 --tab-width 4 --no-bracket-spacing`。
- en: 'In lambda calculus, a function as `x => 2*x` would be represented as*λx.2*x*--
    though there are syntactical differences, the definitions are analogous. Functions
    with more parameters are a bit more complicated: *(x,y)=>x+y* would be expressed
    as*λx.λy.x+y.* We''ll see more about this in section*Of Lambdas and functions*,
    in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions -* A* Core Concept*, and in section *Currying*, in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在λ演算中，函数`x => 2*x`将表示为*λx.2*x*--尽管有一些语法上的差异，但定义是类似的。具有更多参数的函数会复杂一些：*(x,y)=>x+y*将表示为*λx.λy.x+y.*我们将在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*Lambda和函数*部分，[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)的*柯里化*部分中看到更多关于这一点的内容。
- en: Spread
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: 'The spread operator (see [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator))
    lets you expand an expression in places where you would otherwise require multiple
    arguments, elements, or variables. For example, you can replace arguments in a
    function call:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 传播运算符（参见[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator)）允许您在需要多个参数、元素或变量的地方扩展表达式。例如，您可以替换函数调用中的参数：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can also create or join arrays:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建或加入数组：
- en: '[PRE8]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It works with objects too:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它也适用于对象：
- en: '[PRE9]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also use it to work with functions that expect separate parameters,
    instead of an array. Common examples of this would be `Math.min()` and `Math.max()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用它来处理期望单独参数而不是数组的函数。这种情况的常见示例是`Math.min()`和`Math.max()`：
- en: '[PRE10]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also write the following *equation*. The `.apply()` method requires
    an array of arguments, but `.call()` expects individual arguments:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写以下*等式*。`.apply()`方法需要一个参数数组，而`.call()`则需要单独的参数：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you have problems remembering what arguments are required by `.apply()`
    and `.call()`, this mnemonic may help: *A is for* array*, and C is for comma*.
    See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)
    and[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)
    for more information.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记不住`.apply()`和`.call()`需要哪些参数，这个记忆法可能会有所帮助：*A代表*数组*，C代表逗号*。有关更多信息，请参见[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)和[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call)。
- en: Using the spread operator helps write shorter, more concise code, and we will
    be taking advantage of it.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传播运算符有助于编写更短、更简洁的代码，我们将充分利用它。
- en: How do we work with JavaScript?
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何使用JavaScript？
- en: 'All this is quite well, but as we mentioned before, it so happens that the
    JS version available most everywhere isn''t ES8, but rather the earlier JS5\.
    An exception to this is Node.js: it is based on Chrome''s V8 high-performance
    JS engine, which already has several ES8 features available. Nonetheless, as of
    today, ES8 coverage isn''t 100% complete, and there are features that you will
    miss. (Check out [https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)
    for more on Node and V8.)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但正如我们之前提到的，几乎所有地方都可用的JS版本都不是ES8，而是较早的JS5。Node.js是一个例外：它基于Chrome的V8高性能JS引擎，该引擎已经支持了几个ES8功能。尽管如此，截至今天，ES8覆盖率并不是100%，还有一些功能是您会错过的。（有关Node和V8的更多信息，请查看[https://nodejs.org/en/docs/es6/](https://nodejs.org/en/docs/es6/)。）
- en: So, what can you do, if you want to code using the latest version, but the available
    one is an earlier, poorer one? Or, what happens if most of your users may be using
    older browsers, which don't support the fancy features you're keen on using? Let's
    see some solutions for that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您想使用最新版本进行编码，但可用的版本是较早、较差的版本，您该怎么办？或者，如果您的大多数用户可能使用不支持您想要使用的新功能的老版本浏览器，会发生什么？让我们看看一些解决方案。
- en: If you want to be sure before using any given new feature, check out the compatibility
    table at [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/).
    (See Figure 1.1). For Node.js specifically, check out [http://node.green/](http://node.green/).![](assets/12ef0eea-ad3a-4742-90ea-ca23a61426af.png)Figure
    1.1\. - The latest versions of JS aren't yet widely and fully supported, so you'll
    have to check before using any of their new features
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在使用任何给定的新功能之前确保，可以查看[https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/)上的兼容性表。
    （见图1.1）。特别是对于Node.js，请查看[http://node.green/](http://node.green/)。![](assets/12ef0eea-ad3a-4742-90ea-ca23a61426af.png)图1.1
    - JS的最新版本尚未得到广泛和完全支持，因此在使用任何新功能之前，您需要进行检查
- en: Using transpilers
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用转换器
- en: In order to get out of this availability and compatibility problem, there are
    a couple of *transpilers*that you can use. Transpilers take your original ES8
    code, and transform it into equivalent JS5 code. (It's a source-to-source transformation,
    instead of a source-to-object code as in compilation.) You can code using advanced
    ES8 features, but the user's browsers will receive JS5 code. A transpiler will
    also let you keep up with upcoming versions of the language, despite the time
    needed by browsers to adopt new standards across desktop and mobile devices.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了摆脱这种可用性和兼容性问题，你可以使用一些*转译器*。转译器将你的原始ES8代码转换为等效的JS5代码。（这是一种源到源的转换，而不是编译中的源到对象代码。）你可以使用ES8的高级特性编码，但用户的浏览器将接收JS5代码。转译器还可以让你跟上语言的即将推出的版本，尽管浏览器在桌面和移动设备上采用新标准需要时间。
- en: 'If you wonder where did the word *transpiler*come from, it is a portmanteau
    of *translate*and *compiler*. There are many such combinations in technological
    speak: *email* (electronic+mail), *emoticon* (emotion+icon), *malware*(malicious+software),
    or *alphanumeric* (alphabetic+numeric), and several more.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道*转译器*一词是从哪里来的，它是*translate*和*compiler*的混成词。在技术术语中有许多这样的组合：*email*（electronic+mail）、*emoticon*（emotion+icon）、*malware*（malicious+software）、或*alphanumeric*（alphabetic+numeric），以及其他几个。
- en: 'The most common transpilers for JS are **Babel** (at[https://babeljs.io/](https://babeljs.io/))
    and **Traceur** (at[https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)).
    With tools such as **npm** or **Webpack**, it''s fairly easy to configure things
    so your code will get automatically transpiled and provided to end users. You
    can also try out transpilation online; see Figure 1.2 for an example using Babel''s
    online environment:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: JS最常见的转译器是**Babel**（在[https://babeljs.io/](https://babeljs.io/)）和**Traceur**（在[https://github.com/google/traceur-compiler](https://github.com/google/traceur-compiler)）。使用**npm**或**Webpack**等工具，配置代码自动转译并提供给最终用户非常容易。你也可以在线尝试转译；参见图1.2，这是使用Babel的在线环境的示例：
- en: '![](assets/a7fa9d5f-940d-4cdc-96a7-bce9af7f9471.png)Figure 1.2 - The Babel
    transpiler converts ES8 code into compatible JS5 code'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a7fa9d5f-940d-4cdc-96a7-bce9af7f9471.png)图1.2 - Babel转译器将ES8代码转换为兼容的JS5代码'
- en: 'If you prefer Traceur, use its tool at [https://google.github.io/traceur-compiler/demo/repl.html#](https://google.github.io/traceur-compiler/demo/repl.html#)
    instead, but you''ll have to open a developer console to see the results of your
    running code. (See Figure 1.3 for this.) Select the EXPERIMENTAL option, to fully
    enable ES8 support:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢Traceur，可以使用它的工具[https://google.github.io/traceur-compiler/demo/repl.html#](https://google.github.io/traceur-compiler/demo/repl.html#)，但你需要打开开发者控制台来查看运行代码的结果。（见图1.3。）选择实验选项，以完全启用ES8支持：
- en: '![](assets/f80f873f-cff5-44af-97c9-96fbcf098652.png)Figure 1.3 - The Traceur transpiler
    is an equally valid alternative for ES8-to-JS5 translationUsing transpilers is
    also a great way to learn the new JS features. Just type in some code at the left,
    and see the equivalent result at the right. Alternatively, use **command line
    interface** (**CLI**) tools to transpile a source file, and then inspect the produced
    output.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f80f873f-cff5-44af-97c9-96fbcf098652.png)图1.3 - Traceur转译器是ES8到JS5翻译的同样有效的选择使用转译器也是学习新JS特性的好方法。只需在左侧输入一些代码，然后在右侧看到等效的结果。或者，使用**命令行界面**（**CLI**）工具来转译源文件，然后检查生成的输出。'
- en: 'There''s a final possibility you may want to consider: instead of JS, opt for
    Microsoft''s TypeScript (at [http://www.typescriptlang.org/](http://www.typescriptlang.org/)),
    a superset of JS, compiled to JS5\. The main advantage of TypeScript is adding
    (optional) static type checks to JS, which helps detect some programming errors
    at compile time. Beware: as with Babel or Traceur, not all of ES8 will be available.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可能要考虑的选择：不使用JS，而是选择微软的TypeScript（在[http://www.typescriptlang.org/](http://www.typescriptlang.org/)），这是JS的超集，编译为JS5。TypeScript的主要优势是为JS添加（可选的）静态类型检查，有助于在编译时检测一些编程错误。注意：与Babel或Traceur一样，并非所有ES8都可用。
- en: You can also get type checks, without using TypeScript, by using Facebook's
    Flow (see [https://flow.org/](https://flow.org/)).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在不使用TypeScript的情况下获得类型检查，方法是使用Facebook的Flow（参见[https://flow.org/](https://flow.org/)）。
- en: 'If you opt to go with TypeScript, you can also test it online at their *playground*;
    see [http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/).
    You can set options to be more or less strict with data types checks, and you
    can also run your code on the spot. See figure 1.4:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择使用TypeScript，你也可以在它们的*playground*上在线测试；参见[http://www.typescriptlang.org/play/](http://www.typescriptlang.org/play/)。你可以设置选项来更严格或更宽松地检查数据类型，并且还可以立即运行你的代码。见图1.4：
- en: '![](assets/e4f6e6bd-4c1a-439f-af51-e46644231b89.png)Figure 1.4 - TypeScript
    adds type checking features, for safer JS programming'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/e4f6e6bd-4c1a-439f-af51-e46644231b89.png)图1.4 - TypeScript添加了类型检查功能，使JS编程更安全'
- en: Working online
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在线工作
- en: 'There are some more online tools that you can use to test out your JS code.
    Check out **JSFiddle** (at[https://jsfiddle.net/](https://jsfiddle.net/)), **CodePen**
    (at[https://codepen.io/](https://codepen.io/)), or **JSBin** (at [http://jsbin.com/](http://jsbin.com/)),
    among others. You may have to specify whether to use Babel or Traceur; otherwise,
    newer JS features will be rejected. See an example of JSFiddle in Figure 1.5:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些在线工具可以用来测试你的JS代码。查看**JSFiddle**（在[https://jsfiddle.net/](https://jsfiddle.net/)）、**CodePen**（在[https://codepen.io/](https://codepen.io/)）、或**JSBin**（在[http://jsbin.com/](http://jsbin.com/)）等等。你可能需要指定是否使用Babel或Traceur；否则，新的JS特性将被拒绝。在图1.5中可以看到JSFiddle的示例：
- en: '![](assets/b03b9a3c-330a-4832-9369-eae76e96b47a.png)Figure 1.5 - JSFiddle lets
    you try out ES8 code (plus HTML and CSS) without requiring any further tools'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b03b9a3c-330a-4832-9369-eae76e96b47a.png)图1.5 - JSFiddle让你尝试ES8代码（还包括HTML和CSS），而无需任何其他工具'
- en: Testing
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: We will also touch on testing, which is, after all, one of FP's main advantages.
    For that, we will be using Jasmine ([https://jasmine.github.io/](https://jasmine.github.io/)),
    though we could also opt for Mocha ([http://mochajs.org/](http://mochajs.org/)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将涉及测试，毕竟，这是FP的主要优势之一。为此，我们将使用Jasmine（[https://jasmine.github.io/](https://jasmine.github.io/)），尽管我们也可以选择Mocha（[http://mochajs.org/](http://mochajs.org/)）。
- en: You can run Jasmine test suites with a runner such as Karma ([https://karma-runner.github.io](https://karma-runner.github.io)),
    but I opted for standalone tests; see [https://github.com/jasmine/jasmine#installation](https://github.com/jasmine/jasmine#installation)
    for details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Karma（[https://karma-runner.github.io](https://karma-runner.github.io)）等运行器来运行Jasmine测试套件，但我选择了独立测试；有关详细信息，请参见[https://github.com/jasmine/jasmine#installation](https://github.com/jasmine/jasmine#installation)。
- en: Questions
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '1.1. **Classes as first-class objects**: We saw that functions are first class
    objects, but did you know *classes* also are? (Though, of course, speaking of
    classes as *objects* does sound weird...) Study this example and see what makes
    it tick! Be careful: there''s some purposefully weird code in it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 1.1. **类作为一等对象**：我们看到函数是一等对象，但您知道*类*也是吗？（当然，谈论类作为*对象*听起来很奇怪……）研究这个例子，看看是什么使它起作用！注意：其中有一些故意奇怪的代码：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 1.2\. **Factorial errors**: Factorials, as we defined them, should only be calculated
    for non-negative integers. However, the function we wrote doesn't verify if its
    argument is valid or not. Can you add the necessary checks? Try to avoid repeated,
    redundant tests!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2. **阶乘错误**：我们定义的阶乘应该只计算非负整数。然而，我们编写的函数没有验证其参数是否有效。您能添加必要的检查吗？尽量避免重复冗余的测试！
- en: 1.3\. **Climbing factorial:**Our implementation of factorial starts multiplying
    by *n*, then by *n-1*, then *n-2*, and so on., in what we could call a *downward
    fashion*. Can you write a new version of the factorial function, that will loop
    *upwards*?
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3. **爬升阶乘**：我们的阶乘实现从*n*开始乘，然后是*n-1*，然后是*n-2*，依此类推，可以说是以*向下的方式*。您能否编写阶乘函数的新版本，它将以*向上*的方式循环？
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen the basics of functional programming, a bit of
    its history, its advantages (and also some possible disadvantages, to be fair),
    why we can apply it in JavaScript, which isn't usually considered a functional
    language, and what tools we'll need in order to take advantage of the rest of
    the book.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了函数式编程的基础知识，以及一些历史、优势（也可能有一些可能的劣势，公平地说），为什么我们可以将其应用于JavaScript，这通常不被认为是一种函数式语言，以及我们将需要哪些工具才能利用本书的其余部分。
- en: In [chapter 2](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml), *Thinking Functionally
    - A First Example*, we'll go over an example of a simple problem, and look at
    it in *common* ways, to finally end by solving it in a functional manner and analyze
    the advantages of that way of working.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](7e6035b4-9ad0-4301-820a-0b34194bf471.xhtml)中，“功能性思维-第一个例子”，我们将讨论一个简单问题的例子，并以*常见*的方式来看待它，最终以函数式的方式解决它，并分析这种工作方式的优势。
