- en: Securing Access to APIs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API访问
- en: In this chapter, we will see how we can secure access to the APIs and web pages
    exposed by the edge server introduced in the previous chapter. We will learn to
    use HTTPS to protect against eavesdropping on external access to our APIs and
    also how to use OAuth 2.0 and OpenID Connect to authenticate and authorize users
    and client applications to access our APIs. Finally, we will study the use of
    HTTP basic authentication to secure access to the discovery service, Netflix Eureka.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何保护上一章介绍的边缘服务器暴露的API和网页的访问。我们将学习使用HTTPS来保护对我们的API的外部访问，以防止窃听，以及如何使用OAuth
    2.0和OpenID Connect对用户和客户端应用程序进行身份验证和授权以访问我们的API。最后，我们将研究使用HTTP基本身份验证来保护对发现服务Netflix
    Eureka的访问。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: An introduction to the OAuth 2.0 and OpenID Connect standards
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OAuth 2.0和OpenID Connect标准介绍
- en: A general discussion on how to secure the system landscape
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对如何保护系统架构进行了一般讨论
- en: Adding an authorization server to our system landscape
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的系统架构添加授权服务器
- en: Protecting external communication with HTTPS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护对发现服务Netflix Eureka的访问
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对API访问进行身份验证和授权
- en: Testing with the local authorization server
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: Testing with an OpenID Connect provider, Auth0
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OpenID Connect提供者Auth0进行测试
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All commands described in this book are run on a MacBook Pro using macOS Mojave
    but modifying them so they run on another platform such as Linux or Windows should
    be straightforward.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中描述的所有命令都在使用macOS Mojave的MacBook Pro上运行，但修改它们以在其他平台（如Linux或Windows）上运行应该很简单。
- en: No new tools need to be installed in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中不需要安装新工具。
- en: The source code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在GitHub上找到[https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11](https://github.com/PacktPublishing/Hands-On-Microservices-with-Spring-Boot-and-Spring-Cloud/tree/master/Chapter11)。
- en: 'To be able to run the commands as described in the book, download the source
    code to a folder and set up an environment variable, `$BOOK_HOME`, that points
    to that folder. The following commands can be used to perform these steps:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够按照书中描述的方式运行命令，请将源代码下载到一个文件夹并设置一个环境变量`$BOOK_HOME`，指向该文件夹。以下命令可用于执行这些步骤：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The Java source code is written for Java 8 and tested on Java 12\. This chapter
    uses Spring Cloud 2.1.0, SR1 (also known as the **Greenwich** release), Spring
    Boot 2.1.3, and Spring 5.1.5, that is, the latest available version of the Spring
    components at the time of writing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码是为Java 8编写的，并在Java 12上进行了测试。本章使用Spring Cloud 2.1.0，SR1（也称为**Greenwich**发布版），Spring
    Boot 2.1.3和Spring 5.1.5，即编写时可用的Spring组件的最新版本。
- en: 'The source code contains the following Gradle projects:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包含以下Gradle项目：
- en: '`api`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`API`'
- en: '`util`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`工具`'
- en: '`microservices/product-service`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/产品服务`'
- en: '`microservices/review-service`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/评论服务`'
- en: '`microservices/recommendation-service`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/推荐服务`'
- en: '`microservices/product-composite-service`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`微服务/产品组合服务`'
- en: '`spring-cloud/eureka-server`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/eureka-server`'
- en: '`spring-cloud/gateway`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/网关`'
- en: '`spring-cloud/authorization-server`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spring-cloud/授权服务器`'
- en: The code examples in this chapter all come from source code in `$BOOK_HOME/Chapter11`,
    but are, in several cases, edited to remove non-relevant parts of the source code,
    such as comments, imports, and log statements.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例都来自于`$BOOK_HOME/Chapter11`中的源代码，但在几种情况下进行了编辑，以删除源代码中的非相关部分，如注释、导入和日志语句。
- en: If you want to see the changes applied to the source code in [Chapter 11](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml), *Secure
    Access to APIs*, that is, to see what it took to secure access to the APIs in
    the microservice landscape, you can compare it with the source code for [Chapter
    10](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml), *Using Spring Cloud Gateway to
    Hide Microservices Behind an Edge Server*. You can use your favorite `diff` tool
    and compare the two folders, `$BOOK_HOME/Chapter10` and `$BOOK_HOME/Chapter11`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看应用于[第11章](bcb9bba0-d2fe-4ee8-954b-07a7e38e1115.xhtml)源代码的更改，即查看在微服务架构中保护API访问所需的内容，您可以将其与[第10章](a3383211-405d-4319-b142-ddb8cf3674fd.xhtml)的源代码进行比较，*使用Spring
    Cloud Gateway隐藏微服务在边缘服务器后面*。您可以使用您喜欢的`diff`工具，比较两个文件夹`$BOOK_HOME/Chapter10`和`$BOOK_HOME/Chapter11`。
- en: Introduction to OAuth 2.0 and OpenID Connect
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0和OpenID Connect介绍
- en: Before introducing OAuth 2.0 and OpenID Connect, let's clarify what we mean
    with authentication and authorization. **Authentication** means identifying a
    user by validating credentials supplied by the user, such as a username and password.
    **Authorization** is about giving access to various parts of, in our case, an
    API to an authenticated, that is, an identified user. In our case, a user will
    be assigned a set of privileges based on OAuth 2.0 scopes, as explained hereinafter.
    The microservices will be based on these privileges determine whether the user
    is allowed to access an API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍OAuth 2.0和OpenID Connect之前，让我们澄清一下我们所说的身份验证和授权。**身份验证**是指通过验证用户提供的凭据（如用户名和密码）来识别用户。**授权**是指向已经认证的用户，即已经确定身份的用户，授予对各个部分的访问权限，即在我们的情况下，API的访问权限。在我们的情况下，用户将根据OAuth
    2.0范围被分配一组特权，如下所述。微服务将基于这些特权确定用户是否被允许访问API。
- en: '**OAuth 2.0** is an open standard for authorization, and **OpenID Connect** is
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users based on the authentication performed by the authorization server. Let''s
    look briefly at OAuth 2.0 and OpenID Connect separately to get an initial understanding
    of their purposes!'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0是授权的开放标准，OpenID Connect是OAuth 2.0的附加功能，它使客户端应用程序能够根据授权服务器执行的身份验证来验证用户的身份。让我们简要地分别看一下OAuth
    2.0和OpenID Connect，以便初步了解它们的目的！
- en: Introduction to OAuth 2.0
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OAuth 2.0简介
- en: '**OAuth** *2.0* is a widely accepted open standard for authorization that enables
    a user to give consent for a third-party client application to access protected
    resources in the name of the user.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0是一种广泛接受的授权开放标准，使用户能够同意第三方客户端应用程序以用户的名义访问受保护的资源。
- en: So, what does this mean?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这意味着什么呢？
- en: 'Let''s start with sorting out the concepts used:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始整理使用的概念：
- en: '**Resource owner**: The end user.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源所有者：最终用户。
- en: '**Client**: The third-party client application, for example, a web app or a
    native mobile app, that wants to call some protected APIs in the name of the end
    user.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端：第三方客户端应用程序，例如Web应用程序或本机移动应用程序，希望以最终用户的名义调用一些受保护的API。
- en: '**Resource server**: The server that exposes the APIs that we want to protect.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源服务器：暴露我们想要保护的API的服务器。
- en: '**Authorization server:** The authorization server issues tokens to the client
    after the resource owner, that is, the end user, has been authenticated. The management
    of user information and the authentication of users are typically delegated, behind
    the scenes, to an **Identity Provider** (**IdP**).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器：资源所有者（即最终用户）经过身份验证后，授权服务器向客户端发放令牌。用户信息的管理和用户的身份验证通常在幕后委托给身份提供者（IdP）。
- en: A client is registered in the authorization server and is given a **client ID** and
    a **client secret**. The client secret must be protected by the client, like a
    password. A client also gets registered with a set of allowed **redirect-URIs** that
    the authorization server will use after a user has been authenticated to send
    **grant codes** and **tokens** that have been issued back to the client application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在授权服务器中注册，并获得客户端ID和客户端密钥。客户端密钥必须由客户端保护，就像密码一样。客户端还将被注册为一组允许的重定向URI，授权服务器在用户经过身份验证后将使用这些URI发送授予代码和已发放的令牌回到客户端应用程序。
- en: The following is an example by way of illustration. Let's say that a user accesses
    a third-party client application and the client application wants to call a protected
    API to serve the user. To be allowed to access these APIs, the client application
    needs a way to tell the APIs that it is acting in the name of the user. To avoid
    solutions where the user must share their credentials with the client application
    for authentication, an **access token** is issued by an authorization server that
    gives the client application limited access to a selected set of APIs in the name
    of the user.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个举例说明。假设用户访问第三方客户端应用程序，客户端应用程序希望调用受保护的API以服务用户。为了允许访问这些API，客户端应用程序需要一种方式告诉API它是以用户的名义行事。为了避免用户必须与客户端应用程序共享其凭据进行身份验证的解决方案，授权服务器发放了一个访问令牌，该令牌为客户端应用程序提供了有限的访问权限，以代表用户访问一组选定的API。
- en: This means that the user never has to reveal their credentials to the client
    application. The user can also give consent to the client application to access
    specific APIs on behalf of the user. An access token represents a time-constrained
    set of access rights, expressed as a *scope* in OAuth 2.0 terms. A **refresh token**
    can also be issued to a client application by the authorization server. A refresh
    token can be used by the client application to obtain new access tokens without
    having to involve the user.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用户永远不必向客户端应用程序透露其凭据。用户还可以同意客户端应用程序代表用户访问特定API。访问令牌代表一组有时间限制的访问权限，以OAuth
    2.0术语表示为*scope*。授权服务器还可以向客户端应用程序发放刷新令牌。刷新令牌可供客户端应用程序使用，以获取新的访问令牌，而无需涉及用户。
- en: 'The OAuth 2.0 specification defines four authorization grant flows for issuing
    access tokens, explained as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0规范定义了四种授权授予流程来发放访问令牌，如下所述：
- en: '**Authorization Code grant flow**: This is the safest, but also the most complex,
    grant flow. This grant flow requires that the user interact with the authorization
    server using a web browser for authentication and giving consent to the client
    application, as illustrated by the following diagram:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权码授予流程：这是最安全但也是最复杂的授予流程。这个授予流程要求用户通过网络浏览器与授权服务器进行交互进行身份验证，并同意客户端应用程序的访问权限，如下图所示：
- en: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/186b42c1-4690-4407-99c1-c0f71c1894c4.png)'
- en: 'Explanations for this diagram are as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此图的解释如下：
- en: The client application initiates the grant flow by sending the user to the authorization
    server in the web browser.
  id: totrans-48
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端应用程序通过将用户发送到网络浏览器中的授权服务器来启动授予流程。
- en: The authorization server will authenticate the user and ask for the user's consent.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将对用户进行身份验证并征求用户的同意。
- en: The authorization server will redirect the user back to the client application
    with a grant code. The authorization server will use the redirect-URI specified
    by the client in step 1 to know where to send the grant code. Since the grant
    code is passed back to the client application using the web browser, that is,
    to an insecure environment where malicious JavaScript code potentially can pick
    up the grant code, it is only allowed to be used once and only during a short
    time period.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器将使用授予代码将用户重定向回客户端应用程序。授权服务器将使用客户端在步骤1中指定的重定向URI，以确定将授予代码发送到何处。由于授予代码是通过网络浏览器传递回客户端应用程序的，即通过一个不安全的环境，恶意JavaScript代码可能会获取授予代码，因此授予代码只允许使用一次，并且只能在短时间内使用。
- en: To exchange the grant code for an access token, the client application is expected
    to call the authorization server again, using server-side code. The client application
    must present its client ID and client secret together with the grant code for
    the authorization server.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将授权代码交换为访问令牌，预期客户端应用程序再次调用授权服务器，使用服务器端代码。客户端应用程序必须提供其客户端ID和客户端密钥以及授权服务器的授权代码。
- en: The authorization server issues an access token and sends it back to the client
    application. The authorization server can also, optionally, issue and return a
    refresh token.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器发放访问令牌并将其发送回客户端应用程序。授权服务器还可以选择性地发放和返回刷新令牌。
- en: Using the access token, the client can send a request to the protected API exposed
    by the resource server.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用访问令牌，客户端可以向资源服务器发送请求，该服务器提供受保护的API。
- en: The resource server validates the access token and serves the request in the
    event of a successful validation. Steps 6 and 7 can be repeated as long as the
    access token is valid. When the lifetime of the access token has expired, the
    client can use their refresh token to acquire a new access token.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 资源服务器验证访问令牌，并在验证成功的情况下提供请求。只要访问令牌有效，步骤6和7可以重复。当访问令牌的生命周期已过期时，客户端可以使用其刷新令牌来获取新的访问令牌。
- en: '**Implicit grant flow**: This flow is also web browser-based, but intended
    for client applications that are not able to keep a client secret protected, for
    example, a single-page web application. It gets an access token back from the
    authorization server instead of a grant code, but cannot request a refresh token,
    since it is using the implicit grant flow that is less secure than the code grant
    flow.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式授权流程：**这个流程也是基于Web浏览器的，但是适用于无法保护客户端密钥的客户端应用程序，例如单页Web应用程序。它从授权服务器获取访问令牌而不是授权代码，但不能请求刷新令牌，因为它使用的隐式授权流程比代码授权流程不够安全。'
- en: '**Resource Owner Password Credentials grant flow**: If a client application
    can''t interact with a web browser, it can fall back on this grant flow. In this
    grant flow, the user must share their credentials with the client application
    and the client application will use these credentials to acquire an access token.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者密码凭据授权流程：**如果客户端应用程序无法与Web浏览器交互，它可以退而使用此授权流程。在此授权流程中，用户必须与客户端应用程序共享其凭据，客户端应用程序将使用这些凭据来获取访问令牌。'
- en: '**Client Credentials grant flow:** In the case where a client application needs
    to call an API unrelated to a specific user, it can use this grant flow to acquire
    an access token using its own client ID and client secret.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端凭据授权流程：**在客户端应用程序需要调用与特定用户无关的API的情况下，它可以使用此授权流程，使用自己的客户端ID和客户端密钥来获取访问令牌。'
- en: When it comes to automating tests against APIs that are protected by OAuth 2.0,
    the **Resource Owner Password Credentials grant flow** is very handy since it
    doesn't require manual interaction using a web browser. We will use this later
    on in this chapter with our test script; see the *Changes in the test script* section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化测试受OAuth 2.0保护的API时，**资源所有者密码凭据授权流程**非常方便，因为它不需要使用Web浏览器进行手动交互。我们将在本章后面使用这个测试脚本；请参阅*测试脚本中的更改*部分。
- en: 'The full specification can be found here: [https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749).
    There are also a number of additional specifications that detail various aspects
    of OAuth 2.0; for an overview, refer to [https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的规范可以在这里找到：[https://tools.ietf.org/html/rfc6749](https://tools.ietf.org/html/rfc6749)。还有许多其他规范详细介绍了OAuth
    2.0的各个方面；有关概述，请参阅[https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/](https://www.oauth.com/oauth2-servers/map-oauth-2-0-specs/)。
- en: One additional specification that is worth some extra attention is *RFC 7636
    – Proof Key for Code Exchange by OAuth Public Clients (PKCE), *[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636).
    This specification describes how an otherwise insecure public client, such as
    a mobile native app or desktop application, can utilize the code grant flow by
    adding an extra layer of security.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 值得额外关注的一个附加规范是*RFC 7636 – Proof Key for Code Exchange by OAuth Public Clients
    (PKCE)*，[https://tools.ietf.org/html/rfc7636](https://tools.ietf.org/html/rfc7636)。该规范描述了一个否则不安全的公共客户端（如移动原生应用程序或桌面应用程序）如何通过添加额外的安全层来利用代码授权流程。
- en: Securing access to the discovery service, Netflix Eureka
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护对发现服务Netflix Eureka的访问
- en: Previously, we learned to protect external communication with HTTPS. Now we
    will use HTTP basic authentication to restrict access to the APIs and web pages
    on the discovery server, Netflix Eureka; that is, we will require a user to supply
    a username and password to get access. Changes are required both on the Eureka
    server and in the Eureka clients described as follows.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们学习了如何使用HTTPS保护外部通信。现在我们将使用HTTP基本身份验证来限制对发现服务器Netflix Eureka上的API和网页的访问；也就是说，我们将要求用户提供用户名和密码以获取访问权限。需要在Eureka服务器和以下描述的Eureka客户端上进行更改。
- en: Introducing OpenID Connect
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入OpenID Connect
- en: '**OpenID Connect** (abbreviated to **OIDC**) is, as has already been mentioned,
    an add-on to OAuth 2.0 that enables client applications to verify the identity
    of users. OIDC adds an extra token, an ID token, that the client application gets
    back from the authorization server after a completed grant flow.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenID Connect**（缩写为**OIDC**）是OAuth 2.0的附加功能，允许客户端应用程序验证用户的身份。OIDC在完成授权流程后，授权服务器会向客户端应用程序返回一个额外的令牌，即ID令牌。'
- en: The ID token is encoded as a **JSON Web Token** (**JWT**) and contains a number
    of claims, such as the ID and email address of the user. The ID token is digitally
    signed using JSON web signatures. This makes it possible for a client application
    to trust the information in the ID token by validating the digital signature using
    public keys from the authorization server.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ID令牌被编码为**JSON Web Token**（**JWT**），包含许多声明，例如用户的ID和电子邮件地址。ID令牌使用JSON web签名进行数字签名。这使得客户端应用程序可以通过使用授权服务器的公钥验证数字签名来信任ID令牌中的信息。
- en: Optionally, access tokens can also be encoded and signed in the same way as
    ID tokens, but it is not mandatory according to the specification. Finally, OIDC
    defines a **discovery endpoint**, which is a standardized way to establish URLs
    to important endpoints, such as initiating a grant flow, getting the public keys
    to verify a digitally signed JWT token, and a **user-info endpoint**, which can
    be used to get extra information about an authenticated user given an access token
    for that user.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌也可以选择以与ID令牌相同的方式进行编码和签名，但根据规范并非强制要求。最后，OIDC定义了一个**发现端点**，这是建立重要端点的标准化方式，例如启动授权流程、获取用于验证数字签名的JWT令牌的公钥，以及**用户信息端点**，可用于获取经过身份验证的用户的额外信息，给定该用户的访问令牌。
- en: For an overview of the available specifications, see [https://openid.net/developers/specs/](https://openid.net/developers/specs/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用规范的概述，请参阅[https://openid.net/developers/specs/](https://openid.net/developers/specs/)。
- en: This concludes our introduction to the OAuth 2.0 and OpenID Connect standards.
    In the next section, we will get a high-level view of how the system landscape
    will be secured.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对OAuth 2.0和OpenID Connect标准的介绍。在下一节中，我们将高层次地了解系统景观将如何得到保护。
- en: Securing the system landscape
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护系统景观
- en: 'To secure the system landscape as described in the introduction to this chapter,
    we will perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护系统景观，我们将执行以下步骤：
- en: Encrypt external requests and responses to and from our external API using HTTPS
    to protect against eavesdropping
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTPS加密对外部API的外部请求和响应，以防止窃听
- en: Authenticate and authorize users and client applications that access our APIs
    using OAuth 2.0 and OpenID Connect
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect对访问我们的API的用户和客户端应用程序进行身份验证和授权
- en: Secure access to the discovery service, Netflix Eureka, using HTTP basic authentication
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用HTTP基本身份验证安全访问发现服务Netflix Eureka
- en: We will only apply HTTPS for external communication to our edge server, using
    plain HTTP for communication inside our system landscape.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会对外部通信应用HTTPS到我们的边缘服务器，而在系统景观内部使用纯HTTP进行通信。
- en: In the chapter on service mesh ([Chapter 18](422649a4-94bc-48ae-b92b-e3894c014962.xhtml),
    *Using a Service Mesh to Improve Observability and Management*) that will appear
    later in this book, we will see how we can get help from a service mesh product
    to automatically provision HTTPS to secure communication inside a system landscape.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书后面的章节中，我们将看到如何借助服务网格产品自动提供HTTPS，以确保系统内部通信的安全性。
- en: For test purposes, we will add a local OAuth *2.0* authorization server to our
    system landscape. All external communication with the authorization server will
    be routed through the edge server. The edge server and the product-composite service
    will act as OAuth 2.0 resource servers; that is, they will require a valid OAuth
    2.0 access token to allow access.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，我们将向我们的系统景观添加一个本地的OAuth *2.0*授权服务器。所有与授权服务器的外部通信将通过边缘服务器路由。边缘服务器和产品组合服务将充当OAuth
    2.0资源服务器；也就是说，它们将需要一个有效的OAuth 2.0访问令牌才能允许访问。
- en: To minimize the overhead of validating access tokens, we will assume that they
    are encoded as signed JWT tokens and that the authorization server exposes an
    endpoint that the resource servers can use to access the public keys, also known
    as `jwk-set`, required to validate the signing.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最小化验证访问令牌的开销，我们将假设它们被编码为签名的JWT令牌，并且授权服务器公开一个资源服务器可以使用的端点来访问公钥，也称为`jwk-set`，以验证签名。
- en: 'The system landscape will look like the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 系统景观将如下所示：
- en: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c45c1b73-3816-4923-aca4-414cef12a865.png)'
- en: 'From the preceding diagram, we can note that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，我们可以注意到：
- en: HTTPS is used for external communication, while plain text HTTP is used inside
    the system landscape.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外部通信使用HTTPS，而系统景观内部使用纯文本HTTP。
- en: The local OAuth 2.0 authorization server will be accessed externally through
    the edge server.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本地的OAuth 2.0授权服务器将通过边缘服务器进行外部访问。
- en: Both the edge server and the product composite microservice will validate access
    tokens as signed JWT tokens.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边缘服务器和产品组合微服务都将验证访问令牌作为签名的JWT令牌。
- en: The edge server and the product composite microservice will get the authorization
    server's public keys from its `jwk-set` endpoint, and use them to validate the
    signature of the JWT-based access tokens.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边缘服务器和产品组合微服务将从其`jwk-set`端点获取授权服务器的公钥，并使用它们来验证基于JWT的访问令牌的签名。
- en: Note that we will focus on securing access to APIs over HTTP, not on covering
    general best practices for securing web applications, for example, managing web
    application security risks pointed out by the *Category:OWASP Top Ten Project*.
    Refer to [https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)
    for more information on the OWASP Top Ten.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将专注于通过HTTP保护API的访问，而不是涵盖保护web应用程序的一般最佳实践，例如，管理由*Category:OWASP Top Ten
    Project*指出的web应用程序安全风险。有关OWASP十大安全风险的更多信息，请参阅[https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project](https://www.owasp.org/index.php/Category:OWASP_Top_Ten_Project)。
- en: With this overview of how the system landscape will be secured, let's start
    by adding a local authorization server to the system landscape.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对系统景观如何得到保护的概述，让我们从向系统景观添加本地授权服务器开始。
- en: Adding an authorization server to our system landscape
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向系统架构中添加授权服务器
- en: To be able to run tests locally and fully automated with APIs that are secured
    using OAuth 2.0 and OpenID Connect, we will add an OAuth 2.0-based authorization
    server to our system landscape. Spring Security 5.1 does not, unfortunately, provide
    an authorization server out of the box. But there is a legacy project (currently
    in maintenance mode), Spring Security OAuth, that provides an authorization server that
    we can use.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在本地运行测试并使用OAuth 2.0和OpenID Connect进行完全自动化，我们将向系统架构中添加基于OAuth 2.0的授权服务器。不幸的是，Spring
    Security 5.1没有提供授权服务器。但是有一个遗留项目（目前处于维护模式），Spring Security OAuth，提供了一个我们可以使用的授权服务器。
- en: In fact, in the samples provided by Spring Security 5.1, a project using the
    authorization server from Spring Security OAuth is available. It is configured
    to use JWT-encoded access tokens, and it also exposes an endpoint for a **JSON
    Web Key Set** (**JWKS**) (part of the OpenID Connect Discovery standard), a set
    of keys containing the public keys that can be used by resource servers to verify
    JWT tokens issued by the authorization server.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在Spring Security 5.1提供的示例中，可以使用Spring Security OAuth的授权服务器项目。它配置为使用JWT编码的访问令牌，并公开了一个**JSON
    Web Key Set**（**JWKS**）端点（OpenID Connect Discovery标准的一部分），其中包含可以被资源服务器用来验证授权服务器发放的JWT令牌的公钥集。
- en: So, even if it isn't a full-blown OpenID Connect provider, it is suitable for
    use together with tests that we want to be able to run locally and in a fully
    automated manner.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使它不是一个完整的OpenID Connect提供者，它也适用于我们希望能够在本地和完全自动化方式下运行的测试。
- en: For more details on planned support for OAuth 2.0 in Spring Security, refer
    to [https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Spring Security对OAuth 2.0的计划支持的更多详细信息，请参阅[https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security](https://spring.io/blog/2018/01/30/next-generation-oauth-2-0-support-with-spring-security)。
- en: The authorization server in the Spring Security sample projects is available
    here: [https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security示例项目中的授权服务器在这里可用：[https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver](https://github.com/spring-projects/spring-security/tree/master/samples/boot/oauth2authorizationserver)。
- en: The Spring Security sample project configures two OAuth clients, `reader` and
    `writer`, where the `reader` client is granted a read scope, and the `writer`
    client is granted both a read and a write scope. Both clients are configured to
    have the secret set to `secret`; refer to the `configure()` method in the `sample.AuthorizationServerConfiguration` class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Security示例项目配置了两个OAuth客户端，`reader`和`writer`，其中`reader`客户端被授予读取范围，而`writer`客户端被授予读取和写入范围。两个客户端都配置为将密钥设置为`secret`；请参阅`sample.AuthorizationServerConfiguration`类中的`configure()`方法。
- en: 'The following changes have been applied to the sample project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对示例项目进行了以下更改：
- en: A Eureka client has been added in the same way as for the other microservices.
    See [Chapter 9](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml), *Adding Service Discovery
    Using Netflix Eureka and Ribbon;* refer to the *Connecting microservices to a
    Netflix Eureka server* section.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了Eureka客户端，方式与其他微服务相同。参见[第9章](9a514887-19f2-4962-9736-2c0d457bfd9e.xhtml)，*使用Netflix
    Eureka和Ribbon添加服务发现*部分。
- en: Spring Boot Actuator has been added to get access to the `health` endpoint.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加Spring Boot Actuator以访问`health`端点。
- en: A Dockerfile has been added to be able to run the authorization server as a
    Docker container.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加了一个Dockerfile，以便将授权服务器作为Docker容器运行。
- en: The Gradle build file, `spring-security-samples-boot-oauth2authorizationserver.gradle`,
    has been changed to become more like the `build.gradle` files used in the source
    code of this book.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gradle构建文件`spring-security-samples-boot-oauth2authorizationserver.gradle`已更改，以更像本书源代码中使用的`build.gradle`文件。
- en: 'The configuration in the `sample/AuthorizationServerConfiguration` class has
    been changed as follows:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sample/AuthorizationServerConfiguration`类中的配置已更改如下：'
- en: 'Support has been added for the grant types: `code`, `authorization_code`, and
    `implicit`.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加对授权类型`code`、`authorization_code`和`implicit`的支持。
- en: The names of the scopes, `message:read` and `message:write`, have been changed to
    `product:read` and `product:write`.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域的名称`message:read`和`message:write`已更改为`product:read`和`product:write`。
- en: The username of the user registered in the authorization server has been changed
    to `magnus`, with the password `password`; refer to the `userDetailsService()`
    method in the `UserConfig` class (found in the `sample/AuthorizationServerConfiguration.java` file).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在授权服务器中注册的用户的用户名已更改为`magnus`，密码为`password`；请参阅`UserConfig`类中的`userDetailsService()`方法（位于`sample/AuthorizationServerConfiguration.java`文件中）。
- en: The source code for the authorization server is available in `$BOOK_HOME/Chapter11/spring-cloud/authorization-server`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器的源代码位于`$BOOK_HOME/Chapter11/spring-cloud/authorization-server`中。
- en: 'To incorporate the authorization server in the system landscape, a number of
    changes have been applied. The authorization server has been added to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将授权服务器纳入系统架构中，已应用了一些更改。授权服务器已添加到以下位置：
- en: The common build file, `settings.gradle`
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.gradle`是常见的构建文件。'
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件，`docker-compose*.yml`
- en: 'The edge server, `spring-cloud/gateway`:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 边缘服务器`spring-cloud/gateway`：
- en: A health check has been added to `HealthCheckConfiguration`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加健康检查到`HealthCheckConfiguration`。
- en: A route for URIs starting with `/oauth/` has been added.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已添加以`/oauth/`开头的URI的路由。
- en: With an understanding of how a local authorization server is added to the system
    landscape, let's move on and see how we can protect external communication from eavesdropping
    using HTTPS.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 了解了如何将本地授权服务器添加到系统架构中后，让我们继续看看如何使用HTTPS保护外部通信免受窃听。
- en: Protecting external communication with HTTPS
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用HTTPS保护外部通信
- en: 'In this section, we will learn how to prevent eavesdropping on external communication,
    for example from the internet, via the public APIs exposed by the edge server. We
    will use HTTPS to encrypt communication. To use HTTPS, we need to do the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将学习如何防止通过边缘服务器公开的公共API来自互联网的窃听。我们将使用HTTPS加密通信。要使用HTTPS，我们需要执行以下操作：
- en: '**Create a certificate**: We will create our own self-signed certificate, sufficient
    for development purposes.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建证书**：我们将创建自己的自签名证书，足以用于开发目的。'
- en: '**Configure the edge server**: It has to be configured to accept only HTTPS-based
    external traffic using the certificate.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置边缘服务器**：必须配置为仅接受使用证书的基于HTTPS的外部流量。'
- en: 'The self-signed certificate is created with the following command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令创建自签名证书：
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The source code comes with a sample certificate file, so you don't need to run
    this command to run the following examples.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码附带了一个示例证书文件，因此您无需运行此命令来运行以下示例。
- en: The command will ask for a number of parameters. When asked for a password,
    I entered `password`. For the rest of the parameters, I simply entered an empty
    value to accept the default value. The certificate file created, `edge.p12`, is
    placed in the `gateway` projects folder, `src/main/resources/keystore`. This means
    that the certificate file will be placed in the `.jar` file when it is built and
    will be available on the classpath in runtime at: `keystore/edge.p12`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将要求输入一些参数。当要求输入密码时，我输入了`password`。对于其余的参数，我只是输入了一个空值以接受默认值。创建的证书文件`edge.p12`放置在`gateway`项目文件夹`src/main/resources/keystore`中。这意味着在构建时，证书文件将放置在`.jar`文件中，并且在运行时将在类路径中可用于：`keystore/edge.p12`。
- en: Providing certificates using the classpath is sufficient during development,
    but not applicable to other environments, for example, a production environment.
    The following shows how we can replace this certificate with an external certificate
    at runtime!
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，使用类路径提供证书已经足够，但不适用于其他环境，例如生产环境。以下显示了我们如何在运行时用外部证书替换此证书！
- en: 'To configure the edge server to use the certificate and HTTPS, the following
    is added to `application.yml` in the `gateway` project:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置边缘服务器使用证书和HTTPS，需要将以下内容添加到`gateway`项目中的`application.yml`中：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following are the explanations for the preceding source code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述源代码的解释：
- en: The path to the certificate is specified in the `server.ssl.key-store` parameter,
    and is set to the `classpath:keystore/edge.p12` value. This means that the certificate
    will be picked up on the classpath from the location, `keystore/edge.p12`.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的路径在`server.ssl.key-store`参数中指定，并设置为`classpath:keystore/edge.p12`值。这意味着证书将从`keystore/edge.p12`位置的类路径中获取。
- en: The password for the certificate is specified in the `server.ssl.key-store-password` parameter.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书的密码在`server.ssl.key-store-password`参数中指定。
- en: To indicate that the edge server talks HTTPS and not HTTP, we also change the
    port from `8080` to `8443` in the `server.port` parameter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了指示边缘服务器使用HTTPS而不是HTTP进行通信，我们还将`server.port`参数中的端口从`8080`更改为`8443`。
- en: 'In addition to these changes in the edge server, changes are also required
    in the following files to reflect the changes to the port and HTTP protocol:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了边缘服务器中的这些更改之外，还需要更改以下文件以反映端口和HTTP协议的更改：
- en: The three Docker Compose files, `docker-compose*.yml`
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三个Docker Compose文件`docker-compose*.yml`
- en: The test script, `test-em-all.bash`
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试脚本`test-em-all.bash`
- en: Providing certificates using the classpath is as already mentioned previously
    only sufficient during development; let's see how we can replace this certificate
    with an external certificate in runtime!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，使用类路径提供证书已经足够，如前所述；让我们看看如何在运行时用外部证书替换此证书！
- en: Replacing a self-signed certificate in runtime
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时替换自签名证书
- en: Placing a self-signed certificate in the `.jar` file is only useful for development.
    For a working solution in runtime environments, for example, for test or production,
    it must be possible to use certificates signed by authorized **CAs** (short for
    **Certificate Authorities**).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将自签名证书放置在`.jar`文件中仅适用于开发。在运行时环境中，例如测试或生产环境中，必须能够使用由授权的**CA**（证书颁发机构）签名的证书来实现工作解决方案。
- en: It must also be possible to specify the certificates to be used during runtime
    without the need to rebuild the `.jar` files and, when using Docker, the Docker
    image that contains the `.jar` file. When using Docker Compose to manage the Docker
    container, we can map a volume in the Docker container to a certificate that resides
    on the Docker host. We can also set up environment variables for the Docker container
    that points to the new certificate in the Docker volume.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还必须能够在运行时指定要使用的证书，而无需重新构建`.jar`文件，并且在使用Docker时，包含`.jar`文件的Docker镜像。当使用Docker
    Compose管理Docker容器时，我们可以将Docker容器中的卷映射到驻留在Docker主机上的证书。我们还可以为Docker容器设置环境变量，指向Docker卷中的新证书。
- en: In [Chapter 15](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml), *Introduction to
    Kubernetes*, we will learn about Kubernetes, where we will see more powerful solutions
    for how to handle secrets, such as certificates, that are suitable for running
    Docker containers in a cluster; that is, where containers are scheduled on a group
    of Docker hosts and not on a single Docker host.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第15章](87949e5b-2761-4dc1-a70c-d9d21f03d530.xhtml)中，*Kubernetes简介*，我们将学习有关Kubernetes的更多强大解决方案，以处理诸如证书之类的秘密，适用于在集群中运行Docker容器的情况；也就是说，容器被调度到一组Docker主机上，而不是单个Docker主机上。
- en: The changes described in this topic have **not** been applied to the source
    code in the book's GitHub repository; that is, you need to make them yourself
    to see them in action!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改**尚未**应用于书籍的GitHub存储库中的源代码；也就是说，您需要自己进行更改才能看到它们的效果！
- en: 'To replace the certificate packaged in the `.jar` file, perform the following
    steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要替换打包在`.jar`文件中的证书，执行以下步骤：
- en: 'Create a second certificate and set the password to `testtest`, when asked
    for it:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个证书，并在要求时将密码设置为`testtest`：
- en: '[PRE3]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Update the Docker Compose file, `docker-compose.yml`, with environment variables
    for the location and password for the new certificate and a volume that maps to
    the folder where the new certificate is placed. The configuration of the edge
    server will look like the following after the change:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Docker Compose文件`docker-compose.yml`，添加新证书的位置和密码的环境变量，以及映射到放置新证书的文件夹的卷。更改后，边缘服务器的配置将如下所示：
- en: '[PRE4]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If the edge server is up and running, it needs to be restarted with the following
    commands:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果边缘服务器正在运行，需要使用以下命令重新启动：
- en: '[PRE5]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `docker-compose restart gateway` command might look like a good candidate
    for restarting the `gateway` service, but it actually does not take changes in
    `docker-compose.yml` into consideration. Hence, it is not a useful command in
    this case.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose restart gateway`命令可能看起来是重新启动`gateway`服务的好选择，但实际上它并不考虑`docker-compose.yml`中的更改。因此，在这种情况下，这不是一个有用的命令。'
- en: The new certificate is now in use!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 新证书现在正在使用！
- en: This concludes the section on how to protect external communication with HTTPS.
    In the next section we will learn how to secure access to the discovery service,
    Netflix Eureka, using HTTP basic authentication.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了如何使用HTTPS保护外部通信的部分。在下一节中，我们将学习如何使用HTTP基本身份验证来保护对发现服务Netflix Eureka的访问。
- en: Changes in the Eureka server
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka服务器的更改
- en: 'To protect the Eureka servers, the following changes have been applied:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护Eureka服务器，已经应用了以下更改：
- en: 'A dependency in `build.gradle` has been added to Spring Security:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.gradle`中添加了对Spring Security的依赖：
- en: '[PRE6]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Security configuration has been added to the `se.magnus.springcloud.eurekaserver.SecurityConfig` class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全配置已添加到`se.magnus.springcloud.eurekaserver.SecurityConfig`类中：
- en: 'The user is defined as follows:'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义如下：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `username` and `password` are injected into the constructor from the configuration
    file:'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`和`password`是从配置文件中注入到构造函数中的：'
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'All APIs and web pages are protected using HTTP basic authentication by means
    of the following definition:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有API和网页都使用HTTP基本身份验证进行保护，具体定义如下：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Credentials for the user are set up in the configuration file, `application.yml`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的凭据在配置文件`application.yml`中设置：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, the test class, `se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`,
    uses the credentials from the configuration file when testing the APIs of the
    Eureka server:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，测试类`se.magnus.springcloud.eurekaserver.EurekaServerApplicationTests`在测试Eureka服务器的API时使用配置文件中的凭据：
- en: '[PRE11]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding are the steps required for restricting access to the APIs and
    web pages of the discovery server, Netflix Eureka. It will now use HTTP basic
    authentication and require a user to supply a username and password to get access. In
    the next section, we will learn how to configure Netflix Eureka clients so that
    they pass credentials when accessing the Netflix Eureka server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是限制对发现服务器Netflix Eureka的API和网页访问所需的步骤。现在它将使用HTTP基本身份验证，并要求用户提供用户名和密码才能访问。在下一节中，我们将学习如何配置Netflix
    Eureka客户端，以便它们在访问Netflix Eureka服务器时传递凭据。
- en: Changes in Eureka clients
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eureka客户端的更改
- en: 'For Eureka clients, the credentials have to be specified in the connection
    URL for the Eureka server. This is specified in each client''s configuration file,
    `application.yml`, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Eureka客户端，凭据必须在连接URL中指定给Eureka服务器。这在每个客户端的配置文件`application.yml`中指定如下：
- en: '[PRE12]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will see this configuration in use by Netflix Eureka clients when we test
    the secured system landscape in the *Testing with the local authorization server* section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在*使用本地授权服务器进行测试*部分测试受保护的系统环境时，我们将看到Netflix Eureka客户端使用此配置。
- en: In the next section, we will learn how to add credentials when we manually access
    the Netflix Eureka server, either using its API or its Web pages.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何在手动访问Netflix Eureka服务器时添加凭据，无论是使用其API还是其网页。
- en: Testing the protected Eureka server
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试受保护的Eureka服务器
- en: Once the protected Eureka server is up and running, we have to supply valid
    credentials to be able to access its APIs and web pages.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦受保护的Eureka服务器正在运行，我们必须提供有效的凭据才能访问其API和网页。
- en: 'For example, asking the Eureka server for registered instances can be done
    by means of the following `curl` command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过以下`curl`命令询问Eureka服务器注册的实例：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A sample response is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 示例响应如下：
- en: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d901aa7-4296-49ed-ba1d-eae67342dced.png)'
- en: 'When accessing the web page on `https://localhost:8443/eureka/web`, we first
    have to accept an insecure connection, since our certificate is self-signed, and
    next we have to supply valid credentials, as specified in the preceding configuration
    files:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`https://localhost:8443/eureka/web`上的网页时，我们首先必须接受不安全的连接，因为我们的证书是自签名的，然后我们必须提供有效的凭据，如前面的配置文件中所指定的：
- en: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e043650f-1b2b-479f-a3c6-57ff2aa0d767.png)'
- en: 'Following a successful login, we will see the familiar web page from the Eureka
    server:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，我们将看到来自Eureka服务器的熟悉网页：
- en: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46c6f213-a33d-4599-9fdf-9715968c6537.png)'
- en: This concludes the section on how to restrict access to the Netflix Eureka server.
    In the next section we will learn how to use OAuth 2.0 and OpenID Connect to authenticate
    and authorize access to APIs.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了如何限制对Netflix Eureka服务器的访问的部分。在下一节中，我们将学习如何使用OAuth 2.0和OpenID Connect来对API的访问进行身份验证和授权。
- en: Authenticating and authorizing API access using OAuth 2.0 and OpenID Connect
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth 2.0和OpenID Connect进行API访问的身份验证和授权
- en: 'With the authorization server in place, we can enhance the edge server and
    the `product-composite` service so they become OAuth 2.0 resource servers; that
    is, they require a valid access token to allow access. We will configure the edge
    server to accept any access token it can validate using the signature provided
    by the authorization server. The `product-composite` service will also require
    the access token to contain some OAuth 2.0 scopes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器已经就位，我们可以增强边缘服务器和`product-composite`服务，使它们成为OAuth 2.0资源服务器；也就是说，它们需要有效的访问令牌才能允许访问。我们将配置边缘服务器，以接受任何可以使用授权服务器提供的签名验证的访问令牌。`product-composite`服务还将要求访问令牌包含一些OAuth
    2.0范围：
- en: The `product:read` scope will be required for accessing the read-only APIs.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问只读API将需要`product:read`范围。
- en: The `product:write` scope will be required for accessing the create and delete
    APIs.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问创建和删除API将需要`product:write`范围。
- en: We also need to enhance our test script, `test-em-all.bash`, so that it acquires
    access tokens before it runs the tests.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要增强我们的测试脚本`test-em-all.bash`，以便在运行测试之前获取访问令牌。
- en: Changes in both the edge server and the product-composite service
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘服务器和`product-composite`服务中的更改
- en: 'The following changes have been applied:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 已经应用了以下更改：
- en: 'Spring Security 5.1 dependencies have been added to `build.gradle` to support
    OAuth 2.0 resource servers:'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了Spring Security 5.1依赖项到`build.gradle`，以支持OAuth 2.0资源服务器：
- en: '[PRE14]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Security configurations have been added to the `se.magnus.springcloud.gateway.SecurityConfig`
    and `se.magnus.microservices.composite.product.SecurityConfig` classes:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了安全配置到`se.magnus.springcloud.gateway.SecurityConfig`和`se.magnus.microservices.composite.product.SecurityConfig`类中：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Explanations for the preceding source code are as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前述源代码的解释如下：
- en: '`.pathMatchers("/actuator/**").permitAll()` is used to allow access to URLs
    that should be unprotected, for example, the `actuator` endpoints in this case.
    Refer to the source code for URLs that are treated as unprotected. Be careful
    about which URLs are exposed unprotected. For example, the `actuator` endpoints
    should be protected before going to production:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`.pathMatchers("/actuator/**").permitAll()`来允许访问应该不受保护的URL，例如在这种情况下的`actuator`端点。请参考源代码以了解哪些URL被视为不受保护。要小心哪些URL被暴露为不受保护的。例如，`actuator`端点在投入生产之前应该受到保护：
- en: '`.anyExchange().authenticated()` ensures that the user is authenticated before
    being allowed access to all other URLs.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.anyExchange().authenticated()`确保用户在被允许访问所有其他URL之前已经进行了身份验证。'
- en: '`.oauth2ResourceServer().jwt()` specifies that authentication and authorization
    will be based on a JWT-encoded OAuth 2.0 access token.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.oauth2ResourceServer().jwt()`指定认证和授权将基于JWT编码的OAuth 2.0访问令牌。'
- en: 'The endpoint of the authorization server''s `jwk-set` endpoint has been registered
    in the configuration file, `application.yml`:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权服务器的`jwk-set`端点的端点已在配置文件`application.yml`中注册。
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With these changes applied to both the edge server and the `product-composite`
    service to make them act as OAuth 2.0 resource servers, we also need to make some
    changes that only apply to the `product-composite` service.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对边缘服务器和`product-composite`服务应用了这些更改，使它们作为OAuth 2.0资源服务器运行，我们还需要进行一些只适用于`product-composite`服务的更改。
- en: Changes in the product-composite service
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`product-composite`服务中的更改'
- en: 'In addition to the common changes applied in the previous section, the following
    changes have also been applied to the `product-composite` service:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前一节中应用的常见更改之外，还对`product-composite`服务应用了以下更改：
- en: 'The security configuration has been refined by requiring OAuth 2.0 scopes in
    the access token in order to allow access:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过要求访问令牌中包含OAuth 2.0范围来完善了安全配置，以允许访问。
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: By convention, OAuth 2.0 scopes should be prefixed with `SCOPE_` when checked
    for authority using Spring Security.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，OAuth 2.0范围在使用Spring Security进行权限检查时应该以`SCOPE_`为前缀。
- en: A method, `logAuthorizationInfo()`, has been added to log relevant parts from
    the JWT-encoded access token upon each call to the API. The access token can be
    acquired using the standard Spring Security, `SecurityContext`, which, in a reactive
    environment, can be acquired using the static helper method, `ReactiveSecurityContextHolder.getContext()`.
    Refer to the `se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl` class for
    details.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经添加了一个方法`logAuthorizationInfo()`，用于在每次调用API时记录JWT编码的访问令牌中的相关部分。可以使用标准的Spring
    Security `SecurityContext`获取访问令牌，在响应式环境中，可以使用静态辅助方法`ReactiveSecurityContextHolder.getContext()`获取。有关详细信息，请参考`se.magnus.microservices.composite.product.services.ProductCompositeServiceImpl`类。
- en: 'The use of OAuth has been disabled when running Spring-based integration tests.
    To prevent the OAuth machinery from kicking in when we are running integration
    tests, we disable it as follows:'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行基于Spring的集成测试时，已禁用了OAuth的使用。为了防止在运行集成测试时OAuth机制生效，我们进行了如下禁用：
- en: 'A security configuration, `TestSecurityConfig`, is added to be used during
    tests that permit access to all resources:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个安全配置`TestSecurityConfig`，用于在测试期间允许访问所有资源：
- en: '[PRE18]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In each Spring integration test class, we configure `TestSecurityConfig` to
    override the existing security configuration with the following:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个Spring集成测试类中，我们配置`TestSecurityConfig`来覆盖现有的安全配置，如下所示：
- en: '[PRE19]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With these changes in place, both the edge server and the `product-composite`
    service can act as OAuth 2.0 resource servers. The last step we need to take to
    introduce the usage of OAuth 2.0 and OpenID Connect is to update the test script
    so it acquires access tokens and uses them when running the tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，边缘服务器和`product-composite`服务都可以作为OAuth 2.0资源服务器运行。我们需要采取的最后一步是更新测试脚本，以便在运行测试时获取访问令牌并使用它们。
- en: Changes in the test script
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试脚本中的更改
- en: 'To start with, we need to acquire an access token before we can call any of
    the APIs, except the health API. This is done using the OAuth 2.0 password flow.
    To be able to call the create and delete APIs, we acquire an access token as the
    `writer` client, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在调用任何API之前获取访问令牌，除了健康API。这是使用OAuth 2.0密码流完成的。为了能够调用创建和删除API，我们将以`writer`客户端的身份获取访问令牌，如下所示：
- en: '[PRE20]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To verify that the scope-based authorization works, two tests have been added
    to the test script:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证基于范围的授权是否有效，测试脚本中添加了两个测试：
- en: The first test calls an API without supplying an access token. The API is expected
    to return the 401 Unauthorized HTTP status.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个测试调用API而没有提供访问令牌。预期API将返回401未经授权的HTTP状态。
- en: The other test calls an updating API using the `reader` client, which is only
    granted a read scope. The API is expected to return the 403 Forbidden HTTP status.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个测试调用了使用`reader`客户端的更新API，该客户端只被授予读取范围。预期API将返回403禁止访问的HTTP状态。
- en: 'For the full source code, see `test-em-all.bash`:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有关完整的源代码，请参见`test-em-all.bash`：
- en: '[PRE21]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: With the test scripts updated to acquire and use OAuth 2.0 access tokens, we
    are ready to try them out in the next section!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 随着测试脚本更新以获取和使用OAuth 2.0访问令牌，我们已准备好在下一节中尝试它们！
- en: Testing with the local authorization server
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用本地授权服务器进行测试
- en: 'In this section we will try out the secured system landscape; that is, we will
    test all the security components together. We will use the local authorization
    server to issue access tokens. The following tests will be performed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试受保护的系统架构；也就是说，我们将一起测试所有安全组件。我们将使用本地授权服务器来发出访问令牌。将执行以下测试：
- en: First, we build from source and run the test script to ensure that everything
    fits together.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们从源代码构建并运行测试脚本，以确保一切配合。
- en: 'Next, we learn how to acquire access tokens using OAuth 2.0 grant flows: password,
    implicit, and code grant flows.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用OAuth 2.0授权流获取访问令牌：密码、隐式和代码授权流。
- en: Finally, we will use access tokens to call APIs. We will also verify that an
    access token issued for a reader client can't be used to call an updating API.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用访问令牌调用API。我们还将验证为`reader`客户端发放的访问令牌无法用于调用更新API。
- en: Building and running the automated tests
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行自动化测试
- en: 'To build and run automated tests, we perform the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建和运行自动化测试，执行以下步骤：
- en: 'First, build Docker images with the following commands:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令构建Docker镜像：
- en: '[PRE22]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在Docker中启动系统架构，并使用以下命令运行常规测试：
- en: '[PRE23]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note the new negative tests at the end that verify that we get a 401 Unauthorized
    code back when not authenticated, and 403 Forbidden when not authorized.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意最后的新的负面测试，验证当未经授权时我们会收到401未经授权的代码，以及403禁止访问的代码。
- en: Acquiring access tokens
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取访问令牌
- en: 'Now we can acquire access tokens using the various grant flows defined by OAuth
    2.0\. We will try out the following grant flows: password, implicit, and code
    grant.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用OAuth 2.0定义的各种授权流获取访问令牌。我们将尝试以下授权流：密码、隐式和代码授权。
- en: Acquiring access tokens using the password grant flow
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码授权流获取访问令牌
- en: 'To get an access token for the `writer` client, that is, with both the `product:read` and `product:write` scopes,
    issue the following command:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`writer`客户端获取访问令牌，即具有`product:read`和`product:write`范围，发出以下命令：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The client identifies itself using HTTP basic authentication, passing its `writer`
    client ID, and its secret, `secret`. It sends the credentials of the resource
    owners, that is the end user, using the `username` and `password` parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端使用HTTP基本身份验证进行标识，传递其`writer`客户端ID和其密钥`secret`。它使用资源所有者的凭据，即最终用户，使用`username`和`password`参数。
- en: 'A sample response is as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例响应如下：
- en: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aabd7ac5-4ce6-4f92-ae33-0393200e9116.png)'
- en: 'Set the value of the `access_token` field in the response as the access token
    in an environment variable:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 将响应中的`access_token`字段的值设置为环境变量中的访问令牌：
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To get an access token for the `reader` client, that is, with only the `product:read`
    scope, simply replace `writer` with `reader` in the preceding command:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要为`reader`客户端获取访问令牌，即只具有`product:read`范围，只需在上述命令中将`writer`替换为`reader`：
- en: '[PRE26]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式授权流获取访问令牌
- en: 'To acquire an access token using the implicit grant flow, we need to involve
    a web browser. Open the URL in a web browser that accepts the use of self-signed
    certificates, for example, Chrome. Then perform the following steps:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用隐式授权流获取访问令牌，我们需要涉及网页浏览器。在接受自签名证书的网页浏览器中打开URL，例如Chrome。然后执行以下步骤：
- en: 'To get an access token for the `reader` client open the URL, `https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`.
    When asked to login by the web browser, use the credentials specified in the configuration
    of the authorization server, for example, `magnus` and `password`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为`reader`客户端获取访问令牌，请打开URL `https://localhost:8443/oauth/authorize?response_type=token&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=48532`。当网页浏览器要求登录时，请使用授权服务器配置中指定的凭据，例如`magnus`和`password`：
- en: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8faa69da-b3b7-4720-90c3-894d5b351ca0.png)'
- en: 'Next, you will be asked to authorize the `reader` client to call the APIs in
    your name:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您将被要求授权`reader`客户端以您的名义调用API：
- en: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/db2552db-ce24-484a-9eae-48e8a08c4e70.png)'
- en: 'Finally, we will get the following response:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将得到以下响应：
- en: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fedc6ade-fe6a-4abb-839d-c654eea7bd1f.png)'
- en: 'This might, at first glance, look a bit disappointing. The URL that the authorization
    server sent back to the web browser is based on the redirect-URI specified by
    the client in the initial request. Copy the URL into a text editor and you will
    find something similar to the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，这可能看起来有点令人失望。授权服务器发送回网络浏览器的URL是基于客户端在初始请求中指定的重定向URI。将URL复制到文本编辑器中，您将找到类似以下内容的内容：
- en: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`http://my.redirect.uri/#access_token=eyJh...C8pw&token_type=bearer&state=48532&expires_in=599999999&jti=8956b38b-36ea-4888-80dc-685b49f20f91`'
- en: Great! We can find the access token in the new URL in the `access_token` request
    parameter.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们可以在新URL中找到“access_token”请求参数中的访问令牌。
- en: 'Save the access token in an environment variable, as shown:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将访问令牌保存在环境变量中，如下所示：
- en: '[PRE27]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To get an access token for the `writer` client, you can use the following URL:
    `https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要为“writer”客户端获取访问令牌，可以使用以下网址：`https://localhost:8443/oauth/authorize?response_type=token&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=95372`。
- en: You are already authenticated, so you do not need to log in again, but you must
    give your consent to the `writer` client.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经经过身份验证，因此无需再次登录，但必须同意“writer”客户端。
- en: Note that no client secret is required; that is, the implicit grant flow is
    not very secure.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不需要客户端密钥；也就是说，隐式授权流程并不是非常安全的。
- en: Any application can claim that it is the `writer` client and can ask for the
    user's consent to use the requested scopes to access APIs in the name of the user,
    so beware!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序都可以声称自己是“writer”客户端，并且可以要求用户同意以用户的名义使用所请求的范围来访问API，因此请注意！
- en: Acquiring access tokens using the code grant flow
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码授权流程获取访问令牌
- en: Finally, let's try out the most secure grant flow in OAuth 2.0 – the code grant
    flow!
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们尝试OAuth 2.0中最安全的授权流程——代码授权流程！
- en: When it comes to the code grant flow, things are a bit more complicated in order
    to make the flow more secure. In the first insecure step, we will use the web
    browser to acquire a code that can be used only once, when it is exchanged with
    an access token. The code shall be passed from the web browser to a secure layer,
    for example, server-side code, which can make a new request the authorization
    server again to exchange the code with an access token. In this exchange, the
    server has to supply a client secret to verify its origin.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码授权流程时，为了使流程更安全，事情会变得有点复杂。在第一步不安全的步骤中，我们将使用网络浏览器获取一次性使用的代码，然后将其与访问令牌交换。代码将从网络浏览器传递到安全层，例如服务器端代码，该代码可以再次向授权服务器发出新请求，以将代码与访问令牌进行交换。在此交换中，服务器必须提供客户端密钥以验证其来源。
- en: To get a code for the `reader` client, use the following URL in the web browser: `https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要为“reader”客户端获取代码，请在网络浏览器中使用以下网址：`https://localhost:8443/oauth/authorize?response_type=code&client_id=reader&redirect_uri=http://my.redirect.uri&scope=product:read&state=35725`。
- en: This time, you will get back a much shorter URL, for example, `http://my.redirect.uri/?code=T2pxvW&state=72489`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，您将得到一个更短的URL，例如`http://my.redirect.uri/?code=T2pxvW&state=72489`。
- en: 'Extract the authorization code from the `code` parameter and define an environment
    variable, `CODE`, with its value:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从“code”参数中提取授权代码，并定义一个名为“CODE”的环境变量，其值为：
- en: '[PRE28]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, pretend you are the backend server that exchanges the authorization code
    with an access token using the following `curl` command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，假装您是后端服务器，使用以下“curl”命令将授权代码与访问令牌进行交换：
- en: '[PRE29]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A sample response is as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 示例响应如下：
- en: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b06c2376-bab9-452d-8081-fce44ce0b426.png)'
- en: 'Finally, save the access token in an environment variable as previously:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，像以前一样将访问令牌保存在环境变量中：
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get a code for the `writer` client, use the following URL: `https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要为“writer”客户端获取代码，请使用以下网址：`https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=product:read+product:write&state=72489`[.](https://localhost:8443/oauth/authorize?response_type=code&client_id=writer&redirect_uri=http://my.redirect.uri&scope=message:read+message:write&state=72489)
- en: Calling protected APIs using access tokens
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用访问令牌调用受保护的API
- en: Now, let's use the access tokens we have acquired to call the protected APIs!
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用已获取的访问令牌来调用受保护的API！
- en: 'First, call an API to retrieve a composite product without a valid access token:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，调用API以在没有有效访问令牌的情况下检索复合产品：
- en: '[PRE31]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It should return the following response:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应返回以下响应：
- en: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11b7747-9134-464d-956b-8d9ea3ee632b.png)'
- en: The error message clearly states that the access token is invalid!
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息清楚地说明访问令牌无效！
- en: 'Next, try using the API to retrieve a composite product using one of the access
    tokens acquired for the `reader` client from the previous section:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，尝试使用API使用从上一节获取的“reader”客户端的访问令牌检索复合产品：
- en: '[PRE32]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now we will get the `200 OK` status code and the expected response body will
    be returned:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将得到`200 OK`状态代码，并且将返回预期的响应主体：
- en: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35945d10-f681-4265-99d7-8c71e352e889.png)'
- en: 'If we try to access an updating API, for example, the delete API, with an access
    token acquired for the `reader` client, the call will fail:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用为“reader”客户端获取的访问令牌访问更新API，例如删除API，调用将失败：
- en: '[PRE33]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It will fail with a response similar to the following:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 它将以类似以下的响应失败：
- en: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![](img/41ac8596-5ddd-4a60-a2f4-48f0ec0e69e9.png)'
- en: If we repeat the call to the delete API, but with an access token acquired for
    the `writer` client, the call will succeed with 200 OK in the response.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重复调用删除API，但使用为“writer”客户端获取的访问令牌，调用将在响应中成功返回200 OK。
- en: The delete operation should return `200` even if the product with the specified
    product ID does not exist in the underlying database, since the delete operation
    is idempotent, as described in [Chapter 6](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml),
    *Adding Persistence*. Refer to the *Adding new APIs* section.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 即使底层数据库中不存在指定产品ID的产品，删除操作也应返回`200`，因为删除操作是幂等的，如[第6章](6c495e97-f473-4cb1-a404-11fd938f5478.xhtml)
    *添加持久性*中所述。请参考*添加新API*部分。
- en: 'If you look into the log output using the `docker-compose logs -f product-composite` command, you
    should be able to find authorization information such as the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`docker-compose logs -f product-composite`命令查看日志输出，您应该能够找到授权信息，如下所示：
- en: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa8061ea-8387-4bda-b2bd-ad5bab5f2230.png)'
- en: This information was extracted by the new method, `logAuthorizationInfo()`,
    in the `product-composite` service from the JWT-encoded access token; that is,
    the `product-composite` service did not need to communicate with the authorization
    server to get this information!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息是通过`product-composite`服务中的新方法`logAuthorizationInfo()`从JWT编码的访问令牌中提取的；也就是说，`product-composite`服务不需要与授权服务器通信以获取这些信息！
- en: With these tests, we have seen how to acquire an access token with the various
    grant flows, that is, password, implicit, and code grant flow. We have also seen
    how scopes can be used to limit what a client can do with a specific access token,
    for example only use is for reading operations.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些测试，我们已经了解了如何使用各种授权流程（密码、隐式和代码授予流程）获取访问令牌。我们还看到了如何使用范围来限制客户端可以使用特定访问令牌做什么，例如仅用于读取操作。
- en: In the next section, we will replace the local authorization server used in
    this section to an external OpenID Connect provider.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将把本节中使用的本地授权服务器替换为外部OpenID Connect提供程序。
- en: Testing with an OpenID Connect provider – Auth0
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OpenID Connect提供程序-Auth0进行测试
- en: So, the OAuth dance works fine with an authorization server we control ourselves.
    But what happens if we replace it with a certified OpenID Connect provider? In
    theory, it should work out of the box. Let's find out, shall we?
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，OAuth流程与我们自己控制的授权服务器正常工作。但是，如果我们将其替换为经过认证的OpenID Connect提供程序会发生什么？理论上，它应该可以直接使用。让我们来看看，好吗？
- en: 'For a list of certified implementations of OpenID Connect, refer to [https://openid.net/developers/certified/](https://openid.net/developers/certified/).
    We will use Auth0, [https://auth0.com/](https://auth0.com/), for our tests with
    an OpenID provider. To be able to use Auth0 instead of our own authorization server,
    we will go through the following topics:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenID Connect的认证实现的认证实现列表，请参阅[https://openid.net/developers/certified/](https://openid.net/developers/certified/)。我们将使用Auth0，[https://auth0.com/](https://auth0.com/)，进行与OpenID提供程序的测试。为了能够使用Auth0而不是我们自己的授权服务器，我们将通过以下主题进行更改：
- en: Setting up an account with an OAuth client and a user in Auth0
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Auth0中设置带有OAuth客户端和用户的帐户
- en: Applying the changes required to use Auth0 as an OpenID provider and running
    the test script to verify whether it is working
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用所需的更改以使用Auth0作为OpenID提供程序，并运行测试脚本以验证其是否正常工作。
- en: 'Acquiring access tokens using the following:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下方法获取访问令牌：
- en: Password grant flow
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码授予流程
- en: Implicit grant flow
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式授予流程
- en: Authorization code grant flow
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权代码授予流程
- en: Calling protected APIs using the access tokens.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用访问令牌调用受保护的API。
- en: Using the **user info** endpoint to get more information about a user.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**用户信息**端点获取有关用户的更多信息。
- en: Let us understand each of them in the following sections.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下各节中了解每个部分。
- en: Setting up an account and OAuth 2.0 client in Auth0
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Auth0中设置帐户和OAuth 2.0客户端
- en: 'Perform the following steps to sign up for a free account in Auth0, configure
    both an OAuth 2.0 client and the `product-composite` API, and finally register
    a user:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤注册Auth0的免费帐户，配置OAuth 2.0客户端和`product-composite` API，最后注册用户：
- en: Open the URL, [https://auth0.com](https://auth0.com), in your browser.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开URL [https://auth0.com](https://auth0.com)。
- en: 'Click on the SIGN UP button:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击注册按钮：
- en: Sign up with an account of your choice.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您选择的帐户进行注册。
- en: After a successful sign-up, you will be asked to create a tenant domain.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册成功后，您将被要求创建租户域。
- en: Enter the name of the tenant of your choice, in my case: `dev-ml.eu.auth0.com`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 输入您选择的租户名称，在我的情况下是：`dev-ml.eu.auth0.com`。
- en: Fill in information about your account as requested.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据要求填写有关您的帐户的信息。
- en: Following sign-up, you will be directed to your dashboard. Select the Applications
    tab (on the left) to see the default client application that was created for you
    during the sign-up process.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册成功后，您将被引导到您的仪表板。选择应用程序选项卡（左侧）以查看在注册过程中为您创建的默认客户端应用程序。
- en: 'Click on the Default App to configure it:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击默认应用程序进行配置：
- en: Copy the Client ID and Client Secret; you will need them later on.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制客户端ID和客户端密钥；稍后会用到它们。
- en: As Application Type, select Machine to Machine.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为应用程序类型，选择机器对机器。
- en: As Token Endpoint Authentication Method, select POST.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为令牌端点认证方法，选择POST。
- en: Enter `http://my.redirect.uri` as the allowed callback URL.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`http://my.redirect.uri`作为允许的回调URL。
- en: Click on Show Advanced Settings, go to the Grant Types tab, deselect Client
    Credentials, and select the Password box.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击显示高级设置，转到授权类型选项卡，取消选择客户端凭据，并选择密码框。
- en: Click on SAVE CHANGES.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击保存更改。
- en: 'Now define authorizations for our API:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在为我们的API定义授权：
- en: Click on the APIs tab (on the left) and click on the + CREATE API button.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击API选项卡（左侧），然后单击+创建API按钮。
- en: Name the API `product-composite`, give it the identifier `https://localhost:8443/product-composite`,
    and click on the CREATE button.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将API命名为`product-composite`，给它标识符`https://localhost:8443/product-composite`，然后单击创建按钮。
- en: Click on the Permissions tab and create two permissions (that is, OAuth scopes)
    for `product:read` and `product:write`.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击权限选项卡，并为`product:read`和`product:write`创建两个权限（即OAuth范围）。
- en: 'Next, create a user:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个用户：
- en: Click on the Users & Roles and -> Users tab (on the left) and then on the +
    CREATE YOUR FIRST USER button.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击用户和角色->用户选项卡（左侧），然后单击+创建您的第一个用户按钮。
- en: Enter an `email` and `password` of your preference and click on the SAVE button.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您喜欢的`email`和`password`，然后单击保存按钮。
- en: Look for a verification mail from Auth0 in the Inbox for the email address you
    supplied.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您提供的电子邮件地址的收件箱中查找来自Auth0的验证邮件。
- en: 'Finally, validate your Default Directory setting, used for the password grant
    flow:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，验证您的默认目录设置，用于密码授予流程：
- en: Click on your tenant profile in the upper-right corner and select Settings.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击右上角的租户配置文件，然后选择设置。
- en: In the tab named General, scroll down to the field named Default Directory and
    verify that it contains the `Username-Password-Authentication` value. If not,
    update the field and save the change.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为General的选项卡中，向下滚动到名为Default Directory的字段，并验证其中是否包含`Username-Password-Authentication`值。如果没有，请更新该字段并保存更改。
- en: That's it! Note that both the default app and the API get a client ID and secret.
    We will use the client ID and secret for the default app; that is, the OAuth client.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就是这样！请注意，默认应用程序和API都会获得客户端ID和密钥。我们将使用默认应用程序的客户端ID和密钥；也就是说，OAuth客户端。
- en: With an Auth0 account created and configured we can move on and apply the necessary
    configuration changes in the system landscape.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并配置了Auth0帐户后，我们可以继续在系统景观中应用必要的配置更改。
- en: Applying the necessary changes to use Auth0 as an OpenID provider
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用必要的更改以使用Auth0作为OpenID提供程序
- en: In this section we will learn what configuration changes are required to be
    able to replace the local authorization server with Auth0\. We only need to change
    the configuration for the two services that act as OAuth resource servers, the
    `product-composite`, and the `gateway` services. We also need to change our test
    script a bit, so that it acquires the access tokens from Auth0 instead of from
    our local authorization server. Let's start with the OAuth resource servers, that
    is, the `product-composite` and the `gateway` services.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习需要进行哪些配置更改，以便能够用Auth0替换本地授权服务器。我们只需要更改充当OAuth资源服务器的两个服务的配置，即`product-composite`和`gateway`服务。我们还需要稍微更改我们的测试脚本，以便从Auth0而不是从我们的本地授权服务器获取访问令牌。让我们从OAuth资源服务器开始，即`product-composite`和`gateway`服务。
- en: The changes described in this topic have **not** been applied to the source
    code in the book's Git repository; that is, you need to make them yourself to
    see them in action!
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 本主题中描述的更改**尚未**应用于书中的Git存储库中的源代码；也就是说，您需要自己进行更改以查看其运行情况！
- en: Changing the configuration in the OAuth resource servers
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改OAuth资源服务器中的配置
- en: When using an OpenID Connect provider, we only have to configure the base URI
    to the standardized discovery endpoint in the OAuth resource servers, that is,
    the `product-composite` and the `gateway` service. Spring Security will use the
    information in the response from the discovery endpoint to configure the resource
    server.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用OpenID Connect提供程序时，我们只需在OAuth资源服务器中（即`product-composite`和`gateway`服务）配置基本URI为标准化的发现端点。Spring
    Security将使用来自发现端点的响应中的信息来配置资源服务器。
- en: 'In the `product-composite` and `gateway` projects, make the following change
    to the `resource/application.yml` file:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在`product-composite`和`gateway`项目中，对`resource/application.yml`文件进行以下更改：
- en: 'Now find the following property setting:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到以下属性设置：
- en: '[PRE34]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Replace it with:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令替换它：
- en: '[PRE35]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**Note**: Replace `${TENANT_DOMAIN_NAME}` in the preceding configuration with
    your tenant domain name; in my case, it is `dev-ml.eu.auth0.com`, and do not forget
    the trailing `/`!'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：在前面的配置中用您的租户域名替换`${TENANT_DOMAIN_NAME}`；在我的情况下，它是`dev-ml.eu.auth0.com`，不要忘记结尾的`/`！'
- en: 'If you are curious, you can see what''s in the discovery document by running
    the following command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，可以通过运行以下命令查看发现文档中的内容：
- en: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl https://${TENANT_DOMAIN_NAME}/.well-known/openid-configuration -s | jq`'
- en: 'Rebuild the `product-composite` and `gateway` services as follows:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建`product-composite`和`gateway`服务如下：
- en: '[PRE36]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: With the `product-composite` and the `gateway` service updated, we can move
    on and also update the test script.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`product-composite`和`gateway`服务更新后，我们可以继续并更新测试脚本。'
- en: Changing the test script so it acquires access tokens from Auth0
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改测试脚本，以便从Auth0获取访问令牌
- en: We also need to update the test script so it acquires access tokens from the
    Auth0 OIDC provider. This is done by performing the following changes in `test-em-all.bash`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新测试脚本，以便从Auth0 OIDC提供程序获取访问令牌。这是通过在`test-em-all.bash`中执行以下更改来完成的。
- en: 'Take the following command:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令：
- en: '[PRE37]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace it with this command:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令替换它：
- en: '[PRE38]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, replace `${TENANT_DOMAIN_NAME}`, `${USER_EMAIL}`, `${USER_PASSWORD}`,
    `${CLIENT_ID}`, and `${CLIENT_SECRET}` in the preceding command with the values
    you collected during the registration process in Auth0, as described previously.
    Then, take the following command:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请用在之前描述的注册过程中收集到的值替换前述命令中的`${TENANT_DOMAIN_NAME}`、`${USER_EMAIL}`、`${USER_PASSWORD}`、`${CLIENT_ID}`和`${CLIENT_SECRET}`。然后，使用以下命令：
- en: '[PRE39]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Replace it with this command:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下命令替换它：
- en: '[PRE40]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Apply the preceding changes to the command. Also note that we only require the
    `product:read` scope and not the `product:write` scope. This is to simulate a
    client with read-only access.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 将前述更改应用到命令中。还要注意，我们只需要`product:read`范围，而不是`product:write`范围。这是为了模拟具有只读访问权限的客户端。
- en: Now access tokens are issued by Auth0 instead of our local authorization server,
    and our API implementations can verify that the access tokens (have been correctly
    signed by Auth0 and have not expired), using information from Auth0's discovery
    service flagged in the `application.yml` files. The API implementations can, as
    before, use the scopes in the access tokens to authorize the client to perform
    the call to the API, or not.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问令牌由 Auth0 发行，而不是我们的本地授权服务器，并且我们的API实现可以验证访问令牌（已由 Auth0 正确签名并且未过期），使用来自
    Auth0 的发现服务在`application.yml`文件中标记的信息。API 实现可以像以前一样使用访问令牌中的范围来授权客户端对API的调用，或者不授权。
- en: Now we have all the required changes in place, let's run some tests to verify
    that we can acquire access tokens from Auth0.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经做好了所有必要的更改，让我们运行一些测试来验证我们是否可以从 Auth0 获取访问令牌。
- en: Running the test script with Auth0 as the OpenID Connect provider
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Auth0 作为 OpenID Connect 提供程序运行测试脚本
- en: Now, we are ready to give Auth0 a try!
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备尝试 Auth0 了！
- en: 'Run the usual tests against Auth0 with the following command:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令对 Auth0 运行通常的测试：
- en: '[PRE41]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the logs (using the `docker-compose logs -f product-composite` command), you
    will be able to find authorization information from the access tokens issued by
    Auth0:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在日志中（使用`docker-compose logs -f product-composite`命令），您将能够找到由 Auth0 发行的访问令牌的授权信息：
- en: 'From calls using an access token with both the `product:read` and `product:write`
    scopes, we will see that both scopes are listed as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 从使用同时具有`product:read`和`product:write`范围的访问令牌的调用中，我们将看到以下列出的两个范围：
- en: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c98cb07-9e00-4611-8c25-0db0aa384d1d.png)'
- en: 'From calls using an access token with only the `product:read` scope, we will
    see that only that scope is listed as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 从仅具有`product:read`范围的访问令牌的调用中，我们将看到以下列出的仅该范围：
- en: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![](img/568e2fc6-35fa-43e1-8247-1d2b9cad167f.png)'
- en: As we can see from the log output, we now get information regarding the intended
    audience for this access token. To strengthen security, we could add a test to
    our service that verifies that its URL, `https://localhost:8443/product-composite`
    in this case, is part of the audience list. This would prevent the situation where
    someone tries to use an access token issued for another purpose to get access
    to our API.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志输出中可以看到，我们现在获得了有关此访问令牌的预期受众的信息。为了加强安全性，我们可以向我们的服务添加一个测试，以验证其URL，在本例中为`https://localhost:8443/product-composite`，是否包含在受众列表中。这将防止有人尝试使用为其他目的签发的访问令牌来访问我们的API。
- en: With the automated tests working together with Auth0, we can move on and learn
    how to acquire access tokens using the different types of grant flow. Let's start
    with the password grant flow.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与 Auth0 一起使用自动化测试，我们可以继续学习如何使用不同类型的授权流获取访问令牌。让我们从密码授权流开始。
- en: Acquiring access tokens using the password grant flow
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用密码授权流获取访问令牌
- en: In this section we will learn how to acquire an access token from Auth0 using
    the password grant flow.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用密码授权流从 Auth0 获取访问令牌。
- en: 'If you want to acquire an access token from Auth0 yourself, you can do so by
    running the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想自己从 Auth0 获取访问令牌，可以运行以下命令：
- en: '[PRE42]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Following the instruction in the *Calling protected APIs using the access tokens* section, you
    should be able to call the APIs using the acquired access token. The next grant
    flow we'll try out is the implicit grant flow.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 按照“使用访问令牌调用受保护的API”部分的说明，您应该能够使用获取的访问令牌调用API。我们将尝试的下一个授权流程是隐式授权流。
- en: Acquiring access tokens using the implicit grant flow
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用隐式授权流获取访问令牌
- en: In this section, we will learn how to acquire an access token from Auth0 using
    the implicit grant flow.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用隐式授权流从 Auth0 获取访问令牌。
- en: 'If you want to try out the more involved implicit grant flow, you can open
    the following URL in a web browser:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想尝试更复杂的隐式授权流程，可以在Web浏览器中打开以下URL：
- en: '[PRE43]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述URL中用租户域名和客户端ID替换`${TENANT_DOMAIN_NAME}`和`${CLIENT_ID}`，这些信息是在之前在 Auth0 的注册过程中收集的。
- en: 'Let''s have a look at the following steps:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤：
- en: 'Auth0 should present the following login screen:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Auth0 应该呈现以下登录界面：
- en: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51fa7e05-b536-4ae8-8108-403cb016fa7f.png)'
- en: 'Following a successful login, Auth0 will ask you to give the client application
    your consent:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功登录后，Auth0 将要求您同意向客户端应用程序授予权：
- en: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![](img/88af32b9-cb29-4cea-afba-1e337b85d14f.png)'
- en: 'The access token is now in the URL in the browser, just like when we tried
    out the implicit flow in our local authorization server:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，访问令牌就像我们在本地授权服务器中尝试隐式流程时一样，位于浏览器中的URL中：
- en: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2124688f-d39d-431b-982b-6f5f786ac8d7.png)'
- en: To get an access token that corresponds to the `reader` client, remove the `product:write` scope from
    the preceding URL that we used to initiate the implicit grant flow.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与`reader`客户端对应的访问令牌，请从我们用于启动隐式授权流的上述 URL 中删除`product:write`范围。
- en: Now that we know how to acquire an access token using the implicit grant flow,
    we can move on to the third and last grant flow that we will try out, the authorization
    code grant flow.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何使用隐式授权流获取访问令牌，我们可以继续尝试第三种也是最后一种我们将尝试的授权流程，即授权码授权流。
- en: Acquiring access tokens using the authorization code grant flow
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用授权码授权流获取访问令牌
- en: 'Finally, we come to the most secure grant flow – the authorization code grant
    flow. We will follow the same procedure as with the local authorization server;
    that is, we first acquire code and then exchange it for an access token. Get the
    code by opening the following URL in a web browser, as follows:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到最安全的授权流程 - 授权码授权流。我们将按照与本地授权服务器相同的程序进行操作；即，我们首先获取代码，然后将其交换为访问令牌。通过在Web浏览器中打开以下URL来获取代码，如下所示：
- en: '[PRE44]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Replace `${TENANT_DOMAIN_NAME}` and `${CLIENT_ID}` in the preceding URL with
    the tenant domain name and client ID you collected during the registration process
    in Auth0 as described previously.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述URL中，用在Auth0注册过程中收集的租户域名和客户端ID替换`${TENANT_DOMAIN_NAME}`和`${CLIENT_ID}`。
- en: 'Expect a redirect attempt in the web browser to a URL as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 期望在Web浏览器中进行重定向尝试到以下URL：
- en: '[PRE45]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Extract the code and run the following command to get the access token:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 提取代码并运行以下命令以获取访问令牌：
- en: '[PRE46]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Replace `${TENANT_DOMAIN_NAME}`, `${CLIENT_ID}`, `${CLIENT_SECRET}`, and `${CODE}` in
    the preceding URL with the tenant domain name, client ID, and the client code
    you collected during the registration process in Auth0 as described previously.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述URL中，用在Auth0注册过程中收集的租户域名、客户端ID和客户端代码替换`${TENANT_DOMAIN_NAME}`、`${CLIENT_ID}`、`${CLIENT_SECRET}`和`${CODE}`。
- en: Now that we have learned how to acquire access tokens using all three types
    of grant flows, we are ready to try calling the external API using an access token
    acquired from Auth0 in the next section.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用三种授权流获取访问令牌，我们准备在下一节中尝试使用从Auth0获取的访问令牌调用外部API。
- en: Calling protected APIs using the Auth0 access tokens
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Auth0访问令牌调用受保护的API
- en: In this section, we will see how we can use an access token acquired from Auth0
    to call the external API.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到如何使用从Auth0获取的访问令牌调用外部API。
- en: We can use access tokens issued by Auth0 to call our APIs  just like when we
    used access tokens issued by our local authorization server.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Auth0签发的访问令牌调用我们的API，就像我们使用本地授权服务器签发的访问令牌一样。
- en: 'For a read-only API, execute the following command:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只读API，请执行以下命令：
- en: '[PRE47]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'For an updating API, execute the following command:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更新的API，请执行以下命令：
- en: '[PRE48]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Since we have requested both scopes, `product:read` and `product:write`, both
    the preceding API calls are expected to return 200 OK.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们请求了`product:read`和`product:write`两个范围，因此预计前面的API调用都将返回200 OK。
- en: Getting extra information about the user
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取有关用户的额外信息
- en: As you can see in the log output, the ID of the subject, that is, the user,
    is a bit cryptic, for example, `auth0|5ca0b73c97f31e11bc85a5e6`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在日志输出中所见，主题的ID，也就是用户，有点神秘，例如`auth0|5ca0b73c97f31e11bc85a5e6`。
- en: 'If you want your API implementation to know a bit more about the user, it can
    call Auth0''s `userinfo_endpoint` as described in the response to the discovery
    request made previously:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的API实现对用户有更多了解，可以调用Auth0的`userinfo_endpoint`，如前面对发现请求的响应中所述：
- en: '[PRE49]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Replace `${TENANT_DOMAIN_NAME}` in the preceding command with the tenant domain
    name you collected during the registration process in Auth0 as described previously.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述命令中，用在Auth0注册过程中收集的租户域名替换`${TENANT_DOMAIN_NAME}`。
- en: 'A sample response is as follows:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例响应如下：
- en: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![](img/85766cca-2c09-4b6a-9ead-a450d32154af.png)'
- en: This endpoint can also be used to verify that the user hasn't revoked the access
    token in Auth0.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点还可用于验证用户是否在Auth0中撤销了访问令牌。
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令关闭系统架构以结束测试：
- en: '[PRE50]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This concludes the section where we have learned how to replace the local OAuth
    2.0 Authorization server, only used for tests, with an external alternative. We
    have also seen how to reconfigure the microservice landscape to validate access
    tokens using an external OIDC provider.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们学习如何用外部替代本地OAuth 2.0授权服务器（仅用于测试）的部分。我们还看到了如何重新配置微服务架构，以使用外部OIDC提供者验证访问令牌。
- en: Summary
  id: totrans-422
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to use Spring Security to protect our APIs.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Spring Security来保护我们的API。
- en: We have seen how easy it is to enable HTTPS to prevent eavesdropping by third
    parties using Spring Security. With Spring Security, we have also learned that
    it is straightforward to restrict access and the discovery server, Netflix Eureka,
    using HTTP basic authentication. Finally, we have seen how we can use Spring Security
    to simplify the use of OAuth 2.0 and OpenID Connect to allow third-party client
    applications to access our APIs in the name of a user, but without requiring that
    the user share credentials with the client application. We have learned both how
    to set up a local OAuth 2.0 authorization server based on Spring Security and
    also how to change the configuration so that an external OpenID Connect provider,
    Auth0, can be used instead.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到使用Spring Security启用HTTPS以防止第三方窃听是多么容易。通过Spring Security，我们还学会了如何使用HTTP基本身份验证来限制访问和发现服务器Netflix
    Eureka。最后，我们看到了如何使用Spring Security来简化使用OAuth 2.0和OpenID Connect，以允许第三方客户端应用在用户的名义下访问我们的API，但不需要用户与客户端应用共享凭据。我们已经学会了如何基于Spring
    Security设置本地OAuth 2.0授权服务器，以及如何更改配置，以便使用外部OpenID Connect提供者Auth0。
- en: One concern, however, is how to manage the configuration required. Many small
    pieces of configuration must be set up for the microservices involved and the
    configuration must be synchronized to match. Added to the scattered configuration
    is the fact that some of the configuration contains sensitive information, such
    as credentials or certificates. It seems like we need a better way to handle the
    configuration for a number of cooperating microservices and also a solution for
    how to handle sensitive parts of the configuration.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个担忧是如何管理所需的配置。许多微服务涉及的小配置必须设置，并且配置必须同步匹配。除了分散的配置之外，一些配置包含敏感信息，如凭据或证书。看起来我们需要更好的方法来处理一些合作微服务的配置，以及如何处理配置的敏感部分的解决方案。
- en: In the next chapter, we will explore the Spring Cloud Configuration server and
    see how it can be used to handle these types of requirement.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索Spring Cloud配置服务器，并看看它如何用于处理这些类型的需求。
- en: Questions
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the benefits and shortcomings of using self-signed certificates?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自签名证书的好处和缺点是什么？
- en: What is the purpose of OAuth 2.0 authorization codes?
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0授权代码的目的是什么？
- en: What is the purpose of OAuth 2.0 scopes?
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OAuth 2.0 scopes的目的是什么？
- en: What does it mean when a token is a JWT token?
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 令牌是JWT令牌时是什么意思？
- en: How can we trust the information that is stored in a JWT token?
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何相信存储在JWT令牌中的信息？
- en: Is it suitable to use the OAuth 2.0 authorization code grant flow with a native
    mobile app?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在原生移动应用中使用OAuth 2.0授权代码授予流程是否合适？
- en: What does OpenID Connect add to OAuth 2.0?
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenID Connect对OAuth 2.0有什么补充？
