- en: Database Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库编程
- en: 'This chapter covers both basic and commonly used interactions between a Java
    application and a **database** (**DB**), right from connecting to the DB and performing
    CRUD operations to creating transactions, storing procedures, and working with
    **large objects** (**LOBs**). We will be covering the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了Java应用程序与**数据库**（**DB**）之间的基本和常用交互，从连接到数据库和执行CRUD操作到创建事务、存储过程和处理**大对象**（**LOBs**）。我们将涵盖以下内容：
- en: Connecting to a database using JDBC
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC连接到数据库
- en: Setting up the tables required for DB interactions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置所需的用于数据库交互的表。
- en: Performing CRUD operations using JDBC
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JDBC执行CRUD操作
- en: Using the **Hikari Connection Pool** (**HikariCP**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Hikari连接池**（**HikariCP**）
- en: Using prepared statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用预编译语句
- en: Using transactions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务
- en: Working with large objects
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理大对象
- en: Executing stored procedures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: Using batch operations for a large set of data
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用批处理操作处理大量数据
- en: Using **MyBatis** for CRUD operations
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**MyBatis**进行CRUD操作
- en: Using the **Java Persistence API** and **Hibernate**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Java持久性API**和**Hibernate**
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: It is difficult to imagine a complex software application that does not use
    some kind of structured and accessible data storage called a database. This is
    why any modern language implementation includes a framework that allows you to
    access the DB and **create, read, update, and delete** (**CRUD**) data in it.
    In Java, the **Java Database Connectivity** (**JDBC**) API provides access to
    any data source, from relational databases to spreadsheets and flat files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 很难想象一个不使用某种结构化和可访问的数据存储（称为数据库）的复杂软件应用程序。这就是为什么任何现代语言实现都包括一个允许您访问数据库并在其中**创建、读取、更新和删除**（**CRUD**）数据的框架。在Java中，**Java数据库连接**（**JDBC**）API提供对任何数据源的访问，从关系数据库到电子表格和平面文件。
- en: Based on this access, an application can manipulate data in the database directly,
    using database language (SQL, for example), or indirectly, using an **Object-Relational
    Mapping (ORM) **framework, which allows for the mapping of objects in memory to
    the tables in the database. The **Java Persistence API (JPA)** is the ORM specification
    for Java. When an ORM framework is used, the CRUD operations on the mapped Java
    objects are translated into the database language automatically. The list of the
    most popular ORM frameworks includes Apache Cayenne, Apache OpenJPA, EclipseLink,
    jOOQ, MyBatis, and Hibernate, to name a few.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种访问，应用程序可以直接在数据库中操作数据，使用数据库语言（例如SQL），或间接使用**对象关系映射（ORM）**框架，该框架允许将内存中的对象映射到数据库中的表。**Java持久性API（JPA）**是Java的ORM规范。当使用ORM框架时，对映射的Java对象的CRUD操作会自动转换为数据库语言。最受欢迎的ORM框架列表包括Apache
    Cayenne、Apache OpenJPA、EclipseLink、jOOQ、MyBatis和Hibernate等。
- en: The `java.sql` and `javax.sql` packages that compose the JDBC API are included in
    the **Java Platform Standard Edition** (**Java SE**). The `java.sql` package provides
    the API for accessing and processing data stored in a data source (usually a relational
    database)*.* The `javax.sql` package provides the API for server-side data source
    access and processing. Specifically, it provides the `DataSource` interface for
    establishing a connection with a database, connection and statement pooling, distributed
    transactions, and rowsets. The `javax.persistence` package that contains interfaces
    that are compliant with JPA is not included in Java SE and has to be added as
    a dependency to the Maven configuration file `pom.xml`. The specific JPA implementation—the
    preferred ORM framework—has to be included as a Maven dependency too. We will
    discuss the usage of JDBC, JPA, and two ORM frameworks—Hibernate and MyBatis—in
    the recipes of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 组成JDBC API的`java.sql`和`javax.sql`包包含在**Java平台标准版**（**Java SE**）中。`java.sql`包提供了访问和处理存储在数据源中的数据（通常是关系数据库）的API。`javax.sql`包提供了用于服务器端数据源访问和处理的API。具体来说，它提供了用于与数据库建立连接、连接和语句池、分布式事务和行集的`DataSource`接口。包含符合JPA的接口的`javax.persistence`包未包含在Java
    SE中，必须将其作为依赖项添加到Maven配置文件`pom.xml`中。特定的JPA实现——首选的ORM框架——也必须作为Maven依赖项包含在内。我们将在本章的示例中讨论JDBC、JPA和两个ORM框架——Hibernate和MyBatis的使用。
- en: To actually connect `DataSource` to a physical database, you also need a database-specific
    driver (provided by a database vendor, such as MySQL, Oracle, PostgreSQL, or SQL
    server database, for example). It may be written in Java or in a mixture of Java
    and **Java Native Interface** (**JNI**) native methods. This driver implements
    the JDBC API.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际将`DataSource`连接到物理数据库，还需要一个特定于数据库的驱动程序（由数据库供应商提供，例如MySQL、Oracle、PostgreSQL或SQL
    Server数据库）。它可能是用Java编写的，也可能是Java和**Java本机接口**（**JNI**）本机方法的混合体。这个驱动程序实现了JDBC API。
- en: 'Working with a database involves eight steps:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据库的工作涉及八个步骤：
- en: Installing the database by following the vendor instructions.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照供应商的说明安装数据库。
- en: Adding the dependency on a `.jar` to the application with the database-specific
    driver.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序添加特定于数据库的驱动程序的`.jar`依赖项。
- en: Creating a user, database, and database schema—tables, views, stored procedures,
    and so on.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户、数据库和数据库模式——表、视图、存储过程等。
- en: Connecting to the database from the application.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用程序连接到数据库。
- en: Constructing an SQL statement directly using JDBC or indirectly using JPA.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用JDBC或间接使用JPA构建SQL语句。
- en: Executing the SQL statement directly using JDBC or committing data changes using
    JPA.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接使用JDBC执行SQL语句或使用JPA提交数据更改。
- en: Using the result of the execution.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用执行结果。
- en: Closing the database connection and other resources.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭数据库连接和其他资源。
- en: Steps 1 –3 are done only once at the database setup stage, before the application
    is run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1-3仅在数据库设置阶段执行一次，应用程序运行之前。
- en: Steps 4 – 8 are performed by the application repeatedly, as needed.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤4-8根据需要由应用程序重复执行。
- en: Steps 5 – 7 can be repeated multiple times with the same database connection.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤5-7可以重复多次使用相同的数据库连接。
- en: Connecting to a database using JDBC
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 JDBC 连接到数据库
- en: In this recipe, you will learn how to connect to a database.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何连接到数据库。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Select the database you would like to work with. There are good commercial databases
    and good open source databases. The only thing we are going to assume is that
    the database of your choice supports **Structured Query Language** (**SQL**),
    which is a standardized language that allows you to perform CRUD operations on
    a database. In our recipes, we will use the standard SQL and avoid constructs
    and procedures specific to a particular database type.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择您想要使用的数据库。有很好的商业数据库和很好的开源数据库。我们唯一假设的是您选择的数据库支持**结构化查询语言**（**SQL**），这是一种标准化的语言，允许您在数据库上执行CRUD操作。在我们的示例中，我们将使用标准
    SQL，并避免特定于特定数据库类型的构造和过程。
- en: If the database is not installed yet, follow the vendor instructions and install
    it. Then, download the database driver. The most popular ones are of types 4 and
    5, written in Java. They are very efficient and talk to the database server through
    a socket connection. If a `.jar` file with such a driver is placed on the classpath,
    it is loaded automatically. Type 4 and 5 drivers are database specific because
    they use a database native protocol for accessing the database. We are going to
    assume that you are using a driver of such a type.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果数据库尚未安装，请按照供应商的说明进行安装。然后，下载数据库驱动程序。最流行的是类型 4 和 5，用 Java 编写。它们非常高效，并通过套接字连接与数据库服务器通信。如果将带有此类驱动程序的
    `.jar` 文件放置在类路径上，它将自动加载。类型 4 和 5 的驱动程序是特定于数据库的，因为它们使用数据库本机协议来访问数据库。我们将假设您正在使用此类驱动程序。
- en: If your application has to access several types of databases, then you need
    a driver of type 3\. Such a driver can talk to different databases via a middleware
    application server.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序必须访问多种类型的数据库，则需要类型 3 的驱动程序。这样的驱动程序可以通过中间件应用服务器与不同的数据库通信。
- en: Use drivers of type 1 and 2 only when there are no other driver types available
    for your database.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当没有其他驱动程序类型可用于您的数据库时，才使用类型 1 和 2 的驱动程序。
- en: Set the downloaded `.jar` file with the driver on your application's classpath. Now,
    your application can access the database.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将下载的带有驱动程序的 `.jar` 文件设置在应用程序的类路径上。现在，您的应用程序可以访问数据库。
- en: Your database might have a console, a GUI, or some other way to interact with
    it. Read the instructions and first create a user, that is, `cook`, and then a
    database, namely `cookbook`.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的数据库可能有控制台、图形用户界面或其他与之交互的方式。阅读说明，并首先创建一个用户，即 `cook`，然后创建一个名为 `cookbook` 的数据库。
- en: 'For example, here are the commands for PostgreSQL:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是 PostgreSQL 的命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We selected the `SUPERUSER` role for our user; however, a good security practice
    is to assign such a powerful role to an administrator and create another application-specific
    user who can manage data but cannot change the database structure. It is good
    practice to create another logical layer, called a **schema**, that can have its
    own set of users and permissions. This way, several schemas in the same database
    could be isolated, and each user (one of them is your application) will have access
    only to a certain schema.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的用户选择了 `SUPERUSER` 角色；然而，一个良好的安全实践是将这样一个强大的角色分配给管理员，并创建另一个专门用于管理数据但不能更改数据库结构的应用程序特定用户。创建另一个逻辑层，称为
    **模式**，可以拥有自己的一组用户和权限，这是一个良好的实践。这样，同一数据库中的几个模式可以被隔离，每个用户（其中一个是你的应用程序）只能访问特定的模式。
- en: Also, at the enterprise level, the common practice is to create synonyms for
    the database schema so that no application can access the original structure directly.
    You can even create a password for each user, but, again, for the purpose of this
    book, this is not needed. So, we leave it to the database administrators to establish
    the rules and guidelines suitable for the particular working conditions of each
    enterprise.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在企业级别，通常的做法是为数据库模式创建同义词，以便没有应用程序可以直接访问原始结构。您甚至可以为每个用户创建一个密码，但是，再次强调，出于本书的目的，这是不需要的。因此，我们将其留给数据库管理员来制定适合每个企业特定工作条件的规则和指南。
- en: Now, we connect our application to the database. In the following demonstration
    code, we will use, as you may have probably guessed by now, the open source PostgreSQL
    database.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将应用程序连接到数据库。在以下演示代码中，我们将使用开源的 PostgreSQL 数据库，你可能已经猜到了。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is the code fragment that creates a connection to the local PostgreSQL
    database:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建到本地 PostgreSQL 数据库的连接的代码片段：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The commented lines show how you can set a user and password for your connection.
    Since, for this demonstration, we are keeping the database open and accessible
    to anyone, we could use an overloaded `DriverManager.getConnection(String url)` method.
    However, we will show the most general implementation that would allow anyone to
    read from a property file and pass other useful values (`ssl` as true/false, `autoReconnect`
    as true/false, `connectTimeout` in seconds, and so on) to the connection-creating
    method. Many keys for the passed-in properties are the same for all major database
    types, but some of them are database-specific.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注释行显示了如何为连接设置用户和密码。由于在此演示中，我们将数据库保持开放并对任何人都可访问，我们可以使用重载的 `DriverManager.getConnection(String
    url)` 方法。然而，我们将展示最常见的实现，允许任何人从属性文件中读取并传递其他有用的值（`ssl` 为 true/false，`autoReconnect`
    为 true/false，`connectTimeout` 以秒为单位等）到创建连接的方法。传入属性的许多键对于所有主要数据库类型都是相同的，但其中一些是特定于数据库的。
- en: Alternatively, for passing only a user and a password, we could use the third
    overloaded version, namely `DriverManager.getConnection(String url, String user,
    String password)`. It's worth mentioning that it is a good practice to keep the
    password encrypted. We are not going to show you how to do this, but there are
    plenty of guides available online.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，仅传递用户和密码，我们可以使用第三个重载版本，即 `DriverManager.getConnection(String url, String
    user, String password)`。值得一提的是，将密码加密是一个良好的实践。我们不会向您展示如何做到这一点，但在线上有很多指南可用。
- en: Also, the `getConnection()` method throws `SQLException`, so we need to wrap
    it in a `try...catch` block.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`getConnection()`方法会抛出`SQLException`，因此我们需要将其包装在`try...catch`块中。
- en: 'To hide all of this plumbing, it is a good idea to keep the connection-establishing
    code inside a method:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了隐藏所有这些管道，最好将建立连接的代码放在一个方法中：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Another way of connecting to a database is to use the `DataSource` interface.
    Its implementation is typically included in the same `.jar` file as the database
    driver. In the case of PostgreSQL, there are two classes that implement the `DataSource` interface:
    `org.postgresql.ds.PGSimpleDataSource` and `org.postgresql.ds.PGPoolingDataSource`.
    We can use them instead of `DriverManager`. Here is an example of the usage of
    `PGSimpleDataSource`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库的另一种方法是使用`DataSource`接口。它的实现通常包含在与数据库驱动程序相同的`.jar`文件中。在PostgreSQL的情况下，有两个类实现了`DataSource`接口：`org.postgresql.ds.PGSimpleDataSource`和`org.postgresql.ds.PGPoolingDataSource`。我们可以使用它们来代替`DriverManager`。以下是使用`PGSimpleDataSource`的示例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And the following is an example of the usage of `PGPoolingDataSource`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`PGPoolingDataSource`的示例：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The last version of the `getDbConnection()` method is usually the preferred
    way of connecting because it allows you to use connection pooling and some other
    features, in addition to those available when connecting via `DriverManager`.
    Please note though that the class `PGPoolingDataSource` is deprecated, since version
    `42.0.0` was in favor of the third-party connection-pooling software. One such
    framework, HikariCP, which we have mentioned previously, will be discussed and
    demonstrated in the recipe *Using the Hikari Connection Pool*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`getDbConnection()`方法的最新版本通常是首选的连接方式，因为它允许您使用连接池和其他一些功能，除了通过`DriverManager`连接时可用的功能。请注意，自版本`42.0.0`起，`PGPoolingDataSource`类已被弃用，而是支持第三方连接池软件。其中一个框架，HikariCP，我们之前提到过，将在*使用Hikari连接池*的示例中进行讨论和演示。'
- en: Whatever version of the `getDbConnection()` implementation you choose, you can
    use it in all the code examples the same way.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您选择哪个版本的`getDbConnection()`实现，您都可以在所有代码示例中以相同的方式使用它。
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is good practice to close the connection as soon as you do not need it.
    The way to do this is by using the `try-with-resources` construct, which ensures
    that the resource is closed at the end of the `try...catch` block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭连接是一个好习惯，一旦不再需要它，就立即关闭连接。这样做的方法是使用`try-with-resources`构造，它确保在`try...catch`块结束时关闭资源：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Such a construct can be used with any object that implements the `java.lang.AutoCloseable`
    or the `java.io.Closeable` interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的构造可以与实现`java.lang.AutoCloseable`或`java.io.Closeable`接口的任何对象一起使用。
- en: Setting up the tables required for DB interactions
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置所需的用于数据库交互的表
- en: In this recipe, you will learn how to create, change, and delete tables and
    other logical database constructs that compose a database schema.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何创建、更改和删除表和其他组成数据库模式的逻辑数据库构造。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The standard SQL statement for table creation looks as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建表的标准SQL语句如下：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `table_name` and `column_name` have to be alphanumeric and unique (inside
    the schema) identifiers. The limitations for the names and possible data types
    are database-specific. For example, Oracle allows the table name to have 128 characters,
    while in PostgreSQL, the maximum length of the table name and column name is 63
    characters. There are differences in the data types too, so read the database
    documentation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`table_name`和`column_name`必须是字母数字和唯一的（在模式内）。名称和可能的数据类型的限制是特定于数据库的。例如，Oracle允许表名有128个字符，而在PostgreSQL中，表名和列名的最大长度为63个字符。数据类型也有所不同，因此请阅读数据库文档。
- en: How it works...
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Here is an example of a command that creates the `traffic_unit` table in PostgreSQL:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在PostgreSQL中创建`traffic_unit`表的命令示例：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `size` parameter is optional. If not set, as in the previous example code,
    it means that the column can store values of any length. The `integer` type, in
    this case, allows you to store numbers from `Integer.MIN_VALUE` (which is -2147483648)
    to `Integer.MAX_VALUE` (which is +2147483647). The `NOT NULL` type was added because,
    by default, the column would be nullable and we wanted to make sure that all the
    columns will be populated.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`size`参数是可选的。如果不设置，就像前面的示例代码一样，这意味着该列可以存储任意长度的值。在这种情况下，`integer`类型允许您存储从`Integer.MIN_VALUE`（-2147483648）到`Integer.MAX_VALUE`（+2147483647）的数字。添加了`NOT
    NULL`类型，因为默认情况下，该列将是可空的，我们希望确保所有列都将被填充。'
- en: 'We also identified the `id` column as the `PRIMARY KEY`, which indicates that
    the column (or the combination of columns) uniquely identifies the record. For
    example, if there is a table that contains information about all the people of
    all the countries, the unique combination would *probably* be their full name,
    address, and date of birth. Well, it is plausible to imagine that in some households,
    twins are born and given the same name, so we said *probably*. If the chance of
    such an occasion is high, we would need to add another column to the primary key
    combination, which is an order of birth, with the default value of `1`. Here is
    how we can do this in PostgreSQL:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将`id`列标识为`PRIMARY KEY`，这表示该列（或列的组合）唯一标识记录。例如，如果有一张包含所有国家所有人的信息的表，唯一的组合可能是他们的全名、地址和出生日期。嗯，可以想象在一些家庭中，双胞胎出生并被赋予相同的名字，所以我们说*可能*。如果这种情况发生的机会很大，我们需要向主键组合中添加另一列，即出生顺序，默认值为`1`。以下是我们在PostgreSQL中可以这样做的方法：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the case of the `traffic_unit` table, there is no combination of columns
    that can serve as a primary key. Many cars have the same values in any combination
    of columns. But we need to refer to a `traffic_unit` record so we could know,
    for example, which units have been selected and processed and which were not.
    This is why, we added an `id` column to populate it with a unique generated number,
    and we would like the database to generate this primary key automatically.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`traffic_unit`表的情况下，没有任何组合的列可以作为主键。许多汽车在任何组合的列中具有相同的值。但我们需要引用`traffic_unit`记录，这样我们就可以知道，例如，哪些单位已被选择和处理，哪些没有。这就是为什么我们添加了一个`id`列，用一个唯一生成的数字填充它，我们希望数据库能够自动生成这个主键。
- en: 'If you issue the command `\d traffic_unit` to display the table description,
    you will see the function `nextval(''traffic_unit_id_seq''::regclass)` assigned
    to the `id` column. This function generates numbers sequentially, starting with
    1\. If you need a different behavior, create the sequence number generator manually.
    Here''s an example of how to do this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发出命令`\d traffic_unit`来显示表描述，您将看到`id`列分配了函数`nextval('traffic_unit_id_seq'::regclass)`。此函数按顺序生成数字，从1开始。如果您需要不同的行为，可以手动创建序列号生成器。以下是如何做到这一点的示例：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This sequence starts from 1,000, and caches 10 numbers for a better performance,
    if there is a need to generate numbers in quick succession.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列从1,000开始，缓存10个数字以提高性能，如果需要快速生成数字。
- en: 'According to the code examples given in the previous chapters, the values of `vehicle_type`,
    `road_condition`, and `tire_condition` are limited by the `enum` type. That''s
    why when the `traffic_unit` table is populated, we would like to make sure that
    only the values of the corresponding `enum` type can be set in the column. To
    accomplish this, we''ll create a lookup table called `enums` and populate it with
    the values from our `enum` types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前几章中给出的代码示例，`vehicle_type`、`road_condition`和`tire_condition`的值受`enum`类型的限制。这就是为什么当`traffic_unit`表被填充时，我们希望确保只有相应的`enum`类型的值可以设置在列中。为了实现这一点，我们将创建一个名为`enums`的查找表，并用我们`enum`类型的值填充它：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: PostgreSQL has an `enum` data type, but it incurs an overhead if the list of
    possible values is not fixed and has to be changed over time. We think it is quite
    possible that the list of values in our application will expand. So, we decided
    not to use a database `enum` type but create the lookup table ourselves.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL有一个`enum`数据类型，但如果可能值的列表不固定并且需要随时间更改，它会产生额外的开销。我们认为我们的应用程序中可能会扩展值的列表。因此，我们决定不使用数据库的`enum`类型，而是自己创建查找表。
- en: 'Now, we can refer to the values of the `enums` table from the `traffic_unit`
    table by using their ID as a foreign key. First, we delete the table:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用它们的ID作为外键，从`traffic_unit`表中引用`enums`表的值。首先，我们删除表：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, we recreate it with a slightly different SQL command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们用稍微不同的SQL命令重新创建它：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The columns `vehicle_type`, `road_condition`, and `tire_condition` must now
    be populated by the values of a primary key of the corresponding record of the
    `enums` table. This way, we can make sure that our traffic-analyzing code will
    be able to match the values in these columns to the values of the `enum` types
    in the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`vehicle_type`、`road_condition`和`tire_condition`列现在必须由`enums`表相应记录的主键值填充。这样，我们可以确保我们的交通分析代码能够将这些列的值与代码中的`enum`类型的值匹配。'
- en: There's more...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We would also like to make sure that the `enums` table does not contain a duplicate
    combination type and value. To ensure this, we can add a unique constraint to
    the `enums` table:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望确保`enums`表不包含重复的组合类型和值。为了确保这一点，我们可以向`enums`表添加唯一约束：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if we try to add a duplicate, the database will not allow it.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试添加重复项，数据库将不允许。
- en: 'Another important consideration of database table creation is whether an index
    has to be added. An *index* is a data structure that helps to accelerate data
    searches in the table without having to check every table record. It can include
    one or more columns of a table. For example, an index for a primary key is created
    automatically. If you bring up the description of the table we have created already,
    you will see the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库表创建的另一个重要考虑因素是是否需要添加索引。*索引*是一种数据结构，可以加速在表中进行数据搜索，而无需检查每个表记录。它可以包括一个或多个表的列。例如，主键的索引会自动创建。如果您打开我们已经创建的表的描述，您会看到以下内容：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also add an index ourselves if we think (and have proven by experimentation)
    it will help the application performance. In the case of `traffic_unit`, we discovered
    that our code often searches this table by `vehicle_type` and `passengers_count`.
    So, we measured the performance of our code during the search and added these
    two columns to the index:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们认为（并通过实验已经证明）添加索引将有助于应用程序的性能，我们也可以自己添加索引。在`traffic_unit`的情况下，我们发现我们的代码经常通过`vehicle_type`和`passengers_count`搜索这个表。因此，我们测量了我们的代码在搜索过程中的性能，并将这两列添加到了索引中：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, we measure the performance again. If it does improve, we would leave
    the index in place, but, in our case, we have removed it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次测量性能。如果性能有所改善，我们将保留索引，但在我们的情况下，我们已经删除了它：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The index did not improve the performance significantly, probably because an
    index has an overhead of additional writes and storage space.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 索引并没有显著改善性能，可能是因为索引会增加额外的写入和存储空间的开销。
- en: In our examples of primary key, constraints, and indexes, we followed the naming
    convention of PostgreSQL. If you use a different database, we suggest you look
    up its naming convention and follow it, so that your naming aligns with the names
    created automatically.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主键、约束和索引示例中，我们遵循了PostgreSQL的命名约定。如果您使用不同的数据库，我们建议您查找其命名约定并遵循，以便您的命名与自动创建的名称保持一致。
- en: Performing CRUD operations using JDBC
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC执行CRUD操作
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the using JDBC.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用JDBC在表中填充、读取、更改和删除数据。
- en: Getting ready
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We have already seen examples of SQL statements that create (populate) data
    in the database:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了在数据库中创建（填充）数据的SQL语句示例：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We''ve also seen examples of instances where several table records have to
    be added:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了需要添加多个表记录的示例：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If a column has a default value specified, there is no need to list it in the
    `INSERT INTO` statement, unless a different value has to be inserted.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果列有指定的默认值，则无需在 `INSERT INTO` 语句中列出它，除非需要插入不同的值。
- en: 'The reading of the data from the database is done by a `SELECT` statement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `SELECT` 语句从数据库中读取数据：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s a general definition of the `WHERE` clause:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `WHERE` 子句的一般定义：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `column_name operator value` construct can be combined with logical operators
    `AND` and `OR` and grouped with the brackets `(` and `)`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`column_name operator value` 结构可以与逻辑运算符 `AND` 和 `OR` 结合，并用括号 `(` 和 `)` 进行分组。'
- en: 'The selected values can be returned in a certain order:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 所选的值可以按特定顺序返回：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The order can be marked as ascending (default) or descending:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序可以标记为升序（默认）或降序：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The data can be changed with the `UPDATE` statement:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 数据可以使用 `UPDATE` 语句进行更改：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Alternatively, it can be deleted with the `DELETE` statement:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用 `DELETE` 语句进行删除：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Without the `WHERE` clause, all the records of the table are going to be affected
    by the `UPDATE` or `DELETE` statement.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有 `WHERE` 子句，`UPDATE` 或 `DELETE` 语句将影响表的所有记录。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We have already seen an `INSERT` statement. Here is an example of other types
    of statements:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 `INSERT` 语句。这里是其他类型语句的示例：
- en: '![](img/456f0881-a644-4c13-b79f-68f96a8876e1.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/456f0881-a644-4c13-b79f-68f96a8876e1.png)'
- en: 'The preceding `SELECT` statement brings up the values from all the columns
    of all the rows of the table. To limit the amount of returned data, a `WHERE`
    clause can be added:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的 `SELECT` 语句显示了表的所有行的所有列的值。为了限制返回的数据量，可以添加 `WHERE` 子句：
- en: '![](img/1ac573ef-e7fd-47fd-8922-ef05c578f9bf.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1ac573ef-e7fd-47fd-8922-ef05c578f9bf.png)'
- en: 'The following screenshot captures three statements:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图捕获了三个语句：
- en: '![](img/e186a7aa-af83-4997-b7f5-3f1a9f05fe97.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e186a7aa-af83-4997-b7f5-3f1a9f05fe97.png)'
- en: The first one is an `UPDATE` statement that changes values in the `value` column
    to `NEW`, but only in the rows where the `value` column contains value `new` (apparently,
    the value is case-sensitive). The second statement deletes all the rows that do
    not have the value `NEW` in the `value` column. The third statement (`SELECT`)
    retrieves values from all the rows of all columns.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是 `UPDATE` 语句，将 `value` 列中的值更改为 `NEW`，但仅在 `value` 列包含值 `new` 的行中（显然，该值区分大小写）。第二个语句删除所有
    `value` 列中没有值 `NEW` 的行。第三个语句（`SELECT`）检索所有行的所有列的值。
- en: It is worth noting that we would not be able to delete the records of the `enums`
    table if these records were referred to (as foreign keys) by the `traffic_unit` table.
    Only after deleting the corresponding records of the `traffic_unit` table it is
    possible to delete the records of the `enums` table.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，如果 `enums` 表的记录被 `traffic_unit` 表（作为外键）引用，我们将无法删除这些记录。只有在删除 `traffic_unit`
    表的相应记录之后，才能删除 `enums` 表的记录。
- en: 'To execute any of the CRUD operations in the code, one has to acquire a JDBC
    connection first, then create and execute a statement:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中执行CRUD操作之一，首先必须获取JDBC连接，然后创建并执行语句：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is good practice to use the `try-with-resources` construct for the `Statement`
    object. The closing of the `Connection` object would close the `Statement` object
    automatically. However, when you close the `Statement` object explicitly, the
    cleanup happens immediately, instead of you having to wait for the necessary checks
    and actions to propagate through the layers of the framework.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `try-with-resources` 结构来处理 `Statement` 对象是一个良好的实践。关闭 `Connection` 对象将自动关闭
    `Statement` 对象。但是，当您显式关闭 `Statement` 对象时，清理将立即发生，而不必等待必要的检查和操作传播到框架的各个层。
- en: The `execute()` method is the most generic one among the three methods that
    can execute a statement. The other two include `executeQuery()` (for `SELECT`
    statements only) and `executeUpdate()` (for `UPDATE`, `DELETE`, `CREATE`, or `ALTER`
    statements). As you can see from the preceding example, the `execute()` method returns
    `boolean`, which indicates whether the result is a `ResultSet` object or just
    a count. This means that `execute()` acts as `executeQuery()` for the `SELECT`
    statement and `executeUpdate()` for the other statements that we have listed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute()` 方法是可以执行语句的三种方法中最通用的方法。其他两种包括 `executeQuery()`（仅用于 `SELECT` 语句）和
    `executeUpdate()`（用于 `UPDATE`、`DELETE`、`CREATE` 或 `ALTER` 语句）。从前面的示例中可以看出，`execute()`
    方法返回 `boolean`，表示结果是 `ResultSet` 对象还是仅仅是计数。这意味着 `execute()` 对于 `SELECT` 语句起到了
    `executeQuery()` 的作用，对于我们列出的其他语句起到了 `executeUpdate()` 的作用。'
- en: 'We can demonstrate this by running the preceding code for the following sequence
    of statements:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行前面的代码来演示以下语句序列：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result will be as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/cf42e0dc-980d-4553-8b9e-aee5f1c48817.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf42e0dc-980d-4553-8b9e-aee5f1c48817.png)'
- en: We used the positional extraction of the values from `ResultSet` because this
    is more efficient than using the column name (as in `rs.getInt("id")` or `rs.getInt("type")`).
    The difference in performance is very small, though, and becomes important only
    when the operation happens many times. Only the actual measuring and testing can
    tell you whether this difference is significant for your application. Bear in
    mind that getting values by name provides better code readability, which pays
    well in the long term during application maintenance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了从 `ResultSet` 中提取值的位置提取，因为这比使用列名（如 `rs.getInt("id")` 或 `rs.getInt("type")`）更有效。性能差异非常小，只有在操作发生多次时才变得重要。只有实际的测量和测试才能告诉您这种差异对于您的应用程序是否重要。请记住，按名称获取值提供更好的代码可读性，在应用程序维护期间长期受益。
- en: 'We used the `execute()` method for demonstration purposes. In practice, the `executeQuery()` method is
    used for `SELECT` statements:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用`execute()`方法进行演示。在实践中，`executeQuery()`方法用于`SELECT`语句：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As you can see, the preceding code cannot be generalized as a method that receives
    the SQL statement as a parameter. The code that extracts the data is specific
    to the executed SQL statement. By contrast, the call to `executeUpdate()` can
    be wrapped in a generic method:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前面的代码无法作为接收SQL语句作为参数的方法进行泛化。提取数据的代码特定于执行的SQL语句。相比之下，对`executeUpdate()`的调用可以包装在通用方法中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'SQL is a rich language, and we do not have enough space to cover all of its
    features. But we would like to enumerate a few of its most popular ones so that
    you are aware of their existence and can look them up when needed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是一种丰富的语言，我们没有足够的空间来涵盖其所有功能。但我们想列举一些最受欢迎的功能，以便您了解它们的存在，并在需要时查找它们：
- en: The `SELECT` statement allows the use of the `DISTINCT` keyword, to get rid
    of all the duplicate values
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`语句允许使用`DISTINCT`关键字，以摆脱所有重复的值'
- en: The keyword `LIKE` allows you to set the search pattern to the `WHERE` clause
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`LIKE`允许您将搜索模式设置为`WHERE`子句
- en: The search pattern can use several wildcards—`%, _`, `[charlist]`, `[^charlist]`,
    or `[!charlist]`.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索模式可以使用多个通配符——`%， _`，`[charlist]`，`[^charlist]`或`[!charlist]`。
- en: Matching values can be enumerated with the `IN` keyword
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配值可以使用`IN`关键字枚举
- en: The `SELECT` statement can include several tables using the `JOIN` clause
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`语句可以使用`JOIN`子句包括多个表'
- en: '`SELECT * INTO table_2 from table_1` creates `table_2` and copies data from
    `table_1`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT * INTO table_2 from table_1`创建`table_2`并从`table_1`复制数据'
- en: '`TRUNCATE` is faster and uses fewer resources when removing all the rows of
    a table'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRUNCATE`在删除表的所有行时更快且使用更少的资源'
- en: 'There are many other useful methods in the `ResultSet` interface as well. Here
    is an example of how some of its methods can be used to write generic code that
    would traverse the returned result and use metadata to print out the column name
    and the returned value:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`接口中还有许多其他有用的方法。以下是一些方法如何用于编写通用代码，遍历返回的结果并使用元数据打印列名和返回值的示例：'
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We used `ResultSetMetaData` only once to collect the returned column names
    and the length (number of columns) of one row. Then, we extracted the values from
    each row by position and created `List<String>` elements with the corresponding
    column names. To print, we used something you are already familiar with—a programmer''s
    delight—the joining collector (we discussed it in the previous chapter). If we
    call the `traverseRS("select * from enums")` method, the result will be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只使用了一次`ResultSetMetaData`来收集返回的列名和一行的长度（列数）。然后，我们通过位置从每行中提取值，并创建了相应列名的`List<String>`元素。为了打印，我们使用了您已经熟悉的东西——程序员的乐趣——连接收集器（我们在上一章中讨论过）。如果我们调用`traverseRS("select
    * from enums")`方法，结果将如下所示：
- en: '![](img/e39680bf-4ea3-44d3-ac17-e0ae0bbe2e4f.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e39680bf-4ea3-44d3-ac17-e0ae0bbe2e4f.png)'
- en: Using the Hikari Connection Pool (HikariCP)
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Hikari连接池（HikariCP）
- en: In this recipe, you will learn how to set up and use the high-performance HikariCP.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何设置和使用高性能的HikariCP。
- en: Getting ready
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: The HikariCP framework was created by Brett Wooldridge, who lives in Japan.
    *Hikari* in Japanese means *light*. It is a lightweight and relatively small API
    that is highly optimized and allows for tuning via many properties, some of which
    are not available in other pools. In addition to standard user, password, maximum
    pool size, various timeout settings, and cache configuration properties, it also
    exposes such properties as `allowPoolSuspension`, `connectionInitSql`, `connectionTestQuery`,
    and many others, even including a property that deals with the not-timely-closed
    connections, `leakDetectionThreshold`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: HikariCP框架是由居住在日本的Brett Wooldridge创建的。*Hikari*在日语中的意思是*光*。它是一个轻量级且相对较小的API，经过高度优化，并允许通过许多属性进行调整，其中一些属性在其他池中不可用。除了标准用户、密码、最大池大小、各种超时设置和缓存配置属性之外，它还公开了诸如`allowPoolSuspension`、`connectionInitSql`、`connectionTestQuery`等属性，甚至包括处理未及时关闭的连接的属性`leakDetectionThreshold`。
- en: 'To use the latest (at the time of writing this book) version of Hikari pool,
    add the following dependency to the project:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用最新（在撰写本书时）版本的Hikari池，请将以下依赖项添加到项目中：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For demonstration purposes, we will use the database created in the previous
    recipe of this chapter, *Connecting to a database using JDBC*. We will also assume
    that you have studied that recipe and there is no need to repeat what was said
    there about the database, JDBC, and how they work together.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，我们将使用本章前一个配方中创建的数据库*使用JDBC连接到数据库*。我们还假设您已经学习了该配方，因此无需重复讨论数据库、JDBC以及它们如何一起工作的内容。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'There are several ways to configure the Hikari connection pool. All of them
    are based on the usage of the `javax.sql.DataSource` interface:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种配置Hikari连接池的方法。所有这些方法都基于`javax.sql.DataSource`接口的使用：
- en: 'The most obvious and straightforward method is to set the pool properties on
    the `DataSource` object directly:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最明显和直接的方法是直接在`DataSource`对象上设置池属性：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We have commented out password because we did not set one for our database. Between
    properties `jdbcUrl` and `dataSourceClassName`, only one of them can be used at
    a time, except when using some older drivers that may require setting both of
    these properties. Also, please notice how we have used the general method `addDataSourceProperty()`
    when there is no dedicated setter for the particular property.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注释掉了密码，因为我们没有为我们的数据库设置密码。在`jdbcUrl`和`dataSourceClassName`属性之间，一次只能使用一个，除非使用一些可能需要同时设置这两个属性的旧驱动程序。此外，请注意当没有专门的setter用于特定属性时，我们如何使用通用方法`addDataSourceProperty()`。
- en: To switch from PostgreSQL to another relational database, all you need to do
    is change the driver class name and the database URL. There are also many other
    properties; some of them are database specific, but we are not going to dive into
    such details, because this recipe demonstrates how to use HikariCP. Read the database
    documentation about database-specific pool configuration properties and how to
    use them for tuning the pool for the best performance, which also very much depends
    on how the particular application interacts with the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要从PostgreSQL切换到另一个关系数据库，您只需要更改驱动程序类名和数据库URL。还有许多其他属性；其中一些是特定于数据库的，但我们不打算深入研究这些细节，因为本配方演示了如何使用HikariCP。阅读有关特定于数据库的池配置属性的数据库文档，并了解如何使用它们来调整池以获得最佳性能，这在很大程度上也取决于特定应用程序与数据库的交互方式。
- en: 'Another way to configure the Hikari pool is to use the `HikariConfig` class
    to collect all the properties and then set the `HikariConfig` object in the `HikariDataSource`
    constructor:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置Hikari池的另一种方法是使用`HikariConfig`类收集所有属性，然后将`HikariConfig`对象设置在`HikariDataSource`构造函数中：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we have used the general method `addDataSourceProperty()` again
    because there are no dedicated setters for those properties in the `HikariConfig` class
    either.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们再次使用了通用方法`addDataSourceProperty()`，因为在`HikariConfig`类中也没有专门的设置器来设置这些属性。
- en: 'The `HikariConfig` object, in turn, can be populated with data using the class
    `java.util.Properties`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`HikariConfig`对象反过来可以使用`java.util.Properties`类填充数据：'
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Please, note that we have used the prefix `dataSource` for the properties that
    do not have dedicated setters in the `HikariConfig` class.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于在`HikariConfig`类中没有专用设置器的属性，我们使用了前缀`dataSource`。
- en: 'To make the configuration even easier to load, the `HikariConfig` class has
    a constructor that accepts a file with the properties. For example, let''s create
    a file called `database.properties` in the folder `resources` with the following
    content:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使配置更容易加载，`HikariConfig`类具有接受属性文件的构造函数。例如，让我们在`resources`文件夹中创建一个名为`database.properties`的文件，其中包含以下内容：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice how we used the prefix `dataSource` with the same properties again.
    Now, we can load the preceding file directly into the `HikariConfig` constructor:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们再次使用了相同属性的前缀`dataSource`。现在，我们可以直接将上述文件加载到`HikariConfig`构造函数中：
- en: '[PRE35]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Behind the scenes, as you could guess, it just loads properties:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，正如您可能猜到的那样，它只是加载属性：
- en: '[PRE36]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Alternatively, we can use the following functionality that''s included in the
    `HikariConfig` default constructor:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`HikariConfig`默认构造函数中包含的以下功能：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It means that we can set the system property as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以设置系统属性如下：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we can configure HikariCP as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以配置HikariCP如下：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All the preceding methods of the pool configuration produce the same result,
    so it is only up to the style, convention, or just your personal preference to
    decide which of them to use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 池配置的所有前述方法产生相同的结果，因此只取决于风格、约定或个人偏好来决定使用其中的哪一个。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The following method is using the created `DataSource` object to access the
    database and select all the values from the table `enums`, which were created
    in the recipe *Connecting to a database using JDBC*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法是使用创建的`DataSource`对象访问数据库，并从在配方*使用JDBC连接到数据库*中创建的`enums`表中选择所有值：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run the preceding code, the result will be as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，结果将如下所示：
- en: '![](img/5414536a-6a29-4968-9f6d-00b03b826ae7.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5414536a-6a29-4968-9f6d-00b03b826ae7.png)'
- en: There's more...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can read more about HikariCP's features on GitHub ([https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上阅读有关HikariCP功能的更多信息（[https://github.com/brettwooldridge/HikariCP](https://github.com/brettwooldridge/HikariCP)）。
- en: Using prepared statements
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用预处理语句
- en: In this recipe, you will learn how to use a **prepared statement**—a statement
    template that can be stored in the database and executed efficiently with different
    input values.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，您将学习如何使用**预处理语句**——可以存储在数据库中并使用不同输入值高效执行的语句模板。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: An object of `PreparedStatement`—a subinterface of `Statement`—can be precompiled
    and stored in the database and then used to efficiently execute the SQL statement
    multiple times for different input values. Similar to an object of `Statement` (created
    by the `createStatement()` method), it can be created by the `prepareStatement()`
    method of the same `Connection` object.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement`对象——`Statement`的子接口——可以预编译并存储在数据库中，然后用于高效地执行不同输入值的SQL语句。与由`createStatement()`方法创建的`Statement`对象类似，它可以由相同`Connection`对象的`prepareStatement()`方法创建。'
- en: 'The same SQL statement that was used to generate `Statement` can be used to
    generate `PreparedStatement` too. In fact, it is a good idea to consider using
    `PrepdaredStatement` for any SQL statement that is called multiple times, because
    it performs better than `Statement`. To do this, all we need to change are these
    two lines in the sample code of the previous section:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 用于生成`Statement`的相同SQL语句也可以用于生成`PreparedStatement`。实际上，考虑使用`PrepdaredStatement`来替换多次调用的任何SQL语句是一个好主意，因为它的性能优于`Statement`。要做到这一点，我们只需要更改上一节示例代码中的这两行：
- en: '[PRE41]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We change these lines to the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些行更改为以下内容：
- en: '[PRE42]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: How to do it...
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The true usefulness of `PreparedStatement` shines because of its ability to
    accept parameters—the input values that substitute (in order of appearance) the
    `?` symbol. Here''s an example of this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreparedStatement`的真正用处在于它能够接受参数——替换（按顺序出现）`?`符号的输入值。以下是一个示例：'
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The result of this is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 其结果如下：
- en: '![](img/35314b63-dd97-4fae-8663-b4e6215e850f.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35314b63-dd97-4fae-8663-b4e6215e850f.png)'
- en: There's more...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It is not a bad idea to always use prepared statements for CRUD operations.
    They might be slower if executed only once, but you can test and see whether this
    is the price you are willing to pay. By using prepared statements systematically,
    you will produce a consistent (better readable) code that provides more security
    (prepared statements are not vulnerable to SQL injection).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用准备好的语句进行CRUD操作并不是一个坏主意。如果只执行一次，它们可能会比较慢，但您可以测试并查看这是否是您愿意支付的代价。通过系统地使用准备好的语句，您将产生一致的（更易读的）代码，提供更多的安全性（准备好的语句不容易受到SQL注入的攻击）。
- en: Using transactions
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用事务
- en: In this recipe, you will learn what a database transaction is and how it can
    be used in Java code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习什么是数据库事务以及如何在Java代码中使用它。
- en: Getting ready
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: A **transaction** is a unit of work that includes one or many operations that
    change data. If successful, all the data changes are **committed** (applied to
    the database). If one of the operations errors out, the transaction is **rolled
    back**,and none of the changes included in the transaction will be applied to
    the database.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**事务**是一个包括一个或多个改变数据的操作的工作单元。如果成功，所有数据更改都将被**提交**（应用到数据库）。如果其中一个操作出错，事务将**回滚**，并且事务中包含的所有更改都不会应用到数据库。'
- en: Transaction properties are set up on the `Connection` object. They can be changed
    without closing the connection, so different transactions can reuse the same `Connection`
    object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 事务属性是在`Connection`对象上设置的。它们可以在不关闭连接的情况下更改，因此不同的事务可以重用相同的`Connection`对象。
- en: JDBC allows transaction control only for CRUD operations. Table modification
    (`CREATE TABLE`, `ALTER TABLE`, and so on) is committed automatically and cannot
    be controlled from the Java code.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC仅允许对CRUD操作进行事务控制。表修改（`CREATE TABLE`，`ALTER TABLE`等）会自动提交，并且无法从Java代码中进行控制。
- en: By default, a CRUD operation transaction is set to be **auto-committed**. This
    means that every data change that was introduced by a SQL statement is applied
    to the database as soon as the execution of this statement is completed. All the
    preceding examples in this chapter use this default behavior.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CRUD操作事务被设置为**自动提交**。这意味着每个由SQL语句引入的数据更改都会在该语句的执行完成后立即应用到数据库中。本章中的所有前面的示例都使用了这种默认行为。
- en: To change this behavior, you have to use the `setAutoCommit(boolean)` method
    of the `Connection` object. If set to `false`, the data changes will not be applied
    to the database until the `commit()` method on the `Connection` object is invoked.
    Also, if the `rollback()` method is called instead, all the data changes since
    the beginning of the transaction or since the last call to `commit()` will be
    discarded.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改此行为，您必须使用`Connection`对象的`setAutoCommit(boolean)`方法。如果设置为`false`，则数据更改将不会应用到数据库，直到在`Connection`对象上调用`commit()`方法为止。此外，如果调用`rollback()`方法，那么自事务开始或上次调用`commit()`以来的所有数据更改都将被丢弃。
- en: Explicit programmatic transaction management improves performance, but it is
    insignificant in the case of short atomic operations that are called once and
    not very often. Taking over transaction control becomes crucial when several operations
    introduce changes that have to be applied either all together or none of them.
    It allows for group database changes into atomic units and thus avoids accidental
    violation of data integrity.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 显式的程序化事务管理可以提高性能，但在只调用一次且不太频繁的短时间原子操作的情况下，它并不重要。接管事务控制在多个操作引入必须一起应用或全部不应用的更改时变得至关重要。它允许将数据库更改分组为原子单元，从而避免意外违反数据完整性。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, let''s add an output to the `traverseRS()` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向`traverseRS()`方法添加一个输出：
- en: '[PRE44]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will help you analyze the output when many different SQL statements are
    executed in the same demo example.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这将帮助您分析当许多不同的SQL语句在同一个演示示例中执行时的输出。
- en: 'Now, let''s run the following code that reads data from the `enums` table,
    then inserts a row, and then reads all the data from the table again:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们运行以下代码，从`enums`表中读取数据，然后插入一行，然后再次从表中读取所有数据：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Note that we took over transaction control by calling `conn.setAutoCommit(false)`.
    The result is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过调用`conn.setAutoCommit(false)`接管了事务控制。结果如下：
- en: '![](img/63dd3a04-23c6-4544-b564-656112337f7b.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63dd3a04-23c6-4544-b564-656112337f7b.png)'
- en: 'As you can see, the changes were not applied because the call to `commit()` was
    commented out. When we uncomment it, the result changes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，由于对`commit()`的调用被注释掉，所以更改没有被应用。当我们取消注释时，结果会改变：
- en: '![](img/585677de-5653-4928-9304-f01cb41ee08d.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/585677de-5653-4928-9304-f01cb41ee08d.png)'
- en: 'Now, let''s execute two inserts, but introduce a spelling error in the second
    insert:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行两次插入，但在第二次插入中引入一个拼写错误：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We get an exception stack trace (we do not show it to save space) and this
    message:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个异常堆栈跟踪（我们不显示它以节省空间）和这个消息：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Nevertheless, the first insert was executed successfully:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管第一个插入成功执行：
- en: '![](img/e419c1af-ae1e-4f52-942c-a47dacd0d441.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e419c1af-ae1e-4f52-942c-a47dacd0d441.png)'
- en: The second row was not inserted. If there was no `conn.commit()` after the first
    `INSERT INTO` statement, the first insert would not be applied either. This is
    the advantage of the programmatic transaction control in the case of many independent
    data changes—if one fails, we can skip it and continue applying other changes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行没有被插入。如果在第一个`INSERT INTO`语句之后没有`conn.commit()`，那么第一个插入也不会被应用。这是在许多独立数据更改的情况下进行程序化事务控制的优势——如果一个失败，我们可以跳过它并继续应用其他更改。
- en: 'Now, let''s try to insert three rows with an error (by setting a letter instead
    of a number as the `id` value) in the second row:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试插入三行数据，并在第二行中引入一个错误（将字母设置为`id`值而不是数字）：
- en: '[PRE48]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We put each insert execution in the `try...catch` block and commit the changes
    before printing out the result (update count or error message). The result is
    as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个插入执行放在`try...catch`块中，并在打印出结果（更新计数或错误消息）之前提交更改。结果如下：
- en: '![](img/5a3508cd-c51f-4528-84f5-ab1488060a72.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5a3508cd-c51f-4528-84f5-ab1488060a72.png)'
- en: As you can see, the second row was not inserted, although `conn.rollback()`
    was commented out. Why? This is because the only SQL statement included in this
    transaction failed, so there was nothing to roll back.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，第二行没有被插入，尽管`conn.rollback()`被注释掉了。为什么？这是因为此事务中只包括的SQL语句失败了，所以没有什么可以回滚的。
- en: 'Now, let''s create a `test` table with only one column `name` using the database
    console:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用数据库控制台创建一个只有一个名为`name`的列的`test`表：
- en: '![](img/6ca14c11-e647-4987-be46-5c990139bfb0.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6ca14c11-e647-4987-be46-5c990139bfb0.png)'
- en: 'We will insert in the table `test` the vehicle type before inserting a record
    in the `enums` table:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在插入`enums`表中的记录之前，我们将在`test`表中插入车辆类型：
- en: '[PRE49]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'As you can see, the previous code commits the changes after the second insert,
    which, as in the previous example, is not successful for the second element of
    the array `values`. With `conn.rollback()` commented out, the result will be as
    follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，前面的代码在第二次插入后提交了更改，就像前面的例子一样，对于数组`values`的第二个元素来说是不成功的。如果注释掉`conn.rollback()`，结果将如下所示：
- en: '![](img/df8484ad-6982-4d0c-881e-2b3898f82cbb.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df8484ad-6982-4d0c-881e-2b3898f82cbb.png)'
- en: 'The row with `truck` was not inserted in the `enums` table but added to the
    `test` table. That is, when the usefulness of a rollback was demonstrated. If
    we uncomment `conn.rollback()`, the result will be as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`enums`表中没有插入`truck`行，但是添加到了`test`表中。也就是说，演示了回滚的有用性。如果我们取消注释`conn.rollback()`，结果将如下所示：'
- en: '![](img/b69ab672-bf8d-4297-b83e-29fbbbda6850.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b69ab672-bf8d-4297-b83e-29fbbbda6850.png)'
- en: This demonstrates that `conn.rollback()` rolls back all the changes not committed
    yet.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明`conn.rollback()`会回滚所有尚未提交的更改。
- en: There's more...
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Another important property of a transaction is the** transaction isolation level**.
    It defines the boundaries between database users. For example, can other users
    see your database changes before they are committed? The higher the isolation
    (the highest is **serializable**), the more time it takes a transaction to complete
    in the case of concurrent access to the same records. The less restrictive the
    isolation (the least restrictive is **read uncommitted**), the dirtier the data
    is, which means that other users can get the values you have not committed yet
    (and are maybe never going to commit).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的另一个重要属性是**事务隔离级别**。它定义了数据库用户之间的边界。例如，在提交之前其他用户能否看到您的数据库更改？隔离级别越高（最高为**可串行化**），在并发访问相同记录的情况下，事务完成所需的时间就越长。隔离级别越低（最低为**读未提交**），数据就越脏，这意味着其他用户可以获取您尚未提交的值（也许永远不会提交）。
- en: Usually, it is enough to use the default level, which is typically `TRANSACTION_READ_COMMITTED`, although
    it may be different for different databases. JDBC allows you to get the current
    transaction isolation level by calling the method `getTransactionIsolation()` on
    the `Connection` object. The method `setTransactionIsolation()` of the `Connection`
    object allows you to set any isolation level as needed.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用默认级别就足够了，通常是`TRANSACTION_READ_COMMITTED`，尽管对于不同的数据库可能会有所不同。JDBC允许您通过在`Connection`对象上调用`getTransactionIsolation()`方法来获取当前事务隔离级别。`Connection`对象的`setTransactionIsolation()`方法允许您根据需要设置任何隔离级别。
- en: In the case of complex decision-making logic about which changes need to be
    committed and which need to be rolled back, one can use two other `Connection`
    methods to create and delete **savepoints**. The `setSavepoint(String savepointName)` method creates
    a new savepoint and returns a `Savepoint` object, which can later be used to roll
    back all the changes up to this point using the `rollback (Savepoint savepoint)`
    method. A savepoint can be deleted by calling `releaseSavepoint(Savepoint savepoint)`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的决策逻辑中，关于哪些更改需要提交，哪些需要回滚，可以使用另外两个`Connection`方法来创建和删除**保存点**。`setSavepoint(String
    savepointName)`方法创建一个新的保存点并返回一个`Savepoint`对象，以后可以使用`rollback (Savepoint savepoint)`方法回滚到此点的所有更改。可以通过调用`releaseSavepoint(Savepoint
    savepoint)`来删除保存点。
- en: The most complex types of database transactions are **distributed transactions**.
    They are sometimes called **global transactions**, **XA transactions**, or **JTA
    transactions** (the latter is a Java API that consists of two Java packages, namely `javax.transaction`
    and `javax.transaction.xa`). They allow for the creation and execution of a transaction
    that spans operations across two different databases. Providing a detailed overview
    of distributed transactions is outside the scope of this book.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最复杂的数据库事务类型是**分布式事务**。它们有时被称为**全局事务**、**XA事务**或**JTA事务**（后者是一个由两个Java包组成的Java
    API，即`javax.transaction`和`javax.transaction.xa`）。它们允许创建和执行跨两个不同数据库操作的事务。提供分布式事务的详细概述超出了本书的范围。
- en: Working with large objects
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用大对象
- en: In this recipe, you will learn how to store and retrieve a LOB that can be one
    of three types—**Binary Large Object** (**BLOB**), **Character Large Object**
    (**CLOB**), and **National Character Large Object** (**NCLOB**).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何存储和检索可以是三种类型之一的LOB——**二进制大对象**（**BLOB**）、**字符大对象**（**CLOB**）和**国家字符大对象**（**NCLOB**）。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The actual processing of LOB objects inside a database is vendor-specific, but
    JDBC APIs hide these implementation details from the application by representing
    the three LOB types as interfaces—`java.sql.Blob`, `java.sql.Clob`, and `java.sql.NClob`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库内LOB对象的实际处理是特定于供应商的，但是JDBC API通过将三种LOB类型表示为接口——`java.sql.Blob`、`java.sql.Clob`和`java.sql.NClob`，隐藏了这些实现细节。
- en: '`Blob` is usually used to store images or other non-alphanumeric data. On the
    way to the database, an image can be converted into a stream of bytes and stored
    using the `INSERT INTO` statement. The `Blob` interface allows you to find the
    length of the object and convert it into an array of bytes that can be processed
    by Java for the purpose of displaying the image, for example.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Blob`通常用于存储图像或其他非字母数字数据。在到达数据库之前，图像可以转换为字节流并使用`INSERT INTO`语句进行存储。`Blob`接口允许您查找对象的长度并将其转换为Java可以处理的字节数组，以便显示图像等目的。'
- en: '`Clob` allows you to store character data. `NClob` stores Unicode character
    data as a way to support internationalization. It extends the `Clob` interface
    and provides the same methods. Both interfaces allow you to find the length of
    LOB and to get a substring inside the value.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`Clob`允许您存储字符数据。`NClob`以一种支持国际化的方式存储Unicode字符数据。它扩展了`Clob`接口并提供相同的方法。这两个接口都允许您查找LOB的长度并获取值内的子字符串。'
- en: The methods in the `ResultSet`, `CallableStatement` (we will discuss this in
    the next recipe), and `PreparedStatement` interfaces allow an application to store
    and access the stored value in a variety of ways—some of them via setters and
    getters of the corresponding objects, while others as `bytes[]`, or as a binary,
    character, or ASCII stream.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResultSet`，`CallableStatement`（我们将在下一个示例中讨论），和`PreparedStatement`接口中的方法允许应用程序以各种方式存储和访问存储的值——有些通过相应对象的设置器和获取器，而其他一些作为`bytes[]`，或作为二进制、字符或ASCII流。'
- en: How to do it...
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Each database has its specific way of storing a LOB. In the case of PostgreSQL,
    `Blob` is usually mapped to the `OID` or `BYTEA` data type, while `Clob` and `NClob` are
    mapped to the `TEXT` type. To demonstrate how to do this, let''s create tables
    that can store each of the large object types. We will write a new method that
    creates tables programmatically:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据库都有其特定的存储LOB的方式。在PostgreSQL的情况下，`Blob`通常映射到`OID`或`BYTEA`数据类型，而`Clob`和`NClob`则映射到`TEXT`类型。为了演示如何做到这一点，让我们创建可以存储每种大对象类型的表。我们将编写一个新的方法，以编程方式创建表：
- en: '[PRE50]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can create three tables:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建三个表：
- en: '[PRE51]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Look at the JDBC interfaces `PreparedStatement` and `ResultSet` and you'll notice
    the setters and getters for the objects—`get/setBlob()`, `get/setClob()`, `get/setNClob()`,
    `get/setBytes()`—and the methods that use `InputStream` and `Reader`—`get/setBinaryStream()`,
    `get/setAsciiStream()`, or `get/setCharacterStream()`. The big advantage of streaming
    methods is that they move data between the database and source without storing
    the whole LOB in memory.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 查看JDBC接口`PreparedStatement`和`ResultSet`，您会注意到对象的设置器和获取器——`get/setBlob()`，`get/setClob()`，`get/setNClob()`，`get/setBytes()`——以及使用`InputStream`和`Reader`的方法——`get/setBinaryStream()`，`get/setAsciiStream()`，或`get/setCharacterStream()`。流方法的重要优势在于它们在数据库和源之间传输数据而无需在内存中存储整个LOB。
- en: 'However, the object''s setters and getters are closer to our heart being in
    line with object-oriented coding. So we will start with them, using objects that
    aren''t too big, for demonstration purposes. We expect the following code to work
    just fine:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象的设置器和获取器更符合我们的心意，符合面向对象编程。因此，我们将从它们开始，使用一些不太大的对象进行演示。我们期望以下代码可以正常工作：
- en: '[PRE52]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Alternatively, in the case of `Clob`, we write this code:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，在`Clob`的情况下，我们编写这段代码：
- en: '[PRE53]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It turns out that not all methods that are available in the JDBC API are actually
    implemented by the drivers of all the databases. For example, `createBlob()` seems
    to work just fine for Oracle and MySQL, but in the case of PostgreSQL, we get
    this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，并非所有JDBC API中可用的方法都由所有数据库的驱动程序实际实现。例如，`createBlob()`似乎对Oracle和MySQL都可以正常工作，但在PostgreSQL的情况下，我们得到了这个：
- en: '![](img/2f4a350b-2998-4002-bd0e-84a9f5767a20.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2f4a350b-2998-4002-bd0e-84a9f5767a20.png)'
- en: 'For  `Clob`, we get the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Clob`，我们得到以下结果：
- en: '![](img/321c623c-b082-4b55-abf2-fd0a1de83494.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/321c623c-b082-4b55-abf2-fd0a1de83494.png)'
- en: 'We can try to retrieve an object from `ResultSet` via the getter as well:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以尝试通过获取器从`ResultSet`中检索对象：
- en: '[PRE54]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The result will be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下：
- en: '![](img/31e08560-ab43-4f7c-950b-b51ed9df254b.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/31e08560-ab43-4f7c-950b-b51ed9df254b.png)'
- en: 'Apparently, knowing the JDBC API is not enough; you have to read the documentation
    for the database too. Here is what the documentation for PostgreSQL ([https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html))
    has to say about LOB handling:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，仅仅了解JDBC API是不够的；您还必须阅读数据库的文档。以下是PostgreSQL文档（[https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)）对LOB处理的说明：
- en: '"To use the BYTEA data type you should simply use the `getBytes()`, `setBytes()`,
    `getBinaryStream()`, or `setBinaryStream()` methods.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '"要使用BYTEA数据类型，您应该简单地使用`getBytes()`，`setBytes()`，`getBinaryStream()`或`setBinaryStream()`方法。'
- en: To use the Large Object functionality you can use either the `LargeObject` class
    provided by the PostgreSQL JDBC driver, or by using the `getBLOB()` and `setBLOB()`
    methods."
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用大对象功能，您可以使用由PostgreSQL JDBC驱动程序提供的`LargeObject`类，或者使用`getBLOB()`和`setBLOB()`方法。"
- en: Also, you must access large objects within an SQL transaction block. You can
    start a transaction block by calling `setAutoCommit(false)`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您必须在SQL事务块内访问大对象。您可以通过调用`setAutoCommit(false)`来启动事务块。
- en: Without knowing such specifics, figuring out a way to handle LOBs would require
    a lot of time and cause much frustration.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 不知道这样的具体情况，找出处理LOB的方法将需要很多时间并引起很多挫折。
- en: 'When dealing with LOBs, the streaming methods are preferred because they transfer
    data directly from the source into the database (or the other way around) and
    do not consume memory as much as the setters and getters do (which have to load
    all the LOB in memory first). Here is the code that streams `Blob` in and from
    PostgreSQL database:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理LOB时，流方法更受青睐，因为它们直接从源传输数据到数据库（或反之），并且不像设置器和获取器那样消耗内存（后者必须首先将整个LOB加载到内存中）。以下是在PostgreSQL数据库中流传`Blob`的代码：
- en: '[PRE55]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s look at the result. We have cut the screenshot arbitrarily on the right-hand
    side; otherwise, it is too long horizontally:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看结果。我们在右侧任意裁剪了截图；否则，它在水平上太长了：
- en: '![](img/b260d44f-2343-4d92-b53f-66a43e2efdb2.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b260d44f-2343-4d92-b53f-66a43e2efdb2.png)'
- en: 'Another way to process the retrieved image is to use `byte[]`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 处理检索到的图像的另一种方法是使用`byte[]`：
- en: '[PRE56]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'PostgreSQL limits the `BYTEA` size to 1 GB. Larger binary objects can be stored
    as the **object identifier** (**OID**) data type:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL将`BYTEA`大小限制为1 GB。较大的二进制对象可以存储为**对象标识符**（**OID**）数据类型：
- en: '[PRE57]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The result will be as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/f99937f5-82a8-464b-bcd8-4474f59e2f42.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f99937f5-82a8-464b-bcd8-4474f59e2f42.png)'
- en: 'Please note that the `select` statement returns a long value from the `lob` column.
    This is because the `OID` column does not store the value itself like `BYTEA`
    does. Instead, it stores the reference to the object that is stored somewhere
    else in the database. Such an arrangement makes deleting the row with the OID
    type not as straightforward as this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`select`语句从`lob`列返回一个长值。这是因为`OID`列不像`BYTEA`那样存储值本身。相反，它存储对存储在数据库中其他位置的对象的引用。这样的安排使得删除具有OID类型的行不像这样直截了当：
- en: '[PRE58]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If you do just that, it leaves the actual object an orphan that continues to
    consume disk space. To avoid this problem, you have to `unlink` the LOB first
    by executing the following command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只是这样做，它会使实际对象成为一个继续占用磁盘空间的孤立对象。为了避免这个问题，您必须首先通过执行以下命令`unlink` LOB：
- en: '[PRE59]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Only after this can you safely execute the `delete from lobs where id = 100` commands.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在此之后，您才能安全地执行`delete from lobs where id = 100`命令。
- en: 'If you forgot to `unlink` first, or if you created an orphan LOB accidentally
    (because of an error in the code, for example), there is a way to find orphans
    in system tables. Again, database documentation should provide you with instructions
    on how to do this. In the case of PostgreSQL v.9.3 or later, you can check whether
    you have an orphan LOB by executing the `select count(*) from pg_largeobject` command.
    If it returns a count that is bigger than 0, then you can delete all the orphans
    with the following join (assuming that the `lobs` table is the only one that can
    contain a reference to a LOB):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您忘记首先`unlink`，或者因为代码错误而意外创建了孤立的LOB（例如），则可以通过在系统表中查找孤立对象的方式来找到孤立对象。同样，数据库文档应该为您提供如何执行此操作的说明。在PostgreSQL
    v.9.3或更高版本中，您可以通过执行`select count(*) from pg_largeobject`命令来检查是否有孤立的LOB。如果返回的计数大于0，则可以使用以下连接删除所有孤立对象（假设`lobs`表是唯一一个可能包含对LOB的引用的表）：
- en: '[PRE60]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is the price one has to pay for storing a LOB in a database.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在数据库中存储LOB所需付出的代价。
- en: It's worth noting that although `BYTEA` does not require such complexity during
    the delete operation, it has a different kind of overhead. According to the PostgreSQL
    documentation, when close to 1 GB, *it w**ould require a huge amount of memory
    to process such a large value.*
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，尽管`BYTEA`在删除操作期间不需要这样的复杂性，但它有一种不同类型的开销。根据PostgreSQL文档，当接近1 GB时，*处理这样一个大值将需要大量内存*。
- en: 'To read LOB data, you can use the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要读取LOB数据，您可以使用以下代码：
- en: '[PRE61]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Alternatively, it is possible to use a simpler code by getting `Blob` directly
    from the `ResultSet` object if the LOB is not too big:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果LOB不太大，可以直接从`ResultSet`对象中获取`Blob`，使用更简单的代码：
- en: '[PRE62]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To store `Clob` in PostgreSQL, you can use the same code as the preceding one.
    While reading from the database, you can convert bytes into a `String` data type
    or something similar (again, if the LOB is not too big):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PostgreSQL中存储`Clob`，可以使用与前面相同的代码。在从数据库中读取时，可以将字节转换为`String`数据类型或类似的内容（同样，如果LOB不太大）：
- en: '[PRE63]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'However, `Clob` in PostgreSQL can be stored directly as data type `TEXT` that
    is unlimited in size. This code reads the file where this code is written and
    stores/retrieves it in/from the database:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PostgreSQL中，`Clob`可以直接存储为无限大小的数据类型`TEXT`。这段代码读取了存有这段代码的文件，并将其存储/检索到/从数据库中：
- en: '[PRE64]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The result will be as follows (we have shown only the first few lines of the
    output):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示（我们只显示了输出的前几行）：
- en: '![](img/f762b169-3217-4bd3-9a84-254c4b414e97.png)'
  id: totrans-312
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f762b169-3217-4bd3-9a84-254c4b414e97.png)'
- en: 'For bigger objects, streaming methods would be a better (if not the only) choice:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的对象，流式处理方法将是更好的（如果不是唯一的）选择：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note that, as of the time of writing this book, `setCharacterStream(int, Reader,
    long)` is not implemented, while `setCharacterStream(int, Reader, int)` works
    just fine.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，截至撰写本书时，`setCharacterStream(int, Reader, long)`尚未实现，而`setCharacterStream(int,
    Reader, int)`却可以正常工作。
- en: 'We can also read the file from the `texts` table as a character stream and
    limit it to the first 160 characters:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从`texts`表中以字符流的形式读取文件，并将其限制在前160个字符：
- en: '[PRE66]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The result will be as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/1da666ee-263a-4240-a5db-ac07702ff50a.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1da666ee-263a-4240-a5db-ac07702ff50a.png)'
- en: There's more...
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Here is another recommendation from the PostgreSQL documentation (you can access
    it at [https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自PostgreSQL文档的另一个建议（您可以在[https://jdbc.postgresql.org/documentation/80/binary-data.html](https://jdbc.postgresql.org/documentation/80/binary-data.html)上访问）：
- en: '"The BYTEA data type is not well suited for storing very large amounts of binary
    data. While a column of type BYTEA can hold up to 1 GB of binary data, it would
    require a huge amount of memory to process such a large value.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: “BYTEA数据类型不适合存储大量二进制数据。虽然BYTEA类型的列最多可以容纳1 GB的二进制数据，但处理这样大的值将需要大量内存。
- en: The Large Object method for storing binary data is better suited to storing
    very large values, but it has its own limitations. Specifically deleting a row
    that contains a Large Object reference does not delete the Large Object. Deleting
    the Large Object is a separate operation that needs to be performed. Large Objects
    also have some security issues since anyone connected to the database can view
    and/or modify any Large Object, even if they don't have permissions to view/update
    the row containing the Large Object reference."
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 用于存储二进制数据的大对象方法更适合存储非常大的值，但它也有自己的局限性。特别是删除包含大对象引用的行并不会删除大对象。删除大对象是一个需要执行的单独操作。大对象也存在一些安全问题，因为任何连接到数据库的人都可以查看和/或修改任何大对象，即使他们没有权限查看/更新包含大对象引用的行。
- en: While deciding to store LOBs in a database, you need to remember that the bigger
    the database, the more difficult it is to maintain it. The speed of access—the
    main advantage of choosing a database as a storage facility—also decreases, and
    it is not possible to create indices for LOB types to improve the search. Also,
    you cannot use LOB columns in a `WHERE` clause, except for a few CLOB cases, or
    use LOB columns in multiple rows of `INSERT` or `UPDATE` statements.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定将LOB存储在数据库中时，您需要记住，数据库越大，维护起来就越困难。选择数据库作为存储设施的主要优势——访问速度也会下降，而且无法为LOB类型创建索引以改善搜索。此外，除了一些CLOB情况，您不能在`WHERE`子句中使用LOB列，也不能在`INSERT`或`UPDATE`语句的多行中使用LOB列。
- en: So, before thinking about a database for a LOB, you should always consider whether
    storing the name of a file, keywords, and some other content properties in the
    database would be enough for the solution.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在考虑LOB的数据库之前，您应该始终考虑在数据库中存储文件名、关键字和其他一些内容属性是否足够解决方案。
- en: Executing stored procedures
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行存储过程
- en: In this recipe, you will learn how to execute a database-stored procedure from
    a Java program.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何从Java程序中执行数据库存储过程。
- en: Getting ready
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备。
- en: Once in a while, a Java programmer encounters the need to manipulate and/or
    select data in/from several tables, and so the programmer comes up with a set
    of complex SQL statements that are impractical to implement in Java or it is strongly
    suspected that the Java implementation might not yield an adequate performance.
    This is when the set of SQL statements can be wrapped into a stored procedure
    that is compiled and stored in the database and then invoked via the JDBC interface.
    Or, in another twist of fate, a Java programmer might encounter the need for incorporating
    a call to an existing stored procedure into the program. To accomplish this, the
    interface `CallableStatement` (which extends the `PreparedStatement` interface)
    can be used, although some databases allow you to call a stored procedure using
    either an interface `Statement` or a `PreparedStatement`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 偶尔，Java程序员会遇到需要操作和/或从多个表中选择数据的需求，因此程序员会提出一组复杂的SQL语句，这些语句在Java中实现起来不切实际，或者强烈怀疑Java实现可能无法获得足够的性能。这时，SQL语句可以被封装成一个存储过程，编译并存储在数据库中，然后通过JDBC接口调用。或者，另一种情况是，Java程序员可能需要将对现有存储过程的调用合并到程序中。为了实现这一点，可以使用`CallableStatement`接口（它扩展了`PreparedStatement`接口），尽管一些数据库允许您使用`Statement`或`PreparedStatement`接口调用存储过程。
- en: '`CallableStatement` can have parameters of three types—`IN` for an input value,
    `OUT` for the result, and `IN OUT` for either an input or an output value. `OUT`
    parameters must be registered by the `registerOutParameter()` method of `CallableStatement`.
    The `IN` parameters can be set the same way as the parameters of `PreparedStatement`.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`CallableStatement`可以有三种类型的参数——`IN`表示输入值，`OUT`表示结果，`IN OUT`表示输入或输出值。`OUT`参数必须由`CallableStatement`的`registerOutParameter()`方法注册。`IN`参数可以像`PreparedStatement`的参数一样设置。'
- en: Bear in mind that executing a stored procedure from Java programmatically is
    one of the least standardized areas. PostgreSQL, for example, does not support
    stored procedures directly, but they can be invoked as functions, which have been
    modified for this purpose by interpreting `OUT` parameters as return values. Oracle,
    on the other hand, allows `OUT` parameters for functions too.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，从Java程序中以编程方式执行存储过程是最不标准化的领域之一。例如，PostgreSQL不直接支持存储过程，但可以作为函数调用，这些函数已经被修改，将`OUT`参数解释为返回值。另一方面，Oracle也允许函数使用`OUT`参数。
- en: 'This is why the following differences between database functions and stored
    procedures can serve only as a general guideline and not as a formal definition:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么数据库函数和存储过程之间的以下差异只能作为一般指南，而不能作为正式定义：
- en: A function has a return value, but it does not allow `OUT` parameters (except
    for some databases) and can be used in a SQL statement.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数具有返回值，但不允许`OUT`参数（除了一些数据库），并且可以在SQL语句中使用。
- en: A stored procedure does not have a return value (except for some databases);
    it allows `OUT` parameters (for most databases) and can be executed using the
    JDBC interface `CallableStatement`.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储过程没有返回值（除了一些数据库）；它允许`OUT`参数（对于大多数数据库），并且可以使用JDBC接口`CallableStatement`执行。
- en: This is why reading the database documentation to learn how to execute a stored
    procedure is very important.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么阅读数据库文档以了解如何执行存储过程非常重要。
- en: Since stored procedures are compiled and stored on the database server, the
    `execute()` method of `CallableStatement` performs better for the same SQL statement
    than the corresponding method of `Statement` or `PreparedStatement`. This is one
    of the reasons a lot of Java code is sometimes replaced by one or several stored
    procedures that include even the business logic. But there is no right answer
    for every case and problem, so we will refrain from making specific recommendations,
    except to repeat the familiar mantra about the value of testing and the clarity
    of the code you are writing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存储过程是在数据库服务器上编译和存储的，`CallableStatement`的`execute()`方法对于相同的SQL语句执行要比`Statement`或`PreparedStatement`的相应方法性能更好。这是为什么很多Java代码有时会被一个或多个存储过程替代的原因之一，甚至包括业务逻辑。但是对于每种情况和问题，都没有一个正确的答案，因此我们将避免提出具体的建议，除了重复熟悉的测试价值和您正在编写的代码的清晰度的口头禅。
- en: How to do it...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: As in the previous recipe, we will continue using the PostgreSQL database for
    demonstration purposes. Before writing custom SQL statements, functions, and stored
    procedures, you should look at the list of already existing functions first. Usually,
    they provide a wealth of functionality.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的示例一样，我们将继续使用PostgreSQL数据库进行演示。在编写自定义SQL语句、函数和存储过程之前，您应该先查看已经存在的函数列表。通常，它们提供了丰富的功能。
- en: 'Here is an example of calling the `replace(string text, from text, to text)`
    function that searches the first parameter (`string text`) and replaces it with
    all the substrings that match the second parameter (`from text `) with the substring
    provided by the third parameter (`string text`):'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是调用`replace(string text, from text, to text)`函数的示例，该函数搜索第一个参数（`string text`）并用第二个参数（`from
    text`）匹配的所有子字符串替换为第三个参数（`string text`）提供的子字符串：
- en: '[PRE67]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result is as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/5629dab5-57b2-4b6e-9c01-d1fee37bd23f.png)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5629dab5-57b2-4b6e-9c01-d1fee37bd23f.png)'
- en: We will incorporate this function into our custom functions and stored procedures
    to show you how this can be done.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个函数合并到我们的自定义函数和存储过程中，以展示如何完成这个操作。
- en: 'A stored procedure can be without any parameters at all, with `IN` parameters
    only, with `OUT` parameters only, or with both. The result may be one or multiple
    values, or a `ResultSet` object. Here is an example of creating a stored procedure
    without any parameters in PostgreSQL:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 存储过程可以没有任何参数，只有`IN`参数，只有`OUT`参数，或者两者都有。结果可以是一个或多个值，或者是一个`ResultSet`对象。以下是在PostgreSQL中创建一个没有任何参数的存储过程的示例：
- en: '[PRE68]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In the preceding code, we use the method `execute()`, which we are already
    familiar with:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用了我们已经熟悉的`execute()`方法：
- en: '[PRE69]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This stored procedure (it is always a function in PostgreSQL) creates the `texts` table
    (after dropping it if the table existed already). You can find the syntax of the
    SQL for function creation in the database documentation. The only thing we would
    like to comment on here is that instead of the symbol `$$` that denotes the function
    body, you can use single quotes. We prefer `$$`, though, because it helps avoid
    the escaping of single quotes if we need to include them in the body of the function.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个存储过程（在PostgreSQL中总是一个函数）创建了`texts`表（如果表已经存在，则先删除）。您可以在数据库文档中找到有关函数创建的SQL语法。我们想在这里评论的唯一一件事是，可以使用单引号代替表示函数主体的符号`$$`。不过，我们更喜欢`$$`，因为它有助于避免在函数主体中需要包含单引号时进行转义。
- en: 'After being created and stored in the database, the procedure can be invoked
    by `CallableStatement`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在被创建并存储在数据库中之后，该存储过程可以通过`CallableStatement`来调用：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Alternatively, it can be invoked with the SQL statement `select createTableTexts()` or `select
    * from createTableTexts()`. Both statements return a `ResultSet` object (which
    is `null` in the case of the `createTableTexts()` function), so we can traverse
    it by our method:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用SQL语句`select createTableTexts()`或`select * from createTableTexts()`来调用它。这两个语句都会返回一个`ResultSet`对象（在`createTableTexts()`函数的情况下是`null`），因此我们可以通过我们的方法来遍历它：
- en: '[PRE71]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We have already used this method in the previous recipes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在之前的示例中使用过这个方法。
- en: 'The function can be deleted by using the following statement:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下语句删除该函数：
- en: '[PRE72]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, let''s put all of this together in Java code, create a function, and invoke
    it in three different styles:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把所有这些放在一起，用Java代码创建一个函数，并以三种不同的方式调用它：
- en: '[PRE73]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The result is as follows:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/16547c6c-f4c8-410c-ac89-85d2b6907f29.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![](img/16547c6c-f4c8-410c-ac89-85d2b6907f29.png)'
- en: As was expected, the returned `ResultSet` object is `null`. Note that the name
    of the function is case-insensitive. We keep it in camel case style for human
    readability only.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，返回的`ResultSet`对象是`null`。请注意，函数的名称是不区分大小写的。我们将其保留为驼峰式风格，仅供人类阅读。
- en: 'Now, let''s create and call another stored procedure (function) with two input
    parameters:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建并调用另一个带有两个输入参数的存储过程（函数）：
- en: '[PRE74]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In the body of the function, the input parameters are referred to by their
    position as `$1` and `$2`. As was mentioned before, we also used the built-in
    `replace()` function to manipulate the values of the second input parameter before
    inserting it into the table. The newly created stored procedure is called twice:
    first via `CallableStatment` and then via the `execute()` method, with different
    input values. Then, we looked inside the table using `traverseRS("select * from
    texts")` and dropped the newly created function to perform a cleanup. We dropped
    the function just for this demo. In real-life code, the function, once created,
    stays and takes advantage of being there, compiled and ready to run.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的主体中，输入参数通过它们的位置`$1`和`$2`来引用。正如之前提到的，我们还使用了内置的`replace()`函数来操作第二个输入参数的值，然后将其插入到表中。新创建的存储过程被调用了两次：首先通过`CallableStatment`，然后通过`execute()`方法，使用不同的输入值。然后，我们使用`traverseRS("select
    * from texts")`来查看表中的内容，并删除了新创建的函数以进行清理。我们只是为了演示目的删除了该函数。在实际代码中，一旦创建，函数就会留在那里，并利用它的存在，编译并准备运行。
- en: 'If we run the preceding code, we''ll get the following result:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，将得到以下结果：
- en: '![](img/3b9eb46d-9339-48fd-aba3-d616bb91f34c.png)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b9eb46d-9339-48fd-aba3-d616bb91f34c.png)'
- en: 'Now let''s add two rows to the `texts` table and then look into it and create
    a stored procedure (function) that counts the number of rows in the table and
    returns the result:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向`texts`表添加两行，然后查看它并创建一个计算表中行数并返回结果的存储过程（函数）：
- en: '[PRE75]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Note the `bigint` value of the returned value and the matching type for the `OUT` parameter `Types.BIGINT`. The
    newly created stored procedure is executed three times and then deleted. The result
    is as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回值的`bigint`值和`OUT`参数`Types.BIGINT`的匹配类型。新创建的存储过程被执行三次，然后被删除。结果如下所示：
- en: '![](img/dc60f770-b493-45d3-9fa5-d984d1fbf62e.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc60f770-b493-45d3-9fa5-d984d1fbf62e.png)'
- en: 'Now, let''s look at an example of a stored procedure with one input parameter
    of the type `int` that returns the `ResultSet` object:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个具有`int`类型的输入参数并返回`ResultSet`对象的存储过程示例：
- en: '[PRE76]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note the return type defined as `setof texts`, where `texts` is the name of
    the table. If we run the preceding code, the result will be as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意返回类型定义为`setof texts`，其中`texts`是表的名称。如果我们运行上述代码，结果将如下所示：
- en: '![](img/da57a6ac-c2d8-4e27-8e76-638b967f48f2.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/da57a6ac-c2d8-4e27-8e76-638b967f48f2.png)'
- en: It's worth analyzing the difference in the `ResultSet` content of two different
    calls to the stored procedure. Without `select *`, it contains the name of the
    procedure and the returned object (of the `ResultSet` type). But with `select
    *`, it returns the actual `ResultSet` content from the last SQL statement in the
    procedure.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析的是两次对存储过程的不同调用在`ResultSet`内容上的差异。没有`select *`时，它包含存储过程的名称和返回对象（`ResultSet`类型）。但是有`select
    *`时，它返回存储过程中最后一个SQL语句的实际`ResultSet`内容。
- en: 'Naturally, the question arises why we could not call this stored procedure
    via `CallableStatement`, as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然地，问题就是为什么我们不能通过`CallableStatement`调用这个存储过程，如下所示：
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'We tried, but it did not work. Here is what the PostgreSQL documentation has
    to say about it:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试了，但没有成功。以下是PostgreSQL文档对此的描述：
- en: '"Functions that return data as a set should not be called via the CallableStatement
    interface, but instead should use the normal Statement or PreparedStatement interfaces."'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '"返回数据集的函数不应该通过CallableStatement接口调用，而应该使用普通的Statement或PreparedStatement接口。"'
- en: 'There is a way around this limitation, though. The same database documentation
    describes how to retrieve a `refcursor` (a PostgreSQL-specific feature) value
    that can then be cast to `ResultSet`:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有一种方法可以绕过这个限制。同样的数据库文档描述了如何检索`refcursor`（PostgreSQL特有的功能）值，然后可以将其转换为`ResultSet`：
- en: '[PRE78]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A few comments about the preceding code would probably help you understand
    how this was done:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码的一些评论可能会帮助您理解这是如何完成的：
- en: Autocommit has to be turned off.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须关闭自动提交。
- en: Inside the function, `$1` refers to the first `IN` parameter (not counting the
    `OUT` parameter).
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内部，`$1`指的是第一个`IN`参数（不包括`OUT`参数）。
- en: The language is set to `plpgsql` to access the `refcursor` functionality (PL/pgSQL
    is a loadable procedural language of the PostgreSQL database).
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言设置为`plpgsql`以访问`refcursor`功能（PL/pgSQL是PostgreSQL数据库的可加载过程语言）。
- en: 'To traverse `ResultSet`, we wrote a new method, as follows:'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了遍历`ResultSet`，我们编写了一个新的方法，如下所示：
- en: '[PRE79]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'So, our old friend the `traverseRS(String sql)` method can now be refactored
    into the following form:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的老朋友`traverseRS(String sql)`方法现在可以重构为以下形式：
- en: '[PRE80]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we run the last example, the result will be as follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行最后一个示例，结果将如下所示：
- en: '![](img/bc185a01-c374-498a-ab21-ade478c6451b.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bc185a01-c374-498a-ab21-ade478c6451b.png)'
- en: You can see that the result-traversing methods that do not extract an object
    and cast it to `ResultSet` don't show the correct data in this case.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，不提取对象并将其转换为`ResultSet`的结果遍历方法在这种情况下不显示正确的数据。
- en: There's more...
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We covered the most popular cases of calling stored procedures from Java code.
    The scope of this book does not allow us to present more complex and potentially
    useful forms of stored procedures in PostgreSQL and other databases. However,
    we would like to mention them here, so that you have an idea of other possibilities:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了从Java代码调用存储过程的最常见情况。本书的范围不允许我们介绍PostgreSQL和其他数据库中更复杂和潜在有用的存储过程形式。但是，我们想在这里提到它们，这样你就可以了解其他可能性：
- en: Functions on composite types
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合类型的函数
- en: Functions with parameter names
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有参数名称的函数
- en: Functions with variable numbers of arguments
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有可变数量参数的函数
- en: Functions with default values for arguments
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有参数默认值的函数
- en: Functions as table sources
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为表源
- en: Functions returning tables
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回表的函数
- en: Polymorphic SQL functions
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态的SQL函数
- en: Functions with collations
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有排序规则的函数
- en: Using batch operations for a large set of data
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用批处理操作处理大量数据
- en: In this recipe, you will learn how to create and execute many **batches** of
    SQL statements with a single call to a database.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何创建和执行许多SQL语句的**批处理**。
- en: Getting ready
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Batch processing is required when many SQL statements have to be executed at
    the same time to insert, update, or read database records. Executing several SQL
    statements can be done by iterating over them and sending each to the database
    one by one, but it incurs a network overhead that can be avoided by sending all
    the queries to the database at the same time.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要执行许多SQL语句以同时插入、更新或读取数据库记录时，需要批处理。可以通过迭代执行多个SQL语句并逐个发送到数据库来执行多个SQL语句，但这会产生网络开销，可以通过同时将所有查询发送到数据库来避免。
- en: To avoid this network overhead, all the SQL statements can be combined into one
    `String` value, and each statement is separated by a semicolon, so they all can
    be sent to the database in one call. The returned result, if present, is also
    sent back as a collection of result sets generated by each statement. Such a processing
    is usually called bulk processing to distinguish it from a batch processing that's
    available only for `INSERT` and `UPDATE` statements. Batch processing allows you
    to combine many SQL statements using `addBatch()` method of the interface `java.sql.Statement`
    or `java.sql.PreparedStatement`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种网络开销，所有的SQL语句可以合并成一个`String`值，每个语句之间用分号分隔，这样它们可以一次性发送到数据库。返回的结果（如果有的话）也会作为每个语句生成的结果集的集合发送回来。这种处理通常被称为批量处理，以区别于仅适用于`INSERT`和`UPDATE`语句的批处理。批处理允许您使用`java.sql.Statement`或`java.sql.PreparedStatement`接口的`addBatch()`方法来组合许多SQL语句。
- en: 'We will use the PostgreSQL database and the following table, `person`, to insert,
    update, and read data from it:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用PostgreSQL数据库和以下表`person`来插入、更新和从中读取数据：
- en: '[PRE81]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As you can see, each record of the table can contain two attributes of a person—name
    and age.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，表的每个记录都可以包含一个人的两个属性——姓名和年龄。
- en: How to do it...
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We are going to demonstrate both **bulk processing** and **batch processing**.
    In order to accomplish it, let''s follow these steps:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示**批量处理**和**批处理**。为了实现这一点，让我们按照以下步骤进行：
- en: 'An example of bulk processing is a single `INSERT` statement with multiple
    `VALUES` clauses:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批量处理的一个示例是使用单个`INSERT`语句和多个`VALUES`子句：
- en: '[PRE82]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The code that constructs such a statement looks as follows:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 构造这样一个语句的代码如下：
- en: '[PRE83]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As you can see, the preceding code constructs a statement with 100,000 `VALUES`
    clauses, which means it inserts 100,000 records in one trip to a database. In
    our experiment, it took 1,082 milliseconds to complete this job. As the result,
    the table `person` now contains 100,000 records of persons with names from `Name0` to
    `Name99999` and age as a random number from 1 to 99 inclusive.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的代码构造了一个带有100,000个`VALUES`子句的语句，这意味着它一次性向数据库插入了100,000条记录。在我们的实验中，完成这项工作花费了1,082毫秒。结果，表`person`现在包含了100,000条记录，姓名从`Name0`到`Name99999`，年龄是从1到99的随机数。
- en: There are two disadvantages of this method of bulk processing—it is susceptible
    to the SQL injection attack and can consume too much memory. SQL injection can
    be addressed by using `PreparedStatement`, but it is limited by the number of
    bind variables. In the case of PostgreSQL, it cannot be more than `32767`. This
    means that we would need to break the single `PreparedStatement` into several
    smaller ones, each having no more than `32767` bind variables. Incidentally, it
    will also address the memory consumption problem, since each statement is now
    much smaller than the large one. The previous single statement, for example, includes
    200,000 values.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这种批量处理方法有两个缺点——它容易受到SQL注入攻击，并且可能消耗太多内存。使用`PreparedStatement`可以解决SQL注入问题，但受到绑定变量数量的限制。在PostgreSQL的情况下，它不能超过`32767`。这意味着我们需要将单个`PreparedStatement`分解为几个更小的`PreparedStatement`，每个`PreparedStatement`中的绑定变量不超过`32767`。顺便说一句，这也可以解决内存消耗问题，因为每个语句现在比大语句小得多。例如，之前的单个语句包括200,000个值。
- en: 'The following code addresses both problems by breaking the single SQL statement
    into smaller `PreparedStatement` objects, each with no more than `32766` bind
    variables:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码通过将单个SQL语句分解为多个不超过`32766`个绑定变量的`PreparedStatement`对象来解决这两个问题：
- en: '[PRE84]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The previous code executes as quickly as our previous example. It took 1,175
    milliseconds to complete this job. But we ran this code on the same computer where
    the database is installed, so there is no the network overhead from the seven
    trips to the database (that was how many queries were added to the `List queries`).
    But, as you can see, the code is quite complex. It can be substantially simplified
    by using batch processing.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行速度与我们之前的示例一样快。完成这项工作花费了1,175毫秒。但是我们在安装了数据库的同一台计算机上运行了这段代码，所以没有来自数据库的七次网络开销（这是添加到`List
    queries`的查询次数）。但是，正如您所看到的，代码相当复杂。通过使用批处理，可以大大简化它。
- en: 'Batch processing is based on the usage of the methods `addBatch()` and `executeBatch()`,
    which are available in both—`Statement` and `PreparedStatement`—interfaces. For
    our demonstration, we will use `PreparedStatement` for two reasons—it is not susceptible
    to SQL injection and performs better when executed many times (that is the main
    purpose of `PreparedStatement`—to take advantage of multiple executions of the
    same statement with different values):'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 批处理基于`addBatch()`和`executeBatch()`方法的使用，这两种方法在`Statement`和`PreparedStatement`接口中都可用。为了演示，我们将使用`PreparedStatement`，原因有两个——它不容易受到SQL注入攻击，并且在多次执行时性能更好（这是`PreparedStatement`的主要目的——利用对具有不同值的相同语句的多次执行）。
- en: '[PRE85]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: It took 2,299 milliseconds to insert 100,000 records in the `person` table,
    which is almost twice as long if compared with using a single statement with multiple
    `VALUES` clauses (the first example) or using multiple `PreparedStatement` objects
    (the second example). Although its execution takes longer, this code has the obvious
    advantage of being much simpler. And it sends the batch of statements to the database
    in one trip, which means that the gap in performance between this implementation
    and the previous one (with seven trips to the database) will be smaller when the
    database is not collocated with the application.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 向`person`表中插入100,000条记录花费了2,299毫秒，几乎是使用单个带有多个`VALUES`子句的语句（第一个示例）或使用多个`PreparedStatement`对象（第二个示例）的两倍长。尽管它的执行时间更长，但这段代码明显更简单。它将一批语句一次性发送到数据库，这意味着当数据库与应用程序不在同一台计算机上时，这种实现与之前的实现（需要七次访问数据库）之间的性能差距将更小。
- en: But this implementation can be improved too.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种实现也可以得到改进。
- en: 'To improve the batch processing, let''s add the `reWriteBatchedInserts` property
    to the `DataSource` object and set it to `true`:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了改进批处理，让我们向`DataSource`对象添加`reWriteBatchedInserts`属性，并将其设置为`true`：
- en: '[PRE86]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now, if we run the same batch processing code using the connection `createDataSource().getConnection()`,
    the time it takes to insert same 100,000 records drops to 750 milliseconds, which
    is 25% better than any of the implementations we have tested so far. And the code
    remains much simpler than any of the previous implementations.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们使用连接`createDataSource().getConnection()`运行相同的批处理代码，插入相同的10万条记录所需的时间减少到750毫秒，比我们迄今为止测试过的任何实现都要好25%。而且代码仍然比以前的任何实现都简单得多。
- en: But what about memory consumption?
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 但是内存消耗呢？
- en: 'As the size of the batch grows, at some point, JVM may run out of memory. In
    such a case, batch processing can be broken into several batches, each delivered
    to the database in a separate trip:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随着批处理的增长，JVM可能会在某个时候耗尽内存。在这种情况下，批处理可以分成几个批次，每个批次在单独的行程中传递到数据库：
- en: '[PRE87]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: We use variable the `execute` as the flag that indicates that we need to call
    `executeBatch()` one more time when the last statement is added to the batch if
    this last batch is smaller than the `batchSize` value. As you can see from the
    comment to the previous code, `executeBatch()` was called four times, including
    when the last statement was added (when `i=99999`). The performance of this code
    in our runs was the same as without generating multiple batches, because our database
    is located on the same computer as the application. Otherwise, the delivery of
    each batch over the network would add to the time that it took to execute this
    code.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用变量`execute`作为标志，指示当最后一个批次小于`batchSize`值时，我们需要在最后一个语句添加到批次时再次调用`executeBatch()`。从前面代码的注释中可以看出，`executeBatch()`被调用了四次，包括在添加最后一个语句时（当`i=99999`）。在我们的运行中，这段代码的性能与生成多个批次的性能相同，因为我们的数据库位于与应用程序相同的计算机上。否则，每个批次通过网络传递都会增加执行此代码所需的时间。
- en: How it works...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The last example (step 5) of the previous sub-section is an ultimate implementation
    of a batch process that can be used for inserting and updating records in a database.
    The method `executeBatch()` returns an array of `int`, which, in the case of success,
    indicates how many rows were updated by each of the statements in the batch. In
    the case of an `INSERT` statement, this value equals -2 (negative two), which
    is the value of the static constant `Statement.SUCCESS_NO_INFO`. The value of
    -3 (negative three), which is the value of the constant `Statement.EXECUTE_FAILED`,
    indicates a statement failure.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个子部分的最后一个示例（步骤5）是用于在数据库中插入和更新记录的批处理过程的终极实现。方法`executeBatch()`返回一个`int`数组，成功的情况下，表示批处理中每个语句更新了多少行。对于`INSERT`语句，此值等于-2（负二），这是静态常量`Statement.SUCCESS_NO_INFO`的值。值为-3（负三），即常量`Statement.EXECUTE_FAILED`的值，表示语句失败。
- en: If the returned updated row count is expected to be bigger than `Integer.MAX_VALUE`,
    use the method `long[] executeLargeBatch()` to execute the batch.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果预期返回的更新行数大于`Integer.MAX_VALUE`，则使用方法`long[] executeLargeBatch()`来执行批处理。
- en: 'There is no batch processing for reading data from the database. To read data
    in bulk, you can send many statements separated by a semicolon as one string to
    the database and then iterate over the returned multiple result sets. For example,
    let''s submit `SELECT` statements that count the number of records for each of
    the age values from 1 to 99 inclusive:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 没有用于从数据库中读取数据的批处理。要批量读取数据，可以将许多语句作为一个字符串以分号分隔发送到数据库，然后迭代返回的多个结果集。例如，让我们提交`SELECT`语句，计算年龄值从1到99的每个记录的数量：
- en: '[PRE88]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In our test run, it took 2,162 milliseconds to execute the preceding code and
    display the following message:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试运行中，执行上述代码并显示以下消息花费了2,162毫秒：
- en: '[PRE89]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There's more...
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Moving large sets of data to and from PostgreSQL database can also be done using
    the `COPY` command, which copies data to and from a file. You can read more about
    it in the database documentation ([https://www.postgresql.org/docs/current/static/sql-copy.html](https://www.postgresql.org/docs/current/static/sql-copy.html)).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 将大量数据从PostgreSQL数据库移动到数据库和从数据库移动也可以使用`COPY`命令来完成，该命令将数据复制到文件中。您可以在数据库文档中了解更多信息（[https://www.postgresql.org/docs/current/static/sql-copy.html](https://www.postgresql.org/docs/current/static/sql-copy.html)）。
- en: Using MyBatis for CRUD operations
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MyBatis进行CRUD操作
- en: In the previous recipes, while using JDBC, we had the write code, which extracts
    the results of the query from a `ResultSet` object returned by the query. The
    disadvantage of this approach is that you have to write quite a bit of boilerplate
    code to create and populate domain objects that represent records in the database.
    As we have mentioned already in the introduction to this chapter, there are several
    ORM frameworks that can do this for you and create the corresponding domain objects
    automatically (or, in other words, to map database records to the corresponding
    domain objects). Naturally, every such framework takes away some of the control
    and flexibility in constructing SQL statements. So, before committing to a particular
    ORM framework, you need to research and experiment with different frameworks to
    find the one that provides everything the application needs with respect to the
    database and does not create too much of an overhead.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的示例中，使用JDBC时，我们需要编写代码，从查询返回的`ResultSet`对象中提取查询的结果。这种方法的缺点是，您必须编写相当多的样板代码来创建和填充表示数据库中记录的域对象。正如我们在本章的介绍中已经提到的那样，有几个ORM框架可以为您执行此操作，并自动创建相应的域对象（或者换句话说，将数据库记录映射到相应的域对象）。当然，每个这样的框架都会减少一些构建SQL语句的控制和灵活性。因此，在承诺使用特定的ORM框架之前，您需要研究和尝试不同的框架，以找到提供应用程序所需的数据库方面的一切，并且不会产生太多开销的框架。
- en: In this recipe, you will learn about the SQL Mapper tool MyBatis, which simplifies
    database programming compared to using JDBC directly.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习到SQL映射工具MyBatis，与直接使用JDBC相比，它简化了数据库编程。
- en: Getting ready
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'MyBatis is a lightweight ORM framework that allows not only mapping the results
    to Java objects but also executing an arbitrary SQL statement. There are principally
    two ways to describe the mapping:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis是一个轻量级的ORM框架，不仅允许将结果映射到Java对象，还允许执行任意的SQL语句。主要有两种描述映射的方式：
- en: Using Java annotations
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java注解
- en: Using XML configuration
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML配置
- en: 'In this recipe, we are going to use XML configuration. But, whichever style
    you prefer, you need to create an object of the type `org.apache.ibatis.session.SqlSessionFactory`
    and then use it to start a MyBatis session by creating an object of the type `org.apache.ibatis.session.SqlSession`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用XML配置。但是，无论您喜欢哪种风格，您都需要创建一个`org.apache.ibatis.session.SqlSessionFactory`类型的对象，然后使用它来通过创建一个`org.apache.ibatis.session.SqlSession`类型的对象来启动MyBatis会话：
- en: '[PRE90]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The `SqlSessionFactoryBuilder` object has nine overloaded `build()` methods
    that create the `SqlSession` object. These methods allow for configuring the SQL
    execution environment. Using them, you can define the following:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlSessionFactoryBuilder`对象有九个重载的`build()`方法，用于创建`SqlSession`对象。使用这些方法，您可以定义以下内容：'
- en: Whether you prefer to auto-commit database changes or to do them explicitly
    (we use the latter in our examples)
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您喜欢自动提交数据库更改还是显式执行它们（我们在示例中使用后者）
- en: Whether you will use the configured datasource (as in our examples) or use the
    externally provided database connection
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您是使用配置的数据源（就像我们的例子中）还是使用外部提供的数据库连接
- en: Whether you will use the default database-specific transaction isolation level
    (as in our example) or would like to set your own
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您是使用默认的数据库特定事务隔离级别（就像我们的例子中）还是想要设置自己的
- en: Which of the following `ExecutorType` values you will use—`SIMPLE` (default,
    creates a new `PreparedStatement` for each execution of a statement), `REUSE`
    (reuses `PreparedStatements`), or `BATCH` (batches all update statements and demarcate
    them as necessary if `SELECT`s are executed between them)
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将使用以下哪种`ExecutorType`值——`SIMPLE`（默认值，为每次执行语句创建一个新的`PreparedStatement`）、`REUSE`（重用`PreparedStatements`）或`BATCH`（批处理所有更新语句，并在它们之间执行`SELECT`时必要时标记它们）
- en: Which environment (`development`, `test`, or `production`, for example) this
    code is deployed to, so the corresponding section of the configuration will be
    used (we will discuss it shortly)
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码部署在哪个环境（例如`development`、`test`或`production`），因此将使用相应的配置部分（我们将很快讨论它）
- en: The `Properties` object that contains the configuration of the datasource
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含数据源配置的`Properties`对象
- en: The `SqlSession` object provides methods that allow you to execute `SELECT`,
    `INSERT`, `UPDATE`, and `DELETE` statements that are defined in the SQL mapping
    XML files. It also allows you to commit or rollback the current transaction.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlSession`对象提供了允许您执行在SQL映射XML文件中定义的`SELECT`、`INSERT`、`UPDATE`和`DELETE`语句的方法。它还允许您提交或回滚当前事务。'
- en: 'The Maven dependency we used for this recipe is as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用于这个教程的Maven依赖如下：
- en: '[PRE91]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: At the time of writing this book, the latest MyBatis documentation can be found
    here: [http://www.mybatis.org/mybatis-3/index.html ](http://www.mybatis.org/mybatis-3/index.html)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，最新的MyBatis文档可以在这里找到：[http://www.mybatis.org/mybatis-3/index.html ](http://www.mybatis.org/mybatis-3/index.html)
- en: How to do it...
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We will start with CRUD operations by using the PostgreSQL database and the
    class `Person1`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从使用PostgreSQL数据库和`Person1`类开始进行CRUD操作：
- en: '[PRE92]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We need the previous `getId()` method to get an ID value (to demonstrate how
    to find a database record by ID). The method `setName()` will be used to update
    the database record, and the method `toString()` will be used to display the results.
    We use the name `Person1` to distinguish it from another version of the same class, `Person2`,
    which we will use to demonstrate how to implement the relationship between classes
    and the corresponding tables.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要之前的`getId()`方法来获取一个ID值（演示如何通过ID查找数据库记录）。`setName()`方法将用于更新数据库记录，`toString()`方法将用于显示结果。我们使用名称`Person1`来区分它与同一类的另一个版本`Person2`，我们将使用它来演示如何实现类和相应表之间的关系。
- en: 'The matching database table can be created using the following SQL statement:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下SQL语句创建匹配的数据库表：
- en: '[PRE93]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Then execute the following steps:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 然后执行以下步骤：
- en: 'Start by creating an XML configuration file. We will call it `mb-config1.xml`
    and place it in the folder `mybatis` under `resources`. This way, Maven will put
    it on a classpath. Another option would be to place the file in any other folder
    along with the Java code and modify `pom.xml` to tell Maven to put the `.xml`
    files from that folder on the classpath too. The content of the `mb-config1.xml` file
    looks as follows:'
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个XML配置文件。我们将其命名为`mb-config1.xml`，并将其放在`resources`文件夹下的`mybatis`文件夹中。这样，Maven会将其放在类路径上。另一个选项是将文件放在任何其他文件夹中，并与Java代码一起修改`pom.xml`，告诉Maven也将该文件夹中的`.xml`文件放在类路径上。`mb-config1.xml`文件的内容如下：
- en: '[PRE94]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `<settings>` tag allows for defining some behavior globally—lazy loading
    of the values, enable/disable the cache, set auto-mapping behavior (to populate
    nested data or not), and more. We have chosen to set the usage of auto-generated
    keys globally because we need the inserted objects to be populated with IDs generated
    in the database.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`<settings>`标签允许全局定义一些行为——延迟加载值、启用/禁用缓存、设置自动映射行为（是否填充嵌套数据）等。我们选择全局设置自动生成的键的用法，因为我们需要插入的对象被填充为在数据库中生成的ID。'
- en: The `<typeAiases>` tag contains aliases of the fully qualified class names,
    which work similar to the `IMPORT` statement. The only difference is that an alias
    can be any word, not just a class name. After the alias is declared, everywhere
    else in the MyBatis `.xml` files, the class can be referred by this alias only.
    We will see how to do this while reviewing the content of the file `Person1Mapper.xml`
    shortly.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`<typeAiases>` 标签包含完全限定类名的别名，其工作方式类似于 `IMPORT` 语句。唯一的区别是别名可以是任何单词，而不仅仅是类名。在声明别名之后，在
    MyBatis 的 `.xml` 文件中的任何其他地方，只能通过此别名引用该类。我们将在不久的将来查看文件 `Person1Mapper.xml` 的内容时看到如何做到这一点。'
- en: The `<environments>` tag contains configuration for different environments.
    For example, we could have a configuration for the environment `env42` (any string
    would do). Then, while creating a `SqlSession` object, you can pass this name
    as the parameter of the method `SqlSessionFactory.build()` and the configuration
    included in the tags `<environment id="env42"></environment>` will be used. It
    defines the transaction manager to be used and the datasource.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`<environments>` 标签包含不同环境的配置。例如，我们可以为环境 `env42`（任何字符串都可以）创建一个配置。然后，在创建 `SqlSession`
    对象时，可以将此名称作为方法 `SqlSessionFactory.build()` 的参数传递，将使用标签 `<environment id="env42"></environment>`
    中包含的配置。它定义要使用的事务管理器和数据源。'
- en: 'The `TransactionManager` may be one of two types—JDBC, which uses the connection
    provided by the datasource to commit, rollback, and manage the scope of the transaction,
    and `MANAGED`, which does nothing and allows the container to manage the lifecycle
    of the transaction—well, it closes the connection by default, but that behavior
    can be changed by setting the following property:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionManager` 可以是两种类型之一——JDBC，它使用数据源提供的连接来提交、回滚和管理事务的范围，以及 `MANAGED`，它什么也不做，允许容器管理事务的生命周期——好吧，默认情况下它会关闭连接，但是该行为可以通过设置以下属性进行更改：'
- en: '[PRE95]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The tag `<mappers>` contains references to all the `.xml` files that contain
    SQL statements that map database records and Java objects, which in our case is
    the file `Person1Mapper.xml`.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 `<mappers>` 包含对所有包含映射数据库记录和 Java 对象的 SQL 语句的 `.xml` 文件的引用，这在我们的情况下是文件 `Person1Mapper.xml`。
- en: 'Create the `Person1Mapper.xml` file and put it in the same folder as the `mb-config1.xml` file.
    This file can have any name you like, but it contains all SQL statements that
    map database records and objects of the class `Person1`, so we have named it `Person1Mapper.xml` just
    for the sake of clarity:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Person1Mapper.xml` 文件，并将其放在与 `mb-config1.xml` 文件相同的文件夹中。此文件可以使用任何您喜欢的名称，但它包含映射数据库记录和类
    `Person1` 对象的所有 SQL 语句，因此我们将其命名为 `Person1Mapper.xml` 仅仅是为了清晰起见：
- en: '[PRE96]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can see, the `<mapper>` tag has a `namespace` attribute which is used
    to resolve files with the same name in different locations. It may or may not
    match the mapper file location. The mapper file location is specified in the configuration
    file `mb-config1.xml` as the attribute resource of the tag `<mapper>` (see the
    previous step).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`<mapper>` 标签具有 `namespace` 属性，用于解析不同位置相同名称的文件。它可能匹配或不匹配映射器文件的位置。映射器文件的位置在配置文件
    `mb-config1.xml` 中指定为标签 `<mapper>` 的属性资源（参见上一步）。
- en: The attributes of the tags `<insert>`, `<select>`, `<update>`, and `<delete>`
    are self-explanatory for the most part. The attributes `keyProperty`, `keyColumn`,
    and `useGeneratedKeys` (in the configuration `<settings>`) are added to populate
    the inserted object with the value generated by the database. If you don't need
    it globally, the attribute `useGeneratedKeys` can be removed from the settings
    in the configuration and added only to those insert statements where you would
    like to take advantage of the auto-generation of some value. We did this because
    we wanted to get the generated ID and use it in the code later to demonstrate
    how the record can be retrieved by ID.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 标签 `<insert>`、`<select>`、`<update>` 和 `<delete>` 的属性在很大程度上是不言自明的。标签 `<settings>`
    中的属性 `keyProperty`、`keyColumn` 和 `useGeneratedKeys` 被添加以用数据库生成的值填充插入的对象。如果不需要全局使用，可以从配置中的设置中删除属性
    `useGeneratedKeys`，并且只在希望利用某些值的自动生成的插入语句中添加。我们这样做是因为我们想要获取生成的 ID，并在以后的代码中使用它来演示如何通过
    ID 检索记录。
- en: The ID attribute of `<select>` and similar tags are used to invoke, them along
    with the mapper namespace value. We will show you how this is done shortly. The
    construct `#{id}` refers to the value passed in as a parameter if the value is
    of a primitive type. Otherwise, the passed in object is expected to have such
    a field. Having a getter on the object is not required. If a getter is present,
    it has to comply with the JavaBean method format.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select>` 和类似标签的 ID 属性用于调用它们，以及映射器命名空间值。我们将很快向您展示如何做到这一点。构造 `#{id}` 是指传递的值作为参数，如果该值是原始类型。否则，传递的对象应该具有这样的字段。对象上的
    getter 不是必需的。如果存在 getter，则必须符合 JavaBean 方法格式。'
- en: 'For the return value, by default, the name of a column matches the name of
    the object field or setter (has to be compliant with JavaBean method format).
    If the field (or the setter name) and the column name are different, you can provide
    mapping using the tag `<resultMap>`. For example, if the table `person` has the
    columns `person_id` and `person_name`, while the domain object `Person` has the
    fields `id` and `name`, we can create a map:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回值，默认情况下，列的名称与对象字段或 setter 的名称匹配（必须符合 JavaBean 方法格式）。如果字段（或 setter 名称）和列名不同，可以使用标签
    `<resultMap>` 提供映射。例如，如果表 `person` 具有列 `person_id` 和 `person_name`，而域对象 `Person`
    具有字段 `id` 和 `name`，我们可以创建一个映射：
- en: '[PRE97]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This `resultMap` can then used to populate the domain object `Person` as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用此 `resultMap` 来填充域对象 `Person`，如下所示：
- en: '[PRE98]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Alternatively, it is possible to use the standard select clause aliases:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，也可以使用标准的 select 子句别名：
- en: '[PRE99]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Write code that inserts a record in the table `person1` and then reads this
    record by `id`:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，向表 `person1` 中插入记录，然后通过 `id` 读取此记录：
- en: '[PRE100]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The preceding code will produce an output:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生一个输出：
- en: '[PRE101]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The utility `Resources` has ten overloaded methods for reading the configuration
    file. We have already described how to make sure that Maven places the configuration
    and mapper files on the classpath.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resources`实用程序有十个重载方法用于读取配置文件。我们已经描述了如何确保Maven将配置和mapper文件放在类路径上。'
- en: The `SqlSession` object implements the `AutoCloseable` interface, so we can
    use the try-with-resources block and not worry about leaking resources. The `SqlSession` interface
    provides many execution methods, including the overloaded methods `insert()`,
    `select()`, `selectList()`, `selectMap()`, `selectOne()`, `update()`, and `delete()`,
    to name the most often used and straightforward ones. We also have used `insert()`
    and `selectOne()`. The latter makes sure that only one result is returned. Otherwise,
    it throws an exception. It also throws an exception when the column used to identify
    a single record by a value does not have a unique constraint. That is why we have
    added the `PRIMARY KEY` qualification to the column ID. Alternatively, we could
    just add a unique constraint (marking it as `PRIMARY KEY` does this implicitly).
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '`SqlSession`对象实现了`AutoCloseable`接口，因此我们可以使用try-with-resources块，而不必担心资源泄漏。`SqlSession`接口提供了许多执行方法，包括重载方法`insert()`、`select()`、`selectList()`、`selectMap()`、`selectOne()`、`update()`和`delete()`，这些是最常用和直接的方法。我们还使用了`insert()`和`selectOne()`。后者确保只返回一个结果。否则，它会抛出异常。当用于通过值标识单个记录的列没有唯一约束时，它也会抛出异常。这就是为什么我们在ID列上添加了`PRIMARY
    KEY`限定符。或者，我们可以只添加唯一约束（将其标记为`PRIMARY KEY`会隐式执行此操作）。'
- en: The `selectList()` method, on the other hand, produces a `List` object, even
    when only one result is returned. We will demonstrate this now.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`selectList()`方法生成一个`List`对象，即使只返回一个结果。我们现在来演示一下。
- en: 'Write code that reads all the records from the table `person1`:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写代码，从表`person1`中读取所有记录：
- en: '[PRE102]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The preceding code will produce the following output:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE103]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'To demonstrate an update, let''s change the name of `"John"` to `"Bill"` and
    read it all the records in the `person1` again:'
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示更新，让我们将`"John"`的名字更改为`"Bill"`，然后再次读取`person1`中的所有记录：
- en: '[PRE104]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The preceding code will produce the following output:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE105]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Notice how the change was committed: `session.commit()`. Without this line,
    the result is the same, but the change does not persist because the transaction
    is not autocomitted by default. It can be changed by setting autocommit to `true`
    while opening the session:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 注意更改是如何提交的：`session.commit()`。没有这一行，结果是一样的，但更改不会持久化，因为默认情况下事务不会自动提交。可以通过在打开会话时将autocommit设置为`true`来更改它：
- en: '[PRE106]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Finally, call the `DELETE` statement and remove all the records from the table
    `person1`:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用`DELETE`语句并从表`person1`中删除所有记录：
- en: '[PRE107]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The preceding code will produce the following output:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '[PRE108]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'To demonstrate how MyBatis supports relationships, create the table `family`
    and the table `person2`:'
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示MyBatis如何支持关系，请创建表`family`和表`person2`：
- en: '[PRE109]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: As you can see, the records in the tables `family` and `person2` have one-to-many
    relationships. Each record of the table `person2` may belong to a family (refer
    to a `family` record) or not. Several persons can belong to the same family. We
    have also added the `ON DELETE CASCADE` clause so that the `person2` records can
    be deleted automatically when the family they belong to is deleted.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，表`family`和`person2`中的记录具有一对多的关系。表`person2`中的每条记录可能属于一个家庭（指向一个`family`记录）或不属于。几个人可以属于同一个家庭。我们还添加了`ON
    DELETE CASCADE`子句，以便在删除它们所属的家庭时自动删除`person2`记录。
- en: 'The corresponding Java classes look as follows:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的Java类如下所示：
- en: '[PRE110]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: As you see, the class `Family` has a collection of `Person2` objects. For the
    methods `getId()` and `getMembers()`, we need to establish the relationship with
    the `Person2` class. Will will use the method `getName()` for the demonstration
    code.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，类`Family`有一个`Person2`对象的集合。对于`getId()`和`getMembers()`方法，我们需要与`Person2`类建立关系。我们将使用`getName()`方法来进行演示代码。
- en: 'The class `Person2` looks as follows:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person2`类如下所示：'
- en: '[PRE111]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Create a new configuration file called `mb-config2.xml`:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mb-config2.xml`的新配置文件：
- en: '[PRE112]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: Notice that we now had two aliases and two mapper `.xml` files.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在有两个别名和两个mapper`.xml`文件。
- en: 'The content of the `Person2Mapper.xml` file is much smaller than the content
    of the `Person1Mapper.xml` file that we used before:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Person2Mapper.xml`文件的内容比我们之前使用的`Person1Mapper.xml`文件要小得多：'
- en: '[PRE113]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: That is because we are not going to update or manage these persons directly.
    We are going to do this via the families they belong to. We have added a new query
    that returns the count of the records in the `person2` table.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们不打算直接更新或管理这些人。我们将通过他们所属的家庭来进行操作。我们添加了一个新的查询，返回`person2`表中记录的数量。
- en: 'The content of the `FamilyMapper.xml` file is as follows:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FamilyMapper.xml`文件的内容如下：'
- en: '[PRE114]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The family mapper is much more involved because we manage the relationship
    in it. First, look at the query `selectMembersOfFamily`. If you don''t want to
    populate the field `family` in the object of `Person2`, the SQL would be much
    simpler, as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 家庭mapper更加复杂，因为我们在其中管理关系。首先，看一下查询`selectMembersOfFamily`。如果您不想在`Person2`对象的`family`字段中填充数据，SQL将会简单得多，如下所示：
- en: '[PRE115]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: But we wanted to set the corresponding `Family` object value in the `Person2`
    object, so we used the `ResultMap` `personMap` that describes only the mapping
    that cannot be done by default—we used the `<association>` tag to associate the
    field `family` with the column `family_id` a using the query `selectFamilyById`.
    This last query will not populate the field `members` of the `Family` object,
    but we decided it is not needed for our demonstration.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们希望在`Person2`对象中设置相应的`Family`对象值，因此我们使用了`ResultMap` `personMap`，它仅描述了默认情况下无法完成的映射——我们使用`<association>`标签将`family`字段与`family_id`列关联起来，并使用查询`selectFamilyById`。这个查询不会填充`Family`对象的`members`字段，但我们决定在我们的演示中不需要它。
- en: We reuse the query `selectMembersOfFamily` in the query `selectFamilies`. To
    populate the field `members` of the `Family` object, we created a `ResultMap`
    `familyMap` that uses `selectMembersOfFamily` to do that.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查询`selectMembersOfFamily`中重用了查询`selectFamilies`。为了填充`Family`对象的`members`字段，我们创建了一个`ResultMap`
    `familyMap`，它使用`selectMembersOfFamily`来实现。
- en: How it works...
  id: totrans-528
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s write the code that demonstrates CRUD operations on the `family` table.
    First, here''s how a `family` record can be created and associated with two `person2`
    records:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写代码来演示对`family`表的CRUD操作。首先，这是如何创建一个`family`记录并与两个`person2`记录关联的代码：
- en: '[PRE116]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Now, we can read the created records by using the following code:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用以下代码读取创建的记录：
- en: '[PRE117]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The preceding code snippet produces the following output:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段产生了以下输出：
- en: '[PRE118]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Now, we can delete all `family` records and check if any of the tables for `family`
    and `person2` contain any records after it:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以删除所有`family`记录，并检查在此之后`family`和`person2`表中是否包含任何记录：
- en: '[PRE119]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段的输出如下：
- en: '[PRE120]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: The table `person2` is empty now too because we added the clause `ON DELETE
    CASCADE` while creating the table.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '`person2`表现在也是空的，因为我们在创建表时添加了`ON DELETE CASCADE`子句。'
- en: There's more...
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: MyBatis also provides facilities for building a dynamic SQL, a SqlBuilder class,
    and many other ways to construct and execute SQL of any complexity or a stored
    procedure. For the details, read the documentation at [http://www.mybatis.org/mybatis-3](http://www.mybatis.org/mybatis-3).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: MyBatis还提供了构建动态SQL的工具，一个SqlBuilder类以及许多其他构建和执行任意复杂SQL或存储过程的方法。有关详细信息，请阅读[http://www.mybatis.org/mybatis-3](http://www.mybatis.org/mybatis-3)中的文档。
- en: Using the Java Persistence API and Hibernate
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java持久化API和Hibernate
- en: In this recipe, you will learn how to populate, read, change, and delete data
    in the database using a **Java Persistence API** (**JPA**) implementation called
    the **Hibernate Object-Relational Mapping** (**ORM**) framework.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何使用名为**Hibernate对象关系映射**（**ORM**）框架的**Java持久化API**（**JPA**）实现来填充、读取、更改和删除数据库中的数据。
- en: Getting ready
  id: totrans-544
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'JPA is a specification that defines a possible solution for ORM. You can find
    JPA Version 2.2 at the following link:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: JPA是一种定义ORM的规范解决方案。您可以在以下链接找到JPA版本2.2：
- en: '[PRE121]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The interfaces, enums, annotations, and exceptions described in the specification
    belong to the package `javax.persistence` ([https://javaee.github.io/javaee-spec/javadocs](https://javaee.github.io/javaee-spec/javadocs))
    that is included in **Java Enterprise Edition** (**EE**). The JPA is implemented
    by several frameworks, the most popular of them being:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 规范中描述的接口、枚举、注解和异常属于`javax.persistence`包（[https://javaee.github.io/javaee-spec/javadocs](https://javaee.github.io/javaee-spec/javadocs)），该包包含在**Java企业版**（**EE**）中。
    JPA由几个框架实现，其中最流行的是：
- en: Hibernate ORM ([http://hibernate.org/orm](http://hibernate.org/orm))
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hibernate ORM ([http://hibernate.org/orm](http://hibernate.org/orm))
- en: EclipseLink ([http://www.eclipse.org/eclipselink](http://www.eclipse.org/eclipselink))
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EclipseLink ([http://www.eclipse.org/eclipselink](http://www.eclipse.org/eclipselink))
- en: Oracle TopLink ([http://www.oracle.com/technetwork/middleware/toplink/overview/index.html](http://www.oracle.com/technetwork/middleware/toplink/overview/index.html))
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Oracle TopLink ([http://www.oracle.com/technetwork/middleware/toplink/overview/index.html](http://www.oracle.com/technetwork/middleware/toplink/overview/index.html))
- en: jOOQ ([https://www.jooq.org](https://www.jooq.org))
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jOOQ ([https://www.jooq.org](https://www.jooq.org))
- en: JPA is designed around entities—the Java beans that are mapped to the database
    tables using annotations. Alternatively, the mapping can be defined using XML
    or a combination of both. The mapping defined by XML supersedes the one defined
    by the annotations. The specification also defines an SQL-like query language
    for static and dynamic data queries.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: JPA围绕实体设计——映射到数据库表的Java bean，使用注解进行映射。或者，可以使用XML或两者的组合来定义映射。由XML定义的映射优先于注解定义的映射。规范还定义了一种类似SQL的查询语言，用于静态和动态数据查询。
- en: Most of the JPA implementations allow for the creation of a database schema
    using the mapping defined by annotations and XML.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数JPA实现允许使用注解和XML定义的映射创建数据库模式。
- en: How to do it...
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s start with adding the `javax.persistence` package dependency to the
    Maven configuration file `pom.xml`:'
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将`javax.persistence`包依赖项添加到Maven配置文件`pom.xml`开始：
- en: '[PRE122]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: We don't need any of the JPA implementations yet. This way, we can make sure
    that our code does not use any framework-specific code and uses only JPA interfaces.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还不需要任何JPA实现。这样，我们可以确保我们的代码不使用任何特定于框架的代码，只使用JPA接口。
- en: 'Create the class `Person1`:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Person1`类：
- en: '[PRE123]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: We don't add getters, setters, or any other methods; this is so that we can
    keep our code example short and simple. To convert this class into an entity we
    need, according to the JPA spec, to add the annotation `@Entity` to the class
    declaration (requires importing  `java.persistence.Entity`). This means that we
    would like this class to represent a record in a database table called `person`.
    By default, the name of the entity's class matches the name of the table. But
    it is possible to map the class to a table with another name using the annotation `@Table(name="<another
    table name>")`. Similarly, each class property is mapped to a column with the
    same name, and it is possible to change the default name by using the annotation
    `@Column (name="<another column name>")`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不添加getter、setter或任何其他方法；这样可以使我们的代码示例简短而简单。根据JPA规范，要将此类转换为实体，需要在类声明中添加注解`@Entity`（需要导入`java.persistence.Entity`）。这意味着我们希望这个类代表数据库表中的一条记录，表名为`person`。默认情况下，实体类的名称与表的名称相匹配。但是可以使用注解`@Table(name="<another
    table name>")`将类映射到另一个名称的表。类的每个属性也映射到具有相同名称的列，可以使用注解`@Column (name="<another column
    name>")`更改默认名称。
- en: In addition, an entity class must have a primary key—a field depicted by the
    annotation `@Id`. A composite key that combines several fields can be defined
    using the annotation `@IdClass` too (not used in our examples). If the primary
    key is auto-generated in the database, the `@GeneratedValue` annotation can be
    placed in front of that field.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，实体类必须有一个主键——一个由注解`@Id`表示的字段。也可以使用注解`@IdClass`定义结合多个字段的复合键（在我们的示例中未使用）。如果主键在数据库中是自动生成的，可以在该字段前面放置`@GeneratedValue`注解。
- en: 'And, finally, an entity class must have a constructor without arguments. With
    all these annotations, the entity class `Person` now looks as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，实体类必须有一个无参数的构造函数。有了所有这些注解，实体类`Person`现在看起来如下：
- en: '[PRE124]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Neither the class nor any of its persistent instance variables can be declared
    final. This way, the implementing frameworks can extend the entity classes and
    implement the required functionality.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 类和其持久化实例变量都不能声明为final。这样，实现框架可以扩展实体类并实现所需的功能。
- en: Alternatively, the persistence annotations can be added to the getters and setters,
    instead of the instance fields (if the method names follow Java bean conventions).
    But mixing up fields and methods annotations is not allowed and may lead to unexpected
    consequences.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，持久化注解可以添加到getter和setter中，而不是实例字段（如果方法名遵循Java bean约定）。但是不允许混合字段和方法注解，可能会导致意想不到的后果。
- en: It is also possible to use an XML file instead of an annotation to define the
    mapping between a Java class and a database table and columns, but we are going
    to stay with field level annotations in order to provide the most compact and
    clear method to express the intent.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用XML文件而不是注解来定义Java类与数据库表和列之间的映射，但我们打算使用字段级别的注解，以提供最简洁和清晰的方法来表达意图。
- en: 'Create a database table called `person1` using the following SQL script:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下SQL脚本创建名为`person1`的数据库表：
- en: '[PRE125]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: We have defined the column `id` as `SERIAL`, which means that we ask the database
    to generate the next integer value automatically every time a new row is inserted
    into the table `person1`. It matches the annotations of the property `id` of the
    class `Person1`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将列`id`定义为`SERIAL`，这意味着我们要求数据库在每次向`person1`表插入新行时自动生成下一个整数值。它与类`Person1`的属性`id`的注解相匹配。
- en: 'Now, let''s write some code that inserts a record into the table `person1`
    and then reads all the records from it. To create, update, and delete an entity
    (and the corresponding record in the corresponding table), you need to use an
    entity manager such as `javax.persistence.EntityManager`:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一些代码，将一条记录插入到`person1`表中，然后从中读取所有记录。要创建、更新和删除实体（以及相应表中的记录），需要使用`javax.persistence.EntityManager`等实体管理器：
- en: '[PRE126]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'As you can see, an object of `EntityManagerFactory` is created using some configuration,
    that is, `jpa-demo`. We will talk about it shortly. The factory allows for the
    creation of an `EntityManager` object, which controls the persistence process:
    creates, commits, and rolls back a transaction, stores a new `Person1` object
    (thus inserting a new record in the table `person1`), supports reading data using **Java
    Persistence Query Language** (**JPQL**), and many other database operations and
    transaction management processes.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用一些配置创建了`EntityManagerFactory`对象，即`jpa-demo`。我们很快会谈到它。工厂允许创建一个`EntityManager`对象，它控制持久化过程：创建、提交和回滚事务，存储一个新的`Person1`对象（从而在`person1`表中插入新记录），支持使用**Java持久化查询语言**（**JPQL**）读取数据，以及许多其他数据库操作和事务管理过程。
- en: After the entity manager is closed, the managed entities are in a detached state.
    To synchronize them again with the database, one can use the method `merge()`
    of `EntityManager`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 实体管理器关闭后，托管实体处于分离状态。要再次与数据库同步，可以使用`EntityManager`的`merge()`方法。
- en: 'In the previous example, we have JPQL to query the database. Alternatively,
    we could use the Criteria API defined by the JPA specification, too:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用JPQL来查询数据库。或者，我们也可以使用JPA规范定义的Criteria API：
- en: '[PRE127]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: But it seems that JPQL is less verbose and supports the intuition of those programmers
    who know SQL, so we are going to use JPQL.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 但似乎JPQL更简洁，支持那些了解SQL的程序员的直觉，所以我们打算使用JPQL。
- en: 'Define the persistence configuration in the file `persistence.xml` located
    in the folder `resources/META-INF`. The tag `<persistence-unit>` has an attribute
    name. We have set the attribute value to `jpa-demo`, but you can use any other
    name you like. This configuration specifies JPA implementation (provider), database
    connection properties, and many other persistence-related properties in an XML
    format:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resources/META-INF`文件夹中的`persistence.xml`文件中定义持久化配置。标签`<persistence-unit>`有一个名称属性。我们将属性值设置为`jpa-demo`，但你可以使用任何其他你喜欢的名称。这个配置指定了JPA实现（提供者）、数据库连接属性以及许多其他持久化相关属性，以XML格式表示：
- en: '[PRE128]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Refer to the Oracle documentation ([https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm](https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm))
    about the configuration of the `persistence.xml` file. For this recipe, we used
    the Hibernate ORM and, thus, specified `org.hibernate.jpa.HibernatePersistenceProvider`
    as a provider.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 参考Oracle文档（[https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm](https://docs.oracle.com/cd/E16439_01/doc.1013/e13981/cfgdepds005.htm)）关于`persistence.xml`文件的配置。对于这个示例，我们使用了Hibernate
    ORM，并指定了`org.hibernate.jpa.HibernatePersistenceProvider`作为提供者。
- en: 'Finally, we need to add JPA implementation (Hibernate ORM) as a dependency
    in `pom.xml`:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在`pom.xml`中将JPA实现（Hibernate ORM）作为依赖项添加：
- en: '[PRE129]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: As you may have noticed, we have marked Hibernate dependencies as scoped for `runtime`.
    We did this to avoid using Hibernate-specific features while writing the code.
    We have also added the `jaxb-api` dependency, which is used by Hibernate, but
    this library is not Hibernate-specific, so we did not make it used at runtime
    only.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们已经将Hibernate依赖项标记为`runtime`作用域。我们这样做是为了在编写代码时避免使用Hibernate特定的功能。我们还添加了`jaxb-api`依赖项，这是Hibernate使用的，但这个库不是Hibernate特定的，所以我们没有将它仅在运行时使用。
- en: 'For better result presentation, we will add the following `toString()` method
    to the class `Person1`:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更好地呈现结果，我们将向`Person1`类添加以下`toString()`方法：
- en: '[PRE130]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now, we can run our JPA code example and observe the output:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行我们的JPA代码示例并观察输出：
- en: '[PRE131]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The first two lines of the preceding output come from JPQL usage, and the last
    line comes from the Criteria API usage fragment of our code example.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 前面输出的前两行来自JPQL的使用，最后一行来自我们代码示例的Criteria API的使用片段。
- en: 'JPA also has a provision for establishing relationships between classes. An
    entity class (and the corresponding database table) can have one-to-one, one-to-many,
    many-to-one, and many-to-many relationships with another entity class (and its
    table). The relationship can be bidirectional or unidirectional. This specification
    defines the following rules for a bidirectional relationship:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JPA还提供了建立类之间关系的规定。一个实体类（以及相应的数据库表）可以与另一个实体类（以及它的表）建立一对一、一对多、多对一和多对多的关系。关系可以是双向的或单向的。该规范定义了双向关系的以下规则：
- en: The inverse side must refer to its owning side using the `mappedBy` attribute
    of the annotation `@OneToOne`, `@OneToMany`, or `@ManyToMany`.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反向方必须使用注解`@OneToOne`、`@OneToMany`或`@ManyToMany`的`mappedBy`属性引用它的拥有方。
- en: The many side of one-to-many and many-to-one relationships must own this relationship,
    so the `mappedBy` attribute cannot be specified on the `@ManyToOne` annotation.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一对多和多对一关系的多方必须拥有这个关系，因此`mappedBy`属性不能在`@ManyToOne`注解上指定。
- en: In one-to-one relationships, the owning side is the side that contains the foreign
    key.
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一对一关系中，拥有方是包含外键的一方。
- en: In many-to-many relationships, either side may be the owning side.
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多对多关系中，任何一方都可以是拥有方。
- en: With a unidirectional relationship, only one class has a reference to the other
    class.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在单向关系中，只有一个类引用另一个类。
- en: 'To illustrate these rules, let''s create a class called `Family` that has a
    one-to-many relationship with the class `Person2`:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这些规则，让我们创建一个名为`Family`的类，它与类`Person2`有一对多的关系：
- en: '[PRE132]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The SQL script that creates the table `family` is straightforward:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表`family`的SQL脚本非常简单：
- en: '[PRE133]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'We need also to add the `Family` field to the class `Person2`:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将`Family`字段添加到`Person2`类中：
- en: '[PRE134]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `Person2` class is a "many" side, so, according to this rule, it owns the
    relationship, so the table `person2` has to have a foreign key that points to
    the record of the table `family`:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person2`类是“多”方，因此根据这个规则，它拥有关系，所以表`person2`必须有一个指向表`family`记录的外键：'
- en: '[PRE135]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Reference to a column requires this column value to be unique. That is why
    we have marked the column `id` of the table `person2` as `PRIMARY KEY`. Otherwise,
    an error `ERROR:  42830: there is no unique constraint matching given keys for
    referenced table` would be raised.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '引用列需要这个列的值是唯一的。这就是为什么我们将表`person2`的列`id`标记为`PRIMARY KEY`。否则，会出现错误`ERROR: 42830:
    there is no unique constraint matching given keys for referenced table`。'
- en: 'Now, we can use the classes `Family` and `Person2` to create the records in
    the corresponding tables and read from these tables, too:'
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`Family`和`Person2`类来创建相应表中的记录，并从这些表中读取：
- en: '[PRE136]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: In the previous code, we created an object of the class `Family` and persisted
    it. This way, the object acquires an `id` value from the database. We then passed
    it into the constructor of the class `Person2` and established the relationship
    on the many sides. Then, we persisted the `Person2` object (so that it acquired
    an `id` from the database, too) and added to the collection `members` of the `Family` object,
    so the one side of the relationship is established too. To preserve data, the
    transaction has to be committed. When the transaction is committed, all the entity
    objects associated with an `EntityManager`  (such objects are said to be in a** managed**
    state) are persisted automatically.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`Family`类的对象并将其持久化。这样，对象就从数据库中获得了一个`id`值。然后，我们将它传递给`Person2`类的构造函数，并在多方建立了关系。然后，我们持久化了`Person2`对象（这样它也从数据库中获得了一个`id`），并将其添加到`Family`对象的`members`集合中，这样关系的一方也建立了。为了保留数据，事务必须被提交。当事务被提交时，与`EntityManager`关联的所有实体对象（这些对象被称为处于**管理**状态）会自动持久化。
- en: How it works...
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If we run the preceding code, the result will be as follows:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行上述代码，结果将如下所示：
- en: '[PRE137]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: As you can see, that is exactly what we expected—an object of class `Family The
    Jones` has one member—an object of class `Person2`, and the record in the table
    `person2` refers to the corresponding record of the table `family`.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这正是我们所期望的——一个`Family The Jones`类的对象有一个成员——一个`Person2`类的对象，并且表`person2`中的记录指向表`family`中对应的记录。
