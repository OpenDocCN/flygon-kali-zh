- en: Chapter 1. Linux Networking Constructs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Linux网络构造
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Working with interfaces and addresses
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口和地址
- en: Configuring Linux host routing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Linux主机路由
- en: Exploring bridges
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索桥接
- en: Making connections
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立连接
- en: Exploring network namespaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索网络命名空间
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Linux is a powerful operating system with many robust networking constructs.
    Much like any networking technology, they are powerful individually but become
    much more powerful when combined in creative ways. Docker is a great example of
    a tool that combines many of the individual components of the Linux network stack
    into a complete solution. While Docker manages most of this for you, it's still
    helpful to know your way around when looking at the Linux networking components
    that Docker uses.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Linux是一个功能强大的操作系统，具有许多强大的网络构造。就像任何网络技术一样，它们单独使用时很强大，但在创造性地组合在一起时变得更加强大。Docker是一个很好的例子，它将许多Linux网络堆栈的单独组件组合成一个完整的解决方案。虽然Docker大部分时间都在为您管理这些内容，但当查看Docker使用的Linux网络组件时，了解一些基本知识仍然是有帮助的。
- en: In this chapter, we'll spend some time looking at these constructs individually
    outside of Docker. We'll learn how to make network configuration changes on Linux
    hosts and validate the current state of the network configuration. While this
    chapter is not dedicated to Docker itself, it is important to understand the primitives
    for later chapters, where we discuss how Docker uses these constructs to network
    containers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将花一些时间单独查看这些构造，而不是在Docker之外。我们将学习如何在Linux主机上进行网络配置更改，并验证网络配置的当前状态。虽然本章并不专门针对Docker本身，但重要的是要了解原语，以便在以后的章节中讨论Docker如何使用这些构造来连接容器。
- en: Working with interfaces and addresses
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口和地址
- en: Understanding how Linux handles networking is an integral part of understanding
    how Docker handles networking. In this recipe, we'll focus on Linux networking
    basics by learning how to define and manipulate interfaces and IP addresses on
    a Linux host. To demonstrate the configuration, we'll start building a lab topology
    in this recipe and continue it through the other recipes in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Linux如何处理网络是理解Docker处理网络的一个重要部分。在这个配方中，我们将专注于Linux网络基础知识，学习如何在Linux主机上定义和操作接口和IP地址。为了演示配置，我们将在本配方中开始构建一个实验室拓扑，并在本章的其他配方中继续进行。
- en: Getting ready
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to view and manipulate networking settings, you''ll want to ensure
    that you have the `iproute2` toolset installed. If it''s not present on the system,
    it can be installed using the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看和操作网络设置，您需要确保已安装`iproute2`工具集。如果系统上没有安装它，可以使用以下命令进行安装：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In order to make network changes to the host, you'll also need root-level access.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。
- en: 'For the purpose of demonstration in this chapter, we''ll be using a simple
    lab topology. The initial network layout of the host looks like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本章中进行演示，我们将使用一个简单的实验室拓扑。主机的初始网络布局如下：
- en: '![Getting ready](graphics/B05453_01_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B05453_01_01.jpg)'
- en: 'In this case, we have three hosts, each with a single `eth0` interface already
    defined:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有三台主机，每台主机已经定义了一个`eth0`接口：
- en: '`net1`: `10.10.10.110/24` with a default gateway of `10.10.10.1`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net1`: `10.10.10.110/24`，默认网关为`10.10.10.1`'
- en: '`net2`: `172.16.10.2/26`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net2`: `172.16.10.2/26`'
- en: '`net3`: `172.16.10.66/26`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net3`: `172.16.10.66/26`'
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: The network configuration on most end hosts is generally limited to the IP address,
    the subnet mask, and the default gateway of a single interface. This is because
    most hosts are network endpoints offering a discrete set of services on a single
    IP interface. But what happens if we want to define more interfaces or manipulate
    the existing one? To answer that question, let's first look at simple single-homed
    server such as `net2` or `net3` in the preceding example.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数终端主机的网络配置通常仅限于单个接口的IP地址、子网掩码和默认网关。这是因为大多数主机都是网络端点，在单个IP接口上提供一组离散的服务。但是如果我们想要定义更多的接口或操作现有的接口会发生什么呢？为了回答这个问题，让我们首先看一下像前面例子中的`net2`或`net3`这样的简单单宿主服务器。
- en: 'On Ubuntu hosts, all of the interface configuration is done in the `/etc/network/interfaces`
    file. Let''s examine that file on the host `net2`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu主机上，所有的接口配置都是在`/etc/network/interfaces`文件中完成的。让我们检查一下`net2`主机上的文件：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can see that this file defines two interfaces—the local `loopback` interface
    and the interface `eth0`. The `eth0` interface defines the following information:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个文件定义了两个接口——本地的`loopback`接口和接口`eth0`。`eth0`接口定义了以下信息：
- en: '`address`: The IP address of the hosts interface'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`address`：主机接口的IP地址'
- en: '`netmask` : The subnet mask associated with the IP interface'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`netmask`：与IP接口相关的子网掩码'
- en: 'The information in this file will be processed each time the interface attempts
    to come into the up or operational state. We can validate that this configuration
    file was processed at system boot by checking the current IP address of the interface
    `eth0` with the `ip addr show <interface name>` command:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件中的信息将在每次接口尝试进入上行或操作状态时进行处理。我们可以通过使用`ip addr show <interface name>`命令验证该配置文件在系统启动时是否被处理：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we''ve reviewed a single-homed configuration, let''s take a look and
    see what it would take to configure multiple interfaces on a single host. As things
    stand, the `net1` host is the only host that has any sort of reachability off
    its local subnet. This is because it has a defined default gateway pointing back
    to the rest of the network. In order to make `net2` and `net3` reachable we need
    to find a way to connect them back to the rest of the network as well. To do this,
    let''s assume that the host `net1` has two additional network interfaces that
    we can connect directly to hosts `net2` and `net3`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了单宿主配置，让我们来看看在单个主机上配置多个接口需要做些什么。目前为止，`net1`主机是唯一一个在本地子网之外具有可达性的主机。这是因为它有一个定义好的默认网关指向网络的其他部分。为了使`net2`和`net3`可达，我们需要找到一种方法将它们连接回网络的其他部分。为了做到这一点，让我们假设主机`net1`有两个额外的网络接口，我们可以直接连接到主机`net2`和`net3`：
- en: '![How to do it…](graphics/B05453_01_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](graphics/B05453_01_02.jpg)'
- en: Let's walk through how to configure additional interfaces and IP addresses on
    the `net1` to complete the topology.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起来看看如何在`net1`上配置额外的接口和IP地址，以完成拓扑结构。
- en: 'The first thing we want to do is verify that we have additional interfaces
    available to work with on `net1`. To do this, we would use the `ip link show`
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是验证我们在`net1`上有可用的额外接口可以使用。为了做到这一点，我们将使用`ip link show`命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see from the output that in addition to the `eth0` interface, we also
    have interfaces `eth1` and `eth2` available to us. To see which interfaces have
    IP addresses associated with them, we can use the `ip address show` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，除了`eth0`接口，我们还有`eth1`和`eth2`接口可供使用。要查看哪些接口有与之关联的IP地址，我们可以使用`ip address
    show`命令：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding output proves that we currently only have a single IP address
    allocated on the interface `eth0`. This means that we can use the interface `eth1`
    for connectivity to server `net2` and `eth2` for connectivity to the server `net3`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出证明我们目前只在接口`eth0`上分配了一个IP地址。这意味着我们可以使用接口`eth1`连接到服务器`net2`，并使用接口`eth2`连接到服务器`net3`。
- en: 'There are two ways we can configure these new interfaces. The first is to update
    the network configuration file on `net1` with the relevant IP address information.
    Let''s do that for the link facing the host `net2`. To configure this connectivity,
    simply edit the file `/etc/network/interfaces` and add the relevant configuration
    for both interfaces. The finished configuration should look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有两种方法来配置这些新接口。第一种是在`net1`上更新网络配置文件，包括相关的IP地址信息。让我们为面向主机`net2`的链接进行配置。要配置这种连接，只需编辑文件`/etc/network/interfaces`，并为两个接口添加相关的配置。完成的配置应该是这样的：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the file is saved, you need to find a way to tell the system to reload
    the configuration file. One way to do this would be to reload the system. A simpler
    method would be to reload the interfaces. For instance, we could execute the following
    commands to reload interface `eth1`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，您需要找到一种方法告诉系统重新加载配置文件。做到这一点的一种方法是重新加载系统。一个更简单的方法是重新加载接口。例如，我们可以执行以下命令来重新加载接口`eth1`：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While not required in this case, bringing the interface down and up at the same
    time is a good habit to get into. This ensures that you don't cut yourself off
    if you take down the interface you're managing the host from.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下并不需要，但同时关闭和打开接口是一个好习惯。这样可以确保如果关闭了你正在管理主机的接口，你不会被切断。
- en: In some cases, you may find that this method of updating the interface configuration
    doesn't work as expected. Depending on your version of Linux, you may experience
    a condition where the previous IP address is not removed from the interface causing
    the interface to have multiple IP addresses. To resolve this, you can manually
    delete the old IP address or alternatively reboot the host, which will prevent
    legacy configurations from persisting.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会发现更新接口配置的这种方法不像预期的那样工作。根据您使用的Linux版本，您可能会遇到一个情况，即之前的IP地址没有从接口中删除，导致接口具有多个IP地址。为了解决这个问题，您可以手动删除旧的IP地址，或者重新启动主机，这将防止旧的配置持续存在。
- en: 'After the commands are executed, we should be able to see that the interface
    `eth1` is now properly addressed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完命令后，我们应该能够看到接口`eth1`现在被正确地寻址了。
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To configure the interface `eth2` on host `net1`, we''ll use a different approach.
    Rather than relying on configuration files, we''ll use the `iproute2` command-line
    to update the configuration of the interface. To do this, we simply execute the
    following commands:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在主机`net1`上配置接口`eth2`，我们将采用不同的方法。我们将使用`iproute2`命令行来更新接口的配置，而不是依赖配置文件。为此，我们只需执行以下命令：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It should be noted here that this configuration is not persistent. That is,
    since it's not part of a configuration file that's loaded at system initialization,
    this configuration will be lost on reboot. This is the same case for any network-related
    configuration done manually with the `iproute2` or other command-line toolsets.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，这种配置是不持久的。也就是说，由于它不是在系统初始化时加载的配置文件的一部分，这个配置在重新启动后将会丢失。对于使用`iproute2`或其他命令行工具集手动完成的任何与网络相关的配置都是一样的情况。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is the best practice to configure interface information and addressing in
    the network configuration file. Altering interface configuration outside of the
    configuration file is done in these recipes for the purpose of example only.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络配置文件中配置接口信息和地址是最佳实践。在这些教程中，修改配置文件之外的接口配置仅用于举例。
- en: 'Up to this point, we''ve only modified existing interfaces by adding IP information
    to them. We have not actually added a new interface to any of the systems. Adding
    interfaces is a fairly common task, and, as later recipes will show, there are
    a variety of interface types that can be added. For now, let''s focus on adding
    what Linux refers to as dummy interfaces. Dummy interfaces act like loopback interfaces
    in networking and describe an interface type that is always up and online. Interfaces
    are defined or created by using the `ip link add` syntax. You then specify a name
    and define what type of interface it is you are defining. For instance, let''s
    define a dummy interface on the hosts `net2` and `net3`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是通过向现有接口添加IP信息来修改现有接口。我们实际上还没有向任何系统添加新接口。添加接口是一个相当常见的任务，正如后面的教程将展示的那样，有各种类型的接口可以添加。现在，让我们专注于添加Linux所谓的虚拟接口。虚拟接口在网络中的作用类似于环回接口，并描述了一种始终处于开启和在线状态的接口类型。接口是通过使用`ip
    link add`语法来定义或创建的。然后，您指定一个名称，并定义您正在定义的接口类型。例如，让我们在主机`net2`和`net3`上定义一个虚拟接口：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After defining the interface, each host should be able to ping their own `dummy0`
    interface:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义接口之后，每个主机都应该能够ping通自己的`dummy0`接口：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why we had to turn up the `dummy0` interface if they're
    considered to be always up. In reality, the interface is reachable without turning
    up the interface. However, the local route for the interface will not appear in
    the systems routing table without turning the interface up.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么我们必须启动`dummy0`接口，如果它们被认为是一直开启的。实际上，接口是可以在不启动接口的情况下到达的。但是，如果不启动接口，接口的本地路由将不会出现在系统的路由表中。
- en: Configuring Linux host routing
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Linux主机路由
- en: Once you've defined new IP interfaces, the next step is to configure routing.
    In most cases, Linux host routing configuration is limited solely to specifying
    a host's default gateway. While that's typically as far as most need to go, a
    Linux host is capable of being a full-fledged router. In this recipe, we'll learn
    how to interrogate a Linux hosts routing table as well as manually configure routes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您定义了新的IP接口，下一步就是配置路由。在大多数情况下，Linux主机路由配置仅限于指定主机的默认网关。虽然这通常是大多数人需要做的，但Linux主机有能力成为一个完整的路由器。在这个教程中，我们将学习如何查询Linux主机的路由表，以及手动配置路由。
- en: Getting ready
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to view and manipulate networking settings, you''ll want to ensure
    that you have the `iproute2` toolset installed. If not present on the system,
    it can be installed by using the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看和操作网络设置，您需要确保已安装`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to make network changes to the host, you''ll also need root-level
    access. This recipe will continue the lab topology from the previous recipe. We
    left the topology looking like this after the previous recipe:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要root级别的访问权限。本教程将继续上一个教程中的实验拓扑。我们在上一个教程之后留下的拓扑如下所示：
- en: '![Getting ready](graphics/B05453_01_03.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/B05453_01_03.jpg)'
- en: How to do it…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Despite Linux hosts being capable of routing, they do not do so by default.
    In order for routing to occur, we need to modify a kernel-level parameter to enable
    IP forwarding. We can check the current state of the setting a couple of different
    ways:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Linux主机有路由的能力，但默认情况下不会这样做。为了进行路由，我们需要修改内核级参数以启用IP转发。我们可以通过几种不同的方式来检查设置的当前状态：
- en: 'By using the `sysctl` command:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用`sysctl`命令：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'By querying the `/proc/` filesystem directly:'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直接查询`/proc/`文件系统：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In either case, if the returned value is `1`, IP forwarding is enabled. If
    you do not receive a `1`, you''ll need to enable IP forwarding in order for the
    Linux host to route packets through the system. You can manually enable IP forwarding
    by using the `sysctl` command or again by directly interacting with the `/proc/`
    filesystem:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，如果返回值为`1`，则启用了IP转发。如果没有收到`1`，则需要启用IP转发，以便Linux主机通过系统路由数据包。您可以使用`sysctl`命令手动启用IP转发，或者再次直接与`/proc/`文件系统交互：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While this enables IP forwarding on the fly, this setting does not persist
    through a reboot. To make the setting persistent, you need to modify `/etc/sysctl.conf`,
    uncomment the line for IP forwarding, and ensure it''s set to `1`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以在运行时启用IP转发，但此设置不会在重新启动后保持。要使设置持久，您需要修改`/etc/sysctl.conf`，取消注释IP转发的行，并确保将其设置为`1`：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may note that we're only modifying settings related to IPv4 at this time.
    Don't worry; we'll cover IPv6 and Docker networking later on in [Chapter 10](ch10.html
    "Chapter 10. Leveraging IPv6"), *Leveraging IPv6*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，我们目前只修改了与IPv4相关的设置。不用担心；我们稍后会在[第10章](ch10.html "第10章。利用IPv6") *利用IPv6*中介绍IPv6和Docker网络。
- en: 'Once we''ve verified forwarding is configured, let''s look at the routing table
    on all three lab hosts by using the `ip route show` command:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们验证了转发配置，让我们使用`ip route show`命令查看所有三个实验室主机的路由表：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There are a couple of interesting items to note here. First off, we notice that
    the hosts have routes listed that are associated with each of their IP interfaces.
    Based on the subnet mask associated with the interface, the host can determine
    the network the interface is associated with. This route is inherent and would
    be said to be directly connected. Directly connected routes are how the system
    knows what IP destinations are directly connected versus which ones need to be
    forwarded to a next hop to reach a remote destination.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个有趣的地方需要注意。首先，我们注意到主机列出了与其每个IP接口相关联的路由。根据与接口相关联的子网掩码，主机可以确定接口所关联的网络。这条路由是固有的，并且可以说是直接连接的。直接连接的路由是系统知道哪些IP目的地是直接连接的，而哪些需要转发到下一跳以到达远程目的地。
- en: Second, in the last recipe, we added two additional interfaces to the host `net1`
    to provide connectivity to hosts `net2` and `net3`. However, this alone only allows
    `net1` to talk to `net2` and `net3`. If we want `net2` and `net3` to be reachable
    via the rest of the network, they'll need a default route pointing at their respective
    interfaces on `net1`. Once again, let's do this in two separate manners. On `net2`,
    we'll update the network configuration file and reload the interface, and on `net3`,
    we'll add the default route directly through the command line.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在上一篇文章中，我们向主机`net1`添加了两个额外的接口，以便与主机`net2`和`net3`进行连接。但是，仅凭这一点，只允许`net1`与`net2`和`net3`通信。如果我们希望通过网络的其余部分到达`net2`和`net3`，它们将需要指向`net1`上各自接口的默认路由。让我们再次以两种不同的方式进行。在`net2`上，我们将更新网络配置文件并重新加载接口，在`net3`上，我们将通过命令行直接添加默认路由。
- en: 'On host `net2`, update the file `/etc/network/interfaces` and add a gateway
    on the `eth0` interface pointing at the connected interface on the host `net1`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机`net2`上，更新文件`/etc/network/interfaces`，并在`eth0`接口上添加一个指向主机`net1`连接接口的网关：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To activate the new configuration, we''ll reload the interface:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要激活新配置，我们将重新加载接口：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we should be able to see the default route in the `net2` host''s routing
    table pointing out of `eth0` at the `net1` host''s directly connected interface
    (`172.16.10.1`):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够在`net2`主机的路由表中看到默认路由，指向`net1`主机直接连接的接口（`172.16.10.1`）：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the host `net3`, we''ll use the `iproute2` toolset to modify the hosts routing
    table dynamically. To do this, we''ll execute the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机`net3`上，我们将使用`iproute2`工具集动态修改主机的路由表。为此，我们将执行以下命令：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use the keyword `default`. This represents the default gateway
    or the destination of `0.0.0.0/0` in **Classless Inter-domain Routing** (**CIDR**)
    notation. We could have executed the command using the `0.0.0.0/0` syntax as well.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用关键字`default`。这代表了**无类域间路由**（**CIDR**）表示法中的默认网关或目的地`0.0.0.0/0`。我们也可以使用`0.0.0.0/0`语法执行该命令。
- en: 'After executing the command, we''ll check the routing table to make sure that
    we now have a default route pointing at `net1` (`172.16.10.65`):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行命令后，我们将检查路由表，以确保我们现在有一个默认路由指向`net1`（`172.16.10.65`）：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: At this point, the hosts and the rest of the network should have full network
    reachability to all of their physical interfaces. However, the dummy interfaces
    created in the previous recipe are not reachable by any other hosts than the ones
    they are defined on. In order to make those reachable, we're going to need to
    add some static routes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，主机和网络的其余部分应该能够完全访问其所有物理接口。然而，在上一个步骤中创建的虚拟接口对于除了它们所定义的主机之外的任何其他主机都是不可达的。为了使它们可达，我们需要添加一些静态路由。
- en: 'The dummy interface networks are `172.16.10.128/26` and `172.16.10.192/26`.
    Because these networks are part of the larger `172.16.10.0/24` summary, the rest
    of the network already knows to route to the `net1` host''s `10.10.10.110` interface
    to get to these prefixes. However, `net1` currently doesn''t know where those
    prefixes live and will, in turn, loop the traffic right back to where it came
    from following its default route. To solve this, we need to add two static routes
    on `net1`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟接口网络是`172.16.10.128/26`和`172.16.10.192/26`。因为这些网络是较大的`172.16.10.0/24`汇总的一部分，网络的其余部分已经知道要路由到`net1`主机的`10.10.10.110`接口以到达这些前缀。然而，`net1`目前不知道这些前缀位于何处，因此会将流量原路返回到它来自的地方，遵循其默认路由。为了解决这个问题，我们需要在`net1`上添加两个静态路由：
- en: '![How to do it…](graphics/B05453_01_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_01_04.jpg)'
- en: 'We can add these routes ad hoc through the `iproute2` command-line tools or
    we can add them in a more persistent fashion as part of the host''s network script.
    Let''s do one of each:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`iproute2`命令行工具临时添加这些路由，也可以将它们作为主机网络脚本的一部分以更持久的方式添加。让我们各做一次：
- en: 'To add the `172.16.10.128/26` route pointing at `net2`, we''ll use the command-line
    tool:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加指向`net2`的`172.16.10.128/26`路由，我们将使用命令行工具：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, adding manual routes is done through the `ip route add` command
    syntax. The subnet that needs to be reached is specified along with the associated
    next hop address. The command takes effect immediately as the host populates the
    routing table instantly to reflect the change:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，通过`ip route add`命令语法添加手动路由。需要到达的子网以及相关的下一跳地址都会被指定。该命令立即生效，因为主机会立即填充路由表以反映更改：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we wish to make a route persistent, we can allocate it as a `post-up` interface
    configuration. The `post-up` interface configurations take place directly after
    an interface is loaded. If we want the route `172.16.10.192/26` to be added to
    the hosts routing table the instant `eth2` comes online, we can edit the `/etc/network/interfaces`
    configuration script as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望使路由持久化，我们可以将其分配为`post-up`接口配置。`post-up`接口配置在接口加载后直接进行。如果我们希望在`eth2`上线时立即将路由`172.16.10.192/26`添加到主机的路由表中，我们可以编辑`/etc/network/interfaces`配置脚本如下：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After adding the configuration, we can reload the interface to force the configuration
    file to reprocess:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 添加配置后，我们可以重新加载接口以强制配置文件重新处理：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In some cases, the host may not process the `post-up` command because we defined
    the address on the interface manually in an earlier recipe. Deleting the IP address
    before reloading the interface would resolve this issue; however, in these cases,
    rebooting the host is the easiest (and cleanest) course of action.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，主机可能不会处理`post-up`命令，因为我们在早期的配置中手动定义了接口上的地址。在重新加载接口之前删除IP地址将解决此问题；然而，在这些情况下，重新启动主机是最简单（也是最干净）的操作方式。
- en: 'And our routing table will now show both routes:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由表现在将显示两条路由：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To verify this is working as expected, let''s do some testing from a remote
    workstation that''s attempting to ping the dummy interface on the host `net2`
    (`172.16.10.129`). Assuming the workstation is connected to an interface that''s
    not on the external network, the flow might look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这是否按预期工作，让我们从尝试ping主机`net2`（`172.16.10.129`）上的虚拟接口的远程工作站进行一些测试。假设工作站连接到的接口不在外部网络上，流程可能如下：
- en: '![How to do it…](graphics/B05453_01_05.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/B05453_01_05.jpg)'
- en: A workstation with an IP address of `192.168.127.55` is attempting to reach
    the dummy interface connected to `net2` at its IP address of `172.16.10.129`.
    The workstation sends the traffic towards its default gateway since the destination
    it's looking for is not directly connected.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有IP地址`192.168.127.55`的工作站正在尝试到达连接到`net2`的虚拟接口，其IP地址为`172.16.10.129`。由于工作站寻找的目的地不是直接连接的，它将流量发送到其默认网关。
- en: The network has a route for `172.16.10.0/24` pointing at `net1's eth0` interface
    (`10.10.10.110`). The destination IP address (`172.16.10.129`) is a member of
    that larger prefix, so the network forwards the workstation's traffic on to the
    host `net1`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 网络中有一个指向`net1`的`eth0`接口（`10.10.10.110`）的`172.16.10.0/24`路由。目标IP地址（`172.16.10.129`）是该较大前缀的成员，因此网络将工作站的流量转发到主机`net1`。
- en: The `net1` host examines the traffic, interrogates its routing table, and determines
    that it has a route for that prefix pointing towards the `net2` with a next hop
    of `172.16.10.2`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主机`net1`检查流量，查询其路由表，并确定它有一个指向`net2`的该前缀的路由，下一跳是`172.16.10.2`。
- en: The `net2` receives the request, realizes that the dummy interface is directly
    connected, and attempts to send a reply back to the workstation. Not having a
    specific route for the destination of `192.168.127.55`, the host `net2` sends
    its reply to its default gateway, which is `net1` (`172.16.10.1`).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`net2`收到请求，意识到虚拟接口直接连接，并尝试将回复发送回工作站。由于没有目的地为`192.168.127.55`的特定路由，主机`net2`将其回复发送到其默认网关，即`net1`（`172.16.10.1`）。'
- en: Similarly, `net1` does not have a specific route for the destination of `192.168.127.55`,
    so it forwards the traffic back to the network via its default gateway. It is
    assumed that the network has reachability to return the traffic to the workstation.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`net1`没有目的地为`192.168.127.55`的特定路由，因此它将流量通过其默认网关转发回网络。假设网络具有返回流量到工作站的可达性。
- en: 'In the case that we''d like to remove statically defined routes, we can do
    so with the `ip route delete` subcommand. For instance, here''s an example of
    adding a route and then deleting it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要删除静态定义的路由，可以使用`ip route delete`子命令来实现。例如，这是一个添加路由然后删除它的示例：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice how we only need to specify the destination prefix when deleting the
    route, not the next hop.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在删除路由时只需要指定目标前缀，而不需要指定下一跳。
- en: Exploring bridges
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索桥接
- en: Bridges in Linux are a key building block for network connectivity. Docker uses
    them extensively in many of its own network drivers that are included with `docker-engine`.
    Bridges have been around for a long time and are, in most cases, very similar
    to a physical network switch. Bridges in Linux can act like layer 2 or layer 3
    bridges.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中的桥是网络连接的关键构建块。Docker在许多自己的网络驱动程序中广泛使用它们，这些驱动程序包含在`docker-engine`中。桥已经存在很长时间，在大多数情况下，非常类似于物理网络交换机。Linux中的桥可以像二层桥一样工作，也可以像三层桥一样工作。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Layer 2 versus layer 3**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**二层与三层**'
- en: The nomenclature refers to different layers of the OSI network model. Layer
    2 represents the **data link layer** and is associated with switching frames between
    hosts. Layer 3 represents the **network layer** and is associated with routing
    packets across the network. The major difference between the two is switching
    versus routing. A layer 2 switch is capable of sending frames between hosts on
    the same network but is not capable of routing them based on IP information. If
    you wish to route between two hosts on different networks or subnets, you'll need
    a layer 3 capable device that can route between the two subnets. Another way to
    look at this is that layer 2 switches can only deal with MAC addresses and layer
    3 devices can deal with IP addresses.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 命名法是指OSI网络模型的不同层。二层代表**数据链路层**，与在主机之间进行帧交换相关联。三层代表**网络层**，与在网络中路由数据包相关联。两者之间的主要区别在于交换与路由。二层交换机能够在同一网络上的主机之间发送帧，但不能根据IP信息进行路由。如果您希望在不同网络或子网上的两台主机之间进行路由，您将需要一台能够在两个子网之间进行路由的三层设备。另一种看待这个问题的方式是，二层交换机只能处理MAC地址，而三层设备可以处理IP地址。
- en: By default, Linux bridges are layer 2 constructs. In this manner, they are often
    referred to as protocol independent. That is, any number of higher level (layer
    3) protocols can run on the same bridge implementation. However, you can also
    assign an IP address to a bridge that turns it into a layer 3 capable networking
    construct. In this recipe, we'll show you how to create, manage, and inspect Linux
    bridges by walking through a couple of examples.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Linux桥是二层结构。因此，它们通常被称为协议无关。也就是说，任意数量的更高级别（三层）协议可以在同一个桥实现上运行。但是，您也可以为桥分配一个IP地址，将其转换为三层可用的网络结构。在本教程中，我们将通过几个示例来向您展示如何创建、管理和检查Linux桥。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to view and manipulate networking settings, you''ll want to ensure
    that you have the `iproute2` toolset installed. If not present on the system,
    it can be installed by using the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看和操作网络设置，您需要确保已安装`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE28]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In order to make network changes to the host, you'll also need root-level access.
    This recipe will continue the lab topology from the previous recipe. All of the
    prerequisites mentioned earlier still apply.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要具有根级别访问权限。本教程将继续上一个教程中的实验室拓扑。之前提到的所有先决条件仍然适用。
- en: How to do it…
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'To demonstrate how bridges work, let''s consider making a slight change to
    the lab topology we''ve been working with:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示桥接工作原理，让我们考虑对我们一直在使用的实验室拓扑进行轻微更改：
- en: '![How to do it…](graphics/B05453_01_06.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](graphics/B05453_01_06.jpg)'
- en: Rather than having the servers directly connect to each other via physical interfaces,
    we'll instead leverage bridges on the host `net1` for connectivity to downstream
    hosts. Previously, we relied on a one-to-one mapping for connections between `net1`
    and any other hosts. This meant that we'd need a unique subnet and IP address
    configuration for each physical interface. While that's certainly doable, it's
    not very practical. Leveraging bridge interfaces rather than standard interfaces
    affords us some flexibility we didn't have in the earlier configurations. We can
    assign a single IP address to a bridge interface and then plumb many physical
    connections into the same bridge. For example, a `net4` host could be added to
    the topology and its interface on `net1` could simply be added to `host_bridge2`.
    That would allow it to use the same gateway (`172.16.10.65`) as `net3`. So while
    the physical cabling requirement for adding hosts won't change, this does prevent
    us from having to define one-to-one IP address mappings for each host.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与其让服务器通过物理接口直接连接到彼此，我们将利用主机`net1`上的桥接来连接到下游主机。以前，我们依赖于`net1`和任何其他主机之间的一对一映射连接。这意味着我们需要为每个物理接口配置唯一的子网和IP地址。虽然这是可行的，但并不是很实际。与标准接口相比，利用桥接接口为我们提供了一些在早期配置中没有的灵活性。我们可以为桥接接口分配一个单独的IP地址，然后将许多物理连接连接到同一个桥接上。例如，`net4`主机可以添加到拓扑结构中，其在`net1`上的接口可以简单地添加到`host_bridge2`上。这将允许它使用与`net3`相同的网关（`172.16.10.65`）。因此，虽然添加主机的物理布线要求不会改变，但这确实使我们不必为每个主机定义一对一的IP地址映射。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From the perspective of the hosts `net2` and `net3`, nothing will change when
    we reconfigure to use bridges.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 从`net2`和`net3`主机的角度来看，当我们重新配置以使用桥接时，什么都不会改变。
- en: 'Since we''re changing how we define the `net1` host''s `eth1` and `eth2` interface,
    we''ll start by flushing their configuration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改如何定义`net1`主机的`eth1`和`eth2`接口，因此我们将首先清除它们的配置：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Flushing the interface simply clears any IP-related configuration off of the
    interface. The next thing we have to do is to create the bridges themselves. The
    syntax we use is much like we saw in the previous recipe when we created the dummy
    interfaces. We use the `ip link add` command and specify a type of bridge:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 清除接口只是清除接口上的任何与IP相关的配置。我们接下来要做的是创建桥接本身。我们使用的语法与我们在上一个示例中创建虚拟接口时看到的非常相似。我们使用`ip
    link add`命令并指定桥接类型：
- en: '[PRE30]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After creating the bridges, we can verify that they exist by examining the
    available interfaces with the `ip link show <interface>` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 创建桥接之后，我们可以通过使用`ip link show <interface>`命令来验证它们的存在，检查可用的接口：
- en: '[PRE31]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we want to make them layer 3 aware, so we assign an IP address to the
    bridge interface. This is very similar to how we assigned IP addressing to physical
    interfaces in previous recipes:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望使它们具有第3层意识，因此我们为桥接接口分配一个IP地址。这与我们在以前的示例中为物理接口分配IP地址非常相似：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can verify that the IP addresses were assigned by using the `ip addr show
    dev <interface>` command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`ip addr show dev <interface>`命令来验证IP地址的分配情况：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next step is to bind the physical interfaces associated with each downstream
    host to the correct bridge. In our case, we want the host `net2`, which is connected
    to `net1''s` `eth1` interface to be part of the bridge `host_bridge1`. Similarly,
    we want the host `net3`, which is connected to `net1`''s `eth2` interface, to
    be part of the bridge `host_bridge2`. Using the `ip link set` subcommand, we can
    define the bridges to be the masters of the physical interfaces:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将与每个下游主机关联的物理接口绑定到正确的桥上。在我们的情况下，我们希望连接到`net1`的`eth1`接口的主机`net2`成为桥`host_bridge1`的一部分。同样，我们希望连接到`net1`的`eth2`接口的主机`net3`成为桥`host_bridge2`的一部分。使用`ip
    link set`子命令，我们可以将桥定义为物理接口的主设备：
- en: '[PRE34]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can verify that the interfaces were successfully bound to the bridge by using
    the `bridge link show` command.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bridge link show`命令验证接口是否成功绑定到桥上。
- en: Note
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `bridge` command is part of the `iproute2` package and is used to validate
    bridge configuration.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`bridge`命令是`iproute2`软件包的一部分，用于验证桥接配置。'
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we need to turn up the bridge interfaces as they are, by default,
    created in a down state:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将桥接接口打开，因为它们默认处于关闭状态：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once again, we can now check the link status of the bridges to verify that
    they came up successfully:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们现在可以检查桥接的链路状态，以验证它们是否成功启动：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'At this point, you should once again be able to reach the hosts `net2` and
    `net3`. However, the dummy interfaces are now unreachable. This is because the
    routes for the dummy interfaces were automatically withdrawn after we flushed
    interface `eth1` and `eth2`. Removing the IP addresses from those interfaces made
    the next hops used to reach the dummy interfaces unreachable. It is common for
    a device to withdraw a route from its routing table when the next hop becomes
    unreachable. We can add them again rather easily:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您应该再次能够到达主机`net2`和`net3`。但是，虚拟接口现在无法访问。这是因为在我们清除接口`eth1`和`eth2`之后，虚拟接口的路由被自动撤销。从这些接口中删除IP地址使得用于到达虚拟接口的下一跳不可达。当下一跳变得不可达时，设备通常会从其路由表中撤销路由。我们可以很容易地再次添加它们：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that everything is working again, we can perform some extra steps to validate
    the configuration. Linux bridges, much like real layer 2 switches, can also keep
    track of the MAC addresses they receive. We can view the MAC addresses the system
    is aware of by using the `bridge fdb show` command:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切都恢复正常了，我们可以执行一些额外的步骤来验证配置。Linux桥，就像真正的第二层交换机一样，也可以跟踪它们接收到的MAC地址。我们可以使用`bridge
    fdb show`命令查看系统知道的MAC地址：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The two MAC addresses we see in the preceding output reference the directly
    connected interfaces that `net1` talks to in order to get to hosts `net2` and
    `net3` as well as the subnets defined on their associated `dummy0` interfaces.
    We can verify this by looking at the hosts ARP table:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的输出中看到的两个MAC地址是指`net1`直接连接的接口，以便到达主机`net2`和`net3`，以及其关联的`dummy0`接口上定义的子网。我们可以通过查看主机ARP表来验证这一点：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There aren't many scenarios where the old tool is better, but in the case of
    the `bridge` command-line tool, some might argue that the older `brctl` tool has
    some advantages. For one, the output is a little easier to read. In the case of
    learned MAC addresses, it will give you a better view into the mappings with the
    `brctl showmacs <bridge name>` command. If you want to use the older tool, you
    can install the `bridge-utils` package.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧工具更好的情况并不多见，但在`bridge`命令行工具的情况下，一些人可能会认为旧的`brctl`工具有一些优势。首先，输出更容易阅读。在学习MAC地址的情况下，它将通过`brctl
    showmacs <bridge name>`命令为您提供更好的映射视图。如果您想使用旧工具，可以安装`bridge-utils`软件包。
- en: 'Removing interfaces from bridges can be accomplished through the `ip link set`
    subcommand. For instance, if we wanted to remove `eth1` from the bridge `host_bridge1`
    we would run this command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`ip link set`子命令可以从桥中移除接口。例如，如果我们想要从桥`host_bridge1`中移除`eth1`，我们将运行以下命令：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This removes the master slave binding between `eth1` and the bridge `host_bridge1`.
    Interfaces can also be reassigned to new bridges (masters) without removing them
    from the bridge they are currently associated with. If we wanted to delete the
    bridge entirely, we could do so with this command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除`eth1`与桥`host_bridge1`之间的主从绑定。接口也可以重新分配给新的桥（主机），而无需将它们从当前关联的桥中移除。如果我们想要完全删除桥，可以使用以下命令：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: It should be noted that you do not need to remove all of the interfaces from
    the bridge before you delete it. Deleting the bridge will automatically remove
    all master bindings.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在删除桥之前，您不需要将所有接口从桥中移除。删除桥将自动删除所有主绑定。
- en: Making connections
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立连接
- en: Up until this point, we've focused on physical cables to make connections between
    interfaces. But how would we connect two interfaces that didn't have physical
    interfaces? For this purpose, Linux networking has an internal interface type
    called **Virtual Ethernet** (**VETH**) pairs. VETH interfaces are always created
    in pairs making them act like a sort of virtual patch cable. VETH interfaces can
    also have IP addresses assigned to them, which allow them to participate in a
    layer 3 routing path. In this recipe, we'll examine how to define and implement
    VETH pairs by building off the lab topology we've used in previous recipes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直专注于使用物理电缆在接口之间建立连接。但是，如果两个接口没有物理接口，我们该如何连接它们？为此，Linux网络具有一种称为**虚拟以太网**（**VETH**）对的内部接口类型。VETH接口总是成对创建，使其表现得像一种虚拟补丁电缆。VETH接口也可以分配IP地址，这使它们能够参与第3层路由路径。在本教程中，我们将通过构建之前教程中使用的实验拓扑来研究如何定义和实现VETH对。
- en: Getting ready
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to view and manipulate networking settings, you''ll want to ensure
    that you have the `iproute2` toolset installed. If not present on the system,
    it can be installed by using the command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看和操作网络设置，您需要确保已安装了`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In order to make network changes to the host, you'll also need root-level access.
    This recipe will continue the lab topology from the previous recipe. All of the
    prerequisites mentioned earlier still apply.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要具有根级访问权限。本教程将继续上一个教程中的实验拓扑。之前提到的所有先决条件仍然适用。
- en: How to do it…
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Let''s once again modify the lab topology, so we can make use of VETH pairs:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次修改实验拓扑，以便使用VETH对：
- en: '![How to do it…](graphics/B05453_01_07.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](graphics/B05453_01_07.jpg)'
- en: Once again, the configuration on hosts `net2` and `net3` will remain unchanged.
    On the host `net1`, we're going to implement VETH pairs in two different manners.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，主机`net2`和`net3`上的配置将保持不变。在主机`net1`上，我们将以两种不同的方式实现VETH对。
- en: On the connection between `net1` and `net2`, we're going to use two different
    bridges and connect them together with a VETH pair. The bridge `host_bridge1`
    will remain on `net1` and maintain its IP address of `172.16.10.1`. We're also
    going to add a new bridge named `edge_bridge1`. This bridge will not have an IP
    address assigned to it but will have `net1`'s interface facing `net2` (`eth1`)
    as a member of it. At that point, we'll use a VETH pair to connect the two bridges
    allowing traffic to flow from `net1` across both bridges to `net2`. In this case,
    the VETH pair will be used as a layer 2 construct.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`net1`和`net2`之间的连接上，我们将使用两个不同的桥接，并使用VETH对将它们连接在一起。桥接`host_bridge1`将保留在`net1`上，并保持其IP地址为`172.16.10.1`。我们还将添加一个名为`edge_bridge1`的新桥接。该桥接将不分配IP地址，但将具有`net1`的接口面向`net2`（`eth1`）作为其成员。在那时，我们将使用VETH对连接这两个桥接，允许流量从`net1`通过两个桥接流向`net2`。在这种情况下，VETH对将被用作第2层构造。
- en: On the connection between `net1` and `net3` we're going to use a VETH pair but
    in a slightly different fashion. We'll add a new bridge called `edge_bridge2`
    and put `net1` host's interface facing the host `net3` (`eth2`) on that bridge.
    Then we will provision a VETH pair and place one end on the bridge `edge_bridge2`.
    We'll then assign the IP address previously assigned to the `host_bridge2` to
    the host side of the VETH pair. In this case, the VETH pair will be used as a
    layer 3 construct.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在`net1`和`net3`之间的连接上，我们将以稍微不同的方式使用VETH对。我们将添加一个名为`edge_bridge2`的新桥，并将`net1`主机的接口面向主机`net3`（`eth2`）放在该桥上。然后，我们将配置一个VETH对，并将一端放在桥`edge_bridge2`上。然后，我们将分配之前分配给`host_bridge2`的IP地址给VETH对的主机端。在这种情况下，VETH对将被用作第3层构造。
- en: 'Let''s start on the connection between `net1` and `net2` by adding the new
    edge bridge:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`net1`和`net2`之间的连接上添加新的边缘桥开始：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we''ll add the interface facing `net2` to `edge_bridge1`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把面向`net2`的接口添加到`edge_bridge1`上：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, we''ll configure the VETH pair that we''ll use to connect `host_bridge1`
    and `edge_bridge1`. VETH pairs are always defined in a pair. Creating the interface
    will spawn two new objects, but they are reliant on each other. That is, if you
    delete one end of the VETH pair, the other end will get deleted right along with
    it. To define the VETH pair, we use the `ip link add` subcommand:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将配置用于连接`host_bridge1`和`edge_bridge1`的VETH对。VETH对始终成对定义。创建接口将产生两个新对象，但它们是相互依赖的。也就是说，如果删除VETH对的一端，另一端也将被删除。为了定义VETH对，我们使用`ip
    link add`子命令：
- en: '[PRE46]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the command defines the name for both sides of the VETH connection.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，该命令定义了VETH连接的两侧的名称。
- en: 'We can see their configuration using the `ip link show` subcommand:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ip link show`子命令查看它们的配置：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Note that we have two entries showing an interface for each side of the defined
    VETH pair. The next step is to place the ends of the VETH pair in the correct
    place. In the case of the connection between `net1` and `net2`, we want one end
    on `host_bridge1` and the other on `edge_bridge1`. To do this, we use the same
    syntax we used for assigning interfaces to bridges:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有两个条目显示了定义的VETH对的每一侧的接口。下一步是将VETH对的端点放在正确的位置。在`net1`和`net2`之间的连接中，我们希望一个端点在`host_bridge1`上，另一个端点在`edge_bridge1`上。为此，我们使用了分配接口给桥接的相同语法：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We can verify the mappings using the `ip link show` command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ip link show`命令验证映射：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The last thing we need to do is bring up the interfaces associated with the
    connection:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是启动与连接相关的接口：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To reach the dummy interface off of `net2`, you''ll need to add the route back
    since it was once again lost during the reconfiguration:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要到达`net2`上的虚拟接口，您需要添加路由，因为在重新配置期间它再次丢失了：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: At this point, we should have full reachability to `net2` and its `dummy0` interface
    through `net1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们应该可以完全到达“net2”及其通过“net1”到达“dummy0”接口。
- en: 'On the connection between host `net1` and `net3`, the first thing we need to
    do is clean up any unused interfaces. In this case, that would be `host_bridge2`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机“net1”和“net3”之间的连接上，我们需要做的第一件事是清理任何未使用的接口。在这种情况下，那将是“host_bridge2”：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we need to add the new edge bridge (`edge_bridge2`) and associate `net1`''s
    interface facing `net3` to the bridge:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要添加新的边缘桥接（“edge_bridge2”）并将“net1”面向“net3”的接口与桥接关联起来：
- en: '[PRE53]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''ll then define the VETH pair for this connection:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为此连接定义VETH对：
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this case, we''re going to leave the host side VETH pair unassociated from
    the bridges and instead assign an IP address directly to it:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使主机端的VETH对与桥接不相关，而是直接为其分配一个IP地址：
- en: '[PRE55]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Just like any other interface, we can see the assigned IP address by using
    the `ip address show dev` command:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他接口一样，我们可以使用“ip address show dev”命令来查看分配的IP地址：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We will then place the other end of the VETH pair into `edge_bridge2` connecting
    `net1` to the edge bridge:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将另一端的VETH对放入“edge_bridge2”连接“net1”到边缘桥接：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And once again, we turn up all the associated interfaces:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们再次启动所有相关接口：
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Finally, we read our route to get to `net3`''s dummy interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们读取我们到达“net3”的虚拟接口的路由：
- en: '[PRE59]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: After the configuration is completed, we should once again have full reachability
    into the environment and all the interfaces. If there are any issues with your
    configuration, you should be able to diagnose them through the use of the `ip
    link show` and `ip addr show` commands.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，我们应该再次完全进入环境和所有接口的可达性。如果配置有任何问题，您应该能够通过使用“ip link show”和“ip addr show”命令来诊断它们。
- en: 'If you''re ever questioning what the other end of a VETH pair is, you can use
    the `ethtool` command-line tool to return the other side of the pair. For instance,
    assume that we create a non-named VETH pair as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经怀疑VETH对的另一端是什么，您可以使用“ethtool”命令行工具返回对的另一端。例如，假设我们创建一个非命名的VETH对如下所示：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'While obvious in this example, we could use `ethtool` to determine the interface
    index or ID of one or the other side of this VETH pair:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中很明显，我们可以使用“ethtool”来确定这个VETH对的接口索引或ID的一端或另一端：
- en: '[PRE61]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This can be a handy troubleshooting tool later on when determining the ends
    of a VETH pair is not as obvious as it is in these examples.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定VETH对的端点不像在这些示例中那样明显时，这可能是一个方便的故障排除工具。
- en: Exploring network namespaces
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索网络命名空间
- en: Network namespaces allow you to create isolated views of the network. A namespace
    has a unique routing table that can differ entirely from the default routing table
    on the host. In addition, you can map interfaces from the physical host into namespaces
    for use within the namespace. The behavior of network namespaces closely mimics
    that of **Virtual Routing and Forwarding** (**VRF**) instances, which are available
    in most modern networking hardware. In this recipe, we'll learn the basics of
    network namespaces. We'll walk through the process of creating the namespace and
    discuss how to use different types of interfaces within a network namespace. Finally,
    we'll show how to connect multiple namespaces together.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 网络命名空间允许您创建网络的隔离视图。命名空间具有唯一的路由表，可以与主机上的默认路由表完全不同。此外，您可以将物理主机的接口映射到命名空间中，以在命名空间内使用。网络命名空间的行为与大多数现代网络硬件中可用的**虚拟路由和转发**（**VRF**）实例的行为非常相似。在本教程中，我们将学习网络命名空间的基础知识。我们将逐步介绍创建命名空间的过程，并讨论如何在网络命名空间中使用不同类型的接口。最后，我们将展示如何连接多个命名空间。
- en: Getting ready
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to view and manipulate networking settings, you''ll want to ensure
    that you have the `iproute2` toolset installed. If not present on the system,
    it can be installed using the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看和操作网络设置，您需要确保已安装了`iproute2`工具集。如果系统上没有安装，可以使用以下命令进行安装：
- en: '[PRE62]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In order to make network changes to the host, you'll also need root-level access.
    This recipe will continue the lab topology from the previous recipe. All of the
    prerequisites mentioned earlier still apply.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对主机进行网络更改，您还需要具有根级别的访问权限。这个示例将继续上一个示例中的实验室拓扑。之前提到的所有先决条件仍然适用。
- en: How to do it…
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The concept of network namespaces is best demonstrated through an example,
    so let''s jump right back to the lab topology from the previous recipes:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 网络命名空间的概念最好通过一个例子来进行演示，所以让我们直接回到上一个示例中的实验室拓扑：
- en: '![How to do it…](graphics/B05453_01_08.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/B05453_01_08.jpg)'
- en: 'This diagram is the same topology we used in the last recipe, with one significant
    difference. We have the addition of two namespaces, **NS_1** and **NS_2**. Each
    namespace encompasses certain interfaces on the host `net1`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图表和上一个示例中使用的拓扑是一样的，但有一个重要的区别。我们增加了两个命名空间**NS_1**和**NS_2**。每个命名空间包含主机`net1`上的特定接口：
- en: 'NS_1:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NS_1:'
- en: '`edge_bridge1`'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge_bridge1`'
- en: '`eth1`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth1`'
- en: '`edge_veth1`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge_veth1`'
- en: 'NS_2:'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'NS_2:'
- en: '`edge_bridge2`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge_bridge2`'
- en: '`eth2`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eth2`'
- en: '`edge_veth2`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`edge_veth2`'
- en: Take note of where the boundary for the namespaces falls. In either case, the
    boundary falls on a physical interface (the `net1` host's `eth1` and `eth2`) or
    directly in the middle of a VETH pair. As we'll see shortly, VETH pairs can bridge
    between namespaces making them an ideal tool for connecting network namespaces
    together.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意命名空间的边界在哪里。在任何情况下，边界都位于物理接口（`net1`主机的`eth1`和`eth2`）上，或者直接位于VETH对的中间。正如我们将很快看到的，VETH对可以在命名空间之间桥接，使它们成为连接网络命名空间的理想工具。
- en: 'To begin the reconfiguration, let''s start by defining the namespaces, and
    then adding interfaces to the namespace. Defining a namespace is rather straightforward.
    We use the `ip netns add` subcommand:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始重新配置，让我们从定义命名空间开始，然后将接口添加到命名空间中。定义命名空间相当简单。我们使用`ip netns add`子命令：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Namespaces can then be viewed by using the `ip netns list` command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以使用`ip netns list`命令来查看命名空间：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Once the namespaces are created, we can allocate the specific interfaces we
    identified as being part of each namespace. In most cases, this means telling
    an existing interface which namespace it belongs to. However, not all interfaces
    can be moved into a network namespace. Bridges for instances can live in network
    namespaces but need to be instantiated from within the name space. To do this,
    we can use the `ip netns exec` subcommand to run the command from within the namespace.
    For instance, to create the edge bridges in each namespace, we would run these
    two commands:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间创建后，我们可以分配特定的接口给我们确定为每个命名空间的一部分的接口。在大多数情况下，这意味着告诉一个现有的接口它属于哪个命名空间。然而，并非所有接口都可以移动到网络命名空间中。例如，桥接可以存在于网络命名空间中，但需要在命名空间内实例化。为此，我们可以使用`ip
    netns exec`子命令来在命名空间内运行命令。例如，要在每个命名空间中创建边缘桥接，我们将运行这两个命令：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let''s break that command into two pieces:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这个命令分成两部分：
- en: '`sudo ip nent exec ns_1`: This tells the host you want to run a command inside
    a specific namespace, in this case `ns_1`'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo ip nent exec ns_1`：这告诉主机你想在特定的命名空间内运行一个命令，在这种情况下是`ns_1`'
- en: '`ip link add edge_bridge1 type bridge`: As we saw in earlier recipes, we execute
    the command to build a bridge and give it a name, in this case, `edge_bridge1`.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ip link add edge_bridge1 type bridge`：正如我们在之前的示例中看到的，我们执行这个命令来构建一个桥接并给它起一个名字，在这种情况下是`edge_bridge1`。'
- en: 'Using this same syntax, we can now examine the network configuration of a specific
    namespace. For instance, we could look at the interfaces with `sudo ip netns exec
    ns_1 ip link show`:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的语法，我们现在可以检查特定命名空间的网络配置。例如，我们可以使用`sudo ip netns exec ns_1 ip link show`查看接口：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'As we expected, we see the bridge we instantiated inside the namespace. The
    other two interface types that the diagram shows in the namespace are of types
    that can be dynamically allocated into the namespace. To do that, we use the `ip
    link set` command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们预期的那样，我们在命名空间中看到了我们实例化的桥接器。图表中显示在命名空间中的另外两种接口类型是可以动态分配到命名空间中的类型。为此，我们使用`ip
    link set`命令：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now if we look at the available host interfaces, we should note that the interfaces
    we moved no longer exist in the default namespace:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们查看可用的主机接口，我们应该注意到我们移动的接口不再存在于默认命名空间中：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You likely noticed that `edge_bridge1` and `edge_bridge2` still exist in this
    output since we never deleted them. This is interesting because they now also
    exist inside the namespaces `ns_1` and `ns_2`. It's important to point out that
    since the namespaces are totally isolated even the interface names can overlap.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，`edge_bridge1`和`edge_bridge2`仍然存在于此输出中，因为我们从未删除它们。这很有趣，因为它们现在也存在于命名空间`ns_1`和`ns_2`中。重要的是要指出，由于命名空间是完全隔离的，甚至接口名称也可以重叠。
- en: 'Now that all of the interfaces are in the right namespace, all that''s left
    to do is to apply standard bridge mapping and turn up the interfaces. Since we
    had to recreate the bridge interfaces in each namespace, we''ll need to reattach
    the interfaces to each bridge. This is done just like you would normally; we just
    run the command within the namespace:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有接口都在正确的命名空间中，剩下的就是应用标准的桥接映射并启动接口。由于我们需要在每个命名空间中重新创建桥接接口，我们需要重新将接口附加到每个桥接器上。这就像通常做的那样；我们只需在命名空间内运行命令：
- en: '[PRE69]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Once we have all of the interfaces in the right namespace and attached to the
    right bridges, all that''s left is to bring them all up:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有接口放入正确的命名空间并连接到正确的桥接器，剩下的就是将它们全部启动：
- en: '[PRE70]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: After the interfaces come up, we should once again have connectivity to all
    of the networks attached to all three hosts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接口启动后，我们应该再次可以连接到所有三个主机连接的网络。
- en: 'While this example of namespaces only moved layer 2 type constructs into a
    namespace, they also support layer 3 routing with unique routing table instances
    per namespace. For instance, if we look at the routing table of one of the namespaces
    we''ll see that it''s completely empty:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然命名空间的这个示例只是将第2层类型的结构移入了一个命名空间，但它们还支持每个命名空间具有唯一路由表实例的第3层路由。例如，如果我们查看其中一个命名空间的路由表，我们会发现它是完全空的：
- en: '[PRE71]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is because we don't have any interfaces with IP addresses defined in the
    namespace. This demonstrates that both layer 2 and layer 3 constructs are isolated
    within a namespace. That's one major area where network namespaces and VRF instances
    differ. VRF instances only account for layer 3 configuration, whereas network
    namespaces isolate both layer 2 and layer 3 constructs. We'll see an example of
    layer 3 isolation with network namespaces in [Chapter 3](ch03.html "Chapter 3. User-Defined
    Networks"), *User-Defined Networks*, when we discuss the process Docker uses for
    networking containers.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在命名空间中没有定义IP地址的接口。这表明命名空间内部隔离了第2层和第3层结构。这是网络命名空间和VRF实例之间的一个主要区别。VRF实例只考虑第3层配置，而网络命名空间隔离了第2层和第3层结构。在[第3章](ch03.html
    "第3章。用户定义的网络")中，当我们讨论Docker用于容器网络的过程时，我们将在*用户定义的网络*中看到网络命名空间中的第3层隔离的示例。
