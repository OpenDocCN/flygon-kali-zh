- en: Combining Node.js with the Frontend
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 将Node.js与前端结合
- en: Now that we know about frontend frameworks and Node.js, let's wire together
    both the ends. We'll build three small applications for (almost) full-stack functionality
    to demonstrate our knowledge. After all, the frontend and backend want to know
    each other! It's going to be our first foray into working with these technologies
    together, so be sure to give yourself space and time to learn, because these are
    heavy but extremely important topics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了前端框架和Node.js，让我们将两端连接起来。我们将构建三个小应用程序，以演示我们的知识几乎实现全栈功能。毕竟，前端和后端都想要彼此了解！这将是我们首次尝试同时使用这些技术，所以一定要给自己足够的空间和时间来学习，因为这些是重要但非常重的话题。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the architecture handshake
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解架构握手
- en: 'The frontend and Node.js: React and image upload'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端和Node.js：React和图像上传
- en: Creating a recipe book with APIs and JSON
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用API和JSON创建食谱书
- en: Making a restaurant database with Yelp and Firebase
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Yelp和Firebase创建餐厅数据库
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Be prepared to work with the code provided in the `Chapter-15` directory of
    the repository: [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15).
    As we''ll be working with command-line tools, also have your Terminal or command-line
    shell available. We''ll need a modern browser and a local code editor.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好使用存储库的`Chapter-15`目录中提供的代码：[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15)。由于我们将使用命令行工具，还要准备好您的终端或命令行shell。我们需要一个现代浏览器和一个本地代码编辑器。
- en: Understanding the architecture handshake
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解架构握手
- en: Now that we've had experience with JavaScript both on the frontend and the backend
    with Node.js, let's discuss what it really *means* to have the two halves tied
    together. We know that JavaScript on the frontend is great for user interactions,
    visuals, data validation, and other user-experience related pieces. Node.js on
    the backend is a powerful server-side language that helps us do pretty much anything
    we need from most other server-side languages. So, what does combining these two
    ends look like in theory?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们在前端和后端都有了JavaScript的经验，让我们讨论一下将这两个部分绑在一起到底意味着什么。我们知道前端的JavaScript非常适合用户交互、视觉、数据验证和其他与用户体验相关的部分。后端的Node.js是一个强大的服务器端语言，可以帮助我们做几乎任何其他服务器端语言需要做的事情。那么，理论上将这两端结合起来是什么样子呢？
- en: 'You may be wondering why there even *are *two ends of an application. We understand
    that PythonNode.js, and JavaScript all do different tasks and act in either the
    frontend or the backend, but what is the theory behind this? The answer is this:
    there is a principle of software engineering known as the *separation of concerns*,
    which basically states that each piece of a program should do one or a few tasks
    and do them well. Instead of a monolithic application, the idea of a modular system
    that reacts well to scale is, in practice, a more efficient system. In this chapter,
    we''ll be creating three applications that use this principle.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想知道为什么一个应用程序会有*两端。我们知道Python、Node.js和JavaScript都执行不同的任务，并且在前端或后端执行，但背后的理论是什么？答案是：软件工程中有一个被称为*关注分离*的原则，基本上是指程序的每个部分应该做一项或几项任务，并且做得很好。与其使用单片应用程序，实际上，一个对规模有良好反应的模块化系统的概念更高效。在本章中，我们将创建三个应用程序来使用这个原则。
- en: The frontend and Node.js - React and image upload
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端和Node.js - React和图像上传
- en: 'Let''s begin with tying together React and Node. Be prepared to follow along
    with the solution code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album).
    We''re going to build a photo album app that will look something like this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从将React和Node绑定在一起开始。准备好跟随解决方案代码一起进行，网址是[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/photo-album)。我们将构建一个类似于这样的相册应用程序：
- en: '![](assets/56812bfe-0905-4732-8d60-6ba855c16ae1.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/56812bfe-0905-4732-8d60-6ba855c16ae1.png)'
- en: Figure 15.1 - Our photo gallery
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - 我们的相册
- en: We'll begin by exploring the architectural layout, then we'll review the React
    code, and finally we'll examine the Express backend.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探索架构布局，然后我们将审查React代码，最后我们将检查Express后端。
- en: Architecture
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 架构
- en: 'This application will be built using Node.js on the backend to store our uploaded
    files and React on the frontend. But how do we do that? Conceptually, we need
    to tell React to use an Express app to feed React information and to consume the
    files that we have sent. To accomplish this, we use a *proxy* as defined in the
    `package.json` file. It basically looks something like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序将使用后端的Node.js来存储我们上传的文件，并在前端使用React。但是我们该如何做呢？从概念上讲，我们需要告诉React使用Express应用程序来提供React信息并消耗我们发送的文件。为了实现这一点，我们在`package.json`文件中使用了一个*代理*。它基本上看起来像这样：
- en: '![](assets/c279a2d6-5c0c-49da-8b52-784590d62225.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c279a2d6-5c0c-49da-8b52-784590d62225.png)'
- en: Figure 15.2 - Proxying
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 代理
- en: 'If you''re not familiar with the idea of a proxy, essentially it means, in
    computing, the same thing that it does in English: an actor that does an action
    on behalf of another actor. It''s, in essence, a middleman, and as this diagram
    shows it can be thought of as a middleman for our purposes. Since React and frontend
    JavaScript can''t interact with the filesystem or do the other important things
    we learned about in [Chapter 12](e48b0352-8340-4645-8a70-8ca96199a6fa.xhtml),
    *Node.js vs Python*, and [Chapter 13](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml), *Using
    Express,* we need to use our abilities to tie *together* the frontend and backend.
    Hence, the idea of a proxy.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对代理的概念不熟悉，基本上它在计算中的意思与英语中的意思相同：一个代理人代表另一个代理人执行操作。它本质上是一个中间人，正如这个图表所示，它可以被认为是我们目的的中间人。由于React和前端JavaScript无法与文件系统交互或执行我们在[第12章](e48b0352-8340-4645-8a70-8ca96199a6fa.xhtml)中学到的其他重要操作，*Node.js
    vs Python*，以及[第13章](57b3ea57-b927-47f6-b07e-d1dd11796e1a.xhtml) *使用Express*，我们需要使用我们的能力将前端和后端*连接*在一起。因此，代理的概念。
- en: 'Let''s look at one line in `package.json`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`package.json`中的一行：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What this is telling React to do is route certain requests to our Express application.
    If you''re following along with the code from GitHub, this means that we actually
    have to execute a few different `npm` commands:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉React将某些请求路由到我们的Express应用程序。如果您正在从GitHub上跟随代码，这意味着我们实际上需要执行一些不同的`npm`命令：
- en: 'First, install the packages for Express. Start in the `photo-album` directory:
    `npm install`.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`photo-album`目录中安装Express的包：`npm install`。
- en: 'Begin the Express server: `npm start`.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Express服务器：`npm start`。
- en: In another terminal window, `cd` into the `client` directory and run `npm install`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，`cd`进入`client`目录并运行`npm install`。
- en: Now, begin the React app with `npm start`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`npm start`启动React应用程序。
- en: When we access `http://localhost:3000`, we have our Photo Album app ready to
    use. Try uploading a photo by selecting a file and clicking Upload. The UI will
    also refresh and display the photo you just uploaded. Congratulations! It's an
    end-to-end application!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们访问`http://localhost:3000`时，我们的相册应用程序已经准备好使用。尝试通过选择文件并点击上传来上传照片。UI也会刷新并显示您刚刚上传的照片。恭喜！这是一个端到端的应用程序！
- en: So what is this code doing? Let's dissect it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这段代码在做什么呢？让我们来分析一下。
- en: First, we'll look at the JavaScript.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们来看一下JavaScript。
- en: Investigating the React JSX
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查React JSX
- en: 'Open `client/src/components/upload/Upload.jsx`. We''ll start by examining the
    contents of the `render()` method:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`client/src/components/upload/Upload.jsx`。我们将首先检查`render()`方法的内容：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Great, it''s a basic HTML form. The only parts of this that are React-specific
    are the click handlers. Let''s look at the `onClick` method for the form: `this.uploadForm`.
    If we look at that method, we''ll see the real functionality of our upload form:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，这是一个基本的HTML表单。这个表单中唯一与React相关的部分是点击处理程序。让我们看一下表单的`onClick`方法：`this.uploadForm`。如果我们查看该方法，我们将看到我们上传表单的真正功能：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Are you ready to look at the Node.js Express routes?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您准备好查看Node.js Express路由了吗？
- en: Deciphering the Express application
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解密Express应用程序
- en: 'Open `routes/upload.js`. It''s fairly simple:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`routes/upload.js`。它非常简单：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: To make our lives a little easier, we're using a form handler package called
    Formidable. When a POST request comes through to the `/upload` endpoint, it's
    going to run this code. When a form is received via Ajax, our promises are listening
    for files and will trigger the `fileBegin` and `file` events that will write the
    file to disk and then signal success, respectively. This is the method that our
    upload form used in `Upload.jsx` and how the two sides of our application are
    tied together to do something that JavaScript on the frontend can't do alone—access
    the filesystem of a server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生活变得更轻松，我们使用了一个名为Formidable的表单处理程序包。当通过Ajax收到POST请求到`/upload`端点时，它将运行此代码。当通过Ajax接收到表单时，我们的承诺会监听文件并触发`fileBegin`和`file`事件，这将把文件写入磁盘，然后发出成功信号。这是我们在`Upload.jsx`中使用的上传表单的方法，以及我们的应用程序的两个方面如何联系在一起，以执行前端JavaScript无法单独执行的操作——访问服务器的文件系统。
- en: 'Upload a few images with the frontend. You''ll notice that they''ll be stored
    in `public/images`, just as we read in our code. Note that this system is very
    simplistic: it does not check to see if it''s an image file and blindly accepts
    what we send to it and stores it in the filesystem. In practice, **this is dangerous**.
    When working with user input, it is *always* necessary to anticipate attacks and
    possibly malicious files. While the methods of securing your web application are
    somewhat out of the scope of this book, a general tenet to keep in mind is: *don''t
    trust the user*. We''ve examined methods to validate input on the frontend, and
    while that''s useful, it''s vital to also check it on the backend. Some possible
    methods of threat reduction would be to whitelist certain file extensions, blacklist
    others, and use a sandboxed environment to run analysis code on the uploaded file
    to determine if, in fact, it is a harmless image file.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前端上传几张图片。您会注意到它们将存储在`public/images`中，就像我们在代码中读到的那样。请注意，这个系统非常简单：它不会检查是否是图像文件，而是盲目地接受我们发送的内容并将其存储在文件系统中。在实践中，**这是危险的**。在处理用户输入时，*始终*需要预防攻击和可能的恶意文件。虽然保护您的Web应用程序的方法有些超出了本书的范围，但需要牢记的一个基本原则是：*不要相信用户*。我们已经研究了在前端验证输入的方法，虽然这很有用，但在后端也检查它同样重要。一些可能的威胁减少方法包括列出某些文件扩展名，黑名单其他文件扩展名，并使用沙盒环境来运行上传文件的分析代码，以确定它是否是无害的图像文件。
- en: 'Now that we''ve uploaded our image, let''s move on to the retrieval aspect
    of our application. Open `routes/gallery.js`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经上传了我们的图片，让我们继续进行应用程序的检索方面。打开`routes/gallery.js`：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Hopefully, this isn't too difficult to decipher. In our GET route, we're first
    examining the filesystem to see if there are files that we have access to. If
    there's an error for some reason, such as incorrect permissions, we're going to
    send an error to the frontend and abort. Otherwise, we're going to format our
    return data and send it! Easy peasy.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这不会太难解释。在我们的GET路由中，我们首先检查文件系统，看看我们是否可以访问文件。如果出现某种原因的错误，比如权限不正确，我们将向前端发送错误并中止。否则，我们将格式化我们的返回数据并发送！非常简单。
- en: 'Our next method defines the DELETE functionality, and it''s a simple filesystem
    unlink method. The frontend for this isn''t very sophisticated: if you click an
    image in our gallery, it will delete the photo. Of course, in practice, you''d
    want some sort of better user interface and confirmation messages, but for our
    purposes, this is sufficient.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个方法定义了DELETE功能，它是一个简单的文件系统unlink方法。这个功能的前端并不是很复杂：如果你点击我们画廊中的一张图片，它将删除这张照片。当然，在实践中，你可能希望有一些更好的用户界面和确认消息，但对于我们的目的来说，这已经足够了。
- en: Welcome to your first end-to-end application!
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到你的第一个端到端应用程序！
- en: Onward to our next application!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 继续进行我们的下一个应用程序！
- en: Creating a recipe book with APIs and JSON
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用API和JSON创建食谱
- en: 'Part of the beauty of using a backend is to facilitate communication between
    your application, the filesystem, and APIs. Previously, all the work we did was
    constrained to the frontend with no persistence. We''ll now make a recipe book
    application that saves our information in JSON format. Don''t worry, we''ll get
    to using databases in [Chapter 18](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml),
    *Node.js and MongoDB*. For now, we''ll use local files. Here''s what we''re going
    to build:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用后端的美妙之一是促进应用程序、文件系统和API之间的通信。以前，我们所做的所有工作都局限于前端，没有持久性。现在我们将制作一个食谱应用程序，以JSON格式保存我们的信息。别担心，我们将在[第18章](b36b27d1-f6cf-4382-ac73-f21a1aeabd3d.xhtml)中使用数据库，*Node.js和MongoDB*。现在，我们将使用本地文件。这是我们要构建的内容：
- en: '![](assets/9a54d97b-58a7-4f23-8ffa-b4afb26f54c3.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9a54d97b-58a7-4f23-8ffa-b4afb26f54c3.png)'
- en: Figure 15.3 - Our recipe book
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3 - 我们的食谱册
- en: To get started, we'll be setting up credentials using a third-party API and
    then forge onward with the code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用第三方API设置凭据，然后继续编写代码。
- en: Setting up the application
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: Clone the starter code at [https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/).
    Be sure to execute `npm install` both in that directory and inside `client`. We'll
    also need to do a few setup pieces to access our API. To access the Edamam API,
    sign up for a free API key at [https://developer.edamam.com/](https://developer.edamam.com/)
    for the Recipe Search API.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/](https://github.com/PacktPublishing/Hands-on-JavaScript-for-Python-Developers/tree/master/chapter-15/recipe-book/)上克隆起始代码。确保在该目录和`client`内执行`npm
    install`。我们还需要做一些设置来访问我们的API。要访问Edamam API，请在[https://developer.edamam.com/](https://developer.edamam.com/)注册免费API密钥以获取食谱搜索API。
- en: 'At the root level of our project, create a `.env` file and populate it as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的根目录，创建一个`.env`文件，并填写如下内容：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that these are constructed as environment variables and don't have semicolons
    or spaces.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些都是构造为环境变量，没有分号或空格。
- en: 'The next step we''ll do is ensure our application can read these variables.
    Near the end of `app.js`, you''ll see this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的一步是确保我们的应用程序可以读取这些变量。在`app.js`的末尾附近，你会看到这个：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This construction of `process.env.<variable name>` is how we access the environment
    variables in `.env`. The mechanism that provides this access is the `dotenv` package;
    you can see that it's included in `package.json`; environment variables in a file
    aren't included by default.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.env.<variable name>`的构造方式是我们如何访问`.env`中的环境变量的。提供这种访问的机制是`dotenv`包；你可以看到它包含在`package.json`中；文件中的环境变量默认情况下不包括在内。'
- en: Why are we using an environment file? As we'll learn in [Chapter 17](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml),
    *Security and Keys*, we don't want to expose our API keys in our code that we
    may commit to GitHub or similar, because that would allow anyone to use (and abuse)
    our keys. We must keep them secure, and if you noticed in the `.gitignore` file,
    I've listed the `.env` to *not* be committed in Git, which is why you had to create
    the file yourself. This is a best practice for sensitive information. While it
    can make sharing code between developers a bit trickier, it's always best to keep
    sensitive information separate from our code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要使用环境文件？正如我们将在[第17章](655b37ac-84df-4d2b-abda-b9c88fe9f6f2.xhtml)中学到的那样，*安全和密钥*，我们不希望在我们可能提交到GitHub或类似平台的代码中暴露我们的API密钥，因为那样会允许任何人使用（和滥用）我们的密钥。我们必须保持它们的安全性，如果你注意到`.gitignore`文件中，我已经列出了`.env`不要在Git中提交，这就是为什么你必须自己创建这个文件。这是敏感信息的最佳实践。虽然这可能会使开发人员之间共享代码变得有点棘手，但最好还是将敏感信息与我们的代码分开。
- en: Let's test our API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试我们的API。
- en: Testing the API
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试API
- en: 'If you read through `routes/tests.js`, you can see what exactly we''re doing:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你阅读`routes/tests.js`，你可以看到我们到底在做什么：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our `fetch` call is hardcoded to search `cheesecake` (my favorite dessert… ask
    me for my recipe) and if we run it with `node routes/tests.js`, we'll see a bunch
    of JSON returned in the console. If you have any problems, be sure to check your
    API key.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fetch`调用是硬编码为搜索`cheesecake`（我最喜欢的甜点...问我食谱），如果我们用`node routes/tests.js`运行它，我们将在控制台中看到一堆JSON返回。如果你遇到任何问题，请确保检查你的API密钥。
- en: Diving into the code
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入代码
- en: 'Now that we know our API calls are working, let''s switch over to our frontend.
    Take a peek at `client/src/components/search/Search.jsx` and its `render` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道我们的API调用是有效的，让我们切换到我们的前端。看一下`client/src/components/search/Search.jsx`及其`render`函数：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s a simple form so far. Next, let''s look at the `submitSearch` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这是一个简单的表单。接下来，让我们看看`submitSearch`方法：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Again, we''re going to use our proxy to submit our search from the form. After
    we get our results, we''re passing the JSON to the `handleSearchResults` method
    from the `props` that come from the parent component: `RecipeBook`. We''ll take
    a look at that later, but for now, let''s switch back to the Express application
    to look at what our search route is doing. Take a peek at `routes/search.js`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次使用代理来从表单提交我们的搜索。在获得结果后，我们将JSON传递给来自父组件`RecipeBook`的`props`的`handleSearchResults`方法。我们稍后会看一下，但现在让我们切换回Express应用程序，看看我们的搜索路由在做什么。看一下`routes/search.js`。
- en: 'The GET route is quite simple, actually:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: GET路由实际上非常简单：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This should look a little similar to our test file. We''re using our `.env`
    file again for our search queries but this time we''re passing in the query string
    parameter for our search and handling errors. Our `data.on("end")` handler passes
    our results back to React to be used in `RecipeBook.jsx` in the `handleSearchResults`
    method:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来有点类似于我们的测试文件。我们再次使用我们的`.env`文件来进行搜索查询，但这次我们传递了查询字符串参数进行搜索并处理错误。我们的`data.on("end")`处理程序将我们的结果传递回React，以便在`RecipeBook.jsx`中使用`handleSearchResults`方法：
- en: '[PRE11]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We're parsing out the necessary data for our application and assigning it to
    the component's state. So far so good!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在解析出我们应用程序所需的数据，并将其分配给组件的状态。到目前为止一切顺利！
- en: 'Next comes the recipe book''s `render` method for displaying our search results:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是食谱书的`render`方法，用于显示我们的搜索结果：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We're using another ternary operator to conditionally render our results, if
    there are any, as a `<Recipe>` component. Our key attribute is simply a unique
    identifier that React wants items to have, but the `refresh` prop is an interesting
    one. Let's see where it's used by looking at the `Recipe` component.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用另一个三元运算符来有条件地呈现我们的结果，如果有的话，作为`<Recipe>`组件。我们的key属性只是React希望项目具有的唯一标识符，但`refresh`属性是一个有趣的属性。让我们看看它在`Recipe`组件中是如何使用的。
- en: 'The `render` method of our `Recipe` component is fairly standard: it uses a
    few Bootstrap components to render our nice little cards, but other than that
    it is unremarkable. The `save` method is what we really want to investigate:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Recipe`组件的`render`方法相当标准：它使用一些Bootstrap组件来呈现我们漂亮的小卡片，但除此之外并不引人注目。`save`方法才是我们真正想要调查的内容：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `const recipe` declaration may look a little strange, so let's unpack it.
    This is creating an object key/value pair, and for the key, we're using the recipe's
    title. Because it's a variable, we want to use square brackets to denote that
    it should be interpreted. We can't use a dot-property as a key, so our title will
    be a string.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`const recipe`声明可能看起来有点奇怪，让我们来解开它。这是创建一个对象键/值对，对于键，我们使用了食谱的标题。因为它是一个变量，我们希望使用方括号来表示它应该被解释。我们不能使用点属性作为键，所以我们的标题将是一个字符串。'
- en: 'Here''s an example of what a recipe in that construction may look like:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构造中食谱的示例可能是这样的：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It has all the information we specified before when we mapped together our object
    in `RecipeBook.jsx`. The next step in our process is saving the recipe to the
    filesystem with another `fetch` request to the Express server.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含了我们之前在`RecipeBook.jsx`中映射对象时指定的所有信息。我们过程的下一步是使用另一个`fetch`请求将食谱保存到文件系统中。
- en: Back to Express we go, this time to `routes/recipes.js`!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Express，这次是到`routes/recipes.js`！
- en: 'Let''s look at the file part by part. Outside of our Express methods, we have
    a `readData` method, which checks to see if our `recipes.json` file exists:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐部分查看文件。在我们的Express方法之外，我们有一个`readData`方法，它检查我们的`recipes.json`文件是否存在：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If it does not, it creates a file containing an empty array. Then it returns
    the contents of the file, whether empty or not, to the calling function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有，它将创建一个包含空数组的文件。然后将文件的内容（无论是空的还是非空的）返回给调用函数。
- en: 'Our GET method consumes the data from `readData` and sends it in the response,
    in this case to `RecipeBook.jsx`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GET方法从`readData`中消耗数据，并将其发送到响应中，这次是到`RecipeBook.jsx`：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The second part of the `RecipeBook.render` method (which we didn't look at)
    is similar to the search results JSX, and it consumes this JSON.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecipeBook.render`方法的第二部分（我们没有看到）类似于搜索结果的JSX，并且消耗了这个JSON。'
- en: 'Our `save` method has a resemblance to our `readData` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`save`方法与我们的`readData`方法有些相似：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that it's also sending the JSON to the response so that when the item
    is saved, it also populates the saved recipes in `RecipeBook.jsx`. It probably
    goes without saying, but notice that we're using the `readData` method again instead
    of rewriting the same logic, keeping our code DRY.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它还将JSON发送到响应，因此当项目保存时，它还会在`RecipeBook.jsx`中填充保存的食谱。可能不用说，但请注意我们再次使用`readData`方法，而不是重写相同的逻辑，使我们的代码保持DRY。
- en: 'And that''s the logic of our application! We''ve successfully combined an API,
    Node.js, Express, and React for an end-to-end application. Next, we''ll create
    an application that is a bit more true to life: we''re going to create a restaurant
    searching application that saves to a cloud database that''s accessible through
    JavaScript.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们应用程序的逻辑！我们成功地将API、Node.js、Express和React组合成了一个端到端的应用程序。接下来，我们将创建一个更符合实际的应用程序：我们将创建一个餐厅搜索应用程序，将其保存到一个云数据库中，并通过JavaScript访问。
- en: Making a restaurant database with Yelp and Firebase
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Yelp和Firebase创建餐厅数据库
- en: Our applications up to this point have been fairly simple, storing information
    on the filesystem. However, in most cases you'll want it to be some sort of database
    instead of static files. We're going to be using Firebase, a cloud-based NoSQL
    database that plays well with JavaScript, but first, let's set up our React scaffold.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的应用程序相当简单，只是在文件系统上存储信息。然而，在大多数情况下，您可能希望它是某种数据库，而不是静态文件。我们将使用Firebase，这是一个与JavaScript兼容良好的基于云的NoSQL数据库，但首先让我们设置React脚手架。
- en: The starting line - creating a React app
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始行 - 创建一个React应用程序
- en: 'We''ve gone through this setup a few times before, so it should be no surprise:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经进行了几次这样的设置，所以这应该不足为奇：
- en: Create a new React application with `npx create-react-app restaurant-finder`
    and we're ready to go!
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npx create-react-app restaurant-finder`创建一个新的React应用程序，我们准备好了！
- en: Test your setup with `npm start` and access `http://localhost:3000`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`测试您的设置，并访问`http://localhost:3000`。
- en: Getting set up with Firebase
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Firebase进行设置
- en: The first thing we want to do is set up our Firebase account.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是设置我们的Firebase帐户。
- en: 'Please keep in mind that the user interface for Firebase (as with most websites)
    does change periodically, so I won''t be showing you screenshots for the signup
    process. If you run into any problems with the setup process, you can consult
    the documentation. Here''s the steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Firebase的用户界面（与大多数网站一样）会定期更改，因此我不会为注册过程向您展示截图。如果您在设置过程中遇到任何问题，可以查阅文档。以下是步骤：
- en: Go to [https://firebase.google.com](https://firebase.google.com).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://firebase.google.com](https://firebase.google.com)。
- en: If you don't already have a Google account, you'll need to create one and then
    access the Console.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有Google帐户，您需要创建一个，然后访问控制台。
- en: Create a new project called `restaurant-database`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`restaurant-database`的新项目。
- en: You can choose to enable Google Analytics for the project; it's up to you.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以选择为项目启用Google Analytics；这取决于您。
- en: On the Project Overview page, we're going to use the </> button to access the
    setup instructions for a web app.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目概述页面上，我们将使用</>按钮访问网页应用程序的设置说明。
- en: On the next screen, create an app nickname (you can use `restaurant-database`
    again) and you won't need to set up Firebase Hosting.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，创建一个应用程序昵称（您可以再次使用`restaurant-database`），您不需要设置Firebase Hosting。
- en: 'The next screen will present you with code that contains your Firebase configuration,
    but *we''re not going to follow the instructions to the letter* because we can
    use Node modules to help us! Do copy the information in the `firebaseConfig` variable,
    though: we''ll need it later.'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个屏幕将向您显示包含您的Firebase配置的代码，但*我们不会完全按照说明进行*，因为我们可以使用Node模块来帮助我们！不过，请复制`firebaseConfig`变量中的信息：我们以后会用到它。
- en: When your database is created, go to the Database tab in the UI, select Realtime
    Database, and start it in **test mode**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的数据库创建好后，转到UI中的数据库选项卡，选择实时数据库，并在**测试模式**下启动它。
- en: 'You should then see a screen similar to this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您应该看到类似于这样的屏幕：
- en: '![](assets/632bcc84-7961-490e-95f8-7b546c4edea7.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/632bcc84-7961-490e-95f8-7b546c4edea7.png)'
- en: Figure 15.4 - Firebase's base test mode view
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4 - Firebase的基本测试模式视图
- en: 'Next, we''re going to return to our command line and get ready to work with
    Firebase. Install the Firebase toolkit: `npm install firebase`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将返回到命令行，并准备好使用Firebase。安装Firebase工具包：`npm install firebase`。
- en: 'That''s it for installation! Easy! Next, create a `.env` file at the root of
    our project and enter the credentials that you previously copied from `firebaseConfig`,
    similar to this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 安装就是这样！接下来，在我们项目的根目录创建一个`.env`文件，并输入您之前从`firebaseConfig`中复制的凭据，类似于这样：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note the prefix of `REACT_APP_`, the equals signs, quotes, and lack of trailing
    commas. Fill in your configuration similarly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意`REACT_APP_`的前缀，等号，引号和缺少尾随逗号。填写您的配置类似。 '
- en: Before we move further, let's test our database.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步之前，让我们测试我们的数据库。
- en: Testing our database
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试我们的数据库
- en: 'Now we''re going to create a couple React components. Create a `components`
    directory in `src` and within that, two directories named `database` and `finder`.
    We''ll start by creating our database reference:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一些React组件。在`src`中创建一个`components`目录，在其中创建两个名为`database`和`finder`的目录。我们将首先创建我们的数据库引用：
- en: 'In the database directory, create a `database.js` file. Note that it''s `js`,
    not `jsx`, because we''re not actually going to render any data. Instead, we''re
    going to return a variable to a `jsx` component. Your file should look like this:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数据库目录中，创建一个`database.js`文件。请注意，它是`js`，而不是`jsx`，因为我们实际上不会渲染任何数据。相反，我们将返回一个变量给`jsx`组件。您的文件应该如下所示：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the prefix of `process.env` on each variable as well as the trailing commas. `process.env`
    specifies that the application should look at environment variables provided by `dotenv`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每个变量上的`process.env`前缀以及尾随逗号。`process.env`指定应用程序应查看`dotenv`提供的环境变量。
- en: 'Next, we have`Finder.jsx`. Create this file in the `finder` directory:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有`Finder.jsx`。在`finder`目录中创建此文件：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Our `App.js` file will look like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`App.js`文件将如下所示：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, since we've just created our environment variables, we'll need to stop
    and start our React application again. This is not necessary for most of our React
    work, but it is necessary here.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，由于我们刚刚创建了我们的环境变量，我们需要停止并重新启动我们的React应用程序。这对于我们大部分的React工作来说并不是必需的，但在这里是必需的。
- en: 'Go ahead and access the app at `http://localhost:3000`. We should see just
    Let''s find some restaurants on the page, but if we go to Firebase, we''ll see
    this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续访问`http://localhost:3000`上的应用程序。我们应该只在页面上看到“让我们找一些餐馆”，但是如果我们转到Firebase，我们会看到这个：
- en: '![](assets/960f56b9-f09c-454b-9771-c6634fc3f876.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/960f56b9-f09c-454b-9771-c6634fc3f876.png)'
- en: Figure 15.5 - We have data in Firebase!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5 - 我们在Firebase中有数据！
- en: The data appears to be truncated, but you can click on it and see the whole
    statement.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 数据似乎被截断了，但您可以单击它并查看整个语句。
- en: Huzzah! We have Firebase working. Now for the rest of our application.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 万岁！我们的Firebase正在运行。现在是我们应用程序的其余部分。
- en: Creating our app
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'We can remove the test insertion from `Finder.jsx`. Here''s what we''re going
    to be making:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从`Finder.jsx`中删除测试插入。这就是我们要做的事情：
- en: '![](assets/9e9c5a56-053f-4a6d-a7c5-c970353ec85b.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9e9c5a56-053f-4a6d-a7c5-c970353ec85b.png)'
- en: Figure 15.6 - Restaurant finder
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6 - 餐厅查找器
- en: To accomplish this, we're going to be using the Yelp API. First of all, you'll
    need to go to [https://www.yelp.com/developers](https://www.yelp.com/developers)
    and sign up for a Yelp Fusion API key. Once you have it, we're going to store
    it in a new `.env` file in a new `api` directory.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将使用Yelp API。首先，您需要转到[https://www.yelp.com/developers](https://www.yelp.com/developers)并注册Yelp
    Fusion API密钥。一旦您拥有它，我们将把它存储在一个新的`.env`文件中的新`api`目录中。
- en: The Yelp Fusion API is not available in all countries, so if you cannot access
    it, please look in `Chapter-15` folder on GitHub for an alternative API usage
    example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Yelp Fusion API并不在所有国家/地区都可用，所以如果你无法访问它，请在GitHub的`Chapter-15`文件夹中寻找替代API使用示例。
- en: 'The Yelp API is a REST API and doesn''t allow connections from frontend JavaScript
    in order to protect your keys. So, like our recipe book, we''re going to create
    a small API layer to handle our requests. Unlike our recipe book, this will be
    fairly simple, so we''re not going to use Express. Let''s look at the steps:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Yelp API是一个REST API，不允许来自前端JavaScript的连接，以保护你的密钥。因此，就像我们的食谱书一样，我们将创建一个小的API层来处理我们的请求。不同于我们的食谱书，这将会相当简单，所以我们不会使用Express。让我们看看步骤：
- en: 'At the root level of your project, we''re going to install a few tools for
    us to use: `npm install yelp-fusion dotenv react-bootstrap`.'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录，我们将安装一些工具供我们使用：`npm install yelp-fusion dotenv react-bootstrap`。
- en: Create a directory at the root level of your project called `api` and create
    an `api.js` file within it.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目的根目录创建一个名为`api`的目录，并在其中创建一个`api.js`文件。
- en: 'We''re going to have a `.env` file inside our `api` directory as well:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也将在我们的`api`目录中有一个`.env`文件：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you're using Git, *don't forget to add this to your* `.gitignore` *entries*.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用Git，*不要忘记将这些添加到*`.gitignore`*条目*。
- en: 'Our `api.js` file will be fairly simple:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`api.js`文件将会相当简单：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'So far, a lot of this should be familiar: we''re going to include a few packages
    such as the Yelp API in the way we''ve done before, and we''re going to define
    a few variables to help us. Next, we''re going to use the `createServer` method
    of `http` to create a very, very simple server to respond to our API requests.
    Inside it, we''re going to use the `parse` method of `url` to get our query string
    parameters which we will be passing to our API.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，很多内容应该都很熟悉：我们将包括一些包，比如之前使用过的Yelp API，我们将定义一些变量来帮助我们。接下来，我们将使用`http`的`createServer`方法创建一个非常简单的服务器来响应我们的API请求。在其中，我们将使用`url`的`parse`方法来获取我们的查询字符串参数，然后将其传递给我们的API。
- en: The next piece, `client.search`, will be unfamiliar. This is pulled from the
    Yelp documentation and is specifically crafted to adhere to their API's requirements.
    Once we have an asynchronous response, we send it back to our requesting application.
    Don't forget to handle errors! Then we start the server on port `3001`. You can
    go ahead and start this server with `node api.js` and you'll see the console error
    message about it running.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分，`client.search`，可能会让人感到陌生。这是从Yelp文档中提取的，专门设计以符合他们API的要求。一旦我们有了异步响应，我们就将其发送回我们的请求应用程序。不要忘记处理错误！然后我们在端口`3001`上启动服务器。你可以使用`node
    api.js`启动这个服务器，然后你会看到关于它运行的控制台错误消息。
- en: 'Let''s now turn our attention to the React portion of our application:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们把注意力转向我们应用程序的React部分：
- en: 'Inside our `src` directory, we''ll have this file structure when we''re complete:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`src`目录中，当我们完成时，将会有这样的文件结构：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Many of these files were already created when we previously scaffolded our application,
    but some parts of the `components` directory are new.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些文件在我们之前搭建应用程序时已经创建好了，但`components`目录的一些部分是新的。
- en: 'Create these files, and we''ll begin by exploring `Restaurant.jsx`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建这些文件，我们将从探索`Restaurant.jsx`开始：
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Most of this isn''t new, and our recipe book''s structure can help us reason
    through this. We should break apart the `saveRestaurant` method, though, because
    it uses a few interesting pieces:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容都不是新的，我们的食谱书的结构可以帮助我们理清思路。不过，我们应该拆分`saveRestaurant`方法，因为它使用了一些有趣的部分：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First of all, we can deduce we'll be getting data from our component's `props`
    of the restaurant. This will be directly from our search results. Because of that,
    we'll need to massage our data just a little bit.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以推断出我们将从组件的`props`中获取餐厅的数据。这将直接来自我们的搜索结果。因此，我们需要稍微处理一下我们的数据。
- en: 'Here''s what a search result may look like from our `props`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从`props`中得到的搜索结果的样子：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We save it to Firebase with the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将其保存到Firebase中：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We're using the *spread operator* (the triple dots) to expand the object into
    its constituent key/value pairs so that we avoid a nested object in our database.
    We also have just a little touch of CSS to format our cards.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*展开运算符*（三个点）来将对象扩展为其组成的键/值对，以避免在我们的数据库中出现嵌套对象。我们还有一点点CSS来格式化我们的卡片。
- en: 'Let''s turn our attention to the `Search` component:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力转向`Search`组件：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In our constructor, we're doing something a little fun: *browser geolocation*.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们做了一些有趣的事情：*浏览器地理定位*。
- en: 'Have you seen those little alert windows on certain websites when they ask
    to know your location? This is how those sites do it. If the browser supports
    geolocation, we''re going to use it and set our latitude and longitude from our
    browser. Otherwise, we''ll simply set it to `null`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否见过某些网站询问你的位置时弹出的小警告窗口？这就是这些网站的做法。如果浏览器支持地理定位，我们将使用它并从浏览器中设置我们的纬度和经度。否则，我们将简单地将其设置为`null`：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The construction of the search endpoint should look familiar:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索端点的构建应该看起来很熟悉：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you progress through our code, if you get a null value for latitude or longitude,
    you may need to fully exit the React application and restart it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在我们的代码中前进时，如果你得到纬度或经度的空值，你可能需要完全退出React应用程序并重新启动它。
- en: 'Similar to how our recipe book called to our Express application over a proxy,
    don''t forget to add this line to your `package.json` file: `"proxy": "http://localhost:3001"`.
    This is so that we can use `fetch`. These are the values we passed into `api.js`
    for our request to the Yelp API.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '类似于我们的食谱书通过代理调用我们的Express应用程序，不要忘记将这行添加到你的`package.json`文件中：`"proxy": "http://localhost:3001"`。这样我们就可以使用`fetch`。这些是我们传递给`api.js`的值，用于向Yelp
    API发送请求。'
- en: 'We''re almost done with our application! Next up is the `Finder` component
    that we started:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序快要完成了！接下来是我们开始的`Finder`组件：
- en: 'First, we have our imports:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有我们的导入：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, we have some pretty standard pieces:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有一些非常标准的部分：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As a new piece, let''s examine how we''re retrieving information from Firebase:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为一个新的部分，让我们来看看我们如何从Firebase中检索信息：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: One of the interesting things about Firebase is that it's a real-time database;
    you don't always have to execute queries against it to retrieve the latest data.
    In this construction, we're telling the database to continually update the state
    of our component as the value of `/restaurants` changes. When we save a new restaurant
    and go to our Saved! tab, we'll see our new entries.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Firebase的一个有趣之处是它是一个实时数据库；你不总是需要执行查询来检索最新的数据。在这个构造中，我们告诉数据库不断更新我们组件的状态，以反映`/restaurants`的值的变化。当我们保存一个新的餐馆并转到我们的“已保存！”选项卡时，我们将看到我们的新条目。
- en: 'We''re bringing it full circle by using our other components here:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里使用了其他组件，将其完整地呈现出来：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When all is complete, we'll keep our `api.js` file running and start our React
    app with `npm start` and our app is complete!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切都完成时，我们将保持我们的`api.js`文件运行，并使用`npm start`启动我们的React应用程序，我们的应用程序就完成了！
- en: It's time to wrap up this chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候结束本章了。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We''ve covered a *lot* of ground in this chapter. The power of JavaScript on
    both the frontend and the backend shows us that we can truly replace Python for
    many of our application needs. We''ve used a lot of React, but keep in mind that
    any frontend can be substituted here: Vue, Angular, and even frameworkless HTML,
    CSS, and JavaScript are at our disposal to create powerful web applications.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容。JavaScript在前端和后端的强大功能向我们展示，我们确实可以用它来满足许多应用程序需求，不仅仅是Python。我们使用了很多React，但请记住，任何前端都可以在这里替代：Vue、Angular，甚至是无框架的HTML、CSS和JavaScript都可以用来创建强大的Web应用程序。
- en: One of the things to note when using JavaScript and APIs is that there are cases
    when we need a middleware layer, for example, when saving files or accessing REST
    APIs with keys. Combining Express for powerful routing with a basic Node.js script
    to interact with an API is just the beginning of what we can accomplish with JavaScript
    and Node.js tied together.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript和API时需要注意的一点是，有些情况下我们需要一个中间件层，例如在保存文件或使用密钥访问REST API时。将Express与基本的Node.js脚本结合起来与API进行交互，这只是JavaScript和Node.js结合所能实现的开始。
- en: In the next chapter, we'll explore webpack, a utility that allows us to logically
    combine and package our JavaScript application for deployment.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨webpack，这是一个工具，允许我们将JavaScript应用逻辑地组合和打包以进行部署。
