["```js\nimport { readFileSync } from 'fs'\nconst count = readFileSync('./input.txt', {encoding : 'utf8'})\n .split(/\\n|\\r\\n/g).length;\nconsole.log('number of lines in our file is: ', count);\n```", "```js\nimport { readFileSync } from 'fs'\nconst file = readFileSync('./input.txt', {encoding : 'utf8'});\nconst re = /\\slorem\\s/gi;\nconst matches = file.match(re);\n\nconsole.log('the number of matches is: ', matches.length);\n```", "```js\nimport { createReadStream } from 'fs';\n\nconst newLine = 0x0A;\nconst readStream = createReadStream('./input.txt');\nlet counter = 1;\nreadStream.on('data', (chunk) => {\n    for(const byte of chunk) {\n        if( newLine === byte ) counter += 1;\n    }\n}).on('end', () => {\n    console.log('number of line in our file is: ', counter);\n});\n```", "```js\nconst stream = createReadStream('./input.txt');\nconst buf = Buffer.from('lorem');\nlet found = 0;\nlet count = 0;\nstream.on('data', (chunk) => {\n    for(const byte of chunk) {\n        if( byte === buf[found] ) {\n            found += 1;\n        } else {\n            found = 0;\n        }\n        if( found === buf.byteLength ) {\n            count += 1;\n            found = 0;\n        }\n    }\n}).on('end', () => {\n    console.log('the number of matches is: ', count)\n});\n```", "```js\nimport { Readable } from 'stream'\nimport { createReadStream } from 'fs'\n```", "```js\nclass LoremFinder extends Readable {\n    #lorem = Buffer.from('lorem');\n    #found = 0;\n    #totalCount = 0;\n    #startByteLoc = -1;\n    #file = null;\n}\n```", "```js\n// inside our LoremFinder class\nconstructor(opts) {\n    super(opts); \n    if(!opts.stream ) { \n        throw new Error(\"This stream needs a stream to be \n         provided!\");\n    }\n    this.#file = opts.stream;\n    this.#file.on('data', this.#data.bind(this)); // will add #data \n     method next\n    this.#file.on('end', () => this.push(null)); \n}\n```", "```js\n// inside of the LoremFinder class\n#data = function(chunk) {\n    for(let i = 0; i < chunk.byteLength; i++) {\n        const byte = chunk[i];\n        if( byte === this.#lorem[this.#found] ) {\n            if(!this.#found ) {\n                this.#startByteLoc = this.#totalCount + i; \n            }\n            this.#found += 1;\n        } else {\n            this.#found = 0;\n        }\n        if( this.#found === this.#lorem.byteLength ) {\n            const buf = Buffer.alloc(4);\n            buf.writeUInt32BE(this.#startByteLoc);\n            this.push(buf);\n            this.#found = 0;\n        }\n    }\n    this.#totalCount += chunk.byteLength;\n}\n```", "```js\n// inside of the LoremFinder class\n_read(size) {\n    this.#file.resume();\n}\n```", "```js\nconst locs = new Set();\nconst loremFinder = new LoremFinder({\n    stream : createReadStream('./input.txt')\n});\nloremFinder.on('data', (chunk) => {\n    const num = chunk.readUInt32BE();\n    locs.add(num);\n});\nloremFinder.on('end', () => {\n    console.log('here are all of the locations:');\n    for(const val of locs) {\n        console.log('location: ', val);\n    }\n    console.log('number of lorems found is', locs.size);\n});\n```", "```js\nimport { Readable } from 'stream';\n\nclass ReadMessagePassStream extends Readable {\n}\n```", "```js\n// inside of the ReadMessagePassStream class\n#socket = null;\n#bufBegin = Buffer.from(\"!!!START!!!\");\n#bufEnd = Buffer.from(\"!!!END!!!\");\n#internalBuffer = [];\n#size = 0;\n```", "```js\n#data = function(chunk) {\n    let i = -1 \n    if((i = chunk.indexOf(this.#bufBegin)) !== -1) {\n        const tempBuf = chunk.slice(i + this.#bufBegin.byteLength);\n        this.#size += tempBuf.byteLength;            \n        this.#internalBuffer.push(tempBuf);\n    }\n    else if((i = chunk.indexOf(this.#bufEnd)) !== -1) {\n        const tempBuf = chunk.slice(0, i);\n        this.#size += tempBuf.byteLength;\n        this.#internalBuffer.push(tempBuf);\n        const final = Buffer.concat(this.#internalBuffer);            \n        this.#internalBuffer = [];\n        if(!this.push(final)) { \n            this.#socket.pause();\n        }\n    } else {\n        this.#size += chunk.byteLength;\n        this.#internalBuffer.push(chunk);\n    }\n}\n```", "```js\nconstructor(options) {\n    if( options.objectMode ) {\n        options.objectMode = false //we don't want it on\n    }\n    super(options);\n    if(!options.socket ) {\n        throw \"Need a socket to attach to!\"\n    }\n    this.#socket = options.socket;\n    this.#socket.on('data', this.#data.bind(this));\n    this.#socket.on('end', () => this.push(null));\n}\n```", "```js\n// inside the ReadMessagePassStream\n_read(size) {\n    this.#socket.resume();\n}\n```", "```js\nimport { createWriteStream } from 'fs';\n\nconst socket = createConnection(3333);\nconst write = createWriteStream('./output.txt');\nconst messageStream = new ReadMessagePassStream({ socket });\nmessageStream.pipe(write);\n```", "```js\nimport { Writable } from 'stream';\n\nexport default class WriteMessagePassStream extends Writable {\n}\n```", "```js\n// inside the WriteMessagePassStream\n#socket = null;\n#writing = false;\nconstructor(options) {\n  if( options.objectMode ) { \n        options.objectMode = false;\n    }\n    if(!options.socket ) {\n        throw new Error(\"A socket is required to construct this \n         stream!\");\n    }\n    super(options);\n    this.#socket = options.socket;\n}\n```", "```js\n_write(chunk, encoding, callback) { \n    if(!this.#writing ) {\n        this.#writing = true;\n        this.#socket.write(\"!!!START!!!\");\n    }\n    let i = -1;\n    let prevI = 0;\n    let numCount = 0;\n    while((i = chunk.indexOf([0x00], i)) !== -1) {\n        const buf = chunk.slice(prevI, i);\n        this.#socket.write(buf);\n        this.#socket.write(\"!!!END!!!\");\n        if( i !== chunk.byteLength - 1 ) {\n            this.#socket.write(\"!!!START!!!\");\n        } else {\n            return callback();\n        }\n        numCount += 1;\n    }\n    if(!numCount ) {\n        this.#socket.write(chunk);\n    }\n    return callback();\n}\n```", "```js\nimport { createServer } from 'net'\nimport WrappedWritableStream from '../writable/main.js'\nconst server = createServer((con) => {\n console.log('client connected. sending test data');\n const wrapped = new WrappedWritableStream({ socket : con });\n for(let i = 0; i < 100000; i++) {\n wrapped.write(`data${i}\\r\\n`);\n }\n wrapped.write(Buffer.from([0x00]));\n wrapped.end();\n console.log('finished sending test data');\n});\nserver.listen(3333);\n```", "```js\nfor(let i = 0; i < 100000; i++) {\n    wrapped.write(`more_data${i}\\r\\n`);\n}\nwrapped.write(Buffer.from([0x00]));\n```", "```js\nimport { Duplex } from 'stream';\n\nexport default class MessageTranslator extends Duplex {\n}\n```", "```js\n// inside the MessageTranslator class\n#socket = null;\n#internalWriteBuf = new Map();\n#internalReadHoldBuf = [];\n#internalPacketNum = 0;\n#readSize = 0;\n#writeCounter = 0;\n```", "```js\n// inside the MessageTranslator class\nconstructor(opts) {\n    if(!opts.socket ) {\n        throw new Error(\"MessageTranslator stream needs a \n         socket!\");\n    }\n    super(opts);\n    this.#socket = opts.socket;\n    // we are assuming a single message for each chunk\n    this.#socket.on('data', (chunk) => {\n        if(!this.#readSize ) {\n            this.#internalPacketNum = chunk.readInt32BE();\n            this.#readSize = chunk.readInt32BE(4);\n            this.#internalReadHoldBuf.push(chunk.slice(8));\n            this.#readSize -= chunk.byteLength - 8\n        } else {\n            this.#internalReadHoldBuf.push(chunk);\n            this.#readSize -= chunk.byteLength;\n        }\n        // reached end of message\n        if(!this.#readSize ) {\n            this.push(Buffer.concat(this.#internalReadHoldBuf));\n            this.#internalReadHoldBuf = [];\n        }\n    });\n}\n```", "```js\n// inside the MessageTranslator class\n_writev(chunks, cb) { \n    for(const chunk of chunks) {\n        this.#processChunkHelper(chunk); //shown next\n    }\n    this.#writeHelper(cb); //shown next\n}\n_write(chunk, encoding, cb) {\n    this.#processChunkHelper(chunk); //shown next\n    this.#writeHelper(cb); //shown next\n}\n```", "```js\n// inside the MessageTranslator class\n#processChunkHelper = function(chunk) {\n    if(chunk.readInt32BE() === -1) { \n        this.#internalWriteBuf.get(this.#writeCounter).done = true;\n        this.#writeCounter += 1;\n        this.#internalWriteBuf.set(this.#writeCounter, {buf : [], \n         done : false});\n    } else {\n        if(!this.#internalWriteBuf.has(this.#writeCounter)) {\n            this.#internalWriteBuf.set(this.#writeCounter, {buf : \n             [], done : false}); }\n            this.#internalWriteBuf.get(this.#writeCounter)\n             .buf.push(chunk);\n        }\n    }\n}\n#writeHelper = function(cb) {\n    const writeOut = [];\n    for(const [key, val] of this.#internalWriteBuf) { \n        if( val.done ) {\n            const cBuf = Buffer.allocUnsafe(4);\n            const valBuf = Buffer.concat(val.buf);\n            const sizeBuf = Buffer.allocUnsafe(4);\n            cBuf.writeInt32BE(valBuf.readInt32BE());\n            sizeBuf.writeInt32BE(valBuf.byteLength - 4);\n            writeOut.push(Buffer.concat([cBuf, sizeBuf, \n             valBuf.slice(4)]));\n            val.buf = [];\n        }\n    }\n    if( writeOut.length ) {\n        this.#socket.write(Buffer.concat(writeOut));\n    }\n    cb();\n}\n```", "```js\n// inside the MessageTranslator class\n_read() {\n    this.#socket.resume();\n}\n_final(cb) {\n    cb(); // nothing to do since it all should be consumed at this \n          // point\n}\n```", "```js\n// implemented in stream form from \n// https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript\nexport default class StreamHashCreator extends Transform {\n    #currHash = 0; \n    constructor(options={}) {\n        if( options.objectMode ) {\n            throw new Error(\"This stream does not support object mode!\");\n        }\n        options.decodeStrings = true;\n        super(options);\n    }\n    _transform(chunk, encoding, callback) {\n        if( Buffer.isBuffer(chunk) ) { \n            const str = chunk.toString('utf8');\n            for(let i = 0; i < str.length; i++) {\n                const char = str.charCodeAt(i);\n                this.#currHash = ((this.#currHash << 5) - this.#currHash ) \n                 + char;\n                this.#currHash |= 0;\n            }\n        }\n        callback(); \n    }\n    _flush(callback) {\n        const buf = Buffer.alloc(4);\n        buf.writeInt32BE(this.#currHash);\n        this.push(buf); \n        callback(null);\n    }\n}\n```", "```js\nfunction* handleData() {\n    let _char = 97;\n    while(_char < 123 ) { //char code of 'z'\n        yield String.fromCharCode(_char++);\n    }\n}\n```", "```js\nconst readable = Readable.from(handleData());\nreadable.on('data', (chunk) => {\n    console.log(chunk);\n});\n```", "```js\n(async() => {\n    const readable2 = Readable.from(grabData());\n    const tempFile = createWriteStream('./temp.txt');\n    readable2.pipe(tempFile);\n    await once(tempFile, 'finish');\n    console.log('all done');\n})();\n```"]