- en: Chapter 1. Learning Java 9 Underlying Performance Improvements
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。学习Java 9的底层性能改进
- en: Just when you think you have a handle on lambdas and all the performance-related
    features of Java 8, along comes Java 9\. What follows are several of the capabilities
    that made it into Java 9 that you can use to help improve the performance of your
    applications. These go beyond byte-level changes like for string storage or garbage
    collection changes, which you have little control over. Also, ignore implementation
    changes like those for faster object locking, since you don't have to do anything
    differently and you automatically get these improvements. Instead, there are new
    library features and completely new command-line tools that will help you create
    apps quickly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就在你以为你已经掌握了Java 8的lambda和所有与性能相关的功能时，Java 9就出现了。接下来是Java 9中的一些功能，可以帮助改进应用程序的性能。这些功能超越了像字符串存储或垃圾收集变化这样的字节级变化，这些变化你几乎无法控制。还有，忽略实现变化，比如用于更快的对象锁定的变化，因为你不需要做任何不同的事情，你会自动获得这些改进。相反，有新的库功能和全新的命令行工具，可以帮助你快速创建应用程序。
- en: 'In this lesson, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们将涵盖以下主题：
- en: Modular development and its impact on performance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化开发及其对性能的影响
- en: Various string-related performance improvements, including compact string and
    indify string concatenation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种与字符串相关的性能改进，包括紧凑字符串和字符串连接的改进
- en: Advancement in concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发的进步
- en: Various underlying compiler improvements, such as tiered attribution and **Ahead-of-Time**
    (**AOT**) compilation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种底层编译器改进，如分层归因和**提前编译**（**AOT**）编译
- en: Security manager improvements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全管理器的改进
- en: Enhancements in graphics rasterizers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形光栅化器的增强
- en: Introducing the New Features of Java 9
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Java 9的新功能
- en: In this lesson, we will explore many under the cover improvements to performance
    that you automatically get by just running your application in the new environment.
    Internally, string changes also drastically reduce memory footprint requirements
    for times when you don't need full-scale Unicode support in your character strings.
    If most of your strings can be encoded either as ISO-8859-1 or Latin-1 (1 byte
    per character), they'll be stored much more efficiently in Java 9\. So, let's
    dive deep into the core libraries and learn the underlying performance improvements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课程中，我们将探讨许多在新环境中运行应用程序时自动获得的性能改进。在内部，字符串的改变也大大减少了在不需要完整的Unicode支持的字符字符串时的内存占用。如果你的大部分字符串可以被编码为ISO-8859-1或Latin-1（每个字符1个字节），它们将在Java
    9中存储得更有效。因此，让我们深入研究核心库，并学习底层性能改进。
- en: Modular Development and Its Impact
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化开发及其影响
- en: In software engineering, modularity is an important concept. From the point
    of view of performance as well as maintainability, it is important to create autonomous
    units called **modules**. These modules can be tied together to make a complete
    system. The modules provides encapsulation where the implementation is hidden
    from other modules. Each module can expose distinct APIs that can act as connectors
    so that other modules can communicate with it. This type of design is useful as
    it promotes loose coupling, helps focus on singular functionality to make it cohesive,
    and enables testing it in isolation. It also reduces system complexity and optimizes
    application development process. Improving performance of each module helps improving
    overall application performance. Hence, modular development is a very important
    concept.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，模块化是一个重要的概念。从性能和可维护性的角度来看，创建称为**模块**的自主单元非常重要。这些模块可以被绑定在一起以构建完整的系统。模块提供了封装，其中实现对其他模块隐藏。每个模块可以暴露出不同的API，可以作为连接器，使其他模块可以与之通信。这种设计有助于促进松散耦合，有助于专注于单一功能以使其具有内聚性，并使其能够在隔离环境中进行测试。它还减少了系统复杂性并优化了应用程序开发过程。改进每个模块的性能有助于提高整体应用程序性能。因此，模块化开发是一个非常重要的概念。
- en: I know you may be thinking, wait a minute, isn't Java already modular? Isn't
    the object-oriented nature of Java already providing modular operation? Well,
    object-oriented certainly imposes uniqueness along with data encapsulation. It
    only recommends loose coupling but does not strictly enforce it. In addition,
    it fails to provide identity at the object level and also does not have any versioning
    provision for the interfaces. Now you may be asking, what about JAR files? Aren't
    they modular? Well, although JARs provide modularization to some extent, they
    don't have the uniqueness that is required for modularization. They do have a
    provision to specify the version number, but it is rarely used and also hidden
    in the JAR's manifest file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你可能会想，等一下，Java不是已经是模块化的了吗？Java的面向对象性质不是已经提供了模块化操作吗？嗯，面向对象确实强调了独特性和数据封装。它只建议松散耦合，但并不严格执行。此外，它未能在对象级别提供标识，并且也没有接口的版本控制。现在你可能会问，JAR文件呢？它们不是模块化的吗？嗯，尽管JAR文件在一定程度上提供了模块化，但它们缺乏模块化所需的独特性。它们确实有规定版本号的规定，但很少被使用，而且也隐藏在JAR的清单文件中。
- en: So we need a different design from what we already have. In simple terms, we
    need a modular system in which each module can contain more than one package and
    offers robust encapsulation compared to the standard JAR files.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要与我们已有的不同的设计。简单来说，我们需要一个模块化系统，其中每个模块可以包含多个包，并且相对于标准的JAR文件，提供了强大的封装。
- en: This is what Java 9's modular system offers. In addition to this, it also replaces
    the fallible classpath mechanism by declaring dependencies explicitly. These enhancements
    improve the overall application performance as developers can now optimize the
    individual self-contained unit without affecting the overall system.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java 9的模块化系统所提供的。除此之外，它还通过明确声明依赖关系来取代了不可靠的类路径机制。这些增强功能提高了整体应用程序的性能，因为开发人员现在可以优化单个自包含单元，而不会影响整体系统。
- en: This also makes the application more scalable and provides high integrity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这也使得应用程序更具可扩展性并提供高度的完整性。
- en: 'Let''s look at some of the basics of the module system and how it is tied together.
    To start off with, you can run the following commands to see how the module system
    is structured:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下模块系统的一些基础知识以及它们是如何联系在一起的。首先，您可以运行以下命令来查看模块系统的结构：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Modular Development and Its Impact](img/01_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发及其影响](img/01_01.jpg)'
- en: 'If you are interested in a particular module, you can simply add the module
    name at the end of the command, as shown in the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对特定模块感兴趣，您可以简单地在命令的末尾添加模块名称，如下命令所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Modular Development and Its Impact](img/01_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发及其影响](img/01_02.jpg)'
- en: The earlier command will show all the exports in packages from the base module.
    Java base is the core of the system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令将显示基本模块中包的所有导出。Java base是系统的核心。
- en: 'This will show all the graphical user interface packages. This will also show
    `requires` which are the dependencies:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示所有图形用户界面包。这也将显示`requires`，即依赖项：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Modular Development and Its Impact](img/01_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发及其影响](img/01_03.jpg)'
- en: So far so good, right? Now you may be wondering, I got my modules developed
    but how to integrate them together? Let's look into that. Java 9's modular system
    comes with a tool called **JLink**. I know you can guess what I am going to say
    now. You are right, it links a set of modules and creates a runtime image. Now
    imagine the possibilities it can offer. You can create your own executable system
    with your own custom modules. Life is going to be a lot more fun for you, I hope!
    Oh, and on the other hand, you will be able to control the execution and remove
    unnecessary dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都还好，对吧？现在您可能会想，我已经开发了我的模块，但如何将它们集成在一起呢？让我们来看看。Java 9的模块化系统配备了一个名为**JLink**的工具。我知道你可以猜到我现在要说什么。你是对的，它链接一组模块并创建一个运行时映像。现在想象一下它可以提供的可能性。您可以使用自己的自定义模块创建自己的可执行系统。我希望对您来说生活将会更有趣！哦，另一方面，您将能够控制执行并删除不必要的依赖项。
- en: 'Let''s see how to link modules together. Well, it''s very simple. Just run
    the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将模块链接在一起。嗯，很简单。只需运行以下命令：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This linker command will link all the modules for you and create a runtime image.
    You need to provide a module path and then add the module that you want to generate
    a figure and give a name. Isn't it simple?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个链接器命令将为您链接所有模块并创建一个运行时映像。您需要提供一个模块路径，然后添加您想要生成图形并给出名称的模块。很简单，不是吗？
- en: 'Now, let''s check whether the previous command worked properly or not. Let''s
    verify the modules from the figure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查之前的命令是否正常工作。让我们从图中验证模块：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output looks like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '![Modular Development and Its Impact](img/01_04.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![模块化开发及其影响](img/01_04.jpg)'
- en: With this, you will now be able to distribute a quick runtime with your application.
    It is awesome, isn't it? Now you can see how we moved from a somewhat monolithic
    design to a self-contained cohesive one. Each module contains its own exports
    and dependencies and JLink allows you to create your own runtime. With this, we
    got our modular platform.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在您将能够在应用程序中分发一个快速运行时。这太棒了，不是吗？现在您可以看到我们是如何从有点庞大的设计转变为一个自包含的连贯设计的。每个模块都包含自己的导出和依赖项，而JLink允许您创建自己的运行时。有了这个，我们得到了我们的模块化平台。
- en: Note that the aim of this section is to just introduce you to the modular system.
    There is a lot more to explore but that is beyond the scope of this book. In this
    book, we will focus on the performance enhancement areas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，本节的目的只是为了向您介绍模块化系统。还有很多内容可以探索，但这超出了本书的范围。在本书中，我们将专注于性能增强领域。
- en: Quick Introduction to Modules
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块的快速介绍
- en: I am sure that after reading about the modular platform, you must be excited
    to dive deep into the module architecture and see how to develop one. Hold your
    excitement please, I will soon take you on a journey to the exciting world of
    modules.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信在阅读了模块化平台的介绍之后，您一定会对深入了解模块架构并了解如何开发模块感到兴奋。请稍等兴奋，我很快会带您进入模块的激动人心的世界。
- en: 'As you must have guessed, every module has a property `name` and is organized
    by packages. Each module acts as a self-contained unit and may have native code,
    configurations, commands, resources, and so on. A module''s details are stored
    in a file named `module-info.java`, which resides in the root directory of the
    module source code. In that file, a module can be defined as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，每个模块都有一个`name`属性，并且由包组织。每个模块都作为一个自包含的单元，并且可能具有本地代码、配置、命令、资源等。模块的详细信息存储在一个名为`module-info.java`的文件中，该文件位于模块源代码的根目录中。在该文件中，可以定义一个模块，如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to understand it better, let''s go through an example. Let''s say,
    our module name is `PerformanceMonitor`. The purpose of this module is to monitor
    the application performance. The input connectors will accept method names and
    the required parameters for that method. This method will be called from our module
    to monitor the module''s performance. The output connectors will provide performance
    feedback for the given module. Let''s create a `module-info.java` file in the
    root directory of our performance application and insert the following section:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它，让我们通过一个例子来看一下。假设我们的模块名是`PerformanceMonitor`。这个模块的目的是监控应用程序的性能。输入连接器将接受方法名称和该方法所需的参数。该方法将从我们的模块中调用，以监视模块的性能。输出连接器将为给定模块提供性能反馈。让我们在性能应用程序的根目录中创建一个`module-info.java`文件，并插入以下部分：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Awesome! You got your first module declaration. But wait a minute, it does
    not do anything yet. Don''t worry, we have just created a skeleton for this. Let''s
    put some flesh on the skeleton. Let''s assume that our module needs to communicate
    with our other (magnificent) modules, which we have already created and named--`PerformanceBase`,
    `StringMonitor`, `PrimitiveMonitor`, `GenericsMonitor`, and so on. In other words,
    our module has an external dependency. You may be wondering, how would we define
    this relationship in our module declaration? Ok, be patient, this is what we will
    see now:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你得到了你的第一个模块声明。但等一下，它还没有做任何事情。别担心，我们只是创建了一个框架。让我们给这个框架加点肉。假设我们的模块需要与我们已经创建并命名为`PerformanceBase`、`StringMonitor`、`PrimitiveMonitor`、`GenericsMonitor`等的其他（了不起的）模块进行通信。换句话说，我们的模块有外部依赖。你可能想知道，我们如何在模块声明中定义这种关系？好吧，耐心点，这就是我们现在要看到的：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Yes, I know you have spotted two clauses, that is, `exports` and `requires`.
    And I am sure you are curious to know what they mean and why we have them there.
    We''ll first talk about these clauses and what they mean when used in the module
    declaration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我知道你已经发现了两个子句，即`exports`和`requires`。我相信你很好奇它们的含义以及为什么我们要在这里使用它们。我们首先来谈谈这些子句以及它们在模块声明中的含义：
- en: '`exports`: This clause is used when your module has a dependency on another
    module. It denotes that this module exposes only public types to other modules
    and none of the internal packages are visible. In our case, the module `com.java9highperformance.PerformanceMonitor`
    has a dependency on `com.java9highperformance.StringMonitor`, `com.java9highperformance.PrimitiveMonitor`,
    and `com.java9highperformance.GenericsMonitor`. These modules export their API
    packages `com.java9highperformance.StringMonitor`, `com.java9highperformance.PrimitiveMonitor`,
    and `com.java9highperformance.GenericsMonitor`, respectively.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exports`：当你的模块依赖于另一个模块时，使用这个子句。它表示这个模块只向其他模块公开公共类型，内部包都是不可见的。在我们的例子中，模块`com.java9highperformance.PerformanceMonitor`依赖于`com.java9highperformance.StringMonitor`、`com.java9highperformance.PrimitiveMonitor`和`com.java9highperformance.GenericsMonitor`。这些模块分别导出它们的API包`com.java9highperformance.StringMonitor`、`com.java9highperformance.PrimitiveMonitor`和`com.java9highperformance.GenericsMonitor`。'
- en: '`requires`: This clause denotes that the module depends upon the declared module
    at both compile and runtime. In our case, `com.java9highperformance.PerformanceBase`,
    `com.java9highperformance.PerformanceStat`, and `com.java9highperformance.PerformanceIO`
    modules are required by our `com.java9highperformance.PerformanceMonitor` module.
    The module system then locates all the observable modules to resolve all the dependencies
    recursively. This transitive closure gives us a module graph which shows a directed
    edge between two dependent modules.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requires`：这个子句表示模块在编译和运行时依赖于声明的模块。在我们的例子中，`com.java9highperformance.PerformanceBase`、`com.java9highperformance.PerformanceStat`和`com.java9highperformance.PerformanceIO`模块都被`com.java9highperformance.PerformanceMonitor`模块所需。然后模块系统会定位所有可观察的模块，递归解析所有依赖关系。这种传递闭包给我们一个模块图，显示了两个依赖模块之间的有向边。'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note**: Every module is dependent on `java.base` even without explicitly
    declaring it. As you already know, everything in Java is an object.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：每个模块都依赖于`java.base`，即使没有明确声明。正如你所知，Java中的一切都是对象。'
- en: Now you know about the modules and their dependencies. So, let's draw a module
    representation to understand it better. The following figure shows the various
    packages that are dependent on `com.java9highperformance.PerformanceMonitor`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了模块及其依赖关系。所以，让我们画一个模块表示来更好地理解它。下图显示了各种包依赖于`com.java9highperformance.PerformanceMonitor`。
- en: '![Quick Introduction to Modules](img/01_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![模块快速介绍](img/01_05.jpg)'
- en: Modules at the bottom are `exports` modules and modules on the right are `requires`
    modules.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的模块是`exports`模块，右侧的模块是`requires`模块。
- en: Now let's explore a concept called **readability relationship**. Readability
    relationship is a relationship between two modules where one module is dependent
    on another module. This readability relationship is a basis for reliable configuration.
    So in our example, we can say `com.java9highperformance.PerformanceMonitor` reads
    `com.java9highperformance.PerformanceStat`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们探讨一个叫做**可读性关系**的概念。可读性关系是两个模块之间的关系，其中一个模块依赖于另一个模块。这种可读性关系是可靠配置的基础。因此在我们的例子中，我们可以说`com.java9highperformance.PerformanceMonitor`读取`com.java9highperformance.PerformanceStat`。
- en: 'Let''s look at `com.java9highperformance.PerformanceStat` module''s description
    file `module-info.java`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`com.java9highperformance.PerformanceStat`模块的描述文件`module-info.java`：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This module depends on the `java.lang module`. Let''s look at the `PerformanceStat`
    module in detail:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块依赖于`java.lang`模块。让我们详细看看`PerformanceStat`模块：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this case, `com.java9highperformance.PerformanceMonitor` only depends on
    `com.java9highperformance.PerformanceStat` but `com.java9highperformance.PerformanceStat`
    depends on `java.lang`. The `com.java9highperformance.PerformanceMonitor` module
    is not aware of the `java.lang` dependency from the `com.java9highperformance.PerformanceStat`
    module. This type of problem is taken care of by the module system. It has added
    a new modifier called **transitive**. If you look at `com.java9highperformance.PerformanceStat`,
    you will find it requires transitive `java.lang`. This means that any one depending
    on `com.java9highperformance.PerformanceStat` reads on `java.lang`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`com.java9highperformance.PerformanceMonitor`只依赖于`com.java9highperformance.PerformanceStat`，但`com.java9highperformance.PerformanceStat`依赖于`java.lang`。`com.java9highperformance.PerformanceMonitor`模块不知道`com.java9highperformance.PerformanceStat`模块对`java.lang`的依赖。模块系统已经解决了这种问题，它添加了一个叫做**transitive**的新修饰符。如果你看`com.java9highperformance.PerformanceStat`，你会发现它需要transitive`java.lang`。这意味着任何依赖于`com.java9highperformance.PerformanceStat`的模块都会读取`java.lang`。
- en: 'See the following graph which shows the readability graph:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 请看下面的图表，显示了可读性图：
- en: '![Quick Introduction to Modules](img/01_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![模块快速介绍](img/01_06.jpg)'
- en: Now, in order to compile the `com.java9highperformance.PerformanceMonitor` module,
    the system must be able to resolve all the dependencies. These dependencies can
    be found from the module path. That's obvious, isn't that? However, don't misunderstand
    the classpath with the module path. It is a completely different breed. It doesn't
    have the issues that the packages have.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了编译`com.java9highperformance.PerformanceMonitor`模块，系统必须能够解析所有依赖关系。这些依赖关系可以从模块路径中找到。这是显而易见的，不是吗？然而，不要将类路径误解为模块路径。它是一个完全不同的品种。它没有包的问题。
- en: String Operations Performance
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串操作性能
- en: If you are not new to programming, string must be your best friend so far. In
    many cases, you may like it more than your spouse or partner. As we all know,
    you can't live without string, in fact, you can't even complete your application
    without a single use of string. OK, enough has been expressed about string and
    I am already feeling dizzy by the string usage just like JVM in the earlier versions.
    Jokes apart, let's talk about what has changed in Java 9 that will help your application
    perform better. Although this is an internal change, as an application developer,
    it is important to understand the concept so you know where to focus for performance
    improvements.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是编程新手，字符串一定是你迄今为止最好的朋友。在许多情况下，你可能会更喜欢它而不是你的配偶或伴侣。我们都知道，没有字符串你无法生存，事实上，甚至没有一个字符串的使用你都无法完成你的应用程序。好了，关于字符串已经表达得足够多了，我已经感到头晕，就像早期版本的JVM一样。开玩笑的，让我们谈谈Java
    9中发生了什么改变，将帮助你的应用程序表现更好。虽然这是一个内部变化，但作为应用程序开发人员，了解这个概念很重要，这样你就知道在哪里集中精力进行性能改进。
- en: Java 9 has taken a step toward improving string performance. If you have ever
    come across JDK 6's failed attempt `UseCompressedStrings`, then you must be looking
    for ways to improve string performance. Since `UseCompressedStrings` was an experimental
    feature that was error prone and not designed very well, it was removed in JDK
    7\. Don't feel bad about it, I know it's terrible but as always the golden days
    eventually come. The JEP team has gone through immense pain to add a compact string
    feature that will reduce the footprint of string and its related classes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9已经迈出了改善字符串性能的一步。如果你曾经遇到过JDK 6的失败尝试`UseCompressedStrings`，那么你一定在寻找改善字符串性能的方法。由于`UseCompressedStrings`是一个实验性功能，容易出错且设计不太好，它在JDK
    7中被移除了。不要为此感到难过，我知道这很糟糕，但金色时代终将到来。JEP团队经历了巨大的痛苦，添加了一项紧凑字符串功能，将减少字符串及其相关类的占用空间。
- en: Compact strings will improve the footprint of string and help in using memory
    space efficiently. It also preserves compatibility for all related Java and native
    interfaces. The second important feature is **Indify String Concatenation**, which
    will optimize a string at runtime.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 紧凑字符串将改善字符串的占用空间，并帮助高效使用内存空间。它还保留了所有相关的Java和本地接口的兼容性。第二个重要的特性是**Indify String
    Concatenation**，它将在运行时优化字符串。
- en: In this section, we will take a closure look at these two features and their
    impact on overall application performance.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将仔细研究这两个特性及其对整体应用程序性能的影响。
- en: Compact String
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 紧凑字符串
- en: Before we talk about this feature, it is important to understand why we even
    care about this. Let's dive deep into the underworld of JVM (or as any star wars
    fan would put it, the dark side of the Force). Let's first understand how JVM
    treats our beloved string and that will help us understand this new shiny compact
    string improvement. Let's enter into the magical world of heap. And as a matter
    of fact, no performance book is complete without a discussion of this mystical
    world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们谈论这个特性之前，了解为什么我们要关心这个问题是很重要的。让我们深入了解JVM的地下世界（或者正如任何星球大战迷所说的，原力的黑暗面）。让我们首先了解JVM如何对待我们心爱的字符串，这将帮助我们理解这个新的闪亮的紧凑字符串改进。让我们进入堆的神奇世界。事实上，没有讨论这个神秘世界的性能书籍是不完整的。
- en: The World of Heap
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆的世界
- en: Each time JVM starts, it gets some memory from the underlining operating system.
    It is separated into two distinct regions called **heap space** and **Permgen**.
    These are home to all your application's resources. And as always with all good
    things in life, this home is limited in size. This size is set during the JVM
    initialization; however, you can increase or decrease this by specifying the JVM
    parameters, `-Xmx`, and `-XX:MaxPermSize`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每次JVM启动时，它从底层操作系统获取一些内存。它被分成两个不同的区域，称为**堆空间**和**Permgen**。这些是你的应用程序资源的家园。就像生活中的所有美好事物一样，这个家园的大小是有限的。这个大小在JVM初始化时设置；然而，你可以通过指定JVM参数`-Xmx`和`-XX:MaxPermSize`来增加或减少这个大小。
- en: The heap size is divided into two areas, the nursery or young space and the
    old space. As the name suggests, the young space is home to new objects. This
    all sounds great but every house needs a cleanup. Hence, JVM has the most efficient
    cleaner called **garbage collector** (most efficient? Well... let's not get into
    that just yet). As any productive cleaner would do, the garbage collector efficiently
    collects all the unused objects and reclaims memory. When this young space gets
    filled up with new objects, the garbage collector takes charge and moves any of
    those who have lived long enough in the young space to the old space. This way,
    there is always room for more objects in the young space.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 堆大小分为两个区域，幼年空间和老年空间。顾名思义，幼年空间是新对象的家园。这听起来很棒，但每个房子都需要清理。因此，JVM有一个非常高效的清理工具，称为**垃圾收集器**（最有效？嗯...我们暂时不讨论这个）。就像任何高效的清洁工一样，垃圾收集器高效地收集所有未使用的对象并回收内存。当这个幼年空间被新对象填满时，垃圾收集器会负责将那些在幼年空间中生活了足够长时间的对象移动到老年空间。这样，幼年空间总是有更多对象的空间。
- en: And in the same way, if the old space becomes filled up, the garbage collector
    reclaims the memory used.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果老年空间被填满，垃圾收集器会回收使用的内存。
- en: Why Bother Compressing Strings?
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要压缩字符串？
- en: 'Now you know a little bit about heap, let''s look at the `String` class and
    how strings are represented on heap. If you dissect the heap of your application,
    you will notice that there are two objects, one is the Java language `String`object
    that references the second object `char[]` that actually handles the data. The
    `char` datatype is UTF-16 and hence takes up to 2 bytes. Let''s look at the following
    example of how two different language strings look:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对堆有了一点了解，让我们来看看`String`类和字符串在堆上是如何表示的。如果你解剖你的应用程序的堆，你会注意到有两个对象，一个是Java语言`String`对象，它引用第二个对象`char[]`，实际上处理数据。`char`数据类型是UTF-16，因此占用2个字节。让我们看看以下两种不同语言字符串的例子：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: So you can see that `Latin1 String` only consumes 1 byte, and hence we are losing
    about 50% of the space here. There is an opportunity to represent it in a more
    dense form and improve the footprint, which will eventually help in speeding up
    garbage collection as well.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到`Latin1 String`只占用1个字节，因此我们在这里损失了大约50%的空间。有机会以更密集的形式表示它并改进占用空间，这最终也将有助于加快垃圾回收的速度。
- en: Now, before making any changes to this, it is important to understand its impact
    on real-life applications. It is essential to know whether applications use 1
    byte per `char[]` strings or 2 bytes per `char[]` strings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在对此进行任何更改之前，了解其对现实应用的影响是很重要的。了解应用程序是使用1个字节还是2个字节的`char[]`字符串是至关重要的。
- en: To get an answer to this, the JPM team analyzed a lot of heap dumps of real-world
    data. The result highlighted that a majority of heap dumps have around 18 percent
    to 30 percent of the entire heap consumed by `chars[]`, which come from string.
    Also, it was prominent that most strings were represented by a single byte per
    `char[]`. So, it is clear that if we try to improve the footprint for strings
    with a single byte, it will give significant performance boost to many real-life
    applications.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了得到这个答案，JPM团队分析了大量真实数据的堆转储。结果表明，大多数堆转储中有大约18%到30%的整个堆被`chars[]`占用，这些来自字符串。此外，大多数字符串由`char[]`的单个字节表示。因此，很明显，如果我们尝试改进单字节字符串的占用空间，将会显著提高许多现实应用的性能。
- en: What Did They Do?
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 他们做了什么？
- en: After having gone through a lot of different solutions, the JPM team has finally
    decided to come up with a strategy to compress string during its construction.
    First, optimistically try to compress in 1 byte and if it is not successful, copy
    it as 2 bytes. There are a few shortcuts possible, for example, the use of a special
    case encoder like ISO-8851-1, which will always spit 1 byte.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 经过了许多不同的解决方案，JPM团队最终决定制定一项在构建过程中压缩字符串的策略。首先，乐观地尝试以1个字节压缩，如果不成功，再复制为2个字节。还有一些可能的捷径，例如使用像ISO-8851-1这样的特殊情况编码器，它总是输出1个字节。
- en: This implementation is a lot better than JDK 6's `UseCompressedStrings` implementation,
    which was only helpful to a handful of applications as it was compressing string
    by repacking and unpacking on every single instance. Hence the performance gain
    comes from the fact that it can now work on both the forms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现比JDK 6的`UseCompressedStrings`实现要好得多，因为它只对少数应用有帮助，因为它在每个实例上都对字符串进行重新打包和解包。因此，性能的提升来自于它现在可以同时处理两种形式。
- en: What is the Escape Route?
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逃逸路线是什么？
- en: 'Even though it all sounds great, it may affect the performance of your application
    if it only uses 2 byte per `char[]`string. In that case, it make sense not to
    use the earlier mentioned, check, and directly store string as 2 bytes per `char[]`.
    Hence, the JPM team has provided a kill switch `--XX: -CompactStrings` using which
    you can disable this feature.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '尽管这一切听起来很棒，但如果你的应用程序只使用2个字节的`char[]`字符串，它可能会影响应用程序的性能。在这种情况下，不使用前面提到的检查，直接将字符串存储为2个字节的`char[]`是有意义的。因此，JPM团队提供了一个关闭开关`--XX:
    -CompactStrings`，你可以使用它来禁用这个功能。'
- en: What is the Performance Gain?
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能提升是什么？
- en: The previous optimization affects the heap as we saw earlier that the string
    is represented in the heap. Hence, it is affecting the memory footprint of the
    application. In order to evaluate the performance, we really need to focus on
    the garbage collector. We will explore the garbage collection topic later, but
    for now, let's just focus on the run-time performance.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的优化影响了堆，因为我们之前看到字符串是在堆中表示的。因此，它影响了应用程序的内存占用。为了评估性能，我们真的需要关注垃圾收集器。我们将稍后探讨垃圾收集的主题，但现在让我们专注于运行时性能。
- en: Indify String Concatenation
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Indify字符串连接
- en: 'I am sure you must be thrilled by the concept of the compact string feature
    we just learned about. Now let''s look at the most common usage of string, which
    is concatenation. Have you ever wondered what really happens when we try to concatenate
    two strings? Let''s explore. Take the following example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你一定对我们刚刚学到的紧凑字符串功能感到兴奋。现在让我们来看看字符串最常见的用法，即连接。你是否曾经想过当我们尝试连接两个字符串时到底发生了什么？让我们来探索一下。看下面的例子：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we are trying to concatenate a few strings with the
    `int` value. The compiler will then take your awesome strings, initialize a new
    `StringBuilder` instance, and then append all these individuals strings. Take
    a look at the following bytecode generation by `javac`. I have used the **ByteCode
    Outline** plugin for **Eclipse** to visualize the disassembled bytecode of this
    method. You may download it from [http://andrei.gmxhome.de/bytecode/index.html](http://andrei.gmxhome.de/bytecode/index.html):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们试图连接几个带有`int`值的字符串。编译器将获取你的精彩字符串，初始化一个新的`StringBuilder`实例，然后追加所有这些单独的字符串。让我们看看`javac`生成的以下字节码。我使用了**Eclipse**的**ByteCode
    Outline**插件来可视化这个方法的反汇编字节码。你可以从[http://andrei.gmxhome.de/bytecode/index.html](http://andrei.gmxhome.de/bytecode/index.html)下载它。
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Quick Note: How do we interpret this?'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 快速说明：我们如何解释这个？
- en: '`INVOKESTATIC`: This is useful for invoking static methods'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKESTATIC`：这对于调用静态方法很有用'
- en: '`INVOKEVIRTUAL`: This uses of dynamic dispatch for invoking public and protected
    non-static methods'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKEVIRTUAL`：这使用动态分派来调用公共和受保护的非静态方法'
- en: '`INVOKEINTERFACE`: This is very similar to `INVOKEVIRTUAL` except that the
    method dispatch is based on an interface type'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKEINTERFACE`：这与`INVOKEVIRTUAL`非常相似，只是方法分派是基于接口类型的。'
- en: '`INVOKESPECIAL`: This is useful for invoking constructors, methods of a superclass,
    and private methods'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INVOKESPECIAL`：这对于调用构造函数、超类方法和私有方法非常有用'
- en: However, at runtime, due to the inclusion of `-XX:+-OptimizeStringConcat` into
    the JIT compiler, it can now identify the append of `StringBuilder` and the `toString`
    chains. In case the match is identified, produce low-level code for optimum processing.
    Compute all the arguments' length, figure out the final capacity, allocate the
    storage, copy the strings, and do the in place conversion of primitives. After
    this, handover this array to the `String` instance without copying. It is a profitable
    optimization.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在运行时，由于将`-XX:+-OptimizeStringConcat`包含到JIT编译器中，它现在可以识别`StringBuilder`的附加和`toString`链。如果识别到匹配，就会产生低级代码进行最佳处理。计算所有参数的长度，确定最终容量，分配存储空间，复制字符串，并对原始数据进行就地转换。之后，将此数组交给`String`实例而不进行复制。这是一个有利可图的优化。
- en: But this also has a few drawbacks in terms of concatenation. One example is
    that in case of a concatenating string with long or double, it will not optimize
    properly. This is because the compiler has to do `.getChar` first which adds overhead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这在连接方面也有一些缺点。一个例子是，如果连接长字符串或双精度字符串，它将无法正确优化。这是因为编译器首先必须执行`.getChar`，这会增加开销。
- en: Also, if you are appending `int` to `String`, then it works great; however,
    if you have an incremental operator like `i++`, then it breaks. The reason behind
    this is that you need to rewind to the beginning of the expression and re-execute,
    so you are essentially doing `++` twice. And now the most important change in
    Java 9 compact string. The length spell like `value.length >> coder`; `C2` cannot
    optimize it as it does not know about the IR.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您将`int`附加到`String`，那么它的工作效果很好；但是，如果您有像`i++`这样的增量运算符，那么它就会出错。其原因是您需要回到表达式的开头并重新执行，因此您实际上是在做两次`++`。现在是Java
    9中最重要的变化：紧凑字符串的长度拼写为`value.length >> coder`；`C2`无法优化它，因为它不知道IR。
- en: Hence, to solve the problem of compiler optimization and runtime support, we
    need to control the bytecode, and we cannot expect `javac` to handle that.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了解决编译器优化和运行时支持的问题，我们需要控制字节码，而不能指望`javac`来处理。
- en: 'We need to delay the decision of which concatenation can be done at runtime.
    So can we have just method `String.concat` which will do the magic. Well, don''t
    rush into this yet as how would you design the method `concat`. Let''s take a
    look. One way to go about this is to accept an array of the `String` instance:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要推迟在运行时决定哪些连接可以完成。那么我们是否可以只有`String.concat`方法来完成这一点。好吧，不要急着这样做，因为你如何设计`concat`方法呢。让我们来看看。解决这个问题的一种方法是接受`String`实例的数组：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, this approach will not work with primitives as you now need to convert
    each primitive to the `String`instance and also, as we saw earlier, the problem
    is that long and double string concatenation will not allow us to optimize it.
    I know, I can sense the glow on your face like you got a brilliant idea to solve
    this painful problem. You are thinking about using the `Object` instance instead
    of the `String` instance, right? As you know the `Object`instance is catch all.
    Let''s look at your brilliant idea:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法在处理原始数据时不起作用，因为现在您需要将每个原始数据转换为`String`实例，而且正如我们之前看到的，长字符串和双精度字符串连接将不允许我们进行优化。我知道，我能感觉到你脸上闪现出一丝光芒，就像你想到了解决这个痛苦问题的绝妙主意。你在考虑使用`Object`实例而不是`String`实例，对吗？正如你所知道的，`Object`实例是一个通用实例。让我们来看看你的绝妙主意：
- en: '[PRE14]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: First, if you are using the `Object` instance, then the compiler needs to do
    autoboxing. Additionally, you are passing in the `varargs` array, so it will not
    perform optimally. So, are we stuck here? Does it mean we cannot use the preeminent
    compact string feature with string concatenation? Let's think a bit more; maybe
    instead of using the method `runtime`, let `javac` handle the concatenation and
    just give us the optimized bytecode. That sounds like a good idea. Well, wait
    a minute, I know you are thinking the same thing. What if JDK 10 optimizes this
    further? Does that mean, when I upgrade to the new JDK, I have to recompile my
    code again and deploy it again? In some cases, its not a problem, in other cases,
    it is a big problem. So, we are back to square one.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果您正在使用`Object`实例，那么编译器需要进行自动装箱。此外，您正在传递`varargs`数组，因此它不会表现出最佳性能。那么，我们被困在这里了吗？这意味着我们不能在字符串连接中使用卓越的紧凑字符串特性吗？让我们再想一想；也许我们可以让`javac`处理连接而不是使用`runtime`方法，并为我们提供优化的字节码。这听起来是个好主意。等一下，我知道你也在想同样的事情。如果JDK
    10进一步优化这一点怎么办？这是否意味着当我升级到新的JDK时，我必须重新编译我的代码并再次部署？在某些情况下，这不是问题，但在其他情况下，这是一个大问题。所以，我们又回到了原点。
- en: We need something that can be handled at runtime. Ok, so that means we need
    something which will dynamically invoke the methods. Well, that rings a bell.
    If we go back in our time machine, at the dawn of the era of JDK 7 it gave us
    `invokedynamic`. I know you can see the solution, I can sense the sparkle in your
    eyes. Yes, you are right, `invokedynamic` can help us here. If you are not aware
    of `invokedynamic`, let's spend some time to understand it. For those who have
    already mastered the topic, you could skip it, but I would recommend you go through
    this again.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些可以在运行时处理的东西。好吧，这意味着我们需要一些可以动态调用方法的东西。嗯，这让人想起了什么。如果我们回到时光机，回到JDK 7时代的黎明，它给了我们`invokedynamic`。我知道你能看到解决方案，我能感觉到你眼中的闪光。是的，你是对的，`invokedynamic`可以帮助我们。如果您不了解`invokedynamic`，让我们花点时间来了解一下。对于那些已经掌握了这个主题的人，你可以跳过它，但我建议你再次阅读一遍。
- en: Invokedynamic
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调用动态
- en: The `invokedynamic` feature is the most notable feature in the history of Java.
    Rather than having a limit to JVM bytecode, we now can define our own way for
    operations to work. So what is `invokedynamic`? In simple terms, it is the user-definable
    bytecode. This bytecode (instead of JVM) determines the execution and optimization
    strategies. It offers various method pointers and adapters which are in the form
    of method handling APIs. The JVM then work on the pointers given in the bytecode
    and use reflection-like method pointers to optimize it. This way, you, as a developer,
    can get full control over the execution and optimization of code.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic`功能是Java历史上最显著的功能。现在，我们不再受限于JVM字节码，可以自定义操作的方式。那么`invokedynamic`是什么？简单来说，它是用户可定义的字节码。这种字节码（而不是JVM）决定了执行和优化策略。它提供了各种方法指针和适配器，这些适配器以方法处理API的形式存在。JVM然后根据字节码中给定的指针进行工作，并使用类似反射的方法指针来优化它。这样，作为开发人员，您可以完全控制代码的执行和优化。'
- en: It is essentially a mix of user-defined bytecode (which is known as **bytecode
    + bootstrap**) and method handles. I know you are also wondering about the method
    handles--what are they and how to use them? Ok, I heard you, let's talk about
    method handles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它本质上是用户定义的字节码（称为**字节码+引导**）和方法句柄的混合。我知道你也在想方法句柄--它们是什么，如何使用它们？好的，我听到你了，让我们谈谈方法句柄。
- en: Method handles provide various pointers, including field, array, and method,
    to pass data and get results back. With this, you can do argument manipulation
    and flow control. From JVM's point of view, these are native instructions that
    it can optimize as if it were bytecode. However, you have the option to programmatically
    generate this bytecode.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 方法句柄提供各种指针，包括字段、数组和方法，用于传递数据并获取结果。借助这一点，您可以进行参数操作和流控制。从JVM的角度来看，这些是本机指令，它可以将其优化为字节码。但是，您可以选择以编程方式生成此字节码。
- en: Let's zoom in to the method handles and see how it all ties up together. The
    main package's name is `java.lang.invoke`, which has `MethodHandle`, `MethodType`,
    and `MethodHandles`. `MethodHandle` is the pointer that will be used to invoke
    the function. `MethodType` is a representation of a set of arguments and return
    value coming from the method. The utility class `MethodHandles` will act as a
    pointer to a method which will get an instance of `MethodHandle` and map the arguments.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看方法句柄，看看它们是如何联系在一起的。主要包的名称是`java.lang.invoke`，其中包括`MethodHandle`、`MethodType`和`MethodHandles`。`MethodHandle`是将用于调用函数的指针。`MethodType`是来自方法的一组参数和返回值的表示。实用类`MethodHandles`将充当指向一个方法的指针，该方法将获得`MethodHandle`的实例并映射参数。
- en: We won't be going in deep for this section, as the aim was just to make you
    aware of what the `invokedynamic` feature is and how it works so you will understand
    the string concatenation solution. So, this is where we get back to our discussion
    on string concatenation. I know, you were enjoying the `invokedynamic` discussion,
    but I guess I was able to give you just enough insight to make you understand
    the core idea of Indify String Concatenation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这一部分，因为目的只是让您了解`invokedynamic`功能是什么以及它是如何工作的，这样您就能理解字符串连接的解决方案。所以，我们回到了我们对字符串连接的讨论。我知道，你正在享受`invokedynamic`的讨论，但我想我已经给了你足够的见解，让你理解Indify字符串连接的核心思想。
- en: Let's get back on the concatenation part where we were looking for a solution
    to concatenate our awesome compact strings. For concatenating the compact strings,
    we need to take care of types and the number of types of methods and this is what
    the `invokedynamic` gives us.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们正在寻找解决方案来连接我们的精简字符串的部分。为了连接这些精简字符串，我们需要注意方法的类型和数量以及这就是`invokedynamic`给我们的。
- en: So let's use `invokedynamic` for `concat`. Well, not so quick, my friend. There
    is a fundamental problem with this approach. We cannot just use `invokedynamic`
    as it is to solve this problem. Why? Because there is a circular reference. The
    `concat` function needs `java.lang.invoke`, which uses `concat`. This continues,
    and eventually you will get `StackOverflowError`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们为`concat`使用`invokedynamic`。好吧，朋友，不要那么快。这种方法存在一个根本问题。我们不能只是使用`invokedynamic`来解决这个问题。为什么？因为存在循环引用。`concat`函数需要`java.lang.invoke`，而`java.lang.invoke`使用`concat`。这种情况会继续下去，最终会导致`StackOverflowError`。
- en: 'Take a look at the following code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So if we were to use `invokedynamic` here, the `invokedynamic` call would look
    like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果我们在这里使用`invokedynamic`，`invokedynamic`调用会是这样的：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is a need to break the circular reference. However, in the current JDK
    implementation, you cannot control what `java.invoke` calls from the complete
    JDK library. Also, removing the complete JDK library reference from `java.invoke`
    has severe side effects. We only need the `java.base` module for Indify String
    Concatenation, and if we can figure out a way to just call the `java.base` module,
    then it will significantly improve the performance and avoid unpleasant exceptions.
    I know what you are thinking. We just studied the coolest addition to Java 9,
    **Project Jigsaw**. It provides modular source code and now we can only accept
    the `java.base` module. This solves the biggest problem we were facing in terms
    of concatenating two strings, primitives, and so on.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有必要打破循环引用。然而，在当前的JDK实现中，您无法控制`java.invoke`从完整的JDK库中调用什么。此外，从`java.invoke`中删除完整的JDK库引用会产生严重的副作用。我们只需要`java.base`模块来进行Indify字符串连接，如果我们能找到一种方法只调用`java.base`模块，那么它将显著提高性能并避免不愉快的异常。我知道你在想什么。我们刚刚学习了Java
    9的最酷的新功能，**Project Jigsaw**。它提供了模块化的源代码，现在我们只能接受`java.base`模块。这解决了我们在连接两个字符串、原语等方面所面临的最大问题。
- en: 'After going through a couple of different strategies, the Java Performance
    Management team has settled on the following strategy:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几种不同的策略，Java性能管理团队已经确定了以下策略：
- en: Make a call to the `toString()` method on all reference args.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有引用参数调用`toString()`方法。
- en: Make a call to the `tolength()` method or since all the underlying methods are
    exposed, just call `T.stringSize(T t)` on every args.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`tolength()`方法或者由于所有底层方法都是公开的，只需在每个参数上调用`T.stringSize(T t)`。
- en: Figure out the coders and call `coder()` for all reference args.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出编码器并为所有引用参数调用`coder()`。
- en: Allocate `byte[]` storage and then copy all args. And then, convert primitives
    in-place.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配`byte[]`存储，然后复制所有参数。然后，在原地转换原始数据。
- en: Invoke a private constructor `String` by handing over the array for concatenation.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将数组传递给`String`的私有构造函数来调用。
- en: With this, we are able to get an optimized string concat in the same code and
    not in `C2 IR`. This strategy gives us 2.9x better performance and 6.4x less garbage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们能够在同一代码中获得优化的字符串连接，而不是在`C2 IR`中。这种策略使我们的性能提高了2.9倍，垃圾减少了6.4倍。
- en: Storing Interned Strings in CDS Archives
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Interned Strings存储在CDS存档中
- en: The main goal of this feature is to reduce memory footprint caused by creating
    new instances of string in every JVM process. All the classes that are loaded
    in any JVM process can be shared with other JVM processes via **Class Data Sharing**
    (**CDS**) archives.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能的主要目标是减少每个JVM进程中创建新字符串实例所造成的内存占用。在任何JVM进程中加载的所有类都可以通过**类数据共享**（**CDS**）存档与其他JVM进程共享。
- en: Oh, I did not tell you about CDS. I think it's important to spend some time
    to understand what CDS is, so you can understand the underlying performance improvement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，我没告诉你CDS的事。我认为花点时间了解CDS是很重要的，这样你就能理解底层的性能改进。
- en: Many times, small applications in particular spend a comparatively long time
    on startup operations. To reduce this startup time, a concept called CDS was introduced.
    CDS enables sharing of a set of classes loaded from the system JAR file into a
    private internal representation during the JRE installation. This helps a lot
    as then any further JVM invocations can take advantage of these loaded classes'
    representation from the shared archive instead of loading these classes again.
    The metadata related to these classes is shared among multiple JVM processes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多时候，特别是小型应用在启动操作上花费相对较长的时间。为了减少这种启动时间，引入了一个叫做CDS的概念。CDS使得可以在JRE安装期间将从系统JAR文件加载的一组类共享到私有内部表示中。这对于任何进一步的JVM调用都很有帮助，因为它们可以利用这些加载类的共享存档中的表示，而不是再次加载这些类。与多个JVM进程共享与这些类相关的元数据。
- en: CDS stores strings in the form of UTF-8 in the constant pool. When a class from
    these loaded classes begins the initialization process, these UTF-8 strings are
    converted into `String` objects on demand. In this structure, every character
    in every confined string takes 2 bytes in the `String` object and 1 byte to 3
    bytes in the UTF-8, which essentially wastes memory. Since these strings are created
    dynamically, different JVM processes cannot share these strings.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: CDS在常量池中以UTF-8形式存储字符串。当这些加载的类中的一个类开始初始化过程时，这些UTF-8字符串会按需转换为`String`对象。在这种结构中，每个受限字符串中的每个字符在`String`对象中占据2个字节，在UTF-8中占据1个字节到3个字节，这实际上浪费了内存。由于这些字符串是动态创建的，不同的JVM进程无法共享这些字符串。
- en: Shared strings need a feature called **pinned regions** in order to make use
    of the garbage collector. Since the only HotSpot garbage collector that supports
    pinning is G1; it only works with the G1 garbage collector.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 共享字符串需要一个名为**固定区域**的功能来利用垃圾收集器。由于唯一支持固定的HotSpot垃圾收集器是G1；它只能与G1垃圾收集器一起使用。
- en: Concurrency Performance
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发性能
- en: Multithreading is a very popular concept. It allows programs to run multiple
    tasks at the same time. These multithreaded programs may have more than one unit
    which can run concurrently. Every unit can handle a different task keeping the
    use of available resources optimal. This can be managed by multiple threads that
    can run in parallel.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程是一个非常流行的概念。它允许程序同时运行多个任务。这些多线程程序可能有多个单位可以同时运行。每个单位可以处理不同的任务，保持可用资源的最佳利用。这可以通过多个线程并行运行来管理。
- en: Java 9 improved contended locking. You may be wondering what is contended locking.
    Let's explore. Each object has one monitor that can be owned by one thread at
    a time. Monitors are the basic building blocks of concurrency. In order for a
    thread to execute a block of code marked as synchronized on an object or a synchronized
    method declared by an object, it must own this object's monitor. Since there are
    multiple threads trying to get access to the mentioned monitor, JVM needs to orchestrate
    the process and only allow one thread at a time. It means the rest of threads
    go in a wait state. This monitor is then called contended. Because of this provision,
    the program wastes time in the waiting state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9改进了争用锁定。也许你想知道什么是争用锁定。让我们来探讨一下。每个对象都有一个监视器，一次只能被一个线程拥有。监视器是并发的基本构建块。为了让一个线程执行在对象上标记为同步的代码块或对象声明的同步方法，它必须拥有这个对象的监视器。由于有多个线程试图访问所述监视器，JVM需要协调这个过程，并且一次只允许一个线程。这意味着其余的线程进入等待状态。然后这个监视器被称为争用。由于这个规定，程序在等待状态中浪费了时间。
- en: Also, **Java Virtual Machine** (**JVM**) does some work orchestrating the lock
    contention. Additionally, it has to manage threads, so once the existing thread
    finishes its execution, it can allow a new thread to go in. This certainly adds
    overhead and affects performance adversely. Java 9 has taken a few steps to improve
    in this area. The provision refines the JVM's orchestration, which will ultimately
    result in performance improvement in highly contested code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**Java虚拟机**（**JVM**）还要做一些工作来协调锁争用。此外，它还必须管理线程，因此一旦现有线程完成执行，它就可以允许新线程进入。这肯定会增加开销，并对性能产生不利影响。Java
    9已经采取了一些措施来改进这一领域。该规定完善了JVM的协调，最终将导致高度竞争代码的性能改进。
- en: 'The following benchmarks and tests can be used to check the performance improvements
    of contented Java object monitors:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下基准测试可以用来检查争用Java对象监视器的性能改进：
- en: '`CallTimerGrid` (This is more of a stress test than a benchmark)'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CallTimerGrid`（这更像是一个压力测试而不是基准测试）'
- en: '`Dacapo-bach` (earlier dacapo2009)'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dacapo-bach`（之前的dacapo2009）'
- en: '`_ avrora`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ avrora
- en: '`_ batik`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ batik
- en: '`_ fop`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ fop
- en: '`_ h2`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ h2
- en: '`_ luindex`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ luindex
- en: '`_ lusearch`'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ lusearch
- en: '`_ pmd`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ pmd
- en: '`_ sunflow`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ sunflow
- en: '`_ tomcat`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ tomcat
- en: '`_ tradebeans`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ tradebeans
- en: '`_ tradesoap`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ tradesoap
- en: '`_ xalan`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ xalan
- en: '`DerbyContentionModelCounted`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DerbyContentionModelCounted
- en: '`HighContentionSimulator`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HighContentionSimulator
- en: '`LockLoops-JSR166-Doug-Sept2009` (earlier LockLoops)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LockLoops-JSR166-Doug-Sept2009（早期的LockLoops）
- en: '`PointBase`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PointBase
- en: '`SPECjbb2013-critical` (earlier specjbb2005)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPECjbb2013-critical（早期的specjbb2005）
- en: '`SPECjbb2013-max`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPECjbb2013-max
- en: '`specjvm2008`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: specjvm2008
- en: '`volano29` (earlier volano2509)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: volano29（早期的volano2509）
- en: Compiler Improvements
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译器改进
- en: Several efforts have been made to improve the compiler's performance. In this
    section, we will focus on the improvements to the compiler side.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 已经做出了一些努力来改进编译器的性能。在本节中，我们将重点关注编译器方面的改进。
- en: Tiered Attribution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tiered Attribution
- en: The first and foremost change providing compiler improvement is related to **Tiered
    Attribution** (**TA**). This change is more related to lambda expressions. At
    the moment, the type checking of poly expression is done by type checking the
    same tree multiple times against different targets. This process is called **Speculative
    Attribution** (**SA**), which enables the use of different overload resolution
    targets to check a lambda expression.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 提供编译器改进的首要变化与**Tiered Attribution**（**TA**）有关。这个改变更多地涉及到lambda表达式。目前，多态表达式的类型检查是通过多次对同一树针对不同目标进行类型检查来完成的。这个过程被称为**Speculative
    Attribution**（**SA**），它使得可以使用不同的重载解析目标来检查lambda表达式。
- en: This way of type checking, although a robust technique, adversely affects performance
    significantly. For example, with this approach, *n* number of overload candidates
    check against the same argument expression up to *n * 3* once per overload phase,
    strict, loose, and varargs. In addition to this, there is one final check phase.
    Where lambda returns a poly method call results in combinatorial explosion of
    attribution calls, this causes a huge performance problem. So we certainly need
    a different method of type checking for poly expressions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种类型检查方式是一种强大的技术，但它对性能有显著的不利影响。例如，采用这种方法，*n*个重载候选者将在每个重载阶段对相同的参数表达式进行检查，严格、宽松和可变参数分别进行一次，总共*n*3次。除此之外，还有一个最终的检查阶段。当lambda返回一个多态方法调用结果时，会导致属性调用的组合爆炸，这会造成巨大的性能问题。因此，我们确实需要一种不同的多态表达式类型检查方法。
- en: The core idea is to make sure that a method call creates bottom-up structural
    types for each poly argument expression with every single details, which will
    be needed to execute the overload resolution applicability check before performing
    the overload resolution.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是确保方法调用为每个多态参数表达式创建自下而上的结构类型，其中包含每个细节，这将在执行重载解析适用性检查之前执行重载解析时需要。
- en: So in summary, the performance improvement was able to achieve an attribute
    of a given expression by decreasing the total number of tries.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总的来说，性能改进能够通过减少尝试的总次数来实现对给定表达式的属性。
- en: Ahead-of-Time Compilation
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提前编译
- en: The second noticeable change for compiler improvement is Ahead-of-Time compilation.
    If you are not familiar with the term, let's see what AOT is. As you probably
    know, every program in any language needs a runtime environment to execute. Java
    also has its own runtime which is known as **Java Virtual Machine** (**JVM**).
    The typical runtime that most of us use is a bytecode interpreter, which is JIT
    compiler as well. This runtime is known as **HotSpot JVM**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编译器改进的第二个显著变化是提前编译。如果你对这个术语不熟悉，让我们看看AOT是什么。你可能知道，任何语言中的程序都需要一个运行时环境来执行。Java也有自己的运行时环境，被称为**Java虚拟机**（**JVM**）。我们大多数人使用的典型运行时是一个字节码解释器，也是JIT编译器。这个运行时被称为**HotSpot
    JVM**。
- en: This HotSpot JVM is famous for improving performance by JIT compilation as well
    as adaptive optimization. So far so good. However, this does not work well in
    practice for every single application. What if you have a very light program,
    say, a single method call? In this case, JIT compilation will not help you much.
    You need something that will load up faster. This is where AOT will help you.
    With AOT as opposed to JIT, instead of compiling to bytecode, you can compile
    into native machine code. The runtime then uses this native machine code to manage
    calls for new objects into mallocs as well as file access into system calls. This
    can improve performance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HotSpot JVM以通过JIT编译和自适应优化来提高性能而闻名。到目前为止一切都很好。然而，这并不适用于每个单独的应用程序。如果你有一个非常轻量的程序，比如一个单独的方法调用，那该怎么办呢？在这种情况下，JIT编译将帮助不大。你需要一些能够更快加载的东西。这就是AOT将会帮助你的地方。与JIT相反，AOT不是编译成字节码，而是编译成本地机器代码。运行时然后使用这个本地机器代码来管理对新对象的调用，将其分配到malloc中，以及对文件访问的系统调用。这可以提高性能。
- en: Security Manager Improvements
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全管理器改进
- en: Ok, let's talk about security. If you are not one of those who cares about application
    security over pushing more features in a release, then the expression on your
    face may be like **Uh! What's that?** If you are one those, then let's first understand
    the importance of security and find a way to consider this in your application
    development tasks. In today's SaaS-dominated world, everything is exposed to the
    outside world. A determined individual (a nice way of saying, a **malicious hacker**),
    can get access to your application and exploit the security holes you may have
    introduced through your negligence. I would love to talk about application security
    in depth as this is another area I am very much interested in. However, application
    security is out of the scope of this book. The reason we are talking about it
    here is that the JPM team has taken an initiative to improve the existing security
    manager. Hence, it is important to first understand the importance of security
    before talking about the security manager.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们谈谈安全性。如果你不是那些更关心在发布中推出更多功能而不是应用程序安全的人，那么你的表情可能会像**嗯！那是什么？**如果你是其中之一，那么让我们首先了解安全性的重要性，并找到一种方法来考虑在应用程序开发任务中。在今天由SaaS主导的世界中，一切都暴露在外部世界。一个决心的个人（委婉地说，一个**恶意黑客**）可以访问你的应用程序，并利用你可能由于疏忽而引入的安全漏洞。我很乐意深入讨论应用程序安全，因为这是我非常感兴趣的另一个领域。然而，应用程序安全超出了本书的范围。我们在这里谈论它的原因是JPM团队已经采取了改进现有安全管理器的举措。因此，在谈论安全管理器之前，首先了解安全性的重要性是很重要的。
- en: Hopefully, this one line of description may have generated secure programming
    interest in you. However, I do understand that sometimes you may not have enough
    time to implement a complete secure programming model due to tight schedules.
    So, let's find a way which can fit with your tight schedule. Let's think for a
    minute; is there any way to automate security? Can we have a way to create a blueprint
    and ask our program to stay within the boundaries? Well, you are in luck, Java
    does have a feature called **security manager**. It is nothing but a policy manager
    that defines a security policy for the application. It sounds exciting, doesn't
    it? But what does this policy look like? And what does it contain? Both are fair
    questions to ask. This security policy basically states actions that are dangerous
    or sensitive in nature. If your application does not comply with this policy,
    then the security manager throws `SecurityException`. On the other side, you can
    have your application call this security manager to learn about the permitted
    actions. Now, let's look at the security manager in detail.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一行描述可能已经引起了您对安全编程的兴趣。然而，我理解有时候您可能没有足够的时间来实现完整的安全编程模型，因为时间安排很紧。因此，让我们找到一种可以适应您紧张时间表的方法。让我们思考一分钟；有没有办法自动化安全？我们是否可以有一种方法来创建一个蓝图，并要求我们的程序保持在边界内？好吧，你很幸运，Java确实有一个名为**安全管理器**的功能。它只是一个为应用程序定义安全策略的策略管理器。听起来很令人兴奋，不是吗？但这个策略是什么样的？它包含什么？这两个问题都是合理的提问。这个安全策略基本上规定了具有危险或敏感性质的行为。如果您的应用程序不符合这个策略，那么安全管理器会抛出`SecurityException`。另一方面，您可以让您的应用程序调用这个安全管理器来了解允许的操作。现在，让我们详细了解安全管理器。
- en: In case of a web applet, a security manager is provided by the browser, or the
    Java Web Start plugin runs this policy. In many cases, applications other than
    web applets run without a security manager unless those applications implement
    one. It's a no brainer to say that if there is no security manager and no security
    policy attached, the application acts without restrictions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web小程序的情况下，浏览器提供了安全管理器，或者Java Web Start插件运行此策略。在许多情况下，除了Web小程序之外的应用程序都没有安全管理器，除非这些应用程序实现了一个。毫无疑问地说，如果没有安全管理器和没有附加安全策略，应用程序将无限制地运行。
- en: Now we know a little about the security manager, let's look at the performance
    improvement in this area. As per the Java team, there may be a possibility that
    an application running with a security manager installed degrades performance
    by 10 percent to 15 percent. However, it is not possible to remove all the performance
    bottlenecks but narrowing this gap can assist in improving not only security but
    also performance.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对安全管理器有了一些了解，让我们来看看这一领域的性能改进。根据Java团队的说法，安装了安全管理器的应用程序可能会导致性能下降10%至15%。然而，虽然不可能消除所有性能瓶颈，但缩小这一差距可以有助于改善安全性和性能。
- en: The Java 9 team looked at some of the optimizations, including the enforcement
    of security policy and the evaluation of permissions, which will help improve
    the overall performance of using a security manager. During the performance testing
    phase, it was highlighted that even though the permission classes are thread safe,
    they show up as a HotSpot. Numerous improvements have been made to decrease thread
    contention and improve throughput.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9团队研究了一些优化措施，包括执行安全策略和评估权限，这将有助于改善使用安全管理器的整体性能。在性能测试阶段，突出显示了即使权限类是线程安全的，它们也会显示为HotSpot。已经进行了许多改进，以减少线程争用并提高吞吐量。
- en: Computing the `hashcode` method of `java.security.CodeSource` has been improved
    to use a string form of the code source URL to avoid potentially expensive DNS
    lookups. Also, the `checkPackageAccess` method of `java.lang.SecurityManager`,
    which contains the package checking algorithm, has been improved.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 改进了`java.security.CodeSource`的`hashcode`方法，以使用代码源URL的字符串形式，以避免潜在昂贵的DNS查找。此外，`java.lang.SecurityManager`的`checkPackageAccess`方法，其中包含包检查算法，已经得到改进。
- en: 'Some other noticeable changes in security manager improvements are as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 安全管理器改进中的一些其他显着变化如下：
- en: The first noticeable change is that using `ConcurrentHashMap` in place of `Collections.synchronizedMap`
    helps improving throughput of the `Policy.implie` method. Look at the following
    graph, taken from the OpenJDK site, which highlights the significant increase
    in the throughput with `ConcurrentHashMap`:![Security Manager Improvements](img/01_07.jpg)
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个显著的变化是，使用`ConcurrentHashMap`代替`Collections.synchronizedMap`有助于提高`Policy.implie`方法的吞吐量。看看下面的图表，摘自OpenJDK网站，突出显示了使用`ConcurrentHashMap`时吞吐量的显著增加：![Security
    Manager Improvements](img/01_07.jpg)
- en: In addition to this, `HashMap`, which had been used for maintaining internal
    collection of `CodeSource` in `java.security.SecureClassLoader`, has been replaced
    by `ConcurrentHashMap`.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除此之外，在`java.security.SecureClassLoader`中用于维护`CodeSource`内部集合的`HashMap`已被`ConcurrentHashMap`替换。
- en: There are a few other small improvements like an improvement in the throughput
    by removing the compatibility code from the `getPermissions` method (`CodeSource`),
    which synchronizes on identities.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有一些其他小的改进，比如通过从“getPermissions”方法（`CodeSource`）中删除兼容性代码来提高吞吐量，该方法在身份上进行同步。
- en: Another significant gain in performance is achieved using `ConcurrentHashMap`
    instead of `HashMap` surrounded by synchronized blocks in the permission checking
    code, which yielded in greater thread performance.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentHashMap`代替在权限检查代码中被同步块包围的`HashMap`可以显著提高线程性能，从而实现了性能的显著增加。
- en: Graphics Rasterizers
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图形光栅化器
- en: If you are into Java 2D and using OpenJDK, you will appreciate the efforts taken
    by the Java 9 team. Java 9 is mainly related to a graphics rasterizer, which is
    part of the current JDK. OpenJDK uses Pisces, whereas Oracle JDK uses Ductus.
    Oracle's closed-source Ductus rasterizer performs better than OpenJDK's Pisces.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对Java 2D和使用OpenJDK感兴趣，您将会欣赏Java 9团队所做的努力。Java 9主要与图形光栅化器有关，这是当前JDK的一部分。OpenJDK使用Pisces，而Oracle
    JDK使用Ductus。Oracle的闭源Ductus光栅化器的性能优于OpenJDK的Pisces。
- en: These graphics rasterizers are useful for anti-aliased rendering except fonts.
    Hence, for a graphics-intensive application, the performance of this rasterizer
    is very important. However, Pisces is failing in many fronts and its performance
    problems are very visible. Hence, the team has decided to replace this with a
    different rasterizer called Marlin Graphics Renderer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图形光栅化器对于抗锯齿渲染非常有用，除了字体。因此，对于图形密集型应用程序，这种光栅化器的性能非常重要。然而，Pisces在许多方面都表现不佳，其性能问题非常明显。因此，团队决定将其替换为一个名为Marlin
    Graphics Renderer的不同光栅化器。
- en: Marlin is developed in Java and, most importantly, it is the fork of the Pisces
    rasterizer. Various tests have been done on it and the results are very promising.
    It consistently performs better than Pisces. It demonstrates multithreaded scalability
    and even outperforms the closed-source Ductus rasterizer for a single-threaded
    application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Marlin是用Java开发的，最重要的是，它是Pisces光栅化器的分支。对其进行了各种测试，结果非常令人期待。它的性能始终优于Pisces。它展示了多线程可伸缩性，甚至在单线程应用程序中也优于闭源的Ductus光栅化器。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, we have seen some of the exciting features that will improve
    your application's performance without making any effort from your end.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们已经看到了一些令人兴奋的功能，可以在不费吹灰之力的情况下提高您的应用程序性能。
- en: In the next lesson, we will learn about JShell and the **Ahead-of-Time** (**AOT**)
    compiler. We will also learn about **Read-Eval-Print Loop** (**REPL**) tool.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一课中，我们将学习JShell和**提前**（**AOT**）编译器。我们还将学习**读取-求值-打印循环**（**REPL**）工具。
- en: Assessments
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: JLink is a ___________ of Java 9 modular system.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JLink是Java 9模块系统的___________。
- en: What is the relationship between two modules where one module is dependent on
    another module?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个模块之间的关系是什么，其中一个模块依赖于另一个模块？
- en: Readability relationship
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可读性关系
- en: Operability relationship
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可操作性关系
- en: Modular relationship
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块化关系
- en: Entity relationship
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体关系
- en: 'State whether True or False: Each time JVM starts, it gets some memory from
    the underlining operating system.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断真假：每次JVM启动时，它都会从底层操作系统获取一些内存。
- en: Which of the following perform some work orchestrating the lock contention?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项执行一些工作来编排锁争用？
- en: Pinned regions
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 固定区域
- en: Readability relationship
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可读性关系
- en: Java Virtual Machine
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java虚拟机
- en: Class data sharing
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类数据共享
- en: Which of the following enables the use of different overload resolution targets
    to check a lambda expression?
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪项使得可以使用不同的过载解析目标来检查lambda表达式？
- en: Tiered attribution
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分层归因
- en: HotSpot JVM
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HotSpot JVM
- en: Speculative attribution
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推测性归因
- en: Permgen
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Permgen
