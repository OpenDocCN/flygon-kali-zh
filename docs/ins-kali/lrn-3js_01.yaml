- en: Chapter 1. Creating Your First 3D Scene with Three.js
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。使用Three.js创建您的第一个3D场景
- en: 'Modern browsers are slowly getting more powerful features that can be accessed
    directly from JavaScript. You can easily add video and audio with the new HTML5
    tags and create interactive components through the use of the HTML5 canvas. Together
    with HTML5, modern browsers also started supporting WebGL. With WebGL, you can
    directly make use of the processing resources of your graphics card and create
    high-performance 2D and 3D computer graphics. Programming WebGL directly from
    JavaScript to create and animate 3D scenes is a very complex and error-prone process.
    Three.js is a library that makes this a lot easier. The following list shows some
    of the things that Three.js makes easy:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器正在逐渐获得更强大的功能，可以直接从JavaScript中访问。您可以轻松地使用新的HTML5标签添加视频和音频，并通过HTML5画布创建交互式组件。与HTML5一起，现代浏览器还开始支持WebGL。使用WebGL，您可以直接利用图形卡的处理资源，并创建高性能的2D和3D计算机图形。直接从JavaScript编程WebGL以创建和动画3D场景是一个非常复杂和容易出错的过程。Three.js是一个使这变得更容易的库。以下列表显示了Three.js使得易于实现的一些功能：
- en: Creating simple and complex 3D geometries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单和复杂的3D几何体
- en: Animating and moving objects through a 3D scene
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过3D场景中的动画和移动对象
- en: Applying textures and materials to your objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纹理和材质应用到您的对象上
- en: Making use of different light sources to illuminate the scene
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用不同的光源照亮场景
- en: Loading objects from 3D-modeling software
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从3D建模软件加载对象
- en: Adding advanced postprocessing effects to your 3D scene
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的3D场景添加高级后处理效果
- en: Working with your own custom shaders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义着色器
- en: Creating point clouds
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建点云
- en: 'With a couple of lines of JavaScript, you can create anything, from simple
    3D models to photorealistic real-time scenes, as shown in the following screenshot
    (see it yourself by opening [http://www.vill.ee/eye/](http://www.vill.ee/eye/)
    in your browser):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用几行JavaScript代码，您可以创建从简单的3D模型到逼真的实时场景的任何东西，如下图所示（通过在浏览器中打开[http://www.vill.ee/eye/](http://www.vill.ee/eye/)来查看）：
- en: '![Creating Your First 3D Scene with Three.js](graphics/2215OS_01_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![使用Three.js创建您的第一个3D场景](graphics/2215OS_01_01.jpg)'
- en: 'In this chapter, we''ll directly dive into Three.js and create a couple of
    examples that show you how Three.js works, and which you can use to play around
    with. We won''t dive into all the technical details yet; that''s something you''ll
    learn in the following chapters. In this chapter, we''ll cover the following points:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将直接深入了解Three.js，并创建一些示例，向您展示Three.js的工作原理，并可以用来进行实验。我们不会立即深入所有技术细节；这是您将在接下来的章节中学习的内容。在本章中，我们将涵盖以下内容：
- en: Tools required to work with Three.js
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Three.js所需的工具
- en: Downloading the source code and examples used in this book
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载本书中使用的源代码和示例
- en: Creating your first Three.js scene
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个Three.js场景
- en: Improving the first scene with materials, lights, and animations
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用材质、光线和动画改进第一个场景
- en: Introducing a couple of helper libraries for statistics and controlling the
    scene
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些辅助库，用于统计和控制场景
- en: We'll start this book with a short introduction to Three.js and then quickly
    move on to the first examples and code samples. Before we get started, let's quickly
    look at the most important browsers out there and their support for WebGL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从简短介绍Three.js开始这本书，然后迅速转向第一个示例和代码样本。在我们开始之前，让我们快速看看最重要的浏览器以及它们对WebGL的支持。
- en: 'At the time of writing this, WebGL works with the following desktop browsers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，WebGL与以下桌面浏览器兼容：
- en: '| Browser | Support |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器 | 支持 |'
- en: '| --- | --- |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mozilla Firefox | This browser has supported WebGL since version 4.0. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Mozilla Firefox | 该浏览器自4.0版本起就支持WebGL。 |'
- en: '| Google Chrome | This browser has supported WebGL since version 9. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 谷歌Chrome | 该浏览器自9.0版本起就支持WebGL。 |'
- en: '| Safari | Safari Version 5.1 and newer installed on Mac OS X Mountain Lion,
    Lion, or Snow Leopard supports WebGL. Make sure you enable WebGL in Safari. You
    can do this by going to **Preferences** &#124; **Advanced** and checking **Show
    develop menu in menu bar**. After that, go to **Develop** &#124; **Enable WebGL**.
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| Safari | 安装在Mac OS X Mountain Lion、Lion或Snow Leopard上的Safari版本5.1及更高版本支持WebGL。确保您在Safari中启用了WebGL。您可以通过转到**首选项**
    &#124; **高级**并勾选**在菜单栏中显示开发菜单**来实现这一点。之后，转到**开发** &#124; **启用WebGL**。 |'
- en: '| Opera | This browser has supported WebGL since version 12.00\. You still
    have to enable this by opening **opera:config** and setting the values of **WebGL**
    and **Enable Hardware Acceleration** to `1`. After that, restart the browser.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| Opera | 该浏览器自12.00版本起就支持WebGL。您仍然需要通过打开**opera:config**并将**WebGL**和**启用硬件加速**的值设置为`1`来启用此功能。之后，重新启动浏览器。
    |'
- en: '| Internet Explorer | Internet Explorer was for a long time the only major
    player that didn''t support WebGL. Starting with IE11, Microsoft has added WebGL
    support. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 互联网浏览器 | 很长一段时间以来，IE是唯一不支持WebGL的主要浏览器。从IE11开始，微软已经添加了对WebGL的支持。 |'
- en: Basically, Three.js runs on any of the modern browsers except older versions
    of IE. So, if you want to use an older version of IE, you've got to take an additional
    step. For IE 10 and older, there is the *iewebgl* plugin, which you can get from
    [https://github.com/iewebgl/iewebgl](https://github.com/iewebgl/iewebgl). This
    plugin is installed inside IE 10 and older versions and enables WebGL support
    for those browsers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Three.js可以在任何现代浏览器上运行，除了较旧版本的IE。因此，如果您想使用较旧版本的IE，您需要采取额外的步骤。对于IE 10及更早版本，有*iewebgl*插件，您可以从[https://github.com/iewebgl/iewebgl](https://github.com/iewebgl/iewebgl)获取。此插件安装在IE
    10及更早版本中，并为这些浏览器启用了WebGL支持。
- en: 'It is also possible to run Three.js on mobile devices; the support for WebGL
    and the performance you''ll get will vary, but both are quickly improving:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动设备上也可以运行Three.js；对WebGL的支持和性能会有所不同，但两者都在迅速改善：
- en: '| Device | Support |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | 支持 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Android | The native browser for Android doesn''t have WebGL support and
    is generally also lacking in support for modern HTML5 features. If you want to
    use WebGL on Android, you can use the latest Chrome, Firefox, or Opera mobile
    versions. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| Android | Android的原生浏览器不支持WebGL，通常也缺乏对现代HTML5功能的支持。如果您想在Android上使用WebGL，可以使用最新版本的Chrome、Firefox或Opera移动版。
    |'
- en: '| IOS | With IOS 8, there is also support for WebGL on IOS devices. IOS Safari
    version 8 has great WebGL support. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| IOS | IOS 8也支持IOS设备上的WebGL。IOS Safari 8版本具有出色的WebGL支持。 |'
- en: '| Windows mobile | Windows mobile supports WebGL since version 8.1. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Windows mobile | Windows手机自8.1版本起支持WebGL。 |'
- en: With WebGL, you can create interactive 3D visualizations that run very well
    on desktops and on mobile devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用WebGL，您可以创建在台式机和移动设备上运行非常流畅的交互式3D可视化。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In this book, we'll focus mostly on the WebGL-based renderer provided by Three.js.
    There is, however, also a CSS 3D-based renderer, which provides an easy API to
    create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach
    is that this standard is supported on almost all mobile and desktop browsers and
    allows you to render HTML elements in a 3D space. We'll show how to use the CSS
    3D browser in [Chapter 7](ch07.html "Chapter 7. Particles, Sprites, and the Point
    Cloud"), *Particles, Sprites, and the Point Cloud*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将主要关注Three.js提供的基于WebGL的渲染器。然而，还有一个基于CSS 3D的渲染器，它提供了一个简单的API来创建基于CSS
    3D的3D场景。使用CSS 3D的一个重要优势是，这个标准几乎在所有移动和桌面浏览器上都得到支持，并且允许您在3D空间中渲染HTML元素。我们将展示如何在[第7章](ch07.html
    "第7章。粒子、精灵和点云")中使用CSS 3D浏览器，*粒子、精灵和点云*。
- en: 'In this first chapter, you''ll directly create your first 3D scene and will
    be able to run this in any of the previously mentioned browsers. We won''t introduce
    too many complex Three.js features yet, but at the end of this chapter, you''ll
    have created the Three.js scene you can see in the following screenshot:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将直接创建您的第一个3D场景，并且可以在之前提到的任何浏览器中运行。我们暂时不会介绍太多复杂的Three.js功能，但在本章结束时，您将已经创建了下面截图中可以看到的Three.js场景：
- en: '![Creating Your First 3D Scene with Three.js](graphics/2215OS_01_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![使用Three.js创建您的第一个3D场景](graphics/2215OS_01_02.jpg)'
- en: For this first scene, you'll learn about the basics of Three.js and also create
    your first animation. Before you start your work on this example, in the next
    couple of sections, we'll first look at the tools you need to easily work with
    Three.js and how you can download the examples shown in this book.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个第一个场景中，您将学习Three.js的基础知识，并创建您的第一个动画。在开始这个示例之前，在接下来的几节中，我们将首先看一下您需要轻松使用Three.js的工具，以及如何下载本书中展示的示例。
- en: Requirements to use Three.js
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Three.js的要求
- en: 'Three.js is a JavaScript library, so all you need to create Three.js WebGL
    applications is a text editor and one of the supported browsers to render the
    results. I would like to recommend two JavaScript editors, which I''ve started
    using exclusively over the last couple of years:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js是一个JavaScript库，因此创建Three.js WebGL应用程序所需的只是一个文本编辑器和一个支持的浏览器来渲染结果。我想推荐两款JavaScript编辑器，这是我在过去几年中开始专门使用的：
- en: '**WebStorm**: This editor from the JetBrains guides has great support for editing
    JavaScript. It supports code completion, automatic deployment, and JavaScript
    debugging directly from the editor. Besides this, WebStorm has excellent GitHub
    (and other version control systems) support. You can download a trial edition
    from [http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebStorm：这个来自JetBrains指南的编辑器对编辑JavaScript有很好的支持。它支持代码补全、自动部署和直接从编辑器进行JavaScript调试。除此之外，WebStorm还具有出色的GitHub（和其他版本控制系统）支持。您可以从[http://www.jetbrains.com/webstorm/](http://www.jetbrains.com/webstorm/)下载试用版。
- en: '**Notepad++**: Notepad++ is a general-purpose editor that supports code highlighting
    for a wide range of programming languages. It can easily lay out and format JavaScript.
    Note that Notepad++ is only for Windows. You can download Notepad++ from [http://notepad-plus-plus.org/](http://notepad-plus-plus.org/).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Notepad++：Notepad++是一个通用的编辑器，支持多种编程语言的代码高亮显示。它可以轻松地布局和格式化JavaScript。请注意，Notepad++仅适用于Windows。您可以从[http://notepad-plus-plus.org/](http://notepad-plus-plus.org/)下载Notepad++。
- en: '**Sublime Text Editor**: Sublime is a great editor that has a very good support
    to edit JavaScript. Besides this, it provides many very helpful selections (such
    as multiple-line select) and edit options that, once you get used to them, provide
    a really good JavaScript-editing environment. Sublime can also be tested for free
    and can be downloaded from [http://www.sublimetext.com/](http://www.sublimetext.com/).'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sublime文本编辑器：Sublime是一个很棒的编辑器，对编辑JavaScript有很好的支持。除此之外，它还提供了许多非常有用的选择（如多行选择）和编辑选项，一旦您习惯了它们，就会提供一个非常好的JavaScript编辑环境。Sublime也可以免费测试，并且可以从[http://www.sublimetext.com/](http://www.sublimetext.com/)下载。
- en: Even if you don't use any of these editors, there are a lot of editors available,
    open source and commercial, which you can use to edit JavaScript and create your
    Three.js projects. An interesting project you might want to look at is [http://c9.io](http://c9.io).
    This is a cloud-based JavaScript editor that can be connected to a GitHub account.
    This way, you can directly access all the source code and examples from this book
    and experiment with them.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您不使用这些编辑器，也有很多可用的编辑器，开源和商业的，您可以用来编辑JavaScript并创建您的Three.js项目。您可能想看看的一个有趣的项目是[http://c9.io](http://c9.io)。这是一个基于云的JavaScript编辑器，可以连接到GitHub账户。这样，您就可以直接访问本书中的所有源代码和示例，并对其进行实验。
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Besides these text-based editors that you can use to edit and experiment with
    the sources from this book, Three.js currently also provides an online editor
    itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些文本编辑器，您可以使用它们来编辑和实验本书中的源代码，Three.js目前还提供了一个在线编辑器。
- en: With this editor, which you can find at [http://threejs.org/editor/](http://threejs.org/editor/),
    you can create Three.js scenes using a graphical approach.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个编辑器，您可以在[http://threejs.org/editor/](http://threejs.org/editor/)找到，可以使用图形化的方法创建Three.js场景。
- en: I mentioned that most modern web browsers support WebGL and can be used to run
    Three.js examples. I usually run my code in Chrome. The reason is that most often,
    Chrome has the best support and performance for WebGL and it has a really great
    JavaScript debugger. With this debugger, which is shown in the following screenshot,
    you can quickly pinpoint problems, for instance, using breakpoints and console
    output. This is exemplified in the following screenshot. Throughout this book,
    I'll give you pointers on debugger usage and other debugging tips and tricks.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到大多数现代Web浏览器都支持WebGL，并且可以用于运行Three.js示例。我通常在Chrome中运行我的代码。原因是大多数情况下，Chrome对WebGL有最好的支持和性能，并且具有非常好的JavaScript调试器。通过这个调试器，您可以快速定位问题，例如使用断点和控制台输出。这在下面的截图中有所体现。在本书中，我会给您一些关于调试器使用和其他调试技巧的指导。
- en: '![Requirements to use Three.js](graphics/2215OS_01_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用Three.js的要求](graphics/2215OS_01_03.jpg)'
- en: That's enough for an introduction to Three.js for now; let's get the source
    code and start with the first scene.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关于Three.js的介绍就到此为止；让我们获取源代码并从第一个场景开始吧。
- en: Getting the source code
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取源代码
- en: 'All the code for this book can be accessed from GitHub ([https://github.com/](https://github.com/)).
    GitHub is an online Git-based repository that you can use to store, access, and
    version source code. There are a couple of ways that you can get the sources for
    yourself:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的所有代码都可以从GitHub ([https://github.com/](https://github.com/))访问。GitHub是一个在线的基于Git的存储库，您可以用它来存储、访问和管理源代码的版本。有几种方式可以获取源代码：
- en: Clone the Git repository
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 克隆Git存储库
- en: Download and extract the archive
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并提取存档
- en: In the following two paragraphs, we'll explore these options in a bit more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两段中，我们将稍微详细地探讨这些选项。
- en: Using Git to clone the repository
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Git克隆存储库
- en: Git is an open source distributed version control system that I used to create
    and version all the examples in this book. For this, I used GitHub, a free, online
    Git repository. You can browse this repository by [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个开源的分布式版本控制系统，我用它来创建和管理本书中的所有示例。为此，我使用了GitHub，一个免费的在线Git存储库。您可以通过[https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)浏览此存储库。
- en: 'To get all the examples, you can clone this repository using the `git` command-line
    tool. To do this, you first need to download a Git client for your operating system.
    For most modern operating systems, a client can be downloaded from [http://git-scm.com](http://git-scm.com),
    or you can use the one provided by GitHub itself (for Mac and Windows). After
    installing Git, you can use this to get a *clone* of this book''s repository.
    Open a command prompt and go to the directory where you want to download the sources.
    In that directory, run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有示例，您可以使用`git`命令行工具克隆此存储库。为此，您首先需要为您的操作系统下载一个Git客户端。对于大多数现代操作系统，可以从[http://git-scm.com](http://git-scm.com)下载客户端，或者您可以使用GitHub本身提供的客户端（适用于Mac和Windows）。安装Git后，您可以使用它来获取本书存储库的*克隆*。打开命令提示符并转到您想要下载源代码的目录。在该目录中，运行以下命令：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will start downloading all the examples, as shown in the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始下载所有示例，如下截图所示：
- en: '![Using Git to clone the repository](graphics/2215OS_01_04.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![使用Git克隆存储库](graphics/2215OS_01_04.jpg)'
- en: The `learning-three.js` directory will now contain all the examples that are
    used throughout this book.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`learning-three.js`目录现在将包含本书中使用的所有示例。'
- en: Downloading and extracting the archive
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和提取存档
- en: 'If you don''t want to use Git to download the sources directly from GitHub,
    you can also download an archive. Open [https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)
    in a browser and click on the **Download ZIP** button on the right-hand side,
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想使用Git直接从GitHub下载源代码，您也可以下载一个存档。在浏览器中打开[https://github.com/josdirksen/learning-threejs](https://github.com/josdirksen/learning-threejs)，并点击右侧的**Download
    ZIP**按钮，如下所示：
- en: '![Downloading and extracting the archive](graphics/2215OS_01_05.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![下载和提取存档](graphics/2215OS_01_05.jpg)'
- en: Extract this to a directory of your choice, and you'll have all the examples
    available.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 将其提取到您选择的目录中，您就可以使用所有示例了。
- en: Testing the examples
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试示例
- en: Now that you've downloaded or cloned the source code, let's do a quick check
    to see whether everything is working and make you familiar with the directory
    structure. The code and examples are organized per chapter. There are two different
    ways of viewing examples. You can either open the extracted or cloned folder in
    a browser directly and look at and run a specific example, or you can install
    a local web server. This first approach will work for most of the basic examples,
    but when we start loading external resources, such as models or texture images,
    just opening the HTML file isn't enough. In this case, we need a local web server
    to make sure the external resources are loaded correctly. In the following section,
    we explain a couple of different ways you can set up a simple local web server
    for testing. If you can't set up a local web server but use Chrome or Firefox,
    we also provide an explanation on how to disable certain security features so
    that you can even test without a local web server.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经下载或克隆了源代码，让我们快速检查一下是否一切正常，并让您熟悉目录结构。代码和示例按章节组织。有两种不同的查看示例的方式。您可以直接在浏览器中打开提取或克隆的文件夹，并查看和运行特定示例，或者您可以安装本地Web服务器。第一种方法适用于大多数基本示例，但当我们开始加载外部资源，例如模型或纹理图像时，仅仅打开HTML文件是不够的。在这种情况下，我们需要一个本地Web服务器来确保外部资源被正确加载。在接下来的部分中，我们将解释一些不同的设置简单本地Web服务器的方法。如果您无法设置本地Web服务器但使用Chrome或Firefox，我们还提供了如何禁用某些安全功能的说明，以便您甚至可以在没有本地Web服务器的情况下进行测试。
- en: Setting up a local web server is very easy depending on what you've already
    got installed. In here, we list a couple of examples on how to do this. There
    are many different ways to do this depending on what you've already got installed
    on your system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您已经安装了什么，设置本地Web服务器非常容易。在这里，我们列举了一些示例。根据您系统上已经安装了什么，有许多不同的方法可以做到这一点。
- en: Python-based web servers should work on most Unix/Mac systems
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于Python的Web服务器应该在大多数Unix/Mac系统上工作
- en: 'Most Unix/Linux/Mac systems already have Python installed. On those systems,
    you can very easily start a local web server:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Unix/Linux/Mac系统已经安装了Python。在这些系统上，您可以非常容易地启动本地Web服务器：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Do this in the directory where you checked out / downloaded the source code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在您检出/下载源代码的目录中执行此操作。
- en: Npm-based web server if you've worked with Node.js
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如果您已经使用Node.js，可以使用基于npm的Web服务器
- en: 'If you''ve already done some work with Node.js, there is good chance you''ve
    got npm installed. With npm, you have two simple options to set up a quick local
    web server for testing. The first options uses the `http-server` module, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经使用Node.js做了一些工作，那么您很有可能已经安装了npm。使用npm，您有两个简单的选项来设置一个快速的本地Web服务器进行测试。第一个选项使用`http-server`模块，如下所示：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can also use the `simple-http-server` option, as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您还可以使用`simple-http-server`选项，如下所示：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: A disadvantage of this second approach, however, is that it doesn't automatically
    show directory listings, whereas the first approach does.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种第二种方法的缺点是它不会自动显示目录列表，而第一种方法会。
- en: Portable version Mongoose for Mac and/or Windows
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac和/或Windows的Mongoose便携版
- en: If you haven't got Python or npm installed, there is a simple, portable web
    server, named Mongoose, that you can use. First, download the binaries for your
    specific platform from [https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list).
    If you are using Windows, copy it to the directory containing the examples and
    double-click on the executable to start a web browser serving the directory it
    is started in.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有安装Python或npm，那么有一个名为Mongoose的简单、便携式Web服务器可供您使用。首先，从[https://code.google.com/p/mongoose/downloads/list](https://code.google.com/p/mongoose/downloads/list)下载您特定平台的二进制文件。如果您使用Windows，将其复制到包含示例的目录中，并双击可执行文件以启动Web浏览器，为其启动的目录提供服务。
- en: 'For other operating systems, you must also copy the executable to the target
    directory, but instead of double-clicking on the executable, you have to launch
    it from the command line. In both cases, a local web server will be started on
    port `8080`. The following screenshot encapsulates the discussion in this paragraph:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统，您还必须将可执行文件复制到目标目录，但是不是双击可执行文件，而是必须从命令行启动它。在这两种情况下，本地Web服务器将在端口`8080`上启动。以下屏幕截图概括了本段讨论的内容：
- en: '![Portable version Mongoose for Mac and/or Windows](graphics/2215OS_01_06.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Mac和/或Windows的Mongoose便携版](graphics/2215OS_01_06.jpg)'
- en: By just clicking on a chapter, we can show and access all the examples for that
    specific chapter. If I discuss an example in this book, I'll refer to the specific
    name and folder so that you can directly test and play around with the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过单击章节，我们可以显示和访问该特定章节的所有示例。如果我在本书中讨论一个示例，我将引用特定的名称和文件夹，以便您可以直接测试和玩耍代码。
- en: Disabling security exceptions in Firefox and Chrome
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Firefox和Chrome中禁用安全异常
- en: 'If you use Chrome to run the examples, there is a way to disable some security
    settings so that you can use Chrome to view the examples without requiring a web
    server. To do this, you have to start Chrome in the following way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Chrome运行示例，有一种方法可以禁用一些安全设置，以便您可以使用Chrome查看示例，而无需使用Web服务器。要做到这一点，您必须以以下方式启动Chrome：
- en: 'For Windows, you call the following:'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows，执行以下操作：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'On Linux, do the following:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux上，执行以下操作：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And on Mac OS, you disable the settings by starting Chrome like this:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Mac OS上，通过以下方式禁用设置：
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you start Chrome this way, you can access all the examples directly from
    the local filesystem.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式启动Chrome，您可以直接从本地文件系统访问所有示例。
- en: 'For Firefox users, we need to take a couple of different steps. Open Firefox
    and, in the URL bar, type `about:config`. This is what you''ll see:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Firefox用户，我们需要采取一些不同的步骤。打开Firefox，在URL栏中键入`about:config`。这是您将看到的内容：
- en: '![Disabling security exceptions in Firefox and Chrome](graphics/2215OS_01_07.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![在Firefox和Chrome中禁用安全异常](graphics/2215OS_01_07.jpg)'
- en: 'On this screen, click on the **I''ll be careful, I promise!** button. This
    will show you all the available properties you can use to fine-tune Firefox. In
    the search box on this screen, type in `security.fileuri.strict_origin_policy`
    and change its value to `false` just as we did in the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上，点击**我会小心，我保证！**按钮。这将显示您可以使用的所有可用属性，以便微调Firefox。在此屏幕上的搜索框中，键入`security.fileuri.strict_origin_policy`，并将其值更改为`false`，就像我们在以下屏幕截图中所做的那样：
- en: '![Disabling security exceptions in Firefox and Chrome](graphics/2215OS_01_08.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![在Firefox和Chrome中禁用安全异常](graphics/2215OS_01_08.jpg)'
- en: At this point, you can also use Firefox to directly run the examples provided
    in this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您还可以使用Firefox直接运行本书提供的示例。
- en: Now that you've either got a web server installed, or disabled the necessary
    security settings, it is time to start creating our first Three.js scene.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经安装了Web服务器，或者禁用了必要的安全设置，是时候开始创建我们的第一个Three.js场景了。
- en: Creating the HTML skeleton
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建HTML骨架
- en: 'The first thing we need to do is create an empty skeleton page that we can
    use as the base for all our examples, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个空的骨架页面，我们可以将其用作所有示例的基础，如下所示：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载示例代码文件，用于您购买的所有Packt
    Publishing图书。如果您在其他地方购买了本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: As you can see from this listing, the skeleton is a very simple HTML page, with
    only a couple of elements. In the `<head>` element, we load the external JavaScript
    libraries that we'll use for the examples. For all the examples, we'll at least
    need to load the Three.js library, `three.js`. In the `<head>` element, we also
    add a couple of lines of CSS. These style elements remove any scrollbars when
    we create a full-page Three.js scene. In the `<body>` element of this page, you
    can see a single `<div>` element. When we write our Three.js code, we'll point
    the output of the Three.js renderer to that element. At the bottom of this page,
    you can already see a bit of JavaScript. By assigning the `init` function to the
    `window.onload` property, we make sure that this function gets called when the
    HTML document has finished loading. In the `init` function, we'll insert all the
    Three.js specific JavaScript.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从此列表中可以看出，骨架是一个非常简单的HTML页面，只有几个元素。在`<head>`元素中，我们加载了我们将在示例中使用的外部JavaScript库。对于所有示例，我们至少需要加载Three.js库`three.js`。在`<head>`元素中，我们还添加了几行CSS。这些样式元素在创建全屏Three.js场景时移除任何滚动条。在此页面的`<body>`元素中，您可以看到一个单独的`<div>`元素。当我们编写我们的Three.js代码时，我们将把Three.js渲染器的输出指向该元素。在此页面的底部，您已经可以看到一些JavaScript。通过将`init`函数分配给`window.onload`属性，我们确保在HTML文档加载完成时调用此函数。在`init`函数中，我们将插入所有特定于Three.js的JavaScript。
- en: 'Three.js comes in two versions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js有两个版本：
- en: '**Three.min.js**: This is the library you''d normally use when deploying Three.js
    sites on the Internet. This is a minified version of Three.js, created using **UglifyJS**,
    which is a quarter size of the normal Three.js library. All the examples and code
    used in this book are based on Three.js **r69**, which was released in October
    2014.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.min.js**：这是您在互联网上部署Three.js网站时通常使用的库。这是使用**UglifyJS**创建的Three.js的缩小版本，是正常Three.js库的四分之一大小。本书中使用的所有示例和代码都基于于2014年10月发布的Three.js
    **r69**。'
- en: '**Three.js**: This is the normal Three.js library. We use this library in our
    examples since it makes debugging much easier when you can read and understand
    the Three.js source code.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.js**：这是正常的Three.js库。我们在示例中使用这个库，因为当您能够阅读和理解Three.js源代码时，调试会更加容易。'
- en: If we view this page in our browser, the results aren't very shocking. As you'd
    expect, all you see is an empty page.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中查看此页面，结果并不令人震惊。正如您所期望的那样，您只会看到一个空白页面。
- en: In the next section, you'll learn how to add the first couple of 3D objects
    and render those to the `<div>` element we defined in our HTML skeleton.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，您将学习如何添加前几个3D对象并将其渲染到我们在HTML骨架中定义的`<div>`元素中。
- en: Rendering and viewing a 3D object
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染和查看3D对象
- en: 'In this step, you''ll create your first scene and add a couple of objects and
    a camera. Our first example will contain the following objects:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，您将创建您的第一个场景，并添加一些对象和一个相机。我们的第一个示例将包含以下对象：
- en: '| Object | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 对象 | 描述 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Plane` | This is a two-dimensional rectangle that serves as our ground area.
    In the second screenshot of this chapter, this is rendered as the gray rectangle
    in the middle of the scene. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `Plane` | 这是一个作为我们地面区域的二维矩形。在本章的第二个截图中，它被渲染为场景中间的灰色矩形。 |'
- en: '| `Cube` | This is a three-dimensional cube, which we''ll render in red. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `Cube` | 这是一个三维立方体，我们将以红色渲染。 |'
- en: '| `Sphere` | This is a three-dimensional sphere, which we''ll render in blue.
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `Sphere` | 这是一个三维球体，我们将以蓝色渲染。 |'
- en: '| `Camera` | The camera determines what you''ll see in the output. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `Camera` | 相机决定了输出中你将看到什么。 |'
- en: '| `Axes` | These are the *x*, *y*, and *z* axes. This is a helpful debugging
    tool to see where the objects are rendered in 3D space. The *x* axis is colored
    red, the *y* axis is colored green, and the *z* axis is colored blue. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `Axes` | 这些是*x*、*y*和*z*轴。这是一个有用的调试工具，可以看到对象在3D空间中的渲染位置。*x*轴为红色，*y*轴为绿色，*z*轴为蓝色。
    |'
- en: 'I''ll first show you how this looks in code (the source with comments can be
    found in `chapter-01/02-first-scene.html`), and then I''ll explain what''s happening:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先向您展示代码中的外观（带有注释的源代码可以在`chapter-01/02-first-scene.html`中找到），然后我将解释发生了什么：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If we open this example in the browser, we see something that resembles what
    we''re aiming at (see the screenshot at the beginning of this chapter), but it
    is still a long way off, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在浏览器中打开此示例，我们会看到与我们的目标相似的东西（请参阅本章开头的截图），但仍有很长的路要走，如下所示：
- en: '![Rendering and viewing a 3D object](graphics/2215OS_01_09.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![渲染和查看3D对象](graphics/2215OS_01_09.jpg)'
- en: 'Before we start making this more beautiful, I''ll first walk you through the
    code a step at a time so that you understand what the code does:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始让这个更加美丽之前，我将逐步向您介绍代码，以便您了解代码的作用：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At the top of the example, we define `scene`, `camera`, and `renderer`. The
    `scene` object is a container that is used to store and keep track of all the
    objects we want to render and all the lights we want to use. Without a `THREE.Scene`
    object, Three.js isn't able to render anything. More information on the `THREE.Scene`
    object can be found in the next chapter. The sphere and the cube we want to render
    will be added to scene later on in the example. In this first fragment, we also
    create a `camera` object. The `camera` object defines what we'll see when we render
    a scene. In [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up a
    Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, you learn
    more about the arguments you can pass in to the `camera` object. Next we define
    `renderer`. The `renderer` object is responsible for calculating what the `scene`
    object will look like in the browser based on the `camera` object's angle. We
    create `WebGLRenderer` that uses your graphics card to render the scene in this
    example.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例的顶部，我们定义了`scene`，`camera`和`renderer`。`scene`对象是一个容器，用于存储和跟踪我们要渲染的所有对象和我们要使用的所有灯光。没有`THREE.Scene`对象，Three.js就无法渲染任何东西。关于`THREE.Scene`对象的更多信息可以在下一章中找到。我们想要渲染的球体和立方体将在示例的后面添加到场景中。在这个第一个片段中，我们还创建了一个`camera`对象。`camera`对象定义了我们在渲染场景时会看到什么。在[第2章](ch02.html
    "第2章. Three.js场景的基本组件")中，*Three.js场景的基本组件*，您将了解有关您可以传递给`camera`对象的参数的更多信息。接下来我们定义`renderer`。`renderer`对象负责根据`camera`对象的角度在浏览器中计算`scene`对象的外观。在这个示例中，我们创建了一个使用您的图形卡来渲染场景的`WebGLRenderer`。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you look through the source code and the documentation of Three.js (which
    you can find at [http://threejs.org/](http://threejs.org/)), you'll notice that
    there are different renderers available besides the WebGL-based one. There is
    a canvas-based renderer and even an SVG-based one. Even though they work and can
    render simple scenes, I wouldn't recommend using them. They're very CPU-intensive
    and lack features such as good material support and shadows.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看Three.js的源代码和文档（您可以在[http://threejs.org/](http://threejs.org/)找到），您会注意到除了基于WebGL的渲染器之外，还有其他不同的渲染器可用。有一个基于画布的渲染器，甚至还有一个基于SVG的渲染器。尽管它们可以工作并且可以渲染简单的场景，但我不建议使用它们。它们非常消耗CPU，并且缺乏诸如良好的材质支持和阴影等功能。
- en: Here, we set the background color of `renderer` to almost white (`new THREE.Color(0XEEEEEE)`)
    with the `setClearColor` function and tell `renderer` how large the scene needs
    to be rendered using the `setSize` function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`renderer`的背景颜色设置为接近白色（`new THREE.Color(0XEEEEEE)`），并使用`setClearColor`函数告诉`renderer`需要渲染的场景有多大。
- en: 'So far, we''ve got a basic empty scene, a renderer, and a camera. There is,
    however, nothing yet to render. The following code adds the helper axes and the
    plane:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个基本的空场景，一个渲染器和一个摄像头。然而，还没有要渲染的东西。以下代码添加了辅助轴和平面：
- en: '[PRE10]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, we create an `axes` object and use the `scene.add` function
    to add these axes to our scene. Next, we create the plane. This is done in two
    steps. First, we define what the plane looks like using the new `THREE.PlaneGeometry(60,20)`
    code. In this case, it has a width of `60` and a height of `20`. We also need
    to tell Three.js what this plane looks like (for example, its color and its transparency).
    In Three.js, we do this by creating a material object. For this first example,
    we'll create a basic material (`THREE.MeshBasicMaterial`) with the color `0xcccccc`.
    Next, we combine these two into a `Mesh` object with the name `plane`. Before
    we add `plane` to the scene, we need to put it in the correct position; we do
    this by first rotating it 90 degrees around the x axis, and next, we define its
    position in the scene using the position properties. If you're already interested
    in the details of this, look at the `06-mesh-properties.html` example from the
    code folder of [Chapter 2](ch02.html "Chapter 2. Basic Components That Make Up
    a Three.js Scene"), *Basic Components That Make Up a Three.js Scene*, which shows
    and explains rotation and positioning. We then need to do is add `plane` to `scene`,
    just like we did with `axes`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们创建了一个`axes`对象，并使用`scene.add`函数将这些轴添加到我们的场景中。接下来，我们创建了平面。这是分两步完成的。首先，我们使用新的`THREE.PlaneGeometry(60,20)`代码定义了平面的外观。在这种情况下，它的宽度为`60`，高度为`20`。我们还需要告诉Three.js这个平面的外观（例如，它的颜色和透明度）。在Three.js中，我们通过创建一个材质对象来实现这一点。对于这个第一个示例，我们将创建一个基本材质（`THREE.MeshBasicMaterial`），颜色为`0xcccccc`。接下来，我们将这两者合并成一个名为`plane`的`Mesh`对象。在将`plane`添加到场景之前，我们需要将其放在正确的位置；我们首先围绕x轴旋转它90度，然后使用位置属性在场景中定义其位置。如果您已经对此感兴趣，请查看[第2章](ch02.html
    "第2章. Three.js场景的基本组件")的代码文件夹中的`06-mesh-properties.html`示例，该示例显示并解释了旋转和定位。然后我们需要做的就是像我们对`axes`所做的那样将`plane`添加到`scene`中。
- en: 'The `cube` and `sphere` objects are added in the same manner, but with the
    `wireframe` property set to `true`, which tells Three.js to render a wireframe
    and not a solid object. Now, let''s move on to the final part of this example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`cube`和`sphere`对象以相同的方式添加，但`wireframe`属性设置为`true`，告诉Three.js渲染线框而不是实心对象。现在，让我们继续进行这个示例的最后部分：'
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, all the elements we want to render are added to the scene at
    the correct positions. I've already mentioned that the camera defines what will
    be rendered. In this piece of code, we position the camera using the `x`, `y`,
    and `z` position attributes to hover above our scene. To make sure the camera
    is looking at our objects, we use the `lookAt` function to point it at the center
    of our scene, which is located at position (0, 0, 0) by default. All that is left
    to do is append the output from the renderer to the `<div>` element of our HTML
    skeleton. We use standard JavaScript to select the correct output element and
    append it to our `div` element with the `appendChild` function. Finally, we tell
    `renderer` to render `scene` using the `camera` object provided.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们想要渲染的所有元素都已经添加到了正确的位置。我已经提到相机定义了什么将被渲染。在这段代码中，我们使用`x`、`y`和`z`位置属性来定位相机，使其悬浮在我们的场景上方。为了确保相机看向我们的对象，我们使用`lookAt`函数将其指向我们场景的中心，默认情况下位于位置（0,
    0, 0）。剩下的就是将渲染器的输出附加到我们HTML骨架的`<div>`元素上。我们使用标准的JavaScript来选择正确的输出元素，并使用`appendChild`函数将其附加到我们的`div`元素上。最后，我们告诉`renderer`使用提供的`camera`对象来渲染`scene`。
- en: In the next couple of sections, we'll make this scene more pretty by adding
    lights, shadows, more materials, and even animations.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将通过添加光源、阴影、更多材质甚至动画使这个场景更加美观。
- en: Adding materials, lights, and shadows
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加材质、光源和阴影
- en: 'Adding new materials and lights in Three.js is very simple and is done in pretty
    much the same way as we explained in the previous section. We start by adding
    a light source to the scene (for the complete source look at `03-materials-light.html`),
    as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中添加新的材质和光源非常简单，几乎与我们在上一节中解释的方式相同。我们首先通过以下方式向场景添加光源（完整的源代码请查看`03-materials-light.html`）：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`THREE.SpotLight` illuminates our scene from its position (`spotLight.position.set(
    -40, 60, -10 )`). If we render the scene this time, however, you won''t see any
    difference from the previous one. The reason is that different materials respond
    differently to light. The basic material we used in the previous example (`THREE.MeshBasicMaterial`)
    doesn''t do anything with the light sources in the scene. They just render the
    object in the specified color. So, we have to change the materials for `plane`,
    `sphere`, and `cube` to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`THREE.SpotLight`从其位置（`spotLight.position.set(-40, 60, -10)`）照亮我们的场景。然而，如果这次渲染场景，您不会看到与上一个场景的任何不同。原因是不同的材质对光的反应不同。我们在上一个示例中使用的基本材质（`THREE.MeshBasicMaterial`）在场景中不会对光源产生任何影响。它们只是以指定的颜色渲染对象。因此，我们必须将`plane`、`sphere`和`cube`的材质更改为以下内容：'
- en: '[PRE13]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this piece of code, we changed the materials for our objects to `MeshLambertMaterial`.
    This material and `MeshPhongMaterial` are the materials Three.js provides that
    take light sources into account when rendered.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们将对象的材质更改为`MeshLambertMaterial`。这种材质和`MeshPhongMaterial`是Three.js提供的在渲染时考虑光源的材质。
- en: 'The result, shown in the following screenshot, however, still isn''t what we''re
    looking for:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如下截图所示的结果仍然不是我们要找的：
- en: '![Adding materials, lights, and shadows](graphics/2215OS_01_10.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![添加材质、光源和阴影](graphics/2215OS_01_10.jpg)'
- en: We're getting there, and cube and sphere are looking a lot better. What is still
    missing, though, are the shadows.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经接近了，立方体和球看起来好多了。然而，还缺少的是阴影。
- en: 'Rendering shadows takes a lot of computing power, and for that reason, shadows
    are disabled by default in Three.js. Enabling them, though, is very easy. For
    shadows, we have to change the source in a couple of places, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染阴影需要大量的计算能力，因此在Three.js中默认情况下禁用阴影。不过，启用它们非常容易。对于阴影，我们需要在几个地方更改源代码，如下所示：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first change we need to make is tell `renderer` that we want shadows. You
    do this by setting the `shadowMapEnabled` property to `true`. If you look at the
    result from this change, you won''t notice anything different yet. That is because
    we need to explicitly define which objects cast shadows and which objects receive
    shadows. In our example, we want the sphere and the cube to cast shadows on the
    ground plane. You do this by setting the corresponding properties on those objects:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一个更改是告诉`renderer`我们想要阴影。您可以通过将`shadowMapEnabled`属性设置为`true`来实现这一点。如果您查看这个更改的结果，您暂时不会注意到任何不同。这是因为我们需要明确定义哪些对象投射阴影，哪些对象接收阴影。在我们的示例中，我们希望球体和立方体在地面上投射阴影。您可以通过在这些对象上设置相应的属性来实现这一点：
- en: '[PRE15]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, there is just one more thing to do to get the shadows. We need to define
    which light sources in our scene will cause shadows. Not all the lights can cast
    shadows, and you''ll learn more about that in the next chapter, but `THREE.SpotLight`,
    which we used in this example, can. We only need to set the correct property,
    as shown in the following line of code, and the shadows will finally be rendered:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要做一件事就可以得到阴影了。我们需要定义我们场景中哪些光源会产生阴影。并非所有的光源都能产生阴影，您将在下一章中了解更多相关信息，但是我们在这个示例中使用的`THREE.SpotLight`可以。我们只需要设置正确的属性，如下代码行所示，阴影最终将被渲染出来：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And with this, we get a scene complete with shadows from our light source,
    as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们得到了一个包含来自光源的阴影的场景，如下所示：
- en: '![Adding materials, lights, and shadows](graphics/2215OS_01_11.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![添加材质、光源和阴影](graphics/2215OS_01_11.jpg)'
- en: The last feature that we'll add to this first scene is some simple animation.
    In [Chapter 9](ch09.html "Chapter 9. Animations and Moving the Camera"), *Animations
    and Moving the Camera*, you'll learn more advanced animation options.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加到这个第一个场景的最后一个特性是一些简单的动画。在[第9章](ch09.html "第9章。动画和移动摄像机")*动画和移动摄像机*中，您将了解更高级的动画选项。
- en: Expanding your first scene with animations
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过动画扩展您的第一个场景
- en: If we want to animate the scene, the first thing that we need to do is find
    some way to re-render the scene at a specific interval. Before HTML5 and the related
    JavaScript APIs came along, the way to do this was using the `setInterval(function,interval)`
    function. With `setInterval`, we could specify a function that, for instance,
    would be called every 100 milliseconds. The problem with this function is that
    it doesn't take into account what is happening in the browser. If you were browsing
    another tab, this function would still be fired every couple of milliseconds.
    Besides that, `setInterval` isn't synchronized with the redrawing of the screen.
    This can lead to higher CPU usage and bad performance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要对场景进行动画，我们需要做的第一件事是找到一种在特定间隔重新渲染场景的方法。在HTML5和相关的JavaScript API出现之前，做到这一点的方法是使用`setInterval(function,interval)`函数。使用`setInterval`，我们可以指定一个函数，例如，每100毫秒调用一次。这个函数的问题在于它不考虑浏览器中正在发生的事情。如果您正在浏览另一个标签页，这个函数仍然会每隔几毫秒触发一次。此外，`setInterval`与屏幕重绘不同步。这可能导致更高的CPU使用率和性能不佳。
- en: Introducing requestAnimationFrame
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍requestAnimationFrame
- en: 'Modern browsers luckily have a solution for that with the `requestAnimationFrame`
    function. With `requestAnimationFrame`, you can specify a function that is called
    at an interval defined by the browser. You do any drawing you need to do in the
    supplied function, and the browser will make sure it is painted as smoothly and
    efficiently as possible. Using this is really simple (the complete source can
    be found in the `04-materials-light-animation.html` file), you just create a function
    that handles the rendering:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器幸运地有一个解决方案，使用`requestAnimationFrame`函数。使用`requestAnimationFrame`，您可以指定一个由浏览器定义的间隔调用的函数。您可以在提供的函数中进行任何绘图，浏览器将确保尽可能平滑和高效地绘制。使用这个函数非常简单（完整的源代码可以在`04-materials-light-animation.html`文件中找到），您只需创建一个处理渲染的函数：
- en: '[PRE17]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In this `renderScene` function, we call `requestAnimationFrame` again, to keep
    the animation going. The only thing we need to change in the code is that instead
    of calling `renderer.render` after we''ve created the complete scene, we call
    the `renderScene` function once to kick off the animation:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`renderScene`函数中，我们再次调用`requestAnimationFrame`，以保持动画进行。我们需要在代码中改变的唯一一件事是，在我们创建完整的场景后，我们不再调用`renderer.render`，而是调用`renderScene`函数一次，以启动动画：
- en: '[PRE18]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you run this, you won't see any changes yet compared to the previous example
    because we haven't animated anything yet. Before we add the animation, though,
    I want to introduce a small helper library that gives us information about the
    frame rate the animation is running at. This library, from the same author as
    Three.js, renders a small graph that shows us the frames per second we're getting
    for this animation.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行这个代码，与之前的例子相比，您不会看到任何变化，因为我们还没有进行任何动画。在添加动画之前，我想介绍一个小的辅助库，它可以为我们提供有关动画运行帧率的信息。这个库来自与Three.js相同作者，它渲染了一个小图表，显示了我们为这个动画获得的每秒帧数。
- en: 'To add these statistics, we first need to include the library in the `<head>`
    element of the HTML, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加这些统计信息，我们首先需要在HTML的`<head>`元素中包含库，如下所示：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'And we add a `<div>` element that will be used as output for the statistics
    graph, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加一个`<div>`元素，用作统计图的输出，如下所示：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The only thing left to do is initialize the statistics and add them to this
    `<div>` element, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是初始化统计信息并将它们添加到这个`<div>`元素中，如下所示：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This function initializes the statistics. The interesting part is the `setMode`
    function. If we set it to `0`, we''ll measure frames per second (fps), and if
    we set this to `1`, we can measure rendering time. For this example, we''re interested
    in fps, so `0` it is. At the beginning of our `init()` function, we''ll call this
    function, and we''ve got `stats` enabled, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数初始化了统计信息。有趣的部分是`setMode`函数。如果我们将其设置为`0`，我们将测量每秒帧数（fps），如果我们将其设置为`1`，我们可以测量渲染时间。对于这个例子，我们对fps感兴趣，所以设置为`0`。在我们的`init()`函数的开头，我们将调用这个函数，这样我们就启用了`stats`，如下所示：
- en: '[PRE22]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The only thing left to do is tell the `stats` object when we're in a new rendering
    cycle. We do this by adding a call to the `stats.update` function in our `renderScene`
    function, as follows.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一剩下的事情就是告诉`stats`对象我们何时处于新的渲染周期。我们通过在`renderScene`函数中添加对`stats.update`函数的调用来实现这一点，如下所示。
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you run the code with these additions, you''ll see the statistics in the
    upper-left corner, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行带有这些添加的代码，您将在左上角看到统计信息，如下面的截图所示：
- en: '![Introducing requestAnimationFrame](graphics/2215OS_01_12.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![介绍requestAnimationFrame](graphics/2215OS_01_12.jpg)'
- en: Animating the cube
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为立方体添加统计信息
- en: 'With `requestAnimationFrame` and the statistics configured, we''ve got a place
    to put our animation code. In this section, we''ll expand the `renderScene` function
    with code that will rotate our red cube around all of its axes. Let''s start by
    showing you the code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`requestAnimationFrame`和配置好的统计信息，我们有了一个放置动画代码的地方。在本节中，我们将扩展`renderScene`函数的代码，以使我们的红色立方体围绕所有轴旋转。让我们先向您展示代码：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: That looks simple, right? What we do is that we increase the `rotation` property
    of each of the axes with 0.02 every time the `renderScene` function is called,
    which shows up as a cube smoothly rotating around all if its axes. Bouncing the
    blue ball isn't much harder.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，对吧？我们所做的是每次调用`renderScene`函数时，都增加每个轴的`rotation`属性0.02，这样就会显示一个立方体平滑地围绕所有轴旋转。让蓝色的球弹跳并不难。
- en: Bouncing the ball
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹跳球
- en: 'To bounce the ball, we once again add a couple of lines of code to our `renderScene`
    function, as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让球弹跳，我们再次向`renderScene`函数中添加了几行代码，如下所示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the cube, we changed the `rotation` property; for the sphere, we''re going
    to change its `position` property in the scene. We want the sphere to bounce from
    one point in the scene to another with a nice, smooth curve. This is shown in
    the following figure:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用立方体，我们改变了“旋转”属性；对于球体，我们将在场景中改变其“位置”属性。我们希望球体能够从场景中的一个点弹跳到另一个点，并呈现出一个漂亮、平滑的曲线。如下图所示：
- en: '![Bouncing the ball](graphics/2215OS_01_13.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![弹跳球](graphics/2215OS_01_13.jpg)'
- en: 'For this, we need to change its position on the *x* axis and its position on
    the *y* axis. The `Math.cos` and `Math.sin` functions help us in creating a smooth
    trajectory using the step variable. I won''t go into the details of how this works
    here. For now, all you need to know is that `step+=0.04` defines the speed of
    the bouncing sphere. In [Chapter 8](ch08.html "Chapter 8. Creating and Loading
    Advanced Meshes and Geometries"), *Creating and Loading Advanced Meshes and Geometries*,
    we''ll look in much more detail how these functions can be used for animation,
    and I''ll explain everything. Here''s how the ball looks in the middle of a bounce:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们需要改变它在*x*轴上的位置和在*y*轴上的位置。`Math.cos`和`Math.sin`函数帮助我们使用步长变量创建平滑的轨迹。我不会在这里详细介绍这是如何工作的。现在，你需要知道的是`step+=0.04`定义了弹跳球的速度。在[第8章](ch08.html
    "第8章。创建和加载高级网格和几何体")中，*创建和加载高级网格和几何体*，我们将更详细地看看这些函数如何用于动画，并且我会解释一切。这是球在弹跳中间的样子：
- en: '![Bouncing the ball](graphics/2215OS_01_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![弹跳球](graphics/2215OS_01_14.jpg)'
- en: Before wrapping up this chapter, I want to add one more element to our basic
    scene. When working with 3D scenes, animations, colors, and properties like that,
    it often requires a bit of experimenting to get the correct color or speed. It
    would be very easy if you could just have a simple GUI that allows you to change
    these kinds of properties on the fly. Luckily, there is!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我想在我们的基本场景中再添加一个元素。当处理3D场景、动画、颜色和类似属性时，通常需要一些试验来获得正确的颜色或速度。如果你能有一个简单的GUI，可以让你随时改变这些属性，那就太方便了。幸运的是，有这样的工具！
- en: Using dat.GUI to make experimenting easier
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用dat.GUI使实验更容易
- en: 'A couple of employees from Google created a library called **dat.GUI** (you
    can find the documentation online at [http://code.google.com/p/dat-gui/](http://code.google.com/p/dat-gui/)),
    which allows you to very easily create a simple user interface component that
    can change variables in your code. In this last part of this chapter, we''ll use
    dat.GUI to add a user interface to our example that allows us to change the following:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Google的几名员工创建了一个名为**dat.GUI**的库（你可以在[http://code.google.com/p/dat-gui/](http://code.google.com/p/dat-gui/)上找到在线文档），它可以让你非常容易地创建一个简单的用户界面组件，可以改变你代码中的变量。在本章的最后部分，我们将使用dat.GUI为我们的示例添加一个用户界面，允许我们改变以下内容：
- en: Control the speed of the bouncing ball
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制弹跳球的速度
- en: Control the rotation of the cube
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制立方体的旋转
- en: 'Just like we had to do for the statistics, we first add this library to the
    `<head>` element of our HTML page, as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为统计数据所做的那样，我们首先将这个库添加到我们HTML页面的`<head>`元素中，如下所示：
- en: '[PRE26]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next thing we need to configure is a JavaScript object that will hold the
    properties we want to change using dat.GUI. In the main part of our JavaScript
    code, we add the following JavaScript object, as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要配置的是一个JavaScript对象，它将保存我们想要使用dat.GUI改变的属性。在我们的JavaScript代码的主要部分，我们添加以下JavaScript对象，如下所示：
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In this JavaScript object, we define two properties—`this.rotationSpeed` and
    `this.bouncingSpeed`—and their default values. Next, we pass this object into
    a new dat.GUI object and define the range for these two properties, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个JavaScript对象中，我们定义了两个属性——`this.rotationSpeed`和`this.bouncingSpeed`——以及它们的默认值。接下来，我们将这个对象传递给一个新的dat.GUI对象，并为这两个属性定义范围，如下所示：
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `rotationSpeed` and `bouncingSpeed` properties are both set to a range
    of `0` to `0.5`. All we need to do now is make sure that in our `renderScene`
    loop, we reference these two properties directly so that when we make changes
    through the dat.GUI user interface, it immediately affects the rotation and bounce
    speed of our objects, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotationSpeed`和`bouncingSpeed`属性都设置为`0`到`0.5`的范围。现在我们所需要做的就是确保在我们的`renderScene`循环中，直接引用这两个属性，这样当我们通过dat.GUI用户界面进行更改时，它立即影响我们对象的旋转和弹跳速度，如下所示：'
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, when you run this example (`05-control-gui.html`), you''ll see a simple
    user interface that you can use to control the bouncing and rotation speeds. A
    screenshot of the bouncing ball and the rotating cube is shown here:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行这个示例（`05-control-gui.html`），你会看到一个简单的用户界面，你可以用它来控制弹跳和旋转速度。下面是弹跳球和旋转立方体的屏幕截图：
- en: '![Using dat.GUI to make experimenting easier](graphics/2215OS_01_15.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![使用dat.GUI使实验更容易](graphics/2215OS_01_15.jpg)'
- en: If you've looked at the examples in your browser, you might have noticed that
    when you change the size of your browser, the scene doesn't automatically scale.
    In the next section, we'll add this as a final feature for this chapter.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在浏览器中查看示例，你可能会注意到当你改变浏览器的大小时，场景并不会自动缩放。在下一节中，我们将把这作为本章的最后一个特性添加进去。
- en: Automatically resize the output when browser size changes
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当浏览器大小改变时自动调整输出大小
- en: 'Changing the camera when the browser is resized can be done pretty simply.
    The first thing we need to do is register an event listener like this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器大小改变时改变摄像机可以很简单地完成。我们需要做的第一件事是注册一个事件监听器，就像这样：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, whenever the browser window is resized, the `onResize` function, which
    we''ll specify next, is called. In this `onResize` function, we need to update
    the camera and renderer, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当浏览器窗口大小改变时，我们将调用`onResize`函数。在这个`onResize`函数中，我们需要更新摄像机和渲染器，如下所示：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'For the camera, we need to update the `aspect` property, which holds the aspect
    ratio of the screen, and for the `renderer`, we need to change its size. The final
    step is to move the variable definitions for `camera`, `renderer`, and `scene`
    outside of the `init()` function so that we can access them from different functions
    (like the `onResize` function), as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摄像机，我们需要更新`aspect`属性，它保存了屏幕的宽高比，对于`renderer`，我们需要改变它的大小。最后一步是将`camera`、`renderer`和`scene`的变量定义移到`init()`函数之外，这样我们就可以从不同的函数（比如`onResize`函数）中访问它们，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: To see this effect in action, open the `06-screen-size-change.html` example
    and resize your browser window.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这种效果，打开`06-screen-size-change.html`示例并调整浏览器窗口大小。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That's it for the first chapter. In this chapter, we showed you how to set up
    your development environment, how to get the code, and how to get started with
    the examples provided with this book. You further learned that to render a scene
    with Three.js, you first have to create a `THREE.Scene` object, add a camera,
    a light, and the objects that you want to render. We also showed you how you can
    expand this basic scene by adding shadows and animations. Lastly, we added a couple
    of helper libraries. We used dat.GUI, which allows you to quickly create control
    user interfaces, and we added `stats.js`, which provided feedback on the frame
    rate at which your scene is rendered.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章就到这里。在本章中，我们向您展示了如何设置开发环境，如何获取代码，以及如何开始使用本书提供的示例。您还学会了，要使用Three.js渲染场景，首先必须创建一个`THREE.Scene`对象，添加相机、光线和要渲染的对象。我们还向您展示了如何通过添加阴影和动画来扩展基本场景。最后，我们添加了一些辅助库。我们使用了dat.GUI，它允许您快速创建控制用户界面，并添加了`stats.js`，它提供了有关场景渲染帧率的反馈。
- en: In the next chapter, we'll expand on the example we created here. You'll learn
    more about the most important building blocks that you can use in Three.js.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展我们在这里创建的示例。您将了解更多关于在Three.js中可以使用的最重要的构建模块。
