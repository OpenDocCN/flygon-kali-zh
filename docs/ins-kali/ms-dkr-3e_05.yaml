- en: Docker Compose
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: 'In this chapter, we will be taking a look at another core Docker tool called
    Docker Compose, and also the currently in-development Docker App. We will break
    the chapter down into the following sections:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍另一个核心Docker工具，称为Docker Compose，以及目前正在开发中的Docker App。我们将把本章分解为以下几个部分：
- en: Docker Compose introduction
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose介绍
- en: Our first Docker Compose application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一个Docker Compose应用程序
- en: Docker Compose YAML files
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose YAML文件
- en: Docker Compose commands
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose命令
- en: Docker App
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker App
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in previous chapters, we will continue to use our local Docker installations.
    Again, the screenshots in this chapter will be from my preferred operating system,
    macOS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，我们将继续使用本地的Docker安装。同样，在本章中的截图将来自我首选的操作系统macOS。
- en: As before, the Docker commands we will be running will work on all three of
    the operating systems on which we have installed Docker so far. However, some
    of the supporting commands, which will be few and far between, may only apply
    to macOS and Linux-based operating systems.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '与以前一样，我们将运行的Docker命令将适用于我们迄今为止安装了Docker的三种操作系统。但是，一些支持命令可能只适用于macOS和基于Linux的操作系统。 '
- en: A full copy of the code used in this chapter can be found at: [https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码的完整副本可以在以下网址找到：[https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05](https://github.com/PacktPublishing/Mastering-Docker-Third-Edition/tree/master/chapter05)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 观看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2q7MJZU](http://bit.ly/2q7MJZU)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2q7MJZU](http://bit.ly/2q7MJZU)'
- en: Introducing Docker Compose
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Docker Compose
- en: In Chapter 1*, Docker Overview,* we discussed a few of the problems that Docker
    has been designed to solve. We explained how it addresses challenges such as running
    two applications side by side by isolating processes into a single container,
    meaning that you can run two entirely different versions of the same software
    stack, say PHP 5.6 and PHP 7, on the same host, as we did in [Chapter 2](55a49886-9299-4a9b-a3b6-241641a6c097.xhtml)*, Building
    Container Images*.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章*，Docker概述*中，我们讨论了Docker旨在解决的一些问题。我们解释了它如何解决诸如通过将进程隔离到单个容器中来同时运行两个应用程序等挑战，这意味着您可以在同一主机上运行完全不同版本的相同软件堆栈，比如PHP
    5.6和PHP 7，就像我们在[第2章](55a49886-9299-4a9b-a3b6-241641a6c097.xhtml)*，构建容器镜像*中所做的那样。
- en: Towards the end of [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*,
    Managing Containers*, we launched an application that was made up of multiple
    containers rather than running the required software stack in a single container.
    The example application we started, Moby Counter, is written in Node.js and uses
    Redis as a backend to store key values, which, in our case, were the location
    of the Docker logos on screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4章](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*，管理容器*的最后，我们启动了一个由多个容器组成的应用程序，而不是在单个容器中运行所需的软件堆栈。我们启动的示例应用程序Moby
    Counter是用Node.js编写的，并使用Redis作为后端来存储键值，这里我们的案例是Docker标志的位置。
- en: This meant that we had to launch two containers, one for the application and
    one for Redis. While it was quite simple to do this as the application itself
    was quite basic, there are a number of disadvantages to manually launching single
    containers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须启动两个容器，一个用于应用程序，一个用于Redis。虽然启动应用程序本身相当简单，但手动启动单个容器存在许多缺点。
- en: 'For example, if I wanted a colleague to deploy the same application, I would
    have to pass them the following commands:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我想让同事部署相同的应用程序，我将不得不传递以下命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Okay, I could get away with losing the first two commands as the image will
    be pulled during the run if they haven't already pulled it, but as the application
    starts to get more complex, I will have to start passing on an ever-growing set
    of commands and instructions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果镜像还没有被拉取，我可以不用执行前两个命令，因为在运行时会拉取镜像，但随着应用程序变得更加复杂，我将不得不开始传递一个越来越庞大的命令和指令集。
- en: I would also have to make it clear that they would have to take into account
    the order in which the commands need to be executed. Furthermore, my notes would
    have to include details of any potential issues to support them through any problems—which
    could mean we find ourselves in a *worked is DevOps problem now* scenario, which
    we want to avoid at all costs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我还必须明确指出，他们必须考虑命令需要执行的顺序。此外，我的笔记还必须包括任何潜在问题的细节，以帮助他们解决任何问题——这可能意味着我们现在面临的是一个*工作是DevOps问题*的场景，我们要尽一切努力避免。
- en: While Docker's responsibility should end at creating the images and launching
    containers using these images, they saw this as a scenario that the technology
    is meant to stop us from finding ourselves in. Thanks to Docker, people no longer
    have to worry about inconsistencies in the environment they are launching their
    applications in as they can now be shipped in images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker的责任应该止步于创建镜像和使用这些镜像启动容器，但他们认为这是技术意味着我们不会陷入的一个场景。多亏了Docker，人们不再需要担心他们启动应用程序的环境中的不一致性，因为现在可以通过镜像进行部署。
- en: For this reason, back in July 2014, Docker purchased a small British start-up
    who offered two container-based products called Orchard Laboratories.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，回到2014年7月，Docker收购了一家名为Orchard Laboratories的小型英国初创公司，他们提供了两种基于容器的产品。
- en: 'The first of the two products was a Docker-based hosting platform: think of
    it as a hybrid of Docker Machine, which we will be looking at in a later chapter,
    and Docker itself. From a single command, `orchard`, you could launch a host machine
    and then proxy your Docker commands through to the newly launched host; for example,
    you would use the following commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个产品中的第一个是基于Docker的主机平台：可以将其视为Docker Machine和Docker本身的混合体。通过一个单一的命令`orchard`，您可以启动一个主机机器，然后将您的Docker命令代理到新启动的主机上；例如，您可以使用以下命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These would have launched a Docker host on Orchard's platform and then a Redis
    container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个是在Orchard平台上启动Docker主机，然后启动一个Redis容器。
- en: The second product was an open source project called **Fig**. Fig lets you use
    a `YAML` file to define how you would like your multi-container application to
    be structured. It would then take the `YAML` file and automate the launch of the
    containers as defined. The advantage of this was that because it was a YAML file,
    it was straightforward for developers to start shipping `fig.yml` files alongside
    their Dockerfiles within their code bases.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个产品是一个名为Fig的开源项目。Fig允许您使用`YAML`文件来定义您想要如何构建多容器应用程序的结构。然后，它会根据`YAML`文件自动启动容器。这样做的好处是，因为它是一个YAML文件，开发人员可以很容易地在他们的代码库中开始使用`fig.yml`文件和Dockerfiles一起进行部署。
- en: Of these two products, Docker purchased Orchard Laboratories for Fig. After
    a short while, the Orchard service was discontinued, and, in February 2015, Fig
    became Docker Compose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种产品中，Docker为Fig收购了Orchard Laboratories。不久之后，Orchard服务被停止，2015年2月，Fig成为了Docker
    Compose。
- en: As part of our installation of Docker for Mac, Docker for Windows, and Docker
    on Linux in [Chapter 1](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml)*, Docker Overview,*
    we installed Docker Compose, so rather than discussing what it does any further,
    let's try and bring up the two-container application we launched manually at the
    end of the last chapter using just Docker Compose.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们在[第1章](db23d482-1df4-41c2-af33-d38a98fc5a1c.xhtml)*Docker概述*中安装Docker for
    Mac、Docker for Windows和Linux上的Docker的一部分，我们安装了Docker Compose，因此不再讨论它的功能，让我们尝试使用Docker
    Compose仅仅启动我们在上一章末尾手动启动的两个容器应用程序。
- en: Our first Docker Compose application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个Docker Compose应用程序
- en: 'As already mentioned, Docker Compose uses a YAML file, typically named `dockercompose.yml`,
    to define what your multi-container application should look like. The Docker Compose
    representation of the two-container application we launched in [Chapter 4](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*,
    Managing Containers*, is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker Compose使用一个YAML文件，通常命名为`dockercompose.yml`，来定义您的多容器应用程序应该是什么样子的。我们在[第4章](d1bc49d6-f8f8-4c0d-b094-695d42c09f88.xhtml)*管理容器*中启动的两个容器应用程序的Docker
    Compose表示如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Even without working through each of the lines in the file, it should be quite
    straightforward to follow along with what is going on. To launch our application,
    we simply change to the folder that contains your `docker-compose.yml` file and
    run the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有逐行分析文件中的每一行，也应该很容易跟踪到正在发生的事情。要启动我们的应用程序，我们只需切换到包含您的`docker-compose.yml`文件的文件夹，并运行以下命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see from the following Terminal output, a lot happened when it launched:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从以下终端输出中所看到的，启动时发生了很多事情：
- en: '![](Images/4e69ce24-f7a6-4080-a784-5b049cc7c666.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4e69ce24-f7a6-4080-a784-5b049cc7c666.png)'
- en: 'As you can see, from the first few lines, Docker Compose did the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前几行所看到的，Docker Compose做了以下事情：
- en: It created a volume called `mobycounter_redis_data`, using the default driver
    as we defined at the end of the `docker-compose.yml` file.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为`mobycounter_redis_data`的卷，使用我们在`docker-compose.yml`文件末尾定义的默认驱动程序。
- en: It created a network called `mobycounter_default` using the default network
    driver – at no point did we ask Docker Compose to do this. More on this in a minute.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一个名为`mobycounter_default`的网络，使用默认网络驱动程序——在任何时候我们都没有要求Docker Compose这样做。稍后再详细讨论。
- en: It launched two containers, one called `mobycounter_redis_1` , and the second
    called `mobycounter_mobycounter_1`.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它启动了两个容器，一个叫做`mobycounter_redis_1`，第二个叫做`mobycounter_mobycounter_1`。
- en: You may have also spotted the Docker Compose namespace in our multi-container
    application has prefixed everything with `mobycounter`. It took this name from
    the folder our Docker Compose file was being stored in.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还注意到我们的多容器应用程序中的Docker Compose命名空间已经用`mobycounter`作为前缀。它从我们存储Docker Compose文件的文件夹中获取了这个名称。
- en: Once launched, Docker Compose attached to `mobycounter_redis_1` and `mobycounter_mobycounter_1`
    and streamed the output to our Terminal session. On the Terminal screen, you can
    see both `redis_1` and `mobycounter_1` starting to interact with each other.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动，Docker Compose连接到`mobycounter_redis_1`和`mobycounter_mobycounter_1`，并将输出流到我们的终端会话。在终端屏幕上，您可以看到`redis_1`和`mobycounter_1`开始相互交互。
- en: When running Docker Compose using `docker-compose up`, it will run in the foreground.
    Pressing *Ctrl* + *C* will stop the containers and return access to your Terminal
    session.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`docker-compose up`运行Docker Compose时，它将在前台运行。按下*Ctrl* + *C*将停止容器并返回对终端会话的访问。
- en: Docker Compose YAML file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose YAML文件
- en: Before we look at using Docker Compose more, we should have a deeper dive into
    `docker-compose.yml` files as these are the heart of Docker Compose.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们更深入地使用Docker Compose之前，我们应该深入研究`docker-compose.yml`文件，因为这些文件是Docker Compose的核心。
- en: YAML is a recursive acronym that stands for **YAML Ain't Markup Language**.
    It is used by a lot of different applications for both configuration and also
    for defining data in a human-readable structured data format. The indentation
    you see in the examples is very important as it helps to define the structure
    of the data.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是一个递归缩写，代表**YAML不是标记语言**。它被许多不同的应用程序用于配置和定义人类可读的结构化数据格式。你在示例中看到的缩进非常重要，因为它有助于定义数据的结构。
- en: Moby counter application
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Moby计数器应用程序
- en: The `docker-compose.yml` file we used to launch our multi-container application
    is split into three separate sections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来启动多容器应用程序的`docker-compose.yml`文件分为三个独立的部分。
- en: 'The first section simply specifies which version of the Docker Compose definition
    language we are using; in our case, as we are running a recent version of Docker
    and Docker Compose, we are using version 3:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分简单地指定了我们正在使用的Docker Compose定义语言的版本；在我们的情况下，由于我们正在运行最新版本的Docker和Docker Compose，我们使用的是版本3：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next section is where our containers are defined; this section is the services
    section. It takes the following format:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是我们定义容器的地方；这部分是服务部分。它采用以下格式：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In our example, we defined two containers. I have separated them out to make
    it easy to read:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们定义了两个容器。我已经将它们分开以便阅读：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The syntax for defining the service is close to how you would launch a container
    using the `docker container run` command. I say close because although it makes
    perfect sense when you read the definition, it is only on closer inspection that
    you realize there is actually a lot of difference between the Docker Compose syntax
    and the `docker container run` command.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义服务的语法接近于使用`docker container run`命令启动容器。我说接近是因为虽然在阅读定义时它是完全合理的，但只有在仔细检查时才会意识到Docker
    Compose语法和`docker container run`命令之间实际上存在很多差异。
- en: 'For example, there are no flags for the following when running the `docker
    container run` command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在运行`docker container run`命令时，以下内容没有标志：
- en: '`image:` This tells Docker Compose which image to download and use. This does
    not exist as an option when running `docker container run` on the command line
    as you can only run a single container; as we have seen in previous chapters,
    the image is always defined toward the end of the command without the need for
    a flag being passed.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image：`这告诉Docker Compose要下载和使用哪个镜像。在命令行上运行`docker container run`时，这不作为选项存在，因为你只能运行一个单独的容器；正如我们在之前的章节中看到的，镜像总是在命令的末尾定义，而不需要传递标志。'
- en: '`volume:` This is the equivalent of the `--volume flag`, but it can accept
    multiple volumes. It only uses the volumes that are declared in the Docker Compose
    YAML file; more on that in a moment.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume：`这相当于`--volume`标志，但它可以接受多个卷。它只使用在Docker Compose YAML文件中声明的卷；稍后会详细介绍。'
- en: '`depends_on:` This would never work as a `docker container run` invocation
    because the command is only targeting a single container. When it comes to Docker
    Compose, `depends_on` is used to help build some logic into the order your containers
    are launched in. For example, only launch container B when container A has successfully
    started.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on：`这在`docker container run`调用中永远不会起作用，因为该命令只针对单个容器。在Docker Compose中，`depends_on`用于帮助构建一些逻辑到启动容器的顺序中。例如，只有在容器A成功启动后才启动容器B。'
- en: '`ports:` This is basically the `--publish` flag, which accepts a list of ports.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports：`这基本上是`--publish`标志，它接受一个端口列表。'
- en: 'The only part of the command we used that has an equivalent flag when running
    `docker container run` is this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的命令中唯一具有与在运行`docker container run`时等效标志的部分是这个：
- en: '`restart:` This is the same as using the `--restart` flag and accepts the same
    input.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart：`这与使用`--restart`标志相同，并接受相同的输入。'
- en: 'The final section of our Docker Compose YAML file is where we declare our volumes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Docker Compose YAML文件的最后一部分是我们声明卷的地方：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Example voting application
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例投票应用程序
- en: As mentioned already, the Docker Compose file for the Moby counter application
    is quite a simple example. Let's take a look at a more complex Docker Compose
    file and see how we can introduce building containers and multiple networks.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Moby计数器应用程序的Docker Compose文件是一个相当简单的示例。让我们看看一个更复杂的Docker Compose文件，看看我们如何引入构建容器和多个网络。
- en: In the repository for this book, you will find a folder in the `chapter05` directory
    called `example-voting-app`. This is a fork of the voting application from the
    official Docker sample repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的存储库中，您将在`chapter05`目录中找到一个名为`example-voting-app`的文件夹。这是来自官方Docker示例存储库的投票应用程序的一个分支。
- en: 'As you can see, if you were to open up the `docker-compose.yml` file, the application
    is made up of five containers, two networks, and a single volume. Ignore the other
    files, for now; we will look at some of these in future chapters. Let''s walk
    through the `docker-compose.yml` file as there is a lot going on:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，如果您打开`docker-compose.yml`文件，该应用程序由五个容器、两个网络和一个卷组成。暂时忽略其他文件；我们将在以后的章节中查看其中一些。让我们逐步了解`docker-compose.yml`文件，因为其中有很多内容：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As you can see, it starts simply enough by defining the version and then it
    starts to list the services. Our first container is called `vote`; it is a Python
    application that allows users to submit their vote. As you can see from the following
    definition, rather than downloading an image, we are actually building an image
    from scratch by using `build` instead of the `image` command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它从定义版本开始，然后开始列出服务。我们的第一个容器名为`vote`；它是一个允许用户提交他们的投票的Python应用程序。正如您从以下定义中所看到的，我们实际上是通过使用`build`而不是`image`命令从头开始构建一个镜像，而不是下载一个镜像：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The build instruction here tells Docker Compose to build a container using the
    Dockerfile, which can be found in the `./vote` folder. The Dockerfile itself is
    quite straightforward for a Python application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构建指令在这里告诉Docker Compose使用Dockerfile构建一个容器，该Dockerfile可以在`./vote`文件夹中找到。Dockerfile本身对于Python应用程序来说非常简单。
- en: Once the container launches, we are then mounting the `./vote` folder from our
    host machine into the container, which is achieved by passing the path of the
    folder we want to mount and where within the container we would like it mounted.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，我们将`./vote`文件夹从主机机器挂载到容器中，这是通过传递我们想要挂载的文件夹的路径以及我们想要在容器中挂载的位置来实现的。
- en: We are telling the container to run the `python app.py` when it launches. We
    are mapping port `5000` on our host machine to port `80` on the container, and
    finally, we are further attaching two networks to the container, one called `front-tier`
    and the second called `back-tier`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉容器在启动时运行`python app.py`。我们将主机机器上的端口`5000`映射到容器上的端口`80`，最后，我们将两个网络进一步附加到容器上，一个称为`front-tier`，另一个称为`back-tier`。
- en: The `front-tier` network will have the containers that have to have ports mapped
    to the host machine; the `back-tier` network is reserved for containers that do
    not need their ports to be exposed and acts as a private, isolated network.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`front-tier`网络将包含必须将端口映射到主机机器的容器；`back-tier`网络保留用于不需要暴露其端口的容器，并充当私有的隔离网络。'
- en: 'Next up, we have another container that is connected to the `front-tier` network.
    This container displays the results of the vote. The `result` container contains
    a Node.js application that connects to the PostgreSQL database, which we will
    get to in a moment, and displays the results in real time as votes are cast in
    the `vote` container. Like the `vote` container, the image is built locally using
    a `Dockerfile` that can be found in the `./result` folder:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有另一个连接到`front-tier`网络的容器。该容器显示投票结果。`result`容器包含一个Node.js应用程序，它连接到我们马上会提到的PostgreSQL数据库，并实时显示投票容器中的投票结果。与`vote`容器一样，该镜像是使用位于`./result`文件夹中的`Dockerfile`本地构建的：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are exposing port `5001`, which is where we can connect to see the results.
    The next, and final, application container is called `worker`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在暴露端口`5001`，这是我们可以连接以查看结果的地方。接下来，也是最后一个应用程序容器被称为`worker`：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The worker container runs a .NET application whose only job is to connect to
    Redis and register each vote by transferring it into a PostgreSQL database running
    on a container called `db`. The container is again built using a `Dockerfile`,
    but this time, rather than passing the path to the folder where the `Dockerfile`
    and application are stored, we are using context. This sets the working directory
    for the docker build and also allows you to define additional options such as
    labels and changing the name of the `Dockerfile`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: worker容器运行一个.NET应用程序，其唯一工作是连接到Redis，并通过将每个投票转移到运行在名为`db`的容器上的PostgreSQL数据库来注册每个投票。该容器再次使用`Dockerfile`构建，但这一次，我们不是传递存储`Dockerfile`和应用程序的文件夹路径，而是使用上下文。这为docker构建设置工作目录，并允许您定义附加选项，如标签和更改`Dockerfile`的名称。
- en: As this container is doing nothing other than connecting to `redis` and the
    `db` container, it does not need any ports exposed as it has nothing connecting
    directly to it; it also does not need to communicate with either of the containers
    running on the `front-tier` network, meaning we just have to add the `back-tier`
    network.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该容器除了连接到`redis`和`db`容器外什么也不做，因此它不需要暴露任何端口，因为没有任何东西直接连接到它；它也不需要与运行在`front-tier`网络上的任何容器通信，这意味着我们只需要添加`back-tier`网络。
- en: 'So, we now have the `vote` application, which registers the votes from the
    end users and sends them to the `redis` container, where the vote is then processed
    by the `worker` container. The service definition for the `redis` container looks
    like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们现在有了`vote`应用程序，它注册来自最终用户的投票并将它们发送到`redis`容器，然后由`worker`容器处理。`redis`容器的服务定义如下：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This container uses the official Redis image and is not built from a Dockerfile;
    we are making sure that port `6379` is available, but only on the `back-tier`
    network. We are also specifying the name of the container, setting it to `redis`
    by using `container_name`. This is to avoid us having to make any considerations
    on the default names generated by Docker Compose within our code since, if you
    remember, Docker Compose uses the folder name to launch the containers in their
    own application namespace.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该容器使用官方的Redis镜像，并不是从Dockerfile构建的；我们确保端口`6379`可用，但仅在`back-tier`网络上。我们还指定了容器的名称，将其设置为`redis`，使用`container_name`。这是为了避免我们在代码中对Docker
    Compose生成的默认名称做任何考虑，因为您可能还记得，Docker Compose使用文件夹名称在其自己的应用程序命名空间中启动容器。
- en: 'The next and final container is the PostgreSQL one which we have already mentioned called `db`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，也是最后一个容器是我们已经提到的PostgreSQL容器，名为`db`：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, it looks quite similar to the `redis` container in that we are
    using the official image; however, you may notice that we are not exposing a port
    as this is a default option in the official image. We are also specifying the
    name of the container.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，它看起来与`redis`容器非常相似，因为我们正在使用官方镜像；然而，你可能注意到我们没有暴露端口，因为这是官方镜像中的默认选项。我们还指定了容器的名称。
- en: 'As this is where our votes will be stored, we are creating and mounting a volume
    to act as persistent storage for our PostgreSQL database:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我们将存储投票的地方，我们正在创建和挂载一个卷来作为我们的PostgreSQL数据库的持久存储：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, finally, here are the two networks we have been speaking about:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是我们一直在谈论的两个网络：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running `docker-compose up` gives a lot of feedback on what is happening during
    the launch; it takes about 5 minutes to launch the application for the first time.
    If you are not following along and launching the application yourself, what follows
    is an abridged version of the launch.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker-compose up`会给出很多关于启动过程的反馈；首次启动应用程序大约需要5分钟。如果你没有跟着操作并自己启动应用程序，接下来是启动的摘要版本。
- en: 'You may get an error that states `npm ERR! request to https://registry.npmjs.org/nodemon
    failed, reason: Hostname/IP doesn''t match certificate''s altnames`. If you do,
    then run the following command `echo "104.16.16.35 registry.npmjs.org" >> /etc/hosts` as
    a user with privileges to write to `/etc/hosts`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '你可能会收到一个错误，指出`npm ERR! request to https://registry.npmjs.org/nodemon failed,
    reason: Hostname/IP doesn''t match certificate''s altnames`。如果是这样，那么以有写入`/etc/hosts`权限的用户身份运行以下命令`echo
    "104.16.16.35 registry.npmjs.org" >> /etc/hosts`。'
- en: 'We start by creating the networks and getting the volume ready for our containers
    to use:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建网络并准备好卷供我们的容器使用：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then build the `vote` container image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们构建`vote`容器镜像：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once this `vote` image has been built, the `worker` image is constructed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`vote`镜像构建完成，`worker`镜像就会被构建：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then the `redis` image is pulled:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后拉取`redis`镜像：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is followed by the PostgreSQL image for the `db` container:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是为`db`容器准备的PostgreSQL镜像：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now it is time for the big one; the building of the `result` image. Node.js
    is quite verbose, so you will get quite a bit of output being printed to the screen
    as the `npm` sections of the `Dockerfile` are executed; in fact, there are over
    250 lines of output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是大事将要发生的时候了；构建`result`镜像。Node.js非常冗长，所以在执行`Dockerfile`的`npm`部分时，屏幕上会打印出相当多的输出；事实上，有超过250行的输出：
- en: '[PRE21]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `result` part of the application can be accessed at `http://localhost:5001`.
    By default, there are no votes and it is split 50/50:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的`result`部分可以在`http://localhost:5001`访问。默认情况下没有投票，它是50/50的分割：
- en: '![](Images/4a22ffa8-8c43-4c3b-a426-6219b0ee85a0.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4a22ffa8-8c43-4c3b-a426-6219b0ee85a0.png)'
- en: 'The `vote` part of the application can be found at `http://localhost:5000`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的`vote`部分可以在`http://localhost:5000`找到：
- en: '![](Images/f8de0f3e-20dd-45db-ae5f-7488b207f103.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f8de0f3e-20dd-45db-ae5f-7488b207f103.png)'
- en: 'Clicking on either **CATS** or **DOGS** will register a vote; you should be
    able to see this logged in the Docker Compose output in your Terminal:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**CATS**或**DOGS**将注册一票；你应该能在终端的Docker Compose输出中看到这一点：
- en: '![](Images/b3a3eb0d-f32c-46be-8b36-0257af71fc63.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b3a3eb0d-f32c-46be-8b36-0257af71fc63.png)'
- en: 'There are a few errors, as the Redis table structure is only created when the
    vote application registers the first vote; once a vote has been cast, the Redis
    table structure will be created and the worker container will take that vote and
    process it by writing to the `db` container. Once the vote has been cast, the
    `result` container will update in real time:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些错误，因为只有当投票应用程序注册第一张选票时，Redis表结构才会被创建；一旦投票被投出，Redis表结构将被创建，并且工作容器将接收该投票并通过写入`db`容器来处理它。一旦投票被投出，`result`容器将实时更新：
- en: '![](Images/bbd70927-10dc-48ab-ae1a-cada61daea24.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bbd70927-10dc-48ab-ae1a-cada61daea24.png)'
- en: We will be looking at the Docker Compose YAML files again in the upcoming chapters
    when we look at launching both Docker Swarm stacks and Kubenetes clusters. For
    now, let's get back to Docker Compose and look at some of the commands we can
    run.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，当我们查看如何启动Docker Swarm堆栈和Kubenetes集群时，我们将再次查看Docker Compose YAML文件。现在，让我们回到Docker
    Compose，并查看一些我们可以运行的命令。
- en: Docker Compose commands
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose命令
- en: 'We are over halfway through the chapter and the only Docker Compose command
    we have run is `docker-compose up`. If you have been following along and you run
    `docker container ls -a`, you will see something similar to the following Terminal
    screen:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经过了本章的一半，我们运行的唯一Docker Compose命令是`docker-compose up`。如果您一直在跟着做，并且运行`docker
    container ls -a`，您将看到类似以下终端屏幕的内容：
- en: '![](Images/5d363680-67d7-437f-bd51-5dbf01bffb15.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5d363680-67d7-437f-bd51-5dbf01bffb15.png)'
- en: As you can see, we have a lot of containers with the status of `EXITED`. This
    is because when we used *Ctrl* + *C* to return to our Terminal, the Docker Compose
    containers were stopped.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有很多容器的状态是“退出”。这是因为当我们使用*Ctrl* + *C*返回到我们的终端时，Docker Compose容器被停止了。
- en: Choose one of the Docker Compose applications and change to the folder that
    contains the `docker-compose.yml` file, and we will work through some more Docker
    Compose commands. I will be using the **Example Vote** application.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个Docker Compose应用程序，并切换到包含`docker-compose.yml`文件的文件夹，我们将通过一些更多的Docker Compose命令进行工作。我将使用**示例投票**应用程序。
- en: Up and PS
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上升和PS
- en: 'The first one is `docker-compose up`, but this time, we will be adding a flag.
    In your chosen application folder, run the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`docker-compose up`，但这次，我们将添加一个标志。在您选择的应用程序文件夹中，运行以下命令：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will start your application back up, this time in detached mode:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新启动您的应用程序，这次是在分离模式下：
- en: '![](Images/0b96c910-8548-4bf7-ac18-d2d5daf3b40f.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0b96c910-8548-4bf7-ac18-d2d5daf3b40f.png)'
- en: 'Once control of your Terminal is returned, you should be able to check that
    the containers are running using the following command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦控制台返回，您应该能够使用以下命令检查容器是否正在运行：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see from the following Terminal output, all of the containers have
    the state of `Up`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从以下终端输出中所看到的，所有容器的状态都是“上升”的：
- en: '![](Images/bb818478-bc68-4381-84be-11090fbd2b00.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/bb818478-bc68-4381-84be-11090fbd2b00.png)'
- en: When running these commands, Docker Compose will only be aware of the containers
    defined in the service section of your `docker-compose.yml` file; all other containers
    will be ignored as they don't belong to our service stack.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令时，Docker Compose只会知道在`docker-compose.yml`文件的服务部分中定义的容器；所有其他容器将被忽略，因为它们不属于我们的服务堆栈。
- en: Config
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: 'Running the following command will validate our `docker-compose.yml` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将验证我们的`docker-compose.yml`文件：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If there are no issues, it will print a rendered copy of your Docker Compose
    YAML file to screen; this is how Docker Compose will interpret your file. If you
    don''t want to see this output and just want to check for errors, then you can
    run the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有问题，它将在屏幕上打印出您的Docker Compose YAML文件的渲染副本；这是Docker Compose将解释您的文件的方式。如果您不想看到这个输出，只想检查错误，那么您可以运行以下命令：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is shorthand for `--quiet`. If there are any errors, which the examples
    we have worked through so far shouldn''t have, they will be displayed as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`--quiet`的简写。如果有任何错误，我们到目前为止所做的示例中不应该有错误，它们将显示如下：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pull, build, and create
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pull，build和create
- en: 'The next two commands will help you prepare to launch your Docker Compose application.
    The following command will read your Docker Compose YAML file and pull any of
    the images it finds:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个命令将帮助您准备启动Docker Compose应用程序。以下命令将读取您的Docker Compose YAML文件并拉取它找到的任何镜像：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The following command will execute any build instructions it finds in your
    file:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将执行在您的文件中找到的任何构建指令：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: These commands are useful when you are first defining your Docker Compose-powered
    application and want to test without launching your application. The `docker-compose
    build` command can also be used to trigger a build if there are updates to any
    of the Dockerfiles used to originally build your images.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次定义Docker Compose应用程序并希望在启动应用程序之前进行测试时，这些命令非常有用。如果Dockerfile有更新，`docker-compose
    build`命令也可以用来触发构建。
- en: 'The `pull` and `build` command only generate/pull the images needed for our
    application; they do not configure the containers themselves. For this, we need
    to use the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`pull`和`build`命令只生成/拉取我们应用程序所需的镜像；它们不配置容器本身。为此，我们需要使用以下命令：'
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This will create but not launch the containers. In the same way that the `docker
    container create` command does, they will have an exited state until you start
    them. The `create` command has a few useful flags you can pass:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建但不启动容器。与`docker container create`命令一样，它们将处于退出状态，直到您启动它们。`create`命令有一些有用的标志可以传递：
- en: '`--force-recreate`: This recreates the container even if there is no need to
    as nothing within the configuration has changed'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force-recreate`：即使配置没有更改，也会重新创建容器'
- en: '`--no-recreate`: This doesn''t recreate a container if it already exists; this
    flag cannot be used with the preceding flag'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-recreate`：如果容器已经存在，则不重新创建；此标志不能与前一个标志一起使用'
- en: '`--no-build`: This doesn''t build the images, even if an image that needs to
    be built is missing'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-build`：即使缺少需要构建的镜像，也不会构建镜像'
- en: '`--build`: This builds the images before creating the containers'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--build`：在创建容器之前构建镜像'
- en: Start, stop, restart, pause, and unpause
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始，停止，重新启动，暂停和取消暂停
- en: 'The following commands work exactly in the same way as their docker container
    counterparts, the only difference being that they effect change on all of the
    containers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令的工作方式与它们的docker容器对应物完全相同，唯一的区别是它们会对所有容器产生影响：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'It is possible to target a single service by passing its name; for example,
    to `pause` and `unpause` the `db` service, we would run the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递服务名称来针对单个服务；例如，要`暂停`和`取消暂停` `db` 服务，我们可以运行以下命令：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Top, logs, and events
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Top，logs和events
- en: The next three commands all give us feedback on what is happening within our
    running containers and Docker Compose.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个命令都会向我们提供有关正在运行的容器和Docker Compose中发生的情况的反馈。
- en: 'The following command, like its docker container counterpart, displays information
    on the processes running within each of our Docker Compose-launched containers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与其docker容器对应物一样，以下命令显示了在我们的Docker Compose启动的每个容器中运行的进程的信息：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you can see from the following Terminal output, each container is split
    into its own section:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下终端输出可以看到，每个容器都分成了自己的部分：
- en: '![](Images/47672e5f-ef23-41ba-96ac-f09431f5030f.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/47672e5f-ef23-41ba-96ac-f09431f5030f.png)'
- en: 'If you would like to see just one of the services, you simply have to pass
    its name when running the command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想看到其中一个服务，只需在运行命令时传递其名称：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The next command streams the `logs` from each of the running containers to
    screen:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个命令会将每个正在运行的容器的`logs`流式传输到屏幕上：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like the `docker container` command, you can pass flags such as `-f` or `--follow`
    to keep the stream flowing until you press *Ctrl* + *C*. Also, you can stream
    the logs for a single service by appending its name to the end of your command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与`docker container`命令一样，您可以传递标志，如`-f`或`--follow`，以保持流式传输，直到按下*Ctrl* + *C*。此外，您可以通过在命令末尾附加其名称来为单个服务流式传输日志：
- en: '![](Images/ce0c8f42-1208-4a13-b767-c02b3bb462ef.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ce0c8f42-1208-4a13-b767-c02b3bb462ef.png)'
- en: 'The `events` command again works like the docker container version; it streams
    events, such as the ones triggered by the other commands we have been discussing,
    in real time. For example, run this command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`events`命令再次像docker容器版本一样工作；它实时流式传输事件，例如我们一直在讨论的其他命令触发的事件。例如，运行此命令：'
- en: '[PRE35]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Running `docker-compose pause` in a second terminal window gives the following
    output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中运行`docker-compose pause`会得到以下输出：
- en: '![](Images/332e23d6-bc34-4a7e-8e48-c1b910707a23.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/332e23d6-bc34-4a7e-8e48-c1b910707a23.png)'
- en: 'These two commands run similar to their docker container equivalents. Run the
    following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个命令类似于它们的docker容器等效命令。运行以下命令：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will launch a new process in the already running `worker` container and
    ping the `db` container three times, as seen here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在已经运行的`worker`容器中启动一个新进程，并对`db`容器进行三次ping，如下所示：
- en: '![](Images/0647960c-03ed-4c9d-9e24-259c4e0ab85f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0647960c-03ed-4c9d-9e24-259c4e0ab85f.png)'
- en: 'The `run` command is useful if you need to run a containerized command as a
    one-off within your application. For example, if you use a package manager such
    as composer to update the dependencies of your project that is stored on a volume,
    you could run something like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`run`命令在应用程序中需要以容器化命令运行一次时非常有用。例如，如果您使用诸如composer之类的软件包管理器来更新存储在卷上的项目的依赖关系，可以运行类似以下命令：'
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This would run the `composer` container with the `install` command and mount
    the `data_volume` to `/app` within the container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`install`命令在`composer`容器中运行，并将`data_volume`挂载到容器内的`/app`。
- en: Scale
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规模
- en: 'The `scale` command will take the service you pass to the command and scale
    it to the number you define; for example, to add more worker containers, I just
    need to run the following:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`scale`命令将接受您传递给命令的服务，并将其扩展到您定义的数量；例如，要添加更多的worker容器，我只需要运行以下命令：'
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, this actually gives the following warning:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这实际上会给出以下警告：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What we should now be using is the following command:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该使用以下命令：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: While the `scale` command is in the current version of Docker Compose, it will
    be removed from future versions of the software.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`scale`命令在当前版本的Docker Compose中存在，但它将在将来的软件版本中被移除。
- en: 'You will notice that I chose to scale the number of worker containers. There
    is a good reason for this as you will see for yourself if you try running the
    following command:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我选择了扩展worker容器的数量。这是有充分理由的，如果您尝试运行以下命令，您将自己看到：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You will notice that while Docker Compose creates the additional two containers,
    they fail to start with the following error:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，虽然Docker Compose创建了额外的两个容器，但它们未能启动，并显示以下错误：
- en: '![](Images/4a6ae0cb-5db8-4bf8-99cc-2cc1c667be78.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4a6ae0cb-5db8-4bf8-99cc-2cc1c667be78.png)'
- en: That is because we cannot have three individual containers all trying to map
    to the same port. There is a workaround for this and we will look at that in more
    detail in a later chapter.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们不能有三个单独的容器都试图映射到相同的端口。对此有一个解决方法，我们将在后面的章节中更详细地讨论。
- en: Kill, rm, and down
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kill、rm和down
- en: 'The three Docker Compose commands we are finally going to look at are the ones
    that remove/terminate our Docker Compose application. The first command stops
    our running containers by immediately stopping running container processes. This
    is the `kill` command:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终要看的三个Docker Compose命令是用来移除/终止我们的Docker Compose应用程序的命令。第一个命令通过立即停止运行的容器进程来停止我们正在运行的容器。这就是`kill`命令：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Be careful when running this as it does not wait for containers to gracefully
    stop, such as when running `docker-compose stop`, meaning that using the `docker-compose
    kill` command may result in data loss.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令时要小心，因为它不会等待容器优雅地停止，比如运行`docker-compose stop`时，使用`docker-compose kill`命令可能会导致数据丢失。
- en: 'Next up is the `rm` command; this removes any containers with the state of
    `exited`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`rm`命令；这将删除任何状态为`exited`的容器：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have the `down` command. This, as you might have already guessed,
    has the opposite effect of running `docker-compose up`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`down`命令。你可能已经猜到了，它的效果与运行`docker-compose up`相反：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'That will remove the containers and the networks created when running `docker-compose
    up`. If you want to remove everything, you can do so by running the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将删除运行`docker-compose up`时创建的容器和网络。如果要删除所有内容，可以通过运行以下命令来实现：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This will remove all of the containers, networks, volumes, and images (both
    pulled and built) when you ran the `docker-compose up` command; this includes
    images that may be in use outside of your Docker Compose application. There will,
    however, be an error if the images are in use, and they will not be removed:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`docker-compose up`命令时，这将删除所有容器、网络、卷和镜像（包括拉取和构建的镜像）；这包括可能在Docker Compose应用程序之外使用的镜像。但是，如果镜像正在使用中，将会出现错误，并且它们将不会被移除：
- en: '![](Images/08087e2a-53d9-4ff6-829c-6133c8470532.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08087e2a-53d9-4ff6-829c-6133c8470532.png)'
- en: As you can see from the preceding output, there is a container using the `redis`
    image, the Moby counter application, so it was not removed. However, all other
    images used by the Example Vote application are removed, both the ones built as
    part of the initial `docker-compose up` , and the ones downloaded from Docker
    Hub.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，有一个使用`redis`镜像的容器，Moby计数器应用程序，因此它没有被移除。然而，Example Vote应用程序使用的所有其他镜像都被移除了，包括作为初始`docker-compose
    up`的一部分构建的镜像，以及从Docker Hub下载的镜像。
- en: Docker App
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker App
- en: 'Before we start this section, I should issue the following warning:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始本节之前，我应该发出以下警告：
- en: '*The feature we are going to discuss is very much an experimental one. It is
    in its very early stages of development and should not be considered any more
    than a preview of an upcoming feature.*'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们将要讨论的功能非常实验性。它还处于早期开发阶段，不应被视为即将推出的功能的预览以外的东西。*'
- en: Because of this, I am only going to cover the installation of the macOS version.
    However, before we install it, lets discuss what exactly is meant by a Docker
    App.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我只会介绍macOS版本的安装。然而，在安装之前，让我们讨论一下Docker App到底是什么意思。
- en: While Docker Compose files are really useful when it comes to sharing your environment
    with others, you may have noticed that there is one quite crucial element we have
    been missing so far in this chapter, and that is the ability to actually distribute
    your Docker Compose files in a similar way to how you can distribute your Docker
    images.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Docker Compose文件在与他人共享环境时非常有用，但您可能已经注意到，在本章中到目前为止，我们一直缺少一个非常关键的元素，那就是实际上分发您的Docker
    Compose文件的能力，类似于您如何分发Docker镜像。
- en: Docker has acknowledged this and is currently working on a new feature called
    Docker App, which it hopes will fill this gap.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Docker已经承认了这一点，并且目前正在开发一个名为Docker App的新功能，希望能填补这一空白。
- en: '**Docker App** is a self-contained binary that helps you to create an application
    bundle that can be shared via Docker Hub or a Docker Enterprise Registry.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker App**是一个自包含的二进制文件，可帮助您创建一个可以通过Docker Hub或Docker企业注册表共享的应用程序包。'
- en: I would recommend checking the GitHub projects **R****eleases** page (you can
    find the link in the *Further reading* section) to make sure you are a using the
    latest version. If the version is later than 0.4.1, you will need to replace the
    version number in the following command.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议检查GitHub项目的**R****eleases**页面（您可以在*Further reading*部分找到链接），以确保您使用的是最新版本。如果版本晚于0.4.1，您将需要在以下命令中替换版本号。
- en: 'To install Docker App on macOS, you can run the following commands, starting
    with setting the version to download:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要在macOS上安装Docker App，您可以运行以下命令，首先设置要下载的版本：
- en: '[PRE46]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now that you have the correct version, you can download it and put it in place
    using the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经有了正确的版本，可以使用以下命令下载并放置它：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once in place, you should be able to run the following command that will print
    some basic information about binary on screen:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦就位，您应该能够运行以下命令，在屏幕上打印一些关于二进制的基本信息：
- en: '[PRE48]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The full output of the preceding commands can be seen here for those not following
    along:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处查看前述命令的完整输出，供不跟随的人参考：
- en: '![](Images/9c5da96b-a744-4c5f-9cb5-3e853db7aa53.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9c5da96b-a744-4c5f-9cb5-3e853db7aa53.png)'
- en: 'There is a slight change to the `docker-compose.yml` file we will be using.
    The version needs to be updated to `3.6` rather than just `3`. Not doing this
    will result in the following error:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的`docker-compose.yml`文件有一个轻微的更改。版本需要更新为`3.6`而不仅仅是`3`。不这样做将导致以下错误：
- en: '[PRE49]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The command we need to run, and which also generates the preceding error, is
    as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要运行的命令，也是生成前述错误的命令，如下所示：
- en: '[PRE50]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This command takes our `docker-compose.yml` file and embeds it in a `.dockerapp`
    file. Initially, there will be quite a few comments in the file that detail what
    changes you need to make before moving on to the next steps. I have left an unaltered
    version of the file in the repository, in the `chapter5/mobycounter-app` folder
    called `mobycounter.dockerapp.original`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将我们的`docker-compose.yml`文件嵌入`.dockerapp`文件中。最初，文件中将有相当多的注释，详细说明您需要在进行下一步之前进行的更改。我在存储库中留下了一个未更改的文件版本，在`chapter5/mobycounter-app`文件夹中名为`mobycounter.dockerapp.original`。
- en: 'An edited version of the `mobycounter.dockerapp` file can be found here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在此处找到`mobycounter.dockerapp`文件的编辑版本：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, it split into three sections; the first contains metadata about
    the application, as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它分为三个部分；第一部分包含有关应用程序的元数据，如下所示：
- en: '`Version`: This the version of the app that will be published on Docker Hub'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Version`：这是将在Docker Hub上发布的应用程序的版本'
- en: '`Name`: The name of the application as it will appear on Docker Hub'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`：应用程序的名称，将显示在Docker Hub上'
- en: '`Description`: A short description of the application'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Description`：应用程序的简短描述'
- en: '`Namespace`: This is typically your Docker Hub username or an organisation
    you have access to'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称空间：这通常是您的Docker Hub用户名或您可以访问的组织
- en: '`Maintainers`: A list of maintainers for the application'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护者：应用程序的维护者列表
- en: The second section contains our Docker Compose file. You may notice that a few
    of the options have been replaced with variables. In our example, I have replaced
    port `8080` with `${port}` . The default value for the `port` variable is defined
    in the final section.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分包含我们的Docker Compose文件。您可能会注意到一些选项已被替换为变量。在我们的示例中，我已经用`${port}`替换了端口`8080`。`port`变量的默认值在最后一部分中定义。
- en: 'Once the `.dockerapp` file is complete, you can run the following command to
    save the Docker App as an image:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`.dockerapp`文件完成，您可以运行以下命令将Docker应用程序保存为镜像：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'You can view just the Docker Apps you have active on your host by running this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行以下命令仅查看您在主机上激活的Docker应用程序：
- en: '[PRE53]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As the Docker App is mostly just a bunch of metadata wrapped in a standard
    Docker image, you can also see it by running the following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker应用程序主要只是包装在标准Docker镜像中的一堆元数据，您也可以通过运行以下命令来查看它：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you are not following along with this part, you can see the results in the
    terminal output here:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有跟随这部分，您可以在此处查看终端输出的结果：
- en: '![](Images/b63c6b9b-a8dd-40fa-9651-068f329248e4.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b63c6b9b-a8dd-40fa-9651-068f329248e4.png)'
- en: 'Running the following command gives an overview of the Docker App, in much
    the same way you can use `docker image inspect` to find out details on how the
    image was built:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令可以概述Docker应用程序，就像您可以使用`docker image inspect`来查找有关镜像构建方式的详细信息一样：
- en: '[PRE55]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'As you can see from the following terminal output, running the command using
    `docker-app inspect` rather than `docker image inspect` gives a much more friendly
    output:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从以下终端输出中所见，使用`docker-app inspect`而不是`docker image inspect`运行命令会得到更友好的输出：
- en: '![](Images/81756d0f-6074-4664-8738-faf34d524d47.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/81756d0f-6074-4664-8738-faf34d524d47.png)'
- en: 'Now that we have our finished application, we need to push it to Docker Hub.
    To do this, simply run the following command:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了我们的应用程序，我们需要将其推送到Docker Hub。要做到这一点，只需运行以下命令：
- en: '[PRE56]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![](Images/eced72f8-ac1c-4291-a9a1-ff80917c217c.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/eced72f8-ac1c-4291-a9a1-ff80917c217c.png)'
- en: 'This means that our application is now published on Docker Hub:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的应用程序现在已发布在Docker Hub上：
- en: '![](Images/449dc815-8dcf-408d-a7b7-fad918ab0dd0.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/449dc815-8dcf-408d-a7b7-fad918ab0dd0.png)'
- en: 'So how do you get the Docker App? First of all, we need to remove the local
    image. To do this, run the following command:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何获取Docker应用程序呢？首先，我们需要删除本地镜像。要做到这一点，请运行以下命令：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Once gone, move to a different directory:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦删除，移动到另一个目录：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s download the Docker App, make a change to the port, and start it
    up:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们下载Docker应用程序，更改端口并启动它：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Again, for those not following along, the terminal output of the preceding
    command can be found here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于那些没有跟随的人，可以在此找到前述命令的终端输出：
- en: '![](Images/5d14eae8-47a2-4f33-92d7-e7ad8427c401.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5d14eae8-47a2-4f33-92d7-e7ad8427c401.png)'
- en: As you can see, without having to even manually download the Docker App image,
    we have our application up and running. Going to `http://localhost:9090/` should
    present you with the screen that invites you to click to add logos.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，甚至无需手动下载Docker应用程序镜像，我们的应用程序就已经运行起来了。转到`http://localhost:9090/`应该会显示一个邀请您点击添加标志的屏幕。
- en: As per a normal foregrounded Docker Compose app, press *Ctrl* + *C* to return
    to your terminal.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与正常的前台Docker Compose应用程序一样，按下*Ctrl* + *C*返回到您的终端。
- en: 'You can run the following commands to interact and terminate your app:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行以下命令来交互和终止您的应用程序：
- en: '[PRE60]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is more functionality within Docker App. However, we are not quite ready
    to go into further details. We will return to Docker App in [Chapter 8](1c5ca271-e40d-48c9-9fb2-c50e9535953b.xhtml)*,
    Docker* *Swarm,* and [Chapter 9](d3b2dadf-ed17-460b-8d06-ac7edc133ba6.xhtml)*,
    Docker and Kubernetes*.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Docker App中还有更多功能。但我们还没有准备好进一步详细讨论。我们将在第8章，Docker Swarm和第9章，Docker和Kubernetes中回到Docker
    App。
- en: As mentioned at the top of this section, this feature is in its early stages
    of development and it is possible that the commands and functionality we have
    discussed so far may change in the future. But, even at this early stage, I hope
    you can see the advantages of Docker App and how it is building on the solid foundations
    laid by Docker Compose.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如本节顶部所述，此功能处于早期开发阶段，我们讨论的命令和功能可能会在未来发生变化。但即使在这个早期阶段，我希望您能看到Docker App的优势，以及它是如何在Docker
    Compose奠定的坚实基础上构建的。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: I hope you have enjoyed this chapter on Docker Compose, and I hope that like
    I did, you can see that it has evolved from being an incredibly useful third-party
    tool to an extremely important part of the core Docker experience.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢这一章关于Docker Compose的内容，我希望您能像我一样看到它已经从一个非常有用的第三方工具发展成为核心Docker体验中非常重要的一部分。
- en: Docker Compose introduces some key concepts in how you should approach running
    and managing your containers. We will be taking these concepts one step further
    in [Chapter 8](https://cdp.packtpub.com/mastering_docker___thirdedition/wp-admin/post.php?post=28&action=edit#post_31)*,
    Docker** Swarm,* and [Chapter 9](https://cdp.packtpub.com/mastering_docker___thirdedition/wp-admin/post.php?post=28&action=edit#post_32)*,
    Docker and Kubernetes*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose引入了一些关键概念，指导您如何运行和管理容器。我们将在第8章，Docker Swarm和第9章，Docker和Kubernetes中进一步探讨这些概念。
- en: In the next chapter, we are going to move away from Linux-based containers and
    take a whistle-stop tour of Windows containers.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将远离基于Linux的容器，快速了解Windows容器。
- en: Questions
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Docker Compose files use which open source format?
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker Compose文件使用哪种开源格式？
- en: In our initial Moby counter Docker Compose file, which was the only flag that
    works exactly the same as its Docker CLI counterpart?
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们最初的Moby计数器Docker Compose文件中，哪个标志与其Docker CLI对应物完全相同？
- en: 'True or false: You can only use images from the Docker Hub with your Docker
    Compose files?'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真或假：您只能在Docker Compose文件中使用Docker Hub的镜像？
- en: By default, how does Docker Compose decide on the namespace to use?
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Docker Compose如何决定要使用的命名空间？
- en: Which flag do you add to docker-compose up to start the containers in the background?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在docker-compose up中添加哪个标志以在后台启动容器？
- en: What is the best way to run a syntax check on your Docker Compose files?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行Docker Compose文件的语法检查的最佳方法是什么？
- en: Explain the basic principle about how Docker App works.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解释Docker App工作的基本原理。
- en: Further reading
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For details on Orchard Laboratories, see the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Orchard Laboratories的详细信息，请参阅以下内容：
- en: Orchard Laboratories website: [https://www.orchardup.com/](https://www.orchardup.com/)
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Orchard Laboratories网站：[https://www.orchardup.com/](https://www.orchardup.com/)
- en: Orchard Laboratories joins Docker: [https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team](https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team)
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Orchard Laboratories加入Docker：[https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team](https://blog.docker.com/2014/07/welcoming-the-orchard-and-fig-team)
- en: 'For more information on the Docker App project, see the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Docker App项目的更多信息，请参阅以下内容：
- en: GitHub Repository: [http://github.com/docker/app/](http://github.com/docker/app/)
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub存储库：[http://github.com/docker/app/](http://github.com/docker/app/)
- en: Releases page – [https://github.com/docker/app/releases](https://github.com/docker/app/releases)
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布页面 - [https://github.com/docker/app/releases](https://github.com/docker/app/releases)
- en: 'Finally, here are some further links to a number of other topics that we have
    covered:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些我们涵盖的其他主题的进一步链接：
- en: YAML Project home page: [http://www.yaml.org/](http://www.yaml.org/)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: YAML 项目主页：[http://www.yaml.org/](http://www.yaml.org/)
- en: Docker Sample Repository: [https://github.com/dockersamples/](https://github.com/dockersamples/)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 示例仓库：[https://github.com/dockersamples/](https://github.com/dockersamples/)
