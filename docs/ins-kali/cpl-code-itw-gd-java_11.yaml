- en: '*Chapter 9*:'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '*第9章*：'
- en: Bit Manipulation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位操作
- en: This chapter covers the most important aspects of bit manipulation that you
    should know about when it forms part of a technical interview. Such problems are
    often encountered in interviews and they are not easy. The human mind was not
    designed to manipulate bits; computers were designed for that. This means that
    manipulating bits is quite hard and extremely prone to mistakes. Hence, it is
    advisable to always double-check every bit operation.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了位操作的最重要方面，这些方面在技术面试中是必须了解的。这类问题在面试中经常遇到，而且并不容易。人类的大脑并不是为了操作位而设计的；计算机是为了这个而设计的。这意味着操作位相当困难，而且极易出错。因此，建议始终仔细检查每个位操作。
- en: 'Two things are extremely important for mastering these kinds of problems, as
    follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这些问题的两个极其重要的事情如下：
- en: You must understand the theory of bits very well (for example, bit operators)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须非常了解位的理论（例如，位运算符）
- en: You must practice bit manipulation as much as possible
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您必须尽可能多地练习位操作
- en: 'We need to keep these two statements in mind as we tackle the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们解决以下主题时，我们需要牢记这两个陈述：
- en: Understanding bit manipulation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解位操作
- en: Coding challenges
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码挑战
- en: Let's start with the theoretical part. It is strongly recommended that you extract
    the diagrams from this section. They will be your best friends in the second part
    of this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从理论部分开始。强烈建议您从本节中提取图表。它们将是本章第二部分中最好的朋友。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code present in this chapter can be found on GitHub at [https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在GitHub上找到[https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09](https://github.com/PacktPublishing/The-Complete-Coding-Interview-Guide-in-Java/tree/master/Chapter09)。
- en: Bit manipulation in a nutshell
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位操作简介
- en: 'In Java, we can manipulate bits of the following data types: `byte` (8-bit),
    `short` (16-bit), `int` (32-bit), `long` (64-bit), and `char` (16-bit).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以操作以下数据类型的位：`byte`（8位）、`short`（16位）、`int`（32位）、`long`（64位）和`char`（16位）。
- en: 'For example, let''s use the positive number, 51\. In this situation, we have
    the following statements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们使用正数51。在这种情况下，我们有以下陈述：
- en: The binary representation of 51 is 110011.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 51的二进制表示是110011。
- en: Because 51 is an `int`, it is represented as a 32-bit value; that is, 32 values
    of 1 or 0 (from 0 to 31).
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为51是一个`int`，它被表示为一个32位的值；也就是说，32个1或0的值（从0到31）。
- en: All the positions to the left of 110011 are actually filled with zeros, up to
    32 bits in total.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 110011左边的所有位置实际上都填满了零，总共32位。
- en: This means that 51 is 00000000 00000000 00000000 00110011 (we render it as 110011
    since the additional zeros are usually not needed for displaying the binary representation).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这意味着51是00000000 00000000 00000000 00110011（我们将其渲染为110011，因为通常不需要额外的零来显示二进制表示）。
- en: Obtaining the binary representation of a Java integer
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取Java整数的二进制表示
- en: 'How do we know that 110011 is the binary representation of 51? How can we compute
    the binary representation of 112 or any other Java integer? A simple approach
    consists of successively dividing the number by 2 until the quotient is less than
    1 and interpret the remainder as 0 or 1\. A remainder of 0 is interpreted as 0,
    while a remainder greater than 0 is interpreted as 1\. For example, let''s apply
    this to 51:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道110011是51的二进制表示？我们如何计算112或任何其他Java整数的二进制表示？一个简单的方法是不断地将数字除以2，直到商小于1，并将余数解释为0或1。余数为0被解释为0，而大于0的余数被解释为1。例如，让我们将这个应用到51：
- en: 51/2 = 25.5 has a quotient of 25 and a remainder of 5 -> store 1
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 51/2 = 25.5，商为25，余数为5 -> 存储1
- en: 25/2 = 12.5 has a quotient of 12 and a remainder of 5 -> store 1
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 25/2 = 12.5，商为12，余数为5 -> 存储1
- en: 12/2 = 6 has a quotient of 6 and a remainder of 0 -> store 0
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 12/2 = 6，商为6，余数为0 -> 存储0
- en: 6/2 = 3 has a quotient of 3 and a remainder of 0 -> store 0
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 6/2 = 3，商为3，余数为0 -> 存储0
- en: 3/2 = 1.5 has a quotient of 1 and a remainder of 5 -> store 1
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 3/2 = 1.5，商为1，余数为5 -> 存储1
- en: 1/2 = 0.5 has a quotient of 0 and a remainder of 5 -> store 1
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 1/2 = 0.5，商为0，余数为5 -> 存储1
- en: 'So, we stored 110011, which is the binary representation of 51\. The rest of
    the 26 bits are zeros (00000000 00000000 00000000 00**110011**). The reverse process
    starts from right to left and involves adding powers of 2 where the bits are equal
    to 1\. So here, 51 = 20+21+24+25\. The following diagram can help us understand
    this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们存储了110011，这是51的二进制表示。其余的26位都是零（00000000 00000000 00000000 00**110011**）。反向过程从右到左开始，涉及在位等于1的地方添加2的幂。所以这里，51
    = 20+21+24+25。以下图表可以帮助我们理解这一点：
- en: '![Figure 9.1 – Binary to decimal (32-bit integer)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 - 二进制到十进制（32位整数）'
- en: '](img/Figure_9.1_B15403.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B15403.jpg)'
- en: Figure 9.1 – Binary to decimal (32-bit integer)
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 - 二进制到十进制（32位整数）
- en: 'In Java, we can quickly see the binary representation of a number via `Integer#toString(int
    i, int radix)` or `Integer#toBinaryString(int i)`. For example, a radix of 2 means
    binary:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们可以通过`Integer#toString(int i, int radix)`或`Integer#toBinaryString(int
    i)`快速查看数字的二进制表示。例如，基数为2表示二进制：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The reverse process (from binary to decimal) can be obtained via `Integer#parseInt(String
    nr, int radix)`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 反向过程（从二进制到十进制）可以通过`Integer#parseInt(String nr, int radix)`获得：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next, let's tackle bitwise operators. These operators allow us to manipulate
    bits, so it is very important to understand them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来解决位运算符。这些运算符允许我们操作位，因此理解它们非常重要。
- en: Bitwise operators
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'Manipulating bits involves several operators. These operators are as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 操作位涉及几个运算符。这些运算符如下：
- en: '**Unary bitwise complement operator [~]**: Being unary, this operator needs
    a single operand that is placed before the number. This operator takes every bit
    of the number and flips its value, so 1 becomes 0 and vice versa; for example,
    5 = 101, ~5 = 010.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元按位补码运算符[~]**：作为一元运算符，此运算符需要一个放置在数字之前的单个操作数。此运算符取数字的每一位并翻转其值，因此1变为0，反之亦然；例如，5
    = 101，~5 = 010。'
- en: '**Bitwise AND [&]**: This operator needs two operands and is placed between
    two numbers. This operator compares the bits of both numbers one by one. It acts
    as the logical AND (&&), meaning that it returns 1 only if the compared bits are
    equal to 1; for example, 5 = 101, 7 = 111, 5 & 7 = 101 & 111 = 101 = 5.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位与[&]**：此运算符需要两个操作数，并放置在两个数字之间。此运算符逐位比较两个数字的位。它充当逻辑AND（&&），意味着只有在比较的位都等于1时才返回1；例如，5
    = 101，7 = 111，5 & 7 = 101 & 111 = 101 = 5。'
- en: '**Bitwise OR [****|****]**: This operator needs two operands and is placed
    between two numbers. This operator compares the bits of both numbers one by one.
    It acts as the logical OR (||), meaning that it returns 1 if at least one of the
    compared bits is 1 (or both). Otherwise, it returns 0; for example, 5 = 101, 7
    = 111, 5 | 7 = 101 | 111 = 111 = 7.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位或[****|****]**：此运算符需要两个操作数，并放置在两个数字之间。此运算符逐位比较两个数字的位。它充当逻辑OR（||），意味着如果至少有一个比较的位为1（或两者都是），则返回1。否则返回0；例如，5
    = 101，7 = 111，5 | 7 = 101 | 111 = 111 = 7。'
- en: '**Bitwise Exclusive OR (XOR) [****^****]**: This operator needs two operands
    and is placed between two numbers. This operator compares the bits of both numbers
    one by one. It returns 1 only if the compared bits have a different value. Otherwise,
    it returns 0; for example, 5 = 101, 7 = 111, 5 ^ 7 = 101 | 111 = 010 = 2.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**按位异或（XOR）[****^****]**：此运算符需要两个操作数，并放置在两个数字之间。此运算符逐位比较两个数字的位。只有在比较的位具有不同的值时才返回1。否则返回0；例如，5
    = 101，7 = 111，5 ^ 7 = 101 | 111 = 010 = 2。'
- en: 'The following diagram is a handy tool that you should keep close when you need
    to deal with bits. Basically, it summarizes how bit operators work (I suggest
    you keep this table close when you read through the *Coding challenges* section):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图是一个方便的工具，当你需要处理位时，应该随时保持接近。基本上，它总结了位运算符的工作原理（我建议你在阅读*编码挑战*部分时将此表格保持在附近）：
- en: '![Figure 9.2 – Bitwise operators'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 - 按位操作符'
- en: '](img/Figure_9.2_B15403.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B15403.jpg)'
- en: Figure 9.2 – Bitwise operators
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 按位操作符
- en: 'Moreover, the following diagram represents several tips that are quite useful
    for manipulating bits. The 0s notation represents a sequence of zeros, while the
    1s notation represents a sequence of ones:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下图表示了一些对于操作位非常有用的提示。0s表示一系列零，而1s表示一系列1：
- en: '![Figure 9.3 – Bitwise tips'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 - 按位操作提示'
- en: '](img/Figure_9.3_B15403.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.3_B15403.jpg)'
- en: Figure 9.3 – Bitwise tips
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 - 按位操作提示
- en: Take your time and explore each of these tips. Take a paper and a pen and go
    through each of them. Moreover, try to discover other tips as well.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 慢慢来，探索每一个提示。拿一张纸和一支笔，逐个浏览。此外，也尝试发现其他提示。
- en: Bit shift operators
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位移操作符
- en: Shifting is a common operation when working on bits. Here, we have `byte` (8-bit),
    `short` (16-bit), `int` (32-bit), `long` (64-bit), and `char` (16-bit); bit shift
    operators don't throw exceptions.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理位时，移位是一种常见的操作。这里有`byte`（8位）、`short`（16位）、`int`（32位）、`long`（64位）和`char`（16位）；位移操作符不会抛出异常。
- en: Signed Left Shift [<<]
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有符号左移[<<]
- en: Signed Left Shift, or shortly Left Shift , takes two operands. Left Shift gets
    the bit pattern of the first operand (left-hand side operand) and shifts it to
    the left by the number of positions given by the second operand (right-hand operand).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有符号左移，或简称左移，需要两个操作数。左移获取第一个操作数（左操作数）的位模式，并将其向左移动由第二个操作数（右操作数）给出的位置数。
- en: 'For example, the following is the result of left shifting 23 by 3 positions,
    23 << 3:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是将23左移3个位置的结果，23 << 3：
- en: '![Figure 9.4 – Signed Left Shift'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.4 - 有符号左移'
- en: '](img/Figure_9.4_B15403.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.4_B15403.jpg)'
- en: Figure 9.4 – Signed Left Shift
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 - 有符号左移
- en: As we can see, every bit of the integer 12 (10111) is shifted 3 positions to
    the left, while all the positions to the right are automatically padded with zeros.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，整数12（10111）的每一位都向左移动3个位置，而右边的所有位置都自动填充为零。
- en: Important note
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here are two hints that can be quite useful in certain scenarios:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在某些情况下可能非常有用的两个提示：
- en: 1\. Left shifting a number by *n* positions is equivalent to multiplying by
    2n (for example, 23 << 3 is equal to 184, which is equivalent to 184 = 23 * 23).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将一个数字左移*n*个位置等同于乘以2n（例如，23 << 3等同于184，等同于184 = 23 * 23）。
- en: 2\. The number of positions to shift is automatically reduced to modulo 32;
    that is, 23 << 35 is equivalent to 23 << (35 % 32), which is equivalent to 23
    << 3.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 要移位的位置数自动减少为模32；也就是说，23 << 35等同于23 << (35 % 32)，等同于23 << 3。
- en: Negative integers in Java
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Java中的负整数
- en: First of all, it is important to keep in mind that the binary representation
    itself doesn't tell us whether a number is negative. This means that computers
    need some rules for representing negative numbers. Commonly, computers store integers
    in what is known as the *two's complement* representation. Java uses this representation
    as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要记住，二进制表示本身并不能告诉我们一个数字是否为负数。这意味着计算机需要一些规则来表示负数。通常，计算机以所谓的*二进制补码*表示存储整数。Java也使用这种表示。
- en: In short, the *two's complement* representation takes the binary representation
    of a negative number and flips (negates) all its bits. After that, it adds 1 and
    appends it to the left of the bit sign. If the leftmost bit is 1, then the number
    is negative. Otherwise, it is positive.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，*二进制补码*表示将负数的二进制表示取反（否定）所有位。之后，加1并将其附加到位符号的左侧。如果最左边的位为1，则数字为负数。否则，它为正数。
- en: Let's look at the 4-bit integer, -5, as an example. We have one bit for the
    sign and three bits for the value. We know that 5 (positive number) is represented
    as 101, while -5 (negative number) is represented as **1**011\. This is obtained
    by flipping 101 so that it becomes 010, adding 1 to obtain 011 and appending it
    to the left of the sign bit (**1**) to obtain **1**011\. The 1 in bold is the
    sign bit. So, we have one bit for sign and three bits for value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以4位整数-5为例。我们有一位用于符号，三位用于值。我们知道5（正数）表示为101，而-5（负数）表示为**1**011。这是通过翻转101得到的，使其变为010，加1得到011，并将其附加到符号位（**1**）的左侧以获得**1**011。粗体中的1是符号位。所以我们有一位用于符号，三位用于值。
- en: Another way to do this is to know that the binary representation of *-Q* (negative
    *Q*) as an *n*-bit number is obtained by concatenating 1 with 2n - 1 – *Q*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是知道*-Q*（负*Q*）的二进制表示作为*n*位数是通过将1与2n - 1 - *Q*连接起来获得的。
- en: Signed Right Shift [>>]
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 右移签名[>>]
- en: Signed Right Shift, or Arithmetic Right Shift [>>], takes two operands. Signed
    Right Shift gets the bit pattern of the first operand (left-hand side operand)
    and shifts it to the right by the number of positions given by the second operand
    (right-hand operand) by preserving the sign.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 签名右移，或算术右移[>>]，需要两个操作数。签名右移获取第一个操作数（左操作数）的位模式，并通过保留符号将其向右移动给定的位置数（右操作数）。
- en: 'For example, the following is the result of -75 >> 1 (-75 is an 8-bit integer
    where the sign bit is the **Most Significant Bit** (**MSB**)):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，-75 >> 1的结果如下（-75是一个8位整数，其中符号位是**最高有效位**（**MSB**））：
- en: '![Figure 9.5 – Signed Right Shift'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.5 - 签名右移'
- en: '](img/Figure_9.5_B15403.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.5_B15403.jpg)'
- en: Figure 9.5 – Signed Right Shift
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 - 签名右移
- en: As we can see, every bit of -75 (10110101) is shifted by 1 position to the right
    (notice that the **Least Significant Bit** (**LSB**) has changed) and the bit
    sign is preserved.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，-75（10110101）的每一位都向右移动了1个位置（请注意**最低有效位**（**LSB**）已经改变），并且位符号被保留。
- en: Important note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Here are three hints that can be quite useful in certain scenarios:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在某些情况下可能非常有用的三个提示：
- en: Right shifting a number by *n* positions is equivalent to dividing by 2n (for
    example, 24 >> 3 is equal to 3, which is equivalent to 3 = 24/23).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个数字向右移动*n*个位置等同于除以2n（例如，24 >> 3等于3，这等同于3 = 24/23）。
- en: The number of positions to shift is automatically reduced to modulo 32; that
    is, 23 >> 35 is equivalent to 23 >> (35 % 32), which is equivalent to 23 >> 3\.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动的位置数自动减少到模32；也就是说，23 >> 35等同于23 >> (35 % 32)，这等同于23 >> 3。
- en: A sequence of all 1s in (signed) binary terms represents -1 in decimal form.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在（有符号）二进制术语中，一系列1代表十进制形式的-1。
- en: Unsigned Right Shift [>>>]
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无符号右移[>>>]
- en: Unsigned Right Shift, or Logical Right Shift [>>>], takes two operands. Unsigned
    Right Shift gets the bit pattern of the first operand (left-hand side operand)
    and shifts it to the right by the number of positions given by the second operand
    (right-hand operand). The MSB is set to 0\. That means that, for positive numbers,
    the Signed and Unsigned Right Shift return the same result, while negative numbers
    always become positives.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无符号右移，或逻辑右移[>>>]，需要两个操作数。无符号右移获取第一个操作数（左操作数）的位模式，并通过右操作数给定的位置数将其向右移动。MSB设置为0。这意味着对于正数，有符号和无符号右移返回相同的结果，而负数总是变为正数。
- en: 'For example, the following is the result of -75 >>> 1 (-75 is an 8-bit integer
    where the sign bit is the MSB):'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，-75 >>> 1的结果如下（-75是一个8位整数，其中符号位是MSB）：
- en: '![Figure 9.6 – Unsigned Right Shift'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.6 - 无符号右移'
- en: '](img/Figure_9.6_B15403.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.6_B15403.jpg)'
- en: Figure 9.6 – Unsigned Right Shift
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 - 无符号右移
- en: Important note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The number of positions to shift is automatically reduced to modulo 32; that
    is, 23 >>> 35 is equivalent to 23 >>> (35 % 32), which is equivalent to 23 >>>
    3\.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动的位置数自动减少到模32；也就是说，23 >>> 35等同于23 >>> (35 % 32)，这等同于23 >>> 3。
- en: Now that you have an idea of what bit shift operators are, it's time to tackle
    more tips and tricks.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了位移操作符是什么，是时候去探索更多的技巧和窍门了。
- en: Tips and tricks
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧和窍门
- en: 'Manipulating bits involves great skill when working with bits operators and
    knowing some tips and tricks. You already saw several tips earlier in this chapter.
    Now, let''s add some more as a bullet point list:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用位操作符并知道一些技巧和窍门时，操作位需要很大的技巧。在本章的前面，你已经看到了一些技巧。现在，让我们将一些更多的技巧添加为项目符号列表：
- en: If we XOR[^] a number with itself for an even number of times, then the result
    is 0 (*x ^ x =* 0; *x ^ x ^ x^ x =* (*x ^ x*) *^* (*x ^ x*) *=* 0 ^ 0 = 0).
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们对一个数字进行偶数次异或[^]，那么结果就是0（*x ^ x =* 0；*x ^ x ^ x^ x =* (*x ^ x*) *^* (*x ^
    x*) *=* 0 ^ 0 = 0）。
- en: If we XOR[^] a number with itself for an odd number of times, then the result
    is that number (*x ^ x ^ x =* (*x ^* (*x ^ x*)) *=* (*x ^* 0) *= x; x ^ x ^ x
    ^ x ^ x =* (*x ^* (*x ^ x*) *^* (*x ^ x*)) *=* (*x ^* 0 ^ 0) *= x*).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们对一个数字进行奇数次异或[^]，那么结果就是那个数字（*x ^ x ^ x =* (*x ^* (*x ^ x*)) *=* (*x ^* 0)
    *= x；x ^ x ^ x ^ x ^ x =* (*x ^* (*x ^ x*) *^* (*x ^ x*)) *=* (*x ^* 0 ^ 0) *=
    x*）。
- en: We can compute the value of the expression *p % q* with *p* > 0, *q* > 0, where
    *q* is a power of 2; that is, *p* & (*q* - 1). A simple application where you
    can see this is *ComputeModuloDivision*.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以计算表达式*p % q*的值，其中*p* > 0，*q* > 0，*q*是2的幂；也就是*p* & (*q* - 1)。一个简单的应用程序，你可以在*ComputeModuloDivision*中看到这一点。
- en: For a given positive integer *p*, we say that it is odd if ((*p* & 1) != 0)
    and even if ((*p* & 1) == 0). A simple application where you can see this is *OddEven*.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的正整数*p*，如果((*p* & 1) != 0)则我们说它是奇数，如果((*p* & 1) == 0)则我们说它是偶数。一个简单的应用程序，你可以在*OddEven*中看到这一点。
- en: For two given numbers *p* and *q*, we can say that *p* is equal to *q* if ((*p*
    ^ *q*) == 0). A simple application where you can see this is *CheckEquality*.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于给定的两个数字*p*和*q*，我们可以说*p*等于*q*，如果((*p* ^ *q*) == 0)。一个简单的应用程序，你可以在*CheckEquality*中看到这一点。
- en: For two given integers *p* and *q*, we can swap them via *p* = *p* ^ *q* ^ (*q*
    = *p*). A simple application where you can see this is *SwapTwoIntegers*.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于两个给定的整数*p*和*q*，我们可以通过*p* = *p* ^ *q* ^ (*q* = *p*)来交换它们。一个简单的应用程序，你可以在*SwapTwoIntegers*中看到这一点。
- en: Ok, it is time to tackle some coding challenges.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候解决一些编码挑战了。
- en: Coding challenges
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码挑战
- en: In the next 25 coding challenges, we will exploit different aspects of bit manipulations.
    Since these kinds of problems are really brain-teasing, they are preferred in
    interviews. Understanding a snippet of code that manipulates bits is not an easy
    task, so take your time and dissect each problem and snippet of code. This is
    the only way to obtain some patterns and templates in order to solve these kinds
    of problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的25个编码挑战中，我们将利用位操作的不同方面。由于这些问题确实很费脑子，所以在面试中更受青睐。理解操纵位的代码片段并不是一件容易的事情，所以请花时间分析每个问题和代码片段。这是解决这类问题的唯一方法，以获得一些模式和模板。
- en: 'The following figure contains a set of four bit-mask that are important to
    have in your toolbelt:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图包含了一组四个重要的位掩码，这些位掩码对于需要操作位的各种问题是有用的：
- en: '![Figure 9.7 – Bit-masks'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.7 - 位掩码'
- en: '](img/Figure_9.7_B15403.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.7_B15403.jpg)'
- en: Figure 9.7 – Bit-masks
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 - 位掩码
- en: They can be useful for solving a variety of problems where you need to manipulate
    bits.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 它们对于解决需要操作位的各种问题是有用的。
- en: Coding challenge 1 – Getting the bit value
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战1 - 获取位值
- en: '**Problem**: Consider a 32-bit integer, *n*. Write a snippet of code that returns
    the bit value of *n* at the given position, *k*.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个32位整数*n*。编写一小段代码，返回给定位置*k*处*n*的位值。'
- en: '**Solution**: Let''s consider that *n*=423\. Its binary representation is 1**1**0100111\.
    How can we say what the value of the bit at position *k*=7 is (the bold bit at
    position 7 has a value of 1)? A solution will consist of right shifting the given
    number by *k* positions (*n* >> *k*). This way, the *k*th bit becomes the bit
    at position 0 (1**1**0100111 >> 7 = 00000001**1**). Next, we can apply the AND
    [&] operator as 1 & (*n* >> *k*):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设*n*=423。它的二进制表示是1**1**0100111。我们如何说出位置*k*=7的位的值（位置7的粗体位的值为1）？一个解决方案将包括将给定的数字右移*k*位（*n*
    >> *k*）。这样，第*k*位就变成了位置0的位（1**1**0100111 >> 7 = 00000001**1**）。接下来，我们可以应用AND [&]操作符，如1
    & (*n* >> *k*)：'
- en: '![Figure 9.8 Binary representation'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.8 二进制表示'
- en: '](img/coding_challenge_1_(Fig_9.1).jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_challenge_1_(Fig_9.1).jpg)'
- en: Figure 9.8 – Binary representation
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 - 二进制表示
- en: 'If the value of the bit at position 0 is 1, then the AND[&] operator will return
    1; otherwise, it will return 0\. In terms of code, we have the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果位置0的位值为1，则AND[&]操作符将返回1；否则，它将返回0。在代码方面，我们有以下内容：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Another approach consists of replacing the expression 1 & (*n* >> *k*) with
    the expression *n* & (1 << *k*). Take your time and try to dissect it. The complete
    application is called *GetBitValue*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是用表达式*n* & (1 << *k*)替换表达式1 & (*n* >> *k*)。花点时间来分析它。完整的应用程序称为*GetBitValue*。
- en: Coding challenge 2 – Setting the bit value
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战2 - 设置位值
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider a 32-bit integer, *n*. Write a snippet of code that sets
    the bit value of *n* at the given position, *k* to 0 or 1.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个32位整数*n*。编写一小段代码，将*n*在给定位置*k*的位值设置为0或1。'
- en: '**Solution**: Let''s consider that *n*=423\. Its binary representation is 1**1**0100111\.
    How can we set the bit from position *k*=7, which is now 1, to 0? Having the bitwise
    operators table in front of us helps us see that the AND[&] operator is the only
    operator with two operands that allows us to write that 1 & 0 = 0 or the 7th bit
    & 0 = 0\. Moreover, we have 1 & 1 = 1, 0 & 1 = 0 and 0 & 0 = 0, so we can take
    a bit-mask as 1...101111111 and write the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设*n*=423。它的二进制表示是1**1**0100111。我们如何将位置*k*=7的位，现在为1，设置为0？将位操作符表放在我们面前有助于我们看到AND[&]操作符是唯一一个允许我们写1
    & 0 = 0或第7位 & 0 = 0的操作符。此外，我们有1 & 1 = 1，0 & 1 = 0和0 & 0 = 0，所以我们可以取一个位掩码为1...101111111并写如下：'
- en: '![Figure 9.9 Binary representation'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.9 二进制表示'
- en: '](img/coding_challenge_2_(Fig_9.9).jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_challenge_2_(Fig_9.9).jpg)'
- en: Figure 9.9 – Binary representation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 - 二进制表示
- en: 'This is exactly what we want. We want to turn the 7th bit from 1 into 0 and
    leave the rest untouched. But how do we obtain the 1...101111... mask? Well, there
    are two bit-masks that you need to know about. First, a bit-mask, that has a 1
    and the rest are 0s (10000...). This can be obtained by left shifting 1 by *k*
    positions (for example, the bit mask 1000 can be obtained as 1 << 3, though if
    we represent it as a 32-bit mask, we get 00000000 00000000 00000000 000**1000**).
    The other bit-mask contains a 0, while the remainder are 1s (01111...). This can
    be obtained by applying the unary bitwise complement operator [~] to the bit-mask
    10000.... (for example, ~(1000) = 0111, though if we represent it as a 32-bit
    mask, we get 11111111 11111111 11111111 111**0111**). So, we can obtain the 1...101111...
    bit-mask as ~(1 << *k*). Finally, all we have to do is use the AND[&] operator,
    as shown in the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的。我们想把第7位从1变成0，其他位保持不变。但是我们如何获得1...101111...掩码？嗯，有两个位掩码你需要知道。首先，一个位掩码，有一个1，其余都是0（10000...）。这可以通过将1左移*k*位来获得（例如，位掩码1000可以通过1
    << 3获得，尽管如果我们将其表示为32位掩码，我们得到00000000 00000000 00000000 000**1000**）。另一个位掩码包含一个0，其余都是1（01111...）。这可以通过对位掩码10000....应用一元位求反操作符[~]来获得（例如，~(1000)
    = 0111，尽管如果我们将其表示为32位掩码，我们得到11111111 11111111 11111111 111**0111**）。因此，我们可以将1...101111...位掩码获得为~(1
    << *k*)。最后，我们所要做的就是使用AND[&]操作符，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If we take *k*=3, 4, or 6, then we get 0 & 0 = 0.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取*k*=3, 4, 或6，那么我们得到0 & 0 = 0。
- en: Let's consider that *n*=295\. Its binary representation is 1**0**0100111\. How
    can we set the bit from position *k*=7, which is now 0, to 1? Having the bitwise
    operators table in front of us helps us see that the OR[|] and XOR[^] operators
    are the operators with two operands that allow us to write that 0 | 1 = 1 or 0
    ^ 1 = 1, respectively.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑*n*=295。它的二进制表示是1**0**0100111。我们如何设置位置*k*=7的位，现在是0，变为1？在我们面前有位运算符表有助于我们看到，OR[|]和XOR[^]运算符是允许我们写成0|1=1或0^1=1的两个操作数的运算符。
- en: Or, we can write that 7th | 1 = 1 and 7th ^ 1 = 1.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以写成第7个|1=1和第7个^1=1。
- en: 'By going one step further, we can see that in the case of the OR[|] operator,
    we can write the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再进一步，我们可以看到在OR[|]运算符的情况下，我们可以写成以下内容：
- en: 1 | 1 = 1, while in the case of the XOR[^] operator, we write 1 ^ 1 = 0.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 1|1=1，而在XOR[^]运算符的情况下，我们写1^1=0。
- en: 'Since we want to turn the 7th bit value from 0 to 1, we can use either of these
    two operators. However, if *k* indicates a bit with an initial value of 1, then
    1 ^ 1 = 0 doesn''t help us anymore, while 1 | 1 = 1 is exactly what we want. So
    here, we should use the 10000... bit-mask, as shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将第7位的值从0变为1，我们可以使用这两个运算符中的任何一个。然而，如果*k*指示具有初始值1的位，那么1^1=0就不再帮助我们了，而1|1=1正是我们想要的。所以在这里，我们应该使用10000...位掩码，如下所示：
- en: '![Figure 9.10 Binary representation'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.10二进制表示'
- en: '](img/coding_challenge_2_(Fig_9.10).jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_challenge_2_(Fig_9.10).jpg)'
- en: Figure 9.10 – Binary representation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10-二进制表示
- en: 'In terms of code, we have the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If we take *k*=0, 1, 2, 5, or 8, then we get 1 | 1 = 1.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取*k*=0, 1, 2, 5, 或8，那么我们得到1|1=1。
- en: The complete application is called *SetBitValue*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SetBitValue*。
- en: Coding challenge 3 – Clearing bits
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战3-清除位
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider a 32-bit integer, *n*. Write a snippet of code that clears
    the bits of *n* (sets their value to 0) between the MSB and the given *k*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个32位整数*n*。编写一小段代码，清除*n*之间的位（将它们的值设置为0）MSB和给定的*k*之间。'
- en: '**Solution**: Let''s consider that *n*=423\. Its binary representation is **110**100111\.
    How can we clear the bits between MSB and position *k*=6 so that there are 110
    bits? Having the bitwise operators table in front of us helps us see that we need
    a bit-mask of type 00011111\. Let''s see what happens if we apply the AND[&] operator
    between *n* and this bit-mask:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑*n*=423。它的二进制表示是**110**100111。我们如何清除MSB和位置*k*=6之间的位，以便有110位？在我们面前有位运算符表有助于我们看到，我们需要一个类型为00011111的位掩码。让我们看看如果我们在*n*和这个位掩码之间应用AND[&]运算符会发生什么：'
- en: '![Figure 9.11 Binary representation'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.11二进制表示'
- en: '](img/coding_chh_3_(Fig_9.11).jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_chh_3_(Fig_9.11).jpg)'
- en: Figure 9.11 – Binary representation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11-二进制表示
- en: 'So, we cleared the bits between MSB and *k*=6\. Generally speaking, we need
    a bit-mask that contains 0s between the MSB and *k* (inclusive) and 1s between
    *k* (exclusive) and LSB. We can do this by left shifting the bits of 1 with *k*
    positions (for example, for *k*=6, we obtain 1000000) and subtracting 1\. This
    way, we obtain the needed bit-mask, 0111111\. So, in terms of code, we have the
    following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们清除了MSB和*k*=6之间的位。一般来说，我们需要一个包含MSB和*k*（包括）之间的0和*k*（不包括）和LSB之间的1的位掩码。我们可以通过将1的位左移*k*位（例如，对于*k*=6，我们得到1000000）并减去1来实现这一点。这样，我们就得到了所需的位掩码，0111111。因此，在代码方面，我们有以下内容：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'How about clearing the bits between the given *k* and the LSB? Let me show
    you the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如何清除给定*k*和LSB之间的位？让我向你展示代码：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, take your time and dissect this solution. Moreover, we can replace this
    solution with this one: *n* & (-1 << (*k* + 1)).'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，花点时间来分解这个解决方案。此外，我们可以用这个解决方案替换这个解决方案：*n* & (-1 << (*k* + 1))。
- en: Again, use a paper and a pen and take it step by step. The complete application
    is called *ClearBits*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用纸和笔一步一步地进行。完整的应用程序称为*ClearBits*。
- en: Coding challenge 4 – Summing binaries on paper
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战4-在纸上求二进制和
- en: '**Problem**: Consider several positive 32-bit integers. Take a pen and some
    paper and show me how you sum up their binary representation.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑几个正的32位整数。拿一支笔和一些纸，向我展示如何求它们的二进制表示。'
- en: '**Note**: This is not quite a coding challenge, but it is important to know
    about.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这不完全是一个编码挑战，但了解这一点很重要。'
- en: '**Solution**: Summing binary numbers can be done in several ways. A simple
    approach is to do the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：求和二进制数可以用几种方法来完成。一个简单的方法是做以下操作：'
- en: Sum all the bits of the current column (the first column is the column of LSB).
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求当前列的所有位之和（第一列是LSB的列）。
- en: Convert the result into binary (for example, via successive divisions by 2).
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换为二进制（例如，通过连续除以2）。
- en: Keep the rightmost bit as the result.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保留最右边的位作为结果。
- en: Carry the remains bits into the remaining columns (one bit per column).
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将剩余的位带入剩余的列（每列一个位）。
- en: Go to the next column and repeat from *step 1*.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到下一列并重复从*步骤1*开始。
- en: An example will clarify things. Let's add 1 (1) + 9 (1001) + 29 (011101) + 124
    (1111100) = 163 (10100011).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子将澄清事情。让我们加1（1）+9（1001）+29（011101）+124（1111100）=163（10100011）。
- en: 'The following diagram represents the result of summing these numbers:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表了这些数字相加的结果：
- en: '![Figure 9.12 – Summing binary numbers'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.12-求和二进制数'
- en: '](img/Figure_9.12_B15403.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.12_B15403.jpg)'
- en: Figure 9.12 – Summing binary numbers
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12-求和二进制数
- en: 'Now, let''s see this step by step (the bold sections are carried):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步地看（粗体部分是进行的）：
- en: 'Sum bits on column 0: 1 + 1 + 1 + 0 = 3 = **1**1 1'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第0列上求和位：1+1+1+0=3=**1**1 1
- en: 'Sum bits on column 1: **1** + 0 + 0 + 0 = 1 = 1 1'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第1列上求和位：**1**+0+0+0=1=1 1
- en: 'Sum bits on column 2: 0 + 1 + 1 = 2 = **1**0 0'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2列上求和位：0+1+1=2=**1**0 0
- en: 'Sum bits on column 3: **1** + 1 + 1 + 1 = 4 = **10**0 0'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第3列上求和位：**1**+1+1+1=4=**10**0 0
- en: 'Sum bits on column 4: **0** + 1 + 1 = 2 = **1**0 0'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第4列上求和位：**0**+1+1=2=**1**0 0
- en: 'Sum bits on column 5: **1** + **1** + 0+1 = 3 = **1**1 1'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第5列上求和位：**1**+**1**+0+1=3=**1**1 1
- en: 'Sum bits on column 6: **1** + 1 = 2 = **1**0 0'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第6列上求和位：**1**+1=2=**1**0 0
- en: 'Sum bits on column 7: **1** = 1 = 1 1'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第7列上求和位：**1**=1=1 1
- en: So, the result is 10100011.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果是10100011。
- en: Coding challenge 5 – Summing binaries in code
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战5 - 代码中的二进制求和
- en: '**Problem**: Consider two 32-bit integers, *q* and *p*. Write a snippet of
    code that computes *q* + *p* using their binary representation.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个32位整数*q*和*p*。编写一小段代码，使用它们的二进制表示来计算*q* + *p*。'
- en: '**Solution**: We can try an implementation of the algorithm presented in the
    previous coding challenge, or we can try another approach. This approach introduces
    an equation that is useful to know:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以尝试实现前面编码挑战中提出的算法，或者我们可以尝试另一种方法。这种方法引入了一个有用的等式：'
- en: '![](img/coding_ch_5,_image_1.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/coding_ch_5,_image_1.jpg)'
- en: 'Notice the presence of the AND[&] and XOR[^] bitwise operators. If we denote
    *p* & *q* with *and*, and *p* ^ *q* with *xor*, then we can write that as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到AND[&]和XOR[^]位运算符的存在。如果我们用*and*表示*p* & *q*，用*xor*表示*p* ^ *q*，那么我们可以写成如下：
- en: '![](img/Coding_ch_5,_image_2.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Coding_ch_5,_image_2.jpg)'
- en: 'If *p* and *q* have no common bits, then we can reduce this to the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*和*q*没有共同的位，那么我们可以将其简化为以下形式：
- en: '![](img/coding_ch_5,_image_3.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/coding_ch_5,_image_3.jpg)'
- en: For example, if *p* = 1010 and *q* = 0101, then *p* & *q* = 0000\. Since 2*0000
    = 0, we remain with *p* + *q* = *xor*, or *p* + *q* = 1111.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果*p*=1010，*q*=0101，那么*p* & *q*=0000。由于2*0000=0，我们得到*p* + *q*=*xor*，或者*p*
    + *q*=1111。
- en: However, if *p* and *q* have common bits, then we must deal with the addition
    of *and* and *xor*. So*, and + xor* can be solved if we force the *and* expression
    to return 0\. This can be done via recursion.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果*p*和*q*有共同的位，那么我们必须处理*and*和*xor*的加法。因此，如果我们强制*and*表达式返回0，那么*and + xor*就可以解决。这可以通过递归来实现。
- en: 'Through recursion, we can write the first step of recursion as:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归，我们可以将递归的第一步写成：
- en: '![](img/Coding_ch_5,_image_4.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Coding_ch_5,_image_4.jpg)'
- en: 'Alternatively, if we denote *and*{1} = 2 * *and* & *xor*, and *xor*{1} = 2
    * *and* ^ *xor* where {1} means one step of recursion, then we can write this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们表示*and*{1} = 2 * *and* & *xor*，*xor*{1} = 2 * *and* ^ *xor*，其中{1}表示递归的一步，那么我们可以写成这样：
- en: '![](img/Coding_ch_5,_image_5.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Coding_ch_5,_image_5.jpg)'
- en: But when does this recursion stop? Well, it should stop when the intersection
    between the two bit sequences (*p* and *q*) in the *and*{*n*} expression returns
    0\. So, here, we forced the *and* expression to return 0.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个递归什么时候停止呢？嗯，当两个位序列（*p*和*q*）在*and*{*n*}表达式中的交集返回0时，它应该停止。所以，在这里，我们强制*and*表达式返回0。
- en: 'In terms of code, we have the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The complete application is called *SummingBinaries*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SummingBinaries*。
- en: Coding challenge 6 – Multiplying binaries on paper
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战6 - 纸上的二进制相乘
- en: '**Problem**: Consider two positive 32-bit integers, *q* and *p*. Take some
    paper and a pen and show me how you multiply the binary representation of these
    two numbers (*q***p*).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*。拿出纸和笔，向我展示如何计算这两个数字的二进制表示（*q***p*）的乘法。'
- en: '**Note**: This is not quite a coding challenge, but it is important to know
    about.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这不完全是一个编码挑战，但了解这一点很重要。'
- en: '**Solution**: When we multiply binary numbers, we must keep in mind that multiplying
    a binary number by 1 gives us back exactly the same binary number, while multiplying
    a binary number by 0 gives us back 0\. The steps for multiplying two binary numbers
    are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：当我们相乘二进制数时，我们必须记住，将一个二进制数乘以1会得到完全相同的二进制数，而将一个二进制数乘以0会得到0。相乘两个二进制数的步骤如下：'
- en: Multiply every bit of the second binary number by every bit of the first binary
    number, starting from the rightmost column (column 0).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从最右边的列（第0列）开始，将第二个二进制数的每一位乘以第一个二进制数的每一位。
- en: Sum up the results.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总结结果。
- en: Let's do 124 (1111100) * 29 (011101) = 3596 (111000001100).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做124（1111100）* 29（011101）= 3596（111000001100）。
- en: 'The following diagram represents the result of our computation:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了我们计算的结果：
- en: '![Figure 9.13– Multiplying binary numbers'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.13-相乘二进制数'
- en: '](img/Figure_9.13_B15403.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.13_B15403.jpg)'
- en: Figure 9.13 – Multiplying binary numbers
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.13 - 相乘二进制数
- en: So, we multiply every bit of 29 with every bit of 124\. Next, we sum up those
    binaries, as you saw earlier in the *Coding challenge 4 – Summing binaries on
    paper* section.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将29的每一位与124的每一位相乘。接下来，我们将这些二进制数相加，就像你在*编码挑战4 - 纸上的二进制求和*部分看到的那样。
- en: Coding challenge 7 – Multiplying binaries in code
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战7 - 代码中的二进制相乘
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider two 32-bit integers, *q* and *p*. Write a snippet of
    code that computes *q* * *p* using their binary representation.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个32位整数*q*和*p*。编写一小段代码，使用它们的二进制表示来计算*q* * *p*。'
- en: '**Solution**: We can try an implementation of the algorithm presented in the
    previous coding challenge, or we can try another approach. This approach starts
    by assuming that *p*=1, so here, we have *q**1=*q*. We know that any *q* multiplied
    by 1 is *q*, so we can say that *q**1 follows the next sum (we go from 0 to 30,
    so we ignore the signed bit on position 31):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以尝试实现前面编码挑战中提出的算法，或者我们可以尝试另一种方法。这种方法首先假设*p*=1，所以这里，我们有*q**1=*q*。我们知道任何*q*乘以1都是*q*，所以我们可以说*q**1遵循下一个和（我们从0到30，所以我们忽略位置31上的符号位）：'
- en: '![Figure 9.14 Multiplying binaries in a code'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.14 在代码中相乘二进制'
- en: '](img/Figure_9.14_B15403.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.14_B15403.jpg)'
- en: Figure 9.14 – Multiplying binaries in a code
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.14 - 代码中的二进制相乘
- en: For example, if *q*=5 (101), then 5 * 1 = 0*230 + 0*229 + ...1*22 + 0*21 + 1*20
    = 5.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果*q*=5（101），那么5 * 1 = 0*230 + 0*229 + ...1*22 + 0*21 + 1*20 = 5。
- en: So, 5 * 1 = 5\.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，5 * 1 = 5。
- en: So far, this is not such a big deal, but let's continue with 5 * 2; that is,
    with 101 * 10\. If we think that 5 * 2 = 5 * 0 + 10 * 1, then this means that
    101 * 10 = 101 * 0 + 1010 * 1\. So, we left shifted 5 by one position and we right
    shifted 2 by one position.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这并不是什么大不了的事，但让我们继续5 * 2；也就是说，101 * 10。如果我们认为5 * 2 = 5 * 0 + 10 * 1，那么这意味着101
    * 10 = 101 * 0 + 1010 * 1。所以，我们将5左移了一位，将2右移了一位。
- en: Let's continue with 5 * 3\. This is 101 * 011\. However, 5 * 3 = 5 * 1 + 10
    * 1\. Hence it is like 101 * 1 + 1010 * 1.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行5*3。这是101*011。然而，5*3=5*1+10*1。因此，它就像101*1+1010*1。
- en: Let's continue with 5 * 4\. This is 101 * 100\. However, 5 * 4 = 5 * 0 + 10
    * 0 + 20 * 1\. Thus, it is like 101 * 0 + 1010 * 0 + 10100 * 1.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行5*4。这是101*100。然而，5*4=5*0+10*0+20*1。因此，它就像101*0+1010*0+10100*1。
- en: 'Now, we can start to see a pattern that follows these steps (initially, *result*=0):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始看到遵循这些步骤的模式（最初，*result*=0）：
- en: If the LSB of *p* is 1, then we write the following:![Figure 9.15 – LSB of p
    is 1
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*p*的LSB为1，则我们写下以下内容：![图9.15- p的LSB为1
- en: '](img/Figure_9.15_B15403.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.15_B15403.jpg)'
- en: Figure 9.15 – LSB of p is 1
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15- p的LSB为1
- en: We left shift *q* by one position and logical right shift *p* by one position.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将*q*左移一位，将*p*逻辑右移一位。
- en: We repeat from *step 1* until *p* is 0.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重复从*步骤1*直到*p*为0。
- en: 'If we put these three steps into code, then we obtain the following output:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这三个步骤编写成代码，那么我们将得到以下输出：
- en: '[PRE8]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The complete application is called *MultiplyingBinaries*.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*MultiplyingBinaries*。
- en: Coding challenge 8 – Subtracting binaries on paper
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战8-在纸上减去二进制数
- en: '**Problem**: Consider two positive 32-bit integers, *q*, and *p*. Take some
    paper and a pen and show me how you subtract the binary representation of these
    two numbers (*q*-*p*).'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*。拿出纸和笔，向我展示如何减去这两个数字的二进制表示（*q*-*p*）。'
- en: '**Note**: This is not quite a coding challenge, but it is important to know
    about.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这不完全是一个编码挑战，但了解这一点很重要。'
- en: '**Solution**: Subtracting binary numbers can be reduced in order to compute
    0 minus 1\. Mainly, we know that 1 minus 1 is 0, 0 minus 0 is 0, and 1 minus 0
    is 1\. To compute 0 minus 1, we must follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：减去二进制数可以简化为计算0减1。主要是，我们知道1减1是0，0减0是0，1减0是1。要计算0减1，我们必须按照以下步骤进行：'
- en: From the current column, we search the left column(s) until we find a bit of
    1.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从当前列开始，我们搜索左列，直到找到一个1位。
- en: We borrow this bit and put it in the preceding column as two values of 1.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们借用这个位，并将其放在前一列作为两个值为1。
- en: We then borrow one of these two values of 1 from the preceding column as other
    two of 1.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从前一列借用这两个值为1，作为另外两个值为1。
- en: Repeat *step 3* for each column until we reach the current column.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每一列重复*步骤3*，直到达到当前列。
- en: Now, we can perform the computation.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以进行计算。
- en: If we encounter another 0 minus 1, then we repeat this process from *step 1*.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们遇到另一个0减1，那么我们从*步骤1*重复这个过程。
- en: Let's do 124 (1111100) - 29 (011101) = 95 (1011111).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们做124（1111100）-29（011101）=95（1011111）。
- en: 'The following diagram represents the result of our computation:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了我们计算的结果：
- en: '![Figure 9.16 – Subtracting binary numbers'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.16-减去二进制数'
- en: '](img/Figure_9.16_B15403.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.16_B15403.jpg)'
- en: Figure 9.16 – Subtracting binary numbers
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16-减去二进制数
- en: 'Now, let''s see this step by step:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步来看：
- en: Start from column 0, so from 0 minus 1\. We search in the left column(s) until
    we find a bit of 1\. We find it at column 2 (this bit corresponds to 22=4). We
    borrow this bit in column 1 and use it as two values of 1 (in other words, two
    of 2 is 21+21). We borrow one of these two values of 1 (this is 21=2) in column
    0 and use them as two other two values of 1 (in other words, two of 1 is 20+20).
    Now, we can do the computation as 2 minus 1 equals 1\. We write down 1 and move
    on to column 1.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第0列开始，所以从0减1。我们在左列中搜索，直到找到一个1位。我们在第2列找到了它（这个位对应于22=4）。我们从第1列借用这个位，并将其用作两个值为1（换句话说，2的两倍是21+21）。我们从第0列借用这两个值为1（这是21=2），并将它们用作另外两个值为1（换句话说，1的两倍是20+20）。现在，我们可以计算为2减1等于1。我们写下1，并移动到第1列。
- en: We continue with column 1, so with 1 minus 0 equals 1\. We write down 1 and
    we move to column 2.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行第1列，所以是1减0等于1。我们写下1，然后移动到第2列。
- en: We then continue with column 2, so with 0 minus 1\. We search in the left column(s)
    until we find a bit of 1\. We find it at column 3 (this bit corresponds to 23=8).
    We borrow this bit from column 2 and use it as two values of 1 (in other words,
    two of 2 is 22+22). Now, we can do the computation as 2 minus 1 equals 1\. We
    write down 1 and we move to column 3.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们继续进行第2列，所以是0减1。我们在左列中搜索，直到找到一个1位。我们在第3列找到了它（这个位对应于23=8）。我们从第2列借用这个位，并将其用作两个值为1（换句话说，2的两倍是22+22）。现在，我们可以计算为2减1等于1。我们写下1，然后移动到第3列。
- en: We continue with column 3, so with 0 minus 1\. We search in the left column(s)
    until we find a bit of 1\. We find it at column 4 (this bit corresponds to 24=16).
    We borrow this bit in column 3 and use it as two values of 1 (in other words,
    two of 2 is 23+23). Now, we can do the computation as 2 minus 1 equals 1\. We
    write down 1 and we move to column 4.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行第3列，所以是0减1。我们在左列中搜索，直到找到一个1位。我们在第4列找到了它（这个位对应于24=16）。我们从第3列借用这个位，并将其用作两个值为1（换句话说，2的两倍是23+23）。现在，我们可以计算为2减1等于1。我们写下1，然后移动到第4列。
- en: We continue with column 4, so with 0 minus 1\. We search in the left column(s)
    until we find a bit of 1\. We find it at column 5 (this bit corresponds to 25=32).
    We borrow this bit in column 4 and use it as two values of 1 (in other words,
    two of 2 is 24+24). Now, we can do the computation as 2 minus 1 equals 1\. We
    write down 1 and we move to column 5.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行第4列，所以是0减1。我们在左列中搜索，直到找到一个1位。我们在第5列找到了它（这个位对应于25=32）。我们从第4列借用这个位，并将其用作两个值为1（换句话说，2的两倍是24+24）。现在，我们可以计算为2减1等于1。我们写下1，然后移动到第5列。
- en: We continue with column 5, so with 0 minus 0\. We write down 0 and we move to
    column 6.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行第5列，所以是0减0。我们写下0，然后移动到第6列。
- en: We continue with column 6, so with 1 minus 0\. We write down 1 and then we're
    done.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们继续进行第6列，所以是1减0。我们写下1，然后我们完成了。
- en: So, the result is 1011111.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，结果是1011111。
- en: Coding challenge 9 – Subtracting binaries in code
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战9-在代码中减去二进制数
- en: '**Problem**: Consider two 32-bit integers, *q* and *p*. Write a snippet of
    code that computes *q - p* using their binary representation.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个32位整数*q*和*p*。编写一小段代码，使用它们的二进制表示来计算*q - p*。'
- en: '**Solution**: We already know from the previous coding challenge that subtracting
    binary numbers can be reduced to compute 0 minus 1\. Moreover, we know how to
    solve 0 minus 1 by using the *borrowing* technique. Besides the borrowing technique,
    it is important to notice that |*q - p*| = *q* ^ *p*; for example:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们已经从之前的编码挑战中知道，减去二进制数可以简化为计算0减1。此外，我们知道如何使用*借位*技术解决0减1。除了借位技术，重要的是要注意|*q
    - p*| = *q* ^ *p*；例如：'
- en: '|1 - 1| = 1 ^ 1 = 0, |1 - 0| = 1 ^ 0 = 1, |0 - 1| = 0 ^ 1 = 1 and |0 - 0| =
    0 ^ 0 = 0.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '|1 - 1| = 1 ^ 1 = 0, |1 - 0| = 1 ^ 0 = 1, |0 - 1| = 0 ^ 1 = 1和|0 - 0| = 0 ^
    0 = 0。'
- en: 'Based on these two statements, we can implement the subtraction of two binaries,
    as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这两个陈述，我们可以实现两个二进制数的减法，如下所示：
- en: '[PRE9]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete application is called *SubtractingBinaries*.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SubtractingBinaries*。
- en: Coding challenge 10 – Dividing binaries on paper
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战10 - 纸上的二进制除法
- en: '**Problem**: Consider two positive 32-bit integers, *q* and *p*. Take some
    paper and a pen and show me how you divide the binary representation of these
    two numbers (*q*/*p*).'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*。拿出纸和笔，向我展示如何除以这两个数字的二进制表示（*q*/*p*）。'
- en: '**Note**: This is not quite a coding challenge, but it is important to know
    about.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**：这不完全是一个编码挑战，但了解这一点很重要。'
- en: '**Solution**: In binary division, there are only two possibilities: either
    0 or 1\. Division involves the *dividend* (*q*), the *divisor* (*p*)*,* the *quotient*,
    and the *remainder*. For example, we know that 11(dividend) / 2(divisor) = 5(quotient)
    1(remainder). Or, in binary representation, we have 1011(dividend) / 10 (divisor)
    = 101(quotient) 1(remainder)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：在二进制除法中，只有两种可能性：0或1。除法涉及*被除数*（*q*）、*除数*（*p*）、*商*和*余数*。例如，我们知道11（被除数）/
    2（除数）= 5（商）1（余数）。或者，在二进制表示中，我们有1011（被除数）/ 10（除数）= 101（商）1（余数）'
- en: 'We start by comparing the divisor with the MSB of the dividend (let''s call
    this the *sub-dividend*) and do the following:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将除数与被除数的最高位进行比较（让我们称之为*子被除数*），然后进行以下操作：
- en: a. If the divisor doesn't fit into the sub-dividend (divisor > sub-dividend),
    then we append 0 to the quotient.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: a.如果除数不适合子被除数（除数>子被除数），则我们将0附加到商。
- en: a.a) We append the next bit of the dividend to the sub-dividend and continue
    from *step a*).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: a.a)我们将被除数的下一位附加到子被除数上，并从*步骤a*继续)。
- en: b. If the divisor fits into the sub-dividend (divisor <= sub-dividend), then
    we append 1 to the quotient.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: b.如果除数适合子被除数（除数<=子被除数），则我们将1附加到商。
- en: b.a) We subtract the divisor from the current sub-dividend.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: b.a)我们从当前子被除数中减去除数。
- en: b.b) We append the next bit of the dividend to the result of the subtraction
    (this is the new sub-dividend) and we repeat from *step a*)*.*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: b.b)我们将被除数的下一位附加到减法的结果（这是新的子被除数），然后从*步骤a*重复)。
- en: c. When we've processed all the bits of the dividend, we should have the quotient
    and the remainder, which is the result of the division.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: c.当我们处理完被除数的所有位时，我们应该得到商和余数，这是除法的结果。
- en: c.a) We can stop here and express the result in terms of the obtained quotient
    and the remainder.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: c.a)我们可以在这里停下来，并用获得的商和余数表示结果。
- en: c.b) We can append a dot ("**."**) to the quotient and a 0 to the current remainder
    (this is the new sub-dividend) and continue from *step a* until the remainder
    is 0 or we are satisfied by the result.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: c.b)我们可以在商中附加一个点（“**.**”），在当前余数中附加0（这是新的子被除数），并继续从*步骤a*，直到余数为0或我们对结果满意为止。
- en: 'The following diagram represents the 11/2 division:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表示了11/2的除法：
- en: '![Figure 9.17 – Dividing binary numbers'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.17 - 二进制数的除法'
- en: '](img/Figure_9.17_B15403.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.17_B15403.jpg)'
- en: Figure 9.17 – Dividing binary numbers
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 - 二进制数的除法
- en: 'Now, let''s see this step by step (focus on the left-hand side of the preceding
    diagram):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们一步一步来看（专注于前面图表的左侧）：
- en: Sub-dividend = 1, 10 > 1 since 2 > 1, therefore we append 0 to the quotient.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子被除数= 1，10 > 1，因为2 > 1，因此我们将0附加到商。
- en: Sub-dividend = 10, 10 = 10 since 2 = 2, therefore we append 1 to the quotient.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子被除数= 10，10 = 10，因为2 = 2，因此我们将1附加到商。
- en: Do subtraction, 10 - 10 = 0.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行减法，10 - 10 = 0。
- en: Sub-dividend = 01, 10 > 01 since 2 > 1, therefore we append 0 to the quotient.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子被除数= 01，10 > 01，因为2 > 1，因此我们将0附加到商。
- en: Sub-dividend = 011, 10 < 011 since 2 < 3, therefore we append 1 to the quotient.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子被除数= 011，10 < 011，因为2 < 3，因此我们将1附加到商。
- en: Do subtraction, 011 - 10 = 1.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行减法，011 - 10 = 1。
- en: There are no more bits to process from the dividend, so we can say that 11/2
    has the quotient 101 (which is 5) and that the remainder is 1.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从被除数中没有更多的位需要处理，因此我们可以说11/2的商为101（即5），余数为1。
- en: If you look at the right-hand side of the preceding diagram, then you will see
    that we can continue the computation until the remainder is 0 by applying the
    *step c.b* given.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看一下前面图表的右侧，那么您将看到我们可以继续计算，直到余数为0，通过应用给定的*步骤c.b*。
- en: Coding challenge 11 – Dividing binaries in code
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战11 - 代码中的二进制除法
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider two 32-bit integers, *q* and *p*. Write a snippet of
    code that computes *q*/*p* using their binary representation.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个32位整数*q*和*p*。编写一小段代码，使用它们的二进制表示来计算*q*/*p*。'
- en: '**Solution**: There are several approaches we can use to divide two binaries.
    Let''s focus on implementing a solution that computes only the quotient, which
    means we skip the remainder.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们可以使用几种方法来除两个二进制数。让我们专注于实现一个仅计算商的解决方案，这意味着我们跳过余数。'
- en: 'This approach is quite straightforward. We know that a 32-bit integer contains
    the bits that count for us between 31 and 0\. All we have to do is left shift
    the divisor (*p*) by *i* positions (*i*=31, 30, 29, ..., 2, 1, 0) and check if
    the result is less than the dividend (*q*). Each time we find such a bit, we update
    the *i*th bit position. We accumulate the result and pass it to the next position.
    The following code speaks for itself:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法非常直接。我们知道32位整数包含我们在31和0之间计数的位。我们所要做的就是将除数（*p*）左移*i*个位置（*i*=31,30,29,...,2,1,0）并检查结果是否小于被除数（*q*）。每次我们找到这样的位时，我们更新第*i*位位置。我们累积结果并将其传递到下一个位置。以下代码不言自明：
- en: '[PRE10]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The complete application is called *DividingBinaries*. It also contains the
    implementation that computes the remainder.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*DividingBinaries*。它还包含计算余数的实现。
- en: Coding challenge 12 – Replacing bits
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战12 - 替换位
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊，谷歌，Adobe
- en: '**Problem**: Consider two positive 32-bit integers, *q* and *p*, and two bit
    positions, *i* and *j*. Write a snippet of code that replaces the bits from *q*
    between positions *i* and *j* with the bits of *p*. You can assume that, between
    *i* and *j,* there is enough space to fit all bits of *p*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*，以及两个位位置*i*和*j*。编写一小段代码，用*p*的位替换*q*在位置*i*和*j*之间的位。您可以假设在*i*和*j*之间，有足够的空间来容纳*p*的所有位。'
- en: '**Solution**: Let''s consider that *q*=4914 (in binary, 1001100110010), *p*=63
    (in binary, 111111), *i*=4, and *j*=9\. The following diagram shows what we have
    and what we want to obtain:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑*q*=4914（二进制中为1001100110010），*p*=63（二进制中为111111），*i*=4，*j*=9。以下图表显示了我们拥有的内容以及我们想要获得的内容：'
- en: '![Figure 9.18 – Replacing the bits between i and j'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.18 - 替换i和j之间的位'
- en: '](img/Figure_9.18_B15403.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.18_B15403.jpg)'
- en: Figure 9.18 – Replacing the bits between i and j
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.18 - 替换i和j之间的位
- en: As we can see, the solution should accomplish three main steps. First, we need
    to clear the bits of *q* between *i* and *j*. Second, we need to left shift *p*
    by *i* positions (this way, we place *p* in the right position). Finally, we merge
    *p* and *q* in the final result.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，解决方案应该完成三个主要步骤。首先，我们需要清除*i*和*j*之间的*q*位。其次，我们需要将*p*左移*i*个位置（这样，我们将*p*放在正确的位置）。最后，我们将*p*和*q*合并到最终结果中。
- en: 'In order to clear the bits of *q* between *i* and *j* (set those bits to 0,
    no matter their initial value), we can use the AND[&] operator. We know that only
    1 & 1 return 1, so if we have a bit-mask that contains 0s between *i* and *j*,
    then *q* & *bit mask* will result in a sequence of bits containing only 0s between
    *i* and *j* since 1 & 0 and 0 & 0 are 0\. Moreover, between the MSB and *j* (exclusive),
    and *i* (exclusive) and the LSB of the bit mask, we should have only values of
    1\. This way, *q* & *bit mask* will preserve the *q* bits since 1 & 1 = 1 and
    0 & 1 = 0\. So, our bit mask should be 1110000001111\. Let''s see it at work:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清除*i*和*j*之间的*q*位（将这些位设置为0，无论它们的初始值如何），我们可以使用AND[&]运算符。我们知道只有1和1返回1，所以如果我们有一个包含*i*和*j*之间的0的位掩码，那么*q*和*位掩码*将导致*i*和*j*之间只包含0的位序列，因为1和0以及0和0都是0。此外，在MSB和*j*（不包括在内）之间，以及位掩码的LSB和*i*（不包括在内）之间，我们应该只有1的值。这样，*q*和*位掩码*将保留*q*位，因为1和1=1，0和1=0。因此，我们的位掩码应该是1110000001111。让我们看看它是如何工作的：
- en: '![Figure 9.19 – Bit-mask (a)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.19 - 位掩码（a）'
- en: '](img/coding_ch_12._1_(Fig_9.19).jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_12._1_(Fig_9.19).jpg)'
- en: Figure 9.19 – Bit-mask (a)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.19 - 位掩码（a）
- en: 'But how can we obtain this mask? We can obtain it via the OR[|] operator, as
    follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何获得这个掩码？我们可以通过OR[|]运算符获得它，如下所示：
- en: '![Figure 9.20 – Bit-mask (b)'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.20 - 位掩码（b）'
- en: '](img/coding_ch_12,_2_(Fig_9.20).jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_12,_2_(Fig_9.20).jpg)'
- en: Figure 9.20 – Bit-mask (b)
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.20 - 位掩码（b）
- en: The 1110000000000 bit mask can be obtained by left shifting -1 by *j*+1 positions,
    while the 0000000001111 bit mask can be obtained by left shifting 1 by *i* positions
    and subtracting 1.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 1110000000000位掩码可以通过将-1左移*j*+1个位置获得，而0000000001111位掩码可以通过将1左移*i*个位置并减去1获得。
- en: 'Here, we solved the first two steps. Finally, we need to put *p* in the right
    position. This is easy: we just left shift *p* by *i* positions. Finally, we apply
    the OR[|] operator between *q* with cleared bits between *i* and *j*, and the
    shifted *p*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们解决了前两个步骤。最后，我们需要把*p*放在正确的位置。这很容易：我们只需将*p*左移*i*个位置。最后，我们在*q*和*i*和*j*之间的位清除后，应用OR[|]运算符与移位后的*p*：
- en: '![Figure 19.21 Binary representation'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![图19.21 二进制表示'
- en: '](img/coding_ch_12,_3_(Fig_9.21).jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_12,_3_(Fig_9.21).jpg)'
- en: Figure 9.21 – Binary representation
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.21 - 二进制表示
- en: 'We''re done! Now, let''s put this into code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了！现在，让我们把这个放入代码中：
- en: '[PRE11]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The complete application is called *ReplaceBits*.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*ReplaceBits*。
- en: Coding challenge 13 – Longest sequence of 1
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战13 - 最长1序列
- en: '**Amazon**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider a 32-bit integer, *n*. A sequence of 101 can be considered
    111\. Write a snippet of code that computes the length of the longest sequence
    of 1\.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个32位整数*n*。101的序列可以被视为111。编写一小段代码，计算最长1序列的长度。'
- en: '**Solution**: We will look at several examples (the following three columns
    represent the integer number, its binary representation, and the length of the
    longest sequence of 1):'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：我们将看几个例子（以下三列代表整数，其二进制表示和最长1序列的长度）：'
- en: '![Figure 9.22 Longest sequence of 1'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.22 最长1序列'
- en: '](img/coding_challenge_13,_1_(Fig_9.22).jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_challenge_13,_1_(Fig_9.22).jpg)'
- en: Figure 9.22 – Three examples
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.22 - 三个例子
- en: 'The solution to this problem is quite easy to implement if we know that *n*
    & 1 = 1 if the LSB of *n* is 1 and *n* & 0 = 0 if the LSB of *n* is 0\. Let''s
    focus on the first example, 67534 (100000**11111**001110). Here, we do the following:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道*n* & 1 = 1，如果*n*的LSB为1，*n* & 0 = 0，如果*n*的LSB为0，那么这个问题的解决方案就很容易实现。让我们专注于第一个例子，67534（100000**11111**001110）。在这里，我们做了以下事情：
- en: Initialize the longest sequence = 0.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化最长序列= 0。
- en: Apply AND[&]:100000**11111**001110 & 1 = 0, longest sequence = 0.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用AND[&]：100000**11111**001110 & 1 = 0，最长序列= 0。
- en: Right shift and apply AND[&]:100000**11111**00111 & 1 = 1, longest sequence
    = 1.
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111**00111 & 1 = 1，最长序列 = 1。
- en: Right shift and apply AND[&]:100000**11111**0011 & 1 = 1, longest sequence =
    2.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111**0011 & 1 = 1，最长序列 = 2。
- en: Right shift and apply AND[&]:100000**11111**001 & 1 = 1, longest sequence =
    3.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111**001 & 1 = 1，最长序列 = 3。
- en: Right shift and apply AND[&]:100000**11111**00 & 1 = 0, longest sequence = 0
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111**00 & 1 = 0，最长序列 = 0
- en: Right shift and apply AND[&]:100000**11111**0 & 1 = 0, longest sequence = 0.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111**0 & 1 = 0，最长序列 = 0。
- en: Right shift and apply AND[&]:100000**11111** & 1 = 1, longest sequence = 1.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11111** & 1 = 1，最长序列 = 1。
- en: Right shift and apply AND[&]:100000**1111** & 1 = 1, longest sequence = 2.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**1111** & 1 = 1，最长序列 = 2。
- en: Right shift and apply AND[&]:100000**111** & 1 = 1, longest sequence = 3.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**111** & 1 = 1，最长序列 = 3。
- en: Right shift and apply AND[&]:100000**11** & 1 = 1, longest sequence = 4.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**11** & 1 = 1，最长序列 = 4。
- en: Right shift and apply AND[&]:100000**1** & 1 = 1, longest sequence = 5.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000**1** & 1 = 1，最长序列 = 5。
- en: Right shift and apply AND[&]:100000 & 1 = 0, longest sequence = 0.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右移并应用AND[&]：100000 & 1 = 0，最长序列 = 0。
- en: 'So, as long as we don''t have any 0s interleaved in the longest sequence of
    1, we can implement the preceding approach. However, this approach does not work
    for the third case, 339809 (10100**101111011**00001). Here, we need to do some
    additional checks; otherwise, the longest sequence will have a length equal to
    4\. But since 101 can be treated as 111, the correct answer is 9\. This means
    that when we have *n* & 1 = 0, we must perform the following checks (mainly, we
    check that the current bit of 0 is guarded by two bits of 1 as 101):'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只要在最长的1序列中没有0交错，我们就可以实现前面的方法。然而，这种方法对于第三种情况339809（10100**101111011**00001）不起作用。在这种情况下，我们需要进行一些额外的检查；否则，最长序列的长度将等于4。但由于101可以被视为111，正确的答案是9。这意味着当*n*
    & 1 = 0时，我们必须执行以下检查（主要是检查0的当前位是否由101这样的两位1保护）：
- en: Check that the next bit is 1 or 0, (*n* & 2) == 1 or 0
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查下一个位是否为1或0，(*n* & 2) == 1或0
- en: If the next bit is 1, then check whether the previous bit was 1
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果下一个位是1，则检查前一个位是否为1
- en: 'We can put this into code as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这写成代码如下：
- en: '[PRE12]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is called *LongestSequence*.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用称为*LongestSequence*。
- en: Coding challenge 14 – Next and previous numbers
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战14 - 下一个和上一个数字
- en: '**Adobe**, **Microsoft**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**Microsoft**'
- en: '**Problem**: Consider a 32-bit integer, *n*. Write a snippet of code that returns
    the next largest number that contains exactly the same number of 1 bits.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个32位整数*n*。编写一段代码，返回包含完全相同数量的1位的下一个最大数字。'
- en: '**Solution**: Let''s consider that *n*=124344 (11110010110111000). To obtain
    another number with the same number of 1 bits, we have to flip a bit of 1 to turn
    it into 0 and another bit of 0 to turn it into 1\. The resulting number will be
    different from the given one and will contain the same number of 1 bits. Now,
    if we want this number to be bigger than the given one, then the bit that was
    flipped from 0 to 1 should be at the left of the bit that was flipped from 1 to
    0\. In other words, having two bit positions, *i* and *j*, and flipping the bit
    at position *i* from 1 to 0 and the bit at position *j* from 0 to 1, this will
    result in the new number being smaller than the given number if *i > j*, while
    bigger if *i < j*, respectively.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑*n*=124344（11110010110111000）。为了获得另一个具有相同数量的1位的数字，我们必须翻转一个1位以将其变为0，并翻转另一个0位以将其变为1。得到的数字将与给定的数字不同，并且包含相同数量的1位。现在，如果我们希望这个数字比给定的数字大，那么从0翻转为1的位应该在从1翻转为0的位的左边。换句话说，有两个位位置*i*和*j*，并且翻转位*i*从1到0和位*j*从0到1，如果*i
    > j*，那么新数字将比给定数字小，而如果*i < j*，则新数字将比给定数字大。'
- en: 'This means that we must find the first bit of 0 that doesn''t contain only
    zeros on its right (in other words, the first bit of non-trailing zero). This
    way, if we flip this bit from 0 to 1, then we know that there is at least one
    bit of 1 in the right of this bit that can be flipped from 1 to 0\. This means
    that we obtain a bigger number with the same number of 1 bits. The following diagram
    shows these numbers in pictorial form:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须找到第一个不仅包含右侧全为0的位的0位（换句话说，第一个非尾随零位）。这样，如果我们将这一位从0翻转为1，那么我们知道在这一位的右侧至少有一位1可以从1翻转为0。这意味着我们可以获得一个具有相同数量的1位的更大数字。以下图表以图形形式显示了这些数字：
- en: '![Figure 9.23 – The non-trailing zero'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.23 - 非尾随零'
- en: '](img/Figure_9.23_B15403.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.23_B15403.jpg)'
- en: Figure 9.23 – The non-trailing zero
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.23 - 非尾随零
- en: 'So, for our number, the first non-trailing zero is at bit 6\. If we flip this
    bit from 0 to 1, then the resulting number is bigger than the given number. But
    now, we must choose a bit, from the right of this bit, that will flip from 1 to
    0\. Basically, we must choose between the bits from positions 3, 4, and 5\. However,
    is this the proper logic? Remember that we must return the next largest number,
    NOT any number larger than the given one. Flipping the bit at position 5 is better
    than flipping the bit from position 3 or 4, but this is not the next largest number.
    Check out the following relationships (the subscript is the decimal value corresponding
    to the binary representation):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于我们的数字，第一个非尾随零位于第6位。如果我们将这一位从0翻转为1，那么得到的数字将大于给定的数字。但现在，我们必须选择一个位，从这个位的右边开始，将其从1翻转为0。基本上，我们必须在位置3、4和5之间进行选择。然而，这是正确的逻辑吗？请记住，我们必须返回比给定数字大的下一个数字，而不是任何比给定数字大的数字。翻转位置5的位比翻转位置3或4的位更好，但这不是下一个最大的数字。查看以下关系（下标是二进制表示对应的十进制值）：
- en: '![Figure 9.24 Decimal value corresponding to the binary representation'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.24 二进制表示对应的十进制值]'
- en: '](img/coding_challenge_14_(Fig_9.24).jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_challenge_14_(Fig_9.24).jpg)'
- en: Figure 9.24 – Several relationships
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.24 - 几个关系
- en: 'So far, we can conclude that 1111001011**10**11000124376 looks like the proper
    choice. However, we should also take note of the following:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以得出结论，1111001011**10**11000124376看起来是正确的选择。但是，我们还应该注意以下内容：
- en: 1111001011**10**11000124376 > 11110010111000011124355
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 1111001011**10**11000124376 > 11110010111000011124355
- en: So, the next largest number is obtained if we count the number of bits of 1
    between positions 6 (exclusive) and 0 (let's denote it with *k*=3), clear all
    the bits between positions 6 (exclusive) and 0 (set them to 0), and set *k*-1
    bits to 1 between positions *k*-1 and 0.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下一个最大的数字是如果我们计算位置6（不包括）和0之间的1位数（让我们用*k*=3），清除位置6（不包括）和0之间的所有位（将它们设置为0），并在位置*k*-1和0之间设置*k*-1位为1。
- en: 'OK; so far, so good! Now, let''s put this algorithm into code. First, we need
    to find the position of the first bit of non-trailing zero. This means we need
    to sum the count of trailing zeros with the count of 1s until we get the first
    0\. Counting the trailing zeros can be done as follows (we are working on a copy
    of *n* since we don''t want to shift the bits of the given number):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，到目前为止一切顺利！现在，让我们将这个算法编写成代码。首先，我们需要找到第一个非尾随零位的位置。这意味着我们需要将尾随零的计数与我们得到第一个0之前的1的计数相加。计算尾随零可以按以下方式进行（我们正在处理*n*的副本，因为我们不想移动给定数字的位）：
- en: '[PRE13]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Counting the 1s until the first 0 can be done like so:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 计算直到第一个0的1可以这样做：
- en: '[PRE14]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, `marker = zeros + ones` gives us the searched position. Next, we flip
    the bit from this position from 0 to 1 and clear all the bits between this position
    (exclusive) and 0:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`marker = zeros + ones`给出了我们搜索的位置。接下来，我们翻转从此位置到0的位，从0清除所有位：
- en: '[PRE15]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our case, `marker`=6\. The effect of this line produces the following output:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`marker`=6。这行的效果产生以下输出：
- en: '![Figure 9.25 – Output (1)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.25 - 输出（1）'
- en: '](img/coding_chh_14,_2_(Fig_9.25).jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_chh_14,_2_(Fig_9.25).jpg)'
- en: Figure 9.25 – Output (1)
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.25 - 输出（1）
- en: '[PRE16]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Figure 9.26 – Output (2)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.26 - 输出（2）'
- en: '](img/coding_chh_14,3_(Fig_9.26).jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_chh_14,3_(Fig_9.26).jpg)'
- en: Figure 9.26 – Output (2)
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.26 - 输出（2）
- en: 'Finally, we set the bits between (`ones` - 1) and 0 to 1:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将位设置为1，介于（`ones` - 1）和0之间：
- en: '[PRE17]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our case, `ones`=3\. The effect of this line produces the following output:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`ones`=3。这行的效果产生以下输出：
- en: '![Figure 9.27 Output (3)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.27 输出（3）'
- en: '](img/coding_ch_14,_4_(Fig_9.27).jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_14,_4_(Fig_9.27).jpg)'
- en: Figure 9.27 – Output (3)
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.27 - 输出（3）
- en: 'So, the final result is 11110010111000011, which is 124355\. So, the final
    method looks as follows:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终结果是11110010111000011，即124355。因此，最终的方法如下所示：
- en: '[PRE18]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The complete application is called *NextNumber*. It also contains a method that
    returns the next smallest number that contains exactly the same number of 1 bits.
    Take up the challenge and try to provide a solution by yourself. When you're done,
    just confront your solution with the one from the bundled code. As a hint, you
    will need the number of trailing 1s (let's denote this with *k*) and the number
    of 0s immediately to the left of the trailing 1s until you reach the first 1\.
    Summing up these values will give you the position of the bit that should be flipped
    from 1 to 0\. Next, clear up all the bits to the right of this position and set
    (*k* + 1) bits to 1 immediately to the right of this position.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*NextNumber*。它还包含一个返回包含完全相同数量的1位的下一个最小数字的方法。接受挑战，尝试自己提供解决方案。完成后，只需将您的解决方案与捆绑代码中的解决方案进行对比。作为提示，您将需要尾随1的数量（让我们用*k*表示）和直到达到第一个1的尾随1左侧的0的数量。总结这些值将给出应该从1翻转为0的位的位置。接下来，清除此位置右侧的所有位，并在此位置右侧立即设置（*k*
    + 1）位为1。
- en: Coding challenge 15 – Conversion
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战15 - 转换
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider two positive 32-bit integers, *q* and *p*. Write a snippet
    of code that counts the number of bits that we should flip in *q* in order to
    convert it into *p*.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*。编写一小段代码，以便计算我们应该在*q*中翻转的位数，以便将其转换为*p*。'
- en: '**Solution**: The solution to this problem becomes clear if we observe that
    the XOR[^] operator only returns 1 when the operands are different. Let''s consider
    *q* = 290932 (1000111000001110100) and *p* = 352345 (1010110000001011001). Let''s
    apply the XOR[^] operator:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：如果我们观察到XOR[^]运算符只在操作数不同时返回1，那么这个问题的解决方案就变得清晰了。让我们考虑*q* = 290932（1000111000001110100）和*p*
    = 352345（1010110000001011001）。让我们应用XOR[^]运算符：'
- en: '![Figure 9.28 Conversion'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.28 转换'
- en: '](img/coding_ch_15,_1_(Fig_9.28).jpg)'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_15,_1_(Fig_9.28).jpg)'
- en: Figure 9.28 – Conversion
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.28 - 转换
- en: 'In other words, if we denote *q* ^ *p* with *xor* (*xor* = *q* ^ *p*), then
    all we have to do is count the number of bits of 1 in *xor* (in our example, we
    have six of 1). This can be done using the AND[&] operator, which only returns
    1 for 1 & 1 = 1, so we can count *xor* & 1 for each bit in *xor*. After each comparison,
    we right shift *xor* by one position. The code speaks for itself:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们用*xor*（*xor* = *q* ^ *p*）表示*q* ^ *p*，那么我们所要做的就是计算*xor*中1的位数（在我们的示例中，我们有6个1）。这可以使用AND[&]运算符来完成，该运算符仅在1
    & 1 = 1时返回1，因此我们可以为*xor*中的每个位计算*xor* & 1。在每次比较后，我们将*xor*右移一位。代码说明了这一点：
- en: '[PRE19]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The complete application is called *Conversion*.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*Conversion*。
- en: Coding challenge 16 – Maximizing expressions
  id: totrans-388
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战16 - 最大化表达式
- en: '**Problem**: Consider two positive 32-bit integers, *q* and *p*, where *q≠
    p.* What is the relationship between *q* and *p* that maximizes the expression
    (*q* AND *s*) * (*p* AND *s*), where AND is the logical operator [&]?'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个正的32位整数*q*和*p*，其中*q≠ p*。最大化表达式（*q* AND *s*）*（*p* AND *s*）的*q*和*p*之间的关系是什么，其中AND是逻辑运算符[&]？'
- en: '**Solution**: This is the kind of problem that sounds hard but is extremely
    simple. Let''s start with a simple *a * b*. When is *a * b* at its maximum? Well,
    let''s consider that *b* = 4\. When is *a ** 4 at its maximum? Let''s write some
    test cases:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：这是一种听起来很难但实际上非常简单的问题。让我们从一个简单的*a * b*开始。*a * b*何时达到最大值？好吧，让我们考虑*b*
    = 4。*a ** 4何时达到最大值？让我们写一些测试案例：'
- en: '*a* = 1, 1 * 4 = 4'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = 1, 1 * 4 = 4'
- en: '*a* = 2, 2 * 4 = 8'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = 2, 2 * 4 = 8'
- en: '*a* = 3, 3 * 4 = 12'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = 3, 3 * 4 = 12'
- en: '*a* = 4, 4 * 4 = 16'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = 4, 4 * 4 = 16'
- en: So, when *a = b*, we have reached the maximum value, 16\. However, *a* can be
    5 and 5 * 4 = 20 > 16\. This is correct, but this means that *b* can be 5 as well,
    so 5 * 5 =, 25 > 20\. This is far away from a mathematical demonstration, but
    we can notice that *a * b* is at its maximum if *a = b*.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当*a = b*时，我们达到了最大值16。然而，*a*可以是5，5 * 4 = 20 > 16。这是正确的，但这意味着*b*也可以是5，所以5 *
    5 = 25 > 20。这远远不是数学证明，但我们可以注意到如果*a = b*，那么*a * b*达到最大值。
- en: 'For those interested in the mathematical demonstration, let''s say that we
    have the following:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对数学证明感兴趣的人，让我们假设我们有以下内容：
- en: '![Figure 9.29 Maximizing expressions (1)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.29 最大化表达式（1）'
- en: '](img/Figure_9.29_B15403_(2).jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.29_B15403_(2).jpg)'
- en: Figure 9.29 – Maximizing expressions (1)
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.29 - 最大化表达式（1）
- en: 'This means that we have the following:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有以下内容：
- en: '![Figure 9.30 Maximizing expressions (2)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.30 最大化表达式（2）'
- en: '](img/Figure_9.30_B15403_(2).jpg)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.30_B15403_(2).jpg)'
- en: Figure 9.30 – Maximizing expressions (2)
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.30 - 最大化表达式（2）
- en: 'Furthermore, this means that we have the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这意味着我们有以下内容：
- en: '![Figure 9.31 Maximizing expressions (3)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.31 最大化表达式（3）'
- en: '](img/coding_ch_16_(Fig_9.31).jpg)'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_16_(Fig_9.31).jpg)'
- en: Figure 9.31 – Maximizing expressions (3)
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.31 - 最大化表达式（3）
- en: Now, if we say that *a * b* is the maximum when *a = b*, then let's denote *a*
    = (*q* AND *s*) and *b* = (*p* AND *s*). So, (*q* AND *s*) * (*p* AND *s*) is
    at its maximum when (*q* AND *s*) = (*p* AND *s*).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们说当*a = b*时，*a * b*是最大的，那么让我们表示*a* =（*q* AND *s*）和*b* =（*p* AND *s*）。因此，当（*q*
    AND *s*）=（*p* AND *s*）时，（*q* AND *s*）*（*p* AND *s*）是最大的。
- en: 'Let''s consider that *q* = 822 (1100110110) and *p* = 663 (1010010111). The
    LSB of *q* is 0, while the LSB of *p* is 1, so we can write the following:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设*q* = 822（1100110110）和*p* = 663（1010010111）。 *q*的LSB为0，而*p*的LSB为1，因此我们可以写成以下形式：
- en: (1 AND *s*) = (0 AND *s*) → *s* = 0 → (1 & 0) = (0 & 0) = 0
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: （1 AND *s*）=（0 AND *s*）→ *s* = 0 →（1 & 0）=（0 & 0）= 0
- en: 'If we right shift *q* and *p* by 1 position, then we find that the LSB of *q*
    is 1 and that the LSB of *p* is 1:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将*q*和*p*向右移动1个位置，那么我们会发现*q*的LSB为1，*p*的LSB也为1：
- en: '![Figure 9.32 – Right shifting q and p by 1 position'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.32 - 将q和p向右移动1个位置'
- en: '](img/Fig_9.32.jpg)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Fig_9.32.jpg)'
- en: Figure 9.32 – Right shifting q and p by 1 position
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.32 - 将q和p向右移动1个位置
- en: 'Here, we have two more cases that can be intuited as follows:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有另外两种情况，可以直观地解释如下：
- en: '![Figure 9.33 – Two cases'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.33 - 两种情况'
- en: '](img/Fig_9.,33.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Fig_9.,33.jpg)'
- en: Figure 9.33 – Two cases
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.33 - 两种情况
- en: 'Here, we can see that the answer to our problem is *q* & *p = s*. Let''s see
    this at work:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们问题的答案是*q* & *p* = *s*。让我们看看这是如何工作的：
- en: '![Figure 9.34 Answer'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.34 答案'
- en: '](img/coding_ch_16,_2_(Fig_9.34).jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/coding_ch_16,_2_(Fig_9.34).jpg)'
- en: Figure 9.34 – Answer
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.34 - 答案
- en: The answer is 1000010110, which is 534\. This means that (822 AND 534) = (663
    AND 534).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是1000010110，即534。这意味着（822 AND 534）=（663 AND 534）。
- en: Coding challenge 17 – Swapping odd and even bits
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战17 - 交换奇数和偶数位
- en: '**Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**, **Microsoft**, **Flipkart**'
- en: '**Problem**: Consider a positive 32-bit integer, *n*. Write a snippet of code
    that swaps the odd and even bits of this integer.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个正的32位整数*n*。编写一小段代码，交换这个整数的奇数位和偶数位。'
- en: '**Solution**: Let''s consider that *n* = 663 (1010010111). If we perform the
    swap manually, then we should obtain 0101101011\. We can do this in two steps:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设*n* = 663（1010010111）。如果我们手动进行交换，那么我们应该得到0101101011。我们可以分两步完成：'
- en: We take the odd bits and shift them to the right by one position.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们取奇数位并将它们向右移动一位。
- en: We take the even bits and shift them to the left by one position.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们取偶数位并将它们向左移动一位。
- en: But how we can do this?
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们如何做到这一点？
- en: 'We can take the odd bits via the AND[&] operator and a bit-mask that contains
    bits of 1 in the odd positions: 10101010101010101010101010101010\. Let''s see
    this in action:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过AND[&]运算符和包含奇数位置上的1的位掩码来获取奇数位：10101010101010101010101010101010。让我们看看这个过程：
- en: '![Figure 9.35 Swapping odd and even bits (1)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.35 交换奇数和偶数位（1）'
- en: '](img/Figure_9.35_B15403_(2).jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.35_B15403_(2).jpg)'
- en: Figure 9.35 – Swapping odd and even bits (1)
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.35 - 交换奇数和偶数位（1）
- en: The result reveals that 1010010111 contains the odd bits of 1 at positions 1,
    7, and 9\. Next, we shift the result, 1010000010, to the right by one position.
    This results in 0101000001.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示1010010111包含1的奇数位在位置1、7和9。接下来，我们将结果1010000010向右移动一位。这将得到0101000001。
- en: 'We can take the even bits via the AND[&] operator and a bit-mask that contains
    bits of 1 in the even positions: 1010101010101010101010101010101\. Let''s see
    this in action:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过AND[&]运算符和包含奇数位置上的1的位掩码来获取偶数位：1010101010101010101010101010101。让我们看看这个过程：
- en: '![Figure 9.36 swapping odd and even bits (2)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.36 交换奇数和偶数位（2）'
- en: '](img/Figure_9.36_B15403_(2).jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.36_B15403_(2).jpg)'
- en: Figure 9.36 – Swapping odd and even bits (2)
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.36 - 交换奇数和偶数位（2）
- en: The result reveals that 1010010111 contains the even bits of 1 at positions
    0, 2, and 4\. Next, we shift the result, 0000010101, to the left by one position.
    This results in 0000101010.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示1010010111包含0、2和4位置上的1的偶数位。接下来，我们将结果0000010101向左移动一位。这将得到0000101010。
- en: 'To obtain the final result, we just need to apply the OR[|] operator to these
    two results:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得最终结果，我们只需要将这两个结果应用OR[|]运算符：
- en: '![Figure 9.37 Final result'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.37 最终结果'
- en: '](img/Figure_9.37_B15403_(2).jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.37_B15403_(2).jpg)'
- en: Figure 9.37 – Final result
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.37 - 最终结果
- en: 'The final result is 0101101011\. The implementation follows these steps *ad
    litteram*, so this is straightforward:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是0101101011。实现遵循这些步骤*ad litteram*，因此这是直接的：
- en: '[PRE20]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The complete application is called *SwapOddEven*.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*SwapOddEven*。
- en: Coding challenge 18 – Rotating bits
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战18 - 旋转位
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
- en: '**Problem**: Consider a positive 32-bit integer, *n*. Write a snippet of code
    that rotates *k* bits to the left or the right. By rotation, we understand that
    the bits that fall off at one end of the binary representations are sent to the
    other end. So, in the left rotation, the bits that fall off the left end are sent
    to the right end, while in the right rotation, the bits that fall off the right
    end are sent to the left end.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个正的32位整数*n*。编写一小段代码，将*k*位向左或向右旋转。通过旋转，我们理解二进制表示的一端掉落的位被发送到另一端。因此，在左旋转中，从左端掉落的位被发送到右端，而在右旋转中，从右端掉落的位被发送到左端。'
- en: '**Solution**: Let''s focus on the left rotation (typically, the right rotation
    solution is a mirrored left rotation solution). We already know that by shifting
    *k* bits to the left, we move the bits to the left and the empty spots are padded
    with zeros. However, in place of these zeros, we have to put the bits that fell
    off the left end.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们专注于左旋转（通常，右旋转解决方案是左旋转解决方案的镜像）。我们已经知道，通过将*k*位向左移动，我们将位向左移动，空位填充为零。然而，在这些零的位置，我们必须放置从左端掉落的位。'
- en: 'Let''s consider that *n*= 423099897 (00011001001101111111110111111001) and
    *k*=10, so we rotate 10 bits to the left. The following diagram highlights the
    falling bits and the final result:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设*n*= 423099897（00011001001101111111110111111001）和*k*=10，所以我们向左旋转10位。下图突出显示了掉落的位和最终结果：
- en: '![Figure 9.38– Left rotating bits'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.38– 左旋转位'
- en: '](img/Figure_9.38_B15403_(2).jpg)'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.38_B15403_(2).jpg)'
- en: Figure 9.38 – Left rotating bits
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.38 - 左旋转位
- en: The preceding diagram gives us the solution. If we look carefully at points
    b) and c), we will see that the fallen bits appear in the final result. This result
    can be obtained by right shifting the fallen bits by 32-10 = 22 positions.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表给出了解决方案。如果我们仔细观察b)和c)点，我们会发现掉落的位出现在最终结果中。这个结果可以通过将掉落的位右移32-10 = 22位来获得。
- en: 'So, if we left shift *n* by 10 positions, we obtain a binary representation
    padded with zeros on the right-hand side (as in point b) of the preceding diagram
    or the dividend of the next division). If we right shift *n* by 22 positions,
    we obtain a binary representation padded with zeros on the left-hand side (as
    the divisor of the next division). At this point, the OR[|] operator enters the
    scene, as shown in the following example:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将*n*左移10位，我们将得到一个二进制表示，在右侧填充了零（如前面图表的b点）或下一个除法的被除数）。如果我们将*n*右移22位，我们将得到一个在左侧填充了零的二进制表示（作为下一个除法的除数）。此时，OR[|]运算符进入场景，如下例所示：
- en: '![Figure 9.39 OR [|] Operator'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.39 OR [|] 运算符'
- en: '](img/Figure_9.39_B15403.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.39_B15403.jpg)'
- en: Figure 9.39 – Applying the OR[|] operator
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.39 - 应用OR[|]运算符
- en: 'The final result of the left rotation is 11011111111101111110010001100100\.
    Now, we can easily put this into code, as follows:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 左旋转的最终结果是11011111111101111110010001100100。现在，我们可以轻松地将其转换为代码，如下所示：
- en: '[PRE21]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, challenge yourself by implementing the right rotation.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，挑战自己，实现右旋转。
- en: 'For the right rotation, the code will look as follows (you should be able to
    follow this solution with no issues):'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 对于右旋转，代码将如下所示（你应该能够毫无问题地跟随这个解决方案）：
- en: '[PRE22]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The complete application is called *RotateBits*.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*RotateBits*。
- en: Coding challenge 19 – Calculating numbers
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战19 - 计算数字
- en: '**Problem**: Consider two positions, *i* and *j* (*j > i*), representing the
    positions of two bits in a binary representation. Write a snippet of code that
    returns a 32-bit integer containing 1s (set) between *i* (inclusive) and *j* (inclusive)
    and where the rest of the bits are 0s (unset).'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑两个位置，*i*和*j*（*j > i*），表示二进制表示中两个位的位置。编写一小段代码，返回一个32位整数，其中包含1s（设置）在*i*（包括）和*j*（包括）之间，其余位为0s（未设置）。'
- en: '**Solution**: Let''s consider that *i*=3 and *j*=7\. We know that the required
    32-bit integer is 248, or, in binary representation, 11111000 (or with all 0s,
    00000000000000000000000011111000).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们假设*i*=3和*j*=7。我们知道所需的32位整数是248，或者用二进制表示是11111000（或者全部为0的00000000000000000000000011111000）。'
- en: 'If you paid attention to *Coding challenge 8 – Subtracting binaries on paper,*
    then you should know that 0 minus 1 is an operation that can be accomplished by
    *borrowing* a bit from the left of the current bit. The *borrowing* technique
    is propagated to the left until a bit of 1 is found. Moreover, if we remember
    that 1 minus 0 is 1, then we can write the following subtraction:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你注意到了*编码挑战8 - 纸上减法*，那么你应该知道0减1是一个可以通过从当前位的左边*借位*来完成的操作。*借位*技术向左传播，直到找到一个1位。此外，如果我们记得1减0是1，那么我们可以写出以下减法：
- en: '![Figure 9.40 Subtraction'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.40 减法'
- en: '](img/Figure_9.40_B15403.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.40_B15403.jpg)'
- en: Figure 9.40 – Subtraction
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.40 - 减法
- en: 'Look at the result of this subtraction. The 1s are exactly between positions
    *i*=3 (inclusive) and *j*=7 (inclusive). This is exactly the number that we are
    looking for: 248\. The dividend and the divisor are obtained by left shifting
    1 by(*j*+1) positions and by *i* positions, respectively.'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 观察这个减法的结果。1s恰好位于位置*i*=3（包括）和*j*=7（包括）之间。这正是我们要找的数字：248。被除数和除数分别通过将1左移(*j*+1)位和*i*位来获得。
- en: 'With these statements in place, it is very easy to put them into code:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些陈述，很容易将它们转换为代码：
- en: '[PRE23]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The complete application is called *NumberWithOneInLR*.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*NumberWithOneInLR*。
- en: Coding challenge 20 – Unique elements
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战20 - 独特元素
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider a given array of integers, *arr*. Every element from
    this array occurs exactly three times, except for one element, which occurs only
    once. This makes it unique. Write a snippet of code that finds this unique element
    in O(n) complexity time and O(1) extra space.'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个给定的整数数组*arr*。除了一个元素只出现一次外，数组中的每个元素都恰好出现三次。这使得它是唯一的。编写一小段代码，在O(n)复杂度时间和O(1)额外空间中找到这个唯一的元素。'
- en: '**Solution**: Let''s consider that the given array is *arr*={4, 4, 3, 1, 7,
    7, 7, 1, 1, 4}, so 3 is the unique element. If we write the binary representation
    of these numbers, we obtain the following: 100, 100, 011, 001, 111, 111, 111,
    001, 001, 100\. Now, let''s sum up the bits at the same positions and check whether
    the resulting sums are multiples of 3, as follows:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：假设给定的数组是*arr*={4, 4, 3, 1, 7, 7, 7, 1, 1, 4}，所以3是唯一的元素。如果我们写出这些数字的二进制表示，我们得到以下结果：100，100，011，001，111，111，111，001，001，100。现在，让我们将相同位置的位相加，并检查结果的和是否是3的倍数，如下所示：'
- en: Sum of first bits % 3 = 0+0+1+1+1+1+1+1+1+0 = 7 % 3 = 1
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一位的和 % 3 = 0+0+1+1+1+1+1+1+1+0 = 7 % 3 = 1
- en: Sum of second bits % 3 = 0+0+1+0+1+1+1+0+0+0 = 4 % 3 = 1
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二位的和 % 3 = 0+0+1+0+1+1+1+0+0+0 = 4 % 3 = 1
- en: Sum of third bits % 3 = 1+1+0+0+1+1+1+0+0+1 = 6 % 3 = 0
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三位的和 % 3 = 1+1+0+0+1+1+1+0+0+1 = 6 % 3 = 0
- en: The unique number is 011 = 3.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的数字是011 = 3。
- en: 'Let''s take a look at another example. This time, *arr*={51, 14, 14, 51, 98,
    7, 14, 98, 51, 98}, so 7 is the unique element. Let''s apply the same logic we
    used previously to the binary representation: 110011, 1110, 1110, 110011, 1100010,
    111, 1110, 1100010, 110011, 1100010\. This time, let''s use a diagram since this
    makes things clearer:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。这次，*arr*={51, 14, 14, 51, 98, 7, 14, 98, 51, 98}，所以7是唯一的元素。让我们将之前使用的逻辑应用于二进制表示：110011，1110，1110，110011，1100010，111，1110，1100010，110011，1100010。这次，让我们使用图表，因为这样更清晰：
- en: '![Figure 9.41 – Finding the unique element in the given array'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.41 – 找到给定数组中的唯一元素'
- en: '](img/Figure_9.41_B15403.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.41_B15403.jpg)'
- en: Figure 9.41 – Finding the unique element in the given array
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.41 – 找到给定数组中的唯一元素
- en: 'So, based on these two examples, we can elaborate the following algorithm:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于这两个例子，我们可以详细说明以下算法：
- en: Sum up the bits on the same positions.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的位置上求和位。
- en: For each *sum*, compute the modulus 3.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个*sum*，计算模3。
- en: If *sum* % 3 = 0 (*sum* is a multiple of 3), this means that the bit is set
    in the elements that appear thrice among the given elements.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*sum* % 3 = 0（*sum*是3的倍数），这意味着该位在给定元素中出现三次的元素中被设置。
- en: If *sum* % 3 ! = 0 (*sum* is not a multiple of 3), this means that the bit is
    set in the element that appears once (**but it is not sure if that bit is unset
    or set in the elements that appear thrice**).
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*sum* % 3 != 0（*sum*不是3的倍数），这意味着该位在只出现一次的元素中被设置（**但不能确定该位在出现三次的元素中是未设置还是设置**）。
- en: We have to repeat *steps 1*, *2*, and *3* for all the given elements and for
    all the positions of the bits. By doing this, we will get the element that appears
    only once, exactly as you saw in the preceding diagram.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须对所有给定的元素和所有位的位置重复*步骤1*、*2*和*3*。通过这样做，我们将得到只出现一次的元素，就像你在前面的图表中看到的那样。
- en: 'The code for this is as follows:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下：
- en: '[PRE24]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This was one approach to solving this problem. Another approach starts from
    the fact that the XOR[^] operator, when applied to the same number twice, returns
    0\. Moreover, the XOR[^] operator is associative (gives the same result, regardless
    of grouping: 1 ^ 1 ^ 2 ^ 2 = 1 ^ 2 ^ 1 ^ 2 = 0) and commutative (independent of
    order: 1 ^ 2 = 2 ^ 1). However, if we XOR[^] the same number three times, then
    the result will be the same number, so using XOR[^] on all the numbers will not
    be helpful here. However, we can employ the following algorithm:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决这个问题的一种方法。另一种方法是从异或[^]运算符的事实开始，当应用于相同的数字两次时，返回0。此外，异或[^]运算符是可结合的（给出相同的结果，无论分组方式：1
    ^ 1 ^ 2 ^ 2 = 1 ^ 2 ^ 1 ^ 2 = 0）和可交换的（与顺序无关：1 ^ 2 = 2 ^ 1）。然而，如果我们将相同的数字异或[^]三次，那么结果将是相同的数字，因此在所有数字上使用异或[^]在这里将没有帮助。然而，我们可以采用以下算法：
- en: Use a variable to note that the variable appeared for the first time.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个变量来记录该变量第一次出现。
- en: For each new element, put the XOR[^] of it in a variable, `oneAppearance`.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个新元素，将其异或[^]放入一个变量`oneAppearance`中。
- en: If the element appears a second time, then it will be removed from `oneAppearance`
    and we put the XOR[^] of it in another variable, `twoAppearances`.
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素出现第二次，那么它将从`oneAppearance`中移除，并将其异或[^]放入另一个变量`twoAppearances`中。
- en: If the element appears a third time, then it will be removed from `oneAppearance`
    and `twoAppearances` . The `oneAppearance` and `twoAppearances` variables become
    0 and we start looking for a new element.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果元素出现第三次，那么它将从`oneAppearance`和`twoAppearances`中移除。`oneAppearance`和`twoAppearances`变量变为0，我们开始寻找一个新元素。
- en: For all the elements that appear three times, the `oneAppearance` and `twoAppearances`
    variables will be 0\. On the other hand, for the element that appears only once,
    the `oneAppearance` variable will be set with that value.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有出现三次的元素，`oneAppearance`和`twoAppearances`变量将为0。另一方面，对于只出现一次的元素，`oneAppearance`变量将被设置为该值。
- en: 'In terms of code, this looks as follows:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，看起来是这样的：
- en: '[PRE25]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The runtime of this code is O(n) with O(1) extra time. The complete application
    is called *OnceTwiceThrice*.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，额外时间是O(1)。完整的应用程序称为*OnceTwiceThrice*。
- en: Coding challenge 21 – Finding duplicates
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战21 – 查找重复项
- en: '**Amazon**, **Google**, **Adobe**, **Microsoft**, **Flipkart**'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**，**微软**，**Flipkart**'
- en: '**Problem**: Consider that you''re given an array of integers ranging from
    1 to *n*, where *n* can be, at most, 32,000\. The array may contain duplicates
    and you don''t know the value of *n*. Write a snippet of code that prints all
    the duplicates from the given array using only 4 kilobytes (KB) of memory.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个整数数组，范围从1到*n*，其中*n*最多可以是32,000。数组可能包含重复项，而且你不知道*n*的值。编写一小段代码，只使用4千字节（KB）的内存，从给定数组中打印出所有重复项。'
- en: '`BitSet` class (this class implements a vector of bits that grows as needed).'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`BitSet`类（这个类实现了一个根据需要增长的位向量）。'
- en: 'With a `BitSet`, we can iterate the given array and, for each traversed element,
    flip the bit from the corresponding index from 0 to 1\. If we attempt to flip
    a bit that is already 1, then we find and print a duplicate. The code for this
    is quite simple:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BitSet`，我们可以遍历给定的数组，并对于每个遍历的元素，将相应索引处的位从0翻转为1。如果我们尝试翻转已经为1的位，那么我们就找到并打印了一个重复项。这段代码非常简单：
- en: '[PRE26]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The complete application is called *FindDuplicates*.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序称为*FindDuplicates*。
- en: Coding challenge 22 – Two non-repeating elements
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战22 - 两个不重复的元素
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider that you''re given an array of integers containing 2*n*+2
    elements. The 2*n* elements are *n* elements repeated once. So, each element in
    2*n* appears twice in the given array. The remaining two elements appear only
    once. Write a snippet of code that finds these two elements.'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：假设你有一个包含2*n*+2个元素的整数数组。2*n*个元素是*n*个元素重复一次。因此，2*n*中的每个元素在给定数组中都出现两次。剩下的两个元素只出现一次。编写一小段代码来找到这两个元素。'
- en: '**Solution**: Let''s consider that the given array is *arr*={2, 7, 1, 5, 9,
    4, 1, 2, 5, 4}. The two numbers that we are looking for are 7 and 9\. These two
    numbers appear only once in the array, while 2, 1, 5, and 4 appear twice.'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：让我们考虑给定的数组是*arr*={2, 7, 1, 5, 9, 4, 1, 2, 5, 4}。我们要找的两个数字是7和9。这两个数字在数组中只出现一次，而2、1、5和4出现两次。'
- en: If we consider the brute-force approach, then it is quite intuitive to iterate
    the array and check the number of occurrences for each element. But the interviewer
    will not be impressed by this solution since its runtime is O(n2).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑蛮力方法，那么迭代数组并检查每个元素的出现次数是很直观的。但是面试官不会对这个解决方案印象深刻，因为它的运行时间是O(n2)。
- en: Another approach consists of sorting the given array. This way, the repeated
    elements are grouped together so that we can count the number of occurrences for
    each group. The group of size 1 represents a non-repeated value. It is good to
    mention this approach during the process of finding a better solution.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是对给定数组进行排序。这样，重复的元素被分组在一起，这样我们可以计算每个组的出现次数。大小为1的组表示一个不重复的值。在找到更好的解决方案的过程中提到这种方法是很好的。
- en: 'A better solution relies on *hashing*. Create a `Map<`*Element*`,` *Count*`>`
    and fill it with elements and the number of occurrences (for example, for our
    data, we will have the following pairs: (2, 2), (7, 1), (1, 2), (5, 2), (9, 1),
    and (4, 2)). Now, traverse the map and locate the elements whose count is 1\.
    It is good to mention this approach during the process of finding a better solution.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案依赖于*哈希*。创建一个`Map<`*Element*`,` *Count*`>`并用元素和出现次数填充它（例如，对于我们的数据，我们将有以下对：(2,
    2)，(7, 1)，(1, 2)，(5, 2)，(9, 1)和(4, 2)）。现在，遍历地图并找到计数为1的元素。在找到更好的解决方案的过程中提到这种方法是很好的。
- en: 'In this chapter, we are dealing with bits, so the best solution should rely
    on bit manipulation. This solution relies on the XOR[^] operator and a tip that
    we mentioned in the *Tips and tricks* section:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们处理位，因此最好的解决方案应该依赖于位操作。这个解决方案依赖于异或[^]运算符和我们在*提示和技巧*部分提到的技巧：
- en: If we XOR[^] a number with itself for an even number of times, then the result
    is as follows 0 (*x* ^ *x* = 0; *x* ^ *x* ^ *x*^ *x* = (*x* ^ *x*) ^ (*x* ^ *x*)
    = 0 ^ 0 = 0)
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们对一个数字进行偶数次的异或[^]，那么结果如下0（*x* ^ *x* = 0；*x* ^ *x* ^ *x*^ *x* = (*x* ^ *x*)
    ^ (*x* ^ *x*) = 0 ^ 0 = 0）
- en: On the other hand, if we apply the XOR[^] operator to two different numbers,
    *p* and *q*, then the result is a number that contains the set of bits (bits of
    1) at the places where *p* and *q* differ. This means that if we apply XOR[^]
    to all the elements in the array (*xor* = *arr*[0]^*arr*[1]^*arr*[2] ^ ... ^ *arr*[*arr.length*-1]),
    then all the repeating elements would nullify each other.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们对两个不同的数字*p*和*q*应用异或[^]运算符，那么结果是一个包含*p*和*q*不同的位置的位（1位）的数字。这意味着如果我们对数组中的所有元素应用异或[^]（*xor*
    = *arr*[0]^*arr*[1]^*arr*[2] ^ ... ^ *arr*[*arr.length*-1]），那么所有重复的元素将互相抵消。
- en: So, if we take any set bit (for example, the rightmost bit) of the result of
    XOR[^] and divide the elements of the array into two sets, then one set will contain
    elements with the same bit set and the other set will contain elements with the
    same bit not set. In other words, we divide the elements into two sets by comparing
    the rightmost set bit of XOR[^] with the bit at the same position in each element.
    By doing so, we will get *p* in one set and *q* in the other set.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们取结果的任何设置位（例如，最右边的位）并将数组的元素分成两组，那么一组将包含具有相同位设置的元素，另一组将包含具有相同位未设置的元素。换句话说，我们通过比较XOR[^]的最右边的设置位与每个元素相同位置的位，将元素分成两组。通过这样做，我们将在一组中得到*p*，在另一组中得到*q*。
- en: Now, if we apply the XOR[^] operator to all the elements in the first set, then
    we will get the first non-repeating element. Doing the same in the other set will
    get the second non-repeating element.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们对第一组中的所有元素应用异或[^]运算符，那么我们将得到第一个不重复的元素。在另一组中做同样的操作将得到第二个不重复的元素。
- en: 'Let''s apply this flow to our data, *arr*={2, 7, 1, 5, 9, 4, 1, 2, 5, 4}. So,
    7 and 9 are the non-repeating values. First, we apply the XOR[^] operator to all
    the numbers:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个流程应用到我们的数据*arr*={2, 7, 1, 5, 9, 4, 1, 2, 5, 4}。所以，7和9是不重复的值。首先，我们对所有数字应用异或[^]运算符：
- en: '*xor* = 2 ^ 7 ^ 1 ^ 5 ^ 9 ^ 4 ^ 1 ^ 2 ^ 5 ^ 4 = 0010 (2) ^ 0111 (7) ^ 0001
    (1) ^ 0101 (5) ^ 1001 (9) ^ 0100 (4) ^ 0001 (1) ^ 0010 (2) ^ 0101 (5) ^ 0100 (4)
    = 1110 = 7 ^ 9 = 0111 & 1001 = 1110 = 14.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*xor* = 2 ^ 7 ^ 1 ^ 5 ^ 9 ^ 4 ^ 1 ^ 2 ^ 5 ^ 4 = 0010（2）^ 0111（7）^ 0001（1）^
    0101（5）^ 1001（9）^ 0100（4）^ 0001（1）^ 0010（2）^ 0101（5）^ 0100（4）= 1110 = 7 ^ 9 =
    0111 & 1001 = 1110 = 14。'
- en: So, 7 ^ 9 ! = 0 if 7 ! = 9\. Hence, there will be at least one set bit (at least
    one bit of 1). We can take any set bit, but it is quite simple to take the rightmost
    bit as *xor* & ~(*xor*-1). So, we have 1110 & ~(1101) = 1110 & 0010 = 0010\. Feel
    free to take any other set bit.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，7 ^ 9！= 0如果7！= 9。因此，至少会有一个设置位（至少一个1位）。我们可以取任何设置位，但是取最右边的位作为*xor* & ~(*xor*-1)相当简单。所以，我们有1110
    & ~(1101) = 1110 & 0010 = 0010。随意选择其他设置位。
- en: So far, we found this set bit (0010) in XOR[^] of these two numbers (7 and 9),
    so this bit must be present in 7 or 9 (in this case, it is present in 7). Next,
    let's divide the elements into two sets by comparing the rightmost set bit of
    XOR[^] with the bit at the same position in each element. We obtain the first
    set, containing the elements {2, 7, 2}, and the second set, containing the elements
    {1, 5, 9, 4, 1, 5, 4}. Since 2, 7, and 2 contain the set bit, they are in the
    first set, while 1, 5, 9, 4, 1, 5, and 4 don't contain the set bit, which means
    they are part of the second set.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在这两个数字（7和9）的XOR[^]中找到了这个设置位（0010），所以这个位必须存在于7或9中（在这种情况下，它存在于7中）。接下来，让我们通过比较XOR[^]的最右边的设置位与每个元素相同位置的位来将元素分成两组。我们得到第一组，包含元素{2,
    7, 2}，和第二组，包含元素{1, 5, 9, 4, 1, 5, 4}。由于2、7和2包含了设置位，它们在第一组中，而1、5、9、4、1、5和4不包含设置位，这意味着它们是第二组的一部分。
- en: With that, we've isolated the first non-repeated element (7) in a set and put
    the second non-repeated element (9) in the other set. Moreover, each repeated
    element will be in the same set of bit representations (for example, {2, 2} will
    always be in the same set).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们隔离了第一个非重复元素（7）在一个集合中，并把第二个非重复元素（9）放在另一个集合中。此外，每个重复的元素都将在相同的位表示的集合中（例如，{2,
    2}将始终在同一个集合中）。
- en: Finally, we apply XOR[^] to each set. So, we have *xor_first_set* = 2 ^ 7 ^
    2 = 010 ^ 111 ^ 010 = 111 = 7 (the first non-repeated element).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们对每个集合应用XOR[^]。因此，我们有*xor_first_set* = 2 ^ 7 ^ 2 = 010 ^ 111 ^ 010 = 111
    = 7（第一个非重复元素）。
- en: 'For the second set, we have:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二组，我们有：
- en: '*xor_second_set* = 1 ^ 5 ^ 9 ^ 4 ^ 1 ^ 5 ^ 4 = 0001 ^ 0101 ^ 1001 ^ 0100 ^
    0001 ^ 0101 ^ 0100 = 1001 = 9 (the second non-repeated element).'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '*xor_second_set* = 1 ^ 5 ^ 9 ^ 4 ^ 1 ^ 5 ^ 4 = 0001 ^ 0101 ^ 1001 ^ 0100 ^
    0001 ^ 0101 ^ 0100 = 1001 = 9（第二个非重复元素）。'
- en: Done!
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！
- en: 'In terms of code, we have the following:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码方面，我们有以下内容：
- en: '[PRE27]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The runtime of this code is O(n) with an O(1) auxiliary space (*n* is the number
    of elements from the given array). The complete application is called *TwoNonRepeating*.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的运行时间是O(n)，辅助空间是O(1)（*n*是给定数组中的元素数）。完整的应用程序称为*TwoNonRepeating*。
- en: Coding challenge 23 – Power set of a set
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战23 - 集合的幂集
- en: '**Amazon**, **Google**, **Adobe**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊**，**谷歌**，**Adobe**'
- en: '**Problem**: Consider a given set, *S*. Write a snippet of code that returns
    the Power Set of *S*. A Power Set, P(*S*), of a set, *S*, is the set of all possible
    subsets of *S*, including the empty set and *S* itself.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个给定的集合*S*。编写一段代码，返回*S*的幂集。一个集合*S*的幂集P(*S*)是*S*的所有可能子集的集合，包括空集和*S*本身。'
- en: '**Solution**: Consider that the given *S* is {*a, b, c*}. If so, the Power
    Set includes {},{*a*}*,* {*b*}*,* {*c*}*,* {*a, b*}*,* {*a, c*}*,* {*a, c*} and
    {*a, b, c*}. Notice that for a set containing three elements, the Power Set contains
    23=8 elements. For a set containing four elements, the Power Set contains 24=16
    elements. Generally speaking, for a set of *n* elements, the Power Set contains
    2n elements.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：考虑给定的*S*是{*a, b, c*}。如果是这样，幂集包括{}，{*a*}，{*b*}，{*c*}，{*a, b*}，{*a,
    c*}，{*a, c*}和{*a, b, c*}。注意，对于包含三个元素的集合，幂集包含23=8个元素。对于包含四个元素的集合，幂集包含24=16个元素。一般来说，对于包含*n*个元素的集合，幂集包含2n个元素。'
- en: 'Now, if we generate all the binary numbers from 0 to 2n-1, then we obtain something
    similar to the following (this example is for 23-1):'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们生成从0到2n-1的所有二进制数，那么我们得到类似以下的东西（这个例子是23-1）：
- en: 20=000, 21=001, 22=010, 23=011, 24=100, 25=101, 26=110, 27=111
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 20=000, 21=001, 22=010, 23=011, 24=100, 25=101, 26=110, 27=111
- en: 'Next, if we list these binaries and we consider that the first set bit (rightmost
    bit) is associated with *a*, the second set bit is associated with *b*, and the
    third set bit (the leftmost bit) is associated with *c*, then we obtain the following:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们列出这些二进制数，并且我们认为第一个设置位（最右边的位）与*a*相关联，第二个设置位与*b*相关联，第三个设置位（最左边的位）与*c*相关联，那么我们得到以下结果：
- en: 20 = 000 = {}
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 20 = 000 = {}
- en: 21 = 001 = {*a*}
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 21 = 001 = {*a*}
- en: 22 = 010 = {*b*}
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 22 = 010 = {*b*}
- en: 23 = 011 = {*a*, *b*}
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 23 = 011 = {*a*, *b*}
- en: 24 = 100 = {*c*}
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 24 = 100 = {*c*}
- en: 25 = 101 = {*a*, *c*}
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 25 = 101 = {*a*, *c*}
- en: 26 = 110 = {*b*, *c*}
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 26 = 110 = {*b*, *c*}
- en: 27 = 111 = {*a*, *b*, *c*}
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 27 = 111 = {*a*, *b*, *c*}
- en: 'Notice that if we replace the bits of 1 with *a*, *b*, and *c*, then we obtain
    the Power Set of the given set. Based on these statements, we can create the following
    pseudo-code for the given set, *S*:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果我们用*a*、*b*和*c*替换1的位，那么我们就得到了给定集合的幂集。基于这些陈述，我们可以为给定集合*S*创建以下伪代码：
- en: '[PRE28]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So, a solution to this problem can be written as follows:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个问题的解决方案可以写成如下形式：
- en: '[PRE29]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The complete code is called *PowerSetOfSet*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码称为*PowerSetOfSet*。
- en: Coding challenge 24 – Finding the position of the only set bit
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战24 - 查找唯一设置位的位置
- en: '**Adobe**, **Microsoft**'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '**Adobe**，**微软**'
- en: '**Problem**: Consider a positive integer, *n*. The binary representation of
    this number has a single bit set (a single bit of 1). Write a snippet of code
    that returns the position of this bit.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**：考虑一个正整数*n*。这个数字的二进制表示中有一个位被设置为1。编写一段代码，返回这个位的位置。'
- en: '**Solution**: The problem itself give us an important detail or constraint:
    the given number contains a single bit of 1\. This means that the given number
    must be a power of 2\. Only 20, 21, 22, 23, 24, 25, ..., 2n have binary representations
    containing a single bit of 1\. All other numbers contain 0 or multiple values
    of 1.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**：问题本身给了我们一个重要的细节或约束：给定的数字包含一个设置为1的单个位。这意味着给定的数字必须是2的幂。只有20、21、22、23、24、25、...、2n有包含一个设置为1的二进制表示。所有其他数字包含0或多个值为1。'
- en: 'An *n* & (*n*-1) formula can tell us whether the given number is a power of
    two. Check out the following diagram:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '*n* & (*n*-1)公式可以告诉我们给定的数字是否是2的幂。看看下面的图表：'
- en: '![Figure 9.42 – The n & (n-1) formula gives us the powers of two'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.42 - n & (n-1)公式给出了2的幂'
- en: '](img/Figure_9.42_B15403.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.42_B15403.jpg)'
- en: Figure 9.42 – The n & (n-1) formula gives us the powers of two
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.42 - n & (n-1)公式给出了2的幂
- en: So, the numbers 0, 1, 2, 8, 16, ... have their binary representation of *n*
    & (*n*-1) as 0000\. So far, we can say that the given number is a power of two.
    If it is not, then we can return -1 since there is no bit of 1 or there are multiple
    bits of 1.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，数字0、1、2、8、16等的二进制表示为*n* & (*n*-1)为0000。到目前为止，我们可以说给定的数字是2的幂。如果不是，那么我们可以返回-1，因为没有1位或者有多个1位。
- en: 'Next, we can shift *n* to the right as long as *n* is not 0 while tracking
    the number of shifts. When *n* is 0, this means we''ve shifted the single bit
    of 1, so we can stop and return the counted shifts. Based on these statements,
    the code for this is quite simple:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以将*n*向右移动，直到*n*不为0，同时跟踪移动的次数。当*n*为0时，这意味着我们已经移动了1的单个位，因此我们可以停止并返回计数的移位。基于这些陈述，这段代码非常简单：
- en: '[PRE30]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The complete code is called *PositionOfFirstBitOfOne*.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码称为*PositionOfFirstBitOfOne*。
- en: Coding challenge 25 – Converting a float into binary and vice versa
  id: totrans-570
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码挑战25 - 将浮点数转换为二进制，反之亦然
- en: '`float` number, *n*. Write a snippet of code that converts this `float` into
    an IEEE 754 single-precision binary floating-point (binary-32) and vice versa.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`数字*n*。编写一小段代码，将这个`float`转换为IEEE 754单精度二进制浮点数（二进制32），反之亦然。'
- en: '`float` numbers. The IEEE 754 standard specifies a binary-32 as having the
    sign bit (1 bit), exponent width (8 bits that can represent 256 values), and significant
    precision (24 bits (23 explicitly stored)), also known as the mantissa.'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`数字。IEEE 754标准规定二进制32具有符号位（1位）、指数宽度（可以表示256个值的8位）和有效精度（24位（23位显式存储）），也称为尾数。'
- en: 'The following diagram represents a binary-32 in the IEEE 754 standard:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表代表了IEEE 754标准中的二进制32：
- en: '![Figure 9.43 – IEEE 754 single-precision binary floating-point (binary 32)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.43 - IEEE 754单精度二进制浮点数（二进制32）'
- en: '](img/Figure_9.43_B15403.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.43_B15403.jpg)'
- en: Figure 9.43 – IEEE 754 single-precision binary floating-point (binary 32)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.43 - IEEE 754单精度二进制浮点数（二进制32）
- en: 'The `float` value, when represented by the 32-bit binary data with a given
    sign, biased exponent, *e*, (the 8-bit unsigned integer), and a 23-bit fraction,
    is as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`float`值，当用给定符号、偏置指数*e*（8位无符号整数）和23位小数表示的32位二进制数据时，如下所示：'
- en: '![Figure 9.44 Float value'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.44 浮点值'
- en: '](img/Figure_9.44_B15403.jpg)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.44_B15403.jpg)'
- en: Figure 9.44 – Float value
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.44 - 浮点值
- en: The exponent stored on 8 bits uses values from 0 to 127 to represent negative
    exponents (for example, 2-3) and uses the values from 128-255 for positive exponents.
    A negative exponent of 10-7 would have a value of -7+127=120\. The 127 value is
    known as the exponent bias.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在8位上的指数使用从0到127的值来表示负指数（例如，2-3），并使用从128到255的值来表示正指数。10-7的负指数将具有值-7+127=120。127值被称为指数偏差。
- en: With this information, you should be able to convert a `float` number into the
    IEEE 754 binary-32 representation and vice versa. Before checking the source code
    for this, called *FloatToBinaryAndBack*, try using your own implementation.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，你应该能够将`float`数字转换为IEEE 754二进制32表示，反之亦然。在检查名为*FloatToBinaryAndBack*的源代码之前，尝试使用自己的实现。
- en: This was the last coding challenge of this chapter. Let's quickly summarize
    it!
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章的最后一个编码挑战。让我们快速总结一下！
- en: Summary
  id: totrans-584
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Since this chapter is a comprehensive resource for bit manipulation, then if
    you got this far, you've seriously boosted your bit manipulation skills. We covered
    the main theoretical aspects and solved 25 coding challenges in order to help
    you learn patterns and templates for solving bit manipulation problems.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章是位操作的综合资源，所以如果你走到了这一步，你已经大大提高了你的位操作技能。我们涵盖了主要的理论方面，并解决了25个编码挑战，以帮助你学习解决位操作问题的模式和模板。
- en: In the next chapter, we'll continue our journey with arrays and strings.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨数组和字符串。
