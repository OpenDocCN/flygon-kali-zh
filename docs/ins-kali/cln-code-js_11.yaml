- en: Parts of Syntax and Scope
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法和范围的部分
- en: In this chapter, we will continue to explore JavaScript's syntax and constructs.
    We'll be delving into the fundamentals of expressions, statements, blocks, scopes,
    and closures. These are the less visible parts of the language. Most programmers
    assume that they already have a good grasp of how things such as expressions and
    scopes work, but, as we've seen, our intuitions of how things should work may
    not always align with how they truly do work. The constructs we'll be learning
    about in this chapter are the crucial larger building blocks of our programs,
    so it is of vital importance to understand them fully before we explore more abstract
    concepts such as control flow and design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索JavaScript的语法和结构。我们将深入研究表达式、语句、块、作用域和闭包的基础知识。这些是语言中不太显眼的部分。大多数程序员认为他们已经很好地掌握了诸如表达式和作用域等工作原理，但正如我们所见，我们对事物应该如何工作的直觉可能并不总是与它们真正工作的方式一致。我们将在本章学习的构造是我们程序的重要大型构建块，因此在我们探索控制流和设计模式等更抽象的概念之前，充分理解它们是非常重要的。
- en: Why are we learning this now?We've now got a solid grasp of what types are available
    in JavaScript and how to manipulate them via operators. The next logical step
    is to study *syntactic scaffolding* components, where we can place these types
    and operations, and how these scaffolding components behave. The end goal here
    is a high level of fluency in JavaScript so that we are better able to write clean
    code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们现在学习这个？我们现在已经对JavaScript中可用的类型以及如何通过运算符操纵它们有了牢固的掌握。下一个逻辑步骤是学习*句法脚手架*组件，我们可以在其中放置这些类型和操作，以及这些脚手架组件的行为。这里的最终目标是对JavaScript有高水平的流利度，这样我们就能更好地编写清晰的代码。
- en: 'In this chapter we''re going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Expressions, statements, and blocks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式、语句和块
- en: Scopes and declarations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作用域和声明
- en: Expressions, statements, and blocks
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式、语句和块
- en: 'There are broadly three types of syntactic **container **that exist within
    JavaScript: expressions, statements, and blocks. They are all containers in that
    they all hold other pieces of syntax and all have distinct behaviors that are
    worth distinguishing.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中存在三种广义的句法**容器**：表达式、语句和块。它们都是容器，因为它们都包含其他句法片段，并且都有值得区分的不同行为。
- en: There are additional constructs that you can call containers, such as functions
    or modules, but for now we're only interested in the types of syntax that you
    would find *within* these. As we continue to explore the language, we are slowly
    *zooming out* all the way from granular operators and expressions to the much
    larger and more complex functions and programs in which they reside.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他可以称为容器的构造，比如函数或模块，但目前我们只对你在其中找到的句法类型感兴趣。随着我们继续探索语言，我们正在从粒度运算符和表达式逐渐*放大*到更大更复杂的函数和程序中。
- en: 'It''s best to visualize the individual syntactic parts of a program as a hierarchy:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将程序的单个句法部分可视化为一个层次结构：
- en: '![](assets/a2d15faa-d5e6-45fb-a416-a0639b87aefc.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a2d15faa-d5e6-45fb-a416-a0639b87aefc.png)'
- en: Here, we can see that individual **expressions **(with a lower border) are wrapped
    in **statements**, either of the **regular **or **block **variety. It's useful
    to always have this hierarchical view of the language in our mind as this is how
    our code will be parsed and understood by the machine. We don't need to see our
    code as a parser would, of course, but it's indisputably useful to know how our
    code will be parsed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到单个**表达式**（下边界）被包裹在**语句**中，可以是**常规**或**块**类型。始终将语言的这种层次结构视图放在我们的脑海中是有用的，因为这是我们的代码将被解析和理解的方式。当然，我们不需要像解析器那样看待我们的代码，但了解我们的代码将如何被解析是无可争议的有用的。
- en: 'This hierarchical view of the language will also help us write programs that
    communicate their intent well to our fellow programmers. Hierarchy is not only
    a syntactic concern but a human one. When we write a program, we will typically
    model problems at different layers of abstraction: each part of a program goes
    within another part, and from all these individual parts, we can build a program
    that contains many different layers of complexity.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语言的分层视图也将帮助我们编写能够很好地传达意图给其他程序员的程序。层次结构不仅是一个句法问题，也是一个人类问题。当我们编写程序时，我们通常会在不同的抽象层面上建模问题：程序的每个部分都包含在另一个部分中，从所有这些单独的部分中，我们可以构建一个包含许多不同复杂层次的程序。
- en: As we explore the syntactic parts of JavaScript, it's worth remembering how
    individual elements of a program's syntax, its expressions and statements, will
    have a natural symmetry with the individual elements and layers of the problem
    domain.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们探索JavaScript的句法部分时，值得记住程序的句法元素，它的表达式和语句，将与问题域的个别元素和层次具有自然的对称性。
- en: Expressions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'An expression is the most granular type of syntactic container. We''ve already
    been working a lot with expressions. Even expressing a literal value, like the
    number `1`, will produce an expression:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是最粒度的句法容器类型。我们已经在很多表达式中工作过了。甚至表达一个文字值，比如数字`1`，都会产生一个表达式：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Using an operator also forms an expression:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运算符也形成一个表达式：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In fact, we can consider an operator as something that is itself applied to
    expressions. So the addition operator''s syntax can be understood like so:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以将运算符视为应用于表达式的东西。因此，加法运算符的语法可以这样理解：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An expression can be as simple as a literal value or a variable reference,
    but may also be complex. The following expression encompasses a series of operations
    and is spread over a few lines:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式可以是一个简单的文字值或变量引用，但也可以是复杂的。以下表达式包含一系列操作，并分布在几行中：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Expressions are not limited to primitive types or simple literal values. Class definitions, function
    expressions, array literals, and object literals are all things that can appear
    in the context of an expression. The easy way to know whether something is an
    expression is the question of whether or not it can go within a group operator
    (that is, parentheses) without causing a `SyntaxError`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式不仅限于原始类型或简单的文字值。类定义、函数表达式、数组文字和对象文字都是可以出现在表达式上下文中的东西。知道某物是否是表达式的简单方法是问它是否可以在不引起`SyntaxError`的情况下放在一个**group**运算符（即括号）中：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The syntactic building blocks of any program involve various different layers
    of syntactic structures. We have individual values and references: if we zoom
    out a little bit, we have expressions, and if we zoom out even further we have
    statements, which we will now explore.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序的语法构建块都涉及各种不同层次的语法结构。我们有单个值和引用：如果我们稍微放大一点，我们有表达式，如果我们放大得更远，我们有语句，现在我们将探讨这些。
- en: Statements
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语句
- en: A **statement** contains an expression, and is, therefore, another type of syntactic
    container. Knowing how JavaScript sees expressions as distinct from statements
    is hugely helpful in avoiding the various traps and idiosyncrasies of the language.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**语句**包含一个表达式，因此是另一种语法容器。了解 JavaScript 如何将表达式视为与语句不同的东西对于避免语言的各种陷阱和特殊之处非常有帮助。'
- en: 'A statement is formed in a variety of situations. These include the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 语句在各种情况下形成。这些情况包括：
- en: When you terminate an expression with a semicolon (`1 + 2;`)
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您用分号终止一个表达式（`1 + 2;`）
- en: When you use any of the `for`, `while`, `switch`, `do..while`, or `if` constructs
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您使用任何`for`、`while`、`switch`、`do..while`或`if`构造
- en: When you create a function via a function declaration (`function Something()
    {}`)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您通过**function declaration**（`function Something() {}`）创建函数
- en: They are automatically formed by the language's natural **automatic semicolon
    insertion** (**ASI**)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是由语言的自然**自动分号插入**（**ASI**）自动形成的
- en: The syntax of a function declaration (`function name() {}`) will always form
    a statement unless it appears in the context of an expression, in which case it'll
    naturally be a *named function expressio**n*. For the nuanced differences between
    these, please revisit [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*,* *Primitive
    and Built-In Types*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**function declaration**的语法（`function name() {}`）将始终形成一个语句，除非它出现在表达式的上下文中，在这种情况下，它自然会成为**命名函数表达式**。有关这些之间微妙差异，请重新阅读[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)，*原始类型和内置类型*。'
- en: Forming statements with semicolons
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用分号形成语句
- en: When we place one expression after another, we tend to terminate each individual
    one with a semicolon. By doing this, we are forming a statement. Explicitly terminating
    a statement ensures that the JavaScript parser will not have to do so automatically.
    If you don't use semicolons, then the parser will guess where to insert them via
    a process called ASI. This process relies on our placement of new lines (that
    is, `\n`).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将一个表达式放在另一个表达式后面时，我们倾向于用分号终止每个单独的表达式。通过这样做，我们形成了一个语句。显式终止语句可以确保 JavaScript
    解析器不必自动执行此操作。如果您不使用分号，那么解析器将通过称为**ASI**的过程猜测在何处插入它们。此过程依赖于我们换行的位置（即`\n`）。
- en: 'As ASI is automatic, it won''t always provide the outcomes you desire. For
    example, consider the following case where there is a function expression followed
    by a syntax that is intended as a group (that is, an expression delimited by parentheses):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**ASI**是自动的，它不会总是提供您期望的结果。例如，考虑以下情况，其中有一个**function expression**后面跟着一个意图作为**group**（即由括号括起来的表达式）的语法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This will cause a mysterious `TypeError` that says: `Cannot read property join
    of undefined`. This is because, from the parser''s point of view, the following
    is what we''re doing:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致一个神秘的`TypeError`，显示：`Cannot read property join of undefined`。这是因为，从解析器的角度来看，我们正在做以下事情：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we''re creating an inline anonymous function and then immediately calling
    it, passing the `[1, 2, 3]` array as our sole argument, and then we''re attempting
    to invoke the `join` method on whatever''s returned. But as our function returns `undefined`,
    there is no `join` method there, and so we receive an error. This is a rare situation,
    but variations of this issue do crop up from time to time. The best way to avoid
    them is to consistentlyuse semicolons to terminate lines that are intended as
    statements, as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个内联的匿名函数，然后立即调用它，将`[1, 2, 3]`数组作为我们唯一的参数传递，然后我们尝试在返回的内容上调用`join`方法。但是由于我们的函数返回`undefined`，所以那里没有`join`方法，因此我们会收到一个错误。这是一个罕见的情况，但是这个问题的变体偶尔会出现。避免它们的最佳方法是**一致地**使用分号终止作为语句意图的行，如下面的代码所示：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'ASI can bite you in other ways as well. A common example is when you attempt
    to use a `return` statement within a function, with its intended return value
    on the next line. In such cases, you''ll get a nasty surprise:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**ASI**也可能以其他方式影响您。一个常见的例子是当您尝试在函数内部使用`return`语句，并且其预期的返回值在下一行时。在这种情况下，您会得到一个令人讨厌的惊喜：'
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'JavaScript''s ASI mechanism will presume that the `return` statement is terminated
    if there is nothing else present on the same line, and so the following is closer
    to what the JavaScript engine will see when running the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的**ASI**机制将假定如果同一行上没有其他内容，`return`语句已经终止，因此在运行代码时，JavaScript 引擎将看到以下内容更接近：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To fix this, we can either place `a + b` on the same line as our `return` statement
    or we can use a group operator to contain our indented expression:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们可以将`a + b`放在与我们的`return`语句相同的行上，或者我们可以使用**group**运算符来包含我们缩进的表达式：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It's not necessary to know every ASI  rule, but it is very useful to know that
    it exists. The best way of working with ASI is to avoid it wherever possible.
    If you're explicit about the termination of your statements, then you won't need
    to rely on obscure ASI rules, and you won't be relying on your fellow programmers
    knowing these rules either.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要了解每个ASI规则，但知道它的存在非常有用。与其依赖于晦涩的ASI规则，不如尽可能避免使用它。如果您明确地终止您的语句，那么您就不需要依赖于这些规则，也不需要依赖于您的同事知道这些规则。
- en: Blocks
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块
- en: If we consider statements as containers of expressions, then we can consider blocks as
    containers of statements. In other languages, they are sometimes called **compound
    statements** as they allow several statements to exist together.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将语句视为表达式的容器，那么我们可以将块视为语句的容器。在其他语言中，它们有时被称为**复合语句**，因为它们允许多个语句一起存在。
- en: Strictly speaking, blocks are statements. From a language-design perspective,
    this is a useful thing because it allows statements that form part of other constructs
    to be expressed as either single-line statements or entire blocks containing several
    statements—for example, following `if(...)` or `for(...)` constructs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，块是语句。从语言设计的角度来看，这是一件有用的事情，因为它允许构成其他结构的语句可以表达为单行语句或包含多个语句的整个块，例如在`if(...)`或`for(...)`结构之后。
- en: 'Blocks are formed by delimiting zero or more statements with curly braces:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 块由用大括号界定的零个或多个语句组成：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Blocks are very rarely used as completely isolated units of code (there''s
    very limited benefit from doing so). You''ll usually find them within `if`, `while`, `for` and `switch` statements,
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 块很少被用作完全孤立的代码单元（这样做的好处非常有限）。通常会在`if`、`while`、`for`和`switch`语句中找到它们，如下所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `{...}` part of the `while` loop here is a block. It is not an inherent
    part of the `while` syntax. If we wish to, we can entirely exclude the block and
    in its place just have a regular single-line statement:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`while`循环的`{...}`部分是一个块。它不是`while`语法的固有部分。如果愿意，我们可以完全排除该块，而是用一个常规的单行语句代替：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That would be identical to the version in which we use a block, but obviously
    this would be limiting if we intend to add more iteration logic. As a result,
    it's usually preferable to preemptively use a block in such scenarios. Doing so
    has the added benefit of legitimizing indentation and the containment of the iteration
    logic.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这将与使用块的版本相同，但显然如果我们打算添加更多的迭代逻辑，这将是有限制的。因此，在这种情况下通常最好预先使用块。这样做的额外好处是合法化缩进和迭代逻辑的包含。
- en: 'Blocks are not only syntactic containers. They affect the runtime of our code
    as well by providing their own scope, which means that we can declare variables
    within via `const` and `let` statements. Observe here how we declare a variable
    within an `if` block and how it is not available outside that block:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 块不仅仅是语法容器。它们还通过提供自己的作用域影响我们代码的运行时，这意味着我们可以通过`const`和`let`语句在其中声明变量。请注意这里我们如何在`if`块内声明一个变量以及它在该块外部不可用的情况：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Scoping is a topic that we should not take lightly. It can be quite difficult
    to understand, and so what follows is an entire section in which we explore its
    nature and nuances.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 作用域是一个我们不应该轻视的话题。它可能很难理解，因此接下来的部分将探讨其性质和细微差别。
- en: Scopes and declarations
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和声明
- en: The scope of a given variable can be thought of as the areas within the program
    where that variable can be accessed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 给定变量的作用域可以被认为是程序中可以访问该变量的区域。
- en: 'When we declare a variable at the beginning of a module (outside all functions),
    we think that it''s only natural that this variable should then be accessible
    to all functions within the module:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在模块的开头（所有函数之外）声明一个变量时，我们认为这个变量应该可以被模块内的所有函数访问：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And if we define a variable within a function, then we expect all inner functions
    to have access to it:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在函数内定义一个变量，那么我们期望所有内部函数都能访问它：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The fact that we can access `value` in the `doSomething` function here is thanks
    to its scope. The scope of a given variable will depend on how it is declared.
    When you declare a variable via a `var` declaration, it will have a different
    potential scope to a variable created via a `let` declaration. We will cover these
    differences soon, but first, it's useful to have a clearer idea of how scopes
    operate internally.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里的`doSomething`函数中访问`value`是由于它的作用域。给定变量的作用域将取决于它是如何声明的。当您通过`var`声明变量时，它的潜在作用域将与通过`let`声明的变量不同。我们将很快介绍这些差异，但首先，了解作用域内部运作的清晰概念是很有用的。
- en: 'Internally, when you declare variables, JavaScript will create and store that
    variable within a lexical environment, which contains the mappings of identifiers
    to values. A typical JavaScript program can be thought of as having four types
    of lexical environments, as shown in the following list:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，当您声明变量时，JavaScript将在词法环境中创建和存储该变量，该环境包含标识符到值的映射。一个典型的JavaScript程序可以被认为有四种类型的词法环境，如下列表所示：
- en: '**The global environment**: There is only one of these, and it is considered
    the outer scope of all other scopes. It is the global context in which all other
    environments (that is, scopes) exist. The global environment mirrors a global
    object that can be referred to by `window` or `self` in the browser and `global` in
    Node.js.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局环境**：只有一个，它被认为是所有其他作用域的外部作用域。它是所有其他环境（即作用域）存在的全局上下文。全局环境反映了一个全局对象，可以在浏览器中通过`window`或`self`引用，在Node.js中通过`global`引用。'
- en: '**A module environment**: This environment will be created for each distinct
    JavaScript module that is run as part of a singular Node.js process or for each `<script
    type="module">` in the browser.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块环境**：为每个作为单个Node.js进程的一部分运行的不同JavaScript模块或浏览器中的每个`<script type="module">`创建此环境。'
- en: '**A function environment**: This environment will be in effect for every running
    function, however it is declared or invoked.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数环境：这个环境将对每个运行的函数产生影响，无论它是如何声明或调用的。
- en: '**A block environment**: This environment will be in effect for every block
    (`{...}`) in your program, whether following another language construct, such
    as `if(...)` or `while(...)`, or situated independently.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 块环境：这个环境将对程序中的每个块（`{...}`）产生影响，无论是在另一个语言构造之后，比如`if(...)`或`while(...)`，还是独立地放置。
- en: 'As you know, both functions and blocks can exist within other functions and
    blocks. Consider the following piece of code that expresses various environments
    (scopes):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，函数和块都可以存在于其他函数和块中。考虑以下代码片段，它表达了各种环境（作用域）：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At the point where `Done Rendering!` is logged, we may expect the hierarchy
    of environments to look something like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在记录`Done Rendering!`的时候，我们可能期望环境的层次结构看起来像这样：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This hierarchy of environments will change throughout the runtime of a given
    program. If a function is run to completion and its internal scope is no longer
    used in any exposed internal functions (known as **closures**), then the lexical
    environment will be destroyed. Essentially, when a scope is guaranteed to no longer
    be needed, then JavaScript is free to get rid of it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这种环境的层次结构将在给定程序的运行时发生变化。如果一个函数运行完成，并且它的内部作用域不再被任何暴露的内部函数（称为闭包）使用，那么词法环境将被销毁。基本上，当一个作用域不再需要时，JavaScript就可以摆脱它。
- en: Variable declarations
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量声明
- en: 'A variable declaration occurs via a `var` keyword followed by a valid identifier
    or an assignment of the form `a = b`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`var`关键字后跟一个有效的标识符或形式为`a = b`的赋值来进行变量声明：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We call things declared via `var` keyword variable declarations, but it's important
    to note that, in popular terminology, declarations made by both `let` and `const` are
    also considered variables.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称通过`var`关键字声明的事物为变量声明，但重要的是要注意，在流行的术语中，由`let`和`const`声明的声明也被认为是变量。
- en: 'Variables declared via `var` are scoped to the nearest function, module, or global environment—that
    is, they are not block-scoped. At parse time, variable declarations within a given
    scope will be collected and then, at the point of execution, those declared variables
    will be hoisted to the top of their execution context and initialized with the `undefined` value.
    This means that, within a given scope, technically you can access a variable prior
    to its assignment, but it''ll be `undefined`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`var`声明的变量的作用域限制在最近的函数、模块或全局环境中，也就是说，它们不是块作用域的。在解析时，给定作用域内的变量声明将被收集，然后在执行时，这些声明的变量将被提升到它们的执行上下文的顶部，并用`undefined`值进行初始化。这意味着，在给定作用域内，你可以在其赋值之前访问一个变量，但它将是`undefined`：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The **execution context** is a name given to the top of the call stack, meaning
    the currently running function, script, or module. It is a concept that is only
    seen when code is run, and will change as the program progresses. You can usually
    think of it as simply the currently-running function (or outer module or `<script>`). `var` declarations
    are always hoisted to the top of their execution context and initialized to `undefined`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**执行上下文**是指调用堆栈的顶部，也就是当前运行的函数、脚本或模块。这个概念只在代码运行时才能看到，并且随着程序的进行而改变。你通常可以简单地将其视为当前运行的函数（或外部模块或`<script>`）。`var`声明总是被提升到它们的执行上下文的顶部，并初始化为`undefined`。'
- en: 'The hoisting behavior of `var` is in contrast to variables declared via `let` and `const`,
    which will produce an `ReferenceError` if you attempt to access them prior to
    their declaration:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过`let`和`const`声明的变量相比，`var`的提升行为是相反的，如果你在它们声明之前尝试访问它们，将会产生`ReferenceError`：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you''re not careful, the hoisting behavior of `var` can lead to some unexpected
    results. For example, there may be a situation where you''re attempting to refer
    to a variable that exists within the outer scope but you are unable to do so because
    of a variable declaration in your current scope being hoisted:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不小心，var的提升行为可能会导致一些意想不到的结果。例如，可能会出现这样的情况，你试图引用外部作用域中存在的变量，但由于当前作用域中的变量声明被提升，你无法这样做：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, the inner scope's variable declaration of `config` will be hoisted to
    the top of its scope, meaning that, from the very first line of `setupUI`, `config` is `undefined`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，内部作用域变量`config`的声明将被提升到其作用域的顶部，这意味着从`setupUI`的第一行开始，`config`是`undefined`。
- en: 'Since variable declarations are hoisted to the very top of their execution
    context, even those within a block will be hoisted as if they were first initialized
    outside of it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变量声明被提升到它们的执行上下文的顶部，即使在块中，它们也会被提升，就好像它们是在块外部首先初始化的一样：
- en: '[PRE23]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In summary, variable declarations create a variable that is scoped to the nearest
    function, module, or global environment. In the browser, there are no module environments,
    so it'll either be scoped to its function or the global scope. A variable declaration
    will be hoisted, before execution, to the top of its respective execution context.
    This may be the function, the module (in Node.js), or the `<script>` (in the browser).
    Variable declarations have fallen out of favor because of the more recently introduced `const` and `let` declarations,
    which are both block-scoped and do not have any odd hoisting behavior.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，变量声明创建了一个作用域限制在最近的函数、模块或全局环境中的变量。在浏览器中，没有模块环境，所以它将被作用域限制在其函数或全局作用域。变量声明将在执行之前被提升到其相应执行上下文的顶部。这可能是函数、模块（在Node.js中）或`<script>`（在浏览器中）。由于最近引入的`const`和`let`声明都是块作用域的，并且没有任何奇怪的提升行为，因此变量声明已经不再受欢迎。
- en: Let declarations
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let声明
- en: Let declarations are thankfully far simpler than `var` declarations. They will
    be scoped to their nearest environment (whether it is a block, a function, a module,
    or the global environment) and have no complicated hoisting behaviors.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Let声明比var声明简单得多。它们将被作用域限制在它们最近的环境中（无论是块、函数、模块还是全局环境），并且没有复杂的提升行为。
- en: 'Their ability to be scoped to a block means that a let declaration inside a
    block will not have an effect on the `outer` function scope. In the following
    code, we can see three different environments (scopes) with a respective `place` variable
    in each:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它们能够作用域限定到一个块，这意味着块内部的let声明不会影响`outer`函数作用域。在下面的代码中，我们可以看到三个不同的环境（作用域），每个环境中都有一个相应的`place`变量：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This demonstrates two things to us:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了两件事：
- en: Declaring via `let` will not overwrite or mutate a variable by the same name
    in an `outer` scope
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`let`声明不会覆盖或改变`outer`作用域中同名的变量
- en: Declaring via `let` will allow each scope to have its own variable, invisible
    to `outer` scopes
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`let`声明将允许每个作用域拥有自己的变量，对`outer`作用域不可见
- en: 'When you use `let` in either `for(;;)`, `for...in`, or `for...of` constructs,
    even outside of the following block, then that `let` declaration will be scoped
    as if it were inside the block. This makes sense intuitively: when we initialize
    a `for` loop with let declarations, we naturally expect those to be scoped to
    the `for` loop itself and not outside of it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`for(;;)`、`for...in`或`for...of`结构中使用`let`，即使在后面的块之外，那么该`let`声明将被作用域限定为在块内部。这在直觉上是有意义的：当我们用let声明初始化一个for循环时，我们自然期望它们的作用域限定在for循环本身而不是外部。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We should only use `let` if we expect the variable to be reassigned at some
    later point. If no new assignment will occur, then we should prefer `const`, as
    it gives us a little bit of extra peace of mind.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们预期变量在以后的某个时间点会被重新赋值，那么我们应该使用`let`。如果不会发生新的赋值，那么我们应该优先使用`const`，因为它可以给我们一点额外的安心。
- en: Const declarations
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Const声明
- en: 'A `const` declaration has the same characteristics as `let`, except for one
    crucial difference: variables declared via `const` are immutable, meaning that
    the variable cannot be reassigned to a different value:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`声明具有与`let`相同的特性，除了一个关键的区别：通过`const`声明的变量是不可变的，这意味着变量不能被重新分配为不同的值：'
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It''s important to note that this does not affect the mutability of the value
    itself. So if the value is any type of object, then all of its properties will
    retain their mutability:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这并不影响值本身的可变性。因此，如果值是任何类型的对象，那么它的所有属性将保持它们的可变性：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even though `const` does not protect values from all mutability, it does protect
    us from some common mistakes and bad practices, such as reusing a variable to
    refer to several different concepts, or accidentally reassigning a variable because
    of a typo. The `const` code phrase is generally safer to use than `let`, and is
    now considered the best practice for the declaration of all variables, unless
    you have an explicit need to reassign a variable after its declaration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`const`不能保护值免受所有可变性的影响，但它可以保护我们免受一些常见错误和不良实践的影响，比如重复使用一个变量来引用几个不同的概念，或者因为拼写错误而意外地重新赋值一个变量。`const`代码短语通常比`let`更安全，并且现在被认为是声明所有变量的最佳实践，除非你明确需要在声明后重新分配变量。
- en: 'You should also feel free to use `const` when declaring variables in `for...of` and `for...in` iteration
    constructs, such as in the following case:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for...of`和`for...in`迭代结构中声明变量时，也可以自由使用`const`，例如在以下情况下：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: People often mistakenly opt for using `let` here because they believe that the
    looping construct will effectively reassign the variable, making `const` unsuitable.
    But in fact, the declaration within `for(...)` will be tied to a new block scope
    on each iteration, and thus the `const` variable will be newly initialized on
    each iteration within this fresh scope.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 人们经常错误地选择在这里使用`let`，因为他们认为循环结构将有效地重新分配变量，使`const`不合适。但事实上，在`for(...)`中的声明将与每次迭代中的新块作用域相关联，因此`const`变量将在每次迭代中在这个新作用域内重新初始化。
- en: Function declarations
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明
- en: In terms of scoping, function declarations behave similarly to variable declarations (that
    is, `var`). They will be scoped to their closest function, module, or global environment,
    and will be hoisted to the top of their respective execution context.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在作用域方面，函数声明的行为与变量声明（即`var`）类似。它们将作用域限定在它们最近的函数、模块或全局环境中，并且将被提升到它们各自的执行上下文的顶部。
- en: 'Unlike variable declarations, however, a function declaration will cause the
    actual assignment of the `Function` to its identifier to be hoisted as well, meaning
    that the `Function` is effectively available before it is declared:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，函数声明与变量声明不同，它将导致`Function`的实际赋值与其标识符一起被提升，这意味着在声明之前`Function`实际上是可用的。
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This behavior is quite obscure and as such is inadvisable unless it is very
    obvious where the definition for `myFunction` comes from upon invocation. A programmer
    will typically expect a definition for a function to exist above the place where
    it is called (or imported as a dependency at some prior point in time), so it
    can be confusing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为相当隐晦，因此不建议使用，除非在调用时很明显可以确定`myFunction`的定义来自哪里。程序员通常期望函数的定义存在于调用它的地方之上（或者在之前的某个时间点作为依赖导入），因此可能会令人困惑。
- en: 'There is further complexity if we consider the possibility of a function declaration residing
    within a block that is conditionally activated (**warning: don''t do this!**):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑条件激活的块中可能存在函数声明的情况，那么情况会更加复杂（**警告：不要这样做！**）：
- en: '[PRE30]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Unfortunately, previous versions of ECMAScript did not prescribe the behavior
    of function declarations within blocks. This led to various browser implementations
    choosing their own unique way of handling such situations. Over time, implementations
    have begun to align. The ECMAScript 2015 specification sensibly forbids either
    of the `giveMeTheBestNumber` functions from having their values hoisted. The declaration
    itself can, however, still be hoisted, meaning that `giveMeTheBestNumber` would
    be `undefined` on lines prior to its declarations (similar to `var`), as mentioned.
    This is, at the time of writing, the prevalent behavior of most (but not all)
    implementations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，以前的ECMAScript版本没有规定块内的函数声明的行为。这导致各种浏览器实现选择了自己独特的处理方式。随着时间的推移，实现已经开始对齐。2015年的ECMAScript规范明智地禁止了`giveMeTheBestNumber`函数中的任何一个值被提升。然而，声明本身仍然可以被提升，这意味着在其声明之前的行中，`giveMeTheBestNumber`将是`undefined`（类似于`var`），如前所述。这是在撰写本文时大多数（但不是全部）实现的普遍行为。
- en: Because of the obscurity and the remaining inconsistencies across implementations,
    it is strongly suggested that you *don't use function declarations within blocks*.And
    ideally, it's best not to rely on their hoisting behavior (by referencing function
    declarations) unless you're confident that doing so would not be misunderstood
    by those who must read your code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于实现之间的模糊和剩余的不一致性，强烈建议您*不要在块内使用函数声明*。最好不要依赖它们的变量提升行为（通过引用函数声明），除非您确信这样做不会被阅读您代码的人误解。
- en: For more information on how functions produced by function declarations differ
    from other ways of creating functions (for example, function expressions or arrow
    functions), please revisit the *Functions* section in *[Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*, *Primitive
    and Built-In Types*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有关由函数声明产生的函数与其他创建函数的方式（例如，函数表达式或箭头函数）有何不同的更多信息，请重新查看*[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)*中的*函数*部分。
- en: Closures
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Inner scopes, as we''ve seen, have access to the variables of outer scopes:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，内部作用域可以访问外部作用域的变量：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: What naturally follows from this is the concept of a closure. A closure is how
    JavaScript enables you to continue to access the scope of an `inner` function
    regardless of where or when it is called.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里自然而然地引申出了闭包的概念。闭包是JavaScript如何使您能够继续访问`inner`函数的作用域的方式，无论何时何地调用它。
- en: It's simplest to think of a closure as simply a retained scope. A closure is
    a wrapped-up or enclosed scope that is passed around alongside the function, invisibly.
    When you call the function, it has implicit access to its scope provided by this
    closure.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将闭包简单地视为保留的作用域是最简单的。闭包是一个随函数一起传递的包装或封闭作用域，它在调用函数时隐式地提供了对其作用域的访问。
- en: 'Consider the following function (`fn`), which returns another function. It
    has its own scope, in which we declare the `coolNumber` variable:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下函数（`fn`），它返回另一个函数。它有自己的作用域，在其中我们声明了`coolNumber`变量：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The inner function, which we return, has access to the `coolNumber `variable,
    as we would expect. When we call `fn()`, its scope is effectively kept alive so
    that, when we eventually call the `inner` function, it is still able to access
    `coolNumber`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们返回的内部函数可以访问`coolNumber`变量，这是我们所期望的。当我们调用`fn()`时，它的作用域被有效地保持，因此当我们最终调用`inner`函数时，它仍然能够访问`coolNumber`。
- en: 'The following is another example, where we''re making use of the continued
    access to the retained scope (that is, the closure) by reassigning and returning
    the local variable whenever our inner function is called:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是另一个例子，我们利用保留作用域（即闭包）继续访问本地变量，并在调用内部函数时重新分配和返回：
- en: '[PRE33]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The concept of closures is often over-complicated, so at the risk of doing
    that, I''ll state things quite simply. A closure is not an odd thing, really:
    it is a natural extension of how we should expect a scope to work. All functions
    have access to a given scope, so it shouldn''t matter how we then pass around
    these functions after their initial definition. They will continue to have access
    to that same scope, and are free to access or mutate variables within that scope
    as they see fit. A function is always anchored to the place it was originally
    defined and so whether it is called immediately or in a thousand minutes'' time,
    it will have access to the same scope (that is, the same set of lexical environments).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包的概念经常被过度复杂化，因此冒着这样做的风险，我会简单地陈述一下。闭包并不是什么奇怪的东西：它是我们应该期望作用域工作的自然延伸。所有函数都可以访问给定的作用域，因此在我们传递这些函数的初始定义之后，它们将继续访问相同的作用域，并且可以自由访问或修改该作用域内的变量。函数始终锚定在最初定义的位置，因此无论是立即调用还是在一千分钟后调用，它都将访问相同的作用域（即相同的词法环境集）。
- en: Summary
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we continued to explore the JavaScript language, zooming out
    from previous chapters to consider larger pieces of syntax, such as expressions,
    statements, and blocks. These are programmatic scaffolding components in which
    we can place the types and operations we've previously learned about. We also
    covered the complicated mechanisms of scopes, hoisting, and closures. Understanding
    how these concepts all work together is vital to understanding other people's
    JavaScript programs and constructing your own.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续探索JavaScript语言，从之前的章节放大，考虑更大的语法片段，如表达式、语句和块。这些是程序化的支撑组件，我们可以在其中放置我们之前学到的类型和操作。我们还涵盖了作用域、变量提升和闭包的复杂机制。理解这些概念如何共同工作对于理解其他人的JavaScript程序并构建自己的程序至关重要。
- en: In the next chapter, we explore how to control flow within JavaScript. This'll
    allow us to weave together expressions and statements into larger bodies of logic
    in a clean way. We will then explore the art of abstraction design by learning
    about design patterns. Though the process of learning these topics individually
    may appear arduous, by the end of the book you'll have a thorough and powerful
    understanding of JavaScript that'll enable you to pay less attention to the oddities
    of the language and more attention to the cleanliness of your code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何在JavaScript中控制流程。这将使我们能够以一种清晰的方式将表达式和语句编织在一起，形成更大的逻辑体。然后，我们将通过学习设计模式来探索抽象设计的艺术。虽然单独学习这些主题的过程可能看起来很艰难，但在本书结束时，您将对JavaScript有深入而强大的理解，这将使您能够更少地关注语言的怪异之处，更多地关注代码的清晰度。
