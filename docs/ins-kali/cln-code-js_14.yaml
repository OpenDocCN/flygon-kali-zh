- en: Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: Most problems we encounter are not new. Many programmers that have come before
    us have tackled similar problems and, via their struggles, various patterns of
    programming have emerged. We call these design patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到的大多数问题都不是新问题。许多在我们之前的程序员已经解决了类似的问题，并通过他们的努力，各种编程模式已经出现。我们称这些为设计模式。
- en: Design patterns are the useful structures, styles, and stencils that our code
    sits within. A design pattern may prescribe anything from the overall scaffolding
    of a code base to the individual syntactic pieces used to build expressions, functions,
    and modules. By building software, we are constantly, and often unknowingly, in
    the process of *designing*. It is through this process of designing that we are
    defining the experience that users and maintainers will go through when exposed
    to our code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是我们的代码所在的有用结构、样式和模板。设计模式可以规定从代码基础的整体脚手架到用于构建表达式、函数和模块的单个语法片段的任何内容。通过构建软件，我们不断地，而且通常是不知不觉地，处于*设计*的过程中。正是通过这个设计过程，我们正在定义用户和维护者在接触我们代码时将经历的体验。
- en: To attune us to this perspective of the designer instead of programmer, for
    a moment, let's consider the design of a simple software abstraction.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们适应设计师而不是程序员的视角，让我们考虑一个简单软件抽象的设计。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The perspective of a designer
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计师的视角
- en: Architectural design patterns
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构设计模式
- en: JavaScript modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 模块
- en: Modular design patterns
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块化设计模式
- en: Planning and harmony
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划和和谐
- en: The perspective of a designer
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计师的视角
- en: To bestow us with the perspective of a designer, let's explore a simple problem.
    We must construct an abstraction that allows users to give us two strings, a subject string
    and a query string. We must then calculate a count of the query strings found
    within the subject string.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了赋予我们设计师的视角，让我们探索一个简单的问题。我们必须构建一个抽象，允许用户给我们两个字符串，一个主题字符串和一个查询字符串。然后我们必须计算主题字符串中查询字符串的计数。
- en: 'So, consider the following query string:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，请考虑以下查询字符串：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And have a look at the following subject string:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 并看一下以下主题字符串：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We should receive a result of `2`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该收到一个结果为`2`。
- en: For our purposes as a designer, we care about the experience of those who must
    use our code. For now, we won't worry about our implementation; we will instead
    only consider the interface, as it is primarily the interface to our code that
    will drive our fellow programmers' experiences.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们作为设计师的目的，我们关心那些必须使用我们代码的人的体验。现在，我们不会担心我们的实现；我们只会考虑接口，因为主要是我们代码的接口将驱动我们的同行程序员的体验。
- en: 'The very first thing we may do as a designer is to define a function with a
    carefully chosen name and a specific set of named arguments:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计师，我们可能会做的第一件事是定义一个带有精心选择的名称和一组特定命名参数的函数：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This function accepts `needle` and `haystack` and will return `Number`, indicating
    the count of `needle` within `haystack`. The consumer of our code would make use
    of it like so:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受`needle`和`haystack`，并将返回`Number`，表示`needle`在`haystack`中的计数。我们代码的使用者会这样使用它：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are using the popular idiom of needle-in-a-haystack to describe the problem
    of looking for a substring within another string. Considering popular idioms is
    a crucial part of designing code, but we must be wary of idioms being misunderstood.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了寻找大海捞针的流行习语来描述在另一个字符串中寻找子字符串的问题。考虑流行的习语是设计代码的关键部分，但我们必须警惕习语被误解。
- en: 'The design of a piece of code should be defined by the problem domain we wish
    to solve and the user experience we wish to reveal. Another programmer, given
    the same problem domain, may have chosen a different solution. For example, they
    may have employed partial application to allow the following calling syntax:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的设计应该由我们希望解决的问题领域和我们希望展现的用户体验来定义。另一个程序员在相同的问题领域下可能会选择不同的解决方案。例如，他们可能会使用部分应用来允许以下调用语法：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or perhaps they may have designed a more verbose syntax that involves invoking
    a `Haystack` constructor and calling its `count()` method like so:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者他们可能设计了一个更冗长的语法，涉及调用`Haystack`构造函数并调用其`count()`方法，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This *classical* approach arguably has a nice semantic relationship between
    the object (`Haystack`) and the `count` method. It meshes well with the OOP concepts
    we've explored in previous chapters. That said, some programmers may find it to
    be overly verbose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种*经典*方法可以说在对象（`Haystack`）和`count`方法之间有很好的语义关系。它与我们在之前章节中探讨过的面向对象编程概念很契合。尽管如此，一些程序员可能会觉得它过于冗长。
- en: 'There''s also the possibility of a more descriptive API where the arguments
    are defined within a configuration object (that is, a plain object literal passed
    as the sole argument):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能是更具描述性的 API，其中参数在配置对象中定义（即作为唯一参数传递的普通对象文字）：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'There''s also the possibility that this counting functionality may form the
    part of a larger set of string-related utilities and, hence, can be incorporated
    into a larger custom-named module:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 还有可能这种计数功能可能是更大的一组与字符串相关的实用程序的一部分，因此可以并入一个更大的自定义命名模块：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We may even consider it okay to modify the native `String.prototype`, even
    though it is inadvisable, so that we have a `count` method available on all strings:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以考虑修改原生的`String.prototype`，尽管这是不可取的，以便我们在所有字符串上都有一个`count`方法可用：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In terms of our naming conventions as well, we may wish to avoid the needle-in-a-haystack
    idiom and, instead, use more descriptive names where perhaps there is less risk
    of misunderstanding, like the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的命名约定方面，我们可能希望避免使用大海捞针的习语，而是使用更具描述性的名称，也许有较少误解的风险，如下所示：
- en: '`searchableString` and `subString`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchableString`和`subString`'
- en: '`query` and `content`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`查询`和`内容`'
- en: '`search` and `corpus`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`和`corpus`'
- en: The choices available to us, even within this very narrow problem domain, are
    overwhelming. You'll likely have many of your own strong opinions about which
    approach and naming conventions would have been superior here.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个非常狭窄的问题域内，我们可选择的选项也是令人难以置信的。您可能对哪种方法和命名约定更优越有很多自己的强烈意见。
- en: The fact that we can solve a seemingly simple problem with so many different
    approaches shows us how there is a need for a decision process. And this process
    is software design. Effective software design employs design patterns to encapsulate
    problem domains and provide familiarity and ease of comprehension to fellow programmers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用许多不同的方法解决一个看似简单的问题，这表明我们需要一个决策过程。而这个过程就是软件设计。有效的软件设计利用设计模式来封装问题域，并为同行程序员提供熟悉性和易于理解。
- en: The intent with our exploration of the needle-in-a-haystack problem was not
    to find a solution, but rather to highlight the difficulty of software design,
    and to expose our minds to a more user-oriented perspective. It also reminds us
    that there is very rarely one ideal design.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探索“大海捞针”问题的意图并不是为了找到解决方案，而是为了突出软件设计的困难，并让我们的思维接触更加以用户为导向的视角。它也提醒我们，很少有一个理想的设计。
- en: 'A well-chosen design pattern, given any problem domain, can be said to have
    two basic characteristics:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 任何问题域中，一个精心选择的设计模式可以说具有两个基本特征：
- en: '**It solves the problem well**: A well-chosen design pattern will be well-suited
    to the problem domain so that we can fluidly express the nature of the problem
    and its solution easily.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它很好地解决了问题**：一个精心选择的设计模式将很好地适应问题域，以便我们可以轻松地表达问题的性质和其解决方案。'
- en: '**It is familiar and usable**: A well-chosen design pattern will be familiar
    to our fellow programmers. It''ll be immediately obvious how can they can use
    it or make changes to the code.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**它是熟悉和可用的**：一个精心选择的设计模式对我们的同行程序员来说是熟悉的。他们会立刻明白如何使用它或对代码进行更改。'
- en: Design patterns are useful in a variety of contexts and scales. We use them
    when we write individual operations and functions, but we also use them when structuring
    our entire code base. Design patterns, as such, are hierarchical. They exist on
    the macro and micro scale of a code base. A singular code base can easily contain
    many design pattern within.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式在各种情境和规模下都是有用的。我们在编写单个操作和函数时使用它们，但我们在构建整个代码库结构时也使用它们。设计模式本身是分层的。它们存在于代码库的宏观和微观层面。一个单一的代码库很容易包含许多设计模式。
- en: 'In [Chapter 2](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml), *Tenets of Clean
    Code*, we spoke about familiarity as a crucial characteristic. A car mechanic
    opening the hood of a car will hope to see many familiar patterns: from the individual
    pieces of wiring and welding of Components to the larger construction of the cylinders,
    valves, and pistons. There is a certain layout they would expect to find and if
    it is not there, then they would be left scratching their heads, wondering how
    to approach whatever problem they''re trying to solve.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](fd19fa13-f04a-4e03-9bc3-ba318cacf731.xhtml)中，*《清洁代码的原则》*，我们谈到熟悉性是一个至关重要的特征。一个汽车技师打开汽车的引擎盖时，希望看到许多熟悉的模式：从独立的电线和组件的焊接到气缸、阀门和活塞的更大的构造。他们期望找到一定的布局，如果没有，他们将不知所措，想知道如何解决他们正在尝试解决的问题。
- en: 'Familiarity increases the maintainability and usability of our solutions. Consider
    the following directory structure and the displayed `logger.js` source code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉性增加了我们解决方案的可维护性和可用性。考虑以下目录结构和显示的`logger.js`源代码：
- en: '![](assets/9c3cb805-3237-4651-b5b4-4e65a6188a83.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9c3cb805-3237-4651-b5b4-4e65a6188a83.png)'
- en: 'What design patterns can we observe here? Let''s take a look at some examples:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到哪些设计模式？让我们看一些例子：
- en: The use of a top-level `app/` directory to contain all the source code
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶层`app/`目录来包含所有源代码
- en: The existence of **Models, Views, and Controllers** (**MVC**)
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型、视图和控制器**（MVC）的存在'
- en: The separation of utilities into its own directory (`utils/`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将实用程序分离到自己的目录中（`utils/`）
- en: The camel case naming of files (for example,`binarySearch.js`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件的驼峰命名（例如，`binarySearch.js`）
- en: The use of a Conventional Module pattern in `logger.js` (that is, exporting
    a plain object of methods)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logger.js`中使用传统模块模式（即导出一组方法的普通对象）'
- en: The use of `... && msgs.length` to confirm a nonzero (that is, truthy) length
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`... && msgs.length`来确认非零（即真值）长度
- en: Declaring constants at the top of a file (that is, `const ALL_LOGS_LEVEL`)
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件顶部声明常量（即`const ALL_LOGS_LEVEL`）
- en: (Possibly others...)
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可能还有其他的...）
- en: 'Design patterns are not just large, lofty architectural structures. They can
    exist in every part of our code base: the directory structure, the naming of files,
    and the individual expressions of our code. At every level, our usage of common
    patterns can increase our ability to express the problem domain, and increase
    the familiarity of our code to newcomers. Patterns exist within patterns.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式不仅仅是庞大而高远的架构结构。它们可以存在于我们代码库的每个部分：目录结构、文件命名和我们代码的个别表达。在每个层面上，我们对常见模式的使用都可以增加我们表达问题域的能力，并增加我们代码对新手的熟悉度。模式存在于模式之中。
- en: 'Using design patterns well can have beneficial effects on all of the tenets
    of clean code we covered previously—reliability, efficiency, maintainability,
    and usability:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 良好地使用设计模式可以对我们之前涵盖的清洁代码原则的所有要点产生有益影响——可靠性、效率、可维护性和可用性：
- en: '**Reliability**: A good design pattern will suit the problem domain and allow
    you to easily express your desired logic and data structures without too much
    complexity. The familiarity of your adopted design patterns will also enable other
    programmers to easily understand and improve upon the reliability of your code
    over time.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可靠性**：一个好的设计模式将适合问题域，并允许您轻松表达所需的逻辑和数据结构，而不会太复杂。您采用的设计模式的熟悉性也将使其他程序员能够轻松理解和随着时间改进代码的可靠性。'
- en: '**Efficiency**: A good design pattern will enable you to fuss less about how
    to structure your code base or your individual modules. It''ll enable you to spend
    more time worrying about the problem domain. Well-selected design patterns will
    also aid in making the interfaces between different pieces of code streamlined
    and understandable.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：一个好的设计模式将使你不必过多地担心如何构建代码库或个别模块。它将使你能够花更多的时间关注问题域。精心选择的设计模式还将有助于使不同代码片段之间的接口变得简洁和易懂。'
- en: '**Maintainability**: A good design pattern allows for easy adaptation. If there
    is a change of specification or a bug that needs to be fixed, the programmer can
    easily find the desired area of change/insertion and make the change without hassle.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可维护性**：一个好的设计模式可以轻松适应。如果有规范的变化或需要修复的错误，程序员可以轻松找到需要更改/插入的区域，并进行更改而不费力。'
- en: '**Usability**: A good design pattern is easy to understand due to its familiarity.
    A fellow programmer can easily comprehend the flow of the code and quickly make
    correct assertions about how it works and how they can make use of it. A good
    design pattern will also create a pleasant user experience, whether expressed
    via a programmatic API or a GUI.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：一个好的设计模式易于理解，因为它很熟悉。其他程序员可以轻松理解代码的流程，并快速做出正确的断言，了解它的工作原理以及如何使用它。一个好的设计模式还将为用户创造愉快的体验，无论是通过编程API还是GUI表达。'
- en: You can see that a lot of what makes design patterns useful is only actualized
    if we pick the right one. We'll be exploring a selection of popular design patterns
    and, for each, we'll discuss the types of situations they're suited to. This exploration
    should hopefully give you a good idea of what it means to select a good design
    pattern.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，设计模式的许多有用之处只有在选择正确的模式时才能实现。我们将探讨一些流行的设计模式，并讨论它们适用的情况。这种探索应该让你对选择一个好的设计模式有一个很好的理解。
- en: '**Be warned***:* just as good design proliferates via convention, so does bad
    design. We discussed the phenomenon of cargo culting in [Chapter 3](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml),
    *The Enemies of Clean Code*, and so we are not strangers to how such types of
    bad designs may spread, but it''s important to remain mindful of these traps when
    employing design patterns.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意**：好的设计通过惯例传播，坏的设计也是如此。我们在[第3章](4aede822-c58b-4e6b-81cd-ba27582e9aa7.xhtml)中讨论了“模仿神教”的现象，因此我们对这些类型的坏设计如何传播并不陌生，但在使用设计模式时保持警惕是很重要的。'
- en: Architectural design patterns
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构设计模式
- en: Architectural design patterns are the ways in which we tie our code together.
    If we have a dozen different modules, it is how those modules talk to each other
    that defines our architecture.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 架构设计模式是我们将代码联系在一起的方式。如果我们有十几个不同的模块，那么这些模块如何相互通信就定义了我们的架构。
- en: The architectural design patterns utilized in JavaScript code bases have changed
    massively over recent years. With the steady proliferation of popular frameworks
    such as React and Angular, we've seen code bases take on new conventions. The
    landscape is still very much shifting, so we shouldn't expect any specific standard
    to emerge any time soon. Nonetheless, most frameworks tend to follow the same
    broad architectural patterns.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，JavaScript代码库中使用的架构设计模式发生了巨大变化。随着React和Angular等流行框架的不断普及，我们看到代码库采用了新的约定。这个领域仍在不断变化，所以我们不应该指望任何特定的标准很快出现。尽管如此，大多数框架往往遵循相同的广泛的架构模式。
- en: An example of a popular architectural pattern is the separation of data logic
    and rendering logic. This is famously adopted by many different UI frameworks,
    albeit with different styles. This is likely due to the heritage of software UI
    and the early established pattern of MVC that eventually became the de facto approach.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流行的架构模式的例子是数据逻辑和渲染逻辑的分离。这被许多不同的UI框架所采用，尽管风格不同。这很可能是由于软件UI的传统和最终成为事实上的方法的MVC模式的传承。
- en: In this section, we'll be covering two famous architectural design patterns,
    MVC and its offshoot, **Model-View-ViewModel** (**MVVM**). Together, these should
    give us an awareness of the types of concerns that are typically separated and
    will hopefully inspire us to seek a similar level of clarity in the architectures
    we create.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍两种著名的架构设计模式，MVC及其分支**Model-View-ViewModel**（**MVVM**）。这些应该让我们意识到通常分离的关注点，并希望激励我们在创建架构时寻求类似的清晰度。
- en: MVC
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC
- en: 'MVC is characterized by a separation between these three concepts. An MVC architecture
    may involve many individual Models, Views, and Controllers that all work in concert
    to solve a given problem. Each of these parts can be described as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: MVC的特点是这三个概念之间的分离。MVC架构可能涉及许多单独的模型、视图和控制器，它们共同解决一个给定的问题。这些部分可以描述如下：
- en: '**The Model**: This describes the data and how business logic mutates that
    data. Changes in the data will manifest in changes to the View.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：描述数据以及业务逻辑如何改变数据。数据的变化将导致视图的变化。'
- en: '**The View**: This describes how the Model is rendered (its format, layout,
    and appearance) and will invoke the Controller whenever there is an action that
    needs to occur, possibly in response to a user event.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：描述模型如何呈现（其格式、布局和外观），并在需要发生动作时调用控制器，可能是响应用户事件。'
- en: '**The Controller**: This accepts instructions from the View and informs the
    Model what actions or changes to carry out, which will go on to affect whatever
    is rendered to the user via the View.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制器**：接受来自视图的指令，并告知模型要执行哪些操作或更改，这将影响通过视图呈现给用户的内容。'
- en: 'We can observe the flow of control in the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图表中观察控制流：
- en: '![](assets/d5ca9398-52c3-4cdd-b323-74d3941bd397.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d5ca9398-52c3-4cdd-b323-74d3941bd397.png)'
- en: The MVC pattern provides us with a way to separate our various concerns. It
    prescribes where we should put logic about business decisions (that is, in Models)
    and where we should put logic about displaying things to the user (that is, Views).
    Additionally, it gives us the Controller, which enables these two concerns to
    talk to each other. The separation that MVC fosters is hugely beneficial as it
    means our fellow programmers can easily discern where to make required changes
    or fixes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: MVC模式为我们提供了一种分离各种关注点的方法。它规定了我们应该将业务决策逻辑（即在模型中）放在哪里，以及我们应该将关于向用户显示事物的逻辑（即在视图中）放在哪里。此外，它还给我们提供了控制器，使这两个关注点能够相互交流。MVC所促进的分离是非常有益的，因为这意味着我们的同行程序员可以很容易地辨别在哪里进行所需的更改或修复。
- en: MVC was originally posed in 1978 by Trygve Reenskaug while working at Xerox
    PARC. Its original purpose was to support the user's illusion of seeing and manipulating
    the domain information directly. At the time, this was quite revolutionary, but
    we now, as end users, take such UIs (and their transparent relation to their data)
    for granted.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: MVC最初是由Trygve Reenskaug在1978年在施乐帕克（Xerox PARC）工作时提出的。它最初的目的是支持用户直接看到和操作域信息的幻觉。当时，这是相当革命性的，但现在，作为最终用户，我们认为这样的用户界面（以及它们与数据的透明关系）是理所当然的。
- en: A working example of MVC
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC的一个工作示例
- en: To illustrate how an implementation of MVC might look in JavaScript, let's build
    a very simple program. It will be a basic mutable number application that renders
    a simple UI where the user can see the current number and choose to update it
    via either incrementing or decrementing its value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明MVC在JavaScript中的实现可能是什么样子，让我们构建一个非常简单的程序。它将是一个基本的可变数字应用程序，可以呈现一个简单的用户界面，用户可以在其中查看当前数字，并选择通过增加或减少其值来更新它。
- en: 'First, we can implement the logic and containment of our data using a Model:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以使用模型来实现数据的逻辑和包含：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In addition to storing the value itself, this class also accepts and relies
    upon a callback function called `onChangeCallback`. This callback function will
    be provided by the Controller and will be called whenever the value changes. This
    is necessary so that we can kick off a re-render of the View if the Model changes.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了存储值本身，这个类还接受并依赖于一个名为“onChangeCallback”的回调函数。这个回调函数将由控制器提供，并在值更改时调用。这是必要的，以便我们可以在模型更改时启动视图的重新渲染。
- en: 'Next, we need to build the Controller, which will act as a very simple bridge
    (or glue) between `view` and `model`. It registers the necessary callbacks to
    know when either the user requests a change via `view` or the underlying data
    of the `model` changes:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要构建控制器，它将作为“视图”和“模型”之间非常简单的桥梁（或粘合剂）进行操作。它注册了必要的回调函数，以便知道用户通过“视图”请求更改或“模型”的基础数据发生更改时：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our `view` is responsible for retrieving data from `model` and rendering it
    to the user. To do this, it creates a DOM hierarchy in which the data will sit.
    It also listens for and escalates user events to `controller` when either the
    `increment` or `decrement` button is clicked:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的“视图”负责从“模型”中检索数据并将其呈现给用户。为此，它创建了一个DOM层次结构，其中数据将位于其中。它还在“增量”或“减量”按钮被点击时监听并升级用户事件到“控制器”：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This is quite a lengthy View as we're having to create its DOM representation
    manually. Many modern frameworks (React, Angular, Svelte, and so on) allow you
    to declaratively express your hierarchy using either plain HTML or a hybrid syntax
    such as JSX (a syntax extension to JavaScript itself that permits XML-like tags
    within JavaScript code).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当冗长的视图，因为我们必须手动创建其DOM表示。许多现代框架（React、Angular、Svelte等）允许您使用纯HTML或混合语法（例如JSX，它是JavaScript本身的语法扩展，允许在JavaScript代码中使用类似XML的标记）来声明性地表达您的层次结构。
- en: 'This *View* has two rendering methods: `renderInitial` will carry out the initial
    render, which sets up the DOM elements, and then the `renderUpdate` method is
    responsible for updating the number whenever it changes.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个*视图*有两种渲染方法：“renderInitial”将进行初始渲染，设置DOM元素，然后“renderUpdate”方法负责在数字更改时更新数字。
- en: 'Tying this all together, our simple program would be initialized like so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些联系在一起，我们的简单程序将初始化如下：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`view` is given access to `model` so that it can retrieve the data to render.
    `controller` is given to both `model` and `view` so that it can glue them together
    by setting up the appropriate callbacks.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: “视图”可以访问“模型”，以便可以检索数据进行渲染。“控制器”分别提供给“模型”和“视图”，以便通过设置适当的回调将它们粘合在一起。
- en: 'In the case of a user clicking the `+` (increment) button, the following process
    would kick off:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户点击“+”（增量）按钮的情况下，将启动以下过程：
- en: The DOM click event from `incrementButton` is received by the View
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “增量按钮”的DOM点击事件由视图接收
- en: The View fires its `onIncrementCallback()`, listened to by the Controller
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图触发其“onIncrementCallback()”，由控制器监听
- en: The Controller instructs the Model to `increment()`
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器指示模型`increment()`
- en: The Model calls its mutation callback, that is, `onChangeCallback`, listened
    to by the Controller
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模型调用其变异回调，即“onChangeCallback”，由控制器监听
- en: The Controller instructs the View to re-render
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器指示视图重新渲染
- en: You may be wondering why we bother with the separation between the Controller
    and the Model. Why can't the *View* just communicate with the Model directly and
    vice versa? Well, it can! But if we did that, we'd be polluting both our *View*
    and our *Model* with more logic and hence more complexity. We could equally just
    place everything in the *View* and have no Model, but you can imagine how unwieldy
    that would get. Fundamentally, the degree and quantity of separation will vary
    with every project you pursue. At its core, MVC teaches us about the general idea
    of how to separate the problem domain from its presentation. How we wield this
    separation is up to us.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会想为什么我们要在控制器和模型之间进行分离。为什么*视图*不能直接与模型通信，反之亦然？其实可以！但如果我们这样做，我们会在*视图*和*模型*中都添加更多的逻辑，从而增加更多的复杂性。我们也可以把所有东西都放在*视图*中，而没有模型，但你可以想象那会变得多么笨重。从根本上讲，分离的程度和数量将随着你追求的每个项目而变化。在本质上，MVC教会我们如何将问题域与其呈现分离。我们如何使用这种分离取决于我们自己。
- en: Since 1978, when MVC was first coined, many adaptations of it have surfaced,
    but its central theme of separation between *Model* and *View* has persisted through
    the decades. Consider the architectural design of a React application. It includes
    Components, which contain the logic for rendering state, and typically will include
    several domain-specific reducers, which take actions (for example, *user has clicked
    something!*) and derive state from those actions.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 自1978年MVC首次被提出以来，它的许多适配版本已经出现，但其将*模型*和*视图*分离的核心主题已经持续了几十年。考虑一下React应用程序的架构设计。它包括组件，其中包含呈现状态的逻辑，并且通常会包含几个特定领域的reducer，它们会根据动作（例如*用户点击了某些东西！*）来推导状态。
- en: 'This architecture looks surprisingly similar to traditional MVC:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构看起来与传统的MVC非常相似：
- en: '![](assets/3fb419a2-2ce5-4af8-a214-a7ad4d6d9d45.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3fb419a2-2ce5-4af8-a214-a7ad4d6d9d45.png)'
- en: MVC, as a general guiding pattern, has impacted the design of countless frameworks
    and code bases throughout the last few decades, and it will continue to do so.
    Not every adaptation, reproduction, or MVC will abide by the original description
    posed in 1978 but, usually, these adaptations will stay true to the centrally
    important theme of separating a Model from its View and of having a View be a
    reflection (or even, a derivation) of a Model.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个通用的指导模式，MVC在过去几十年中影响了无数框架和代码库的设计，并将继续如此。并非每个适配、复制或MVC都会遵循1978年提出的原始描述，但通常这些适配都会忠于将模型与视图分离以及使视图成为模型的反映（甚至是派生）的核心重要主题。
- en: MVVM
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVVM
- en: 'MVVM is similar in spirit to its ancestor, MVC. It prescribes a strict separation
    between the underlying business logic and data that drives a program and the rendering
    of that data:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM的精神与其祖先MVC相似。它规定了程序的基础业务逻辑和驱动程序的数据与数据的呈现之间严格的分离：
- en: '**The Model**: This describes the data and how business logic mutates that
    data. Changes in the data will manifest in changes to the **View**.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：描述数据以及业务逻辑如何改变数据。数据的变化将体现在**视图**中。'
- en: '**The View**: This describes how the **Model** is rendered (its structure,
    layout, and appearance) and will invoke the **Data Binding** mechanism of the
    **ViewModel** whenever there is an action that needs to occur, possibly in response
    to a user event.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：描述**模型**的呈现方式（其结构、布局和外观），并且在需要发生动作时会调用**视图模型**的**数据绑定**机制，可能是响应用户事件。'
- en: '**The ViewModel**: This is the glue between the **Model** and the **View**
    and enables them to talk to each other via a **Data Binding** mechanism. This
    mechanism tends to vary a lot between implementations.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图模型**：这是**模型**和**视图**之间的粘合剂，并通过**数据绑定**机制使它们能够相互通信。这种机制在不同的实现中往往有很大的变化。'
- en: 'The relationship between these parts is illustrated in the following diagram:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分之间的关系如下图所示：
- en: '![](assets/e3109724-cf07-41a4-8303-a04730b7f4ce.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e3109724-cf07-41a4-8303-a04730b7f4ce.png)'
- en: The MVVM architecture is more popular in frontend JavaScript as it suits the
    need of having a constantly updated **View**, while traditional MVC is more popular
    on the backend as it caters well to the simple render-once nature of most HTTP
    responses.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM架构在前端JavaScript中更受欢迎，因为它适应了需要不断更新的**视图**，而传统的MVC在后端更受欢迎，因为它很好地满足了大多数HTTP响应只需简单渲染一次的特性。
- en: Within MVVM, the data binding between the **ViewModel** and the **View** usually
    uses DOM events to track user intent and then mutates data on the **Model**, which
    then emits mutation events of its own that can be listened for by the **ViewModel**,
    resulting in the **View** being constantly kept up to date with changing data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM中，**视图模型**和**视图**之间的数据绑定通常使用DOM事件来跟踪用户意图，然后在**模型**上改变数据，**模型**再发出自己的变化事件，**视图模型**可以监听这些事件，从而使**视图**始终保持与数据的变化同步。
- en: Many frameworks will have their own adaptation of data-binding. Angular, for
    example, allows you to specify in your HTML templates a custom attribute called
    `ng-model`, which will tie a user input element such as `<input>` to a given data
    model, allowing data to flow in both directions. If the Model is updated, `<input>`
    will be updated to reflect that and vice versa.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 许多框架都会有自己的数据绑定适配。例如，Angular允许您在HTML模板中指定一个名为`ng-model`的自定义属性，它将把用户输入元素（如`<input>`）与给定的数据模型绑定在一起，从而实现数据的双向流动。如果模型更新了，`<input>`也会更新以反映这一点，反之亦然。
- en: MV* and the nature of software
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MV*和软件的性质
- en: 'Throughout your time as a JavaScript programmer, you will encounter variations
    of both MVC and MVVM. As patterns, they are infinitely applicable as they are
    concerned with the very basic tenets of a software system: the input of data into
    a system, the processing of that data, and the subsequent output of that processed
    data. There are a few other ways we could choose to architect these tenets into
    a code base, but it''s likely that, in the end, almost every time, we''ll end
    up with a system that delineates these concerns in a spirit similar to MVC (or
    MVVM).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在您作为JavaScript程序员的时间里，您将遇到MVC和MVVM的各种变体。作为模式，它们是无限适用的，因为它们关注的是软件系统的非常基本的原则：将数据输入系统，处理该数据，然后输出处理后的数据。我们可以选择将这些原则架构到代码库中的其他几种方式，但最终，几乎每次，我们最终都会得到一个类似MVC（或MVVM）的系统，它以类似的精神划分了这些关注点。
- en: 'Now that we have a firm idea of how we might architect a code base and the
    types of delineations that characterize a well-designed architecture, we can explore
    the individual pieces of that code base: the modules themselves.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何构建代码库以及表征良好设计架构的类型有了明确的想法，我们可以探索代码库的各个部分：模块本身。
- en: JavaScript modules
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript模块
- en: 'In JavaScript, the word module has changed over the years. A module used to
    be any piece of code that was distinct and self-contained. A few years ago, you
    might have expressed several modules within the same file like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模块这个词多年来发生了变化。模块曾经是任何独立且自包含的代码片段。几年前，您可能会在同一个文件中表达几个模块，就像这样：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Nowadays, however, the word *module* tends to refer to Modules (capital *M)*
    as prescribed by the ECMAScript specification. These Modules are distinct files
    imported and exported across a code base via `import` and `export` statements.
    Using such Modules, we might have a `DropdownComponent.js` file that looks like
    this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今，*module*这个词倾向于指的是ECMAScript规范所规定的Modules（大写*M)*。这些模块是通过`import`和`export`语句在代码库中导入和导出的不同文件。使用这样的模块，我们可能有一个`DropdownComponent.js`文件，看起来像这样：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, it uses the `export` statement to export its class. If we wish
    to use this class as a dependency, we would import it like so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，它使用`export`语句来导出其类。如果我们希望将这个类用作依赖项，我们将这样导入它：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ECMAScript Modules are slowly gaining more support across various environments.
    To make use of them within the browser, you can provide an *entry* script tag
    with a type of *modul**e*, that is, `<script type="module" />`. Within Node.js,
    at the time of writing, ES Modules are still an experimental feature, so you can
    either rely on the old style of importing (`const thing = require('./thing')`)
    or you can enable *experimental modules* by using the `--experimental-modules`
    flag and using the `.mjs` extension on all of your JavaScript files.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript模块正在逐渐在各种环境中得到更多支持。要在浏览器中使用它们，可以提供一个类型为*module*的*entry*脚本标签，即`<script
    type="module" />`。在Node.js中，目前，ES模块仍然是一个实验性功能，因此您可以依赖旧的导入方式（`const thing = require('./thing')`），或者可以通过使用`--experimental-modules`标志并在所有JavaScript文件上使用`.mjs`扩展名来启用*实验性模块*。
- en: 'Both the `import` and `export` statements permit a variety of syntaxes. These
    allow you to define the names of what you''re exporting or importing. In a scenario
    where a Module is only exporting one item, it is conventional to use `export default
    [item]` as we have done in `DropdownComponent.js`. This ensures that any dependents
    of the Module can import it and name it as they wish, as shown in this example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`和`export`语句都允许各种语法。这使您可以定义要导出或导入的名称。在只导出一个项目的情况下，惯例上使用`export default
    [item]`，就像我们在`DropdownComponent.js`中所做的那样。这确保了模块的任何依赖项都可以导入它并根据需要命名它，就像这个例子中所示的那样：'
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In contrast to this, you can specifically name your exports by declaring them
    within curly braces and using the `as` keyword:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，您可以通过在花括号内声明它们并使用`as`关键字来明确命名您的导出项：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will mean that any importers will need to specifically specify the name
    of `TheDropdown`, like so:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何导入者都需要明确指定`TheDropdown`的名称，如下所示：
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Alternatively, you can export named items by having specific declarations inline
    with your `export` statements, such as `var`, `const`, `let`, function declarations,
    or class definitions:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在`export`语句中具体声明来导出命名项，例如`var`、`const`、`let`、函数声明或类定义：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'On the importing side, such named exports can be imported by, again, using
    curly braces:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入方面，这些命名导出可以通过再次使用花括号来导入：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When importing, you can also optionally designate the local name of that import
    with the `as` keyword to have its local name be different to its exported named
    (this is especially useful in cases of naming conflicts):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入时，您还可以选择使用`as`关键字指定该导入的本地名称，使其本地名称与其导出的名称不同（在命名冲突的情况下，这是特别有用的）：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s conventional to aggregate exports in areas of your code that provide
    several related abstractions. For example, if you have composed a small Component
    library, where each Component exports itself as `default`, then you could have
    `index.js` that exposes all of the Components together:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的代码中，将导出聚合在一起的区域通常是惯例，这些区域提供了几个相关的抽象。例如，如果您已经组合了一个小的组件库，其中每个组件都将自己作为`default`导出，那么您可以有一个`index.js`，将所有组件一起公开：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In Node.js, an `index.js`/`index.mjs` file is imported by default if you try
    to import an entire directory. That is, if you import `'./components/'`, it would
    first look for the index file and, if available, would import it. In the browser,
    no such convention currently exists. All imports must be fully qualified filenames.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中，默认情况下，如果尝试导入整个目录，将导入`index.js`/`index.mjs`文件。也就是说，如果您导入`'./components/'`，它首先会查找索引文件，如果可用，会导入它。在浏览器中，目前没有这样的约定。所有导入必须是完全限定的文件名。
- en: 'We can, very conveniently, now import our entire set of Components by using
    the asterisk with our `import` statement:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在`import`语句中使用星号来非常方便地导入我们的整套组件：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There are some additional nuances and complexities around modules in JavaScript,
    especially when considering the legacies of Node.js, that we, unfortunately, don't
    have time to go into, but what we've covered so far should give you a good enough
    coverage of the topic to be productive and nicely paves the way for us to explore
    the topic of modular design patterns.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，模块存在一些额外的细微差别和复杂性，特别是考虑到Node.js的遗留问题，不幸的是，我们没有时间深入讨论，但到目前为止，我们所涵盖的内容应该足够让你对这个主题有一个很好的了解，以便提高生产力，并为我们探讨模块化设计模式铺平道路。
- en: Modular design patterns
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化设计模式
- en: Modular design patterns are the structures and syntactic conventions we use
    to craft individual modules. We would usually employ these patterns within distinct
    JavaScript Modules. Each distinct file should offer up and export a specific abstraction.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 模块化设计模式是我们用来构建单个模块的结构和语法约定。我们通常会在不同的JavaScript模块中使用这些模式。每个不同的文件应该提供并导出一个特定的抽象。
- en: If you find yourself using these patterns several times within the same file,
    then it may be worth splitting them out. The directory and file structure of a
    given code base should ideally reflect its landscape of abstractions. You shouldn't
    have several abstractions crammed into a single file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己在同一个文件中多次使用这些模式，那么将它们拆分出来可能是值得的。给定代码库的目录和文件结构应该理想地反映其抽象的景观。您不应该将多个抽象塞进一个文件中。
- en: Constructor patterns
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数模式
- en: The Constructor pattern uses a singular constructor and then manually fills
    its `prototype` with methods and properties. This was the traditional approach
    for creating classical OOP-like classes in JavaScript before the class definition
    syntax existed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数模式使用一个构造函数，然后手动填充其`prototype`方法和属性。这是在类定义语法存在之前，在JavaScript中创建经典面向对象类的传统方法。
- en: 'Typically, it begins with the definition of a constructor as a function declaration:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，它以构造函数的定义作为函数声明开始：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This would then be followed by assigning individual methods to the prototype:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会跟着将单独的方法分配给原型：
- en: '[PRE25]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or it would be followed by replacing the entire `prototype` with an object
    literal:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者它将被跟随着用一个对象字面量替换整个`prototype`：
- en: '[PRE26]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The latter approach tends to be preferred as it''s more encapsulated and succinct.
    Nowadays, of course, if you wished to use the Constructor pattern, you would likely
    opt for method definitions as they take up less space than individual key-value
    pairs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种方法往往更受青睐，因为它更封装和简洁。当然，现在，如果您希望使用构造函数模式，您可能会选择方法定义，因为它们占用的空间比单独的键值对少：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The instantiation of a constructor would be via the `new` keyword:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的实例化将通过`new`关键字进行：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This creates a new object that has an internal `[[Prototype]]` of the constructor's
    `prototype` (that is, our object, which contains `getNumberOfPages`, `renderFrontCover`,
    and `renderBackCover`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有构造函数的`prototype`的内部`[[Prototype]]`（也就是我们的对象，其中包含`getNumberOfPages`、`renderFrontCover`和`renderBackCover`）。
- en: If you're struggling to recall the prototypal mechanisms that underlie constructors
    and instantiation, then please revisit [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitives and Built-in Types*, and, specifically, the section called *The prototype*.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对构造函数和实例化的原型机制记忆不太清楚，请重新阅读[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)，*基本类型和内置类型*，特别是名为*原型*的部分。
- en: When to use the Constructor pattern
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用构造函数模式
- en: The Constructor pattern is useful in scenarios where you wish to have an abstraction
    that encapsulates the concept of a noun, that is, a thing that would make sense
    to have an instance of. Examples may include `NavigationComponent` or `StorageDevice`.
    The Constructor pattern allows you to create abstractions akin to traditional
    OOP classes. So, if you're coming from a classical OOP language, then you can
    feel free to use the Constructor pattern where you may have previously used classes.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数模式在您希望有一个封装名词概念的抽象的情况下非常有用，也就是说，一个有意义的实例。例如`NavigationComponent`或`StorageDevice`。构造函数模式允许您创建类似于传统面向对象编程类的抽象。因此，如果您来自经典的面向对象编程语言，那么您可以随意使用构造函数模式，以前可能使用类。
- en: 'If you''re not sure whether the Constructor pattern is applicable, consider
    whether the following questions are true:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定构造函数模式是否适用，请考虑以下问题是否属实：
- en: Is the concept expressible as a noun?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念可以表达为名词吗？
- en: Does the concept require construction?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念需要构造吗？
- en: Will the concept vary between instances?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概念在实例之间会有变化吗？
- en: If the concept you're abstracting does not fulfill any of the preceding criteria,
    then you may want to consider another modular design pattern. An example of this
    may be a utility module that has various helper methods. Such a module may not
    require construction since it is essentially a collection of methods, and these
    methods and their behaviors would not vary between instances.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你抽象出的概念不满足以上任何标准，那么你可能需要考虑另一种模块化设计模式。一个例子是一个具有各种辅助方法的实用程序模块。这样的模块可能不需要构造，因为它本质上是一组方法，这些方法及其行为在实例之间不会有变化。
- en: The Constructor pattern has largely fallen out of favor since the introduction
    of class definitions into JavaScript, which allow you to declare classes in a
    fashion much more akin to classical OOP languages (that is, `class X extends Y
    {...}`). Skip ahead to *The* *Class pattern* section to see this in action!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 自从JavaScript引入类定义以来，构造函数模式已经大多不受青睐，类定义允许您以更类似于经典面向对象编程语言的方式声明类（即`class X extends
    Y {...}`）。跳转到*类模式*部分，看看这个模式是如何运作的！
- en: Inheritance with the Constructor pattern
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数模式中的继承
- en: To achieve inheritance with the Constructor pattern, you need to manually make
    your `prototype` objects inherit from your parent constructor's `prototype`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用构造函数模式实现继承，您需要手动使您的`prototype`对象从父构造函数的`prototype`继承。
- en: 'At the risk of over simplifying, we''ll illustrate this with the classic example
    of an `Animal` super-class and a `Monkey` subclass. Here is our definition of
    `Animal`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 冒着过于简化的风险，我们将以`Animal`超类和`Monkey`子类的经典示例来说明这一点。这是我们对`Animal`的定义：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Technically, to achieve inheritance, we want to create an object that has `[[Prototype]]`
    of `Animal.prototype` prototype and then use that newly-created object as our
    sub-class `prototype` subclass. The end goal is a prototypal tree that looks like
    this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，为了实现继承，我们希望创建一个具有`Animal.prototype`原型的`[[Prototype]]`的对象，然后将这个新创建的对象用作我们的子类`prototype`子类。最终目标是一个看起来像这样的原型树：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The easiest way to create an object with a given `[[Prototype]]` is with `Object.create(ThePrototype)`.
    Here, we can use it to extend `Animal.prototype` and assign the result to `Monkey.prototype`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Object.create(ThePrototype)`是创建具有给定`[[Prototype]]`的对象的最简单方法。在这里，我们可以使用它来扩展`Animal.prototype`并将结果分配给`Monkey.prototype`：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can then freely assign methods and properties to this new object:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以自由地将方法和属性分配给这个新对象：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we now try to instantiate `Monkey`, then we should be able to access not
    only its own methods and properties but also those we inherited from `Animal.prototype`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试实例化`Monkey`，那么我们应该能够访问不仅其自己的方法和属性，还有我们从`Animal.prototype`继承的方法和属性：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '**Remember**, this only works because `Monkey.prototype` (that is, `[[Prototype]]`
    of every `Monkey` instance) does itself have `[[Prototype]]` of `Animal.prototype`.
    And, as we know, if a property cannot be found on a given object, then it''ll
    be looked for on its `[[Prototype]]` (*if available*).'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**记住**，这只能工作是因为`Monkey.prototype`（也就是每个`Monkey`实例的`[[Prototype]]`）本身具有`Animal.prototype`的`[[Prototype]]`。而且，正如我们所知，如果在给定对象上找不到属性，那么它将在其`[[Prototype]]`上寻找（*如果可用*）。'
- en: 'It can be quite cumbersome to individually set a prototype''s properties and
    methods one at a time, as shown in this example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一次设置一个原型的属性和方法可能会非常麻烦，就像在这个例子中所示的那样：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Due to this, another pattern has emerged to make things easier: using `Object.assign()`.
    This allows us to set properties and methods in bulk as object literals, and it
    means we can make use of the method definition syntax as well:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一点，另一种模式已经出现，使事情变得更容易：使用`Object.assign()`。这允许我们以对象文字的形式批量设置属性和方法，并且意味着我们也可以利用方法定义语法：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`Object.assign` here will assign any properties from its second (and third,
    fourth, and so on) arguments to the object passed as the first argument. This
    provides us with a more succinct syntax for adding properties to our child `prototype`
    object.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object.assign`将会将其第二个（第三个、第四个等等）参数中的任何属性分配给作为第一个参数传递的对象。这为我们提供了一种更简洁的语法，用于向我们的子`prototype`对象添加属性。'
- en: The Constructor pattern and its inheritance conventions have largely lost favor
    due to the newer class definition syntax, which allows a more succinct and simpler
    way to harness prototypal inheritance in JavaScript. As such, the very next thing
    we will explore is the Class pattern, which uses this newer syntax.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 由于较新的类定义语法，构造函数模式及其继承约定已经大大失宠，它允许以更简洁和简单的方式在JavaScript中利用原型继承。因此，我们将要探索的下一个内容就是类模式，它使用了这种较新的语法。
- en: '**Reminder**: For a more thorough refresher on `[[Prototype]]` (which is vital
    to understanding constructors and classes in JavaScript), you should re visit
    the section on *The prototype* in [Chapter 6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml),
    *Primitives and Built-in Types*. A lot of the design patterns in this chapter
    make use of the prototype mechanism, so it''s useful to have it fresh in your
    mind.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**提醒**：要更彻底地了解`[[Prototype]]`（这对于理解JavaScript中的构造函数和类至关重要），您应该重新访问[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)中关于*原型*的部分，*基本类型和内置类型*。本章中的许多设计模式都使用了原型机制，因此将其牢记在心是很有用的。'
- en: The Class pattern
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类模式
- en: The Class pattern, which relies on the newer class definition syntax, has largely
    replaced the Constructor pattern. It involves the creation of classes, analogous
    to classical OOP languages, although behind the scenes it uses the same prototypal
    mechanism that the Constructor pattern uses. So, it can be said that it's just
    a bit of extra syntactic *sugar* to make the language a bit more expressive.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式依赖于较新的类定义语法，已经在很大程度上取代了构造函数模式。它涉及创建类，类似于经典的面向对象编程语言，尽管在幕后它使用了与构造函数模式相同的原型机制。因此，可以说这只是一点额外的语法*糖*，使语言更加表达。
- en: 'Here is an example of a basic class that abstracts the concept of a name:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个抽象名称概念的基本类的示例：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The creation of a class via this syntax is effectively the creation of a constructor
    with an attached prototype, hence the following code is exactly equivalent:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种语法创建类实际上是创建一个带有附加原型的构造函数，因此以下代码是完全等效的：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Using the Class pattern is certainly aesthetically preferable to the clunky
    and older Constructor pattern, but do not be misled! Behind the scenes, exactly
    the same mechanisms are at play.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类模式在美学上确实比笨重且陈旧的构造函数模式更可取，但不要被误导！在幕后，完全相同的机制正在发挥作用。
- en: When to use the Class pattern
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用类模式
- en: 'The Class pattern, much like the Constructor pattern, is useful when you have
    a self-contained concept that fulfills the following criteria:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式，就像构造函数模式一样，在满足以下标准的自包含概念时非常有用：
- en: The concept is expressible as a noun
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个概念可以表示为一个名词
- en: The concept requires construction
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个概念需要构建
- en: The concept will vary between instances of itself
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个概念将在其自身的实例之间变化
- en: 'Here are some examples of concepts that abide by these criteria and are hence
    reasonable to express via the Class pattern:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些符合这些标准并因此可以通过类模式表达的概念的示例：
- en: A database record (represents a piece of data and allows inquiry and manipulation)
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库记录（表示一条数据并允许查询和操作）
- en: A todo item component (represents a todo item and allows it to be rendered)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 待办事项组件（表示待办事项并允许其被渲染）
- en: A binary tree (represents a binary-tree data structure)
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二叉树（表示二叉树数据结构）
- en: Typically such cases will stick out quite obviously to you. If you're having
    trouble, consider the use cases of your abstraction and try to write some consumer
    code, that is, pseudo code that utilizes your abstraction. If it seems sensible
    and doesn't feel too awkward to use, then you've probably landed on a good pattern.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的情况通常会很明显地显露出来。如果你遇到麻烦，请考虑你的抽象的用例，并尝试编写一些消费者代码，也就是使用你的抽象的伪代码。如果它看起来合理，使用起来不会太尴尬，那么你可能已经找到了一个好的模式。
- en: Static methods
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'Static methods and properties can be declared by using the `static` keyword:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和属性可以通过使用`static`关键字声明：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'These properties and methods could also easily be added after the initial class
    definition:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性和方法也可以在初始类定义之后轻松添加：
- en: '[PRE39]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Static methods are useful when you have a method or property whose functionality
    and existence are semantically related to the entire class as opposed to a singular
    instance.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法在整个类的语义上与单个实例不同，因此在这种情况下非常有用。
- en: Public and private fields
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 公共和私有字段
- en: 'To declare a public field (that is, a property) on your instance, you can simply
    declare this within the class definition syntax in line:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要在实例上声明公共字段（即属性），您可以在类定义语法中简单地声明它：
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'These fields are initialized for each instance and are, therefore, mutable
    on the instance itself. They''re most useful when you need to define some sensible
    default for a given property. This can then be easily overridden within the constructor:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段为每个实例初始化，并且因此在实例本身上是可变的。当您需要为给定属性定义一些合理的默认值时，它们最有用。然后可以在构造函数中轻松地覆盖它们。
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You can also define private fields by prefixing their identifier with a `#`
    symbol:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在其标识符前加上`#`符号来定义私有字段：
- en: '[PRE42]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Traditionally, JavaScript had no concept of private fields, so programmers opted
    instead to prefix properties intended as private with one or more underscores
    (for example, `__somePropertyName`). This was understood as a social contract
    where other programmers would not mess with these properties (knowing that doing
    so might break things in unexpected ways).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，JavaScript没有私有字段的概念，因此程序员选择用一个或多个下划线作为前缀来表示私有属性（例如，`__somePropertyName`）。这被理解为一种社会契约，其他程序员不会干扰这些属性（知道这样做可能会以意想不到的方式破坏事情）。
- en: 'Private fields are only accessible by the class itself. Sub-classes do not
    have access:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段只能被类本身访问。子类无法访问：
- en: '[PRE43]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Private fields should be used with extreme caution as they can severely limit
    the extensibility of your code, hence increasing its rigidity and lack of flexibility.
    If you use a private field, you should ensure that you have considered the consequences.
    It may be the case that what you need is, in fact, just a pseudo-private field,
    prefixed with an underscore (for example, `_private`) or another obscure piece
    of punctuation (for example, `$_private`). Doing this will, by convention, ensure
    that fellow programmers making use of your interface will (hopefully) understand
    that they should not make use of the field publicly. If they do so, then the implication
    is that they may break things. If they wish to extend your class with their own
    implementation, then they can make use of your private field freely.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 私有字段应该极度谨慎地使用，因为它们可能严重限制代码的可扩展性，从而增加其刚性和缺乏灵活性。如果您使用私有字段，您应该确保已经考虑了后果。也许你需要的是一个伪私有字段，实际上只是一个带有下划线前缀的字段（例如，`_private`）或另一个不常见的标点符号（例如，`$_private`）。这样做将会按照惯例确保使用您接口的其他程序员（希望）理解他们不应该公开使用该字段。如果他们这样做，那么暗示着他们可能会破坏事情。如果他们希望用自己的实现扩展您的类，那么他们可以自由地使用您的私有字段。
- en: Extending classes
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展类
- en: 'Inheritance within the Class pattern can very simply be achieved by using the `class
    ... extends` syntax like so:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式内的继承可以通过使用`class ... extends`语法来非常简单地实现：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will ensure that any instance of `Tiger` will have `[[Prototype]]`, which
    itself has `[[Prototype]]` of `Animal.prototype`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保`Tiger`的任何实例都将具有`[[Prototype]]`，它本身具有`Animal.prototype`的`[[Prototype]]`。
- en: '[PRE45]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, we have confirmed that each new instance of `Tiger` has `[[Prototype]]`
    of `Tiger.prototype` and that `Tiger.prototype` inherits from `Animal.prototype.`
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经确认`Tiger`的每个新实例都有`Tiger.prototype`的`[[Prototype]]`，并且`Tiger.prototype`继承自`Animal.prototype`。
- en: Mixing-in classes
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合类
- en: Conventionally, an extension is used not only to create semantic sub-classes
    but also to provide mixins of methods. JavaScript provides no native mixing-in
    mechanism so to achieve it you, either need to augment the prototype after the
    definition or effectively inherit from your mixins (as if they are superclasses).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，扩展不仅用于创建语义子类，还用于提供方法的混入。JavaScript没有提供原生的混入机制，因此为了实现它，您需要在定义之后增加原型，或者有效地从您的混入中继承（就好像它们是超类一样）。
- en: 'Augmenting a `prototype` with your mixins is the simplest approach. We can
    achieve this by specifying mixins as objects and then adding them to `prototype`
    of a class via a convenient method such as `Object.assign`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将混入作为对象指定，然后通过方便的方法（例如`Object.assign`）将它们添加到类的`prototype`中，我们可以最简单地使用`prototype`来扩充我们的混入。
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This approach, however, does not allow `MyClass` to override its own mixin
    methods:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法不允许`MyClass`覆盖自己的混合方法：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is expected behavior but creates a headache for us in some cases. Therefore,
    to achieve a more generalized mixin approach, we can explore a different mechanism.
    Instead of directly *mixing-in* methods to an existing `prototype` object, we
    can use inheritance. This can most easily be achieved by so-called *Subclass Factories.*
    These are essentially just functions that themselves return a class that extends
    a specified super-class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的行为，但在某些情况下会给我们带来麻烦。因此，为了实现更通用的混合方法，我们可以探索不同的机制。我们可以使用继承来实现这一点，这最容易通过所谓的*子类工厂*来实现。这些本质上只是返回一个扩展指定超类的类的函数：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here''s an example of how it might work in reality:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它在现实中可能的工作方式的一个例子：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can additionally implement a helper to combine any number of these *Subclass
    Factories*. It can do so by constructing a chain (or tree) of `[[Prototype]]`
    links that is as long as the list of `mixins` we provide:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以实现一个辅助程序来组合任意数量的这些*子类工厂*。它可以通过构建与我们提供的`mixins`列表一样长的`[[Prototype]]`链接的链（或树）来实现：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note how we have the default `base` class of our mixin reduction as `Object`.
    This is to ensure that `Object` is always at the top of our inheritance tree (and
    that we're not creating pointless intermediary classes).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的mixin减少的默认`base`类是`Object`。这是为了确保`Object`始终位于我们的继承树的顶部（并且我们不会创建无意义的中间类）。
- en: 'And here''s how we would make use of our `mixin` helper: first, we''d define
    our sub-class factories (that is, the actual mixins):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用我们的`mixin`助手：首先，我们将定义我们的子类工厂（即实际的mixin）：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we can construct a class definition using both of these mixins via the
    `mixin` helper:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过`mixin`助手使用这些mixin构造一个类定义：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This means that the result''s `MyClass` instances will have access to its own
    prototype (containing `myMethod`), alpha''s prototype (containing `alphaMethod`),
    and bravo''s prototype (containing `bravoMethod`):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结果的`MyClass`实例将可以访问其自己的原型（包含`myMethod`），alpha的原型（包含`alphaMethod`）和bravo的原型（包含`bravoMethod`）：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Mixins can be awkward to get right, so it helps to utilize a library or proven
    piece of code to take care of this for you. The mixin mechanism you should use
    will probably depend on the exact characteristics you''re seeking. In this section,
    we''ve seen two examples: one where we compose methods into a singular `[[Prototype]]`
    via `Object.assign()`, and another where we create a tree of inheritance (that
    is, a chain of `[[Prototypes]]`) to represent our mixin hierarchy. Hopefully,
    you are now in a better position to select which one of these (or indeed, all
    of the others available online) are best suited to your needs.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 混合可能很难搞对，因此最好利用一个库或经过验证的代码来为您处理这些。您应该使用的mixin机制可能取决于您所寻求的确切特征。在本节中，我们看到了两个例子：一个是通过`Object.assign()`将方法组合成一个单一的`[[Prototype]]`，另一个是创建一个继承树（即`[[Prototypes]]`链）来表示我们的mixin层次结构。希望您现在能更好地选择这些（或者在线提供的所有其他）中的哪一个最适合您的需求。
- en: Accessing a super-class
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问超类
- en: All functions within a class defined using the method definition syntax have
    the `super` binding available, which provides access to the super-class and its
    properties. The `super()` function is available to invoke directly (which will
    call the constructor of the super-class) and can provide access to specific methods
    (`super.methodName()`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法定义语法定义的类中的所有函数都可以使用`super`绑定，它提供对超类及其属性的访问。`super()`函数可直接调用（将调用超类的构造函数），并且可以提供对特定方法的访问（`super.methodName()`）。
- en: 'If you are extending another class and you are defining your own constructor,
    you must call `super()` and you must do so before any other code within your constructor
    that modifies the instance (that is, `this`) in any way:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在扩展另一个类并且正在定义自己的构造函数，则必须调用`super()`，并且必须在构造函数内修改实例（即`this`）的任何其他代码之前这样做：
- en: '[PRE54]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If your constructor attempts to call `super()` after modifying the instance,
    or if it attempts to avoid calling `super()`, then you will receive `ReferenceError`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的构造函数在修改实例后尝试调用`super()`，或者尝试避免调用`super()`，那么您将收到`ReferenceError`：
- en: '[PRE55]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `super` binding and its oddities are described in greater detail in [Chapter
    6](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml), *Primitives and Built-in Types*
    (see the section on *Function bindings*).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`super`绑定及其特殊性的详细描述，请参阅[第6章](ae94cc02-a077-4ffb-903a-b9ec222a2a09.xhtml)，*基本类型和内置类型*（请参阅*函数绑定*部分）。
- en: The Prototype pattern
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型模式
- en: The Prototype pattern involves using plain objects to act as templates for other
    objects. The Prototype pattern extends this template object directly without fussing
    with instantiation via `new` or `Constructor.prototype` objects. You can think
    of it as similar to conventional constructor or Class patterns minus the constructor.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式涉及使用普通对象作为其他对象的模板。原型模式直接扩展此模板对象，而不需要通过`new`或`Constructor.prototype`对象进行实例化。您可以将其视为类似于传统构造函数或类模式，但没有构造函数。
- en: 'Typically, you''ll first create an object to act as your template. This will
    have all of the methods and properties associated with your abstraction. In the
    case of an `inputComponent` abstraction, it may look like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您将首先创建一个对象作为您的模板。这将具有与您的抽象相关的所有方法和属性。对于`inputComponent`抽象，它可能如下所示：
- en: '[PRE56]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note how `inputComponent` starts with a lowercase character. By convention,
    only constructor functions should be named with an initial capital letter.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`inputComponent`以小写字符开头。按照惯例，只有构造函数应以大写字母开头命名。
- en: 'Using our `inputComponent` template, we can then create (or instantiate) specific
    instances using `Object.create`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`inputComponent`模板，我们可以使用`Object.create`创建（或实例化）特定的实例：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As we''ve learned, `Object.create(thePrototype)` simply creates a new object
    and sets its internal `[[Prototype]]` property to `thePrototype`, meaning that
    any properties accessed on the new object will be looked for on `thePrototype`
    if they are not available on the object itself. As such, we can treat the resulting
    object just like any other classical instance, accessing properties as we would
    on instances resulting from the more conventional Constructor or Class patterns:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，`Object.create(thePrototype)`简单地创建一个新对象，并将其内部的`[[Prototype]]`属性设置为`thePrototype`，这意味着在新对象上访问的任何属性，如果在对象本身上不可用，将在`thePrototype`上查找。因此，我们可以像在更传统的构造函数或类模式产生的实例上一样对待生成的对象，访问属性：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For convenience, we could also introduce a method on `inputComponent` itself
    designed to do the object creation work:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我们还可以在`inputComponent`本身上引入一个设计用于执行对象创建工作的方法：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This means that we can create individual instances with slightly less code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以用稍微少一些的代码创建单独的实例：
- en: '[PRE60]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'And if we wish to create other types of inputs, then we can easily extend `inputComponent`,
    as we already have; add some methods to our the resulting object; and then offer
    that new object up for others to extend:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望创建其他类型的输入，那么我们可以像我们已经做的那样轻松扩展`inputComponent`，向生成的对象添加一些方法，然后将新对象提供给其他人扩展：
- en: '[PRE61]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: To override a particular method and access its parent, as you can see, we need
    to reference and call it directly (`InputComponent.render.call()`). You may expect
    that we should be able to use `super.render()` but, unfortunately, `super` only
    refers to `[[Prototype]]` of the object (the home) on which the containing method
    is defined. And because `Object.assign()` effectively steals these methods off
    their home objects, `super` would refer to the wrong thing.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖特定方法并访问其父级，如你所见，我们需要直接引用并调用它（`InputComponent.render.call()`）。你可能期望我们应该能够使用`super.render()`，但不幸的是，`super`只是指包含方法所定义的对象（主体）的`[[Prototype]]`。因为`Object.assign()`实际上是从它们的主体对象中窃取这些方法，`super`将指向错误的东西。
- en: The Prototype pattern is rather confusingly named. As we've seen, both the conventional
    Constructor pattern and the newer Class pattern involve the prototype, so you
    may want to instead refer to this pattern as the *Object Extension Pattern* or
    even the *No-Constructor Approach to Prototypal Inheritance*. Whatever you decide,
    it's quite a rare pattern. The classical OOP patterns are usually favored.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式的命名相当令人困惑。正如我们所见，传统的构造函数模式和较新的类模式都涉及原型，因此你可能希望将这种模式称为*对象扩展模式*，甚至是*无构造函数的原型继承方法*。无论你决定如何称呼，这都是一种相当罕见的模式。通常更受青睐的是经典的OOP模式。
- en: When to use the Prototype pattern
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用原型模式
- en: The Prototype pattern is most useful in scenarios where you have an abstraction
    that will have varying characteristics between instances (or extensions) but does
    not require construction. At its core, the Prototype pattern really only refers
    to the extension mechanism (that is, via `Object.create`), so it can equally be
    used in any scenario where you have objects that may semantically relate to other
    objects via inheritance.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 原型模式在具有实例之间变化特征的抽象情景中最有用（或扩展），但不需要构造。在其核心，原型模式实际上只是指扩展机制（即通过`Object.create`），因此它同样可以用于任何情景，其中对象可能通过继承在语义上与其他对象相关。
- en: 'Imagine a scenario in which we need to represent sandwich data. Every sandwich
    has a name, a bread type, and three slots for ingredients. For example, here is
    the representation of a BLT:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一种需要表示三明治数据的情景。每个三明治都有一个名称，一个面包类型和三个成分槽。例如，这是BLT的表示：
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We may wish to create an adaptation of the BLT, reusing most of its characteristics
    except the `Tomato` ingredient, which will be replaced with `Avocado`. We could
    simply clone the object wholesale, by using `Object.assign` to copy all the properties
    from `theBLT` to a fresh object and then specifically copying over (that is, overwriting)
    `slotC`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望创建BLT的一个适应版本，重用其大部分特征，除了`Tomato`成分，它将被替换为`Avocado`。我们可以简单地克隆整个对象，通过使用`Object.assign`从`theBLT`复制所有属性到一个新对象，然后专门复制（即覆盖）`slotC`：
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'But what if the BLT''s `breadType` was changed? Let''s take a look:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果BLT的`breadType`被更改了呢？让我们来看一下：
- en: '[PRE64]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, `theBLA` is out of sync with `theBLT`. We have realized that what we actually
    want  here is an inheritance Model so that `breadType` of `theBLA` will always
    match `breadType` of its parent sandwich. To achieve this, we can simply change
    our creation of `theBLA` so that it inherits from `theBLT` (using the Prototype
    pattern):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`theBLA`与`theBLT`不同步。我们已经意识到，这里实际上需要的是一个继承模型，以便`theBLA`的`breadType`始终与其父三明治的`breadType`匹配。为了实现这一点，我们可以简单地改变我们创建`theBLA`的方式，使其继承自`theBLT`（使用原型模式）：
- en: '[PRE65]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If we later change a characteristic of `theBLT`, it will helpfully be reflected
    in `theBLA` via inheritance:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍后更改`theBLT`的特征，它将有助于通过继承在`theBLA`中得到反映：
- en: '[PRE66]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This constructor-less Model of inheritance, as you can see, can be useful in
    some scenarios. We could equally represent this data using straightforward classes
    but with such basic data that may be overkill. The Prototype pattern is useful
    in that it provides a simple and explicit mechanism of inheritance that *can*
    result in less clunky code (although, equally, if misapplied, can lead to more
    complexity).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 可以看到，这种无构造函数的继承模型在某些情况下是有用的。我们可以同样使用直接的类来表示这些数据，但是对于如此基本的数据来说可能有些过度。原型模式有用之处在于它提供了一个简单明确的继承机制，可以导致更少臃肿的代码（尽管同样地，如果错误应用，也可能导致更多的复杂性）。
- en: The Revealing Module pattern
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 揭示模块模式
- en: 'The Revealing Module pattern is a pattern used to encapsulate some private
    logic and then expose a public API. There are a few adaptations of this pattern,
    but usually it is expressed via an **Immediately Invoked Function Expression**
    (**IIFE**) that returns an object literal containing the public methods and properties:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示模块模式是一种用于封装一些私有逻辑然后公开公共API的模式。这种模式有一些改编，但通常是通过**立即调用的函数表达式**（**IIFE**）来表达的，它返回一个包含公共方法和属性的对象字面量：
- en: '[PRE67]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Any functions returned by the IIFE will form a closure around their respective
    scopes, meaning that they will continue to have access to the *private* scope.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE返回的任何函数将形成一个封闭环绕其各自作用域的闭包，这意味着它们将继续访问*私有*作用域。
- en: 'An example of a real-world Revealing Module would be this simple DOM Component
    that contains logic for rendering a notification to users:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一个真实世界的揭示模块的例子是这个包含渲染通知给用户逻辑的简单DOM组件：
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The notification variable in the outer scope will refer to the object returned
    by the IIFE, meaning we have access to its public API:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 外部作用域中的通知变量将引用IIFE返回的对象，这意味着我们可以访问它的公共API：
- en: '[PRE69]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The Revealing Module pattern is especially useful in scenarios where you need
    to have a delineation between private and public, where you have specific initialization
    logic, and where, for whatever reason, your abstraction does not suit more object-oriented
    patterns (Class or Constructor patterns).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 揭示模块模式在需要区分私有和公共部分、具有特定初始化逻辑以及由于某种原因，你的抽象不适合更面向对象的模式（类或构造函数模式）的场景中特别有用。
- en: Before the existence of class definitions and `#private` fields, the Revealing
    Module pattern was the only easy way to emulate real privacy. As such, it has
    somewhat fallen out of favor. Some programmers still make use of it but, usually,
    only due to aesthetic preferences.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义和`#private`字段存在之前，揭示模块模式是模拟真正私有性的唯一简单方法。因此，它已经有些过时。一些程序员仍然使用它，但通常只是出于审美偏好。
- en: The Conventional Module pattern
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统模块模式
- en: 'The Conventional Module pattern is usually expressed as a plain object literal
    with a set of methods:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 传统模块模式通常表示为一个普通的对象文字，带有一组方法：
- en: '[PRE70]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'It''s quite typical for such a module to also reveal specific initialization
    methods such as `initialize`, `init`, or `setup`. Alternatively, we may want to
    provide methods that change the state or configuration of the entire module (such
    as `setConfig`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模块通常还会公开特定的初始化方法，例如`initialize`、`init`或`setup`。或者，我们可能希望提供改变整个模块状态或配置的方法（例如`setConfig`）：
- en: '[PRE71]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The Conventional Module pattern is incredibly flexible since it is just a plain
    object. JavaScript''s treatment of functions as first-class citizens (that is,
    they''re just like any other value) means that you can easily compose the objects
    of methods from functions defined elsewhere, as well:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 传统模块模式非常灵活，因为它只是一个普通对象。JavaScript将函数视为一等公民（也就是说，它们就像任何其他值一样），这意味着您可以轻松地从其他地方定义的函数组合方法的对象，例如：
- en: '[PRE72]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Conventionally, you may have considered using an inheritance or mixin pattern
    to include this `log` method in our library module, but here we're simply composing
    it ourselves by referencing and inserting it directly into our object. This pattern
    gives us a lot of flexibility in terms of how we reuse code in JavaScript.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，您可能考虑使用继承或混合模式将`log`方法包含在我们的库模块中，但在这里，我们只是通过引用并直接插入到我们的对象中来组合它。这种模式在JavaScript中为我们提供了很大的灵活性，可以灵活地重用代码。
- en: When to use the Conventional Module pattern
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用传统模块模式
- en: 'The Conventional Module pattern is useful in any scenario where you simply
    wish to wrap up a set of related methods or properties into something with a common
    name. They are often used for collections of common methods that somehow relate
    to each other, such as logging utilities:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 传统模块模式在任何您希望将一组相关方法或属性封装成具有共同名称的东西的情况下都很有用。它们通常用于与彼此相关的常见方法集合，例如日志记录实用程序：
- en: '[PRE73]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The Conventional Module pattern is just an object, so it's arguably unnecessary
    to even mention it at all. But, technically, it is an alternative to other techniques
    of abstraction definition, so it's useful to designate it as a pattern of its
    own.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 传统模块模式只是一个对象，因此可能根本不需要提及它。但从技术上讲，它是抽象定义的其他技术的替代方案，因此将其指定为一种模式是有用的。
- en: The Singleton Class pattern
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例类模式
- en: 'The Class pattern is quite quickly become the de facto pattern for creating
    abstractions of all types, including singletons and utility objects as well, so
    it may not always be the case that your class will need to be utilized as a conventionally
    OOP class with inheritance and instantiation. For example, we may wish to set
    up a utility object with a class definition so that we can define any initialization
    logic within the constructor and provide a semblance of encapsulation within its
    methods:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 类模式已经迅速成为创建各种类型的抽象的事实标准模式，包括单例和实用对象，因此您的类可能并不总是需要作为传统的面向对象类进行使用，包括继承和实例化。例如，我们可能希望使用类定义来设置一个实用对象，以便我们可以在构造函数中定义任何初始化逻辑，并在其方法中提供封装的外观：
- en: '[PRE74]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Here, we're creating and immediately instantiating a class. This is similar
    in spirit to the Revealing Module pattern where we utilize an IIFE to encapsulate
    initialization logic and the public API. Here, instead of achieving that encapsulation
    via a scope (and the resulting closure around private variables), we are using
    the straightforward constructor to define our initialization. We then are using
    the regular instance properties and methods to define both our private variables
    and our public interface.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建并立即实例化一个类。这在精神上类似于揭示模块模式，我们利用IIFE来封装初始化逻辑和公共API。在这里，我们不是通过作用域（以及围绕私有变量的闭包）来实现封装，而是使用直接的构造函数来定义初始化。然后，我们使用常规实例属性和方法来定义私有变量和公共接口。
- en: When to use the Singleton Class pattern
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用单例类模式
- en: Singletons are useful when only one instance of a class is required. The singular
    instance produced is similar in nature to the Conventional or Revealing Module
    pattern. It enables you to wrap up an abstraction with the option of private variables
    and implicit construction logic. Common use cases of singletons include *Utilities*,
    *Logging*, *Caching*, *Global Event Buse*s, and so on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 单例在需要一个类的唯一实例时非常有用。产生的单一实例在性质上类似于传统或揭示模块模式。它使您能够用私有变量和隐式构造逻辑封装一个抽象。单例的常见用例包括*实用程序*、*日志记录*、*缓存*、*全局事件总线*等。
- en: Planning and harmony
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划和和谐
- en: 'Deciding on which architectural and modular design patterns to use can be a
    tricky process, as usually at the time of deciding, it may not be immediately
    obvious what all of the requirements of the project are. Also, we as programmers
    are not omniscient. We are flawed, egoistic, and usually passionate individuals.
    This combination, if not kept in check, can yield chaotic code bases with designs
    that block the very productivity, reliability, and maintainability that we are
    trying to foster. To be wary of these pitfalls, remember the following:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 决定使用哪些架构和模块化设计模式可能是一个棘手的过程，因为通常在决定的时候，项目的所有要求可能并不立即显而易见。此外，我们作为程序员并不是全知全能的。我们是有缺陷的、自我中心的，通常是充满激情的个体。如果不加以控制，这种组合可能会产生混乱的代码库，其中的设计会阻碍我们试图培养的生产力、可靠性和可维护性。要警惕这些陷阱，记住以下内容：
- en: '**Expect change and adaptation**: Every software project will involve change
    at some point. If we are forward-thinking in our architectural and modular designs,
    then we will be able to limit this future pain, but never begin a project thinking
    that you will create the *One True Solution*. Instead, iterate, question your
    judgment, and then iterate again.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期待变化和适应：每个软件项目都会在某个时候涉及变化。如果我们在架构和模块化设计上有远见，那么我们将能够限制未来的痛苦，但永远不要开始一个项目，认为你会创造“唯一真正的解决方案”。相反，迭代，质疑自己的判断，然后再次迭代。
- en: '**Consult with other programmers**: Talk to the stakeholders who will have
    to make use of your code. That may be fellow programmers on your team or other
    programmers who''ll be making use of the interfaces that you''re providing. Field
    opinions and data and then make an informed decision.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他程序员协商：与将使用您的代码的利益相关者交谈。这可能是您团队中的其他程序员，或者将使用您提供的接口的其他程序员。听取意见和数据，然后做出明智的决定。
- en: '**Avoid cargo culting and ego**: Be aware of cargo culting and your ego and
    how, if we''re not careful, we can blindly inherit ways of doing things without
    crucially considering their suitability, or we can be trapped by our egos: thinking
    that one specific design or methodology is perfect just because it''s the one
    we personally know and love.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免模仿和自我：要注意模仿和自我，要小心，如果我们不小心，我们可能会盲目地继承做事情的方式，而不是关键地考虑它们的适用性，或者我们可能会被自己的自我困住：认为某种特定的设计或方法论是完美的，只是因为这是我们个人所知道和喜爱的。
- en: '**Bias toward harmony and consistency**: When designing an architecture, above
    all, seek harmony. There is always the possibility of many individually tailored
    parts of a code base, but too many internal differences can confuse maintainers
    and lead to a code base of splintered quality and reliability.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏向和谐与一致性：在设计架构时，最重要的是寻求和谐。代码库中总是可能有许多个性化定制的部分，但太多的内部差异会让维护者困惑，并导致代码库的分裂质量和可靠性。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored the purpose and application of design patterns
    in JavaScript. This has spanned a foundational introspection on what it even means
    for something to be a design pattern and an exploration of some common modular
    and architectural design patterns. We have explored the various ways we can declare
    abstractions using JavaScript's native mechanisms such as classes and prototypes,
    and some more novel mechanisms such as the Revealing Module pattern. Our deep
    coverage of these patterns will ensure that, in the future, we have ample options
    available to us when crafting our abstractions.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了JavaScript中设计模式的目的和应用。这涵盖了对什么是设计模式的基础性反思，以及对一些常见的模块化和架构设计模式的探索。我们已经探讨了使用JavaScript的原生机制（如类和原型）以及一些更新颖的机制（如揭示模块模式）声明抽象的各种方式。我们对这些模式的深入覆盖将确保在未来，我们在构建抽象时有充分的选择。
- en: In the next chapter, we will be exploring real-world challenges encountered
    by JavaScript programmers, such as state management and network communication,
    and applying our knowledge of new perspectives to them.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨JavaScript程序员遇到的现实挑战，如状态管理和网络通信，并将我们对新视角的知识应用到其中。
