- en: '*Chapter 4*: Getting Started with Layouts and Material Design'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*：开始使用布局和Material Design'
- en: We have already seen the Android Studio **user interface** (**UI**) designer,
    as well as Java, in action. In this hands-on chapter, we will build three more
    layouts—still quite simple, yet a step up from what we have done so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Android Studio的**用户界面**（**UI**）设计师，以及Java的实际应用。在这个动手实践的章节中，我们将构建三个更多的布局——仍然相当简单，但比我们迄今为止所做的要进一步。
- en: Before we get to the hands-on part, we will have a quick introduction to the
    concept of **Material Design**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始动手之前，我们将快速介绍**Material Design**的概念。
- en: We will see another type of layout called `LinearLayout`, and step through using
    it to create a usable UI. We will take things a step further using `ConstraintLayout`,
    both with understanding constraints and with designing more complex and precise
    UI designs. Finally, we will meet `TableLayout`, for laying out data in an easily
    readable table.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到另一种称为`LinearLayout`的布局类型，并逐步使用它来创建可用的UI。我们将进一步使用`ConstraintLayout`，既了解约束，又设计更复杂和精确的UI设计。最后，我们将介绍`TableLayout`，用于在易于阅读的表格中布置数据。
- en: We will also write some Java code to switch between different layouts within
    our app/project. This is the first major app that links together multiple topics
    into one neat parcel. The app is called **Exploring Layouts**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将编写一些Java代码，以在我们的应用程序/项目中在不同的布局之间切换。这是第一个将多个主题整合到一个整洁包裹中的重要应用程序。该应用程序名为**探索布局**。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主题：
- en: Finding out about Material Design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Material Design
- en: Exploring Android UI design
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索Android UI设计
- en: Introducing layouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍布局
- en: Building a `LinearLayout` and learning when it is best to use this type of layout
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`LinearLayout`并学习何时最好使用这种类型的布局
- en: Building another, slightly more advanced `ConstraintLayout` and finding out
    a bit more about using constraints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建另一个稍微更高级的`ConstraintLayout`并了解更多关于使用约束的知识
- en: Building a `TableLayout` and filling it with data to display
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建`TableLayout`并填充数据以显示
- en: Linking everything together in one app called **Exploring Layouts**
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容连接在一个名为**探索布局**的应用程序中
- en: First on the list is Material Design.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是Material Design。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2004](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2004).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章的代码[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2004](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2004)。
- en: Finding out about Material Design
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Material Design
- en: You might have heard of Material Design, but what exactly is it? The objective
    of Material Design is quite simple—to create beautiful UIs. It is also, however,
    about making these UIs consistent across Android devices. Material Design is not
    a new idea; it is taken straight from the design principles used in pen-and-paper
    design, such as having visually pleasing embellishments through shadows and depth.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过Material Design，但它究竟是什么？Material Design的目标非常简单——创建美观的UI。然而，它也是关于使这些UI在Android设备上保持一致。Material
    Design并不是一个新的想法；它直接来源于纸笔设计中使用的设计原则，例如通过阴影和深度具有视觉上令人愉悦的装饰。
- en: Material Design uses the concept of layers of materials, which you can think
    of in the same way you would think of layers in a photo-editing app. Consistency
    is achieved with a set of principles, rules, and guidelines. It must be stressed
    that Material Design is entirely optional, but it also must be stressed that Material
    Design works—and if you are not following it, there is a good chance your design
    will be less appreciated by the user. The user has after all become used to a
    certain type of UI, and that UI was most likely created using Material Design
    principles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design使用材料层的概念，您可以将其视为照片编辑应用程序中的图层的方式。通过一组原则、规则和指南实现一致性。必须强调的是Material
    Design是完全可选的，但也必须强调的是Material Design是有效的——如果您不遵循它，您的设计很可能不会受到用户的欣赏。毕竟，用户已经习惯了某种类型的UI，而该UI很可能是使用Material
    Design原则创建的。
- en: Material Design is a sensible standard to strive for, but while we are learning
    the details of it, we mustn't let that hold us back from learning how to get started
    with Android.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Material Design是一个值得追求的合理标准，但在学习其细节时，我们不应该让它阻碍我们学习如何开始使用Android。
- en: This book will focus on getting things done, while occasionally pointing out
    when Material Design has influenced the design, how it has influenced the design,
    and further resources for those who want to look at Material Design in more depth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将专注于完成任务，偶尔指出Material Design如何影响设计，以及对于那些想深入了解Material Design的人的更多资源。
- en: Exploring Android UI design
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索Android UI设计
- en: We will see with Android UI design that so much of what we learn is context-sensitive.
    The way that a given widget's *x* attribute will influence its appearance might
    depend on a widget's *y* attribute or even on an attribute on another widget.
    It isn't easy to learn this verbatim. It is best to expect to gradually get better
    and faster results with practice.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到，对于Android UI设计，我们所学到的很多内容都是依赖上下文的。给定小部件的*x*属性如何影响其外观可能取决于小部件的*y*属性，甚至取决于另一个小部件的属性。这并不容易逐字学习。最好期望通过实践逐渐取得更好和更快的结果。
- en: For example, if you play with the designer by dragging and dropping widgets
    onto the design, the **Extensible Markup Language** (**XML**) code that is generated
    will vary quite considerably, depending upon which layout type you are using.
    We will see this as we go ahead throughout this chapter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您通过拖放小部件到设计中来玩转设计师，生成的**可扩展标记语言**（**XML**）代码将会有很大的不同，这取决于您使用的布局类型。在本章中我们将看到这一点。
- en: This is because different layout types use different means to decide the position
    of their children—for example, the `LinearLayout` we will explore next works very
    differently from the `ConstraintLayout` that was added by default to our project
    in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*, Beginning Android
    and Java*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为不同的布局类型使用不同的方法来决定其子元素的位置，例如，我们将在下面探索的`LinearLayout`与我们项目中默认添加的`ConstraintLayout`的工作方式完全不同。
- en: This information might initially seem to be a problem, or even a bad idea, and
    it certainly is a little awkward at first. What we will grow to learn, however,
    is that this clear abundance of layout options and their individual quirks is
    a good thing because they give us almost unlimited design potential. There are
    very few layouts you can imagine that are not possible to achieve.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息起初可能看起来是一个问题，甚至是一个坏主意，而且起初确实有点尴尬。然而，我们将会逐渐了解到，这种清晰的布局选项的丰富性及其各自的特点是一件好事，因为它们给了我们几乎无限的设计潜力。您几乎可以想象不可能实现的布局是非常少的。
- en: 'This almost unlimited potential comes with a bit of complexity, however. The
    best way to start to get to grips with this is to build some working examples
    of several types. In this chapter, we will see three types of layouts, outlined
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这几乎无限的潜力也带来了一些复杂性。开始掌握这一点的最好方法是构建一些不同类型的工作示例。在本章中，我们将看到三种类型的布局，如下所述：
- en: '`LinearLayout`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinearLayout`'
- en: '`ConstraintLayout`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConstraintLayout`'
- en: '`TableLayout`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TableLayout`'
- en: We will see how to make things easier using the distinctive features of the
    visual designer, and we will also pay some attention to the XML that is autogenerated,
    to make our understanding more rounded.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何利用可视化设计工具的独特功能使事情变得更容易，我们还将对自动生成的XML进行一些关注，以使我们的理解更全面。
- en: Introducing layouts
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍布局
- en: We have already seen `ConstraintLayout` in [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014),
    *Beginning Android and Java*, but there are more layouts than this. Layouts are
    the building blocks that group together the other UI elements. Layouts can also
    contain other layouts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[*第1章*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)，*开始Android和Java*中看到了`ConstraintLayout`，但除此之外还有更多的布局。布局是将其他UI元素组合在一起的构建块。布局也可以包含其他布局。
- en: Let's look at some commonly used layouts in Android, because knowing the different
    layouts and their pros and cons will make us more aware of what can be achieved
    and will therefore expand our horizons in terms of what is possible.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下Android中一些常用的布局，因为了解不同的布局及其优缺点将使我们更加了解可以实现什么，从而扩展我们的可能性。
- en: We have already seen that once we have designed a layout, we can put it into
    action with the `setContentView` method in our Java code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，一旦我们设计了一个布局，就可以在我们的Java代码中使用`setContentView`方法将其付诸实践。
- en: Let's build three designs with different layout types, and then put `setContentView`
    to work and switch between them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建三种不同布局类型的设计，然后使用`setContentView`并在它们之间切换。
- en: Creating and exploring a layout project
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和探索布局项目
- en: One of the toughest things in Android is not just finding out *how to do something*
    but finding out *how to do something in a particular context*. That is why throughout
    this book, as well as showing you how to do some neat stuff, we will link lots
    of topics together into apps that span multiple topics and, often, chapters. The
    **Exploring Layouts** project is the first app of this type. We will learn how
    to build multiple types of layout while linking them all together in one handy
    app.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中最困难的事情之一不仅是找出*如何做某事*，而是找出*如何在特定上下文中做某事*。这就是为什么在本书中，除了向您展示如何做一些很酷的东西之外，我们还会将许多主题链接到跨越多个主题和章节的应用程序中。**探索布局**项目是这种类型的第一个应用程序。我们将学习如何构建多种类型的布局，同时将它们全部链接在一个方便的应用程序中。
- en: 'Let''s get started, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，如下所示：
- en: Create a new project in Android Studio. If you already have a project open,
    select **File** | **New Project**. When prompted, choose **Open in same window**
    as we do not need to refer to our previous project.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新项目。如果您已经打开了一个项目，请选择**文件** | **新建项目**。在提示时，选择**在同一窗口中打开**，因为我们不需要参考以前的项目。
- en: Important note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are on the start screen of Android Studio, you can create a new project
    simply by clicking the **Create new project** option.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Android Studio的起始屏幕上，可以通过单击**创建新项目**选项来创建一个新项目。
- en: Make sure to select the **Empty Activity** project template, as we will build
    most of the UI from scratch. Click the **Next** button.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保选择**空活动**项目模板，因为我们将从头开始构建大部分UI。单击**下一步**按钮。
- en: Enter `Exploring Layouts` for the application name and then click the **Finish**
    button.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入`探索布局`作为应用程序名称，然后单击**完成**按钮。
- en: 'Look at the `MainActivity.java` file. Here is the code, excluding the `import…`
    statements:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`MainActivity.java`文件。以下是代码，不包括`import…`语句：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Locate the call to the `setContentView` method and delete the entire line. The
    line is shown highlighted in the previous code snippet.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 找到对`setContentView`方法的调用，并删除整行代码。该行在前面的代码片段中显示为高亮显示。
- en: This is just what we want because now, we can build our very own layouts, explore
    the underlying XML, and write our own Java code to display these layouts. If you
    run the app now, you will just get a blank screen with a title; not even a Hello
    World! message.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们想要的，因为现在，我们可以构建我们自己的布局，探索底层的XML，并编写我们自己的Java代码来显示这些布局。如果您现在运行应用程序，您将只会得到一个带有标题的空白屏幕；甚至没有一个Hello
    World!的消息。
- en: The first type of layout we will explore is the `LinearLayout` type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探索的第一种布局类型是`LinearLayout`类型。
- en: Building a layout with LinearLayout
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LinearLayout构建布局
- en: '`LinearLayout` is probably the simplest layout that Android offers. As the
    name hints at, all the UI items within it are laid out linearly. You have just
    two choices: vertical and horizontal. By adding the following line of code (or
    editing via the `LinearLayout` to lay things out vertically:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`LinearLayout`可能是Android提供的最简单的布局。顾名思义，其中的所有UI项都是线性布局的。你只有两个选择：垂直和水平。通过添加以下代码行（或通过`LinearLayout`编辑）来垂直布局：'
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can then (as you could probably have guessed) change `"vertical"` to `"horizontal"`
    to lay things out horizontally.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后（你可能已经猜到了）将`"vertical"`更改为`"horizontal"`以水平布局。
- en: Before we can do anything with `LinearLayout`, we need to add one to a layout
    file; and as we are building three layouts in this project, we also need a new
    layout file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对`LinearLayout`进行任何操作之前，我们需要将其添加到布局文件中；由于我们在这个项目中构建了三个布局，所以我们还需要一个新的布局文件。
- en: Adding a LinearLayout layout type to a project
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向项目添加LinearLayout布局类型
- en: 'In the project window, expand the `res` folder. Now, right-click the `layout`
    folder and select **New**. Notice there is an option for **Layout resource file**,
    as shown in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目窗口中，展开`res`文件夹。现在，右键单击`layout`文件夹，然后选择**新建**。注意，有一个**布局资源文件**选项，如下面的截图所示：
- en: '![Figure 4.1 – Adding LinearLayout to project'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - 将LinearLayout添加到项目'
- en: '](img/Figure_4.01_B16773.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.01_B16773.jpg)'
- en: Figure 4.1 – Adding LinearLayout to project
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - 将LinearLayout添加到项目
- en: 'Select `LinearLayout`, as illustrated in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 选择`LinearLayout`，如下面的截图所示：
- en: '![Figure 4.2 – Creating new resource file'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 - 创建新的资源文件'
- en: '](img/Figure_4.02_B16773.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.02_B16773.jpg)'
- en: Figure 4.2 – Creating new resource file
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 创建新的资源文件
- en: In the `main_menu`. The name is arbitrary, but this layout is going to be our
    main menu that is used to select the other layouts, so the name seems appropriate.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main_menu`中。名称是任意的，但这个布局将是我们用来选择其他布局的主菜单，所以名称似乎是合适的。
- en: Click the `LinearLayout` in an XML file called `main_menu` and place it in the
    `layout` folder, ready for us to build our new main menu UI. The new file is automatically
    opened in the editor, ready for us to get designing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 点击XML文件中的`LinearLayout`，并将其放在`layout`文件夹中，准备好为我们构建新的主菜单UI。新文件会自动在编辑器中打开，准备好让我们进行设计。
- en: Preparing your workspace
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作空间
- en: 'Click the **Design** tab to switch to design view if you are not already in
    this view. Adjust the windows by dragging and resizing their borders (as you can
    in most windowed apps) to make the palette, design, and attributes as clear as
    possible but no bigger than necessary. The following screenshot shows the approximate
    window proportions I chose to make designing our UI and exploring the XML as clear
    as possible. The detail in the screenshot is not important:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**设计**选项卡以切换到设计视图，如果你还没有在这个视图中。通过拖动和调整窗口边框（就像大多数窗口化应用程序中一样），使调色板、设计和属性尽可能清晰，但不要超出必要的大小。下面的截图显示了我选择的大致窗口比例，以使设计我们的UI和探索XML尽可能清晰。截图中的细节并不重要：
- en: '![Figure 4.3 – Preparing workspace'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 准备工作空间'
- en: '](img/Figure_4.03_B16773.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.03_B16773.jpg)'
- en: Figure 4.3 – Preparing workspace
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 准备工作空间
- en: Important note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: I have made the project, palette, and attribute windows as narrow as possible
    yet without obscuring any content. I have also closed the Build/logcat window
    at the bottom of the screen, the result being that I have a nice clear canvas
    on which to build the UI.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经尽可能地将项目、调色板和属性窗口变窄，但没有遮挡任何内容。我还关闭了屏幕底部的构建/logcat窗口，结果是我有一个很清晰的画布来构建UI。
- en: Examining the generated XML
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生成的XML
- en: 'Click on the **Code** tab, and we will have a look at the current state of
    the XML code that forms our design at this stage. Here is the code so that we
    can talk about it (I have reformatted it slightly to make it appear more clearly
    on the page):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**代码**选项卡，我们将查看当前阶段构成我们设计的XML代码的当前状态。以下是代码，以便我们讨论（我稍微重新格式化了一下，以使其在页面上更清晰）：
- en: '[PRE2]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We have the usual starting and closing tags and, as we could have predicted,
    they are called `<LinearLayout` and `</LinearLayout>`. There is no child element
    yet, but there are three attributes. We know they are attributes and not children
    of the `LinearLayout` because they appear before the first closing `>`. The three
    attributes that define this `LinearLayout` have been highlighted in the previous
    code for clarity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '我们有通常的起始和结束标签，正如我们可能已经预测到的那样，它们被称为`<LinearLayout`和`</LinearLayout>`。目前还没有子元素，但有三个属性。我们知道它们是`LinearLayout`的属性而不是子元素，因为它们出现在第一个闭合`>`之前。为了清晰起见，前面的代码中突出显示了定义这个`LinearLayout`的三个属性。 '
- en: The first attribute is `android:orientation`, or—more succinctly—we will just
    refer to the attributes without the `android:` part. The `orientation` attribute
    has a value of `vertical`. This means that when we start to add items to this
    layout, it will arrange them vertically from top to bottom. We could change the
    `vertical` value to `horizontal`, and it would lay things out from left to right.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个属性是`android:orientation`，或者更简洁地说，我们将只提到属性而不包括`android:`部分。`orientation`属性的值为`vertical`。这意味着当我们开始向这个布局添加项目时，它将垂直从上到下排列它们。我们可以将`vertical`值更改为`horizontal`，它会从左到右排列。
- en: The next two attributes are `layout_width` and `layout_height`. These determine
    the size of the `LinearLayout`. The value given to both attributes is `match_parent`.
    The parent of a layout is the entire available space. By matching the parent horizontally
    and vertically, the layout will fill the entire space available.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个属性是`layout_width`和`layout_height`。这些属性确定了`LinearLayout`的大小。给这两个属性的值都是`match_parent`。布局的父级是整个可用空间。通过水平和垂直匹配父级，布局将填充整个可用空间。
- en: Adding a TextView to the UI
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向UI添加一个TextView
- en: Switch back to the **Design** tab, and we will add some elements to the UI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**设计**选项卡，我们将向UI添加一些元素。
- en: First, find the `TextView` widget in the palette. This can be found in both
    the `TextView` onto the UI, and notice that it sits neatly at the top of the `LinearLayout`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在调色板中找到`TextView`小部件。这可以在UI上找到`TextView`，请注意它整齐地位于`LinearLayout`的顶部。
- en: 'Look at the XML on the `LinearLayout` and that it is indented by one tab to
    make this clear. Here is the code for the `TextView` widget, without the surrounding
    code for the `LinearLayout`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`LinearLayout`上的XML，并且它缩进了一个制表符以使其清晰。以下是`TextView`小部件的代码，不包括`LinearLayout`的周围代码：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Notice it has four attributes: an `id` attribute, in case we need to refer
    to it from another UI element or from our Java code; a `layout_width` attribute
    set to `match_parent`, which means the `TextView` stretches across the whole width
    of the `LinearLayout`; and a `layout_height` attribute set to `wrap_content`,
    which means the `TextView` is precisely tall enough to contain the text within
    it. Finally, for now, it has a `text` element, which determines the actual text
    it will display, and this is currently set to just "`TextView`".'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，它有四个属性：`id`属性，以防我们需要从另一个UI元素或我们的Java代码中引用它；`layout_width`属性设置为`match_parent`，这意味着`TextView`横跨整个`LinearLayout`的宽度；`layout_height`属性设置为`wrap_content`，这意味着`TextView`的高度正好足够容纳其中的文本。最后，目前它有一个`text`元素，确定它将显示的实际文本，目前设置为“`TextView`”。
- en: Switch back to the **Design** tab, and we will make some changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Design**选项卡，我们将进行一些更改。
- en: 'We want this text to be the heading text of this screen, which is the menu
    screen. In the `text` into the search box, as shown in the following screenshot.
    Find the `text` attribute and change its value to `Menu`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这段文字成为此屏幕的标题文字，即菜单屏幕。在搜索框中输入`text`，如下截图所示。找到`text`属性并将其值更改为`Menu`：
- en: '![Figure 4.4 – Adding TextView to UI'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 将TextView添加到UI'
- en: '](img/Figure_4.04_B16773.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.04_B16773.jpg)'
- en: Figure 4.4 – Adding TextView to UI
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 将TextView添加到UI
- en: Tip
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You can find any attribute by searching or just by scrolling through the options.
    When you have found the attribute you want to edit, left-click it to select it
    and then press the *Enter* key on the keyboard to make it editable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过搜索或只是浏览选项来查找任何属性。找到要编辑的属性后，左键单击选择它，然后按键盘上的*Enter*键使其可编辑。
- en: Next, find the `textSize` attribute using your preferred search technique, and
    set `textSize` to `50sp`. When you have entered this new value, the text size
    will increase.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用您喜欢的搜索技术找到`textSize`属性，并将`textSize`设置为`50sp`。输入这个新值后，文本大小将增加。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `sp` value stands for **scalable pixels**. This means that when the user
    changes the font-size settings on their Android device, the font will dynamically
    rescale itself.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`sp`值代表**可伸缩像素**。这意味着当用户在其Android设备上更改字体大小设置时，字体将动态重新调整大小。'
- en: 'Now, search for the `gravity` attribute and expand the options by clicking
    the little arrow indicated in the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，搜索`gravity`属性，并通过单击以下截图中指示的小箭头来展开选项：
- en: '![Figure 4.5 – Expanding gravity attribute'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - 展开gravity属性'
- en: '](img/Figure_4.05_B16773.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.05_B16773.jpg)'
- en: Figure 4.5 – Expanding gravity attribute
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - 展开gravity属性
- en: 'Add `center_horizontal` to the gravity by setting that value to **true**, as
    illustrated in the following screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将该值设置为**true**，将`center_horizontal`添加到gravity中，如下截图所示：
- en: '![Figure 4.6 – Adding center_horizontal to gravity by setting the value to
    true'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6 - 通过将值设置为true向gravity添加center_horizontal'
- en: '](img/Figure_4.06_B16773.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.06_B16773.jpg)'
- en: Figure 4.6 – Adding center_horizontal to gravity by setting the value to true
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 - 通过将值设置为true向gravity添加center_horizontal
- en: The `gravity` attribute refers to the gravity within the `TextView` itself,
    and our change has the effect of moving the actual text inside the `TextView`
    to the center.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity`属性指的是`TextView`本身的重力，我们的更改会使`TextView`内的实际文本居中。'
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `gravity` attribute is different from the `layout_gravity` attribute. The
    `layout_gravity` attribute sets the gravity within the layout—in this case, the
    parent `LinearLayout`. We will use `layout_gravity` later in this project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity`属性与`layout_gravity`属性不同。`layout_gravity`属性设置布局内的重力，即在这种情况下是父`LinearLayout`。我们将在项目的后续部分中使用`layout_gravity`。'
- en: 'At this point, we have changed the text of the `TextView` widget, increased
    its size, and centered it horizontally. The UI designer should now look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们已更改了`TextView`小部件的文本，增加了其大小，并使其水平居中。UI设计师现在应该看起来像这样：
- en: '![Figure 4.7 – Adjusting textView on the UI'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7 - 调整UI上的textView'
- en: '](img/Figure_4.07_B16773.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.07_B16773.jpg)'
- en: Figure 4.7 – Adjusting textView on the UI
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 - 调整UI上的textView
- en: 'A quick glance at the **Code** tab to see the XML would reveal the following
    code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看**Code**选项卡上的XML，将显示以下代码：
- en: '[PRE4]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see the new attributes as follows: `gravity`, which is set to `center_horizontal`;
    `text`, which has been changed to `Menu`; and `textSize`, which is set to `50sp`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按如下方式查看新属性：`gravity`，设置为`center_horizontal`；`text`，已更改为`Menu`；和`textSize`，设置为`50sp`。
- en: If you run the app, you might not see what you expected. This is because we
    haven't called the `setContentView` method in our Java code to load the UI. You
    will still see the blank UI. We will fix this once we have made a bit more progress
    with our design.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行应用程序，您可能看不到预期的结果。这是因为我们还没有在我们的Java代码中调用`setContentView`方法来加载UI。您仍将看到空白的UI。一旦我们在设计上取得了更多进展，我们将解决这个问题。
- en: Adding a multiline TextView to the UI
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将多行TextView添加到UI
- en: Switch back to the `TextView` widget we added a moment ago.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回我们刚刚添加的`TextView`小部件。
- en: 'Using your preferred search technique, set the `text` attribute to the following:
    `Select a layout type to view an example. The onClick attribute of each button
    will call a method which executes setContentView to load the new layout`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您喜欢的搜索技术，将`text`属性设置为以下内容：`选择布局类型以查看示例。每个按钮的onClick属性将调用一个方法，该方法执行setContentView以加载新布局`。
- en: 'Now, your layout will look like this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你的布局将如下所示：
- en: '![Figure 4.8 – Multiline textView added to UI'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8 - 添加到UI的多行textView'
- en: '](img/Figure_4.08_B16773.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.08_B16773.jpg)'
- en: Figure 4.8 – Multiline textView added to UI
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 - 添加到UI的多行textView
- en: 'Your XML will be updated with another child in the `LinearLayout` (after the
    `TextView`) that looks like this (I have slightly reformatted it for presenting
    it on the page):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你的XML将在`LinearLayout`中更新另一个子项（在`TextView`之后），看起来像这样（我稍微重新格式化了它以便在页面上呈现）：
- en: '[PRE5]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see the details of the UI item. A look at the XML reveals we have an
    `inputType` attribute, indicating that this text is editable. There is also another
    attribute that we haven't seen before, and that is `ems`. The `ems` attribute
    controls how many characters can be entered per line, and the value of 10 was
    chosen automatically by Android Studio. However, another attribute, `layout_width="match_parent"`,
    overrides this value because it causes the element to expand to fit its parent—
    that is, the whole width of the screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到UI项的细节。查看XML文件，我们有一个`inputType`属性，表示这个文本是可编辑的。还有另一个我们以前没有见过的属性，那就是`ems`。`ems`属性控制每行可以输入多少个字符，值为10是由Android
    Studio自动选择的。然而，另一个属性`layout_width="match_parent"`覆盖了这个值，因为它导致元素扩展以适应其父元素 - 也就是屏幕的整个宽度。
- en: When you run the app in the next section, you will see the text is indeed editable,
    although for the purposes of this demo app it serves no practical purpose.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在下一节运行应用程序时，你会看到文本确实是可编辑的，尽管对于这个演示应用程序来说，它没有实际用途。
- en: Wiring up the UI with the Java code (Part 1)
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将UI与Java代码连接起来（第1部分）
- en: 'To achieve an interactive app, we will do the following three things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现一个交互式的应用程序，我们将做以下三件事：
- en: We will call the `setContentView` method from the `onCreate` method to show
    the progress of our UI when we run the app.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从`onCreate`方法中调用`setContentView`方法来显示我们运行应用程序时UI的进展。
- en: We will write two more methods of our own, and each one will call the `setContentView`
    method on a different layout (that we have yet to design).
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写另外两种自己的方法，每种方法都将在不同的布局上调用`setContentView`方法（我们还没有设计）。
- en: Then, later in this chapter when we design two more UI layouts, we will be able
    to load them at the click of a button.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在本章稍后设计另外两个UI布局时，我们将能够在点击按钮时加载它们。
- en: As we will be building a `ConstraintLayout` and a `TableLayout`, we will call
    our new methods `loadConstraintLayout` and `loadTableLayout`, respectively.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将构建一个`ConstraintLayout`和一个`TableLayout`，我们将分别调用我们的新方法`loadConstraintLayout`和`loadTableLayout`。
- en: Let's do that now, and then we can see how we can add some buttons that call
    these methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们这样做，然后我们可以看到如何添加一些调用这些方法的按钮。
- en: 'Switch to the `MainActivity.java` file, then inside the `onCreate` method add
    the following highlighted code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到`MainActivity.java`文件，然后在`onCreate`方法内添加以下突出显示的代码：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The code uses the `setContentView` method to load the UI we are currently working
    on. You can now run the app to see the following result:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码使用`setContentView`方法来加载我们目前正在工作的UI。现在你可以运行应用程序来查看以下结果：
- en: '![Figure 4.9 –Exploring Layouts menu'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9 - 探索布局菜单'
- en: '](img/Figure_4.09_B16773.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.09_B16773.jpg)'
- en: Figure 4.9 –Exploring Layouts menu
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 - 探索布局菜单
- en: 'Add these two new methods inside the `MainActivity` class after the `onCreate`
    method, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity`类的`onCreate`方法之后添加这两个新方法，如下所示：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There is one error with the first method and two errors with the second. The
    first error we can fix by adding an `import` statement so that Android Studio
    is aware of the `View` class. Left-click the word `View` to select the error.
    Hold down the *Alt* key and then tap the *Enter* key. You will see the following
    messages pop up:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法有一个错误，第二种方法有两个错误。我们可以通过添加一个`import`语句来修复第一个错误，以便Android Studio知道`View`类。左键单击`View`单词以选择错误。按住*Alt*键然后点击*Enter*键。你会看到以下消息弹出：
- en: '![Figure 4.10 – Selecting Import class to eliminate the error'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10 - 选择导入类以消除错误'
- en: '](img/Figure_4.10_B16773.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.10_B16773.jpg)'
- en: Figure 4.10 – Selecting Import class to eliminate the error
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 - 选择导入类以消除错误
- en: 'Choose **Import class**. The error is gone. If you scroll to the top of the
    code, you will see that a new line of code has been added by that shortcut we
    just performed. Here is the new code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**导入类**。错误消失了。如果你滚动到代码的顶部，你会看到通过我们刚刚执行的快捷方式添加了一行新的代码。下面是新代码：
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Android Studio knows about the `View` class and no longer has an error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio知道`View`类，不再有错误。
- en: 'The second method still has an error, however. The problem is that the code
    calls the `setContentView` method to load a new UI (`R.layout.my_table_layout`).
    As this UI layout does not exist yet, it produces an error. You can comment out
    this call to remove the error until we create the file and design the UI layout
    later in this chapter. Add the comment forward slashes ( `//` ), as highlighted
    next:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第二种方法仍然有一个错误。问题在于代码调用`setContentView`方法来加载一个新的UI（`R.layout.my_table_layout`）。由于这个UI布局还不存在，它会产生一个错误。你可以注释掉这个调用以消除错误，直到我们在本章后面创建文件并设计UI布局为止。添加注释斜杠（`//`），如下所示：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The reason why the `loadConstraintLayout` method does not have an error is because
    that method loads the `activity_main.xml` layout, which was created by Android
    Studio when we generated the project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadConstraintLayout`方法没有错误的原因是该方法加载了由Android Studio在生成项目时创建的`activity_main.xml`布局。'
- en: Now, we want to add some buttons we can click to call our new methods and load
    the new layouts we will be building. But adding a couple of buttons with some
    text on is too easy—we have done that before. What we want to do is line up some
    text with a button to the right of it. The problem is our `LinearLayout` has the
    `orientation` attribute set to `vertical` and, as we have seen, all the new parts
    we add to the layout will be lined up vertically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要添加一些按钮，以便单击调用我们的新方法并加载我们将要构建的新布局。但是，添加一些带有文本的按钮太容易了 - 我们以前已经做过了。我们想要做的是将一些文本与按钮对齐，使其位于文本的右侧。问题是，我们的`LinearLayout`的`orientation`属性设置为`vertical`，正如我们所见，我们添加到布局中的所有新部分都将垂直排列。
- en: Adding layouts within layouts
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在布局中添加布局
- en: The solution to laying out some elements with a different orientation from others
    is to nest layouts within layouts. Here is how to do it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在布局中嵌套布局，以便以不同方向排列一些元素。以下是如何做到的。
- en: 'From the **Layouts** category of the palette, drag a **LinearLayout (Horizontal)**
    onto our design, placing it just below the **Multiline Text**. Notice in the following
    screenshot that there is a blue border occupying all the space below the **Multiline
    Text**:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从调色板的**布局**类别中，将一个**LinearLayout (Horizontal)**拖放到我们的设计中，将其放置在**多行文本**的正下方。请注意以下截图中，有一个蓝色边框占据了**多行文本**下方的所有空间：
- en: '![Figure 4.11 – Dragging a LinearLayout (Horizontal) from the Layouts category
    onto our design and placing it just below the Multiline Text'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11 - 从布局类别将LinearLayout (Horizontal)拖放到我们的设计中，并将其放置在多行文本的正下方'
- en: '](img/Figure_4.11_B16773.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.11_B16773.jpg)'
- en: Figure 4.11 – Dragging a LinearLayout (Horizontal) from the Layouts category
    onto our design and placing it just below the Multiline Text
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 - 从布局类别将LinearLayout (Horizontal)拖放到我们的设计中，并将其放置在多行文本的正下方
- en: This indicates that our new **LinearLayout (Horizontal)** is filling the space.
    Keep this blue border area in mind, as this is where we will put the next item
    on our UI.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的新**LinearLayout (Horizontal)**正在填充空间。请记住这个蓝色边框区域，因为这将是我们在UI上放置下一个项目的地方。
- en: 'Now, go back to the `TextView` widget onto the new `LinearLayout` we just added.
    Notice in the following screenshot how the `TextView` widget sits snuggly in the
    top left-hand corner of the new `LinearLayout`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到新添加的`LinearLayout`上的`TextView`小部件。请注意以下截图中，`TextView`小部件紧密地坐落在新`LinearLayout`的左上角：
- en: '![Figure 4.12 – Dragging a TextView widget from the Text category of the palette
    onto the new LinearLayout'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12 - 从调色板的文本类别将TextView小部件拖放到新的LinearLayout中'
- en: '](img/Figure_4.12_B16773.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.12_B16773.jpg)'
- en: Figure 4.12 – Dragging a TextView widget from the Text category of the palette
    onto the new LinearLayout
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12 - 从调色板的文本类别将TextView小部件拖放到新的LinearLayout中
- en: This at first seems no different from what happened with the previous vertical
    `LinearLayout`, which was part of our UI from the start. But watch what happens
    when we add our next piece of the UI.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这似乎与之前的垂直`LinearLayout`发生的情况没有什么不同，它从一开始就是我们UI的一部分。但是当我们添加UI的下一个部分时，请看看会发生什么。
- en: Important note
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The term used to refer to adding layouts within layouts is `TextView`, `Button`,
    `LinearLayout`) or more broadly (UI element, item, or widget).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 用于指代在布局中添加布局的术语是`TextView`、`Button`、`LinearLayout`)或更广泛的（UI元素、项目或小部件）。
- en: 'From the `Button` widget onto the right-hand side of the previous `TextView`
    widget. Notice that the button sits to the right of the text, as shown here:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从先前的`TextView`小部件的右侧将`Button`小部件拖放。请注意，按钮位于文本的右侧，如下所示：
- en: '![Figure 4.13 – Dragging a Button widget from the Button category onto the
    right-hand side of the previous TextView widget'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13 - 从按钮类别将按钮小部件拖放到先前TextView小部件的右侧'
- en: '](img/Figure_4.13_B16773.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.13_B16773.jpg)'
- en: Figure 4.13 – Dragging a Button widget from the Button category onto the right-hand
    side of the previous TextView widget
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 - 从按钮类别将按钮小部件拖放到先前TextView小部件的右侧
- en: 'Next, select the `LinearLayout` (the horizontal one) by clicking on an empty
    part of it. Find the `layout_height` attribute and set it to `wrap_content`. Notice
    that the `LinearLayout` is now taking up only as much space as it needs, and there
    is space below where we can add more widgets. This is shown in the following screenshot:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过点击其空白部分选择`LinearLayout`（水平的那个）。找到`layout_height`属性，并将其设置为`wrap_content`。请注意，`LinearLayout`现在只占用所需的空间，并且在下方有空间可以添加更多小部件。如下截图所示：
- en: '![Figure 4.14 – Selecting the LinearLayout (the horizontal one) by clicking
    on an empty part'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14 - 通过点击空白部分选择LinearLayout (水平的那个)'
- en: '](img/Figure_4.14_B16773.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.14_B16773.jpg)'
- en: Figure 4.14 – Selecting the LinearLayout (the horizontal one) by clicking on
    an empty part
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 - 通过点击空白部分选择LinearLayout (水平的那个)
- en: Let's configure the `text` attribute of the `TextView` widget and the `Button`
    widget before we add the next part of the UI. Change the `text` attribute of the
    `Button` widget to `LOAD`. Change the text attribute of our new `TextView` widget
    to `Load` `ConstraintLayout`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加UI的下一部分之前，让我们配置`TextView`小部件和`Button`小部件的`text`属性。将`Button`小部件的`text`属性更改为`LOAD`。将我们新的`TextView`小部件的文本属性更改为`Load`
    `ConstraintLayout`。
- en: 'This screenshot shows what the layout should look like currently:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此截图显示了当前布局的外观：
- en: '![Figure 4.15 – Configuring the text attribute of the TextView widget and the
    Button widget'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15 - 配置TextView小部件和Button小部件的文本属性'
- en: '](img/Figure_4.15_B16773.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.15_B16773.jpg)'
- en: Figure 4.15 – Configuring the text attribute of the TextView widget and the
    Button widget
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 - 配置TextView小部件和Button小部件的文本属性
- en: Tip
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Did that work? Yes? Excellent. You are now familiar with editing attributes
    of Android views. No? Left-click the item you want to edit (in this case, the
    `TextView` widget), search using the search icon, or scroll to find the attribute
    you want to edit in the `text` attribute), select the attribute, and press *Enter*
    to edit it. I can now give more succinct instructions on how to build future UI
    projects, and this makes your journey to becoming an Android Ninja much quicker.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 那起作用了吗？是的？太棒了。您现在已经熟悉了编辑Android视图属性。没有？左键单击要编辑的项目（在本例中为“TextView”小部件），使用搜索图标进行搜索，或滚动查找要在“text”属性中编辑的属性），选择属性，然后按*Enter*进行编辑。现在我可以更简洁地说明如何构建未来的UI项目，这将使您成为Android忍者的旅程更快。
- en: 'Now, we can repeat ourselves and add another `TextView` widget and `Button`
    widget within another **LinearLayout (Horizontal)**, just below the one we have
    just finished. To do so, follow these steps in order:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重复自己，在刚刚完成的下方再添加一个**LinearLayout（水平）**，分别添加另一个“TextView”小部件和“Button”小部件。要这样做，请按照以下顺序进行：
- en: Add another **LinearLayout (Horizontal)** just below the previous one.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个下面添加另一个**LinearLayout（水平）**。
- en: Add a `LinearLayout`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个“LinearLayout”。
- en: Change the `text` attribute of the `TextView` to `Load TableLayout`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“TextView”的“text”属性更改为“加载TableLayout”。
- en: Add a `Button` widget on the right-hand side of the `TextView` widget.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“TextView”小部件的右侧添加一个“Button”小部件。
- en: Change the `text` attribute of the `Button` widget to `LOAD`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将“Button”小部件的“text”属性更改为“LOAD”。
- en: Resize the `LinearLayout` by changing the `layout_height` attribute to `wrap_content`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将“layout_height”属性更改为“wrap_content”来调整“LinearLayout”的大小。
- en: Just for fun and for the sake of exploring the palette a bit more, find the
    `RatingBar` widget onto the design, just below the final `LinearLayout`.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只是为了好玩，也为了更多地探索调色板，找到“RatingBar”小部件并将其放在设计的下方，就在最后一个“LinearLayout”下方。
- en: 'Now, your UI should look like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的UI应该是这样的：
- en: '![Figure 4.16 – Another TextView widget and Button widget added within another
    LinearLayout (Horizontal)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16 - 在另一个LinearLayout（水平）中添加了另一个TextView小部件和Button小部件'
- en: '](img/Figure_4.16_B16773.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.16_B16773.jpg)'
- en: Figure 4.16 – Another TextView widget and Button widget added within another
    LinearLayout (Horizontal)
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 - 在另一个LinearLayout（水平）中添加了另一个TextView小部件和Button小部件
- en: Let's add some visual finishing touches to the layout.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为布局添加一些视觉上的润色。
- en: Making the layout look pretty
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使布局看起来漂亮
- en: In this section, we will explore some more attributes that control the finer
    details of our UI. You have probably noticed the UI looks a bit squashed in some
    places and wonky and unsymmetrical in others. As we progress through the book,
    we will continually add to our repertoire to improve our layouts, but these short
    steps will introduce and take care of some of the basics.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一些控制UI细节的更多属性。您可能已经注意到UI在某些地方看起来有点挤，而在其他地方看起来不对称。随着我们在书中的进展，我们将不断增加我们的技能来改善我们的布局，但这些简短的步骤将介绍并处理一些基础知识。
- en: Before you get started with the next steps, consider the following tip.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始下一步之前，请考虑以下提示。
- en: Tip
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When you are configuring the attributes of widgets, you can select multiple
    widgets at a time—for example, in *Step 3* in the instructions that follow, you
    could left-click to select the first `TextView` widget and then *Shift* and left-click
    to select the second `TextView` widget. You could then alter attributes for both
    simultaneously. This tip will also work for *Step 4* with the `Button` widgets.
    It will even work when the widgets are different types, provided you are only
    editing attributes that all the selected widgets have. So, in *Step 5* that follows,
    you can simultaneously select and edit the `padding` attribute on both `TextView`
    and both `Button` widgets.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当您配置小部件的属性时，您可以一次选择多个小部件 - 例如，在接下来的说明中的*步骤3*中，您可以左键单击以选择第一个“TextView”小部件，然后*Shift*和左键单击以选择第二个“TextView”小部件。然后可以同时更改两者的属性。这个提示也适用于*步骤4*和“Button”小部件。即使小部件类型不同，只要您只编辑所有选定小部件都具有的属性，它也可以工作。因此，在接下来的*步骤5*中，您可以同时选择并编辑“TextView”和两个“Button”小部件上的“填充”属性。
- en: 'Follow these instructions:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下说明进行：
- en: Select the `Multiline Text` widget, and find then expand the `padding` attribute.
    Set the `padding` option to `15sp`. This has made a neat area of space around
    the outside of the `text`.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“多行文本”小部件，找到并展开“填充”属性。将“填充”选项设置为“15sp”。这在“文本”周围留出了一个整洁的空间。
- en: To make a nice space below the Multiline Text widget, find and expand the `Layout_Margin`
    attribute and set `bottom` to `50sp`.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在多行文本小部件下面留出一个漂亮的空间，找到并展开“Layout_Margin”属性，将“bottom”设置为“50sp”。
- en: On both button-aligned `TextView` widgets, set the `textSize` attribute to `20sp`;
    `layout_gravity` to `center_vertical`; the `layout_width` attribute to `match_parent`;
    and `layout_weight` to `.7`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个对齐的“TextView”小部件上，将“textSize”属性设置为“20sp”；“layout_gravity”设置为“center_vertical”；“layout_width”属性设置为“match_parent”；并将“layout_weight”设置为“.7”。
- en: On both buttons, set the weight to `.3`. Notice how both buttons now take up
    exactly `.3` of the width and the text takes up `.7` of the `LinearLayout`, making
    the whole appearance more pleasing.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个按钮上，将权重设置为“.3”。注意两个按钮现在都占据了宽度的“.3”，文本占据了“.7”的“LinearLayout”，使整体外观更加愉悦。
- en: On both `TextView` widgets and both `Button` widgets, select `padding` then
    `padding`, and set the value to `10dp`.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个“TextView”小部件和两个“Button”小部件上，选择“填充”然后选择“填充”，并将值设置为“10dp”。
- en: On the `RatingBar` widget, find the `Layout_Margin` attribute, then set `left`
    and `right` to `15sp`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“RatingBar”小部件上，找到“Layout_Margin”属性，然后将“left”和“right”设置为“15sp”。
- en: Still with the `RatingBar` widget and the `Layout_Margin` attribute, change
    top to `75sp`.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然使用“RatingBar”小部件和“Layout_Margin”属性，将顶部更改为“75sp”。
- en: 'You can now run the app and see our first full layout in all its glory, as
    illustrated here:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序，看到我们的第一个完整布局的全部荣耀，如下所示：
- en: '![Figure 4.17 – The improved layout'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17 - 改进的布局'
- en: '](img/Figure_4.17_B16773.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.17_B16773.jpg)'
- en: Figure 4.17 – The improved layout
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 - 改进的布局
- en: Notice that you can play with the `RatingBar` widget, although the rating won't
    persist when the app is turned off.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以使用`RatingBar`小部件，尽管在关闭应用程序时评分不会保留。
- en: Unfortunately, the buttons in our app don't do anything yet. Let's fix that
    now.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们应用程序中的按钮还没有做任何事情。让我们现在修复它。
- en: Wiring up the UI with Java code (Part 2)
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用Java代码连接UI（第2部分）
- en: 'To enable the user to interact with our buttons, follow the next two steps
    to make the buttons in the layout call our methods:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户与我们的按钮交互，按照下面的两个步骤使布局中的按钮调用我们的方法：
- en: Select the button next to the `Load ConstraintLayout` text. Find the `onClick`
    attribute and set it to `loadConstraintLayout`.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Load ConstraintLayout`文本旁边的按钮。找到`onClick`属性并将其设置为`loadConstraintLayout`。
- en: Select the button next to the `Load TableLayout` text. Find the `onClick` attribute
    and set it to `loadTableLayout`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Load TableLayout`文本旁边的按钮。找到`onClick`属性并将其设置为`loadTableLayout`。
- en: Now, the buttons will call the methods, but the code inside the `loadTableLayout`
    method is commented out to avoid errors. Feel free to run the app and check that
    you can switch to the `ConstraintLayout` by clicking the `loadConstraintLayout`
    button. But all the `ConstraintLayout` currently has is a **Hello World!** message.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按钮将调用方法，但`loadTableLayout`方法内的代码被注释掉以避免错误。随时运行应用程序并检查您是否可以通过单击`loadConstraintLayout`按钮切换到`ConstraintLayout`。但是`ConstraintLayout`目前只有一个**Hello
    World!**消息。
- en: We can now move on to building this `ConstraintLayout`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续构建这个`ConstraintLayout`。
- en: Building a precise UI with ConstraintLayout
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ConstraintLayout构建精确的UI
- en: Open the `ConstraintLayout` that was autogenerated when we created the project.
    It is probably open already in a tab at the top of the editor. If not, it will
    be in the `res/layout` folder. The filename is `activity_main.xml`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们创建项目时自动生成的`ConstraintLayout`。它可能已经在编辑器顶部的选项卡中打开了。如果没有，它将在`res/layout`文件夹中。文件名是`activity_main.xml`。
- en: Inspect the XML in the `TextView` that says `Hello World`. Switch back to the
    `Design` tab, left-click the `TextView` to select it, and tap the *Delete* key
    to get rid of it.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`Hello World`中的`TextView`中的XML。切换回`Design`选项卡，左键单击`TextView`以选择它，然后按*Delete*键将其删除。
- en: Now, we can build ourselves a simple yet intricate UI. The `ConstraintLayout`
    is most useful when you want to position parts of your UI very precisely and/or
    relative to the other parts and not just in a linear fashion.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以构建一个简单而复杂的UI。当您想要非常精确地定位UI的部分和/或相对于其他部分而不仅仅是线性方式时，`ConstraintLayout`是最有用的。
- en: Adding a CalendarView
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日历视图
- en: To get started, look in the `CalendarView`. Drag and drop the `CalendarView`
    near the top and horizontally central. As you drag the `CalendarView` around,
    notice that it jumps/snaps to some locations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请查看`CalendarView`。将`CalendarView`拖放到顶部并水平居中。当您拖动`CalendarView`时，请注意它会跳到某些位置。
- en: 'Also, notice the subtle visual cues that show when the view is aligned. I have
    highlighted the horizontally central visual cue in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意显示视图对齐时的微妙视觉提示。我在下面的截图中突出显示了水平中心的视觉提示：
- en: '![Figure 4.18 – The horizontally central visual cue'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18 - 水平中心的视觉提示'
- en: '](img/Figure_4.18_B16773.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.18_B16773.jpg)'
- en: Figure 4.18 – The horizontally central visual cue
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 - 水平中心的视觉提示
- en: Let go when it is horizontally central, as it is in the preceding screenshot.
    Now, we will resize it.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当它水平居中时，就像前面的截图中一样，松开。现在，我们将调整它的大小。
- en: Resizing a view in a ConstraintLayout
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在ConstraintLayout中调整视图大小
- en: 'Left-click and hold one of the corner squares that are revealed when you let
    go of the `CalendarView`, and drag inward to decrease the size of the `CalendarView`,
    as illustrated in the following screenshot:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 左键单击并按住`CalendarView`释放时显示的角落中的一个，向内拖动以减小`CalendarView`的大小，如下面的截图所示：
- en: '![Figure 4.19 – Resizing a view in the ConstaintLayout'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19 - 在ConstaintLayout中调整视图大小'
- en: '](img/Figure_4.19_B16773.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.19_B16773.jpg)'
- en: Figure 4.19 – Resizing a view in the ConstaintLayout
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 - 在ConstaintLayout中调整视图大小
- en: 'Reduce the size by about half and leave the `CalendarView` near the top and
    horizontally central. You might need to reposition the widget a little after you
    have resized it. The result should look like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将大小减少约一半，将`CalendarView`留在顶部并水平居中。在调整大小后，您可能需要重新定位小部件。结果应该是这样的：
- en: '![Figure 4.20 – Repositioning the widget'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20 - 重新定位小部件'
- en: '](img/Figure_4.20_B16773.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.20_B16773.jpg)'
- en: Figure 4.20 – Repositioning the widget
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 - 重新定位小部件
- en: You do not need to place the `CalendarView` in exactly the same place, as the
    purpose of the exercise is to get familiar with the visual cues that inform you
    where you have placed it, not to create a replica of my layout.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要将`CalendarView`放在完全相同的位置，因为练习的目的是熟悉通知您放置位置的视觉提示，而不是创建我的布局的复制品。
- en: Using the Component Tree window
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Component Tree窗口
- en: Now, look at the **Component Tree** window, the window to the left of the visual
    designer and below the palette. A component tree is a way of visualizing the layout
    of the XML but without all the details.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看**Component Tree**窗口，即可视化设计师左侧和调色板下方的窗口。组件树是一种可视化XML布局的方式，但没有所有细节。
- en: If you don't see this, look for a tab at the bottom of the **Palette** tab that
    says Component Tree vertically. Click on this to open up the **Component Tree**
    tab.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有看到这个，请在**Palette**选项卡底部找到一个标签，上面写着垂直的Component Tree。单击它以打开**Component Tree**选项卡。
- en: In the next screenshot, we can see that the `CalendarView` is indented to the
    right of the `ConstraintLayout` and is therefore a child. In the next UI we build,
    we will see that we sometimes need to take advantage of the **Component Tree**
    to build the UI.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个截图中，我们可以看到`CalendarView`向右缩进到`ConstraintLayout`的右侧，因此是一个子级。在我们构建的下一个UI中，我们将看到有时需要利用**Component
    Tree**来构建UI。
- en: 'For now, I just want you to see there is a warning sign by our `CalendarView`.
    I have highlighted it here:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我只是想让您看到我们的`CalendarView`旁边有一个警告标志。我在这里突出显示了它：
- en: '![Figure 4.21 – Warning sign by our CalendarView'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21 - 我们的CalendarView旁边的警告标志'
- en: '](img/Figure_4.21_B16773.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.21_B16773.jpg)'
- en: Figure 4.21 – Warning sign by our CalendarView
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 - 我们的CalendarView旁边的警告标志
- en: 'The error says **This view is not constrained. It only has designtime positions,
    so it will jump to (0,0) at runtime unless you add the constraints**. Remember
    when we first added buttons to the screen in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*,
    First Contact: Java, XML, and the UI Designer*, they simply moved off to the top-left
    corner?'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 错误提示**此视图没有约束。它只有设计时位置，因此在运行时会跳转到(0,0)，除非你添加约束**。还记得当我们在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*中首次向屏幕添加按钮时，它们只是移动到左上角吗？
- en: Tip
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Run the app now and click on the `Load ConstraintLayout` button if you want
    to be reminded of this problem.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，如果你想提醒自己这个问题，请点击**加载ConstraintLayout**按钮。
- en: 'Now, we could fix this by clicking the **Infer constraints** button that we
    used in [*Chapter 2*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*, First Contact:
    Java, XML, and the UI Designer*. Here it is again as a reminder:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过点击我们在[*第2章*](B16773_02_ePub_RK.xhtml#_idTextAnchor043)*中使用的**推断约束**按钮来修复这个问题。这里再次提醒一下：
- en: '![Figure 4.22 – Fixing error by clicking the Infer constraints button'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22 - 点击推断约束按钮修复错误'
- en: '](img/Figure_4.22_B16773.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.22_B16773.jpg)'
- en: Figure 4.22 – Fixing error by clicking the Infer constraints button
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22 - 点击推断约束按钮修复错误
- en: But learning to add constraints manually is worthwhile because it offers us
    more options and flexibility. Also, as your layouts get more complex, there is
    always an item or two that doesn't behave as you want it to, and fixing it manually
    is nearly always necessary.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是学会手动添加约束是值得的，因为它为我们提供了更多的选项和灵活性。而且，当你的布局变得更加复杂时，总会有一两个项目的行为不如你所愿，手动修复几乎总是必要的。
- en: Adding constraints manually
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动添加约束
- en: 'Make sure the `CalendarView` is selected, and notice the four small circles
    on the top, bottom, left, and right, as illustrated in the following screenshot:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择了CalendarView，并注意下图中顶部、底部、左侧和右侧的四个小圆圈：
- en: '![Figure 4.23 – The four constraint handles'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23 - 四个约束手柄'
- en: '](img/Figure_4.23_B16773.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.23_B16773.jpg)'
- en: Figure 4.23 – The four constraint handles
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23 - 四个约束手柄
- en: These are the `CalendarView` with the four edges of the screen, we can lock
    it into position when the app is run.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是CalendarView与屏幕的四个边缘，当应用程序运行时，我们可以将其锁定在位置上。
- en: One at a time, click and drag the top handle to the top of the design, the right
    handle to the right of the design, the bottom handle to the bottom, and the left
    handle to the left. Notice how the `CalendarView` is jumping around as we're applying
    these constraints? That's because the designer is applying the constraints as
    soon as we put them in, so we can see exactly how it will look at runtime.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 依次点击并拖动顶部手柄到设计的顶部，右侧手柄到设计的右侧，底部手柄到底部，左侧手柄到左侧。注意当我们应用这些约束时，CalendarView是如何跳动的？这是因为设计师在我们放置约束时立即应用约束，所以我们可以看到它在运行时的实际效果。
- en: 'Notice that the `CalendarView` is now constrained in the center. Left-click
    and drag the `CalendarView` back to the upper part of the screen, somewhere like
    the position shown in the following screenshot. Use the visual cues (also shown
    in the next screenshot) to make sure the `CalendarView` is horizontally central:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，CalendarView现在在中间约束了。左键单击并拖动CalendarView回到屏幕的上部，位置大致如下截图所示。使用视觉线索（也显示在下一个截图中）确保CalendarView水平居中：
- en: '![Figure 4.24 – Making the CalendarView horizontally central'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.24 - 使CalendarView水平居中'
- en: '](img/Figure_4.24_B16773.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.24_B16773.jpg)'
- en: Figure 4.24 – Making the CalendarView horizontally central
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24 - 使CalendarView水平居中
- en: At this stage, you could run the app and the `CalendarView` would be positioned
    as just pictured in the preceding screenshot.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可以运行应用程序，CalendarView将被定位为前面截图中所示。
- en: Let's add a couple more items to the UI and see how to constrain them.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向UI添加更多项目并看看如何约束它们。
- en: Adding and constraining more UI elements
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加和约束更多的UI元素
- en: Drag an `ImageView` from the `CalendarView`. When you place the `ImageView`,
    a pop-up window will prompt you to choose an image. You can choose any image you
    like, but for the purposes of seeing another Android Studio feature in action,
    choose the image from the top of the list, **Avatar**, in the **Sample data**
    section. Click **OK** to add the image to the layout. We will see in the forthcoming
    *Making the text clickable section* the effect of adding an image from the **Sample
    data** section has on our project.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从CalendarView中拖动一个ImageView。当你放置ImageView时，会弹出一个窗口提示你选择一张图片。你可以选择任何你喜欢的图片，但是为了看到另一个Android
    Studio功能的效果，请选择列表顶部的图片**Avatar**，在**示例数据**部分。点击**确定**将图片添加到布局中。我们将在接下来的*使文本可点击部分*看到从**示例数据**部分添加图片对我们项目的影响。
- en: 'Constrain the left-hand side of the `ImageView` and the bottom of the `ImageView`
    to the left and bottom of the UI respectively. Here is the position you should
    be in now:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 将ImageView的左侧和底部分别约束到UI的左侧和底部。现在你应该处于这个位置：
- en: '![Figure 4.25 – Constraining the left-hand-side and the bottom of the ImageView
    respectively to the left and bottom of the UI'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.25 - 将ImageView的左侧和底部分别约束到UI的左侧和底部'
- en: '](img/Figure_4.25_B16773.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.25_B16773.jpg)'
- en: Figure 4.25 – Constraining the left-hand-side and the bottom of the ImageView
    respectively to the left and bottom of the UI
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25 - 将ImageView的左侧和底部分别约束到UI的左侧和底部
- en: 'The `ImageView` is constrained in the bottom-left corner. Now, grab the top
    constraint handle on the `ImageView` and drag it to the bottom constraint handle
    of the `CalendarView`. This is now the current situation:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ImageView在左下角被约束。现在，抓住ImageView上的顶部约束手柄，并将其拖动到CalendarView的底部约束手柄。现在的情况是：
- en: '![Figure 4.26 – Edited UI'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.26 - 编辑的UI'
- en: '](img/Figure_4.26_B16773.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.26_B16773.jpg)'
- en: Figure 4.26 – Edited UI
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26 – 编辑后的UI
- en: The `ImageView` is only constrained horizontally on one side and so is pinned/constrained
    to the left. It is constrained vertically and equally between the `CalendarView`
    and the bottom of the UI.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImageView` 只在水平方向上有约束，因此被固定/约束在左侧。它在`CalendarView`和UI底部之间垂直并且等距约束。'
- en: 'Next, add a `TextView` to the right of the `ImageView`. Constrain the right
    of the `TextView` to the right of the UI and constrain the left of the `TextView`
    to the right of the `ImageView`. Then, constrain the top of the `TextView` to
    the top of the `ImageView` and constrain the bottom of the `TextView` to the bottom
    of the UI. Now, you will be left with something resembling this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`ImageView`的右侧添加一个`TextView`。将`TextView`的右侧约束到UI的右侧，并将`TextView`的左侧约束到`ImageView`的右侧。然后，将`TextView`的顶部约束到`ImageView`的顶部，并将`TextView`的底部约束到UI的底部。现在，您将得到类似于以下内容：
- en: '![Figure 4.27 – Adding a TextView to the UI'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.27 – 将TextView添加到UI'
- en: '](img/Figure_4.27_B16773.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.27_B16773.jpg)'
- en: Figure 4.27 – Adding a TextView to the UI
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27 – 将TextView添加到UI
- en: Important note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: All the warnings in the `strings.xml` file, and a warning about missing the
    `contentDescription` attribute. The `contentDescription` attribute should be used
    to add a textual description so that visually impaired users can get a spoken
    description of images in the app. For the sake of making fast progress with the
    `ConstraintLayout`, we will ignore these two warnings. We will look at adding
    String resources more correctly in [*Chapter 18*](B16773_18_ePub_RK.xhtml#_idTextAnchor320),
    *Localization*, and you can read about accessibility features in Android Studio
    on the *Android Developers* website, at [https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`strings.xml`文件中的所有警告，以及有关缺少`contentDescription`属性的警告。`contentDescription`属性应用于添加文本描述，以便视力受损的用户可以在应用程序中获得图像的口头描述。为了快速进展`ConstraintLayout`，我们将忽略这两个警告。我们将在[*第18章*](B16773_18_ePub_RK.xhtml#_idTextAnchor320)中更正确地添加字符串资源，*本地化*，您可以在*Android开发者*网站上阅读有关Android
    Studio的辅助功能的信息，网址为[https://developer.android.com/studio/intro/accessibility](https://developer.android.com/studio/intro/accessibility)。'
- en: 'You can move the three UI elements around and line them up neatly, just how
    you want them. Notice that when you move the `ImageView`, the `TextView` moves
    with it because the `TextView` is constrained to the `ImageView`. But also notice
    that you can move the `TextView` independently and, wherever you drop it, this
    represents its new constrained position relative to the `ImageView`. Whatever
    an item is constrained to, its position will always be relative to that item.
    And as we have seen, the horizontal and vertical constraints are distinct from
    each other. I positioned mine like this:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以移动三个UI元素并将它们整齐地排列，就像您想要的那样。请注意，当您移动`ImageView`时，`TextView`也会随之移动，因为`TextView`受到`ImageView`的约束。但也请注意，您可以独立移动`TextView`，无论您放在哪里，这都代表了它相对于`ImageView`的新约束位置。无论一个项目受到什么约束，它的位置始终是相对于该项目的。正如我们所见，水平和垂直约束是彼此独立的。我将我的位置放在这里：
- en: '![Figure 4.28 – Positioning the TextView'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.28 – 定位TextView'
- en: '](img/Figure_4.28_B16773.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.28_B16773.jpg)'
- en: Figure 4.28 – Positioning the TextView
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.28 – 定位TextView
- en: Tip
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: '`ConstraintLayout` could be considered the default layout type, and while it
    is more complex than the other layouts it is the most powerful, as well as the
    one that runs the best on our user''s device. It is worth spending time looking
    at some more tutorials about `ConstraintLayout`. Especially look on *YouTube*,
    as video is a great way to learn about tweaking `ConstraintLayout`. We will return
    to `ConstraintLayout` throughout the book, and you do not need to know any more
    than we have covered already to be able to move on.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout`可以被认为是默认的布局类型，虽然它比其他布局更复杂，但它是最强大的，也是在我们用户设备上运行最好的。值得花时间查看一些关于`ConstraintLayout`的更多教程。特别是在*YouTube*上查看，因为视频是学习调整`ConstraintLayout`的好方法。我们将在整本书中回到`ConstraintLayout`，而且您不需要知道比我们已经涵盖的更多内容才能继续前进。'
- en: Making the text clickable
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使文本可点击
- en: We are nearly done with our `ConstraintLayout`. We just want to wire up a link
    back to the main menu screen. This is a good opportunity to demonstrate that `TextView`
    (and most other UI items) are also clickable. In fact, clickable text is probably
    more common in modern Android apps than conventional-looking buttons.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`ConstraintLayout`快要完成了。我们只想要连接回主菜单屏幕的链接。这是一个很好的机会来演示`TextView`（以及大多数其他UI项）也是可点击的。事实上，可点击的文本在现代Android应用程序中可能比传统的按钮更常见。
- en: Change the `text` attribute of the `TextView` widget to `Back to the menu`.
    Now, find the `onClick` attribute and enter `loadMenuLayout`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TextView`小部件的`text`属性更改为“返回菜单”。现在，找到`onClick`属性，并输入`loadMenuLayout`。
- en: 'Now, add the following method to the `MainActivity.java` file just after the
    `loadTableLayout` method, as highlighted next:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MainActivity.java`文件中，在`loadTableLayout`方法之后添加以下方法，如下所示：
- en: '[PRE10]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, whenever the user clicks the `loadMenuLayout` method will be called and
    the `setContentView` method will load the layout in `main_menu.xml`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当用户点击时，`loadMenuLayout`方法将被调用，并且`setContentView`方法将在`main_menu.xml`中加载布局。
- en: You can run the app and click back and forth between the main menu (`LinearLayout`)
    and the `CalendarView` widget (`ConstraintLayout`), but have you noticed that
    the image in the following screenshot seems to be missing?
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行应用程序，并在主菜单（`LinearLayout`）和`CalendarView`小部件（`ConstraintLayout`）之间来回点击，但您是否注意到以下截图中的图像似乎丢失了？
- en: '![Figure 4.29 – Image missing from the UI'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.29 – UI中缺少的图像'
- en: '](img/Figure_4.29_B16773.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.29_B16773.jpg)'
- en: Figure 4.29 – Image missing from the UI
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.29 – UI中缺少的图像
- en: The `TextView` widget is neatly positioned as if the `ImageView` widget were
    there, but as we can see from the preceding screenshot, the avatar icon that is
    visible in Android Studio is absent. The reason for this is because we chose the
    image from the **sample data** category. Android Studio allows us to use sample
    data so that we can get on with the job of laying out our apps before the images
    are available. This is useful because it is quite common that images will need
    to be produced/sourced throughout the development life cycle of an app.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '`TextView`小部件被整齐地定位，就好像`ImageView`小部件在那里一样，但是从前面的屏幕截图中可以看到，Android Studio中可见的头像图标已经消失了。这是因为我们选择了**示例数据**类别中的图像。Android
    Studio允许我们使用示例数据，这样我们就可以在图像可用之前继续布局我们的应用程序。这很有用，因为在应用程序的开发生命周期中通常需要制作/获取图像。'
- en: 'To solve this missing image problem, we can simply find the `srcCompat` attribute
    in the `Attributes` window, left-click it, and choose any image that is not from
    the `sym_def_app_icon`, which is the cool Android icon shown next:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个缺失图像的问题，我们可以在`Attributes`窗口中找到`srcCompat`属性，左键单击它，并选择不是来自`sym_def_app_icon`的任何图像，这是下一个酷炫的Android图标：
- en: '![Figure 4.30 – Adding an icon from the srcCompat attribute'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.30 - 从srcCompat属性添加图标'
- en: '](img/Figure_4.30_B16773.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.30_B16773.jpg)'
- en: Figure 4.30 – Adding an icon from the srcCompat attribute
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.30 - 从srcCompat属性添加图标
- en: Let's build the final layout for this chapter.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为本章构建最终布局。
- en: Laying out data with TableLayout
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TableLayout布局数据
- en: Now, we will build a layout that resembles a spreadsheet. It will have neatly
    aligned cells with titles and data. In a real-world app, you would most likely
    use real live data from the user. As we are just practicing with different layouts,
    we will not go to this extent.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将构建一个类似电子表格的布局。它将具有整齐对齐的带有标题和数据的单元格。在真实的应用程序中，您很可能会使用来自用户的真实实时数据。由于我们只是练习不同的布局，我们不会走到这一步。
- en: 'Follow these steps:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤：
- en: In the project window, expand the `res` folder. Now, right-click the `layout`
    folder and select **New**. Notice that there is an option for **Layout resource
    file**.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目窗口中，展开`res`文件夹。现在，右键单击`layout`文件夹，然后选择**New**。注意到有一个**Layout resource file**选项。
- en: Select **Layout resource file**, and you will see the **New Resource File**
    dialog window.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Layout resource file**，然后您将看到**New Resource File**对话框窗口。
- en: In the `my_table_layout`. This is the same name we used in the call to `setContentView`
    within the `loadTableLayout` method.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`my_table_layout`中。这与我们在`loadTableLayout`方法中对`setContentView`的调用中使用的名称相同。
- en: Notice in the `ConstraintLayout` and type `TableLayout`.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意`ConstraintLayout`中的`TableLayout`。
- en: Click the `TableLayou`t in an XML file called `my_table_layout` and place it
    in the `layout` folder, ready for us to build our new table-based UI. Android
    Studio will also open the UI designer (if it isn't already open) with the palette
    on the left and the **Attributes** window on the right.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击XML文件中的`TableLayout`，命名为`my_table_layout`，并将其放在`layout`文件夹中，准备构建我们的基于表格的新UI。如果UI设计师尚未打开，Android
    Studio还将打开UI设计师，左侧是调色板，右侧是**Attributes**窗口。
- en: 'You can now uncomment the `loadTableLayout` method in the `MainActivity.java`
    file, as follows:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以取消注释`MainActivity.java`文件中的`loadTableLayout`方法，如下所示：
- en: '[PRE11]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can now switch to the screen with the new `TableLayout` widget when you
    run the app, although at the moment it is blank and there is no way of switching
    back to the main menu screen; therefore, you will have to quit the app.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您运行应用程序时，可以切换到具有新的`TableLayout`小部件的屏幕，尽管目前它是空白的，并且没有办法切换回主菜单屏幕；因此，您将不得不退出应用程序。
- en: Adding a TableRow element to TableLayout
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向TableLayout添加一个TableRow元素
- en: Drag a `TableRow` element from the `Layouts` category on to the UI design. Notice
    that the appearance of this new `TableRow` element is virtually imperceptible,
    so much so that it is not worth putting a screenshot of it in the book. There
    is just a thin blue line at the top of the UI. This is because the `TableRow`
    element has collapsed itself around its contents, which are currently empty.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Layouts`类别中拖放一个`TableRow`元素到UI设计中。请注意，这个新的`TableRow`元素的外观几乎是不可察觉的，以至于不值得在书中放置它的屏幕截图。UI顶部只有一条蓝线。这是因为`TableRow`元素已经将其内容折叠在一起，而这些内容目前是空的。
- en: It is possible to drag and drop our chosen UI elements onto this thin blue line,
    but it is also a little awkward, even counterintuitive. Furthermore, once we have
    multiple `TableRow` elements next to each other, it gets even harder. The solution
    lies in the `ConstraintLayout`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所选的UI元素拖放到这条蓝线上，但这也有点麻烦，甚至有点违反直觉。此外，一旦我们在一起有多个`TableRow`元素，情况就会变得更加困难。解决方案在于`ConstraintLayout`。
- en: Using the Component Tree for when the visual designer won't do
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用组件树进行可视化设计师无法完成的布局
- en: 'Look at the `TableRow` as a child of the `TableLayout`. We can drag our new
    UI widgets directly onto the `TableRow` in the `TextView` widgets onto the `TableRow`
    in the **Component Tree**, and that should leave you with the following layout.
    I have Photoshopped the next screenshot to show you the **Component Tree** and
    the regular UI designer at the same time:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 将`TableRow`视为`TableLayout`的子元素。我们可以直接将新的UI小部件拖放到`TableRow`中，在**Component Tree**中的`TextView`小部件拖放到`TableRow`中，这样就会得到以下布局。我已经使用Photoshop修改了下一个屏幕截图，以便同时显示**Component
    Tree**和常规UI设计师：
- en: '![Figure 4.31 – Dragging three TextView widgets onto the TableRow element in
    the Component Tree'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.31 - 将三个TextView小部件拖放到组件树中的TableRow元素上'
- en: '](img/Figure_4.31_B16773.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.31_B16773.jpg)'
- en: Figure 4.31 – Dragging three TextView widgets onto the TableRow element in the
    Component Tree
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.31 - 将三个TextView小部件拖放到组件树中的TableRow元素上
- en: Now, add another two `TableRow` widgets (from the **Layouts** category). You
    can add them via the **Component Tree** window or the main UI designer.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加另外两个`TableRow`小部件（来自**Layouts**类别）。您可以通过**Component Tree**窗口或主UI设计师添加它们。
- en: Tip
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You need to drop the widgets on the far left of the window, otherwise the new
    `TableRow` will become a child of the previous `TableRow`. This would leave the
    whole table in a bit of a muddle. If you accidentally add a `TableRow` as a child
    of the previous `TableRow`, you can either select it then tap the *Delete* key,
    use the *Ctrl* + *z* keyboard combination to undo it, or drag the mispositioned
    `TableRow` to the left (in the `Table` (instead of `TableRow`).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将小部件放在窗口的最左侧，否则新的`TableRow`将成为上一个`TableRow`的子级。这将使整个表格变得有些混乱。如果您意外地将`TableRow`添加为上一个`TableRow`的子级，您可以选择它，然后点击*删除*键，使用*Ctrl*
    + *z*键组合进行撤消，或者将位置错误的`TableRow`拖到左侧（在`Table`中而不是`TableRow`）。
- en: 'Now, add three `TextView` widgets to each of the new `TableRow` elements. This
    will be most easily achieved by adding them via the **Component Tree** window.
    Check your layout to make sure it is like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，向每个新的`TableRow`元素添加三个`TextView`小部件。最简单的方法是通过**组件树**窗口添加它们。检查您的布局，确保它是这样的：
- en: '![Figure 4.32 – Adding three TextView widgets to each of the new TableRow elements'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.32 – 向每个新的TableRow元素添加三个TextView小部件'
- en: '](img/Figure_4.32_B16773.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.32_B16773.jpg)'
- en: Figure 4.32 – Adding three TextView widgets to each of the new TableRow elements
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32 – 向每个新的TableRow元素添加三个TextView小部件
- en: Let's make the table look more like a genuine table of data you might get in
    an app by changing some attributes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过更改一些属性使表格看起来更像您可能在应用程序中获得的真实数据表。
- en: On the `TableLayout`, set the `layout_width` and `layout_height` attributes
    to `wrap_content`. This gets rid of extra cells
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在`TableLayout`上，将`layout_width`和`layout_height`属性设置为`wrap_content`。这样可以去掉多余的单元格
- en: Change all the outer (along the top and down the left-hand side) `TextView`
    widgets to black by editing the `textColor` attribute. You can achieve this by
    selecting the first `TextView`, searching for its `color` attribute, and then
    starting to type `black` into the `color` attribute values field. You will then
    be able to select `@android:color/black` from a drop-down list. Do this for each
    of the outer `TextView` widgets.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`textColor`属性，将所有外部（顶部和左侧）的`TextView`小部件更改为黑色。您可以通过选择第一个`TextView`，搜索其`color`属性，然后开始在`color`属性值字段中输入`black`来实现这一点。然后，您将能够从下拉列表中选择`@android:color/black`。对每个外部`TextView`小部件都这样做。
- en: Tip
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Remember you can select multiple widgets at the same time by holding the *Shift*
    key and left-clicking each required widget in turn.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您可以通过按住*Shift*键并依次左键单击每个所需的小部件来同时选择多个小部件。
- en: Find the `padding` category for all the `TextView` widgets, and change the `padding`
    attribute to `10sp`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 找到所有`TextView`小部件的`padding`类别，并将`padding`属性更改为`10sp`。
- en: 'This next screenshot shows what the table looks like in Android Studio at this
    stage:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了此时在Android Studio中表格的样子：
- en: '![Figure 4.33 – The table in Android Studio'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.33 – Android Studio中的表格'
- en: '](img/Figure_4.33_B16773.jpg)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.33_B16773.jpg)'
- en: Figure 4.33 – The table in Android Studio
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33 – Android Studio中的表格
- en: Let's add some finishing touches to the table.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为表格添加一些最后的修饰。
- en: Organizing the table columns
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织表格列
- en: It might seem at this point that we are done, but we need to organize the data
    better. Our table, as with many tables, will have a blank cell in the top left
    to divide the column and row titles. To achieve this, we need to number all the
    cells. For this, we need to edit the `layout_column` attribute.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 此时似乎我们已经完成了，但是我们需要更好地组织数据。我们的表格，就像许多表格一样，将在左上角有一个空白单元格来分隔列和行标题。为了实现这一点，我们需要对所有单元格进行编号。为此，我们需要编辑`layout_column`属性。
- en: Tip
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Cell numbers are numbered from 0 from the left.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 单元格编号从左边开始从0开始。
- en: Start by deleting the top-left `TextView`. Notice the `TextView` from the right
    has moved into the top-left position.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 首先删除左上角的`TextView`。注意右侧的`TextView`已经移动到左上角位置。
- en: Next, in the new top-left `TextView`, edit the `layout_column` attribute to
    be `1` (this assigns it to the second cell because the first cell is `0`, and
    we want to leave the first one empty), and for the next cell along, edit the `layout_column`
    attribute to be `2`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在新的左上角`TextView`中，编辑`layout_column`属性为`1`（这将其分配给第二个单元格，因为第一个单元格是`0`，我们希望将第一个单元格留空），并且对于下一个单元格，编辑`layout_column`属性为`2`。
- en: 'The result should look like this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是这样的：
- en: '![Figure 4.34 – Table column organized'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.34 – 表列组织'
- en: '](img/Figure_4.34_B16773.jpg)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.34_B16773.jpg)'
- en: Figure 4.34 – Table column organized
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34 – 表列组织
- en: For the next two rows of cells, edit their `layout_column` attributes from `0`
    to `2` from left to right.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下面两行单元格，从左到右将它们的`layout_column`属性从`0`更改为`2`。
- en: If you want clarification on the precise code for this row after editing, here
    is a snippet, and remember to look in the download bundle in the [*Chapter 4*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)
    folder to see the whole file in context.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在编辑后想要对此行的精确代码进行澄清，请参阅以下代码片段，并记得在[*第4章*](B16773_04_ePub_RK.xhtml#_idTextAnchor076)文件夹中的下载包中查看整个文件的上下文。
- en: Important note
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '[PRE12]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Try to complete this exercise, however, using the **Attributes** window if possible.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试完成这个练习，如果可能的话，使用**属性**窗口。
- en: Linking back to the main menu
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接回主菜单
- en: 'Finally, for this layout, we will add a button that links back to the menu,
    as follows:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于这个布局，我们将添加一个按钮，链接回菜单，如下所示：
- en: Add another `TableRow` via the **Component Tree**.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**组件树**添加另一个`TableRow`。
- en: Drag a button onto the new `TableRow`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个按钮拖到新的`TableRow`上。
- en: Edit its `layout_column` attribute to `1` so that it is in the middle of the
    row.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`layout_column`属性编辑为`1`，使其位于行的中间。
- en: Edit its `text` attribute to `Menu` and edit its `onClick` attribute to match
    our already existing `loadMenuLayout` method.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其`text`属性编辑为`Menu`，并将其`onClick`属性编辑为匹配我们已经存在的`loadMenuLayout`方法。
- en: You can now run the app and switch back and forth between the different layouts.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以运行应用程序并在不同的布局之间来回切换。
- en: 'If you want to, you can add some meaningful titles and data to the table by
    editing all the `text` attributes of the `TextView`, as I have done in the following
    screenshot, which shows the `TableLayout` running in the emulator:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以通过编辑TextView的所有`text`属性向表格添加一些有意义的标题和数据，就像我在下面的截图中所做的那样，它展示了在模拟器中运行的TableLayout：
- en: '![Figure 4.35 – Adding some significant titles and data to the table by editing
    all the text attributes of the TextView'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.35 - 通过编辑TextView的所有文本属性向表格添加一些重要的标题和数据'
- en: '](img/Figure_4.35_B16773.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_4.35_B16773.jpg)'
- en: Figure 4.35 – Adding some significant titles and data to the table by editing
    all the text attributes of the TextView
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35 - 通过编辑TextView的所有文本属性向表格添加一些重要的标题和数据
- en: Note
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The author admits that the preceding data might be considered overly optimistic.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 作者承认，前述数据可能被认为过于乐观。
- en: As a final thought, think about an app that presents tables of data. Chances
    are that data will be added to the table dynamically, not by the developer at
    design time as we have just done, but more likely by the user or from a database
    on the web. In [*Chapter 16*](B16773_16_ePub_RK.xhtml#_idTextAnchor285), *Adapters
    and Recyclers*, we will see how to dynamically add data to different types of
    layout using adapters; and in [*Chapter 27*](B16773_27_ePub_RK.xhtml#_idTextAnchor462),
    *Android Databases*, we will also see how to create and use databases in our apps.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，想想一个展示数据表的应用程序。很可能数据将动态地添加到表中，而不是由开发人员在设计时像我们刚刚做的那样，而更可能是由用户或来自网络上的数据库添加。在[*第16章*](B16773_16_ePub_RK.xhtml#_idTextAnchor285)，*适配器和回收器*中，我们将看到如何使用适配器动态地向不同类型的布局添加数据；在[*第27章*](B16773_27_ePub_RK.xhtml#_idTextAnchor462)，*Android数据库*中，我们还将看到如何在我们的应用程序中创建和使用数据库。
- en: Summary
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have covered many topics in just a few dozen pages. We have not only built
    three different types of layout—including `LinearLayout` with nested layouts,
    `ConstraintLayout` with manually configured constraints, and `TableLayout` (albeit
    with fake data) —but we have also wired all the layouts together with clickable
    buttons and text that trigger our Java code to switch between all these different
    layouts.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短短几十页中涵盖了许多主题。我们不仅构建了三种不同类型的布局，包括带有嵌套布局的`LinearLayout`，手动配置约束的`ConstraintLayout`，以及`TableLayout`（尽管使用的是虚假数据），而且还通过可点击的按钮和文本将所有布局连接在一起，触发我们的Java代码在所有这些不同的布局之间切换。
- en: In the next chapter, we will stick with the topic of layouts. We will review
    many attributes we have seen, and we will build our most aesthetically pleasing
    layout so far by incorporating multiple `CardView` layouts, complete with depth
    and shadow into a smooth-scrolling `ScrollView` layout.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续讨论布局的主题。我们将回顾我们已经见过的许多属性，并且通过将多个`CardView`布局整合到一个平滑滚动的`ScrollView`布局中，构建迄今为止最美观的布局。
