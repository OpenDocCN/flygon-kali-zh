- en: Chapter 11. Coding and Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。编码和设计模式
- en: Now that you know all about the objects in JavaScript, mastered prototypes and
    inheritance, and seen some practical examples of using browser-specific objects,
    let's move forward, or rather, move a level up. Let's take a look at some common
    JavaScript patterns.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然您已经了解了JavaScript中的所有对象，掌握了原型和继承，并看到了使用特定于浏览器的对象的一些实际示例，让我们继续前进，或者说，向上移动一级。让我们来看看一些常见的JavaScript模式。
- en: But first, what's a pattern? In short, a pattern is a good solution to a common
    problem. Codifying the solution into a pattern makes it repeatable as well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，什么是模式？简而言之，模式是对常见问题的良好解决方案。将解决方案编码为模式使其可重复使用。
- en: Sometimes, when you're facing a new programming problem, you may recognize right
    away that you've previously solved another, suspiciously similar problem. In such
    cases, it's worth isolating this class of problems and searching for a common
    solution. A pattern is a proven and reusable solution (or an approach to a solution)
    to a class of problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当您面对一个新的编程问题时，您可能立即意识到您以前解决过另一个非常相似的问题。在这种情况下，值得将这类问题隔离出来，并寻找一个共同的解决方案。模式是一种经过验证和可重复使用的解决方案（或解决方案的方法）。
- en: There are cases where a pattern is nothing more than an idea or a name. Sometimes,
    just using a name helps you think more clearly about a problem. Also, when working
    with other developers in a team, it's much easier to communicate when everybody
    uses the same terminology to discuss a problem or a solution.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模式只是一个想法或一个名称。有时，仅仅使用一个名称可以帮助您更清晰地思考问题。此外，在团队中与其他开发人员合作时，当每个人使用相同的术语讨论问题或解决方案时，沟通会更容易。
- en: Other times, you may come across a unique problem that doesn't look like anything
    you've seen before and doesn't readily fit into a known pattern. Blindly applying
    a pattern just for the sake of using a pattern, is not a good idea. It's preferable
    to not use any known pattern than to try to tweak your problem so that it fits
    an existing solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能会遇到一个独特的问题，看起来与您以前见过的任何东西都不一样，并且不容易适应已知的模式。盲目地应用模式只是为了使用模式，这不是一个好主意。最好不要使用任何已知的模式，而是尝试调整问题，使其适应现有的解决方案。
- en: 'This chapter talks about two types of patterns, which are as follows:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了以下两种模式：
- en: '**Coding patterns**: These are mostly JavaScript-specific best practices'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码模式**：这些主要是JavaScript特定的最佳实践'
- en: '**Design patterns**: These are language-independent patterns, popularized by
    the famous *Gang of Four* book'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计模式**：这些是与语言无关的模式，由著名的*四人帮*书籍推广'
- en: Coding patterns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码模式
- en: 'Let''s start with some patterns that reflect JavaScript''s unique features.
    Some patterns aim to help you organize your code, for example, namespacing; others
    are related to improving performance, such as lazy definitions and init-time branching;
    and some make up for missing features, such as private properties. The patterns
    discussed in this section include the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一些反映JavaScript独特特性的模式开始。一些模式旨在帮助您组织代码，例如命名空间；其他与改进性能有关，例如延迟定义和初始化时分支；还有一些弥补了缺失的功能，例如私有属性。本节讨论的模式包括以下主题：
- en: Separating behavior
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离行为
- en: Namespaces
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Init-time branching
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化时分支
- en: Lazy definition
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟定义
- en: Configuration objects
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置对象
- en: Private variables and methods
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有变量和方法
- en: Privileged methods
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特权方法
- en: Private functions as public methods
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将私有函数作为公共方法
- en: Immediate functions
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数
- en: Chaining
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接
- en: JSON
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON
- en: Separating behavior
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离行为
- en: 'As discussed previously, the three building blocks of a web page are as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，网页的三个构建块如下：
- en: Content (HTML)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容（HTML）
- en: Presentation (CSS)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示（CSS）
- en: Behavior (JavaScript)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为（JavaScript）
- en: Content
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容
- en: HTML is the content of the web page, the actual text. Ideally, the content should
    be marked-up using the least amount of HTML tags that sufficiently describe the
    semantic meaning of that content. For example, if you're working on a navigation
    menu, it's a good idea to use the `<ul>` and `<li>` tags as a navigation menu
    is in essence, just a list of links.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: HTML是网页的内容，实际文本。理想情况下，内容应该使用尽可能少的HTML标记进行标记，以充分描述该内容的语义含义。例如，如果您正在处理导航菜单，最好使用`<ul>`和`<li>`标记，因为导航菜单本质上只是一个链接列表。
- en: 'Your content (HTML) should be free from any formatting elements. Visual formatting
    belongs to the presentation layer and should be achieved through the use of **CSS**
    (**Cascading Style Sheets**). This means the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您的内容（HTML）应该不包含任何格式化元素。视觉格式应属于演示层，并且应通过**CSS**（层叠样式表）来实现。这意味着以下内容：
- en: The style attribute of HTML tags should not be used, if possible.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能的话，不应该使用HTML标记的样式属性。
- en: Presentational HTML tags such as `<font>` should not be used at all.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根本不应该使用`<font>`等呈现HTML标签。
- en: Tags should be used for their semantic meaning, not because of how browsers
    render them by default. For instance, developers sometimes use a `<div>` tag where
    a `<p>` would be more appropriate. It's also favorable to use `<strong>` and `<em>`
    instead of `<b>` and `<i>` as the latter describe the visual presentation rather
    than the meaning.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记应该根据其语义含义使用，而不是因为浏览器默认呈现它们。例如，开发人员有时会在更适合使用`<p>`的地方使用`<div>`标记。使用`<strong>`和`<em>`而不是`<b>`和`<i>`也是有利的，因为后者描述的是视觉呈现而不是含义。
- en: Presentation
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示
- en: A good approach to keep presentation out of the content is to reset or nullify
    all browser defaults, for example, using `reset.css` from the Yahoo! UI library.
    This way, the browser's default rendering won't distract you from consciously
    thinking about the proper semantic tags to use.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将演示内容与内容分开的一个好方法是重置或清空所有浏览器默认设置，例如使用来自Yahoo! UI库的`reset.css`。这样，浏览器的默认呈现不会让您分心，而是会让您有意识地考虑使用适当的语义标记。
- en: Behavior
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 行为
- en: The third component of a web page is the behavior. Behavior should be kept separate
    from both the content and the presentation. It is usually added by using JavaScript
    that is isolated to `<script>` tags, and preferably contained in external files.
    This means not using any inline attributes, such as `onclick`, `onmouseover`,
    and so on. Instead, you can use the `addEventListener`/`attachEvent` methods from
    the previous chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 网页的第三个组件是行为。行为应该与内容和表现分开。通常使用隔离在`<script>`标签中的JavaScript来添加，最好包含在外部文件中。这意味着不使用任何内联属性，如`onclick`，`onmouseover`等。相反，您可以使用上一章中的`addEventListener`/`attachEvent`方法。
- en: 'The best strategy to separate behavior from content is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将行为与内容分离的最佳策略如下：
- en: Minimize the number of `<script>` tags
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化`<script>`标签的数量
- en: Avoid inline event handlers
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免内联事件处理程序
- en: Do not use CSS expressions
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用CSS表达式
- en: Toward the end of your content, when you are ready to close the `<body>` tag,
    insert a single `external.js` file
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在内容的末尾，当您准备关闭`<body>`标签时，插入一个`external.js`文件
- en: Example of separating behavior
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 行为分离示例
- en: 'Let''s say you have a search form on a page, and you want to validate the form
    with JavaScript. So, you go ahead and keep the `form` tags free from any JavaScript,
    and then immediately before closing the `</body>` tag, you insert a `<script>`
    tag that links to an external file, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在页面上有一个搜索表单，并且希望使用JavaScript验证表单。因此，您可以继续保持`form`标签不受任何JavaScript的影响，然后在关闭`</body>`标签之前立即插入一个链接到外部文件的`<script>`标签，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In `behaviors.js` you attach an event listener to the submit event. In your
    listener, you can check to see if the text input field was left blank and, if
    so, stop the form from being submitted. This way, you will save a roundtrip between
    the server and the client and make the application immediately responsive.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在`behaviors.js`中，您可以将事件侦听器附加到提交事件。在您的侦听器中，您可以检查文本输入字段是否为空，如果是，则阻止表单提交。这样，您将节省服务器和客户端之间的往返，并使应用程序立即响应。
- en: 'The content of `behaviors.js` is given in the following code. It assumes that
    you''ve created your `myevent` utility from the exercise at the end of the previous
    chapter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`behaviors.js`的内容如下所示。它假定您已经根据上一章的练习创建了您的`myevent`实用程序：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Asynchronous JavaScript loading
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步JavaScript加载
- en: You noticed how the script was loaded at the end of the HTML, right before closing
    the body. The reason is that JavaScript blocks the DOM construction of the page,
    and in some browsers, even downloads of the other components that follow. By moving
    the scripts to the bottom of the page, you ensure that the script is out of the
    way, and when it arrives, it simply enhances the already usable page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您注意到脚本是在HTML结束前加载的，就在关闭body之前。原因是JavaScript会阻止页面的DOM构建，并且在某些浏览器中，甚至会阻止后续组件的下载。通过将脚本移动到页面底部，您可以确保脚本不会妨碍，并且当它到达时，它只是增强了已经可用的页面。
- en: 'Another way to prevent external JavaScript files from blocking the page is
    to load them asynchronously. This way you can start loading them earlier. HTML5
    has the `defer` attribute for this purpose. Consider the following line of code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 防止外部JavaScript文件阻止页面的另一种方法是异步加载它们。这样您可以更早地开始加载它们。HTML5具有此目的的`defer`属性。请考虑以下代码行：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Unfortunately, the `defer` attribute is not supported by older browsers, but
    luckily, there is a solution that works across browsers, old and new. The solution
    is to create a `script` node dynamically and append it to the DOM. In other words,
    you can use a bit of inline JavaScript to load the external JavaScript file. You
    can have this script loader snippet at the top of your document so that the download
    has an early start. Take a look at the following code example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`defer`属性不受旧版浏览器支持，但幸运的是，有一个可以跨浏览器（新旧）工作的解决方案。解决方案是动态创建一个`script`节点并将其附加到DOM。换句话说，您可以使用一点内联JavaScript来加载外部JavaScript文件。您可以在文档顶部放置此脚本加载程序片段，以便下载可以尽早开始。请看以下代码示例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Namespaces
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: Global variables should be avoided in order to reduce the possibility of variable
    naming collisions. You can minimize the number of globals by namespacing your
    variables and functions. The idea is simple, you will create only one global object,
    and all your other variables and functions become properties of that object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 应避免全局变量以减少变量命名冲突的可能性。通过为变量和函数命名空间化，您可以最小化全局变量的数量。这个想法很简单，您只会创建一个全局对象，而您的所有其他变量和函数都成为该对象的属性。
- en: An Object as a namespace
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象作为命名空间
- en: 'Let''s create a global object called `MYAPP`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`MYAPP`的全局对象：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, instead of having a global `myevent` utility (from the previous chapter),
    you can have it as an `event` property of the `MYAPP` object, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再需要全局的`myevent`实用程序（来自上一章），您可以将其作为`MYAPP`对象的`event`属性，如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Adding the methods to the `event` utility is still the same. Consider the following
    example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 向`event`实用程序添加方法仍然是相同的。请考虑以下示例：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Namespaced constructors
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间构造函数
- en: 'Using a namespace doesn''t prevent you from creating constructor functions.
    Here is how you can have a DOM utility that has an `Element` constructor, which
    allows you to create DOM elements easily:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名空间不妨碍您创建构造函数。以下是如何创建具有`Element`构造函数的DOM实用程序，它允许您轻松创建DOM元素：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Similarly, you can have a `Text` constructor to create text nodes. Consider
    the following code example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以有一个`Text`构造函数来创建文本节点。请考虑以下代码示例：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the constructors to create a link at the bottom of a page can be done
    as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数在页面底部创建链接可以按以下方式完成：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A namespace() method
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个命名空间()方法
- en: 'You can create a namespace utility that makes your life easier so that you
    can use more convenient syntax as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个命名空间实用程序，使您的生活更轻松，以便您可以使用更方便的语法，如下所示：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Instead of the more verbose syntax as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是更冗长的语法如下：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s how you can create such a `namespace()` method. First, you will create
    an array by splitting the input string using the period (`.`) as a separator.
    Then, for every element in the new array, you will add a property to your global
    object, if one doesn''t already exist, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何创建`namespace()`方法的方法。首先，您将使用句点（`.`）作为分隔符拆分输入字符串，创建一个数组。然后，对于新数组中的每个元素，如果全局对象中不存在该属性，则添加一个属性，如下所示：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Testing the new method is done as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下方式进行新方法的测试：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result of the preceding code is the same as if you did the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的结果与以下操作相同：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Init-time branching
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化时分支
- en: In the previous chapter, you noticed that sometimes, different browsers have
    different implementations for the same or similar functionalities. In such cases,
    you will need to branch your code, depending on what's supported by the browser
    currently executing your script. Depending on your program, this branching can
    happen far too often and, as a result, may slow down the script execution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，您注意到有时不同的浏览器对相同或类似的功能有不同的实现。在这种情况下，您需要根据当前执行脚本的浏览器支持的内容对代码进行分支。根据您的程序，这种分支可能会发生得太频繁，结果可能会减慢脚本的执行速度。
- en: You can mitigate this problem by branching some parts of the code during initialization,
    when the script loads, rather than during runtime. Building upon the ability to
    define functions dynamically, you can branch and define the same function with
    a different body, depending on the browser. Let's see how.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在初始化时对代码的某些部分进行分支来缓解这个问题，当脚本加载时，而不是在运行时。借助动态定义函数的能力，您可以根据浏览器的不同分支和定义相同的函数，具体取决于浏览器。让我们看看如何。
- en: 'First, let''s define a namespace and placeholder method for the `event` utility:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个命名空间和`event`实用程序的占位符方法。
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'At this point, the methods to add or remove a listener are not implemented.
    Based on the results from feature sniffing, these methods can be defined differently,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，添加或删除侦听器的方法尚未实现。根据特性嗅探的结果，可以以不同的方式定义这些方法，如下所示：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: After this script executes, you have the `addListener()` and `removeListener()`
    methods defined in a browser-dependent way. Now, every time you invoke one of
    these methods, there's no more feature-sniffing, and it results in less work and
    faster execution.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本执行后，您将以与浏览器相关的方式定义`addListener()`和`removeListener()`方法。现在，每次调用这些方法时，都不再需要特性嗅探，这将减少工作量并加快执行速度。
- en: One thing to watch out for when sniffing features is not to assume too much
    after checking for one feature. In the previous example, this rule is broken because
    the code only checks for `addEventListener` support, but then defines both `addListener()`
    and `removeListener()`. In this case, it's probably safe to assume that if a browser
    implements `addEventListener()`, it also implements `removeEventListener()`. However,
    imagine what happens if a browser implements `stopPropagation()` but not `preventDefault()`,
    and you haven't checked for these individually. You have assumed that because
    `addEventListener()` is not defined, the browser must be an old IE and write your
    code using your knowledge and assumptions of how IE works. Remember that all of
    your knowledge is based on the way a certain browser works today, but not necessarily
    the way it will work tomorrow. So, to avoid many rewrites of your code as new
    browser versions are shipped, it's best to individually check for features you
    intend to use and don't generalize on what a certain browser supports.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在嗅探特性时要注意的一点是，在检查一个特性后不要假设太多。在前面的示例中，这条规则被打破了，因为代码只检查了`addEventListener`的支持，但随后定义了`addListener()`和`removeListener()`。在这种情况下，可以假设如果浏览器实现了`addEventListener()`，那么它也实现了`removeEventListener()`。然而，想象一下，如果浏览器实现了`stopPropagation()`但没有实现`preventDefault()`，而您没有单独检查这些情况会发生什么。您假设因为`addEventListener()`未定义，浏览器必须是一个旧的IE，并使用您对IE工作方式的知识和假设来编写代码。请记住，您所有的知识都是基于某个浏览器今天的工作方式，但不一定是明天的工作方式。因此，为了避免在新的浏览器版本发布时多次重写代码，最好单独检查您打算使用的特性，并不要对某个浏览器支持的特性进行概括。
- en: Lazy definition
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 懒惰定义
- en: The lazy definition pattern is similar to the previous init-time branching pattern.
    The difference is that the branching happens only when the function is called
    for the first time. When the function is called, it redefines itself with the
    best implementation. Unlike the init-time branching, where the if happens once,
    during loading, here it may not happen at all, in cases when the function is never
    called. The lazy definition also makes the initialization process lighter as there's
    no init-time branching work to be done.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 懒惰定义模式类似于先前的初始化时分支模式。不同之处在于分支只会在第一次调用函数时发生。当调用函数时，它会使用最佳实现重新定义自身。与初始化时分支不同，初始化时分支只发生一次，在加载时，而在这里，当函数从未被调用时，可能根本不会发生。懒惰定义还使初始化过程更轻松，因为不需要进行初始化时分支工作。
- en: 'Let''s see an example that illustrates this via the definition of an `addListener()`
    function. The function is first defined with a generic body. It checks which functionality
    is supported by the browser when it''s called for the first time and then redefines
    itself using the most suitable implementation. At the end of the first call, the
    function calls itself, so that the actual event attaching is performed. The next
    time you call the same function, it will be defined with its new body and be ready
    for use, so no further branching is necessary. The following is the code snippet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过定义一个`addListener()`函数的示例来说明这一点。首先，该函数使用通用的主体进行定义。当首次调用函数时，它会检查浏览器支持的功能，然后使用最合适的实现重新定义自身。在第一次调用结束时，函数会调用自身，以便执行实际的事件附加。下次调用相同的函数时，它将使用新的主体进行定义，并准备好使用，因此不需要进一步的分支。以下是代码片段：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Configuration object
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置对象
- en: This pattern is convenient when you have a function or method that accepts a
    lot of optional parameters. It's up to you to decide how many constitutes a lot.
    But generally, a function with more than three parameters is not convenient to
    call, because you have to remember the order of the parameters, and it is even
    more inconvenient when some of the parameters are optional.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有一个接受许多可选参数的函数或方法时，这种模式很方便。由您决定多少个构成了很多。但一般来说，一个具有三个以上参数的函数不方便调用，因为您必须记住参数的顺序，当一些参数是可选的时，这更加不方便。
- en: 'Instead of having many parameters, you can use one parameter and make it an
    object. The properties of the object are the actual parameters. This is suitable
    to pass configuration options because these tend to be numerous and optional (with
    smart defaults). The beauty of using a single object as opposed to multiple parameters
    is described as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是有许多参数，您可以使用一个参数并将其设置为对象。对象的属性是实际参数。这适用于传递配置选项，因为这些 tend to be numerous and
    optional (with smart defaults). 使用单个对象而不是多个参数的美妙之处如下所述：
- en: The order doesn't matter
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序无关紧要
- en: You can easily skip parameters that you don't want to set
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以轻松跳过不想设置的参数
- en: It's easy to add more optional configuration attributes
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易添加更多的可选配置属性
- en: It makes the code more readable because the configuration object's properties
    are present in the calling code along with their names
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使代码更易读，因为配置对象的属性与它们的名称一起出现在调用代码中
- en: 'Imagine you have some sort of UI widget constructor you use to create fancy
    buttons. It accepts the text to put inside the button (the `value` attribute of
    the `<input>` tag) and an optional parameter of the `type` of button. For simplicity,
    let''s say the fancy button takes the same configuration as a regular button.
    Take a look at the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一些UI小部件构造函数，用于创建漂亮的按钮。它接受要放在按钮内部的文本（`<input>`标签的`value`属性）以及`type`按钮的可选参数。为简单起见，让我们假设漂亮的按钮采用与常规按钮相同的配置。看一下以下代码：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using the constructor is simple; you just give it a string. Then, you can add
    the new button to the body of the document as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数很简单；您只需给它一个字符串。然后，您可以将新按钮添加到文档的主体中，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This is all well and works fine, but then you decide you also want to be able
    to set some of the style properties of the button, such as colors and fonts. You
    can end up with a definition like the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，运行良好，但是然后您决定还想能够设置按钮的一些样式属性，比如颜色和字体。您最终可能会得到以下定义：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, using the constructor can become a little inconvenient, especially when
    you want to set the third and fifth parameter, but not the second or the fourth.
    Consider the following example:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用构造函数可能会变得有点不方便，特别是当您想设置第三个和第五个参数，但不想设置第二个或第四个时。考虑以下示例：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A better approach is to use one `config` object parameter for all the settings.
    The function definition can become something like the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的方法是使用一个`config`对象参数来设置所有的设置。函数定义可以变成以下代码片段：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using the constructor is shown as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Another usage example is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用法示例如下：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, it's easy to set only some of the parameters and to switch around
    their order. In addition, the code is friendlier and easier to understand when
    you see the names of the parameters at the same place where you call the method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，设置只有一些参数并且切换它们的顺序很容易。此外，当您在调用方法的地方看到参数的名称时，代码更友好，更易于理解。
- en: A drawback of this pattern is the same as its strength. It's trivial to keep
    adding more parameters, which means trivial to abuse the technique. Once you have
    an excuse to add to this free-for-all bag of properties, you will find it tempting
    to keep adding some that are not entirely optional, or some that are dependent
    on other properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的缺点与其优点相同。很容易不断添加更多的参数，这意味着滥用这种技术很容易。一旦您有理由向这个自由的属性包中添加更多内容，您会发现很容易不断添加一些并非完全可选的属性，或者一些依赖于其他属性的属性。
- en: As a rule of thumb, all these properties should be independent and optional.
    If you have to check all possible combinations inside your function ("oh, A is
    set, but A is only used if B is also set"), this is a recipe for a large function
    body, which quickly becomes confusing and difficult, if not impossible, to test,
    because of all the combinations.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，所有这些属性都应该是独立的和可选的。如果您必须在函数内部检查所有可能的组合（“哦，A已设置，但只有在B也设置了A才会被使用”），这将导致一个庞大的函数体，很快就会变得令人困惑和难以理解，甚至是不可能测试，因为所有的组合。
- en: Private properties and methods
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有属性和方法
- en: 'JavaScript doesn''t have the notion of access modifiers, which set the privileges
    of the properties in an object. Other languages often have access modifiers, as
    follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有访问修饰符的概念，它设置对象中属性的特权。其他语言通常有访问修饰符，如下所示：
- en: '`Public`: All users of an object can access these properties or methods'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Public`: 对象的所有用户都可以访问这些属性或方法'
- en: '`Private`: Only the object itself can access these properties'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Private`: 只有对象本身才能访问这些属性'
- en: '`Protected`: Only objects inheriting the object in question can access these
    properties'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protected`: 只有继承所讨论的对象的对象才能访问这些属性'
- en: JavaScript doesn't have a special syntax to denote private properties or methods,
    but as discussed in [Chapter 3](ch03.html "Chapter 3. Functions"), *Functions*,
    you can use local variables and methods inside a function and achieve the same
    level of protection.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript没有特殊的语法来表示私有属性或方法，但如[第3章](ch03.html "第3章。函数")中所讨论的 *函数*，您可以在函数内部使用局部变量和方法，并实现相同级别的保护。
- en: 'Continuing with the example of the `FancyButton` constructor, you can have
    local variable styles that contains all the defaults, and a local `setStyle()`
    function. These are invisible to the code outside of the constructor. Here''s
    how `FancyButton` can make use of the local private properties:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用`FancyButton`构造函数的示例，您可以有一个包含所有默认值的本地变量styles和一个本地的`setStyle()`函数。这些对于构造函数外部的代码是不可见的。以下是`FancyButton`如何利用本地私有属性：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this implementation, `styles` is a private property and `setStyle()` is a
    private method. The constructor uses them internally (and they can access anything
    inside the constructor), but they are not available to code outside of the function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，`styles`是一个私有属性，`setStyle()`是一个私有方法。构造函数在内部使用它们（它们可以访问构造函数内部的任何内容），但它们对函数外部的代码不可用。
- en: Privileged methods
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特权方法
- en: Privileged methods (this term was coined by Douglas Crockford) are normal public
    methods that can access private methods or properties. They can act like a bridge
    in making some of the private functionality accessible, but in a controlled manner,
    wrapped in a privileged method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 特权方法（这个术语是由Douglas Crockford创造的）是可以访问私有方法或属性的普通公共方法。它们可以充当桥梁，以受控的方式包装特定的私有功能，使其可访问。
- en: Private functions as public methods
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有函数作为公共方法
- en: Let's say you've defined a function that you absolutely need to keep intact,
    so you make it private. However, you also want to provide access to the same function,
    so that outside code can also benefit from it. In this case, you can assign the
    private function to a publicly available property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经定义了一个绝对需要保持完整的函数，因此将其设置为私有。但是，您还希望提供对相同函数的访问权限，以便外部代码也可以从中受益。在这种情况下，您可以将私有函数分配给公开可用的属性。
- en: 'Let''s define `_setStyle()` and `_getStyle()` as private functions, but then
    assign them to the public `setStyle()` and `getStyle()`, consider the following
    example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`_setStyle()`和`_getStyle()`定义为私有函数，然后将它们分配给公共的`setStyle()`和`getStyle()`，考虑以下示例：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, when you call `MYAPP.dom.setStyle()`, it invokes the private `_setStyle()`
    function. You can also overwrite `setStyle()` from the outside as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您调用`MYAPP.dom.setStyle()`时，它会调用私有的`_setStyle()`函数。您也可以从外部覆盖`setStyle()`如下：
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, the result is as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果如下：
- en: '`MYAPP.dom.setStyle` points to the new function'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP.dom.setStyle`指向新函数'
- en: '`MYAPP.dom.yetAnother` still points to `_setStyle()`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MYAPP.dom.yetAnother`仍然指向`_setStyle()`'
- en: '`_setStyle()` is always available when any other internal code relies on it
    to be working as intended, regardless of the outside code'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_setStyle()`在任何其他内部代码依赖它按预期工作时始终可用，而不受外部代码的影响'
- en: When you expose something private, keep in mind that objects (functions and
    arrays are objects too) are passed by reference and, therefore, can be modified
    from the outside.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当您公开私有内容时，请记住对象（函数和数组也是对象）是通过引用传递的，因此可以从外部修改。
- en: Immediate functions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 立即函数
- en: 'Another pattern that helps you keep the global namespace clean is to wrap your
    code in an anonymous function and execute that function immediately. This way,
    any variables inside the function are local, as long as you use the `var` statement,
    and are destroyed when the function returns, if they aren''t part of a closure.
    This pattern was discussed in more detail in [Chapter 3](ch03.html "Chapter 3. Functions"),
    *Functions*. Take a look at the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 帮助您保持全局命名空间清晰的另一种模式是将代码包装在匿名函数中并立即执行该函数。这样，只要使用`var`语句，函数内部的任何变量都是局部的，并且在函数返回时被销毁，如果它们不是闭包的一部分。这种模式在[第3章](ch03.html
    "第3章。函数")*函数*中有更详细的讨论。看一下以下代码：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This pattern is especially suitable for on-off initialization task, performed
    when the script loads.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式特别适用于一次性初始化任务，在脚本加载时执行。
- en: 'The immediate self-executing function pattern can be extended to create and
    return objects. If the creation of these objects is more complicated and involves
    some initialization work, then you can do this in the first part of the self-executable
    function and return a single object that can access and benefit from any private
    properties at the top portion, as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 立即自执行函数模式可以扩展到创建和返回对象。如果创建这些对象更复杂并涉及一些初始化工作，那么您可以在自执行函数的第一部分中执行此操作，并返回一个可以访问和受益于顶部私有属性的单个对象，如下所示：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Modules
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块
- en: Combining several of the previous patterns gives you a new pattern, commonly
    referred to as a module pattern. The concept of modules in programming is convenient
    as it allows you to code separate pieces or libraries and combine them as needed,
    just like pieces of a puzzle.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 结合前面几种模式可以得到一个新模式，通常称为模块模式。编程中的模块概念很方便，因为它允许您编写单独的代码片段或库，并根据需要组合它们，就像拼图一样。
- en: 'The module pattern includes the following:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 模块模式包括以下内容：
- en: Namespaces to reduce naming conflicts among modules
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间以减少模块之间的命名冲突
- en: An immediate function to provide a private scope and initialization
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即函数提供私有作用域和初始化
- en: Private properties and methods
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有属性和方法
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: ES5 doesn't have a built-in concept of modules. There is the module specification
    from [http://www.commonjs.org](http://www.commonjs.org), which defines a `require()`
    function and an exports object. ES6, however, supports modules. [Chapter 8](ch08.html
    "Chapter 8. Classes and Modules"), Classes and Modules has covered modules in
    detail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ES5没有内置的模块概念。有来自[http://www.commonjs.org](http://www.commonjs.org)的模块规范，它定义了一个`require()`函数和一个exports对象。然而，ES6支持模块。[第8章](ch08.html
    "第8章。类和模块")类和模块已经详细介绍了模块。
- en: 'Returning an object that has the public API of the module as follows:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回具有模块公共API的对象，如下所示：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'And, you can use the module in the following way:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，您可以以以下方式使用模块：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chaining
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接
- en: Chaining is a pattern that allows you to invoke multiple methods on one line
    as if the methods are the links in a chain. This is convenient when calling several
    related methods. You invoke the next method on the result of the previous without
    the use of an intermediate variable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 链接是一种模式，允许你在一行上调用多个方法，就好像这些方法是链条中的链接一样。当调用几个相关的方法时，这是很方便的。你在前一个方法的结果上调用下一个方法，而不使用中间变量。
- en: 'Say you''ve created a constructor that helps you work with DOM elements. The
    code to create a new `<span>` tag that is added to the `<body>` tag can look something
    like the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经创建了一个构造函数，可以帮助你处理DOM元素。创建一个新的添加到`<body>`标签的`<span>`标签的代码可能如下所示：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'As you know, constructors return the object referred to as `this` keyword that
    they create. You can make your methods, such as `setText()` and `setStyle()`,
    also return `this` keyword, which allows you to call the next method on the instance
    returned by the previous one. This way, you can chain method calls, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，构造函数返回所谓的`this`关键字所创建的对象。你可以让你的方法，比如`setText()`和`setStyle()`，也返回`this`关键字，这样你就可以在前一个方法返回的实例上调用下一个方法。这样，你可以链式调用方法，如下所示：
- en: '[PRE33]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You don''t even need the `obj` variable if you don''t plan on using it after
    the new element has been added to the tree, so the code looks like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在新元素添加到树之后不打算使用`obj`变量，那么代码看起来像下面这样：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A drawback of this pattern is that it makes it a little harder to debug when
    an error occurs somewhere in a long chain, and you don't know which link is to
    blame because they are all on the same line.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的一个缺点是，当长链中的某个地方发生错误时，它会使得调试变得有点困难，因为你不知道哪个链接有问题，因为它们都在同一行上。
- en: JSON
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JSON
- en: Let's wrap up the coding patterns section of this chapter with a few words about
    JSON. JSON is not technically a coding pattern, but you can say that using it
    is a good pattern.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用几句话来总结本章的编码模式部分关于JSON的内容。JSON在技术上并不是一个编码模式，但你可以说使用它是一个很好的模式。
- en: 'JSON is a popular lightweight format to exchange data. It''s often preferred
    over XML when using `XMLHttpRequest()` to retrieve data from the server. There''s
    nothing specifically interesting about **JSON** other than the fact that it''s
    extremely convenient. The JSON format consists of data defined using object and
    array literals. Here is an example of a JSON string that your server can respond
    with after an `XHR` request:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种流行的轻量级数据交换格式。在使用`XMLHttpRequest()`从服务器检索数据时，它通常优先于XML。**JSON**除了它极其方便之外，没有什么特别有趣的地方。JSON格式由使用对象和数组文字定义的数据组成。以下是一个JSON字符串的示例，你的服务器可以在`XHR`请求之后用它来响应：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'An XML equivalent of this will be something like the following piece of code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个的XML等价物将是以下代码片段：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, you can see how JSON is lighter in terms of the number of bytes. However,
    the main benefit is not the smaller byte size, but the fact that it''s trivial
    to work with JSON in JavaScript. Let''s say, you''ve made an `XHR` request and
    have received a JSON string in the `responseText` property of the `XHR` object.
    You can convert this string of data into a working JavaScript object by simply
    using `eval()`. Consider the following example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以看到JSON在字节数量上更轻。然而，主要好处不是较小的字节大小，而是在JavaScript中使用JSON非常简单。比如，你已经发出了一个`XHR`请求，并在`XHR`对象的`responseText`属性中收到了一个JSON字符串。你可以通过简单地使用`eval()`将这个数据字符串转换为一个可用的JavaScript对象。考虑以下示例：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, you can access the data in `obj` as object properties as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以像下面这样访问`obj`中的数据作为对象属性：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The problem is that `eval()` is insecure, so it''s best if you use the JSON
    object to parse the JSON data (a fallback for older browsers is available at [http://json.org/](http://json.org/)).
    Creating an object from a JSON string is still trivial as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`eval()`是不安全的，所以最好使用JSON对象来解析JSON数据（旧版浏览器的备用方案可在[http://json.org/](http://json.org/)找到）。从JSON字符串创建对象仍然很简单，如下所示：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To do the opposite, that is, to convert an object to a JSON string, you can
    use the `stringify()` method, as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要做相反的事情，也就是将对象转换为JSON字符串，你可以使用`stringify()`方法，如下所示：
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Due to its simplicity, JSON has quickly become popular as a language-independent
    format to exchange data, and you can easily produce JSON on the server side using
    your preferred language. In PHP, for example, there are the `json_encode()` and
    `json_decode()` functions that let you serialize a PHP array or object into a
    JSON string, and vice versa.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其简单性，JSON很快就成为了一种独立于语言的数据交换格式，并且你可以使用你喜欢的语言在服务器端轻松地生成JSON。例如，在PHP中，有`json_encode()`和`json_decode()`函数，让你将PHP数组或对象序列化为JSON字符串，反之亦然。
- en: Higher order functions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高阶函数
- en: Functional programming was confined to a limited set of languages so far. With
    more languages adding features to support functional programming, interest in
    the area is gaining momentum. JavaScript is evolving to support common features
    of functional programming. You will gradually see a lot of code written in this
    style. It is important to understand the functional programming style, even if
    you don't feel inclined just yet to use it in your code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，函数式编程一直局限于有限的一组语言。随着越来越多的语言添加支持函数式编程的特性，人们对这一领域的兴趣正在增长。JavaScript正在发展以支持函数式编程的常见特性。你将逐渐看到很多以这种风格编写的代码。重要的是要理解函数式编程风格，即使你现在还不想在你的代码中使用它。
- en: 'Higher order functions are one of the important mainstays of functional programing.
    Higher order function is a function that does at least one of the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 高阶函数是函数式编程的重要支柱之一。高阶函数是至少做以下一种事情的函数：
- en: Takes one or more functions as arguments
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一个或多个函数作为参数
- en: Returns a function as a result
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个函数作为结果
- en: As functions are first class objects in JavaScript, passing and returning functions
    to and from a function is a pretty routine affair. Callbacks are higher order
    functions. Let's take a look at how we can take these two principles together
    and write a higher order function.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript中函数是一等对象，因此将函数传递给函数并从函数返回函数是一件相当常见的事情。回调函数是高阶函数。让我们看看如何将这两个原则结合起来编写一个高阶函数。
- en: Let's write a `filter` function; this function filters out values from an array
    based on a criteria determined by a function. This function takes two arguments-a
    function, which returns a Boolean value, `true` for keeping this element.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`filter`函数；这个函数根据由函数确定的条件从数组中过滤出值。这个函数接受两个参数-一个返回布尔值`true`以保留此元素的函数。
- en: 'For example, with this function, we are filtering all odd values from an array.
    Consider the following lines of code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用这个函数，我们正在从数组中过滤出所有奇数值。考虑以下代码行：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are passing an anonymous function to the `filter` function as the first argument.
    This function returns a Boolean based on a condition that checks if the element
    is odd or even.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个匿名函数作为第一个参数传递给`filter`函数。这个函数根据一个条件返回一个布尔值，检查元素是奇数还是偶数。
- en: This is an example of one of the several higher order functions added to ECMAScript
    5\. The point we are trying to make here is that you will increasingly see similar
    patterns of usage in JavaScript. You must first understand how higher order functions
    work and later, once you are comfortable with the concept, try to incorporate
    them in your code as well.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ECMAScript 5中添加的几个高阶函数之一的示例。我们试图表达的观点是，您将越来越多地看到JavaScript中类似的使用模式。您必须首先了解高阶函数的工作原理，然后，一旦您对概念感到舒适，尝试在您的代码中也加入它们。
- en: 'With ES6 function syntax changes, it is even more elegant to write higher order
    functions. Let''s take a small example in ES5 and see how that translates into
    its ES6 equivalent:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ES6函数语法的变化，编写高阶函数变得更加优雅。让我们以ES5中的一个小例子来看看它如何转换为ES6：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `add` function takes `x` and returns a function that takes `y` as an argument
    and then returns value of expression `y+x`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`add`函数接受`x`并返回一个接受`y`作为参数的函数，然后返回表达式`y+x`的值。'
- en: 'When we looked at arrow functions, we discussed that arrow functions return
    results of a single expression implicitly. So, the preceding function can be turned
    into an arrow function by making the body of the arrow function another arrow
    function. Take a look at the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论箭头函数时，我们讨论了箭头函数隐式返回单个表达式的结果。因此，前面的函数可以通过将箭头函数的主体变为另一个箭头函数来转换为箭头函数。看看下面的例子：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, we have an outer function, `x =>` [inner function with `x` as argument],
    and we have an inner function, `y => y+x`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个外部函数，`x =>` [带有`x`作为参数的内部函数]，以及一个内部函数，`y => y+x`。
- en: This introduction will help you get familiar with the increasing usage of higher
    order functions, and their increased importance in JavaScript.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这个介绍将帮助您熟悉高阶函数的增加使用，以及它们在JavaScript中的增加重要性。
- en: Design patterns
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式
- en: 'The second part of this chapter presents a JavaScript approach to a subset
    of the design patterns introduced by *Design Patterns: Elements of Reusable Object-Oriented
    Software*, an influential book most commonly referred to as the *Book of Four*,
    the *Gang of Four*, or *GoF* (after its four authors). The patterns discussed
    in the *GoF* book are divided into the three following groups:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第二部分介绍了JavaScript对《设计模式：可复用面向对象软件的元素》中引入的设计模式子集的方法，这是一本有影响力的书，通常被称为《四人帮》或《GoF》（四位作者的缩写）。《GoF》书中讨论的模式分为以下三组：
- en: Creational patterns that deal with how objects are created (instantiated)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理对象如何创建（实例化）的创建模式
- en: Structural patterns that describe how different objects can be composed in order
    to provide new functionality
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述不同对象如何组合以提供新功能的结构模式
- en: Behavioral patterns that describe ways for objects to communicate with each
    other
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述对象之间通信方式的行为模式
- en: There are 23 patterns in the *Book of Four*, and more patterns have been identified
    since the book's publication. It's way beyond the scope of this book to discuss
    all of them, so the remainder of the chapter demonstrates only four, along with
    examples of their implementation in JavaScript. Remember that the patterns are
    more about interfaces and relationships rather than implementation. Once you have
    an understanding of a design pattern, it's often not difficult to implement it,
    especially in a dynamic language such as JavaScript.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 《四人帮》中有23种模式，自该书出版以来已经发现了更多模式。讨论所有这些模式远远超出了本书的范围，因此本章的其余部分仅演示了四种模式，以及它们在JavaScript中的实现示例。请记住，这些模式更多关于接口和关系而不是实现。一旦您了解了设计模式，通常很容易实现它，特别是在JavaScript这样的动态语言中。
- en: 'The patterns discussed through the rest of the chapter are as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余部分讨论的模式如下：
- en: Singleton
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Factory
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: Decorator
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: Observer
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Singleton pattern
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例模式
- en: Singleton is a creational design pattern, meaning that its focus is on creating
    objects. It helps you when you want to make sure there is only one object of a
    given kind or class. In a classical language, this would mean that an instance
    of a class is only created once, and any subsequent attempts to create new objects
    of the same class would return the original instance.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是一种创建型设计模式，意味着它的重点是创建对象。当您想要确保只有一个给定种类或类的对象时，它会帮助您。在经典语言中，这意味着只创建一个类的实例，并且任何后续尝试创建相同类的新对象都将返回原始实例。
- en: In JavaScript, because there are no classes, a singleton is the default and
    most natural pattern. Every object is a singleton object.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，由于没有类，单例是默认和最自然的模式。每个对象都是单例对象。
- en: 'The most basic implementation of the singleton in JavaScript is the object
    literal. Take a look at the following line of code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中单例的最基本实现是对象字面量。看一下下面的代码行：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That was easy, right?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 那很容易，对吧？
- en: Singleton 2 pattern
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例2模式
- en: 'If you want to use a class-like syntax and still implement the singleton pattern,
    things become a bit more interesting. Let''s say, you have a constructor called
    `Logger()`, and you want to be able to do something like the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用类似类的语法并且仍然实现单例模式，事情会变得更有趣一些。假设您有一个名为`Logger()`的构造函数，并且希望能够执行以下操作：
- en: '[PRE45]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The idea is that, although you use `new`, only one instance needs to be created,
    and this instance is then returned in consecutive calls.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 思想是，尽管使用了`new`，但只需要创建一个实例，然后在连续调用中返回该实例。
- en: Global variable
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'One approach is to use a global variable to store the single instance. Your
    constructor could look like the following code snippet:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用全局变量来存储单个实例。您的构造函数可能如下代码片段所示：
- en: '[PRE46]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Using this constructor gives the expected result, which is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此构造函数会产生预期的结果，如下所示：
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The drawback is, obviously, the use of a global variable. It can be overwritten
    at any time, even accidentally, and you can lose the instance. The opposite, your
    global variable overwriting someone else's is also possible.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 缺点显而易见，就是使用全局变量。它可以在任何时候被意外覆盖，您可能会丢失实例。相反，覆盖别人的全局变量也是可能的。
- en: Property of the constructor
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构造函数的属性
- en: 'As you know, functions are objects and they have properties. You can assign
    the single instance to a property of the constructor function, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，函数是对象，它们有属性。您可以将单个实例分配给构造函数的属性，如下所示：
- en: '[PRE48]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If you write `var a = new Logger()`, `a` points to the newly created `Logger.single_instance`
    property. A subsequent `var b = new Logger()` call results in `b` pointing to
    the same `Logger.single_instance` property, which is exactly what you want.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写`var a = new Logger()`，`a`指向新创建的`Logger.single_instance`属性。随后的`var b =
    new Logger()`调用会导致`b`指向相同的`Logger.single_instance`属性，这正是您想要的。
- en: This approach certainly solves the global namespace issue because no global
    variables are created. The only drawback is that the property of the `Logger`
    constructor is publicly visible, so it can be overwritten at any time. In such
    cases, the single instance can be lost or modified. Of course, you can only provide
    so much protection against fellow programmers shooting themselves in the foot.
    After all, if someone can mess with the single-instance property, they can mess
    up the `Logger` constructor directly as well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法确实解决了全局命名空间问题，因为不会创建全局变量。唯一的缺点是`Logger`构造函数的属性是公开可见的，因此可以随时被覆盖。在这种情况下，单个实例可能会丢失或修改。当然，您只能提供有限的保护，以防止其他程序员自食其力。毕竟，如果有人可以干扰单实例属性，他们也可以直接干扰`Logger`构造函数。
- en: In a private property
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在私有属性中
- en: The solution to the problem of overwriting the publicly visible property is
    not to use a public property, but a private one. You already know how to protect
    variables with a closure, so as an exercise, you can implement this approach to
    the singleton pattern.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 解决公开可见属性被覆盖的问题的方法不是使用公共属性，而是使用私有属性。您已经知道如何使用闭包保护变量，因此作为练习，您可以实现这种方法来实现单例模式。
- en: Factory pattern
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The factory is another creational design pattern, as it deals with creating
    objects. The factory can help you when you have similar types of objects and you
    don't know in advance which one you want to use. Based on user input or other
    criteria, your code determines the type of object it needs on the fly.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂是另一种创建型设计模式，因为它涉及创建对象。当您有类似类型的对象并且事先不知道要使用哪个时，工厂可以帮助您。根据用户输入或其他条件，您的代码可以动态确定所需的对象类型。
- en: 'Let''s say you have three different constructors that implement similar functionality.
    All the objects they create take a URL but do different things with it. One creates
    a text DOM node; the second creates a link; and the third, an image, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有三种不同的构造函数，实现类似的功能。它们创建的所有对象都需要一个URL，但对其执行不同的操作。一个创建文本DOM节点；第二个创建一个链接；第三个创建一个图像，如下所示：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Using the three different constructors is exactly the same-pass the `url` variable
    and call the `insert()` method, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三种不同的构造函数完全相同-传递`url`变量并调用`insert()`方法，如下所示：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Imagine your program doesn''t know in advance which type of object is required.
    The user decides, during runtime, by clicking on a button for example. If `type`
    contains the required type of object, you''ll need to use an `if` or a `switch`
    statement, and write something like the following piece of code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您的程序事先不知道需要哪种类型的对象。用户在运行时通过单击按钮等方式决定。如果`type`包含所需的对象类型，则需要使用`if`或`switch`语句，并编写以下代码片段：
- en: '[PRE51]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This works fine; however, if you have a lot of constructors, the code becomes
    too lengthy and hard to maintain. Also, if you are creating a library or a framework
    that allows extensions or plugins, you don't even know the exact names of all
    the constructor functions in advance. In such cases, it's convenient to have a
    factory function that takes care of creating an object of the dynamically determined
    type.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做效果很好；但是，如果您有很多构造函数，代码会变得太长且难以维护。此外，如果您正在创建允许扩展或插件的库或框架，您甚至不知道所有构造函数的确切名称。在这种情况下，有一个工厂函数来负责创建动态确定类型的对象是很方便的。
- en: 'Let''s add a factory method to the `MYAPP.dom` utility:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向`MYAPP.dom`实用程序添加一个工厂方法：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, you can replace the three `if` functions with the simpler code, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以用更简单的代码替换三个`if`函数，如下所示：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The example `factory()` method in the previous code was simple; however, in
    a real-life scenario, you'd want to do some validation against the type value
    (for example, check if `MYAPP.dom[type]` exists) and optionally do some set up
    work common to all object types (for example, set up the URL all constructors
    use).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 先前代码中的示例`factory()`方法很简单；但是，在实际情况下，您可能希望针对类型值进行一些验证（例如，检查`MYAPP.dom[type]`是否存在），并且可能对所有对象类型进行一些通用的设置工作（例如，设置所有构造函数使用的URL）。
- en: Decorator pattern
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: 'The decorator design pattern is a structural pattern; it doesn''t have much
    to do with how objects are created, but rather how their functionality is extended.
    Instead of using inheritance, where you extend in a linear way (parent-child-grandchild),
    you can have one base object and a pool of different decorator objects that provide
    extra functionality. Your program can pick and choose which decorators it wants,
    and in which order. For a different program or code path, you may have a different
    set of requirements and pick different decorators out of the same pool. Take a
    look at the following code snippet to see how the usage part of the decorator
    pattern can be implemented:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰者设计模式是一种结构模式；它与对象如何创建没有太多关系，而是与它们的功能如何扩展有关。你可以有一个基础对象和一组不同的装饰者对象，它们提供额外的功能，而不是使用继承，继承是线性的（父-子-孙），你的程序可以选择想要的装饰者，以及顺序。对于不同的程序或代码路径，你可能有不同的需求集，并从同一个池中选择不同的装饰者。看一下以下代码片段，看看装饰者模式的使用部分如何实现：
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You can see how you can start with a simple object that has a `doSomething()`
    method. Then, you can pick one of the decorator objects you have lying around
    and which can be identified by name. All decorators provide a `doSomething()`
    method that first calls the same method of the previous decorator and then proceeds
    with its own code. Every time you add a decorator, you overwrite the base `obj`
    with an improved version of it. In the end, when you are finished adding decorators,
    you call `doSomething()`. As a result, all of the `doSomething()` methods of all
    the decorators are executed in sequence. Let's see an example.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到如何从一个具有`doSomething()`方法的简单对象开始。然后，你可以选择你手头上的一个装饰者对象，并通过名称进行识别。所有装饰者都提供一个`doSomething()`方法，首先调用前一个装饰者的相同方法，然后继续执行自己的代码。每次添加一个装饰者，都会用改进版本的`obj`覆盖基础对象。最后，当你添加完装饰者后，调用`doSomething()`。结果，所有装饰者的`doSomething()`方法都按顺序执行。让我们看一个例子。
- en: Decorating a christmas tree
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 装饰一棵圣诞树
- en: 'Let''s illustrate the decorator pattern with an example of decorating a Christmas
    tree. You can start with the `decorate()` method as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个装饰一棵圣诞树的例子来说明装饰者模式。你可以按照以下方式开始`decorate()`方法：
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, let''s implement a `getDecorator()` method that adds extra decorators.
    The decorators will be implemented as constructor functions, and they''ll all
    inherit from the base `tree` object as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一个`getDecorator()`方法，添加额外的装饰者。装饰者将作为构造函数实现，并且它们都将从基础`tree`对象继承，如下所示：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s create the first decorator, `RedBalls()`, as a property of `tree`,
    in order to keep the global namespace cleaner. The red ball objects also provide
    a `decorate()` method, but they make sure they call their parent''s `decorate()`
    first. For example, take a look at the following code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个装饰者`RedBalls()`，作为`tree`的属性，以保持全局命名空间更清洁。红色球对象也提供一个`decorate()`方法，但它们确保首先调用它们父级的`decorate()`。例如，看一下以下代码：
- en: '[PRE57]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Similarly, implement `BlueBalls()` and `Angel()` decorators as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，按照以下方式实现`BlueBalls()`和`Angel()`装饰者：
- en: '[PRE58]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let''s add all of the decorators to the base object, as shown in the following
    code snippet:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将所有装饰者添加到基础对象中，如下所示的代码片段：
- en: '[PRE59]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally, run the `decorate()` method as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，按照以下方式运行`decorate()`方法：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This single call results in the following alerts, specifically in this order:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个单一的调用会导致以下警报，具体顺序如下：
- en: Make sure the tree won't fall.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保树不会倒下。
- en: Add the blue balls.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加蓝色的球。
- en: Add an angel at the top.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶部添加一个天使。
- en: Add some red balls.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些红色的球。
- en: As you see, this functionality allows you to have as many decorators as you
    like, and to choose and combine them in any way you like.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个功能允许你拥有任意数量的装饰者，并以任意方式选择和组合它们。
- en: Observer pattern
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察者模式
- en: 'The observer pattern, also known as the **subscriber-publisher** pattern, is
    a behavioral pattern, which means that it deals with how different objects interact
    and communicate with each other. When implementing the observer pattern, you have
    the following objects:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式，也称为**订阅者-发布者**模式，是一种行为模式，意味着它处理不同对象之间的交互和通信。在实现观察者模式时，你会有以下对象：
- en: One or more publisher objects that announce when they do something important.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个发布者对象，它们在做重要事情时会宣布。
- en: One or more subscribers tuned in to one or more publishers. They listen to what
    the publishers announce and then act appropriately.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个订阅者调整到一个或多个发布者。他们听取发布者的宣布然后采取适当的行动。
- en: The observer pattern may look familiar to you. It sounds similar to the browser
    events discussed in the previous chapter, and rightly so, because the browser
    events are one example application of this pattern. The browser is the publisher;
    it announces the fact that an event, such as a `click`, has happened. Your event
    listener functions that are subscribed to listen to this type of event will be
    notified when it happens. The browser-publisher sends an event object to all of
    the subscribers. In your custom implementations, you can send any type of data
    you find appropriate.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式可能对你来说很熟悉。它听起来与前一章讨论的浏览器事件类似，这是正确的，因为浏览器事件是这种模式的一个应用实例。浏览器是发布者；它宣布了事件（如`click`）发生的事实。订阅了这种类型事件的事件监听函数在事件发生时会收到通知。浏览器-发布者向所有订阅者发送一个事件对象。在自定义实现中，你可以发送任何你认为合适的数据。
- en: 'There are two subtypes of the observer pattern: push and pull. Push is where
    the publishers are responsible to notify each subscriber, and pull is where the
    subscribers monitor for changes in a publisher''s state.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者模式有两种子类型：推（push）和拉（pull）。推是指发布者负责通知每个订阅者，而拉是指订阅者监视发布者状态的变化。
- en: 'Let''s take a look at an example implementation of the push model. Let''s keep
    the observer-related code in a separate object and then use this object as a mix-in,
    adding its functionality to any other object that decides to be a publisher. In
    this way, any object can become a publisher and any function can become a subscriber.
    The observer object will have the following properties and methods:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个推送模型的示例实现。让我们将观察者相关的代码保留在一个单独的对象中，然后将此对象用作混合对象，将其功能添加到任何决定成为发布者的其他对象中。这样，任何对象都可以成为发布者，任何函数都可以成为订阅者。观察者对象将具有以下属性和方法：
- en: An array of `subscribers` that are just callback functions
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `subscribers` 数组，它们只是回调函数
- en: The `addSubscriber()`and `removeSubscriber()` methods that add to, and remove
    from, the `subscribers` collection
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addSubscriber()` 和 `removeSubscriber()` 方法，用于向 `subscribers` 集合添加和移除订阅者'
- en: A `publish()` method that takes data and calls all subscribers, passing the
    data to them
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `publish()` 方法，它接受数据并调用所有订阅者，将数据传递给它们
- en: A `make()` method that takes any object and turns it into a publisher by adding
    all of the methods mentioned previously to it
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `make()` 方法，它接受任何对象，并通过向其添加之前提到的所有方法将其转换为发布者
- en: 'Here''s the observer mix-in object that contains all the subscription-related
    methods and can be used to turn any object into a publisher:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含所有订阅相关方法的观察者混合对象，可以用来将任何对象转换为发布者：
- en: '[PRE61]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, let''s create some publishers. A publisher can be any object and its only
    duty is to call the `publish()` method whenever something important occurs. Here''s
    a `blogger` object that calls `publish()` every time a new blog posting is ready:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一些发布者。发布者可以是任何对象，其唯一职责是在发生重要事件时调用 `publish()` 方法。这里有一个 `blogger` 对象，每次准备好新的博客帖子时都会调用
    `publish()`：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another object can be the LA Times newspaper that calls `publish()` when a
    new newspaper issue is out. Consider the following lines of code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个对象可以是 LA Times 报纸，当有新的报纸发布时调用 `publish()`。考虑以下代码行：
- en: '[PRE63]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can turn these objects into publishers as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些对象转换为发布者，如下所示：
- en: '[PRE64]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s have the following two simple objects, `jack` and `jill`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下以下两个简单的对象，`jack` 和 `jill`：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `jack` and `jill` objects can subscribe to the `blogger` object by providing
    the callback methods they want to call when something is published, as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`jack` 和 `jill` 对象可以通过提供他们想要在发布时调用的回调方法来订阅 `blogger` 对象，如下所示：'
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'What happens now, when the `blogger` object writes a new post? The result is
    that `jack` and `jill` will get notified:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 `blogger` 对象写了一个新的帖子时会发生什么？结果是 `jack` 和 `jill` 会收到通知：
- en: '[PRE67]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'At any time, `jill` may decide to cancel her subscription. Then, when writing
    another blog post, the unsubscribed object is no longer notified. Consider the
    following code snippet:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，`jill` 可能决定取消她的订阅。然后，在写另一篇博客文章时，已取消订阅的对象将不再收到通知。考虑以下代码片段：
- en: '[PRE68]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `jill` object may decide to subscribe to LA Times, as an object can be
    a subscriber to many publishers, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`jill` 对象可以决定订阅 LA Times，因为一个对象可以订阅多个发布者，如下所示：'
- en: '[PRE69]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, when LA Times publishes a new issue, `jill` gets notified and `jill.gossip()`
    is executed, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当 LA Times 发布新问题时，`jill` 被通知并执行 `jill.gossip()`，如下所示：
- en: '[PRE70]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about common JavaScript coding patterns and learned
    how to make your programs cleaner, faster, and better at working with other programs
    and libraries. Then, you saw a discussion and sample implementations of a handful
    of the design patterns from the *Book of Four*. You can see how JavaScript is
    a fully featured dynamic programming language, and that implementing classical
    patterns in a dynamic loosely typed language is pretty easy. The patterns are,
    in general, a large topic, and you can join the author of this book in a further
    discussion of the JavaScript patterns at [JSPatterns.com](http://www.jspatterns.com/),
    or take a look at the *JavaScript Patterns* book. The next chapter focuses on
    testing and debugging methodologies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了常见的 JavaScript 编码模式，并学会了如何使您的程序更清洁、更快速，并更好地与其他程序和库一起工作。然后，您看到了《四人组设计模式》中一些设计模式的讨论和示例实现。您可以看到
    JavaScript 是一种功能齐全的动态编程语言，而在动态弱类型语言中实现经典模式是相当容易的。总的来说，模式是一个大主题，您可以加入本书的作者在 [JSPatterns.com](http://www.jspatterns.com/)
    进一步讨论 JavaScript 模式，或者查看 *JavaScript Patterns* 书籍。下一章将重点介绍测试和调试方法论。
