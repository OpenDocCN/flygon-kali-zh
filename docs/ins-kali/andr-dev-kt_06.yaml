- en: Generics Are Your Friends
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型是你的朋友
- en: In the previous chapter, we discussed concepts related to functional programming
    and functions as first-class citizens in Kotlin.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了与Kotlin中的函数式编程和函数作为一等公民相关的概念。
- en: In this chapter, we will discuss concept of generic types and generic functions
    known as generics. We will learn why they exist and how to use them - we will
    define generic classes, interfaces, and functions. We will discuss how to deal
    with generics at runtime, take look at subtyping relations, and deal with generics
    nullability
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论泛型类型和泛型函数的概念，称为泛型。我们将学习它们存在的原因以及如何使用它们-我们将定义泛型类、接口和函数。我们将讨论如何在运行时处理泛型，看一下子类型关系，并处理泛型可空性
- en: In this chapter, we will discuss the concepts of generic types and generic functions,
    known as generics. We will learn why they exist and how to use them and also how
    to define generic classes, interfaces, and functions. We will discuss how to deal
    with generics at runtime, take a look at subtyping relations, and deal with generic
    nullability.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论泛型类型和泛型函数的概念，称为泛型。我们将学习它们存在的原因以及如何使用它们，以及如何定义泛型类、接口和函数。我们将讨论如何在运行时处理泛型，看一下子类型关系，并处理泛型可空性。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generic classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类
- en: Generic interfaces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型接口
- en: Generic functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型函数
- en: Generic constraints
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型约束
- en: Generic nullability
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型可空性
- en: Variance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异
- en: Use-site target versus declaration-site target
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用地点目标与声明地点目标
- en: Declaration-site target
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明地点目标
- en: Type erasure
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型擦除
- en: Reified and erased type parameters
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体化和擦除类型参数
- en: Star-projection syntax
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星投影语法
- en: Variance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异
- en: Generics
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: '**Generic** is a programming style where classes, functions, data structures,
    or algorithms are written in such a way that the exact type can be specified later.
    In general, generics provide type safety together with the ability to reuse a
    particular code structure for various data types.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型**是一种编程风格，其中类、函数、数据结构或算法以后可以指定确切的类型。通常，泛型提供类型安全性以及重用特定代码结构的能力，用于各种数据类型。'
- en: Generics are present in both Java and Kotlin. They work in a similar way, but
    Kotlin offers a few improvements over the Java generic type system, such as use-site
    variance, start-projection syntax, and reified type parameters. We will discuss
    them in this chapter.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型在Java和Kotlin中都存在。它们的工作方式类似，但Kotlin在Java泛型类型系统上提供了一些改进，比如使用地点变异、星投影语法和具体化类型参数。我们将在本章讨论它们。
- en: The need for generics
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型的需求
- en: 'Programmers often need a way to specify that a collection contains only elements
    of particular type, such as `Int` , `Student` , or `Car` . Without generics, we
    would need separate classes for each data type (`IntList` , `StudentList` , `CarList`
    , and so on). Those classes would have a very similar internal implementation,
    which would only differ in the stored data type. This means that we would need
    to write the same code (such as adding or removing an item from a collection)
    multiple times and maintain each class separately. This is a lot of work, so before
    generics were implemented, programmers usually operated on a universal list. This
    forced them to cast elements each time they were accessed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员经常需要一种方法来指定集合只包含特定类型的元素，比如`Int`，`Student`或`Car`。如果没有泛型，我们将需要为每种数据类型创建单独的类（`IntList`，`StudentList`，`CarList`等）。这些类的内部实现非常相似，唯一的区别在于存储的数据类型。这意味着我们需要多次编写相同的代码（比如向集合添加或删除项目）并分别维护每个类。这是很多工作，所以在实现泛型之前，程序员通常操作通用列表。这迫使他们每次访问时都需要转换元素：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Casting adds boilerplate, and there is no type validation when an element is
    added to a collection. Generics are the solution for this problem, because a generic
    class defines and uses a placeholder instead of a real type. This placeholder
    is called a **type parameter** *.* Let''s define our first generic class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 转换会增加样板代码，并且在将元素添加到集合时没有类型验证。泛型是这个问题的解决方案，因为泛型类定义并使用占位符而不是真实类型。这个占位符称为**类型参数**。让我们定义我们的第一个泛型类：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The type parameter means that our class will use a certain type, but this type
    will be specified during class creation. This way, our `SimpleList` class can
    be instantiated for a variety of types. We can parametrize a generic class with
    various data types using *type arguments* . This allows us to create multiple
    data types from single class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 类型参数意味着我们的类将使用特定类型，但这种类型将在类创建期间指定。这样，我们的`SimpleList`类可以为各种类型实例化。我们可以使用*类型参数*为泛型类参数化各种数据类型。这允许我们从单个类创建多个数据类型：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `SimpleList` class is parametrized with *type arguments* (`Int` , `Student`
    , and `Car` ) that define what kind of data can be stored in the given list.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleList`类是使用*类型参数*（`Int`，`Student`和`Car`）进行参数化的，定义了可以存储在给定列表中的数据类型。'
- en: Type parameters versus type arguments
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数与类型参数
- en: Functions have parameters (variables declared inside a function declaration)
    and arguments (actual value that is passed to a function). Similar terminology
    applies for generics. A *type parameter* is a blueprint or placeholder for a type
    declared in a generic and a *type argument* is an actual type used to parametrize
    a generic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 函数具有参数（在函数声明内部声明的变量）和参数（传递给函数的实际值）。泛型也适用类似的术语。*类型参数*是泛型中声明的类型的蓝图或占位符，*类型参数*是用于参数化泛型的实际类型。
- en: 'We can use a *type parameter* in a method signature. This way, we can make
    sure that we will be able to add items of a certain type to our list and retrieve
    items of a certain type:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在方法签名中使用*类型参数*。这样，我们可以确保我们将能够向我们的列表添加特定类型的项目并检索特定类型的项目：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Generic type parameter `T` used as type for item
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类型参数`T`用作项目类型
- en: Type parameter used as return type
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数用作返回类型
- en: 'The type of item that can be added to a list or retrieved from a list depends
    on the *type argument* . Let''s see an example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加到列表或从列表中检索的项目的类型取决于*类型参数*。让我们看一个例子：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can only add and get items of type `Student` from the list. The compiler
    will automatically perform all necessary type checks. It is guaranteed that the
    collection will only contain objects of a particular type. Passing an object of
    incompatible type to the add method will result in a compile-time error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能从列表中添加和获取`Student`类型的项目。编译器将自动执行所有必要的类型检查。可以保证集合只包含特定类型的对象。将不兼容类型的对象传递给add方法将导致编译时错误：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We cannot add Boolean, because expected type is `Student` .
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法添加布尔值，因为期望的类型是`Student`。
- en: The Kotlin standard library defines various generic collections in the `kotlin.collections`
    package, such as `List` , `Set` , and `Map` . We will discuss them in [Chapter
    7](text00171.html) , *Extension Functions and Properties* .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库在`kotlin.collections`包中定义了各种通用集合，如`List`，`Set`和`Map`。我们将在[第7章](text00171.html)中讨论它们，*扩展函数和属性*。
- en: 'In Kotlin, generics are often used in combination with higher-order functions
    (discussed in [Chapter 5](text00125.html) , *Functions as A First Class Citizen*
    ) and extension functions (which we will discuss in [Chapter 7](text00171.html)
    , *Extension Functions and Properties* ). Examples of such connections are functions:
    `map` , `filter` , `takeUntil` , and so on. We can perform common operations that
    will differ in the details. For example, we can find matching elements in the
    collection using the operation `filter` function and specifying how matching elements
    will be detected:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，通常将通用与高阶函数（在[第5章](text00125.html)中讨论）和扩展函数（我们将在[第7章](text00171.html)中讨论）结合使用。这些连接的示例是函数：`map`，`filter`，`takeUntil`等。我们可以执行通用操作，其细节将有所不同。例如，我们可以使用`filter`函数在集合中查找匹配的元素，并指定如何检测匹配的元素：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can call the `startsWith` method, because the collection can contain only
    `Strings` , so the lambda parameter (`it` ) has the same type.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以调用`startsWith`方法，因为集合只能包含`Strings`，所以lambda参数（`it`）具有相同的类型。
- en: Generic constraints
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通用约束
- en: 'By default, we can parametrize a generic class with any type of *type argument*
    . However, we can limit the possible types that can be used as *type arguments*
    . To limit the possible values of *type argument* , we need to define a *type
    parameter bound* . The most common type of *constraint* is an *upper bound* .
    By default, all type parameters have `Any?` as an implicit *upper bound* . This
    is why both the following declarations are equivalent:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们可以使用任何类型的*类型参数*对通用类进行参数化。但是，我们可以限制可以用作*类型参数*的可能类型。为了限制*类型参数*的可能值，我们需要定义一个*类型参数边界*。最常见的*约束*类型是*上界*。默认情况下，所有类型参数都具有`Any?`作为隐式*上界*。这就是为什么以下两个声明是等价的：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding bounds mean that we can use any type we want as *type argument*
    for our `SimpleList` class (including nullable types). This is possible because
    all nullable and non-nullable types are subtypes of `Any?` :'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的边界意味着我们可以使用任何类型作为`SimpleList`类的*类型参数*（包括可空类型）。这是可能的，因为所有可空和非可空类型都是`Any?`的子类型：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In some situations, we want to limit the data types that can be used as *type
    arguments.* To make it happen, we need to explicitly define a *type parameter*
    upper bound. Let''s assume that we want to be able to use only numeric types as
    *type arguments* for our `SimpleList` class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望限制可用作*类型参数*的数据类型。为了实现这一点，我们需要明确定义一个*类型参数*上界。假设我们只想能够将数值类型用作`SimpleList`类的*类型参数*：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Number` class is an abstract class, that is, a superclass of Kotlin numeric
    types (`Byte` , `Short` , `Int` , `Long` , `Float` , and `Double` ). We can use
    the `Number` class and all its subclasses (`Int` , `Double` , and so on) as a
    *type argument* , but we can't use the `String` class, because it's not a subclass
    of `Number` . Any attempt to add an incompatible type will be rejected by the
    IDE and compiler. Type parameters also incorporate Kotlin type system nullability.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`类是一个抽象类，即Kotlin数值类型（`Byte`，`Short`，`Int`，`Long`，`Float`，和`Double`）的超类。我们可以使用`Number`类及其所有子类（`Int`，`Double`等）作为*类型参数*，但我们不能使用`String`类，因为它不是`Number`的子类。任何尝试添加不兼容类型的操作都将被IDE和编译器拒绝。类型参数还包括Kotlin类型系统的可空性。'
- en: Nullability
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空性
- en: 'When we define a class with an unbounded type parameter, we can use both non-nullable
    and nullable types as *type arguments* . Occasionally, we need to make sure that
    a particular generic type will not be parametrized with nullable *type arguments*
    . To block the ability to use nullable types as *type arguments,* we need to explicitly
    define a non-nullable **type parameter upper bound** :'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个具有无界类型参数的类时，我们可以使用非可空和可空类型作为*类型参数*。偶尔，我们需要确保特定的通用类型不会被参数化为可空*类型参数*。为了阻止使用可空类型作为*类型参数*的能力，我们需要明确定义一个非可空**类型参数上界**：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can't pass a nullable *type argument* (`Action?` ) to the `ActionGroup`
    class.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们无法将可空的*类型参数*（`Action?`）传递给`ActionGroup`类。
- en: 'Let''s consider another example. Imagine that we want to retrieve the last
    `Action` in the `ActionGroup` . A simple definition of the `last` method would
    look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑另一个例子。假设我们想要检索`ActionGroup`中的最后一个`Action`。`last`方法的简单定义如下：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s analyze what will happen when we pass an empty list to the constructor:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析当我们将空列表传递给构造函数时会发生什么：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Our application crashes, because the method `last` is throwing an error when
    there is no element with such an index on the list. Instead of an exception, we
    might prefer a null value when the list is empty. The Kotlin standard library
    already has a corresponding method that will return a null value:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序崩溃了，因为当列表为空时，`last`方法会抛出错误。我们可能更喜欢在列表为空时返回空值而不是异常。Kotlin标准库已经有了一个相应的方法，它将返回一个空值：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code will not compile because there is a possibility that the last method
    will return null irrespective of *type argument* nullability (there may be no
    elements in the list to return). To solve this problem, we need to enforce a nullable
    return type by adding a question mark to the type parameter use-site (`T?` ):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将无法编译，因为最后一个方法可能会返回null，无论*类型参数*是否为空（列表中可能没有元素返回）。为了解决这个问题，我们需要通过在类型参数使用位置（`T?`）添加一个问号来强制可空返回类型：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Type parameter *declaration-site* (place in code where type parameter is declared)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数*声明位置*（类型参数声明的代码位置）
- en: Type parameter *use-site* (place in code where type parameter is used)
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数*使用位置*（类型参数使用的代码位置）
- en: 'The `T?` parameter means that the `lastOrNull` method will always be nullable
    regardless of potential *type argument* nullability. Notice that we restored the
    type parameter `T` bound as non-nullable type `Action` , because we want to store
    non-nullable types and deal with nullability only for certain scenarios (such
    as a non-existing last element). Let''s use our updated `ActionGroup` class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`T?`参数意味着`lastOrNull`方法始终是可空的，无论潜在的*类型参数*是否为空。请注意，我们将类型参数`T`的界限恢复为非空类型`Action`，因为我们希望存储非空类型并仅在某些情况下处理可空性（例如不存在的最后一个元素）。让我们使用我们更新的`ActionGroup`类：'
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice that the `actionGroup` inferred type is nullable even if we parameterized
    the generic with a non-nullable *type argument* .
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使我们使用非空*类型参数*对泛型进行参数化，`actionGroup`推断类型仍然是可空的。
- en: 'A nullable type at the use-site does not stop us from allowing non-null types
    in the declaration-site:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用位置的可空类型不会阻止我们在声明位置允许非空类型：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's sum up the above solution. We specified a non-nullable bound for type
    parameter to disallow parameterizing the `ActionGroup` class with nullable types
    as *type arguments* . We parameterized the `ActionGroup` class with the non-nullable
    *type argument* `Action` . Finally, we enforced type parameter nullability at
    the use-site (`T?` ), because the last property can return null if there are no
    elements in the list.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下上面的解决方案。我们为类型参数指定了一个非空界限，以阻止使用可空类型作为*类型参数*对`ActionGroup`类进行参数化。我们使用非空*类型参数*`Action`对`ActionGroup`类进行参数化。最后，我们在使用位置（`T?`）强制类型参数的可空性，因为如果列表中没有元素，最后一个属性可能会返回null。
- en: Variance
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变化
- en: 'Subtyping is a popular concept in the OOP paradigm. We define inheritance between
    two classes by extending the class:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型是面向对象编程范式中的一个流行概念。我们通过扩展类来定义两个类之间的继承：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The class `Dog` extends the class `Animal` , so the type `Dog` is a subtype
    of `Animal` . This means that we can use an expression of type `Dog` whenever
    an expression of type `Animal` is required; for example, we can use it as a function
    argument or assign a variable of type `Dog` to a variable of type `Animal` :'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Dog`扩展了类`Animal`，因此类型`Dog`是`Animal`的子类型。这意味着我们可以在需要`Animal`类型的表达式中使用`Dog`类型的表达式；例如，我们可以将其用作函数参数或将`Dog`类型的变量分配给`Animal`类型的变量：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Before we move on, we need to discuss the difference between class and type.
    Type is a more general term--it can be defined by class or interface, or it can
    be built into the language (primitive type). In Kotlin, for each class (for example,
    `Dog` ), we have at least two possible types--non-nullable (`Dog` ) and nullable
    (`Dog?` ). What is more, for each generic class (for example, `class Box<T>` )
    we can define multiple data types (`Box*<Dog>*` , `Box<Dog?>` *,* `Box<Animal>`
    *,* `Box<Box<Dog>>` , and so on).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们需要讨论类和类型之间的区别。类型是一个更一般的术语--它可以由类或接口定义，也可以内置到语言中（原始类型）。在Kotlin中，对于每个类（例如`Dog`），我们至少有两种可能的类型--非空（`Dog`）和可空（`Dog?`）。而且，对于每个泛型类（例如`class
    Box<T>`），我们可以定义多个数据类型（`Box*<Dog>*`，`Box<Dog?>`，`Box<Animal>`，`Box<Box<Dog>>`等）。
- en: The previous example applies only to simple types. Variance specifies how subtyping
    between more complex types (for example, `Box<Dog>` and `Box<Animal>` ) relates
    to subtyping between their components (for example, `Animal` , and `Dog` ).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子仅适用于简单类型。变化指定了更复杂类型之间的子类型关系（例如`Box<Dog>`和`Box<Animal>`）与它们的组件之间的子类型关系（例如`Animal`和`Dog`）之间的关系。
- en: 'In Kotlin, generics are *invariant* by default. This means that there is no
    subtyping relation between the generic types `Box<Dog>` and `Box<Animal>` . The
    `Dog` component is subtype of `Animal` , but `Box<Dog>` is neither a subtype nor
    a supertype of `Box<Animal>` :'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，泛型默认是*不变*的。这意味着泛型类型`Box<Dog>`和`Box<Animal>`之间没有子类型关系。`Dog`是`Animal`的子类型，但`Box<Dog>`既不是`Box<Animal>`的子类型也不是超类型：
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Error Type mismatch. Required `Box<Animal>` , found `Box<Dog>` .
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误类型不匹配。需要`Box<Animal>`，找到`Box<Dog>`。
- en: Error Type mismatch. Required `Box<Dog>` , found `Box<Animal>` .
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误类型不匹配。需要`Box<Dog>`，找到`Box<Animal>`。
- en: The `Box<Dog>` type is neither a subtype nor a supertype of `Box<Animal>` ,
    so we can't use any of the assignments shown in the preceding code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box<Dog>`类型既不是`Box<Animal>`的子类型也不是超类型，因此我们不能使用前面代码中显示的任何赋值。'
- en: We can define subtyping relations between `Box<Dog>` and `Box<Animal>` . In
    Kotlin, a subtyping relation of generic type can be preserved (co-variant), reversed
    (contra-variant), or ignored (invariant).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义`Box<Dog>`和`Box<Animal>`之间的子类型关系。在Kotlin中，泛型类型的子类型关系可以被保留（协变）、颠倒（逆变）或忽略（不变）。
- en: When a subtyping relation is co-variant, it means that subtyping is preserved.
    The generic type will have the same relation as the *type arguments* . If `Dog`
    is a subtype of `Animal` , then `Box<Dog>` is a subtype of `Box<Animal>` .
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当子类型关系是协变时，这意味着子类型关系被保留。泛型类型将与*类型参数*具有相同的关系。如果`Dog`是`Animal`的子类型，则`Box<Dog>`是`Box<Animal>`的子类型。
- en: 'Contra-variant is the exact opposite of co-variant, where subtyping is reversed.
    The generic type will have reversed relation with respect to *type arguments*
    . If `Dog` is a subtype of `Animal` , then `Box<Animal>` is a subtype of `Box<Dog>`
    . The following diagram present all types of variance:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 逆变是协变的确切相反，子类型关系被颠倒。泛型类型将与*类型参数*的关系相反。如果`Dog`是`Animal`的子类型，则`Box<Animal>`是`Box<Dog>`的子类型。以下图表显示了所有类型的变化：
- en: '![](img/Image00043.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: ！[](img/Image00043.jpg)
- en: To define co-variant or contra-variant behavior, we need to use *variance modifiers.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义协变或逆变行为，我们需要使用*变异修饰符*。
- en: Variance modifiers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变异修饰符
- en: 'Generics in Kotlin are invariant by default. This means that we need to use
    type as the type of declared variable or function parameter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的泛型默认是不变的。这意味着我们需要将类型用作声明的变量或函数参数的类型：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can't use a generic type parametrized with `Int` , which is a subtype of
    `Number` , and `Any` , which is a supertype of `Number.` We can relax this restriction
    and change the default variance by using variance modifiers. In Java, there is
    question mark (`?` ) notation (wildcard notation) used to represent an unknown
    type. Using it, we can define two types of wildcard bounds--upper bound and lower
    bound. In Kotlin, we can achieve similar behavior using `in` and `out` modifiers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能使用泛型类型参数化为`Int`（`Number`的子类型）和`Any`（`Number`的超类型）。我们可以通过使用变异修饰符来放宽这个限制并改变默认的变异。在Java中，有一个问号（`?`）符号（通配符符号）用于表示未知类型。使用它，我们可以定义两种通配符边界--上界和下界。在Kotlin中，我们可以使用`in`和`out`修饰符来实现类似的行为。
- en: 'In Java, the upper bound wildcard allows us to define a function that accepts
    any argument that is a certain type of its subtype. In the following example,
    the sum function will accept any `List` that was parametrized with the `Number`
    class or a subtype of the Number class (`Box<Integer>` , `Box<Double>` , and so
    on):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，上界通配符允许我们定义一个接受任何参数的函数，该参数是其子类型的某种类型。在下面的例子中，sum函数将接受任何使用`Number`类或`Number`类的子类型（`Box<Integer>`，`Box<Double>`等）参数化的`List`：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can now pass `Box<Number>` to our sum function and all the subtypes, for
    example, `Box<Int>` . This Java behavior corresponds to the Kotlin out modifier.
    It represents covariance, which restricts the type to be a specific type or a
    subtype of that type. This means that we can safely pass instances of the `Box`
    class that are parametrized with any direct or indirect subclass of `Number` :'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`Box<Number>`传递给我们的sum函数以及所有的子类型，例如`Box<Int>`。这种Java行为对应于Kotlin的out修饰符。它表示协变，限制类型为特定类型或该类型的子类型。这意味着我们可以安全地传递使用任何`Number`的直接或间接子类参数化的`Box`类的实例：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In Java, the lower bound wildcard allows us to define a function that accepts
    any argument that is a certain type or its supertype. In the following example,
    the `sum` function will accept any `List` that was parametrized with the `Number`
    class or a supertype of the `Number` class (`Box<Number>` and `Box<Object>` ):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，下界通配符允许我们定义一个接受任何参数的函数，该参数是某种类型或其超类型。在下面的例子中，`sum`函数将接受任何使用`Number`类或`Number`类的超类型（`Box<Number>`和`Box<Object>`）参数化的`List`：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can now pass `Box<Any>` to our sum function and all the subtypes, for example,
    `Box<Any>` . This Java behavior corresponds to the Kotlin in modifier. It represents
    contra-variance, which restricts the type to be a specific type or a supertype
    of that type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将`Box<Any>`传递给我们的sum函数以及所有的子类型，例如`Box<Any>`。这种Java行为对应于Kotlin的in修饰符。它表示逆变，限制类型为特定类型或该类型的超类型：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It's forbidden to use an `in` and `out` modifier together. We can define variance
    modifiers in two different ways. Let's look at them in the upcoming section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 禁止同时使用`in`和`out`修饰符。我们可以以两种不同的方式定义变异修饰符。让我们在接下来的部分看看它们。
- en: Use-site variance versus declaration-site variance
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用地点变异与声明地点变异
- en: '*Use-site* variance and *declaration-site* variance basically describes the
    place in the code (site) where the variance modifier is specified. Let''s consider
    the `View` and `Presenter` example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用地点*变异和*声明地点*变异基本上描述了代码中指定变异修饰符的位置。让我们考虑`View`和`Presenter`的例子：'
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The class `Presenter` is invariant on its type `parameterT` . To fix the problem,
    we can explicitly define the subtyping relation. We can do it in two ways (use-site
    and declaration-site). First, let''s define the variance at the use-site:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Presenter`在其类型`parameterT`上是不变的。为了解决问题，我们可以明确定义子类型关系。我们可以以两种方式（使用地点和声明地点）进行定义。首先，让我们在使用地点定义变异：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Variance modifier defined at type argument use-site
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数使用地点定义的变异修饰符
- en: 'Now the `preseter` variable can store subtypes of `Presenter<BaseView>` , including
    `Presenter<ProductView>` . Our solution works, but our implementation can be improved.
    There are two problems with this approach. Now we need to specify this `out` variance
    modifier each time we want to use a generic type, for example, use it in multiple
    variables across different classes:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`preseter`变量可以存储`Presenter<BaseView>`的子类型，包括`Presenter<ProductView>`。我们的解决方案有效，但实现可以改进。这种方法有两个问题。现在我们需要每次在想要使用泛型类型时指定`out`变异修饰符，例如，在不同类中的多个变量中使用它：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Both classes `A` and `B` contains the `preseter` variable that has variance
    modifier. We lose the ability to use type inference and in result the code is
    more verbose. To improve our code we can specify variance modifier at type parameter
    declaration-site:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 类`A`和`B`都包含具有变异修饰符的`preseter`变量。我们失去了使用类型推断的能力，结果代码更冗长。为了改进我们的代码，我们可以在类型参数声明地点指定变异修饰符：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Variance modifier defined at type parameter declaration-site
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类型参数声明地点定义的变异修饰符
- en: We only need to define variance modifier once inside `Presenter` class. In fact,
    both preceding implementations are the equivalent, although *declaration-site*
    variance is more concise and it can be easier used by external clients of the
    class
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要在`Presenter`类内部定义一次变异修饰符。实际上，前面的两种实现是等价的，尽管*声明地点*变异更简洁，外部类的使用更容易
- en: Collection variance
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合变异
- en: 'In Java, arrays are co-variant. By default, we can pass an array of `String[]`
    even if an array of `Object[]` is expected:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数组是协变的。默认情况下，我们可以传递一个`String[]`数组，即使期望的是`Object[]`数组：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This behavior was important in early versions of Java, because it allowed us
    to use different types of arrays as arguments:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为在Java的早期版本中很重要，因为它允许我们使用不同类型的数组作为参数：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'But this behavior also may lead to potential runtime errors:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种行为也可能导致潜在的运行时错误：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The function `updateArray` accepts parameters of type `Object[]` and we are
    passing `String[]` . We are calling the add method with a `String` parameter.
    We can do so because array items are of type `Object,` so we can use `String`
    , which is a new value. Finally, we want to add `String` , into the generic array
    that may only contain items of `String` type. Due to default co-variant behavior,
    the compiler can't detect this problem and this will lead to an `ArrayStoreException`
    exception.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`updateArray`接受类型为`Object[]`的参数，我们正在传递`String[]`。我们正在使用`String`参数调用add方法。我们可以这样做，因为数组项的类型是`Object`，所以我们可以使用`String`，这是一个新值。最后，我们想要将`String`添加到可能只包含`String`类型项的通用数组中。由于默认的协变行为，编译器无法检测到这个问题，这将导致`ArrayStoreException`异常。
- en: 'The corresponding code would not compile in Kotlin, because the Kotlin compiler
    treats this behavior as potentially dangerous. This is the reason why arrays in
    Kotlin are invariant. Therefore, passing type other than `Array<Number>` when
    `Array<Any>` is required will result in compile time error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相应的代码在Kotlin中不会编译，因为Kotlin编译器将此行为视为潜在的危险。这就是为什么Kotlin中的数组是不变的原因。因此，在需要`Array<Any>`时传递除`Array<Number>`之外的类型将导致编译时错误：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Therefore, passing a type other than `Array<Number>` when `Array<Any>` is required
    will result in a compile-time error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在需要`Array<Any>`时传递除`Array<Number>`之外的类型将导致编译时错误：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Notice that a potential runtime exception may only occur when we can modify
    the object. Variance is also applied to Kotlin collection interfaces. In the Kotlin
    standard library, we have two list interfaces that are defined in different ways.
    The Kotlin `List` interface is defined as co-variant, because it is immutable
    (it does not contain any methods that would allow us to change the inner state),
    while the Kotlin `MutableList` interface is invariant. Here are the definitions
    of their type parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只有当我们可以修改对象时才可能发生潜在的运行时异常。变异也适用于Kotlin集合接口。在Kotlin标准库中，我们有两个以不同方式定义的列表接口。Kotlin
    `List`接口被定义为协变，因为它是不可变的（它不包含任何允许我们更改内部状态的方法），而Kotlin `MutableList`接口是不变的。以下是它们类型参数的定义：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s see the consequences of such definitions in action. It makes mutable
    lists safe from the risks of covariance:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些定义在实际中的后果。它使可变列表免受协变的风险：
- en: '[PRE35]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The list is safe, because it has no methods used to change its inner state,
    and its covariance behavior allows more general usage of functions:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该列表是安全的，因为它没有用于更改其内部状态的方法，并且其协变行为允许更广泛地使用函数：
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We can pass `List<Any>` or any of its subtypes to the `printElements` function,
    because the `List` interface is co-variant. We can only pass `MutableList<Any>`
    to the `addElement` function because the `MutableList` interface is invariant.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`List<Any>`或其任何子类型传递给`printElements`函数，因为`List`接口是协变的。我们只能将`MutableList<Any>`传递给`addElement`函数，因为`MutableList`接口是不变的。
- en: Using `in` and `out` modifiers, we can manipulate variance behavior. We should
    also be aware that variance has some limitations. Let's discuss them.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`in`和`out`修饰符，我们可以操纵变异行为。我们还应该意识到变异有一些限制。让我们讨论一下。
- en: Variance producer/consumer limitation
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变异生产者/消费者限制
- en: By applying a variance modifier, we gain co-variant/contra-variant behavior
    for a certain type parameter of the class/interface (declaration-site variance)
    or *type argument* (use-site variance). However, there is a limitation that we
    need to be aware of. To make it safe, the Kotlin compiler limits the positions
    where type parameters can be used.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用变异修饰符，我们可以为类/接口的某个类型参数（声明位置变异）或*类型参数*（使用位置变异）获得协变/逆变行为。然而，我们需要注意一个限制。为了使其安全，Kotlin编译器限制了类型参数可以使用的位置。
- en: 'With invariant (default no variance modifier on type parameter) we can use
    a type parameter on both `in` (type of function parameter) and `out` (function
    return type) positions:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不变（类型参数上默认没有变异修饰符），我们可以在`in`（函数参数的类型）和`out`（函数返回类型）位置上使用类型参数：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With variance modifier, we are only limited to a single position. This means
    that we can use a type parameter only as a type for method parameters (`in` )
    or method return value (`out` ). Our class can be producer or consumer, but never
    both. We can say that the class *takes in parameters* or *gives out parameters*
    .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过变异修饰符，我们只限于一个位置。这意味着我们只能将类型参数用作方法参数的类型（`in`）或方法返回值（`out`）。我们的类可以是生产者或消费者，但永远不会同时。我们可以说该类*接收参数*或*提供参数*。
- en: 'Let''s look at how this restriction relates to variance modifiers specified
    at the declaration-site. Here are all the correct and incorrect usages for the
    two type parameters `R` and `T` :'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这种限制与在声明位置指定的变异修饰符的关系。以下是两个类型参数`R`和`T`的所有正确和不正确的用法：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: OK type parameter `T` at in position
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在in位置的OK类型参数`T`
- en: Error, type parameter `R` at in position
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误，类型参数`R`在in位置
- en: Error, type parameter `T` at out position
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误，类型参数`T`在out位置
- en: OK, type parameter `R` at out position
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在out位置的OK，类型参数`R`
- en: As we can see, the compiler will report an error if the configuration is prohibited.
    Notice that we can add different modifiers for the two type parameters `R` and
    `T` .
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，如果配置被禁止，编译器将报告错误。请注意，我们可以为两个类型参数`R`和`T`添加不同的修饰符。
- en: 'Position restriction applies only for methods accessible (visible) outside
    the class. This means not only all `public` methods (`public` is the default modifier)
    as used previously, but also methods marked with `protected` or `internal` . When
    we change method visibility to `private` , then we can use our type parameters
    (`R` and `T` ) on any position, just like invariant type parameters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 位置限制仅适用于类外可访问（可见）的方法。这意味着不仅仅是所有`public`方法（`public`是默认修饰符），如之前所使用的，还包括标记为`protected`或`internal`的方法。当我们将方法可见性更改为`private`时，我们可以在任何位置使用我们的类型参数（`R`和`T`），就像不变的类型参数一样：
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s look at the following table, which presents all allowed positions for
    type parameters used as type:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下下表，它展示了类型参数作为类型使用时的所有允许位置：
- en: '| **Visibility modifier** | **Invariance** | **Covariance (out)** | **Contravariance
    (in)** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| **可见性修饰符** | **不变性** | **协变性（out）** | **逆变性（in）** |'
- en: '| `public` , `protected` , `internal` | in/out | out | in |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `public`，`protected`，`internal` | in/out | out | in |'
- en: '| `private` | in/out | in/out | in/out |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `private` | in/out | in/out | in/out |'
- en: Invariant constructor
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不变的构造函数
- en: 'There is one important exception for the `in` and `out` position rules described
    in the previous section: constructor parameters are always invariant:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节描述的`in`和`out`位置规则中，构造函数参数始终是不变的一个重要例外：
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The constructor is public, type parameter `T` is declared as `out,` but we can
    still use it as constructor parameter type at the in position. The reason is that
    the constructor method can't be called after an instance is created, so it is
    always safe to call it.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是公共的，类型参数`T`声明为`out`，但我们仍然可以在in位置使用它作为构造函数参数类型。原因是构造函数方法在实例创建后不能被调用，因此始终可以安全地调用它。
- en: 'As we discussed in [Chapter 4](text00088.html) , *Classes and Objects,* we
    can also define a property directly in the class constructor using a `val` or
    `var` modifier. When covariance is specified, we can only define a read-only property
    (`val` ) in the constructor that has co-variant type. It is safe because only
    the getter will be generated, so the value of this property can''t change after
    class instantiation:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第4章](text00088.html)中讨论的那样，*类和对象*，我们还可以使用`val`或`var`修饰符直接在类构造函数中定义属性。当指定协变时，我们只能在构造函数中定义具有协变类型的只读属性（`val`）。这是安全的，因为只会生成getter，因此在类实例化后，此属性的值不会改变：
- en: '[PRE41]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With `var` *,* both getter and setter are generated by the compiler, so the
    property value can potentially change at some point. That''s why we can''t declare
    a read-write (`var` ) property of co-variant type in the constructor:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`var`时，编译器会生成getter和setter，因此属性值可能在某个时刻发生变化。这就是为什么我们不能在构造函数中声明一个协变类型的读写（`var`）属性的原因：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We already said that variance restriction only applies for external clients,
    so we could still define a co-variant read-write property by adding a private
    visibility modifier:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经说过，变异限制只适用于外部客户端，因此我们仍然可以通过添加私有可见性修饰符来定义一个协变读写属性：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Another popular generic type restriction, known from Java, relates to type erasure.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个来自Java的流行的泛型类型限制与类型擦除有关。
- en: Type erasure
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型擦除
- en: Type erasure was introduced into JVM to make JVM bytecode backward compatible
    with versions that predate the introduction of generics. On the Android platform,
    both Kotlin and Java are compiled to JVM bytecode, so they both are vulnerable
    to *type erasure* .
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除是引入到JVM中的，以使JVM字节码向后兼容于引入泛型之前的版本。在Android平台上，Kotlin和Java都被编译成JVM字节码，因此它们都容易受到*类型擦除*的影响。
- en: 'Type erasure is the process of removing a *type argument* from a generic type,
    so that the generic type loses some of its type information (*type argument* )
    at runtime:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除是从泛型类型中移除*类型参数*的过程，因此泛型类型在运行时失去了一些类型信息（*类型参数*）：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The compiler can distinguish both types and guarantee type safety. However,
    during compilation, the parameterized types `Box<Int>` and `Box<String>` are translated
    by the compiler to a `Box` (raw type). The generated Java bytecode does not contain
    any information related to *type arguments* , so we can't distinguish generic
    types at runtime.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器可以区分两种类型并保证类型安全。然而，在编译过程中，编译器将参数化类型`Box<Int>`和`Box<String>`转换为`Box`（原始类型）。生成的Java字节码不包含任何与*类型参数*相关的信息，因此我们无法在运行时区分泛型类型。
- en: 'Type erasure leads to a few problems. In JVM, we can''t declare two overloads
    of the same method, with the same JVM signature:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类型擦除导致了一些问题。在JVM中，我们不能声明具有相同JVM签名的同一方法的两个重载：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the *type argument* is removed, those two methods will have exactly the
    same declaration:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当*类型参数*被移除时，这两个方法将具有完全相同的声明：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can also solve this problem by changing the JVM name of the generated function.
    We can do it using `JvmName` annotation to change the name of one of the methods
    when the code is compiled to JVM bytecode:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过更改生成函数的JVM名称来解决此问题。我们可以使用`JvmName`注解在将代码编译为JVM字节码时更改其中一个方法的名称：
- en: '[PRE47]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Nothing changed in this function usage from Kotlin, but since we changed the
    JVM name of the first function, we need to use a new name to use it from Java:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从Kotlin中使用此函数的用法没有改变，但由于我们更改了第一个函数的JVM名称，因此我们需要使用新名称从Java中使用它：
- en: '[PRE48]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Sometimes we want to preserve the *type argument* at runtime and this is where
    `reified` *type parameters* are quite handy.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望在运行时保留*类型参数*，这就是`reified` *类型参数*非常方便的地方。
- en: Reified type parameters
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具体化类型参数
- en: 'There are some cases where accessing the type parameter at runtime would be
    useful, but they are not allowed because of type erasure:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，在运行时访问类型参数会很有用，但由于类型擦除，这是不允许的：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To be able to overcome JVM limitation, Kotlin allows us to use a special modifier
    that can preserve a *type argument* at runtime. We need to mark the type parameter
    with the reified modifier:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够克服JVM的限制，Kotlin允许我们使用特殊的修饰符来在运行时保留*类型参数*。我们需要使用reified修饰符标记类型参数：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Type parameter marked as refined and function marked as `inline` .
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类型参数标记为精炼，函数标记为`inline`。
- en: Now we can safely access the *type argument* type at runtime. Reified type parameters
    work only with inline functions, because during compilation (inlining), the Kotlin
    compiler replaces reified *type argument* actual class. This way, the *type argument*
    will not be removed by type erasure.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以安全地在运行时访问*类型参数*类型。具体化类型参数仅适用于内联函数，因为在编译过程中（内联），Kotlin编译器会替换具体化*类型参数*的实际类。这样，*类型参数*就不会被类型擦除移除。
- en: 'We can also use reflection on a reified type to retrieve more information about
    the type:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对具体化类型使用反射来检索有关类型的更多信息：
- en: '[PRE51]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Occurrences of a reified type parameter are represented at JVM bytecode level
    as an actual type or a wrapper type for primitive types. That's why reified type
    parameters are not affected by type erasure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在JVM字节码级别，具体类型或原始类型的包装类型表示具体类型参数的出现。这就是为什么具体类型参数不受类型擦除影响的原因。
- en: 'Using reified type parameters allows us to write methods in a whole new way.
    To start a new `Activity` in Java, we need code like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具体类型参数允许我们以全新的方式编写方法。在Java中启动新的`Activity`，我们需要这样的代码：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In Kotlin, we can define the `startActivity` method that will allow us to navigate
    to `Activity` in much simpler way:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以定义`startActivity`方法，这将使我们以更简单的方式导航到`Activity`：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We defined the `startActivity` method and we passed information about the `Activity`
    we want to start (`ProductActivity` ) by using a *type argument* . We also defined
    an explicit reified type parameter bound to make sure that we can only use `Activity`
    (and its subclasses) as *type argument* .
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`startActivity`方法，并通过使用*类型参数*传递了关于我们要启动的`Activity`（`ProductActivity`）的信息。我们还定义了一个显式的具体类型参数边界，以确保我们只能使用`Activity`（及其子类）作为*类型参数*。
- en: The startActivity method
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: startActivity方法
- en: 'To make proper use of the `startActivity` method, we need a way to pass parameters
    to the `Activity` being started (`Bundle` ). It is possible to update the preceding
    implementation to support arguments like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确使用`startActivity`方法，我们需要一种方法来将参数传递给正在启动的`Activity`（`Bundle`）。可以更新前面的实现以支持这样的参数：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the preceding example, arguments are filled using a key and value provided
    by pairs (defined by the inline *to* function). This function implementation is,
    however, outside of the scope of this book. We can, however, use an existing one.
    The **Anko** library ([https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)
    ) already implements the `startActivity` method with all the required functionality.
    We just need to import `Appcompat-v7-commons` dependency.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，使用键和值填充参数（由内联*to*函数定义）。但是，此函数的实现超出了本书的范围。但是，我们可以使用现有的实现。**Anko**库（[https://github.com/Kotlin/anko](https://github.com/Kotlin/anko)）已经实现了具有所有必需功能的`startActivity`方法。我们只需要导入`Appcompat-v7-commons`依赖项。
- en: '[PRE55]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Anko defines extensions for `Context` and `Fragment` classes so we can use this
    method in any `Activity` or `Fragment` just like any other method defined in the
    class without the need to define the method in the class. We will discuss extensions
    in [Chapter 7](text00171.html) , *Extension Functions and Properties* .
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Anko为`Context`和`Fragment`类定义了扩展，因此我们可以在任何`Activity`或`Fragment`中使用此方法，就像在类中定义的任何其他方法一样，而无需在类中定义该方法。我们将在[第7章](text00171.html)中讨论扩展，*扩展函数和属性*。
- en: 'Be aware that reified type parameters have one main limitation: we can''t create
    an instance of a class from a reified type parameter (without reflection usage).
    The reason behind this is that a constructor is always only associated to a concrete
    instance (it is never inherited) so there is no constructor that could be safely
    used for all possible type parameters.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，具体类型参数有一个主要限制：我们无法从具体类型参数创建类的实例（不使用反射）。其背后的原因是构造函数总是只与具体实例相关联（它永远不会被继承），因此没有构造函数可以安全地用于所有可能的类型参数。
- en: Star-projections
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 星投影
- en: 'Because of type erasure, incomplete type information is available at runtime.
    For example, type parameters of generic types are not available:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型擦除，运行时只能获得不完整的类型信息。例如，泛型类型的类型参数是不可用的：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This leads to a few problems. We can''t perform any check to verify what types
    of elements `List` contains:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一些问题。我们无法执行任何检查来验证`List`包含哪些类型的元素：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The problem occurs because a check is performed at runtime where information
    about *t* ype parameters is not available. Kotlin, however, as opposed to Java,
    does not allow us to declare raw type (generic type that is not parametrized with
    *type argument* ):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在运行时执行了一个检查，其中关于*类型参数*的信息是不可用的。然而，与Java相反，Kotlin不允许我们声明原始类型（未使用*类型参数*的泛型类型）：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Kotlin allows us to use *star-projection* syntax instead, which is basically
    a way to say that information about *type argument* is missing or it is not important:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin允许我们使用*星投影*语法，这基本上是一种表明*类型参数*信息缺失或不重要的方式：
- en: '[PRE59]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'By using star-projection syntax, we say that `Box` stores arguments of a certain
    type:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用星投影语法，我们说`Box`存储特定类型的参数：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Notice that there is a difference between `Box<*>` and `Box<Any>` . If we want
    to define list contains items of Any we would use `Box<Any>` . However if we want
    to define list that contains terms of certain type, but this type is unknown (it
    may be `Any` , `Int` , `String` , and so on. But we don’t have information about
    this type), while `Box<Any>` means that list contains items of `Any` type. We
    will use `Box<*>` :'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`Box<*>`和`Box<Any>`之间存在差异。如果我们想定义包含任何项的列表，我们将使用`Box<Any>`。但是，如果我们想定义包含特定类型项的列表，但是这种类型是未知的（可能是`Any`，`Int`，`String`等等。但是我们没有关于这种类型的信息），而`Box<Any>`表示列表包含`Any`类型的项。我们将使用`Box<*>`：
- en: '[PRE61]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If a generic type defines with multiple type parameters, we need to use a star
    (`*` ) for each missing *type argument* :'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果泛型类型定义了多个类型参数，我们需要为每个缺失的*类型参数*使用星（`*`）：
- en: '[PRE62]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Star-projection is also helpful when we want to perform an operation on the
    type, but information about *type argument* is not important:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 星投影在我们想对类型执行操作，但是*类型参数*信息不重要时也很有帮助：
- en: '[PRE63]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In the preceding example, the information about *type argument* is not required
    to determine collection size. Using star-projection syntax reduces the need for
    variance modifiers as long as we don't use any methods that depend on a *type
    argument* .
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，不需要关于*类型参数*的信息来确定集合大小。使用星投影语法减少了对变异修饰符的需求，只要我们不使用依赖于*类型参数*的任何方法。
- en: Type parameter naming conventions
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型参数命名约定
- en: 'The official Java type parameter naming convention ([https://docs.oracle.com/javase/tutorial/java/generics/types.html](https://docs.oracle.com/javase/tutorial/java/generics/types.html)
    ) defines the following guidelines for parameter naming:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Java类型参数命名约定（[https://docs.oracle.com/javase/tutorial/java/generics/types.html](https://docs.oracle.com/javase/tutorial/java/generics/types.html)）为参数命名定义了以下准则：
- en: '*By convention, type parameter names are single, uppercase letters. This stands
    in sharp contrast to the variable naming conventions that you already know about,
    and with good reason. Without this convention, it would be difficult to tell the
    difference between a type variable and an ordinary class or interface name. The
    most commonly used type parameter names are:*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*按照惯例，类型参数名称为单个大写字母。这与您已经了解的变量命名约定形成鲜明对比，这是有充分理由的。如果没有这个约定，很难区分类型变量和普通类或接口名称。最常用的类型参数名称是：*'
- en: '*E: Element (used extensively by the Java Collections Framework)*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E: 元素（Java集合框架广泛使用）*'
- en: '*K: Key*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*K: 键*'
- en: '*N: Number*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N: 数字*'
- en: '*T: Type*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*T: 类型*'
- en: '*V: Value*'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*V: 值*'
- en: '*S,U,V, and so on: 2nd, 3rd, 4th types*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*S,U,V等：第2、第3、第4个类型*'
- en: Many classes in the Kotlin standard library follow this convention. It works
    fine for popular kinds of classes such as common classes (`List` *,* `Mat` *,*
    `Set` , and so on) or classes that define a simple type parameter (`Box<T>` class).
    However, with custom classes and multiple type parameters, we quickly realize
    that a single letter does not contain a sufficient amount of information and sometimes
    it's hard to quickly tell what kind of data the type parameter represents. There
    are a few solutions for this problem.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin标准库中的许多类遵循这种约定。对于常见类（`List`，`Mat`，`Set`等）或定义简单类型参数的类（`Box<T>`类）来说，这种方式很好用。然而，对于自定义类和多个类型参数，我们很快意识到单个字母包含的信息量不足，有时很难快速判断类型参数代表的数据类型。对于这个问题有一些解决方案。
- en: We could make sure that generics are properly documented and, yes, this would
    definitely help, but we still wouldn't be able to determine the meaning of a type
    parameter just by looking at the code. Documentation is important, but we should
    treat documentation as an auxiliary source of information and strive for the highest
    possible code readability.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确保泛型得到适当的文档记录，是的，这肯定会有所帮助，但我们仍然无法仅通过查看代码来确定类型参数的含义。文档很重要，但我们应该将文档视为辅助信息源，并努力实现最高可能的代码可读性。
- en: 'Over the years, programmers have started to migrate into more meaningful naming
    conventions. The **Google Java Style Guide** ([https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names](https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names)
    ) briefly describes a mix of the official Java type parameter naming convention
    and custom naming conventions. They promote two distinct styles. The first is
    to use a single capital letter, optionally followed by a single numeral (as opposed
    to the `S` *,* `U` *,* `V` names described by Java):'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，程序员已经开始转向更有意义的命名惯例。**Google Java Style Guide**（[https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names](https://google.github.io/styleguide/javaguide.html#s5.2.8-type-variable-names)）简要描述了官方Java类型参数命名约定和自定义命名约定的混合。他们提倡两种不同的风格。第一种是使用单个大写字母，可选地后跟单个数字（与Java描述的`S`，`U`，`V`名称相反）：
- en: '[PRE64]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The second style is more descriptive because it adds a meaningful prefix for
    type parameter:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种风格更具描述性，因为它为类型参数添加了有意义的前缀：
- en: '[PRE65]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Unfortunately, there is no single standard for type paramete*r* names. The most
    common solution is the use of a single uppercase letter. Those are simplified
    examples, but keep in mind that classes usually use generics in multiple places,
    so proper naming will improve your code readability.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，类型参数名称没有单一的标准。最常见的解决方案是使用单个大写字母。这些都是简化的例子，但请记住，类通常在多个地方使用泛型，因此适当的命名将提高代码的可读性。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned why generics exist and we have discussed various
    ways of defining a generic class and interface, and declaring generic types. We
    know how to deal with subtyping relations by using use-site and declaration-site
    variance modifiers. We learned how to deal with type erasure and how to preserve
    generic type at runtime using reified type parameters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了泛型存在的原因，并讨论了定义泛型类和接口以及声明泛型类型的各种方式。我们知道如何通过使用使用点和声明点变异修饰符来处理子类型关系。我们学会了如何处理类型擦除，以及如何使用具体化的类型参数在运行时保留泛型类型。
- en: In the next chapter, we will discuss one of the most exciting Kotlin features-extensions.
    This feature allows us to add new behavior to an existing class. We will learn
    how we can implement new methods and properties for any given class, including
    final classes from the Android framework and third-party libraries.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Kotlin最令人兴奋的功能之一-扩展。这个功能允许我们为现有类添加新的行为。我们将学习如何为任何给定的类实现新的方法和属性，包括Android框架和第三方库中的最终类。
