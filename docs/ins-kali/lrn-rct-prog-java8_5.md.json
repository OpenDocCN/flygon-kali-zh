["```java\nObservable<Integer> zip = Observable\n.zip(\n Observable.just(1, 3, 4),\n Observable.just(5, 2, 6),\n (a, b) -> a + b\n);\nsubscribePrint(zip, \"Simple zip\");\n```", "```java\nObservable<String> timedZip = Observable\n.zip(\n Observable.from(Arrays.asList(\"Z\", \"I\", \"P\", \"P\")),\n Observable.interval(300L, TimeUnit.MILLISECONDS),\n (value, i) -> value\n);\nsubscribePrint(timedZip, \"Timed zip\");\n```", "```java\nObservable<String> timedZip = Observable\n.from(Arrays.asList(\"Z\", \"I\", \"P\", \"P\"))\n.zipWith(\n Observable.interval(300L, TimeUnit.MILLISECONDS),\n (value, skip) -> value\n);\nsubscribePrint(timedZip, \"Timed zip\");\n```", "```java\nObservable<String> greetings = Observable\n.just(\"Hello\", \"Hi\", \"Howdy\", \"Zdravei\", \"Yo\", \"Good to see ya\")\n.zipWith(\n  Observable.interval(1L, TimeUnit.SECONDS),\n  this::onlyFirstArg\n);\nObservable<String> names = Observable\n.just(\"Meddle\", \"Tanya\", \"Dali\", \"Joshua\")\n.zipWith(\n  Observable.interval(1500L, TimeUnit.MILLISECONDS),\n  this::onlyFirstArg\n);\nObservable<String> punctuation = Observable\n.just(\".\", \"?\", \"!\", \"!!!\", \"...\")\n.zipWith(\n  Observable.interval(1100L, TimeUnit.MILLISECONDS),\n  this::onlyFirstArg\n);\n```", "```java\npublic <T, R> T onlyFirstArg(T arg1, R arg2) {\n  return arg1;\n}\n```", "```java\nObservable<String> combined = Observable\n.combineLatest(\n greetings, names, punctuation,\n (greeting, name, puntuation) ->\n greeting + \" \" + name + puntuation)\n;\nsubscribePrint(combined, \"Sentences\");\n```", "```java\nObservable<String> merged = Observable\n  .merge(greetings, names, punctuation);\nsubscribePrint(merged, \"Words\");\n```", "```java\nObservable<String> concat = Observable\n  .concat(greetings, names, punctuation);\nsubscribePrint(concat, \"Concat\");\n```", "```java\nObservable<String> concat = punctuation\n  .startWith(names)\n .startWith(greetings);\nsubscribePrint(concat, \"Concatenated\");\n```", "```java\nObservable.combineLatest(\n  a.startWith(0.0),\n  b.startWith(0.0),\n  (x, y) -> x + y\n);\n```", "```java\nObservable<String> words = Observable.just(\"Some\", \"Other\");\nObservable<Long> interval = Observable\n  .interval(500L, TimeUnit.MILLISECONDS)\n  .take(2);\nsubscribePrint(Observable.amb(words, interval), \"Amb 1\");\nRandom r = new Random();\nObservable<String> source1 = Observable\n  .just(\"data from source 1\")\n  .delay(r.nextInt(1000), TimeUnit.MILLISECONDS);\nObservable<String> source2 = Observable\n  .just(\"data from source 2\")\n  .delay(r.nextInt(1000), TimeUnit.MILLISECONDS);\nsubscribePrint(Observable.amb(source1, source2), \"Amb 2\");\n```", "```java\nObservable<String> words = Observable // (1)\n  .just(\"one\", \"way\", \"or\", \"another\", \"I'll\", \"learn\", \"RxJava\")\n  .zipWith(\n    Observable.interval(200L, TimeUnit.MILLISECONDS),\n    (x, y) -> x\n  );\nObservable<Long> interval = Observable\n  .interval(500L, TimeUnit.MILLISECONDS);\nsubscribePrint(words.takeUntil(interval), \"takeUntil\"); // (2)\nsubscribePrint( // (3)\n  words.takeWhile(word -> word.length() > 2), \"takeWhile\"\n);\nsubscribePrint(words.skipUntil(interval), \"skipUntil\"); // (4)\n```", "```java\nloadingAnimationObservable.takeUntil(requestObservable);\n```", "```java\nObservable<Object> test = Observable\n  .empty()\n  .defaultIfEmpty(5);\nsubscribePrint(test, \"defaultIfEmpty\");\n```", "```java\nObservable<String> numbers = Observable\n  .just(\"1\", \"2\", \"three\", \"4\", \"5\")\n  .map(Integer::parseInt)\n  .onErrorReturn(e -> -1);\n  subscribePrint(numbers, \"Error returned\");\n```", "```java\nObservable<Integer> defaultOnError =\n  Observable.just(5, 4, 3, 2, 1);\nObservable<String> numbers = Observable\n  .just(\"1\", \"2\", \"three\", \"4\", \"5\")\n  .map(Integer::parseInt)\n  .onExceptionResumeNext(defaultOnError);\n  subscribePrint(numbers, \"Exception resumed\");\n```", "```java\nObservable<String> numbers = Observable\n  .just(\"1\", \"2\", \"three\", \"4\", \"5\")\n  .doOnNext(number -> {\n    assert !number.equals(\"three\");\n  }\n  .map(Integer::parseInt)\n  .onErrorResumeNext(defaultOnError);\n  subscribePrint(numbers, \"Error resumed\");\n```", "```java\nclass FooException extends RuntimeException {\n  public FooException() {\n    super(\"Foo!\");\n  }\n}\n\nclass BooException extends RuntimeException {\n  public BooException() {\n    super(\"Boo!\");\n  }\n}\nclass ErrorEmitter implements OnSubscribe<Integer> {\n  private int throwAnErrorCounter = 5;\n  @Override\n  public void call(Subscriber<? super Integer> subscriber) {\n    subscriber.onNext(1);\n    subscriber.onNext(2);\n    if (throwAnErrorCounter > 4) {\n      throwAnErrorCounter--;\n      subscriber.onError(new FooException());\n      return;\n    }\n    if (throwAnErrorCounter > 0) {\n      throwAnErrorCounter--;\n      subscriber.onError(new BooException());\n      return;\n    }\n    subscriber.onNext(3);\n    subscriber.onNext(4);\n    subscriber.onCompleted();\n    }\n  }\n}\n```", "```java\nsubscribePrint(Observable.create(new ErrorEmitter()).retry(), \"Retry\");\n```", "```java\nObservable<Integer> when = Observable.create(new ErrorEmitter())\n  .retryWhen(attempts -> {\n return attempts.flatMap(error -> {\n if (error instanceof FooException) {\n System.err.println(\"Delaying...\");\n return Observable.timer(1L, TimeUnit.SECONDS);\n }\n return Observable.error(error);\n });\n })\n  .retry((attempts, error) -> {\n return (error instanceof BooException) && attempts < 3;\n });\nsubscribePrint(when, \"retryWhen\");\n```", "```java\nString username = \"meddle0x53\";\nObservable<Map> resp = githubUserInfoRequest(client, username);\nsubscribePrint(\n  resp\n  .map(json ->\n    json.get(\"name\") + \"(\" + json.get(\"language\") + \")\"),\n  \"Json\"\n);\n```", "```java\nObservable<Map> githubUserInfoRequest(HttpAsyncClient client, String githubUser) {\n  if (githubUser == null) { // (1)\n    return Observable.<Map>error(\n      new NullPointerException(\"Github user must not be null!\")\n    );\n  }\n  String url = \"https://api.github.com/users/\" + githubUser + \"/repos\";\n  return requestJson(client, url) // (2)\n  .filter(json -> json.containsKey(\"git_url\")) // (3)\n  .filter(json -> json.get(\"fork\").equals(false));\n}\n```", "```java\n    Observable<Map> requestJson(HttpAsyncClient client, String url) {\n      Observable<String> rawResponse = ObservableHttp\n     .createGet(url, client)\n     .toObservable() // (1)\n      .flatMap(resp -> resp.getContent() // (2)\n        .map(bytes -> new String(\n          bytes,  java.nio.charset.StandardCharsets.UTF_8\n        ))\n      )\n      .retry(5) // (3)\n      .cast(String.class) // (4)\n      .map(String::trim)\n      .doOnNext(resp -> getCache(url).clear()); // (5)\n    ```", "```java\n      // (6)\n      Observable<String> objects = rawResponse\n        .filter(data -> data.startsWith(\"{\"))\n        .map(data -> \"[\" + data + \"]\");\n      Observable<String> arrays = rawResponse\n        .filter(data -> data.startsWith(\"[\"));\n      Observable<Map> response = arrays\n     .ambWith(objects) // (7)\n        .map(data -> { // (8)\n          return new Gson().fromJson(data, List.class);\n        })\n        .flatMapIterable(list -> list) // (9)\n        .cast(Map.class)\n        .doOnNext(json -> getCache(url).add(json)); // (10)\n      return Observable.amb(fromCache(url), response); // (11)\n    }\n    ```", "```java\nJson : of-presentation-14(JavaScript)\nJson : portable-vim(null)\nJson : pro.js(JavaScript)\nJson : tmangr(Ruby)\nJson : todomvc-proact(JavaScript)\nJson : vimconfig(VimL)\nJson : vimify(Ruby)\nJson ended!\n\n```"]