- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: How to Choose Your Data Storage in the Cloud
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何在云中选择您的数据存储
- en: Azure, like other clouds, offers a wide range of storage devices. The simplest
    approach is to define a scalable set of virtual machines hosted in the cloud where
    we can implement our custom solutions. For instance, we can create a SQL Server
    cluster on our cloud-hosted virtual machines to increase reliability and computational
    power. However, usually, custom architectures are not the optimal solution and
    do not take full advantage of the opportunities offered by the cloud infrastructure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他云一样，Azure提供了各种存储设备。最简单的方法是在云中定义一组可扩展的虚拟机，我们可以在其中实现自定义解决方案。例如，我们可以在云托管的虚拟机上创建SQL
    Server集群，以增加可靠性和计算能力。然而，通常情况下，自定义架构并不是最佳解决方案，并且无法充分利用云基础设施提供的机会。
- en: Therefore, this chapter will not discuss such custom architectures but will
    focus mainly on the various **Platform as a Service** (**PaaS**) storage offerings
    that are available in the cloud and on Azure. These offerings include scalable
    solutions based on plain disk space, relational databases, NoSQL databases, and
    in-memory data stores such as Redis.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本章不会讨论这些自定义架构，而主要关注云中和Azure上可用的各种**平台即服务**（**PaaS**）存储方案。这些方案包括基于普通磁盘空间、关系型数据库、NoSQL数据库和Redis等内存数据存储的可扩展解决方案。
- en: Choosing a more adequate storage type is based not only on the application's
    functional requirements but also on performance and scaling-out requirements.
    In fact, while scaling out when processing resources causes a linear increase
    in performance, scaling out storage resources does not necessarily imply an acceptable
    increase in performance. In a few words, no matter how much you duplicate your
    data storage devices, if several requests affect the same chunk of data, they
    will always queue for the same amount of time to access it!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 选择更合适的存储类型不仅基于应用程序的功能要求，还基于性能和扩展要求。事实上，尽管在处理资源时进行扩展会导致性能线性增加，但扩展存储资源并不一定意味着性能会有可接受的增加。简而言之，无论您如何复制数据存储设备，如果多个请求影响相同的数据块，它们将始终排队等待相同的时间来访问它！
- en: Scaling out data causes linear increases in read operation throughput since
    each copy can serve a different request, but it doesn't imply the same increase
    in throughput for write operations since all copies of the same chunk of data
    must be updated! Accordingly, more sophisticated techniques are required to scale
    out storage devices, and not all storage engines scale equally well.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展数据会导致读操作吞吐量线性增加，因为每个副本可以处理不同的请求，但对于写操作的吞吐量并不意味着同样的增加，因为相同数据块的所有副本都必须更新！因此，需要更复杂的技术来扩展存储设备，并非所有存储引擎都能够同样良好地扩展。
- en: Relational databases do not scale well in all scenarios. Therefore, scaling
    needs and the need to distribute data geographically play a fundamental role in
    the choice of a storage engine, as well as in the choice of a SaaS offering.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有场景中，关系型数据库并不都能很好地扩展。因此，扩展需求和地理数据分布的需求在选择存储引擎以及SaaS提供方面起着基本作用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the different repositories for different purposes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解不同用途的不同存储库
- en: Choosing between relational or NoSQL storage
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关系型或NoSQL存储之间进行选择
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Cosmos DB - 管理多大陆数据库的机会
- en: Use case – storing data
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例 - 存储数据
- en: Let's get started!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter requires that you have the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要您具备以下内容：
- en: Visual Studio 2019 free Community edition or better, with all the database tools
    components installed.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019免费社区版或更高版本，安装了所有数据库工具组件。
- en: A free Azure account. The *Creating an Azure account* subsection in *Chapter
    1*, *Understanding the Importance of Software Architecture*, explains how to create
    one.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费的Azure账户。*第1章*的*创建Azure账户*小节解释了如何创建账户。
- en: For a better development experience, we advise that you also install the local
    emulator of Cosmos DB, which can be found at [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获得更好的开发体验，我们建议您还安装Cosmos DB的本地模拟器，可以在[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)找到。
- en: Understanding the different repositories for different purposes
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解不同用途的不同存储库
- en: This section describes the functionalities that are offered by the most popular
    data storage techniques. Mainly, we will focus on the functional requirements
    they are able to satisfy. Performance and scaling-out features will be analyzed
    in the next section, which is dedicated to comparing relational and NoSQL databases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了最流行的数据存储技术提供的功能。主要关注它们能够满足的功能要求。性能和扩展功能将在下一节中进行分析，该节专门比较关系型和NoSQL数据库。
- en: In Azure, the various offerings can be found by typing product names into the
    search bar at the top of all Azure portal pages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure中，可以通过在所有Azure门户页面顶部的搜索栏中输入产品名称来找到各种产品。
- en: The following subsections describe the various kinds of databases that we can
    use in our C# projects.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节描述了我们在C#项目中可以使用的各种数据库类型。
- en: Relational databases
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系型数据库
- en: Relational databases are the most common and studied type of storage. With them,
    society evolves, guaranteeing a high level of service and an uncountable amount
    of stored data. Dozens of applications have been designed to store data in this
    kind of database, and we can find them in banks, stores, industries, and so on.
    When you store data in a relational database, the basic principle is to define
    the entities and properties you will save in each of them, defining the correct
    relationship between these entities.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库是最常见和研究的存储类型。随着它们的发展，社会保证了高水平的服务和无数的存储数据。已经设计了数十种应用程序来存储这种类型的数据库中的数据，我们可以在银行、商店、工业等领域找到它们。当您将数据存储在关系数据库中时，基本原则是定义您将在其中保存的实体和属性，并定义这些实体之间的正确关系。
- en: For decades, relational databases were the only option imagined for designing
    great projects. Many big companies in the world have built their own database
    management system. Oracle, MySQL, and MS SQL Server would be listed by many as
    the ones you can trust to store your data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 几十年来，关系数据库是设计大型项目所想象的唯一选择。世界上许多大公司都建立了自己的数据库管理系统。Oracle、MySQL和MS SQL Server被许多人列为您可以信任存储数据的数据库。
- en: Usually, clouds offer several database engines. Azure offers a variety of popular
    database engines, such as Oracle, MySQL, and SQL Server (Azure SQL).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，云提供多种数据库引擎。Azure提供各种流行的数据库引擎，如Oracle、MySQL和SQL Server（Azure SQL）。
- en: Regarding the Oracle database engine, Azure offers configurable virtual machines
    with various Oracle editions installed on them, which you can easily verify by
    the suggestions you get after typing `Oracle` into the Azure portal search bar.
    Azure fees do not include Oracle licenses; they just include computation time,
    so you must bring your own license to Azure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Oracle数据库引擎，Azure提供可配置的虚拟机，上面安装了各种Oracle版本，您可以通过在Azure门户搜索栏中键入`Oracle`后获得的建议轻松验证。Azure的费用不包括Oracle许可证；它们只包括计算时间，因此您必须自行携带许可证到Azure。
- en: With MySQL on Azure, you pay to use a private server instance. The fees you
    incur depend on the number of cores you have, how much memory must be allocated,
    and on backup retention time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Azure上使用MySQL，您需要支付使用私有服务器实例的费用。您产生的费用取决于您拥有的核心数、必须分配的内存量以及备份保留时间。
- en: 'MySQL instances are redundant, and you can choose between local or geographically
    distributed redundancy:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL实例是冗余的，您可以选择本地或地理分布式冗余：
- en: '![](img/B16756_09_01.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_01.png)'
- en: 'Figure 9.1: Creating a MySQL server on Azure'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：在Azure上创建MySQL服务器
- en: Azure SQL is the most flexible offer. Here, you can configure resources that
    are used by every single database. When you create a database, you have the option
    to place it on an existing server instance or create a new instance. There are
    several pricing options that you may choose while defining your solution and Azure
    keeps incrementing them to make sure you will be able to handle your data in the
    cloud. Basically, they vary due to the computing capacity you need.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Azure SQL是最灵活的选择。在这里，您可以配置每个数据库使用的资源。创建数据库时，您可以选择将其放置在现有服务器实例上，或创建一个新实例。在定义解决方案时，您可以选择几种定价选项，Azure会不断增加它们，以确保您能够处理云中的数据。基本上，它们因您需要的计算能力而异。
- en: For instance, in the **Database Transaction Units** (**DTUs**) model, fees are
    based on the database storage capacity that has been reserved and a linear combination
    of I/O operations, CPU usage, and memory usage that is determined by a reference
    workload. Roughly, maximal database performance increases linearly when you increase
    DTUs.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在**数据库事务单位**（**DTUs**）模型中，费用基于已预留的数据库存储容量和由参考工作负载确定的I/O操作、CPU使用率和内存使用率的线性组合。粗略地说，当您增加DTUs时，最大的数据库性能会线性增加。
- en: '![](img/B16756_09_02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_02.png)'
- en: 'Figure 9.2: Creating an Azure SQL Database'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：创建Azure SQL数据库
- en: You can also configure data replication by enabling read scale-out. This way,
    you can improve the performance of read operations. Backup retention is fixed
    for each offering level (basic, standard, and premium).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过启用读取扩展来配置数据复制。这样，您可以提高读取操作的性能。备份保留对于每个提供级别（基本、标准和高级）都是固定的。
- en: If you select **Yes** for **Want to use SQL elastic pool?**, the database will
    be added to an elastic pool. Databases that are added to the same elastic pool
    will share their resources, so resources that are not used by a database can be
    used during the usage CPU peaks of other databases. It is worth mentioning that
    elastic pools can only contain databases hosted on the same server instance. Elastic
    pools are an efficient way to optimize resource usage to reduce costs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择**是**作为**是否要使用SQL弹性池？**的答案，数据库将被添加到弹性池中。添加到同一弹性池的数据库将共享其资源，因此未被数据库使用的资源可以在其他数据库的CPU使用高峰期间使用。值得一提的是，弹性池只能包含托管在同一服务器实例上的数据库。弹性池是优化资源使用以减少成本的有效方式。
- en: NoSQL databases
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NoSQL数据库
- en: 'One of the biggest challenges that relational databases have caused software
    architects is related to how we deal with database structural schema changes.
    The agility of changes needed at the beginning of this century brought the opportunity
    of using a new database style, called NoSQL. There are several types of NoSQL
    database, as we can see here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库带来的最大挑战之一是与数据库结构模式更改相关的问题。本世纪初所需的变化的灵活性带来了使用新数据库样式的机会，称为NoSQL。这里有几种类型的NoSQL数据库：
- en: '**Document-Oriented Database**: The most common one, where you have the key
    and complex data called a document.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面向文档的数据库**：最常见的数据库类型，其中您有一个称为文档的键和复杂数据。'
- en: '**Graph Database**: Social media tend to use this kind of database since the
    data is stored as graphs.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图数据库**：社交媒体倾向于使用这种类型的数据库，因为数据存储为图形。'
- en: '**Key-Value Database**: A useful database for implementing caches since you
    have the opportunity of storing key-value pairs.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**键值数据库**：用于实现缓存的有用数据库，因为您有机会存储键值对。'
- en: '**Wide-Column Store Database**: A database where the same column in each row
    can store different data.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽列存储数据库**：每行中相同的列可以存储不同的数据。'
- en: In NoSQL databases, relational tables are replaced with more general collections
    that can contain heterogeneous JSON objects. That is, collections have no predefined
    structure and no predefined fields with length constraints (in the case of strings)
    but can contain any type of object. The only structural constraint associated
    with each collection is the name of the property that acts as a primary key.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库中，关系表被更一般的集合所取代，这些集合可以包含异构的JSON对象。也就是说，集合没有预定义的结构，也没有预定义的字段长度约束（对于字符串），但可以包含任何类型的对象。与每个集合关联的唯一结构约束是充当主键的属性的名称。
- en: More specifically, each collection entry can contain nested objects and object
    collections nested in object properties, that is, related entities that, in relational
    databases, are contained in different tables and connected through external keys.
    In NoSQL, databases can be nested in their father entities. Since collection entries
    contain complex nested objects instead of simple property/value pairs, as is the
    case with relational databases, entries are not called tuples or rows, but *documents*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，每个集合条目都可以包含嵌套对象和嵌套在对象属性中的对象集合，即在关系数据库中包含在不同表中并通过外部键连接的相关实体。在NoSQL中，数据库可以嵌套在其父实体中。由于集合条目包含复杂的嵌套对象而不是简单的属性/值对，因此条目不被称为元组或行，而是*文档*。
- en: No relations and/or external key constraints can be defined between documents
    that belong to the same collection or to different collections. If a document
    contains the primary key of another document in one of its properties, it does
    so at its own risk. The developer has the responsibility of maintaining and keeping
    these coherent references.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 无法在属于同一集合或不同集合的文档之间定义关系和/或外部键约束。如果文档在其属性中包含另一个文档的主键，那么它就自担风险。开发人员有责任维护和保持这些一致的引用。
- en: Finally, since NoSQL storage is quite cheap, whole binary files can be stored
    as the values of document properties as Base64 strings. The developer can define
    rules to decide what properties to index in a collection. Since documents are
    nested objects, properties are tree paths. Usually, by default, all the paths
    are indexed, but you can specify which collection of paths and sub-paths to index.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于NoSQL存储相当便宜，整个二进制文件可以作为文档属性的值存储为Base64字符串。开发人员可以定义规则来决定在集合中索引哪些属性。由于文档是嵌套对象，属性是树路径。通常，默认情况下，所有路径都被索引，但您可以指定要索引的路径和子路径的集合。
- en: NoSQL databases are queried either with a subset of SQL or with a JSON-based
    language where queries are JSON objects whose paths represent the properties to
    query, and whose values represent the query constraints that have been applied
    to them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库可以使用SQL的子集或基于JSON的语言进行查询，其中查询是JSON对象，其路径表示要查询的属性，其值表示已应用于它们的查询约束。
- en: The possibility of nesting children objects inside documents can be simulated
    in relational databases with the help of one-to-many relationships. However, with
    relational databases, we are forced to redefine the exact structure of all the
    related tables, while NoSQL collections do not impose any predefined structure
    on the objects they contain. The only constraint is that each document must provide
    a unique value for the primary key property. Therefore, NoSQL databases are the
    only option when the structure of our objects is extremely variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中，可以通过一对多关系来模拟在文档中嵌套子对象的可能性。但是，在关系数据库中，我们被迫重新定义所有相关表的确切结构，而NoSQL集合不对其包含的对象施加任何预定义的结构。唯一的约束是每个文档必须为主键属性提供唯一值。因此，当我们的对象结构非常可变时，NoSQL数据库是唯一的选择。
- en: However, often they are chosen for the way they scale out read and write operations
    and, more generally, for their performance advantages in distributed environments.
    Their performance features will be discussed in the next section, which compares
    them to relational databases.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常它们被选择是因为它们在扩展读写操作方面的性能优势，更一般地说，在分布式环境中的性能优势。它们的性能特性将在下一节中进行讨论，该节将它们与关系数据库进行比较。
- en: The graph data model is an extreme case of a completely unstructured document.
    The whole database is a graph where queries can add, change, and delete graph
    documents.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图形数据模型是完全无结构文档的极端情况。整个数据库是一个图形，其中查询可以添加、更改和删除图形文档。
- en: 'In this case, we have two kinds of document: nodes and relationships. While
    relationships have a well-defined structure (the primary key of the nodes connected
    by the relationship, plus the relationship''s name), nodes have no structure at
    all since properties and their values are added together during node update operations.
    Graph data models were conceived to represent the features of people and the objects
    they manipulate (media, posts, and so on), along with their relationships in *social
    applications*. The Gremlin language was conceived specifically to query graph
    data models. We will not discuss this in this chapter, but references are available
    in the *Further reading* section.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两种文档：节点和关系。虽然关系具有明确定义的结构（由关系连接的节点的主键加上关系的名称），但节点根本没有结构，因为在节点更新操作期间，属性及其值会被添加在一起。图形数据模型旨在表示人和他们操纵的对象（媒体、帖子等）以及它们在*社交应用程序*中的关系的特征。Gremlin语言是专门为查询图形数据模型而设计的。我们不会在本章中讨论这一点，但在*进一步阅读*部分中有参考资料。
- en: NoSQL databases will be analyzed in detail in the remaining sections of this
    chapter, which are dedicated to describing Azure Cosmos DB and comparing it with relational
    databases.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库将在本章的其余部分中进行详细分析，这些部分专门描述了Azure Cosmos DB并将其与关系数据库进行比较。
- en: Redis
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is a distributed concurrent in-memory storage based on key-value pairs
    and supports distributed queuing. It can be used as permanent in-memory storage
    and as a web application cache for database data. Alternatively, it can be used
    as a cache for pre-rendered content.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redis`是基于键值对的分布式并发内存存储，支持分布式排队。它可以用作永久的内存存储，以及数据库数据的Web应用程序缓存。或者，它可以用作预渲染内容的缓存。'
- en: Redis can also be used to store a web application's user session data. In fact,
    ASP.NET Core supports session data to overcome the fact that the HTTP protocol
    is stateless. More specifically, user data that is kept between page changes is
    maintained in server-side stores such as Redis and indexed by a session key stored
    in cookies.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Redis`还可以用于存储Web应用程序的用户会话数据。事实上，`ASP.NET Core`支持会话数据，以克服`HTTP`协议是无状态的事实。更具体地说，保持在页面更改之间的用户数据存储在服务器端存储中，例如`Redis`，并由存储在`cookies`中的会话密钥索引。'
- en: Interaction with the Redis server in the cloud is typically based on a client
    implementation that offers an easy-to-use interface. The client for .NET and .NET
    Core is available through the `StackExchange.Redis` NuGet package. The basic operations
    of the `StackExchange.Redis` client have been documented at [https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics),
    while the full documentation can be found at [https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与云中的`Redis`服务器的交互通常基于提供易于使用界面的客户端实现。`.NET`和`.NET Core`的客户端可以通过`StackExchange.Redis`
    `NuGet`包获得。`StackExchange.Redis`客户端的基本操作已在[https://stackexchange.github.io/StackExchange.Redis/Basics](https://stackexchange.github.io/StackExchange.Redis/Basics)中记录，完整文档可以在[https://stackexchange.github.io/StackExchange.Redis](https://stackexchange.github.io/StackExchange.Redis)中找到。
- en: 'The user interface for defining a Redis server on Azure is quite simple:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Azure`上定义`Redis`服务器的用户界面非常简单：
- en: '![](img/B16756_09_03.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_03.png)'
- en: 'Figure 9.3: Creating a Redis cache'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：创建`Redis`缓存
- en: The **Pricing tier** dropdown allows us to select one of the available memory/replication
    options. A quick-start guide that explains how to use Azure Redis credentials
    and the URI with the `StackExchange.Redis` .NET Core client can be found at [https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**定价层**下拉菜单允许我们选择可用的内存/复制选项之一。可以在[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-dotnet-core-quickstart)找到一个快速入门指南，该指南解释了如何在`.NET
    Core`客户端中使用`Azure Redis`凭据和`URI`。'
- en: Azure storage accounts
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Azure`存储账户'
- en: All clouds offer scalable and redundant general-purpose disk memory that you
    can use as virtual disks in virtual machines and/or as external file storage.
    Azure *storage account* disk space can also be structured in **Tables** and **Queues**.
    Consider using this option if you need cheap blob storage. However, there are
    more sophisticated options, as we have mentioned before. Depending on the scenario
    you have, Azure NoSQL databases are a better option than tables and Azure Redis
    is a better option than Azure storage queues.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 所有云都提供可扩展和冗余的通用磁盘内存，您可以将其用作虚拟机中的虚拟磁盘和/或外部文件存储。`Azure`的*存储账户*磁盘空间也可以结构化为**表**和**队列**。如果您需要廉价的`blob`存储，可以考虑使用此选项。但是，正如我们之前提到的，还有更复杂的选项。根据您的情况，`Azure
    NoSQL`数据库比表更好，`Azure Redis`比`Azure`存储队列更好。
- en: '![](img/B16756_09_04.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_04.png)'
- en: 'Figure 9.4: Creating a storage account'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4：创建存储账户
- en: In the rest of this chapter, we will focus on NoSQL databases and how they differ
    from relational databases. Next, we will look at how to choose one over the other.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将专注于`NoSQL`数据库以及它们与关系数据库的区别。接下来，我们将看看如何在两者之间进行选择。
- en: Choosing between structured or NoSQL storage
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在结构化或`NoSQL`存储之间进行选择
- en: As a software architect, you may consider some aspects of structured and NoSQL
    storage to decide the best storage option for you. In many cases, both will be
    needed. The key point here will surely be how organized your data is and how big
    the database will become.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为软件架构师，您可能会考虑结构化和`NoSQL`存储的一些方面，以决定最适合您的存储选项。在许多情况下，两者都是需要的。关键点在于您的数据有多有组织以及数据库将变得多大。
- en: In the previous section, we stated that NoSQL databases should be preferred
    when data has almost no predefined structure. NoSQL databases not only keep variable
    attributes close to their owners, but they also keep some related objects close
    since they allow related objects to be nested inside properties and collections.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们指出当数据几乎没有预定义的结构时，应优先选择`NoSQL`数据库。`NoSQL`数据库不仅使可变属性靠近其所有者，而且还使一些相关对象靠近，因为它们允许将相关对象嵌套在属性和集合中。
- en: Unstructured data can be represented in relational databases since variable
    properties of a tuple, `t`, can be placed in a connected table containing the
    property name, property value, and the external key of `t`. However, the problem
    in this scenario is performance. In fact, property values that belong to a single
    object would be spread all over the available memory space. In a small database,
    *all over the available memory space* means far away but on the same disk; in
    a bigger database, it means far away but in different disk units; in a distributed
    cloud environment, it means far away but in different – and possibly geographically
    distributed – servers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库中可以表示非结构化数据，因为元组`t`的可变属性可以放在一个包含属性名称、属性值和`t`的外部键的连接表中。然而，在这种情况下的问题是性能。事实上，属于单个对象的属性值将分散在可用内存空间中。在小型数据库中，“分散在可用内存空间中”意味着远离但在同一磁盘上；在较大的数据库中，它意味着远离但在不同的磁盘单元中；在分布式云环境中，它意味着远离但在不同的
    - 也可能是地理分布的 - 服务器中。
- en: In NoSQL database design, we always try to put all related objects that are
    likely to be processed together into a single entry. Related objects that are
    accessed less frequently are placed in different entries. Since external key constraints
    are not enforced automatically and NoSQL transactions are very flexible, the developer
    can choose the best compromise between performance and coherence.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在NoSQL数据库设计中，我们总是试图将所有可能一起处理的相关对象放入单个条目中。访问频率较低的相关对象放在不同的条目中。由于外部键约束不会自动执行，而且NoSQL事务非常灵活，开发人员可以在性能和一致性之间选择最佳折衷方案。
- en: Therefore, we can conclude that relational databases perform well when tables
    that are usually accessed together can be stored close together. NoSQL databases,
    on the other hand, automatically ensure that related data is kept close together
    since each entry keeps most of the data it is related to inside it as nested objects.
    Therefore, NoSQL databases perform better when they are distributed to a different
    memory and to different geographically distributed servers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出结论，当通常一起访问的表可以被存储在一起时，关系数据库的表现良好。另一方面，NoSQL数据库会自动确保相关数据保持在一起，因为每个条目都将大部分相关数据作为嵌套对象保存在其中。因此，当它们分布到不同的内存和不同地理分布的服务器时，NoSQL数据库的表现更好。
- en: Unfortunately, the only way to scale out storage write operations is to split
    collection entries across several servers according to the values of *shard keys*.
    For instance, we can place all the records containing usernames that start with
    **A** on a server, the records containing usernames that start with **B** on another
    server, and so on. This way, write operations for usernames with different start
    letters may be executed in parallel, ensuring that the write throughput increases
    linearly with the number of servers.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，扩展存储写操作的唯一方法是根据*分片键*的值将集合条目分布到多个服务器上。例如，我们可以将所有以**A**开头的用户名记录放在一个服务器上，将以**B**开头的用户名记录放在另一个服务器上，依此类推。这样，具有不同起始字母的用户名的写操作可以并行执行，确保写吞吐量随着服务器数量的增加而线性增加。
- en: However, if a *shard* collection is related to several other collections, there
    is no guarantee that related records will be placed on the same server. Also,
    putting different collections on different servers without using collection sharding
    increases write throughput linearly until we reach the limit of a single collection
    per server, but it doesn't solve the issue of being forced to perform several
    operations on different servers to retrieve or update data that's usually processed
    together.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果一个*分片*集合与其他几个集合相关联，就无法保证相关记录会被放在同一台服务器上。此外，将不同的集合放在不同的服务器上而不使用集合分片会使写吞吐量线性增加，直到达到单个服务器上的单个集合的限制，但这并不能解决被迫在不同服务器上执行多个操作以检索或更新通常一起处理的数据的问题。
- en: This issue becomes catastrophic for performance in relational databases if access
    to related distributed objects must be transactional and/or must ensure structural
    constraints (such as external key constraints) are not violated. In this case,
    all related objects must be blocked during the transaction, preventing other requests
    from accessing them during the whole lifetime of a time-consuming distributed
    operation.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题对关系数据库的性能造成了灾难性的影响，如果访问相关的分布式对象必须是事务性的和/或必须确保结构约束（如外部键约束）不被违反。在这种情况下，所有相关的对象在事务期间必须被阻塞，防止其他请求在耗时的分布式操作的整个生命周期内访问它们。
- en: NoSQL databases do not suffer from this problem and perform better with sharding
    and consequently with write-scaled output. This is because they do not distribute
    related data to different storage units and instead store them as nested objects
    of the same database entry. On the other hand, they suffer from different problems,
    like not supporting transactions by default.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库不会遇到这个问题，并且在分片和因此写扩展输出方面表现更好。这是因为它们不会将相关数据分布到不同的存储单元，而是将它们存储为同一数据库条目的嵌套对象。另一方面，它们遇到了不支持事务的不同问题。
- en: It is worth mentioning that there are situations where relational databases
    perform well with sharding. A typical instance is a multi-tenant application.
    In a multi-tenant application, all entries collections can be partitioned into
    non-overlapping sets called **tenants**. Only entries belonging to the same tenant
    can refer to each other, so if all the collections are sharded in the same way
    according to their object tenants, all related records end up in the same shard,
    that is, in the same server, and can be navigated efficiently.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，有些情况下关系数据库在分片时表现良好。一个典型的例子是多租户应用。在多租户应用中，所有条目集合可以被分成不重叠的集合，称为**租户**。只有属于同一个租户的条目才能相互引用，因此如果所有集合都按照它们的对象租户以相同的方式分片，那么所有相关记录最终都会在同一个分片中，也就是在同一个服务器上，并且可以被高效地导航。
- en: Multi-tenant applications are not rare in the cloud since all applications that
    offer the same services to several different users are often implemented as multi-tenant
    applications, where each tenant corresponds to a user subscription. Accordingly,
    relational databases are conceived to work in the cloud, such as Azure SQL Server,
    and usually offer sharding options for multi-tenant applications. Typically, sharding
    is not a cloud service and must be defined with database engine commands. Here,
    we will not describe how to define shards with Azure SQL Server, but the *Further
    reading* section contains a link to the official Microsoft documentation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户应用在云中并不罕见，因为所有为多个不同用户提供相同服务的应用通常都是作为多租户应用实现的，其中每个租户对应一个用户订阅。因此，关系数据库被设计为在云中工作，例如Azure
    SQL Server，并通常为多租户应用提供分片选项。通常，分片不是云服务，必须使用数据库引擎命令来定义。在这里，我们不会描述如何使用Azure SQL Server定义分片，但*进一步阅读*部分包含了官方微软文档的链接。
- en: In conclusion, relational databases offer a pure, logical view of data that
    is independent of the way they are actually stored and use a declarative language
    to query and update them. This simplifies development and system maintenance,
    but it may cause performance issues in a distributed environment that requires
    write scale-out. In NoSQL databases, you must handle more details about how to
    store data, as well as some procedural details for all the update and query operations,
    manually, but this allows you to optimize performance in distributed environments
    that require both read and write scale-out.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，关系数据库提供了数据的纯逻辑视图，与实际存储方式无关，并使用声明性语言来查询和更新数据。这简化了开发和系统维护，但在需要写入扩展的分布式环境中可能会导致性能问题。在NoSQL数据库中，您必须手动处理有关如何存储数据以及所有更新和查询操作的一些过程性细节，但这使您能够在需要读取和写入扩展的分布式环境中优化性能。
- en: In the next section, we will look at Azure Cosmos DB, the main Azure NoSQL offering.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍Azure Cosmos DB，这是Azure的主要NoSQL产品。
- en: Azure Cosmos DB – an opportunity to manage a multi-continental database
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Azure Cosmos DB - 管理多大陆数据库的机会
- en: Azure Cosmos DB is Azure's main NoSQL offering. Azure Cosmos DB has its own
    interface that is a subset of SQL, but it can be configured with a MongoDB interface.
    It can also be configured as a graph data model that can be queried with Gremlin.
    Cosmos DB allows replication for fault tolerance and read scale-out, and replicas
    can be distributed geographically to optimize communication performance. Moreover,
    you can specify which data center all the replicas are placed in. The user also
    has the option to write-enable all the replicas so that writes are immediately
    available in the geographical area where they are done. Write scale-up is achieved
    with sharding, which the user can configure by defining which properties to use
    as shard keys.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Cosmos DB是Azure的主要NoSQL产品。Azure Cosmos DB具有自己的界面，是SQL的子集，但可以配置为具有MongoDB接口。它还可以配置为可以使用Gremlin查询的图形数据模型。Cosmos
    DB允许复制以实现容错和读取扩展，并且副本可以在地理上分布以优化通信性能。此外，您可以指定所有副本放置在哪个数据中心。用户还可以选择启用所有副本的写入，以便在进行写入的地理区域立即可用。通过分片实现写入扩展，用户可以通过定义要用作分片键的属性来配置分片。
- en: Creating an Azure Cosmos DB account
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Azure Cosmos DB帐户
- en: 'You can define a Cosmos DB account by typing `Cosmos DB` into the Azure portal
    search bar and clicking **Add**. The following page will appear:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Azure门户搜索栏中键入`Cosmos DB`并单击**添加**来定义Cosmos DB帐户。将出现以下页面：
- en: '![](img/B16756_09_05.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_05.png)'
- en: 'Figure 9.5: Creating an Azure Cosmos DB account'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5：创建Azure Cosmos DB帐户
- en: The account name you choose is used in the resource URI as `{account_name}.documents.azure.com`.
    The **API** dropdown lets you choose the kind of interface you prefer (for example,
    SQL, MongoDB, or Gremlin). Then, you can decide which data center the main database
    will be placed in and whether you want to enable geographically distributed replication.
    Once you have enabled geographically distributed replication, you can choose the
    number of replicas you want to use and where to place them.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的帐户名称将在资源URI中用作`{account_name}.documents.azure.com`。**API**下拉菜单可让您选择所需的接口类型（例如SQL、MongoDB或Gremlin）。然后，您可以决定主数据库将放置在哪个数据中心，以及是否要启用地理分布式复制。启用地理分布式复制后，您可以选择要使用的副本数量以及放置它们的位置。
- en: Microsoft has been improving many of its Azure services. By the time this book
    was written, the Serverless option for capacity mode and Notebooks were in Preview.
    The best way to keep updated about new features of any Azure Component is by checking
    its documentation from time to time.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 微软一直在改进其许多Azure服务。在撰写本书时，容量模式和笔记本的无服务器选项处于预览状态。了解任何Azure组件的新功能的最佳方法是不时查看其文档。
- en: The **Multi-region Writes** toggle lets you enable writes on geographically
    distributed replicas. If you do not do this, all write operations will be routed
    to the main data center. Finally, you may also define backup policies and encryption
    during the creation process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**多区域写入**切换允许您在地理分布的副本上启用写入。如果不这样做，所有写操作将被路由到主数据中心。最后，您还可以在创建过程中定义备份策略和加密。'
- en: Creating an Azure Cosmos container
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Azure Cosmos容器
- en: Once you have created your account, select **Data Explorer** to create your
    databases and containers inside of them. A container is the unit of scalability
    both for provisioned throughput and storage.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建帐户后，选择**Data Explorer**来创建数据库和其中的容器。容器是预留吞吐量和存储的可扩展单位。
- en: 'Since databases just have a name and no configuration, you can directly add
    a container and then the database where you wish to place it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数据库只有名称而没有配置，您可以直接添加一个容器，然后将其放置在希望放置它的数据库中：
- en: '![](img/B16756_09_06.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_06.png)'
- en: 'Figure 9.6: Adding a container in Azure Cosmos DB'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6：在Azure Cosmos DB中添加容器
- en: Here, you can decide on database and container names and the property to use
    for sharding (the partition key). Since NoSQL entries are object trees, property
    names are specified as paths. You can also add properties whose values are required
    to be unique.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以决定数据库和容器的名称以及用于分片的属性（分区键）。由于NoSQL条目是对象树，因此属性名称被指定为路径。您还可以添加值必须唯一的属性。
- en: However, uniqueness IDs are checked inside each shard, so this option is only
    useful in certain situations, such as multi-tenant applications (where each tenant
    is included in a single shard). The fees depend on the collection throughput that
    you choose.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，唯一性ID在每个分片内进行检查，因此此选项仅在某些情况下有用，例如多租户应用程序（其中每个租户包含在单个分片中）。费用取决于您选择的集合吞吐量。
- en: This is where you need to target all resource parameters to your needs. Throughput
    is expressed in request units per second, where request units per second is defined
    as the throughput we have when performing a read of 1 KB per second. Hence, if
    you check the *Provision database throughput* option, the chosen throughput is
    shared with the whole database, instead of being reserved as a single collection.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您需要将所有资源参数定位到您的需求的地方。吞吐量以每秒请求单位表示，其中每秒请求单位定义为执行每秒1 KB读取时的吞吐量。因此，如果选择*预留数据库吞吐量*选项，则所选的吞吐量将与整个数据库共享，而不是作为单个集合保留。
- en: Accessing Azure Cosmos data
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问Azure Cosmos数据
- en: After creating the Azure Cosmos container, you will be able to access data.
    To get connection information, you can select the **Keys** menu. There, you will
    see all the information you need to connect with your Cosmos DB account from your
    application. **The connection information page** will provide you with the account
    URI and two connection keys, which can be used interchangeably to connect with
    the account.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Azure Cosmos容器后，您将能够访问数据。要获取连接信息，您可以选择**Keys**菜单。在那里，您将看到连接到您的应用程序的Cosmos
    DB帐户所需的所有信息。**连接信息页面**将为您提供帐户URI和两个连接密钥，这两个密钥可以互换使用以连接到帐户。
- en: '![](img/B16756_09_07.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_09_07.png)'
- en: 'Figure 9.7: Connection information page'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7：连接信息页面
- en: There are also keys with read-only privileges. Every key can be regenerated,
    and each account has two equivalent keys, like many other Azure Components. This
    approach enables operations to be handled efficiently; that is, when a key is
    changed, the other one is kept. Therefore, existing applications can continue
    using the other key before upgrading to the new key.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '还有具有只读权限的密钥。每个密钥都可以重新生成，每个帐户都有两个等效的密钥，就像许多其他Azure组件一样。这种方法使操作能够有效地处理；也就是说，当一个密钥被更改时，另一个密钥被保留。因此，在升级到新密钥之前，现有应用程序可以继续使用另一个密钥。 '
- en: Defining database consistency
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义数据库一致性
- en: Considering that you are in the context of a distributed database, Azure Cosmos
    DB enables you to define the default read consistency level you will have. By
    selecting **Default consistency** in the main menu of your Cosmos DB account,
    you can choose the default replication consistency that you wish to apply to all
    your containers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您处于分布式数据库的上下文中，Azure Cosmos DB使您能够定义您将拥有的默认读一致性级别。通过在Cosmos DB帐户的主菜单中选择**默认一致性**，您可以选择要应用于所有容器的默认复制一致性。
- en: This default can be overridden in each container, either from Data Explorer
    or programmatically. Consistency problems in read/write operations are a consequence
    of data replication. More specifically, the results of various read operations
    may be incoherent if the read operations are executed on different replicas that
    have received different partial updates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在数据资源管理器或以编程方式中覆盖每个容器的默认设置。读/写操作中的一致性问题是数据复制的结果。具体来说，如果读操作在接收到不同部分更新的不同副本上执行，则各种读操作的结果可能不一致。
- en: 'The following are the available consistency levels. These have been ordered
    from the weakest to the strongest:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可用的一致性级别。这些级别已经按从最弱到最强的顺序排列：
- en: '**Eventual**: After enough time has passed, if no further write operations
    are done, all the reads converge and apply all the writes. The order of writes
    is also not guaranteed, so while writes are being processed, you could also end
    up reading an earlier version than the one you have previously read.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最终一致性**：足够的时间过去后，如果没有进一步的写操作，所有读取将收敛并应用所有写操作。写入的顺序也不能保证，因此在处理写入时，您可能会读取先前读取的较早版本。'
- en: '**Consistent Prefix**: All the writes are executed in the same order on all
    the replicas. So, if there are `n` write operations, each read is consistent with
    the result of applying the first `m` writes for some `m` less or equal to `n`.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性前缀**：所有写操作在所有副本上以相同的顺序执行。因此，如果有`n`个写操作，每次读取都与应用前`m`个写操作的结果一致，其中`m`小于或等于`n`。'
- en: '**Session**: This is the same as the consistency prefix but also guarantees
    that each writer sees the result of its own writes in all subsequent read operations
    and that subsequent reads of each reader are coherent (either the same database
    or a more updated version of it).'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话**：这与一致性前缀相同，但还保证每个写入者在所有后续读取操作中看到其自己写入的结果，并且每个读取者的后续读取是一致的（要么是相同的数据库，要么是更新的版本）。'
- en: '**Bounded Staleness**: This is associated either with a delay time, `Delta`,
    or with several operations, `N`. Each read sees the results of all the write operations
    that were performed before a time `Delta` (or before the last `N` operations).
    That is, its reads converge with the result of all the writes with a maximum time
    delay of `Delta` (or a maximum operations delay of `N`).'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有界陈旧性**：这与延迟时间`Delta`或多个操作`N`相关联。每次读取都会看到在时间`Delta`（或最后`N`次操作）之前执行的所有写操作的结果。也就是说，它的读取与最大时间延迟`Delta`（或最大操作延迟`N`）的所有写操作的结果收敛。'
- en: '**Strong**: This is bounded staleness combined with `Delta = 0`. Here, each
    read reflects the result of all previous write operations.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强一致性**：这是有界陈旧性与`Delta = 0`相结合。在这里，每次读取都反映了所有先前的写操作的结果。'
- en: The strongest consistency can be obtained to the detriment of performance. By
    default, the consistency is set to **Session**, which is a good compromise between
    coherence and performance. A lower level of consistency is difficult to handle
    in applications and is only usually acceptable if sessions are either read-only
    or write-only.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最强的一致性可以通过牺牲性能来获得。默认情况下，一致性设置为**Session**，这是一致性和性能之间的良好折衷。较低级别的一致性在应用程序中很难处理，通常只有在会话是只读或只写时才可接受。
- en: 'If you select the **Settings** option in the **Data Explorer** menu of the
    container of your database, you can configure which paths to index and which kind
    of indexing to apply to each data type of each path. The configuration consists
    of a JSON object. Let us analyze its various properties:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在数据库容器的**Data Explorer**菜单中选择**Settings**选项，您可以配置要对哪些路径进行索引以及对每个路径的每种数据类型应用哪种类型的索引。配置由JSON对象组成。让我们分析其各种属性：
- en: '[PRE0]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you set `indexingMode` to `none` instead of `consistent`, no index is generated,
    and the collection can be used as a key-value dictionary that is indexed by the
    collection primary key. In this scenario, no **secondary** indexes are generated,
    so the primary key could not efficiently be searched on. When `automatic` is set
    to `true`, all document properties are automatically indexed:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`indexingMode`设置为`none`而不是`consistent`，则不会生成索引，并且集合可以用作由集合主键索引的键值字典。在这种情况下，不会生成**次要**索引，因此无法有效地进行搜索。当`automatic`设置为`true`时，所有文档属性都会自动索引：
- en: '[PRE1]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Each entry in the `IncludedPaths` specifies a path pattern such as `/subpath1/subpath2/?`
    (settings apply just to the `/subpath1/subpath2/property`) or `/subpath1/subpath2/*`
    (settings apply to all the paths starting with `/subpath1/subpath2/`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`IncludedPaths`中的每个条目都指定了一个路径模式，例如`/subpath1/subpath2/?`（设置仅适用于`/subpath1/subpath2/property`）或`/subpath1/subpath2/*`（设置适用于以`/subpath1/subpath2/`开头的所有路径）。'
- en: Patterns contain the `[]` symbol when settings must be applied to child objects
    contained in collection properties; for example, `/subpath1/subpath2/[]/?`, `/subpath1/subpath2/[]/childpath1/?`,
    and so on. Settings specify the index type to apply to each data type (string,
    number, geographic point, and so on). Range indexes are needed for comparison
    operations, while hash indices are more efficient if we need equality comparisons.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将设置应用于集合属性中包含的子对象时，模式包含`[]`符号；例如，`/subpath1/subpath2/[]/?`，`/subpath1/subpath2/[]/childpath1/?`等。设置指定要应用于每种数据类型（字符串、数字、地理点等）的索引类型。范围索引用于比较操作，而哈希索引在需要进行相等比较时更有效。
- en: 'It is possible to specify a precision, that is, the maximum number of characters
    or digits to use in all the index keys. `-1` means the maximum precision and is
    always recommended:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以指定精度，即在所有索引键中使用的最大字符或数字的数量。`-1`表示最大精度，始终建议使用：
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Paths contained in `excludedPaths` are not indexed at all. Index settings can
    also be specified programmatically.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`excludedPaths`中包含的路径根本不被索引。索引设置也可以以编程方式指定。'
- en: 'Here, you have two options to connect to Cosmos DB: use a version of its official
    client for your preferred programming language or use Cosmos DB''s Entity Framework
    Core provider. In the following subsections, we will have a look at both options.
    Then, we will describe how to use Cosmos DB''s Entity Framework Core provider
    with a practical example.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您有两种连接到Cosmos DB的选项：使用首选编程语言的官方客户端的版本，或者使用Cosmos DB的Entity Framework Core提供程序。在接下来的小节中，我们将看看这两个选项。然后，我们将描述如何使用Cosmos
    DB的Entity Framework Core提供程序，并提供一个实际示例。
- en: The Cosmos DB client
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cosmos DB客户端
- en: The Cosmos DB client for .NET 5 is available through the `Microsoft.Azure.Cosmos`
    NuGet package. It offers full control of all Cosmos DB features, while the Cosmos
    DB Entity Framework provider is easier to use but hides some Cosmos DB peculiarities.
    Follow these steps to interact with Cosmos DB through the official Cosmos DB client
    for .NET 5.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 5的Cosmos DB客户端可通过`Microsoft.Azure.Cosmos` NuGet包获得。它提供了对所有Cosmos DB功能的完全控制，而Cosmos
    DB Entity Framework提供程序更易于使用，但隐藏了一些Cosmos DB的特殊性。按照以下步骤通过.NET 5的官方Cosmos DB客户端与Cosmos
    DB进行交互。
- en: 'The following code sample shows the creation of a database and a container
    using the client component. Any operation requires the creation of a client object.
    Do not forget that the client must be disposed of by calling its `Dispose` method
    (or by enclosing the code that references it in a `using` statement) when you
    do not need it anymore:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了使用客户端组件创建数据库和容器。任何操作都需要创建客户端对象。不要忘记，当您不再需要它时，必须通过调用其`Dispose`方法（或将引用它的代码封装在`using`语句中）来处理客户端：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: During collection creation, you can pass a `ContainerProperties` object, where
    you can specify the consistency level, how to index properties, and all the other
    collection features.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建集合时，可以传递`ContainerProperties`对象，其中可以指定一致性级别、如何对属性进行索引以及所有其他集合功能。
- en: 'Then, you must define the .NET classes that correspond to the structure of
    the JSON document you need to manipulate in your collections. You can also use
    the `JsonProperty` attribute to map class property names to JSON names if they
    are not equal:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须定义与您需要在集合中操作的JSON文档结构相对应的.NET类。如果它们不相等，您还可以使用`JsonProperty`属性将类属性名称映射到JSON名称：
- en: '[PRE4]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have all the necessary classes, you can use client methods to `ReadItemAsync`,
    `CreateItemAsync`, and `DeleteItemAsync`. You can also query data using a `QueryDefinition`
    object that accepts SQL commands. You can find a complete introduction to this
    library at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有所有必要的类，您可以使用客户端方法`ReadItemAsync`，`CreateItemAsync`和`DeleteItemAsync`。您还可以使用接受SQL命令的`QueryDefinition`对象来查询数据。您可以在[https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-get-started)找到有关此库的完整介绍。
- en: The Cosmos DB Entity Framework Core provider
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cosmos DB Entity Framework Core提供程序
- en: 'The Cosmos DB provider for Entity Framework Core is contained in the `Microsoft.EntityFrameworkCore.Cosmos`
    NuGet package. Once you''ve added this to your project, you can proceed in a similar
    way to when you used the SQL Server provider in *Chapter 8*, *Interacting with
    Data in C# – Entity Framework Core*, but with a few differences. Let us look:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Entity Framework Core的Cosmos DB提供程序包含在`Microsoft.EntityFrameworkCore.Cosmos`
    NuGet包中。一旦将其添加到项目中，您可以以类似的方式进行操作，就像在*第8章*中使用SQL Server提供程序时一样，但有一些不同之处。让我们看看：
- en: 'There are no migrations since Cosmos DB databases have no structure to update.
    Instead, they have a method that ensures that the database, along with all the
    necessary collections, is created:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Cosmos DB数据库没有结构需要更新，因此没有迁移。相反，它们有一种方法可以确保数据库以及所有必要的集合被创建：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'By default, the `DbSet<T>` properties from `DBContext` are mapped to a unique
    container since this is the cheapest option. You can override this default by
    explicitly specifying which container you want to map some entities to by using
    the following configuration instruction:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，从`DBContext`映射到唯一容器的`DbSet<T>`属性，因为这是最便宜的选项。您可以通过显式指定要将某些实体映射到哪个容器来覆盖此默认设置，方法是使用以下配置指令：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The only useful annotation on entity classes is the `Key` attribute, which becomes
    obligatory when the principal keys are not called `Id`.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体类上唯一有用的注释是`Key`属性，当主键不叫`Id`时，它就变得强制性了。
- en: Principal keys must be strings and cannot be auto-incremented to avoid synchronization
    issues in a distributed environment. The uniqueness of primary keys can be ensured
    by generating GUIDs and transforming them into strings.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主键必须是字符串，不能自动增加以避免在分布式环境中出现同步问题。主键的唯一性可以通过生成GUID并将其转换为字符串来确保。
- en: When defining relationships between entities, you can specify that an entity
    or a collection of entities is owned by another entity, in which case it is stored
    together with the father entity.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义实体之间的关系时，您可以指定一个实体或实体集合是由另一个实体拥有的，这种情况下它将与父实体一起存储。
- en: We will look at the usage of Cosmos DB's Entity Framework provider in the next
    section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中查看Cosmos DB的Entity Framework提供程序的用法。
- en: Use case – storing data
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例-存储数据
- en: 'Now that we have learned how to use NoSQL, we must decide whether NoSQL databases
    are adequate for our book use case WWTravelClub application. We need to store
    the following families of data:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何使用NoSQL，我们必须决定NoSQL数据库是否适合我们的书籍使用案例WWTravelClub应用程序。我们需要存储以下数据系列：
- en: '**Information about available destinations and packages**: Relevant operations
    for this data are reads since packages and destinations do not change very often.
    However, they must be accessed as fast as possible from all over the world to
    ensure a pleasant user experience when users browse the available options. Therefore,
    a distributed relational database with geographically distributed replicas is
    possible, but not necessary since packages can be stored inside their destinations
    in a cheaper NoSQL database.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有关可用目的地和套餐的信息**：此数据的相关操作是读取，因为套餐和目的地不经常更改。但是，它们必须尽可能快地从世界各地访问，以确保用户在浏览可用选项时有愉快的体验。因此，可能存在具有地理分布副本的分布式关系数据库，但并非必需，因为套餐可以存储在更便宜的NoSQL数据库中。'
- en: '**Destination reviews**: In this case, distributed write operations have a
    non-negligible impact. Moreover, most writes are additions since reviews are not
    usually updated. Additions benefit a lot from sharding and do not cause consistency
    issues like updates do. Accordingly, the best option for this data is a NoSQL
    collection.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目的地评论**：在这种情况下，分布式写操作会产生不可忽略的影响。此外，大多数写入都是添加，因为评论通常不会更新。添加受益于分片，并且不像更新那样会导致一致性问题。因此，这些数据的最佳选择是NoSQL集合。'
- en: '**Reservations**: In this case, consistency errors are not acceptable because
    they may cause overbooking. Reads and writes have a comparable impact, but we
    need reliable transactions and good consistency checks. Luckily, data can be organized
    in a multi-tenant database where tenants are destinations since reservation information
    belonging to different destinations is completely unrelated. Accordingly, we may
    use sharded SQL Azure database instances.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**预订**：在这种情况下，一致性错误是不可接受的，因为它们可能导致超额预订。读取和写入具有可比较的影响，但我们需要可靠的事务和良好的一致性检查。幸运的是，数据可以组织在一个多租户数据库中，其中租户是目的地，因为属于不同目的地的预订信息是完全不相关的。因此，我们可以使用分片的SQL
    Azure数据库实例。'
- en: In conclusion, the best option for data in the first and second bullet points
    is Cosmos DB, while the best option for the third point is Azure SQL Server. Actual
    applications may require a more detailed analysis of all data operations and their
    frequencies. In some cases, it is worth implementing prototypes for various possible
    options and executing performance tests with typical workloads on all of them.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，第一和第二个要点的数据的最佳选择是Cosmos DB，而第三个要点的最佳选择是Azure SQL Server。实际应用可能需要对所有数据操作及其频率进行更详细的分析。在某些情况下，值得为各种可能的选项实施原型，并在所有选项上使用典型工作负载执行性能测试。
- en: In the remainder of this section, we will migrate the destinations/packages
    data layer we looked at in *Chapter 8*, *Interacting with Data in C# – Entity
    Framework Core*, to Cosmos DB.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将迁移我们在*第8章* *与C#中的数据交互-Entity Framework Core*中查看的目的地/套餐数据层到Cosmos
    DB。
- en: Implementing the destinations/packages database with Cosmos DB
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Cosmos DB实现目的地/套餐数据库
- en: 'Let''s move on to the database example we built in *Chapter 8*, *Interacting
    with Data in C# – Entity Framework Core*, to Cosmos DB by following these steps:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续按照以下步骤将我们在*第8章* *与C#中的数据交互-Entity Framework Core*中构建的数据库示例迁移到Cosmos DB：
- en: First, we need to make a copy of the WWTravelClubDB project and make `WWTravelClubDBCosmo`
    the new root folder.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要复制WWTravelClubDB项目，并将`WWTravelClubDBCosmo`作为新的根文件夹。
- en: Open the project and delete the migrations folder since migrations are not required
    anymore.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开项目并删除迁移文件夹，因为不再需要迁移。
- en: We need to replace the SQL Server Entity Framework provider with the Cosmos
    DB provider. To do this, go to **Manage NuGet Packages** and uninstall the `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet package. Then, install the `Microsoft.EntityFrameworkCore.Cosmos` NuGet
    package.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要用Cosmos DB提供程序替换SQL Server Entity Framework提供程序。为此，请转到**管理NuGet包**并卸载`Microsoft.EntityFrameworkCore.SqlServer`
    NuGet包。然后，安装`Microsoft.EntityFrameworkCore.Cosmos` NuGet包。
- en: 'Then, do the following on the `Destination` and `Package` entities:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`Destination`和`Package`实体上执行以下操作：
- en: Remove all data annotations.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除所有数据注释。
- en: Add the `[Key]` attribute to their `Id` properties since this is obligatory
    for Cosmos DB providers.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为它们的 `Id` 属性添加 `[Key]` 属性，因为这对于 Cosmos DB 提供程序是强制性的。
- en: Transform the type of the `Id` properties of both `Package` and `Destination`,
    and the `PackagesListDTO` classes from `int` to `string`. We also need to turn
    the `DestinationId` external references in `Package` and in the `PackagesListDTO`
    classes into `string`. In fact, the best option for keys in distributed databases
    is a string generated from a GUID, because it is hard to maintain an identity
    counter when table data is distributed among several servers.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `Package` 和 `Destination` 的 `Id` 属性的类型，以及 `PackagesListDTO` 类从 `int` 转换为 `string`。我们还需要将
    `Package` 和 `PackagesListDTO` 类中的 `DestinationId` 外部引用转换为 `string`。实际上，在分布式数据库中，使用
    GUID 生成的字符串作为键是最佳选择，因为在表数据分布在多个服务器之间时，很难维护标识计数器。
- en: 'In the `MainDBContext` file, we need to specify that packages related to a
    destination must be stored inside the destination document itself. This can be
    achieved by replacing the Destination-Package relation configuration in the `OnModelCreatingmethod`
    method with the following code:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainDBContext` 文件中，我们需要指定与目的地相关的包必须存储在目的地文档本身内。这可以通过在 `OnModelCreatingmethod`
    方法中替换 Destination-Package 关系配置来实现，代码如下：
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we must replace `HasMany` with `OwnsMany`. There is no equivalent to `WithOne`
    since once an entity is owned, it must have just one owner, and the fact that
    the `MyDestination` property contains a pointer to the father entity is evident
    from its type. Cosmos DB also allows the use of `HasMany`, but in this case, the
    two entities are not nested one in the other. There is also an `OwnOne` configuration
    method for nesting single entities inside other entities.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们必须用 `OwnsMany` 替换 `HasMany`。没有等效于 `WithOne`，因为一旦实体被拥有，它必须只有一个所有者，并且 `MyDestination`
    属性包含对父实体的指针的事实从其类型中显而易见。Cosmos DB 也允许使用 `HasMany`，但在这种情况下，这两个实体不是相互嵌套的。还有一个用于将单个实体嵌套在其他实体内的
    `OwnOne` 配置方法。
- en: Actually, both `OwnsMany` and `OwnsOne` are available for relational databases,
    but in this case, the difference between `HasMany` and `HasOne` is that children
    entities are automatically included in all queries that return their father entities,
    with no need to specify an `Include` LINQ clause. However, child entities are
    still stored in separate tables.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实际上，对于关系数据库，`OwnsMany` 和 `OwnsOne` 都是可用的，但在这种情况下，`HasMany` 和 `HasOne` 之间的区别在于子实体会自动包含在返回其父实体的所有查询中，无需指定
    `Include` LINQ 子句。但是，子实体仍然存储在单独的表中。
- en: '`LibraryDesignTimeDbContextFactory` must be modified to use Cosmos DB connection
    data, as shown in the following code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`LibraryDesignTimeDbContextFactory` 必须修改为使用 Cosmos DB 连接数据，如下所示的代码：'
- en: '[PRE8]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, in our test console, we must explicitly create all entity principal
    keys using GUIDs:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的测试控制台中，我们必须明确使用 GUID 创建所有实体主键：
- en: '[PRE9]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we call `context.Database.EnsureCreated()` instead of applying migrations
    since we only need to create the database. Once the database and collections have
    been created, we can fine-tune their settings from the Azure portal. Hopefully,
    future versions of the Cosmos DB Entity Framework Core provider will allow us
    to specify all collection options.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们调用 `context.Database.EnsureCreated()` 而不是应用迁移，因为我们只需要创建数据库。一旦数据库和集合被创建，我们可以从
    Azure 门户微调它们的设置。希望未来版本的 Cosmos DB Entity Framework Core 提供程序将允许我们指定所有集合选项。
- en: 'Finally, the final query, which starts with `context.Packages.Where...` must
    be modified since queries can''t start with entities that are nested in other
    documents (in our case, `Packages` entities). Therefore, we must start our query
    from the unique root `DbSet<T>` property we have in our `DBContext`, that is,
    `Destinations`. We can move from listing the external collection to listing all
    the internal collections with the help of the `SelectMany` method, which performs
    a logical merge of all nested `Packages` collections. However, since `CosmosDB`
    SQL doesn''t support `SelectMany`, we must force `SelectMany` to be simulated
    on the client with `AsEnumerable()`, as shown in the following code:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，以 `context.Packages.Where...` 开头的最终查询必须进行修改，因为查询不能以嵌套在其他文档中的实体（在我们的情况下是 `Packages`
    实体）开头。因此，我们必须从我们的 `DBContext` 中唯一的根 `DbSet<T>` 属性开始查询，即 `Destinations`。我们可以通过
    `SelectMany` 方法从列出外部集合转到列出所有内部集合，该方法执行所有嵌套 `Packages` 集合的逻辑合并。但是，由于 `CosmosDB`
    SQL 不支持 `SelectMany`，我们必须强制在客户端上模拟 `SelectMany`，如下所示的代码：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The remainder of the query remains unchanged. If you run the project now, you
    should see the same outputs that were received in the case of SQL Server (except
    for the primary key values).
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询的其余部分保持不变。如果现在运行项目，您应该看到与 SQL Server 情况下收到的相同输出（除了主键值）。
- en: After executing the program, go to your Cosmos DB account. You should see something
    like the following:![](img/B16756_09_08.png)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行程序后，转到您的 Cosmos DB 帐户。您应该看到类似以下内容的内容：![](img/B16756_09_08.png)
- en: 'Figure 9.8: Execution results'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8：执行结果
- en: The packages have been nested inside their destinations as required and Entity
    Framework Core creates a unique collection that has the same name as the `DBContext`
    class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求，包已嵌套在其目的地内，并且 Entity Framework Core 创建了一个与 `DBContext` 类同名的唯一集合。
- en: 'If you would like to continue experimenting with Cosmos DB development without
    wasting all your free Azure portal credit, you can install the Cosmos DB emulator
    available at this link: [https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想继续尝试 Cosmos DB 开发而不浪费所有免费的 Azure 门户信用，您可以安装位于以下链接的 Cosmos DB 模拟器：[https://aka.ms/cosmosdb-emulator](https://aka.ms/cosmosdb-emulator)。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at the main storage options available in Azure and
    learned when to use them. Then, we compared relational and NoSQL databases. We
    pointed out that relational databases offer automatic consistency checking and
    transaction isolation, but NoSQL databases are cheaper and offer better performance,
    especially when distributed writes form a high percentage of the average workload.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了Azure中可用的主要存储选项，并学会了何时使用它们。然后，我们比较了关系数据库和NoSQL数据库。我们指出，关系数据库提供自动一致性检查和事务隔离，但NoSQL数据库更便宜，性能更好，特别是在分布式写入占平均工作负载的高比例时。
- en: Then, we described Azure's main NoSQL option, Cosmos DB, and explained how to
    configure it and how to connect with a client.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们描述了Azure的主要NoSQL选项Cosmos DB，并解释了如何配置它以及如何与客户端连接。
- en: Finally, we learned how to interact with Cosmos DB with Entity Framework Core
    and looked at a practical example based on the WWTravelClubDB use case. Here,
    we learned how to decide between relational and NoSQL databases for all families
    of data involved in an application. This way, you can choose the kind of data
    storage that ensures the best compromise between data coherence, speed, and parallel
    access to data in each of your applications.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何使用实体框架核心与Cosmos DB进行交互，并查看了基于WWTravelClubDB用例的实际示例。在这里，我们学习了如何在应用程序中涉及的所有数据族之间决定关系和NoSQL数据库之间的选择。这样，您可以选择确保在每个应用程序中数据一致性、速度和并行访问之间取得最佳折衷的数据存储方式。
- en: In the next chapter, we will learn all about Serverless and Azure Functions.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习有关无服务器和Azure函数的所有内容。
- en: Questions
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is Redis a valid alternative to relational databases?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Redis是否是关系数据库的有效替代品？
- en: Are NoSQL databases a valid alternative to relational databases?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NoSQL数据库是否是关系数据库的有效替代品？
- en: What operation is more difficult to scale out in relational databases?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在关系数据库中，哪种操作更难扩展？
- en: What is the main weakness of NoSQL databases? What is their main advantage?
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NoSQL数据库的主要弱点是什么？它们的主要优势是什么？
- en: Can you list all Cosmos DB consistency levels?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能列出所有Cosmos DB的一致性级别吗？
- en: Can we use auto-increment integer keys with Cosmos DB?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以在Cosmos DB中使用自增整数键吗？
- en: Which Entity Framework configuration method is used to store an entity inside
    its related father document?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种实体框架配置方法用于将实体存储在其相关的父文档中？
- en: Can nested collections be searched efficiently with Cosmos DB?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Cosmos DB中，可以有效地搜索嵌套集合吗？
- en: Further reading
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'In this chapter, we did not talk about how to define sharding with Azure SQL.
    Here is the link to the official documentation if you want to find out more: [https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction).'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们没有讨论如何在Azure SQL中定义分片。如果您想了解更多信息，请访问官方文档链接：[https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction](https://docs.microsoft.com/en-us/azure/sql-database/sql-database-elastic-scale-introduction)。
- en: 'Cosmos DB was described in detail in this chapter, but further details can
    be found in the official documentation: [https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/).'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cosmos DB在本章中有详细描述，但更多细节可以在官方文档中找到：[https://docs.microsoft.com/en-us/azure/cosmos-db/](https://docs.microsoft.com/en-us/azure/cosmos-db/)。
- en: 'The following is a reference to the Gremlin language, which is supported by
    Cosmos DB: [http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps).'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是Gremlin语言的参考，它受Cosmos DB支持：[http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps](http://tinkerpop.apache.org/docs/current/reference/#graph-traversal-steps)。
- en: 'The following is a general description of the Cosmos DB Graph Data Model: [https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是Cosmos DB图形数据模型的一般描述：[https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction](https://docs.microsoft.com/en-us/azure/cosmos-db/graph-introduction)。
- en: Details on how to use Cosmos DB's official .NET client can be found at [https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started).
    A good introduction to the `MvcControlsToolkit.Business.DocumentDB` NuGet package
    we mentioned in this chapter is the *Fast Azure Cosmos DB Development with the
    DocumentDB Package* article contained in Issue 34 of DNCMagazine. This can be
    downloaded from [https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb](https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb).
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关如何使用Cosmos DB的官方.NET客户端的详细信息，请参阅[https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started](https://docs.microsoft.com/en-us/azure/cosmos-db/sql-api-dotnetcore-get-started)。我们在本章中提到的`MvcControlsToolkit.Business.DocumentDB`
    NuGet包的良好介绍是DNCMagazine第34期中包含的*使用DocumentDB包快速进行Azure Cosmos DB开发*文章。可从[https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb](https://www.dotnetcurry.com/microsoft-azure/aspnet-core-cosmos-db-documentdb)下载。
