- en: Personal Trainer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人教练
- en: The *7 Minute Workout* app has been an excellent opportunity for us to learn
    about Angular. Working through the app, we have covered a number of Angular constructs.
    Still, there are areas such as Angular form support and client-server communication
    that remain unexplored. This is partially due to the fact that 7 Minute Workout,
    from a functional standpoint, has limited touch points with the end user. Interactions
    are limited to starting, stopping, and pausing the workout. Also, the app neither
    consumes nor produces any data (except workout history).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 《7分钟锻炼》应用程序是我们学习Angular的绝佳机会。通过这个应用程序，我们已经涵盖了许多Angular构造。然而，仍有一些领域，比如Angular表单支持和客户端-服务器通信，尚未被探索。这部分是因为从功能角度来看，《7分钟锻炼》与最终用户的接触点有限。交互仅限于开始、停止和暂停锻炼。此外，该应用程序既不消耗也不产生任何数据（除了锻炼历史）。
- en: In this chapter, we plan to delve deeper into one of the two aforementioned
    areas, Angular form support. Keeping up with the health and fitness theme (no
    pun intended), we plan to build a *Personal Trainer* app. The new app will be
    an extension to *7 Minute Workout*, allowing us to build our own customized workout
    plans that are not limited to the *7 Minute Workout* plans we already have.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们计划深入研究前面提到的两个领域之一，即Angular表单支持。与健康和健身主题保持一致，我们计划构建一个*个人教练*应用程序。这个新应用程序将是*7分钟锻炼*的扩展，使我们能够构建自己定制的锻炼计划，不再局限于我们已经拥有的*7分钟锻炼*计划。
- en: This chapter is dedicated to understanding Angular forms and how to put them
    to use as we build out our *Personal Trainer* app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于理解Angular表单以及在构建*个人教练*应用程序时如何使用它们。
- en: 'The topics that we will cover in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: '**Defining Personal Trainer requirements**: Since we are building a new app
    in this chapter, we start with defining the app requirements.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练需求**：由于我们在本章构建一个新应用程序，我们从定义应用程序需求开始。'
- en: '**Defining the Personal Trainer model**: Any app design starts with defining
    its model. We define the model for *Personal Trainer*, which is similar to the
    *7 Minute Workout* app built earlier.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练模型**：任何应用程序设计都始于定义其模型。我们为*个人教练*定义模型，这与之前构建的*7分钟锻炼*应用程序类似。'
- en: '**Defining the Personal Trainer layout and navigation**: We define the layout,
    navigation patterns, and views for the new app. We also set up a navigation system
    that is integrated with Angular routes and the main view.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义个人教练布局和导航**：我们为新应用程序定义布局、导航模式和视图。我们还设置了一个与Angular路由和主视图集成的导航系统。'
- en: '**Adding support pages**: Before we focus on the form capability and build
    a Workout component, we build some supporting components for workout and exercise
    listing.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加支持页面**：在专注于表单功能并构建锻炼组件之前，我们为锻炼和锻炼列表构建了一些支持组件。'
- en: '**Defining the Workout Builder component structure**: We lay out the Workout
    Builder components that we will use to manage workouts.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义锻炼构建器组件结构**：我们布置了将用于管理锻炼的锻炼构建器组件。'
- en: '**Building forms**: We make extensive use of HTML forms and input elements
    to create custom workouts. In the process, we will learn more about Angular Forms.
    The concepts that we cover include:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建表单**：我们广泛使用HTML表单和输入元素来创建自定义锻炼。在这个过程中，我们将学习更多关于Angular表单的知识。我们涵盖的概念包括：'
- en: '**Form types**: The two types of form that can be built with Angular are template-driven
    and reactive. We''re working with both template-driven and reactive forms in this
    chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表单类型**：使用Angular可以构建的两种表单类型是模板驱动型和响应式的。在本章中，我们将使用模板驱动型和响应式表单。'
- en: '**ngModel**: This provides two-way data binding for template driven forms and
    allows us to track changes and validate form input.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ngModel**：这为模板驱动的表单提供了双向数据绑定，并允许我们跟踪更改和验证表单输入。'
- en: '**Reactive Form Controls**: These include the form builder, form control, form
    group, and form array. These are used to construct forms programmatically.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应式表单控件**：这些包括表单构建器、表单控件、表单组和表单数组。这些用于以编程方式构建表单。'
- en: '**Data formatting**: These are the CSS classes that permit us to style our
    feedback to the user.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据格式化**：这些是允许我们对用户的反馈进行样式化的CSS类。'
- en: '**Input validation**: We will learn about the validation capabilities of Angular
    forms.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：我们将学习Angular表单的验证能力。'
- en: Personal Trainer requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人健身教练要求
- en: 'Based on the notion of managing workouts and exercises, these are some of the
    requirements that our *Personal Trainer* app should fulfill:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基于管理锻炼和练习的概念，这些是我们的*个人健身教练*应用程序应该满足的一些要求：
- en: The ability to list all available workouts.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出所有可用的锻炼。
- en: 'The ability to create and edit a workout. While creating and editing a workout,
    it should have:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建和编辑锻炼。在创建和编辑锻炼时，它应该具有：
- en: The ability to add workout attributes including name, title, description, and
    rest duration
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够添加包括名称、标题、描述和休息时间在内的锻炼属性
- en: The ability to add/remove multiple exercises for workouts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为锻炼添加/删除多个练习
- en: The ability to order exercises in the workout
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够按照锻炼顺序排列练习
- en: The ability to save workout data
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够保存锻炼数据
- en: The ability to list all available exercises.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出所有可用的练习。
- en: 'The ability to create and edit an exercise. While creating and editing an exercise,
    it should have:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够创建和编辑练习。在创建和编辑练习时，它应该具有：
- en: The ability to add exercise attributes such as name, title, description, and
    procedure
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够添加练习属性，如名称、标题、描述和步骤
- en: The ability to add pictures for the exercise
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为练习添加图片
- en: The ability to add related videos for the exercise
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为练习添加相关视频
- en: The ability to add audio clues for the exercise
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够为练习添加音频提示
- en: All the requirements seem to be self-explanatory, so let's start with the design
    of the application. As customary, we first need to think about the model that
    can support these requirements.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的要求似乎都很明显，所以让我们从应用程序的设计开始。按照惯例，我们首先需要考虑能够支持这些要求的模型。
- en: Getting started with the code for Personal Trainer
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用个人健身教练的代码
- en: First, download the base version of the new *Personal Trainer* app from `checkpoint4.1`
    in the GitHub repository for the book.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从书籍的GitHub存储库中的`checkpoint4.1`下载新的*个人健身教练*应用的基本版本。
- en: 'The code is available on GitHub [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)
    for everyone to download. Checkpoints are implemented as branches in GitHub. The
    branch to download is as follows: `GitHub Branch: checkpoint4.1`. If you are not
    using Git, download the snapshot of Checkpoint 4.1 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上找到[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)，供所有人下载。检查点在GitHub中作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.1`。如果您不使用Git，请从以下GitHub位置下载Checkpoint
    4.1的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.1.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: 'This code has the complete *7 Minute Workout (Workout Runner)* app. We have
    added some more content to support the new *Personal Trainer* app. Some of the
    relevant updates are:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码包含了完整的*7分钟锻炼（Workout Runner）*应用程序。我们已经添加了一些内容来支持新的*个人健身教练*应用程序。一些相关的更新包括：
- en: Adding the new `WorkoutBuilder` feature. This feature contains implementations
    pertaining to *Personal Trainer*.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新的`WorkoutBuilder`功能。这个功能包含与*个人健身教练*相关的实现。
- en: Updating the layout and styles of the app.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新应用程序的布局和样式。
- en: Adding some components and HTML templates with placeholder content for *Personal
    Trainer* in the `workout-builder` folder under `trainer/src/app`.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`trainer/src/app`文件夹下的`workout-builder`文件夹中添加一些组件和带有*个人健身教练*占位内容的HTML模板。
- en: Defining a new route to the `WorkoutBuilder` feature. We will cover setting
    up this route within the app in the coming section.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个新的路由到`WorkoutBuilder`功能。我们将在接下来的部分中介绍如何在应用程序中设置这个路由。
- en: As we just mentioned, moving the existing  `model.ts` file into the `core` folder.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，将现有的`model.ts`文件移动到`core`文件夹中。
- en: Let's discuss how we will be using the model.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下我们将如何使用这个模型。
- en: Using the Personal Trainer model in Workout Builder services
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Workout Builder服务中使用个人健身教练模型。
- en: Services are useful for sharing data across controllers and other Angular constructs.
    Open the `model.ts` file present in the `core` folder under `app`. In this class,
    we essentially do not have any data, but a blueprint that describes the shape
    of the data. The plan is to use services to expose this model structure.  We have
    already done that in Workout Runner. Now, we will do the same in Workout Builder.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 服务对于在控制器和其他Angular构造之间共享数据非常有用。打开`app`文件夹下`core`文件夹中的`model.ts`文件。在这个类中，我们基本上没有任何数据，而是描述数据形状的蓝图。计划是使用服务来公开这个模型结构。我们已经在Workout
    Runner中做过了。现在，我们将在Workout Builder中做同样的事情。
- en: 'The `model.ts` file has been moved into the `core` folder as it is shared across
    the *Workout Builder* and *Workout Runner* apps. Note: in `checkpoint4.1` we have
    updated the import statements in `workout-runner.component.ts` , `workout-audio.component.ts`, and `workout-history-tracker-service.ts` to
    reflect this change.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`model.ts`文件已经移动到`core`文件夹中，因为它在*Workout Builder*和*Workout Runner*应用程序之间共享。注意：在`checkpoint4.1`中，我们已经更新了`workout-runner.component.ts`，`workout-audio.component.ts`和`workout-history-tracker-service.ts`中的导入语句以反映这一变化。'
- en: In [Chapter 1](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml), *Building Our First
    App - 7 Minute Workout*, we reviewed the class definitions in the model file: `Exercise`,
    `ExercisePlan`, and `WorkoutPlan`**.** As we then mentioned, these three classes
    constitute our base model. We will now start using this base model in our new
    app.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](8eb47c1f-58fe-45dd-9afe-b955ef2080be.xhtml)中，*构建我们的第一个应用程序-7分钟锻炼*，我们回顾了模型文件中的类定义：`Exercise`，`ExercisePlan`和`WorkoutPlan`。正如我们之前提到的，这三个类构成了我们的基本模型。现在我们将开始在我们的新应用程序中使用这个基本模型。
- en: That's all on the model design front. The next thing we are going to do is define
    the structure for the new app.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于模型设计的全部内容。接下来我们要做的是定义新应用程序的结构。
- en: The Personal Trainer layout
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 个人健身教练布局
- en: 'The skeleton structure of *Personal Trainer* looks like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*个人健身教练*的骨架结构如下：'
- en: '![](Images/38aaf003-6900-4429-8954-72093475d5d3.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/38aaf003-6900-4429-8954-72093475d5d3.png)'
- en: 'This has the following components:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括以下组件：
- en: 'Top Nav: This contains the app branding title and history link.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶部导航：这包含应用品牌标题和历史链接。
- en: 'Sub Nav: This has navigation elements that change based on the active component.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子导航：这包含根据活动组件而变化的导航元素。
- en: 'Left Nav: This contains elements that are dependent upon the active component.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧导航：这包含依赖于活动组件的元素。
- en: 'Content Area: This is where the main view for our component will display. This
    is where most of the action happens. We will create/edit exercises and workouts
    and show a list of exercises and workouts here.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容区域：这是我们组件的主视图显示的地方。这里发生了大部分的操作。我们将在这里创建/编辑练习和训练，并显示这里的练习和训练列表。
- en: Look at the source code files; there is a new folder `workout-builder` under
    `trainer/src/app`. It has files for each component that we described previously,
    with some placeholder content. We will be building these components as we go along
    in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看源代码文件；在`trainer/src/app`下有一个新的`workout-builder`文件夹。它包含了我们之前描述的每个组件的文件，其中包含一些占位内容。在本章中，我们将逐步构建这些组件。
- en: However, we first need to link up these components within the app. This requires
    us to define the navigation patterns for the Workout Builder app and accordingly
    define the app routes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们首先需要在应用程序中链接这些组件。这要求我们为训练构建器应用程序定义导航模式，并相应地定义应用程序路由。
- en: Personal Trainer navigation with routes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路由的个人教练导航
- en: 'The navigation pattern that we plan to use for the app is the list-detail pattern.
    We will create list pages for the exercises and workouts available in the app.
    Clicking on any list item takes us to the detailed view for the item where we
    can perform all CRUD operations (create/read/update/delete). The following routes
    adhere to this pattern:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划在应用程序中使用的导航模式是列表-详细信息模式。我们将为应用程序中可用的练习和训练创建列表页面。单击任何列表项将带我们到该项的详细视图，在那里我们可以执行所有CRUD操作（创建/读取/更新/删除）。以下路由符合此模式：
- en: '| **Route** | **Description** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **路由** | **描述** |'
- en: '| `/builder` | This just redirects to **builder/workouts** |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `/builder` | 这只是重定向到**builder/workouts** |'
- en: '| `/builder/workouts` | This lists all the available workouts. It is the landing
    page for *Workout Builder* |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workouts` | 这列出了所有可用的训练。这是*训练构建器*的登陆页面 |'
- en: '| `/builder/workout/new` | This creates a new workout |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/new` | 这将创建一个新的训练 |'
- en: '| `/builder/workout/:id` | This edits an existing workout with the specific
    ID |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/workout/:id` | 这将编辑具有特定ID的现有训练 |'
- en: '| `/builder/exercises` | This lists all the available exercises |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercises` | 这列出了所有可用的练习 |'
- en: '| `/builder/exercise/new` | This creates a new exercise |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/new` | 这将创建一个新的练习 |'
- en: '| `/builder/exercise/:id` | This edits an existing exercise with the specific
    ID |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `/builder/exercise/:id` | 这将编辑具有特定ID的现有练习 |'
- en: Getting started with Personal Trainer navigation
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用个人教练导航
- en: At this point, if you look at the route configuration in `app-routing.module.ts`
    in the `src/app` folder, you will find one new route definition, `builder`**:**
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您查看`src/app`文件夹中的`app-routing.module.ts`中的路由配置，您将找到一个新的路由定义，`builder`**：**
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And if you run the application, you will see that the start screen shows another
    link, Create a Workout:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行应用程序，您将看到开始屏幕显示另一个链接，创建一个训练：
- en: '![](Images/91aeb5b5-d0e6-4423-b679-0dd4c8b1d79f.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/91aeb5b5-d0e6-4423-b679-0dd4c8b1d79f.png)'
- en: 'Behind the scenes, we have added another router link for this link into `start.component.html`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，我们已经为`start.component.html`中的此链接添加了另一个路由链接：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And if you click on this link, you will be taken to the following view:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击此链接，将会进入以下视图：
- en: '![](Images/c4bb197b-3abd-4895-be6c-ced456c6b230.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c4bb197b-3abd-4895-be6c-ced456c6b230.png)'
- en: 'Again, behind the scenes we have added  `workout-builder.component.ts` to the
    `trainer/src/app/workout-builder` folder with the following inline template:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在幕后，我们已经在`trainer/src/app/workout-builder`文件夹中添加了`workout-builder.component.ts`，其中包含以下内联模板：
- en: '[PRE2]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this view is displayed on the screen under the header using the router
    outlet in our `app.component.html` template:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个视图显示在屏幕上的标题下，使用我们的`app.component.html`模板中的路由出口：
- en: '[PRE3]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have wrapped this component (along with the other files we have stubbed out
    for this feature) in a new module named `workout-builder.module.ts:`
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个组件（以及我们为这个功能创建的其他文件）封装在一个名为`workout-builder.module.ts`的新模块中：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only thing that might look different here from the other modules that we
    have created is that we are importing `CommonModule` instead of `BrowserModule`.
    This avoids importing the whole of `BrowserModule` a second time, which would
    generate an error when we get to implementing lazy loading for this module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可能与我们创建的其他模块不同的是，我们导入的是`CommonModule`而不是`BrowserModule`。这样可以避免第二次导入整个`BrowserModule`，这在我们实现此模块的惰性加载时会产生错误。
- en: 'Finally, we have added an import for this module to `app.module.ts`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经在`app.module.ts`中为这个模块添加了一个导入：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, nothing surprising here. Following these patterns, we should now begin to
    think about adding the additional navigation outlined previously for our new feature.
    However, before we jump into doing that, there are a couple of things we need
    to consider.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这并不奇怪。遵循这些模式，我们现在应该开始考虑为我们的新功能添加先前概述的额外导航。然而，在我们开始做这件事之前，有一些事情我们需要考虑。
- en: First, if we start adding our routes to the `app.routing-module.ts` file, then
    the number of routes stored there will grow. These new routes for *Workout Builder*
    will also be intermixed with the routes for *Workout Runner***.** While the number
    of routes we are now adding might seem insignificant, over time this could get
    to be a maintenance problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们开始将路由添加到`app.routing-module.ts`文件中，那么存储在那里的路由数量将增加。*Workout Builder*的这些新路由也将与*Workout
    Runner*的路由混合在一起。虽然我们现在添加的路由数量可能看起来微不足道，但随着时间的推移，这可能会成为一个维护问题。
- en: Second, we need to take into consideration that our application now consists
    of two features—*Workout Runner* and *Workout Builder*. We should be thinking
    about ways to separate these features within our application so that they can
    be developed independently of each other.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们需要考虑到我们的应用现在包括两个功能——*Workout Runner*和*Workout Builder*。我们应该考虑如何在应用程序中分离这些功能，以便它们可以独立开发。
- en: Put differently, we want **loose coupling** between the features that we build.
    Using this pattern allows us to swap out a feature within our application without
    affecting the other features. For example, somewhere down the line, we may want
    to convert the *Workout Runner* into a mobile app but leave the *Workout Builder*
    intact as a web-based application.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望我们构建的功能之间**松散耦合**。使用这种模式可以让我们在不影响其他功能的情况下替换应用程序中的功能。例如，迟早我们可能想将*Workout
    Runner*转换为移动应用程序，但保持*Workout Builder*作为基于Web的应用程序不变。
- en: This ability to separate our components from each other is one of the key advantages
    of using the **component design pattern** that Angular implements. Fortunately,
    Angular's router gives us the ability to separate out our routing into logically
    organized **routing configurations** that closely match the features in our application.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将组件彼此分离的能力是Angular实现的**组件设计模式**的关键优势之一。幸运的是，Angular的路由器使我们能够将我们的路由分离成逻辑上组织良好的**路由配置**，这与我们应用程序中的功能密切匹配。
- en: In order to accomplish this separation, Angular allows us to use **child routing**,
    where we can isolate the routing for each of our features. In this chapter, we
    will use **child routing** to separate out the routing for *Workout Builder*.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种分离，Angular允许我们使用**子路由**，在这里我们可以隔离每个功能的路由。在本章中，我们将使用**子路由**来分离*Workout
    Builder*的路由。
- en: Introducing child routes to Workout Builder
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Workout Builder的子路由
- en: Angular supports our goal of isolating the routing for our new *Workout Builder*
    by providing us with the ability to create a hierarchy of router components within
    our application. We currently have just one router component, which is in the
    root component of our application. But Angular allows us to add what are called
    **child router components** under our root component. This means that one feature
    can be ignorant of the routes the other is using and each is free to adapt its routes
    in response to changes within that feature.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持我们通过在应用程序中创建路由器组件的层次结构来隔离新的*Workout Builder*的路由的目标。我们目前只有一个路由器组件，它位于我们应用程序的根组件中。但是Angular允许我们在根组件下添加所谓的**子路由器组件**。这意味着一个功能可以忽略另一个功能使用的路由，并且每个功能都可以自由地根据该功能内部的更改来调整其路由。
- en: 'Getting back to our application, we can use **child routing** in Angular to
    match the routing for the two features of our application with the code that will
    be using them. So in our application, we can structure the routing into the following
    routing hierarchy for our *Workout Builder* (at this point, we are leaving the
    *Workout Runner* as is to show the before and after comparison):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的应用程序，我们可以使用Angular中的**子路由**来匹配我们应用程序的两个功能的路由与将使用它们的代码。因此，在我们的应用程序中，我们可以将路由结构化为以下路由层次结构，用于我们的*Workout
    Builder*（在这一点上，我们将*Workout Runner*保持不变，以显示之前和之后的比较）：
- en: '![](Images/f4b8f0b2-c5a8-41fc-b7ad-a0b0606092b2.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f4b8f0b2-c5a8-41fc-b7ad-a0b0606092b2.png)'
- en: With this approach, we can create a logical separation of our routes by feature
    and make them easier to manage and maintain.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方法，我们可以通过功能创建路由的逻辑分离，并使其更易于管理和维护。
- en: So, let's get started by adding child routing to our application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始为我们的应用程序添加子路由。
- en: 'From this point on in this section, we''ll be adding to the code that we downloaded
    earlier for this chapter. If you want to see the complete code for this next section,
    you can download it from `checkpoint 4.2` in the GitHub repository. If you want
    to work along with us as we build out the code for this section, still be sure
    to add the changes in `styles.css` in the `trainer/src` folder that are part of
    this checkpoint, since we won''t be discussing them here. Also be sure and add
    the files for exercise(s) ,workout(s), and navigation from the `trainer/src/app/workout-builder`
    folder in the repository. At this stage, these are just stub files, which we will
    implement later in this chapter. However, you will need these stub files here
    in order to implement navigation for the *Workout Builder* module. The code is
    available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.2` . If you are not using Git, download the
    snapshot of `Checkpoint 4.2` (a ZIP file) from the following GitHub location:
    [https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节开始，我们将继续添加本章前面下载的代码。如果你想查看本节完整的代码，可以从GitHub存储库的`checkpoint 4.2`中下载。如果你想和我们一起构建本节的代码，请确保添加`styles.css`中的更改，因为我们不会在这里讨论它们。还要确保从存储库的`trainer/src/app/workout-builder`文件夹中添加exercise(s)、workout(s)和navigation的文件。在这个阶段，这些只是存根文件，我们将在本章后面实现它们。然而，你需要这些存根文件来实现*Workout
    Builder*模块的导航。该代码可在GitHub上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.2`。如果你不使用Git，请从以下GitHub位置下载`Checkpoint
    4.2`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.2.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Adding the child routing component
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加子路由组件
- en: 'In the `workout-builder` directory, add a new TypeScript file named `workout-builder.routing.module.ts`
    with the following imports:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在`workout-builder`目录中，添加一个名为`workout-builder.routing.module.ts`的新的TypeScript文件，其中包含以下导入内容：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we are importing the components we just mentioned; they will
    be part of our *Workout Builder* (exercise, exercises, workout, and workouts).
    Along with those imports, we are also importing `NgModule` from the Angular core
    module and `Routes` and `RouterModule` from the Angular router module. These imports
    will give us the ability to add and export child routes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在导入我们刚刚提到的组件；它们将成为我们*Workout Builder*（exercise, exercises, workout,
    and workouts）的一部分。除了这些导入之外，我们还从Angular核心模块中导入`NgModule`，从Angular路由器模块中导入`Routes`和`RouterModule`。这些导入将使我们能够添加和导出子路由。
- en: We are not using the Angular CLI here because it does not have a standalone
    blueprint for creating a routing module. However, you can have the CLI create
    a routing module at the time that you create a module using the `--routing` option.
    In this case, we already had an existing module created so we couldn't use that
    flag. See [https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)
    for more details about how to do this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有使用Angular CLI，因为它没有一个独立的蓝图来创建路由模块。但是，您可以在使用`--routing`选项创建模块时，让CLI创建一个路由模块。在这种情况下，我们已经创建了一个现有的模块，所以我们不能使用该标志。有关如何执行此操作的更多详细信息，请参见[https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md](https://github.com/angular/angular-cli/blob/master/docs/documentation/stories/routing.md)。
- en: 'Then, add the following route configuration to the file:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在文件中添加以下路由配置：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first configuration, `path: ''builder''`, sets the base URL for the child
    routes so that each of the child routes prepends it. The next configuration identifies
    the `WorkoutBuilder` component as the feature area root component for the child
    components in this file. This means it will be the component in which each of
    the child components is displayed using `router-outlet`. The final configuration
    is a list of one or more children that defines the routing for the child components.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个配置，`path: ''builder''`，设置了子路由的基本URL，以便每个子路由都会在其前面添加它。接下来的配置将`WorkoutBuilder`组件标识为此文件中子组件的功能区根组件。这意味着它将是使用`router-outlet`显示每个子组件的组件。最后的配置是一个或多个子组件的路由定义。'
- en: 'One thing to note here is that we have set up `Workouts` as the default for
    the child routes with the following configuration:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一件事是，我们已经将`Workouts`设置为子路由的默认值，具体配置如下：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This configuration indicates that if someone navigates to `builder`, they will
    be redirected to the `builder/workouts` route. The `pathMatch: ''full''` setting
    means that the match will only be made if the path after workout/builder is an
    empty string. This prevents the redirection from happening if the routes are something
    else, such as `workout/builder/exercises` or any of the other routes we have configured
    within this file.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '这个配置表示，如果有人导航到`builder`，他们将被重定向到`builder/workouts`路由。`pathMatch: ''full''`设置意味着只有在workout/builder后的路径为空字符串时才会进行匹配。这可以防止在路由为其他内容时进行重定向，比如`workout/builder/exercises`或者我们在这个文件中配置的其他路由。'
- en: 'Finally, add the following class declaration preceded by an `@NgModule` decorator
    that defines imports and exports for our module:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加以下类声明，前面有一个`@NgModule`装饰器，用于定义我们模块的导入和导出：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This import is very similar to the one in `app.routing-module.ts`, with one
    difference - instead of `RouterModule.forRoot`, we are using `RouterModule.forChild`.
    The reason for the difference may seem self-explanatory: we are creating child
    routes, not the routes in the root of the application, and this is how we signify
    that. Under the hood, however, there is a significant difference. This is because
    we cannot have more than one router service active in our application. `forRoot`
    creates the router service but `forChild` does not.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个导入与`app.routing-module.ts`中的导入非常相似，只有一个区别 - 我们使用的是`RouterModule.forChild`，而不是`RouterModule.forRoot`。这种差异的原因似乎很容易理解：我们正在创建子路由，而不是应用程序根目录中的路由，这就是我们如何表示的。然而，在底层，有一个重大的区别。这是因为我们的应用程序中不能有多个路由器服务处于活动状态。`forRoot`创建路由器服务，但`forChild`不会。
- en: Updating the WorkoutBuilder component
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新WorkoutBuilder组件
- en: 'We next need to update the `WorkoutBuilder` component to support our new child
    routes. To do so, change the `@Component` decorator for Workout Builder to:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新`WorkoutBuilder`组件以支持我们的新子路由。为此，将`Workout Builder`的`@Component`装饰器更改为：
- en: Remove the `selector`
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`selector`
- en: Add a `<abe-sub-nav-main>` custom element to the template
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<abe-sub-nav-main>`自定义元素
- en: Add a `<router-outlet>` tag to the template
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中添加一个`<router-outlet>`标签
- en: 'The decorator should now look like the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器现在应该如下所示：
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We are removing the selector because `WorkoutBuilderComponent` will not be embedded
    in the application root, `app.component.ts`. Instead, it will be reached from
    `app.routing-module.ts` through routing. And while it will handle incoming routing
    requests from `app.routes.ts`, it will, in turn, be routing them to the other
    components contained in the Workout Builder feature.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在删除选择器，因为`WorkoutBuilderComponent`将不会嵌入在应用程序根`app.component.ts`中。相反，它将通过路由从`app.routing-module.ts`中到达。虽然它将处理来自`app.routes.ts`的传入路由请求，但它将把它们路由到Workout
    Builder功能中包含的其他组件。
- en: And those components will display their views using the `<router-outlet>` tag
    that we have just added to the `WorkoutBuilder` template. Given that the template
    for `Workout BuilderComponent` will be simple, we are using an inline `template`
    instead of a `templateUrl`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件将使用我们刚刚添加到`WorkoutBuilder`模板中的`<router-outlet>`标签来显示它们的视图。鉴于`Workout BuilderComponent`的模板将是简单的，我们使用内联`template`而不是`templateUrl`。
- en: Typically, for a component's view we recommend using a `templateUrl` that points
    to a separate HTML template file. This is especially true when you anticipate
    that the view will involve more than a few lines of HTML. In that situation, it
    is much easier to work with a view inside its own HTML file.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对于组件的视图，我们建议使用指向单独HTML模板文件的`templateUrl`。当您预期视图将涉及超过几行HTML时，尤其如此。在这种情况下，更容易使用单独的HTML文件中的视图。
- en: We are also adding an `<abe-sub-nav-main>` element that will be used to create
    a secondary top-level menu for navigating within the *Workout Builder* feature.
    We'll discuss that a little later in this chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了一个`<abe-sub-nav-main>`元素，用于创建*Workout Builder*功能内部的次级顶级菜单。我们将在本章稍后讨论这一点。
- en: Updating the Workout Builder module
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新Workout Builder模块
- en: 'Now, let''s update `WorkoutBuilderModule`.  First, add the following import
    to the file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新`WorkoutBuilderModule`。首先，将以下导入添加到文件中：
- en: '[PRE11]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It imports the child routing that we just set up. Next, update the `@NgModule`
    decorator to add `workoutBuilderRoutingModule`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 它导入了我们刚刚设置的子路由。接下来，更新`@NgModule`装饰器以添加`workoutBuilderRoutingModule`：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, add the imports and declarations for the new navigation components
    that can be found in `checkpoint4.2`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加可以在`checkpoint4.2`中找到的新导航组件的导入和声明：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Updating App Routing module
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新App路由模块
- en: 'One last step: return to `app.routing-module.ts` and remove the import of the
    `WorkoutBuilderComponent` and the route definition that points to the builder:`{
    path: ''builder'', component: WorkoutBuilderComponent },`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '最后一步：返回到`app.routing-module.ts`并删除`WorkoutBuilderComponent`的导入和指向构建器的路由定义：`{
    path: ''builder'', component: WorkoutBuilderComponent },`。'
- en: Be sure to leave the import of the `WorkoutBuilderModule`  in `app.module.ts`
    unchanged. We'll discuss removing that in the next section when we cover lazy
    loading.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`app.module.ts`中保持`WorkoutBuilderModule`的导入不变。当我们讨论延迟加载时，我们将在下一节中讨论删除它。
- en: Putting it all together
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: We now have area or feature routing that contains child routes, and all the
    routes related to the *Workout Builder* are now separately contained in their
    own routing configuration. This means that we can manage all the routing for *Workout
    Builder* in the `WorkoutBuilderRoutes` component without affecting other parts
    of the application.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了包含子路由的区域或功能路由，与*Workout Builder*相关的所有路由现在都分别包含在它们自己的路由配置中。这意味着我们可以在`WorkoutBuilderRoutes`组件中管理*Workout
    Builder*的所有路由，而不会影响应用程序的其他部分。
- en: 'We can see how the router combines the routes in `app.routes.ts` with the default
    route in `workout-builder.routes.ts`, if we now navigate from the start page to
    the Workout Builder:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在从起始页面导航到Workout Builder，我们可以看到路由器如何将`app.routes.ts`中的路由与`workout-builder.routes.ts`中的默认路由组合起来：
- en: '![](Images/879d478e-200d-4a7f-9f42-46cda87c2735.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/879d478e-200d-4a7f-9f42-46cda87c2735.png)'
- en: If we look at the URL in the browser, it is `/builder/workouts`. You'll recall
    that the router link on the start page is `['/builder']`. So how did the router
    take us to this location?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下浏览器中的URL，它是`/builder/workouts`。您会记得起始页面上的路由链接是`['/builder']`。那么路由器是如何将我们带到这个位置的呢？
- en: 'It does it this way: when the link is clicked, the Angular router first looks
    to `app-routing.module.ts` for the `builder` path because that file contains the
    configuration for the root routes in our application. The router does not find
    that path because we have removed it from the routes in that file.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 它是这样做的：当链接被点击时，Angular路由器首先查找`app-routing.module.ts`中的`builder`路径，因为该文件包含了我们应用程序的根路由的配置。路由器没有找到该路径，因为我们已经从该文件的路由中删除了它。
- en: However, `WorkoutBuilderModule` has been imported into our `AppModule` and that
    module in turn imports `workoutBuilderRoutingModule`. The latter file contains
    the child routes that we just configured. The router finds that `builder` is the
    parent route in that file and so it uses that route. It also finds the default
    setting that redirects to the child path `workouts` in the event that the `builder`
    path ends with an empty string, which it does in this case.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`WorkoutBuilderModule`已经被导入到我们的`AppModule`中，而该模块又导入了`workoutBuilderRoutingModule`。后者文件包含了我们刚刚配置的子路由。路由器发现`builder`是该文件中的父路由，因此使用了该路由。它还找到了默认设置，即在`builder`路径以空字符串结尾时重定向到子路径`workouts`的设置，而在这种情况下确实是这样。
- en: If you look at the screen, you will see it is displaying the view for `Workouts`
    (and not as previously *Workout Builder*). This means that the router has successfully
    routed the request to `WorkoutsComponent`, which is the component for the default
    route in the child route configuration that we set up in `workoutBuilderRoutingModule`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看屏幕，您会发现它显示的是`Workouts`的视图（而不是之前的*Workout Builder*）。这意味着路由器已成功将请求路由到了`WorkoutsComponent`，这是我们在`workoutBuilderRoutingModule`中设置的子路由配置的默认路由的组件。
- en: 'This process of route resolution is illustrated here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 路由解析的这个过程在这里说明：
- en: '![](Images/a8a361ee-a043-4814-893c-6eb4cb067fc0.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a8a361ee-a043-4814-893c-6eb4cb067fc0.png)'
- en: One final thought on child routing. When you look at our child routing component, `workout-builder.component.ts`,
    you will see that it has no references to its parent component, `app.component.ts`
    (the `<selector>` tag has been removed, so  `WorkoutBuilderComponent`  is not
    being embedded in the root component). This means that we have successfully encapsulated
    `WorkoutBuilderComponent` (and all of its related components that are imported
    in the `WorkoutBuilderModule`) in a way that will allow us to move all of it elsewhere
    in the application, or even into a new application.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关于子路由的最后一点想法。当您查看我们的子路由组件`workout-builder.component.ts`时，您会发现它没有引用其父组件`app.component.ts`（`<selector>`标签已被移除，因此`WorkoutBuilderComponent`未嵌入到根组件中）。这意味着我们已成功封装了`WorkoutBuilderComponent`（以及在`WorkoutBuilderModule`中导入的所有相关组件），这将使我们能够将其全部移动到应用程序的其他位置，甚至是一个新的应用程序中。
- en: Now, it's time for us to move on to converting our routing for the Workout Builder
    to use lazy loading and building out its navigation menus. If you want to see
    the completed code for this next section, you can download it from the companion
    codebase in `checkpoint 4.3`. Again, if you are working along with us as we build
    the application, be sure and update the `styles.css` file, which we are not discussing
    here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候开始将我们的路由转换为懒加载，并构建其导航菜单了。如果您想查看下一节的完整代码，可以从`checkpoint 4.3`的伴随代码库中下载。再次强调，如果您正在与我们一起构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。
- en: 'The code is also available on GitHub: [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.3` (folder - `trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.3` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可在GitHub上找到：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.3`（文件夹
    - `trainer`）。如果您不使用Git，请从以下GitHub位置下载`Checkpoint 4.3`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.3.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。
- en: Lazy loading of routes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由的懒加载
- en: When we roll out our application, we expect that our users will be accessing
    the Workout Runner every day (and we know that this will be the case for you!).
    But, we anticipate that they will only occasionally be using the Workout Builder
    to construct their exercises and workout plans. It would, therefore, be nice if
    we could avoid the overhead of loading the Workout Builder when our users are
    just doing their exercises in the Workout Runner. Instead, we would prefer to
    load Workout Builder only on demand when a user wants to add to or update their
    exercises and workout plans. This approach is called **lazy loading**. Lazy loading
    allows us to employ an asynchronous approach when loading our modules. This means
    that we can load just what is required to get the application started and then
    load other modules as we need them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们推出我们的应用程序时，我们期望我们的用户每天都会访问Workout Runner（我们知道这对你来说也是如此！）。但是，我们预计他们只偶尔会使用Workout
    Builder来构建他们的练习和锻炼计划。因此，如果我们的用户只是在Workout Runner中做练习，我们最好能够避免加载Workout Builder的开销。相反，我们希望只在用户想要添加或更新他们的练习和锻炼计划时按需加载Workout
    Builder。这种方法称为**延迟加载**。延迟加载允许我们在加载模块时采用异步方法。这意味着我们可以只加载启动应用程序所需的内容，然后根据需要加载其他模块。
- en: Under the hood, when we use the Angular CLI to build and serve our application,
    it uses WebPack's bundling and chunking capabilities to accomplish lazy loading.
    We'll be discussing these capabilities as we work through how to implement lazy
    loading in our application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，当我们使用Angular CLI构建和提供我们的应用程序时，它使用Webpack的捆绑和分块功能来实现延迟加载。当我们在应用程序中实现延迟加载时，我们将讨论这些功能。
- en: So in our *Personal Trainer*, we want to change the application so that it only
    loads the **Workout Builder** on demand. And the Angular router allows us to do
    just that using lazy loading.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的*Personal Trainer*中，我们希望更改应用程序，以便只在需要时加载**Workout Builder**。Angular路由器允许我们使用延迟加载来实现这一点。
- en: 'But before we get started implementing lazy loading, let''s take a look at
    our current application and how it is loading our modules. With the developer
    tools open in the Sources tab, start up the application; when the start page appears
    in your browser, if you look under the webpack node in the source tree, you will
    see that all the files in the application have loaded, including both the *Workout
    Runner* and *Workout Builder* files:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但在开始实现延迟加载之前，让我们看看我们当前的应用程序以及它如何加载我们的模块。在“Sources”选项卡中打开开发者工具，启动应用程序；当启动页面出现在您的浏览器中时，如果您在源树中的webpack节点下查看，您将看到应用程序中加载了所有文件，包括*Workout
    Runner*和*Workout Builder*文件：
- en: '![](Images/a3d91ddd-3613-4e72-af09-10f7c84551a8.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a3d91ddd-3613-4e72-af09-10f7c84551a8.png)'
- en: So, even though we may just want to use the *Workout Runner*, we have to load
    the *Workout Builder* as well. In a way, this makes sense if you think of our
    application as a **Single Page Application** (**SPA**). In order to avoid round
    trips to the server, an SPA will typically load all the resources that will be
    needed to use the application when it is first started up by a user. But in our
    case, the important point is that we do not need the *Workout Builder* when the
    application is first loaded. Instead, we would like to load those resources only
    when the user decides that they want to add or change a workout or exercise.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使我们可能只想使用*Workout Runner*，我们也必须加载*Workout Builder*。从某种意义上讲，如果你把我们的应用程序看作是一个**单页应用程序**（**SPA**），这是有道理的。为了避免与服务器的往返，SPA通常会在用户首次启动应用程序时加载所有将需要的资源。但在我们的情况下，重要的一点是，当应用程序首次加载时，我们不需要*Workout
    Builder*。相反，我们希望只在用户决定要添加或更改锻炼或练习时才加载这些资源。
- en: So, let's get started with making that happen.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始让这种情况发生。
- en: 'First, modify `app.routing-module.ts` to add the following route configuration
    for `WorkoutBuilderModule`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`app.routing-module.ts`，添加以下`WorkoutBuilderModule`的路由配置：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Notice that the `loadChildren` property is:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`loadChildren`属性是：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This configuration provides the information that will be needed to load and
    instantiate `WorkoutBuilderModule`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置提供了加载和实例化`WorkoutBuilderModule`所需的信息。
- en: 'Next go back to `workout-builder-routing.module.ts` and change the `path` property
    to an empty string:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来回到`workout-builder-routing.module.ts`，将`path`属性更改为空字符串：
- en: '[PRE16]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We are making this change because we are now setting the path (`builder`) to
    the `WorkoutBuilderRoutes` in the new configuration for them that we added in
    `app.routing-module.ts`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进行这个更改是因为我们现在正在将路径（`builder`）设置为`app.routing-module.ts`中添加的它们的新配置中的`WorkoutBuilderRoutes`。
- en: Finally go back to `app-module.ts`  and remove the `WorkoutBuilderModule` import
    in the `@NgModule` configuration in that file. What this means is that instead
    of loading the **Workout Builder** feature when the application first starts,
    we only load it when a user accesses the route to *Workout Builder*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后回到`app-module.ts`，在该文件的`@NgModule`配置中移除`WorkoutBuilderModule`的导入。这意味着我们不是在应用程序启动时加载**Workout
    Builder**功能，而是在用户访问*Workout Builder*路由时才加载它。
- en: 'Let''s go build and run the application again using `ng serve`. In the Terminal
    window, you should see something like the following output:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次使用`ng serve`构建和运行应用程序。在终端窗口中，你应该看到类似以下的输出：
- en: '![](Images/4ac5d80c-d801-4ec7-acdf-5b4e30f5174e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/4ac5d80c-d801-4ec7-acdf-5b4e30f5174e.png)'
- en: What's interesting here is the last line that shows a separate file for the
    `workout.builder.module` called `workout-builder.module.chunk.js.`. **WebPack**
    has used what is called code splitting to carve out our workout builder module
    into a separate chunk. This chunk will not be loaded in our application until
    it is needed (that is when the router navigates to `WorkoutBuilderModule`).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是最后一行显示了一个名为`workout.builder.module`的单独文件，名为`workout-builder.module.chunk.js`。**WebPack**使用了所谓的代码拆分，将我们的锻炼构建器模块划分为一个单独的块。直到需要时（即路由器导航到`WorkoutBuilderModule`时），这个块才会在我们的应用程序中加载。
- en: 'Now, keeping the Sources tab open in the Chrome developer tools bring up the
    application in the browser again. When the start page loads, only the files related
    to the *Workout Runner* appear and not those related to the *Workout Builder*,
    as shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，保持Chrome开发者工具中的Sources标签页打开，再次在浏览器中打开应用程序。当起始页面加载时，只有与*Workout Runner*相关的文件出现，而与*Workout
    Builder*相关的文件没有出现，如下所示：
- en: '![](Images/be994372-be5b-4fb3-bfcc-1aa0a96f2ded.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/be994372-be5b-4fb3-bfcc-1aa0a96f2ded.png)'
- en: 'Then, if we clear the Network tab and click on the Create a Workout link, we''ll
    see the `workout-builder.module` chunk load:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们清空网络标签页并点击“创建锻炼”链接，我们将看到`workout-builder.module`块加载：
- en: '![](Images/adfb8093-199e-4ef7-8afa-984364ffeeec.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/adfb8093-199e-4ef7-8afa-984364ffeeec.png)'
- en: This means that we have achieved encapsulation of our new feature and with asynchronous
    routing we are able to use lazy loading to load all its components only when needed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们已经实现了新功能的封装，并且通过异步路由，我们能够使用惰性加载，只在需要时加载所有组件。
- en: Child and asynchronous routing make it straightforward to implement applications
    that allow us to have our cake and eat it too. On one hand, we can build SPAs
    with powerful client-side navigation, while on the other hand we can also encapsulate
    features in separate child routing components and load them only on demand.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由和异步路由使得实现允许我们既拥有强大的客户端导航SPA，又能够将功能封装在单独的子路由组件中，并且只在需要时加载它们变得简单。
- en: This power and flexibility of the Angular router give us the ability to meet
    user expectations by closely mapping our application's behavior and responsiveness
    to the ways they will use the application. In this case, we have leveraged these
    capabilities to achieve what we set out to do: immediately load *Workout Runner *so
    that our users can get to work on their exercises right away, but avoid the overhead
    of loading *Workout Builder *and instead only serve it when a user wants to build
    a workout.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器的这种强大和灵活性使我们能够通过紧密映射应用程序的行为和响应性来满足用户的期望。在这种情况下，我们利用了这些能力来实现我们的目标：立即加载*Workout
    Runner*，这样我们的用户就可以立即开始锻炼，但避免加载*Workout Builder*的开销，而只在用户想要构建锻炼时才提供它。
- en: Now that we have the routing configuration in place in the *Workout Builder*,
    we will turn our attention to building out the sub-level and left navigation;
    this will enable us to use this routing. The next sections cover implementing
    this navigation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在*Workout Builder*中设置了路由配置，我们将把注意力转向构建子级和左侧导航；这将使我们能够使用这个路由。接下来的部分将介绍实现这个导航。
- en: Integrating sub- and side-level navigation
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成子级和侧边导航
- en: The basic idea around integrating sub- and side-level navigation into the app
    is to provide context-aware sub-views that change based on the active view. For
    example, when we are on a list page as opposed to editing an item, we may want
    to show different elements in the navigation. An e-commerce site is a great example
    of this. Imagine Amazon's search result page and product detail page. As the context
    changes from a list of products to a specific product, the navigation elements
    that are loaded also change.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将子级和侧边导航集成到应用程序中的基本思想是提供基于活动视图而变化的上下文感知子视图。例如，当我们在列表页面而不是编辑项目时，我们可能希望在导航中显示不同的元素。电子商务网站是一个很好的例子。想象一下亚马逊的搜索结果页面和产品详情页面。当上下文从产品列表变为特定产品时，加载的导航元素也会发生变化。
- en: Sub-level navigation
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子级导航
- en: 'We''ll start by adding sub-level navigation to the *Workout Builder*. We have
    already imported our `SubNavMainComponent` into the *Workout Builder*. But, currently
    it is just displaying placeholder content:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从向*Workout Builder*添加子级导航开始。我们已经将`SubNavMainComponent`导入*Workout Builder*中。但是，目前它只显示占位内容：
- en: '![](Images/28e60e18-8309-4acd-b151-5b2a584a74ee.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/28e60e18-8309-4acd-b151-5b2a584a74ee.png)'
- en: 'We''ll now replace that content with three router links: Home, New Workout,
    and New Exercise.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将用三个路由链接替换这个内容：主页、新锻炼和新练习。
- en: 'Open the `sub-nav-main.component.html` file and change the HTML in it to the
    following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`sub-nav-main.component.html`文件并将其中的HTML更改为以下内容：
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, rerun the application and you will see the three navigation links. If
    we click on the New Exercise link button, we will be routed to `ExerciseComponent`
    and its view will appear in the Router Outlet in the *Workout Builder* view:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，重新运行应用程序，你将看到三个导航链接。如果我们点击新练习链接按钮，我们将被路由到`ExerciseComponent`，并且它的视图将出现在*Workout
    Builder*视图中的路由器出口中：
- en: '![](Images/0fb35542-d5c7-42b7-bc20-2a5f20ca0b98.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0fb35542-d5c7-42b7-bc20-2a5f20ca0b98.png)'
- en: The New Workout link button will work in a similar fashion; when clicked on,
    it will take the user to the `WorkoutComponent` and display its view in the router
    outlet. Clicking on the Home link button will return the user to the `WorkoutsComponent` and
    view.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新锻炼链接按钮将以类似的方式工作；当点击时，它将带用户到`WorkoutComponent`并在路由出口显示其视图。点击主页链接按钮将返回用户到`WorkoutsComponent`和视图。
- en: Side navigation
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 侧边导航
- en: Side-level navigation within the *Workout Builder* will vary depending on the
    child component that we navigate to. For instance, when we first navigate to the
    *Workout Builder*, we are taken to the Workouts screen because the `WorkoutsComponent` route
    is the default route for the *Workout Builder*. That component will need side
    navigation; it will allow us to select to view a list of workouts or a list of
    exercises.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '*Workout Builder*内的侧边级别导航将根据我们导航到的子组件而有所不同。例如，当我们首次导航到*Workout Builder*时，我们会进入Workouts屏幕，因为`WorkoutsComponent`路由是*Workout
    Builder*的默认路由。该组件将需要侧边导航；它将允许我们选择查看锻炼列表或练习列表。'
- en: 'The component-based nature of Angular gives us an easy way to implement these
    context-sensitive menus. We can define new components for each of the menus and
    then import them into the components that need them. In this case, we have three
    components that will need side menus: **Workouts**, **Exercises**, and **Workout**.
    The first two of these components can actually use the same menu so we really
    only need two side menu components: `LeftNavMainComponent`, which will be like
    the preceding menu and will be used by the `Exercises` and `Workouts` components,
    and `LeftNavExercisesComponent`, which will contain a list of existing exercises
    and will be used by the `Workouts` component.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Angular的基于组件的特性为我们提供了一种实现这些上下文敏感菜单的简单方法。我们可以为每个菜单定义新的组件，然后将它们导入到需要它们的组件中。在这种情况下，我们有三个组件将需要侧边菜单：**Workouts**，**Exercises**和**Workout**。前两个组件实际上可以使用相同的菜单，所以我们实际上只需要两个侧边菜单组件：`LeftNavMainComponent`，它将类似于前面的菜单，并将被`Exercises`和`Workouts`组件使用，以及`LeftNavExercisesComponent`，它将包含现有练习列表，并将被`Workouts`组件使用。
- en: We already have files for the two menu components, including template files,
    and have imported them into `WorkoutBuilderModule`. We will now integrate these
    into the components that need them.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为这两个菜单组件准备了文件，包括模板文件，并将它们导入到`WorkoutBuilderModule`中。现在我们将把它们整合到需要它们的组件中。
- en: 'First, modify the `workouts.component.html` template to add the selector for
    the menu:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，修改`workouts.component.html`模板以添加菜单的选择器：
- en: '[PRE18]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, replace the placeholder text in the `left-nav-main.component.html` with
    the navigation links to `WorkoutsComponent` and `ExercisesComponent`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`left-nav-main.component.html`中用导航链接替换占位文本到`WorkoutsComponent`和`ExercisesComponent`：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the application and you should see the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，你应该看到以下内容：
- en: '![](Images/021d2798-3ff7-47bf-8fe9-e122f98333f0.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/021d2798-3ff7-47bf-8fe9-e122f98333f0.png)'
- en: Follow the exact same steps to complete the side menu for the `Exercises` component.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 按照完全相同的步骤完成`Exercises`组件的侧边菜单。
- en: We won't show the code for this menu here, but you can find it in the `workout-builder/exercises`
    folder under `trainer/src/app` in `checkpoint 4.3` of the GitHub repository.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里展示菜单的代码，但你可以在GitHub存储库的`checkpoint 4.3`中的`trainer/src/app`下的`workout-builder/exercises`文件夹中找到它。
- en: 'For the menu for the Workout screen, the steps are the same except that you
    should change `left-nav-exercises.component.html` to the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在Workout屏幕的菜单中，步骤是相同的，只是你应该将`left-nav-exercises.component.html`更改为以下内容：
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use this template as the starting point for building out a list of exercises
    that will appear on the left-hand side of the screen and can be selected for inclusion
    in a workout.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个模板作为构建出现在屏幕左侧的练习列表的起点，并可以选择包含在锻炼中的练习。
- en: Implementing workout and exercise lists
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现锻炼和练习列表
- en: Even before we start implementing the Workout and Exercise list pages, we need
    a data store for exercise and workout data. The current plan is to have an in-memory
    data store and expose it using an Angular service. In [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*, where we talk about server interaction,
    we will move this data to a server store for long-term persistence. For now, the
    in-memory store will suffice. Let's add the store implementation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至在我们开始实现锻炼和练习列表页面之前，我们需要一个练习和锻炼数据的数据存储。当前计划是拥有一个内存数据存储并使用Angular服务公开它。在[第3章](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml)中，*支持服务器数据持久性*，我们将把这些数据移到服务器存储以实现长期持久性。目前，内存存储就足够了。让我们添加存储实现。
- en: WorkoutService as a workout and exercise repository
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WorkoutService作为锻炼和练习存储库
- en: 'The plan here is to create a `WorkoutService` instance that is responsible
    for exposing the exercise and workout data across the two applications. The main
    responsibilities of the service include:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的计划是创建一个`WorkoutService`实例，负责在两个应用程序之间公开练习和锻炼数据。服务的主要职责包括：
- en: '**Exercise-related CRUD operations**: Get all exercises, get a specific exercise
    based on its name, create an exercise, update an exercise, and delete it'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与练习相关的CRUD操作**：获取所有练习，根据名称获取特定练习，创建练习，更新练习和删除练习'
- en: '**Workout-related CRUD operations**: These are similar to the exercise-related
    operations, but targeted toward the workout entity'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与锻炼相关的CRUD操作**：这些类似于与练习相关的操作，但针对锻炼实体'
- en: 'The code is available to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    The branch to download is as follows: **GitHub Branch: checkpoint4.4** (folder`trainer`).
    If you are not using Git, download the snapshot of `Checkpoint 4.4` (a ZIP file)
    from the following GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here. Because
    some of the files in this section are rather long, rather than showing the code
    here, we are also going to suggest at times that you simply copy the files into
    your solution.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可在GitHub上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。要下载的分支如下：**GitHub分支：checkpoint4.4**（文件夹`trainer`）。如果您不使用Git，请从以下GitHub位置下载`Checkpoint
    4.4`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.4.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次，如果您正在与我们一起构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。因为本节中的一些文件相当长，所以我们不会在这里显示代码，有时我们还会建议您将文件简单复制到您的解决方案中。
- en: 'Locate `workout-service.ts` in the `trainer/src/core` folder. The code in that
    file should look like the following, except for the implementation of the two
    methods `setupInitialExercises` and `setupInitialWorkouts`, which we have left
    out because of their length:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`trainer/src/core`文件夹中找到`workout-service.ts`。该文件中的代码应该如下所示，除了两个方法`setupInitialExercises`和`setupInitialWorkouts`的实现，我们因为它们太长而省略了：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we have mentioned before, the implementation of an Angular service is straightforward.
    Here, we are declaring a class with the name `WorkoutService` and decorating it
    with `@Injectable` . Within the `@Injectable` decorator, we have set the `provided-in`
    property to `CoreModule`.  This registers `WorkoutService` as a provider with
    Angular's **Dependency Injection** framework and makes it available throughout
    our application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Angular服务的实现是直接的。在这里，我们声明了一个名为`WorkoutService`的类，并用`@Injectable`进行了修饰。在`@Injectable`装饰器内，我们将`provided-in`属性设置为`CoreModule`。这将`WorkoutService`注册为Angular的**依赖注入**框架的提供者，并使其在整个应用程序中可用。
- en: In the class definition, we first create two arrays: one for `Workouts` and
    one for `Exercises`. These arrays are of types `WorkoutPlan` and `Exercise` respectively,
    and we, therefore, need to import `WorkoutPlan` and `Exericse` from `model.ts`
    to get the type definitions for them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义中，我们首先创建两个数组：一个用于`Workouts`，一个用于`Exercises`。这些数组分别是`WorkoutPlan`和`Exercise`类型的，因此我们需要从`model.ts`中导入`WorkoutPlan`和`Exericse`以获取它们的类型定义。
- en: The constructor calls two methods to set up the Workouts and Services List.
    At the moment, we are just using an in-memory store that populates these lists
    with data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用两个方法来设置Workouts和Services列表。目前，我们只是使用一个内存存储来填充这些列表的数据。
- en: The two methods, `getExercises` and `getWorkouts`, as the names suggest, return
    a list of exercises and workouts respectively. Since we plan to use the in-memory
    store to store workout and exercise data, the `Workouts` and `Exercises` arrays
    store this data. As we go along, we will be adding more functions to the service.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 两个方法`getExercises`和`getWorkouts`，正如它们的名称所示，分别返回一系列练习和锻炼。由于我们计划使用内存存储来存储锻炼和运动数据，`Workouts`和`Exercises`数组存储这些数据。随着我们的进展，我们将向服务添加更多功能。
- en: Time to build out the components for the workout and exercise lists!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候为锻炼和运动清单构建组件了！
- en: Workout and exercise list components
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锻炼和运动清单组件
- en: 'First, open the `workouts.component.ts` file in the `trainer/src/app/workout-builder/workouts`
    folder and update the imports as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开`trainer/src/app/workout-builder/workouts`文件夹中的`workouts.component.ts`文件，并按以下方式更新导入：
- en: '[PRE22]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This new code imports the Angular  `Router` as well as `WorkoutService` and
    the `WorkoutPlan` type.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码导入了Angular的`Router`以及`WorkoutService`和`WorkoutPlan`类型。
- en: 'Next, replace the class definition with the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，用以下代码替换类定义：
- en: '[PRE23]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This code adds a constructor into which we are injecting the `Router` and the
    `WorkoutService`. The `ngOnInit` method then calls the `getWorkouts` method on
    the `WorkoutService` and populates a `workoutList`  array with a list of `WorkoutPlans`
    returned from that method call. We'll use that `workoutList` array to populate
    the list of workout plans that will display in the `Workouts` component's view.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码添加了一个构造函数，我们在其中注入了`Router`和`WorkoutService`。然后`ngOnInit`方法调用`WorkoutService`的`getWorkouts`方法，并用从该方法调用返回的`WorkoutPlans`列表填充了一个`workoutList`数组。我们将使用`workoutList`数组来填充将显示在`Workouts`组件视图中的锻炼计划列表。
- en: You'll notice that we are putting the code for calling `WorkoutService` into
    the `ngOnInit` method. We want to avoid placing this code in the constructor.
    Eventually, we will be replacing the in-memory store that this service uses with
    a call to an external data store and we do not want the instantiation of our component
    to be affected by this call. Adding these method calls to the constructor would
    also complicate testing the component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们将调用`WorkoutService`的代码放在了`ngOnInit`方法中。我们希望避免将此代码放在构造函数中。最终，我们将用外部数据存储的调用替换此服务使用的内存存储，并且我们不希望我们组件的实例化受到此调用的影响。将这些方法调用添加到构造函数中也会使组件的测试变得更加复杂。
- en: To avoid such unintended side effects, we instead place the code in the `ngOnInit`
    method. This method implements one of Angular's lifecycle hooks, `OnInit`, which
    Angular calls after creating an instance of the service. This way, we rely on
    Angular to call this method in a predictable way that does not affect the instantiation
    of the component.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种意外的副作用，我们将代码放在“ngOnInit”方法中。这个方法实现了Angular的生命周期钩子之一，“OnInit”，Angular在创建服务实例后调用这个方法。这样，我们依赖于Angular以一种可预测的方式调用这个方法，不会影响组件的实例化。
- en: Next, we'll make almost identical changes to the `Exercises` component. As with
    the `Workouts` component, this code injects the workout service into our component.
    This time, we then use the workout service to retrieve the exercises.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对“Exercises”组件进行几乎相同的更改。与“Workouts”组件一样，这段代码将训练服务注入到我们的组件中。这次，我们使用训练服务来检索练习。
- en: As it is similar to the `Workouts` component, we won't show that code here.
    Just add it from the `workout-builder/exercises` folder in  `checkpoint 4.4`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它与“Workouts”组件类似，我们不会在这里显示该代码。只需从“checkpoint 4.4”中的“workout-builder/exercises”文件夹中添加即可。
- en: Workout and exercise list views
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练和练习列表视图
- en: Now, we need to implement the list views that have so far been empty!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要实现到目前为止为空的列表视图！
- en: In this section, we will be updating the code from `checkpoint 4.3` with `checkpoint
    4.4`. So if you are coding along with us, simply follow the steps laid out in
    this section. If you want to see the finished code, then just copy the files from
    `checkpoint 4.4` into your solution.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用“checkpoint 4.4”更新来自“checkpoint 4.3”的代码。因此，如果您正在与我们一起编码，只需按照本节中列出的步骤进行操作。如果您想查看完成的代码，只需将“checkpoint
    4.4”中的文件复制到您的解决方案中。
- en: Workouts list views
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练列表视图
- en: 'To get the view working, open `workouts.component.html` and add the following
    markup:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要使视图工作，请打开“workouts.component.html”并添加以下标记：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We are using one of the Angular core directives, `ngFor`, to loop through the
    list of workouts and display them in a list on the page. We add the `*` sign in
    front of `ngFor` to identify it as an Angular directive. Using a `let` statement,
    we assign `workout` as a local variable that we use to iterate through the workout
    list and identify the values to be displayed for each workout (for example, `workout.title`).
    We then use one of our custom pipes, `orderBy`, to display a list of workouts
    in alphabetical order by title. We are also using another custom pipe, `secondsToTime`,
    to format the time displayed for the total workout duration.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用Angular核心指令之一，“ngFor”，来循环遍历训练列表，并在页面上以列表的形式显示它们。我们在“ngFor”前面加上“*”号，以将其标识为Angular指令。使用“let”语句，我们将“workout”赋值为一个本地变量，用于遍历训练列表并确定要为每个训练显示的值（例如，“workout.title”）。然后，我们使用我们的自定义管道之一，“orderBy”，按标题的字母顺序显示训练列表。我们还使用另一个自定义管道，“secondsToTime”，来格式化显示总训练持续时间的时间。
- en: If you are coding along with us, you will need to move the `secondsToTime` pipe
    into the shared folder and include it in the `SharedModule`. Then, add `SharedModule`
    to `WorkoutBuilderModule` as an additional import. That change has already been
    made in `checkpoint 4.4` in the GitHub repository.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在与我们一起编码，您需要将“secondsToTime”管道移动到共享文件夹，并将其包含在“SharedModule”中。然后，将“SharedModule”添加到“WorkoutBuilderModule”中作为额外的导入。这个更改已经在GitHub存储库的“checkpoint
    4.4”中进行了。
- en: 'Finally, we bind the click event to the following `onSelect` method that we
    add to our component:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将点击事件绑定到以下添加到我们组件中的“onSelect”方法：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This sets up navigation to the workout details page. This navigation happens
    when we click on an item in the workout list. The selected workout name is passed
    as part of the route`/URL` to the workout detail page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置导航到训练详情页面。当我们点击训练列表中的项目时，导航就会发生。所选的训练名称作为路由/URL的一部分传递到训练详情页面。
- en: 'Go ahead and refresh the builder page (`/builder/workouts`); one workout is
    listed, the 7 Minute Workout. Click on the tile for that workout. You''ll be taken
    to the Workout screen and the workout name, `7MinWorkout`, will appear at the
    end of the URL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 继续刷新构建器页面(`/builder/workouts`)；一个训练被列出，7分钟训练。点击该训练的图块。您将被带到训练屏幕，训练名称`7MinWorkout`将出现在URL的末尾：
- en: '![](Images/52e68978-023c-4c2a-baaa-3bdc273eb151.png)The Workout screen'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/52e68978-023c-4c2a-baaa-3bdc273eb151.png)训练屏幕'
- en: Exercises list views
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习列表视图
- en: 'We are going to follow the same approach for the `Exercises` list view as we
    did for the `Workouts` list view, except that in this case, we will actually be
    implementing two views: one for the `Exercises` component (which will display
    in the main content area when a user navigates to that component) and one for
    the `LeftNavExercisesComponent` exercises context menu (which will display when
    the user navigates to the `Workouts` component to create or edit a workout).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照与“训练”列表视图相同的方法来处理“练习”列表视图，只是在这种情况下，我们实际上将实现两个视图：一个用于“练习”组件（当用户导航到该组件时将显示在主内容区域中），另一个用于“LeftNavExercisesComponent”练习上下文菜单（当用户导航到“训练”组件以创建或编辑训练时将显示）。
- en: For the `Exercises` component, we will follow an approach that is almost identical
    to what we did to display a list of workouts in the `Workouts` component. So,
    we won't show that code here. Just add the files for `exercises.component.ts`
    and `exercises.component.html` from `checkpoint 4.4`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“练习”组件，我们将遵循几乎与在“训练”组件中显示训练列表所做的方法几乎相同的方法。因此，我们不会在这里显示该代码。只需从`checkpoint 4.4`中添加`exercises.component.ts`和`exercises.component.html`文件。
- en: When you are done copying the files, click on the Exercises link in the left
    navigation to load the 12 exercises that you have already configured in `WorkoutService`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成复制文件后，点击左侧导航中的“练习”链接，加载您已在“WorkoutService”中配置的12个练习。
- en: As with the `Workouts` list, this sets up the navigation to the exercise detail
    page. Clicking on an item in the exercises list takes us to the exercise detail
    page. The selected exercise name is passed as part of the route`/URL` to the exercise
    detail page.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与“训练”列表一样，这设置了导航到练习详细页面。点击练习列表中的项目会带我们到练习详细页面。所选练习名称作为路由`/URL`的一部分传递到练习详细页面。
- en: In the final list view, we will add a list of exercises that will display in
    the left context menu for the *Workout Builder* screen. This view is loaded in
    the left navigation when we create or edit a workout. Using Angular's component-based
    approach, we will update the `leftNavExercisesComponent` and its related view
    to provide this functionality. Just add the files for `left-nav-exercises.component.ts`
    and `left-nav-exercises.component.html` from the `trainer/src/app/navigation`
    folder in `checkpoint 4.4`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的列表视图中，我们将添加一个练习列表，该列表将显示在*Workout Builder*屏幕的左上下文菜单中。当我们创建或编辑训练时，此视图将加载在左侧导航中。使用Angular的基于组件的方法，我们将更新`leftNavExercisesComponent`及其相关视图以提供此功能。只需从`checkpoint
    4.4`中的`trainer/src/app/navigation`文件夹中添加`left-nav-exercises.component.ts`和`left-nav-exercises.component.html`文件。
- en: Once you are done copying those files, click on the New Workout button on the
    sub-navigation menu in the *Workout Builder* and you will now see a list of exercises
    displayed in the left navigation menu—exercises that we have already configured
    in `WorkoutService`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您完成复制这些文件，点击*Workout Builder*子导航菜单中的“新训练”按钮，您现在将在左侧导航菜单中看到一系列练习的列表—这些练习已经在`WorkoutService`中配置好了。
- en: Time to add the ability to load, save, and update exercise/workout data!
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加加载、保存和更新练习/训练数据的功能了！
- en: Building a workout
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建训练
- en: The core functionality *Personal Trainer* provides centers around workout and
    exercise building. Everything is there to support these two functions. In this
    section, we focus on building and editing workouts using Angular.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 核心功能*个人教练*主要围绕锻炼和锻炼建设。一切都是为了支持这两个功能。在这一部分，我们专注于使用Angular构建和编辑锻炼。
- en: The `WorkoutPlan` model has already been defined, so we are aware of the elements
    that constitute a workout. The *Workout Builder* page facilitates user input and
    lets us build/persist workout data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutPlan`模型已经定义，因此我们知道构成锻炼的元素。*锻炼建设者*页面促进用户输入，并让我们构建/保存锻炼数据。'
- en: 'Once complete, the *Workout Builder* page will look like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，*锻炼建设者*页面将如下所示：
- en: '![](Images/876d3637-e3f8-468e-92e7-6f89cb85c636.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/876d3637-e3f8-468e-92e7-6f89cb85c636.png)'
- en: The page has a left navigation that lists all the exercises that can be added
    to the workout. Clicking on the arrow icon on the right adds the exercise to the
    end of the workout.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 页面左侧导航列出了可以添加到锻炼中的所有练习。点击右侧的箭头图标将练习添加到锻炼的末尾。
- en: The center area is designated for workout building. It consists of exercise
    tiles laid out in order from top to bottom and a form that allows the user to
    provide other details about the workout such as name, title, description, and
    rest duration.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 中心区域专门用于锻炼建设。它由按顺序铺设的锻炼瓷砖和一个表单组成，允许用户提供关于锻炼的其他细节，如名称、标题、描述和休息时间。
- en: 'This page operates in two modes:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面有两种模式：
- en: 'Create/New: This mode is used for creating a new workout. The URL is `#/ builder/workout/new`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建/新建：此模式用于创建新的锻炼。URL为`#/ builder/workout/new`。
- en: 'Edit: This mode is used for editing the existing workout. The URL is `#/ builder/workout/:id`,
    where `:id` maps to the name of the workout.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑：此模式用于编辑现有的锻炼。URL为`#/ builder/workout/:id`，其中`:id`映射到锻炼的名称。
- en: With this understanding of the page elements and layout, it's time to build
    each of these elements. We will start with left nav (navigation).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了页面元素和布局之后，现在是构建每个元素的时候了。我们将从左侧导航开始。
- en: Finishing left nav
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成左侧导航
- en: At the end of the previous section, we updated the left navigation view for
    the `Workout` component to show a list of exercises. Our intention was to let
    the user click on an arrow next to an exercise to add it to the workout. At the
    time, we deferred implementing the `addExercise` method in the `LeftNavExercisesComponent`
    that was bound to that click event. Now, we will go ahead and do that.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节结束时，我们更新了`Workout`组件的左侧导航视图，以显示锻炼的练习列表。我们的意图是让用户点击练习旁边的箭头将其添加到锻炼中。当时，我们推迟了在`LeftNavExercisesComponent`中实现`addExercise`方法，该方法绑定到该点击事件。现在，我们将继续执行。
- en: We have a couple of options here. The `LeftNavExercisesComponent` is a child
    component of the `WorkoutComponent`, so we can implement child/parent inter-component
    communication to accomplish that. We covered this technique in the previous chapter
    while working on *7 Minute Workout*.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里有几个选择。`LeftNavExercisesComponent`是`WorkoutComponent`的子组件，因此我们可以实现子/父组件间通信来完成这一点。在上一章节中，我们在*7分钟锻炼*时使用了这种技术。
- en: However, adding an exercise to the workout is part of a larger process of building
    the workout and using child/parent inter-component communication would make the
    implementation of the `AddExercise` method differ from the other functionality
    that we will be adding going forward.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将练习添加到锻炼中是构建锻炼的一个较大过程的一部分，使用子/父组件间通信将使`AddExercise`方法的实现与我们将来要添加的其他功能不同。
- en: For this reason, it makes more sense to follow another approach for sharing
    data, one that we can use consistently throughout the process of building a workout.
    That approach involves using a service. As we get into adding the other functionality
    for creating an actual workout, such as save/update logic and implementing the
    other relevant components, the benefits of going down the service route will become
    increasingly clear.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更合理的是采用另一种共享数据的方法，这是我们可以在整个构建锻炼的过程中一致使用的方法。这种方法涉及使用服务。随着我们开始添加用于创建实际锻炼的其他功能，例如保存/更新逻辑和实现其他相关组件，采用服务路线的好处将变得越来越清晰。
- en: So, we introduce a new service into the picture: `WorkoutBuilderService`. The
    ultimate aim of `WorkoutBuilderService` service is to coordinate between `WorkoutService`
    (which retrieves and persists the workout) and the components (such as `LeftNavExercisesComponent`
    and others we will add later), while the workout is being built, hence reducing
    the amount of code in `WorkoutComponent` to the bare minimum.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将一个新的服务引入到图片中：`WorkoutBuilderService`。`WorkoutBuilderService`服务的最终目标是协调`WorkoutService`（用于检索和保存锻炼）和组件（例如`LeftNavExercisesComponent`和其他我们稍后将添加的组件）之间的协调，因此在构建锻炼时减少`WorkoutComponent`中的代码量至最低。
- en: Adding WorkoutBuilderService
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加WorkoutBuilderService
- en: '`WorkoutBuilderService` monitors the state of the workout that a user of the
    application is building. It:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`监视应用程序用户正在构建的锻炼的状态。它：'
- en: Tracks the current workout
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪当前锻炼
- en: Creates a new workout
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的锻炼
- en: Loads the existing workout
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载现有的锻炼
- en: Saves the workout
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: Copy `workout-builder-service.ts` from the `workout-builder/builder-services` folder
    under `trainer/src/app` in `checkpoint 4.5`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从`checkpoint 4.5`中的`trainer/src/app`下的`workout-builder/builder-services`文件夹中复制`workout-builder-service.ts`。
- en: 'The code is also available for everyone to download on GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.5` (folder—`trainer`). If you are not using
    Git, download the snapshot of `Checkpoint 4.5` (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure to update the `styles.css` file, which we are not discussing here.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码也可供所有人在GitHub上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub中作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.5`（文件夹—`trainer`）。如果您不使用Git，请从以下GitHub位置下载`Checkpoint
    4.5`的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.5.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次，如果您正在与我们一起构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。
- en: 'While we normally make services available application-wide,  `WorkoutBuilderService`
    will only be used in the *Workout Builder* feature. Therefore, instead of registering
    it with the providers in `AppModule`, we have registered it in the provider array
    of `WorkoutBuilderModule` as follows (after adding it as an import at the top
    of the file):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们通常会使服务在整个应用程序中可用，但`WorkoutBuilderService`只会在*Workout Builder*功能中使用。因此，我们没有在`AppModule`的提供程序中注册它，而是在`WorkoutBuilderModule`的提供程序数组中注册它（在文件顶部添加导入后）：
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Adding it as a provider here means that it will only be loaded when the *Workout
    Builder* feature is being accessed and it cannot be reached outside this module.
    This means that it can be evolved independently of other modules in the application
    and can be modified without affecting other parts of the application.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里将其添加为提供者意味着只有在访问*训练计划生成器*功能时才会加载它，并且它无法在此模块之外被访问。这意味着它可以独立于应用程序中的其他模块进行演变，并且可以在不影响应用程序其他部分的情况下进行修改。
- en: Let's look at some of the relevant parts of the service.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看服务的一些相关部分。
- en: '`WorkoutBuilderService` needs the type definitions for `WorkoutPlan`, `ExercisePlan`,
    and `WorkoutService`, so we import these into the component:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`需要`WorkoutPlan`，`ExercisePlan`和`WorkoutService`的类型定义，因此我们将其导入到组件中：'
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`WorkoutBuilderService` has a dependency on `WorkoutService` to provide persistence
    and querying capabilities. We resolve this dependency by injecting `WorkoutService`
    into the constructor for `WorkoutBuilderService`**:**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`依赖于`WorkoutService`来提供持久性和查询功能。我们通过将`WorkoutService`注入到`WorkoutBuilderService`的构造函数中来解决这一依赖关系。'
- en: '[PRE28]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`WorkoutBuilderService` also needs to track the workout being built. We use
    the `buildingWorkout` property for this. The tracking starts when we call the
    `startBuilding` method on the service:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`还需要跟踪正在构建的训练计划。我们使用`buildingWorkout`属性来实现这一点。跟踪是在调用服务的`startBuilding`方法时开始的：'
- en: '[PRE29]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The basic idea behind this tracking function is to set up a `WorkoutPlan` object
    (`buildingWorkout`) that will be made available to components to manipulate the
    workout details. The `startBuilding` method takes the workout name as a parameter.
    If the name is not provided, it implies we are creating a new workout, and hence
    a new `WorkoutPlan` object is created and assigned; if not, we load the workout
    details by calling `WorkoutService.getWorkout(name)`. In any case, the `buildingWorkout`
    object has the workout being worked on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这个跟踪功能背后的基本思想是建立一个`WorkoutPlan`对象（`buildingWorkout`），以便让组件可以操纵训练计划的细节。`startBuilding`方法以训练名称作为参数。如果没有提供名称，那就意味着我们正在创建一个新的训练计划，因此会创建并分配一个新的`WorkoutPlan`对象；如果提供了名称，我们通过调用`WorkoutService.getWorkout(name)`来加载训练计划的细节。无论哪种情况，`buildingWorkout`对象都包含正在进行的训练计划。
- en: The `newWorkout` object signifies whether the workout is new or an existing
    one. It is used to differentiate between save and update situations when the `save`
    method on this service is called.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`newWorkout`对象表示训练计划是新的还是现有的。它用于区分在调用此服务的`save`方法时的保存和更新情况。'
- en: The rest of the methods, `removeExercise`, `addExercise`, and `moveExerciseTo`, are
    self-explanatory and affect the exercise list that is part of the workout (`buildingWorkout`).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的方法，`removeExercise`，`addExercise`和`moveExerciseTo`，都是不言自明的，并且会影响作为训练计划一部分的练习列表（`buildingWorkout`）。
- en: '`WorkoutBuilderService` is calling a new method, `getWorkout`, on `WorkoutService`,
    which we have not added yet. Go ahead and copy the `getWorkout` implementation
    from the `workout-service.ts` file in the `services` folder under `trainer/src`
    in `checkpoint 4.5`. We will not dwell on the new service code as the implementation
    is quite simple.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutBuilderService`正在调用`WorkoutService`上的一个新方法`getWorkout`，而我们尚未添加。继续并从`checkpoint
    4.5`中`trainer/src`文件夹下的`services`文件夹中的`workout-service.ts`文件中复制`getWorkout`的实现。我们不会深入讨论新服务代码，因为实现非常简单。'
- en: Let's get back to left nav and implement the remaining functionality.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到左侧导航栏并实现剩下的功能。
- en: Adding exercises using ExerciseNav
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`ExerciseNav`添加练习。
- en: 'To add exercises to the workout we are building, we just need to import `WorkoutBuilderService`
    and `ExercisePlan`, inject `WorkoutBuilderService` into the `LeftNavExercisesComponent`,
    and call its `addExercise` method, passing the selected exercise as a parameter:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们正在构建的训练添加练习，我们只需要导入`WorkoutBuilderService`和`ExercisePlan`，将`WorkoutBuilderService`注入`LeftNavExercisesComponent`，并调用其`addExercise`方法，将所选的练习作为参数传递：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Internally, `WorkoutBuilderService.addExercise` updates the `buildingWorkout`
    model data with the new exercise.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`WorkoutBuilderService.addExercise`使用新的练习更新`buildingWorkout`模型数据。
- en: The preceding implementation is a classic case of sharing data between independent
    components. The shared service exposes the data in a controlled manner to any
    component that requests it. While sharing data, it is always a good practice to
    expose the state/data using methods instead of directly exposing the data object.
    We can see that in our component and service implementations too. `LeftNavExercisesComponent`
    does not update the workout data directly; in fact, it does not have direct access
    to the workout being built. Instead, it relies upon the service method, `addExercise`,
    to change the current workout's exercise list.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 上述实现是共享独立组件之间数据的经典案例。共享服务以受控的方式向任何请求它的组件公开数据。在共享数据时，一直使用方法来公开状态/数据而不是直接公开数据对象是一个良好的实践。我们在组件和服务的实现中也可以看到这一点。`LeftNavExercisesComponent`不直接更新训练数据；事实上，它没有直接访问正在构建的训练。相反，它依赖于服务方法`addExercise`来改变当前训练的练习列表。
- en: Since the service is shared, there are pitfalls to be aware of. As services
    are injectable through the system, we cannot stop any component from taking dependency
    on any service and calling its functions in an inconsistent manner, leading to
    undesired results or bugs. For example, `WorkoutBuilderService` needs to be initialized
    by calling `startBuilding` before `addExercise` is called. What happens if a component
    calls `addExercise` before the initialization takes place?
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务是共享的，所以需要注意一些陷阱。由于服务可以通过系统进行注入，我们无法阻止任何组件依赖任何服务并以不一致的方式调用其函数，导致不良结果或错误。例如，`WorkoutBuilderService`需要在调用`addExercise`之前通过调用`startBuilding`进行初始化。如果一个组件在初始化之前调用`addExercise`会发生什么？
- en: Implementing the Workout component
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现训练组件
- en: The `WorkoutComponent` is responsible for managing a workout. This includes
    creating, editing, and viewing the workout. Due to the introduction of `WorkoutBuilderService`,
    the overall complexity of this component will be reduced. Other than the primary
    responsibility of integrating with, exposing, and interacting with its template
    view, we will delegate most of the other work to `WorkoutBuilderService`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent`负责管理训练。这包括创建、编辑和查看训练。由于引入了`WorkoutBuilderService`，这个组件的整体复杂性将会降低。除了与模板视图集成、暴露和交互的主要责任外，我们将把大部分其他工作委托给`WorkoutBuilderService`。'
- en: The `WorkoutComponent` is associated with two `routes/views`, namely `/builder/workout/new`
    and `/builder/workout/:id`. These routes handle both creating and editing workout
    scenarios. The first job of the component is to load or create the workout that
    it needs to manipulate.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutComponent`与两个`路由/视图`相关联，即`/builder/workout/new`和`/builder/workout/:id`。这些路由处理创建和编辑训练的情况。组件的第一个任务是加载或创建它需要操作的训练。'
- en: Route parameters
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由参数
- en: But before we get to building out the `WorkoutComponent`and its associated view,
    we need to touch briefly on the navigation that brings a user to the screen for
    that component. This component handles both creating and editing workout scenarios.
    The first job of the component is to load or create the workout that it needs
    to manipulate. We plan to use Angular's routing framework to pass the necessary
    data to the component, so that it will know whether it is editing an existing
    workout or creating a new one, and in the case of an existing workout, which component
    it should be editing.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始构建`WorkoutComponent`及其关联视图之前，我们需要简要介绍一下将用户带到该组件屏幕的导航。该组件处理创建和编辑锻炼方案。组件的第一个任务是加载或创建需要操作的锻炼。我们计划使用Angular的路由框架将必要的数据传递给组件，以便它知道自己是在编辑现有的锻炼还是创建新的锻炼，并且在现有的锻炼情况下，应该编辑哪个组件。
- en: How is this done? The `WorkoutComponent` is associated with two routes, namely
    `/builder/workout/new` and `/builder/workout/:id`. The difference in these two
    routes lies in what is at the end of these routes; in one case, it is `/new`,
    and in the other,` /:id`. These are called **route parameters.** The `:id` in
    the second route is a token for a route parameter. The router will convert the
    token to the ID for the workout component. As we saw earlier, this means that
    the URL that will be passed to the component in the case of *7 Minute Workout*
    will be `/builder/workout/7MinuteWorkout`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何实现的？`WorkoutComponent`与两个路由相关联，即`/builder/workout/new`和`/builder/workout/:id`。这两个路由的区别在于这两个路由的末尾是什么；在一个情况下，是`/new`，在另一个情况下是`/:id`。这些被称为**路由参数**。第二个路由中的`:id`是路由参数的标记。路由器将把标记转换为锻炼组件的ID。正如我们之前看到的，这意味着在*7分钟锻炼*的情况下，将传递给组件的URL将是`/builder/workout/7MinuteWorkout`。
- en: 'How do we know that this workout name is the right parameter for the ID? As
    you recall, when we set up the event for handling a click on the Workout tiles
    on the Workouts screen that takes us to the Workout screen, we designated the
    workout name as the parameter for the ID, like so:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怎么知道这个锻炼名称是ID的正确参数？你还记得，当我们设置处理在锻炼屏幕上点击锻炼瓷砖的事件时，我们将锻炼名称指定为ID的参数，就像这样：
- en: '[PRE31]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are constructing the route using the programmatic interface for the
    router. The `router.navigate` method accepts an array. This is called the **link
    parameters array**. The first item in the array is the path of the route, and
    the second is a route parameter that specifies the ID of the workout. In this
    case, we set the `id` parameter to the workout name. We can also construct the
    same type of URL as part of a router link or simply enter it in the browser to
    get to the Workouts screen and edit a particular workout.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在使用路由器的编程接口构建路由。`router.navigate`方法接受一个数组。这被称为**链接参数数组**。数组中的第一项是路由的路径，第二项是指定锻炼ID的路由参数。在这种情况下，我们将`id`参数设置为锻炼名称。我们也可以构建相同类型的URL作为路由链接的一部分，或者简单地在浏览器中输入它以到达锻炼屏幕并编辑特定的锻炼。
- en: The other of the two routes ends with `/new`. Since this route does not have
    a `token` parameter, the router will simply pass the URL unmodified to the `WorkoutComponent`.
    The `WorkoutComponent` will then need to parse the incoming URL to identify that
    it should be creating a new component.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另外一个路由以`/new`结尾。由于这个路由没有`token`参数，路由器将简单地将URL未经修改地传递给`WorkoutComponent`。然后，`WorkoutComponent`需要解析传入的URL，以确定它应该创建一个新的组件。
- en: Route guards
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由守卫
- en: But before the link takes the user to the `WorkoutComponent`, there is another
    step along the way that we need to consider. The possibility always exists that
    the ID that is passed in the URL for editing a workout could be incorrect or missing.
    In those cases, we do not want the component to load, but instead, we want to
    have the user redirected to another page or back to where they came from.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 但在链接将用户带到`WorkoutComponent`之前，我们需要考虑另一个步骤。始终存在一个可能性，即在编辑训练的URL中传递的ID可能不正确或丢失。在这些情况下，我们不希望加载组件，而是希望将用户重定向到另一个页面或返回到他们来自的页面。
- en: Angular offers a way to accomplish this result with **route guards**. As the
    name implies, route guards **provide a way to prevent navigation to a route**.
    A route guard can be used to inject custom logic that can do things such as check
    authorization, load data, and make other verifications to determine whether the
    navigation to the component needs to be canceled or not. And all of this is done
    before the component loads so it is never seen if the routing is canceled.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一种使用路由守卫来实现这一结果的方法。顾名思义，路由守卫提供了一种阻止导航到路由的方法。路由守卫可用于注入自定义逻辑，例如检查授权、加载数据和进行其他验证，以确定是否需要取消导航到组件。所有这些都是在组件加载之前完成的，因此如果取消了路由，则永远不会看到该组件。
- en: Angular offers several route guards, including `CanActivate`, `CanActivateChild`,
    `CanDeActivate`, `Resolve`, and `CanLoad`**.** At this point, we are interested
    in the `Resolve` route guard**. **The `Resolve` guard will allow us not only to
    check for the existence of a workout, but also to load the data associated with
    a workout before loading the `WorkoutComponent`. The advantage of doing the latter
    is that we avoid the necessity of checking to make sure the data is loaded in
    the `WorkoutComponent` and it eliminates adding conditional logic throughout its
    component template to make sure that the data is there when it is rendered.  This
    will be especially useful when in the next chapter when we start using `observables`
    where we must wait for the observable to complete before we are guaranteed of
    having the data that it will provide. The `Resolve` guard will handle waiting
    for the observable to complete, which means that the `WorkoutComponent` will be
    guaranteed to have the data that it needs before it loads.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几种路由守卫，包括`CanActivate`，`CanActivateChild`，`CanDeActivate`，`Resolve`和`CanLoad`。在这一点上，我们对`Resolve`路由守卫感兴趣。`Resolve`守卫不仅允许我们检查训练存在与否，还允许我们在加载`WorkoutComponent`之前加载与训练相关的数据。这样做的好处是我们避免了在`WorkoutComponent`中检查数据是否加载的必要性，并且消除了在组件模板中添加条件逻辑以确保数据在渲染时存在的需要。当我们开始使用`observables`时，这将特别有用，因为我们必须等待可观察对象完成，才能确保它提供的数据已经存在。`Resolve`守卫将处理等待可观察对象完成的过程，这意味着`WorkoutComponent`在加载之前将确保具有所需的数据。
- en: Implementing the resolve route guard
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现解析路由守卫
- en: The `Resolve` guard allows us to prefetch the data for a workout. In our case,
    what we want to do is use `Resolve` to check the validity of any ID that is passed
    for an existing workout. Specifically, we will run a check on that ID by making
    a call to the `WorkoutBuilderService` to retrieve the Workout Plan and see if
    it exists. If it exists, we will load the data associated with the Workout Plan
    so that it is available to the `WorkoutComponent`; if not we will redirect back
    to the Workouts screen.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resolve`守卫允许我们预取训练的数据。在我们的情况下，我们想要使用`Resolve`来检查传递给现有训练的任何ID的有效性。具体来说，我们将通过调用`WorkoutBuilderService`来检查该ID，以检索训练计划并查看其是否存在。如果存在，我们将加载与训练计划相关的数据，以便`WorkoutComponent`可以使用；如果不存在，我们将重定向回训练屏幕。'
- en: 'Copy `workout.resolver.ts` from the `workout-builder/workout` folder under
    `trainer/src/app/workout` in `checkpoint 4.5` and you will see the following code:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 从`trainer/src/app/workout`文件夹下的`workout-builder/workout`文件夹中复制`workout.resolver.ts`到`checkpoint
    4.5`，然后你会看到以下代码：
- en: '[PRE32]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, the `WorkoutResolver` is an injectable class that implements
    the `Resolve` interface.  The code injects the `WorkoutBuilderService` and `Router`
    into the class and implements the interface with the `resolve` method. The `resolve`
    method accepts two parameters; `ActivatedRouteSnapshot` and `RouterStateSnapshot`.
    In this case, we are only interested in the first of these two parameters, `ActivatedRouteSnapshot`. 
    It contains a `paramMap` from which we extract the ID parameter for the route.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`WorkoutResolver`是一个可注入的类，实现了`Resolve`接口。 该代码将`WorkoutBuilderService`和`Router`注入到类中，并使用`resolve`方法实现了接口。
    `resolve`方法接受两个参数；`ActivatedRouteSnapshot`和`RouterStateSnapshot`。 在这种情况下，我们只对这两个参数中的第一个感兴趣，即`ActivatedRouteSnapshot`。
    它包含一个`paramMap`，我们从中提取路由的ID参数。
- en: The `resolve` method then calls the `startBuilding` method of `WorkoutBuildingService` using
    the parameter supplied in the route. If the workout exists, then `resolve` returns
    the data and the navigation proceeds; if not, it re-routes the user to the workouts
    page and returns false. If `new` is passed as an ID, `WorkoutBuilderService` will
    load a new workout and the `Resolve` guard will allow navigation to proceed to
    the `WorkoutComponent`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`resolve`方法使用路由中提供的参数调用`WorkoutBuildingService`的`startBuilding`方法。 如果锻炼存在，则`resolve`返回数据并进行导航；如果不存在，则重新将用户重定向到锻炼页面并返回false。
    如果将`new`作为ID传递，`WorkoutBuilderService`将加载一个新的锻炼，并且`Resolve`守卫将允许导航到`WorkoutComponent`。
- en: The `resolve` method can return a `Promise` , an `Observable,` or a synchronous
    value. If we return an `Observable`,  we will need to make sure that the `Observable`
    completes before proceeding with navigation. In this case, however, we are making
    a synchronous call to a local in-memory data store, so we are just returning a
    value.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve`方法可以返回一个`Promise`，一个`Observable`或一个同步值。 如果我们返回一个`Observable`，我们需要确保`Observable`在继续导航之前完成。
    但是，在这种情况下，我们正在对本地内存数据存储进行同步调用，因此我们只返回一个值。'
- en: 'To complete the implementation of the `WorkoutResolver`, first make sure to
    import and add it to `WorkoutBuilderModule` as a provider:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`WorkoutResolver`的实现，首先确保将其导入并添加到`WorkoutBuilderModule`作为提供者：
- en: '[PRE33]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Then, add it to the route configuration for `WorkoutComponent` by updating `workout-builder-routing.module.ts`
    as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过更新`workout-builder-routing.module.ts`，将其添加到`WorkoutComponent`的路由配置中，如下所示：
- en: '[PRE34]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, we add `WorkoutResolver` to the routing module''s imports.
    Then, we add `resolve { workout: WorkoutResolver }` to the end of the route configuration
    for `workout/new` and `workout/:id` . This instructs the router to use the `WorkoutResolver` resolve
    method and assign its return value to `workout` in the route''s data. This configuration
    means that `WorkoutResolver` will be called prior to the router navigating to `WorkoutComponent`
    and that the workout data will be available to the `WorkoutComponent` when it
    loads. We''ll see how to extract this data in the `WorkoutComponent` in the next
    section.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '如您所见，我们将`WorkoutResolver`添加到路由模块的导入中。 然后，我们在`workout/new`和`workout/:id`的路由配置末尾添加`resolve
    { workout: WorkoutResolver }`。 这指示路由器使用`WorkoutResolver`的解析方法，并将其返回值分配给路由数据中的`workout`。
    这个配置意味着`WorkoutResolver`将在路由器导航到`WorkoutComponent`之前被调用，并且在加载`WorkoutComponent`时将可用锻炼数据。
    我们将在下一节中看到如何在`WorkoutComponent`中提取这些数据。'
- en: Implementing the Workout component continued...
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续实现Workout组件...
- en: Now that we have established the routing that takes us to the `Workout` component,
    let's turn to completing its implementation. So, copy the `workout.component.ts`
    file from the `workout-builder/workout` folder under `trainer/src/app` in `checkpoint
    4.5`. (Also, copy `workout-builder.module.ts` from the `workout-builder` folder.
    We'll discuss the changes in this file a little later when we get to Angular forms.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了将我们带到`Workout`组件的路由，让我们转而完成它的实现。因此，从`trainer/src/app`下的`workout-builder/workout`文件夹中复制`workout.component.ts`文件到`checkpoint
    4.5`中。（还要复制`workout-builder.module.ts`文件从`workout-builder`文件夹中。当我们到达Angular表单时，我们稍后会讨论这个文件的更改。）
- en: 'Open `workout.component.ts` and you''ll see that we have added a constructor
    that injects `ActivatedRoute` and `WorkoutBuilderService`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout.component.ts`，你会看到我们添加了一个构造函数，它注入了`ActivatedRoute`和`WorkoutBuilderService`：
- en: '[PRE35]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In addition, we have added the following `ngOnInit` method:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们添加了以下`ngOnInit`方法：
- en: '[PRE36]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method subscribes to the `route` and extracts the `workout` from the `route.data`.
    There is no need to check the workout exists because we have already done that
    in the `WorkoutResolver`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法订阅`route`并从`route.data`中提取`workout`。无需检查锻炼是否存在，因为我们已经在`WorkoutResolver`中做过了。
- en: We are subscribing to the `route.data` because as an `ActivatedRoute`, the `route`
    exposes its `data` as an  `Observable`, which can change during the lifetime of
    the component. This gives us the ability to reuse the same component instance
    with different parameters, even though the `OnInit` life cycle event for that
    component is called only once. We'll cover `Observables` in detail in the next
    chapter.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在订阅`route.data`，因为作为`ActivatedRoute`，`route`将其`data`公开为`Observable`，在组件的生命周期内可以更改。这使我们能够重用相同的组件实例，即使该组件的`OnInit`生命周期事件只调用一次，也可以使用不同的参数。我们将在下一章节详细介绍`Observables`。
- en: In addition to this code, we have also added a series of methods to the `Workout
    Component` for adding, removing,  and moving a workout. These methods all call
    corresponding methods on the `WorkoutBuilderService` and we will not review them
    in detail here. We've also added an array of `durations` for populating the duration
    drop-down list.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这段代码，我们还为`Workout Component`添加了一系列用于添加、删除和移动锻炼的方法。这些方法都调用了`WorkoutBuilderService`上的相应方法，我们将不在这里详细讨论它们。我们还添加了一个用于填充持续时间下拉列表的`durations`数组。
- en: For now, this is enough for the **component** class implementation. Let's update
    the associated `Workout` template.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这对于**组件**类的实现就足够了。让我们更新相关的`Workout`模板。
- en: Implementing the Workout template
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Workout模板
- en: Now, copy the `workout.component.html` files from the `workout-builder/workout`
    folder under `trainer/src/app` in `checkpoint 4.5`. Run the app, navigate to `/builder/workouts`,
    and double-click on the *7 Minute Workout* tile. This should load the *7 Minute
    Workout* details with a view similar to the one shown at the start of the *Building
    a workout* section.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从`trainer/src/app`下的`checkpoint 4.5`中的`workout-builder/workout`文件夹中复制`workout.component.html`文件。运行应用程序，导航到`/builder/workouts`，然后双击*7分钟锻炼*瓷砖。这应该加载类似于*构建锻炼*部分开头所示的视图的*7分钟锻炼*详情。
- en: 'In the event of any problem, you can refer to the `checkpoint4.5` code in the
    `GitHub repository: Branch: checkpoint4.5` (folder - `trainer`).'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现任何问题，您可以参考`GitHub存储库中的`checkpoint4.5`代码：分支：checkpoint4.5（文件夹 - `trainer`）。
- en: We will be dedicating a lot of time to this view, so let's understand some specifics
    here.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将花费大量时间在这个视图上，所以让我们在这里了解一些具体情况。
- en: 'The exercise list div (`id="exercise-list"`) lists the exercises that are part
    of the workout in order. We display them as top-to-bottom tiles in the left part
    of the content area. Functionally, this template has:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 练习列表div（`id="exercise-list"`）按顺序列出了训练中的练习。我们将它们显示为内容区域左侧的从上到下的瓷砖。从功能上讲，这个模板有：
- en: The Delete button to delete the exercise
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除按钮用于删除练习
- en: Reorder buttons to move the exercise up and down the list, as well as to the
    top and bottom
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新排序按钮可将练习上移和下移列表，以及移到顶部和底部
- en: 'We use `ngFor` to iterate over the list of exercises and display them:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ngFor`来迭代练习列表并显示它们：
- en: '[PRE37]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You will notice that we are using the `*` asterisk in front of `ngFor`,  which
    is shorthand for the `<template>` tag. We are also using `let` to set two local
    variables: `exerisePlan` to identify an item in the list of exercises and `i`
    to set up an index value that we will use to show a number for the exercises as
    they are displayed on the screen. We will also use the index value to manage reordering
    and deleting exercises from the list.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们在`ngFor`前面使用了`*`星号，这是`<template>`标签的简写。我们还使用`let`来设置两个局部变量：`exerisePlan`用于识别练习列表中的项目，`i`用于设置一个索引值，我们将用它来在屏幕上显示练习的编号。我们还将使用索引值来管理重新排序和从列表中删除练习。
- en: The second div element for workout data (`id="workout-data"`) contains the HTML
    input element for details such as name, title, and rest duration, and a button
    to save workout changes.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 用于训练数据的第二个div元素（`id="workout-data"`）包含了有关名称、标题和休息时间的HTML输入元素，以及保存训练变更的按钮。
- en: The complete list has been wrapped inside the HTML form element so that we can
    make use of the form-related capabilities that Angular provides. So, what are
    these capabilities?
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的列表已经包裹在HTML表单元素内，以便我们可以利用Angular提供的与表单相关的功能。那么，这些功能是什么呢？
- en: Angular forms
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular表单
- en: Forms are such an integral part of HTML development that any framework that
    targets client-side development just cannot ignore them. Angular provides a small
    but well-defined set of constructs that make standard form-based operations easier.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 表单是HTML开发的一个重要部分，任何针对客户端开发的框架都不能忽视它们。Angular提供了一组小而明确定义的构造，使标准基于表单的操作更容易。
- en: 'If we think carefully, any form of interaction boils down to:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细思考，任何形式的交互都归结为：
- en: Allowing user inputs
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户输入
- en: Validating those inputs against business rules
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据业务规则验证这些输入
- en: Submitting the data to the backend server
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据提交到后端服务器
- en: Angular has something to offer for all the preceding use cases.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Angular为所有前述用例提供了一些东西。
- en: For user input, it allows us to create two-way bindings between the form input
    elements and the underlying model, hence avoiding any boilerplate code that we
    may have to write for model input synchronization.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户输入，它允许我们在表单输入元素和底层模型之间创建双向绑定，从而避免我们可能需要为模型输入同步编写的任何样板代码。
- en: It also provides constructs to validate the input before it can be submitted.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供了用于在提交之前验证输入的构造。
- en: Lastly, Angular provides HTTP services for client-server interaction and persisting
    data to the server. We'll cover those services in [Chapter 3](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml),
    *Supporting Server Data Persistence*.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Angular提供了用于客户端-服务器交互和将数据持久化到服务器的HTTP服务。我们将在[第3章](cba52e86-29c5-4c51-a34f-5db71de16503.xhtml)中介绍这些服务，*支持服务器数据持久化*。
- en: Since the first two use cases are our main focus in this chapter, let's learn
    more about Angular user input and data validation support.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两种用例是本章的主要重点，让我们更多地了解一下Angular用户输入和数据验证支持。
- en: Template-driven and reactive forms
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于模板和响应式表单
- en: 'Angular offers two types of forms: **template-driven** and **reactive**. We''ll
    be discussing both types of form in this chapter. Because the Angular team indicates
    that many of us will primarily use **template-driven forms**, that is what we
    will start in this chapter.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了两种类型的表单：**模板驱动**和**响应式**。我们将在本章讨论这两种类型的表单。因为Angular团队表示我们中的许多人主要会使用**模板驱动表单**，这就是我们将在本章开始的原因。
- en: Template-driven forms
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板驱动表单
- en: As the name suggests, **template-driven forms** place the emphasis on developing
    a form within an HTML template and handling most of the logic for the form inputs,
    data validation, saving, and updating in-form directives placed within that template.
    The result is that very little form-related code is required in the component
    class that is associated with the form's template.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，**模板驱动表单**侧重于在HTML模板中开发表单，并处理大部分表单输入、数据验证、保存和更新的逻辑，这些逻辑都放在该模板中的指令中。结果是与表单相关的代码在与表单模板关联的组件类中所需的很少。
- en: '**Template-driven forms** make heavy use of the `ngModel` form directive. We
    will be discussing it in the next sections. It provides two-way data binding for
    form controls, which is a nice feature indeed. It allows us to write much less
    boilerplate code to implement a form. It also helps us to manage the state of
    the form (such as whether the form controls have changed and whether these changes
    have been saved). And, it also gives us the ability to easily construct messages
    that display if the validation requirements for a form control have not been met
    (for example, a required field not provided, email not in the right format, and
    so on).'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板驱动表单**大量使用`ngModel`表单指令。我们将在接下来的章节中讨论它。它为表单控件提供了双向数据绑定，这确实是一个很好的功能。它允许我们编写更少的样板代码来实现一个表单。它还帮助我们管理表单的状态（例如表单控件是否已更改以及这些更改是否已保存）。而且，它还使我们能够轻松构建消息，显示如果表单控件的验证要求未满足（例如，未提供必填字段，电子邮件格式不正确等）。'
- en: Getting started
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'In order to use Angular forms in our `Workout` component, we must first add
    some additional configuration. Open  `workout-buider.module.ts` from the `workout-builder`
    folder under `trainer/src/app` in `checkpoint 4.5`. You will see that it imports
    `FormsModule`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的“Workout”组件中使用Angular表单，我们必须首先添加一些额外的配置。在“checkpoint 4.5”中的`trainer/src/app`下的`workout-builder`文件夹中打开`workout-buider.module.ts`。您会看到它导入了`FormsModule`：
- en: '[PRE38]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This brings in all that we will need to implement our form, including:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引入我们实现表单所需的所有内容，包括：
- en: '`NgForm`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NgForm`'
- en: '`ngModel`'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ngModel`'
- en: Let's start using these to build our form.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用这些来构建我们的表单。
- en: Using NgForm
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NgForm
- en: 'In our template (`workout.component.html`), we have added the following `form`
    tag:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模板（`workout.component.html`）中，我们已经添加了以下`form`标签：
- en: '[PRE39]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let's take a look at what we have here. One interesting thing is that we are
    still using a standard `<form>` tag and not a special Angular tag. We've also
    used `#` to define a local variable `f` to which we have assigned `ngForm`. Creating
    this local variable provides us with the convenience of being able to use it for
    form-related activity in other places within the form. For example, you can see
    that we are using it at the end of the opening `form` tag in a parameter, `f.form`,
    which is being passed to the `onSubmit` event bound to `(ngSubmit)`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们在这里有什么。一个有趣的事情是，我们仍然使用标准的`<form>`标签，而不是特殊的Angular标签。我们还使用了`#`来定义一个本地变量`f`，并将`ngForm`赋给它。创建这个本地变量使我们能够在表单的其他地方使用它进行与表单相关的活动。例如，您可以看到我们在开放的`form`标签的末尾使用它作为参数，`f.form`，它被传递给了与`(ngSubmit)`绑定的`onSubmit`事件。
- en: That last binding to `(ngSubmit)` should tell us that something different is
    going on here. Even though we did not explicitly add the `NgForm` directive, our
    `<form>` now has additional events such as `ngSubmit` to which we can bind actions.
    How did this happen? Well, this was not triggered by our assigning `ngForm` to
    a local variable. Instead, it happened *automagically* because we imported the
    forms module into `workout-builder.module.ts`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个绑定到`(ngSubmit)`的内容应该告诉我们这里发生了一些不同的事情。即使我们没有明确添加`NgForm`指令，我们的`<form>`现在有了额外的事件，比如`ngSubmit`，我们可以将动作绑定到这些事件上。这是怎么发生的呢？嗯，这不是因为我们将`ngForm`分配给了一个本地变量。相反，这是*自动*发生的，因为我们在`workout-builder.module.ts`中导入了表单模块。
- en: With that import in place, Angular scanned our template for a `<form>` tag and
    wrapped that `<form>` tag within an `NgForm` directive. The Angular documentation
    indicates that `<form>` elements in the component will be upgraded to use the
    Angular form system. This is important because it means that various capabilities
    of  `NgForm` are now available to use with the form. These include the `ngSubmit`
    event, which signals when a user has triggered a form submission and provides
    the ability to validate the entire form before submitting it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个导入，Angular扫描了我们的模板，找到了一个`<form>`标签，并将该`<form>`标签包装在`NgForm`指令中。Angular文档指出，组件中的`<form>`元素将升级为使用Angular表单系统。这很重要，因为这意味着各种`NgForm`的功能现在可以与表单一起使用。这些功能包括`ngSubmit`事件，该事件在用户触发表单提交时发出信号，并提供在提交之前验证整个表单的能力。
- en: ngModel
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngModel
- en: One of the fundamental building blocks for template-driven forms is `ngModel`,
    and you will find it being used throughout our form. One of the primary roles
    of `ngModel` is to support two-way binding between user input and an underlying
    model. With such a setup, changes in the model are reflected in the view, and
    updates to the view too are reflected back on the model. Most of the other directives
    that we have covered so far only support one-way binding from models to views.
    `ngModel` goes both ways. But, be aware that it is only available within `NgForm`
    for use with elements that allow user input.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 模板驱动表单的基本构建块之一是`ngModel`，你会发现它在我们的表单中被广泛使用。`ngModel`的主要作用之一是支持用户输入和底层模型之间的双向绑定。有了这样的设置，模型中的更改会反映在视图中，视图的更新也会反映在模型上。到目前为止，我们介绍的大多数其他指令只支持从模型到视图的单向绑定。`ngModel`是双向的。但是，请注意，它仅在`NgForm`中可用，用于允许用户输入的元素。
- en: 'As you know, we already have a model that we are using for the Workout page,
    `WorkoutPlan`. Here is the `WorkoutPlan` model from `model.ts`:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们已经有一个模型用于Workout页面，即`WorkoutPlan`。这是来自`model.ts`的`WorkoutPlan`模型：
- en: '[PRE40]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note the use of the `?` after `description`. This means that it is an optional
    property in our model and is not required to create a `WorkoutPlan`. In our form,
    this will mean that we will not require that a description be entered and everything
    will work fine without it.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在`description`后面使用了`?`。这意味着这是我们模型中的一个可选属性，不需要创建`WorkoutPlan`。在我们的表单中，这意味着我们不需要输入描述，一切都可以正常工作。
- en: 'Within the `WorkoutPlan` model, we also have a reference to an array made up
    of instances of another type of model: `ExercisePlan`. `ExercisePlan` in turn
    is made up of a number (`duration`) and another model (`Exercise`), which looks
    like this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在`WorkoutPlan`模型中，我们还引用了另一种类型的模型实例组成的数组：`ExercisePlan`。`ExercisePlan`又由一个数字（`duration`）和另一个模型（`Exercise`）组成，看起来是这样的：
- en: '[PRE41]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The use of these nested classes shows that we can create complex hierarchies
    of models that can all be data-bound within our form using `NgModel`. So throughout
    the form, whenever we need to update one of the values in a `WorkoutPlan` or an
    `ExercisePlan`, we can use `NgModel` to do that (the `WorkoutPlan` model will
    be represented by a local variable named `workout` in the following examples).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些嵌套类的方法表明，我们可以创建复杂的模型层次结构，可以在我们的表单中使用`NgModel`来对所有这些模型进行数据绑定（在以下示例中，`WorkoutPlan`模型将由一个名为`workout`的局部变量表示）。
- en: Using ngModel with input and textarea
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngModel与input和textarea
- en: 'Open `workout-component.html` and look for `ngModel.` It has been applied to
    form elements that allow user data input. These include input, textarea, and select.
    The workout name input setup looks like this:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`workout-component.html`并查找`ngModel`。它已经应用于允许用户数据输入的表单元素。这些包括input、textarea和select。锻炼名称输入设置如下：
- en: '[PRE42]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The preceding `[(ngModel)]` directive sets up a two-way binding between the
    input control and the `workout.name` model property. The brackets and parentheses
    should each look familiar. Previously, we used them separately from each other:
    the `[]` brackets for property binding and the `()` parentheses for event binding.
    In the latter case, we usually bound the event to a call to a method in the component
    associated with the template. You can see an example of this in the form with
    the button that a user clicks on to remove an exercise:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`[(ngModel)]`指令在输入控件和`workout.name`模型属性之间建立了双向绑定。方括号和括号应该都很熟悉。以前，我们分别使用它们：`[]`方括号用于属性绑定，`()`括号用于事件绑定。在后一种情况下，我们通常将事件绑定到与模板关联的组件中的一个方法的调用上。您可以在表单中看到一个例子，其中按钮用于删除一个练习：
- en: '[PRE43]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Here, the click event is explicitly bound to a method called `removeExercise`
    in our `Workout` component class. But for the `workout.name` input, we do not
    have an explicit binding to a method on the component. So what's going on here
    and how does the update happen without us calling a method on the component? The
    answer to that question is that the combination `[( )]` is shorthand for both
    binding a model property to the input element and wiring up an event that updates
    the model.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，点击事件明确绑定到我们`Workout`组件类中的一个名为`removeExercise`的方法。但对于`workout.name`输入，我们没有将其显式绑定到组件上的方法。那么这里发生了什么，更新是如何发生的，而不需要我们在组件上调用一个方法？这个问题的答案是，组合`[(
    )]`是将模型属性绑定到输入元素和连接更新模型的事件的速记。
- en: Put differently, if we reference a model element in our form, `ngModel` is smart
    enough to know that what we want to do is update that element (`workout.name`
    here) when a user enters or changes the data in the input field to which it is
    bound. Under the hood, Angular creates an update method similar to what we would
    otherwise have to write ourselves. Nice! This approach keeps us from having to
    write repetitive code to update our model.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果我们在表单中引用一个模型元素，`ngModel`足够聪明，知道我们想要做的是在用户输入或更改与其绑定的输入字段中的数据时更新该元素（这里是`workout.name`）。在幕后，Angular创建了一个更新方法，类似于我们自己本来需要编写的方法。很好！这种方法使我们不必编写重复的代码来更新我们的模型。
- en: Angular supports most of the HTML5 input types, including text, number, select,
    radio, and checkbox. This means binding between a model and any of these input
    types just works out of the box.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持大多数HTML5输入类型，包括文本、数字、选择、单选和复选框。这意味着模型与任何这些输入类型之间的绑定都可以直接使用。
- en: 'The `textarea` element works the same as the input:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`textarea`元素的工作方式与输入相同：'
- en: '[PRE44]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we bind `textarea` to `workout.description`. Under the hood, `ngModel`
    updates the workout description in our model with every change we type into the
    text area.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`textarea`绑定到`workout.description`。在幕后，`ngModel`会在我们输入文本区域时更新我们模型中的训练描述。
- en: 'To test out how this works, why don''t we verify this binding? Add a model
    interpolation expression at the end of any of the linked inputs, such as this
    one:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这个工作原理，为什么我们不验证一下这个绑定呢？在任何链接输入框的末尾添加一个模型内插表达式，比如这样一个：
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Open the Workout page, type something in the input, and see how the interpolation
    is updated instantaneously. The magic of two-way binding!
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 打开训练页面，在输入框中输入一些内容，看看内插是如何即时更新的。双向绑定的魔力！
- en: '![](Images/f8286d8e-bfb3-44e6-a448-771693aa1e64.png)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f8286d8e-bfb3-44e6-a448-771693aa1e64.png)'
- en: Using ngModel with select
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ngModel与select
- en: 'Let''s look at how `select` has been set up:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`select`是如何设置的：
- en: '[PRE46]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are using `ngFor` here to bind to an array, `durations`, which is in the
    `Workout` component class. The array looks like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用`ngFor`来绑定到一个数组`durations`，这个数组在`Workout`组件类中。数组看起来是这样的：
- en: '[PRE47]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `ngFor` component will loop over the array and populate the drop-down values
    with the corresponding values in the array with the title for each item being
    displayed using interpolation, `{{duration.title}}`. And `[(ngModel)]` then binds
    the drop-down selection to the `exercisePlan.duration` in the model.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngFor`组件将循环遍历数组，并使用插值将下拉框的值与数组中的相应值填充，每个项目的标题都使用插值`{{duration.title}}`显示。然后`[(ngModel)]`将下拉框选择绑定到模型中的`exercisePlan.duration`。'
- en: Notice here that we are binding to the nested model: `ExercisePlan`. And, we
    may have multiple exercises to which we will be applying this binding. With that
    being the case, we have to make use of another Angular form directive—`ngModelGroup`—to
    handle these bindings. `ngModelGroup` will allow us to create a nested group within
    our model that will contain the list of exercises included in the workout and
    then in turn loop over each exercise to bind its duration to the model.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们绑定的是嵌套模型：`ExercisePlan`。而且，我们可能有多个练习需要应用这个绑定。在这种情况下，我们必须使用另一个Angular表单指令`ngModelGroup`来处理这些绑定。`ngModelGroup`将允许我们在模型中创建一个嵌套组，其中包含训练中包含的练习列表，然后再循环每个练习以将其持续时间绑定到模型中。
- en: 'To start with, we will add `ngModelGroup` to the div tag that we have created
    within the form to hold our list of exercises:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在表单中创建的div标签上添加`ngModelGroup`来保存我们的练习列表：
- en: '[PRE48]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'That takes care of creating the nested list of exercises. Now, we have to handle
    the individual exercises within that list, and we can do that by adding another
    `ngModelGroup` to the individual divs that contain each exercise:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就处理了创建嵌套的练习列表。现在，我们必须处理列表中的个别练习，我们可以通过向包含每个练习的个别div添加另一个`ngModelGroup`来实现这一点：
- en: '[PRE49]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Here, we are using the index in our for loop to dynamically create an individual
    model group for each of our exercises. These model groups will be nested inside
    the first model group that we created. Temporarily, add the tag `<pre>{{ f.value
    | json }}</pre>` to the bottom of the form and you will be able to see the structure
    of this nested model:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用for循环中的索引动态创建每个练习的个别模型组。这些模型组将嵌套在我们创建的第一个模型组中。暂时在表单底部添加标签`<pre>{{ f.value
    | json }}</pre>`，您将能够看到这个嵌套模型的结构：
- en: '[PRE50]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is powerful stuff that enables us to create complicated forms with nested
    models, all of which can use `ngModel` for databinding**.**
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是强大的东西，使我们能够创建具有嵌套模型的复杂表单，所有这些模型都可以使用`ngModel`进行数据绑定。
- en: You may have noticed a subtle difference in the two `ngModelGroup` directive
    tags we just introduced. The second of the two is wrapped in angle brackets, `[]`,
    while the first is not. This is because with the first tag we are just naming
    our model group, whereas with the second we are binding it dynamically to each
    exercise's div tag using the index of our for loop.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们刚刚介绍的两个`ngModelGroup`指令标签之间的微妙差异。其中第二个标签被包裹在尖括号`[]`中，而第一个没有。这是因为在第一个标签中，我们只是给我们的模型组命名，而在第二个标签中，我们使用for循环的索引动态地将其绑定到每个练习的div标签上。
- en: Like input, select too supports two-way binding. We saw how changing select
    updates a model, but the model-to-template binding may not be apparent. To verify
    that a model to a template binding works, open the *7 Minute Workout* app and
    verify the duration dropdowns. Each one has a value that is consistent with the
    model value (30 seconds).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 与输入类似，选择也支持双向绑定。我们看到改变选择会更新模型，但是从模型到模板的绑定可能不太明显。要验证模型到模板的绑定是否有效，请打开*7分钟锻炼*应用程序并验证持续时间下拉菜单。每个下拉菜单的值与模型值（30秒）一致。
- en: Angular does an awesome job of keeping the model and view in sync using `ngModel`.
    Change the model and see the view updated; change the view and watch as the model
    is updated instantaneously.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Angular通过`ngModel`出色地保持了模型和视图的同步。改变模型，看到视图更新；改变视图，观察模型瞬间更新。
- en: Now, let's add validation to our form.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们给我们的表单添加验证。
- en: 'The code for the next section is also available for everyone to download on
    GitHub at [https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample).
    Checkpoints are implemented as branches in GitHub. The branch to download is as
    follows: `GitHub Branch: checkpoint4.6` (folder—`trainer`). Or if you are not
    using Git, download the snapshot of Checkpoint 4.6 (a ZIP file) from the following
    GitHub location: [https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip).
    Refer to the `README.md` file in the `trainer` folder when setting up the snapshot
    for the first time. Again, if you are working along with us as we build the application,
    be sure and update the `styles.css` file, which we are not discussing here.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节的代码也可以在GitHub上下载：[https://github.com/chandermani/angular6byexample](https://github.com/chandermani/angular6byexample)。检查点在GitHub上作为分支实现。要下载的分支如下：`GitHub分支：checkpoint4.6`（文件夹—`trainer`）。或者如果您不使用Git，可以从以下GitHub位置下载Checkpoint
    4.6的快照（ZIP文件）：[https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip](https://github.com/chandermani/angular6byexample/archive/checkpoint4.6.zip)。首次设置快照时，请参考`trainer`文件夹中的`README.md`文件。再次强调，如果您正在与我们一起构建应用程序，请确保更新`styles.css`文件，这里我们不讨论。
- en: Angular validation
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular验证
- en: As the saying goes, *never trust user input*. Angular has support for validation,
    including the standard required, min, max, and pattern, as well as custom validators.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 俗话说，“不要相信用户输入”。Angular支持验证，包括标准的required、min、max和pattern，以及自定义验证器。
- en: ngModel
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ngModel
- en: '`ngModel` is the building block that we will use to implement validation. It
    does two things for us: it maintains the model state and provides a mechanism
    for identifying validation errors and displaying validation messages.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '`ngModel`是我们将用来实现验证的基本组件。它为我们做了两件事：它维护模型状态并提供了一种识别验证错误并显示验证消息的机制。'
- en: 'To get started, we need to assign `ngModel` to a local variable in all of our
    form controls that we will be validating. In each case, we need to use a unique
    name for this local variable. For example, for workout name we add `#name="ngModel"`
    within the `input` tag for that control along with the HTML 5 `required` attribute.
    The workout name `input` tag should now look like this:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要在所有需要验证的表单控件中为`ngModel`分配一个本地变量。在每种情况下，我们需要为这个本地变量使用一个唯一的名称。例如，对于训练名称，我们在该控件的`input`标签中添加`#name="ngModel"`，以及HTML
    5的`required`属性。现在，训练名称的`input`标签应该是这样的：
- en: '[PRE51]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Continue through the form, assigning `ngModel` to local variables for each of
    the inputs. Also, add the required attribute for all the required fields.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 继续填写表单，为每个输入框分配`ngModel`到本地变量。同时，为所有必填字段添加required属性。
- en: The Angular model state
  id: totrans-417
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular模型状态
- en: 'Whenever we use `NgForm`, every element within our form, including input, text
    area, and select, has some states defined on the associated model. `ngModel` tracks
    these states for us. The states tracked are:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们使用`NgForm`时，表单中的每个元素，包括输入框、文本区域和选择框，都有一些与关联模型定义的状态。`ngModel`为我们跟踪这些状态。跟踪的状态包括：
- en: '`pristine`: The value of this is `true` as long as the user does not interact
    with the input. Any update to the `input` field and `ng-pristine` is set to `false`.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pristine`：只要用户不与输入框交互，这个值就是`true`。对`input`字段的任何更新，`ng-pristine`都会被设置为`false`。'
- en: '`dirty`: This is the reverse of `ng-pristine`. This is `true` when the input
    data has been updated.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dirty`：这是`ng-pristine`的反义词。当输入数据已更新时为`true`。'
- en: '`touched`: This is `true` if the control ever had focus.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touched`：如果控件曾经获得焦点，则为`true`。'
- en: '`untouched`: This is `true` if the control has never lost focus. This is just
    the reverse of `ng-touched`.'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`untouched`：如果控件从未失去焦点，则为`true`。这就是`ng-touched`的反义词。'
- en: '`valid`: This is `true` if there are validations defined on the `input` element
    and none of them are failing.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`valid`：如果在`input`元素上定义了验证，并且没有失败，则为`true`。'
- en: '`invalid`: This is `true` if any of the validations defined on the element
    are failing.'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invalid`：如果元素上定义的任何验证失败，则为`true`。'
- en: '`pristine``dirty` or `touched``untouched` are useful properties that can help
    us decide when error labels are shown.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '`pristine``dirty`或`touched``untouched`是有用的属性，可以帮助我们决定何时显示错误标签。'
- en: Angular CSS classes
  id: totrans-426
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Angular CSS类
- en: 'Based on the model state, Angular adds some CSS classes to an input element.
    These include the following:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 根据模型状态，Angular会为输入元素添加一些CSS类。这些包括以下内容：
- en: '`ng-valid`: This is used if the model is valid'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-valid`：如果模型有效则使用'
- en: '`ng-invalid`: This is used if the model is invalid'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-invalid`：如果模型无效则使用'
- en: '`ng-pristine`: This is used if the model is pristine'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-pristine`：如果模型是原始的则使用'
- en: '`ng-dirty`: This is used if the model is dirty'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-dirty`：如果模型是脏的则使用'
- en: '`ng-untouched`: This is used when the input is never visited'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-untouched`：当输入框从未被访问时使用'
- en: '`ng-touched`: This is used when the input has focus'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ng-touched`：当输入框获得焦点时使用'
- en: 'To verify it, go back to the `workoutName` input tag and add a template reference
    variable named `spy` inside the `input` tag:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证它，回到`workoutName`输入标签，并在`input`标签内部添加一个名为`spy`的模板引用变量：
- en: '[PRE52]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, below the tag, add the following label:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在标签下面添加以下标签：
- en: '[PRE53]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Reload the application and click on the New Workout link in the *Workout Builder*.
    Before touching anything on the screen, you will see the following displayed:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载应用程序，点击*Workout Builder*中的New Workout链接。在屏幕上什么都不触摸之前，您将看到以下内容显示：
- en: '![](Images/f8643209-7e90-4b2f-8665-60fad1fd0777.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/f8643209-7e90-4b2f-8665-60fad1fd0777.png)'
- en: 'Add some content into the Name input box and tab away from it. The label changes
    to this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 在名称输入框中添加一些内容，然后切换到其他地方。标签会变成这样：
- en: '![](Images/a44e53db-4fdf-4545-8ac7-6a986a1aa973.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a44e53db-4fdf-4545-8ac7-6a986a1aa973.png)'
- en: What we are seeing here is Angular changing the CSS classes that apply to this
    control as the user interacts with it. You can also see these changes by inspecting
    the `input` element in the developer console.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到的是Angular随着用户与其交互而改变适用于该控件的CSS类。您还可以通过检查开发者控制台中的`input`元素来看到这些更改。
- en: 'These CSS class transitions are tremendously useful if we want to apply visual
    clues to the element depending on its state. For example, look at this snippet:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想根据元素的状态应用视觉提示，这些CSS类转换非常有用。例如，看看这个片段：
- en: '[PRE54]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This draws a red border around any input control that has invalid data.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在任何具有无效数据的输入控件周围绘制红色边框。
- en: As you add more validations to the Workout page, you can observe (in the developer
    console) how these classes are added and removed as the user interacts with the
    `input` element.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向训练页面添加更多验证时，您可以观察（在开发者控制台中）这些类在用户与`input`元素交互时是如何添加和移除的。
- en: Now that we have an understanding of model states and how to use them, let's
    get back to our discussion of validations (before moving on, remove the variable
    name and label that you just added).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了模型状态以及如何使用它们，让我们回到验证的讨论（在继续之前，删除刚刚添加的变量名称和标签）。
- en: Workout validation
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 训练验证
- en: The workout data needs to be validated for a number of conditions.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 需要对训练数据进行多种条件的验证。
- en: After taking the step of adding the local variable references for `ngModel`
    and the required attribute to our `input` fields, we have been able to see how
    `ngModel` tracks changes in the state of these controls and how it toggles the
    CSS styles.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在为我们的`input`字段添加了`ngModel`和`required`属性的本地变量引用之后，我们已经能够看到`ngModel`如何跟踪这些控件状态的变化以及如何切换CSS样式。
- en: Displaying appropriate validation messages
  id: totrans-451
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示适当的验证消息
- en: Now, the input needs to have a value; otherwise, the validation fails. But,
    how can we know if the validation has failed? `ngModel` comes to our rescue here.
    It can provide the validation state of the particular input. And that gives us
    what we need to display an appropriate validation message.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入需要有一个值；否则，验证将失败。但是，我们如何知道验证失败了呢？`ngModel`在这里帮了我们。它可以提供特定输入的验证状态。这给了我们显示适当验证消息所需的内容。
- en: 'Let''s go back to the input control for the Workout name. In order to get a
    validation message to display, we have to first modify the input tag to the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到训练名称的输入控件。为了显示验证消息，我们首先必须修改输入标签如下：
- en: '[PRE55]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We have added a local variable called `#name` and assigned `ngModel` to it.
    This is called a template reference variable and we can use it with the following
    label to display a validation message for the input:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`#name`的本地变量，并将`ngModel`分配给它。这称为模板引用变量，我们可以将其与以下标签一起使用，以显示输入的验证消息：
- en: '[PRE56]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We are showing the validation message in the event that the name is not provided
    and the control has been touched. To check the first condition, we retrieve the
    `hasError` property of the control and see if the error type is `required`. We
    check to see if the name input has been `touched` because we do not want the message
    to display when the form first loads for a new workout.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在事件中显示验证消息，以防名称未提供且控件已被触摸。要检查第一个条件，我们检索控件的`hasError`属性，并查看错误类型是否为`required`。我们检查名称输入是否已被`触摸`，因为我们不希望在表单首次加载新的训练时显示消息。
- en: You will notice that we are using a somewhat more verbose style to identify
    validation errors than is required in this situation. Instead of `name.control.hasError('required')`,
    we could have used `!name. valid` and it would have worked perfectly fine. However,
    using the more verbose approach allows us to identify validation errors with greater
    specificity, which will be essential when we start adding multiple validators
    to our form controls. We'll look at using multiple validators a little later in
    this chapter. For consistency, we'll stick with the more verbose approach.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们使用了一种比在这种情况下所需的更冗长的样式来识别验证错误。我们可以使用`!name. valid`而不是`name.control.hasError('required')`，它也可以完美地工作。但是，使用更冗长的方法允许我们更具体地识别验证错误，这在我们开始向表单控件添加多个验证器时将是至关重要的。我们稍后在本章中将看到如何使用多个验证器。为了保持一致，我们将坚持使用更冗长的方法。
- en: 'Load the new Workout page (`/builder/workouts/new`) now. Enter a value in the
    name input box and then delete it. The error label appears as shown in the following
    screenshot:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 现在加载新的锻炼页面（`/builder/workouts/new`）。在名称输入框中输入一个值，然后删除它。错误标签将显示如下截图所示：
- en: '![](Images/a29cbdcd-9184-49cb-9e78-ab45b6605d97.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a29cbdcd-9184-49cb-9e78-ab45b6605d97.png)'
- en: Adding more validation
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加更多验证
- en: 'Angular provides several out-of-the-box validators, including:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了几个开箱即用的验证器，包括：
- en: '`required`'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`'
- en: '`minLength`'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minLength`'
- en: '`maxLength`'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxLength`'
- en: '`email`'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`email`'
- en: '`pattern`'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern`'
- en: For the complete list of out-of-the box validators, see the documentation for
    the `Validators` class at [https://angular.io/api/forms/Validators.](https://angular.io/api/forms/Validators)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 有关开箱即用验证器的完整列表，请参阅`Validators`类的文档[https://angular.io/api/forms/Validators.](https://angular.io/api/forms/Validators)
- en: 'We''ve seen how the `required` validator works. Now, let''s look at two of
    the other out-of-the-box validators: `minLength` and `maxLength`. In addition
    to making it required, we want the title of the workout to be between 5 and 20
    characters (we''ll look at the `pattern` validator a little later in this chapter).'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`required`验证器的工作原理。现在，让我们来看看另外两个开箱即用的验证器：`minLength`和`maxLength`。除了使其必填外，我们希望锻炼的标题在5到20个字符之间（我们稍后在本章中将看到`pattern`验证器）。
- en: 'So, in addition to the `required` attribute we added previously to the title
    input box, we will add the `minLength` attribute and set it to `5`, and add the
    `maxLength` attribute and set it to `20`, like so:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了我们之前添加到标题输入框的`required`属性之外，我们将添加`minLength`属性并将其设置为`5`，并添加`maxLength`属性并将其设置为`20`，如下所示：
- en: '[PRE57]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we add another label with a message that will display when this validation
    is not met:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加另一个带有消息的标签，当未满足此验证时将显示该消息：
- en: '[PRE58]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Managing multiple validation messages
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理多个验证消息
- en: 'You''ll see that the conditions for displaying the message now test for the
    length not being zero. This prevents the message from displaying in the event
    that the control is touched but left empty. In that case, the title required message
    should display. This message only displays if nothing is entered in the field
    and we accomplish this by checking explicitly to see if the control''s `hasError`
    type is `required`:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到显示消息的条件现在测试长度不为零。这可以防止在控件被触摸但保持空白时显示消息。在这种情况下，标题必填消息应该显示。只有在字段中没有输入任何内容时，此消息才会显示，我们通过明确检查控件的`hasError`类型是否为`required`来实现这一点：
- en: '[PRE59]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Since we are attaching two validators to this input field, we can consolidate
    the check for the input being touched by wrapping both validators in a div tag
    that checks for that condition being met:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将两个验证器附加到此输入字段，我们可以通过将两个验证器包装在一个检查该条件是否满足的div标签中来合并对输入的触摸检查：
- en: '[PRE60]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: What we just did shows how we can attach multiple validations to a single input
    control and also display the appropriate message in the event that one of the
    validation conditions is not met. However, it's pretty clear that this approach
    will not scale for more complicated scenarios. Some inputs contain a lot of validations
    and controlling when a validation message shows up can become complex. As the
    expressions for handling the various displays get more complicated, we may want
    to refactor and move them into a custom directive. Creating a custom directive
    will be covered in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml),
    *Angular Directives in Depth*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚所做的展示了如何将多个验证附加到单个输入控件，并在未满足验证条件之一的情况下显示适当的消息。然而，很明显，这种方法在更复杂的情况下不会扩展。一些输入包含大量验证，并且控制验证消息何时显示可能变得复杂。随着处理各种显示的表达式变得更加复杂，我们可能希望重构并将其移入自定义指令中。如何创建自定义指令将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中详细介绍，《深入理解Angular指令》。
- en: Custom validation messages for an exercise
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为练习定制验证消息
- en: A workout without any exercise is of no use. There should at least be one exercise
    in the workout and we should validate this restriction.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何练习的锻炼是没有用的。锻炼中至少应该有一个练习，我们应该验证这个限制。
- en: The problem with exercise count validation is that it is not something that
    the user inputs directly and the framework validates. Nonetheless, we still want
    a mechanism to validate the exercise count in a manner similar to other validations
    on this form.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 练习计数验证的问题在于，这不是用户直接输入并由框架验证的内容。尽管如此，我们仍希望有一种机制来验证练习计数，类似于此表单上的其他验证方式。
- en: 'What we will do is add a hidden input box to the form that contains the count
    of the exercises. We will then bind this to `ngModel` and add a pattern validator
    that will check to make sure that there is more than one exercise. We will set
    the value of the input box to the count of the exercises:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在表单中添加一个隐藏的输入框，其中包含练习的计数。然后，我们将将其绑定到 `ngModel` 并添加一个模式验证器，以确保有多于一个练习。我们将设置输入框的值为练习的计数：
- en: '[PRE61]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Then, we will attach a validation message to it similar to what we just did
    with our other validators:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将为其附加一个类似于我们刚刚使用其他验证器的验证消息：
- en: '[PRE62]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We are not using `ngModel` in its true sense here. There is no two-way binding
    involved. We are only interested in using it to do custom validation.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里并没有真正使用 `ngModel`。这里没有涉及双向绑定。我们只对使用它进行自定义验证感兴趣。
- en: 'Open the new Workout page, add an exercise, and remove it; we should see this
    error:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 打开新的锻炼页面，添加一个练习，然后将其删除；我们应该看到这个错误：
- en: '![](Images/a46fd29c-0d4f-4157-ba8d-e6d2cd3b5e60.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a46fd29c-0d4f-4157-ba8d-e6d2cd3b5e60.png)'
- en: What we did here could have been easily done without involving any model validation
    infrastructure. But, by hooking our validation into that infrastructure, we do
    derive some benefits. We can now determine errors with a specific model and errors
    with the overall form in a consistent and familiar manner. Most importantly, if
    our validation fails here, the entire form will be invalidated.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的这些可以很容易地在不涉及任何模型验证基础设施的情况下完成。但是，通过将我们的验证钩入该基础设施，我们确实获得了一些好处。现在，我们可以以一种一致且熟悉的方式确定特定模型的错误以及整个表单的错误。最重要的是，如果我们的验证在这里失败，整个表单将无效。
- en: Implementing custom validation the way we just did is not what you would want
    to do very often. Instead, it will usually make more sense to implement this kind
    of complicated logic inside a custom directive. We'll cover creating custom directives
    in detail in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 实现刚才所做的自定义验证并不是你经常想要做的事情。相反，通常更有意义的是在自定义指令内部实现这种复杂逻辑。我们将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中详细介绍创建自定义指令，*深入理解
    Angular 指令*。
- en: One nuisance with our newly implemented `Exercise Count` validation is that
    it shows when the screen for a new `Workout` first appears. With this message,
    we are not able to use `ng-touched` to hide the display. This is because the exercises
    are being added programmatically and the hidden input we are using to track their
    count never changes from untouched as exercises are added or removed.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新实现的 `Exercise Count` 验证的一个麻烦之处是，当新的 `Workout` 屏幕首次出现时会显示。通过这条消息，我们无法使用 `ng-touched`
    来隐藏显示。这是因为练习是以编程方式添加的，并且我们用于跟踪它们数量的隐藏输入在添加或删除练习时从未改变过。
- en: 'To fix this problem, we need an additional value to check when the state of
    the exercise list has been reduced to zero, except when the form is first loaded.
    The only way that situation can happen is if the user adds and then removes exercises
    from a workout to the point that there are no more exercises. So, we''ll add another
    property to our component that we can use to track whether the remove method has
    been called. We call that value `removeTouched` and set its initial value to `false`:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要一个额外的值来检查当练习列表的状态被减少到零时，除非表单首次加载。这种情况发生的唯一方式是用户添加然后从锻炼中移除练习，直到没有更多的练习为止。因此，我们将向组件添加另一个属性，用于跟踪删除方法是否已被调用。我们称这个值为
    `removeTouched`，并将其初始值设置为 `false`：
- en: '[PRE63]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in the remove method we will set that value to `true`:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在删除方法中，我们将把该值设置为 `true`：
- en: '[PRE64]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we will add `removeTouched` to our validation message conditions, like
    so:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把 `removeTouched` 添加到我们的验证消息条件中，如下所示：
- en: '[PRE65]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, when we open a new workout screen, the validation message will not display.
    But if the user adds and then removes all the exercises, then it will display.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们打开一个新的锻炼屏幕时，验证消息将不会显示。但是，如果用户添加然后移除所有练习，那么它将显示。
- en: To understand how model validation rolls up into form validation, we need to
    understand what form-level validation has to offer. However, even before that,
    we need to implement saving the workout and calling it from the workout form.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解模型验证如何卷入表单验证，我们需要了解表单级别验证能提供什么。然而，甚至在此之前，我们需要实现保存锻炼并从锻炼表单中调用它。
- en: Saving the workout
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存锻炼
- en: The workout that we are building needs to be persisted (in-memory only). The
    first thing that we need to do is extend `WorkoutService` and `WorkoutBuilderService`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的锻炼需要被持久化（仅在内存中）。我们需要做的第一件事是扩展 `WorkoutService` 和 `WorkoutBuilderService`。
- en: '`WorkoutService` needs two new methods, `addWorkout` and `updateWorkout`:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`WorkoutService` 需要两个新方法，`addWorkout` 和 `updateWorkout`：'
- en: '[PRE66]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `addWorkout` method does a basic check on the workout name and then pushes
    the workout into the workout array. Since there is no backing store involved,
    if we refresh the page, the data is lost. We will fix this in the next chapter
    where we persist the data to a server.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`addWorkout` 方法对锻炼名称进行基本检查，然后将锻炼推入锻炼数组中。由于没有涉及后备存储，如果刷新页面，数据将丢失。我们将在下一章中修复这个问题，将数据持久化到服务器上。'
- en: The `updateWorkout` method looks for a workout with the same name in the existing
    workouts array and if found, updates and replaces it.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateWorkout` 方法会在现有的锻炼数组中查找同名的锻炼，如果找到，则更新并替换它。'
- en: 'We only add one save method to `WorkoutBuilderService` as we are already tracking
    the context in which workout construction is going on:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只向`WorkoutBuilderService`添加一个保存方法，因为我们已经在跟踪进行锻炼构建的上下文：
- en: '[PRE67]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The `save` method calls either `addWorkout` or `updateWorkout` in the `Workout`
    service based on whether a new workout is being created or an existing one is
    being edited.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '- `save`方法根据正在创建新锻炼还是正在编辑现有锻炼，在`Workout`服务中调用`addWorkout`或`updateWorkout`。'
- en: From a service perspective, that should be enough. Time to integrate the ability
    to save workouts into the `Workout` component and learn more about the form directive!
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务的角度来看，这应该足够了。是时候将保存锻炼的能力集成到`Workout`组件中，并了解更多关于表单指令的知识了！
- en: 'Before we look at `NgForm` in more detail, let''s add the save method to `Workout`
    to save the workout when the `Save` button is clicked on. Add this code to the
    `Workout` component:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在更详细地查看`NgForm`之前，让我们向`Workout`组件添加一个保存方法，以便在单击“保存”按钮时保存锻炼。将以下代码添加到`Workout`组件中：
- en: '[PRE68]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We check the validation state of the form using its invalid property and then
    call the `WorkoutBuilderService.save` method if the form state is valid.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '- 使用其无效属性检查表单的验证状态，然后在表单状态有效时调用`WorkoutBuilderService.save`方法。'
- en: More on NgForm
  id: totrans-514
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于NgForm
- en: Forms in Angular have a different role to play as compared to traditional forms
    that post data to the server. If we go back and look again at the form tag, we
    will see that it is missing the standard action attribute. The standard form behavior
    of posting data to the server using full-page post-back does not make sense with
    an SPA framework such as Angular. In Angular, all server requests are made through
    asynchronous invocations originating from directives or services.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: Angular中的表单与传统的将数据提交到服务器的表单相比有不同的作用。如果我们回过头再看一下表单标签，我们会发现它缺少标准的action属性。使用全页后退进行数据提交到服务器的标准表单行为在Angular这样的SPA框架中是没有意义的。在Angular中，所有服务器请求都是通过指令或服务发起的异步调用。
- en: Under the hood, Angular is also turning off the browser's inbuilt validation.
    As you have seen in this chapter, we are still using validation attributes such
    as `required` that look the same as native HTML validation attributes. However,
    as the Angular documentation explains, inside an Angular form "Angular uses directives
    to match these attributes with validator functions in the framework." See  [https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Angular还关闭了浏览器的内置验证。正如你在本章中所看到的，我们仍然使用诸如`required`之类的验证属性，看起来与原生HTML验证属性相同。然而，正如Angular文档所解释的那样，在Angular表单中，“Angular使用指令将这些属性与框架中的验证器函数进行匹配”。请参阅[https://angular.io/guide/form-validation#template-driven-validation](https://angular.io/guide/form-validation#template-driven-validation)。
- en: 'The form here plays a different role. When the form encapsulates a set of input
    elements (such as input, textarea, and select) it provides an API for:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的表单扮演着不同的角色。当表单封装一组输入元素（如input、textarea和select）时，它提供了一个API，用于：
- en: Determining the state of the form, such as whether the form is dirty or pristine
    based on the input controls on it
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 根据其上的输入控件确定表单的状态，例如表单是脏的还是原始的。'
- en: Checking validation errors at the form or control level
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '- 在表单或控件级别检查验证错误'
- en: If you still want the standard form behavior, you can add an `ngNoForm` attribute
    to the `form` element, but this will definitely cause a full-page refresh. You
    can also turn on the browser's inbuilt validation by adding the `ngNativeValidate`
    attribute. We'll explore the specifics of the `NgForm` API a little later in this
    chapter when we look at saving the form and implementing validation.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然希望使用标准表单行为，可以在`form`元素上添加`ngNoForm`属性，但这肯定会导致整个页面刷新。您还可以通过添加`ngNativeValidate`属性来启用浏览器的内置验证。在本章稍后，当我们查看保存表单和实现验证时，我们将更详细地探讨`NgForm`
    API的具体内容。
- en: The state of the `FormControl` objects within the form is being monitored by
    `NgForm`. If any of them are invalid, then `NgForm` sets the entire form to invalid.
    In this case, we have been able to use `NgForm` to determine that one or more
    of the `FormControl` objects is invalid and therefore the state of the form as
    a whole is invalid too.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`NgForm`通过监视表单中的`FormControl`对象的状态。如果其中任何一个无效，那么`NgForm`会将整个表单设置为无效。在这种情况下，我们已经能够使用`NgForm`来确定一个或多个`FormControl`对象是无效的，因此整个表单的状态也是无效的。'
- en: Let's look at one more issue before we finish this chapter.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章之前，让我们再看一个问题。
- en: Fixing the saving of forms and validation messages
  id: totrans-523
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复表单保存和验证消息
- en: 'Open a new Workout page and directly click on the Save button. Nothing is saved
    as the form is invalid, but validations on individual form input do not show up
    at all. It now becomes difficult to know what elements have caused validation
    failure. The reason behind this behavior is pretty obvious. If we look at the
    error message binding for the name input element, it looks like this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个新的Workout页面，直接单击保存按钮。由于表单无效，什么都没有保存，但是单个表单输入的验证并没有显示出来。现在很难知道哪些元素导致了验证失败。这种行为背后的原因非常明显。如果我们看一下名称输入元素的错误消息绑定，它看起来像这样：
- en: '[PRE69]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Remember that, earlier in the chapter, we explicitly disabled showing validation
    messages until the user has touched the input control. The same issue has come
    back to bite us and we need to fix it now.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在本章的前面，我们明确禁用了在用户触摸输入控件之前显示验证消息的功能。同样的问题又出现了，我们现在需要修复它。
- en: 'We do not have a way to explicitly change the touched state of our controls
    to untouched. Instead, we will resort to a little trickery to get the job done.
    We''ll introduce a new property called `submitted`. Add it at the top of the `Workout`
    class definition and set its initial value to `false`, like so:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有办法显式地将控件的触摸状态更改为未触摸状态。相反，我们将采取一些诡计来完成这项工作。我们将引入一个名为`submitted`的新属性。将其添加到`Workout`类定义的顶部，并将其初始值设置为`false`，如下所示：
- en: '[PRE70]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The variable will be set to `true` on the Save button click. Update the save
    implementation by adding the highlighted code:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 单击保存按钮后，变量将设置为`true`。通过添加下面突出显示的代码来更新保存实现：
- en: '[PRE71]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'However, how does this help? Well, there is another part to this fix that requires
    us to change the error message for each of the controls we are validating. The
    expression now changes to:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这有什么帮助呢？嗯，这个修复还有另一个部分，需要我们更改每个正在验证的控件的错误消息。表达式现在变成了：
- en: '[PRE72]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: With this fix, the error message is shown when the control is touched or the
    form submit button is pressed (`submitted` is `true`). This expression fix now
    has to be applied to every validation message where a check appears.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个修复，当控件被触摸或表单提交按钮被按下时（`submitted`为`true`），错误消息将被显示。现在，这个表达式修复现在必须应用于出现检查的每个验证消息。
- en: 'If we now open the new Workout page and click on the Save button, we should
    see all validation messages on the input controls:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在打开新的Workout页面并单击保存按钮，我们应该看到所有输入控件上的验证消息：
- en: '![](Images/39735e3a-1907-4f9b-b1c6-b619a72a9c98.png)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/39735e3a-1907-4f9b-b1c6-b619a72a9c98.png)'
- en: Reactive forms
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应式表单
- en: The other type of form that Angular supports is called **reactive** forms. **Reactive
    forms** start with a model that is constructed in a component class. With this
    approach, we use the **form builder API** to create a form in code and associate
    it with a model.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: Angular支持的另一种表单类型称为**响应式**表单。**响应式表单**从在组件类中构建的模型开始。通过这种方法，我们使用**表单构建器API**在代码中创建一个表单并将其与模型关联起来。
- en: Given the minimal code we have to write to get template-driven forms working,
    why and when should we consider using reactive forms? There are several situations
    in which we might want to use them. These include cases where we want to take
    programmatic control of creating the form. This is especially beneficial, as we
    will see, when we are trying to create form controls dynamically based on data
    we are retrieving from the server.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们必须编写的最小代码来使模板驱动的表单工作，为什么以及何时应该考虑使用响应式表单？有几种情况下我们可能想要使用它们。这些情况包括我们想要以编程方式控制创建表单的情况。特别是当我们试图根据从服务器检索的数据动态创建表单控件时，这是特别有益的。
- en: If our validation gets complicated, it is often easier to handle it in code.
    Using reactive forms, we can keep this complicated logic out of the HTML template,
    making the template syntax simpler.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的验证变得复杂，通常更容易在代码中处理它。使用响应式表单，我们可以将这种复杂的逻辑从HTML模板中剥离出来，使模板语法更简单。
- en: Another significant advantage of reactive forms is that they make unit-testing
    the form possible, which is not the case with **template-driven forms.** We can
    simply instantiate our form controls in our tests and then test them outside the
    markup on our page.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式表单的另一个重要优势是，它们使得对表单进行单元测试成为可能，而这在**模板驱动表单**中并非如此。我们可以在测试中简单地实例化我们的表单控件，然后在页面上的标记之外对它们进行测试。
- en: '**Reactive forms** use three new form directives that we haven''t discussed
    before: `FormGroup`, `FormControl`, and `FormArray`. These directives allow the
    form object that is constructed in code to be tied directly to the HTML markup
    in the template. The form controls that are created in the component class are
    then directly available in the form itself. Technically speaking, this means that
    we don''t need to use `ngModel` (which is integral to template-driven forms) with
    reactive forms (although it can be used). The overall approach is a cleaner and
    less cluttered template with more focus on the code that drives the form. Let''s
    get started with building a reactive form.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**响应式表单**使用了三个我们之前没有讨论过的新表单指令：`FormGroup`、`FormControl`和`FormArray`。这些指令允许在代码中构建的表单对象直接与模板中的HTML标记绑定。在组件类中创建的表单控件随后直接在表单本身中可用。从技术上讲，这意味着我们不需要在响应式表单中使用`ngModel`（这是模板驱动表单的一部分），尽管它可以使用。总体的方法是一个更清洁、更简洁的模板，更加关注驱动表单的代码。让我们开始构建一个响应式表单。'
- en: Getting started with reactive forms
  id: totrans-542
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用响应式表单
- en: We'll make use of reactive forms to build the form to add and edit Exercises.
    Among other things, this form will allow the user to add links to exercise videos
    on YouTube. And since they can add any number of video links, we will need to
    be able to add controls for these video links dynamically. This challenge will
    present a good test of how effective reactive forms can be in developing more
    complex forms.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用响应式表单来构建添加和编辑练习的表单。除其他事项外，这个表单将允许用户在YouTube上添加练习视频的链接。而且，由于他们可以添加任意数量的视频链接，我们需要能够动态添加这些视频链接的控件。这个挑战将是测试响应式表单在开发更复杂表单时的有效性的一个很好的测试。
- en: 'Here is how the form will look:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表单的样子：
- en: '![](Images/5dbd17b9-5bcb-41b1-b46d-5f1260402003.png)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5dbd17b9-5bcb-41b1-b46d-5f1260402003.png)'
- en: 'To get started, open `workout-builder.module.ts` and add the following `import`:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请打开`workout-builder.module.ts`并添加以下`import`：
- en: '[PRE73]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`ReactiveFormsModule` contains what we will need to build reactive forms.'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactiveFormsModule`包含了我们构建响应式表单所需的内容。'
- en: 'Next, copy `exercise-builder-service.ts` from the `workout-builder/builder-services`
    folder under `trainer/src/app` in `checkpoint 4.6` and import it into `workout-builder.module.ts`:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从`checkpoint 4.6`中的`trainer/src/app`下的`workout-builder/builder-services`文件夹中复制`exercise-builder-service.ts`并将其导入到`workout-builder.module.ts`中：
- en: '[PRE74]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Then, add it as an additional provider to the providers array in that same
    file:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在同一文件中的providers数组中将其添加为额外的提供者：
- en: '[PRE75]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You will notice here that we also have added `ExerciseResolver` as a provider.
    We won't be covering that here, but you should copy it from the `exercise` folder
    as well and also copy the updated `workout-builder-routing.module.ts`, which adds
    it as a route guard for the navigation to `ExerciseComponent`.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们还添加了`ExerciseResolver`作为提供者。我们不会在这里涵盖它，但您也应该从`exercise`文件夹中复制它，并复制更新后的`workout-builder-routing.module.ts`，将其添加为导航到`ExerciseComponent`的路由守卫。
- en: 'Now, open `exercise.component.ts` and add the following import statement:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开`exercise.component.ts`并添加以下导入语句：
- en: '[PRE76]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This brings in the following, which we will use to construct our form:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了以下内容，我们将使用它来构建我们的表单：
- en: '`FormBuilder`'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormBuilder`'
- en: '`FormGroup`'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormGroup`'
- en: '`FormControl`'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormControl`'
- en: '`FormArray`'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormArray`'
- en: 'Finally, we inject `FormBuilder` (as well as `Router`, `ActivatedRoute`, and
    `ExerciseBuilderService`) into the constructor of our class:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将`FormBuilder`（以及`Router`，`ActivatedRoute`和`ExerciseBuilderService`）注入到我们类的构造函数中：
- en: '[PRE77]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: With these preliminary steps out of the way, we can now go ahead and start building
    out our form.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些初步步骤后，我们现在可以开始构建我们的表单了。
- en: Using the FormBuilder API
  id: totrans-564
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FormBuilder API
- en: 'The `FormBuilder` API is the foundation for reactive forms. You can think of
    it as a factory for turning out the forms we are constructing in our code. Go
    ahead and add the `ngOnInit` lifecycle hook to your class, as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormBuilder` API是构建响应式表单的基础。您可以将其视为一个工厂，用于在我们的代码中构建表单。继续将`ngOnInit`生命周期钩子添加到您的类中，如下所示：'
- en: '[PRE78]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When `ngOnInit` fires, it will extract the data for an existing or new `exercise`
    from the route data that has been retrieved and returned by `ExerciseResolver`.
    This is the same pattern we followed with initializing the `Workout` component.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ngOnInit`触发时，它将从已检索和返回的路由数据中提取现有或新的`exercise`的数据，该数据由`ExerciseResolver`返回。这与初始化`Workout`组件时遵循的模式相同。
- en: 'Now, let''s implement the `buildExerciseForm` method by adding the following
    code:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过添加以下代码来实现`buildExerciseForm`方法：
- en: '[PRE79]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Let''s examine this code. To start with, we are using the injected instance
    of `FormBuilder` to construct the form and assign it to a local variable, `exerciseForm`.
    Using `formBuilder.group`, we add several form controls to our form. We add each
    of them by a simple key/value mapping:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这段代码。首先，我们使用注入的`FormBuilder`实例来构建表单并将其分配给一个本地变量`exerciseForm`。使用`formBuilder.group`，我们向我们的表单添加了几个表单控件。我们通过简单的键/值映射添加了每个控件：
- en: '[PRE80]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The left side of the mapping is the name of the `FormControl`, and the right
    is an array containing as its first element the value of the control (in our case,
    the corresponding element on our exercise model) and the second a validator (in
    this case, the out-of-the-box required validator). Nice and neat! It's definitely
    easier to see and reason about our form controls by setting them up outside the
    template.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 映射的左侧是`FormControl`的名称，右侧是一个数组，其第一个元素是控件的值（在我们的情况下是我们的exercise模型上对应的元素），第二个是验证器（在这种情况下是现成的required验证器）。清晰明了！通过在模板外部设置它们，可以更容易地查看和理解我们的表单控件。
- en: 'We can not only build up `FormControls` in our form this way but also add `FormControlGroups`
    and `FormControlArray`, which contain `FormControls` within them. This means we
    can create complex forms that contain nested input controls. In our case, as we
    have mentioned, we are going to need to accommodate the possibility of our users
    adding multiple videos to an exercise. We can do this by adding the following
    code:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以以这种方式在我们的表单中构建`FormControls`，还可以添加包含其中的`FormControls`的`FormControlGroups`和`FormControlArray`。这意味着我们可以创建包含嵌套输入控件的复杂表单。在我们的情况下，正如我们已经提到的，我们需要考虑用户可能向练习中添加多个视频的可能性。我们可以通过添加以下代码来实现这一点：
- en: '[PRE81]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'What we are doing here is assigning a `FormArray` to videos, which means we
    can assign multiple controls in this mapping. To construct this new `FormArray`,
    we add the following `addVideoArray` method to our class:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将`FormArray`分配给视频，这意味着我们可以在这个映射中分配多个控件。为了构建这个新的`FormArray`，我们在我们的类中添加了以下`addVideoArray`方法：
- en: '[PRE82]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This method constructs a `FormControl` for each video; each is then added each
    to a `FormArray` that is assigned to the videos control in our form.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法为每个视频构建一个`FormControl`；然后将每个`FormControl`添加到我们表单中的视频控件中的`FormArray`中。
- en: Adding the form model to our HTML view
  id: totrans-578
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单模型添加到我们的HTML视图
- en: 'So far, we have been working behind the scenes in our class to construct our
    form. The next step is to wire up our form to the view. To do this, we use the
    same controls that we used to build the form in our code: `formGroup`, `formControl`,
    and `formArray`.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在我们的类中幕后工作，构建我们的表单。下一步是将我们的表单与视图连接起来。为此，我们使用了与在代码中构建表单时相同的控件：`formGroup`、`formControl`和`formArray`。
- en: 'Open `exercise.component.html` and add a `form` tag as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`exercise.component.html`，并添加一个`form`标签如下：
- en: '[PRE83]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Within the tag, we are first assigning the `exerciseForm` that we just built
    in code to `formGroup`. This establishes the connection between our coded model
    and the form in the view. We also wire up the `ngSubmit` event to an `onSubmit`
    method in our code (we'll discuss this method a little later).
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 在标签内，我们首先将我们刚刚在代码中构建的`exerciseForm`分配给`formGroup`。这样就建立了我们编码模型和视图中的表单之间的连接。我们还将`ngSubmit`事件与我们代码中的`onSubmit`方法绑定（稍后我们将讨论这个方法）。
- en: Adding form controls to our form inputs
  id: totrans-583
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将表单控件添加到我们的表单输入
- en: 'Next, we start constructing the inputs for our form. We''ll start with the
    input for the name of our exercise:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始构建我们表单的输入。我们将从练习名称的输入开始：
- en: '[PRE84]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: We assign the name of our coded form control to `formControlName`. This establishes
    the link between the control in our code and the `input` field in the markup.
    Another item of interest here is that we do not use the `required` attribute.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们编码的表单控件的名称分配给`formControlName`。这样就建立了我们代码中的控件与标记中的`input`字段之间的链接。这里还有一件有趣的事情是，我们没有使用`required`属性。
- en: Adding validation
  id: totrans-587
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加验证
- en: 'The next thing that we do is add a validation message to the control that will
    display in the event of a validation error:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要做的是向将在验证错误发生时显示的控件添加验证消息：
- en: '[PRE85]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that this markup is very similar to what we used in template-driven forms
    for validation, except that the syntax for identifying the control is somewhat
    more verbose Again, it checks the state of the `hasError` property of the control
    to make sure it is valid.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个标记与我们在模板驱动表单中用于验证的标记非常相似，只是用于识别控件的语法有点更冗长。同样，它检查控件的`hasError`属性的状态，以确保它是有效的。
- en: 'But wait a minute! How can we validate this input? Haven''t we removed the
    required attribute from our tag? This is where the control mappings that we added
    in our code come into play. If you look back at the code for the form model, you
    can see the following mapping for the `name` control:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 但等一下！我们如何验证这个输入？我们不是已经从标签中删除了required属性吗？这就是我们在代码中添加的控制映射发挥作用的地方。如果你回顾一下表单模型的代码，你会看到`name`控件的以下映射：
- en: '[PRE86]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The second element in the mapping array assigns the required validator to the
    name form control. This means that we don't have to add anything to our template;
    instead, the form control itself is attached to the template with a required validator.
    The ability to add a validator in our code enables us to conveniently add validators
    outside our template. This is especially useful when it comes to writing custom
    validators with complex logic behind them.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 映射数组中的第二个元素将必填验证器分配给了名字表单控件。这意味着我们不必在模板中添加任何内容；相反，表单控件本身附加了一个必填验证器到模板中。在我们的代码中添加验证器的能力使我们能够方便地在模板之外添加验证器。当涉及编写具有复杂逻辑的自定义验证器时，这是特别有用的。
- en: Adding dynamic form controls
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加动态表单控件
- en: 'The Exercise form that we are building requires that we allow the user to add
    one or more videos to the exercise. Since we don''t know how many videos the user
    may want to add, we will have to build the `input` fields for these videos dynamically
    as the user clicks on the Add Video button. Here''s how it will look:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建的练习表单要求允许用户向练习中添加一个或多个视频。由于我们不知道用户可能想要添加多少个视频，我们将不得不在用户点击“添加视频”按钮时动态构建这些视频的`input`字段。它会是这个样子：
- en: '![](Images/94aa6524-5112-41ea-8ce0-6c9e622cdce8.png)'
  id: totrans-596
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/94aa6524-5112-41ea-8ce0-6c9e622cdce8.png)'
- en: We have already seen the code in our component class that we use to do this.
    Now, let's take a look at how it is implemented in our template.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在组件类中看到了用于执行此操作的代码。现在，让我们看看它是如何在模板中实现的。
- en: 'We first use `ngFor` to loop through our list of videos. Then, we assign the
    index in our videos to a local variable, `i`. No surprises so far:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用`ngFor`循环遍历我们的视频列表。然后，我们将视频的索引分配给一个本地变量`i`。到目前为止没有什么意外：
- en: '[PRE87]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Inside the loop, we do three things. First, we dynamically add a video `input` field
    for each of the videos currently in our exercise:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 循环内部，我们做三件事。首先，我们为当前练习中的每个视频动态添加一个视频`input`字段：
- en: '[PRE88]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Next, we add a button to allow the user to delete a video:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加一个按钮，允许用户删除一个视频：
- en: '[PRE89]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We bind a `deleteVideo` method in our component class to the button's `click`
    event and pass to it the index of the video being deleted.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个`deleteVideo`方法绑定到组件类中的按钮的`click`事件，并将视频的索引传递给它。
- en: 'We then add a validation message for each of the video `input` fields:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们为每个视频`input`字段添加验证消息：
- en: '[PRE90]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The validation message follows the same pattern for displaying the message that
    we have used elsewhere in this chapter. We drill into the `exerciseFormControls`
    group to find the particular control by its index. Again, the syntax is verbose
    but easy enough to understand.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 验证消息遵循了在本章其他地方使用的显示消息的相同模式。我们深入到`exerciseFormControls`组中，通过索引找到特定的控件。再次，语法冗长但足够容易理解。
- en: Saving the form
  id: totrans-608
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存表单
- en: 'The final step in building out our reactive form is to handle saving the form.
    When we constructed the form tag earlier, we bound the `ngSubmit` event to the
    following `onSubmit` method in our code:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 构建响应式表单的最后一步是处理保存表单的操作。当我们之前构建表单标签时，我们将`ngSubmit`事件绑定到了我们代码中的以下`onSubmit`方法：
- en: '[PRE91]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This method sets `submitted` to `true`, which will trigger the display of any
    validation messages that might have been previously hidden because the form had
    not been touched. It also returns without saving in the event that there are any
    validation errors on the form. If there are none, then it calls the following
    `mapFormValues` method, which assigns the values from our form to the `exercise`
    that will be saved:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将`submitted`设置为`true`，这将触发任何之前因表单未被触摸而隐藏的验证消息的显示。如果表单上有任何验证错误，则它也会返回而不保存。如果没有错误，则调用以下`mapFormValues`方法，该方法将我们表单中的值分配给将要保存的`exercise`：
- en: '[PRE92]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: It then calls the save method in `ExerciseBuilderService` and routes the user
    back to the exercise list screen (remember that any new exercise will not display
    in that list because we have not yet implemented data persistence in our application).
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 然后它调用`ExerciseBuilderService`中的保存方法，并将用户路由回练习列表屏幕（请记住，任何新练习都不会显示在该列表中，因为我们尚未在我们的应用程序中实现数据持久性）。
- en: We hope this makes it clear; reactive forms offer many advantages when we are
    trying to build more complicated forms. They allow programming logic to be removed
    from the template. They permit validators to be added to the form programmatically.
    And, they support building forms dynamically at runtime.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这一点很清楚；当我们试图构建更复杂的表单时，响应式表单提供了许多优势。它们允许将编程逻辑从模板中移除。它们允许以编程方式向表单添加验证器。而且，它们支持在运行时动态构建表单。
- en: Custom validators
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义验证器
- en: Now, we'll take a look at one more thing before we conclude this chapter. As
    anyone who has worked on building web forms (either in Angular or any other web
    technology) knows, we are often called on to create validations that are unique
    to the application we are building. Angular provides us with the flexibility to
    enhance our reactive form validation by building custom validators.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们结束本章之前，让我们再看一件事。任何在构建Web表单（无论是在Angular还是其他任何Web技术中）上工作过的人都知道，我们经常需要创建特定于我们正在构建的应用程序的验证。Angular为我们提供了灵活性，通过构建自定义验证器来增强我们的响应式表单验证。
- en: In building our exercise form, we need to be sure about what is entered, as
    a name contains only alphanumeric characters and no spaces. This is because when
    we get to storing the exercises in a remote data store, we are going to use the
    name of the exercise as its key. So, in addition to the standard required field
    validator, let's build another validator that checks to make sure that the name
    entered is in alphanumeric form only.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的练习表单时，我们需要确保输入的内容，因为名称只包含字母数字字符，不包含空格。这是因为当我们开始将练习存储在远程数据存储中时，我们将使用练习的名称作为其键。因此，除了标准的必填字段验证器之外，让我们构建另一个验证器，以确保输入的名称只是字母数字形式。
- en: 'Creating a custom control is quite straightforward. In its simplest form, an
    Angular custom validator is a function that takes a control as an input parameter,
    runs the validation check, and returns true or false. So, let''s start by adding
    a TypeScript file with the name `alphanumeric-validator.ts`. In that file, first
    import `FormControl` from `@angular/forms`, then add the following class to that
    file:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义控件非常简单。在其最简单的形式中，Angular自定义验证器是一个以控件作为输入参数的函数，运行验证检查，并返回true或false。因此，让我们首先添加一个名为`alphanumeric-validator.ts`的TypeScript文件。在该文件中，首先从`@angular/forms`导入`FormControl`，然后将以下类添加到该文件中：
- en: '[PRE93]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The code follows the pattern for creating a validator that we just mentioned.
    The only thing that may be a little surprising is that it returns true when the
    validation fails! As long as you are clear on this one quirk, you should have
    no problem writing your own custom validator.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 代码遵循了我们刚提到的创建验证器的模式。唯一可能有点令人惊讶的是，当验证失败时它返回true！只要你清楚了这个怪癖，你就应该没有问题编写自己的自定义验证器。
- en: Integrating a custom validator into our forms
  id: totrans-621
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义验证器集成到我们的表单中
- en: 'So how do we plug our custom validator into our form? If we are using reactive
    forms, the answer is pretty simple. We add it just like a built-in validator when
    we build our form in code. Let''s do that. Open `exercise.component.ts` and first
    add an import for our custom validator:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们如何将自定义验证器插入到我们的表单中呢？如果我们使用响应式表单，答案非常简单。当我们在代码中构建表单时，我们将它添加到内置验证器的方式一样。让我们这样做。打开`exercise.component.ts`并首先为我们的自定义验证器添加一个导入：
- en: '[PRE94]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Then, modify the form builder code to add the validator to the `name` control:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，修改表单构建器代码以将验证器添加到`name`控件中：
- en: '[PRE95]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Since the name control already has a required validator, we add `AlphaNumericValidator`
    as a second validator using an array that contains both validators. The array
    can be used to add any number of validators to a control.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称控件已经具有必填验证器，我们使用包含两个验证器的数组将`AlphaNumericValidator`作为第二个验证器添加。该数组可用于向控件添加任意数量的验证器。
- en: 'The final step is to incorporate the appropriate validation message for the
    control into our template. Open `workout.component.html` and add the following
    label just below the label that displays the message for the required validator:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将控件的适当验证消息合并到我们的模板中。打开`workout.component.html`并在显示必填验证器消息的标签下方添加以下标签：
- en: '[PRE96]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The exercise screen will now display a validation message if a non-alphanumeric
    value is entered in the name input box:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在名称输入框中输入了非字母数字值，练习屏幕现在将显示验证消息：
- en: '![](Images/62930377-9559-4807-8c6f-b86049e996e2.png)'
  id: totrans-630
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/62930377-9559-4807-8c6f-b86049e996e2.png)'
- en: As we hope you can see, reactive forms give us the ability to add custom validators
    to our forms in a straightforward manner that allows us to maintain the validation
    logic in our code and easily integrate it into our templates.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们希望您所看到的，响应式表单使我们能够以简单的方式向我们的表单添加自定义验证器，这样我们就可以在我们的代码中维护验证逻辑并轻松地将其集成到我们的模板中。
- en: You may have noticed that in this chapter, we have not covered how to use custom
    validators in template-driven forms. That is because implementing them requires
    the additional step of building a custom directive. We'll cover that in [Chapter
    4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular Directives in Depth*.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在本章中，我们还没有涵盖如何在模板驱动的表单中使用自定义验证器。这是因为实现它们需要额外的步骤来构建自定义指令。我们将在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中介绍*深入理解Angular指令*。
- en: Configuration options for running validation
  id: totrans-633
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行验证的配置选项
- en: Before we move on from validation, there is one more topic to cover and that
    is configuration options for running the validations. So far, we have been using
    the default option, which runs validation checks on every input event. However,
    you have the choice of configuring them to run either on "blur"(that is when the
    user leaves an input control) or when the form is submitted. You can set this
    configuration at the form level or on a control-by-control basis.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开验证之前，还有一个主题要涵盖，那就是运行验证的配置选项。到目前为止，我们一直使用默认选项，即在每次输入事件上运行验证检查。但是，您可以选择将它们配置为在“失焦”（即用户离开输入控件时）或在提交表单时运行。您可以在表单级别或逐个控件的基础上设置此配置。
- en: 'For example, we might decide that to avoid the complexity of handling missing
    exercises in the workout form, we will set that form to validate only upon submit.
    We can set this by adding the following highlighted assignment of `NgFormOptions`
    to the form tag:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能决定为了避免在锻炼表单中处理缺少的练习的复杂性，我们将设置该表单仅在提交时进行验证。我们可以通过将以下突出显示的`NgFormOptions`分配到表单标签中来设置这一点：
- en: '[PRE97]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This instructs Angular to run our validations only upon `submit`. Try it and
    you’ll see that no validations appear when you make entries into the form. Leave
    the form blank and press the Save button, and you will see the validation messages
    appear. Taking this approach, of course, means that there are no visual cues to
    the user regarding validation until they press the Save button.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示Angular仅在`submit`时运行我们的验证。试一试，你会发现当你在表单中输入时，不会出现任何验证。留空表单并按保存按钮，你会看到验证消息出现。当然，采取这种方法意味着用户在按保存按钮之前不会有关于验证的视觉提示。
- en: There are also a couple of other unintended side effects to using this approach
    in our form. The first is that the title no longer updates at the top of the screen
    as we type into the title input box. That value will only be updated when we press
    Save. Second, you will also see a validation message appear if you add one or
    more workouts and then remove all of them. This is because of the special conditions
    we set up for this control, which cause it to fire outside the normal validation
    flow.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的表单中使用这种方法还会产生一些意想不到的副作用。首先，当我们在标题输入框中输入时，标题不再在屏幕顶部更新。只有当我们按保存时，该值才会更新。其次，如果您添加一个或多个锻炼，然后将它们全部删除，您还会看到一个验证消息出现。这是因为我们为该控件设置了特殊条件，导致它在正常验证流程之外触发。
- en: 'So, maybe we should take a different approach. Angular provides the option
    of implementing more fine-grained control of the validation flow by allowing us
    to make such configurations at the control level using `ngModelOptions`. For example,
    let’s remove the `ngFormOptions` assignment from the form tag and modify the title
    input control to add `ngModelOptions` as follows:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，也许我们应该采取不同的方法。Angular提供了实现更精细的验证流程控制的选项，允许我们在控件级别使用`ngModelOptions`进行这样的配置。例如，让我们从表单标签中移除`ngFormOptions`赋值，并修改标题输入控件以添加`ngModelOptions`，如下所示：
- en: '[PRE98]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You’ll then notice that as you type the title into the input box, it does not
    update the title on the screen until you move off it (which triggers the `updateOn`
    event):'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你会注意到，当你在输入框中输入标题时，直到你移开它（触发`updateOn`事件）它才不会更新屏幕上的标题：
- en: '![](Images/b8ffe1dc-c01d-4c0d-a100-d45672b67cfe.png)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/b8ffe1dc-c01d-4c0d-a100-d45672b67cfe.png)'
- en: As you will remember, the default option caused the title to update with every
    keystroke. This is a contrived example but it illustrates how the differences
    in these configurations work.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得，默认选项会导致标题随着每次按键而更新。这是一个刻意的例子，但它说明了这些配置之间的差异如何工作。
- en: 'You probably don’t see the need to use the on blur setting here. But, in case
    where you may be doing validation by calling an external data store, this approach
    could be helpful in limiting the number of calls that are being made. And making
    such remote calls is exactly what we will be doing in [Chapter 4](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml), *Angular
    Directives in Depth*, when we implement a custom directive. The directive will
    be checking for duplicate names that already exist in our remote data store. So,
    let’s remove this configuration from the title input control and place it instead
    on the name input control, like so:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得在这里使用on blur设置没有必要。但是，在可能需要通过调用外部数据存储进行验证的情况下，这种方法可以帮助限制调用的次数。在[第4章](c3725f08-81b4-4bd5-a50f-6173510dd9c6.xhtml)中，当我们实现自定义指令时，我们将会进行远程调用，这正是我们将要做的。该指令将检查远程数据存储中已经存在的重复名称。因此，让我们将这个配置从标题输入控件中移除，然后放到名称输入控件上，就像这样：
- en: '[PRE99]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We also can set the validation timing options within a reactive form. From
    what we have already learned about reactive forms, you will not be surprised to
    learn that we will be applying these settings in our code rather than the template.
    For example, to set them for a form group you use the following syntax:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在响应式表单中设置验证时间选项。根据我们已经学到的关于响应式表单的知识，您不会感到惊讶，我们将在我们的代码中应用这些设置，而不是在模板中。例如，要为表单组设置它们，您可以使用以下语法：
- en: '[PRE100]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can also apply them to individual form controls and that is what we will
    do in the case of our exercise form. Like the workout form, we will want to be
    able to validate the uniqueness of the name by making a remote call. So, we will
    want to limit the validation checking in a similar manner. We’ll do that by adding
    the following to the code that creates the name form control:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将它们应用于单个表单控件，这就是我们将在我们的锻炼表单中做的事情。与锻炼表单一样，我们希望能够通过进行远程调用来验证名称的唯一性。因此，我们希望以类似的方式限制验证检查。我们将通过向创建名称表单控件的代码添加以下内容来实现这一点：
- en: '[PRE101]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note that we are putting the setting, along with the `validators` array, in
    the options object inside a pair of curly braces.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将设置与`validators`数组一起放在大括号对内的选项对象中。
- en: Summary
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We now have a *Personal Trainer* app. The process of converting a specific *7
    Minute Workout* app to a generic *Personal Trainer* app helped us learn a number
    of new concepts. We started the chapter by defining the new app requirements.
    Then, we designed the model as a shared service.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了一个*个人教练*应用程序。将特定的*7分钟锻炼*应用程序转换为通用的*个人教练*应用程序的过程帮助我们学习了许多新概念。我们首先定义了新应用程序的要求。然后，我们将模型设计为共享服务。
- en: We defined some new views and corresponding routes for the *Personal Trainer*
    app. We also used both child and asynchronous routing to separate out *Workout
    Builder* from the rest of the app.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为*个人教练*应用程序定义了一些新视图和相应的路由。我们还使用了子路由和异步路由来将*锻炼构建器*与应用程序的其他部分分开。
- en: We then turned our focus to workout building. One of the primary technological
    focuses in this chapter was on Angular forms. The *Workout Builder* employed a
    number of form input elements and we implemented a number of common form scenarios
    using both template-driven and reactive forms. We also explored Angular validation
    in depth, and implemented a custom validator. We also covered configuring the
    timing options for running validation.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将焦点转向了锻炼建立。本章的主要技术重点之一是Angular表单。*锻炼构建器*使用了许多表单输入元素，并且我们使用了模板驱动和响应式表单来实现许多常见的表单场景。我们还深入探讨了Angular验证，并实现了自定义验证器。我们还介绍了配置运行验证的时间选项。
- en: The next chapter is all about client-server interaction. The workouts and exercises
    that we create need to be persisted. In the next chapter, we build a persistence
    layer, which will allow us to save workout and exercise data on the server.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将全面讨论客户端-服务器交互。我们创建的锻炼和锻炼需要被持久化。在下一章中，我们将构建一个持久化层，这将允许我们在服务器上保存锻炼和锻炼数据。
- en: Before we conclude this chapter, here is a friendly reminder. If you have not
    completed the exercise building routine for *Personal Trainer*, go ahead and do
    it. You can always compare your implementation with what has been provided in
    the companion code base. There are also things you can add to the original implementation,
    such as file uploads for the exercise image, and once you are more familiar with
    client-server interaction, a remote check to determine whether the YouTube videos
    actually exist.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本章之前，这里有一个友好的提醒。如果您还没有完成*个人教练*的锻炼建立例程，请继续进行。您可以随时将您的实现与伴随代码库中提供的内容进行比较。您还可以添加一些原始实现中没有的内容，比如为锻炼图片上传文件，以及一旦您更熟悉客户端-服务器交互，就可以进行远程检查以确定YouTube视频是否真的存在。
