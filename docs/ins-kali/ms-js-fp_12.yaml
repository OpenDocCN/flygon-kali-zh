- en: Building Better Containers - Functional Data Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建更好的容器-函数式数据类型
- en: 'In [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Implementing
    Design Patterns - The Functional Way*, we have gone over many ways of using functions
    to achieve different results, and in this chapter, we will go more deeply into
    data types from a functional point of view. We''ll be considering ways of actually
    implementing our own data types, with several features to help composing operations
    or ensuring purity, so your FP coding will become actually simpler and shorter.
    We''ll be touching on several themes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml) *以函数式方式实现设计模式* 中，我们已经讨论了使用函数实现不同结果的许多方法，在本章中，我们将更深入地从函数式角度考虑数据类型。我们将考虑实际实现自己的数据类型的方法，其中包括几个功能，以帮助组合操作或确保纯度，因此您的FP编码实际上会变得更简单和更短。我们将涉及几个主题：
- en: '**Data types** from a functional point of view, because even though JavaScript
    is not a typed language, a better understanding of types and functions are needed'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从函数式角度看数据类型**，因为即使JavaScript不是一种类型化的语言，也需要更好地理解类型和函数'
- en: '**Containers**, including *functors* and the mystifying *monads*, to better
    structure data flow'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**，包括*函子*和神秘的*单子*，以更好地结构化数据流'
- en: '**Functions as structures**, in which we''ll see yet another way of using functions
    to represent data types, with immutability thrown in as an extra'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数作为结构**，我们将看到另一种使用函数表示数据类型的方式，其中还加入了不可变性'
- en: Data types
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'Even though JavaScript is a dynamic language, without static or explicit typing
    declarations and controls, it doesn''t mean that you can simply ignore types.
    Even if the language doesn''t allow you to specify the types of your variables
    or functions, you still work --even if only in your head-- with types. Let''s
    now get into the theme of seeing how we can specify types, for that we will have
    at least some advantages:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 即使JavaScript是一种动态语言，没有静态或显式的类型声明和控制，也不意味着您可以简单地忽略类型。即使语言不允许您指定变量或函数的类型，您仍然会--即使只是在脑海中--使用类型。现在让我们来看看如何指定类型的主题，这样我们至少会有一些优势：
- en: Even if you don't have runtime data type checking, there are several tools,
    such as Facebook's *flow* static type checker or Microsoft's *TypeScript* language,
    which let you deal with it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使您没有运行时数据类型检查，也有一些工具，比如Facebook的*flow*静态类型检查器或Microsoft的*TypeScript*语言，可以让您处理它
- en: It will help if you plan to move on from JavaScript to a more functional language
    such as *Elm*
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您计划从JavaScript转移到更多的函数式语言，比如*Elm*，这将有所帮助
- en: It serves as documentation, to let future developers understand what type of
    arguments they have to pass to the function, and what type it will return. As
    an example of this, all the functions in the Ramda library are documented in this
    way
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它作为文档，让未来的开发人员了解他们必须传递给函数的参数的类型，以及它将返回的类型。例如，Ramda库中的所有函数都是以这种方式记录的
- en: It will also help with the functional data structures later in this section,
    where we will examine a way of dealing with structures, similar in some aspects
    to what you do in fully functional languages such as Haskell
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这也将有助于后面的函数数据结构，在这一部分中，我们将研究一种处理结构的方法，某些方面类似于您在Haskell等完全函数语言中所做的事情。
- en: If you want to learn more about the tools that I cited, visit [https://flow.org/](https://flow.org/)
    for flow, [https://www.typescriptlang.org/](https://www.typescriptlang.org/) for
    TypeScript, and [http://elm-lang.org/](http://elm-lang.org/) for Elm. If you directly
    want to know about type checks, the corresponding web pages are [https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/),
    [https://www.typescriptlang.org/docs/handbook/functions.html](https://www.typescriptlang.org/docs/handbook/functions.html),
    and [https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解我引用的工具，请访问[https://flow.org/](https://flow.org/)了解flow，[https://www.typescriptlang.org/](https://www.typescriptlang.org/)了解TypeScript，以及[http://elm-lang.org/](http://elm-lang.org/)了解Elm。如果您直接想了解类型检查，相应的网页是[https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/)，[https://www.typescriptlang.org/docs/handbook/functions.html](https://www.typescriptlang.org/docs/handbook/functions.html)，以及[https://flow.org/en/docs/types/functions/](https://flow.org/en/docs/types/functions/)
- en: Whenever you read or work with a function, you will have to reason about types,
    think about the possible operations on this or that variable or attribute, and
    so on. Having type declarations will help, so we shall now begin considering how
    we can define, most importantly, the types of functions and their parameters and
    result.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您阅读或使用函数时，您将不得不思考类型，考虑对这个或那个变量或属性的可能操作等。有类型声明将有所帮助，因此我们现在将开始考虑如何定义最重要的函数类型及其参数和结果。
- en: Signatures for functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的签名
- en: 'The specification of a function''s arguments and result, is given by a *signature*.
    Type signatures are based on a *type system* called Hindley-Milner, which influenced
    several (preferably functional) languages, including Haskell, though the notation
    has changed from that of the original paper. This system can even deduce types
    that are not directly given; tools such as TypeScript or Flow also do that kind
    of figuring out, so the developer need not specify *all* types. Instead of going
    for a dry, formal, explanation about the rules for writing correct signatures,
    let''s work by examples. We need to only know that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的参数和结果的规范由*签名*给出。类型签名基于一个名为Hindley-Milner的*类型系统*，它影响了几种（最好是函数式）语言，包括Haskell，尽管符号已经从原始论文中改变。这个系统甚至可以推断出不直接给出的类型；诸如TypeScript或Flow的工具也可以做到这种推断，因此开发人员不需要指定*所有*类型。与其去进行干燥、正式的解释关于编写正确签名的规则，我们不如通过例子来工作。我们只需要知道：
- en: We will be writing the type declaration as a comment.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将把类型声明写成注释。
- en: The function name is written first, and then `::` that can be read as *is of
    type* or *has type.*
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数名首先写出，然后是`::`，可以读作*是类型*或*具有类型*。
- en: Optional constraints may follow, with a double (*fat*) arrow `⇒` (or `=>` in
    basic ASCII fashion, if you cannot key in the arrow) afterwards.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选的约束条件可能会跟在之后，使用双（*粗*）箭头`⇒`（或者如果你无法输入箭头，则使用基本ASCII风格的`=>`）。
- en: The input type of the function follows, with a `→` (or `->` depending on your
    keyboard).
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的输入类型在箭头后面，使用`→`（或者根据你的键盘使用`->`）。
- en: The result type of the function comes last.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的结果类型最后出现。
- en: Note that instead of this vanilla JS style, Flow and TypeScript have their own
    syntax for specifying type signatures.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了这种普通的JS风格之外，Flow和TypeScript都有自己的语法来指定类型签名。
- en: 'Now we can begin with some examples:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始一些例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These are simple cases -- and mind the signatures; we are not interested in
    the actual functions here. The first function receives a string as an argument
    and returns a new string. The second one receives no arguments (the empty parentheses
    show this is so) and returns a floating point number. The arrows denote functions.
    So, we can read the first signature as `firstToUpper` *is a function of the type
    that receives a string and returns a string* and we can speak similarly about
    the maligned (impurity-wise) `Math.random()` function, with the only difference
    that it doesn't receive arguments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是简单的情况——注意签名；我们这里不关心实际的函数。第一个函数接收一个字符串作为参数，并返回一个新的字符串。第二个函数不接收参数（空括号表明如此），并返回一个浮点数。箭头表示函数。因此，我们可以将第一个签名解读为`firstToUpper`
    *是一个接收字符串并返回字符串的类型的函数*，我们也可以类似地谈论受到诟病（在纯度方面）的`Math.random()`函数，唯一的区别是它不接收参数。
- en: 'We saw functions with zero or one parameter: what about functions with more
    than one? There are two answers to this. If we are working in strict functional
    style, we would always be doing currying (as we saw in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*), so all functions
    would be unary. The other solution is enclosing a list of argument types in parentheses.
    We can see the following both ways:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了零个或一个参数的函数：那么多个参数的函数呢？对此有两个答案。如果我们在严格的函数式风格中工作，我们总是会进行柯里化（正如我们在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中看到的，*转换函数
    - 柯里化和部分应用*），因此所有函数都是一元的。另一个解决方案是将参数类型的列表括在括号中。我们可以这样看待以下两种方式：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first signature can also be read as:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个签名也可以解读为：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is correct when you remember the idea of currying. After you provide the
    first argument to the function, you are left with a new function, that also expects
    an argument, and returns a third function, which, when given an argument, will
    produce the final result. We won't be using parentheses because we'll always assume
    this grouping from right to left.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你记得柯里化的概念时，这是正确的。当你提供函数的第一个参数后，你会得到一个新的函数，它也期望一个参数，并返回一个第三个函数，当给定一个参数时，将产生最终结果。我们不会使用括号，因为我们总是假设从右到左进行分组。
- en: 'Now, what about higher-order functions, which receive functions as arguments?
    The `map()` function poses a problem: it works with arrays, but of any type. Also,
    the mapping function can produce any type of result. For these cases, we can specify
    *generic types*, identified by lower case letters: these generic types can stand
    for any possible type. For arrays themselves, we use brackets. So, we would have
    the following:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于接收函数作为参数的高阶函数呢？`map()`函数提出了一个问题：它可以处理任何类型的数组。此外，映射函数可以产生任何类型的结果。对于这些情况，我们可以指定*通用类型*，用小写字母表示：这些通用类型可以代表任何可能的类型。对于数组本身，我们使用方括号。因此，我们会有以下内容：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s perfectly valid to have *a* and *b* represent the same type, as in a
    mapping applied to an array of numbers, which produces another array of numbers.
    The point is that, in principle, *a* and *b* may stand for different types, and
    that''s what''s described previously. Also notice that if we weren''t currying,
    the signature would have been `([a], (a → b)) → [b]` showing a function that receives
    two arguments (an array of elements of type *a* and a function that maps from
    type *a* to type *b*) and produces an array of elements of type *b* as the result.
    Given this, we can write in a similar fashion the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*和*b*代表相同类型是完全有效的，就像应用于数字数组的映射会产生另一个数字数组一样。关键是，原则上*a*和*b*可以代表不同的类型，这就是之前描述的内容。还要注意，如果我们不进行柯里化，签名将是`([a],
    (a → b)) → [b]`，显示一个接收两个参数（类型为*a*的元素数组和从类型*a*到类型*b*的映射函数）并产生类型为*b*的元素数组作为结果的函数。鉴于此，我们可以以类似的方式写出以下内容：'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And, the big one: how''s the signature for `reduce()`? Be sure to read it carefully,
    and see if you can work out why it''s written that way. You may prefer thinking
    about the second part of the signature as if it were `((b, a) → b)`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个大问题：`reduce()`的签名是什么？一定要仔细阅读，看看你能否弄清楚为什么它是这样写的。你可能更喜欢将签名的第二部分看作`((b, a)
    → b)`：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, if you are defining a method instead of a function, you use a squiggly
    arrow such as `~>`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你定义的是一个方法而不是一个函数，你会使用一个类似`~>`的波浪箭头：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Other type options
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型选项
- en: 'What else are we missing? Let''s see some other options that you might use.
    *Union types* are defined as a list of possible values. For example, our `getField()`
    function from [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*, either returns the value of an attribute,
    or it returns undefined. We can then write the following signature:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还缺少什么？让我们看看你可能会使用的其他选项。*联合类型*被定义为可能值的列表。例如，我们在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中的`getField()`函数，*生成函数
    - 高阶函数*，要么返回属性的值，要么返回undefined。然后我们可以写出以下签名：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We could also define a type (union or otherwise) and later use it in further
    definitions. For instance, the data types that can be directly compared and sorted
    are numbers, strings, and booleans, so we could write the following definitions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义一个类型（联合类型或其他类型），然后在进一步的定义中使用它。例如，可以直接比较和排序的数据类型是数字、字符串和布尔值，因此我们可以写出以下定义：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Afterwards, we could specify that a comparison function could be defined in
    terms of the Sortable type... but be careful: there''s a hidden problem here!'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以指定比较函数可以根据可排序类型来定义...但要小心：这里存在一个隐藏的问题！
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Actually, this definition isn't quite precise, because you actually can compare
    any types, even if it doesn't make much sense. However, bear with me for the sake
    of the example! And if you want to refresh your memory about sorting and comparison
    functions, see [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这个定义并不太准确，因为实际上你可以比较任何类型，即使这并没有太多意义。然而，为了例子的完整性，请暂时忍耐！如果你想要回顾一下排序和比较函数，请参阅[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)。
- en: 'The last definition would allow writing a function that received, say, a Number
    and a Boolean: it doesn''t say that both types should be the same. However, there''s
    a way out. If you have constraints for some data types, you can express them before
    the actual signature, using a *fat* arrow:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的定义将允许编写一个函数，比如说，接收一个数字和一个布尔值：它并没有说这两种类型应该是相同的。然而，还是有办法的。如果对于某些数据类型有约束条件，你可以在实际签名之前表达它们，使用一个*胖*箭头：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the definition is correct because all occurrences of the same type (denoted
    by the same letter, in this case, *a*) must be exactly the same. An alternative,
    but requiring much more typing, would have been writing all the possibilities
    with a union:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在定义是正确的，因为所有相同类型的出现（在这种情况下，用相同的字母表示，*a*）必须完全相同。另一种选择，但需要更多的输入，是使用联合写出所有可能性：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So far, we have been using the standard type definitions. But, when we work
    with JavaScript, we have to consider some other possibilities, such as functions
    with optional parameters, or even with an undetermined number of parameters. We
    can use `...` to stand for any number of arguments, and an added `?` to represent
    an optional type:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用标准类型定义。但是，当我们使用JavaScript时，我们必须考虑一些其他可能性，比如带有可选参数的函数，甚至带有不确定数量的参数。我们可以使用`...`代表任意数量的参数，并添加`?`来表示可选类型：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `unary()` higher-order function that we defined in the same chapter cited
    previously, took as a parameter any function, and returned a unary function as
    its result: we can show that the original function could receive any number of
    arguments, but the result used only the first:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前引用的同一章节中定义的`unary()`高阶函数，它以任何函数作为参数，并返回一个一元函数作为其结果：我们可以表明原始函数可以接收任意数量的参数，但结果只使用第一个：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The standard `parseInt()` function provides an example of optional arguments:
    though it''s highly recommended not to omit the second parameter (the base radix)
    you can, in fact, skip it.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseInt()`函数提供了可选参数的示例：虽然强烈建议不要省略第二个参数（基数），但实际上可以跳过它。'
- en: Check out [https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/)
    and [https://sanctuary.js.org/#types](https://sanctuary.js.org/#types) for a more
    formal definition and description of types, as applied to JavaScript.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/)和[https://sanctuary.js.org/#types](https://sanctuary.js.org/#types)以获取更正式的类型定义和描述，应用于JavaScript。
- en: 'From now on, throughout this chapter, we will often be adding signatures to
    methods and functions. This will not only be so you can get accustomed to them,
    but because when we start delving into more complex containers, it will help to
    understand what we are dealing with: some cases can be hard to understand!'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在本章中，我们将经常为方法和函数添加签名。这不仅是为了让你习惯于它们，而且当我们开始深入研究更复杂的容器时，它将有助于理解我们正在处理的内容：有些情况可能很难理解！
- en: Containers
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: Back in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml), *Programming
    Declaratively - A Better Style*, and later in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, we saw that the ability of
    being able to apply a mapping to all the elements of an array, and, even better,
    being able to chain a sequence of similar operations, was a good way to produce
    better, more understandable code.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)，*声明式编程-更好的风格*，以及稍后的[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)，*连接函数-管道和组合*，我们看到能够将映射应用于数组的所有元素，甚至更好的是，能够链接一系列类似的操作，是生成更好、更易理解的代码的好方法。
- en: 'However, there is a problem: the `.map()` method (or the equivalent, *demethodized*
    one, as in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing
    Functions - Higher-Order Functions*), is available only for arrays, and we might
    want to be able to apply mappings and chaining to other data types. So, what can
    we do?'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，存在一个问题：`.map()`方法（或等效的*解方法*，如[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)，*生成函数-高阶函数*）仅适用于数组，我们可能希望能够将映射和链接应用于其他数据类型。那么，我们该怎么办呢？
- en: 'Let''s consider different ways of doing this, which will give us several new
    tools for better functional coding. Basically, there are only two possible ways
    of solving this: we can either add new methods to existing types (though that
    will be limited because we can apply that only to basic JS types) or we can wrap
    types in some type of container, which will allow mapping and chaining.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑不同的做法，这将为我们提供更好的功能编码工具。基本上，解决这个问题只有两种可能的方法：我们可以为现有类型添加新的方法（尽管这将受到限制，因为我们只能将其应用于基本的JS类型），或者我们可以将类型包装在某种类型的容器中，这将允许映射和链接。
- en: Let's start first by extending current types, and then move on to using wrappers,
    which will lead us into deep functional territory, with entities such as functors
    and monads.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先扩展当前类型，然后转而使用包装器，这将使我们进入深层的功能领域，涉及到诸如函子和单子等实体。
- en: Extending current data types
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展当前数据类型
- en: 'If we want to add mapping to basic JS data types, let''s start by considering
    our options:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将基本的JS数据类型添加映射，让我们首先考虑我们的选择：
- en: With `null`, `undefined`, and `Symbol`, applying maps doesn't sound too interesting
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`null`、`undefined`和`Symbol`，应用映射听起来并不太有趣
- en: With the `Boolean`, `Number`, and `String` data types, we have some interesting
    possibilities, so we can examine some of those
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于`Boolean`、`Number`和`String`数据类型，我们有一些有趣的可能性，因此我们可以检查其中一些
- en: 'Applying mapping to an object would be trivial: you just have to add a `.map()`
    method, which must return a new object'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将映射应用于对象将是微不足道的：你只需要添加一个`.map()`方法，它必须返回一个新对象
- en: Finally, despite not being basic data types, we could also consider special
    cases, such as dates or functions, to which we could also add `.map()` methods
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，尽管不是基本数据类型，我们也可以考虑特殊情况，比如日期或函数，我们也可以添加`.map()`方法
- en: As in the rest of the book, we are sticking to plain JS, but you should look
    into libraries such as LoDash, Underscore, or Ramda, which already provide functionalities
    such as we are developing here.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的其余部分一样，我们坚持使用纯JS，但是你应该查看诸如LoDash、Underscore或Ramda之类的库，它们已经提供了我们在这里开发的功能。
- en: 'A key point, in all these mapping operations, should be that the returned value
    is of exactly the same type as the original one: when we use `Array.map()`, the
    result is also an array, and similar considerations must apply to any other `.map()`
    implementations (you could observe that the resulting array may have different
    element types as the original one, but it still is an array).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些映射操作中，一个关键点应该是返回的值与原始值的类型完全相同：当我们使用`Array.map()`时，结果也是一个数组，任何其他`.map()`实现都必须遵循类似的考虑（你可以观察到生成的数组可能具有不同的元素类型，但它仍然是一个数组）。
- en: 'What could we do with a boolean? First, let''s accept that booleans are not
    containers, so they do not really behave in the same way as an array: trivially,
    a boolean can only have a boolean value, while an array may contain any type of
    elements. However, accepting that difference, we can extend the `Boolean.prototype`
    (though, as I''ve already mentioned, that''s not usually recommended) by adding
    a new `.map()` method to it, and make sure that whatever the mapping function
    returns is turned into a new boolean value. And, for the latter, the solution
    will be similar:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能对布尔值做什么？首先，让我们接受布尔值不是容器，因此它们的行为方式与数组不同：显然，布尔值只能有一个布尔值，而数组可以包含任何类型的元素。然而，接受这种差异，我们可以扩展`Boolean.prototype`（尽管，正如我已经提到的，这通常是不推荐的），通过向其添加一个新的`.map()`方法，并确保映射函数返回的任何内容都转换为新的布尔值。对于后者，解决方案将是类似的：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `!!` operator forces the result to be a boolean: `Boolean(fn(this))` could
    also have been used. This kind of solution can also be applied to numbers and
    strings:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`!!`运算符强制结果为布尔值：`Boolean(fn(this))`也可以使用。这种解决方案也可以应用于数字和字符串：'
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As with boolean values, we are forcing the results of the mapping operations
    to the correct data types.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 与布尔值一样，我们强制映射操作的结果为正确的数据类型。
- en: 'Finally, if we wanted to apply mappings to a function, what would that mean?
    Mapping a function should produce a function. The logical interpretation for `f.map(g)`
    would be first applying `f()`, and then applying `g()` to the result. So, `f.map(g)`
    should be the same as writing `x => g(f(x))` or equivalently, `pipe(f,g)`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果我们想将映射应用到一个函数，那意味着什么？映射一个函数应该产生一个函数。`f.map(g)`的逻辑解释应该是首先应用`f()`，然后将`g()`应用于结果。因此，`f.map(g)`应该与编写`x
    => g(f(x))`或等效地`pipe(f,g)`是相同的：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Verifying that this works, is simple:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 验证这是否有效很简单：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With this, we are done as to what we can do with basic JS types -- but we need
    a more general solution if we want to apply this to other data types. We'd like
    to be able to apply mapping to any kind of values, and for that, we'll need to
    create some container; let's do this.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们对基本的JS类型可以做的事情就完成了——但是如果我们想将这个应用到其他数据类型，我们需要一个更通用的解决方案。我们希望能够将映射应用到任何类型的值上，为此，我们需要创建一些容器；让我们来做这个。
- en: Containers and functors
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器和函子
- en: 'What we did in the previous section does work, and can be used with no problems.
    However, we would like to consider a more general solution, which we could apply
    to any data type. Since not all things in JS provide the desired `.map()` method,
    we will have to either extend the type (as we did in the previous section) or
    apply a design pattern that we considered in [Chapter 11](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml),
    *Implementing Design Patterns - The Functional Way*: wrapping our data types,
    with a wrapper that will provide the required `map()` operations.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中所做的确实有效，并且可以无问题地使用。然而，我们希望考虑一个更通用的解决方案，可以应用于任何数据类型。由于JS中并非所有东西都提供所需的`.map()`方法，我们将不得不扩展类型（就像我们在上一节中所做的那样），或者应用我们在[第11章](24b391f7-abaf-439e-9bfc-a71d989cfd48.xhtml)中考虑过的设计模式，*实现设计模式-函数式方法*：用一个包装器包装我们的数据类型，该包装器将提供所需的`map()`操作。
- en: 'Wrapping a value: a basic container'
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包装一个值：一个基本的容器
- en: 'Let''s pause a bit, and consider what we do need from this wrapper. There are
    two basic requirements:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，考虑一下我们需要这个包装器。有两个基本要求：
- en: We must have a `.map()` method
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须有一个`.map()`方法
- en: We need a simple way to wrap a value
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一种简单的方法来包装一个值
- en: 'Let''s create a basic container to get started with -- but we''ll require some
    changes:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的容器来开始——但我们需要做一些改变：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Some basic considerations:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一些基本的考虑：
- en: We want to be able to store some value in a container, so the constructor takes
    care of that
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望能够将一些值存储在容器中，因此构造函数会处理这个问题
- en: 'Using a `Symbol` helps to *hide* the field: the property key won''t show up
    in `Object.keys()` or in `for...in` or `for...of` loops, making them more *meddle-proof*'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Symbol`有助于*隐藏*字段：属性键不会显示在`Object.keys()`中，也不会显示在`for...in`或`for...of`循环中，使它们更加*不易干涉*
- en: We need to be able to `.map()`, so a method is provided for that
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够`.map()`，因此提供了一个方法
- en: 'Our basic barebones container is ready, but we can, however, add some other
    methods for convenience:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本容器已经准备好了，但是我们可以为方便起见添加一些其他方法：
- en: In order to get the value of a container, we could do `.map(x => x)`, but that
    won't work with more complex containers, so let's add a `.valueOf()` method to
    get the contained value
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了获取容器的值，我们可以使用`.map(x => x)`，但这对于更复杂的容器不起作用，所以让我们添加一个`.valueOf()`方法来获取包含的值
- en: 'Being able to list a container can certainly help with debugging: a `.toString()`
    method will come in handy'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够列出一个容器肯定有助于调试：`.toString()`方法会派上用场
- en: Because we need not write `new Container()` all the time, we can add a static
    `.of()` method to do the equivalent job
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为我们不需要一直写`new Container()`，我们可以添加一个静态的`.of()`方法来完成相同的工作。
- en: 'Working with classes to represent containers (and later functors and monads)
    when living in a functional programming world may seem like heresy or sin... but
    remember we do not want to be dogmatic, and `class` and `extends` simplify our
    coding. Similarly, it could be argued that you must never take a value out of
    the container -- but using `.valueOf()` is sometimes too handy, so it won''t be
    that restrictive.Our Container becomes as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当在函数式编程世界中使用类来表示容器（以及后来的函子和单子）可能看起来像异端邪说或罪恶...但请记住我们不想教条主义，`class`和`extends`简化了我们的编码。同样，可以说你绝不能从容器中取出一个值--但是使用`.valueOf()`有时太方便了，所以不会那么严格。我们的容器变成了这样：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, we can use this container to store a value, and we can use `.map()` to
    apply any function to that value... but this isn't very different to what we could
    do with a variable! Let's enhance this a bit.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用这个容器来存储一个值，并且我们可以使用`.map()`来对该值应用任何函数...但这与我们可以用变量做的事情并没有太大的不同！让我们再加强一点。
- en: 'Enhancing our container: functors'
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强我们的容器：函子
- en: We wanted to have wrapped values, so what exactly should return the `map()`
    method? If we want to be able to chain operations, then the only logical answer
    is that it should return a new wrapped object. In true functional style, when
    we apply a mapping to a wrapped value, the result will be another wrapped value,
    with which we can keep on working.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要包装值，那么`map()`方法到底应该返回什么？如果我们想要能够链接操作，那么唯一合乎逻辑的答案是它应该返回一个新的包装对象。在真正的函数式风格中，当我们对包装值应用映射时，结果将是另一个包装值，我们可以继续使用它。
- en: Instead of `.map()`, this operation is sometimes called `fmap()` standing for
    functorial map. The rationale for the name change was to avoid expanding the meaning
    of `.map()`. But, since we are working in a language that supports reusing the
    name, we can keep it.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作有时被称为`fmap()`，代表函子映射，而不是`.map()`。更改名称的原因是为了避免扩展`.map()`的含义。但是，由于我们正在使用支持重用名称的语言，我们可以保留它。
- en: 'We can extend our `Container` class to implement this change. The `.of()` method
    will require a small change:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的`Container`类来实现这个改变。`.of()`方法将需要一个小改变：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'With these properties, we have just defined what''s called a *Functor* in Category
    Theory! (Or, if you want to get really technical, a *Pointed Functor* because
    of the `.of()` method - but let''s keep it simple). We won''t go into the theoretical
    details, but roughly speaking, a functor is just some kind of container that allows
    applying `.map()` to its contents, producing a new container of the same type...
    and if this sounds familiar, it''s because you already know a functor: arrays!
    When you apply `.map()` to an array, the result is a new array, containing transformed
    (mapped) values.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些属性，我们刚刚定义了范畴论中所谓的*函子*！（或者，如果你想变得更加技术化，是*指向函子*，因为有`.of()`方法--但让我们保持简单）。我们不会深入理论细节，但粗略地说，函子只是一种允许对其内容应用`.map()`的容器，产生相同类型的新容器...如果这听起来很熟悉，那是因为你已经知道一个函子：数组！当你对数组应用`.map()`时，结果是一个新数组，包含转换（映射）后的值。
- en: 'There are more requirements for functors. First, the contained values may be
    polymorphic (of any types) as it happens with arrays. Second, there must exist
    a function, whose mapping produces the same contained value -- and `x => x` does
    this job. Finally, applying two consecutive mappings must produce the same result
    as applying their composition: `container.map(f).map(g)` must be the same as `container.map(compose(g,f))`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 函子还有更多要求。首先，包含的值可能是多态的（任何类型），就像数组一样。其次，必须存在一个函数，其映射产生相同的包含值--`x => x`就是这个工作。最后，连续应用两个映射必须产生与应用它们的组合相同的结果：`container.map(f).map(g)`必须与`container.map(compose(g,f))`相同。
- en: 'Let''s pause a moment to consider the signature for our function and methods:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下来考虑我们函数和方法的签名：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first function, `of()`, is the simplest: given a value of any type, it
    produces a functor of that type. The next two are also rather simple to understand:
    given a functor, `toString()` always returns a string (no surprise there!) and
    if the functor contained value is of some given type, `valueOf()` produces a result
    of that same type. The third one, `map()`, is more interesting. Given a function
    that takes an argument of type *a* and produces a result of type *b*, applying
    it to a functor that contains a value of type *a*, produces a functor containing
    a value of type *b* -- this is exactly what we described above.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`of()`是最简单的：给定任何类型的值，它产生该类型的函子。接下来的两个也很容易理解：给定一个函子，`toString()`总是返回一个字符串（毫无意外！），如果函子包含的值是某种给定类型，`valueOf()`产生相同类型的结果。第三个`map()`更有趣。给定一个接受类型为*a*的参数并产生类型为*b*的结果的函数，将其应用于包含类型为*a*的值的函子，产生包含类型为*b*的值的函子--这正是我们上面描述的。
- en: As is, functors are not allowed or expected to produce side effects, throw exceptions,
    or any other behavior outside from producing a containered result. Their main
    usage is to provide a way to manipulate a value, apply operations to it, compose
    results, and so on, without changing the original -- in this last sense we are
    once again coming back to immutability.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，函子不允许或期望产生副作用、抛出异常或任何其他行为，除了产生一个包含的结果。它们的主要用途是提供一种操作值、对其应用操作、组合结果等的方式，而不改变原始值--在这个意义上，我们再次回到了不可变性。
- en: You could also compare functors to promises, at least in one aspect. In functor,
    instead of acting on its value directly, you have to apply a function with `.map()`
    -- and in promises, you do exactly the same, but using `.then()` instead! In fact,
    there are more analogies, as we'll be seeing soon.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将函子与承诺进行比较，至少在一个方面是如此。在函子中，你不直接作用于其值，而是使用`.map()`应用函数——在承诺中，你也是这样做的，但是使用`.then()`！事实上，还有更多的类比，我们很快就会看到。
- en: However, you could well say that this isn't enough, since in normal programming
    it's quite usual having to deal with exceptions, undefined or null values, and
    so on. So, let's start seeing more examples of functors, and after a while, we'll
    be entering into the realms of monads, for even more sophisticated kinds of processing.
    So, let's now experiment a bit!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能会说这还不够，因为在正常的编程中，必须处理异常、未定义或空值等情况是非常常见的。因此，让我们开始看更多的函子示例，过一段时间，我们将进入单子的领域，进行更复杂的处理。所以，现在让我们进行一些实验！
- en: Dealing with missing values with Maybe
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maybe处理丢失的值
- en: 'A common problem in programming is dealing with missing values. There are many
    possible causes for this situation: a web service Ajax call may have returned
    an empty result, or a dataset could be empty, or an optional attribute might be
    missing from an object, and so on. Dealing with this kind of situation, in normal
    imperative fashion, requires adding `if` statements or ternary operators everywhere,
    to catch the possible missing value, avoiding a certain runtime error. We can
    do a bit better by implementing a `Maybe` functor, to represent a value that may
    be (or may *not* be) present! We will use two classes, `Just` (as in *just some
    value*) and `Nothing`, one for each functor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的一个常见问题是处理丢失的值。造成这种情况的可能原因有很多：Web服务Ajax调用可能返回空结果，数据集可能为空，或者对象中可能缺少可选属性，等等。在正常的命令式方式中处理这种情况需要在各处添加`if`语句或三元运算符，以捕获可能丢失的值，避免某种运行时错误。通过实现一个`Maybe`函子，我们可以做得更好，以表示可能存在（或可能*不存在*）的值！我们将使用两个类，`Just`（表示*刚好有些值*）和`Nothing`，每个函子一个：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can quickly verify that this works, by trying to apply an operation to either
    a valid value or a missing one:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过尝试将操作应用于有效值或丢失的值来快速验证这一点：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We just applied `plus1()` several times to a `Maybe.of(null)` value, and there
    was no error whatsoever. A `MayBe` functor can deal with mapping a missing value,
    by just skipping the operation, and returning a wrapped `null` value instead.
    This means that this functor is basically including an abstracted check, which
    won't let an error happen. Let's give a more realistic example of its usage.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚对`Maybe.of(null)`值多次应用了`plus1()`，完全没有错误。`MayBe`函子可以处理映射丢失的值，只需跳过操作，并返回一个包装的`null`值。这意味着这个函子基本上包括了一个抽象的检查，不会让错误发生。让我们举一个更现实的例子来说明它的用法。
- en: Later in the chapter, we'll see that Maybe can actually be a Monad instead of
    a Functor, and we'll also examine more examples of monads.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后面，我们将看到Maybe实际上可以是一个单子，而不是一个函子，并且我们还将研究更多的单子示例。
- en: 'Suppose we are writing a small server-side service in Node, and we want to
    get the alerts for a city, and produce a not very fashionable HTML `<table>` with
    them, supposedly to be part of some server-side produced web page (yes, I know
    you should try to avoid tables in your pages, but what I want here is a short
    example of HTML generation, and actual results aren''t really important). If we
    used the *Dark Sky* API (see [https://darksky.net/](https://darksky.net/) for
    more on this API, and to register for usage) to get the alarms, our code would
    be something like this; all quite normal... Do notice the callback in case of
    an error; you''ll see why in the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在Node中编写一个小的服务器端服务，并且我们想要获取某个城市的警报，并生成一个不太时尚的HTML `<table>`，假设它是某个服务器端生成的网页的一部分（是的，我知道你应该尽量避免在你的页面中使用表格，但我在这里想要的是一个HTML生成的简短示例，实际结果并不重要）。如果我们使用*Dark
    Sky* API（请参阅[https://darksky.net/](https://darksky.net/)了解更多关于此API的信息，并注册使用），来获取警报，我们的代码将是这样的；都很正常...请注意错误的回调；你将在下面的代码中看到原因：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The (heavily edited and reduced in size) output of such a call, might be something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这样调用的输出（经过大幅编辑和缩小）可能是这样的：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'I got this information for Houston, TX, US, on a day when Hurricane Harvey
    was approaching the state. If you called the API on a normal day, the data would
    simply totally exclude the `alerts:[...]` part. So, we can use a `Maybe` functor
    to process the received data without any problems, with or without any alerts:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在飓风哈维逼近德克萨斯州的那一天获取了这些信息。如果你在正常的一天调用API，数据将完全排除`alerts:[...]`部分。因此，我们可以使用`Maybe`函子来处理接收到的数据，无论是否有警报，都不会出现任何问题：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Of course, you would probably do something more interesting than just logging
    the value of the contained result of `produceAlertsTable()`! The most likely option
    would be to `.map()` again with a function that would output the table, send it
    to a client, or whatever you needed to do. In any case, the resulting output would
    match something like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可能会做一些比仅仅记录`produceAlertsTable()`的结果更有趣的事情！最有可能的选择是再次使用`.map()`，使用一个输出表格的函数，将其发送给客户端，或者你需要做的任何其他事情。无论如何，最终的输出将与以下内容匹配：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If we had instead called `getAlerts(-34.9, -54.60, ...)` with the coordinates
    for Montevideo, Uruguay, since there were no alerts for that city, the `getField("alerts")`
    function would have returned `undefined` -- and as that value is recognized by
    the `Maybe` functor, and even though all the following `.map()` operations would
    still be executed, no one would actually do anything, and a `null` value would
    be the final result. See figure 12.1:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改为使用乌拉圭蒙得维的坐标调用`getAlerts(-34.9, -54.60, ...)`，因为该城市没有警报，`getField("alerts")`函数将返回`undefined`——尽管所有后续的`.map()`操作仍将被执行，但实际上没有任何操作，最终结果将是`null`值。见图12.1：
- en: '![](assets/289aa8c5-320c-4ef5-bf35-e6133796f238.png)Figure 12.1\. The output
    table is not much to look at, but the logic that produced it didn''t require a
    single if.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1。输出表格看起来并不起眼，但产生它的逻辑并不需要一个if语句。
- en: We did take advantage of this behavior also when coding the error logic. If
    an error happens when calling the service, we would still call the original callback
    to produce a table, but providing an empty object. Even if this result is unexpected,
    we would be safe, because the same guards would avoid causing a runtime error.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在编写错误逻辑时也利用了这种行为。如果在调用服务时发生错误，我们仍然会调用原始回调来生成一个表，但提供一个空对象。即使这个结果是意外的，我们也会很安全，因为相同的保护措施会避免导致运行时错误。
- en: 'As a final enhancement, we can add an `.orElse()` method, to provide a default
    value when no one is present:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的增强，我们可以添加一个`.orElse()`方法，在没有值的情况下提供一个默认值：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Using this new method instead of `valueOf()`, if trying to get the alerts for
    someplace without them, you would just get whatever default value you wanted.
    In the case we cited before when attempting to get the alerts for Montevideo,
    instead of a `null` value, we would now get an appropriate result:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新方法而不是`valueOf()`，如果尝试为某个地方获取警报，而那里没有警报，你将得到任何你想要的默认值。在我们之前引用的情况下，当尝试获取蒙得维的亚的警报时，我们现在将得到一个合适的结果，而不是一个`null`值：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Working in this fashion we can simplify our coding, and avoid many tests for
    nulls and other similar situations. However, we may want to go beyond this; for
    instance, we could want to know *why* there were no alerts: was it a service error?
    Or just a normal situation? Just getting a `null` at the end isn''t enough, and
    in order to work with these new requirements, we will need to add something to
    our functors and enter the domain of *monads*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式工作，我们可以简化我们的编码，并避免对空值和其他类似情况进行许多测试。然而，我们可能想要超越这一点；例如，我们可能想知道*为什么*没有警报：是服务错误吗？还是正常情况？最后只得到一个`null`是不够的，为了满足这些新的要求，我们需要向我们的函子添加一些东西，并进入*单子*的领域。
- en: Monads
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子
- en: '*Monads* have a weird fame among programmers. Well known developer Douglas
    Crockford has famously spoken of *their* "curse", maintaining that *Once you happen
    to finally understand monads, you immediately lose the ability to explain them
    to other people!* On a different note, if you decide to go to the basics and read
    a book like *Categories for the Working Mathematician* by Saunders Mac Lane (one
    of the creators of Category Theory) you may find a somewhat disconcerting explanation:
    *A monad in X is just a monoid in the category of endofunctors of X, with product*
    × *replaced by composition of endofunctors and unit set by the identity endofunctor.*
    Not too illuminating!'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*单子*在程序员中有着奇怪的名声。著名的开发者道格拉斯·克罗克福德曾经谈到过*它们*的“诅咒”，他认为*一旦你终于理解了单子，你立刻就失去了向其他人解释它们的能力！*另一方面，如果你决定回到基础，阅读一本像是*工作数学家的范畴*这样的书，作者是范畴论的创始人之一桑德斯·麦克莱恩，你可能会发现一个有些令人困惑的解释：*X中的单子只是X的自函子范畴中的幺半群，乘积*
    × *被自函子的组合所取代，单位集由恒等自函子取代。*并不是太有启发性！'
- en: The difference between monads and functors is just that the former adds some
    extra functionality. Let's start by seeing the new requirements, and afterwards
    move on to consider some common, useful monads. As with functors, we will have
    a basic monad, which you could consider to be an *abstract* version, and specific
    *monadic types*, which are *concrete* implementations, geared to solving specific
    cases.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单子和函子之间的区别只是前者增加了一些额外的功能。让我们先看看新的要求，然后再考虑一些常见的有用的单子。与函子一样，我们将有一个基本的单子，你可以将其视为*抽象*版本，并且具体的*单子类型*，它们是*具体*的实现，旨在解决特定情况。
- en: 'If you want to read a precise and careful description of functors, monads,
    and all their family (but leaning heavily to the theoretical side, with plenty
    of algebraic definitions to go around) you can try the Fantasy Land Specification
    at [https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/).
    Don''t say we didn''t warn you: the alternative name for that page is *Algebraic
    JavaScript Specification*!)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想阅读关于函子、单子以及它们所有家族的精确和仔细的描述（但更倾向于理论方面，并且有大量的代数定义），你可以尝试一下Fantasy Land规范，网址是[https://github.com/fantasyland/fantasy-land/](https://github.com/fantasyland/fantasy-land/)。不要说我们没有警告过你：该页面的另一个名称是*代数JavaScript规范*！
- en: Adding operations
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加操作
- en: 'Let''s consider a simple problem. Suppose you have the following pair of functions,
    working with `Maybe` functors: the first function tries to search for *something*
    (say, a client or a product, whatever) given its key, and the second attempts
    to extract *some* attribute from it (I''m being purposefully vague because the
    problem does not have anything to do with whatever objects or things we may be
    working with). Both functions produce `Maybe` results, to avoid possible errors.
    We are using a mocked search function, just to help us see the problem: for even
    keys, it returns fake data, and for odd keys, it throws an exception:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个简单的问题。假设你有以下一对函数，它们使用`Maybe`函子工作：第一个函数尝试根据其键搜索*某些东西*（比如客户或产品，无论是什么），第二个函数尝试从中提取*某些*属性（我故意含糊其辞，因为问题与我们可能正在处理的任何对象或事物无关）。这两个函数产生`Maybe`结果，以避免可能的错误。我们使用了一个模拟的搜索函数，只是为了帮助我们看到问题：对于偶数键，它返回虚假数据，对于奇数键，它会抛出异常。
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'What''s the problem here? The problem is that the output from `getSome()` is
    a `Maybe` value, which itself contains a `Maybe` value, so the result we want
    is double wrapped:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在哪里？问题在于`getSome()`的输出是一个`Maybe`值，它本身包含一个`Maybe`值，所以我们想要的结果被双重包装了。
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This problem can be easily solved in this toy problem (just avoid using `Maybe.of()`
    in `getSome()`), but this kind of result can happen in many ways, in more complex
    ways. For instance, you could be building a `Maybe` out of an object, one of whose
    attributes happened to be a `Maybe`, and if you''d get the same situation when
    accessing that attribute: you would end up with some doubly wrapped value.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个玩具问题中可以很容易地解决这个问题（只需在`getSome()`中避免使用`Maybe.of()`），但这种结果可能以更复杂的方式发生。例如，您可能正在构建一个`Maybe`，其中一个属性恰好是一个`Maybe`，如果在访问该属性时出现相同的情况：您最终会得到一些双重包装的值。
- en: 'Monads should provide the following operations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 单子应该提供以下操作：
- en: A constructor.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构造函数。
- en: 'A function that inserts a value into a monad: our `.of()` method.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将值插入单子的函数：我们的`.of()`方法。
- en: 'A function that allows for chaining operations: our `.map()` method.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许链接操作的函数：我们的`.map()`方法。
- en: 'A function that can remove extra wrappers: we will call it `.unwrap()`, and
    it will solve our preceding multiple wrapper problems. Sometimes it''s called
    `.flatten()`.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以去除额外包装的函数：我们将其称为`.unwrap()`，它将解决我们之前的多重包装问题。有时它被称为`.flatten()`。
- en: 'We will also have a function to chain calls, just to simplify our coding, and
    another function to apply functions, but we''ll get to those later. Let''s see
    what a monad looks like in actual JavaScript code. Data type specifications are
    very much like those for functors, so we won''t repeat them here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个用于链接调用的函数，只是为了简化我们的编码，还有另一个用于应用函数的函数，但我们稍后再说。让我们看看实际的JavaScript代码中单子是什么样子的。数据类型规范非常类似于函子的规范，所以我们不会在这里重复它们：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We use recursion to successively remove wrappers, until the wrapped value isn''t
    itself a container anymore. Using this method, we could avoid doubly wrapping
    easily:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用递归来逐步去除包装，直到包装的值不再是一个容器。使用这种方法，我们可以轻松地避免双重包装：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'However, this sort of problem could recur at different levels. For example,
    if we were doing a series of `.map()` operations, any of the intermediate results
    may end up being doubly wrapped. You could easily solve this by remembering to
    call `.unwrap()` after each `.map()` -- note that you could do it even if it is
    not actually needed, for in that case the result of `.unwrap()` would be the very
    same object (can you see why?). But we can do better! Let''s define a `.chain()`
    operation, which will do both things for us (sometimes `.chain()` is called `.flatMap()`):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种问题可能会在不同的层面上重复出现。例如，如果我们正在进行一系列`.map()`操作，任何中间结果都可能最终被双重包装。您可以很容易地通过记住在每个`.map()`之后调用`.unwrap()`来解决这个问题--请注意，即使实际上并不需要，您也可以这样做，因为在这种情况下，`.unwrap()`的结果将是完全相同的对象（你能看出为什么吗？）。但我们可以做得更好！让我们定义一个`.chain()`操作，它将为我们执行这两个操作（有时`.chain()`被称为`.flatMap()`）：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's only one operation left. Suppose you have a curried function, with two
    parameters; nothing outlandish! What would happen if you were to provide that
    function to a `.map()` operation?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 只剩下一个操作。假设您有一个柯里化的函数，有两个参数；没有什么奇怪的！如果您将该函数提供给`.map()`操作，会发生什么？
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What would something be? Given that we have provided only one argument to add,
    the result of that application will be a function... not just any function, but
    a *wrapped* one! (Since functions are first-class objects, there''s no logical
    obstacle to wrapping a function in a Monad, is there?) What would we want to do
    with such a function? In order to be able to apply this wrapped function to a
    value, we''ll need a new method: `.ap()`. What could the value be? In this case,
    it could either be a plain number, or a number wrapped in a monad as a result
    of other operations. Since we can always `Map.of()` a plain number into a wrapped
    one, let''s have `.ap()` work with a monad as its parameter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 某物会是什么？鉴于我们只提供了一个参数来添加，该应用的结果将是一个函数...不仅仅是任何函数，而是一个*包装*的函数！（由于函数是一级对象，逻辑上没有障碍将函数包装在单子中，对吧？）我们想对这样的函数做什么？为了能够将这个包装的函数应用到一个值上，我们需要一个新的方法：`.ap()`。这个值可能是什么？在这种情况下，它可以是一个普通的数字，或者是由其他操作的结果作为单子包装的数字。由于我们总是可以将一个普通数字`Map.of()`成一个包装数字，让我们让`.ap()`使用一个单子作为它的参数：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With this, you could then do the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你就可以这样做：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, you can use monads to hold either values or functions, and to interact
    with other monads and chaining operations as you may wish. So, as you can see,
    there's no big trick to monads, which are just functors with some extra methods.
    Let's see now how we can apply them to our original problem, and handle errors
    in a better way.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用单子来保存值或函数，并根据需要与其他单子和链接操作进行交互。因此，正如您所看到的，单子并没有什么大技巧，它们只是带有一些额外方法的函子。现在让我们看看如何将它们应用到我们的原始问题中，并以更好的方式处理错误。
- en: Handling alternatives - the Either monad
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理替代方案 - Either单子
- en: 'Knowing that a value was missing may be enough in some cases, but in others,
    you''ll want to be able to provide an explanation. We can get such explanation
    if we use a different functor, which will take one of two possible values, one
    associated with a problem, error, or failure, and another associated with normal
    execution, or success:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 知道一个值是否丢失在某些情况下可能足够了，但在其他情况下，您可能希望能够提供一个解释。如果我们使用一个不同的函子，它将接受两个可能的值，一个与问题、错误或失败相关联，另一个与正常执行或成功相关联，我们可以得到这样的解释：
- en: A *left* value, which should be null, but if present it represents some kind
    of special value (for example, an error message or a thrown exception), which
    cannot be mapped over
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*左*值，应该是null，但如果存在，它代表某种特殊值（例如，错误消息或抛出的异常），它不能被映射
- en: A *right* value, which represents the *normal* value of the functor, and can
    be mapped over
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*正确*的值，它代表了函子的*正常*值，并且可以被映射
- en: 'We can construct this monad in a similar way than what we did for `Maybe` (actually,
    the added operations make it better for `Maybe` to extend `Monad` as well). The
    constructor will receive a left and a right value: if the left value is present,
    it will become the value of the `Either` monad; otherwise, the right value will
    be used. Since we have been providing `.of()` methods for all our functors, we
    need one for `Either` too:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以与我们为`Maybe`所做的类似的方式构造这个monad（实际上，添加的操作使得`Maybe`也可以扩展`Monad`）。构造函数将接收左值和右值：如果左值存在，它将成为`Either`
    monad的值；否则将使用右值。由于我们为所有的functors提供了`.of()`方法，我们也需要为`Either`提供一个：
- en: '[PRE38]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `.map()` method is key. If this functor has got a *left* value, it won''t
    be processed any further; in other cases, the mapping will be applied to the *right*
    value, and the result will be wrapped. Now, how can we enhance our code with this?
    The key idea is for every involved method to return an `Either` monad; `.chain()`
    will be used to execute operations one after another. Getting the alerts would
    be the first step -- we invoke the callback either with a `AJAX FAILURE` message
    or with the result from the API call:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map()`方法是关键。如果这个functor有一个*left*值，它将不会被进一步处理；在其他情况下，映射将被应用于*right*值，并且结果将被包装。现在，我们如何用这个来增强我们的代码呢？关键的想法是每个涉及的方法都返回一个`Either`
    monad；`.chain()`将被用来依次执行操作。获取警报将是第一步--我们调用回调，要么得到`AJAX FAILURE`消息，要么得到API调用的结果：'
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, the general process would become as follows. We use an Either again:
    if there are no alerts, instead of an array, we return a `NO ALERTS` message:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一般的过程将变成如下。我们再次使用一个Either：如果没有警报，而不是一个数组，我们返回一个`NO ALERTS`消息：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice how we used `.chain()`, so multiple wrappers would be no problem. We
    can now test multiple situations, and get appropriate results -- or at least,
    for the current weather situation around the world!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何使用`.chain()`，所以多个包装器不会有问题。现在我们可以测试多种情况，并得到适当的结果--或者至少对于世界各地的当前天气情况是这样！
- en: For Houston, TX, we still get an HTML table.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于TX的Houston，我们仍然得到一个HTML表格。
- en: For Montevideo, UY, we get a text saying there were no alerts.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于UY的Montevideo，我们得到一条消息，说没有警报。
- en: 'For a point with wrong coordinates, we learn that the AJAX call failed: nice!'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于错误坐标的点，我们得知AJAX调用失败了：不错！
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are not done with the Either monad. It's likely that much of your code will
    involve calling functions. Let's look for a better way of achieving this, through
    a variant of this monad.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成Either monad。你的大部分代码可能涉及调用函数。让我们寻找一个更好的方法来实现这一点，通过这个monad的一个变体。
- en: Calling a function - the Try monad
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数 - Try monad
- en: 'If we are calling functions that may throw exceptions, and we want to do it
    in a functional way, we could use the *Try* monad, to encapsulate the function
    result or the exception. The idea is basically the same as the Either monad: the
    only difference is in the constructor, which receives a function, and calls it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用可能抛出异常的函数，并且我们想以一种功能性的方式来做，我们可以使用*Try* monad，来封装函数的结果或异常。这个想法基本上与Either
    monad是一样的：唯一的区别在于构造函数，它接收一个函数，并调用它：
- en: If there are no problems, the returned value becomes the right value for the
    monad
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有问题，返回的值将成为monad的右值
- en: If there's an exception, it will become the left value
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有异常，它将成为左值
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we can invoke any function, catching exceptions in a good way. For example,
    the `getField()` function that we have been using, would crash if called with
    a null argument:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以调用任何函数，以一种良好的方式捕获异常。例如，我们一直在使用的`getField()`函数，如果用空参数调用，就会崩溃：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can rewrite it using the Try monad, so it will *play nice* with other composed
    functions:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Try monad来重写它，这样它就可以与其他组合函数*友好*地协作：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There are many more monads, and of course, you can even define your own, so
    we couldn't possibly go over all of them. However, let's do visit just one more,
    which you have been using, without being aware of its *monad-ness*!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他的monads，当然，你甚至可以定义自己的monad，所以我们不可能涵盖所有的monads。然而，让我们再访问一个，你可能一直在使用，却没有意识到它的*monad-ness*！
- en: Unexpected Monads - Promises
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意外的Monads - Promises
- en: 'Let''s finish this section on monads, by mentioning yet another one that you
    may have used, though under a different name: *Promises*! We already commented,
    earlier in this chapter, that functors (and remember, monads are functors) had
    at least something in common with promises: using a method in order to access
    the value. However, the analogy is greater than that!'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过提及另一个你可能使用过的monad来完成monads的这一部分，尽管它有一个不同的名字：*Promises*！我们在本章的前面已经评论过，functors（记住，monads是functors）至少与promises有一些共同之处：使用方法来访问值。然而，这种类比更大！
- en: '`Promise.resolve()` corresponds with `Monad.of()` -- if you pass a value to
    `.resolve()`, you''ll get a promise resolved to that value, and if you provide
    a promise, you will get a new promise, whose value will be that of the original
    one (see [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)
    for more on this). This is an *unwrapping* behavior!'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.resolve()`对应于`Monad.of()` -- 如果你传递一个值给`.resolve()`，你将得到一个解析为该值的promise，如果你提供一个promise，你将得到一个新的promise，其值将是原始promise的值（有关更多信息，请参阅[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve)）。这是一种*解包*行为！'
- en: '`Promise.then()` stands for `Monad.map()` and also `Monad.chain()`, given the
    mentioned unwrapping.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Promise.then()`代表`Monad.map()`，也代表`Monad.chain()`，鉴于前面提到的解包。'
- en: 'And we don''t have a direct match to `Monad.ap()`, but we could add something
    like the following code:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有直接匹配`Monad.ap()`，但我们可以添加类似以下代码的东西：
- en: '[PRE45]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even if you opt for the modern `async` and `await` features, internally they
    are based on promises. Furthermore, in some situations you may still need `Promise.race()`
    and `Promise.all()`, so it's likely you will keep using promises, even if you
    opt for full ES8 coding.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您选择现代的`async`和`await`功能，它们在内部也是基于承诺。此外，在某些情况下，您可能仍然需要`Promise.race()`和`Promise.all()`，因此您可能会继续使用承诺，即使选择完整的ES8编码。
- en: This is an appropriate ending for this section. Earlier, you found out that
    common arrays were in fact functors. And now, in the same way, that Monsieur Jourdain
    (a character in Molière's play *Le Bourgeois Gentilhomme*, *The Burgeois Gentleman*)
    discovered that all his life he had been speaking in prose, you now know you had
    already been using monads, even without knowing it!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本节的一个合适的结尾。之前，您已经发现常见的数组实际上是函子。现在，以同样的方式，就像莫里哀戏剧《市民绅士》中的角色若尔当先生发现他一生都在说散文一样，您现在知道自己已经在使用单子，即使不知道它！
- en: Functions as data structures
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为数据结构
- en: So far, we have seen how to use functions to work with or transform, other functions,
    to process data structures, or to create data types. Let's then finish this chapter
    by showing how a function can actually implement a data type by itself, becoming
    a sort of container of its own. In fact, this is a basic theoretical point of
    the lambda calculus (and if you want to learn more, look up *Church Encoding*
    and *Scott Encoding*), so we might very well say that we have come around to the
    point where we began this book, at the origins of Functional Programming!
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到如何使用函数来处理其他函数，处理数据结构或创建数据类型。让我们通过展示函数实际上如何实现自己的数据类型来结束本章，成为一种容器。事实上，这是λ演算的一个基本理论点（如果您想了解更多，请查阅*Church编码*和*Scott编码*），因此我们很可能可以说我们已经回到了本书的起点，即函数式编程的起源！
- en: Binary trees in Haskell
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Haskell中的二叉树
- en: 'Consider a binary tree. Such a tree may either be empty, or consist of a node
    (the tree *root*) with two sons: a left binary tree, and a right one.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个二叉树。这样的树可以是空的，也可以由一个节点（树的*根*）和两个子树组成：左二叉树和右二叉树。
- en: In [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, we worked with more general tree structures, such as a filesystem
    or the browser DOM itself, which allow a node to have any number of sons. In the
    particular case of the trees we are working with in this section, each node always
    has two sons, although each of them may be empty. The difference may seem minor,
    but allowing for empty subtrees is what lets you define that all nodes are binary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)中，*设计函数 - 递归*，我们使用了更一般的树结构，比如文件系统或浏览器DOM本身，这些结构允许一个节点有任意数量的子节点。在本节中，我们正在处理的树的特殊情况是，每个节点始终有两个子节点，尽管它们中的每一个都可能为空。这种差异似乎很小，但允许空子树是让您定义所有节点都是二进制的关键。
- en: 'Let''s make a digression with the Haskell language. In it, we might write something
    like the following; *a* would be the type of whatever value we hold in the nodes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用Haskell语言做一个离题。在这种语言中，我们可能会写出以下内容；*a*将是我们在节点中持有的任何值的类型：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In that language, pattern matching is often used for coding. For example, we
    could define an `empty` function, as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种语言中，模式匹配经常用于编码。例如，我们可以定义一个`empty`函数，如下所示：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The logic is simple: if the tree is `Nil` (the first possibility in the definition
    of the type) then the tree is certainly empty; otherwise, the tree isn''t empty.
    The last line would probably be written `empty _ = False` because you don''t actually
    care for the components of the tree; the mere fact that it''s not `Nil` suffices.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑很简单：如果树是`Nil`（类型定义中的第一种可能性），那么树肯定是空的；否则，树不是空的。最后一行可能会写成`empty _ = False`，因为您实际上不关心树的组件；它不是`Nil`就足够了。
- en: 'Searching for a value in a binary search tree (in which the root is greater
    than all the values of its left subtree, and less than all the values of its right
    subtree) would be similarly written:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在二叉搜索树中搜索值（其中根大于其左子树的所有值，并且小于其右子树的所有值）将类似地编写：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: An empty tree doesn't contain the searched value. For other trees, if the root
    matches the searched value, we are done. If the root is greater than the searched
    value, the answer is found searching in the left subtree; otherwise, search in
    the right subtree.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 空树不包含搜索的值。对于其他树，如果根与搜索的值匹配，我们就完成了。如果根大于搜索的值，则在左子树中搜索；否则，在右子树中搜索。
- en: 'There''s an important point to be remembered: for this data type, a union of
    two possible types, we have to provide two conditions, and pattern matching will
    be used to decide which one is to be applied. Keep this in mind!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的要点需要记住：对于这种数据类型，两种可能类型的联合，我们必须提供两个条件，并且将使用模式匹配来决定应用哪一个。记住这一点！
- en: Functions as binary trees
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为二叉树
- en: 'Can we do something similar with functions? The answer is yes: we will represent
    a tree (or any other structure) with a function itself -- and mind: not with a
    data structure that is processed by a set of functions, and not either with an
    object with some methods, but by just a function. Furthermore, we will get a functional
    data structure, 100% immutable, which if updated produces a new copy of itself.
    And, we will do all this without using objects; rather, closures will provide
    the desired results.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否用函数做类似的事情？答案是肯定的：我们将用函数本身来表示树（或任何其他结构） - 请注意：不是用一组函数处理的数据结构，也不是用一些方法的对象，而只是一个函数。此外，我们将得到一个功能性数据结构，100%不可变，如果更新会产生一个新的副本。而且，我们将在不使用对象的情况下完成所有这些操作；相反，闭包将提供所需的结果。
- en: How can this work? We shall be applying similar concepts as those we saw earlier
    in the chapter, so the function will act as a container, and it will produce,
    as its result, a mapping of its contained values. Let's walk backwards, and start
    by showing how we'll use the new data type, and then go to the implementation
    details.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这怎么可能？我们将应用与本章前面所见类似的概念，因此该函数将充当容器，并且其结果将是其包含值的映射。让我们倒着走，首先展示如何使用新的数据类型，然后再去实现细节。
- en: 'Creating a tree will be done by using two functions: `EmptyTree()` and `Tree(value,
    leftTree, rightTree)`. For example, creating a tree as shown in figure 12.2, would
    be done by using the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 创建树将使用两个函数：`EmptyTree()`和`Tree(value, leftTree, rightTree)`。例如，创建图12.2中所示的树，将使用以下代码：
- en: '![](assets/09f3f6b2-11cb-4c02-b8b1-07b63c60d964.jpg)Figure 12.2\. A binary
    search tree, created by the following code.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/09f3f6b2-11cb-4c02-b8b1-07b63c60d964.jpg)图12.2 二叉搜索树，由以下代码创建。'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'How do you work with this structure? According to the data type description,
    whenever you work with a tree, you must consider two cases: a non-empty tree,
    or an empty one. In the preceding code, `myTree()` is actually a function that
    receives two functions as arguments, one for each of the two data type cases.
    The first function will be called with the node value and left and right trees
    as arguments, and the second function will receive none. So, to get the root we
    could write something as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用这个结构？根据数据类型描述，每当你使用树时，你必须考虑两种情况：非空树或空树。在前面的代码中，`myTree()`实际上是一个接收两个函数作为参数的函数，分别对应两种数据类型情况。第一个函数将以节点值和左右树作为参数调用，第二个函数将不接收参数。因此，要获取根，我们可以写如下内容：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we were dealing with a non-empty tree, we expect the first function to be
    called and produce the value of the root as the result. With an empty tree, the
    second function should be called, and then a `null` value would be returned.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处理的是非空树，我们期望调用第一个函数并将根的值作为结果。对于空树，应该调用第二个函数，然后返回一个`null`值。
- en: 'Similarly, if we wanted to count how many nodes are there in a tree, we would
    write the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们想要计算树中有多少个节点，我们会写如下代码：
- en: '[PRE51]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: For non-empty trees, the first function would return 1 (for the root) plus the
    node count from both the root's subtrees. For empty trees, the count is simply
    zero. Get the idea?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非空树，第一个函数将返回1（对于根）加上根的子树的节点计数。对于空树，计数就是零。明白了吗？
- en: 'We can now show the `Tree()` and `EmptyTree()` functions:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以展示`Tree()`和`EmptyTree()`函数：
- en: '[PRE52]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `destructure()` function is what you will pass as an argument (the name
    comes from the destructuring statement in JS, which lets you separate an object
    attribute into distinct variables). You will have to provide two versions of this
    function. If the tree is non-empty, the first function will be executed; for an
    empty tree, the second one will be run (this mimics the *case* selection in the
    Haskell code, except we are placing the non-empty tree case first, and the empty
    tree last). The `__` variable is used just as a placeholder, to stand for an otherwise
    ignored argument, but showing that two arguments are assumed.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`destructure()`函数是你将作为参数传递的函数（名称来自JS中的解构语句，它允许你将对象属性分隔为不同的变量）。你将需要提供这个函数的两个版本。如果树是非空的，将执行第一个函数；对于空树，将运行第二个函数（这模仿了Haskell代码中的*case*选择，只是我们将非空树的情况放在第一位，空树的情况放在最后）。`__`变量只是作为占位符使用，表示一个被忽略的参数，但显示了假定有两个参数。'
- en: 'This can be hard to understand, so let''s see some more examples. If we need
    to access specific elements of a tree, we have the following three functions,
    one of which (`treeRoot()`) we already saw -- let''s repeat it here for completeness:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很难理解，所以让我们看一些更多的例子。如果我们需要访问树的特定元素，我们有以下三个函数，其中一个（`treeRoot()`）我们已经看到了--让我们在这里重复一下以完整起见：
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Functions that access the component values of structures (or *constructions*,
    to use another term) are called *projector functions*. We won't be using this
    term, but you might find it elsewhere.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 访问结构的组件值的函数（或*构造*，用另一个术语）称为*投影函数*。我们不会使用这个术语，但你可能会在其他地方找到它。
- en: 'How can we decide if a tree is empty? See if you can see why this short line
    works:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何判断一棵树是否为空？看看你是否能理解为什么这一行代码有效：
- en: '[PRE54]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s just go over a few more samples of this. For example, we can build an
    object out of a tree, and that would help with debugging. I added logic to avoid
    including left or right empty subtrees, so the produced object would be shorter:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一些例子。例如，我们可以从树中构建一个对象，这有助于调试。我添加了逻辑以避免包含左侧或右侧的空子树，因此生成的对象会更短：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Note the usage of recursion, as in the *Traversing a Tree Structure* section
    of [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml), *Designing Functions
    - Recursion*, in order to produce the object equivalents of the left and right
    subtrees. An example of this function is as follows; I edited the output to make
    it more clear:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意递归的使用，就像[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)中的*遍历树结构*部分中所述的那样，为了生成左右子树的对象等价物。这个函数的一个例子如下；我编辑了输出以使其更清晰：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Can we search for a node? Of course, and the logic follows closely the definition
    we saw in the previous section (we could have shortened the code a bit, but I
    did want to parallel the Haskell version):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以搜索节点吗？当然可以，逻辑紧随我们在上一节中看到的定义（我们可以缩短代码，但我确实想要与Haskell版本保持一致）：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'And, to round out this section, let''s also include how to add new nodes to
    a tree. Study the code carefully, and you''ll notice how the current tree isn''t
    modified, and a new one is produced instead. Of course, given that we are using
    functions to represent our tree data type, it should be obvious that we wouldn''t
    have been able to just modify the old structure: it''s immutable by default:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了完成本节，让我们还包括如何向树中添加新节点。仔细研究代码，您会注意到当前树没有被修改，而是产生了一个新的树。当然，鉴于我们使用函数来表示我们的树数据类型，显然我们不能只修改旧结构：它默认是不可变的：
- en: '[PRE58]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: When trying to insert a new key, if it's less or equal to the root of the tree,
    we produce a new tree that has the current root as its own root, maintains the
    old right subtree, but changes its left subtree to incorporate the new value (which
    will be done in a recursive way). If the key was greater than the root, the changes
    would not have been symmetrical, but analogous. And if we try to insert a new
    key, and we find ourselves an empty tree, we just replace that empty structure
    with a new tree, with just the new value as its root, and empty left and right
    subtrees.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试插入一个新键时，如果它小于或等于树的根节点，我们会产生一个新树，该树的根节点为当前根节点，保留旧的右子树，但更改其左子树以包含新值（这将以递归方式完成）。如果键大于根节点，则更改不会对称，但类似。如果我们尝试插入一个新键，并且发现自己是一个空树，我们只需用一个新树替换该空结构，该树只有新值作为其根，以及空的左右子树。
- en: 'We can test out this logic easily -- but the simplest way is to verify that
    the binary tree is shown earlier (Figure 12.2) is generated by the following sequence
    of operations:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松测试这个逻辑--但最简单的方法是验证之前显示的二叉树（图12.2）是否由以下操作序列生成：
- en: '[PRE59]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We could make this insertion function even more general, by providing the comparator
    function that would be used to compare values. In this fashion, we could easily
    adapt a binary tree to represent a generic map. The value of a node would actually
    be an object such as `{key:... , data:...}` and the provided function would compare
    `newValue.key` and `value.key` to decide where to add the new node. Of course,
    if the two keys were equal, we would change the root of the current tree:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过提供比较器函数来使这个插入函数更加通用，该函数将用于比较值。这样，我们可以轻松地调整二叉树以表示通用映射。节点的值实际上将是一个对象，例如`{key:...
    , data:...}`，并且提供的函数将比较`newValue.key`和`value.key`以决定在哪里添加新节点。当然，如果两个键相等，我们将更改当前树的根节点：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'What else do we need? Of course, we may program diverse functions: deleting
    a node, counting nodes, determining a tree''s height, comparing two trees, and
    so on. But, in order to gain more usability, we should really turn the structure
    into a functor, by implementing a `map()` function. Fortunately, using recursion,
    this proves to be easy:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要什么？当然，我们可以编写各种函数：删除节点，计算节点数，确定树的高度，比较两棵树等等。但是，为了获得更多的可用性，我们真的应该将结构转换为一个函子，通过实现`map()`函数。幸运的是，使用递归，这被证明是很容易的：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We could go on with more examples, but that won''t change the important conclusions
    we can derive from this work:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续举更多的例子，但这不会改变我们从这项工作中得出的重要结论：
- en: We are handling a data structure (a recursive one, at that) representing it
    with a function
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在处理一个数据结构（一个递归的数据结构），并用一个函数来表示它
- en: 'We are not using any external variables or objects for the data: closures are
    used instead'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有为数据使用任何外部变量或对象：而是使用闭包
- en: The data structure itself satisfies all the requirements we analyzed in Chapter
    10, *Ensuring Purity - Immutability*, insofar it is immutable and all changes
    always produce new structures
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构本身满足我们在第10章*确保纯度-不可变性*中分析的所有要求，因为它是不可变的，所有更改总是产生新的结构
- en: And, finally, the tree is a functor, providing all the corresponding advantages
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，树是一个函子，提供了所有相应的优势
- en: So, we have seen even one more application of functional programming -- and
    we've seen how a function can actually become a structure by itself, which isn't
    what one is usually accustomed to!
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们甚至看到了函数式编程的另一个应用--我们看到一个函数实际上可以成为一个结构，这并不是人们通常习惯的！
- en: Questions
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 12.1\. **Maybe tasks?** In the questions section of [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining and Composition*, a question had to do with
    getting the pending tasks for a person, but taking into account errors or border
    situations, such as the possibility that the selected person might not even exist.
    Redo that exercise, but using Maybe or Either monads to simplify that coding.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 12.1\. **也许任务？** 在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)的问题部分，*连接函数-管道和组合*，一个问题涉及获取某人的待办任务，但考虑到错误或边界情况，比如所选的人可能根本不存在。重新做这个练习，但使用Maybe或Either单子来简化编码。
- en: '12.2\. **Extending your trees**. In order to get a more complete implementation
    of our functional binary search trees, implement the following functions:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 12.2\. **扩展您的树**。为了获得我们的函数式二叉搜索树的更完整的实现，实现以下函数：
- en: Calculate the tree's height -- or, equivalently, the maximum distance from the
    root to any other node
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算树的高度--或者等效地，从根到任何其他节点的最大距离
- en: List all the tree's keys, in ascending order
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按升序列出树的所有键
- en: Delete a key from a tree
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从树中删除一个键
- en: '12.3\. **Functional lists**. In the same spirit of the binary trees, implement
    functional lists. Since a list is defined to be either empty or a node (head)
    followed by another list (tail), you might want to start with the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 12.3\. **函数式列表**。在与二叉树相同的精神下，实现函数式列表。由于列表被定义为空或一个节点（头部）后跟另一个列表（尾部），您可能希望从以下内容开始：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Here are some easy one-liner operations to get you started:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些简单的一行操作，让您开始：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You could consider having these operations:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以考虑进行以下操作：
- en: Transforming a list into an array, and vice-versa
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将列表转换为数组，反之亦然
- en: Reversing a list
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转列表
- en: Append one list to the end of another list
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个列表附加到另一个列表的末尾
- en: Concatenating two lists
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个列表
- en: Don't forget a `listMap()` function! Also, `listReduce()` and `listFilter()`
    functions would come in handy.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记`listMap()`函数！此外，`listReduce()`和`listFilter()`函数会派上用场。
- en: 12.4\. **Code shortening**. We mentioned that the `treeSearch()` function could
    be shortened -- can you do that? Yes, this is more of a JavaScript problem than
    a functional one, and I'm not saying that shorter code is necessarily better,
    but many programmers act as if it were, so it's good to be aware of such style
    if only because you're likely to find it.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 12.4\. **代码缩短**。我们提到`treeSearch()`函数可以缩短 - 你能做到吗？是的，这更多是一个JavaScript问题，而不是一个功能性的问题，我并不是说更短的代码一定更好，但许多程序员似乎是这样认为的，所以了解这种风格是很好的，因为你可能会遇到它。
- en: Summary
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we turned a bit closer to theory and seeing how to use and
    implement data types from a functional point of view. We started with ways of
    defining function signatures, to help understand the transformations implied by
    the multiple operations we later met; then, we went on to define several containers,
    including functors and monads, and see how they could be used to enhance function
    composition, and finally we saw how functions could be directly used by themselves,
    with no extra baggage, to implement functional data structures.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更接近理论，看到了如何从功能性的角度使用和实现数据类型。我们从定义函数签名的方式开始，以帮助理解后来遇到的多个操作所暗示的转换；然后，我们继续定义了几个容器，包括函子和单子，并看到它们如何用于增强函数组合，最后我们看到函数如何直接被自身使用，不需要额外的负担，来实现功能性数据结构。
- en: As of now, in this book we have seen several features of functional programming
    for JavaScript. We started out with some definitions, a practical example, and
    then moved on to important considerations such as pure functions, side effects
    avoidance, immutability, testability, building new functions out of other ones,
    and implementing data flow based upon function connections and data containers.
    We have seen a lot of concepts, but I'm confident that you'll be able to put them
    in practice, and start writing even higher quality code - give it a try!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本书中我们已经看到了JavaScript的函数式编程的几个特性。我们从一些定义开始，到一个实际的例子，然后转向重要的考虑因素，如纯函数、避免副作用、不可变性、可测试性、通过函数连接和数据容器实现数据流的构建新函数，我们已经看到了很多概念，但我相信你能够将它们付诸实践，并开始编写更高质量的代码
    - 试一试吧！
