- en: Chapter 9. Advanced Contract Programming with Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。接口的高级契约编程
- en: 'In this chapter, we will dive deeper into contract programming with interfaces.
    We will have a better understanding of how interfaces work as types. We will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨接口的契约编程。我们将更好地理解接口作为类型的工作方式。我们将：
- en: Work with methods receiving interfaces as arguments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口作为参数的方法
- en: Downcast with interfaces and classes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用接口和类进行向下转型
- en: Understand boxing and unboxing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解装箱和拆箱
- en: Treat instances of an interface type as a different subclass
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接口类型的实例视为不同的子类
- en: Take advantage of default methods in interfaces in Java 9
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Java 9中接口的默认方法
- en: Working with methods receiving interfaces as arguments
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口作为参数的方法
- en: 'In the previous chapter, we created the following five interfaces: `DrawableInComic`,
    `DrawableInGame`, `Hideable`, `Powerable`, and `Fightable`. Then, we created the
    following classes that implemented different interfaces, and, many of them, also
    inherited from superclasses: `SpiderDog`, `WonderCat`, `HideableWonderCat`, `PowerableWonderCat`,
    and `FightableWonderCat`.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了以下五个接口：`DrawableInComic`、`DrawableInGame`、`Hideable`、`Powerable`和`Fightable`。然后，我们创建了实现不同接口的以下类，并且其中许多类还继承自超类：`SpiderDog`、`WonderCat`、`HideableWonderCat`、`PowerableWonderCat`和`FightableWonderCat`。
- en: 'Run the following command in JShell to check all the types we have created:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中运行以下命令以检查我们创建的所有类型：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The following screenshot shows the results of executing the previous command
    in JShell. JShell enumerates the five interfaces and the five classes we have
    created in the session.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在JShell中执行上一个命令的结果。JShell列举了我们在会话中创建的五个接口和五个类。
- en: '![Working with methods receiving interfaces as arguments](img/00085.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![使用接口作为参数的方法](img/00085.jpeg)'
- en: When we work with interfaces, we use them to specify the argument types instead
    of using class names. Multiple classes might implement a single interface, and
    therefore, instances of different classes might qualify as an argument of a specific
    interface.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用接口时，我们使用它们来指定参数类型，而不是使用类名。多个类可能实现单个接口，因此，不同类的实例可能符合特定接口的参数。
- en: Now we will create additional instances of the previously mentioned classes
    and we will call methods that specified their required arguments with interface
    names instead of class names. We will understand what happens under the hood when
    we use interfaces as types for arguments in methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建先前提到的类的额外实例，并调用指定其所需参数的方法，使用接口名称而不是类名。我们将了解在方法中使用接口作为参数类型时发生了什么。
- en: In the following code, the first two lines create two instances of the `SpiderDog`
    class named `teddy` and `winston`. Then, the code calls the two versions of the
    `drawSpeechBalloon` method for `teddy`. The second call to this method passes
    `winston` as the `DrawableInComic` argument because `winston` is an instance of
    `SpiderDog`, which is a class that implements the `DrawableInComic` instance.
    The code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_01.java` file.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，前两行创建了`SpiderDog`类的两个实例，分别命名为`teddy`和`winston`。然后，代码调用了`teddy`的`drawSpeechBalloon`方法的两个版本。对该方法的第二次调用将`winston`作为`DrawableInComic`参数传递，因为`winston`是`SpiderDog`的一个实例，而`SpiderDog`是实现`DrawableInComic`实例的类。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following code creates an instance of the `WonderCat` class named `oliver`.
    The value specified for the `nickName` argument in the constructor is `"Oliver"`.
    The next line calls the `drawSpeechBalloon` method for the new instance to introduce
    `Oliver` in the comic strip, and then `teddy` calls the `drawSpeechBalloon` method
    and passes `oliver` as the `DrawableInComic` argument because `oliver` is an instance
    of `WonderCat`, which is a class that implements the `DrawableInComic` instance.
    Hence, we can also use instances of `WonderCat` whenever we need a `DrawableInComic`
    argument. The code file for the sample is included in the `java_9_oop_chapter_09_01`
    folder, in the `example09_01.java` file.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`oliver`的`WonderCat`类的实例。在构造函数中为`nickName`参数指定的值为`"Oliver"`。下一行调用了新实例的`drawSpeechBalloon`方法，介绍了`Oliver`在漫画中，然后`teddy`调用了`drawSpeechBalloon`方法，并将`oliver`作为`DrawableInComic`参数传递，因为`oliver`是`WonderCat`的一个实例，而`WonderCat`是实现`DrawableInComic`实例的类。因此，我们也可以在需要`DrawableInComic`参数时使用`WonderCat`的实例。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The following code creates an instance of the `HideableWonderCat` class named
    `misterHideable`. The value specified for the `nickName` argument in the constructor
    is `"Mr. Hideable"`. The next line checks whether the call to the `isIntersectingWith`
    method with `oliver` as a parameter returns `true`. The method requires a `DrawableInComic`
    argument, and therefore, we can use `oliver`. The method will return `true` because
    the `x` and `y` fields of both instances have the same value. The line within
    the `if` block calls the `setLocation` method for `misterHideable`. Then, the
    code calls the `show` method. The code file for the sample is included in the
    `java_9_oop_chapter_09_01` folder, in the `example09_01.java` file.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`misterHideable`的`HideableWonderCat`类的实例。在构造函数中为`nickName`参数指定的值为`"Mr.
    Hideable"`。下一行检查了使用`oliver`作为参数调用`isIntersectingWith`方法是否返回`true`。该方法需要一个`DrawableInComic`参数，因此我们可以使用`oliver`。该方法将返回`true`，因为两个实例的`x`和`y`字段具有相同的值。`if`块中的行调用了`misterHideable`的`setLocation`方法。然后，代码调用了`show`方法。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The following code creates an instance of the `PowerableWonderCat` class named
    `merlin`. The value specified for the `nickName` argument in the constructor is
    `"Merlin"`. The next lines call the `setLocation` and `draw` methods. Then, the
    code calls the `useSpellToHide` method with `misterHideable` as the `Hideable`
    argument. The method requires a `Hideable` argument, and therefore, we can use
    `misterHideable`, which is the previously created instance of `HideableWonderCat`
    that implements the `Hideable` interface. Then, a call to the `show` method for
    `misterHideable` makes the `Hideable` with three eyes appear again. The code file
    for the sample is included in the `java_9_oop_chapter_09_01` folder, in the `example09_01.java`
    file.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`merlin`的`PowerableWonderCat`类的实例。在构造函数中为`nickName`参数指定的值是`"Merlin"`。接下来的几行调用了`setLocation`和`draw`方法。然后，代码使用`misterHideable`作为`Hideable`参数调用了`useSpellToHide`方法。该方法需要一个`Hideable`参数，因此我们可以使用`HideableWonderCat`的先前创建的实例`misterHideable`，该实例实现了`Hideable`接口。然后，对`misterHideable`的`show`方法的调用使具有三只眼睛的`Hideable`再次出现。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The following code creates an instance of the `FightableWonderCat` class named
    `spartan`. The value specified for the `nickName` argument in the constructor
    is `"Spartan"`. The next lines call the `setLocation` and `draw` methods. Then,
    the code calls the `unsheathSword` method with `misterHideable` as a parameter.
    The method requires a `Hideable` argument, and therefore, we can use `misterHideable`,
    the previously created instance of `HideableWonderCat` that implements the `Hideable`
    interface. The code file for the sample is included in the `java_9_oop_chapter_09_01`
    folder, in the `example09_01.java` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建了一个名为`spartan`的`FightableWonderCat`类的实例。在构造函数中为`nickName`参数指定的值是`"Spartan"`。接下来的几行调用了`setLocation`和`draw`方法。然后，代码使用`misterHideable`作为参数调用了`unsheathSword`方法。该方法需要一个`Hideable`参数，因此我们可以使用`HideableWonderCat`的先前创建的实现`Hideable`接口的实例`misterHideable`。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, the code calls the `drawThoughtBalloon` and `drawSpeechBalloon` methods
    for `misterHideable`. We can call these methods because `misterHideable` is an
    instance of `HideableWonderCat`, and this class inherits the implementation of
    the `DrawableInComic` interface from its superclass: `WonderCat`.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码调用了`misterHideable`的`drawThoughtBalloon`和`drawSpeechBalloon`方法。我们可以调用这些方法，因为`misterHideable`是`HideableWonderCat`的一个实例，而这个类从其超类`WonderCat`继承了`DrawableInComic`接口的实现。
- en: 'The call to the `drawSpeechBalloon` method passes `spartan` as the `DrawableInComic`
    argument because `spartan` is an instance of `FightableWonderCat`, which is a
    class that also inherits the implementation of the `DrawableInComic` interface
    from its superclass: `WonderCat`. Hence, we can also use instances of `FightableWonderCat`
    whenever we need a `DrawableInComic` argument, as done in the next lines. The
    code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_01.java` file.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对`drawSpeechBalloon`方法的调用将`spartan`作为`DrawableInComic`参数，因为`spartan`是`FightableWonderCat`的一个实例，它是一个类，也从其超类`WonderCat`继承了`DrawableInComic`接口的实现。因此，我们还可以在需要`DrawableInComic`参数时使用`FightableWonderCat`的实例，就像下面的代码中所做的那样。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_01.java`文件中。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After we execute all the previously explained code snippets in JShell, we will
    see the following text output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在JShell中执行了前面解释的所有代码片段后，我们将看到以下文本输出：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Downcasting with interfaces and classes
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用接口和类进行向下转型
- en: 'The `DrawableInComic` interface defines one of the method requirements for
    the `drawSpeechBalloon` method with `destination` as an argument of the `DrawableInComic`
    type, which is the same type that the interface defines. The following is the
    first line in our sample code that called this method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`DrawableInComic`接口定义了`drawSpeechBalloon`方法的一个方法要求，其参数为`DrawableInComic`类型的`destination`，这与接口定义的类型相同。以下是我们示例代码中调用此方法的第一行：'
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We called the method implemented in the `SpiderDog` class because `teddy` is
    an instance of `SpiderDog`. We passed a `SpiderDog` instance, `winston`, to the
    `destination` argument. The method works with the `destination` argument as an
    instance that implements the `DrawableInComic` interface. Hence, whenever we reference
    the `destination` variable, we will only be able to see what the `DrawableInComic`
    type defines.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`SpiderDog`类中实现的方法，因为`teddy`是`SpiderDog`的一个实例。我们将`SpiderDog`实例`winston`传递给`destination`参数。该方法使用`destination`参数作为实现`DrawableInComic`接口的实例。因此，每当我们引用`destination`变量时，我们只能看到`DrawableInComic`类型定义的内容。
- en: 'We can easily understand what happens under the hood when Java downcasts a
    type from its original type to a target type, such as an interface to which the
    class conforms. In this case, `SpiderDog` is downcasted to `DrawableInComic`.
    If we enter the following code in JShell and press the *Tab* key, JShell will
    enumerate the members for the `SpiderDog` instance named `winston`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java将类型从其原始类型向下转换为目标类型时，例如转换为类符合的接口，我们可以很容易地理解发生了什么。在这种情况下，`SpiderDog`被向下转换为`DrawableInComic`。如果我们在JShell中输入以下代码并按*Tab*键，JShell将枚举名为`winston`的`SpiderDog`实例的成员：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'JShell will display the following members:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下成员：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Whenever we ask JShell to list the members, it will include the following members
    inherited from `java.lang.Object`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们要求JShell列出成员时，它将包括从`java.lang.Object`继承的以下成员：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Delete the previously entered code (`winston.`). If we enter the following
    code in JShell and press the *Tab* key, the `DrawableInComic` interface type enclosed
    in parentheses as a prefix for the `winston` variable forces the downcast to the
    `DrawableInComic` interface type. Hence, JShell will only enumerate the members
    for the `SpiderDog` instance named `winston` that are required members in the
    `DrawableInComic` interface:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 删除先前输入的代码（`winston.`）。如果我们在JShell中输入以下代码并按*Tab*键，括号中的`DrawableInComic`接口类型作为`winston`变量的前缀将强制将其降级为`DrawableInComic`接口类型。因此，JShell将只列举`SpiderDog`实例`winston`中作为`DrawableInComic`接口所需成员：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'JShell will display the following members:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下成员：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s take a look at the difference between the results when we entered `winston.`
    and pressed the *Tab* key, and the latest results. The displayed members in the
    last list don''t include the two methods that are defined in the `SpiderDog` class
    but aren''t required in the `DrawableInComic` interface: `speak` and `think`.
    Hence, when Java downcasts `winston` to `DrawableInComic`, we can only work with
    the members required by the `DrawableInComic` interface.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下当我们输入`winston.`并按*Tab*键时的结果与最新结果之间的区别。上一个列表中显示的成员不包括在`SpiderDog`类中定义但在`DrawableInComic`接口中不是必需的两个方法：`speak`和`think`。因此，当Java将`winston`降级为`DrawableInComic`时，我们只能使用`DrawableInComic`接口所需的成员。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If we work with any IDE that supports auto-completion features, we will notice
    that same difference in the enumeration of the members when we use the auto-completion
    features instead of pressing the *Tab* key in JShell.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用支持自动补全功能的任何IDE，我们会注意到在使用自动补全功能而不是在JShell中按*Tab*键时，成员的枚举中存在相同的差异。
- en: 'Now we will analyze another case in which we downcast an instance to one of
    the interfaces that it implements. The `DrawableInGame` interface defines a method
    requirement for the `isIntersectingWith` method with `otherDrawableInGame` as
    an argument of the `DrawableInGame` type, which is the same type that the interface
    defines. The following is the first line in our sample code that called this method:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将分析另一种情况，即将一个实例降级为其实现的接口之一。`DrawableInGame`接口为`isIntersectingWith`方法定义了一个对`DrawableInGame`类型的`otherDrawableInGame`参数的要求，这与接口定义的类型相同。以下是我们调用此方法的示例代码中的第一行：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We called the method defined within the `WonderCat` class because `misterHideable`
    is an instance of `HideableWonderCat` that inherits the implementation of the
    `isIntersectingWith` method from the `WonderCat` class. We passed a `WonderCat`
    instance, `oliver`, to the `otherDrawableInGame` argument. The method works with
    the `otherDrawableInGame` argument as an instance that implements the `DrawableInGame`
    instance. Hence, whenever we reference the `otherDrawableInGame` variable, we
    will only be able to see what the `DrawableInGame` type defines. In this case,
    `WonderCat` is downcasted to `DrawableInGame`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了`WonderCat`类中定义的方法，因为`misterHideable`是`HideableWonderCat`的一个实例，它继承了`WonderCat`类中`isIntersectingWith`方法的实现。我们将`WonderCat`实例`oliver`传递给了`otherDrawableInGame`参数。该方法使用`otherDrawableInGame`参数作为一个实现了`DrawableInGame`实例的实例。因此，每当我们引用`otherDrawableInGame`变量时，我们只能看到`DrawableInGame`类型定义的内容。在这种情况下，`WonderCat`被降级为`DrawableInGame`。
- en: 'If we enter the following code in JShell and press the *Tab* key, JShell will
    enumerate the members for the `WonderCat` instance named `oliver`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在JShell中输入以下代码并按*Tab*键，JShell将列举`WonderCat`实例`oliver`的成员：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'JShell will display the following members for `oliver`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示`oliver`的以下成员：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Delete the previously entered code (`oliver.`). If we enter the following code
    in JShell and press the *Tab* key, the `DrawableInGame` interface type enclosed
    in parentheses as a prefix for the `oliver` variable forces the downcast to the
    `DrawableInGame` interface type. Hence, JShell will only enumerate the members
    for the `WonderCat` instance named `oliver` that are required members in the `DrawableInGame`
    instance:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 删除先前输入的代码（`oliver.`）。如果我们在JShell中输入以下代码并按*Tab*键，括号中的`DrawableInGame`接口类型作为`oliver`变量的前缀将强制将其降级为`DrawableInGame`接口类型。因此，JShell将只列举`WonderCat`实例`oliver`中作为`DrawableInGame`实例所需成员：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'JShell will display the following members:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下成员：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Let's take a look at the difference between the results when we entered `oliver.`
    and pressed the *Tab* key, and the latest results. When Java downcasts `oliver`
    to `DrawableInGame`, we can only work with the members required by the `DrawableInGame`
    interface.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下当我们输入`oliver.`并按*Tab*键时的结果与最新结果之间的区别。当Java将`oliver`降级为`DrawableInGame`时，我们只能使用`DrawableInGame`接口所需的成员。
- en: 'We can use a similar syntax to force a cast of the previous expression to the
    original type, that is, to the `WonderCat` type. If we enter the following code
    in JShell and press the *Tab* key, JShell will enumerate all the members for the
    `WonderCat` instance named `oliver`, again:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的语法来强制将先前的表达式转换为原始类型，即`WonderCat`类型。如果我们在JShell中输入以下代码并按*Tab*键，JShell将再次列举`WonderCat`实例`oliver`的所有成员：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'JShell will display the following members, that is, all the members that JShell
    enumerated when we entered `oliver.` without any kind of casting and pressed the
    *Tab* key:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JShell将显示以下成员，即当我们输入`oliver.`并按*Tab*键时，JShell列举的所有成员，而没有任何类型的强制转换：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Treating instances of an interface type as a different subclass
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将接口类型的实例视为不同的子类
- en: In [Chapter 7](part0069_split_000.html#21PMQ2-bc1530b4c4784270ae8a31a7038f8341
    "Chapter 7. Members Inheritance and Polymorphism"), *Members Inheritance and Polymorphism*,
    we worked with polymorphism. The next example doesn't represent a best practice
    because polymorphism is the way to make it work. However, we will write some code
    that doesn't represent a best practice just to understand a bit more about typecasting.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](part0069_split_000.html#21PMQ2-bc1530b4c4784270ae8a31a7038f8341 "第7章。成员继承和多态性")中，*成员继承和多态性*，我们使用了多态性。下一个示例并不代表最佳实践，因为多态性是使其工作的方式。但是，我们将编写一些代码，这些代码并不代表最佳实践，只是为了更多地了解类型转换。
- en: The following lines create a method called `doSomethingWithWonderCat` in JShell.
    We will use this method to understand how we can treat an instance received with
    an interface type as a different subclass. The code file for the sample is included
    in the `java_9_oop_chapter_09_01` folder, in the `example09_02.java` file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个名为`doSomethingWithWonderCat`的方法在JShell中。我们将使用这个方法来理解如何将以接口类型接收的实例视为不同的子类。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_02.java`文件中。
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `doSomethingWithWonderCat` method receives a `WonderCat` instance in the
    `wonderCat` argument. The method evaluates many expressions that use the `instanceof`
    keyword to determine whether the instance received in the `wonderCat` argument
    is an instance of `HideableWonderCat`, `FightableWonderCat`, or `PowerableWonder`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`doSomethingWithWonderCat`方法在`wonderCat`参数中接收一个`WonderCat`实例。该方法评估了许多使用`instanceof`关键字的表达式，以确定`wonderCat`参数中接收的实例是否是`HideableWonderCat`、`FightableWonderCat`或`PowerableWonder`的实例。'
- en: In case `wonderCat` is an instance of `HideableWonderCat` or of any potential
    subclass of `HideableWonderCat`, the code declares a `HideableWonderCat` local
    variable named `hideableCat` to save the reference of `wonderCat` casted to `HideableWonderCat`.
    Then, the code calls the `hideableCat.show` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`wonderCat`是`HideableWonderCat`的实例或任何潜在的`HideableWonderCat`子类的实例，则代码声明一个名为`hideableCat`的`HideableWonderCat`局部变量，以保存`wonderCat`转换为`HideableWonderCat`的引用。然后，代码调用`hideableCat.show`方法。
- en: In case `wonderCat` is not an instance of `HideableWonderCat`, the code evaluates
    the next expression. In case `wonderCat` is an instance of `FightableWonderCat`
    or of any potential subclass of `FightableWonderCat`, the code declares a `FightableWonderCat`
    local variable named `fightableCat` to save the reference of `wonderCat` casted
    to `FightableWonderCat`. Then, the code calls the `fightableCat.unsheathSword`
    method.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`wonderCat`不是`HideableWonderCat`的实例，则代码评估下一个表达式。如果`wonderCat`是`FightableWonderCat`的实例或任何潜在的`FightableWonderCat`子类的实例，则代码声明一个名为`fightableCat`的`FightableWonderCat`局部变量，以保存`wonderCat`转换为`FightableWonderCat`的引用。然后，代码调用`fightableCat.unsheathSword`方法。
- en: In case `wonderCat` is not an instance of `FightableWonderCat`, the code evaluates
    the next expression. In case `wonderCat` is an instance of `PowerableWonderCat`
    or of any potential subclass of `PowerableWonderCat`, the code declares a `PowerableWonderCat`
    local variable named `powerableCat` to save the reference of `wonderCat` casted
    to `PowerableWonderCat`. Then, the code uses the results returned by the `powerableCat.getSpellPower()`
    method to print the spell power value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`wonderCat`不是`FightableWonderCat`的实例，则代码评估下一个表达式。如果`wonderCat`是`PowerableWonderCat`的实例或任何潜在的`PowerableWonderCat`子类的实例，则代码声明一个名为`powerableCat`的`PowerableWonderCat`局部变量，以保存`wonderCat`转换为`PowerableWonderCat`的引用。然后，代码使用`powerableCat.getSpellPower()`方法返回的结果来打印咒语能量值。
- en: Finally, if the last expression evaluates to `false`, it means that the `wonderCat`
    instance just belongs to `WonderCat`, and the code prints a message indicating
    that `WonderCat` isn't cool.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果最后一个表达式评估为`false`，则表示`wonderCat`实例只属于`WonderCat`，代码将打印一条消息，指示`WonderCat`不够酷。
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In case we have to do something similar to the code shown in this method, we
    must take advantage of polymorphism instead of using the `instanceof` keyword
    to run code based on the class to whom an instance belongs. Remember that we are
    using the example to learn a bit more about typecasting.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们必须执行类似于此方法中显示的代码的操作，我们必须利用多态性，而不是使用`instanceof`关键字基于实例所属的类来运行代码。请记住，我们使用这个示例来更多地了解类型转换。
- en: 'Now we will make many calls to the recently coded `doSomethingWithWonderCat`
    method in JShell. We will call this method with instances of `WonderCat` and its
    subclasses that we created before we declared this method. We will call the `doSomethingWithWonderCat`
    method with the following values for the `wonderCat` argument:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在JShell中多次调用最近编写的`doSomethingWithWonderCat`方法。我们将使用`WonderCat`及其子类的实例调用此方法，这些实例是在我们声明此方法之前创建的。我们将使用以下值调用`doSomethingWithWonderCat`方法作为`wonderCat`参数：
- en: '`misterHideable`: An instance of the `HideableWonderCat` class'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`misterHideable`：`HideableWonderCat`类的实例'
- en: '`spartan`: An instance of the `FightableWonderCat` class'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spartan`：`FightableWonderCat`类的实例'
- en: '`merlin`: An instance of the `PowerableWonderCat` class'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merlin`：`PowerableWonderCat`类的实例'
- en: '`oliver`: An instance of the `WonderCat` class'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oliver`：`WonderCat`类的实例'
- en: The following four lines call the `doSomethingWithWonderCat` method in JShell
    with the previously enumerated arguments. The code file for the sample is included
    in the `java_9_oop_chapter_09_01` folder, in the `example09_02.java` file.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以下四行在JShell中使用先前枚举的参数调用`doSomethingWithWonderCat`方法。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_02.java`文件中。
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following screenshot shows the output generated in JShell for the previous
    lines. Each call triggers a different type cast and calls a method of the typecasted
    instance:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了JShell为前面的行生成的输出。每次调用都会触发不同的类型转换，并调用类型转换后的实例的方法：
- en: '![Treating instances of an interface type as a different subclass](img/00086.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![将接口类型的实例视为不同的子类](img/00086.jpeg)'
- en: Taking advantage of default methods in interfaces in Java 9
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用Java 9中接口的默认方法
- en: Both the `SpiderDog` and `WonderCat` classes implement the `DrawableInComic`
    interface. All the classes that inherit from the `WonderCat` class, inherit the
    implementation of the `DrawableInComic` interface. Imagine that we have to add
    a new method requirement to the `DrawableInComic` interface and that we will create
    new classes that implement this new version of the interface. We will add a new
    `drawScreamBalloon` method that draws a scream balloon, also known as scream bubble,
    with a message.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpiderDog`和`WonderCat`类都实现了`DrawableInComic`接口。所有继承自`WonderCat`类的类都继承了`DrawableInComic`接口的实现。假设我们需要向`DrawableInComic`接口添加一个新的方法要求，并且我们将创建实现这个新版本接口的新类。我们将添加一个新的`drawScreamBalloon`方法，用于绘制一个带有消息的尖叫气泡。'
- en: 'We will add the implementation of the new method in the `SpiderDog` class.
    However, imagine that we cannot make changes to the code in one of the classes
    that implement the `DrawableInComic` interface: `WonderCat`. We have a big problem
    because as soon as we change the code for the `DrawableInComic` interface, the
    Java compiler will generate a compile error for the `WonderCat` class and we won''t
    be able to compile this class and its subclasses.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`SpiderDog`类中添加新方法的实现。但是，假设我们无法更改实现`DrawableInComic`接口的某个类的代码：`WonderCat`。这会带来一个大问题，因为一旦我们更改了`DrawableInComic`接口的代码，Java编译器将为`WonderCat`类生成编译错误，我们将无法编译这个类及其子类。
- en: In this scenario, the default methods for interfaces introduced in Java 8 and
    also available in Java 9 are extremely useful. We can declare a default implementation
    for the `drawScreamBalloon` method and include it in the new version of the `DrawableInComic`
    interface. This way, the `WonderCat` class and its subclasses will be able to
    use the default implementation for the method provided in the interface and they
    will comply with the requirements specified in the interface.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Java 8引入的接口默认方法以及Java 9中也可用的接口默认方法非常有用。我们可以为`drawScreamBalloon`方法声明一个默认实现，并将其包含在`DrawableInComic`接口的新版本中。这样，`WonderCat`类及其子类将能够使用接口中提供的方法的默认实现，并且它们将符合接口中指定的要求。
- en: The following UML diagram shows the new version of the `DrawableInComic` interface
    with the default method named `drawScreamBalloon` and the new version of the `SpiderDog`
    class that overrides the default method. Notice that the `drawScreamBalloon` method
    is the only one that doesn't use italic text because it is not an abstract method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的UML图显示了`DrawableInComic`接口的新版本，其中包含了名为`drawScreamBalloon`的默认方法，以及覆盖默认方法的`SpiderDog`类的新版本。请注意，`drawScreamBalloon`方法是唯一一个不使用斜体文本的方法，因为它不是一个抽象方法。
- en: '![Taking advantage of default methods in interfaces in Java 9](img/00087.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![利用Java 9中接口的默认方法](img/00087.jpeg)'
- en: The following lines show the code that declares the new version of the `DrawableInComic`
    interface that includes a method requirement for the `drawScreamBalloon` method
    with a default implementation. Notice the `default` keyword before the method's
    return type to indicate that we are declaring a default method. The default implementation
    calls the `drawSpeechBalloon` method that each class that implements the interface
    will declare. This way, by default, the classes that implement this interface
    will draw a speech balloon when they receive the request to draw a scream balloon.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了声明`DrawableInComic`接口的新版本的代码，其中包括对`drawScreamBalloon`方法的方法要求和默认实现。请注意，在方法的返回类型之前使用`default`关键字表示我们正在声明一个默认方法。默认实现调用了每个实现接口的类将声明的`drawSpeechBalloon`方法。这样，实现这个接口的类默认情况下将在接收到绘制尖叫气泡的请求时绘制一个对话气泡。
- en: The code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_03.java` file.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_03.java`文件中。
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: After we create the new version of the interface, JShell will reset all the
    variables that hold references of instances of classes that implement the `DrawableInComic`
    interface to `null`. Hence, we won't be able to use the instances we have been
    creating to test the changes in the interface.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建接口的新版本后，JShell将重置所有持有实现`DrawableInComic`接口的类实例引用的变量为`null`。因此，我们将无法使用我们一直在创建的实例来测试接口的更改。
- en: The following lines show the code for the new version of the `SpiderDog` class
    with the new `drawScreamBalloon` method. The new lines are highlighted. The code
    file for the sample is included in the `java_9_oop_chapter_09_01` folder, in the
    `example09_03.java` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了`SpiderDog`类的新版本的代码，其中包括新的`drawScreamBalloon`方法。新的行已经高亮显示。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_03.java`文件中。
- en: '[PRE24]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `SpiderDog` class overrides the default implementation of the `drawScreamBalloon`
    method with a new version that calls the protected `scream` method that prints
    the received `message` with a specific format that includes the `nickName` value
    as a prefix. This way, this class won't use the default implementation declared
    in the `DrawableInComic` interface and will use its own implementation instead.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpiderDog`类覆盖了`drawScreamBalloon`方法的默认实现，使用了一个调用受保护的`scream`方法的新版本，该方法以特定格式打印接收到的`message`，并将`nickName`值作为前缀。这样，这个类将不使用`DrawableInComic`接口中声明的默认实现，而是使用自己的实现。'
- en: 'In the following code, the first lines create an instance of the new version
    of the `SpiderDog` class named `rocky`, and an instance of the new version of
    the `FightableWonderCat` class named `maggie`. Then, the code calls the `drawScreamBalloon`
    method with a message for the two created instances: `rocky` and `maggie`. The
    code file for the sample is included in the `java_9_oop_chapter_09_01` folder,
    in the `example09_03.java` file.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，前几行创建了`SpiderDog`类的新版本实例`rocky`，以及`FightableWonderCat`类的新版本实例`maggie`。然后，代码调用`drawScreamBalloon`方法，并为两个创建的实例`rocky`和`maggie`传递消息。示例的代码文件包含在`java_9_oop_chapter_09_01`文件夹中的`example09_03.java`文件中。
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When we call `rocky.drawScreamBalloon`, Java executes the overridden implementation
    for this method declared in the `SpiderDog` class. When we call `maggie.drawScreamBalloon`,
    Java executes the default method declared in the `DrawableInComic` interface because
    neither the `WonderCat` nor the `FightableWonderCat` classes override the default
    implementation for this method. Don''t forget that `FightableWonderCat` is a subclass
    of `WonderCat`. The following screenshot shows the results of executing the previous
    lines in JShell:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`rocky.drawScreamBalloon`时，Java执行了在`SpiderDog`类中声明的这个方法的重写实现。当我们调用`maggie.drawScreamBalloon`时，Java执行了在`DrawableInComic`接口中声明的默认方法，因为`WonderCat`和`FightableWonderCat`类都没有重写这个方法的默认实现。不要忘记`FightableWonderCat`是`WonderCat`的子类。以下截图显示了在JShell中执行前面几行代码的结果：
- en: '![Taking advantage of default methods in interfaces in Java 9](img/00088.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![利用Java 9中接口的默认方法](img/00088.jpeg)'
- en: Test your knowledge
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'A default method allows us to declare:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认方法允许我们声明：
- en: A default constructor for an interface that Java will use when the class that
    implements the interface doesn't declare a constructor.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个默认的构造函数，当实现接口的类没有声明构造函数时，Java会使用这个默认构造函数。
- en: A method that will be called before any method is executed for the instance
    of a class that implements the interface.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现接口的类的实例执行任何方法之前将被调用的方法。
- en: A default implementation for a method in an interface that Java will use when
    a class that implements the interface doesn't provide its own implementation of
    this method.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接口中的一个方法的默认实现，当实现接口的类没有提供自己的方法实现时，Java会使用这个默认实现。
- en: 'Consider that we have an existing interface that many classes implement and
    all the classes compile without errors. If we add a default method to this interface:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们有一个现有的接口，许多类实现了这个接口，所有的类都能够编译通过而没有错误。如果我们向这个接口添加一个默认方法：
- en: The classes that implement the interface won't compile until they provide an
    implementation for the new method requirement.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口的类在提供新方法要求的实现之前不会编译。
- en: The classes that implement the interface won't compile until they provide an
    implementation for the new constructor requirement.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口的类在提供新构造函数要求的实现之前不会编译。
- en: The classes that implement the interface will compile.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现接口的类将会编译。
- en: 'Which of the following keywords allow us to determine whether an instance is
    an instance of a class that implements a specific interface:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下关键字中哪些允许我们确定一个实例是否是实现特定接口的类的实例：
- en: '`instanceof`'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`instanceof`'
- en: '`isinterfaceimplementedby`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isinterfaceimplementedby`'
- en: '`implementsinterface`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`implementsinterface`'
- en: 'Which of the following code snippets forces the downcast of the `winston` variable
    to the `DrawableInComic` interface:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些代码片段强制将`winston`变量向下转型为`DrawableInComic`接口：
- en: '`(winston as DrawableInComic)`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(winston as DrawableInComic)`'
- en: '`((DrawableInComic) < winston)`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`((DrawableInComic) < winston)`'
- en: '`((DrawableInComic) winston)`'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`((DrawableInComic) winston)`'
- en: 'Which of the following code snippets forces the downcast of the `misterHideable`
    variable to the `HideableWonderCat` class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些代码片段强制将`misterHideable`变量向下转型为`HideableWonderCat`类：
- en: '`(misterHideable as HideableWonderCat)`'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(misterHideable as HideableWonderCat)`'
- en: '`((HideableWonderCat) < misterHideable)`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`((HideableWonderCat) < misterHideable)`'
- en: '`((Hid``eableWonderCat) misterHideable)`'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`((Hid``eableWonderCat) misterHideable)`'
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned what happens under the hood when a method receives
    an argument of an interface type. We worked with methods that received arguments
    of interface types and we downcasted with interfaces and classes. We understood
    how we could treat an object as an instance of different compatible types and
    what happens when we do this. JShell allowed us to easily understand what happens
    when we use typecasting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学会了当一个方法接收一个接口类型的参数时，在幕后发生了什么。我们使用了接收接口类型参数的方法，并且通过接口和类进行了向下转型。我们理解了如何将一个对象视为不同兼容类型的实例，以及当我们这样做时会发生什么。JShell让我们能够轻松理解当我们使用类型转换时发生了什么。
- en: We took advantage of default methods in interfaces. We could add a new method
    to an interface and provide a default implementation to avoid breaking existing
    code that we couldn't edit.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用了接口中的默认方法。我们可以向接口添加一个新方法并提供默认实现，以避免破坏我们无法编辑的现有代码。
- en: Now that you have learned advanced scenarios in which we worked with interfaces,
    we are ready to maximize code reuse with generics in Java 9, which is the topic
    we are going to discuss in the next chapter.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '现在你已经学会了在接口中使用高级场景，我们准备在Java 9中通过泛型最大化代码重用，这是我们将在下一章讨论的主题。 '
