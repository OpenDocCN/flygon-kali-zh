["```c\n/* \nHeader Segment \n*/ \n\n##include <Python.h> \n##include <math.h> \n##include <numpy/arrayobject.h> \nInitialization Segment \n\n```", "```c\n(void)Py_InitModule3(name_of_module, method_array, Docstring) \n\n```", "```c\n/* \nInitialization module \n*/ \n\nPyMODINIT_FUNC \ninitnumpy_api_demo(void) \n{ \n(void)Py_InitModule3(\"numpy_api_demo\", Api_methods, \n         \"A demo to show Python and Numpy C-API\"); \nimport_array(); \n} \n\n```", "```c\nStruct PyMethodDef { \nchar *method_name; \nPyCFunction method_function; \nint method_flags; \nchar *method_docstring; \n}; \n\n```", "```c\n\n/* \nMethod array structure definition \n*/ \nstatic PyMethodDefApi_methods[] = \n{ \n{\"py_square_func\", square_func, METH_VARARGS, \"evaluate the squares\"}, \n{\"np_square\", square_nparray_func, METH_VARARGS,  \"evaluates the square in numpy array\"}, \n{NULL, NULL, 0, NULL} \n}; \n\n```", "```c\n/* \nImplementation of the actual C funtions \n*/ \n\nstatic PyObject* square_func(PyObject* self, PyObject* args) \n{ \ndouble value; \ndouble answer; \n\n/*  parse the input, from python float to c double */ \nif (!PyArg_ParseTuple(args, \"d\", &value)) \nreturn NULL; \n/* if the above function returns -1, an appropriate Python exception will \n* have been set, and the function simply returns NULL \n*/ \n\nanswer = value*value; \n\nreturn Py_BuildValue(\"f\", answer); \n} \n\n```", "```c\n// Implementation of square of numpy array \n\nstatic PyObject* square_nparray_func(PyObject* self, PyObject* args) \n{ \n\n// variable declarations \nPyArrayObject *in_array; \nPyObject      *out_array; \nNpyIter *in_iter; \nNpyIter *out_iter; \nNpyIter_IterNextFunc *in_iternext; \nNpyIter_IterNextFunc *out_iternext; \n\n// Parse the argument tuple by specifying type \"object\" and putting the reference in in_array \nif (!PyArg_ParseTuple(args, \"O!\", &PyArray_Type, &in_array)) \nreturn NULL; \n...... \n...... \n\n```", "```c\n//Construct the output from the new constructed input array \nout_array = PyArray_NewLikeArray(in_array, NPY_ANYORDER, NULL, 0); \n// Test it and if the input is nothing then just return nothing. \n{handle failure} \n\n//  Create the iterators \nin_iter = NpyIter_New(in_array, NPY_ITER_READONLY, NPY_KEEPORDER, \nNPY_NO_CASTING, NULL); \n\n// {handle failure} \n\nout_iter = NpyIter_New((PyArrayObject *)out_array, NPY_ITER_READWRITE, \nNPY_KEEPORDER, NPY_NO_CASTING, NULL); \n{handle failure} \n\nin_iternext = NpyIter_GetIterNext(in_iter, NULL); \nout_iternext = NpyIter_GetIterNext(out_iter, NULL); \n{handle failure} \n\ndouble ** in_dataptr = (double **) NpyIter_GetDataPtrArray(in_iter); \ndouble ** out_dataptr = (double **) NpyIter_GetDataPtrArray(out_iter); \n\nA simple handle failure module is like \n// {Start handling failure} \nif (in_iter == NULL) \n// remove the ref and return null \nPy_XDECREF(out_array); \nreturn NULL; \n// {End handling failure} \n\n```", "```c\n/*  iterate over the arrays */ \ndo { \n    out_dataptr =pow(**in_dataptr,2); \n} while(in_iternext(in_iter) && out_iternext(out_iter)); \n\n/*  clean up and return the result */ \nNpyIter_Deallocate(in_iter); \nNpyIter_Deallocate(out_iter); \nPy_INCREF(out_array); \nreturn out_array; \n\n```", "```py\nfrom distutils.core import setup, Extension \nimport numpy \n## define the extension module \ndemo_module = Extension('numpy_api_demo', sources=['numpy_api.c'], \ninclude_dirs=[numpy.get_include()]) \n\n## run the setup \nsetup(ext_modules=[demo_module]) \n\n```", "```py\npython setup.py build_ext -inplace \n\n```", "```py\n>>>import numpy_api_demo as npd \n>>> import numpy as np \n>>>npd.py_square_func(4) \n>>> 16.0 \n>>> x = np.arange(0,10,1) \n>>> y = npd.np_square(x) \n\n```"]