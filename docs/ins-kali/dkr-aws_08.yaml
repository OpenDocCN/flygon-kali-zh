- en: Deploying Applications Using ECS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECS部署应用程序
- en: In the previous chapter, you learned how to configure and deploy ECS clusters
    in AWS using EC2 Auto Scaling groups, and the goal of this chapter is to deploy
    ECS applications to your newly built ECS cluster using CloudFormation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何使用EC2自动扩展组在AWS中配置和部署ECS集群，本章的目标是使用CloudFormation将ECS应用程序部署到您新建的ECS集群。
- en: You will first get started learning how to define and deploy the various supporting
    resources that are typically required for ECS applications in a production-grade
    environment. These resources include creating an application database to store
    data for your application, deploying application load balancers to service and
    load balance requests to your application, and configuring other resources, such
    as IAM roles and security groups, that control access to and from your application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 您将首先开始学习如何定义和部署通常在生产环境中ECS应用程序中所需的各种支持资源。这些资源包括创建应用程序数据库以存储应用程序的数据，部署应用程序负载均衡器以服务和负载均衡对应用程序的请求，以及配置其他资源，例如IAM角色和安全组，以控制对应用程序的访问和从应用程序的访问。
- en: With these supporting resources in place, you will proceed to create ECS task
    definitions that define the run-time configuration of your containers and then
    configure ECS services that deploy your ECS task definitions to your ECS clusters,
    and also integrate with your application load balancers to manage features, such
    as rolling deployments. Finally, you will learn how to create CloudFormation custom
    resources to perform custom provisioning tasks, such as running database migrations,
    providing you with a complete application deployment framework based upon AWS
    CloudFormation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些支持资源，您将继续创建ECS任务定义，定义容器的运行时配置，然后配置ECS服务，将ECS任务定义部署到ECS集群，并与应用程序负载均衡器集成，以管理滚动部署等功能。最后，您将学习如何创建CloudFormation自定义资源，执行自定义的配置任务，例如运行数据库迁移，为您提供基于AWS
    CloudFormation的完整应用程序部署框架。
- en: 'The following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: Creating an application database using RDS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RDS创建应用程序数据库
- en: Configuring Application Load Balancers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置应用程序负载均衡器
- en: Creating ECS task definitions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ECS任务定义
- en: Deploying ECS services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署ECS服务
- en: ECS rolling deployments
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECS滚动部署
- en: Creating a CloudFormation custom resource
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建CloudFormation自定义资源
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists the technical requirements to complete this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: Administrator access to an AWS account
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS账户的管理员访问权限
- en: Local AWS profile configured as per instructions in Chapter 3
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地AWS配置文件按第3章的说明配置
- en: AWS CLI
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI
- en: This chapter continues on from Chapter 7 so requires you have successfully completed
    all configuration tasks defined there
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章将继续自第7章开始，因此需要您成功完成那里定义的所有配置任务
- en: The following GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch4)
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下GitHub URL包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch8)[.](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch4)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2Mx8wHX](http://bit.ly/2Mx8wHX)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2Mx8wHX](http://bit.ly/2Mx8wHX)'
- en: Creating an application database using RDS
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RDS创建应用程序数据库
- en: The sample todobackend application includes a MySQL database that is used to
    persist todo items that are created through the application API. When you first
    set up and ran the sample application back in Chapter 1, you used a Docker container
    to provide the application database, however, in production-grade environments,
    it is generally considered best practice to run databases, and other services
    that provide persistent storage, on dedicated machines optimized specifically
    for database and data access operations. One such service in AWS is the relational
    database services (RDS), which provides dedicated managed instances optimized
    for providing popular relational database engines, including MySQL, Postgres,
    SQL Server, and Oracle. RDS is a very mature and robust service, and is very commonly
    used to support database requirements for both ECS and other applications that
    are run in AWS.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 示例todobackend应用程序包括一个MySQL数据库，用于持久化通过应用程序API创建的待办事项。当您在第1章首次设置和运行示例应用程序时，您使用Docker容器提供应用程序数据库，但是在生产级环境中，通常认为最佳做法是在专门为数据库和数据访问操作进行了优化的专用机器上运行数据库和其他提供持久性存储的服务。AWS中的一个这样的服务是关系数据库服务（RDS），它提供了专用的托管实例，针对提供流行的关系数据库引擎进行了优化，包括MySQL、Postgres、SQL
    Server和Oracle。RDS是一个非常成熟和强大的服务，非常常用于支持在AWS中运行的ECS和其他应用程序的数据库需求。
- en: 'RDS instances can be configured using CloudFormation. To get started, let''s
    define a new resource in your todobackend CloudFormation template called `ApplicationDatabase`,
    with an `AWS::RDS::DBInstance` resource type, as demonstrated in the following
    example:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用CloudFormation配置RDS实例。要开始，让我们在您的todobackend CloudFormation模板中定义一个名为`ApplicationDatabase`的新资源，其资源类型为`AWS::RDS::DBInstance`，如下例所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating RDS resources
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建RDS资源
- en: 'The configuration in the preceding example is considered a minimal configuration
    for defining RDS instances, as described here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的配置被认为是定义RDS实例的最小配置，如下所述：
- en: '`Engine` and `EngineVersion`: The database engine, which in this case is MySQL,
    along with the major or minor version to deploy.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Engine`和`EngineVersion`：数据库引擎，在本例中是MySQL，以及要部署的主要或次要版本。'
- en: '`DBInstanceClass`: The RDS instance type to run the database on. To ensure
    you qualify for free-tier access, you hardcode this to `db.t2.micro`, although
    you would typically parameterize this property to use larger instance sizes for
    your production environments.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBInstanceClass`：用于运行数据库的RDS实例类型。为了确保您有资格获得免费使用，您可以将其硬编码为`db.t2.micro`，尽管在生产环境中，您通常会将此属性参数化为更大的实例大小。'
- en: '`AllocatedStorage` and `StorageType`: Defines the amount of storage in GB and
    the storage type. In the first example, the storage type is set to 10 GB of SSD-based
    gp2 (general purpose 2) storage.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AllocatedStorage`和`StorageType`：定义以GB为单位的存储量和存储类型。在第一个示例中，存储类型设置为10GB的基于SSD的gp2（通用用途2）存储。'
- en: '`MasterUsername` and `MasterUserPassword`: Specifies the master username and
    password configured for the RDS instance. The `MasterUserPassword` property references
    an input parameter called `DatabasePassword`, which includes a property called
    `NoEcho` that ensures CloudFormation will not print the value of this parameter
    in any logs.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MasterUsername`和`MasterUserPassword`：指定为RDS实例配置的主用户名和密码。`MasterUserPassword`属性引用了一个名为`DatabasePassword`的输入参数，其中包括一个名为`NoEcho`的属性，确保CloudFormation不会在任何日志中打印出此参数的值。'
- en: '`DBName`: Specifies the name of the database.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBName`：指定数据库的名称。'
- en: '`VPCSecurityGroups`: List of security groups to apply to network communications
    ingress and egress from the RDS instance.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VPCSecurityGroups`：要应用于RDS实例的网络通信入口和出口的安全组列表。'
- en: '`DBSubnetGroupName`: References a resource of the `AWS::RDS::DBSubnetGroup` type,
    which defines the subnets that the RDS instance can be deployed to. Note that
    even if you only configure a single-availability-zone RDS instance, you still
    need to reference a least two subnets in the database subnet group resource you
    create. In the preceding example, you reference a resource called `ApplicationDatabaseSubnetGroup`,
    which you''ll create shortly.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DBSubnetGroupName`：引用`AWS::RDS::DBSubnetGroup`类型的资源，该资源定义RDS实例可以部署到的子网。请注意，即使您只配置了单可用区RDS实例，您仍然需要引用您创建的数据库子网组资源中的至少两个子网。在前面的例子中，您引用了一个名为`ApplicationDatabaseSubnetGroup`的资源，稍后将创建该资源。'
- en: '`MultiAZ`: Defines whether or not to deploy the RDS instance in a highly available
    multi-availability-zone configuration. For the purposes of the demonstration application,
    this setting can be configured as `false`, however in a real-world application,
    you would typically configure this setting as `true`, at least for your production
    environments.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MultiAZ`：定义是否在高可用的多可用区配置中部署RDS实例。对于演示应用程序，可以将此设置配置为`false`，但在实际应用程序中，您通常会将此设置配置为`true`，至少对于生产环境是这样。'
- en: '`AvailabilityZone`: Defines the availability zone that the RDS instance will
    be deployed to. This setting is only applicable for single-availability-zone instances
    (that is, an instance with `MultiAZ` set to false). In the preceding example,
    you use the `AWS::Region` pseudo-parameter to reference availability zone `a` in
    your local region.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AvailabilityZone`：定义RDS实例将部署到的可用区。此设置仅适用于单可用区实例（即`MultiAZ`设置为false的实例）。在前面的例子中，您使用`AWS::Region`伪参数来引用本地区域中可用区`a`。'
- en: Configuring supporting RDS resources
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置支持的RDS资源
- en: 'Referring back to the preceding example, it is clear that you need to configure
    at least two additional supporting resources for the RDS instance:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾前面的例子，很明显您需要配置至少两个额外的支持资源用于RDS实例：
- en: '`ApplicationDatabaseSecurityGroup`: A security group resource that defines
    the ingress and egress security rules applied to the RDS instance.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationDatabaseSecurityGroup`：定义应用于RDS实例的入站和出站安全规则的安全组资源。'
- en: '`ApplicationDatabaseSubnetGroup`: A list of subnets that the RDS instance can
    be deployed to.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationDatabaseSubnetGroup`：RDS实例可以部署到的子网列表。'
- en: 'In addition to these resources, the following example demonstrates we also
    need to add a few more:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些资源，以下示例还演示了我们还需要添加一些资源：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating supporting RDS resources
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 创建支持的RDS资源
- en: In the preceding example, you first create the database subnet group resource,
    with the SubnetIds property referencing the same `ApplicationSubnets` list parameter
    you created in Chapter 7, meaning your database instance will be installed in
    the same subnets as your application ECS cluster and EC2 Auto Scaling group instances.
    In a production application, you would typically run your RDS instances on a separate
    dedicated subnet, ideally with no route to the internet for security purposes,
    however in the interests of keeping our example simple, we will just leverage
    the same subnet as the application ECS cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您首先创建了数据库子网组资源，其中SubnetIds属性引用了您在第7章中创建的相同的`ApplicationSubnets`列表参数，这意味着您的数据库实例将安装在与应用程序ECS集群和EC2自动扩展组实例相同的子网中。在生产应用程序中，您通常会在单独的专用子网上运行RDS实例，理想情况下，出于安全目的，该子网不会连接到互联网，但出于简化示例的目的，我们将利用与应用程序ECS集群相同的子网。
- en: You next create a security group resource called `ApplicationDatabaseSecurityGroup`,
    and notice that this only contains a single egress rule, which somewhat curiously
    permits ICMP access to the IP address `192.0.2.0/32`. This IP address is a special
    address that is part of the "TEST-NET" IP address range, which is an invalid IP
    address on the internet and is intended for use in example code and documentation.
    The reason for including this as an egress rule is that, by default, AWS automatically
    applys an allow any rule on egress unless you explicitly override these rules,
    so by adding a single rule that permits access to an unroutable IP address, you
    are effectively blocking any outbound communications from being initiated by the
    RDS instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您创建了一个名为`ApplicationDatabaseSecurityGroup`的安全组资源，并注意到它只包含一个出站规则，有点奇怪的是允许对IP地址`192.0.2.0/32`进行ICMP访问。这个IP地址是"TEST-NET"
    IP地址范围的一部分，是互联网上的无效IP地址，用于示例代码和文档。包含这个作为出站规则的原因是，AWS默认情况下会自动应用一个允许任何规则的出站规则，除非您明确覆盖这些规则，因此通过添加一个允许访问无法路由的IP地址的规则，您实际上阻止了RDS实例发起的任何出站通信。
- en: 'Finally, notice that you create two security-group-related resources, `ApplicationToApplicationDatabaseIngress`
    and `ApplicationToApplicationDatabaseEgress`, that respectively have resource
    types of `AWS::EC2::SecurityGroupIngress` and `AWS::EC2::SecurityGroupEgress`.
    These special resources avoid an issue known as circular dependencies in CloudFormation,
    where you create a circular dependency between two resources that need to reference
    each other for some reason. In our specific scenario, we want to allow members
    of the `ApplicationAutoscalingSecurityGroup` access to members of the `ApplicationDatabaseSecurityGroup`,
    with appropriate security rules applied ingress to the application database, and
    also applied egress from application instances. If you try to configure these
    rules as demonstrated in the following diagram, CloudFormation will throw an error
    and detect a circular dependency:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，您创建了两个与安全组相关的资源，`ApplicationToApplicationDatabaseIngress`和`ApplicationToApplicationDatabaseEgress`，它们分别具有`AWS::EC2::SecurityGroupIngress`和`AWS::EC2::SecurityGroupEgress`的资源类型。这些特殊资源避免了在CloudFormation中出现的一个问题，即创建了两个需要相互引用的资源之间的循环依赖。在我们的具体场景中，我们希望允许`ApplicationAutoscalingSecurityGroup`的成员访问`ApplicationDatabaseSecurityGroup`的成员，并应用适当的安全规则，从应用程序数据库中进行入站访问，并从应用程序实例中进行出站访问。如果您尝试按照以下图表所示的规则进行配置，CloudFormation将抛出错误并检测到循环依赖。
- en: '![](assets/0139e646-f450-4086-99aa-09fc2e454a4a.png)CloudFormation circular
    dependencies'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/0139e646-f450-4086-99aa-09fc2e454a4a.png)CloudFormation循环依赖'
- en: To address this, the following diagram demonstrates an alternative approach
    using the resources you created in the previous example.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，以下图表演示了一种替代方法，使用了您在上一个示例中创建的资源。
- en: 'The `ApplicationToApplicationDatabaseIngress` resource will dynamically create
    an ingress rule in `ApplicationDatabaseSecurityGroup` (as specified by the `GroupId`
    property), which permits access to the MySQL port (TCP/3306) from `ApplicationAutoscalingSecurityGroup`
    (as specified by the `SourceSecurityGroupId` property). Similarly, the `ApplicationToApplicationDatabaseEgress` resource
    will dynamically create an egress rule in `ApplicationAutoscalingSecurityGroup` (as
    specified by the `GroupId` property), which permits access to the MySQL port (TCP/3306)
    associated with instances that belong to `ApplicationDatabaseSecurityGroup` (as
    specified by the `DestinationSecurityGroupId` property). This ultimately achieves
    the intention of the configuration illustrated in the preceding diagram, but without
    causing any circular dependency errors in CloudFormation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApplicationToApplicationDatabaseIngress`资源将动态创建`ApplicationDatabaseSecurityGroup`中的入口规则（由`GroupId`属性指定），允许从`ApplicationAutoscalingSecurityGroup`（由`SourceSecurityGroupId`属性指定）访问MySQL端口（TCP/3306）。同样，`ApplicationToApplicationDatabaseEgress`资源将动态创建`ApplicationAutoscalingSecurityGroup`中的出口规则（由`GroupId`属性指定），允许访问属于`ApplicationDatabaseSecurityGroup`的实例的MySQL端口（TCP/3306）（由`DestinationSecurityGroupId`属性指定）。这最终实现了前面图表中所示配置的意图，但不会在CloudFormation中引起任何循环依赖错误。'
- en: '![](assets/4abce996-823e-4813-a977-7975e8894666.png)Solving CloudFormation
    circular dependencies'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4abce996-823e-4813-a977-7975e8894666.png)解决CloudFormation循环依赖'
- en: Deploying RDS resources using CloudFormation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署RDS资源
- en: 'With the configuration of the previous examples in place, you can now actually
    update your CloudFormation stack, which will add in the RDS instance and other
    supporting resources. Before you can do this, you need to update the `dev.cfg`
    file you created in Chapter 7, which provides environment specific values for
    the input parameters you need to provide to your CloudFormation stack. Specifically,
    you need to specify a value for the `MasterPassword` parameter, as demonstrated
    in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例的配置完成后，您现在可以实际更新CloudFormation堆栈，其中将添加RDS实例和其他支持资源。在执行此操作之前，您需要更新第7章中创建的`dev.cfg`文件，该文件为您的CloudFormation堆栈提供了环境特定的输入参数值。具体来说，您需要为`MasterPassword`参数指定一个值，如下例所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding a database password to the dev.cfg file
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 向dev.cfg文件添加数据库密码
- en: Now at this point, if you are alarmed that you are providing a password in clear
    text that will eventually be committed to source code, then well done, you are
    absolutely 100% correct to be very concerned about this approach. In the next
    chapter, we will deal specifically with managing credentials securely, but for
    now we won't address this, so bear in mind the approach demonstrated in the preceding
    example is not considered best practice and we will only leave this in place temporarily
    to get your application database instance up and running.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，如果您对于以明文提供最终将提交到源代码中的密码感到担忧，那么恭喜您，您对于这种方法感到非常担忧是完全正确的。在接下来的章节中，我们将专门讨论如何安全地管理凭据，但目前我们不会解决这个问题，因此请记住，上述示例中演示的方法并不被认为是最佳实践，我们只会暂时保留这个方法来使您的应用数据库实例正常运行。
- en: 'With the configuration of the preceding example in place, you can now proceed
    to deploy your updated stack using the `aws cloudformation deploy` command you
    previously used in Chapter 7:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例的配置完成后，您现在可以使用在第7章中使用过的`aws cloudformation deploy`命令来部署更新后的堆栈。
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Updating a CloudFormation stack with RDS resources
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RDS资源更新CloudFormation堆栈
- en: The deployment will take some time (typically 15-20 minutes) to complete, and
    once the deployment has completed, notice that you can use the `aws cloudformation
    describe-stack-resource` command to obtain further information about the `ApplicationDatabase`
    resource, including the `PhysicalResourceId` property, which specifies the RDS
    instance identifier.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 部署将需要一些时间（通常为15-20分钟）才能完成，一旦部署完成，请注意您可以使用`aws cloudformation describe-stack-resource`命令获取有关`ApplicationDatabase`资源的更多信息，包括`PhysicalResourceId`属性，该属性指定了RDS实例标识符。
- en: Configuring Application Load Balancers
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用负载均衡器
- en: We have established an ECS cluster and created an application database to store
    application data, and we next need to create the frontend infrastructure that
    will service connections from the outside world to our Docker applications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经建立了一个ECS集群并创建了一个应用程序数据库来存储应用程序数据，接下来我们需要创建前端基础设施，以服务于外部世界对我们的Docker应用程序的连接。
- en: 'A popular approach within AWS to provide such infrastructure is to leverage
    the Elastic Load Balancing service, which provides a number of different options
    for load balancing connections to your applications:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在AWS中提供这种基础设施的一种流行方法是利用弹性负载均衡服务，该服务提供了多种不同的选项，用于负载均衡连接到您的应用程序：
- en: '**Classic Elastic Load Balancers**: The original AWS load balancer that supports
    Layer 4 (TCP) load balancing. In general, you should use either the newer Application
    Load Balancer or the network load balancer, which collectively provide all of
    the existing functionality of classic load balancers and much more.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经典弹性负载均衡器**：原始的AWS负载均衡器，支持第4层（TCP）负载均衡。一般来说，您应该使用较新的应用负载均衡器或网络负载均衡器，它们共同提供了经典负载均衡器的所有现有功能以及更多功能。'
- en: '**Application Load Balancers**: An HTTP-aware load balancer that specifically
    targets web-based applications and APIs.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用负载均衡器**：一种特别针对基于Web的应用程序和API的HTTP感知负载均衡器。'
- en: '**Network Load Balancers**: A high performance Layer 4 (TCP) load-balancing
    service, typically used for non-HTTP TCP-based applications, or applications that
    require very high performance.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络负载均衡器**：高性能的第4层（TCP）负载均衡服务，通常用于非HTTP基于TCP的应用程序，或者需要非常高性能的应用程序。'
- en: For our purposes, we will leverage the Application Load Balancer (ALB), which
    is a modern Layer 7 load balancer that can perform advanced actions based upon
    HTTP protocol information, such as host-header and path-based routing. For example,
    an ALB can route requests for a given HTTP host header to a given set of targets,
    and can also route requests for the some.domain/foo path to one group of targets,
    and requests for the some.domain/bar path to a different set of targets.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将利用应用负载均衡器（ALB），这是一个现代的第7层负载均衡器，可以根据HTTP协议信息执行高级操作，例如基于主机头和基于路径的路由。例如，ALB可以将针对特定HTTP主机头的请求路由到一组特定的目标，并且还可以将针对some.domain/foo路径的请求路由到一组目标，将针对some.domain/bar路径的请求路由到另一组目标。
- en: 'The AWS ALB integrates with the Elastic Container Service, supporting a number
    of key integration features:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: AWS ALB与弹性容器服务集成，支持许多关键的集成功能：
- en: '**Rolling updates**: ECS services can be deployed in a rolling fashion, with
    ECS leveraging the load balancer connection draining to take old versions of your
    applications out of service gracefully, terminate and replace each application
    container with a new version, and then add your new containers to the load balancer,
    ensuring updates are performed with no end user outages or impact.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动更新**：ECS服务可以以滚动方式部署，ECS利用负载均衡器连接排空来优雅地将旧版本的应用程序停止服务，终止并替换每个应用程序容器为新版本，然后将新容器添加到负载均衡器，确保更新在没有最终用户中断或影响的情况下进行。'
- en: '**Dynamic port mapping**: This feature allows you to map your container port
    to a dynamic port on the ECS container instance, with ECS taking care of ensuring
    the dynamic port mapping is correctly registered with the Application Load Balancer.
    The primary benefit of dynamic port mapping is that it allows multiple instances
    of the same application container to run on a single ECS container instance, providing
    much greater flexibility around dimensioning and scaling your ECS clusters.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态端口映射**：此功能允许您将容器端口映射到 ECS 容器实例上的动态端口，ECS 负责确保动态端口映射正确地注册到应用负载均衡器。动态端口映射的主要好处是它允许同一应用程序容器的多个实例在单个
    ECS 容器实例上运行，从而在维度和扩展 ECS 集群方面提供了更大的灵活性。'
- en: '**Health checks**: ECS using Application Load Balancer health checks to determine
    the health of your Docker applications, automatically terminating and replacing
    any containers that may become unhealthy and fail load balancer health checks.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健康检查**：ECS 使用应用负载均衡器的健康检查来确定您的 Docker 应用程序的健康状况，自动终止和替换任何可能变得不健康并且无法通过负载均衡器健康检查的容器。'
- en: Application Load Balancer architecture
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用负载均衡器架构
- en: If you are familiar with the older classic Elastic Load Balancers, you will
    find that the architecture of the newer Application Load Balancers is more complex,
    given the nature of the advanced Layer 7/HTTP capabilities the ALBs support.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉旧版经典弹性负载均衡器，您会发现新版应用负载均衡器的架构更加复杂，因为 ALB 支持高级的第 7 层/HTTP 功能。
- en: 'The following diagram shows the various components that comprise an Application
    Load Balancer:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了组成应用负载均衡器的各种组件：
- en: '![](assets/7797ed7f-45ba-49b0-aca7-5116fd62bb32.png)Application Load Balancer
    components'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 应用负载均衡器组件
- en: 'The following describes each of the components illustrated in the preceding
    diagram:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下描述了上图中所示的每个组件：
- en: '**Application Load Balancer**: The Application Load Balancer is a physical
    resource that defines physical characteristics of the load balancer, such as the
    subnets the load balancer should run in and security groups that permit or deny
    network traffic to or from the load balancer.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用负载均衡器**：应用负载均衡器是定义负载均衡器的物理资源，例如负载均衡器应该运行在哪些子网以及允许或拒绝网络流量到负载均衡器或从负载均衡器流出的安全组。'
- en: '**Listener**: A listener defines a network port that end users and devices
    attach to. You can think of the listener as the frontend component of the load
    balancer, servicing incoming connections that ultimately will be routed to target
    groups that host your applications. Each Application Load Balancer can include
    multiple listeners—a common example of this might be a listener configuration
    that services both port `80` and port `443` network traffic.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听器**：监听器定义了终端用户和设备连接的网络端口。您可以将监听器视为负载均衡器的前端组件，为传入连接提供服务，最终将被路由到托管应用程序的目标组。每个应用负载均衡器可以包括多个监听器——一个常见的例子是监听器配置，可以为端口`80`和端口`443`的网络流量提供服务。'
- en: '**Listener rule**: A listener rule optionally routes HTTP traffic received
    by a listener to different target groups, based upon the value of the received
    host header and/or request path. For example, as demonstrated in the preceding
    diagram, you might route all traffic sent to the `/foo/*` request path to one
    target group, whilst all traffic sent to `/bar/*` might be routed to the another
    target group. Note that every listener must define a default target group, where
    all traffic that does not route a listener rule will be routed to.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监听规则**：监听规则可选择性地根据接收到的主机标头和/或请求路径的值将由监听器接收的HTTP流量路由到不同的目标组。例如，如前图所示，您可以将发送到`/foo/*`请求路径的所有流量路由到一个目标组，而将发送到`/bar/*`的所有流量路由到另一个目标组。请注意，每个监听器必须定义一个默认目标组，所有未路由到监听规则的流量将被路由到该目标组。'
- en: '**Target group**: A target group defines one or more targets that incoming
    connections should be routed to. You can think of the target group as the backend
    component of the load balancer, responsible for load-balancing-received connections
    to members within the target group. When integrating application load balancers
    with ECS, the target group is linked to an ECS service, with each instance of
    the ECS service (that is, container) considered a single target.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标组**：目标组定义了应该路由到的一个或多个目标的传入连接。您可以将目标组视为负载均衡器的后端组件，负责将接收到的连接负载均衡到目标组中的成员。在将应用程序负载均衡器与ECS集成时，目标组链接到ECS服务，每个ECS服务实例（即容器）被视为单个目标。'
- en: Configuring an Application Load Balancer
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序负载均衡器
- en: Now that you understand the basic architecture of application load balancers,
    let's define the various Application Load Balancer components in your CloudFormation
    template and proceed to deploy the new resources to your CloudFormation stack.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了应用程序负载均衡器的基本架构，让我们在您的CloudFormation模板中定义各种应用程序负载均衡器组件，并继续将新资源部署到您的CloudFormation堆栈中。
- en: Creating an Application Load Balancer
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建应用程序负载均衡器
- en: 'The following example demonstrates adding a resource called `ApplicationLoadBalancer`,
    which, as the name suggests, configures the base Application Load Balancer resource:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何添加一个名为`ApplicationLoadBalancer`的资源，正如其名称所示，它配置了基本的应用程序负载均衡器资源：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating an Application Load Balancer
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序负载均衡器
- en: 'In the preceding example, the following properties are configured for the Application
    Load Balancer resource:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，为应用程序负载均衡器资源配置了以下属性：
- en: '`Scheme`: Defines whether the load balancer has public IP addressing (as specified
    by a value of `internet-facing`) or only has private IP addressing (as specified
    by a value of `internal`)'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`方案`：定义负载均衡器是否具有公共IP地址（由值`internet-facing`指定）或仅具有私有IP地址（由值`internal`指定）'
- en: '`Subnets`: Defines the subnets that the Application Load Balancer endpoints
    will be deployed to. In the preceding example, you reference the `ApplicationSubnets`
    input parameter, which you have previously used for the EC2 Auto Scaling group
    and RDS database instance resources.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`子网`：定义了应用程序负载均衡器端点将部署到的子网。在上述示例中，您引用了`ApplicationSubnets`输入参数，该参数之前已用于EC2自动扩展组和RDS数据库实例资源。'
- en: '`SecurityGroups`: Specifies a list of security groups to apply to the load
    balancer, which restricts ingress and egress network traffic. You reference a
    single security group called `ApplicationLoadBalancerSecurityGroup`, which you
    will create shortly.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`安全组`：指定要应用于负载均衡器的安全组列表，限制入站和出站网络流量。您引用了一个名为`ApplicationLoadBalancerSecurityGroup`的安全组，稍后将创建该安全组。'
- en: '`LoadBalancerAttributes`: Configures various attributes of the Application
    Load Balancer in a key/value format. You can find a list of supported attributes
    at [https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes),
    and in the preceding example, you configure a single attribute that reduces the
    idle connection timeout from the default value of `60` seconds to `30` seconds.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadBalancerAttributes`：以键/值格式配置应用程序负载均衡器的各种属性。您可以在[https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/application-load-balancers.html#load-balancer-attributes)找到支持的属性列表，在前面的示例中，您配置了一个属性，将空闲连接超时从默认值`60`秒减少到`30`秒。'
- en: 'A feature of CloudFormation is the ability to define your own *outputs*, which
    can be used to provide information about resources in your stack.  One useful
    output that you can configure for your stack is the value of the public DNS name
    of the application load balancer endpoint, as this is where any applications served
    by the load balancer will be published:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation的一个特性是能够定义自己的*输出*，这些输出可用于提供有关堆栈中资源的信息。您可以为堆栈配置一个有用的输出，即应用程序负载均衡器端点的公共DNS名称的值，因为这是负载均衡器提供的任何应用程序发布的地方：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Configuring a CloudFormation Output
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 配置CloudFormation输出
- en: In the preceding example, notice that the `ApplicationLoadBalancer` resource
    outputs a property called `DNSName`, which returns the public DNS name of the
    `ApplicationLoadBalancer` resource.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，请注意`ApplicationLoadBalancer`资源输出一个名为`DNSName`的属性，该属性返回`ApplicationLoadBalancer`资源的公共DNS名称。
- en: Configuring Application Load Balancer security groups
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置应用程序负载均衡器安全组
- en: In the preceding example, you referenced a resource called `ApplicationLoadBalancerSecurityGroup`,
    which defines ingress and egress network access to and from your Application Load
    Balancer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您引用了一个名为`ApplicationLoadBalancerSecurityGroup`的资源，该资源定义了对应用程序负载均衡器的入站和出站网络访问。
- en: 'In addition to this resource, you also need to create `AWS::EC2::SecurityGroupIngress`
    and `AWS::EC2::SecurityGroupEgress` resources in a similar manner earlier example,
    which ensure the Application Load Balancer can communicate with your ECS service
    application instances:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个资源，您还需要以类似的方式创建`AWS::EC2::SecurityGroupIngress`和`AWS::EC2::SecurityGroupEgress`资源，这些资源确保应用程序负载均衡器可以与您的ECS服务应用程序实例通信：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Configuring Application Load Balancer security group resources
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 配置应用程序负载均衡器安全组资源
- en: In the preceding example, you first create the `ApplicationLoadBalancerSecurityGroup`
    resource, permitting ingress access to port 80 from the Internet. The `ApplicationLoadBalancerToApplicationIngress`
    and `ApplicationLoadBalancerToApplicationEgress` resources add security rules
    to the `ApplicationLoadBalancerSecurityGroup` and `ApplicationAutoscalingSecurityGroup`
    resources without creating circular dependencies (refer back to the previous diagram
    and the associated description), and notice that these rules reference the ephemeral
    port range of `32768` to `60999` on the application Auto Scaling group, given
    we will be configuring dynamic port mapping for your ECS services.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您首先创建了`ApplicationLoadBalancerSecurityGroup`资源，允许从互联网访问端口80。`ApplicationLoadBalancerToApplicationIngress`和`ApplicationLoadBalancerToApplicationEgress`资源向`ApplicationLoadBalancerSecurityGroup`和`ApplicationAutoscalingSecurityGroup`资源添加安全规则，而不会创建循环依赖（请参阅前面的图表和相关描述），请注意这些规则引用了应用程序自动缩放组的短暂端口范围`32768`到`60999`，因为我们将为您的ECS服务配置动态端口映射。
- en: Creating a listener
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个监听器
- en: Now that you have established the base Application Load Balancer and related
    security group resources, you can configure a listener for the Application Load
    Balancer. For the purposes of this book, you only need to configure a single listener
    that will service HTTP connections, however in any real-world production use case,
    you would typically configure an HTTPS listener with associated certificates,
    especially for any internet-facing service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经建立了基本的应用程序负载均衡器和相关的安全组资源，可以为应用程序负载均衡器配置一个监听器。对于本书的目的，您只需要配置一个支持HTTP连接的单个监听器，但在任何真实的生产用例中，您通常会为任何面向互联网的服务配置HTTPS监听器以及相关证书。
- en: 'The following example demonstrates configuring a single listener that supports
    access to the Application Load Balancer using port `80` (HTTP):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了配置一个支持通过端口`80`（HTTP）访问应用程序负载均衡器的单个监听器：
- en: '[PRE8]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating an Application Load Balancer listener
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 创建应用程序负载均衡器监听器
- en: In the preceding example, the listener is bound to the `ApplicationLoadBalancer`
    resource via the `LoadBalancerArn` property, with the `Protocol` and `Port` properties
    configuring the listener to expect incoming HTTP connections on port `80`. Notice
    that you must define the `DefaultActions` property, which defines the default
    target group that incoming connections will be forwarded to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，通过`LoadBalancerArn`属性将监听器绑定到`ApplicationLoadBalancer`资源，`Protocol`和`Port`属性配置监听器以期望在端口`80`上接收传入的HTTP连接。请注意，您必须定义`DefaultActions`属性，该属性定义了传入连接将被转发到的默认目标组。
- en: Creating a target group
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建目标组
- en: The final configuration task related to configuring an Application Load Balancer
    is to configure a target group, which will be used to forward incoming requests
    received by the listener resource to your application instances.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与配置应用程序负载均衡器相关的最终配置任务是配置目标组，该目标组将用于将监听器资源接收的传入请求转发到应用程序实例。
- en: 'The following example demonstrates configuring a target group resource:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了配置目标组资源：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a target group
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建目标组
- en: 'In the preceding example, the following configuration is defined for the target
    group:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，为目标组定义了以下配置：
- en: '`Protocol`: Defines the protocol of connections that will be forwarded to the
    target group.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol`：定义将转发到目标组的连接的协议。'
- en: '`Port`: Specifies the container port your application will run on. By default,
    the todobackend sample application runs on port `8000`, so you can configure this
    value for the port. Note that ECS will dynamically reconfigure this port when
    dynamic port mapping is configured.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Port`：指定应用程序将运行的容器端口。默认情况下，todobackend示例应用程序在端口`8000`上运行，因此您可以为端口配置此值。请注意，当配置动态端口映射时，ECS将动态重新配置此端口。'
- en: '`VpcId`: Configures the VPC ID where your targets are located.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VpcId`：配置目标所在的VPC ID。'
- en: '`TargetGroupAttributes`: Defines the configuration attributes ([https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes))
    for the target group. In the preceding example, the `deregistration_delay.timeout_seconds`
    attribute configures the time to wait before deregistering a target, which takes
    place when draining connections during a rolling deployment of your application.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetGroupAttributes`：定义了目标组的配置属性（[https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes](https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-target-groups.html#target-group-attributes)），在上面的示例中，`deregistration_delay.timeout_seconds`属性配置了在滚动部署应用程序期间排空连接时等待取消注册目标的时间。'
- en: Deploying an Application Load Balancer using CloudFormation
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署应用负载均衡器
- en: Now that all of your Application Load Balancer components have been defined
    in your CloudFormation template, you can deploy these components to AWS using
    the `aws cloudformation deploy` command.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的CloudFormation模板中已经定义了所有应用负载均衡器组件，您可以使用`aws cloudformation deploy`命令将这些组件部署到AWS。
- en: Once your stack deployment is complete, if you open the AWS console and navigate
    to the EC2 dashboard, under the **Load Balancing** section you should be able
    to see your new Application Load Balancer resources.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的堆栈部署完成，如果您打开AWS控制台并导航到EC2仪表板，在**负载均衡**部分，您应该能够看到您的新应用负载均衡器资源。
- en: 'The following screenshot demonstrates viewing the Application Load Balancer
    resource that was created as part of your deployment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图演示了查看作为部署的一部分创建的应用负载均衡器资源：
- en: '![](assets/b91dab42-c34b-47da-a94f-69a7c62d23e7.png)Viewing an Application
    Load Balancer'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 查看应用负载均衡器
- en: In the preceding screenshot, you can see the Application Load Balancer resource
    has a DNS name, which is the name of the endpoint your end users and devices need
    to connect to when accessing the applications behind the load balancer. You will
    use this name later on, once you have fully deployed all resources in your stack,
    but for now because your target group is empty, this URL will just return a 503
    error, as demonstrated in the following example. Note that you can view your listener
    resources by clicking on the **Listeners** tab in the preceding screenshot, and
    your associated target group resources can be viewed by clicking the **Target
    Groups** link on the left-hand menu.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到应用负载均衡器资源有一个DNS名称，这是您的最终用户和设备在访问负载均衡器后面的应用时需要连接的端点名称。一旦您完全部署了堆栈中的所有资源，您将在稍后使用这个名称，但是现在因为您的目标组是空的，这个URL将返回一个503错误，如下例所示。请注意，您可以通过单击前面截图中的**监听器**选项卡来查看您的监听器资源，您可以通过单击左侧菜单上的**目标组**链接来查看您的关联目标组资源。
- en: You will notice that the DNS name of the Application Load Balancer is not a
    particularly friendly name that your end users will be able to recognize or remember.
    In a real-world application, you would typically create a CNAME or ALIAS DNS record,
    which configures a friendly canonical name, such as example.com, that points to
    your load balancer DNS name. See [https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html)
    for more details on how to do this, and note that you can and should create CNAME
    and ALIAS records using CloudFormation ([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到应用负载均衡器的DNS名称并不是您的最终用户能够识别或记住的友好名称。在实际应用中，您通常会创建一个CNAME或ALIAS DNS记录，配置一个友好的规范名称，比如example.com，指向您的负载均衡器DNS名称。有关如何执行此操作的更多详细信息，请参阅[https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html](https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/routing-to-elb-load-balancer.html)，并注意您可以并且应该使用CloudFormation创建CNAME和ALIAS记录([https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/quickref-route53.html#scenario-recordsetgroup-zoneapex))。
- en: '[PRE10]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Testing an Application Load Balancer endpoint
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应用负载均衡器端点
- en: Notice in the preceding example that you can use the AWS CLI to query the outputs
    of your CloudFormation stack and obtain the public DNS name of your application
    load balancer.  You can also view the outputs of your stack by clicking on the
    Outputs tab after selecting your stack in the CloudFormation dashboard.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上面的示例中，您可以使用AWS CLI来查询CloudFormation堆栈的输出，并获取应用程序负载均衡器的公共DNS名称。您还可以在CloudFormation仪表板中选择堆栈后，单击“输出”选项卡来查看堆栈的输出。
- en: Creating ECS task definitions
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ECS任务定义
- en: You have now reached the point where you have defined an ECS cluster using CloudFormation
    and created a number of supporting resources, including an RDS instance for your
    application database and an Application Load Balancer to service connections to
    your application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经达到了定义使用CloudFormation的ECS集群并创建了许多支持资源的阶段，包括用于应用程序数据库的RDS实例和用于服务应用程序连接的应用程序负载均衡器。
- en: At this stage, you are ready to create the ECS resources that will represent
    your application, which include ECS task definitions and ECS services.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您已经准备好创建将代表您的应用程序的ECS资源，包括ECS任务定义和ECS服务。
- en: 'We will get started by defining an ECS task definition in your CloudFormation
    template, as demonstrated in the following example:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在CloudFormation模板中定义ECS任务定义开始，如下例所示：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Defining an ECS task definition using CloudFormation
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation定义ECS任务定义
- en: As you can see in the preceding example, configuring a task definition requires
    a reasonable amount of configuration, and requires a detailed understanding of
    the runtime configuration of the container application your task definition represents.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面的示例中所看到的，配置任务定义需要合理的配置量，并需要对任务定义所代表的容器应用程序的运行时配置有详细的了解。
- en: 'Back in Chapter 1, when you created the sample application and ran it locally,
    you had to perform a similar exercise using Docker Compose. The following example
    shows the relevant snippet from the Docker Compose file in the todobackend repository:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1章中，当您创建了示例应用并在本地运行时，您必须使用Docker Compose执行类似的操作。以下示例显示了todobackend存储库中Docker
    Compose文件中的相关片段：
- en: '[PRE12]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Todobackend application Docker Compose configuration
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Todobackend应用程序Docker Compose配置
- en: If you compare the configurations of both of the previous examples, you can
    see that you can use your local Docker Compose configuration to determine the
    configuration required for your ECS task definition.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较前面两个示例的配置，您会发现您可以使用本地Docker Compose配置来确定ECS任务定义所需的配置。
- en: Let's now examine each of the various ECS task definition configuration properties
    in greater detail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地检查各种ECS任务定义配置属性。
- en: Configuring ECS task definition families
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ECS任务定义家族
- en: The first property you define in the task definition is the **Family** property,
    which establishes the ECS task definition family name, and affects the way CloudFormation
    will create new instances of your task definition resources whenever you make
    changes to your task definition.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您在任务定义中定义的第一个属性是**Family**属性，它建立了ECS任务定义家族名称，并影响CloudFormation在您对任务定义进行更改时创建新实例的方式。
- en: Recall in Chapter 4, that ECS task definitions support the concept of revisions,
    which you can think of as a specific version or configuration of your ECS task
    definition, and whenever you need to modify your task definition (for example,
    to modify the image tag), you can create a new revision of your ECS task definition.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第4章中，ECS任务定义支持修订的概念，您可以将其视为ECS任务定义的特定版本或配置，每当您需要修改任务定义（例如修改镜像标签）时，您可以创建ECS任务定义的新修订版本。
- en: So if your ECS task definition family name is **todobackend**, the first revision
    of your task definition will be **todobackend:1**, and any subsequent changes
    to the task definition will result in the creation of a new revision—for example, **todobackend:2**,
    **todobackend:3**, and so on. Configuring the **Family** property in your ECS
    task definition resource ensures CloudFormation will adopt this behavior of creating
    new revisions, whenever your ECS task definition resource is modified.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您的ECS任务定义族名称为**todobackend**，则任务定义的第一个修订版将为**todobackend:1**，对任务定义的任何后续更改都将导致创建一个新的修订版，例如**todobackend:2**，**todobackend:3**等。配置ECS任务定义资源中的**Family**属性可确保CloudFormation在修改ECS任务定义资源时采用创建新修订版的行为。
- en: Note that if you did not configure the **Family** property as per the previous
    example, CloudFormation would generate a random name for the family with a revision
    of 1, and any subsequent changes to the task definition would result in a *new*
    family being created with a random name, again with a revision of 1.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您未按照之前的示例配置**Family**属性，CloudFormation将为族生成一个随机名称，修订版为1，对任务定义的任何后续更改都将导致创建一个*新*的族，其名称随机，修订版仍为1。
- en: Configuring ECS task definition volumes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ECS任务定义卷
- en: Referring back to the `ApplicationTaskDefinition` resource in earlier example,
    the `Volumes` property defines local Docker volumes that will be created whenever
    an instance of the ECS task definition is deployed to an ECS container instance.
    Referring to the local Docker Compose configuration in the previous example, you
    can see that a volume called **public** is configured, which is then referenced
    as a mount point in the **app** service definition.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前示例中的`ApplicationTaskDefinition`资源，`Volumes`属性定义了每当ECS任务定义的实例部署到ECS容器实例时将创建的本地Docker卷。参考之前示例中的本地Docker
    Compose配置，您可以看到配置了一个名为**public**的卷，然后在**app**服务定义中引用为挂载点。
- en: 'This volume is used to store static web files, which are generated by running
    the `python3 manage.py collectstatic --no-input` command in the local Makefile
    workflow, and must be available to the main application container, hence a volume
    is required to ensure the files generated by running this command are available to
    the application container:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 该卷用于存储静态网页文件，这些文件是通过在本地Makefile工作流中运行`python3 manage.py collectstatic --no-input`命令生成的，并且必须对主应用程序容器可用，因此需要一个卷来确保通过运行此命令生成的文件对应用程序容器可用：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Todobackend Makefile
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Todobackend Makefile
- en: Notice that in our ECS task definition, we are also required to specify a host
    source path of `/data/public`, which we created in the previous chapter as part
    of our ECS cluster auto scaling group CloudFormation init configuration.  This
    folder has the correct permissions on the underlying ECS container instance, which
    ensures our application will be able to read and write to the public volume.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们的ECS任务定义中，我们还需要指定一个主机源路径`/data/public`，这是我们在上一章中作为ECS集群自动扩展组CloudFormation
    init配置的一部分创建的。该文件夹在底层ECS容器实例上具有正确的权限，这确保我们的应用程序能够读取和写入公共卷。
- en: Configuring ECS task definition containers
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置ECS任务定义容器
- en: 'The ECS task definition configured earlier includes a `ContainerDefinitions`
    property, which defines a list of one or more containers associated with the task
    definition. You can see that there are two containers defined:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前配置的ECS任务定义包括`ContainerDefinitions`属性，该属性定义了与任务定义关联的一个或多个容器的列表。您可以看到有两个容器被定义：
- en: '`todobackend` container: This is the main application container definition.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`todobackend`容器：这是主应用程序容器定义。'
- en: '`collectstatic` container: This container is a short lived container that runs
    the `python3 manage.py collectstatic` command to generate local static web files.
    An important configuration parameter associated with this container is the `Essential`
    property, which defines whether or not ECS should attempt to restart the container
    if it should fail or exit (in fact, ECS will attempt to restart all containers
    in the task definition, causing the main application container to be unnecessarily
    stopped and restarted). Given the `collectstatic` container is only intended to
    run as a short-lived task, you must set this property to false to ensure ECS does
    not attempt to restart your ECS task definition containers.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collectstatic`容器：这个容器是一个短暂的容器，运行`python3 manage.py collectstatic`命令来生成本地静态网页文件。与这个容器相关的一个重要配置参数是`Essential`属性，它定义了ECS是否应该尝试重新启动容器，如果它失败或退出（事实上，ECS将尝试重新启动任务定义中的所有容器，导致主应用容器不必要地停止和重新启动）。鉴于`collectstatic`容器只打算作为短暂的任务运行，您必须将此属性设置为false，以确保ECS不会尝试重新启动您的ECS任务定义容器。'
- en: There are many ways you could tackle the requirement to run the collect static
    process to generate static web files. For example, you could define a startup
    script that first runs collect static and then starts the application container,
    or you may wish to publish your static files to an S3 bucket, meaning you would
    run the collect static process quite differently.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以满足运行收集静态过程以生成静态网页文件的要求。例如，您可以定义一个启动脚本，首先运行收集静态，然后启动应用程序容器，或者您可能希望将静态文件发布到S3存储桶，这意味着您将以完全不同的方式运行收集静态过程。
- en: 'Aside from the Essential property, the configuration properties of the `todobackend`
    and `collectstatic` container definitions are very similar, so we will just discuss
    the properties of the main `todobackend` container definition here and discuss
    any differences to the `collectstatic` container definition where appropriate:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Essential属性之外，`todobackend`和`collectstatic`容器定义的配置属性非常相似，因此我们将在这里仅讨论主`todobackend`容器定义的属性，并在适当的地方讨论与`collectstatic`容器定义的任何差异。
- en: '`Image`: This property defines the URI of the Docker image the container is
    based from. Notice that we publish the URI of the ECR repository you created in
    Chapter 5, for the todobackend application, and reference a stack parameter called
    `ApplicationImageTag`, which allows you to provide an appropriate version of your
    Docker Image when deploying the stack.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Image`：此属性定义了容器基于的Docker镜像的URI。请注意，我们发布了您在第5章创建的ECR存储库的URI，用于todobackend应用程序，并引用了一个名为`ApplicationImageTag`的堆栈参数，这允许您在部署堆栈时提供适当版本的Docker镜像。'
- en: '`Cpu` and `MemoryReservation`: These properties allocate CPU and memory resources
    to your containers. We will discuss these resources in more detail in the coming
    chapters, but for now understand that these values reserve the configured amount
    of CPU shares and memory, yet allow your containers to use more CPU and memory
    (that is,"burst") if it is available. Notice that you allocate a minimal amount
    of CPU and memory to the `collectstatic` container, given it only needs to run
    for a short period of time and in all likelihood the ECS container instance will
    have spare CPU and memory capacity available to service the actual resource requirements
    of the container. This avoids reserving large amounts of CPU and memory for a
    container that only is active a fraction of the time.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cpu` 和 `MemoryReservation`：这些属性为您的容器分配 CPU 和内存资源。我们将在接下来的章节中更详细地讨论这些资源，但现在要明白，这些值保留了配置的
    CPU 分配和内存，但允许您的容器在可用时使用更多的 CPU 和内存（即“burst”）。请注意，您为 `collectstatic` 容器分配了最少量的
    CPU 和内存，因为它只需要运行很短的时间，而且很可能 ECS 容器实例将有多余的 CPU 和内存容量可用来满足容器的实际资源需求。这避免了为只在一小部分时间内活动的容器保留大量的
    CPU 和内存。'
- en: '`MountPoints`: Defines the Docker volumes that will be mounted to the container.
    Each container has a single mount point that mounts the **public** volume to the `/public` container
    path for hosting static web files.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MountPoints`：定义将挂载到容器的 Docker 卷。每个容器都有一个单独的挂载点，将 **public** 卷挂载到 `/public`
    容器路径，用于托管静态网页文件。'
- en: '`Environment`: Defines the environment variables that will be available to
    the container. Referring to the local Docker Compose configuration in the preceding
    example, you can see that the release service, which is a base service definition
    that the app service inherits from, indicates the container requires the `DJANGO_SETTINGS_MODULE`
    variable to be set to `todobackend.settings_release`, and requires a number of
    database-related environment variables to be defined that define connectivity
    to the application database. One other environment variable that is required is
    the `SECRET_KEY` variable, which is used for various cryptographic functions in
    the Django framework that powers the todobackend application, and should be configured
    with a secret, random value. As you can see, for now we have set a somewhat non-random
    plaintext value, in the next chapter, you will learn how you can inject this value
    as an encrypted secret'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Environment`：定义将可用于容器的环境变量。参考前面示例中的本地 Docker Compose 配置，您可以看到 release 服务，这是应用服务继承的基本服务定义，指示容器需要将
    `DJANGO_SETTINGS_MODULE` 变量设置为 `todobackend.settings_release`，并需要定义一些与数据库相关的环境变量，以定义与应用程序数据库的连接。另一个需要的环境变量是
    `SECRET_KEY` 变量，它用于 Django 框架中的各种加密功能，用于驱动 todobackend 应用程序，应该配置为一个秘密的随机值。正如您所看到的，现在我们设置了一个相当非随机的明文值，下一章中，您将学习如何将此值作为加密的秘密注入。'
- en: '`Command`: Defines the command that should be executed when starting the container.
    You can see the `todobackend` container definition uses the same `uwsgi` command
    that the local Docker Compose workflow uses to start the `uwsgi` application server,
    whilst the collectstatic container uses the `python3 manage.py collectstatic`
    command to generate static web files to be served from the main application.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`：定义启动容器时应执行的命令。您可以看到 `todobackend` 容器定义使用了与本地 Docker Compose 工作流使用的相同的
    `uwsgi` 命令来启动 `uwsgi` 应用服务器，而 `collectstatic` 容器使用 `python3 manage.py collectstatic`
    命令来生成要从主应用程序提供的静态网页文件。'
- en: '`PortMappings`: Specifies port mappings that should be exposed from the container.
    The todobackend container definition has a single port mapping, which specifies
    the default application port of `8000` for the container port, and specifies a
    host port value of `0`, meaning dynamic port mapping will be used (note that you
    can also omit the HostPort parameter when using dynamic port mapping).'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortMappings`：指定应从容器公开的端口映射。todobackend容器定义有一个单一的端口映射，指定了容器端口的默认应用程序端口`8000`，并指定了主机端口值为`0`，这意味着将使用动态端口映射（请注意，当使用动态端口映射时，您也可以省略HostPort参数）。'
- en: '`LogConfiguration`: Configures the logging configuration for the container.
    In the previous example, you configure CloudWatch logs as the log driver by using
    the awslogs driver, and then configure options specific to this driver. The awslogs-group
    option specifies the log group that logs will be output to, and this references
    the name of a log group that is defined in the `ApplicationLogGroup` resource,
    just below the `ApplicationTaskDefinition` resource. The awslogs-stream-prefix
    is quite important, as it modifies the default log stream naming convention of
    container ID to the `<prefix-name>/<container-name>/<ecs-task-id>` format, with
    the key piece of information here being the ECS task ID, which is the primary
    task identifier you work with when using ECS rather than container IDs.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LogConfiguration`：配置容器的日志记录配置。在前面的示例中，您使用awslogs驱动程序配置CloudWatch日志作为日志驱动程序，然后配置特定于此驱动程序的选项。awslogs-group选项指定日志将输出到的日志组，这引用了在`ApplicationLogGroup`资源下方定义的日志组的名称。awslogs-stream-prefix非常重要，因为它修改了容器ID的默认日志流命名约定为`<prefix-name>/<container-name>/<ecs-task-id>`格式，这里的关键信息是ECS任务ID，这是您在使用ECS时处理的主要任务标识，而不是容器ID。'
- en: In Chapter 7, you granted your ECS container instances the ability to publish
    to any log group prefixed with the name of your CloudFormation stack. As long
    as your ECS task definitions and associated log groups follow this naming convention,
    the Docker Engine will be able to publish logs for your ECS tasks and containers
    to CloudWatch logs.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7章中，您授予了ECS容器实例发布到任何以您的CloudFormation堆栈名称为前缀的日志组的能力。只要您的ECS任务定义和相关的日志组遵循这个命名约定，Docker引擎就能够将您的ECS任务和容器的日志发布到CloudWatch日志中。
- en: Deploying ECS task definitions using CloudFormation
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署ECS任务定义
- en: 'Now that you have defined your ECS task definition, you can deploy it using
    the now-familiar `aws cloudformation deploy` command. Once your stack has been
    updated, a new task definition with a family name to todobackend should be created,
    which you can view using the AWS CLI, as demonstrated in the following example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了ECS任务定义，您可以使用现在熟悉的`aws cloudformation deploy`命令部署它。一旦您的堆栈已经更新，一个名为todobackend的新任务定义应该被创建，您可以使用AWS
    CLI查看，如下例所示：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Verifying the todobackend task definition
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 验证todobackend任务定义
- en: Deploying ECS services
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署ECS服务
- en: With your ECS cluster, ECS task definition, and various supporting resources
    in place, you can now define an ECS service that will deploy your container application
    as defined in the ECS task definition to your ECS cluster.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有了您的ECS集群、ECS任务定义和各种支持资源，现在您可以定义一个ECS服务，将您在ECS任务定义中定义的容器应用程序部署到您的ECS集群中。
- en: 'The following example demonstrates adding an ECS service resource to your CloudFormation
    template, which has a resource type of `AWS::ECS::Service`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了向您的CloudFormation模板添加一个`AWS::ECS::Service`资源的ECS服务资源：
- en: '[PRE15]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating an ECS service
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ECS服务
- en: One interesting aspect of the configuration in the preceding example is the
    `DependsOn` parameter, which defines other resources in the stack that must be
    created or updated before the ECS service resource can be created or updated.
    Although CloudFormation automatically creates dependencies when a resource directly
    references another resource, a resource may have dependencies on other resources
    that don't have a direct relationship to that resource. The ECS service resource
    is a good example of this—the service can't operate without a functional ECS cluster
    and associated ECS container instances (this is represented by the `ApplicationAutoscaling`
    resource) and can't write logs without the `ApplicationLogGroup` resource. A more
    subtle dependency is the `ApplicationLoadBalancerHttpListener` resource, which
    must be functional before the target group associated with the ECS service will
    register targets.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，配置的一个有趣方面是`DependsOn`参数，它定义了堆栈中必须在创建或更新ECS服务资源之前创建或更新的其他资源。虽然CloudFormation在资源直接引用另一个资源时会自动创建依赖关系，但是一个资源可能对其他资源有依赖，而这些资源与该资源没有直接关系。ECS服务资源就是一个很好的例子——服务在没有功能的ECS集群和相关的ECS容器实例（这由`ApplicationAutoscaling`资源表示）的情况下无法运行，并且在没有`ApplicationLogGroup`资源的情况下无法写入日志。一个更微妙的依赖关系是`ApplicationLoadBalancerHttpListener`资源，在与ECS服务关联的目标组注册目标之前必须是功能性的。
- en: 'The various properties that are configured for the ECS service are described
    here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里描述了为ECS服务配置的各种属性：
- en: '`TaskDefinition`, `DesiredCount`, and `Cluster`: Defines the ECS task definition,
    number of ECS tasks, and the target ECS cluster that the service will deploy to.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TaskDefinition`、`DesiredCount`和`Cluster`：定义了ECS任务定义、ECS任务数量和服务将部署到的目标ECS集群。'
- en: '`LoadBalancers`: Configures a load balancer resource that the ECS service should
    be integrated with. You must specify the container name, container port, and target
    group ARN that the ECS service will be registered with. Notice that you reference
    the `ApplicationServiceTargetGroup` resource you created earlier in this chapter.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadBalancers`：配置了ECS服务应该集成的负载均衡器资源。您必须指定容器名称、容器端口和ECS服务将注册的目标组ARN。请注意，您引用了在本章前面创建的`ApplicationServiceTargetGroup`资源。'
- en: '`Role`: This property is only required if you are integrating your ECS service
    with a load balancer and specifies an IAM role that grants permissions for the
    ECS service to manage the configured load balancer. In the preceding example,
    you reference the ARN of a special IAM role known as a service role ([https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)),
    which is automatically created by AWS whenever you create ECS resources. The `AWSServiceRoleForECS`
    service role grants a number of permissions typically required for ECS, including
    managing and integrating with application load balancers.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Role`：如果要将ECS服务与负载均衡器集成，则只有在这种情况下才需要此属性，并且指定了授予ECS服务管理配置的负载均衡器权限的IAM角色。在前面的例子中，您引用了一个特殊的IAM角色的ARN，这个角色被称为服务角色（[https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/using-service-linked-roles.html)），它在创建ECS资源时由AWS自动创建。`AWSServiceRoleForECS`服务角色授予了通常需要的ECS权限，包括管理和集成应用程序负载均衡器。'
- en: '`DeploymentConfiguration`: Configures settings related to rolling deployments
    of new versions of your ECS task definitions. During a deployment, ECS will stop
    existing containers and deploy new containers based on the new version of your
    ECS task definition, and the `MinimumHealthyPercent` setting defines minimum allowable
    percentage of containers in relation to the `DesiredCount` property that must
    be in service during a deployment. Similarly, the `MaximumPercent` setting defines
    the maximum allowable percentage of containers that can be deployed in relation
    to the `DesiredCount` property during a deployment.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeploymentConfiguration`：配置与ECS任务定义的新版本滚动部署相关的设置。在部署过程中，ECS将停止现有容器，并根据ECS任务定义的新版本部署新容器，`MinimumHealthyPercent`设置定义了在部署过程中必须处于服务状态的容器的最低允许百分比，与`DesiredCount`属性相关。同样，`MaximumPercent`设置定义了在部署过程中可以部署的容器的最大允许百分比，与`DesiredCount`属性相关。'
- en: Deploying an ECS service using CloudFormation
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CloudFormation部署ECS服务
- en: 'With your ECS service configuration in place, it''s time to deploy the changes
    to your stack using the `aws cloudformation deploy` command. Once deployment is
    complete, you ECS service should register with the target group you created earlier
    in this chapter, and if you browse to the URL of your Application Load Balancer,
    you should see that the root URL of the sample application is loading correctly:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好ECS服务配置后，现在是时候使用`aws cloudformation deploy`命令将更改部署到您的堆栈了。部署完成后，您的ECS服务应该注册到您在本章前面创建的目标组中，如果您浏览到您的应用程序负载均衡器的URL，您应该看到示例应用程序的根URL正在正确加载：
- en: '![](assets/68a5cac1-2c9c-4711-bb88-70eb0ee1e14e.png)Testing the todobackend
    application'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/68a5cac1-2c9c-4711-bb88-70eb0ee1e14e.png)测试todobackend应用程序'
- en: 'If, however, you click on the **todos** link shown in the preceding screenshot,
    you will receive an error, as demonstrated in the following screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您点击前面截图中显示的**todos**链接，您将收到一个错误，如下截图所示：
- en: '![](assets/b1ba0115-82ab-40ff-9473-2f5887ed15b7.png)todobackend application
    error'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b1ba0115-82ab-40ff-9473-2f5887ed15b7.png)todobackend应用程序错误'
- en: 'The problem in the preceding screenshot is that the database tables expected
    in the application database have not been created, as we have not yet run database
    migrations against the application database. We will learn how to address this
    issue shortly, but before we do this, we have one more topic to discuss related
    to deploying ECS services: rolling deployments.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中的问题是，应用程序数据库中预期的数据库表尚未创建，因为我们尚未对应用程序数据库运行数据库迁移。我们将很快学习如何解决这个问题，但在我们这样做之前，我们还有一个与部署ECS服务相关的主题要讨论：滚动部署。
- en: ECS rolling deployments
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ECS滚动部署
- en: 'A key feature of ECS is rolling deployments, where ECS will automatically deploy
    new versions of your application in a rolling fashion, orchestrating the various
    operations in conjunction with your configured load balancers to ensure your application
    is successfully deployed with no down time and no impact to end users. The process
    of how ECS manages rolling deployments is actually quite detailed, and following
    diagram attempts to describe the process at a high level in a single diagram:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ECS的一个关键特性是滚动部署，ECS将自动以滚动方式部署应用程序的新版本，与您配置的负载均衡器一起协调各种操作，以确保您的应用程序成功部署，没有停机时间，也不会影响最终用户。ECS如何管理滚动部署的过程实际上是非常详细的，以下图表试图以一个图表高层次地描述这个过程：
- en: '![](assets/9486bf16-31d9-4726-a3fb-d06d0fd92aeb.png)ECS rolling deployments'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/9486bf16-31d9-4726-a3fb-d06d0fd92aeb.png)ECS滚动部署'
- en: 'In the preceding diagram, the following events take place during a rolling
    deployment:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，滚动部署期间发生了以下事件：
- en: A configuration change is made to the `ApplicationTaskDefinition` ECS task definition
    linked to the ECS service, which generally will be a change in the image tag for
    new versions of an application, but could be any change made to the task definition.
    This results in a new revision of the task definition being created (revision
    2 in this example).
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对与ECS服务关联的`ApplicationTaskDefinition` ECS任务定义进行配置更改，通常是应用程序新版本的镜像标签的更改，但也可能是对任务定义的任何更改。这将导致任务定义的新修订版被创建（在这个例子中是修订版2）。
- en: The ECS service is configured to use the new task definition revision, which
    happens automatically when using CloudFormation to manage your ECS resources.
    The deployment configuration of the ECS service determines how ECS manages the
    rolling deployment - in the preceding diagram, ECS must ensure that a minimum
    of 100% of the configured desired task count is maintained during the deployment,
    and can temporarily increase the task count up to 200% during a deployment. Assuming
    the desired task count is one, this means ECS can deploy a new ECS task based
    on the new task definition revision and satisfy the deployment configuration.
    Note that your ECS cluster must have enough resources available to accommodate
    these deployments and you are responsible for managing ECS cluster capacity (that
    is, ECS will not increase ECS cluster capacity temporarily to accommodate deployments).
    You will learn how to dynamically manage ECS cluster capacity in later chapters.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECS 服务配置为使用新的任务定义修订版，当使用CloudFormation来管理ECS资源时，这是自动发生的。ECS 服务的部署配置决定了ECS如何管理滚动部署-在前面的图表中，ECS必须确保在部署过程中维持配置的期望任务数量的最低100%，并且可以在部署过程中暂时增加任务数量达到最高200%。假设期望的任务数量为1，这意味着ECS可以部署基于新任务定义修订版的新ECS任务并满足部署配置。请注意，您的ECS集群必须有足够的资源来容纳这些部署，并且您负责管理ECS集群的容量（即ECS不会暂时增加ECS集群的容量来容纳部署）。您将在后面的章节中学习如何动态管理ECS集群的容量。
- en: Once the new ECS task starts successfully, ECS registers the new task with the
    configure load balancer (in the case of an Application Load Balancer, the task
    will be registered with a target group resource). The load balancer will perform
    health checks to determine the health of the new task, and once confirmed healthy,
    the new ECS task will be registered in the load balancer and able to accept incoming
    connections.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦新的ECS任务成功启动，ECS会将新任务注册到配置的负载均衡器（在应用负载均衡器的情况下，任务将被注册到目标组资源）。负载均衡器将执行健康检查来确定新任务的健康状况，一旦确认健康，新的ECS任务将被注册到负载均衡器并能够接受传入连接。
- en: ECS now instructs the load balancer to drain the existing ECS task. The load
    balancer will take the existing ECS task out of service (that is, it won't forward
    any new connections to the task), however will wait for a configurable period
    of time for existing connections to "drain" or close. During this time, any new
    connections to the load balancer will be forwarded to the new ECS task that was
    registered with the load balancer in Step 3.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ECS现在指示负载均衡器排水现有的ECS任务。负载均衡器将使现有的ECS任务停止服务（即不会将任何新连接转发到任务），但会等待一段可配置的时间来使现有连接“排水”或关闭。在此期间，任何对负载均衡器的新连接将被转发到在第3步中向负载均衡器注册的新ECS任务。
- en: Once the draining process is complete, the load balancer removes the old ECS
    task completely from the target group, and ECS can now terminate the existing
    ECS task. Once this is complete, the deployment of the new application task definition
    is complete.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦排水过程完成，负载均衡器将完全从目标组中删除旧的ECS任务，ECS现在可以终止现有的ECS任务。一旦这个过程完成，新应用任务定义的部署就完成了。
- en: As you can see from this description, the deployment process is quite involved.
    The great news is that all of this comes out of the box with ECS - all that you
    need to understand is that any changes to your task definitions will trigger a
    new deployment, and that your deployment configuration, as determined by the `DeploymentConfiguration`
    property, gives you some control over the rolling deployment.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个描述中可以看出，部署过程非常复杂。好消息是，所有这些都可以通过ECS开箱即用——您需要理解的是，对任务定义的任何更改都将触发新的部署，并且您的部署配置，由DeploymentConfiguration属性确定，可以在滚动部署中对其进行一些控制。
- en: Executing a rolling deployment
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行滚动部署
- en: Now that you understand how rolling deployments work, let's see the process
    in action by making a change to your ECS task definitions and deploying the change
    via CloudFormation, which will trigger a rolling deployment of your ECS service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了滚动部署的工作原理，让我们通过对ECS任务定义进行更改并通过CloudFormation部署更改的过程来看看它的实际操作，这将触发ECS服务的滚动部署。
- en: At the moment, your CloudFormation configuration is not specifying the `ApplicationImageTag`
    parameter, meaning your ECS task definitions are using the default value of `latest`.
    Back in Chapter 5, when you published your Docker image to ECR, you actually pushed
    two tags—the `latest` tag and also the commit hash of the todobackend repository.
    This provides us with a good opportunity to further improve our CloudFormation
    template—by referencing the commit hash, rather than the `latest` tag, we will
    always be able to trigger a configuration change to your ECS task definitions
    whenever you have a new version of your application to deploy.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，您的CloudFormation配置未指定ApplicationImageTag参数，这意味着您的ECS任务定义正在使用latest的默认值。回到第5章，当您将Docker镜像发布到ECR时，实际上推送了两个标签——latest标签和todobackend存储库的提交哈希。这为我们提供了一个很好的机会来进一步改进我们的CloudFormation模板——通过引用提交哈希，而不是latest标签，我们将始终能够在您有新版本的应用程序要部署时触发对ECS任务定义的配置更改。
- en: 'The following example demonstrates adding the `ApplicationImageTag` parameter
    to the `dev.cfg` file in the todobackend-aws repository, referencing the commit
    hash of the currently published image in ECR:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在todobackend-aws存储库中的dev.cfg文件中添加ApplicationImageTag参数，引用当前发布的ECR镜像的提交哈希：
- en: '[PRE17]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding ApplicationImageTag to the dev.cfg file
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将ApplicationImageTag添加到dev.cfg文件
- en: If you now deploy your changes using the `aws cloudformation deploy` command, although the
    image you have now referenced is identical to the current latest tagged image,
    CloudFormation will detect this as a configuration change, create a new revision
    of your ECS task definitions, and update the `ApplicationService` ECS service
    resource, triggering a rolling deployment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在使用aws cloudformation deploy命令部署更改，尽管您现在引用的镜像与当前latest标记的镜像相同，CloudFormation将检测到这是一个配置更改，创建ECS任务定义的新修订版本，并更新ApplicationService
    ECS服务资源，触发滚动部署。
- en: 'While the deployment is running, if you browse to your ECS service in the ECS
    dashboard and select the Deployments tab, as demonstrated in the following screenshot,
    you will see two deployments—the ACTIVE deployment refers to the existing ECS
    tasks, while the PRIMARY deployment refers to the new ECS tasks that are being
    deployed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署运行时，如果您浏览ECS仪表板中的ECS服务并选择部署选项卡，如下截图所示，您将看到两个部署——ACTIVE部署指的是现有的ECS任务，而PRIMARY部署指的是正在部署的新的ECS任务。
- en: '![](assets/44aab8c6-3a36-47ec-b224-74861afc4181.png)ECS service rolling deployment'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/44aab8c6-3a36-47ec-b224-74861afc4181.png)ECS服务滚动部署'
- en: 'Eventually, the ACTIVE deployment will disappear once the rolling deployment
    process is complete, and if you click on the Events tab, you will see the various
    events that took place during the deployment, which correspond to the earlier
    description:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，一旦滚动部署过程完成，ACTIVE部署将消失，如果您点击“事件”选项卡，您将看到部署过程中发生的各种事件，这些事件对应了先前的描述：
- en: '![](assets/adc2feb0-c12b-4822-b81d-0acf52cefc78.png)ECS service rolling deployment
    events'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/adc2feb0-c12b-4822-b81d-0acf52cefc78.png)ECS服务滚动部署事件'
- en: Creating a CloudFormation custom resource
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CloudFormation自定义资源
- en: Although our application has been deployed and is running, we clearly have a
    problem in that we haven't run database migrations, which is a required deployment
    task. We already have dealt with running another deployment task, which is to
    collect static files, however database migrations should only be run as a *single*
    deployment task per deployment. For example, if you are deploying multiple instances
    of your service, you don't want to run migrations for each instance you deploy,
    you just want to run migrations once per deployment, regardless of the number
    of instances that are in service.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的应用已经部署并运行，但很明显我们有一个问题，即我们尚未运行数据库迁移，这是一个必需的部署任务。我们已经处理了运行另一个部署任务，即收集静态文件，但是数据库迁移应该只作为*单个*部署任务运行。例如，如果您正在部署服务的多个实例，您不希望为每个部署的实例运行迁移，您只想在每个部署中运行一次迁移，而不管服务中有多少实例。
- en: One obvious solution is to manually run migrations after each deployment, however
    ideally you want to fully automate your deployments and ensure you have a mechanism
    to automatically run migrations. CloudFormation does not provide a resource that
    allows you run one-off ECS tasks, however an extremely powerful feature of CloudFormation
    is the ability to create your own custom resources, which allow you to perform
    custom provisioning tasks. A benefit of creating custom resources is that you
    can incorporate custom provisioning tasks into the workflow of deploying various
    AWS services and resources, using the CloudFormation framework to manage this
    for you.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个明显的解决方案是在每次部署后手动运行迁移，但是理想情况下，您希望完全自动化您的部署，并确保您有一种机制可以自动运行迁移。CloudFormation不提供允许您运行一次性ECS任务的资源，但是CloudFormation的一个非常强大的功能是能够创建自己的自定义资源，这使您能够执行自定义的配置任务。创建自定义资源的好处是您可以将自定义的配置任务纳入部署各种AWS服务和资源的工作流程中，使用CloudFormation框架来为您管理这一切。
- en: Let's now learn how you can create a simple ECS task runner custom resource
    that will run the migrate task as part of creating and updating your application
    environment via CloudFormation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们学习如何创建一个简单的ECS任务运行器自定义资源，该资源将作为创建和更新应用程序环境的一部分来运行迁移任务。
- en: Understanding CloudFormation custom resources
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CloudFormation自定义资源
- en: Before you get started configuring CloudFormation custom resources, it is worthwhile
    to discuss how they actually work and describe the key components that compose
    a custom resource.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始配置CloudFormation自定义资源之前，值得讨论它们实际上是如何工作的，并描述组成自定义资源的关键组件。
- en: 'The following diagram illustrates how CloudFormation custom resources work:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了CloudFormation自定义资源的工作原理：
- en: '![](assets/a8738f96-3ab5-46a3-95dc-d5d9216a7f06.png)CloudFormation custom resources'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a8738f96-3ab5-46a3-95dc-d5d9216a7f06.png)CloudFormation自定义资源'
- en: 'In the preceding diagram, the following steps take place when you use custom
    resources in your CloudFormation templates:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，当您在CloudFormation模板中使用自定义资源时，将发生以下步骤：
- en: You need to define custom resources in your CloudFormation templates. A custom
    resource has the `AWS::CloudFormation::CustomResource` resource type, or alternatively
    `Custom::<resource-name>`. When CloudFormation encounters a custom resource, it
    looks for a specific property called `ServiceToken`, which provides the ARN of
    a Lambda function that should provision the custom resource.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要在CloudFormation模板中定义自定义资源。自定义资源具有`AWS::CloudFormation::CustomResource`资源类型，或者是`Custom::<resource-name>`。当CloudFormation遇到自定义资源时，它会查找一个名为“ServiceToken”的特定属性，该属性提供应该配置自定义资源的Lambda函数的ARN。
- en: CloudFormation invokes the Lambda function, and passes a custom resource request
    to the function in the form of a JSON object. The event has a request type, which
    defines whether the request is to either create, update, or delete the resource,
    and includes request properties, which are custom properties you can define in
    your custom resource definition that will be passed to the Lambda function. Another
    important property of the request is the response URL, which provides a pre-signed
    S3 URL where the Lambda function should post a response once provisioning is complete.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CloudFormation调用Lambda函数，并以JSON对象的形式将自定义资源请求传递给函数。事件具有请求类型，该类型定义了请求是创建、更新还是删除资源，并包括请求属性，这些属性是您可以在自定义资源定义中定义的自定义属性，将传递给Lambda函数。请求的另一个重要属性是响应URL，它提供了一个预签名的S3
    URL，Lambda函数应在配置完成后向其发布响应。
- en: The Lambda function processes the custom resource request and performs appropriate
    provisioning of the resource, based upon the request type and request properties.
    Once provisioning is complete, the function posts a success or failure response
    to the response URL received in the custom resource request, and includes a resource
    identifier in the event a resource has been created or updated.  Assuming the
    response signals success, the response may include a `Data` property, which can
    include useful information about the provisioned custom resource that can be referenced
    elsewhere in the CloudFormation stack using the standard `!Sub ${<resource-name>.<data-property>}`
    syntax, where `<data-property>` is a property included in the `Data` property
    of the response.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda函数处理自定义资源请求，并根据请求类型和请求属性执行资源的适当配置。配置完成后，函数向自定义资源请求中收到的响应URL发布成功或失败的响应，并在创建或更新资源时包含资源标识符。假设响应信号成功，响应可能包括“Data”属性，该属性可以包含有关已配置的自定义资源的有用信息，可以在CloudFormation堆栈的其他位置使用标准的“!Sub
    ${<resource-name>.<data-property>}”语法引用，其中“<data-property>”是响应的“Data”属性中包含的属性。
- en: The CloudFormation service polls the response URL for a response. Once a response
    is received, CloudFormation parses the response and continues stack provisioning
    (or rolls back the stack in the event the response indicates a failure).
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 云形成服务轮询响应URL以获取响应。一旦收到响应，CloudFormation解析响应并继续堆栈配置（或在响应指示失败的情况下回滚堆栈）。
- en: Creating a custom resource Lambda function
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义资源Lambda函数
- en: As discussed in the previous section, a custom resource requires you to create
    a Lambda function that processes an incoming event sent by CloudFormation, performs
    custom provisioning actions, and then responds to CloudFormation using a pre-signed
    S3 URL.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所讨论的，自定义资源需要您创建一个Lambda函数，该函数处理CloudFormation发送的传入事件，执行自定义配置操作，然后使用预签名的S3
    URL响应CloudFormation。
- en: 'This sounds reasonably complicated, however there are a number of tools available
    that make this possible to achieve in a relatively straightforward manner for
    simple use cases, as demonstrated in the following example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来相当复杂，但是有许多可用的工具可以使这在相对简单的用例中成为可能，如以下示例所示。
- en: '[PRE18]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating an inline Lambda function using CloudFormation
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation创建内联Lambda函数
- en: The most important aspect of the preceding example to initially focus on is
    the `Code.ZipFile` property within the `EcsTaskRunner` resource, which defines
    an inline Python script that performs the custom provisioning actions of your
    custom resource. Note this approach of defining code inline is generally not recommended
    for real world use cases, and in later chapters we will create a more complex
    custom resource complete with its own source code repository for the Lambda function
    code, but for the purposes of keeping this example simple and introducing the
    core concepts of custom resources, I am using an inline approach for now.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中最重要的方面是`EcsTaskRunner`资源中的`Code.ZipFile`属性，它定义了一个内联Python脚本，执行自定义资源的自定义配置操作。请注意，这种内联定义代码的方法通常不推荐用于实际用例，稍后我们将创建一个更复杂的自定义资源，其中包括自己的Lambda函数代码的源代码库，但为了保持这个示例简单并介绍自定义资源的核心概念，我现在使用了内联方法。
- en: Understanding the custom resource function code
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自定义资源函数代码
- en: Let's focus on discussing the custom resource function code, which I have isolated
    in the earlier example and added comments to describe what various statements
    are doing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于讨论自定义资源函数代码，我已经在之前的示例中将其隔离，并添加了注释来描述各种语句的作用。
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating an inline Lambda function using CloudFormation
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用CloudFormation创建内联Lambda函数
- en: At a high level, the custom resource function receives CloudFormation custom
    resource event and calls the `run_task` method for the ECS service from the AWS
    Python SDK, passing in the ECS cluster, ECS task definition, and optional overrides
    to execute. The function then waits for the task to complete, inspects the result
    of the ECS task to determine whether the associated container completed successfully
    and then responds with either success or failure to CloudFormation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，自定义资源函数接收CloudFormation自定义资源事件，并调用AWS Python SDK中ECS服务的`run_task`方法，传入ECS集群、ECS任务定义和可选的覆盖以执行。然后函数等待任务完成，检查ECS任务的结果，以确定相关容器是否成功完成，然后向CloudFormation响应成功或失败。
- en: Notice that the function imports a module called `cfnresponse`, which is a module
    included in the AWS Lambda Python runtime environment that provides a simple high-level
    mechanism for responding to CloudFormation custom resource requests. The function
    also imports a module called `boto3`, which provides the AWS Python SDK and is
    used to create a `client` object that interacts specifically with the ECS service.
    The Lambda function then defines a single function called `handler`, which is
    the entry point for new events passed to the Lambda function, and notice that
    the `handler` function must accept both an `event` object that contains the CloudFormation
    custom resource event, and a `context` object that provides runtime information
    about the Lambda environment. Note that the function should only attempt to run
    a task for CloudFormation create and update requests, and can simply return success
    when a request to delete the custom resource is received, given tasks are short-lived
    resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，函数导入了一个名为`cfnresponse`的模块，这是AWS Lambda Python运行时环境中包含的一个模块，提供了一个简单的高级机制来响应CloudFormation自定义资源请求。函数还导入了一个名为`boto3`的模块，它提供了AWS
    Python SDK，并用于创建一个与ECS服务专门交互的`client`对象。然后Lambda函数定义了一个名为`handler`的函数，这是传递给Lambda函数的新事件的入口点，并注意`handler`函数必须接受包含CloudFormation自定义资源事件的`event`对象和提供有关Lambda环境的运行时信息的`context`对象。请注意，函数应该只尝试运行CloudFormation创建和更新请求的任务，并且当接收到删除自定义资源的请求时，可以简单地返回成功，因为任务是短暂的资源。
- en: The code in the preceding example is by no means production-level code and has
    been simplified for demonstration purposes to only handle two primary scenarios
    related to success and failure.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的代码绝不是生产级代码，并且已经简化为仅处理与成功和失败相关的两个主要场景以进行演示。
- en: Understanding the custom resource Lambda function resources
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解自定义资源Lambda函数资源
- en: Now that you understand how the Lambda function code actually works, let's focus
    on the remainder of the configuration you added in earlier example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了Lambda函数代码的实际工作原理，让我们专注于您在之前示例中添加的配置的其余部分。
- en: 'The `EcsTaskRunner` resource defines the Lambda function, with key configuration
    properties described here:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`EcsTaskRunner`资源定义了Lambda函数，其中描述了关键配置属性：'
- en: '`FunctionName`: The name of the function. An important aspect to understand
    with function naming is that the associated CloudWatch logs group that is used
    to store function logs must follow a naming convention of `/aws/lambda/<function-name>`,
    and you see that the `FunctionName` property matches the `LogGroupName` property
    of the `EcsTaskRunnerLogGroup` resource. Notice that the `EcsTaskRunner` must
    also declare a dependency on the `EcsTaskRunnerLogGroup` resource, as per the
    configuration of the `DependsOn` setting.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FunctionName`：函数的名称。要理解的一个重要方面是，用于存储函数日志的关联CloudWatch日志组必须遵循`/aws/lambda/<function-name>`的命名约定，您会看到`FunctionName`属性与`EcsTaskRunnerLogGroup`资源的`LogGroupName`属性匹配。请注意，`EcsTaskRunner`还必须声明对`EcsTaskRunnerLogGroup`资源的依赖性，根据`DependsOn`设置的配置。'
- en: '`Handler`: Specifies the entry point for the Lambda function in the `<module>.<function>` format.
    Note that when using the inline code mechanism of the module created for your
    Lambda function will always be called `index`.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`处理程序`：指定Lambda函数的入口点，格式为`<module>.<function>`。请注意，当使用模块创建的内联代码机制时，用于Lambda函数的模块始终被称为`index`。'
- en: '`Timeout`: It is important to understand that, at the time of writing, Lambda
    has a maximum five-minute (300 seconds) timeout, meaning your functions must complete
    within five minutes or they will be terminated. The default timeout for a Lambda
    function is 3 seconds, and because it does take time to deploy a new ECS task,
    run the ECS task and wait for the task to complete, this timeout has been increased
    to maximum timeout of 300 seconds.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`超时`：重要的是要理解，目前Lambda的最长超时时间为五分钟（300秒），这意味着您的函数必须在五分钟内完成，否则它们将被终止。Lambda函数的默认超时时间为3秒，因为部署新的ECS任务，运行ECS任务并等待任务完成需要时间，因此将此超时时间增加到最大超时时间为300秒。'
- en: '`Role`: Defines the IAM role to assign to the Lambda function. Note that the
    referenced `EcsTaskRunnerRole` resource must trust the lambda.amazonaws.com and
    at a minimum, every Lambda function must have permissions to write to the associated
    CloudWatch logs group if you want to capture any logs. The ECS task runner function
    requires permissions to run and describe ECS tasks, and the use of conditions
    is configured to only grant these permissions to the ECS cluster defined in the
    stack.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`角色`：定义要分配给Lambda函数的IAM角色。请注意，引用的`EcsTaskRunnerRole`资源必须信任lambda.amazonaws.com，而且至少每个Lambda函数必须具有权限写入关联的CloudWatch日志组，如果您想要捕获任何日志。ECS任务运行器函数需要权限来运行和描述ECS任务，并且使用条件配置为仅向堆栈中定义的ECS集群授予这些权限。'
- en: Creating custom resources
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义资源
- en: Now that your custom resource Lambda function and associated supporting resources
    are in place, you can define the actual custom resource object. For our use case,
    we need to define a custom resource that will run the `python3 manage.py migrate`
    command inside our application container, and given the migrate task interacts
    with the application database, the task must be configured with the various database
    environment variables that define connectivity to the application database resource.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的自定义资源Lambda函数和相关的支持资源都已经就位，你可以定义实际的自定义资源对象。对于我们的用例，我们需要定义一个自定义资源，它将在我们的应用容器中运行`python3
    manage.py migrate`命令，并且由于迁移任务与应用数据库交互，任务必须配置各种数据库环境变量，以定义与应用数据库资源的连接。
- en: 'One approach would be to leverage the `ApplicationTaskDefinition` resource
    you created earlier and specify a command override, however one issue is that
    the `ApplicationTaskDefinition` includes the `collectstatic` container, which
    we don''t really want to run whenever you run migrations. To overcome this, you
    need to create a separate task definition called `MigrateTaskDefinition`, which
    only includes a single container definition that specifically runs database migrations:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是利用之前创建的`ApplicationTaskDefinition`资源，并指定一个命令覆盖，但一个问题是`ApplicationTaskDefinition`包括`collectstatic`容器，我们并不真的想在运行迁移时运行它。为了克服这个问题，你需要创建一个名为`MigrateTaskDefinition`的单独任务定义，它只包括一个特定运行数据库迁移的容器定义：
- en: '[PRE21]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Creating a migrate task definition
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 创建迁移任务定义
- en: In the preceding example, notice that the `MigrateTaskDefinition` resource requires
    database-related environment variables to be configured, however does not require
    the volume mappings or port mappings you configured previously in the `ApplicationTaskDefinition`
    resource.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，注意到`MigrateTaskDefinition`资源需要配置与数据库相关的环境变量，但不需要你之前在`ApplicationTaskDefinition`资源中配置的卷映射或端口映射。
- en: 'With this task definition in place, you can now create your custom resource,
    as demonstrated in the following example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个任务定义，你现在可以创建你的自定义资源，就像下面的例子所示：
- en: '[PRE23]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Creating a migrate task custom resource
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 创建迁移任务自定义资源
- en: In the preceding example, notice that your custom resource is created with the `AWS::CloudFormation::CustomResource` type,
    and every custom resource you create must include the `ServiceToken` property,
    which references the ARN of the associated custom resource Lambda function. The
    remainder of the properties are specific to your custom resource function, which
    in our case must specify, at a minimum, the target ECS cluster and ECS task definition
    of the task that needs to be executed. Notice that the custom resource includes
    dependencies to ensure it is only run once the `ApplicationAutoscaling` and `ApplicationDatabase`
    resources have been created, and you also need to add a dependency on the `ApplicationService`
    resource you created earlier in this chapter, so that this resource is not created
    or updated until the `MigrateTask` custom resource has completed successfully.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，注意到你的自定义资源是用`AWS::CloudFormation::CustomResource`类型创建的，你创建的每个自定义资源都必须包括`ServiceToken`属性，它引用了相关自定义资源Lambda函数的ARN。其余的属性是特定于你的自定义资源函数的，对于我们的情况，至少必须指定要执行的任务的目标ECS集群和ECS任务定义。注意，自定义资源包括依赖关系，以确保它只在`ApplicationAutoscaling`和`ApplicationDatabase`资源创建后运行，你还需要在本章前面创建的`ApplicationService`资源上添加一个依赖关系，以便在`MigrateTask`自定义资源成功完成之前不会创建或更新此资源。
- en: Deploying custom resources
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署自定义资源
- en: You are now ready to deploy your changes using the `aws cloudformation deploy`
    command. While the CloudFormation stack changes are deploying, once CloudFormation
    initiates creation of the custom resource and invokes your Lambda function, you
    can navigate to AWS Lambda console to view your Lambda function and also check
    function logs.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`aws cloudformation deploy`命令部署您的更改。在CloudFormation堆栈更改部署时，一旦CloudFormation启动创建自定义资源并调用您的Lambda函数，您可以导航到AWS
    Lambda控制台查看您的Lambda函数，并检查函数日志。
- en: CloudFormation custom resources can be time-consuming to initially get working,
    particularly if your code throws exceptions and you don't have appropriate code
    to catch these exceptions and send failure responses. It is possible for you to
    end up waiting several hours for a custom resource action to timeout, because
    your custom resource threw an exception and did not return an appropriate failure
    response to CloudFormation.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation自定义资源在最初工作时可能会耗费大量时间，特别是如果您的代码抛出异常并且没有适当的代码来捕获这些异常并发送失败响应。您可能需要等待几个小时才能超时，因为您的自定义资源抛出了异常并且没有返回适当的失败响应给CloudFormation。
- en: 'The following screenshot demonstrates viewing the `todobackend-ecsTasks` Lambda
    function that is created from your CloudFormation stack in the AWS Lambda console:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图演示了在AWS Lambda控制台中查看从CloudFormation堆栈创建的`todobackend-ecsTasks` Lambda函数：
- en: '![](assets/eb137671-2741-4ba2-8634-1079e75d3526.png)Viewing Lambda functions
    in the AWS console'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/eb137671-2741-4ba2-8634-1079e75d3526.png)在AWS控制台中查看Lambda函数'
- en: 'In the preceding screenshot, the **Configuration** tab provides configuration
    details about your function, and even includes an inline code editor where you
    can review, test, and debug your code. The **Monitoring** tab provides access
    to various metrics for your function, and includes a useful **Jump to Logs** link
    that takes you straight to the logs for your function in CloudWatch logs:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，**配置**选项卡提供了有关函数的配置详细信息，甚至包括内联代码编辑器，您可以在其中查看、测试和调试您的代码。**监控**选项卡提供了对函数的各种指标的访问权限，并包括一个有用的**跳转到日志**链接，该链接可以直接带您到CloudWatch日志中函数的日志：
- en: '![](assets/6adc9b11-80cc-4199-b42f-94ef997e1f74.png)Viewing Lambda function
    logs in the AWS console'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6adc9b11-80cc-4199-b42f-94ef997e1f74.png)在AWS控制台中查看Lambda函数日志'
- en: In the preceding screenshot, the START message indicates when the function was
    invoked, and you can see a response body with a status of SUCCESS was generated,
    which is published to the CloudFormation custom resource response URL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的屏幕截图中，START消息指示函数何时被调用，并且您可以看到生成了一个状态为SUCCESS的响应体，该响应体被发布到CloudFormation自定义资源响应URL。
- en: 'Now is also a good time to review the CloudWatch logs for your ECS tasks—shows
    the **/todobackend/ecs/todobackend** log group, which is the log group configured
    in your CloudFormation stack that collects all ECS task logs for the application.
    Notice that there are several log streams - one for the **collectstatic** container
    that generated static tasks, one for the **migrate** container that ran migrations,
    and a log stream for the main todobackend application. Notice that each log stream
    includes the ECS task ID at the end of the log stream name - these correlate directly
    to the ECS task IDs that you interact with using the ECS console or AWS CLI:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是审查ECS任务的CloudWatch日志的好时机——显示了**/todobackend/ecs/todobackend**日志组，这是在您的CloudFormation堆栈中配置的日志组，用于收集应用程序的所有ECS任务日志。请注意，有几个日志流
    - 一个用于生成静态任务的**collectstatic**容器，一个用于运行迁移的**migrate**容器，以及一个用于主要todobackend应用程序的日志流。请注意，每个日志流的末尾都包括ECS任务ID
    - 这些直接对应于您使用ECS控制台或AWS CLI与之交互的ECS任务ID：
- en: '![](assets/03520e7d-967e-43de-a3cd-855c822ebe16.png)ECS log groups in CloudWatch
    logs'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ECS CloudWatch日志组
- en: Verifying the application
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证应用程序
- en: As a final check, the sample application should now be fully functional - for
    example, the todos link that failed earlier in should now work, as demonstrated
    in the following screenshot.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的检查，示例应用程序现在应该是完全功能的 - 例如，之前失败的待办事项链接现在应该可以工作，如下面的截图所示。
- en: 'You can interact with the API to add or remove todo items, and all of your
    todo items will now be persisted in the application database defined in your stack:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以与API交互以添加或删除待办事项，并且所有待办事项现在将持久保存在应用程序数据库中，该数据库在您的堆栈中定义：
- en: '![](assets/98dcd51c-619f-4fde-bab1-95f5526d88bb.png)Working todobackend application'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/98dcd51c-619f-4fde-bab1-95f5526d88bb.png)Working todobackend application'
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you successfully deployed the sample Docker application to
    AWS using ECS. You learned how to define key supporting application and infrastructure
    resources, including how to create an application database using the AWS RDS service,
    and how to integrate your ECS applications with application load balancers provided
    by the AWS Elastic Load Balancing service.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您成功地将示例Docker应用程序部署到AWS使用ECS。您学会了如何定义关键的支持应用程序和基础设施资源，包括如何使用AWS RDS服务创建应用程序数据库，以及如何将您的ECS应用程序与AWS弹性负载均衡服务提供的应用程序负载均衡器集成。
- en: With these supporting resources in place, you learned how to create ECS task
    definitions that control the runtime configuration of your containers, and then
    deployed instances of your ECS task definitions to your ECS cluster by creating
    an ECS service for the sample application. You learned how an ECS task definition
    can define volumes and multiple container definitions, and you used this capability
    to create a separate non-essential container definition that always runs whenever
    your ECS task definition is deployed and generates static web files for the sample
    application. You also integrated the ECS service for the sample application with
    the various Application Load Balancer resources in your stack, ensuring connections
    to your application can be load balanced across multiple instances of your ECS
    service in a highly available manner.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些支持资源，您学会了如何创建控制容器运行时配置的ECS任务定义，然后通过为示例应用程序创建ECS服务来部署您的ECS任务定义的实例。您学会了ECS任务定义如何定义卷和多个容器定义，并且您使用了这个功能来创建一个单独的非必要容器定义，每当部署您的ECS任务定义时，它总是运行并为示例应用程序生成静态网页文件。您还将示例应用程序的ECS服务与堆栈中的各种应用程序负载均衡器资源集成，确保可以跨多个ECS服务实例进行负载均衡连接到您的应用程序。
- en: Although you were able to successfully deploy your application as an ECS service,
    you discovered that your application was not fully functional, because the database
    migrations that establish the schema and tables for your application database
    had not been run. You addressed this issue by creating an ECS task runner CloudFormation
    custom resource, which allowed you to run migrations as a single-shot task per
    application deployment. The custom resource is defined as a simple Lambda function
    written in Python, which first runs a task for a given ECS task definition on
    a given ECS cluster, waits for the task to complete, and then reports the success
    or failure of the task based upon the exit code of the container associated with
    the task.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您能够成功将应用程序部署为ECS服务，但您发现您的应用程序并不完全功能，因为尚未运行为应用程序数据库建立架构和表的数据库迁移。您通过创建ECS任务运行器CloudFormation自定义资源来解决了这个问题，这使您能够在每次应用程序部署时运行迁移作为单次任务。自定义资源被定义为一个简单的用Python编写的Lambda函数，它首先在给定的ECS集群上为给定的ECS任务定义运行任务，等待任务完成，然后根据与任务相关联的容器的退出代码报告任务的成功或失败。
- en: With this custom resource in place, your sample application is now fully functional,
    although it still has some deficiencies. In the next chapter, we will address
    one of those deficiencies—secrets management and ensuring passwords remain confidential—which
    is critical in secure, production-grade Docker applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个自定义资源，您的示例应用现在已经完全可用，尽管它仍然存在一些不足之处。在下一章中，我们将解决其中一个不足之处——保密管理和确保密码保持机密——这在安全的、生产级别的Docker应用中至关重要。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'True/False: An RDS instance requires you to create a DB subnet group with at
    least two subnets.'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：RDS实例需要您创建至少两个子网的DB子网组。
- en: When configuring an Application Load Balancer, which component services frontend
    connections from end users?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置应用负载均衡器时，哪个组件服务于来自最终用户的前端连接？
- en: 'True/False: A target group can accept registrations from targets before the
    Application Load Balancer listener is created.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：在创建应用负载均衡器监听器之前，目标组可以接受来自目标的注册。
- en: When configuring security group rules permitting access between an application
    database and ECS container instances, you receive a CloudFormation error about
    circular dependencies. What type of resources can you use to overcome this issue?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在配置允许应用数据库和ECS容器实例之间访问的安全组规则时，您收到了关于循环依赖的CloudFormation错误。您可以使用哪种类型的资源来克服这个问题？
- en: You configure an ECS task definition that includes two container definitions.
    One of the container definition performs a short provisioning task and then exits.
    You discover that ECS is continuously restarting ECS services based on this task
    definition. How can you resolve this issue?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您配置了一个包括两个容器定义的ECS任务定义。其中一个容器定义执行一个短暂的配置任务然后退出。您发现ECS不断地基于这个任务定义重新启动ECS服务。您如何解决这个问题？
- en: Which CloudFormation parameter can you configure to define explicit dependencies
    on other resources?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以配置哪个CloudFormation参数来定义对其他资源的显式依赖关系？
- en: 'True/False: CloudFormation custom resources use AWS Lambda functions to perform
    custom provisioning tasks.'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：CloudFormation自定义资源使用AWS Lambda函数执行自定义的配置任务。
- en: What are the three types of events you need to handle when receiving CloudFormation
    custom resource events?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接收CloudFormation自定义资源事件时，您需要处理哪三种类型的事件？
- en: You create a Lambda function with an inline Python function that performs custom
    provisioning tasks, however when attempting to view logs for this function nothing
    is being written to CloudWatch logs. You confirm that the log group name is configured
    correctly for the function. What is the most likely reason for the issue?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您创建了一个带有内联Python函数的Lambda函数，用于执行自定义的配置任务，但是当尝试查看该函数的日志时，没有任何内容被写入CloudWatch日志。您确认日志组名称已正确配置给该函数。出现这个问题最可能的原因是什么？
- en: Further reading
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接，了解本章涵盖的主题的更多信息：
- en: CloudFormation RDS Instance Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html)
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation RDS实例资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-rds-database-instance.html)
- en: CloudFormation Application Load Balancer Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html)
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation应用负载均衡器资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-loadbalancer.html)
- en: CloudFormation Application Load Balancer Listener Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html)
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation应用负载均衡监听器资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-listener.html)
- en: CloudFormation Application Load Balancer Target Group Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html)
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation应用负载均衡目标组资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-elasticloadbalancingv2-targetgroup.html)
- en: CloudFormation ECS Task Definition Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html)
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation ECS任务定义资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html)
- en: CloudFormation ECS Service Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html)
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation ECS服务资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-service.html)
- en: CloudFormation Lambda Function Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation Lambda函数资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-lambda-function.html)
- en: CloudFormation Lambda Function Code: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html)
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation Lambda函数代码：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html)
- en: CloudFormation Custom Resource Documentation: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation自定义资源文档：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/template-custom-resources.html)
- en: CloudFormation Custom Resource Reference: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudFormation自定义资源参考：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/crpg-ref.html)
