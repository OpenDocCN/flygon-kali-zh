- en: Going Functional
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进行函数式编程
- en: 'This chapter introduces a programming paradigm called functional programming and
    its applicability in Java 11\. We will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一种称为函数式编程的编程范式，以及它在Java 11中的适用性。我们将涵盖以下内容：
- en: Using standard functional interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标准功能接口
- en: Creating a functional interface
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建函数式接口
- en: Understanding lambda expressions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解lambda表达式
- en: Using lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: Using method references
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: Leveraging lambda expressions in your programs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中利用lambda表达式
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Functional programming is the ability to treat a certain piece of functionality
    as an object and pass it as a parameter or the return value of a method. This
    feature is present in many programming languages, and Java acquired it with the
    release of Java 8.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是将某个功能作为对象对待，并将其作为方法的参数或返回值传递的能力。这个特性存在于许多编程语言中，Java在Java 8发布时获得了这个特性。
- en: It avoids creating a class, its object, and managing the object state. The result
    of a function depends only on the input data, no matter how many times it is called.
    This style makes the outcome more predictable, which is the most attractive aspect
    of functional programming.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 它避免了创建类、对象和管理对象状态。函数的结果仅取决于输入数据，无论调用多少次。这种风格使结果更可预测，这是函数式编程最吸引人的方面。
- en: Its introduction to Java also allows us to improve parallel programming capabilities
    in Java by shifting the responsibility of parallelism from the client code to
    the library. Before this, in order to process elements of Java collections, the
    client code had to acquire an iterator from the collection and organize the processing
    of the collection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它也让我们能够通过将并行性的责任从客户端代码转移到库中，来改进Java中的并行编程能力。在此之前，为了处理Java集合的元素，客户端代码必须从集合中获取迭代器并组织集合的处理。
- en: Some of the default methods of Java collections accept a function (an implementation
    of a functional interface) as a parameter and then apply it to each element of
    the collection. So, it is the library's responsibility to organize the processing. One
    example is the `forEach(Consumer)` method that is available in every `Iterable` interface,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate)` method
    that is available for every `Collection` interface, where `Predicate` is a functional
    interface too. Also, the `sort(Comparator)` and `replaceAll(UnaryOperator)` methods
    were added to the `List` interface, and the `compute()` method was added to `Map`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java集合的一些默认方法接受一个函数（函数式接口的实现）作为参数，然后将其应用于集合的每个元素。因此，库的责任是组织处理。一个例子是在每个Iterable接口中都可用的forEach(Consumer)方法，其中Consumer是一个函数式接口。另一个例子是在每个Collection接口中都可用的removeIf(Predicate)方法，其中Predicate也是一个函数式接口。此外，List接口中添加了sort(Comparator)和replaceAll(UnaryOperator)方法，Map中添加了compute()方法。
- en: Lambda expressions take advantage of functional interfaces and significantly
    simplify their implementation, making the code shorter, clearer, and more expressive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式利用函数式接口，并显著简化了它们的实现，使代码更短、更清晰、更具表现力。
- en: Throughout this chapter, we will discuss the advantages of functional programming,
    define and explain functional interfaces and lambda expressions, and demonstrate
    all the related features in code examples.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数式编程的优势，定义和解释函数式接口和lambda表达式，并在代码示例中演示所有相关功能。
- en: Making functions first-class citizens of the language adds more power to Java.
    But taking advantage of this language capability requires—from those not exposed
    to functional programming yet—a new way of thinking and organizing the code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使函数成为语言的一等公民为Java增加了更多的功能。但利用这种语言能力需要——对于尚未接触函数式编程的人来说——一种新的思维方式和代码组织方式。
- en: Explaining this new feature and sharing the best practices of using it is the
    purpose of this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 解释这一新特性并分享使用它的最佳实践是本章的目的。
- en: Using standard functional interfaces
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标准功能接口
- en: In this recipe, you will learn what a functional interface is and why it was
    added to Java, along with 43 ready-to-use functional interfaces of the standard
    Java library that comes with JDK 8 in the `java.util.function` package.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习什么是函数式接口，以及为什么它被添加到Java中，以及JDK 8中附带的标准Java库中的43个可用的函数式接口。
- en: Without functional interfaces, the only way to pass a functionality into a method
    would be through writing a class, creating its object, and then passing it as
    a parameter. But even the least involved style—using an anonymous class—requires
    writing too much code. Using functional interfaces helps to avoid all of that.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 没有函数式接口，将功能传递到方法的唯一方法是通过编写一个类，创建其对象，然后将其作为参数传递。但即使是最不涉及的样式——使用匿名类——也需要编写太多的代码。使用函数式接口有助于避免所有这些。
- en: Getting ready
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Any interface that has one and only one abstract method is called a functional
    interface. To help avoid a runtime error, the `@FunctionalInterface` annotation
    can be added in front of the interface. It tells the compiler about the intent,
    so the compiler can check to see whether there is actually one abstract method
    in that interface, including those inherited from other interfaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有一个且仅有一个抽象方法的接口都被称为函数式接口。为了避免运行时错误，可以在接口前面添加@FunctionalInterface注解。它告诉编译器意图，因此编译器可以检查该接口中是否实际上有一个抽象方法，包括从其他接口继承的方法。
- en: 'In our demo code in the previous chapters, we''ve already had an example of
    a functional interface, even if we did not annotate it as functional:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的演示代码中，我们已经有了一个函数式接口的示例，即使我们没有将其注释为函数式接口。
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The presence of `enum` types or any implemented (default or static) methods
    does not make it a non-functional interface. Only abstract (not implemented) methods
    count. So, this is an example of a functional interface too:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型的存在或任何实现的（默认或静态）方法并不会使其成为非功能接口。只有抽象（未实现）方法才算。因此，这也是一个功能接口的例子：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To recap what you have already learned about a default method of an interface
    in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast Track to OOP
    - Classes and Interfaces*, the `getWeightPounds()` method will return `-1` when
    called by `getWeightKg()` or directly, using the object of a class that implements
    the `Vehicle` interface. However, this is only true if the `getWeightPounds()`
    method is not implemented in a class. Otherwise, the class implementation will
    be used and return a different value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾您在[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中已经学到的关于接口的默认方法，`getWeightPounds()`方法在被`getWeightKg()`调用或直接调用时将返回`-1`，使用实现`Vehicle`接口的类的对象。但是，只有在类中未实现`getWeightPounds()`方法时才会如此。否则，将使用类的实现并返回不同的值。
- en: In addition to default and static interface methods, a functional interface
    can include any and all abstract methods of the `java.lang.Object` base. In Java,
    every object is provided with the default implementation of `java.lang.Object`
    methods, so the compiler and Java runtime ignore such abstract methods.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认和静态接口方法，功能接口还可以包括`java.lang.Object`基类的任何和所有抽象方法。在Java中，每个对象都提供了`java.lang.Object`方法的默认实现，因此编译器和Java运行时会忽略这样的抽象方法。
- en: 'For example, this is a functional interface, too:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这也是一个功能接口：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following is not a functional interface, though:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下虽然不是功能接口：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is because the `Car` interface has two abstract methods—its own `getPassengersCount()`
    method and the `setSpeedModel(SpeedModel speedModel)` method inherited from the
    `Vehicle` interface.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`Car`接口有两个抽象方法——它自己的`getPassengersCount()`方法和从`Vehicle`接口继承的`setSpeedModel(SpeedModel
    speedModel)`方法。
- en: 'We can try to add the `@FunctionalInterface` annotation to the `Car` interface:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试将`@FunctionalInterface`注解添加到`Car`接口中：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we do that, the compiler generates the following error:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做，编译器将生成以下错误：
- en: '![](img/df18df69-1aed-4f20-b3cf-b2c5f741d2f6.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df18df69-1aed-4f20-b3cf-b2c5f741d2f6.png)'
- en: Using the `@FunctionalInterface` annotation helps to not only catch errors at
    compile-time, but it also secures reliable communication of the design intent
    between programmers. It helps you or other programmers remember that this interface
    cannot have more than one abstract method, which is especially important when
    some code exists already that relies on such an assumption.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@FunctionalInterface`注解不仅有助于在编译时捕获错误，而且还确保了程序员之间设计意图的可靠沟通。它可以帮助您或其他程序员记住该接口不能有多个抽象方法，这在已经存在依赖于这种假设的一些代码时尤其重要。
- en: 'For the same reason, the `Runnable` and `Callable` interfaces (they''ve existed
    in Java since its earlier versions) were annotated as `@FunctionalInterface` in
    Java 8 to make this distinction explicit:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，`Runnable`和`Callable`接口（它们自Java早期版本以来就存在）在Java 8中被注释为`@FunctionalInterface`，以明确区分：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: Before you create your own functional interface, consider using one of the 43
    functional interfaces provided in the `java.util.function` package first. Most
    of them are specializations of the `Function`, `Consumer`, `Supplier`, and `Predicate` interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自己的功能接口之前，首先考虑使用`java.util.function`包中提供的43个功能接口中的一个。它们中的大多数是`Function`、`Consumer`、`Supplier`和`Predicate`接口的特殊化。
- en: 'The following are the steps you can follow to get familiar with functional
    interfaces:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以遵循的步骤，以熟悉功能接口：
- en: 'Look at the `Function<T,R>` functional interface:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看`Function<T,R>`功能接口：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see from the `<T,R>` generics, the only method of this interface
    takes a parameter of the `T` type and returns a value of the `R` type. According
    to the JavaDoc, this interface has the `R apply(T t)` method. We can create an
    implementation of this interface using an anonymous class:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从`<T,R>`泛型中可以看出，该接口的唯一方法接受`T`类型的参数并返回`R`类型的值。根据JavaDoc，该接口具有`R apply(T t)`方法。我们可以使用匿名类创建该接口的实现：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `R apply(T t)` method in our implementation accepts a value of the `Integer` type
    (or the `int` primitive, which is going to be auto-boxed), multiplies it by `10`,
    and returns the value of the `Double` type so that we can use our new function
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现中的`R apply(T t)`方法接受`Integer`类型的值（或将自动装箱的`int`原始类型），将其乘以`10`，并返回`Double`类型的值，以便我们可以如下使用我们的新函数：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the recipe *Understanding lambda expressions* below, we will introduce a
    lambda expression and show you how its usage makes the implementation much shorter.
    But for now, we will continue using an anonymous class.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的*理解lambda表达式*的示例中，我们将介绍lambda表达式，并向您展示它的使用方式如何使实现变得更短。但现在，我们将继续使用匿名类。
- en: 'Look at the `Consumer<T>` functional interface. The name helps us to remember
    that the method of this interface accepts a value but does not return anything—it
    only consumes. Its only method is `void accept(T)`. The implementation of this
    interface can look as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看`Consumer<T>`功能接口。名称帮助我们记住该接口的方法接受一个值，但不返回任何东西——它只消耗。它的唯一方法是`void accept(T)`。该接口的实现可以如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `void accept(T t)` method in our implementation receives a value of the `String` type
    and prints it. For example, we can use it as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现中的`void accept(T t)`方法接收`String`类型的值并打印它。例如，我们可以这样使用它：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Look at the `Supplier<T>` functional interface. The name helps you to remember
    that the method of this interface does not accept any value but does return something—only
    supplies. Its only method is `T get()`. Based on this, we can create a function:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看`Supplier<T>`功能接口。名称帮助您记住该接口的方法不接受任何值，但确实返回一些东西——只提供。它的唯一方法是`T get()`。基于此，我们可以创建一个函数：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `T get()` method in our implementation does something and then returns
    a value of the `String` type, so we can write the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现中的`T get()`方法执行某些操作，然后返回`String`类型的值，因此我们可以编写以下内容：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Look at the `Predicate<T>` functional interface. The name helps to remember
    that the method of this interface returns a Boolean—it predicates something. Its
    only method is `boolean test(T t)`, which means that we can create the following
    function:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看一下`Predicate<T>`函数接口。名称有助于记住该接口的方法返回一个布尔值——它预测某些东西。它的唯一方法是`boolean test(T t)`，这意味着我们可以创建以下函数：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Its `boolean test(T t)` method of our implementation accepts a value of the `Double` type
    as a parameter and returns the value of the `boolean` type, so we can use it as
    follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现的`boolean test(T t)`方法接受`Double`类型的值作为参数，并返回`boolean`类型的值，因此我们可以这样使用它：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The result of this will be as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果：
- en: '![](img/e7d9f55b-d73b-41f4-9142-39cfb2f4fe29.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7d9f55b-d73b-41f4-9142-39cfb2f4fe29.png)'
- en: 'Look at the other 39 functional interfaces in the `java.util.function` package.
    Notice that they are variations of the four interfaces we have discussed already.
    These variations are created for the following reasons:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看`java.util.function`包中的其他39个函数接口。请注意，它们是我们已经讨论过的四个接口的变体。这些变体是为以下原因而创建的：
- en: For better performance by avoiding auto-boxing and unboxing via the explicit
    usage of the `int`, `double`, or `long` primitives
  id: totrans-65
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了通过显式使用`int`、`double`或`long`原始类型来避免自动装箱和拆箱而获得更好的性能
- en: For accepting two input parameters
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受两个输入参数
- en: For a shorter notation
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更短的表示法
- en: The following functional interfaces are just a few examples from the list of
    39 interfaces.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数接口只是39个接口列表中的几个示例。
- en: 'The `IntFunction<R>` functional interface has the `R apply(int i)` abstract
    method. It provides a shorter notation (without generics for the parameter type)
    and avoids auto-boxing (by defining the `int` primitive as the parameter). Here''s
    an example of its usage:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntFunction<R>`函数接口具有`R apply(int i)`抽象方法。它提供了更短的表示法（不带参数类型的泛型）并避免了自动装箱（通过将`int`原始类型定义为参数）。以下是其用法示例：'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `BiFunction<T,U,R>` functional interface has abstract method, `R apply(T,U)`.
    Here''s an example of its implementation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`BiFunction<T,U,R>`函数接口具有抽象方法`R apply(T,U)`。以下是其实现示例：'
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `BinaryOperator<T>` functional interface has an abstract method, `T apply(T,T)`.
    It provides a shorter notation by avoiding repeating the same type three times.
    Here''s an example of its usage:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`BinaryOperator<T>`函数接口具有一个抽象方法`T apply(T,T)`。它通过避免重复三次相同类型提供了更短的表示法。以下是其用法示例：'
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `IntBinaryOperator` functional interface has the `int applyAsInt(int,int)` abstract
    method. We can use it to reproduce the same functionality as in the previous example:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`IntBinaryOperator`函数接口具有`int applyAsInt(int,int)`抽象方法。我们可以使用它来复制前面示例中的相同功能：'
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: More examples of the usage of such specializations will be provided in the following
    recipes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的食谱将提供更多此类专业化用法示例。
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它的工作原理...
- en: 'We can compose the whole method using only the functions:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以仅使用函数来组成整个方法：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The preceding code gets the value from the source, processes it, and then decides
    whether the result is successful—all based on the functions provided as parameters.
    Now, let''s create these functions and invoke the method. The source parameter
    we decided to be as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码从源中获取值，处理它，然后根据提供的函数决定结果是否成功。现在，让我们创建这些函数并调用该方法。我们决定源参数如下：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In real-life code, this function could pull data from a database or any other
    source of data. We keep it simple—with a hardcoded return value—in order to get
    a predictable result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际代码中，此函数可以从数据库或任何其他数据源中提取数据。我们保持简单——使用硬编码的返回值——以获得可预测的结果。
- en: 'The processing function and predicate will remain the same as before:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 处理函数和谓词将保持与以前相同的方式：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the consumers will be almost identical, except for the different prefix
    before printing the result:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者几乎相同，只是在打印结果之前有不同的前缀：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can now invoke the calculate method, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以调用calculate方法，如下所示：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And the result will be as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we need to quickly test various combinations of the source value and the
    predicate condition, we can create the `testSourceAndCondition(int src, int limit)` method,
    as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要快速测试源值和谓词条件的各种组合，我们可以创建`testSourceAndCondition(int src, int limit)`方法，如下所示：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how we pass the `src` value into the `source` supplier, and the `limit` value
    into the `condition` predicate. Now, we can run the `testSourceAndCondition(int
    src, int limit)` method with different input values in search of the combination
    of the `src` value and the `limit` value that brings success:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将`src`值传递给`source`供应商，将`limit`值传递给`condition`谓词。现在，我们可以运行`testSourceAndCondition(int
    src, int limit)`方法，使用不同的输入值寻找`src`值和`limit`值的组合，以获得成功：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The result will be as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Many of the functional interfaces in the `java.util.function` package have
    default methods that not only enhance their functionality but also allow you to
    chain the functions and pass the result of one as an input parameter to another.
    For example, we can use the `Function<T,V> andThen(Function<R,V> after)` default
    method of the `Function<T,R>` interface:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中的许多函数接口都具有默认方法，不仅增强了它们的功能，还允许您将函数链接在一起，并将一个函数的结果作为输入参数传递给另一个函数。例如，我们可以使用`Function<T,V>
    andThen(Function<R,V> after)`接口的默认方法：'
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, our `process` function is now a combination of our original
    function (which multiplies the source value by 10.0) and a new function, `after`,
    that adds 10.0 to the result of the first function. If we call the `testSourceAndCondition(int
    source, int condition)` method as  `testSourceAndCondition(42, 20)`, the result
    will be as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的`process`函数现在是我们原始函数（将源值乘以10.0）和一个新函数`after`的组合，该函数将10.0添加到第一个函数的结果中。如果我们调用`testSourceAndCondition(int
    source, int condition)`方法，如`testSourceAndCondition(42, 20)`，结果将如下所示：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `Supplier<T>` interface does not have methods that allow us to chain several
    functions, but the `Predicate<T>` interface has the `and(Predicate<T> other)` and `or(Predicate<T>
    other)` default methods, which allow us to construct more complex Boolean expressions.
    The `Consumer<T>` interface has the `andThen(Consumer<T> after)` default method,
    too.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier<T>`接口没有允许我们链接多个函数的方法，但`Predicate<T>`接口有`and(Predicate<T> other)`和`or(Predicate<T>
    other)`默认方法，允许我们构造更复杂的布尔表达式。`Consumer<T>`接口也有`andThen(Consumer<T> after)`默认方法。'
- en: 'Notice how the type of the input value of the `after` function has to match
    the result type of the `before` function:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`after`函数的输入值类型必须与`before`函数的结果类型匹配：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The resulting function accepts a value of the `T` type and produces a value
    of the `V` type.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数接受`T`类型的值并产生`V`类型的值。
- en: 'Another way to achieve the same result is to use the `Function<V,R> compose(Function<V,T>
    before)` default method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的另一种方法是使用`Function<V,R> compose(Function<V,T> before)`默认方法：
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Which of the methods—`andThen()` or `compose()`—to use depends on which of the
    functions is available to invoke the aggregating method. Then, one is considered
    a base, while another is a parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`andThen()`或`compose()`中的哪种方法取决于哪个函数可用于调用聚合方法。然后，一个被认为是基础，而另一个是参数。
- en: If this coding looks a bit over-engineered and convoluted, that's because it
    is. We did it for demo purposes only. The good news is that lambda expressions
    presented in the next recipe allow us to achieve the same results in a much shorter
    and clearer way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种编码看起来有点过度设计和复杂，那是因为确实如此。我们只是为了演示目的而这样做的。好消息是，下一个示例中介绍的lambda表达式可以让我们以更简洁和更清晰的方式实现相同的结果。
- en: 'Functional interfaces of the `java.util.function` package have other helpful
    default methods. The one that stands out is the `identity()` method, which returns
    a function that always returns its input argument:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包的函数接口还有其他有用的默认方法。其中一个突出的是`identity()`方法，它返回一个始终返回其输入参数的函数：'
- en: '[PRE32]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `identity()` method is very helpful when a method requires you to provide
    a certain function, but you do not want this function to modify the result.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity()`方法在需要提供某个函数但不希望该函数修改结果时非常有用。'
- en: Other default methods are mostly related to conversion, boxing, unboxing, and
    extracting the min and max of two parameters. We encourage you to walk through
    the API of all the functional interfaces of the `java.util.function` and get an
    idea of the possibilities.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其他默认方法大多与转换、装箱、拆箱以及提取两个参数的最小值和最大值有关。我们鼓励您浏览`java.util.function`的所有函数接口的API，并了解可能性。
- en: Creating a functional interface
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建函数接口
- en: In this recipe, you will learn how to create and use a custom functional interface
    when none of the standard interfaces in the `java.util.function` package satisfies
    the requirements.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，您将学习如何在`java.util.function`包中没有满足要求的标准接口时创建和使用自定义函数接口。
- en: Getting ready
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Creating a functional interface is easy. One just has to make sure there is
    only one abstract method in the interface, including methods inherited from other
    interfaces:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建函数接口很容易。只需确保接口中只有一个抽象方法，包括从其他接口继承的方法：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the preceding example, interface `C` is not a functional interface because
    it has two abstract methods—`m1()`, inherited from interface `A`, and its own
    method, `m3()`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，接口`C`不是函数接口，因为它有两个抽象方法-`m1()`，从接口`A`继承，以及它自己的方法`m3()`。
- en: 'We have also already seen the `SpeedModel` functional interface:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了`SpeedModel`函数接口：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have annotated it to express the intent and to be warned in case another
    abstract method will be added to the `SpeedModel` interface. And, to make it simpler,
    we have removed `enum` classes from it. This interface is used in the `Vehicle`
    interface:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对其进行了注释以表达意图，并在`SpeedModel`接口中添加另一个抽象方法时得到警告。为了简化，我们已将`enum`类从中删除。此接口用于`Vehicle`接口：
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And the reason the `Vehicle` implementation needs it is because `SpeedModel`
    is the source of the functionality that calculates the speed:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vehicle`实现需要它的原因是`SpeedModel`是计算速度功能的来源：'
- en: '[PRE36]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As we mentioned in [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml),
    *Fast Track to OOP – Classes and Interfaces*, such a design is called aggregation.
    It is a preferred way of composing the desired behavior as it allows for more
    flexibility.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中提到的*OOP快速通道-类和接口*，这种设计被称为聚合。这是组合所需行为的首选方式，因为它允许更灵活性。
- en: With functional interfaces, such a design becomes even more flexible. To demonstrate
    it, let's implement our custom interface—`SpeedModel`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数接口，这种设计变得更加灵活。为了演示，让我们实现我们的自定义接口`SpeedModel`。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The traditional approach would be to create a class that implements the `SpeedModel` interface:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的方法是创建一个实现`SpeedModel`接口的类：
- en: '[PRE37]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then, we can use this implementation as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按以下方式使用此实现：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To change the way the speed is calculated, we need to change the `SpeedModelImpl` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改速度计算的方式，我们需要更改`SpeedModelImpl`类。
- en: 'Alternatively, using the fact that `SpeedModel` is an interface, we can introduce
    changes faster and even avoid having the `SpeedModelImpl` class in the first place:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，利用`SpeedModel`是一个接口的事实，我们可以更快地引入更改，甚至避免首先拥有`SpeedModelImpl`类：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'However, the preceding implementation does not take advantage of the interface
    being functional. If we comment out the annotation, we can add another method
    to the `SpeedModel` interface:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的实现没有利用接口是功能性的优势。如果我们注释掉注解，我们可以向`SpeedModel`接口添加另一个方法：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see from the preceding code, not only `SpeedModel` interface has
    another abstract method `m1()`, but the anonymous class has yet another method `m2()` that
    is not listed in the `SpeedModel` interface. So, an anonymous class does not require
    the interface to be functional. But lambda expression does.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，不仅`SpeedModel`接口有另一个抽象方法`m1()`，而且匿名类还有另一个未在`SpeedModel`接口中列出的方法`m2()`。因此，匿名类不需要接口是功能性的。但是lambda表达式需要。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Using lambda expressions, we can rewrite the preceding code as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用lambda表达式，我们可以将前面的代码重写如下：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will discuss the lambda expressions format in the next recipe. For now, we
    would like only to point out the importance of functional interfaces for an implementation
    such as the preceding one. As you can see, there is only the name of the interface
    specified and no method name at all. That is possible because a functional interface
    has only one method that has to be implemented, and that is how JVM can figure
    it out and generate a functional interface implementation behind the scenes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个示例中讨论lambda表达式的格式。现在，我们只想指出功能接口对于前面的实现非常重要。正如您所看到的，只指定了接口的名称，没有任何方法名称。这是可能的，因为功能接口只有一个必须实现的方法，这就是JVM如何找出并在幕后生成功能接口实现的方式。
- en: There's more...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'It is possible to define a generic custom functional interface that looks similar
    to the standard functional interfaces. For example, we could create the following
    custom functional interface:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个类似于标准功能接口的通用自定义功能接口。例如，我们可以创建以下自定义功能接口：
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It allows three input parameters, which is exactly what we need to calculate
    the speed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许三个输入参数，这正是我们计算速度所需要的：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Using this function instead of the `SpeedModel` interface, we could change
    the `Vehicle` interface and its implementation as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个函数而不是`SpeedModel`接口，我们可以将`Vehicle`接口及其实现更改如下：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The preceding code produces the same result as before—with the `SpeedModel`
    interface.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了与`SpeedModel`接口相同的结果。
- en: 'The name of the custom interface and the name of its only method can be anything
    we like. For example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义接口的名称和其唯一方法的名称可以是我们喜欢的任何东西。例如：
- en: '[PRE45]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Well, since we are going to create a new interface anyway, using the `SpeedModel` name
    and the `getSpeedMph()` method name is probably a better solution since it makes
    the code more readable. But there are cases when a generic custom functional interface
    is a better choice. In such cases, you can use the preceding definition and enhance
    it however you need to.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们无论如何都要创建一个新接口，使用`SpeedModel`名称和`getSpeedMph()`方法名称可能是更好的解决方案，因为这样可以使代码更易读。但是在某些情况下，通用自定义功能接口是更好的选择。在这种情况下，您可以使用前面的定义，并根据需要进行增强。
- en: Understanding lambda expressions
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解lambda表达式
- en: We have mentioned lambda expressions several times already and stated that their
    usage in Java justified the introduction of functional interfaces in the `java.util.function` package.
    The lambda expression allows us to simplify function implementation by removing
    all boilerplate code of anonymous classes, leaving only minimally necessary information.
    We have also explained that this simplification is possible because a functional
    interface has only one abstract method, so the compiler and JVM match the provided
    functionality with the method signature and generate the functional interface
    implementation behind the scene.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次提到lambda表达式，并指出它们在Java中的使用证明了在`java.util.function`包中引入功能接口的必要性。lambda表达式允许我们通过删除匿名类的所有样板代码来简化函数实现，只留下最少必要的信息。我们还解释了这种简化是可能的，因为功能接口只有一个抽象方法，所以编译器和JVM将提供的功能与方法签名进行匹配，并在幕后生成功能接口实现。
- en: Now, it's time to define the lambda expression syntax and see the range of possible
    forms of lambda expressions, before we start using them to make our code shorter
    and more readable than when we used anonymous classes.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候定义lambda表达式语法并查看lambda表达式的可能形式范围了，在我们开始使用它们使我们的代码比使用匿名类时更短更易读之前。
- en: Getting ready
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the 1930s, the mathematician Alonzo Church, in the course of his research
    into the foundations of mathematics, introduced lambda calculus—a universal model
    of computation that can be used to simulate any Turing machine. Well, at that
    time, the Turing machine hadn't been created. Only later, when Alan Turing invented
    his *a-machine* (automatic machine), also called the *universal Turing machine*,
    did he and Church join forces and produce a Church-Turing thesis that showed that
    lambda calculus and the Turing machine had very similar capabilities.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在20世纪30年代，数学家阿隆佐·邱奇在研究数学基础时引入了lambda演算——一种通用的计算模型，可以用来模拟任何图灵机。那个时候，图灵机还没有被创建。只有后来，当艾伦·图灵发明了他的*a-机器*（自动机），也称为*通用图灵机*时，他和邱奇联手提出了一个邱奇-图灵论题，表明lambda演算和图灵机具有非常相似的能力。
- en: Church used the Greek letter *lambda* to describe anonymous functions, and it
    became an unofficial symbol of the field of programming language theory. The first
    programming language that took advantage of lambda calculus formalism was Lisp.
    Java added functional programming to its capabilities in 2014, with the release
    of Java 8.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Church使用希腊字母*lambda*来描述匿名函数，它成为了编程语言理论领域的非官方符号。第一个利用lambda演算形式的编程语言是Lisp。Java在2014年发布Java
    8时添加了函数式编程能力。
- en: A lambda expression is an anonymous method that allows us to omit modifiers,
    return types, and parameter types. That makes for a very compact notation. The
    syntax of a lambda expression includes the list of parameters, an arrow token
    (`->`), and a body. The list of parameters can be empty (just brackets, `()`),
    without brackets (if there is only one parameter), or a comma-separated list of
    parameters surrounded by brackets. The body can be a single expression without
    brackets or a statement block surrounded by brackets.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式是一个允许我们省略修饰符、返回类型和参数类型的匿名方法。这使得它非常紧凑。lambda表达式的语法包括参数列表、箭头标记(`->`)和主体。参数列表可以为空（只有括号，`()`），没有括号（如果只有一个参数），或者由括号括起来的逗号分隔的参数列表。主体可以是一个没有括号的单个表达式，也可以是由括号括起来的语句块。
- en: How to do it...
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Let''s look at a few examples. The following lambda expression has no input
    parameters and always returns `33`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子。以下lambda表达式没有输入参数，总是返回`33`：
- en: '[PRE46]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following lambda expression accepts one parameter of the integer type, increments
    it by 1, and returns the result:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下lambda表达式接受一个整数类型的参数，将其增加1，并返回结果：
- en: '[PRE47]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following lambda expression accepts two parameters and returns their sum:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下lambda表达式接受两个参数并返回它们的和：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following lambda expression accepts two parameters, compares them, and
    returns the `boolean` result:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下lambda表达式接受两个参数，比较它们，并返回`boolean`结果：
- en: '[PRE49]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And the last lambda expression accepts two parameters, calculates, and prints
    the result:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个lambda表达式接受两个参数，计算并打印结果：
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, a lambda expression can include a code block of any size—similarly
    to any method. The preceding example does not return any value. Here is another
    example of a code block that returns the `String` value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，lambda表达式可以包含任意大小的代码块，类似于任何方法。前面的例子没有返回任何值。这里是另一个返回`String`值的代码块的例子：
- en: '[PRE51]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s look at that last example again. If there is a `String m1(double x,
    double y)` method defined in a *functional* interface, `A`, and if there is a `m2(A
    a)` method that accepts an object of the `A` type, we can invoke it as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看最后一个例子。如果在*functional*接口`A`中定义了一个`String m1(double x, double y)`方法，并且有一个接受`A`类型对象的`m2(A
    a)`方法，我们可以这样调用它：
- en: '[PRE52]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code means that the passed-in object has the following implementation
    of the `m1()` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码意味着传入的对象有以下`m1()`方法的实现：
- en: '[PRE53]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The fact that `m2(A a)` has the `A` object as a parameter tells us that the
    code of `m2(A a)` probably uses at least one of the `A` interface methods (there
    may be also defaulted or static methods in the `A` interface). But, in general,
    there is no guarantee that the method uses the passed-in object because the programmer
    may have decided to stop using it and left the signature unchanged just to avoid
    breaking the client code, for example.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`m2(A a)`有`A`对象作为参数告诉我们，`m2(A a)`的代码可能使用了`A`接口的至少一个方法（`A`接口中也可能有默认或静态方法）。但是，一般来说，不能保证方法使用了传入的对象，因为程序员可能决定停止使用它，但保持签名不变，以避免破坏客户端代码，例如。'
- en: Nevertheless, the client must pass into the method an object that implements
    the `A` interface, which means its only abstract method has to be implemented.
    And that is what the lambda expression does. It defines the abstract method functionality
    using the minimal amount of code—a list of the input parameters and a code block
    of the method's implementation. This is all the compiler and JVM need to generate
    an implementation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，客户端必须传入实现`A`接口的对象到方法中，这意味着它的唯一抽象方法必须被实现。这就是lambda表达式所做的事情。它使用最少的代码定义抽象方法的功能——输入参数列表和方法实现的代码块。这就是编译器和JVM生成实现所需的一切。
- en: Writing such compact and efficient code became possible because of the combination
    of a lambda expression and functional interface.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 编写这样紧凑和高效的代码成为可能，是因为lambda表达式和函数接口的结合。
- en: There's more...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'As in an anonymous class, the variable created outside but used inside a lambda
    expression becomes effectively final and cannot be modified. You can write the
    following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与匿名类一样，外部创建但在lambda表达式内部使用的变量实际上是最终的，不能被修改。你可以写下以下代码：
- en: '[PRE54]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'However, you cannot change the value of the `v` variable outside the lambda
    expression:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能在lambda表达式外部改变`v`变量的值：
- en: '[PRE55]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You cannot change it inside the expression, either:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你也不能在表达式内部改变它：
- en: '[PRE56]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The reason for this restriction is that a function can be passed and executed
    for different arguments in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would frustrate the original idea
    of the distributed evaluation of functions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制的原因是一个函数可以在不同的上下文（例如不同的线程）中传递和执行不同的参数，试图同步这些上下文会破坏函数的分布式评估的原始想法。
- en: 'Another lambda expression feature worth mentioning is its interpretation of
    the `this` keyword, which is quite different from its interpretation by an anonymous
    class. Inside an anonymous class, `this` refers to the instance of the anonymous
    class, but inside the lambda expression, `this` refers to the instance of the
    class that surrounds the expression. Let''s demonstrate it, assuming that we have
    the following class:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得一提的lambda表达式特性是它对`this`关键字的解释，这与匿名类的解释有很大不同。在匿名类内部，`this`指的是匿名类的实例，但在lambda表达式内部，`this`指的是包围表达式的类的实例。让我们来演示一下，假设我们有以下类：
- en: '[PRE57]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'As you can see, in the `method()` code, the `Consumer` functional interface
    is implemented twice—using the lambda expression and using an anonymous class.
    Let''s invoke this method in the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在`method()`代码中，`Consumer`函数接口被实现了两次——使用lambda表达式和使用匿名类。让我们在以下代码中调用这个方法：
- en: '[PRE58]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The output will be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '![](img/324ceaa7-1714-4153-bd7a-43ae67258283.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](img/324ceaa7-1714-4153-bd7a-43ae67258283.png)'
- en: The lambda expression is not an inner class and cannot be referred to by `this`.
    The lambda expression just does not have fields or properties. It is stateless.
    That's why in a lambda expression, the `this` keyword refers to the surrounding
    context. And that is another reason for the requirement that all the variables
    of the surrounding context used by the lambda expression must be final or effectively
    final.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式不是内部类，也不能被`this`引用。Lambda表达式没有字段或属性。它是无状态的。这就是为什么在lambda表达式中，`this`关键字指的是周围的上下文。这也是lambda表达式要求周围上下文中的所有变量必须是final或有效final的另一个原因。
- en: Using lambda expressions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: In this recipe, you will learn how to use lambda expressions in practice.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，你将学习如何在实践中使用lambda表达式。
- en: Getting ready
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Creating and using lambda expressions is actually much simpler than writing
    a method. One just needs to list the input parameters, if any, and the code that
    does what has to be done.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和使用lambda表达式实际上比编写方法简单得多。只需要列出输入参数（如果有的话），以及执行所需操作的代码。
- en: 'Let''s revisit our implementation of standard functional interfaces from the
    first recipe of this chapter and rewrite them using lambda expressions. Here''s
    how we have implemented the four main functional interfaces using anonymous classes:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视本章第一个示例中标准功能接口的实现，并使用lambda表达式重写它们。以下是我们使用匿名类实现了四个主要功能接口的方式：
- en: '[PRE59]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'And here''s how they look with lambda expressions:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用lambda表达式的样子：
- en: '[PRE60]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The examples of specialized functional interfaces we have presented are as
    follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供的专门功能接口示例如下：
- en: '[PRE61]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And here''s how they look with lambda expressions:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用lambda表达式的样子：
- en: '[PRE62]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: As you can see, the code is less cluttered and more readable.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，代码更简洁，更易读。
- en: How to do it...
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Those who have some traditional code-writing experience, when starting functional
    programming, equate functions with methods.  They try to create functions first
    because that was how we all used to write traditional code—by creating methods.
    Yet, functions are just smaller pieces of functionality that modify some aspects
    of the behavior of the methods or provide the business logic for the otherwise
    non-business-specific code. In functional programming, as in traditional programming,
    methods continue to provide the code structure, while functions are the nice and
    helpful additions to it. So, in functional programming, creating a method comes
    first, before the functions are defined. Let's demonstrate this.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那些有一些传统代码编写经验的人，在开始进行函数式编程时，将函数等同于方法。他们首先尝试创建函数，因为这是我们以前编写传统代码的方式——通过创建方法。然而，在函数式编程中，方法继续提供代码结构，而函数则是它的良好和有用的补充。因此，在函数式编程中，首先创建方法，然后再定义函数。让我们来演示一下。
- en: 'The following are the basic steps of code writing. First, we identify the well-focused
    block of code that can be implemented as a method. Then, after we know what the
    new method is going to do, we can convert some pieces of its functionality into
    functions:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码编写的基本步骤。首先，我们确定可以作为方法实现的精心设计的代码块。然后，在我们知道新方法将要做什么之后，我们可以将其功能的一些部分转换为函数：
- en: 'Create the `calculate()` method:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`calculate()`方法：
- en: '[PRE63]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The preceding pseudocode outlines the idea of the `calculate()` method''s functionality.
    It can be implemented in a traditional style—by using methods, as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述伪代码概述了`calculate()`方法的功能。它可以以传统方式实现——通过使用方法，如下所示：
- en: '[PRE64]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'But some of these methods may be very small, so the code becomes fragmented
    and less readable with so many additional indirections. This disadvantage becomes
    especially glaring in the case when the methods come from outside the class where
    the `calculate()` method is implemented:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 但是其中一些方法可能非常小，因此代码变得分散，使用这么多额外的间接会使代码变得不太可读。这个缺点在方法来自实现`calculate()`方法的类外部的情况下尤为明显：
- en: '[PRE65]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: As you can see, in the case where each of the external methods is small, the
    amount of plumbing code may substantially exceed the payload it supports. Besides,
    the preceding implementation creates many tight dependencies between classes.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在每个外部方法都很小的情况下，管道代码的数量可能大大超过它所支持的负载。此外，上述实现在类之间创建了许多紧密的依赖关系。
- en: 'Let''s look at how we can implement the same functionality using functions.
    The advantage is that the functions can be as small as they need to be, but the
    plumbing code will never exceed the payload because there is no plumbing code.
    Another reason to use functions is when we need the flexibility to change sections
    of the functionality on the fly, for the algorithm''s research purpose. And if
    these pieces of functionality have to come from outside the class, we do not need
    to build other classes just for the sake of passing a method into `calculate()`.
    We can pass them as functions:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看如何使用函数来实现相同的功能。优势在于函数可以尽可能小，但是管道代码永远不会超过负载，因为没有管道代码。使用函数的另一个原因是，当我们需要灵活地在算法研究目的上更改功能的部分时。如果这些功能部分需要来自类外部，我们不需要为了将方法传递给`calculate()`而构建其他类。我们可以将它们作为函数传递：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Here''s how the functions may look:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是函数可能的样子：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The result of the preceding code is going to be as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果将如下：
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: How it works...
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The lambda expression acts as a regular method, except when you think about
    testing each function separately. How to do it?
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式就像一个普通的方法，除了当你考虑单独测试每个函数时。如何做呢？
- en: 'There are two ways to address this issue. First, since the functions are typically
    small, there is often no need to test them separately, and they are tested indirectly
    when the code that uses them is tested. Second, if you still think the function
    has to be tested, it is always possible to wrap it in the method that returns
    the function, so you can test that method as any other method. Here is an example
    of how it can be done:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来解决这个问题。首先，由于函数通常很小，通常不需要单独测试它们，它们在使用它们的代码测试时间接测试。其次，如果您仍然认为函数必须进行测试，总是可以将其包装在返回函数的方法中，这样您就可以像测试其他方法一样测试该方法。以下是如何做的一个例子：
- en: '[PRE69]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we can write the function unit tests as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写函数单元测试如下：
- en: '[PRE70]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Typically, lambda expressions (and functions in general) are used for specializing
    otherwise generic functionalities—by adding business logic to a method. A good
    example is stream operations, which we are going to discuss in [Chapter 5](eaa70333-8e9d-453d-a9b6-063152fcc1e1.xhtml), *Streams
    and Pipelines.* The library authors have created them to be able to work in parallel,
    which required a lot of expertise. And now the library users can specialize the
    operations by passing into them the lambda expressions (functions) that provide
    the application's business logic.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，lambda表达式（以及一般的函数）用于为通用功能添加业务逻辑，从而实现特定功能。一个很好的例子是流操作，我们将在第5章《流和管道》中讨论。库的作者已经创建了它们以便能够并行工作，这需要很多专业知识。现在库的用户可以通过传递lambda表达式（函数）来专门定制操作，从而提供应用程序的业务逻辑。
- en: There's more...
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Since, as we have mentioned already, functions are often simple one-liners,
    they are often inlined when passed in as parameters, for example:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 由于，正如我们已经提到的，函数通常是简单的一行代码，当作为参数传递时通常会内联，例如：
- en: '[PRE71]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: But one should not push it too far, as such inlining may decrease code readability.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，不要过分推动，因为这样的内联可能会降低代码的可读性。
- en: Using method references
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法引用
- en: In this recipe, you will learn how to use a method reference, with the constructor
    reference being one of the cases.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何使用方法引用，构造函数引用是其中的一种情况。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: When a one-line lambda expression consists only of a reference to an existing
    method implemented somewhere else, it is possible to further simplify the lambda
    notation by using the *method reference*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当一行lambda表达式只包含对其他地方实现的现有方法的引用时，可以进一步简化lambda表示法，使用方法引用。
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found.
    The two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的语法是`Location::methodName`，其中`Location`表示`methodName`方法所在的位置（对象或类）。两个冒号(`::`)作为位置和方法名之间的分隔符。如果在指定的位置有多个同名方法（因为方法重载），则引用方法由lambda表达式实现的函数接口的抽象方法的签名来确定。
- en: How to do it...
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: The exact format of the method reference depends on whether the referred method
    is static or non-static. The method reference can also be *bound* or *unbound*,
    or to be more formal, the method reference can have a *bound receiver* or an *unbound
    receiver.* A receiver is an object or class that is used to invoke the method.
    It *receives* the call. It can be bound to a particular context or not (unbound).
    We will explain what this means during the demonstration.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的确切格式取决于所引用的方法是静态的还是非静态的。方法引用也可以是*绑定的*或*未绑定的*，或者更正式地说，方法引用可以有*绑定的接收者*或*未绑定的接收者*。接收者是用于调用方法的对象或类。它*接收*调用。它可以绑定到特定的上下文或不绑定。我们将在演示过程中解释这意味着什么。
- en: The method reference can also refer to a constructor with or without parameters.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用也可以引用带参数或不带参数的构造函数。
- en: Please note that the method reference is applicable *only when the expression
    consists of only one method call and nothing else*. For example, a method reference
    can be applied to the `() -> SomeClass.getCount()` lambda expression. It will
    look like `SomeClass::getCount`. But the expression `() -> 5 + SomeClass.getCount()` cannot
    be replaced with method reference because there are more operations in this expression
    than just a method call.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法引用仅适用于表达式只包含一个方法调用而没有其他内容的情况。例如，方法引用可以应用于`() -> SomeClass.getCount()`
    lambda表达式。它看起来像`SomeClass::getCount`。但是表达式`() -> 5 + SomeClass.getCount()`不能用方法引用替换，因为这个表达式中有比方法调用更多的操作。
- en: Static unbound method reference
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态未绑定方法引用
- en: 'To demonstrate a static method reference, we will use the `Food` class with
    two static methods:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示静态方法引用，我们将使用`Food`类和两个静态方法：
- en: '[PRE72]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Since the first method, `String getFavorite()`, does not accept any input parameters and
    returns a value, it can be implemented as a functional interface, `Supplier<T>`.
    The lambda expression that implements the function that consists of the call to
    the `String getFavorite()` static method looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于第一个方法`String getFavorite()`不接受任何输入参数并返回一个值，它可以作为一个函数接口`Supplier<T>`来实现。实现调用`String
    getFavorite()`静态方法的lambda表达式如下：
- en: '[PRE73]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Using the method reference, the preceding line changes to the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法引用，前面的行变成了以下内容：
- en: '[PRE74]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see, the preceding format defines the location of the method (as
    the `Food` class), the name of the method, and the value of the return type (as
    `String`). The name of the functional interface indicates that there are no input
    parameters, so the compiler and JVM can identify the method among the methods
    of the `Food` class.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，前面的格式定义了方法的位置（作为`Food`类），方法的名称和返回类型的值（作为`String`）。函数接口的名称表示没有输入参数，因此编译器和JVM可以在`Food`类的方法中识别该方法。
- en: A static method reference is unbound because there's no object being used to
    invoke the method. In the case of a static method, a class is the call receiver,
    not an object.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法引用是未绑定的，因为没有对象用于调用该方法。在静态方法的情况下，类是调用接收器，而不是对象。
- en: 'The second static method, `String getFavorite(int num)`, accepts one parameter
    and returns a value. It means we can use the `Function<T,R>` functional interface
    to implement the function that consists only of a call to this method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个静态方法`String getFavorite(int num)`接受一个参数并返回一个值。这意味着我们可以使用`Function<T,R>`函数接口来实现仅调用此方法的函数：
- en: '[PRE75]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'But when the method reference is used, it changes to exactly the same form
    as the previous example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当使用方法引用时，它会变成与前面示例完全相同的形式：
- en: '[PRE76]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The difference is in the specified functional interface. It allows the compiler
    and Java runtime to identify the method to be used: the method is named `getFavorite()`,
    accepts the `Integer` value, and returns `String` value. And there is only one
    such method in the `Food` class. Actually, there is no need to even look at which
    value the method returns, because it is not possible to overload a method by the
    return value only. The signature of the method—name, and list of parameter types—is
    enough for the method''s identification.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在于指定的函数接口。它允许编译器和Java运行时识别要使用的方法：方法名为`getFavorite()`，接受`Integer`值，并返回`String`值。`Food`类中只有一个这样的方法。实际上，甚至不需要查看方法返回的值，因为仅通过返回值无法重载方法。方法的签名——名称和参数类型列表——足以标识方法。
- en: 'We can use the implemented functions as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按以下方式使用实现的函数：
- en: '[PRE77]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we run the preceding code, the result is going to be as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行上述代码，结果将如下所示：
- en: '![](img/b59f41b3-3172-45ff-b858-7967323967de.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b59f41b3-3172-45ff-b858-7967323967de.png)'
- en: Non-static bound method reference
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非静态绑定方法引用
- en: 'To demonstrate a non-static bound method reference, let''s enhance the `Food` class by
    adding a `name` field, two constructors, and two `String sayFavorite()` methods:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示非静态绑定方法引用，让我们通过添加`name`字段、两个构造函数和两个`String sayFavorite()`方法来增强`Food`类：
- en: '[PRE78]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now, let''s create three instances of the `Food` class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建`Food`类的三个实例：
- en: '[PRE79]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The preceding is the context—the code that surrounds the lambda expression
    we are going to create now. We use the local variables of the preceding context
    to implement three different suppliers:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是上下文——我们将要创建的lambda表达式周围的代码。我们使用前面上下文的局部变量来实现三个不同的供应商：
- en: '[PRE80]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We used `Supplier<T>` because the `String`, `sayFavorite()` method does not
    require any parameter and just produces (supplies) the `String` value. Using the
    method reference, we can rewrite the preceding lambda expressions as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Supplier<T>`，因为`String sayFavorite()`方法不需要任何参数，只产生（提供）`String`值。使用方法引用，我们可以将前面的lambda表达式重写如下：
- en: '[PRE81]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The method `sayFavorite()` belongs to an object that was created in a certain
    context. In other words, this object (the call receiver) is bound to a certain
    context, which is why such method reference is called a *bound method reference*
    or *bound receiver method reference*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`sayFavorite()`属于在特定上下文中创建的对象。换句话说，这个对象（调用接收器）绑定到特定的上下文，这就是为什么这样的方法引用被称为*绑定方法引用*或*绑定接收器方法引用*。
- en: 'We can pass the newly created functions as any other object and use them anywhere
    we need, for example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将新创建的函数作为任何其他对象传递，并在需要的任何地方使用它们，例如：
- en: '[PRE82]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The result will be as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下所示：
- en: '![](img/8cf07e4c-f18c-4df7-8b95-20f98446228f.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf07e4c-f18c-4df7-8b95-20f98446228f.png)'
- en: Please note that the receiver remains bound to the context, so its state may
    change and affect the output. That is the significance of the distinction of being
    *bound*. Using such a reference, one has to be careful not to change the state
    of the receiver in the context of its origination. Otherwise, it may lead to unpredictable
    results. This consideration is especially pertinent for parallel processing when
    the same function can be used in different contexts.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，接收器仍然绑定到上下文，因此其状态可能会改变并影响输出。这就是*绑定*的区别的重要性。使用这样的引用时，必须小心不要在其原始上下文中更改接收器的状态。否则，可能会导致不可预测的结果。在并行处理时，同一函数可以在不同的上下文中使用，这一考虑尤为重要。
- en: 'Let''s look at another case of a bound method reference using the second non-static
    method, `String sayFavorite(String name)`. First, we create an implementation
    of a functional interface, `UnaryOperator<T>`, using the same objects of the `Food` class
    that we used in the previous example:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用第二个非静态方法`String sayFavorite(String name)`的绑定方法引用的另一个案例。首先，我们使用相同的`Food`类的对象创建了一个`UnaryOperator<T>`函数接口的实现，这与前面的示例中使用的相同：
- en: '[PRE83]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The reason we have used the `UnaryOperator<T>` functional interface is that
    the `String sayFavorite(String name)` method accepts a parameter and produces
    the value of the same type. And that is the purpose of functional interfaces with
    the name `Operator` in them—to support cases when the input value and the result
    have the same type.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`UnaryOperator<T>`函数接口的原因是，`String sayFavorite(String name)`方法接受一个参数并产生相同类型的值。这就是它们名称中带有`Operator`的函数接口的目的——支持输入值和结果类型相同的情况。
- en: 'The method reference allows us to change the lambda expression as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用允许我们将lambda表达式更改如下：
- en: '[PRE84]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now we can use the preceding functions (operators) anywhere in the code, for
    example:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在代码的任何地方使用前面的函数（操作符），例如：
- en: '[PRE85]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的结果如下：
- en: '![](img/f873fc74-fbd0-4b23-bde2-85d3643d2469.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f873fc74-fbd0-4b23-bde2-85d3643d2469.png)'
- en: Non-static unbound method reference
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非静态未绑定方法引用
- en: 'To demonstrate an unbound method reference to the `String sayFavorite()` method,
    we will use the `Function<T,R>` functional interface because we would like to
    use an object of the `Food` class (the call receiver) as a parameter and get back
    a `String` value:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示对`String sayFavorite()`方法的非绑定方法引用，我们将使用`Function<T,R>`函数接口，因为我们希望使用`Food`类的对象（调用接收器）作为参数，并返回一个`String`值：
- en: '[PRE86]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The method reference allows us to rewrite the preceding lambda expression as
    follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用允许我们将前面的lambda表达式重写为以下形式：
- en: '[PRE87]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Using the same objects of the `Food` class we created in the previous examples,
    we use the newly created function in the following code, for example:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用在前面的例子中创建的`Food`类的相同对象，我们在以下代码中使用新创建的函数，例如：
- en: '[PRE88]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: As you can see, the parameter (the call receiver object) comes from the current
    context only, as any parameter does. Wherever the function is passed, it does
    not carry the context with it. Its receiver is not bound to the context that was
    used for the function's creation. That is why this method reference is called
    *unbound*.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，参数（调用接收对象）仅来自当前上下文，就像任何参数一样。无论函数传递到哪里，它都不携带上下文。它的接收器不绑定到用于函数创建的上下文。这就是为什么这个方法引用被称为*未绑定*的原因。
- en: 'The output of the preceding code is as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '![](img/3dda0849-946f-42dd-a499-97cd5b6628aa.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3dda0849-946f-42dd-a499-97cd5b6628aa.png)'
- en: 'And, to demonstrate another case of the unbound method reference, we will use
    the second method, `String sayFavorite(String name)`, with the same `Food` objects
    we have used all along. The functional interface we are going to implement this
    time is called `BiFunction<T,U,R>`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示未绑定方法引用的另一个案例，我们将使用第二个方法`String sayFavorite(String name)`，并使用一直使用的`Food`对象。我们要实现的功能接口这次叫做`BiFunction<T,U,R>`：
- en: '[PRE89]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The reason we select this functional interface is that it accepts two parameters—exactly
    what we need in this case—to have the receiver object and `String` value as parameters.
    The method reference version of the preceding lambda expression looks as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这个功能接口的原因是它接受两个参数——这正是我们在这种情况下需要的——以便将接收对象和`String`值作为参数。前面lambda表达式的方法引用版本如下所示：
- en: '[PRE90]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can use the preceding function by writing the following code, for example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过编写以下代码来使用前面的函数，例如：
- en: '[PRE91]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The result is as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![](img/ce301b7b-80bd-49e0-afb6-7b4b0e72e77e.png)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce301b7b-80bd-49e0-afb6-7b4b0e72e77e.png)'
- en: Constructor method references
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数方法引用
- en: 'Using the method reference for a constructor is very similar to a static method
    reference because it uses a class as the call receiver, not an object (it has
    not been created yet). Here is the lambda expression that implements the `Supplier<T>`
    interface:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构造函数的方法引用与静态方法引用非常相似，因为它使用类作为调用接收器，而不是对象（它尚未被创建）。这是实现`Supplier<T>`接口的lambda表达式：
- en: '[PRE92]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'And here is its version with the method reference:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的方法引用版本：
- en: '[PRE93]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If we run the preceding code, we get the following output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，我们会得到以下输出：
- en: '![](img/34b6cfe4-9407-41fb-81a5-f23f2f307e52.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34b6cfe4-9407-41fb-81a5-f23f2f307e52.png)'
- en: 'Now, let''s add another constructor to the `Food` class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们向`Food`类添加另一个构造函数：
- en: '[PRE94]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Once we do this, we can express the preceding constructor using the method
    reference:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们可以通过方法引用来表示前面的构造函数：
- en: '[PRE95]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here is the output of the preceding code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/882157fe-d4e8-4439-ba19-cc505020fbf8.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/882157fe-d4e8-4439-ba19-cc505020fbf8.png)'
- en: 'In the same manner, we can add a constructor with two parameters:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，我们可以添加一个带有两个参数的构造函数：
- en: '[PRE96]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Once we do that, we can express it via `BiFunction<String, String>`:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们可以通过`BiFunction<String, String>`来表示它：
- en: '[PRE97]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The result of the preceding code is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码的结果如下：
- en: '![](img/981b14a2-265d-4fe6-a524-5785d675f49a.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/981b14a2-265d-4fe6-a524-5785d675f49a.png)'
- en: 'To express a constructor that accepts more than two parameters, we can create a
    custom functional interface with any number of parameters. For example, we can
    use the following custom functional interface, which we discussed in the previous
    recipe:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示接受多于两个参数的构造函数，我们可以创建一个自定义的功能接口，带有任意数量的参数。例如，我们可以使用前面一篇文章中讨论的以下自定义功能接口：
- en: '[PRE98]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Let''s assume that we need to use the `AClass` class:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要使用`AClass`类：
- en: '[PRE99]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can write the following code by using the method reference:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用方法引用来编写以下代码：
- en: '[PRE100]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: There's more...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There are several simple but very helpful method references because it gets
    its call receiver that is often used in practice:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个简单但非常有用的方法引用，因为它得到了通常在实践中使用的调用接收器：
- en: '[PRE101]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'There are also a few useful methods for working with arrays and lists:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些用于处理数组和列表的有用方法：
- en: '[PRE102]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Here are the results of the preceding code:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的结果：
- en: '![](img/dda4ac9d-511a-44dd-918d-7d48e26f2c87.png)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dda4ac9d-511a-44dd-918d-7d48e26f2c87.png)'
- en: We leave it up to you to analyze how the preceding lambda expressions were created
    and used.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们由你来分析前面的lambda表达式是如何创建和使用的。
- en: Leveraging lambda expressions in your programs
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用lambda表达式在您的程序中
- en: In this recipe, you will learn how to apply a lambda expression to your code.
    We will get back to the demo application and modify it by introducing a lambda
    expression where it makes sense.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何将lambda表达式应用到您的代码中。我们将回到演示应用程序，并通过引入lambda表达式来修改它。
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Equipped with functional interfaces, lambda expressions, and the best practices
    of a lambda-friendly API design, we can substantially improve our speed-calculating
    application by making its design more flexible and user-friendly. Let's set up
    some background as close to a real-life problem as possible without making it
    too complex.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 配备了功能接口、lambda表达式和友好的lambda API设计最佳实践，我们可以通过使其设计更加灵活和用户友好来大大改进我们的速度计算应用程序。让我们尽可能接近真实问题的背景，而不要使它过于复杂。
- en: 'Driverless cars are in the news these days, and there is good reason to believe
    it is going be this way for quite some time. One of the tasks in this domain is
    the analysis and modeling of the traffic flow in an urban area based on real data.
    A lot of such data already exists and will continue to be collected in future.
    Let''s assume that we have access to such a database by date, time, and geographical
    location. Let''s also assume that the traffic data from this database comes in
    units, each capturing details about one vehicle and the driving conditions:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 无人驾驶汽车如今成为新闻头条，有充分的理由相信它将在相当长的一段时间内保持这种状态。在这个领域的任务之一是基于真实数据对城市区域的交通流进行分析和建模。这样的数据已经存在很多，并且将继续在未来被收集。假设我们可以通过日期、时间和地理位置访问这样的数据库。还假设来自该数据库的交通数据以单位形式存在，每个单位捕捉有关一个车辆和驾驶条件的详细信息：
- en: '[PRE103]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The `enum` types—`VehicleType`, `RoadCondition`, and `TireCondition`—were already
    constructed in  [Chapter 2](db468cc9-60fa-4966-890a-872bef36ff01.xhtml), *Fast
    Track to OOP - Classes and Interfaces*:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum`类型——`VehicleType`、`RoadCondition`和`TireCondition`——已经在[第2章](db468cc9-60fa-4966-890a-872bef36ff01.xhtml)中构建，*OOP快速通道-类和接口*：'
- en: '[PRE104]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The interface of accessing traffic data may look like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 访问交通数据的接口可能如下所示：
- en: '[PRE105]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Here is an example of the access to the preceding methods:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是访问前述方法的示例：
- en: '[PRE106]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: The number `17` is an hour of a day (5 pm) and `Main1035` is a traffic light
    identification.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 数字`17`是一天中的小时（下午5点），`Main1035`是交通灯的标识。
- en: 'The call to the second method returns multiple results:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个方法的调用返回多个结果：
- en: '[PRE107]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The first parameter, `20`, is the number of the requested units of traffic.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`20`是请求的交通单位数。
- en: As you can see, such a traffic factory provides data about traffic in a particular
    location at a particular time (between 5 pm and 6 pm in our example). Each call
    to the factory yields a different result, while the list of traffic units describes statistically-correct
    data (including the most probable weather conditions) in the specified location.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这样的交通工厂提供了关于特定时间（在我们的示例中为下午5点至6点之间）特定地点的交通数据。每次调用工厂都会产生不同的结果，而交通单位列表描述了统计上正确的数据（包括指定位置的最可能天气条件）。
- en: 'We will also change the interfaces of `FactoryVehicle` and `FactorySpeedModel` so
    they could build `Vehicle` and `SpeedModel` based on the `TrafficUnit` interface.
    The resulting demo code is as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更改`FactoryVehicle`和`FactorySpeedModel`的接口，以便它们可以基于`TrafficUnit`接口构建`Vehicle`和`SpeedModel`。结果演示代码如下：
- en: '[PRE108]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The `printResult()` method has the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`printResult()`方法包含以下代码：'
- en: '[PRE109]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The output of this code may look like this:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出可能如下所示：
- en: '![](img/51e23141-3a9a-4765-9790-3e73337b7c89.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51e23141-3a9a-4765-9790-3e73337b7c89.png)'
- en: Since we use the "real" data now, every run of this program produces a different
    result, based on the statistical properties of the data. In a certain location,
    a car or dry weather would appear more often at that date and time, while in another
    location, a truck or snow would be more typical.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在使用“真实”数据，因此该程序的每次运行都会产生不同的结果，这取决于数据的统计特性。在某个地点，汽车或干燥天气可能更常出现在该日期和时间，而在另一个地点，卡车或雪更典型。
- en: 'In this run, the traffic unit brought a wet road, new tires, and `Truck` with
    such an engine power and load that in 10 seconds it was able to reach a speed
    of 22 mph. The formula we used to calculate the speed (inside an object of `SpeedModel`)
    is familiar to you:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次运行中，交通单位带来了湿地面、新轮胎和`Truck`，具有这样的发动机功率和负载，以至于在10秒内能够达到22英里/小时的速度。我们用来计算速度的公式（在`SpeedModel`对象内部）对您来说是熟悉的：
- en: '[PRE110]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Here, the `traction` value comes from `TrafficUnit`. In the class that implements
    the `TrafficUnit` interface, the `getTraction()` method looks like the following:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`traction`值来自`TrafficUnit`。在实现`TrafficUnit`接口的类中，`getTraction()`方法如下所示：
- en: '[PRE111]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `getRoadCondition()` and `getTireCondition()` methods return the elements
    of the corresponding `enum` types we just described.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`getRoadCondition()`和`getTireCondition()`方法返回我们刚刚描述的相应`enum`类型的元素。'
- en: Now we are ready to improve our speed-calculating application using the lambda
    expressions discussed in the previous recipes.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备使用前面讨论的lambda表达式来改进我们的速度计算应用程序。
- en: How to do it...
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Follow these steps to learn how to use lambda expressions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤学习如何使用lambda表达式：
- en: 'Let''s start building an API. We will call it `Traffic`. Without using functional
    interfaces, it might look like this:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始构建一个API。我们将其称为`Traffic`。如果不使用函数接口，它可能如下所示：
- en: '[PRE112]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Its implementation may be as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 其实现可能如下所示：
- en: '[PRE113]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Let''s write sample code that uses the `Traffic` interface:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写使用`Traffic`接口的示例代码：
- en: '[PRE114]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We get results similar to the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到类似以下的结果：
- en: '![](img/038d044d-970e-4fa4-bb1f-cea021a97788.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/038d044d-970e-4fa4-bb1f-cea021a97788.png)'
- en: As mentioned before, since we are using real data, the same code does not produce
    exactly the same result every time. One should not expect to see the speed values
    of the preceding screenshot, but instead something that looks very similar.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，由于我们使用真实数据，因此相同的代码不会每次产生完全相同的结果。不应该期望看到前面截图中的速度值，而是看到非常相似的结果。
- en: 'Let''s use a lambda expression. The preceding API is quite limited. For example,
    it does not allow you to test different speed-calculation formulas without changing
    `FactorySpeedModel`. Meanwhile, the `SpeedModel` interface has only one abstract
    method, called `getSpeedMph()` (which makes it a functional interface):'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用lambda表达式。前面的API相当有限。例如，它不允许您在不更改`FactorySpeedModel`的情况下测试不同的速度计算公式。同时，`SpeedModel`接口只有一个名为`getSpeedMph()`的抽象方法（这使它成为函数接口）：
- en: '[PRE115]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can take advantage of `SpeedModel` being a functional interface, and add
    another method to the `Traffic` interface that is able to accept the `SpeedModel`
    implementation as a lambda expression:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`SpeedModel`是函数接口的特性，并向`Traffic`接口添加另一个方法，该方法能够接受`SpeedModel`实现作为lambda表达式：
- en: '[PRE116]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The problem though is the `traction` value does not come as a parameter to
    the `getSpeedMph()` method, so we cannot implement it as a function passed as
    a parameter into the `speedAfterStart()` method. Look closer at the speed calculation
    by `FactorySpeedModel.generateSpeedModel(TrafficUnit trafficUnit)`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 不过问题在于`traction`值不作为`getSpeedMph()`方法的参数传递，因此我们无法将其作为一个函数传递到`speedAfterStart()`方法中。仔细查看`FactorySpeedModel.generateSpeedModel(TrafficUnit
    trafficUnit)`的速度计算：
- en: '[PRE117]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'As you can see, the `traction` value is a multiplier to the calculated value
    of `speed` and that is the only dependency on traffic unit. We can remove traction
    from the speed model and apply traction after the speed is calculated using the
    speed model. It means we can change the implementation of `speedAfterStart()`
    of the `TrafficImpl` class, as follows:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`traction`值是计算出的`speed`值的乘数，这是对交通单位的唯一依赖。我们可以从速度模型中移除`traction`，并在使用速度模型计算速度后应用`traction`。这意味着我们可以改变`TrafficImpl`类的`speedAfterStart()`的实现，如下所示：
- en: '[PRE118]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This change allows the users of the `Traffic` API pass `SpeedModel` as a function:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变允许`Traffic` API的用户将`SpeedModel`作为一个函数传递：
- en: '[PRE119]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The result of the preceding code is the same as when `SpeedModel` was generated
    by `FactorySpeedModel`. But now the API users can come up with their own speed-calculating
    function.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述代码的结果与通过`FactorySpeedModel`生成`SpeedModel`时相同。但现在API用户可以自己想出自己的速度计算函数。
- en: We can Annotate the `SpeedModel` interface as `@FunctionalInterface`, so everybody
    who tries to add another method to it would be dutifully warned and would not
    be able to add another abstract method without removing this annotation and being
    aware of the risk of breaking the code of the existing clients that have implemented
    this functional interface already.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以将`SpeedModel`接口注释为`@FunctionalInterface`，这样所有试图向其添加另一个方法的人都会得到警告，并且不能在删除此注释并意识到破坏已经实现此功能接口的现有客户端代码的风险的情况下添加另一个抽象方法。
- en: We can enrich the API by adding various criteria that slice all of the possible
    traffic into segments.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过添加各种标准来丰富API，将所有可能的交通划分为不同的片段。
- en: 'For example, API users might want to analyze only cars, trucks, cars with an engine
    bigger than 300 horsepower, or trucks with an engine bigger than 400 horsepower.
    The traditional way to accomplish this would be by creating methods such as these:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，API用户可能只想分析汽车、卡车、引擎大于300马力的汽车，或引擎大于400马力的卡车。传统的方法是创建这样的方法：
- en: '[PRE120]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Instead, we can just add standard functional interfaces to the existing `speedAfterStart()` method
    of the `Traffic` interface and let the API user decide which slice of traffic
    to extract:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以将标准的函数接口添加到`Traffic`接口的现有`speedAfterStart()`方法中，并让API用户决定要提取哪一部分交通：
- en: '[PRE121]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `speedAfterStart()` method implementation in the `TrafficImpl` class would
    change as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`TrafficImpl`类中`speedAfterStart()`方法的实现将如下更改：'
- en: '[PRE122]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The `Traffic` API users can then define the traffic they need as follows:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Traffic` API用户可以按以下方式定义他们需要的交通情况：
- en: '[PRE123]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The results are now limited to cars with an engine smaller than 250 `hp` and
    trucks with an engine smaller than 400 `hp`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 结果现在被限制为引擎小于250 `hp`的汽车和引擎小于400 `hp`的卡车：
- en: '![](img/d601ea9c-2be1-4f90-971f-e6ecb0259f05.png)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d601ea9c-2be1-4f90-971f-e6ecb0259f05.png)'
- en: 'In fact, a `Traffic` API user can now apply any criteria for limiting the traffic
    as long as they are applicable to the values in the `TrafficUnit` object. A user
    can write, for example, the following:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，`Traffic` API用户现在可以应用任何限制交通的标准，只要它们适用于`TrafficUnit`对象中的值。例如，用户可以写以下内容：
- en: '[PRE124]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Alternatively, they can write any other combination of limits on the values
    that come from `TrafficUnit`. If a user decides to remove the limit and analyze
    all of the traffic, this code will do it too:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，他们可以写任何其他限制`TrafficUnit`值的组合。如果用户决定移除限制并分析所有交通情况，这段代码也可以做到：
- en: '[PRE125]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If there is a need to select traffic units by speed, we can apply the predicate
    criteria after the speed calculations (notice how we replaced `Predicate` with
    `BiPredicate` since we need to use two parameters now):'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要通过速度选择交通单位，我们可以在速度计算后应用谓词标准（请注意，我们用`BiPredicate`替换了`Predicate`，因为我们现在需要使用两个参数）：
- en: '[PRE126]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The `Traffic` API users can now write the following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`Traffic` API用户现在可以编写以下代码：'
- en: '[PRE127]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The predicate above selects traffic units that exceed the speed limit by more
    than a certain amount (which is different for different driving conditions). If
    needed, it can disregard the speed completely and limit traffic exactly the same
    way the previous predicate did. The only drawback of this implementation is that
    it is slightly less efficient because the predicate is applied after the speed
    calculations. This means that the speed calculation will be done for each generated
    traffic unit, not to a limited number, as in the previous implementation. If this
    is a concern, you might leave all the different signatures we have discussed in
    this recipe:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的谓词选择超过一定数量的速度限制的交通单位（对于不同的驾驶条件是不同的）。如果需要，它可以完全忽略速度，并且以与之前的谓词完全相同的方式限制交通。这种实现的唯一缺点是它略微不那么高效，因为谓词是在速度计算之后应用的。这意味着速度计算将针对每个生成的交通单位进行，而不是像之前的实现中那样限制数量。如果这是一个问题，你可以留下我们在本文中讨论过的所有不同签名：
- en: '[PRE128]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This way, the API user decides which of the methods to use, more flexible or
    more efficient, and decide whether the default speed-calculation implementation
    is acceptable.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，API用户可以决定使用哪种方法，更灵活或更高效，并决定默认的速度计算实现是否可接受。
- en: There's more...
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'So far, we have not given the API user a choice of the output format. Currently,
    it is implemented as the `printResult()` method:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有给API用户选择输出格式的选择。目前，它是作为`printResult()`方法实现的：
- en: '[PRE129]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'To make it more flexible, we can add another parameter to our API:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其更加灵活，我们可以向我们的API添加另一个参数：
- en: '[PRE130]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Notice that we take the `timeSec` value-not as one of the function parameters,
    but from the enclosed scope of the function. We can do this because it remains
    constant (and can be effectively final) throughout the calculations. In the same
    manner, we can add any other object to the `output` function—a filename or another
    output device, for example—thus leaving all the output-related decisions to the
    API user. To accommodate this new function, the API implementation changes to
    the following:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们取`timeSec`值不是作为函数参数之一，而是从函数的封闭范围中取得。我们之所以能够这样做，是因为它在整个计算过程中保持不变（并且可以被视为最终值）。同样地，我们可以向`output`函数添加任何其他对象，比如文件名或另一个输出设备，从而将所有与输出相关的决策留给API用户。为了适应这个新函数，API的实现发生了变化，如下所示：
- en: '[PRE131]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: It took us a while to come to this point—where the power of functional programming
    starts to shine and justify the effort of learning it. Yet, when used to process
    streams, as described in the next chapter, lambda expressions yield even more
    power.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间才达到这一点——函数式编程的威力开始显现并证明了学习它的努力是值得的。然而，当用于处理流时，如下一章所述，lambda表达式会产生更大的威力。
