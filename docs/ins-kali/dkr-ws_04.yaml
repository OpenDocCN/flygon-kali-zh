- en: 4\. Multi-Stage Dockerfiles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 多阶段Dockerfiles
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we will discuss a normal Docker build. You will review and
    practice `Dockerfile` best practices and learn to create and optimize the size
    of the Docker images using a builder pattern and multi-stage `Dockerfile`.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论普通的Docker构建。您将审查和实践`Dockerfile`的最佳实践，并学习使用构建模式和多阶段`Dockerfile`来创建和优化Docker镜像的大小。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In the previous chapter, we learned about Docker registries, including private
    and public registries. We created our own private Docker registry to store the
    Docker images. We also learned how to set up access and store our Docker images
    in the Docker Hub. In this chapter, we will be discussing the concept of multi-stage
    `Dockerfiles`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了Docker注册表，包括私有和公共注册表。我们创建了自己的私有Docker注册表来存储Docker镜像。我们还学习了如何设置访问权限并将我们的Docker镜像存储在Docker
    Hub中。在本章中，我们将讨论多阶段`Dockerfiles`的概念。
- en: Multi-stage `Dockerfiles` are a feature introduced in Docker version 17.05\.
    This feature is preferable when we want to optimize Docker image size while running
    Docker images in production environments. To achieve this, a multi-stage `Dockerfile`
    will create multiple intermediate Docker images during the build process and selectively
    copy only essential artifacts from one stage to the other.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段`Dockerfiles`是在Docker版本17.05中引入的一个功能。当我们想要在生产环境中运行Docker镜像时，这个功能是可取的。为了实现这一点，多阶段`Dockerfile`将在构建过程中创建多个中间Docker镜像，并有选择地从一个阶段复制只有必要的构件到另一个阶段。
- en: Before multi-stage Docker builds were introduced, the builder pattern was used
    to optimize the Docker image size. Unlike multi-stage builds, the builder pattern
    needs two `Dockerfiles` and a shell script to create efficient Docker images.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入多阶段Docker构建之前，构建模式被用来优化Docker镜像的大小。与多阶段构建不同，构建模式需要两个`Dockerfiles`和一个shell脚本来创建高效的Docker镜像。
- en: In this chapter, we will first examine normal Docker builds and the problems
    associated with them. Next, we will learn how to use the builder pattern to optimize
    the Docker image size and discuss the problems associated with the builder pattern.
    Finally, we will learn to use multi-stage `Dockerfiles` to overcome the problems
    of the builder pattern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先检查普通的Docker构建以及与之相关的问题。接下来，我们将学习如何使用构建模式来优化Docker镜像的大小，并讨论与构建模式相关的问题。最后，我们将学习如何使用多阶段`Dockerfiles`来克服构建模式的问题。
- en: Normal Docker Builds
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 普通的Docker构建
- en: With Docker, we can use `Dockerfiles` to create custom Docker images. As we
    discussed in *Chapter 2, Getting Started with Dockerfiles*, a `Dockerfile` is
    a text file that contains instructions on how to create a Docker image. However,
    it is critical to have minimal-sized Docker images when running them in production
    environments. This allows developers to speed up their Docker containers' build
    and deployment times. In this section, we will build a custom Docker image to
    observe the problems associated with the normal Docker build process.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker，我们可以使用`Dockerfiles`来创建自定义的Docker镜像。正如我们在*第2章，使用Dockerfiles入门*中讨论的那样，`Dockerfile`是一个包含如何创建Docker镜像的指令的文本文件。然而，在生产环境中运行它们时，拥有最小尺寸的Docker镜像是至关重要的。这使开发人员能够加快他们的Docker容器的构建和部署时间。在本节中，我们将构建一个自定义的Docker镜像，以观察与普通的Docker构建过程相关的问题。
- en: 'Consider an example where we build a simple Golang application. We are going
    to deploy a `hello world` application written in Golang using the following `Dockerfile`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们构建一个简单的Golang应用程序。我们将使用以下`Dockerfile`部署一个用Golang编写的`hello world`应用程序：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This `Dockerfile` starts with the latest Golang image as the parent image. This
    parent image contains all the build tools required to build our Golang application.
    Next, we will set the `/myapp` directory as the current working directory and
    copy the `helloworld.go` source file from the host filesystem to the container
    filesystem. Then, we will use the `RUN` directive to execute the `go build` command
    to build the application. Finally, the `ENTRYPOINT` directive is used to run the
    `helloworld` executable created in the previous step.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`以最新的Golang镜像作为父镜像开始。这个父镜像包含构建Golang应用程序所需的所有构建工具。接下来，我们将把`/myapp`目录设置为当前工作目录，并将`helloworld.go`源文件从主机文件系统复制到容器文件系统。然后，我们将使用`RUN`指令执行`go
    build`命令来构建应用程序。最后，使用`ENTRYPOINT`指令来运行在上一步中创建的`helloworld`可执行文件。
- en: 'The following is the content of the `helloworld.go` file. This is a simple
    file that will print the text `"Hello World"` when executed:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`helloworld.go`文件的内容。这是一个简单的文件，当执行时将打印文本`"Hello World"`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once the `Dockerfile` is ready, we can build the Docker image using the `docker
    image build` command. This image will be tagged as `helloworld:v1`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Dockerfile`准备好，我们可以使用`docker image build`命令构建Docker镜像。这个镜像将被标记为`helloworld:v1`：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, observe the built image with the `docker image ls` command. You will get
    an output similar to the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`docker image ls`命令观察构建的镜像。您将获得类似以下的输出：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice the image size. This build has resulted in a huge Docker image of 805
    MB in size. It is not efficient to have these large Docker images in production
    environments as they will take a lot of time and bandwidth to be pushed and pulled
    over networks. Small Docker images are much more efficient and can be pushed and
    pulled quickly and deployed faster.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意镜像大小。这个构建导致了一个大小为805 MB的巨大Docker镜像。在生产环境中拥有这些大型Docker镜像是低效的，因为它们将花费大量时间和带宽在网络上传输。小型Docker镜像更加高效，可以快速推送、拉取和部署。
- en: In addition to the size of the image, these Docker images can be vulnerable
    to attacks since they contain build tools that can have potential security vulnerabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了镜像的大小，这些Docker镜像可能容易受到攻击，因为它们包含可能存在潜在安全漏洞的构建工具。
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Potential security vulnerabilities may vary depending on what packages are
    in the given Docker image. As an example, Java JDK has a number of vulnerabilities.
    You can have a detailed look at the vulnerabilities related to Java JDK at the
    following link:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在的安全漏洞可能会因给定的Docker镜像中包含哪些软件包而有所不同。例如，Java JDK有许多漏洞。您可以在以下链接中详细了解与Java JDK相关的漏洞：
- en: '[https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19116/Oracle-JDK.html](https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19116/Oracle-JDK.html).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19116/Oracle-JDK.html](https://www.cvedetails.com/vulnerability-list/vendor_id-93/product_id-19116/Oracle-JDK.html)。'
- en: To reduce the attack surface, it is recommended to have only the essential artifacts
    (for example, compiled code) and runtimes when running Docker images in production
    environments. As an example, with Golang, the Go compiler is required to build
    the application, but not to run the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少攻击面，建议在生产环境中运行Docker镜像时只包含必要的构件（例如编译代码）和运行时。例如，使用Golang时，需要Go编译器来构建应用程序，但不需要运行应用程序。
- en: Ideally, you want a minimal-sized Docker image that only contains the runtime
    tools and excludes all the build tools that we used to build the application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您希望有一个最小尺寸的Docker镜像，其中只包含运行时工具，而排除了用于构建应用程序的所有构建工具。
- en: We will now build such a Docker image using the normal build process in the
    following exercise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用以下练习中的常规构建过程构建这样一个Docker镜像。
- en: 'Exercise 4.01: Building a Docker Image with the Normal Build Process'
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.01：使用正常构建过程构建Docker镜像
- en: 'Your manager has asked you to dockerize a simple Golang application. You are
    provided with the Golang source code file, and your task is to compile and run
    this file. In this exercise, you will build a Docker image using the normal build
    process. You will then observe the image size of the final Docker image:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您的经理要求您将一个简单的Golang应用程序docker化。您已经提供了Golang源代码文件，您的任务是编译和运行此文件。在这个练习中，您将使用正常的构建过程构建一个Docker镜像。然后，您将观察最终Docker镜像的大小：
- en: 'Create a new directory named `normal-build` for this exercise:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此练习创建一个名为`normal-build`的新目录：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Navigate to the newly created `normal-build` directory:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到新创建的`normal-build`目录：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Within the `normal-build` directory, create a file named `welcome.go`. This
    file will be copied to the Docker image during the build time:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`normal-build`目录中，创建一个名为`welcome.go`的文件。此文件将在构建时复制到Docker镜像中：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, open the `welcome.go` file using your favorite text editor:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`welcome.go`文件：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following content to the `welcome.go` file, save it, and exit from
    the `welcome.go` file:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`welcome.go`文件中，保存并退出`welcome.go`文件：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a simple `hello world` application written in Golang. This will output
    `"Welcome to multi-stage Docker builds"` on execution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用Golang编写的简单的`hello world`应用程序。这将在执行时输出`"Welcome to multi-stage Docker builds"`。
- en: 'Within the `normal-build` directory, create a file named `Dockerfile`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`normal-build`目录中，创建一个名为`Dockerfile`的文件：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following content to the `Dockerfile` and save the file:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中并保存文件：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `Dockerfile` starts with the `FROM` directive that specifies the latest
    Golang image as the parent image. This will set the `/myapp` directory as the
    current working directory of the Docker image. Then, the `COPY` directive will
    copy the `welcome.go` source file that you created in *step 3* to the Docker filesystem.
    Next is the `go build` command, which will build the Golang code that you created.
    Finally, the welcome code will be executed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`以`FROM`指令开头，指定最新的Golang镜像作为父镜像。这将把`/myapp`目录设置为Docker镜像的当前工作目录。然后，`COPY`指令将`welcome.go`源文件复制到Docker文件系统中。接下来是`go
    build`命令，用于构建您创建的Golang代码。最后，将执行welcome代码。'
- en: 'Now, build the Docker image:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，构建Docker镜像：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You will see that the image is successfully built with the image ID as `b938bc11abf1`
    and tagged as `welcome:v1`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到该镜像成功构建，镜像ID为`b938bc11abf1`，标记为`welcome:v1`：
- en: '![Figure 4.1: Building the Docker image'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：构建Docker镜像'
- en: '](image/B15021_04_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_01.jpg)'
- en: 'Figure 4.1: Building the Docker image'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：构建Docker镜像
- en: 'Use the `docker image ls` command to list all the Docker images available on
    your computer:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image ls`命令列出计算机上所有可用的Docker镜像：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The command should return the following output:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应返回以下输出：
- en: '![Figure 4.2: Listing all Docker images'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：列出所有Docker镜像'
- en: '](image/B15021_04_02.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_02.jpg)'
- en: 'Figure 4.2: Listing all Docker images'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：列出所有Docker镜像
- en: It can be observed in the preceding output that the image size of the `welcome:v1`
    image is `805MB`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以观察到`welcome:v1`镜像的镜像大小为`805MB`。
- en: In this section, we discussed how to use the normal Docker build process to
    build a Docker image and observed its size. The result was a huge Docker image,
    over 800 MB in size. The main disadvantage of these large Docker images is that
    they will take significant time to build, deploy, push, and pull over the networks.
    So, it is recommended to create minimal-sized Docker images whenever possible.
    In the next section, we will discuss how we can use the builder pattern to optimize
    the image size.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何使用普通的Docker构建过程来构建Docker镜像，并观察了其大小。结果是一个巨大的Docker镜像，大小超过800 MB。这些大型Docker镜像的主要缺点是它们将花费大量时间来构建、部署、推送和拉取网络。因此，建议尽可能创建最小尺寸的Docker镜像。在下一节中，我们将讨论如何使用构建模式来优化镜像大小。
- en: What Is the Builder Pattern?
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是构建模式？
- en: The **builder pattern** is a method used to create optimally sized Docker images.
    It uses two Docker images and selectively copies essential artifacts from one
    to the other. The first Docker image is known as the `build image` and is used
    as the build environment to build the executables from the source code. This Docker
    image contains compilers, build tools, and development dependencies required during
    the build process.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建模式**是一种用于创建最优尺寸的Docker镜像的方法。它使用两个Docker镜像，并从一个镜像选择性地复制必要的构件到另一个镜像。第一个Docker镜像称为`构建镜像`，用作构建环境，用于从源代码构建可执行文件。这个Docker镜像包含在构建过程中所需的编译器、构建工具和开发依赖项。'
- en: The second Docker image is known as the `runtime image` and is used as the runtime
    environment to run the executables created by the first Docker container. This
    Docker image contains only the executables, the dependencies, and the runtime
    tools. A shell script is used to copy the artifacts using the `docker container
    cp` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个Docker镜像称为`运行时镜像`，用作运行由第一个Docker容器创建的可执行文件的运行时环境。这个Docker镜像只包含可执行文件、依赖项和运行时工具。使用一个shell脚本来使用`docker
    container cp`命令复制构件。
- en: 'The entire process of building the image using the builder pattern consists
    of the following steps:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建模式构建镜像的整个过程包括以下步骤：
- en: Create the `Build` Docker image.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Build` Docker镜像。
- en: Create a container from the `Build` Docker image.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Build` Docker镜像创建一个容器。
- en: Copy the artifacts from the `Build` Docker image to the local filesystem.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构件从`Build` Docker镜像复制到本地文件系统。
- en: 'Build the `Runtime` Docker image using copied artifacts:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用复制的构件构建`Runtime` Docker镜像：
- en: '![Figure 4.3: Building images using the builder pattern'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：使用构建模式构建镜像'
- en: '](image/B15021_04_03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_03.jpg)'
- en: 'Figure 4.3: Building images using the builder pattern'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：使用构建模式构建镜像
- en: As illustrated in the preceding image, the `Build` `Dockerfile` is used to create
    the build container that will contain all the tools required to build the source
    code, including compilers and build tools such as Maven, Gradle, and development
    dependencies. Once the build container is created, the shell script will copy
    the executables from the build container to the Docker host. Finally, the `Runtime`
    container will be created with the executables copied from the `Build` container.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的图所示，`Build` `Dockerfile`用于创建构建容器，其中包含构建源代码所需的所有工具，包括编译器和构建工具，如Maven、Gradle和开发依赖项。创建构建容器后，shell脚本将从构建容器复制可执行文件到Docker主机。最后，将使用从`Build`容器复制的可执行文件创建`Runtime`容器。
- en: 'Now, observe how the builder pattern can be used to create minimal Docker images.
    The following is the first `Dockerfile` used to create the `Build` Docker container.
    This `Dockerfile` is named Dockerfile.build to distinguish it from the `Runtime` `Dockerfile`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察如何使用构建模式来创建最小的Docker镜像。以下是用于创建`Build` Docker容器的第一个`Dockerfile`。这个`Dockerfile`被命名为Dockerfile.build，以区别于`Runtime`
    `Dockerfile`：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is the same `Dockerfile` that we observed with the normal Docker builds.
    This was used to create the `helloworld` executable from the `helloworld.go` source
    file.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们观察到的与普通Docker构建相同的`Dockerfile`。这是用来从`helloworld.go`源文件创建`helloworld`可执行文件的。
- en: 'The following is the second `Dockerfile` used to build the `Runtime` Docker container:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于构建`Runtime` Docker容器的第二个`Dockerfile`：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As opposed to the first `Dockerfile`, created from the `golang` parent image,
    this second `Dockerfile` uses the `alpine` image as its parent image because it
    is a minimal-sized Docker image, at only 5 MB. This image uses Alpine Linux, a
    lightweight Linux distribution. Next, the `/myapp` directory is configured as
    the working directory. Finally, the `helloworld` artifact is copied to the Docker
    image, and the `ENTRYPOINT` directive is used to run the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个`Dockerfile`相反，它是从`golang`父镜像创建的，这个第二个`Dockerfile`使用`alpine`镜像作为其父镜像，因为它是一个仅有5MB的最小尺寸的Docker镜像。这个镜像使用Alpine
    Linux，一个轻量级的Linux发行版。接下来，`/myapp`目录被配置为工作目录。最后，`helloworld`构件被复制到Docker镜像中，并且使用`ENTRYPOINT`指令来运行应用程序。
- en: This `helloworld` artifact is the result of the `go build -o helloworld .` command
    executed in the first `Dockerfile`. We will be using a shell script to copy this
    artifact from the `build` Docker container to the local filesystem, from where
    this artifact will be copied to the runtime Docker image.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`helloworld`构件是在第一个`Dockerfile`中执行的`go build -o helloworld .`命令的结果。我们将使用一个shell脚本将这个构件从`build`
    Docker容器复制到本地文件系统，然后从那里将这个构件复制到运行时Docker镜像。
- en: 'Consider the following shell script used to copy the build artifacts between
    Docker containers:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于在Docker容器之间复制构建构件的shell脚本：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This shell script will first build the `helloworld-build` Docker image using
    the `Dockerfile.build` file. The next step is to create a Docker container from
    the `helloworld-build` image so that we can copy the `helloworld` artifact to
    the Docker host. Once the container is created, we need to execute the command
    to copy the `helloworld` artifact from the `helloworld-build-container` to the
    current directory of the Docker host. Now, we can build the runtime container
    with the `docker image build` command. Finally, we will execute the necessary
    cleanup tasks by removing the intermediate artifacts, such as the `helloworld-build-container`
    container and the `helloworld` executable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shell脚本将首先使用`Dockerfile.build`文件构建`helloworld-build` Docker镜像。下一步是从`helloworld-build`镜像创建一个Docker容器，以便我们可以将`helloworld`构件复制到Docker主机。容器创建后，我们需要执行命令将`helloworld`构件从`helloworld-build-container`复制到Docker主机的当前目录。现在，我们可以使用`docker
    image build`命令构建运行时容器。最后，我们将执行必要的清理任务，如删除中间构件，比如`helloworld-build-container`容器和`helloworld`可执行文件。
- en: 'Once we execute the shell script, we should be able to see two Docker images:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们执行了shell脚本，我们应该能够看到两个Docker镜像：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the size difference between the two Docker images. The `helloworld` Docker
    image is only 7.6 MB in size, which is a huge reduction from the `helloworld-build`
    image at 805 MB.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意两个Docker镜像之间的大小差异。`helloworld` Docker镜像的大小仅为7.6MB，这是从805MB的`helloworld-build`镜像中大幅减少的。
- en: As we can see, the builder pattern can drastically reduce the size of the Docker
    images by copying only the essential artifacts to the final image. However, the
    disadvantage with the builder pattern is that we need to maintain two `Dockerfiles`
    and a shell script.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，构建模式可以通过仅复制必要的构件到最终镜像来大大减小Docker镜像的大小。然而，构建模式的缺点是我们需要维护两个`Dockerfiles`和一个shell脚本。
- en: In the next exercise, we will gain hands-on experience in creating an optimized
    Docker image using the builder pattern.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将亲自体验使用构建模式创建优化的Docker镜像。
- en: 'Exercise 4.02: Building a Docker Image with the Builder Pattern'
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.02：使用构建模式构建Docker镜像
- en: 'In *Exercise 4.01*, *Building a Docker Image with the Normal Build Process*,
    you created a Docker image to compile and run the Golang application. Now the
    application is ready to go live, but the manager is not happy with the size of
    the Docker image. You have been asked to create a minimal-sized Docker image to
    run the application. In this exercise, you will optimize the Docker image using
    the builder pattern:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习4.01*中，*使用常规构建过程构建Docker镜像*，您创建了一个Docker镜像来编译和运行Golang应用程序。现在应用程序已经准备就绪，但经理对Docker镜像的大小不满意。您被要求创建一个最小尺寸的Docker镜像来运行应用程序。在这个练习中，您将使用构建模式优化Docker镜像：
- en: 'Create a new directory named `builder-pattern` for this exercise:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个练习创建一个名为`builder-pattern`的新目录：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Navigate to the newly created `builder-pattern` directory:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`builder-pattern`目录：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Within the `builder-pattern` directory, create a file named `welcome.go`. This
    file will be copied to the Docker image at build time:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`builder-pattern`目录中，创建一个名为`welcome.go`的文件。这个文件将在构建时复制到Docker镜像中：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, open the `welcome.go` file using your favorite text editor:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`welcome.go`文件：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following content to the `welcome.go` file, and then save and exit
    this file:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`welcome.go`文件中，然后保存并退出该文件：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is a simple `hello world` application written in Golang. This will output
    `"Welcome to multi-stage Docker builds"` once executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用Golang编写的简单的“hello world”应用程序。一旦执行，它将输出“欢迎来到多阶段Docker构建”。
- en: 'Within the `builder-pattern` directory, create a file named `Dockerfile.build`.
    This file will contain all the instructions that you are going to use to create
    the `build` Docker image:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`builder-pattern`目录中，创建一个名为`Dockerfile.build`的文件。这个文件将包含您将用来创建`build` Docker镜像的所有指令：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, open the `Dockerfile.build` using your favorite text editor:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile.build`：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following content to the `Dockerfile.build` file and save the file:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile.build`文件中并保存该文件：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This has the same content that you created for the `Dockerfile` in *Exercise
    4.01*, *Building a Docker Image with the Normal Build Process*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您在*练习4.01*中为`Dockerfile`创建的内容相同，*使用常规构建过程构建Docker镜像*。
- en: 'Next, create the `Dockerfile` for the runtime container. Within the `builder-pattern`
    directory, create a file named `Dockerfile`. This file will contain all the instructions
    that you are going to use to create the runtime Docker image:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为运行时容器创建`Dockerfile`。在`builder-pattern`目录中，创建一个名为`Dockerfile`的文件。这个文件将包含您将用来创建运行时Docker镜像的所有指令：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following content to the `Dockerfile` and save the file:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`并保存该文件：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This `Dockerfile` uses the scratch image, which is the most minimal image in
    Docker, as the parent. Then, it will configure the `/myapp` directory as the working
    directory. Next, the welcome executable is copied from the Docker host to the
    runtime Docker image. Finally, the `ENTRYPOINT` directive is used to execute the
    welcome executable.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`使用了scratch镜像，这是Docker中最小的镜像，作为父镜像。然后，它将`/myapp`目录配置为工作目录。接下来，欢迎可执行文件从Docker主机复制到运行时Docker镜像。最后，使用`ENTRYPOINT`指令来执行欢迎可执行文件。
- en: 'Create the shell script to copy the executables between Docker containers.
    Within the `builder-pattern` directory, create a file named `build.sh`. This file
    will contain the steps to coordinate the build process between the two Docker containers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个shell脚本，在两个Docker容器之间复制可执行文件。在`builder-pattern`目录中，创建一个名为`build.sh`的文件。这个文件将包含协调两个Docker容器之间构建过程的步骤：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, open the `build.sh` file using your favorite text editor:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`build.sh`文件：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following content to the shell script and save the file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到shell脚本中并保存文件：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This shell script will first build the `welcome-builder` Docker image and create
    a container from it. Then it will copy the compiled Golang executable from the
    container to the local filesystem. Next, the `welcome-builder-container` container
    is removed as it is an intermediate container. Finally, the `welcome-runtime`
    image is built.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个shell脚本将首先构建`welcome-builder` Docker镜像并从中创建一个容器。然后它将从容器中将编译的Golang可执行文件复制到本地文件系统。接下来，`welcome-builder-container`容器将被删除，因为它是一个中间容器。最后，将构建`welcome-runtime`镜像。
- en: 'Add execution permissions to the `build.sh` shell script:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`build.sh` shell脚本添加执行权限：
- en: '[PRE32]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that you have the two `Dockerfiles` and the shell script, build the Docker
    image by executing the `build.sh` shell script:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您已经有了两个`Dockerfiles`和shell脚本，通过执行`build.sh` shell脚本构建Docker镜像：
- en: '[PRE33]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The image will be successfully built and tagged as `welcome-runtime:v1`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像将成功构建并标记为`welcome-runtime:v1`：
- en: '![Figure 4.4: Building the Docker image'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：构建Docker镜像'
- en: '](image/B15021_04_04.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_04.jpg)'
- en: 'Figure 4.4: Building the Docker image'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：构建Docker镜像
- en: 'Use the `docker image` ls command to list all the Docker images available on
    your computer:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image` ls命令列出计算机上所有可用的Docker镜像：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should get the list of all the available Docker images as shown in the
    following figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到所有可用Docker镜像的列表，如下图所示：
- en: '![Figure 4.5: Listing all Docker images'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：列出所有Docker镜像'
- en: '](image/B15021_04_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_05.jpg)'
- en: 'Figure 4.5: Listing all Docker images'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：列出所有Docker镜像
- en: As you can see from the preceding output, there are two Docker images available.
    welcome-builder has all the builds tools and is 805 MB, while welcome-runtime
    has a significantly lower image size of 2.01 MB. `golang:latest` is the Docker
    image we used as the parent image of `welcome-builder`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看到，有两个Docker镜像可用。welcome-builder具有所有构建工具，大小为805 MB，而welcome-runtime的镜像大小显著较小，为2.01
    MB。`golang:latest`是我们用作`welcome-builder`父镜像的Docker镜像。
- en: In this exercise, you learned how to use the builder pattern to reduce the size
    of the Docker image. However, using the builder pattern to optimize the size of
    the Docker image means that we have to maintain two `Dockerfiles` and one shell
    script. In the next section, let's observe how we can eliminate them by using
    a multi-stage `Dockerfile`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学会了如何使用构建模式来减小Docker镜像的大小。然而，使用构建模式来优化Docker镜像的大小意味着我们必须维护两个`Dockerfiles`和一个shell脚本。在下一节中，让我们观察如何通过使用多阶段`Dockerfile`来消除它们。
- en: Introduction to Multi-Stage Dockerfiles
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段Dockerfile简介
- en: '**Multi-stage Dockerfiles** are a feature that allows for a single `Dockerfile`
    to contain multiple stages that can produce optimized Docker images. As we observed
    with the builder pattern in the previous section, the stages will usually include
    a builder state to build the executables from source code, and a runtime stage
    to run the executables. Multi-stage `Dockerfiles` will use multiple `FROM` directives
    within the `Dockerfile` for each stage, and each stage will start with a different
    base image. Only the essential files will be copied selectively from one stage
    to the other. Before multi-stage `Dockerfiles`, this was achieved with the builder
    pattern, as we discussed in the previous section.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**多阶段Dockerfile**是一个功能，允许单个`Dockerfile`包含多个阶段，可以生成优化的Docker镜像。正如我们在上一节中观察到的构建模式一样，这些阶段通常包括一个构建状态，用于从源代码构建可执行文件，以及一个运行时阶段，用于运行可执行文件。多阶段`Dockerfiles`将在`Dockerfile`中为每个阶段使用多个`FROM`指令，并且每个阶段将以不同的基础镜像开始。只有必要的文件将从一个阶段有选择地复制到另一个阶段。在多阶段`Dockerfiles`之前，这是通过构建模式实现的，正如我们在上一节中讨论的那样。'
- en: Multi-stage Docker builds allow us to create minimal-sized Docker images that
    are similar to the builder pattern but eliminate the problems associated with
    it. As we have seen in the previous example, the builder pattern needs to maintain
    two `Dockerfiles` and a shell script. In contrast, multi-stage Docker builds will
    need only one `Dockerfile` and do not require any shell script to copy the executables
    between Docker containers. Also, the builder pattern requires that you copy the
    executables to the Docker host before copying them to the final Docker image.
    This is not required with the multi-stage Docker builds as we can use the `--from`
    flag to copy the executables between Docker images without copying them to the
    Docker host.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段Docker构建允许我们创建与构建模式类似但消除了与之相关的问题的最小尺寸Docker镜像。正如我们在前面的示例中看到的，构建模式需要维护两个`Dockerfile`和一个shell脚本。相比之下，多阶段Docker构建只需要一个`Dockerfile`，并且不需要任何shell脚本来在Docker容器之间复制可执行文件。此外，构建模式要求您在将可执行文件复制到最终Docker镜像之前将其复制到Docker主机。而多阶段Docker构建不需要这样做，因为我们可以使用`--from`标志在Docker镜像之间复制可执行文件，而无需将其复制到Docker主机。
- en: 'Now, let''s observe the structure of a multi-stage `Dockerfile`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们观察一下多阶段`Dockerfile`的结构：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The main difference between a normal `Dockerfile` and a multi-stage `Dockerfile`
    is that a multi-stage `Dockerfile` will use multiple `FROM` directives to build
    each phase. Each new phase will start with a new parent image and does not contain
    anything from the previous image other than the selectively copied executables.
    `COPY --from=0` is used to copy the executable from the first stage to the second
    stage.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的`Dockerfile`和多阶段`Dockerfile`之间的主要区别在于，多阶段`Dockerfile`将使用多个`FROM`指令来构建每个阶段。每个新阶段将从一个新的父镜像开始，并且不包含来自先前镜像的任何内容，除了有选择地复制的可执行文件。使用`COPY
    --from=0`将可执行文件从第一阶段复制到第二阶段。
- en: 'Build the Docker image and tag the image as `multi-stage:v1`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 构建Docker镜像并将镜像标记为`multi-stage:v1`：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, you can list the available Docker images:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以列出可用的Docker镜像：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can see that this has resulted in a Docker image of the same size that we
    observed with the builder pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，这导致了与构建模式中观察到的相同大小的Docker镜像。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Multi-stage `Dockerfiles` reduce the number of `Dockerfiles` required and eliminate
    the shell script without making any difference to the size of the image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段`Dockerfile`减少了所需的`Dockerfile`数量，并消除了shell脚本，而不会对镜像的大小产生任何影响。
- en: 'By default, the stages in the multi-stage `Dockerfile` are referred to by an
    integer number, starting with `0` from the first stage. These stages can be named
    to increase readability and maintainability by adding `AS <NAME>` to the `FROM`
    directive. The following is the improved version of the multi-stage `Dockerfile`
    that you observed in the preceding code block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，多阶段`Dockerfile`中的阶段由整数编号引用，从第一阶段开始为`0`。可以通过在`FROM`指令中添加`AS <NAME>`来为这些阶段命名，以增加可读性和可维护性。以下是您在前面的代码块中观察到的多阶段`Dockerfile`的改进版本：
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the preceding example, we named the first stage `builder` and second stage
    `runtime`, as shown here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将第一阶段命名为`builder`，第二阶段命名为`runtime`，如下所示：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, while copying the artifacts in the second stage, you used the name `builder`
    for the `--from` flag:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在第二阶段复制工件时，您使用了`--from`标志的名称`builder`：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'While building a multi-stage `Dockerfile`, there might be instances where you
    want to build only up to a specific build stage. Consider that your `Dockerfile`
    has two stages. The first one is to build the development stage and contains all
    the build and debug tools, and the second is to build the production image that
    will contain only the runtime tools. During the code development phase of the
    project, you might only need to build up to the development stage to test and
    debug your code whenever necessary. In this scenario, you can use the `--target`
    flag with the `docker build` command to specify an intermediate stage as the final
    stage for the resulting image:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建多阶段`Dockerfile`时，可能会有一些情况，您只想构建到特定的构建阶段。考虑到您的`Dockerfile`有两个阶段。第一个是构建开发阶段，包含所有构建和调试工具，第二个是构建仅包含运行时工具的生产镜像。在项目的代码开发阶段，您可能只需要构建到开发阶段，以便在必要时测试和调试代码。在这种情况下，您可以使用`docker
    build`命令的`--target`标志来指定一个中间阶段作为最终镜像的阶段：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding example, you used `--target builder` to stop the build at the
    builder stage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，您使用了`--target builder`来停止在构建阶段停止构建。
- en: In the next exercise, you will learn to use a multi-stage `Dockerfile` to create
    a size-optimized Docker image.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将学习如何使用多阶段`Dockerfile`来创建一个大小优化的Docker镜像。
- en: 'Exercise 4.03: Building a Docker Image with a Multi-Stage Docker Build'
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4.03：使用多阶段Docker构建构建Docker镜像
- en: In *Exercise 4.02*, *Building a Docker Image with the Builder Pattern*, you
    used the builder pattern to optimize the size of the Docker image. However, there
    is an operational burden, as you need to manage two `Dockerfiles` and a shell
    script during the Docker image build process. In this exercise, you are going
    to use a multi-stage `Dockerfile` to eliminate this operational burden.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Exercise 4.02*，*使用构建模式构建Docker镜像*中，您使用了构建模式来优化Docker镜像的大小。然而，这会带来操作负担，因为您需要在Docker镜像构建过程中管理两个`Dockerfiles`和一个shell脚本。在这个练习中，您将使用多阶段`Dockerfile`来消除这种操作负担。
- en: 'Create a new directory named `multi-stage` for this exercise:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为这个练习创建一个名为`multi-stage`的新目录：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Navigate to the newly created `multi-stage` directory:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到新创建的`multi-stage`目录：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Within the `multi-stage` directory, create a file named `welcome.go`. This
    file will be copied to the Docker image during the build time:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`multi-stage`目录中，创建一个名为`welcome.go`的文件。这个文件将在构建时复制到Docker镜像中：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, open the `welcome.go` file using your favorite text editor:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`welcome.go`文件：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following content to the `welcome.go` file, and then save and exit
    this file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`welcome.go`文件中，然后保存并退出此文件：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is a simple `hello world` application written in Golang. This will output
    `"Welcome to multi-stage Docker builds"` once executed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用Golang编写的简单的`hello world`应用程序。一旦执行，它将输出`"Welcome to multi-stage Docker
    builds"`。
- en: 'Within the multi-stage directory, create a file named `Dockerfile`. This file
    will be the multi-stage `Dockerfile`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在multi-stage目录中，创建一个名为`Dockerfile`的文件。这个文件将是多阶段`Dockerfile`：
- en: '[PRE47]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, open the `Dockerfile` using your favorite text editor:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用您喜欢的文本编辑器打开`Dockerfile`：
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following content to the `Dockerfile` and save the file:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到`Dockerfile`中并保存文件：
- en: '[PRE49]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This multi-stage `Dockerfile` uses the latest `golang` image as the parent image
    and this stage is named `builder`. Next, the `/myapp` directory is specified as
    the current working directory. Then, the `COPY` directive is used to copy the
    `welcome.go` source file and the `RUN` directive is used to build the Golang file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个多阶段`Dockerfile`使用最新的`golang`镜像作为父镜像，这个阶段被命名为`builder`。接下来，指定`/myapp`目录作为当前工作目录。然后，使用`COPY`指令复制`welcome.go`源文件，并使用`RUN`指令构建Golang文件。
- en: The next stage of the `Dockerfile` uses the `scratch` image as the parent image.
    This will set the `/myapp` directory as the current working directory of the Docker
    image. Then, the `COPY` directive is used to copy the `welcome` executable from
    the builder stage to this stage. Finally, `ENTRYPOINT` is used to run the `welcome`
    executable.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的下一阶段使用`scratch`镜像作为父镜像。这将把`/myapp`目录设置为Docker镜像的当前工作目录。然后，使用`COPY`指令将`welcome`可执行文件从构建阶段复制到此阶段。最后，使用`ENTRYPOINT`运行`welcome`可执行文件。'
- en: 'Build the Docker image using the following command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令构建Docker镜像：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The image will be successfully built and tagged as `welcome-optimized:v1`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像将成功构建并标记为`welcome-optimized:v1`：
- en: '![Figure 4.6: Building the Docker image'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：构建Docker镜像'
- en: '](image/B15021_04_06.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_06.jpg)'
- en: 'Figure 4.6: Building the Docker image'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：构建Docker镜像
- en: 'Use the `docker image ls` command to list all the Docker images available on
    your computer. These images are available on your computer, either when you pull
    them from Docker Registry or when you build them on your computer:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker image ls`命令列出计算机上所有可用的Docker镜像。这些镜像可以在您的计算机上使用，无论是从Docker Registry拉取还是在您的计算机上构建：
- en: '[PRE51]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see from the following output, the `welcome-optimized` image has
    the same size as the `welcome-runtime` image that you built in *Exercise 4.02,
    Building a Docker Image with the Builder Pattern*:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下输出中可以看出，“welcome-optimized”镜像与您在*练习4.02中构建的“welcome-runtime”镜像大小相同，构建Docker镜像使用以下命令：
- en: '![Figure 4.7: Listing all Docker images'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：列出所有Docker镜像'
- en: '](image/B15021_04_07.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_07.jpg)'
- en: 'Figure 4.7: Listing all Docker images'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：列出所有Docker镜像
- en: 'In this exercise, you learned how to use multi-stage `Dockerfiles` to build
    optimized Docker images. The following table presents a summary of the key differences
    between the builder pattern and multi-stage `Docker Builds`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您学习了如何使用多阶段`Dockerfiles`构建优化的Docker镜像。以下表格总结了构建器模式和多阶段`Docker Builds`之间的关键差异：
- en: '![Figure 4.8: Differences between the builder pattern and multi-stage Docker
    Builds'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：构建器模式和多阶段Docker构建之间的差异'
- en: '](image/B15021_04_08.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_08.jpg)'
- en: 'Figure 4.8: Differences between the builder pattern and multi-stage Docker
    Builds'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：构建器模式和多阶段Docker构建之间的差异
- en: In the next section, we will review the best practices to follow when writing
    a `Dockerfile`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾编写`Dockerfile`时应遵循的最佳实践。
- en: Dockerfile Best Practices
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile最佳实践
- en: In the previous section, we discussed how we can build an efficient Docker image
    with multi-stage `Dockerfiles`. In this section, we will cover other recommended
    best practices for writing `Dockerfiles`. These best practices will ensure reduced
    build time, reduced image size, increased security, and increased maintainability
    of the Docker images produced.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们讨论了如何使用多阶段`Dockerfiles`构建高效的Docker镜像。在本节中，我们将介绍编写`Dockerfiles`的其他推荐最佳实践。这些最佳实践将确保减少构建时间、减少镜像大小、增加安全性和增加Docker镜像的可维护性。
- en: Using an Appropriate Parent Image
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用适当的父镜像
- en: Using the appropriate base image is one of the key recommendations when building
    efficient Docker images.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建高效的Docker镜像时，使用适当的基础镜像是其中的关键建议之一。
- en: 'It is always encouraged to use official images from the **Docker Hub** as the
    parent image when you are building custom Docker images. These official images
    will ensure that all best practices are followed, documentation is available,
    and security patches are applied. For example, if you need the **JDK** (**Java
    Development Kit**) for your application, you can use the `openjdk` official Docker
    image instead of using the generic `ubuntu` image and installing the JDK on top
    of the `ubuntu` image:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自定义Docker镜像时，建议始终使用**Docker Hub**的官方镜像作为父镜像。这些官方镜像将确保遵循所有最佳实践，提供文档，并应用安全补丁。例如，如果您的应用程序需要**JDK**（Java开发工具包），您可以使用`openjdk`官方Docker镜像，而不是使用通用的`ubuntu`镜像并在`ubuntu`镜像上安装JDK：
- en: '![Figure 4.9: Using appropriate parent images'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：使用适当的父镜像'
- en: '](image/B15021_04_09.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_09.jpg)'
- en: 'Figure 4.9: Using appropriate parent images'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：使用适当的父镜像
- en: 'Secondly, avoid using the `latest` tag for the parent image when building Docker
    images for production environments. The `latest` tag might get pointed to a newer
    version of the image as the new versions are released to the Docker Hub, and the
    newer version might not be backward compatible with your applications, leading
    to failures in your production environments. Instead, the best practice is to
    always use a specific versioned tag as the parent image:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在为生产环境构建Docker镜像时，避免使用父镜像的`latest`标签。`latest`标签可能会指向Docker Hub发布新版本时的新版本镜像，而新版本可能与您的应用程序不兼容，导致生产环境中的故障。相反，最佳实践是始终使用特定版本的标签作为父镜像：
- en: '![Figure 4.10: Avoiding the use of the latest tag of the parent image'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：避免使用父镜像的最新标签'
- en: '](image/B15021_04_10.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_10.jpg)'
- en: 'Figure 4.10: Avoiding the use of the latest tag of the parent image'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10：避免使用父镜像的最新标签
- en: 'Finally, using the minimal version of the parent image is critical to getting
    a minimal-sized Docker image. Most of the official Docker images in Docker Hub
    have a minimal-sized image built around the Alpine Linux image. Also, in our example,
    we can use the **JRE** (**Java Runtime Environment**) to run the application instead
    of the JDK, which contains the build tools:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用父镜像的最小版本对于获得最小尺寸的Docker镜像至关重要。Docker Hub中的大多数官方Docker镜像都是围绕Alpine Linux镜像构建的最小尺寸镜像。此外，在我们的示例中，我们可以使用**JRE**（Java运行环境）来运行应用程序，而不是JDK，后者包含构建工具：
- en: '![Figure 4.11: Using minimal-sized images'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：使用最小尺寸的镜像'
- en: '](image/B15021_04_11.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_11.jpg)'
- en: 'Figure 4.11: Using minimal-sized images'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11：使用最小尺寸的镜像
- en: The `openjdk:8-jre-alpine` image will be only 84.9 MB in size, whereas `openjdk:8`
    will be 488 MB in size.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`openjdk:8-jre-alpine`镜像的大小仅为84.9 MB，而`openjdk:8`的大小为488 MB。'
- en: Using a Non-Root User for Better Security
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了更好的安全性，使用非根用户
- en: By default, Docker containers run with the root (`id = 0`) user. This allows
    the user to perform all the necessary administrative activities, such as changing
    system configurations, installing packages, and binding to privileged ports. However,
    this is high risk and is considered a bad security practice when running Docker
    containers in production environments since hackers can gain root access to the
    Docker host by hacking the applications running inside the Docker container.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker容器以root（`id = 0`）用户运行。这允许用户执行所有必要的管理活动，如更改系统配置、安装软件包和绑定特权端口。然而，在生产环境中运行Docker容器时，这是高风险的，被认为是一种不良的安全实践，因为黑客可以通过攻击Docker容器内运行的应用程序来获得对Docker主机的root访问权限。
- en: 'Running containers as a non-root user is a recommended best practice to improve
    the security of the Docker container. This will adhere to the principle of least
    privilege, which ensures that the application has only the bare minimum privileges
    to perform its tasks. There are two methods that we can use to run a container
    as a non-root user: with the `--user` (or `-u`) flag, and with the `USER` directive.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以非root用户身份运行容器是改善Docker容器安全性的推荐最佳实践。这将遵循最小特权原则，确保应用程序只具有执行其任务所需的最低权限。我们可以使用两种方法来以非root用户身份运行容器：使用`--user`（或`-u`）标志，以及使用`USER`指令。
- en: 'Using the `--user` (or `-u`) flag with the `docker run` command is one method
    for changing the default user while running a Docker container. Either the username
    or the user ID can be specified with the `--user` (or `-u`) flag:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--user`（或`-u`）标志与`docker run`命令是在运行Docker容器时更改默认用户的一种方法。`--user`（或`-u`）标志可以指定用户名或用户ID：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In the preceding command, we have specified the user ID as `9999`. If we are
    specifying the user as an ID, the corresponding user does not have to be available
    in the Docker container.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们指定了用户ID为`9999`。如果我们将用户指定为ID，则相应的用户不必在Docker容器中可用。
- en: 'Additionally, we can use the `USER` directive within the `Dockerfile` to define
    the default user. However, this value can be overridden with the `--user` flag
    while starting the Docker container:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以在`Dockerfile`中使用`USER`指令来定义默认用户。但是，可以在启动Docker容器时使用`--user`标志覆盖此值：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the preceding example, we have used the `USER` directive to set the default
    user to `demo-user`. This means that any command after the `USER` directive will
    be executed as a `demo-user`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`USER`指令将默认用户设置为`demo-user`。这意味着在`USER`指令之后的任何命令都将以`demo-user`身份执行。
- en: Using dockerignore
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用dockerignore
- en: 'The `.dockerignore` file is a special text file within the Docker context that
    is used to specify a list of files to be excluded from the Docker context while
    building the Docker image. Once we execute the `docker build` command, the Docker
    client will package the entire build context as a TAR archive and upload it to
    the Docker daemon. When we execute the `docker build` command, the first line
    of the output is `Sending build context to Docker daemon`, which indicates that
    the Docker client is uploading the build context to the Docker daemon:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件是Docker上下文中的一个特殊文本文件，用于指定在构建Docker镜像时要排除的文件列表。一旦执行`docker
    build`命令，Docker客户端将整个构建上下文打包为一个TAR归档文件，并将其上传到Docker守护程序。当我们执行`docker build`命令时，输出的第一行是`Sending
    build context to Docker daemon`，这表示Docker客户端正在将构建上下文上传到Docker守护程序。'
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Each time we build the Docker image, the build context will be sent to the Docker
    daemon. As this will take time and bandwidth during the Docker image build process,
    it is recommended to exclude all the files that are not needed in the final Docker
    image. The `.dockerignore` file can be used to achieve this purpose. In addition
    to saving time and bandwidth, the `.dockerignore` file is used to exclude the
    confidential files, such as password files and key files from the build context.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次构建Docker镜像时，构建上下文都将被发送到Docker守护程序。由于这将在Docker镜像构建过程中占用时间和带宽，建议排除所有在最终Docker镜像中不需要的文件。`.dockerignore`文件可用于实现此目的。除了节省时间和带宽外，`.dockerignore`文件还用于排除机密文件，例如密码文件和密钥文件，以防止其出现在构建上下文中。
- en: The `.dockerignore` file should be created in the root directory of the build
    context. Before sending the build context to the Docker daemon, the Docker client
    will look for the `.dockerignore` file in the root of the build context. If the
    `.dockerignore` file exists, the Docker client will exclude all the files mentioned
    in the `.dockerignore` file from the build context.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore`文件应该创建在构建上下文的根目录中。在将构建上下文发送到Docker守护程序之前，Docker客户端将在构建上下文的根目录中查找`.dockerignore`文件。如果`.dockerignore`文件存在，Docker客户端将从构建上下文中排除`.dockerignore`文件中提到的所有文件。'
- en: 'The following is the content of a sample `.dockerignore` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例`.dockerignore`文件的内容：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, we have specifically excluded the `PASSWORDS.txt`
    file and `tmp` directory from the build context, as well as all files with the
    `.md` extension except for the `README.md` file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们特别排除了`PASSWORDS.txt`文件和`tmp`目录，以及除`README.md`文件之外的所有扩展名为`.md`的文件。
- en: Minimizing Layers
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化层
- en: Each line in the `Dockerfile` will create a new layer that will take up space
    in the Docker image. So, it is recommended to create as few layers as possible
    when building the Docker image. To achieve this, combine the `RUN` directives
    whenever possible.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`中的每一行都将创建一个新的层，这将占用Docker镜像中的空间。因此，在构建Docker镜像时，建议尽可能少地创建层。为了实现这一点，尽可能合并`RUN`指令。'
- en: 'As an example, consider the following `Dockerfile`, which will update the package
    repository first and then install the `redis-server` and `nginx` packages:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下`Dockerfile`，它将首先更新软件包存储库，然后安装`redis-server`和`nginx`软件包：
- en: '[PRE56]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This `Dockerfile` can be optimized by combining the three `RUN` directives:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`可以通过合并三个`RUN`指令来优化：
- en: '[PRE57]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Don't Install Unnecessary Tools
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不安装不必要的工具
- en: 'Not installing unnecessary debugging tools (such as `vim`, `curl`, and `telnet`)
    and removing unnecessary dependencies can help to create efficient Docker images
    that are small in size. Some package managers such as `apt` will install recommended
    and suggested packages automatically alongside required packages. We can avoid
    this by specifying the `no-install-recommends` flag with the `apt-get install` command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不安装不必要的调试工具（如`vim`，`curl`和`telnet`）并删除不必要的依赖项可以帮助创建尺寸小的高效Docker镜像。一些软件包管理器（如`apt`）将自动安装推荐和建议的软件包，以及所需的软件包。我们可以通过在`apt-get
    install`命令中指定`no-install-recommends`标志来避免这种情况：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding example, we are installing the `nginx` package with the `no-install-recommends`
    flag, which will help to reduce the final image size by around 10 MB.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们正在使用`no-install-recommends`标志安装`nginx`软件包，这将帮助将最终镜像大小减少约10MB。
- en: 'In addition to using the `no-install-recommends` flag, we can also remove the
    cache of the `apt` package manager to further reduce the final Docker image size.
    This can be achieved by running `rm -rf /var/lib/apt/lists/*` at the end of the
    `apt-get install` command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`no-install-recommends`标志之外，我们还可以删除`apt`软件包管理器的缓存，以进一步减少最终的Docker镜像大小。这可以通过在`apt-get
    install`命令的末尾运行`rm -rf /var/lib/apt/lists/*`来实现：
- en: '[PRE59]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In this section, we discussed the best practices when writing a `Dockerfile`.
    Following these best practices will help to reduce build time, reduce the image
    size, increase security, and increase the maintainability of the Docker image.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了编写`Dockerfile`时的最佳实践。遵循这些最佳实践将有助于减少构建时间，减小镜像大小，增加安全性，并增加Docker镜像的可维护性。
- en: Now, let's test our knowledge by deploying a Golang HTTP server with a multi-stage
    Docker build in the next activity.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过在下一个活动中使用多阶段Docker构建部署一个Golang HTTP服务器来测试我们的知识。
- en: 'Activity 4.01: Deploying a Golang HTTP Server with a Multi-Stage Docker Build'
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动4.01：使用多阶段Docker构建部署Golang HTTP服务器
- en: Imagine that you have been tasked with deploying a Golang HTTP server to a Docker
    container. Your manager has asked you to build a minimal-sized Docker image and
    observe best practices while building the `Dockerfile`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被要求将一个Golang HTTP服务器部署到一个Docker容器中。你的经理要求你构建一个最小尺寸的Docker镜像，并在构建`Dockerfile`时遵循最佳实践。
- en: 'This Golang HTTP server will return different responses based on the invoke
    URL:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Golang HTTP服务器将根据调用URL返回不同的响应：
- en: '![Figure 4.12: Responses based on the invoke URL'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：基于调用URL的响应'
- en: '](image/B15021_04_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_12.jpg)'
- en: 'Figure 4.12: Responses based on the invoke URL'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.12：基于调用URL的响应
- en: 'Your task is to dockerize the Golang application given in the following code
    block using a multi-stage `Dockerfile`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是使用多阶段`Dockerfile`来将下面代码块中给出的Golang应用程序docker化：
- en: '[PRE60]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Execute the following steps to complete this activity:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成这个活动：
- en: Create a folder to store the activity files.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹来存储活动文件。
- en: Create a `main.go` file with the code provided in the preceding code block.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`main.go`文件，其中包含前面代码块中提供的代码。
- en: Create a multi-stage `Dockerfile` with two stages. The first stage will use
    the `golang` image. This stage will build the Golang application using the `go
    build` command. The second stage will use an `alpine` image. This stage will copy
    the executable from the first stage and execute it.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个阶段创建一个多阶段`Dockerfile`。第一阶段将使用`golang`镜像。这个阶段将使用`go build`命令构建Golang应用程序。第二阶段将使用`alpine`镜像。这个阶段将从第一阶段复制可执行文件并执行它。
- en: Build and run the Docker image.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行Docker镜像。
- en: Once completed, stop and remove the Docker container.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，停止并移除Docker容器。
- en: 'You should get the following output when you navigate to the URL `http://127.0.0.1:8080/`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当你访问URL `http://127.0.0.1:8080/`时，你应该得到以下输出：
- en: '![Figure 4.13: Expected output of Activity 4.01'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.13：活动4.01的预期输出'
- en: '](image/B15021_04_13.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_04_13.jpg)'
- en: 'Figure 4.13: Expected output of Activity 4.01'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：活动4.01的预期输出
- en: Note
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor326).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor326)找到。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We started this chapter by defining a normal Docker build and creating a simple
    Golang Docker image using the normal Docker build process. Then we observed the
    size of the resulting Docker image and discussed how a minimal-sized Docker image
    can speed up the build and deployment times for Docker containers and enhance
    security by reducing the attack surface.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从定义普通的Docker构建开始，使用普通的Docker构建过程创建了一个简单的Golang Docker镜像。然后我们观察了生成的Docker镜像的大小，并讨论了最小尺寸的Docker镜像如何加快Docker容器的构建和部署时间，并通过减少攻击面来增强安全性。
- en: We then used the builder pattern to create minimal-sized Docker images, utilizing
    two `Dockerfiles` and a shell script in this process to create the image. We explored
    multi-stage Docker builds—a new feature introduced to Docker in version 17.05
    that can help to eliminate the operational burden of having to maintain two `Dockerfiles`
    and a shell script. Finally, we discussed the best practices for writing `Dockerfiles`
    and how these best practices can ensure reduced build time, reduced image size,
    and increased security, while increasing the maintainability of the Docker image.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用构建器模式创建了最小尺寸的Docker镜像，在这个过程中利用了两个`Dockerfiles`和一个shell脚本来创建镜像。我们探讨了多阶段Docker构建——这是Docker
    17.05版本引入的新功能，可以帮助消除维护两个`Dockerfiles`和一个shell脚本的操作负担。最后，我们讨论了编写`Dockerfiles`的最佳实践以及这些最佳实践如何确保减少构建时间、减小镜像大小、增强安全性，同时提高Docker镜像的可维护性。
- en: In the next chapter, we will cover `docker-compose` and how it can be used to
    define and run multi-container Docker applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍`docker-compose`以及如何使用它来定义和运行多容器Docker应用程序。
