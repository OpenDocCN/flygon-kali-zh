- en: Administering and Monitoring Dockerized Solutions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理和监控Docker化解决方案
- en: Applications built on Docker are inherently portable, and the process of deployment
    is the same for every environment. As you promote your application through system
    tests and user tests to production, you'll use the same artifacts every time.
    The Docker images you use in production are the exact same versioned images that
    were signed off in the test environments, and any environmental differences can
    be captured in compose-file overrides, Docker configuration objects, and secrets.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基于Docker构建的应用程序本质上是可移植的，部署过程对于每个环境都是相同的。当您将应用程序从系统测试和用户测试推广到生产环境时，您每次都会使用相同的构件。您在生产环境中使用的Docker镜像与在测试环境中签署的完全相同版本的镜像，任何环境差异都可以在compose-file覆盖、Docker配置对象和secrets中捕获。
- en: In a later chapter, I'll cover how continuous deployment works with Docker,
    so your whole deployment process can be automated. But when you adopt Docker,
    you'll be moving to a new application platform, and the path to production is
    about more than just the deployment process. Containerized applications run in
    fundamentally different ways to apps deployed on VMs or bare-metal servers. In
    this chapter, I'll look at administering and monitoring applications running in
    Docker.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我将介绍Docker的持续部署工作原理，因此您的整个部署过程可以自动化。但是当您采用Docker时，您将会转移到一个新的应用平台，而通往生产环境的道路不仅仅是部署过程。容器化应用程序的运行方式与部署在虚拟机或裸机服务器上的应用程序有根本的不同。在本章中，我将讨论管理和监控在Docker中运行的应用程序。
- en: Some of the tools you use to manage Windows applications today can still be
    used when the apps are moved to Docker, and I'll start by looking at some examples.
    But there are different management needs and opportunities for apps running in
    containers, and the main focus of this chapter will be management products specific
    to Docker.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天您用来管理Windows应用程序的一些工具在应用程序迁移到Docker后仍然可以使用，我将从一些示例开始。但是在容器中运行的应用程序有不同的管理需求和机会，本章的主要重点将是特定于Docker的管理产品。
- en: 'In this chapter I''ll be using simple Dockerized applications to show you how
    to manage containers, including:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将使用简单的Docker化应用程序来向您展示如何管理容器，包括：
- en: Connecting  **Internet Information Services** (**IIS**) manager to IIS services
    running in containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**Internet Information Services** (**IIS**)管理器连接到运行在容器中的IIS服务
- en: Connecting Windows Server Manager to containers, to see event logs and features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接Windows Server Manager到容器，查看事件日志和功能
- en: Using open source projects to view and administer Docker swarms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开源项目查看和管理Docker集群
- en: Using **Universal Control Plane** (**UCP**) with **Docker Enterprise**
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Universal Control Plane** (**UCP**)与**Docker Enterprise**
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need Docker running on Windows 10 update 18.09, or Windows Server 2019
    to follow along with the examples. The code for this chapter is available at [https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch08](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch08)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在Windows 10更新18.09或Windows Server 2019上运行Docker，以便跟随示例。本章的代码可在[https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch08](https://github.com/sixeyed/docker-on-windows/tree/second-edition/ch08)找到。
- en: Managing containers with Windows tools
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Windows工具管理容器
- en: Many of the administration tools in Windows are able to manage services running
    on remote machines. IIS Manager, server manager, and **SQL Server Management Studio**
    (**SSMS**) can all be connected to a remote server on the network for inspection
    and administration.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Windows中的管理工具都能够管理远程机器上运行的服务。IIS管理器、服务器管理器和**SQL Server Management Studio**
    (**SSMS**)都可以连接到网络上的远程服务器进行检查和管理。
- en: Docker containers are different than remote machines, but they can be set up
    to allow remote access from these tools. Typically, you need to set up access
    for the tool explicitly by exposing management ports, enabling Windows features,
    and running PowerShell cmdlets. This can all be done in the Dockerfile for your
    application, and I'll cover the setup steps for each of these tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器不同于远程机器，但它们可以被设置为允许从这些工具进行远程访问。通常情况下，您需要显式地为工具设置访问权限，通过公开管理端口、启用Windows功能和运行PowerShell
    cmdlets。这些都可以在您的应用程序的Dockerfile中完成，我将为每个工具的设置步骤进行介绍。
- en: Being able to use familiar tools can be helpful, but there are limits to what
    you should do with them; remember, containers are meant to be disposable. If you
    connect to a web application container with IIS Manager and tweak the app pool
    settings, that tweak will be lost when you update the app with a new container
    image. You can use the graphical tools to inspect a running container and diagnose
    problems, but you should make changes in the Dockerfile and redeploy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 能够使用熟悉的工具可能是有帮助的，但你应该对它们的使用有所限制；记住，容器是可以被丢弃的。如果您使用IIS Manager连接到Web应用程序容器并调整应用程序池设置，当您使用新的容器映像更新应用程序时，这些调整将会丢失。您可以使用图形工具检查运行中的容器并诊断问题，但您应该在Dockerfile中进行更改并重新部署。
- en: IIS Manager
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IIS Manager
- en: 'The IIS web management console is a perfect example. Remote access is not enabled
    by default in the Windows base images, but you can configure it with a simple
    PowerShell script. Firstly, the web management feature needs to be installed:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: IIS Web管理控制台是一个完美的例子。在Windows基础映像中，默认情况下不允许远程访问，但您可以使用一个简单的PowerShell脚本进行配置。首先，需要安装Web管理功能：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, you need to enable remote access with a registry setting and start the
    web management Windows service:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要使用注册表设置启用远程访问，并启动Web管理Windows服务：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You also need an `EXPOSE` instruction in the Dockerfile to allow traffic into
    the management service on the expected port `8172`. This will allow you to connect,
    but IIS management console requires user credentials for the remote machine. To
    support this without having to connect the container to **Active Directory** (**AD**),
    you can create a user and password in the setup script:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要在Dockerfile中添加一个`EXPOSE`指令，以允许流量进入预期端口`8172`的管理服务。这将允许您连接，但IIS管理控制台需要远程机器的用户凭据。为了支持这一点，而不必将容器连接到**Active
    Directory**（**AD**），您可以在设置脚本中创建用户和密码：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There are security issues here. You need to create an administrative account
    in the image, expose a port, and run an additional service—all increasing the
    attack surface of your application. Instead of running the setup script in the
    Dockerfile, it would be better to attach to a container and run the script interactively
    if you need remote access.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里存在安全问题。您需要在镜像中创建一个管理帐户，公开一个端口，并运行一个额外的服务，所有这些都会增加应用程序的攻击面。与其在Dockerfile中运行设置脚本，不如附加到一个容器并交互式地运行脚本，如果您需要远程访问。
- en: 'I''ve set up a simple web server in an image, packaged with a script to enable
    remote management in the Dockerfile for `dockeronwindows/ch08-iis-with-management:2e`.
    I''ll run a container from this image, publishing the HTTP- and IIS-management
    ports:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在一个镜像中设置了一个简单的Web服务器，并在`dockeronwindows/ch08-iis-with-management:2e`的Dockerfile中打包了一个脚本以启用远程管理。我将从这个镜像中运行一个容器，发布HTTP和IIS管理端口：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the container is running, I''ll execute the `EnableIisRemoteManagement.ps1`
    script inside the container, which sets up remote access with the IIS management
    service:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器运行时，我将在容器内执行`EnableIisRemoteManagement.ps1`脚本，该脚本设置了IIS管理服务的远程访问：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The setup script ends by running `ipconfig`, so I can see the internal IP address
    of the container (I can also see this from `docker container inspect`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安装脚本最后运行`ipconfig`，所以我可以看到容器的内部IP地址（我也可以从`docker container inspect`中看到这一点）。
- en: 'Now I can run IIS Manager on my Windows host, choose Start Page | Connect to
    a Server, and enter the IP address of the container. When IIS challenges me to
    authenticate, I use the credentials for the `iisadmin` user I created in the setup
    script:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我可以在Windows主机上运行IIS管理器，选择“开始页面|连接到服务器”，并输入容器的IP地址。当IIS要求我进行身份验证时，我使用了在安装脚本中创建的`iisadmin`用户的凭据：
- en: '![](Images/789fefbf-e5c3-4b47-8fd9-1504fc86ae7e.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/789fefbf-e5c3-4b47-8fd9-1504fc86ae7e.png)'
- en: 'Here, I can navigate around the application pools and the website hierarchy
    as if I were connected to a remote server:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我可以像连接到远程服务器一样浏览应用程序池和网站层次结构：
- en: '![](Images/e325acd8-cdab-4b78-8936-40753d777478.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e325acd8-cdab-4b78-8936-40753d777478.png)'
- en: This is a good way of checking the configuration of IIS or an ASP.NET application
    running on IIS. You can check the virtual directory setup, application pools,
    and application configuration, but this should be used for investigation only.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是检查在IIS上运行的IIS或ASP.NET应用程序配置的良好方法。您可以检查虚拟目录设置、应用程序池和应用程序配置，但这应该仅用于调查目的。
- en: If I find that something in the application is not configured correctly, I need
    to go back to the Dockerfile and fix it and not make a change to the running container.
    This technique can be very useful when you're migrating an existing app to Docker.
    If you install an MSI with the web app in the Dockerfile, you can't see what the
    MSI actually does—but you can connect with IIS Manager and see the results.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我发现应用程序中的某些内容配置不正确，我需要回到Dockerfile中进行修复，而不是对正在运行的容器进行更改。当您将现有应用程序迁移到Docker时，这种技术可能非常有用。如果您在Dockerfile中安装了带有Web应用程序的MSI，您将无法看到MSI实际执行的操作，但您可以连接到IIS管理器并查看结果。
- en: SQL Server Management Studio (SSMS)
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL Server管理工作室（SSMS）
- en: SSMS is more straightforward, because it uses the standard SQL client port `1433`.
    You don't need to expose any extra ports or start any extra services; SQL Server
    images from Microsoft and from this book already have everything set up. You can
    connect using SQL Server authentication with the `sa` credentials you use when
    you run the container.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: SSMS更为直接，因为它使用标准的SQL客户端端口`1433`。您不需要公开任何额外的端口或启动任何额外的服务；来自Microsoft和本书的SQL Server镜像已经设置好了一切。您可以使用在运行容器时使用的`sa`凭据使用SQL
    Server身份验证进行连接。
- en: 'This command runs a SQL Server 2019 Express Edition container, publishing port
    `1433` to the host and specifying the `sa` credentials:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行SQL Server 2019 Express Edition容器，将端口`1433`发布到主机，并指定`sa`凭据：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This publishes the standard SQL Server port `1433`, so you have three options
    for connecting to SQL Server inside the container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发布标准的SQL Server端口`1433`，因此您有三种选项可以连接到容器内部的SQL Server。
- en: On the host, use `localhost` as the server name.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机上，使用`localhost`作为服务器名称。
- en: On the host, use the container's IP address as the server name.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机上，使用容器的IP地址作为服务器名称。
- en: On a remote machine, use the Docker host's machine name or AP address.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程计算机上，使用Docker主机的计算机名称或AP地址。
- en: 'I''ve fetched the IP address for my container, so in SSMS on the Docker host,
    I just specify the SQL credentials:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经获取了容器的IP地址，所以在Docker主机上的SSMS中，我只需指定SQL凭据：
- en: '![](Images/0f7b835a-5d10-4170-ad44-d20e7d961ce5.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0f7b835a-5d10-4170-ad44-d20e7d961ce5.png)'
- en: You can administer this SQL instance in the same way as any SQL Server—creating
    databases, assigning user permissions, restoring Dacpacs, and running SQL scripts.
    Remember that any changes you make won't impact the image, and you'll need to
    build your own image if you want the changes to be available to new containers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像任何SQL Server一样管理这个SQL实例——创建数据库，分配用户权限，还原Dacpacs，并运行SQL脚本。请记住，您所做的任何更改都不会影响镜像，如果您希望这些更改对新容器可用，您需要构建自己的镜像。
- en: This approach lets you build a database through SSMS, if that's your preference,
    and get it working in a container without installing and running SQL Server. You
    can perfect your schema, add service accounts and seed data, and then export the
    database as a script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许您通过SSMS构建数据库，如果这是您的首选，并在容器中运行而无需安装和运行SQL Server。您可以完善架构，添加服务帐户和种子数据，然后将数据库导出为脚本。
- en: 'I''ve done this for a simple example database, exporting the schema and data
    to a single file called `init-db.sql`. The Dockerfile for `dockeronwindows/ch08-mssql-with-schema:2e`
    takes the SQL script and packages it into a new image, with a bootstrap PowerShell
    script that deploys the database when you create a container:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我为一个简单的示例数据库做了这个，将架构和数据导出到一个名为`init-db.sql`的单个文件中。`dockeronwindows/ch08-mssql-with-schema:2e`的Dockerfile将SQL脚本打包到一个新的镜像中，并使用一个引导PowerShell脚本在创建容器时部署数据库：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's a `HEALTHCHECK` in the SQL Server image here, which is good practice—it
    lets Docker check whether the database is running correctly. In this case, the
    test will fail if the schema has not been created, so the container won't report
    as healthy until the schema deployment has completed successfully.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的SQL Server镜像中有一个`HEALTHCHECK`，这是一个好的做法——它让Docker检查数据库是否正常运行。在这种情况下，如果架构尚未创建，测试将失败，因此在架构部署成功完成之前，容器将不会报告为健康状态。
- en: 'I can run a container from this image in the usual way:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以以通常的方式从这个镜像运行一个容器：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'By publishing port `1433`, the database container is available at a random
    port on the host, so I connect to the database with an SQL client and see the
    schema and data from the script:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发布端口`1433`，数据库容器可以在主机上的随机端口上使用，因此我可以使用SQL客户端连接到数据库，并从脚本中查看架构和数据。
- en: '![](Images/86e5cff3-5407-4e0f-a8f1-ae1bd82b2e7b.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/86e5cff3-5407-4e0f-a8f1-ae1bd82b2e7b.png)'
- en: This represents a fresh deployment of an application database, and in this case,
    I've used SQL Server's development edition to work out my schema but SQL Server
    Express for the actual database, all running in Docker with no local SQL Server
    instances.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个应用数据库的新部署，在这种情况下，我使用了SQL Server的开发版来制定我的架构，但是实际数据库使用了SQL Server Express，所有这些都在Docker中运行，没有本地SQL
    Server实例。
- en: If you think using SQL Server authentication is a retrograde step, you need
    to remember that Docker enables a different runtime model. You won't have a single
    SQL Server instance running multiple databases; they could all be targets if the
    credentials were compromised. Each SQL workload will be in a dedicated container
    with its own set of credentials, so you effectively have one SQL instance per
    database, and you could potentially have one database per service.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为使用SQL Server身份验证是一个倒退的步骤，您需要记住Docker可以实现不同的运行时模型。您不会有一个运行多个数据库的单个SQL Server实例；如果凭据泄露，它们都可能成为目标。每个SQL工作负载将在一个专用容器中，具有自己的一组凭据，因此您实际上每个数据库都有一个SQL实例，并且您可能每个服务都有一个数据库。
- en: Security can be increased by running in Docker. Unless you need to connect to
    SQL Server remotely, you don't need to publish the port from the SQL container.
    Any applications that need database access will run as containers in the same
    Docker network as the SQL container and will be able to access port `1433` without
    publishing it to the host. This means SQL is only accessible to other containers
    running in the same Docker network, and in production, you can use Docker secrets
    for the connection details.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 Docker 中运行，可以增加安全性。除非您需要远程连接到 SQL Server，否则无需从 SQL 容器发布端口。需要数据库访问的任何应用程序都将作为容器在与
    SQL 容器相同的 Docker 网络中运行，并且可以访问端口 `1433` 而无需将其发布到主机。这意味着 SQL 仅对在相同 Docker 网络中运行的其他容器可访问，在生产环境中，您可以使用
    Docker 机密来获取连接详细信息。
- en: If you need to use Windows authentication with an AD account, you can still
    do that in Docker. Containers can be domain-joined when they start, so you can
    use service accounts for SQL Server instead of SQL Server authentication.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在 AD 帐户中使用 Windows 身份验证，您仍然可以在 Docker 中执行。容器在启动时可以加入域，因此您可以使用服务帐户来代替 SQL
    Server 身份验证。
- en: Event logs
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件日志
- en: You can connect Event Viewer on your local machine to a remote server, but currently
    the remote event log services are not enabled on the Windows Server Core or the
    Nano Server images. This means you can't connect to a container and read event
    log entries with the Event Viewer UI—but you can do that with the server manager
    UI, which I'll cover in the next section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将本地计算机上的事件查看器连接到远程服务器，但目前 Windows Server Core 或 Nano Server 映像上未启用远程事件日志服务。这意味着您无法使用事件查看器
    UI 连接到容器并读取事件日志条目，但您可以使用服务器管理器 UI 进行操作，我将在下一节中介绍。
- en: 'If you just want to read event logs, you can execute PowerShell cmdlets against
    running containers to get the log entries. This command reads the two latest event
    log entries for the SQL Server application from my database container:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想读取事件日志，可以针对正在运行的容器执行 PowerShell cmdlet 以获取日志条目。此命令从我的数据库容器中读取 SQL Server
    应用程序的两个最新事件日志条目：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Reading event logs can be useful if you have an issue with a container that
    you can't diagnose any other way. But it's an approach that doesn't scale when
    you have dozens or hundreds of containers running. It's better to relay the event
    logs that are of interest to the console, so they're collected by the Docker platform,
    and you can read them with `docker container logs`, or a management tool that
    can access the Docker API.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到无法以其他方式诊断的容器问题，读取事件日志可能会很有用。但是，当您有数十个或数百个容器运行时，这种方法并不适用。最好将感兴趣的事件日志中继到控制台，以便
    Docker 平台收集它们，并且您可以使用 `docker container logs` 或可以访问 Docker API 的管理工具来读取它们。
- en: Relaying event logs is simple to do, taking a similar approach to relaying IIS
    logs in [Chapter 3](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml), *Developing Dockerized
    .NET Framework and .NET Core Applications*. For any apps that write to the event
    log, you use a startup script as the entry point, which runs the app and then
    enters a read loop—getting entries from the event log and writing them out to
    the console.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 中继事件日志很容易做到，采用了与 [第 3 章](ee527f27-ee07-40e1-a39d-86aa2d11da72.xhtml) *开发 Docker
    化的 .NET Framework 和 .NET Core 应用程序* 中中继 IIS 日志类似的方法。对于写入事件日志的任何应用程序，您可以使用启动脚本作为入口点，该脚本运行应用程序，然后进入读取循环，从事件日志中获取条目并将其写入控制台。
- en: 'This is a useful approach for apps that run as Windows Services, and it''s
    an approach Microsoft has used in the SQL Server Windows images. The Dockerfile
    uses a PowerShell script as `CMD`, and that script ends with a loop that calls
    the same `Get-EventLog` cmdlet to relay logs to the console:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于作为 Windows 服务运行的应用程序非常有用，这也是 Microsoft 在 SQL Server Windows 映像中使用的方法。Dockerfile
    使用 PowerShell 脚本作为 `CMD`，该脚本以循环结束，调用相同的 `Get-EventLog` cmdlet 将日志中继到控制台：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This script reads the event log every 2 seconds, gets any entries since the
    last read, and writes them out to the console. The script runs in the process
    started by Docker, so the log entries are captured and can be surfaced by the
    Docker API.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本每2秒读取一次事件日志，获取自上次读取以来的任何条目，并将它们写入控制台。该脚本在Docker启动的进程中运行，因此日志条目被捕获并可以通过Docker
    API公开。
- en: This is not a perfect approach—it uses a timed loop and only selects some of
    the data from the log, and it means storing data in both the container's event
    log and in Docker. It is valid if your application already writes to the event
    log and you want to Dockerize it without rebuilding the app. In this case, you
    need to be sure you have a mechanism to keep your application process running,
    such as a Windows Service, and a health check in the Dockerfile, because Docker
    is monitoring only the event log loop.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个完美的方法——它使用了定时循环，只选择了日志中的一些数据，并且意味着在容器的事件日志和Docker中存储数据。如果您的应用程序已经写入事件日志，并且您希望将其Docker化而不需要重新构建应用程序，则这是有效的。在这种情况下，您需要确保您有一种机制来保持应用程序进程运行，比如Windows服务，并且在Dockerfile中进行健康检查，因为Docker只监视事件日志循环。
- en: Server manager
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器管理器
- en: Server manager is a great tool to administer and monitor servers remotely, and
    it works well with containers based on Windows Server Core. You need to take a
    similar approach to the IIS management console, configuring a user in the container
    with administrator access and then connecting from the host.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器管理器是一个很好的工具，可以远程管理和监控服务器，并且它与基于Windows Server Core的容器配合良好。您需要采用类似的方法来管理IIS控制台，配置容器中具有管理员访问权限的用户，然后从主机连接。
- en: 'Just as with IIS, you can add a script to the image, which enables access so
    you can run it when you need it. This is safer than always enabling remote access
    in the image. The script just needs to add a user, configure the server to allow
    remote access from administrator accounts, and ensure the **Windows Remote Management**
    (**WinRM**) service is running:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 就像IIS一样，您可以向镜像添加一个启用访问的脚本，这样您可以在需要时运行它。这比在镜像中始终启用远程访问更安全。该脚本只需要添加一个用户，配置服务器以允许管理员帐户进行远程访问，并确保**Windows远程管理**（**WinRM**）服务正在运行：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I have a sample image which shows this approach, `dockeronwindows/ch08-iis-with-server-manager:2e`. It
    is based on IIS and packages a script to enable remote access with server manager.
    The Dockerfile also exposes the ports used by WinRM, `5985` and `5986`. I can
    start a container running IIS in the background and then enable remote access:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我有一个示例镜像展示了这种方法，`dockeronwindows/ch08-iis-with-server-manager:2e`。它基于IIS，并打包了一个脚本来启用服务器管理器的远程访问。Dockerfile还公开了WinRM使用的端口`5985`和`5986`。我可以启动一个在后台运行IIS的容器，然后启用远程访问：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can connect to the container with the server manager, using the container''s
    IP address, but the container isn''t domain-joined. The server manager will try
    to authenticate over a secure channel and fail, so you''ll get a WinRM authentication
    error. To add a server that isn''t domain-joined, you need to add it as a trusted
    host. The trusted host list needs to use the hostname of the container, and not
    the IP address, so first I''ll get the hostname of the container:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用容器的IP地址连接到服务器管理器，但容器没有加入域。服务器管理器将尝试通过安全通道进行身份验证并失败，因此您将收到WinRM身份验证错误。要添加一个未加入域的服务器，您需要将其添加为受信任的主机。受信任的主机列表需要使用容器的主机名，而不是IP地址，所以首先我会获取容器的主机名：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I will add that as an entry in the `hosts` file for my server, at `C:\Windows\system32\drivers\etc\hosts`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在我的服务器的`hosts`文件中添加一个条目，位于`C:\Windows\system32\drivers\etc\hosts`：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And now, I can add the container to the trusted list. This command needs to
    run on the host, and not in the container. You''re adding the container''s hostname
    to the local machine''s list of trusted servers. I run this on my Windows Server
    2019 host:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以将容器添加到受信任的列表中。此命令需要在主机上运行，而不是在容器中运行。您正在将容器的主机名添加到本地计算机的受信任服务器列表中。我在我的Windows
    Server 2019主机上运行此命令：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I'm running Windows Server 2019, but you can use the server manager on Windows
    10 too. Install the **Remote Server Administration Tools** (**RSAT**), and you
    can use the server manager on Windows 10 in the same way.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我正在运行Windows Server 2019，但您也可以在Windows 10上使用服务器管理器。安装**远程服务器管理工具**（**RSAT**），您可以在Windows
    10上以相同的方式使用服务器管理器。
- en: 'In the server manager, navigate to All Servers | Add Servers, and open the
    DNS tab. Here, you can enter the hostname of the container, and the server manager
    will resolve the IP address:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器管理器中，导航到所有服务器 | 添加服务器，并打开DNS选项卡。在这里，您可以输入容器的主机名，服务器管理器将解析IP地址：
- en: '![](Images/281c2292-4fc3-4a73-a045-1267e090f3a5.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/281c2292-4fc3-4a73-a045-1267e090f3a5.png)'
- en: 'Select the server details and click on OK—now the server manager will try to
    connect to the container. You''ll see an updated status in the All Servers tab,
    which says the server is online but that access is denied. Now, you can right-click
    on the container in the server list and click on Manage As to provide the credentials
    for the local administrator account. You need to specify the hostname as the domain
    part of the username. The local user created in the script is called `serveradmin`, but
    I need to authenticate with  `9c097d80c08b\serveradmin`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 选择服务器详细信息，然后单击“确定” - 现在服务器管理器将尝试连接到容器。您将在“所有服务器”选项卡中看到更新的状态，其中显示服务器已上线，但访问被拒绝。现在，您可以右键单击服务器列表中的容器，然后单击“以...身份管理”以提供本地管理员帐户的凭据。您需要将主机名指定为用户名的域部分。脚本中创建的本地用户名为`serveradmin`，但我需要使用`9c097d80c08b\serveradmin`进行身份验证：
- en: '![](Images/35b53a20-2065-4844-b52e-ec397a9106d4.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/35b53a20-2065-4844-b52e-ec397a9106d4.png)'
- en: 'Now the connection succeeds, and you''ll see the data from the container surfaced
    in the server manager, including the event log entries, Windows Services, and
    all the installed roles and features:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接成功了，您将在服务器管理器中看到来自容器的数据，包括事件日志条目、Windows服务以及所有安装的角色和功能：
- en: '![](Images/73b37959-9d87-40bc-a0b8-dce0d6f392e9.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/73b37959-9d87-40bc-a0b8-dce0d6f392e9.png)'
- en: You can even add features to the container from the remote server manager UI—but
    that wouldn't be a good practice. Like the other UI management tools, it's better
    to use them for exploration and investigation but not to make any changes in the
    Dockerfile.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以从远程服务器管理器UI向容器添加功能-但这不是一个好的做法。像其他UI管理工具一样，最好用它们进行探索和调查，而不是在Dockerfile中进行任何更改。
- en: Managing containers with Docker tools
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker工具管理容器
- en: You've seen that you can use existing Windows tools to administer containers,
    but what you can do with these tools doesn't always apply in the Docker world.
    A container will run a single web application, so the hierarchy navigation of
    IIS Manager isn't really helpful. Checking event logs in the server manager can
    be useful, but it is much more useful to relay entries to the console, so they
    can be surfaced from the Docker API.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到可以使用现有的Windows工具来管理容器，但是这些工具可以做的事情并不总是适用于Docker世界。一个容器将运行一个单独的Web应用程序，因此IIS
    Manager的层次结构导航并不是很有用。在服务器管理器中检查事件日志可能是有用的，但将条目中继到控制台更有用，这样它们可以从Docker API中显示出来。
- en: Your application images also need to be set up explicitly to enable access to
    remote management tools, exposing ports, adding users, and running additional
    Windows services. All this adds to the attack surface of your running container.
    You should see these existing tools as useful in debugging in development and
    test environments, but they're not really suitable for production.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序镜像还需要明确设置，以便访问远程管理工具，公开端口，添加用户和运行其他Windows服务。所有这些都增加了正在运行的容器的攻击面。您应该将这些现有工具视为在开发和测试环境中调试有用，但它们并不适合生产环境。
- en: The Docker platform provides a consistent API for any type of application running
    in a container, and that's an opportunity for a new type of admin interface. For
    the rest of the chapter, I'll be looking at management tools that are Docker-aware
    and provide an alternative management interface to the Docker command line. I'll
    start with some open source tools and move on to the commercial **Containers-as-a-Service**
    (**CaaS**) platform in Docker Enterprise.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台为在容器中运行的任何类型的应用程序提供了一致的API，这为一种新类型的管理员界面提供了机会。在本章的其余部分，我将研究那些了解Docker并提供替代管理界面的管理工具。我将从一些开源工具开始，然后转向Docker企业中商业**容器即服务**（**CaaS**）平台。
- en: Docker visualizer
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker可视化工具
- en: '**Visualizer** is a very simple web UI that shows basic information about nodes
    and containers in a Docker swarm. It''s an open source project on GitHub in the
    `dockersamples/docker-swarm-visualizer` repository. It''s a Node.js application,
    and it comes packaged in Docker images for Linux and Windows.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**可视化工具**是一个非常简单的Web UI，显示Docker集群中节点和容器的基本信息。它是GitHub上`dockersamples/docker-swarm-visualizer`存储库中的开源项目。它是一个Node.js应用程序，并且它打包在Linux和Windows的Docker镜像中。'
- en: 'I''ve deployed a hybrid Docker Swarm in Azure for this chapter, with a Linux
    manager node, two Linux worker nodes, and two Windows worker nodes. I can run
    the visualizer as a Linux container on the manager node, by deploying a service
    that binds to the Docker Engine API:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Azure中为本章部署了一个混合Docker Swarm，其中包括一个Linux管理节点，两个Linux工作节点和两个Windows工作节点。我可以在管理节点上将可视化工具作为Linux容器运行，通过部署绑定到Docker
    Engine API的服务：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The constraint ensures the container runs only on a manager node, and as my
    manager runs on Linux, I can use the `mount` option to let the container talk
    to the Docker API. In Linux, you can treat sockets as filesystem mounts, so the
    container can use the API socket, without having to expose it publicly over the **Transmission
    Control Protocol** (**TCP**).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该约束条件确保容器仅在管理节点上运行，由于我的管理节点运行在Linux上，我可以使用`mount`选项让容器与Docker API进行通信。在Linux中，您可以将套接字视为文件系统挂载，因此容器可以使用API套接字，而无需将其公开到**传输控制协议**（**TCP**）上。
- en: You can also run the visualizer in an all-Windows swarm. Docker currently supports
    Windows named pipes as volumes on a single server, but not in Docker Swarm; however,
    you can mount the API using TCP, as I did with Traefik in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm*.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在全Windows集群中运行可视化工具。Docker目前支持Windows命名管道作为单个服务器上的卷，但在Docker Swarm中不支持；但是，您可以像我在[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)中使用Traefik一样，通过TCP挂载API。
- en: 'The visualizer gives you a read-only view of the containers in the swarm. The
    UI shows the status of hosts and containers and gives you a quick way to check
    the distribution of the workload on your swarm. This is how my Docker Enterprise
    cluster in Azure looks with the NerdDinner stack deployed:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化工具为您提供了对集群中容器的只读视图。UI显示主机和容器的状态，并为您提供了一种快速检查集群中工作负载分布的方式。这是我在Azure中部署NerdDinner堆栈的Docker企业集群的外观：
- en: '![](Images/732dc814-28a2-4751-83f3-b518681e96ba.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/732dc814-28a2-4751-83f3-b518681e96ba.png)'
- en: I can see at a glance whether my nodes and containers are healthy, and I can
    see that Docker has distributed containers across the swarm as evenly as it can.
    Visualizer uses the API in the Docker service, which exposes all the Docker resources
    with a RESTful interface.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我一眼就能看到我的节点和容器是否健康，我可以看到Docker已经尽可能均匀地分布了容器。可视化器使用Docker服务中的API，该API使用RESTful接口公开所有Docker资源。
- en: The Docker API also provides write access, so you can create and update resources.
    An open source project called **Portainer** provides administration using these
    APIs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Docker API还提供了写访问权限，因此您可以创建和更新资源。一个名为**Portainer**的开源项目使用这些API提供管理功能。
- en: Portainer
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Portainer
- en: Portainer is a lightweight management UI for Docker. It runs as a container,
    and it can manage single Docker hosts and clusters running in swarm mode. It's
    an open source project hosted on GitHub in the `portainer/portainer` repository.
    Portainer is written in Go, so it's cross-platform, and you can run it as a Linux
    or a Windows container.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer是Docker的轻量级管理UI。它作为一个容器运行，可以管理单个Docker主机和以集群模式运行的集群。它是一个托管在GitHub上的开源项目，位于`portainer/portainer`存储库中。Portainer是用Go语言编写的，因此它是跨平台的，您可以将其作为Linux或Windows容器运行。
- en: 'There are two parts to Portainer: You need to run an agent on each node and
    then run the management UI. All these run in containers, so you can use a Docker
    Compose file such as the one in the source code for this chapter under `ch08-portainer`.
    The Compose file defines a global service that is the Portainer agent, running
    in a container on each node in the swarm. Then there is the Portainer UI:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer有两个部分：您需要在每个节点上运行一个代理，然后运行管理UI。所有这些都在容器中运行，因此您可以使用Docker Compose文件，例如本章源代码中的`ch08-portainer`中的文件。Compose文件定义了一个全局服务，即Portainer代理，在集群中的每个节点上都在容器中运行。然后是Portainer
    UI：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `portainer/portainer` image on Docker Hub is a multi-arch image, which means
    you can use the same image tag on Linux and Windows, and Docker will use the matching
    image for the host OS. You can't mount the Docker socket on Windows, but the Portainer
    documentation shows you how to access the Docker API on Windows.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub上的`portainer/portainer`镜像是一个多架构镜像，这意味着您可以在Linux和Windows上使用相同的镜像标签，Docker将使用与主机操作系统匹配的镜像。您无法在Windows上挂载Docker套接字，但Portainer文档会向您展示如何在Windows上访问Docker
    API。
- en: 'When you first browse to Portainer, you need to specify an administrator password.
    Then, the service connects to the Docker API and surfaces details about all the
    resources. In swarm mode, I can see a count of the nodes in the swarm, the number
    of stacks, the services and containers running, and the images, volumes, and networks
    in my cluster:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次浏览到Portainer时，您需要指定管理员密码。然后，服务将连接到Docker API并显示有关所有资源的详细信息。在集群模式下，我可以看到集群中节点的数量，堆栈的数量，正在运行的服务和容器的数量，以及集群中的镜像、卷和网络。
- en: '![](Images/179bc3ae-5b55-4487-b2c8-dad341998b9d.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/179bc3ae-5b55-4487-b2c8-dad341998b9d.png)'
- en: 'The cluster visualizer link shows a UI very much like the Docker Swarm visualizer,
    with the containers running on each node:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 集群可视化器链接显示了一个非常类似于Docker Swarm可视化器的UI，显示了每个节点上运行的容器：
- en: '![](Images/8b3a9fe6-5690-4bbc-af88-1fb2d3191700.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8b3a9fe6-5690-4bbc-af88-1fb2d3191700.png)'
- en: 'The Services view shows me all the running services, and, from here, I can
    drill down into service details, and there''s a quick link to update the scale
    of the service:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 服务视图向我展示了所有正在运行的服务，从这里，我可以深入了解服务的详细信息，并且有一个快速链接来更新服务的规模：
- en: '![](Images/3f0d001c-3a79-4cf4-8f68-f0028ca0fe9e.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/3f0d001c-3a79-4cf4-8f68-f0028ca0fe9e.png)'
- en: Portainer has been evolving in line with new Docker functionality, and you can
    deploy stacks and services and manage them from Portainer. You can drill down
    into service logs, connect a console session to containers, and deploy common
    applications from Docker Compose templates built into the UI.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer随着新的Docker功能不断发展，您可以从Portainer部署堆栈和服务并对其进行管理。您可以深入了解服务日志，连接到容器的控制台会话，并从内置UI中部署Docker
    Compose模板的常见应用程序。
- en: You can create multiple users and teams in Portainer and apply access control
    to resources. You can create services that have access limited to certain teams.
    Authentication is managed by Portainer with a local user database, or through
    connection to an existing **Lightweight Directory Access Protocol** (**LDAP**)
    provider.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Portainer中创建多个用户和团队，并对资源应用访问控制。您可以创建仅限于某些团队访问的服务。认证由Portainer通过本地用户数据库或连接到现有的轻量级目录访问协议（LDAP）提供者进行管理。
- en: Portainer is a great tool and an active open source project, but you should
    evaluate the latest version before you adopt it as your management tool. Portainer
    was originally a Linux tool, and there are still a few areas where Windows features
    are not fully supported. At the time of writing, the agent container needs special
    configuration on Windows nodes, which means you can't deploy it as a global service
    across your swarm, and you can't see Windows containers in Portainer without it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Portainer是一个很棒的工具，也是一个活跃的开源项目，但在采用它作为管理工具之前，您应该评估最新版本。Portainer最初是一个Linux工具，仍然有一些Windows功能不完全支持的地方。在撰写本文时，代理容器需要在Windows节点上进行特殊配置，这意味着您无法将其部署为跨整个群集的全局服务，并且没有它，您无法在Portainer中看到Windows容器。
- en: In a production environment, you may have a requirement to run software with
    support. Portainer is open source, but there is a commercial support option available.
    For enterprise deployments or environments with strict security processes, Docker
    Enterprise offers a complete feature set.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您可能需要运行具有支持的软件。Portainer是开源的，但也提供了商业支持选项。对于企业部署或具有严格安全流程的环境，Docker Enterprise提供了完整的功能集。
- en: CaaS with Docker Enterprise
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Enterprise的CaaS
- en: Docker Enterprise is the commercial edition from Docker, Inc. It's a complete
    CaaS platform and makes full use of Docker to provide a single pane of glass to
    manage any number of containers running on any number of hosts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise是Docker，Inc.的商业版本。它是一个完整的CaaS平台，充分利用Docker提供单一的管理界面，用于管理任意数量的运行在任意数量主机上的容器。
- en: Docker Enterprise is a production-grade product that you run on a cluster of
    machines in your data center or in the cloud. The clustering functionality supports
    multiple orchestrators, Kubernetes, as well as Docker Swarm. In production, you
    could have a 100-node cluster using the exact same application platform as your
    development laptop running as a single-node cluster.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise是一个在数据中心或云中运行的生产级产品。集群功能支持多个编排器，包括Kubernetes和Docker Swarm。在生产中，您可以拥有一个包含100个节点的集群，使用与您的开发笔记本相同的应用程序平台作为单节点集群运行。
- en: There are two parts to Docker Enterprise. There's the **Docker Trusted Registry**
    (**DTR**), which is like running your own private instance of Docker Hub, complete
    with image signing and security scanning. I'll cover DTR in [Chapter 9](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml),
    *Understanding the Security Risks and Benefits of Docker*, when I look at security
    in Docker. The administration component is called **Universal Control Plane**
    (**UCP**), and it's a new type of management interface.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise有两个部分。其中一个是**Docker Trusted Registry**（**DTR**），它类似于运行您自己的私有Docker
    Hub实例，包括图像签名和安全扫描。当我在Docker的安全性方面进行讨论时，我将在[第9章](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml)中涵盖DTR，*理解Docker的安全风险和好处*。管理组件称为**Universal
    Control Plane**（**UCP**），它是一种新型的管理界面。
- en: Understanding Universal Control Plane
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Universal Control Plane
- en: UCP is a web-based interface used to manage nodes, images, services, containers,
    secrets, and all the other Docker resources. UCP itself is a distributed application
    that runs in containers across connected services in the swarm. UCP gives you
    a single place to administer all your Docker applications in the same way. It
    provides role-based access control to resources so you can set fine-grained controls
    over who can do what.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: UCP是一个基于Web的界面，用于管理节点、图像、服务、容器、秘密和所有其他Docker资源。UCP本身是一个分布式应用程序，运行在swarm中连接的服务中的容器中。UCP为您提供了一个统一的地方来以相同的方式管理所有Docker应用程序。它提供了基于角色的访问控制，以便您可以对谁可以做什么进行细粒度的控制。
- en: Docker Enterprise runs Kubernetes and Docker Swarm. Kubernetes will support
    Windows nodes in a future release, so you will be able to deploy Windows containers
    to Docker Swarm or Kubernetes on a single Docker Enterprise cluster. You can deploy
    a stack to UCP with a Docker Compose file, target either Docker Swarm or Kubernetes,
    and UCP will create all the resources.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise运行Kubernetes和Docker Swarm。Kubernetes将在未来的版本中支持Windows节点，因此您将能够在单个Docker
    Enterprise集群上将Windows容器部署到Docker Swarm或Kubernetes。您可以使用Docker Compose文件将堆栈部署到UCP，将目标设置为Docker
    Swarm或Kubernetes，UCP将创建所有资源。
- en: 'UCP gives you the full range of administration features: you can create, scale,
    and remove services, inspect, and connect to the tasks running the services, and
    manage the nodes running the swarm. All the additional resources you need, such
    as Docker networks, configs, secrets, and volumes, are surfaced in UCP for management
    in the same way.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: UCP为您提供了完整的管理功能：您可以创建、扩展和删除服务，检查并连接到运行服务的任务，并管理运行swarm的节点。您需要的所有其他资源，如Docker网络、配置、秘密和卷，都以相同的方式在UCP中进行管理。
- en: You can run a hybrid Docker Enterprise cluster with Linux nodes for UCP and
    DTR and Windows nodes for your user workloads. As a subscription service from
    Docker, you have support from Docker's team for the setting up of your cluster
    and for dealing with any issues, covering all the Windows and Linux nodes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在UCP和DTR的Linux节点上运行混合Docker Enterprise集群，并在Windows节点上运行用户工作负载。作为Docker的订阅服务，您可以得到Docker团队的支持，他们将为您设置集群并处理任何问题，涵盖所有的Windows和Linux节点。
- en: Navigating the UCP UI
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导航UCP UI
- en: You log into UCP from the home page. You can either use the authentication built
    into Docker Enterprise, managing users manually from UCP, or you can connect to
    any LDAP authentication store. This means you can set up Docker Enterprise to
    use your organization's AD and have users log in with their Windows accounts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从主页登录到UCP。您可以使用Docker Enterprise内置的身份验证，手动管理UCP中的用户，或者连接到任何LDAP身份验证存储。这意味着您可以设置Docker
    Enterprise来使用您组织的AD，并让用户使用他们的Windows帐户登录。
- en: 'The UCP home page is a dashboard that shows the key performance indicators
    of your cluster, the number of nodes, services, and the Swarm and Kubernetes services
    running at that moment, together with the overall compute utilization of the cluster:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: UCP主页是一个仪表板，显示了集群的关键性能指标，节点数、服务数，以及在那一刻运行的Swarm和Kubernetes服务，以及集群的整体计算利用率：
- en: '![](Images/6daec606-9f03-42a5-bc82-c6ed29acc086.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6daec606-9f03-42a5-bc82-c6ed29acc086.png)'
- en: 'From the dashboard, you can navigate to the resource views that give you access
    grouped by the resource type: Services, Containers, Images, Nodes, Networks, Volumes,
    and Secrets. For most of the resource types, you can list the existing resources,
    inspect them, delete them, and create new ones.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从仪表板，您可以导航到资源视图，按资源类型分组访问：服务、容器、镜像、节点、网络、卷和秘密。对于大多数资源类型，您可以列出现有资源、检查它们、删除它们，并创建新的资源。
- en: UCP is a multi-orchestrator container platform, so you can have some applications
    running in Kubernetes and others in Docker Swarm on the same cluster. The Shared
    Resources section of the navigation shows the resources that are shared between
    the orchestrators, including images, containers, and stacks. This is a great way
    to support heterogeneous deliveries, or to evaluate different orchestrators in
    controlled environments.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: UCP是一个多编排器容器平台，因此您可以在同一集群中在Kubernetes中运行一些应用程序，而在Docker Swarm中运行其他应用程序。导航栏中的共享资源部分显示了编排器之间共享的资源，包括镜像、容器和堆栈。这是支持异构交付的一个很好的方法，或者在受控环境中评估不同的编排器。
- en: UCP provides **Role-Based Access Control** (**RBAC**) for all the resources.
    You can apply a permission label to any resource and secure access based on that
    label. Teams can be assigned permissions to labels—ranging from no access to full
    control—which secures access to team members for all the resources that have these
    labels.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: UCP为所有资源提供了基于角色的访问控制（RBAC）。您可以将权限标签应用于任何资源，并根据该标签来保护访问。团队可以被分配到标签的权限，从无访问权限到完全控制权限不等，这样可以确保团队成员对拥有这些标签的所有资源的访问权限。
- en: Managing nodes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理节点
- en: 'The node view shows you all the nodes in the cluster, listing the operating
    system and CPU architecture, the node status, and the node manager status:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 节点视图显示了集群中的所有节点，列出了操作系统和CPU架构、节点状态和节点管理器状态：
- en: '![](Images/65b4a710-75ef-4d74-acd5-78405f58ec28.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/65b4a710-75ef-4d74-acd5-78405f58ec28.png)'
- en: 'I have six nodes in my cluster:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我的集群中有六个节点：
- en: 'Two Linux nodes used for mixed workloads: these can run Kubernetes or Docker
    Swarm services'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于混合工作负载的两个Linux节点：这些节点可以运行Kubernetes或Docker Swarm服务
- en: Two Linux nodes that are only configured for Docker Swarm services
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅配置为Docker Swarm服务的两个Linux节点
- en: Two Windows nodes that are only for Docker Swarm
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个仅用于Docker Swarm的Windows节点
- en: These nodes are running all the UCP and DTR containers. Docker Enterprise can
    be configured to exempt manager nodes from running user workloads, and this can
    also be done for running DTR. This is a good way to ring-fence compute power for
    the Docker Enterprise services, to ensure your application workload doesn't starve
    the management components of resources.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些节点正在运行所有UCP和DTR容器。Docker Enterprise可以配置免除管理节点运行用户工作负载，也可以对运行DTR进行同样的配置。这是一个很好的方法，可以为Docker
    Enterprise服务划定计算资源的边界，以确保您的应用工作负载不会使管理组件资源匮乏。
- en: In node administration, you have a graphical way to view and manage the cluster
    servers you have access to. You can put nodes into the drain mode, allowing you
    to run Windows updates or to upgrade Docker on the node. You can promote workers
    to managers, demote managers to workers, and see the tokens you need to join new
    nodes to the swarm.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在节点管理中，您可以以图形方式查看和管理您可以访问的集群服务器。您可以将节点放入排水模式，从而可以运行Windows更新或升级节点上的Docker。您可以将工作节点提升为管理节点，将管理节点降级为工作节点，并查看加入新节点到集群所需的令牌。
- en: 'Drilling into each node, you can see the total CPU, memory, and disk usage
    of the server, with a graph showing usage, which you can aggregate for periods
    from 30 minutes to 24 hours:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 深入了解每个节点，您可以查看服务器的总CPU、内存和磁盘使用情况，并显示使用情况的图表，您可以将其聚合为30分钟到24小时的时间段：
- en: '![](Images/58297ff5-c3fc-4b0c-b5df-a7744e6acdd6.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/58297ff5-c3fc-4b0c-b5df-a7744e6acdd6.png)'
- en: In the Metrics tab, there is a list of all the containers on the node, showing
    their current status and the image the container is running from. From the container
    list, you can navigate to the container view, which I'll cover shortly.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在指标选项卡中，列出了节点上的所有容器，显示它们的当前状态以及容器正在运行的镜像。从容器列表中，您可以导航到容器视图，我将很快介绍。
- en: Volumes
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卷
- en: '**Volumes** exist at the node level rather than the swarm level, but you can
    manage them in UCP across all the swarm nodes. How you manage volumes in the swarm
    depends on the type of volume you''re using. Local volumes are fine for scenarios
    such as global services that write logs and metrics to the disk and then forward
    them centrally.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**卷**存在于节点级别而不是集群级别，但您可以在UCP中管理它们跨所有集群节点。您在集群中管理卷的方式取决于您使用的卷的类型。本地卷适用于诸如将日志和指标写入磁盘然后将其集中转发的全局服务等场景。'
- en: Persistent data stores running as clustered services could also use local storage.
    You might create a local volume on every node but add labels to servers with high-volume
    RAID arrays. When you create the data service, you can use a constraint to limit
    it to RAID nodes, so other nodes will never have a task scheduled on them, and
    where the tasks are running, they will write data to the volume on the RAID array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为集群服务运行的持久数据存储也可以使用本地存储。您可以在每个节点上创建一个本地卷，但在具有高容量RAID阵列的服务器上添加标签。创建数据服务时，您可以使用约束将其限制为RAID节点，因此其他节点永远不会在其上安排任务，并且任务运行的地方将数据写入RAID阵列上的卷。
- en: For on-premises data centers and in the cloud, you can use shared storage with
    volume plugins. With shared storage, services can continue to access data even
    if containers move to different swarm nodes. Service tasks will read and write
    data to the volume that gets persisted on the shared storage device. There are
    many volume plugins available on Docker Store, including for-cloud services such
    as AWS and Azure, physical infrastructure from HPE and Nimble, and virtualization
    platforms, such as vSphere.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本地数据中心和云中，您可以使用卷插件与共享存储。使用共享存储，即使容器移动到不同的集群节点，服务也可以继续访问数据。服务任务将读取和写入数据到持久保存在共享存储设备上的卷中。Docker
    Store上有许多卷插件可用，包括用于云服务的AWS和Azure，来自HPE和Nimble的物理基础设施，以及vSphere等虚拟化平台。
- en: Docker Enterprise uses the Cloudstor plugin to provide cluster-wide storage,
    and if you deploy with Docker Certified Infrastructure, then this is configured
    for you. At the time of writing, the plugin is only supported on Linux nodes,
    so Windows nodes are restricted to running local volumes. There are still many
    stateful application architectures that can work well in Docker Swarm with local
    volumes, but you need to configure them carefully.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Enterprise使用Cloudstor插件提供集群范围的存储，如果您使用Docker Certified Infrastructure部署，那么这将为您配置。在撰写本文时，该插件仅受Linux节点支持，因此Windows节点受限于运行本地卷。在Docker
    Swarm中仍然有许多有状态的应用程序架构可以很好地工作，但您需要仔细配置它们。
- en: Storage is an area that there is a lot of focus on in the container ecosystem.
    Technologies are emerging that create cluster-wide storage options, without the
    need for specific infrastructure. As these mature, you will be able to run stateful
    services with high availability and scale, just by pooling the disks on your cluster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 存储是容器生态系统中受到很多关注的领域。正在出现的技术可以创建集群范围的存储选项，而无需特定的基础设施。随着这些技术的成熟，您将能够通过汇集集群上的磁盘来运行具有高可用性和可扩展性的有状态服务。
- en: 'Volumes have a limited number of options, so creating them is a case of specifying
    the Driver and applying any driver Options:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 卷有有限数量的选项，因此创建它们是指定驱动程序并应用任何驱动程序选项的情况：
- en: '![](Images/2b4af10f-fd2f-4090-99e7-480862e189a9.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/2b4af10f-fd2f-4090-99e7-480862e189a9.png)'
- en: Permissions can be applied to volumes, such as other resources, by specifying
    a collection where the resource belongs to. Collections are how UCP enforces role-based
    access control to limit access.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 权限可以应用于卷，如其他资源一样，通过指定资源所属的集合。集合是UCP如何强制基于角色的访问控制以限制访问的方式。
- en: 'Local volumes are created on each node, so containers that need a named volume
    can run on any node and still find the volume. In a hybrid swarm that UCP creates,
    local volumes are created on each node, and show the physical location on the
    server where the volume data is mounted:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本地卷在每个节点上创建，因此需要命名卷的容器可以在任何节点上运行并仍然找到卷。在UCP创建的混合Swarm中，本地卷在每个节点上创建，并显示挂载卷数据的服务器的物理位置：
- en: '![](Images/adff0283-7fa3-42ee-b1bc-5260cf8f8a29.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/adff0283-7fa3-42ee-b1bc-5260cf8f8a29.png)'
- en: UCP gives you a single view for all the resources in your cluster, including
    the volumes on each node and the images which are available for running containers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: UCP为您提供了集群中所有资源的单一视图，包括每个节点上的卷和可用于运行容器的图像。
- en: Images
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像
- en: 'UCP is not an image registry. DTR is the enterprise private registry in Docker
    Enterprise, but you can manage the images that are in the Docker cache on each
    node, using UCP. In the images view, UCP shows you which images have been pulled
    on the cluster nodes, and it also allows you to pull images, which get downloaded
    onto every node:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: UCP不是图像注册表。DTR是Docker Enterprise中的企业私有注册表，但您可以使用UCP管理在每个节点上的Docker缓存中的图像。在图像视图中，UCP会显示已在集群节点上拉取的图像，并允许您拉取图像，这些图像会下载到每个节点上：
- en: '![](Images/c64c83a7-f56b-46e5-ab53-05edf617388c.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/c64c83a7-f56b-46e5-ab53-05edf617388c.png)'
- en: 'Docker images are compressed for distribution, and the Docker engine decompresses
    the layers when you pull an image. There are OS-specific optimizations to start
    containers as soon as the pull completes, which is why you can''t pull Windows
    images on Linux hosts, or vice versa. UCP will try to pull the image on every
    host, but if some fail because of an OS mismatch, it will continue with the remaining
    nodes. You will see errors if there is a mismatch:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker图像经过压缩以进行分发，当您拉取图像时，Docker引擎会解压缩图层。有特定于操作系统的优化，可以在拉取完成后立即启动容器，这就是为什么您无法在Linux主机上拉取Windows图像，反之亦然。UCP将尝试在每个主机上拉取图像，但如果由于操作系统不匹配而导致某些主机失败，它将继续进行剩余节点。如果存在不匹配，您将看到错误：
- en: '![](Images/03333dcf-1a6d-49b1-ba17-063ec6e62f06.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/03333dcf-1a6d-49b1-ba17-063ec6e62f06.png)'
- en: 'In the image view, you can drill down and see the details of an image, including
    the history of the layers, the health check, any environment variables, and the
    exposed ports. The basic details also show you the OS platform of the image, the
    virtual size, and the date on which it was created:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在图像视图中，您可以深入了解图像的详细信息，包括图层的历史记录，健康检查，任何环境变量和暴露的端口。基本详细信息还会显示图像的操作系统平台，虚拟大小和创建日期：
- en: '![](Images/161ff9ad-3d91-44d2-8864-8b1606fbcbe7.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/161ff9ad-3d91-44d2-8864-8b1606fbcbe7.png)'
- en: In UCP, you can also remove images from the cluster. You may have a policy of
    retaining just the current and previous image versions on the cluster to allow
    rollback. Other images can be safely removed from the Docker Enterprise nodes,
    leaving all previous image versions in DTR so they can be pulled if needed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在UCP中，您还可以从集群中删除图像。您可能有一个保留集群上当前和先前图像版本的策略，以允许回滚。其他图像可以安全地从Docker Enterprise节点中删除，将所有先前的图像版本留在DTR中，以便在需要时拉取。
- en: Networks
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络
- en: Network management is straightforward and UCP presents the same interface as
    for other resource types. The network list shows the networks in the cluster and
    these can be added to a collection with RBAC applied, so you'll only see networks
    you're allowed to see.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 网络管理很简单，UCP呈现与其他资源类型相同的界面。网络列表显示了集群中的网络，这些网络可以添加到应用了RBAC的集合中，因此您只能看到您被允许看到的网络。
- en: 'There are several low-level options for networks, allowing you to specify IPv6
    and custom MTU packet sizes. Swarm mode supports encrypted networks, where the
    traffic between nodes is transparently encrypted, and it can be enabled through
    UCP. In a Docker Enterprise cluster, you''ll use the overlay driver to allow services
    to communicate in a virtual network across the cluster nodes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个网络的低级选项，允许您指定IPv6和自定义MTU数据包大小。Swarm模式支持加密网络，在节点之间的流量被透明加密，可以通过UCP启用。在Docker
    Enterprise集群中，您将使用覆盖驱动程序允许服务在集群节点之间的虚拟网络中进行通信：
- en: '![](Images/fb40e1e0-5d11-45d4-8471-8326cb0fe93e.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/fb40e1e0-5d11-45d4-8471-8326cb0fe93e.png)'
- en: Docker supports a special type of swarm network called an **ingress network**.
    Ingress networks have load balancing and service discovery for external requests.
    This makes port publishing very flexible. On a 10-node cluster, you could publish
    port `80` on a service with three replicas. If a node receives an incoming request
    on port `80` but it isn't running one of the service tasks, Docker will intelligently
    redirect it to a node that is running a task.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持一种特殊类型的Swarm网络，称为**入口网络**。入口网络具有用于外部请求的负载平衡和服务发现。这使得端口发布非常灵活。在一个10节点的集群上，您可以在具有三个副本的服务上发布端口`80`。如果一个节点收到端口`80`的传入请求，但它没有运行服务任务，Docker会智能地将其重定向到运行任务的节点。
- en: Ingress networks are a powerful feature that work the same for Linux and Windows
    nodes in a Docker Swarm cluster. I cover them in more detail in [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 入口网络是Docker Swarm集群中Linux和Windows节点的强大功能。我在[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)中更详细地介绍了它们，*使用Docker
    Swarm编排分布式解决方案*。
- en: Networks can also be deleted through UCP, but only if there are no containers
    attached. If you have services defined that use the network, you'll get a warning
    if you try to delete it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 网络也可以通过UCP删除，但只有在没有附加的容器时才能删除。如果您定义了使用网络的服务，那么如果您尝试删除它，您将收到警告。
- en: Deploying stacks
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署堆栈
- en: There are two ways to deploy your applications with UCP, which are analogous
    to deploying individual services with `docker service create`, and deploying a
    full compose file with `docker stack deploy`. Stacks are the easiest to deploy
    and will let you use a compose file that you've verified in pre-production environments.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UCP部署应用程序有两种方式，类似于使用`docker service create`部署单个服务和使用`docker stack deploy`部署完整的compose文件。堆栈是最容易部署的，可以让您使用在预生产环境中验证过的compose文件。
- en: In the source code for this chapter, the folder `ch08-docker-stack` contains
    the deployment manifests to run NerdDinner on Docker Enterprise, using swarm mode.
    The `core docker-compose.yml` file is the same as the one mentioned in [Chapter
    7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),* Orchestrating Distributed Solutions
    with Docker Swarm*, but there are some changes in the override file to deploy
    to my production cluster. I'm taking advantage of the hybrid cluster I have in
    Docker Enterprise, and I'm using Linux containers for all the open source infrastructure
    components.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的源代码中，文件夹`ch08-docker-stack`包含了在Docker Enterprise上运行NerdDinner的部署清单，使用了swarm模式。`core
    docker-compose.yml`文件与[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)中提到的相同，*使用Docker
    Swarm编排分布式解决方案*，但在覆盖文件中有一些更改以部署到我的生产集群。我正在利用我在Docker Enterprise中拥有的混合集群，并且我正在为所有开源基础设施组件使用Linux容器。
- en: 'There are only two changes for a service to use Linux containers instead of
    Windows: the image name, and a deployment constraint to ensure containers are
    scheduled to run on Linux nodes. Here''s the override for the NATS message queue
    in the file `docker-compose.hybrid-swarm.yml`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使服务使用Linux容器而不是Windows，只有两个更改：镜像名称和部署约束，以确保容器被安排在Linux节点上运行。以下是文件`docker-compose.hybrid-swarm.yml`中NATS消息队列的覆盖：
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'I''ve used the same approach as [Chapter 7](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml),
    *Orchestrating Distributed Solutions with Docker Swarm* with `docker-compose config`
    to join the override files together and export them into `docker-swarm.yml`. I
    could connect my Docker CLI to the cluster and deploy the application with `docker
    stack deploy`, or I could use the UCP UI. From the Stacks view, under Shared Resources,
    I can click on Create Stack and select the orchestrator and upload a compose YML
    file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了与[第7章](bf6a5e90-bbba-435b-b0a0-734611e0e834.xhtml)相同的方法，*使用Docker Swarm编排分布式解决方案*，使用`docker-compose
    config`将覆盖文件连接在一起并将它们导出到`docker-swarm.yml`中。我可以将我的Docker CLI连接到集群并使用`docker stack
    deploy`部署应用程序，或者我可以使用UCP UI。从堆栈视图中，在共享资源下，我可以点击创建堆栈，并选择编排器并上传一个compose YML文件：
- en: '![](Images/def85847-d39d-44ba-b2ff-f6d639a85227.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/def85847-d39d-44ba-b2ff-f6d639a85227.png)'
- en: 'UCP validates the contents and highlights any issues. Valid compose files are
    deployed as a stack, and you will see all the resources in UCP: networks, volumes,
    and services. After a few minutes, all the images for my application are pulled
    on to the cluster nodes and UCP schedules replicas for each of the services. The
    service list shows me that all the components are running at the required level
    of scale:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: UCP验证内容并突出显示任何问题。有效的组合文件将部署为堆栈，并且您将在UCP中看到所有资源：网络、卷和服务。几分钟后，我的应用程序的所有图像都被拉到集群节点上，并且UCP为每个服务安排了副本。服务列表显示所有组件都以所需的规模运行：
- en: '![](Images/e94a002b-0c9d-437a-bb82-48eae1560c01.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/e94a002b-0c9d-437a-bb82-48eae1560c01.png)'
- en: My modernized NerdDinner application is now running across 15 containers in
    a six-node Docker Enterprise swarm. I have high availability and scale in a supported
    production environment, and I've switched the four open source components from
    my custom images to the official Docker images, without any changes to my application
    images.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我的现代化 NerdDinner 应用程序现在在一个六节点的 Docker Enterprise 集群中运行了 15 个容器。我在受支持的生产环境中实现了高可用性和扩展性，并且将四个开源组件从我的自定义镜像切换到了官方的
    Docker 镜像，而不需要对我的应用程序镜像进行任何更改。
- en: Stacks are the preferred deployment model, as they continue to use the known
    compose file format, and they automate all the resources. But stacks are not suitable
    for every solution, particularly when you're moving legacy applications to containers.
    In a stack deployment, there's no guarantee about the order in which the services
    will be created; the `depends_on` option used by Docker Compose doesn't apply.
    This is a deliberate design decision based on the idea that services should be
    resilient, but not all services are.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是首选的部署模型，因为它们继续使用已知的 compose 文件格式，并自动化所有资源。但堆栈并不适用于每种解决方案，特别是当您将传统应用程序迁移到容器时。在堆栈部署中，无法保证服务创建的顺序；Docker
    Compose 使用的 `depends_on` 选项不适用。这是一种有意设计的决策，基于服务应该具有弹性的想法，但并非所有服务都是如此。
- en: Modern applications should be built for failure. If a web component can't connect
    to the database, it should use a policy-based retry mechanism to reconnect repeatedly rather
    than failing to start. Traditional applications usually expect their dependencies
    to be available and don't have graceful retries built in. NerdDinner is like that,
    so if I deploy a stack from the compose file, the web app could start before the
    database service is created, and it will fail.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序应该设计成可以容忍故障。如果 web 组件无法连接到数据库，它应该使用基于策略的重试机制来重复连接，而不是无法启动。传统的应用程序通常期望它们的依赖可用，并没有优雅的重试机制。NerdDinner
    就是这样，所以如果我从 compose 文件部署一个堆栈，web 应用可能会在数据库服务创建之前启动，然后失败。
- en: In this case, the container should exit, so Docker knows the application is
    not running. Then it will schedule a new container to run, and by the time it
    starts up, the dependency should be available. If not, the new container will
    end, and Docker will schedule a replacement, and this will keep happening until
    the application is working correctly. If your legacy applications don't have any
    dependency checks, you can build this logic into the Docker image, using startup
    checks and health checks in the Dockerfile.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，容器应该退出，这样 Docker 就知道应用程序没有在运行。然后它将安排一个新的容器运行，并在启动时，依赖项应该是可用的。如果不是，新容器将结束，Docker
    将安排一个替代品，并且这将一直持续下去，直到应用程序正常工作。如果您的传统应用程序没有任何依赖检查，您可以将这种逻辑构建到 Docker 镜像中，使用 Dockerfile
    中的启动检查和健康检查。
- en: In some cases, that might not be possible, or it might be that new containers
    starting repeatedly cause a problem with your legacy application. You can still
    manually create services rather than deploying a stack. UCP supports this workflow
    too, and this lets you manually ensure that all the dependencies are running before
    you start each service.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可能是不可能的，或者可能是新容器的重复启动会导致您的传统应用程序出现问题。您仍然可以手动创建服务，而不是部署堆栈。UCP 也支持这种工作流程，这样可以手动确保所有依赖项在启动每个服务之前都在运行。
- en: This is the imperative approach to managing your apps, which you really should
    try to avoid. It's far better to encapsulate your application manifest in a simple
    set of Docker Compose files that can be managed in source control, but it may
    be difficult to do that with some legacy apps.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管理应用程序的命令式方法，你真的应该尽量避免使用。更好的方法是将应用程序清单封装在一组简单的Docker Compose文件中，这样可以在源代码控制中进行管理，但对于一些传统的应用程序可能会很难做到这一点。
- en: Creating services
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建服务
- en: 'There are dozens of options for the `docker service create` command. UCP supports
    them all in a guided UI, which you start with Create a Service from the services
    view. First, you specify the basic details, the name of the image to use for the
    service; the service name, which is how other services will discover this one;
    and the command arguments, if you want to override the default startup in the
    image:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker service create`命令有数十个选项。UCP在引导式UI中支持所有这些选项，您可以从服务视图中启动。首先，您需要指定基本细节，比如用于服务的镜像名称；服务名称，其他服务将通过该名称发现此服务；以及命令参数，如果您想要覆盖镜像中的默认启动命令。'
- en: '![](Images/6fc4a829-65d8-4dbd-8560-d98948433217.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6fc4a829-65d8-4dbd-8560-d98948433217.png)'
- en: 'I won''t cover all the details; they map to the options in the `docker service
    create` command, but the Scheduling tab is worth looking at. This is where you
    set the service mode to be replicated or global, add the required number of replicas,
    and the configuration for rolling updates:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会覆盖所有细节；它们与`docker service create`命令中的选项相对应，但是值得关注的是调度选项卡。这是您设置服务模式为复制或全局，添加所需副本数量以及滚动更新配置的地方。
- en: '![](Images/9053565b-46a2-4e08-a97f-f66405add85c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9053565b-46a2-4e08-a97f-f66405add85c.png)'
- en: The Restart Policy defaults to Always. This works in conjunction with the replica
    count, so if any tasks fail or are stopped, they will be restarted to maintain
    the service level. You can configure the update settings for automated roll-outs,
    and you can also add scheduling constraints. Constraints work with node labels
    to limit which nodes can be used to run service tasks. You can use this to restrict
    tasks to high-capacity nodes or to nodes that have strict access controls.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 重启策略默认为始终。这与副本计数一起工作，因此如果任何任务失败或停止，它们将被重新启动以维持服务水平。您可以配置自动部署的更新设置，还可以添加调度约束。约束与节点标签一起工作，限制可以用于运行服务任务的节点。您可以使用此功能将任务限制为高容量节点或具有严格访问控制的节点。
- en: In the other sections, you can configure how the service integrates with other
    resources in the cluster, including networks and volumes, configs, and secrets,
    and you can specify compute reservations and limits. This lets you restrict services
    to a limited amount of CPU and memory, and you can also specify a minimum share
    of CPU and memory that each container should have.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他部分，您可以配置服务与集群中其他资源的集成方式，包括网络和卷、配置和秘密，还可以指定计算保留和限制。这使您可以将服务限制在有限的CPU和内存量上，并且还可以指定每个容器应具有的CPU和内存的最小份额。
- en: When you deploy the service, UCP takes care of pulling the image on to any nodes
    that need it and starts the required number of containers. That would be one container
    per node for global services or the specified number of tasks for replicated services.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当您部署服务时，UCP会负责将镜像拉取到需要的任何节点上，并启动所需数量的容器。对于全局服务，每个节点将有一个容器，对于复制服务，将有指定数量的任务。
- en: Monitoring services
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控服务
- en: UCP lets you deploy any type of application in the same way, either with a stack
    compose file or by creating services. The application can use many services with
    any combination of technologies—parts of the new NerdDinner stack are running
    on Linux now in my hybrid cluster. I've deployed Java, Go, and Node.js components
    as Linux containers and .NET Framework and .NET Core components as Windows containers
    on the same cluster.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: UCP允许您以相同的方式部署任何类型的应用程序，可以使用堆栈组合文件或创建服务。该应用程序可以使用多个服务，任何技术组合都可以——NerdDinner堆栈的部分现在正在我的混合集群中的Linux上运行。我已经部署了Java、Go和Node.js组件作为Linux容器，以及.NET
    Framework和.NET Core组件作为Windows容器在同一个集群上运行。
- en: All these different technology platforms  are managed in the same way with UCP,
    which is what makes it such a valuable platform for companies with a large application
    estate. The service view shows all services with basic information, such as the
    overall status, the number of tasks, and the last time an error was reported.
    For any service, you can drill down into a detailed view that shows all the information
    about the service.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些不同的技术平台都可以通过UCP以相同的方式进行管理，这就是使其成为对于拥有大型应用程序资产的公司如此宝贵的平台。服务视图显示了所有服务的基本信息，例如总体状态、任务数量以及上次报告错误的时间。对于任何服务，您都可以深入到详细视图，显示有关服务的所有信息。
- en: 'This is the Overview tab of the core NerdDinner ASP.NET web app:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这是核心NerdDinner ASP.NET Web应用程序的概述选项卡：
- en: '![](Images/a5081765-3382-4623-a3bf-5e2a7dfb6feb.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/a5081765-3382-4623-a3bf-5e2a7dfb6feb.png)'
- en: I've scrolled this view so I can see the secrets that the service has available,
    along with the environment variables (none in this case), the labels, which include
    the Traefik routing setup and the constraints, including the platform constraint
    to ensure this runs on Windows nodes. The Metrics view shows me a graph of the
    CPU and memory usage, and a list of all the running containers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经滚动了这个视图，这样我就可以看到服务可用的秘密，以及环境变量（在这种情况下没有），标签，其中包括Traefik路由设置和约束，包括平台约束，以确保其在Windows节点上运行。指标视图向我显示了CPU和内存使用情况的图表，以及所有正在运行的容器的列表。
- en: You can use the service view to check the overall status of the service and
    make changes—you can add environment variables, change the networks or volumes,
    and change the scheduling constraints. Any changes you make to the service definition
    will be implemented by restarting the service, so you need to understand the application
    impact. Stateless apps and apps that gracefully handle transient failures can
    be amended on-the-fly, but there may be application downtime—depending on your
    solution architecture.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用服务视图来检查服务的总体状态并进行更改-您可以添加环境变量，更改网络或卷，并更改调度约束。对服务定义所做的任何更改都将通过重新启动服务来实施，因此您需要了解应用程序的影响。无状态应用程序和优雅处理瞬态故障的应用程序可以在运行时进行修改，但可能会有应用程序停机时间-这取决于您的解决方案架构。
- en: 'You can adjust the scale of the service without restarting existing tasks.
    Just specify the new level of scale in the Scheduling tab, and UCP will create
    or remove containers to meet the service level:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以调整服务的规模，而无需重新启动现有任务。只需在调度选项卡中指定新的规模级别，UCP将创建或删除容器以满足服务水平：
- en: '![](Images/aced9423-5414-406d-98d8-8d9b2c5f2c91.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/aced9423-5414-406d-98d8-8d9b2c5f2c91.png)'
- en: When you increase the scale, the existing containers are retained and new ones
    are added, so that won't affect the availability of your application (unless the
    app keeps the state in individual containers).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您增加规模时，现有的容器将被保留，新的容器将被添加，因此这不会影响您的应用程序的可用性（除非应用程序将状态保留在单独的容器中）。
- en: 'From the service view or the container list, under Shared Resources, you can
    select a task to drill down into the container view, which is where the consistent
    management experience makes administering Dockerized applications so straightforward.
    Every detail about the running container is surfaced, including the configuration
    and the actual process list inside the container. This is the container for my
    Traefik proxy, which just has the `traefik` process running:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务视图或容器列表中，在共享资源下，您可以选择一个任务来深入了解容器视图，这就是一致的管理体验，使得管理Docker化应用程序变得如此简单。显示了运行容器的每个细节，包括配置和容器内的实际进程列表。这是我的Traefik代理的容器，它只运行了`traefik`进程：
- en: '![](Images/77b433fa-222e-45e8-9eed-97b20eebef3f.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/77b433fa-222e-45e8-9eed-97b20eebef3f.png)'
- en: 'You can read the logs of the container, which show all the output from the
    container''s standard output streams. These are the logs from Elasticsearch, which
    is a Java application, so these are in `log4j` format:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以阅读容器的日志，其中显示了容器标准输出流的所有输出。这些是Elasticsearch的日志，它是一个Java应用程序，因此这些日志是以`log4j`格式的：
- en: '![](Images/718b5db5-c0cf-4b0e-88cf-9bf978e7995f.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/718b5db5-c0cf-4b0e-88cf-9bf978e7995f.png)'
- en: You can view the logs of any container in the cluster in the same way, whether
    it's a new Go app running in a minimal Linux container, or a legacy ASP.NET app
    running in a Windows container. This is why it's so important to build your Docker
    image so that log entries from your app are relayed out to the console.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以以相同的方式查看集群中任何容器的日志，无论是在最小的Linux容器中运行的新Go应用程序，还是在Windows容器中运行的传统ASP.NET应用程序。这就是为什么构建Docker镜像以便将应用程序的日志条目中继到控制台是如此重要的原因。
- en: 'You can even connect to a command-line shell running in the container, if you
    need to troubleshoot a problem. This is the equivalent of running `docker container
    exec -it powershell` in the Docker CLI, but all from the UCP interfaces so you
    don''t need to connect to a specific node on the cluster. You can run any shell
    that''s installed in the container image, so in the Kibana Linux image, I can
    use `bash`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以连接到容器中运行的命令行 shell，如果需要排除问题。这相当于在Docker CLI中运行`docker container exec -it
    powershell`，但都是从UCP界面进行的，因此您不需要连接到集群上的特定节点。您可以运行容器镜像中安装的任何 shell，在Kibana Linux镜像中，我可以使用`bash`：
- en: '![](Images/8a0a0818-0629-407e-83b2-8b2022582d98.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/8a0a0818-0629-407e-83b2-8b2022582d98.png)'
- en: UCP gives you an interface that lets you drill down from the overall health
    of the cluster, through the status of all the running services, to the individual
    containers running on specific nodes. You can easily monitor the health of your
    applications, check application logs, and connect to containers for debugging—all
    within the same management UI. You can also download a **client bundle**, which
    is a set of scripts and certificates you can use to securely manage the cluster
    from a remote Docker **command-line interface** (**CLI**) client.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: UCP为您提供了一个界面，让您可以从集群的整体健康状态，通过所有运行服务的状态，到特定节点上运行的个别容器。您可以轻松监视应用程序的健康状况，检查应用程序日志，并连接到容器进行调试
    - 这一切都在同一个管理界面中。您还可以下载一个**客户端捆绑包**，这是一组脚本和证书，您可以使用它们来从远程Docker **命令行界面**（**CLI**）客户端安全地管理集群。
- en: The client bundle script points your local Docker CLI to the Docker API running
    on the cluster manager and also sets up client certificates for secure communication.
    The certificates identify a specific user in UCP, whether they have been created
    in UCP or whether they're an external LDAP user. So, users can log into the UCP
    UI or use the `docker` commands to manage resources, and for both options, they
    will have the same access defined by the UCP RBAC policies.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端捆绑脚本将您的本地Docker CLI指向在集群管理器上运行的Docker API，并为安全通信设置客户端证书。证书标识了UCP中的特定用户，无论他们是在UCP中创建的还是外部LDAP用户。因此，用户可以登录到UCP
    UI或使用`docker`命令来管理资源，对于这两种选项，他们将具有UCP RBAC策略定义的相同访问权限。
- en: RBAC
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RBAC
- en: Authorization in UCP gives you fine-grained access control over all the Docker
    resources. RBAC in UCP is defined by creating a grant for a subject to access
    a resource set. The subject of a grant can be an individual user, a team of users,
    or an organization containing many teams. A resource set could be an individual
    resource, such as a Docker Swarm service, or a set of resources, such as all the
    Windows nodes in the cluster. The grant defines the level of access, from no access
    to full control.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: UCP中的授权为您提供对所有Docker资源的细粒度访问控制。UCP中的RBAC是通过为主体创建对资源集的访问授权来定义的。授权的主体可以是单个用户、一组用户或包含许多团队的组织。资源集可以是单个资源，例如Docker
    Swarm服务，也可以是一组资源，例如集群中的所有Windows节点。授权定义了访问级别，从无访问权限到完全控制。
- en: 'It''s a very flexible approach to security, because it allows you to enforce
    security rules at whatever level makes sense for your company. I can use an application-first
    approach, where I have a resource collection called `nerd-dinner` that represents
    the NerdDinner application, and this collection is the parent of other collections
    that represent deployment environments: production, UAT, and system test. The
    collection hierarchy is on the right-hand side of this diagram:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常灵活的安全方法，因为它允许您在公司的任何级别强制执行安全规则。我可以采用应用程序优先的方法，其中我有一个名为`nerd-dinner`的资源集合，代表NerdDinner应用程序，这个集合是其他代表部署环境的集合的父级：生产、UAT和系统测试。集合层次结构在此图表的右侧：
- en: '![](Images/5fcce0e5-c3dd-4779-8b2c-af4ada0805ec.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/5fcce0e5-c3dd-4779-8b2c-af4ada0805ec.png)'
- en: 'Collections are groups of resources—so I would deploy each environment as a
    stack with the resources all belonging to the relevant collection. Organizations
    are the ultimate grouping of users, and here I have a **nerd-dinner** organization
    shown on the left, which is the grouping of all the people who work on NerdDinner.
    In the organization, there are two teams: **Nerd Dinner Ops** are the application
    administrators, and **Nerd Dinner Testers** are the testers. There''s only one
    user shown in the diagram, **elton**, who is a member of the **Nerd Dinner Ops**
    team.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 集合是资源的组合 - 因此，我会将每个环境部署为一个堆栈，其中所有资源都属于相关的集合。组织是用户的最终分组，在这里我在左侧显示了一个**nerd-dinner**组织，这是所有在NerdDinner上工作的人的分组。在组织中，有两个团队：**Nerd
    Dinner Ops**是应用程序管理员，**Nerd Dinner Testers**是测试人员。在图表中只显示了一个用户**elton**，他是**Nerd
    Dinner Ops**团队的成员。
- en: 'This structure lets me create grants to give access to different resources
    at different levels:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构让我可以创建授权，以便在不同级别为不同资源提供访问权限：
- en: The **nerd-dinner** organization has **View Only** access to the **nerd-dinner**
    collection, which means any user in any team in the organization can list and
    view the details any of the resources in any environment.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nerd-dinner**组织对**nerd-dinner**集合具有**仅查看**权限，这意味着组织中任何团队的任何用户都可以列出并查看任何环境中任何资源的详细信息。'
- en: The **Nerd Dinner Ops** team also has **Restricted Control** over the **nerd-dinner**
    collection, which means they can run and manage resources in any environment.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nerd Dinner Ops**团队还对**nerd-dinner**集合具有**受限控制**，这意味着他们可以在任何环境中运行和管理资源。'
- en: The user **elton** in the **Nerd Dinner Ops** team also has **Full Control**
    over the **nerd-dinner-uat** collection, which gives full admin control to resources
    in the UAT environment.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nerd Dinner Ops**团队中的用户**elton**还对**nerd-dinner-uat**集合拥有**完全控制**，这为UAT环境中的资源提供了完全的管理员控制。'
- en: The **Nerd Dinner Testers** team has **Scheduler** access to the **nerd-dinner-test**
    collection, which means members of the team can manage nodes in the test environment.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nerd Dinner Testers**团队对**nerd-dinner-test**集合具有**调度程序**访问权限，这意味着团队成员可以管理测试环境中的节点。'
- en: The default roles for Docker Swarm collections are **View Only**, **Restricted
    Control**, **Full Control**, and **Scheduler**. You can create your own roles,
    and set specific permissions for specific types of resources.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm集合的默认角色是**仅查看**，**受限控制**，**完全控制**和**调度器**。您可以创建自己的角色，并为特定类型的资源设置特定权限。
- en: 'You create grants in UCP to create a role that links a subject to a set of
    resources, giving them known permissions. I''ve deployed the security access diagram
    in my Docker Enterprise cluster, and I can see my grants alongside the default
    system grants:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在UCP中创建授权以创建将主体与一组资源链接起来的角色，从而赋予它们已知的权限。我已在我的Docker Enterprise集群中部署了安全访问图表，并且我可以看到我的授权以及默认的系统授权：
- en: '![](Images/6c89cc56-1c9d-4066-a684-0a8fd8b70d1a.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6c89cc56-1c9d-4066-a684-0a8fd8b70d1a.png)'
- en: 'You create grants and collections independently of the resources you want to
    secure. Then you specify a collection when you create resources by adding a label,
    with the key `com.docker.ucp.access.label` and the value of the collection name.
    You can do this imperatively in Docker''s create commands, declaratively in Docker
    Compose files, and through the UCP UI. Here, I''ve specified that the reverse-proxy
    service belongs in the `nerd-dinner-prod` collection:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以独立于要保护的资源创建授权和集合。然后，在创建资源时，通过添加标签指定集合，标签的键为`com.docker.ucp.access.label`，值为集合名称。您可以在Docker的创建命令中以命令方式执行此操作，在Docker
    Compose文件中以声明方式执行此操作，并通过UCP UI执行此操作。在这里，我指定了反向代理服务属于`nerd-dinner-prod`集合：
- en: '![](Images/9b6f6205-6a0e-484f-bc98-825d666d4b17.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/9b6f6205-6a0e-484f-bc98-825d666d4b17.png)'
- en: 'If I log into UCP as a member of the Nerd Dinner Testers team, I will see only
    that one service. The test users don''t have access to view services from the
    default collection, and only the proxy service has been explicitly put into the
    `nerd-dinner-prod` collection:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以Nerd Dinner Testers团队成员的身份登录UCP，我只会看到一个服务。测试用户无权查看默认集合中的服务，只有代理服务明确放入了`nerd-dinner-prod`集合中：
- en: '![](Images/0e34116f-3197-4748-addd-5e1249dd100d.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/0e34116f-3197-4748-addd-5e1249dd100d.png)'
- en: 'As this user, I only have view access, so if I try to modify the service in
    any way—such as restarting it—I''ll get an error:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个用户，我只有查看权限，所以如果我尝试以任何方式修改服务，比如重新启动它，我会收到错误提示：
- en: '![](Images/6b0cd91d-15b3-40d0-bdd5-ae53ebf017a1.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/6b0cd91d-15b3-40d0-bdd5-ae53ebf017a1.png)'
- en: Teams can have multiple permissions for different resource sets, and users can
    belong to multiple teams, so the authorization system in UCP is flexible enough
    to suit many different security models. You could take a DevOps approach and build
    collections for specific projects, with all the team members getting complete
    control over the project resources, or you could have a dedicated admin team with
    complete control over everything. Or you could have individual developer teams,
    where the members have restricted control over the apps they work on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 团队可以对不同的资源集拥有多个权限，用户可以属于多个团队，因此UCP中的授权系统足够灵活，适用于许多不同的安全模型。您可以采用DevOps方法，为特定项目构建集合，所有团队成员都可以完全控制项目资源，或者您可以有一个专门的管理员团队，完全控制一切。或者您可以拥有单独的开发团队，团队成员对他们工作的应用程序有受限控制。
- en: RBAC is a major feature of UCP, and it complements the wider security story
    of Docker, which I will cover in [Chapter 9](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml),
    *Understanding the Security Risks and Benefits of Docker*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC是UCP的一个重要功能，它补充了Docker更广泛的安全故事，我将在[第9章](ea2edfd1-c625-4599-8ec2-d5ae811941ef.xhtml)中介绍，*理解Docker的安全风险和好处*。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter focused on the operations side of running Dockerized solutions.
    I showed you how to use existing Windows management tools with Docker containers
    and how that can be useful for investigation and debugging. The main focus was
    on a new way of administering and monitoring applications, using UCP in Docker
    Enterprise to manage all kinds of workloads in the same way.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍了运行Docker化解决方案的操作方面。我向您展示了如何将现有的Windows管理工具与Docker容器结合使用，以及这对于调查和调试是如何有用的。主要重点是使用Docker
    Enterprise中的UCP来管理各种工作负载的新方法。
- en: You learned how to use existing Windows management tools, such as IIS Manager
    and the server manager, to administer Docker containers, and you also learned
    about the limitations of this approach. Sticking with the tools you know can be
    useful when you start with Docker, but dedicated container management tools are
    a better option.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何使用现有的Windows管理工具，比如IIS管理器和服务器管理器，来管理Docker容器，您也了解了这种方法的局限性。在开始使用Docker时，坚持使用您已知的工具可能是有用的，但专门的容器管理工具是更好的选择。
- en: 'I covered two open source options to manage containers: the simple visualizer
    and the more advanced Portainer. Both run as containers and connect to the Docker
    API, and they are cross-platform apps packaged in Linux and Windows Docker images.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我介绍了两种开源选项来管理容器：简单的可视化工具和更高级的Portainer。它们都作为容器运行，并连接到Docker API，它们是在Linux和Windows
    Docker镜像中打包的跨平台应用程序。
- en: Lastly I walked you through the main features in Docker Enterprise used to manage
    production workloads. I demonstrated UCP as a single pane of glass to administer
    a diverse range of containerized applications, running in multiple technology
    stacks on Linux and Windows containers in the same cluster, and showed how RBAC
    lets you secure access to all of your Docker resources.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我向您介绍了Docker Enterprise中用于管理生产工作负载的主要功能。我演示了UCP作为一个单一的管理界面，用于管理在同一集群中以多种技术堆栈在Linux和Windows容器上运行的各种容器化应用程序，并展示了RBAC如何让您安全地访问所有Docker资源。
- en: The next chapter is focused on security. Applications running in containers
    potentially offer a new avenue of attack. You need to be aware of the risks, but
    security is at the center of the Docker platform. Docker lets you easily set up
    an end-to-end security story, where policies are enforced by the platform at runtime—something
    which is very hard to do without Docker.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍安全性。在容器中运行的应用程序可能提供了新的攻击途径。您需要意识到风险，但安全性是Docker平台的核心。Docker让您可以轻松地建立端到端的安全性方案，其中平台在运行时强制执行策略——这是在没有Docker的情况下很难做到的。
