- en: '*Chapter 7*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*'
- en: Advanced JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级JavaScript
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Test simple scripts using Node.js REPL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node.js REPL测试简单脚本
- en: Construct objects and arrays and modify their content
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造对象和数组并修改它们的内容
- en: Use object methods and operators to get information about the object
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用对象方法和运算符获取有关对象的信息
- en: Create simple JavaScript classes and classes that inherit from other classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建简单的JavaScript类和继承自其他类的类
- en: Use advanced built-in methods from Math, RegEx, Date, and String
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Math、RegEx、Date和String的高级内置方法
- en: Manipulate data in JavaScript using Array, Map, and Set methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组、Map和Set方法在JavaScript中操作数据
- en: Implement Symbols, Iterators, Generators, and Proxies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现符号、迭代器、生成器和代理
- en: In this chapter, we will work with arrays, classes, and objects in JavaScript,
    and then we will use inheritance and built-in methods in common JavaScript classes
    to simplify our code and make it highly reusable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用JavaScript中的数组、类和对象，然后我们将使用继承和常见JavaScript类中的内置方法来简化我们的代码并使其高度可重用。
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: When writing JavaScript code for medium to large projects (10+ files), it is
    helpful to understand all of the possible features that this language provides.
    It is always easier and quicker to use what is already there than reinvent the
    wheel. These built-in methods will not only help you with performing basic functions,
    but they will also help with code readability and maintainability. These built-in
    methods range from basic calculations to the complex array and string manipulation
    that developers face every day. By using these built-in methods, we can reduce
    our code size and help with the performance of our application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在为中大型项目（10+个文件）编写JavaScript代码时，了解语言提供的所有可能特性是有帮助的。使用已有的东西总比重新发明轮子更容易更快。这些内置方法不仅可以帮助您执行基本功能，还可以帮助提高代码的可读性和可维护性。这些内置方法涵盖了从基本计算到开发人员每天面临的复杂数组和字符串操作。通过使用这些内置方法，我们可以减少代码大小，并帮助提高应用程序的性能。
- en: JavaScript is usually used as a functional language, but you can use it for
    **Object-Oriented Programming** (**OOP**). In recent years, many new features,
    such as classes, have been added to the language in response to the growing need
    for JavaScript to accomplish more complex and data-driven tasks. While it is still
    possible to create JavaScript using function prototypes, many developers have
    moved on from doing so since it offers a much closer syntax, similar to popular
    OOP languages such as C++, Java, and C#.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通常用作函数式语言，但您也可以将其用于**面向对象编程**（**OOP**）。近年来，为了满足JavaScript完成更复杂和数据驱动的任务的不断增长的需求，语言中添加了许多新功能，例如类。虽然仍然可以使用函数原型创建JavaScript，但许多开发人员已经放弃了这样做，因为它提供了更接近流行的OOP语言（如C++、Java和C#）的语法。
- en: In this chapter, we will explore the vast number of built-in methods that JavaScript
    provides us with. We will use Node.js **REPL** (**Read-Eval-Print Loop**) to test
    our code as this doesn't require us to create any files on the disk or invoke
    any special commands.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索JavaScript提供的大量内置方法。我们将使用Node.js **REPL**（**读取-求值-打印循环**）来测试我们的代码，因为这不需要我们在磁盘上创建任何文件或调用任何特殊命令。
- en: Language Features Supported in ES5, ES6, ES7, ES8, and ES9
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ES5、ES6、ES7、ES8和ES9支持的语言特性
- en: 'Before we dive into the depths of these amazing language features, let''s take
    a look at the different versions of JavaScript. Currently, most websites that
    you regularly come across that still support legacy browsers use ES5\. As of 2019,
    many mainstream browsers have already added support for ES6\. Later versions will
    only have minimal browser support. Since we will be running and testing our code
    in a Node.js runtime, we don''t have to worry about version compatibility as long
    as we are using the latest LTS (long term support) version of Node.js. Regarding
    the materials that will be used in this chapter, here is a breakdown of the minimum
    ES version your runtime needs to support:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解这些令人惊奇的语言特性之前，让我们先看一下不同版本的JavaScript。目前，大多数您经常遇到的支持旧版浏览器的网站使用ES5。截至2019年，许多主流浏览器已经添加了对ES6的支持。后续版本将只有最小的浏览器支持。由于我们将在Node.js运行时中运行和测试我们的代码，只要我们使用最新的LTS（长期支持）版本的Node.js，就不必担心版本兼容性。关于本章将使用的材料，以下是您的运行时需要支持的最低ES版本的详细说明：
- en: '![Figure 7.1: Minimum required ES version'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1：最低要求的ES版本'
- en: '](Images/C14587_07_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_01.jpg)'
- en: 'Figure 7.1: Minimum required ES version'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.1：最低要求的ES版本
- en: In this chapter, we won't be switching runtimes, but in the future, it is best
    to check the language support on the runtime you are going to be developing for
    before getting started.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会切换运行时，但在将来，在开始之前最好先检查您要开发的运行时的语言支持。
- en: Working in the Node.js REPL
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Node.js REPL中工作
- en: We won't be doing anything too complex in this chapter, so we are going to write
    our code in the `Node.js` REPL. This allows us to test some ideas before we start
    coding without the need to create any files. Before we start, make sure you have
    Node.js installed on your computer and you have opened a Terminal application.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会做任何太复杂的事情，所以我们将在`Node.js` REPL中编写我们的代码。这样可以让我们在开始编码之前测试一些想法，而无需创建任何文件。在开始之前，请确保您的计算机上已安装了Node.js，并且已打开终端应用程序。
- en: Executing the Node.js REPL
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行Node.js REPL
- en: 'Every Node.js installation includes a node executable that allows you to run
    local JavaScript files or start the REPL. To run the Node.js executable as a REPL,
    all you need to do is type the `node` command in your favorite Terminal without
    any parameters. To test our Node.js installation, you can run the `node -v` command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Node.js安装都包括一个node可执行文件，允许您运行本地JavaScript文件或启动REPL。要将Node.js可执行文件作为REPL运行，您只需在您喜欢的终端中输入`node`命令，不带任何参数。要测试我们的Node.js安装，您可以运行`node
    -v`命令：
- en: '![Figure 7.2: Testing the Node.js installation'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2：测试Node.js安装'
- en: '](Images/C14587_07_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_02.jpg)'
- en: 'Figure 7.2: Testing the Node.js installation'
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.2：测试Node.js安装
- en: If you see an output like this, it means you have `Node.js` installed correctly.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到这样的输出，这意味着你已经正确安装了`Node.js`。
- en: Note
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: This command outputs the currently running version of the `Node.js` runtime,
    so it is also a very good way to check the current version. For this book, we
    will be using the current LTS, that is, v10.16.0.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令输出当前运行的`Node.js`运行时版本，因此这也是一个非常好的检查当前版本的方法。对于本书，我们将使用当前的LTS，即v10.16.0。
- en: 'After we have verified our Node.js installation, to run the node command in
    REPL mode, all you need to do is type `node` in your Command Prompt:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证了我们的Node.js安装之后，要以REPL模式运行node命令，你只需要在命令提示符中输入`node`：
- en: '![Figure 7.3: Running the node command in REPL mode'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3：在REPL模式下运行node命令'
- en: '](Images/C14587_07_03.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_03.jpg)'
- en: 'Figure 7.3: Running the node command in REPL mode'
  id: totrans-35
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.3：在REPL模式下运行node命令
- en: If you can see a cursor waiting for your input, congratulations – you have successfully
    entered the REPL mode of Node.js! From now on, you can start typing code into
    the prompt and pressing Enter to evaluate it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到一个等待你输入的光标，恭喜你——你已经成功进入了Node.js的REPL模式！从现在开始，你可以开始在提示符中输入代码，然后按Enter键进行评估。
- en: Array Manipulation in JavaScript
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的数组操作
- en: Creating arrays and modifying its content in JavaScript is very easy. Unlike
    other languages, creating arrays in JavaScript doesn't require you to specify
    the data type or size because these can be changed on request later.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建数组并修改其内容非常容易。与其他语言不同，在JavaScript中创建数组不需要指定数据类型或大小，因为这些可以在以后根据需要更改。
- en: 'To create a JavaScript array, use the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个JavaScript数组，请使用以下命令：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that, in JavaScript, there is no need to define the size or the type of
    items in the array.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在JavaScript中，不需要定义数组中的大小或类型。
- en: 'To create an array with elements predefined, use the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有预定义元素的数组，请使用以下命令：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To access and modify items in an array, use the following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问和修改数组中的项目，请使用以下命令：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is very similar to other programming languages when accessing the array.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这与访问数组时其他编程语言非常相似。
- en: 'Exercise 37: Creating and Modifying an Array'
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习37：创建和修改数组中的项目
- en: 'In this exercise, we will be creating a simple array and exploring its value
    using the REPL. The syntax for creating an array is very similar to many other
    scripting languages. We will create an array of `singers` in two ways: one is
    using the `Array` constructor and the other is to use an array literal way. Once
    we have created the array, we will then manipulate the contents of the array.
    Let''s get started:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个简单的数组，并使用REPL来探索它的值。创建数组的语法与许多其他脚本语言非常相似。我们将以两种方式创建`singers`数组：一种是使用`Array`构造函数，另一种是使用数组文字方式。一旦我们创建了数组，我们将操纵数组的内容。让我们开始吧：
- en: 'Use the array literal method to create an empty array and test it is successfully
    created afterward:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组文字方法创建一个空数组并测试它是否成功创建后：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will use the `Array` constructor to do the same. While they yield the
    same result, the constructor allows more flexibility:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用`Array`构造函数来做同样的事情。虽然它们产生相同的结果，但构造函数允许更多的灵活性：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice we are not using `typeof` to check the type of the array because, in
    JavaScript, array is a type of object. If we were to use `typeof` on the array
    we just created, we would get an unexpected result:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有使用`typeof`来检查数组的类型，因为在JavaScript中，数组是对象的一种类型。如果我们在刚刚创建的数组上使用`typeof`，我们会得到一个意外的结果：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create arrays with a predefined size and items. Note that JavaScript arrays
    will automatically resize as you add items to the array:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建具有预定义大小和项目的数组。请注意，随着向数组添加项目，JavaScript数组将自动调整大小：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we have an array initialized that has an initial size of `6`.
    We also used the `fill` method to predefine all the items in our array. This is
    very useful when we want to use the array to keep track of flags in our application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们初始化了一个具有初始大小为`6`的数组。我们还使用了`fill`方法来预定义数组中的所有项目。当我们想要使用数组来跟踪应用程序中的标志时，这是非常有用的。
- en: 'Assign a value to index `0`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为索引`0`分配一个值：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Assign any arbitrary index for a JavaScript array. The indexes without assignment
    will simply be `undefined`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为JavaScript数组分配任意索引。未分配的索引将简单地是`undefined`：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Modify the item at the end of the array using the array''s length:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组的长度修改数组末尾的项目：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Thus, we have learned how we can define arrays in JavaScript. These arrays behave
    similar to other languages and they are also auto-expanded so that you don't have
    to worry about manually resizing the array. In the next exercise, we will go over
    how to add items to the array.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经学会了如何在JavaScript中定义数组。这些数组的行为类似于其他语言，它们也会自动扩展，因此你不必担心手动调整数组的大小。在下一个练习中，我们将讨论如何向数组中添加项目。
- en: 'Exercise 38: Adding and Removing Items'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习38：添加和删除项目
- en: 'It''s very easy to add and remove items from JavaScript arrays, which we have
    to do in many applications where we have to accumulate a number of items. In this
    exercise, we are going to modify the existing `singers` array we created previously.
    Let''s get started:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，很容易添加和删除数组中的项目，在许多应用程序中我们必须累积许多项目。在这个练习中，我们将修改之前创建的`singers`数组。让我们开始吧：
- en: 'Start with an empty array:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个空数组开始：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a new item to the end of an array using `push`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`push`在数组末尾添加一个新项目：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `push` method will always add the item to the end of the array, even if
    you have items in the array that are `undefined`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`方法将始终将项目添加到数组的末尾，即使数组中有`undefined`的项目：'
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see in the preceding code, if you have an array that of a predefined
    size, using `push` will expand the array and add it to the end of the array instead
    of just adding it to the beginning
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在上面的代码中所看到的，如果你有一个预定义大小的数组，使用`push`将会扩展数组并将其添加到数组的末尾，而不是只将其添加到开头
- en: 'Remove an item from the end of an array:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组末尾删除一个项目：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add an item to the beginning of an array:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在数组开头添加一个项目：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Remove items from the beginning of an array:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组的开头移除项目：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These are very useful in a larger scale application, such as if you are building
    a simple web application that processes images. When a request comes in, you can
    push the image data, the job ID, and even the client connection to an array, which
    means that the JavaScript array can be of any type. You can have another worker
    calling `pop` on the array to retrieve the jobs and then process them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在更大规模的应用程序中，这些非常有用，比如如果您正在构建一个处理图像的简单Web应用程序。当请求到来时，您可以将图像数据、作业ID甚至客户端连接推送到数组中，这意味着JavaScript数组可以是任何类型。您可以有另一个工作人员在数组上调用`pop`来检索作业，然后处理它们。
- en: 'Exercise 39: Getting Information About the Items in Your Array'
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习39：获取数组中项目的信息
- en: 'In this exercise, we will go over various basic ways to get information about
    the items in your array. These functions are very helpful when we are working
    on applications that need to manipulate the data. Let''s get started:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍获取有关数组中项目的各种基本方法。当我们在处理需要操作数据的应用程序时，这些函数非常有帮助。让我们开始吧：
- en: 'Create an empty array and push items to it:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空数组并向其中推送项目：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Find the index of an item:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找项目的索引：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Find the number of items in the array:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找数组中项目的数量：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remove an item from a certain index in the array. We will do this by storing
    the position of the item we want to remove into a variable position. After we
    know where we want to remove the item, we can call `array.splice` to remove it:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从数组中的特定索引中移除一个项目。我们将通过将要移除的项目的位置存储到一个变量中来实现这一点。知道我们要移除项目的位置后，我们可以调用`array.splice`来移除它：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`array.splice` can also be used to insert/replace items into the array at a
    specific index. We will go over the specifics of that function later. When we
    are using it, we are supplying it with two parameters. The first one tells splice
    where to start, and the next one tells it how many items to delete from the start
    position. Since we only want to remove the item at that index, we are supplying
    it with 1.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`array.splice`也可以用于在特定索引处插入/替换项目到数组中。我们将在后面详细介绍该函数的具体情况。当我们使用它时，我们提供它两个参数。第一个告诉splice从哪里开始，下一个告诉它从起始位置删除多少个项目。因为我们只想删除该索引处的项目，所以我们提供1。'
- en: In this exercise, we explored ways to get more information about the array.
    Trying to locate the index of a specific item is very useful in building applications.
    Using these built-in methods is very useful because you don't need to iterate
    through the array to find the item yourself. In the next activity, we will be
    building a simple user tracker using the ID of the user.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们探讨了获取有关数组更多信息的方法。尝试定位特定项目的索引在构建应用程序中非常有用。使用这些内置方法非常有用，因为您不需要通过数组来查找项目。在下一个活动中，我们将使用用户的ID构建一个简单的用户跟踪器。
- en: 'Activity 8: Creating a User Tracker'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动8：创建用户跟踪器
- en: Suppose you are building a website and you want to track how many people are
    currently viewing it. In order to do this, you decide to keep a list of users
    in your backend. When a user opens your website, you will update the list to include
    that user, and when that user closes your website, you will remove that user from
    the list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在构建一个网站，并且想要跟踪当前有多少人正在查看它。为了做到这一点，您决定在后端保留一个用户列表。当用户打开您的网站时，您将更新列表以包括该用户，当该用户关闭您的网站时，您将从列表中删除该用户。
- en: For this activity, we will have a list called `users`, which stores a list of
    strings, and a couple of helper functions to help store and remove the users from
    the list.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此活动，我们将有一个名为`users`的列表，其中存储了一系列字符串，以及一些辅助函数来帮助存储和删除列表中的用户。
- en: In order to do this, we need to define a function that takes our list of users
    and modifies it to our liking.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要定义一个函数，该函数接受我们的用户列表并对其进行修改以符合我们的要求。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此活动的步骤如下：
- en: Create the `Activity08.js` file.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Activity08.js`文件。
- en: Define a `logUser` function, which will add the user to the `userList` argument
    supplied and make sure no duplicates are added.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`logUser`函数，它将添加用户到提供的`userList`参数中，并确保不添加重复项。
- en: Define a `userLeft` function. It will remove the user from the `userList` argument
    supplied in the argument.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`userLeft`函数。它将从提供的`userList`参数中移除用户。
- en: Define a `numUsers` function, which returns the number of users currently inside
    the list.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`numUsers`函数，它返回当前列表中的用户数量。
- en: Define a function called `runSite`. This will be used to test our implementation.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个名为`runSite`的函数。这将用于测试我们的实现。
- en: Note
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 607.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第607页找到。
- en: In this activity, we explored one of the ways in which we can use arrays to
    accomplish certain tasks in JavaScript. We can use it to keep track of a list
    of items and use the built-in methods to add and remove items. The reason we are
    seeing **user3**, **user5**, and **user6** is because these users were never removed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们探讨了在JavaScript中使用数组完成某些任务的一种方式。我们可以使用它来跟踪项目列表，并使用内置方法来添加和删除项目。我们看到**user3**、**user5**和**user6**是因为这些用户从未被移除。
- en: Object Manipulation in JavaScript
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript中的对象操作
- en: Creating basic objects in JavaScript is very easy and objects are used in every
    JavaScript application out there. A JavaScript object also includes a collection
    of built-in methods for you to use. These methods are very helpful when we are
    writing our code because it makes developing in JavaScript very easy and fun.
    In this section, we will examine how to create objects in our code and how we
    can use them to maximize their potential.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中创建基本对象非常容易，并且对象在每个JavaScript应用程序中都被使用。JavaScript对象还包括一系列内置方法供您使用。当我们编写代码时，这些方法非常有帮助，因为它使得在JavaScript中开发非常容易和有趣。在本节中，我们将研究如何在我们的代码中创建对象以及如何最大限度地利用它们的潜力。
- en: 'To create an object in JavaScript, use the following command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在JavaScript中创建一个对象，请使用以下命令：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By using the `{}` notation, we are defining an empty object and assigning it
    to our variable name.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`{}`符号，我们正在定义一个空对象并将其分配给我们的变量名。
- en: 'We can use objects to store many numbers of key-value pairs in our application:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用对象在我们的应用程序中存储许多键值对的数字：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we want to access the value, this is also quite easy:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要访问值，这也很容易：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In JavaScript, creating an object doesn''t mean having to follow a specific
    schema. You can put any number of properties within the object. Just make sure
    that none of the object keys are duplicated:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，创建对象并不意味着必须遵循特定的模式。您可以在对象中放入任意数量的属性。只需确保对象键没有重复：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Notice that the syntax for a new object is very similar to the JSON notation.
    There are times where we need to know exactly what kind of information is in our
    object.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新对象的语法与JSON表示法非常相似。有时我们需要确切知道对象中有什么样的信息。
- en: 'You can create an object user with some properties:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以创建一个具有一些属性的用户对象：
- en: '[PRE24]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In order to get all the property names, you need to use the `keys` method,
    as shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有属性名称，您需要使用`keys`方法，如下所示：
- en: '[PRE25]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also test whether a property exists. Let''s check this for a property
    that has not been defined:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试属性是否存在。让我们检查尚未定义的属性：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let''s check this for the properties that we defined previously:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查我们之前定义的属性：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a very simple way of testing whether the property exists in an object.
    In a lot of applications, this is used frequently to check the existence of the
    field and, if it doesn't exist, a default value will be set. Just keep in mind
    that, in JavaScript, an empty string, an empty array, the number zero, and other
    falsy values will be evaluated to `false` by the `if` statement. In the following
    exercise, we will try to create an object with a lot of information and output
    very useful information from it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是测试属性是否存在于对象中的一种非常简单的方法。在许多应用程序中，这经常用于检查字段的存在性，如果不存在，则将设置默认值。只需记住，在JavaScript中，空字符串、空数组、数字零和其他虚假值将被`if`语句评估为`false`。在下一个练习中，我们将尝试创建一个包含大量信息并从中输出非常有用信息的对象。
- en: 'Exercise 40: Creating and Modifying Objects in JavaScript'
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习40：在JavaScript中创建和修改对象
- en: 'In this exercise, we will store objects inside an array and modify the array
    by making changes to the object. We will then check how we can access an object
    using its properties. We will keep using the `singers` array we defined earlier,
    but this time instead of only storing a list of strings, we will use objects.
    Let''s get started:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在数组中存储对象，并通过对对象进行更改来修改数组。然后，我们将检查如何使用其属性访问对象。我们将继续使用之前定义的`singers`数组，但这次不仅存储字符串列表，而是使用对象。让我们开始吧：
- en: 'Set the `singers` array to an empty array:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`singers`数组设置为空数组：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Push an object to the array:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象推送到数组中：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Modify the `name` property of the first object inside the array:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改数组中第一个对象的`name`属性：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It's very simple to modify values in an object; for example, you can assign
    any value to the property, but it doesn't stop there. You can also add properties
    that weren't originally part of the object to expand its information.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 修改对象中的值非常简单；例如，您可以将任何值分配给属性，但不仅如此。您还可以添加原本不是对象一部分的属性，以扩展其信息。
- en: 'Add a property called `birthday` to the object:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向对象添加一个名为`birthday`的属性：
- en: '[PRE31]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To add properties to an existing object, simply assign a value to a property
    name. This will create that property if it doesn't exist. You can assign any value
    to the property, functions, arrays, or other objects.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要向现有对象添加属性，只需将值分配给属性名称。如果该属性不存在，将创建该属性。您可以将任何值分配给属性，函数、数组或其他对象。
- en: 'Read the property in the object by executing the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下代码读取对象中的属性：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, accessing the property value of an object is very simple in
    JavaScript. If you already know the name of the value, you can just use dot notation.
    In some cases where the property name is dynamic or from a variable, you can use
    bracket notation to access the property value of that property name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，访问JavaScript对象的属性值非常简单。如果您已经知道值的名称，只需使用点表示法。在某些情况下，属性名称是动态的或来自变量，您可以使用括号表示法来访问该属性名称的属性值。
- en: In this exercise, we went over ways to create an object in JavaScript and how
    to modify and add properties to it. JavaScript objects, just like arrays, are
    very easy to modify and they do not need you to specify a schema. In the next
    activity, we will build a very interesting utility that can help you understand
    how objects work across networks and how to efficiently use them.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了在JavaScript中创建对象的方法以及如何修改和添加属性。JavaScript对象和数组一样，非常容易修改，而且不需要您指定模式。在下一个活动中，我们将构建一个非常有趣的实用程序，可以帮助您了解对象在网络中的工作方式以及如何有效地使用它们。
- en: JSON.stringify
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON.stringify
- en: '`JSON.stringify` is a very useful utility that converts a JavaScript object
    into a formatted string. Later, the string can be transmitted over the network.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSON.stringify`是一个非常有用的实用程序，它将JavaScript对象转换为格式化的字符串。稍后，可以通过网络传输字符串。'
- en: 'For example, let''s say we have a `user` object that we want to convert it
    into a string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个`user`对象，我们想将其转换为字符串：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If we want to convert our object into a string, we need to call `JSON.stringify`
    with this object, as shown in the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将对象转换为字符串，我们需要使用`JSON.stringify`调用此对象，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will get a result like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到这样的结果：
- en: '![Figure 7.4: Result using JSON.stringify'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.4：使用JSON.stringify的结果'
- en: '](Images/C14587_07_04.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_04.jpg)'
- en: 'Figure 7.4: Result using JSON.stringify'
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.4：使用JSON.stringify的结果
- en: As you can see, calling `JSON.stringify` has converted our object into a string
    representation of the object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，调用`JSON.stringify`已将我们的对象转换为对象的字符串表示。
- en: But because of the way it is implemented, `JSON.stringify` is very inefficient.
    Although the performance difference is not apparent in most applications, in high-performance
    applications, a little bit of performance does matter. One way to make a faster
    `JSON.stringify` utility is to know which property you need in the final output.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于它的实现方式，`JSON.stringify`非常低效。尽管在大多数应用程序中性能差异并不明显，在高性能应用程序中，性能确实很重要。使`JSON.stringify`更快的一种方法是知道你需要最终输出中的哪些属性。
- en: 'Exercise 41: Creating an Efficient JSON.Stringify'
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习41：创建一个高效的JSON.Stringify
- en: 'Our objective is to write a simple function that takes an object and a list
    of properties to be included in the final output. The function will then call
    `JSON.stringify` to create the string version of the object. Let''s define a function
    called `betterStringify` in the `Exercise41.js` file:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是编写一个简单的函数，该函数接受一个对象和要包含在最终输出中的属性列表。然后，该函数将调用`JSON.stringify`来创建对象的字符串版本。让我们在`Exercise41.js`文件中定义一个名为`betterStringify`的函数：
- en: 'Create the `betterStringify` function:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`betterStringify`函数：
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, we will create a temporary output. We will store the property we want
    to be included in `propertyMap`:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个临时输出。我们将存储我们想要包含在`propertyMap`中的属性：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Iterate through our `propertyMap` argument to cherry-pick the property we want
    to include:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历我们的`propertyMap`参数以挑选我们想要包含的属性：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because our `propertyMap` argument is an array, we want to use `forEach` to
    iterate through it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`propertyMap`参数是一个数组，我们希望使用`forEach`来对其进行迭代。
- en: 'Assign the value from our item to the temporary output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值从我们的项目分配给临时输出：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are checking whether the key in our `propertyMap` argument is set.
    If it is set, we will store the value in our `output` property.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在检查我们的`propertyMap`参数中的键是否已设置。如果已设置，我们将把值存储在我们的`output`属性中。
- en: 'Use a function on a test object:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试对象上使用一个函数：
- en: '[PRE39]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After finishing the function, running the file will produce the following output:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 完成函数后，运行文件将产生以下输出：
- en: '![Figure 7.5: Output of running better_stringify.js'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5：运行better_stringify.js的输出'
- en: '](Images/C14587_07_05.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_05.jpg)'
- en: 'Figure 7.5: Output of running Exercise41.js'
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.5：运行Exercise41.js的输出
- en: 'Now, it''s time to answer the tough question: just how fast can you make your
    code if you did something like this?'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候回答一个棘手的问题了：如果你像这样做了一些事情，你的代码会有多快？
- en: 'If you run a benchmark on this over `JSON.stringify`, you will see a 30% performance
    gain:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此进行基准测试，你会看到比`JSON.stringify`快30%的性能提升：
- en: '![Figure 7.6 Performance difference between JSON.stringify and ouR method'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.6 JSON.stringify和我们的方法之间的性能差异'
- en: '](Images/C14587_07_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_06.jpg)'
- en: Figure 7.6 Performance difference between JSON.stringify and ouR method
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.6：JSON.stringify和我们的方法之间的性能差异
- en: That's 30% more time you can spend calculating more important stuff. Note that
    this is a very bare-bones example of what you can do if you cherry-pick your properties
    rather than dumping everything using `JSON.stringify`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你可以用来挑选属性而不是使用`JSON.stringify`来转储所有内容的一个非常基本的例子。
- en: Array and Object Destructuring
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和对象的解构赋值
- en: In the previous exercises and activities, we went over basic ways to modify
    values in objects and arrays and ways to get more information from them. There
    is also a way to retrieve values from the array or object using **destructuring
    assignment**.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习和活动中，我们讨论了修改对象和数组中的值的基本方法，以及从中获取更多信息的方法。还有一种方法可以使用**解构赋值**从数组或对象中检索值。
- en: 'Consider you have been given a list of parameters you need to assign to variables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经得到了一个需要分配给变量的参数列表：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'One way to assign them is to access each item in the array:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一种分配它们的方法是访问数组中的每个项目：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can also simplify this into one line by using destructuring:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用解构赋值将其简化为一行：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Exercise 42: Using Destructuring Assignment for an Array'
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习42：使用数组的解构赋值
- en: 'In this exercise, we will declare an array called `userInfo`. It will include
    basic user information. We will also declare a couple of variables so that we
    can store the item inside the array by using the destructuring assignment. Let''s
    get started:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将声明一个名为`userInfo`的数组。它将包括基本的用户信息。我们还将声明一些变量，以便我们可以使用解构赋值将数组中的项目存储起来。让我们开始吧：
- en: 'Create the `userInfo` array:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`userInfo`数组：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Create the variables for storing `name`, `age`, and `job:`
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于存储`name`、`age`和`job`的变量：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Use the destructuring assignment syntax to assign values to our variables:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用解构赋值语法将值分配给我们的变量：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Check our values:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 检查我们的值：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can also ignore values inside the array using the following code:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以使用以下代码忽略数组中的值：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The destructuring assignment is very useful when you are dealing with data that
    is not exactly formatted the way you like. It can also be used to pick items you
    want inside the array.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解构赋值在处理数据时非常有用，因为数据的格式通常不是你所期望的。它还可以用来挑选数组中你想要的项目。
- en: 'Exercise 43: Using Destructuring Assignment for an Object'
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习43：使用对象的解构赋值
- en: 'In the previous exercise, we declared an array with the user''s information,
    and we used destructuring assignment to retrieve some values from it. A similar
    thing can be done to objects as well. In this exercise, we will try destructuring
    assignment on objects. Let''s get started:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们声明了一个包含用户信息的数组，并使用解构赋值从中检索了一些值。同样的事情也可以用于对象。在这个练习中，我们将尝试对对象使用解构赋值。让我们开始吧：
- en: 'Create an object called `userInfo`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`userInfo`的对象：
- en: '[PRE48]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Create the variables we will use to store the information:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们将用来存储信息的变量：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the destructuring assignment syntax to assign values:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用解构赋值语法来分配值：
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Check the values:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查这些值：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note that when using deconstructing assignment on an object, it acts like a
    filter where the variable name must match, and you can selectively choose which
    property in the array you want to select. There is also a different way of using
    this on objects that don't require you to predeclare the variables.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在对象上使用解构赋值时，它的作用类似于一个过滤器，其中变量名必须匹配，并且您可以有选择地选择要选择的数组中的属性。还有一种不需要预先声明变量的对象使用方式。
- en: 'Use deconstructing assignment with the arrays:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组进行解构赋值：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use the destructuring operator to create a variable from the object values:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用解构运算符从对象值创建变量：
- en: '[PRE53]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following is the output of the preceding code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.7: Output of the job variable'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.7：作业变量的输出'
- en: '](Images/C14587_07_07.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_07.jpg)'
- en: 'Figure 7.7: Output of the job variable'
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.7：作业变量的输出
- en: In this exercise, we went over how we can use the destructuring operator to
    extract specific information from our objects and arrays. This is very useful
    when we are dealing with a lot of information and we only want to transfer a subset
    of that information.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了如何使用解构运算符从对象和数组中提取特定信息。当我们处理大量信息并且只想传输该信息的子集时，这非常有用。
- en: Spread Operators
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展开运算符
- en: In the previous exercise, we went over some ways in which we can get specific
    information from objects or arrays. There is another operator that can help us
    expand arrays or objects. The spread operator was added to the ES6 specification,
    but in ES9, it also added support for object spread. The spread operator's function
    is to spread each item into individual items. In the case of arrays, when we use
    the spread operator, we can treat it as a list of separate values. For objects,
    they will be spread into key-value pairs. In the next exercise, we will explore
    different ways we can use the spread operator in our application.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们讨论了从对象或数组中获取特定信息的一些方法。还有另一个运算符可以帮助我们展开数组或对象。展开运算符被添加到ES6规范中，但在ES9中，它还添加了对对象展开的支持。展开运算符的功能是将每个项目展开为单独的项目。对于数组，当我们使用展开运算符时，我们可以将其视为单独值的列表。对于对象，它们将展开为键值对。在下一个练习中，我们将探索在应用程序中使用展开运算符的不同方式。
- en: 'To use the spread operator, we use three dots (`…`) before any iterrable object,
    like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用展开运算符，我们在任何可迭代对象之前使用三个点（`…`），就像这样：
- en: '[PRE54]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Exercise 44: Using Spread Operators'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习44：使用展开运算符
- en: In this exercise, we are going to see how the spread operator can help us. We
    will use the original `userInfo` array from the previous exercise.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到展开运算符如何帮助我们。我们将使用上一个练习中的原始`userInfo`数组。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create the `userInfo` array:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`userInfo`数组：
- en: '[PRE55]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create a function that prints out the user''s information:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个打印用户信息的函数：
- en: '[PRE56]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Spread the array into a list of arguments:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将数组展开为参数列表：
- en: '[PRE57]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As you can see, the original way to call this function without the spread operator
    is to use the array access operator and repeat this for each argument. Since the
    ordering of the array matches the respective arguments, we can just use the spread
    operator.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，调用这个函数的原始方式，没有使用展开运算符，是使用数组访问运算符，并为每个参数重复这样做。由于数组的排序与相应的参数匹配，我们可以只使用展开运算符。
- en: 'Use the spread operator when you want to merge arrays:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你想要合并数组时使用展开运算符：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use the spread operator as a way to copy an array:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用展开运算符作为复制数组的一种方式：
- en: '[PRE59]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Using the spread operator on objects is much more powerful and practical.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上使用展开运算符要强大得多且实用。
- en: 'Create a new object called `userRequest`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`userRequest`的新对象：
- en: '[PRE60]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Clone the object using the `object` spread:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`object`展开克隆对象：
- en: '[PRE61]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create an object that includes every property of this object:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含此对象的每个属性的对象：
- en: '[PRE62]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You can see that the spread operator is very useful when you want to copy all
    the properties over to a new object. You can see this being used in many applications
    where you want to wrap a user request with some generic properties for further
    processing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，当您想要复制所有属性到一个新对象时，展开运算符非常有用。您可以在许多应用程序中看到它的使用，其中您希望用一些通用属性包装用户请求以进行进一步处理。
- en: Rest Operators
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 剩余运算符
- en: In the previous section, we looked at spread operators. The same operator can
    also be used in a different way. In function declarations, they are called **rest
    operators**.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看了展开运算符。同样的运算符也可以以不同的方式使用。在函数声明中，它们被称为**剩余运算符**。
- en: 'Rest operators are mainly used to represent an indefinite number of arguments.
    Then, the arguments will be placed in an array:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余运算符主要用于表示无限数量的参数。然后，参数将被放入一个数组中：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As you can see, we used the same three dots before the name. This tells our
    code that we are expecting an indefinite number of arguments for this function.
    When we do call the function with a list of arguments, they will be put inside
    a JavaScript array:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在名称前使用了相同的三个点。这告诉我们的代码，我们期望这个函数有无限数量的参数。当我们使用参数列表调用函数时，它们将被放入一个JavaScript数组中：
- en: '![Figure 7.8: Output of sum when called with a list of numbers'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.8：当使用数字列表调用sum时的输出'
- en: '](Images/C14587_07_08.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_08.jpg)'
- en: 'Figure 7.8: Output of sum when called with a list of numbers'
  id: totrans-254
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.8：当使用数字列表调用sum时的输出
- en: 'That doesn''t mean you don''t have any control over the number of arguments.
    You can write your function declaration like this to let JavaScript map several
    parameters to your liking and the rest into an array:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着你对参数的数量没有任何控制。您可以像这样编写函数声明，让JavaScript将多个参数映射到您喜欢的方式，并将其余参数放入数组中：
- en: '[PRE64]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This maps the first parameter to the variable initial, and the rest to an array
    called `numbers`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这将第一个参数映射到名为initial的变量，其余参数映射到名为`numbers`的数组：
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following is the output of the preceding code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.9: Output of sum when called with 0 and 1-9.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.9：当使用0和1-9调用sum时的输出。'
- en: '](Images/C14587_07_09.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_09.jpg)'
- en: 'Figure 7.9: Output of sum when called with 0 and 1-9.'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.9：调用0和1-9时sum的输出。
- en: OOP in JavaScript
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的面向对象编程
- en: 'Because of the popularity of JavaScript in web development, it is used mainly
    in a functional way. This led many developers to the assumption that there is
    no way to do OOP in JavaScript. Even before the release of the ES6 standard, there
    was a way to define a class: by using functions. You might have seen this way
    of defining a class before in legacy frontend code. For example, if you want to
    create a class called `Food`, you would have to write something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript在Web开发中的流行，它主要以一种功能性的方式使用。这导致许多开发人员认为在JavaScript中没有办法进行面向对象编程。甚至在ES6标准发布之前，已经有一种定义类的方式：使用函数。您可能在旧版前端代码中看到过这种定义类的方式。例如，如果您想创建一个名为`Food`的类，您将不得不写类似于这样的代码：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: After the release of ES6, an increasing number of developers adopted the modern
    way of writing JavaScript classes using the `class` keyword. In this chapter,
    we will be going over ways to declare classes using the ES6 standard.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6发布后，越来越多的开发人员采用了使用`class`关键字编写现代JavaScript类的方式。在本章中，我们将介绍使用ES6标准声明类的方法。
- en: Defining a Class in JavaScript
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在JavaScript中定义类
- en: Before we dive into the latest syntax to define a class in JavaScript, let's
    go over how it used to be done before ES6.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论JavaScript中定义类的最新语法之前，让我们先了解ES6之前的做法。
- en: 'The syntax that was used to define a class before ES6 was as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES6之前用于定义类的语法如下：
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Essentially, we are defining the `constructor` class. The name of the function
    will be the name of the class.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，我们正在定义`constructor`类。函数的名称将是类的名称。
- en: 'The syntax to define a class with ES6 is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ES6定义类的语法如下：
- en: '[PRE68]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is what we usually do with class definitions in other languages. Here,
    we can define a constructor and a method.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是我们在其他语言中对类定义所做的事情。在这里，我们可以定义一个构造函数和一个方法。
- en: 'Exercise 45: Declaring an Object Constructor Using Functions'
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习45：使用函数声明对象构造函数
- en: 'In this exercise, we will create a very simple class called `Food`. Later,
    we will also add some methods to the class. We will be using the function constructor
    method here. Let''s get started:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个非常简单的名为`Food`的类。稍后，我们还将为类添加一些方法。我们将在这里使用函数构造方法。让我们开始吧：
- en: 'Define the `Food` constructor function:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Food`构造函数：
- en: '[PRE69]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Add the method to the constructor:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将方法添加到构造函数中：
- en: '[PRE70]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create a new object using the `Food` constructor:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Food`构造函数创建一个新对象：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Call the method we have declared:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们声明的方法：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The following is the output of the preceding code:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.10: Output of the burger.description() method'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.10：burger.description()方法的输出'
- en: '](Images/C14587_07_10.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_10.jpg)'
- en: 'Figure 7.10: Output of the burger.description() method'
  id: totrans-288
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.10：burger.description()方法的输出
- en: Many of you might be familiar with this type of declaration of a class. But
    this also creates issues. First, using functions as constructors gives a developer
    no clear idea of when to treat a function as a function and when to use it as
    a constructor. Later, when JavaScript released ES6, it introduced a new way of
    declaring classes. In the next exercise, we will use the new method to declare
    the `Food` class.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 你们中的许多人可能熟悉这种类声明的方式。但这也会带来问题。首先，使用函数作为构造函数会让开发人员不清楚何时将函数视为函数，何时将其视为构造函数。后来，当JavaScript发布了ES6时，它引入了一种新的声明类的方式。在下一个练习中，我们将使用新的方法来声明`Food`类。
- en: 'Exercise 46: Creating a Class in JavaScript'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习46：在JavaScript中创建一个类
- en: 'In this exercise, we will create a class definition in JavaScript to store
    food data. It will include a name, a cost, and a calorie count. Later, we will
    also create methods that return the description of the food and another static
    method to output the calories for a certain food. Let''s get started:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将在JavaScript中创建一个类定义来存储食物数据。它将包括一个名称、成本和卡路里计数。稍后，我们还将创建一些返回食物描述的方法，以及另一个静态方法来输出特定食物的卡路里。让我们开始吧：
- en: 'Declare a `Food` class:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`Food`类：
- en: '[PRE73]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Run `typeof` on the class name to see what type it is:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对类名运行`typeof`以查看它的类型：
- en: '[PRE74]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following is the output of the preceding code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.11: Running the typeof command on the class'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11：在类上运行typeof命令'
- en: '](Images/C14587_07_11.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_11.jpg)'
- en: 'Figure 7.11: Running the typeof command on the class'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.11：在类上运行typeof命令
- en: As you can see, the type of the new class we just declared is `function` – isn't
    that interesting? This is because, inside JavaScript, the class we declared is
    just another way of writing the `constructor` function.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们刚刚声明的新类的类型是`function` - 这不是很有趣吗？这是因为在JavaScript内部，我们声明的类只是另一种编写`constructor`函数的方式。
- en: 'Let''s add our `constructor`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加我们的`constructor`：
- en: '[PRE75]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Just like any other language, the class definition will include a constructor,
    which is called using the `new` keyword to create an instance of this class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何其他语言一样，类定义将包括一个构造函数，使用`new`关键字调用它来创建这个类的实例。
- en: 'Write the `description` method inside the class definition:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类定义中编写`description`方法：
- en: '[PRE76]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'If you try to invoke the `Food` class constructor like a function, it will
    throw the following error:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尝试像调用函数一样调用`Food`类构造函数，它将抛出以下错误：
- en: '[PRE77]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following is the output of the preceding code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.12: TypeError for invoking the constructor as a function'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12：以函数方式调用构造函数的TypeError'
- en: '](Images/C14587_07_12.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_12.jpg)'
- en: 'Figure 7.12: TypeError for invoking the constructor as a function'
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.12：以函数方式调用构造函数的TypeError
- en: Notice that the runtime throws an error when you are trying to call the constructor
    like a function. This is very helpful as it prevents the developer from mistakenly
    calling the constructor as a function.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您尝试将构造函数作为函数调用时，运行时会抛出错误。这非常有帮助，因为它可以防止开发人员错误地将构造函数作为函数调用。
- en: 'Create a new food object using the class constructor:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类构造函数创建一个新的食物对象：
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Call the method we have declared:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用我们声明的方法：
- en: '[PRE79]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Declare the `static` method, which returns the number of calories:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`static`方法，它返回卡路里数：
- en: '[PRE80]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Call the `static` method with the object we just created:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚创建的对象调用`static`方法：
- en: '[PRE81]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The following is the output of the preceding code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.13: Output generated after calling the static method of the Food
    class'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.13：调用Food类的静态方法后生成的输出'
- en: '](Images/C14587_07_13.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_13.jpg)'
- en: 'Figure 7.13: Output generated after calling the static method of the Food class'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.13：调用Food类的静态方法后生成的输出
- en: Like any other programming language, you can call the `static` method without
    instantiating the object.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他编程语言一样，您可以在不实例化对象的情况下调用`static`方法。
- en: 'Now that we''ve looked at the new way to declare classes in JavaScript, let''s
    talk about some of the differences of class declarations:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看过了在JavaScript中声明类的新方法，让我们谈谈一些类声明的不同之处：
- en: The constructor method is required. If you do not declare one, JavaScript will
    add an empty constructor.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数方法是必需的。 如果您没有声明一个，JavaScript将添加一个空构造函数。
- en: The class declaration is not hoisted, which means that you cannot use it before
    it is declared. So, it's best to have your class definitions or imports at the
    top of the code.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类声明不会被提升，这意味着您不能在声明之前使用它。 因此，最好将类定义或导入放在代码的顶部。
- en: Creating a Simple User Information Cache Using Objects
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用对象创建简单的用户信息缓存
- en: In this section, we will design a simple user info cache. A cache is a temporary
    location where you can store the most frequently accessed items when fetching
    them from the original place takes time. Suppose you are designing for a backend
    application that handles user profiles. Whenever the request comes in, the server
    needs to call the database to retrieve the user profile and send it back to the
    handler. As you may know, calling the database is a very costly operation. As
    a backend developer, you may be asked to improve the read performance of the service.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设计一个简单的用户信息缓存。 缓存是一个临时位置，您可以在从原始位置获取它们时将最常访问的项目存储在其中。 假设您正在为处理用户配置文件的后端应用程序进行设计。
    每当请求到来时，服务器都需要调用数据库来检索用户配置文件并将其发送回处理程序。 正如您可能知道的那样，调用数据库是一个非常昂贵的操作。 作为后端开发人员，您可能会被要求提高服务的读取性能。
- en: In the next exercise, you will create a simple cache for storing the user profile
    so that you can skip the request to the database most of the time.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，您将创建一个简单的缓存，用于存储用户配置文件，以便大部分时间可以跳过对数据库的请求。
- en: 'Exercise 47: Creating a Cache Class to Add/Update/Remove Records from the Data
    Store'
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习47：创建一个缓存类以添加/更新/删除数据存储中的记录
- en: In this exercise, we will create a cache class that includes a local memory
    data store. It also includes a method that adds/updates/removes a record from
    the data store.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将创建一个包含本地内存数据存储的缓存类。 它还包括一个从数据存储中添加/更新/删除记录的方法。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Create the `MySimpleCache` class:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`MySimpleCache`类：
- en: '[PRE82]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In the constructor, we will also initialize our internal state for the cache.
    This will be a simple object.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们还将初始化缓存的内部状态。 这将是一个简单的对象。
- en: 'Define `addItem`, which will set the cache item for the key:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`addItem`，它将为键设置缓存项：
- en: '[PRE83]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Define `updateItem`, which will use the `addItem` we already defined:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`updateItem`，它将使用我们已经定义的`addItem`：
- en: '[PRE84]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define `removeItem`. This will remove the object we stored in our cache and
    invoke the `updateItem` method we created previously:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`removeItem`。 这将删除我们存储在缓存中的对象，并调用我们之前创建的`updateItem`方法：
- en: '[PRE85]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Test our cache using `assert()` with `testMycache` by updating and deleting
    a few users:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`assert()`测试我们的缓存，通过更新和删除一些用户来测试`testMycache`：
- en: '[PRE86]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Note
  id: totrans-346
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '`assert()` is a built-in Node.js function that takes an expression. It will
    pass if the expression evaluates to `true` and throw an exception if it is evaluated
    to `false`.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`assert()`是一个内置的Node.js函数，它接受一个表达式。 如果表达式求值为`true`，它将通过，如果求值为`false`，它将抛出异常。'
- en: 'After running the file, you should see no errors and the following output:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 运行文件后，您应该看不到错误，并且会看到以下输出：
- en: '![Figure 7.14: Output of simple_cache.js'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.14：simple_cache.js的输出'
- en: '](Images/C14587_07_14.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_14.jpg)'
- en: 'Figure 7.14: Output of simple_cache.js'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.14：simple_cache.js的输出
- en: Class Inheritance
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类继承
- en: 'So far, we have only created simple class definitions in JavaScript. In OOP,
    we can also have a class inherit from another class. Class inheritance is simply
    making one class''s implementation be derived from another class. The child class
    that''s created will have all the attributes and methods of the parent class.
    This is shown in the following diagram:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在JavaScript中创建了简单的类定义。 在OOP中，我们还可以让一个类继承自另一个类。 类继承只是使一个类的实现派生自另一个类。
    创建的子类将具有父类的所有属性和方法。 这在以下图表中显示：
- en: '![Figure 7.15: Class inheritance'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.15：类继承'
- en: '](Images/C14587_07_15.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_15.jpg)'
- en: 'Figure 7.15: Class inheritance'
  id: totrans-356
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.15：类继承
- en: 'Class inheritance provides some benefits:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承提供了一些好处：
- en: It creates clean, testable, and reusable code.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了干净，可测试和可重用的代码。
- en: It reduces the amount of similar code.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它减少了相似代码的数量。
- en: It reduces maintenance time when writing a new feature that will apply to all
    subclasses.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在编写适用于所有子类的新功能时，减少了维护时间。
- en: 'In JavaScript, it is very easy to create a subclass that inherits from another
    class. In order to do so, the `extends` keyword is used:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，很容易创建一个从另一个类继承的子类。 为此，使用`extends`关键字：
- en: '[PRE87]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Exercise 48: Implementing a Subclass'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习48：实现子类
- en: In this exercise, we will define a superclass called `Vehicle` and create our
    subclasses from it. The superclass will have methods called `start`, `buy`, and
    `name`, `speed`, and `cost` as its attributes.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个名为`Vehicle`的超类，并从中创建我们的子类。 超类将具有名为`start`，`buy`和`name`，`speed`和`cost`的方法作为其属性。
- en: The constructor of the superclass will take a name, color, and speed attributes,
    and then store them inside the object.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 超类的构造函数将获取名称，颜色和速度属性，然后将它们存储在对象内部。
- en: The `start` method will simply print out a string, telling you which vehicle
    you are using and how you are traveling. The `buy` function will print out which
    vehicle you are about to purchase.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`start`方法将简单地打印一个字符串，告诉您正在使用哪种车辆以及您是如何旅行的。`buy`函数将打印出您即将购买的车辆。'
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Define the `Vehicle` class:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`Vehicle`类：
- en: '[PRE88]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Create a `vehicle` instance and test out its methods:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`vehicle`实例并测试其方法：
- en: '[PRE89]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'You should see the following output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 7.16: Output of the Vehicle class'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.16：车辆类的输出'
- en: '](Images/C14587_07_16.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_16.jpg)'
- en: 'Figure 7.16: Output of the Vehicle class'
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.16：车辆类的输出
- en: 'Create the `Car`, `Plane`, and `Rocket` subclasses:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`Car`，`Plane`和`Rocket`子类：
- en: '[PRE90]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'In `Car`, `Plane`, and `Rocket`, override the `start` method:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Car`，`Plane`和`Rocket`中，重写`start`方法：
- en: '[PRE91]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Create an instance for `Plane`, `Rocket`, and `Car`:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Plane`，`Rocket`和`Car`创建一个实例：
- en: '[PRE92]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Call the `start` method on all three objects:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有三个对象上调用`start`方法：
- en: '[PRE93]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The following is the output of the preceding code:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '![Figure 7.17: Output from the objects'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.17：对象的输出'
- en: '](Images/C14587_07_17.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_17.jpg)'
- en: 'Figure 7.17: Output from the objects'
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.17：对象的输出
- en: When you call these start methods now, you can clearly see that the output is
    different. When declaring subclasses, most of the time, we need to override some
    methods from the parent class. This is very useful when we are reducing the duplicated
    code while preserving the customization this creates.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当您调用这些start方法时，您可以清楚地看到输出是不同的。在声明子类时，大多数时候，我们需要重写父类的一些方法。当我们减少重复的代码同时保留定制时，这非常有用。
- en: The customization doesn't stop here – you are also able to create a new subclass
    with a different constructor. You are also able to call the parent method from
    the subclass.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 定制不止于此 - 您还可以创建具有不同构造函数的新子类。您还可以从子类调用父方法。
- en: 'For the subclasses we created previously, we will be modifying the `Car` subclass
    so that it includes extra parameters in the constructor:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对我们之前创建的子类，我们将修改`Car`子类，以便在构造函数中包含额外的参数：
- en: '[PRE94]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Check to see whether the extra property is set:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查额外的属性是否已设置：
- en: '[PRE95]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The following is the output of the preceding code:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前述代码的输出：
- en: '![Figure 7.18: Checking the extra property of the Car class'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.18：检查Car类的额外属性'
- en: '](Images/C14587_07_18.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_18.jpg)'
- en: 'Figure 7.18: Checking the extra property of the Car class'
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.18：检查Car类的额外属性
- en: As you can see, declaring a subclass is very easy – you can have a lot of code
    shared when coding this way. Also, you do not lose the ability of being able to
    do customization. After the ES6 standard, you can easily define classes just like
    the other OOP languages out there. It can make your code cleaner, more testable,
    and more easily maintainable.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，声明子类非常容易 - 在以这种方式编码时，您可以共享大量代码。此外，您不会失去进行定制的能力。在ES6标准之后，您可以轻松地定义类，就像其他面向对象的编程语言一样。它可以使您的代码更清晰，更易于测试和更易于维护。
- en: Private and Public Methods
  id: totrans-399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 私有和公共方法
- en: In OOP, sometimes, it's useful to separate publicly accessible properties and
    functions and privately accessible properties and functions. It's a protection
    layer to prevent developers who are using the class from invoking or accessing
    some internal states of the class. In JavaScript, that behavior is not possible
    because ES6 doesn't allow private properties to be declared; all the properties
    you declare in the class will be publicly accessible. To achieve this type of
    behavior, some developers have opted to use the underscore prefix, for example,
    `privateMethod()`, to inform other developers not to use it. However, there are
    hacks around declaring private methods. In the next exercise, we will explore
    private methods.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，有时将可公开访问的属性和函数与私有可访问的属性和函数分开是有用的。这是一种保护层，可以防止使用类的开发人员调用或访问类的一些内部状态。在JavaScript中，这种行为是不可能的，因为ES6不允许声明私有属性；您在类中声明的所有属性都将是公开可访问的。为了实现这种类型的行为，一些开发人员选择使用下划线前缀，例如`privateMethod()`，以通知其他开发人员不要使用它。但是，有关声明私有方法的黑客。在下一个练习中，我们将探讨私有方法。
- en: 'Exercise 49: Private Methods in the Vehicle Class'
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习49：车辆类中的私有方法
- en: 'In this exercise, we will try to declare a private function for the `Car` class
    we created previously so that we can make sure our private method isn''t exposed
    when we export the class as a module later. Let''s get started:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试为我们之前创建的`Car`类声明一个私有函数，以便在以后将类导出为模块时确保我们的私有方法不会暴露出来。让我们开始吧：
- en: 'Create a function named `printStat`:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`printStat`的函数：
- en: '[PRE96]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Modify the `public` method to use the function we just declared:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`public`方法以使用我们刚刚声明的函数：
- en: '[PRE97]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We called `printStat` from our `start` method directly, but there is no real
    way to access the method directly without using one of the methods in our class.
    By having the method declared outside, we made the method `private`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接从`start`方法调用了`printStat`，但是没有真正的方法可以直接访问，而是使用我们类中的一个方法。通过在外部声明方法，我们使方法成为`private`。
- en: 'Create another `car` instance and call the `start` method:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个`car`实例并调用`start`方法：
- en: '[PRE98]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'When you run this code, you will realize that this causes an anomaly:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此代码时，您将意识到这会导致异常：
- en: '![Figure 7.19: Output of printStat'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.19：printStat的输出'
- en: '](Images/C14587_07_19.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_19.jpg)'
- en: 'Figure 7.19: Output of printStat'
  id: totrans-413
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.19：printStat的输出
- en: 'Modify the `start` method so that the function knows about the object instance
    we are calling it from:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`start`方法，以便函数了解我们从中调用它的对象实例：
- en: '[PRE99]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Notice we used `.bind()`. By using bind, we are binding the current instance
    to the `this` variable inside this function. This enabled our code to work as
    expected:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用了`.bind()`。通过使用绑定，我们将当前实例绑定到此函数内部的`this`变量。这使我们的代码能够按预期工作：
- en: '![Figure 7.20: Output of printStat after using .bind()'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.20：使用.bind()后的printStat的输出'
- en: '](Images/C14587_07_20.jpg)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_20.jpg)'
- en: 'Figure 7.20: Output of printStat after using .bind()'
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.20：使用.bind()后printStat的输出
- en: As you can see, currently, there is no way to easily declare a `private` method
    or properties in JavaScript. This example is just a hack around the issue; it
    still doesn't provide equal separation like other OOP languages do, such as Java
    or Python. There are also options online where you can declare private methods
    using symbols, but they can also be accessed if you know where to look.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，目前在JavaScript中没有一种简单地声明`private`方法或属性的方法。这个例子只是对这个问题的一个变通方法；它仍然不能像其他面向对象的语言（如Java或Python）那样提供相等的分离。也有在线选项，可以使用符号声明私有方法，但如果知道在哪里查找，它们也可以被访问。
- en: Array and Object Built-in Methods
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组和对象内置方法
- en: Previously, we talked about basic arrays and objects. They deal with how we
    store data. Now, we will dive deep into how we take the data we have just stored
    in them and make advanced calculations and manipulations on them.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了基本数组和对象。它们处理我们如何存储数据。现在，我们将深入探讨如何对刚刚存储在其中的数据进行高级计算和操作。
- en: '**array.map(function)**'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '**array.map(function)**'
- en: 'Array map will iterate over each item in the array and return a new array as
    a result. The function that''s passed to the method will take the current item
    as a parameter and the returned value of the function will be included in the
    final array''s result; for example:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 数组映射将遍历数组中的每个项目，并返回一个新数组作为结果。传递给方法的函数将以当前项目作为参数，并且函数的返回值将包含在最终数组的结果中；例如：
- en: '[PRE100]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'If we want to create a new array and only include the name property from the
    object in the list, we can use `array.map` to accomplish this:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个新数组，并且只包括列表中对象的名称属性，我们可以使用`array.map`来实现：
- en: '[PRE101]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The following is the output of the preceding code:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.21: Output using array.map(function)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.21：使用数组映射方法的输出'
- en: '](Images/C14587_07_21.jpg)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_21.jpg)'
- en: 'Figure 7.21: Output using array.map(function)'
  id: totrans-431
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.21：使用数组映射方法的输出
- en: '**array.forEach(function)**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**array.forEach(function)**'
- en: '`.forEach` is a way of iterating over an array of items. Unlike `.map`, it
    does not return new values. The function we passed in simply gets called repeatedly
    with the values in the array; for example:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`.forEach`是一种迭代数组项的方法。与`.map`不同，它不会返回新值。我们传递的函数只是重复调用数组中的值；例如：'
- en: '[PRE102]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This will print out every singer's name in the array.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出数组中每个歌手的名字。
- en: '**array.find(function)**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**array.find(function)**'
- en: 'The `.find` method works just like the `.map` and `.forEach` methods; it takes
    a function as a parameter. This function will be used to determine whether the
    current object matches the requirement of the search. If a match is found, it
    will be used as the returned result for the method. This method is only useful
    if you have only one match in the array and will not return at all if multiple
    matches were found. For example, if we want to find the object with the name equal
    to a string, we can do the following:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`.find`方法的工作原理与`.map`和`.forEach`方法相同；它接受一个函数作为参数。此函数将用于确定当前对象是否符合搜索的要求。如果找到匹配项，它将用作方法的返回结果。如果数组中找到多个匹配项，则此方法将不返回任何结果。例如，如果我们想要找到名称等于某个字符串的对象，我们可以这样做：'
- en: '[PRE103]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '**array.filter(function)**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**array.filter(function)**'
- en: '`.filter` works just like `.find`, but it allows multiple items to be returned.
    If we want to match multiple items in a list, we need to use `.filter`. If we
    want to find a list of singers with an age less than 30, use the following code:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '`.filter`的工作原理与`.find`相同，但它允许返回多个项目。如果我们想要在列表中匹配多个项目，我们需要使用`.filter`。如果要查找年龄小于30岁的歌手列表，请使用以下代码：'
- en: '[PRE104]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `map` method from the array creates a new array while iterating through
    every item in the array. The `map` method takes a function such as the `forEach`
    method. When it executes, it will call the function with the first parameter with
    the current item and the second with the current index. The `map` method also
    expects the function that''s supplied to it to be returned. The returned value
    will be put inside a new array and returned by the method, like so:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的`map`方法在迭代数组中的每个项目时创建一个新数组。`map`方法接受一个函数，就像`forEach`方法一样。当执行时，它将使用当前项目调用函数的第一个参数和当前索引的第二个参数。`map`方法还期望返回提供给它的函数。返回的值将放入新数组中，并由该方法返回，如下所示：
- en: '[PRE105]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `.map` method will iterate through the array and our `map` function will
    return `"I know,"` plus the current language. So, the result of `myMappedArray`
    will be as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`.map`方法将遍历数组，我们的`map`函数将返回`"I know,"`加上当前语言。因此，`myMappedArray`的结果将如下所示：'
- en: '![Figure 7.22: Example output using an array map method'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.22：使用数组映射方法的示例输出'
- en: '](Images/C14587_07_22.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_22.jpg)'
- en: 'Figure 7.22: Example output using an array map method'
  id: totrans-447
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.22：使用数组映射方法的示例输出
- en: We will go over `array.map` in more detail in *Chapter 10*, *Functional Programming
    in JavaScript*.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在*第10章* *JavaScript中的函数式编程*中更详细地介绍`array.map`。
- en: 'Another method that we will use in the following exercise is the `forEach`
    method. The `forEach` method is much cleaner, as there is no need to manage the
    current index and write the actual call to the function. The `forEach` method
    is a built-in array method and it takes a function as a parameter. The following
    is an example of the `forEach` method:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的练习中使用的另一种方法是`forEach`方法。`forEach`方法更加简洁，因为不需要管理当前索引并编写实际调用函数的代码。`forEach`方法是一个内置的数组方法，它接受一个函数作为参数。以下是`forEach`方法的示例：
- en: '[PRE106]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: In the following exercise, we will use iteration methods on arrays.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将在数组上使用迭代方法。
- en: 'Exercise 50: Using Iteration Methods on Arrays'
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习50：在数组上使用迭代方法
- en: 'There are many ways to iterate through an array. One is to use the `for` loop
    with an index, while another is to use one of its built-in methods. In this exercise,
    we will initialize an array of strings and then explore some of the iteration
    methods that are available in JavaScript. Let''s get started:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多遍历数组的方法。一种是使用带有索引的`for`循环，另一种是使用其中一种内置方法。在这个练习中，我们将初始化一个字符串数组，然后探索JavaScript中可用的一些迭代方法。让我们开始吧：
- en: 'Create a list of foods as an array:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个食物列表作为数组：
- en: '[PRE107]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Join every item in the array using `join`:'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`join`连接数组中的每个项目：
- en: '[PRE108]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The following is the output of the preceding code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.23: Joined items in the array'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.23：数组中的连接项目'
- en: '](Images/C14587_07_23.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_23.jpg)'
- en: 'Figure 7.23: Joined items in the array'
  id: totrans-461
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.23：数组中的连接项目
- en: Array joining is another way to iterate through every item in the array, combining
    them into one single string using the separator supplied in between them.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 数组连接是另一种遍历数组中每个项目的方法，使用提供的分隔符将它们组合成一个单一的字符串。
- en: 'Create a function called `eat_food`:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`eat_food`的函数：
- en: '[PRE109]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Use the `for` loop to iterate through the array and call the function:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`for`循环来遍历数组并调用函数：
- en: '[PRE110]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The following is the output of the preceding code:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.24: Output of eat_food being called inside a loop'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.24：在循环中调用eat_food的输出'
- en: '](Images/C14587_07_24.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_24.jpg)'
- en: 'Figure 7.24: Output of eat_food being called inside a loop'
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.24：在循环中调用eat_food的输出
- en: 'Use the `forEach` method to achieve the same:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`方法来实现相同的效果：
- en: '[PRE111]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The following is the output of the preceding code:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.25: The same output is generated by using the forEach method'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.25：使用forEach方法生成相同的输出'
- en: '](Images/C14587_07_24.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_24.jpg)'
- en: 'Figure 7.25: The same output is generated by using the forEach method'
  id: totrans-476
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.25：使用forEach方法生成相同的输出
- en: Because `eat_food` is a function and its first parameter references the current
    item, we can just pass the function name over.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`eat_food`是一个函数，它的第一个参数引用了当前项目，所以我们可以直接传递函数名。
- en: 'Create a new array of calorie numbers:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的卡路里数字数组：
- en: '[PRE112]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This array includes all the calories for each item in our `food` array. Next,
    we will use a different iterative function to create a new list of objects, including
    this information.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数组包括我们`food`数组中每个项目的卡路里。接下来，我们将使用不同的迭代函数来创建一个包含这些信息的新对象列表。
- en: 'Create new array of objects:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建新的对象数组：
- en: '[PRE113]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Print out `foodInfo` to the console:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`foodInfo`打印到控制台上：
- en: '[PRE114]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The following is the output of the preceding code:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.26: Array containing food and calorie information'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.26：包含食物和卡路里信息的数组'
- en: '](Images/C14587_07_26.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_26.jpg)'
- en: 'Figure 7.26: Array containing food and calorie information'
  id: totrans-488
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.26：包含食物和卡路里信息的数组
- en: After running `array.map`, the new array will be created, which includes information
    about our food name and its calorie count.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`array.map`后，将创建一个新数组，其中包含有关我们食物名称和其卡路里计数的信息。
- en: In this exercise, we went over two iteration methods, that is, `forEach` and
    `map`. Each has its own capabilities and usages. In most applications, maps are
    generally used to calculate array results by running the same code on each array
    item. This is very useful if you want to manipulate every item in the array without
    modifying the array directly.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了两种迭代方法，即`forEach`和`map`。每种方法都有其自己的功能和用法。在大多数应用程序中，通常使用映射来通过在每个数组项上运行相同的代码来计算数组结果。如果你想要在不直接修改数组的情况下操作数组中的每个项目，这是非常有用的。
- en: 'Exercise 51: Lookups and Filtering the Array'
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习51：查找和过滤数组
- en: 'Previously, we talked about ways to iterate through arrays. These ways can
    also be used for lookups. As we all know, a lookup is very costly when you are
    iterating the array from start to finish. Luckily, a JavaScript array has some
    built-in methods for that, so we don''t have to write our search function ourselves.
    In this exercise, we will use `includes` and `filter` to search the items in our
    array. Let''s get started:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们讨论了遍历数组的方法。这些方法也可以用于查找。众所周知，当你从头到尾迭代数组时，查找是非常昂贵的。幸运的是，JavaScript数组有一些内置方法，因此我们不必自己编写搜索函数。在这个练习中，我们将使用`includes`和`filter`来搜索数组中的项目。让我们开始吧：
- en: 'Create a list of names called `profiles`:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`profiles`的名称列表：
- en: '[PRE115]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Try to find out whether the list of profiles includes a person named `Jim Halpert`:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试找出`profiles`列表中是否包含名为`Jim Halpert`的人：
- en: '[PRE116]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The following is the output of the preceding code:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.27: Output of the hasJim method'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.27：hasJim方法的输出'
- en: '](Images/C14587_07_27.jpg)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_27.jpg)'
- en: 'Figure 7.27: Output of the hasJim method'
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.27：hasJim方法的输出
- en: 'Modify the `profiles` array to include extra information:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`profiles`数组以包含额外的信息：
- en: '[PRE117]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Now, the array is no longer a simple list of strings – it's a list of objects,
    and things will work a little bit differently when we are dealing with objects.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数组不再是简单的字符串列表-它是一个对象列表，当我们处理对象时，事情会有点不同。
- en: 'Try to use `includes` to find the `Jim Halpert` profile again:'
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试再次使用`includes`查找`Jim Halpert`个人资料：
- en: '[PRE118]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The following is the output of the preceding code:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上述代码的输出：
- en: '![Figure 7.28: Output of the hasJim method'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.28：hasJim方法的输出'
- en: '](Images/C14587_07_28.jpg)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_28.jpg)'
- en: 'Figure 7.28: Output of the hasJim method'
  id: totrans-509
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.28：hasJim方法的输出
- en: 'Find the profile with the name `Jim Halpert`:'
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到名为`Jim Halpert`的个人资料：
- en: '[PRE119]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Find all the users with an age older than `18`:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有年龄大于`18`的用户：
- en: '[PRE120]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'When you run the preceding code, it should output all the users with an age
    over 18\. The difference between `filter` and `find` is that `filter` returns
    an array:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行上述代码时，它应该输出所有年龄超过18岁的用户。`filter`和`find`之间的区别在于`filter`返回一个数组：
- en: '![Figure 7.29: Output after using the filter method'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.29：使用filter方法后的输出'
- en: '](Images/C14587_07_29.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_29.jpg)'
- en: 'Figure 7.29: Output after using the filter method'
  id: totrans-517
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.29：使用filter方法后的输出
- en: In this exercise, we looked at two ways we can locate a specific item in our
    array. By using these methods, we can avoid rewriting the search algorithm. The
    difference between `find` and `filter` is that `filter` returns an array of all
    the objects matching the requirement. In an actual production environment, when
    we want to test whether the array has an object that matches our requirement,
    we usually use the `find` method because it stops scanning when it finds one match,
    whereas `filter` compares with all the objects in the array and will return all
    the matching occurrences. This is more costly if you are just testing for the
    existence of something. We also used the double negative operator to cast our
    result to a Boolean. This notation is very useful if you are using this value
    later in a conditional.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们看了两种定位数组中特定项的方法。通过使用这些方法，我们可以避免重写搜索算法。`find`和`filter`之间的区别在于`filter`返回符合要求的所有对象的数组。在实际的生产环境中，当我们想要测试数组是否有与我们要求匹配的对象时，通常使用`find`方法，因为它在找到一个匹配时就停止扫描，而`filter`会与数组中的所有对象进行比较，并返回所有匹配的结果。如果您只是测试某物的存在，这将更加昂贵。我们还使用了双重否定运算符将结果转换为布尔值。如果您稍后在条件语句中使用这个值，这种表示法非常有用。
- en: Sorting
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: Sorting is one of the biggest challenges that developers face. When we want
    to sort a number of items in our array, we usually need to define a specific sorting
    algorithm. These algorithms usually require us to write a lot of logic on sorting
    and they are not easily reused. In JavaScript, we can use the built-in array methods
    to sort our custom list of items and write minimal custom code.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是开发人员面临的最大挑战之一。当我们想要对数组中的一些项目进行排序时，通常需要定义特定的排序算法。这些算法通常需要我们编写大量的排序逻辑，并且不容易重用。在JavaScript中，我们可以使用内置的数组方法对我们的自定义项目列表进行排序，并编写最少的自定义代码。
- en: Sorting in JavaScript arrays requires us to call the `.sort()` function on the
    array. The `sort()` function takes one parameter, called the sorting comparator.
    Based on the comparator, the `sort()` function will make a decision on how to
    arrange each element.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript数组中进行排序需要在数组上调用`.sort()`函数。`sort()`函数接受一个参数，称为排序比较器。根据比较器，`sort()`函数将决定如何排列每个元素。
- en: The following is a brief description of some of the other functions we will
    use in the upcoming exercise.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在即将进行的练习中使用的一些其他函数的简要描述。
- en: 'The `compareNumber` function only calculates the difference between `a` and
    `b`. In the `sort` method, we can declare our own custom compare function to be
    passed down to do the comparison:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareNumber`函数只计算`a`和`b`之间的差异。在`sort`方法中，我们可以声明自己的自定义比较函数进行比较：'
- en: '[PRE121]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The `compareAge` function is very similar to the `compareNumber` function.
    The only difference here is that we are comparing JavaScript objects instead of
    numbers:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`compareAge`函数与`compareNumber`函数非常相似。唯一的区别在于我们比较的是JavaScript对象而不是数字：'
- en: '[PRE122]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Exercise 52: Sorting Arrays in JavaScript'
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习52：JavaScript中的数组排序
- en: In this exercise, we will go over ways to sort our arrays. Sorting is always
    complicated in computer science. In JavaScript, the array object has a sorting
    method built into it where you can do basic sorting on the array.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将讨论对数组进行排序的方法。在计算机科学中，排序总是复杂的。在JavaScript中，数组对象内置了一个排序方法，可以对数组进行基本排序。
- en: 'We will be using the `profiles` array of objects from the previous exercise.
    Let''s get started:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一个练习中的`profiles`对象数组。让我们开始吧：
- en: 'Create an array of `numbers`:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`numbers`数组：
- en: '[PRE123]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Call `array.sort()` to sort this array:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`array.sort()`对这个数组进行排序：
- en: '[PRE124]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'When you run the preceding code, you will get the following output:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您将获得以下输出：
- en: '![Figure 7.30: Output of array.sort()'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.30：数组.sort()的输出'
- en: '](Images/C14587_07_30.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_30.jpg)'
- en: 'Figure 7.30: Output of array.sort()'
  id: totrans-537
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.30：数组.sort()的输出
- en: This is not exactly what we want; it appears that the `sort` function just randomly
    arranges the values. The reason behind this is that, in JavaScript, `array.sort()`
    doesn't really support sorting by values. By default, it treats everything as
    a string. When we called it using the number array, it converted everything into
    strings and then started sorting. That's why you are seeing numbers with 1 appearing
    before 2 and 3\. To implement the sorting of numbers, we need to do something
    extra.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们想要的；似乎`sort`函数只是随机排列值。其背后的原因是，在JavaScript中，`array.sort()`实际上并不支持按值排序。默认情况下，它将所有内容视为字符串。当我们使用数字数组调用它时，它将所有内容转换为字符串，然后开始排序。这就是为什么您会看到数字1出现在2和3之前的原因。为了实现对数字的排序，我们需要做一些额外的工作。
- en: 'Define the `compareNumber` function:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`compareNumber`函数：
- en: '[PRE125]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The function expects to take two values that are going to be compared, and
    returns a value that must match the following: if `a` is smaller than `b`, return
    a number less than 0; if `a` is equal to `b`, return 0; and if `a` is larger than
    `b`, return a number greater than 0.'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数期望接受两个要进行比较的值，并返回一个必须匹配以下内容的值：如果`a`小于`b`，则返回小于0的数字；如果`a`等于`b`，则返回0；如果`a`大于`b`，则返回大于0的数字。
- en: 'Run the `sort` function and provide the `compareNumber` function as our parameter:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`sort`函数，并将`compareNumber`函数作为参数传递：
- en: '[PRE126]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'When you run the preceding code, you will see that the function has sorted
    our array into the order we wanted:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行上述代码时，您将看到该函数已将我们的数组按照我们想要的顺序排序：
- en: '![Figure 7.31: Output of array.sort(compareNumber)'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.31：数组.sort(compareNumber)的输出'
- en: '](Images/C14587_07_31.jpg)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_31.jpg)'
- en: 'Figure 7.31: Output of array.sort(compareNumber)'
  id: totrans-547
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.31：数组.sort(compareNumber)的输出
- en: Now, the array is sorted correctly from smallest to largest. However, most of
    the time when we have to do sorting, we need to sort complex objects into order.
    For the next step, we will use the `profiles` array we created in the previous
    exercise.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，数组已经正确地从最小到最大排序。然而，大多数情况下，当我们需要进行排序时，我们需要将复杂的对象排序。在下一步中，我们将使用在上一个练习中创建的`profiles`数组。
- en: 'Create the `profiles` array if it isn''t defined in your workspace:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的工作空间中未定义`profiles`数组，请创建它：
- en: '[PRE127]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Call `profiles.sort()`:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`profiles.sort()`：
- en: '[PRE128]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The following is the output of the preceding code:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.32: Output of the profiles.sort() function'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.32：profiles.sort()函数的输出'
- en: '](Images/C14587_07_32.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_32.jpg)'
- en: 'Figure 7.32: Output of the profiles.sort() function'
  id: totrans-556
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.32：profiles.sort()函数的输出
- en: Because our `sort` function has no idea how to compare these objects, the array
    is left the way it is. In order to make it correctly sort objects, we need a compare
    function just like last time.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的`sort`函数不知道如何比较这些对象，所以数组保持原样。为了正确排序对象，我们需要一个与上次一样的比较函数。
- en: 'Define `compareAge`:'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义`compareAge`：
- en: '[PRE129]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The two arguments that are supplied to `compareAge`, `a` and `b`, are objects
    in our array. So, in order to have them sorted correctly, we need to access the
    `age` property of these objects and compare them.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`compareAge`的两个参数`a`和`b`是数组中的对象。因此，为了正确排序它们，我们需要访问这些对象的`age`属性并进行比较。
- en: 'Call the `sort` function with the `compare` function we just have defined:'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们刚刚定义的`compare`函数调用`sort`函数：
- en: '[PRE130]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The following is the output of the preceding code:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.33: Result of profile.sort(compareAge)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.33：profile.sort(compareAge)的结果'
- en: '](Images/C14587_07_33.jpg)'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_33.jpg)'
- en: 'Figure 7.33: Result of profile.sort(compareAge)'
  id: totrans-566
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.33：profile.sort(compareAge)的结果
- en: In this exercise, we went over the ways to sort our arrays. One thing to keep
    in mind is that, in JavaScript, if you are not sorting string values, you are
    required to supply the sorting function with a compare function so that it knows
    how to sort. The space and time complexity for this method varies from platform
    to platform, but if you are using Node.js, the V8 engine of JavaScript is highly
    optimized for these types of operations, so you don't have to worry about performance.
    In the next exercise, we will go over a very interesting, yet useful, array operation
    in JavaScript, the array reducer. By using the array reducer, we can easily combine
    items in the array and reduce them into one single value.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了对数组进行排序的方法。需要记住的一件事是，在JavaScript中，如果不对字符串值进行排序，则需要使用比较函数来告诉它如何排序。该方法的空间和时间复杂度因平台而异，但如果使用Node.js，JavaScript的V8引擎对这些类型的操作进行了高度优化，因此您不必担心性能问题。在下一个练习中，我们将讨论JavaScript中非常有趣但又有用的数组操作，即数组减少器。通过使用数组减少器，我们可以轻松地将数组中的项目组合在一起，并将它们减少为一个单一的值。
- en: Array Reduce
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组减少
- en: When building backend applications, there are many times where you are given
    a list of formatted results and you must calculate a single value from them. While
    this can be done using the traditional loop method, it is much cleaner and much
    easier to maintain when you are using the JavaScript reducing function. Reducing
    means taking each element in the array and producing a single value in return.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建后端应用程序时，经常会出现给定格式化结果列表并且必须从中计算单个值的情况。虽然可以使用传统的循环方法来完成，但使用JavaScript减少函数时更加简洁和易于维护。减少意味着对数组中的每个元素进行处理，并返回一个单一的值。
- en: 'If we want to reduce an array, we can call the built-in `array.reduce()` method:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要减少一个数组，我们可以调用内置的`array.reduce()`方法：
- en: '[PRE131]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: When we call `array.reduce()`, we need to pass in a function and the initial
    value. The function will feed a previous value and a current value as arguments
    and will use the return as the final value.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`array.reduce()`时，我们需要传入一个函数和初始值。该函数将以前一个值和当前一个值作为参数，并将返回值用作最终值。
- en: 'Exercise 53: Using JavaScript Reduce Method to Make Calculations for a Shopping
    Cart'
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习53：使用JavaScript减少方法为购物车进行计算
- en: 'In this exercise, we will try to use JavaScript `reduce` method to make calculations
    for a shopping cart. Let''s get started:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将尝试使用JavaScript的`reduce`方法为购物车进行计算。让我们开始吧：
- en: 'Create the shopping cart variable:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建购物车变量：
- en: '[PRE132]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Push items into the array:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目推入数组：
- en: '[PRE133]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Calculate the total cost of the shopping cart using the loop method:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用循环方法计算购物车的总成本：
- en: '[PRE134]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The following is the output of the preceding code:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.34: Result of the loop method of calculating total'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.34：计算总数的循环方法的结果'
- en: '](Images/C14587_07_34.jpg)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_34.jpg)'
- en: 'Figure 7.34: Result of the loop method of calculating total'
  id: totrans-584
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.34：计算总数的循环方法的结果
- en: 'We write our reducer called `priceReducer`:'
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写了名为`priceReducer`的reducer：
- en: '[PRE135]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Call `cart.reduce` with our reducer:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的reducer调用`cart.reduce`：
- en: '[PRE136]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Following is the output of the preceding code:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.35: Result of cart.reduce'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.35：cart.reduce的结果'
- en: '](Images/C14587_07_34.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_34.jpg)'
- en: 'Figure 7.35: Result of cart.reduce'
  id: totrans-592
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.35：cart.reduce的结果
- en: In this exercise, we went over the ways in which we can reduce the array into
    a single value in JavaScript. While it is perfectly correct to use a loop to iterate
    through the array and return the accumulator, it makes the code much cleaner when
    you are using the reduce function. We not only reduced the number of mutable variables
    in the scope, but we also made the code much cleaner and maintainable. The next
    person maintaining the code will know that the returned value of that function
    will be a single value, whereas the `forEach` method may make it unclear what
    the result of that returned is.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们讨论了在JavaScript中将数组减少为单个值的方法。虽然使用循环迭代数组并返回累加器是完全正确的，但是使用减少函数时，代码会更加简洁。我们不仅减少了作用域中可变变量的数量，还使代码更加简洁和可维护。下一个维护代码的人将知道该函数的返回值将是一个单一的值，而`forEach`方法可能会使得返回结果不清晰。
- en: 'Activity 9: Creating a Student Manager Using JavaScript Arrays and Classes'
  id: totrans-594
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动9：使用JavaScript数组和类创建学生管理器
- en: 'Suppose you are working for a local school district, and up until now they''ve
    been using a paper register to keep track of student information. Now, they''ve
    had some funding and want you to develop a piece of computer software to track
    student information. They have the following requirements for the software:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为当地的学区工作，到目前为止，他们一直在使用纸质登记簿来记录学生信息。现在，他们获得了一些资金，并希望您开发一款计算机软件来跟踪学生信息。他们对软件有以下要求：
- en: It needs to be able to record information about students, including their name,
    age, grade level, and book information.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它需要能够记录关于学生的信息，包括他们的姓名、年龄、年级和书籍信息。
- en: Each student will be assigned a unique ID that will be used to retrieve and
    modify student record.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个学生将被分配一个唯一的ID，用于检索和修改学生记录。
- en: Book information will include the name and the current grade (number grade)
    of the book for that student.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书籍信息将包括该学生的书籍名称和当前成绩（数字成绩）。
- en: There needs to be a way to calculate the average grade for the student.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一种方法来计算学生的平均成绩。
- en: There needs to be a way to search for all students with the same age or grade
    level.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一种方法来搜索具有相同年龄或年级的所有学生。
- en: There needs to be a way to search for a student using their name. When multiples
    are found, return all of them.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一种方法来使用他们的名字搜索学生。当找到多个时，返回所有学生。
- en: Note
  id: totrans-602
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete code for this activity can also be found on our GitHub repository,
    here: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js).'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的完整代码也可以在我们的GitHub存储库中找到，链接在这里：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson07/Activity09/Activity09.js)。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a `School` class and initialize a list of students in the constructor.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`School`类并在构造函数中初始化学生列表。
- en: Create a `Student` class and store a list of courses, the student's `age`, `name`,
    and `grade level` in it.
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Student`类，并在其中存储课程列表、学生的`age`、`name`和`grade level`。
- en: Create a `Course` class that will include information about `course`, `name`
    and `grades`.
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Course`类，其中包括有关`course`、`name`和`grades`的信息。
- en: Create the `addStudent` function in the `School` class to push students into
    a list in the `school` object.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`addStudent`函数，将学生推入`school`对象中的列表中。
- en: Create the `findByGrade` function in the `School` class, which returns all the
    students with a given `grade level`.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByGrade`函数，该函数返回具有给定`grade level`的所有学生。
- en: Create the `findByAge` function in the `School` class, which returns a list
    of students with the same `age`.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByAge`函数，该函数返回具有相同`age`的学生列表。
- en: Create the `findByName` function in the `School` class, which searches for all
    the students in the school by name.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`School`类中创建`findByName`函数，通过姓名搜索学校中的所有学生。
- en: In the `Student` class, create a `calculateAverageGrade` method for calculating
    the average grade of the student.
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student`类中，为计算学生的平均成绩创建一个`calculateAverageGrade`方法。
- en: In the `Student` class, create a `assignGrade` method, which will assign a number
    grade for a course the student is taking.
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Student`类中，创建一个`assignGrade`方法，该方法将为学生所学课程分配一个数字成绩。
- en: Note
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 608.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在第608页找到。
- en: In the previous section, we went over methods that allow us to iterate, look
    up, and reduce our arrays. These are very useful methods when dealing with arrays.
    While most of the methods only accomplish basic tasks and they can be easily implemented
    using loops, using them helps with making our code more usable and testable. Some
    of the built-in methods are also well optimized by the runtime engine.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了允许我们迭代、查找和减少数组的方法。在处理数组时，这些方法非常有用。虽然大多数方法只能完成基本任务，并且可以很容易地使用循环实现，但使用它们有助于使我们的代码更易用和可测试。一些内置方法也经过了运行时引擎的优化。
- en: In the next section, we will go over some built-in functions for Map and Set.
    They are very useful if we need to track values in our application.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Map和Set的一些内置函数。如果我们需要在应用程序中跟踪值，它们非常有用。
- en: Maps and Sets
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Map和Set
- en: Maps and Sets are very underrated types in JavaScript, but they can be very
    powerful in some applications. Maps work just like a basic hashmap in JavaScript,
    and are useful when you need to keep track of a list of key-value pairs. Sets
    are used when you need to keep a list of unique values. Most developers often
    use objects for everything while forgetting that, in some cases, using Maps and
    Sets is way more efficient. In the following section, we will go over Maps and
    Sets and how to use them.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Map和Set在JavaScript中是非常被低估的类型，但在某些应用中它们可以非常强大。Map在JavaScript中的工作原理就像一个基本的哈希映射，当您需要跟踪一组键值对时非常有用。Set用于在需要保留一组唯一值时使用。大多数开发人员经常在所有情况下都使用对象，而忽略了在某些情况下使用Map和Set更有效的事实。在接下来的部分中，我们将讨论Map和Set以及如何使用它们。
- en: 'There are many cases where we must keep track of a list of unique key-value
    pairs in our application. When programming with other languages, we often need
    to implement a class called **Hashmap**. In JavaScript, there are two types that
    can accomplish this: one is Map and the other is Object. Because they seem to
    do the same thing, many JavaScript developers tend to use Object for everything
    while ignoring that using Map is sometimes way more effective for their use case.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多情况下，我们必须跟踪应用程序中的一组唯一键值对。在使用其他语言编程时，我们经常需要实现一个名为**哈希映射**的类。在JavaScript中，有两种类型可以实现这一点：一种是Map，另一种是Object。因为它们似乎做同样的事情，许多JavaScript开发人员倾向于在所有情况下都使用Object，而忽略了在某些情况下使用Map对他们的用例更有效的事实。
- en: 'Exercise 54: Using Maps versus Objects'
  id: totrans-621
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习54：使用Map与对象
- en: 'In this exercise, we will go over ways we can use Maps and how they are different
    compared to Objects:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将讨论我们可以如何使用Map以及它们与对象相比有何不同：
- en: 'Create a new Map called `map`:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`map`的新Map：
- en: '[PRE137]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Create a list of objects we want to use as keys:'
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建我们想要用作键的对象列表：
- en: '[PRE138]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Use `map.set` to set a value for all the keys we defined earlier:'
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map.set`为我们之前定义的所有键设置一个值：
- en: '[PRE139]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The following is the output of the preceding code:'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.36: Output after assigning values to map.set'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.36：对map.set分配值后的输出'
- en: '](Images/C14587_07_36.jpg)'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_36.jpg)'
- en: 'Figure 7.36: Output after assigning values to map.set'
  id: totrans-632
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.36：对map.set分配值后的输出
- en: 'Get the values of the keys:'
  id: totrans-633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取键的值：
- en: '[PRE140]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The following is the output of the preceding code:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.37: Output of console.log for value retrieval'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.37：值检索的console.log输出'
- en: '](Images/C14587_07_37.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_37.jpg)'
- en: 'Figure 7.37: Output of console.log for value retrieval'
  id: totrans-638
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.37：值检索的console.log输出
- en: 'Retrieve the value for `key2` without using the reference:'
  id: totrans-639
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不使用引用的情况下检索`key2`的值：
- en: '[PRE141]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'The following is the output of the preceding code:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.38: Output of console.log when using get without reference'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.38：在没有引用的情况下使用get时的console.log输出'
- en: '](Images/C14587_07_38.jpg)'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_38.jpg)'
- en: 'Figure 7.38: Output of console.log when using get without reference'
  id: totrans-644
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.38：在没有引用的情况下使用get时的console.log输出
- en: While we typed everything correctly, our Map doesn't seem to be able to find
    the value for that key. This is because, when doing these retrievals, it is using
    the reference to the object instead of the values.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们输入了所有正确的内容，但是我们的地图似乎无法找到该键的值。这是因为在进行这些检索时，它使用的是对象的引用而不是值。
- en: 'Iterate through the Map using `forEach`:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`迭代地图：
- en: '[PRE142]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The Map can be iterated through like an array. When using the `forEach` method,
    the function that is passed in will be called with two parameters: the first parameter
    is the value while the second parameter is the key.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 地图可以像数组一样进行迭代。使用`forEach`方法时，传入的函数将被调用两个参数：第一个参数是值，第二个参数是键。
- en: 'Get the list of keys and values as arrays:'
  id: totrans-649
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取键和值的数组列表：
- en: '[PRE143]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The following is the output of the preceding code:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.39: List of keys and values as arrays'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.39：键和值的数组列表'
- en: '](Images/C14587_07_39.jpg)'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_39.jpg)'
- en: 'Figure 7.39: List of keys and values as arrays'
  id: totrans-654
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.39：键和值的数组列表
- en: These methods are useful when you only need a part of the information it stores.
    If you have a Map tracking the users while using their IDs as keys, calling the
    `values` method will simply return a list of users.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 当您只需要存储信息的一部分时，这些方法非常有用。如果您有一个地图来跟踪用户，使用他们的ID作为键，调用`values`方法将简单地返回一个用户列表。
- en: 'Check whether the Map includes a key:'
  id: totrans-656
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查地图是否包含一个键：
- en: '[PRE144]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The following is the output of the preceding code:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.40: Output indicating that Map does not include a key'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.40：指示地图不包括键的输出'
- en: '](Images/C14587_07_40.jpg)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_40.jpg)'
- en: 'Figure 7.40: Output indicating that Map does not include a key'
  id: totrans-661
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.40：指示地图不包括键的输出
- en: Note
  id: totrans-662
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Here, we can see the first major difference between Maps and Objects, even though
    both are able to keep track of a list of unique key-value pairs. In Maps, you
    can have keys that are references of an object or function. This is not possible
    with Objects in JavaScript. Another thing we can see is that it also preserves
    the order of the keys according to the order that they are added to the Map. While
    you might get ordered keys in Objects, JavaScript does not guarantee the order
    for keys in terms of the order they are added into the Object.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到地图和对象之间的第一个主要区别，尽管两者都能够跟踪唯一键值对的列表。在地图中，您可以拥有对象或函数的引用作为键。这在JavaScript中的对象中是不可能的。我们还可以看到的另一件事是，它还保留了根据它们被添加到地图中的顺序的键的顺序。虽然您可能会在对象中获得有序的键，但JavaScript不能保证键的顺序与它们被添加到对象中的顺序一致。
- en: 'With this exercise, we went over the usage of Maps and its differences compared
    to Object. When you are dealing with key-value data and you need to do ordering,
    Map should be always preferred over Objects because not only does it keep the
    order of your keys, it also allows object references to be used as keys. That''s
    the main difference between the two types. In the next exercise, we will go over
    another type that is often overlooked by developers: Set.'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，我们了解了地图的用法及其与对象的区别。当你处理键值数据并且需要进行排序时，地图应该始终优先于对象，因为它不仅保留了键的顺序，还允许将对象引用用作键。这是两种类型之间的主要区别。在下一个练习中，我们将介绍另一种经常被开发人员忽视的类型：集合。
- en: In mathematics, a set is defined as a collection of distinct objects. In JavaScript,
    it is rarely used, but we are going to go over one usage of Set regardless.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 在数学中，集合被定义为不同对象的集合。在JavaScript中，它很少被使用，但是我们将无论如何介绍一种使用集合的方法。
- en: 'Exercise 55: Using Sets to Track Unique Values'
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习55：使用集合跟踪唯一值
- en: In this exercise, we will go over the JavaScript Set. We will be building an
    algorithm to remove all the duplicate values inside an array.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍JavaScript集合。我们将构建一个算法来删除数组中的所有重复值。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成此练习：
- en: 'Declare an array string called `planets`:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`planets`的字符串数组：
- en: '[PRE145]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Create a new Set using the array:'
  id: totrans-671
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组创建一个新的集合：
- en: '[PRE146]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Retrieve the unique values in the `planets` array:'
  id: totrans-673
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索`planets`数组中的唯一值：
- en: '[PRE147]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'The following is the output of the preceding code:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.41: Unique array values'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.41：唯一的数组值'
- en: '](Images/C14587_07_41.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_41.jpg)'
- en: 'Figure 7.41: Unique array values'
  id: totrans-678
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.41：唯一的数组值
- en: 'Add more values to the Set using the `add` method:'
  id: totrans-679
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`add`方法向集合添加更多值：
- en: '[PRE148]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'We can use the `add` method to add a new value to our Set, but because Set
    always maintains the uniqueness of its members, if you add anything that already
    exists, it will be ignored:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`add`方法向我们的集合添加一个新值，但是因为集合始终保持其成员的唯一性，如果您添加任何已经存在的内容，它将被忽略：
- en: '![Figure 7.42: Failure to add duplicate values'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.42：无法添加重复值'
- en: '](Images/C14587_07_42.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_42.jpg)'
- en: 'Figure 7.42: Failure to add duplicate values'
  id: totrans-684
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.42：无法添加重复值
- en: 'Get the size of the Set using the `.size` property:'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.size`属性获取Set的大小：
- en: '[PRE149]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Clear all the values inside the Set:'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清除集合中的所有值：
- en: '[PRE150]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The following is the output of the preceding code:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 7.43: All values cleared from the set'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: ！[图7.43：从集合中清除所有值
- en: '](Images/C14587_07_43.jpg)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: ']（Images/C14587_07_43.jpg）'
- en: 'Figure 7.43: All values cleared from the set'
  id: totrans-692
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.43：从集合中清除所有值
- en: In this exercise, we went over some ways in which we can use Set as a tool to
    help us remove duplicate values in our arrays. Sets are very useful when you want
    to keep a list of unique values with the smallest effort possible while you don't
    have any need to access them through an index. Otherwise, arrays are still the
    best choice if you are dealing with a lot of items that may include duplicates.
    In the next section, we will talk about the Math, Date, and String methods.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们介绍了一些使用Set作为工具来帮助我们在数组中删除重复值的方法。当您想要保留一系列唯一值并且不需要通过索引访问它们时，集合非常有用。否则，如果您处理可能包含重复项的大量项目，则数组仍然是最佳选择。在下一节中，我们将讨论Math，Date和String方法。
- en: Math, Date, and String
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学，日期和字符串
- en: When building complex applications using JavaScript, there will be times when
    you need to deal with string manipulation, math calculations, and dates. Luckily,
    JavaScript has several built-in methods for this type of data. In the following
    exercises, we will go over the ways we can utilize these in our applications.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript构建复杂应用程序时，有时您需要处理字符串操作，数学计算和日期。幸运的是，JavaScript有几种内置方法可以处理这种类型的数据。在接下来的练习中，我们将介绍如何在应用程序中利用这些方法。
- en: 'To create a `new Date` object, use the following command:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`new Date`对象，请使用以下命令：
- en: '[PRE151]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This will point to the current date.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指向当前日期。
- en: 'To create a new string, use the following command:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新字符串，请使用以下命令：
- en: '[PRE152]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'To use the `Math` module, we can use the `Math` class:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`Math`模块，我们可以使用`Math`类：
- en: '[PRE153]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Exercise 56: Using String Methods'
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习56：使用字符串方法
- en: In this exercise, we will go over some of the ways we can work with strings
    more easily in our applications. String manipulation and building have always
    been complex tasks in other languages. In JavaScript, by using String methods,
    we can create, match, and manipulate strings with ease. In this exercise, we will
    create various strings and use String methods to manipulate them.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将介绍一些更容易在应用程序中处理字符串的方法。在其他语言中，字符串操作和构建一直是复杂的任务。在JavaScript中，通过使用String方法，我们可以轻松地创建，匹配和操作字符串。在这个练习中，我们将创建各种字符串并使用String方法来操作它们。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Create a variable called `planet`:'
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`planet`的变量：
- en: '[PRE154]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Create a `sentence` using template strings:'
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板字符串创建`句子`：
- en: '[PRE155]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: A template strings is a very useful feature that was introduced in ES6\. We
    can create strings by combining templates and variables without the need to create
    a string build or using string concatenation. String templates are wrapped using
    [PRE156]
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串是ES6中引入的非常有用的功能。我们可以通过组合模板和变量来创建字符串，而无需创建字符串构建或使用字符串连接。字符串模板使用[PRE156]包装
- en: console.log(sentence.split(' '));
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（sentence.split（' '））;
- en: '[PRE157]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: sentence = sentence.replace('Earth', 'Venus');
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 句子=句子.replace（'地球'，'金星'）;
- en: console.log(sentence);
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（句子）;
- en: '[PRE158]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: console.log(sentence.includes('Mars'));
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（sentence.includes（'Mars'））;
- en: '[PRE159]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: sentence.toUpperCase();
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 句子.toUpperCase（）;
- en: sentence.toLowerCase();
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: sentence.toLowerCase（）;
- en: '[PRE160]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: sentence.charAt(0); // returns W
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: sentence.charAt（0）; //返回W
- en: '[PRE161]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: sentence.length;
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 句子长度;
- en: '[PRE162]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: function generateRandomString(length) {
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: function generateRandomString（长度）{
- en: '}'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE163]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: function generateRandomNumber(min, max) {
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: function generateRandomNumber（min，max）{
- en: return Math.floor(Math.random() * (max - min + 1)) + min;
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Math.floor（Math.random（）*（max-min + 1）+ min;
- en: '}'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE164]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: function generateRandomString(length) {
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: function generateRandomString（长度）{
- en: const characters = [];
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: const characters = [];
- en: const characterSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: const characterSet ='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
- en: for (let i = 0; i < length; i++) {
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: for（let i = 0; i <长度; i ++）{
- en: characters.push(characterSet.charAt(generateRandomNumber(0, characterSet.length)));
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: characters.push（characterSet.charAt（generateRandomNumber（0，characterSet.length）））;
- en: '}'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return characters.join(');
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 返回characters.join（'）;
- en: '}'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE165]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: console.log(generateRandomString(16));
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（generateRandomString（16））;
- en: '[PRE166]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: function circleArea(radius) {
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: function circleArea（半径）{
- en: return Math.pow(radius, 2) * Math.PI;
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Math.pow（半径，2）* Math.PI;
- en: '}'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE167]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: const now = new Date();
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的const = new Date（）;
- en: console.log(now);
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（现在）;
- en: '[PRE168]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: const past = new Date('August 31, 2007 00:00:00');
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: const past = new Date（'2007年8月31日00:00:00'）;
- en: '[PRE169]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: console.log(past.getFullYear());
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（过去.getFullYear（））;
- en: console.log(past.getMonth());
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（过去.getMonth（））;
- en: console.log(past.getDate());
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（过去.getDate（））;
- en: '[PRE170]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: console.log(past.toString());
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（过去.toString（））;
- en: '[PRE171]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: console.log(Math.floor(Date.now() / 1000));
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（Math.floor（Date.now（）/ 1000））;
- en: '[PRE172]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: let symbol1 = Symbol();
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: let symbol1 = Symbol（）;
- en: let symbol2 = Symbol('symbol');
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: let symbol2 = Symbol（'symbol'）;
- en: '[PRE173]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: console.log(symbol1 === symbol2);
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（symbol1 === symbol2）;
- en: console.log(symbol1 === Symbol('symbol'));
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（symbol1 === Symbol（'symbol'））;
- en: '[PRE174]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: const testObj = {};
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: const testObj = {};
- en: testObj.name = 'test object';
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: testObj.name ='测试对象';
- en: testObj.included = 'this will be included';
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: testObj.included ='这将被包含';
- en: '[PRE175]'
  id: totrans-769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: const symbolKey = Symbol();
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: const symbolKey = Symbol（）;
- en: testObj[symbolKey] = 'this will be hidden';
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: testObj [symbolKey] ='这将被隐藏';
- en: '[PRE176]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: console.log(Object.keys(testObj));
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（Object.keys（testObj））;
- en: '[PRE177]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: console.log(testObj[Symbol()]); // Will return undefined
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（testObj [Symbol（）]）; //将返回未定义
- en: console.log(testObj[symbolKey]); // Will return our hidden property
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（testObj [symbolKey]）; //将返回我们的隐藏属性
- en: '[PRE178]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: const anotherSymbolKey = Symbol.for('key');
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: const anotherSymbolKey = Symbol.for（'key'）;
- en: const copyOfAnotherSymbol = Symbol.for('key');
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: const copyOfAnotherSymbol = Symbol.for（'key'）;
- en: '[PRE179]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: testObj[anotherSymbolKey] = 'another key';
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: testObj [anotherSymbolKey] ='另一个键';
- en: console.log(testObj[copyOfAnotherSymbol]);
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（testObj [copyOfAnotherSymbol]）;
- en: '[PRE180]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: function range(max) {
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: function range（max）{
- en: return {
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 返回{
- en: '*[Symbol.iterator]() {'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Symbol.iterator]（）{'
- en: yield 1;
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 产量1;
- en: '}'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE181]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: for (let value of range(10)) {
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: for（let value of range（10））{
- en: console.log(value);
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: console.log（值）;
- en: '}'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE182]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: function range(max) {
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: function range（max）{
- en: return {
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 返回{
- en: '*[Symbol.iterator]() {'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '*[Symbol.iterator]（）{'
- en: for (let i = 0; i < max; i++) {
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: for（let i = 0; i <max; i ++）{
- en: yield i;
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 产量i;
- en: '}'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE183]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: function* gen() {
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: function* gen() {
- en: yield 1;
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: yield 1;
- en: '}'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE184]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: const generator = gen();
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: const generator = gen();
- en: '[PRE185]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: console.log(generator.next());
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(generator.next());
- en: console.log(generator.next());
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(generator.next());
- en: console.log(generator.next());
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(generator.next());
- en: '[PRE186]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: const handlers = {
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: const handlers = {
- en: 'set: (object, prop, value) => {'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 'set: (object, prop, value) => {'
- en: console.log('setting ' + prop);
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: console.log('setting ' + prop);
- en: '}'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: const proxiesValue = new Proxy({}, handlers);
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: const proxiesValue = new Proxy({}, handlers);
- en: proxiesValue.prop1 = 'hi';
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: proxiesValue.prop1 = 'hi';
- en: '[PRE187]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: const simpleObject = {};
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: const simpleObject = {};
- en: '[PRE188]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: const handlers = {
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: const handlers = {
- en: '}'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE189]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: const proxiesValue = new Proxy(simpleObject, handlers);
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: const proxiesValue = new Proxy(simpleObject, handlers);
- en: '[PRE190]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: const handlers = {
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: const handlers = {
- en: 'get: (object, prop) => {'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 'get: (object, prop) => {'
- en: return 'values are private';
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: return 'values are private';
- en: '}'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE191]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: proxiedValue.key1 = 'value1';
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: proxiedValue.key1 = 'value1';
- en: console.log(proxiedValue.key1);
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(proxiedValue.key1);
- en: console.log(proxiedValue.keyDoesntExist);
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: console.log(proxiedValue.keyDoesntExist);
- en: '[PRE192]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'set: (object, prop, value) => {'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 'set: (object, prop, value) => {'
- en: if (prop === 'id') {
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: if (prop === 'id') {
- en: if (!Number.isInteger(value)) {
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: if (!Number.isInteger(value)) {
- en: throw new TypeError('The id needs to be an integer');
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: throw new TypeError('The id needs to be an integer');
- en: '}'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE193]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: proxiedValue.id = 'not an id'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: proxiedValue.id = 'not an id'
- en: '[PRE194]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: function appendPrefix(prefix, input) {
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: function appendPrefix(prefix, input) {
- en: const result = [];
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: const result = [];
- en: for (var i = 0; i < input.length; i++) {
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: for (var i = 0; i < input.length; i++) {
- en: result.push(prefix + input[i]);
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: result.push(prefix + input[i]);
- en: '}'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: return result;
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: return result;
- en: '}'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE195]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
- en: '[PRE196]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: function appendPrefix(prefix, input) {
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: function appendPrefix(prefix, input) {
- en: return input.map((inputItem) => {
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: return input.map((inputItem) => {
- en: return prefix + inputItem;
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: return prefix + inputItem;
- en: '});'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '});'
- en: '}'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE197]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: appendPrefix('Hi! ', ['Miku', 'Rin', 'Len']);
- en: '```'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We will still get the same output:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会得到相同的输出：
- en: '![Figure 7.61: Getting the same output after refactoring the code'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.61：重构代码后获得相同的输出'
- en: '](Images/C14587_07_60.jpg)'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_07_60.jpg)'
- en: 'Figure 7.61: Getting the same output after refactoring the code'
  id: totrans-872
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图7.61：重构代码后获得相同的输出
- en: 'Activity 10: Refactoring Functions to Use Modern JavaScript Features'
  id: totrans-873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动10：重构函数以使用现代JavaScript特性
- en: You have recently joined a company. The first task that's been assigned to you
    is to refactor a number of legacy modules. You opened the file and saw that the
    existing code has already been written using legacy JavaScript methods. You'll
    need to refactor all the functions in that file and make sure it can still pass
    the required test.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 你最近加入了一家公司。分配给你的第一个任务是重构一些遗留模块。你打开了文件，发现现有的代码已经使用了遗留的JavaScript方法编写。你需要重构该文件中的所有函数，并确保它仍然可以通过所需的测试。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Run `Activity10.js` using node.js to check that the tests have passed.
  id: totrans-876
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用node.js运行`Activity10.js`来检查测试是否通过。
- en: Refactor the `itemExist` function using the `includes` array.
  id: totrans-877
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`includes`数组重构`itemExist`函数。
- en: Use `array push` to add a new item to the bottom of the `pushunique` function.
  id: totrans-878
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`pushunique`函数中使用`array push`来向底部添加一个新项。
- en: Use `array.fill` in `createFilledArray` to fill our array with an initial value.
  id: totrans-879
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`createFilledArray`中使用`array.fill`来用初始值填充我们的数组。
- en: Use `array.shift` in the `removeFirst` function to remove the first item.
  id: totrans-880
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`removeFirst`函数中使用`array.shift`来移除第一项。
- en: Use `array.pop` in the `removeLast` function to remove the last item.
  id: totrans-881
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`removeLast`函数中使用`array.pop`来移除最后一项。
- en: Use the spread operator in `cloneArray` to make a clone of our array.
  id: totrans-882
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`cloneArray`中使用展开运算符来克隆我们的数组。
- en: Refactor the `Food` class using the `ES6` class.
  id: totrans-883
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ES6`类重构`Food`类。
- en: After refactoring, run the code to observe that the same output is generated
    as it was by the legacy code.
  id: totrans-884
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构后，运行代码以观察与旧代码生成相同的输出。
- en: Note
  id: totrans-885
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 611.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第611页找到。
- en: In this activity, we learned how to use modern JavaScript functions by using
    refactoring functions. We have successfully learned how to rewrite code while
    maintaining its compatibility.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，我们学会了如何通过重构函数来使用现代JavaScript函数。我们已经成功学会了如何重写代码同时保持其兼容性。
- en: Summary
  id: totrans-888
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we started by looking at the ways we can construct and manipulate
    arrays and objects in JavaScript. Then, we looked at ways we can concatenate arrays
    and objects using spread operators. Using spread operators saves us from having
    to write functions without a loop. Later, we looked at ways we can do OOP in JavaScript.
    By using these classes and class inheritance, we can build complex applications
    without having to write a lot of duplicate code. We also looked at built-in methods
    for Array, Map, Set, Regex, Date, and Math. These are very helpful when we need
    to deal with a large number of different types of data. Lastly, Symbols, Iterators,
    Generators, and Proxies opened up a huge range of possibilities when it comes
    to making our program dynamic and clean. This concludes our chapter on advanced
    JavaScript. In the next chapter, we will talk about asynchronous programming in
    JavaScript.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先看了一下在JavaScript中构建和操作数组和对象的方法。然后，我们看了一下使用展开运算符来连接数组和对象的方法。使用展开运算符可以避免我们编写不带循环的函数。后来，我们看了一下在JavaScript中进行面向对象编程的方法。通过使用这些类和类继承，我们可以构建复杂的应用程序，而不必编写大量重复的代码。我们还看了Array、Map、Set、Regex、Date和Math的内置方法。当我们需要处理大量不同类型的数据时，这些方法非常有用。最后，符号、迭代器、生成器和代理在使我们的程序动态和清晰方面开辟了广阔的可能性。这结束了我们关于高级JavaScript的章节。在下一章中，我们将讨论JavaScript中的异步编程。
