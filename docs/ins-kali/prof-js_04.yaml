- en: '*Chapter 4*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*'
- en: RESTful APIs with Node.js
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Node.js创建RESTful API
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Set up the project structure for an Express.js API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Express.js API设置项目结构
- en: Design an API with endpoints using different HTTP methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用不同的HTTP方法设计具有端点的API
- en: Run the API on the localhost and interact with it via cURL or a GUI-based tool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地主机上运行API，并通过cURL或基于GUI的工具与其交互
- en: Parse user inputs for endpoints and consider different ways of dealing with
    errors
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析端点的用户输入，并考虑处理错误的不同方式
- en: Set up an endpoint that requires user authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置需要用户身份验证的端点
- en: In this chapter, we will use Express.js and Node.js to set up an API that can
    be used by frontend applications.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Express.js和Node.js来设置一个可以供前端应用程序使用的API。
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: '**Application Program Interfaces** (**APIs**) have become more important than
    ever. The use of an API allows for a single server-side program to be used by
    multiple scripts and applications. Due to its usefulness, API management has become
    one of the most common tasks for backend developers using Node.js.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序编程接口**（**API**）变得比以往任何时候都更加重要。使用API可以使单个服务器端程序被多个脚本和应用程序使用。由于其有用性，使用Node.js的后端开发人员的API管理已成为最常见的任务之一。'
- en: Let's take the example of a company with both a website and a mobile app. Both
    of these front-facing interfaces require essentially the same functionality from
    the server. By wrapping this functionality in an API, we allow for clean separation
    and reuse of the server-side code. Gone are the days of clunky PHP applications
    that embed backend functionality directly into the interface code of a website.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个既有网站又有移动应用程序的公司为例。这两个前端界面都需要服务器端的基本相同功能。通过将这些功能封装在API中，我们可以实现服务器端代码的清晰分离和重用。过去那些将后端功能直接嵌入网站界面代码的笨拙PHP应用程序的时代已经一去不复返。
- en: We'll use Node.js to set up a **Representational State Transfer** (**REST**)
    API. Our API will run on Express.js, a popular web application framework with
    routing functionality. With these tools, we can quickly have an endpoint running
    on our localhost. We'll look at the best practices for setting up an API as well
    as the specific syntax that is used in the Express.js library. In addition to
    this, we will also consider the basics of API design, simplifying its use for
    the developers and services that use it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Node.js来设置一个**表述状态转移**（**REST**）API。我们的API将在Express.js上运行，这是一个具有路由功能的流行Web应用程序框架。借助这些工具，我们可以快速在本地主机上运行一个端点。我们将研究设置API的最佳实践，以及Express.js库中使用的特定语法。除此之外，我们还将考虑API设计的基础知识，简化开发人员和使用它的服务的使用。
- en: What is an API?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是API？
- en: An API is a standardized way of interacting with a software application. APIs
    allow different software applications to interact with each other without having
    to understand the inner workings of the underlying functions.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: API是与软件应用程序进行交互的标准化方式。API允许不同的软件应用程序相互交互，而无需了解底层功能的内部工作原理。
- en: 'APIs have become popular in modern software engineering as they allow organizations
    to be more effective by reusing code. Take the use of maps as an example: before
    the popularization of APIs, organizations needing map functionality would have
    to maintain map widgets internally. Often, these map widgets would perform poorly,
    as they were only a secondary concern of their business and engineering teams.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: API在现代软件工程中变得流行，因为它们允许组织通过重用代码更加有效。以地图的使用为例：在API普及之前，需要地图功能的组织必须在内部维护地图小部件。通常，这些地图小部件的性能会很差，因为它们只是业务和工程团队的次要关注点。
- en: Now it's rare for a website or application that uses a map to maintain it internally.
    Many applications for the web and mobile phones are utilizing map APIs from either
    Google or alternatives such as OpenStreetMap. This allows each company to focus
    on its core competency by not having to create and maintain their own map widgets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用地图的网站或应用程序很少在内部维护地图。许多网络和手机应用程序都使用来自Google或OpenStreetMap等替代方案的地图API。这使得每家公司都可以专注于其核心竞争力，而不必创建和维护自己的地图小部件。
- en: There are several successful start-ups whose business models revolve around
    providing a service via an API. Some examples include well-known companies such
    as Twilio, Mailgun, and Sentry. In addition to this, there are several smaller
    companies that offer unique services via APIs, such as Lob, which can send physical
    letters and postcards on request via their API. Here, developers simply send the
    contents of the letter and the destination address to Lob's API and it will automatically
    be printed and sent in the mail on the developer's behalf. Here are a few examples
    of the API services provided by a number of well-known companies.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 有几家成功的初创公司的业务模式围绕着通过API提供服务。一些例子包括著名公司如Twilio、Mailgun和Sentry。除此之外，还有一些较小的公司通过API提供独特的服务，比如Lob，它可以通过其API根据请求发送实体信件和明信片。在这里，开发人员只需将信件内容和目的地地址发送到Lob的API，它就会自动打印并代表开发人员寄出。以下是一些知名公司提供的API服务的示例。
- en: '![](Images/C14587_04_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_04_01.jpg)'
- en: 'Figure 4.1: API-based company examples'
  id: totrans-20
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：基于API的公司示例
- en: These companies enable developers to make apps better and faster by providing
    building blocks that can be used to provide a particular service. The proof of
    its effectiveness can be seen in the widespread adoption of these services. Companies
    that use Twilio to provide text or phone integration include Coca-Cola, Airbnb,
    Uber, Twitch, and many others. Many of those companies, in turn, provide their
    own APIs for other companies and developers to build upon. This trend is referred
    to as the API economy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些公司通过提供可用于提供特定服务的构建块，使开发人员能够更好地、更快地开发应用程序。其有效性的证明可以从这些服务的广泛采用中看出。使用Twilio提供文本或电话集成的公司包括可口可乐、Airbnb、优步、Twitch等许多其他公司。这些公司中的许多公司又为其他公司和开发人员提供自己的API来构建。这种趋势被称为API经济。
- en: Another thing these services all have in common is that they use REST via HTTP.
    New developers often assume that all APIs are used via HTTP; however, when we
    talk about an API, there is no restriction on the protocol or medium used. The
    interface of an API could theoretically be anything from a button to a radio wave.
    While there are many interface options to choose from, HTTP is still the most
    widely used medium. In the next section, we'll discuss REST in more detail.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务的另一个共同点是它们都通过HTTP使用REST。新开发人员经常认为所有API都是通过HTTP使用的；然而，当我们谈论API时，对使用的协议或介质没有限制。API的接口理论上可以是任何东西，从按钮到无线电波。虽然有许多接口选项可供选择，但HTTP仍然是最广泛使用的介质。在下一节中，我们将更详细地讨论REST。
- en: What is REST?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST是什么？
- en: REST is a software architecture pattern for creating web-based services. This
    means that resources are represented by a specific URL endpoint, for example,
    `website.com/post/12459`, where a website's post can be accessed by using its
    specific ID. REST is the method of mapping resources to URL endpoints.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一种用于创建基于web的服务的软件架构模式。这意味着资源由特定的URL端点表示，例如`website.com/post/12459`，可以使用其特定ID访问网站的帖子。REST是将资源映射到URL端点的方法。
- en: A related concept in the area of database management is that of **CRUD** (**create,
    read, update, and delete**). These are the four ways in which you can interact
    with database resources. Similarly, there are also four ways in which we generally
    interact with resource objects defined by our API endpoints. The HTTP protocol
    has built-in methods that facilitate tasks such as `POST`, `GET`, `PUT`, and `DELETE`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库管理领域的一个相关概念是**CRUD**（**创建、读取、更新和删除**）。这是你可以与数据库资源交互的四种方式。同样，我们通常与由我们的API端点定义的资源对象交互的方式也有四种。HTTP协议具有内置方法，可以简化诸如`POST`、`GET`、`PUT`和`DELETE`等任务。
- en: 'The functionalities of the previously mentioned tasks are as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 先前提到的任务的功能如下：
- en: '`POST`: Creates an object resource'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建对象资源'
- en: '`GET`: Retrieves information about the object resource'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：检索有关对象资源的信息'
- en: '`PUT`: Updates a specific object''s information'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新特定对象的信息'
- en: '`DELETE`: Removes a specific object'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除特定对象'
- en: 'Additional Methods: In addition to the four main methods, there are some other
    less frequently used methods. We won''t use them here and you shouldn''t worry
    about them as they are rarely used by clients and servers:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法：除了四种主要方法外，还有一些其他不太常用的方法。我们不会在这里使用它们，你也不必担心它们，因为客户端和服务器很少使用它们：
- en: '`HEAD`: This is the same as `GET` but only retrieves headers and not the body.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HEAD`：与`GET`相同，但只检索标头而不是主体。'
- en: '`OPTIONS`: This returns a list of allowed options for the server or API.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：返回服务器或API的允许选项列表。'
- en: '`CONNECT`: This is used for creating an HTTP tunnel.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONNECT`：用于创建HTTP隧道。'
- en: '`TRACE`: This is a message loopback used for debugging.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TRACE`：这是用于调试的消息回路。'
- en: '`PATCH`: This is similar to `PUT` but is used for updating a single value.
    Note that `PUT` can be used instead of `PATCH`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：这类似于`PUT`，但用于更新单个值。请注意，`PUT`可以代替`PATCH`使用。'
- en: Express.js for RESTful APIs on Node.js
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Express.js用于Node.js上的RESTful API
- en: The good news is that if you understand basic JavaScript, you're already halfway
    to creating your first API. Using Express.js, we can easily construct HTTP endpoints.
    Express is a popular and minimal web framework that is used for creating and hosting
    web applications on a node. It includes several built-in routing methods that
    allow us to map incoming requests. There are many middleware packages that make
    common tasks easier. We will use a validation package later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如果你了解基本的JavaScript，你已经完成了创建你的第一个API的一半。使用Express.js，我们可以轻松构建HTTP端点。Express是一个流行的、最小的web框架，用于在节点上创建和托管web应用程序。它包括几种内置的路由方法，允许我们映射传入的请求。有许多中间件包可以使常见任务更容易。在本章后面，我们将使用一个验证包。
- en: In this chapter, we'll be creating various aspects of a hypothetical smart-house
    API. This will require adding endpoints for various devices that have logic to
    change the state of the devices. Some of the endpoints will be open to anyone
    in the network, for example, a smart light, while others, such as a heater, will
    require authentication.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个假设的智能房屋API的各个方面。这将需要为具有改变设备状态逻辑的各种设备添加端点。一些端点将对网络中的任何人开放，例如智能灯，而其他一些，如加热器，将需要身份验证。
- en: Note
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: What is a smart house? A smart house is a house that contains internet-connected
    devices, which you can interact with via a cloud-based control system. The trend
    of devices that are connected to the internet and communicate with users and other
    devices is often referred to as the **Internet of Things** (**IoT**).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是智能房屋？智能房屋是一个包含互联网连接设备的房屋，您可以通过基于云的控制系统与之交互。与用户和其他设备通信的互联网连接设备的趋势通常被称为**物联网**（**IoT**）。
- en: In this chapter, we'll write an API for a house that contains smart devices,
    including a smart lightbulb and a heater. The code files for this exercise are
    available at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise16](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise16).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将为一个包含智能设备的房屋编写API，包括智能灯泡和加热器。此练习的代码文件可在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise16](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise16)上找到。
- en: 'Exercise 16: Creating an Express Project with an Index Route'
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习16：创建一个带有索引路由的Express项目
- en: 'In this exercise, our aim is to create a new node project, install Express,
    and then create an index route that returns a JSON object with a single attribute
    of the message. Once it''s running, we can test it by making a cURL request to
    our localhost. To do this, perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是创建一个新的节点项目，安装Express，然后创建一个返回带有消息单个属性的JSON对象的索引路由。一旦它运行起来，我们可以通过在本地主机上进行cURL请求来测试它。要做到这一点，执行以下步骤：
- en: 'Create a folder called `smartHouse` and initiate an `npm` project:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`smartHouse`的文件夹并初始化一个`npm`项目：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the `express` library, using the `-s` flag to have it saved to our
    `package.json` file:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`express`库，使用`-s`标志将其保存到我们的`package.json`文件中：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a file called `server.js` that imports `express` and makes an `app`
    object:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`server.js`的文件，导入`express`并创建一个`app`对象：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add an `app.get` method that specifies `''/''` for our index route in `server.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`中添加一个指定'/'的`app.get`方法，用于我们的索引路由：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code creates an `HTTP GET` function that returns an object called
    `info` with a single attribute of `message`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个`HTTP GET`函数，返回一个名为`info`的对象，其中包含一个名为`message`的属性。
- en: 'Add an `app.listen` function that tells our application to listen on `port
    3000`:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`app.listen`函数，告诉我们的应用程序监听`端口3000`：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding steps are all that is needed for a simple example of the Node.js
    Express API. By running the preceding code, we'll create an application on our
    localhost that returns a simple JSON object.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的步骤就是一个简单的Node.js Express API示例所需的全部内容。通过运行前面的代码，我们将在本地主机上创建一个应用程序，返回一个简单的JSON对象。
- en: 'In another Terminal window, return to the root of your `smartHouse` folder
    and run the following command:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，返回到您的`smartHouse`文件夹的根目录并运行以下命令：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Confirm the application is running correctly by going to `localhost:3000` in
    your web browser:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Web浏览器中转到`localhost:3000`，确认应用程序是否正确运行：
- en: '![Figure 4.2: Showing localhost:3000 in the web browser'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：在Web浏览器中显示localhost:3000'
- en: '](Images/C14587_04_02.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_02.jpg)'
- en: 'Figure 4.2: Showing localhost:3000 in the web browser'
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：在Web浏览器中显示localhost:3000
- en: If you've copied the code correctly, you should see a JSON object being served
    at **localhost:3000**, as displayed in the preceding screenshot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已正确复制了代码，您应该在**localhost:3000**看到一个JSON对象被提供，就像在前面的屏幕截图中显示的那样。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If, during any step, you're having trouble or aren't sure what the project files
    should look like, you can use the project folders to move your code back in line
    with the project. The folders will be named based on which step they're associated
    with, for example, `Exercise01, Exercise02`, and so on. When you first go into
    a folder, make sure to run `npm install` to install any modules used by the project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在任何步骤中遇到问题或不确定项目文件应该是什么样子，您可以使用项目文件夹将代码恢复到与项目一致的状态。文件夹将根据它们关联的步骤命名，例如`Exercise01，Exercise02`等。当您第一次进入文件夹时，请确保运行`npm
    install`来安装项目使用的任何模块。
- en: Interacting with Your API via HTTP
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过HTTP与您的API进行交互
- en: In this section, we'll interact with the server created in *Exercise 16,* *Creating
    an Express Project with an Index Route*. Therefore, make sure you keep a Terminal
    window open with the server running. If you've since closed that window or turned
    it off, simply return to the `smartHouse` folder and run `npm start`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将与*练习16*中创建的服务器进行交互，*创建一个带有索引路由的Express项目*。因此，请确保您保持一个终端窗口打开并运行服务器。如果您已经关闭了该窗口或关闭了它，只需返回到`smartHouse`文件夹并运行`npm
    start`。
- en: 'We verified that our API is running by using the web browser. A web browser
    is the easiest way to look at a route, but it is limited and only works for `GET`
    requests. In this section, we''ll look at two other methods for interacting with
    the API in a more advanced way, both of which allow for more advanced requests
    including the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用Web浏览器验证了我们的API正在运行。Web浏览器是查看路由的最简单方式，但它有限，只适用于`GET`请求。在本节中，我们将介绍另外两种与API进行更高级交互的方法，这两种方法都允许进行更高级的请求，包括以下内容：
- en: Requests beyond `GET`, including `PUT`, `POST`, and `DELETE`
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超出`GET`的请求，包括`PUT`、`POST`和`DELETE`
- en: Adding header information to your requests
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向您的请求添加标头信息
- en: Including authorization information for protected endpoints
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为受保护的端点包括授权信息
- en: 'My preferred method is to use the command-line tool cURL. cURL stands for Client
    for URLs. It comes installed on most versions of macOS, Linux, and Windows 10
    (for versions released in 2018 and later). It is a command-line tool for making
    HTTP requests. For a very simple command, run the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我首选的方法是使用命令行工具cURL。cURL代表URL的客户端。它已安装在大多数版本的macOS、Linux和Windows 10上(2018年及以后的版本)。它是一个用于进行HTTP请求的命令行工具。对于一个非常简单的命令，运行以下命令：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output of the preceding code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](Images/C14587_04_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_04_03.jpg)'
- en: 'Figure 4.3: Showing cURL localhost:3000'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：显示cURL localhost:3000
- en: Note
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The command-line program `jq` will be used throughout this chapter to format
    cURL requests. `jq` is a lightweight and flexible command-line JSON processor.
    The program is available for macOS, Linux, and Windows. If you cannot get it installed
    on your system, you can still use `curl` without `jq`. To do so, simply remove
    the `| jq` command from the end of any curl command in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行程序`jq`将在本章中用于格式化cURL请求。`jq`是一个轻量级和灵活的命令行JSON处理器。该程序适用于macOS、Linux和Windows。如果您无法在系统上安装它，仍然可以使用不带`jq`的`curl`。要这样做，只需从本章中任何curl命令的末尾删除`|
    jq`命令。
- en: Instructions for installing `jq` can be found at [https://github.com/stedolan/jq](https://github.com/stedolan/jq).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 安装`jq`的说明可以在[https://github.com/stedolan/jq](https://github.com/stedolan/jq)找到。
- en: 'By using `curl` with `jq`, we can make reading the output a bit easier, which
    will be especially useful once our JSON becomes more complex. In the following,
    we''ll repeat the same curl command as in the preceding example, but this time
    using a Unix pipe (`|`) to feed the output into `jq`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用带有`jq`的`curl`，我们可以使阅读输出变得更容易，这将在我们的JSON变得更复杂时特别有用。在下面的示例中，我们将重复与前面示例中相同的curl命令，但这次使用Unix管道(`|`)将输出传送到`jq`：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When piping `curl` into `jq` as in the preceding command, we'll use the `-s`
    flag, which stands for "silent." If `curl` is piped without this flag, you'll
    also see unwanted information about the speed of the request.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当像前面的命令一样将`curl`传送到`jq`时，我们将使用`-s`标志，该标志代表“静默”。如果`curl`在没有此标志的情况下进行传送，您还将看到关于请求速度的不需要的信息。
- en: 'Assuming that you''ve done everything correctly, you should observe some cleanly
    displayed JSON as the output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经做了一切正确的事情，你应该观察到一些干净的JSON作为输出显示：
- en: '![Figure 4.4: cURL piped to jq'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4：cURL管道传输到jq'
- en: '](Images/C14587_04_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_04.jpg)'
- en: 'Figure 4.4: cURL piped to jq'
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：cURL管道传输到jq
- en: 'If you prefer using a GUI-based application, you can use Postman, which is
    a Chrome extension that can easily send HTTP requests in a straightforward manner.
    Generally, I prefer cURL and jq for quick use on the command line. However, for
    more complex use cases, I may open up Postman, as the GUI makes dealing with headers
    and authorization a bit easier. For instructions on installing Postman, check
    out the website at [https://www.getpostman.com](https://www.getpostman.com):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢使用基于GUI的应用程序，你可以使用Postman，它是一个Chrome扩展程序，可以以直接的方式轻松发送HTTP请求。一般来说，我更喜欢在命令行上快速使用cURL和jq。然而，对于更复杂的用例，我可能会打开Postman，因为GUI使得处理头部和授权变得更容易一些。有关安装Postman的说明，请访问网站[https://www.getpostman.com](https://www.getpostman.com)：
- en: '![Figure 4.5: Screenshot of the cURL request in Postman'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：Postman中cURL请求的屏幕截图'
- en: '](Images/C14587_04_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_05.jpg)'
- en: 'Figure 4.5: Screenshot of the cURL request in Postman'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：Postman中cURL请求的屏幕截图
- en: 'Exercise 17: Creating and Importing a Route File'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习17：创建和导入路由文件
- en: Currently, our application is running with a single endpoint at the root URL.
    Typically, an API will have many routes, and keeping them all in the main `server.js`
    file will quickly cause the project to become unorganized. To prevent this, we'll
    separate each of our routes into modules and import each one into our `server.js`
    file.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序在根URL上运行一个端点。通常，一个API会有许多路由，将它们全部放在主`server.js`文件中会很快导致项目变得杂乱。为了防止这种情况发生，我们将把每个路由分离成模块，并将每个模块导入到我们的`server.js`文件中。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this example can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise17](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise17).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise17](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise17)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'To get started, create a new folder in the `smartHouse` folder:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，创建`smartHouse`文件夹中的一个新文件夹：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create the `routes/index.js` file and move the `import` statements and `main`
    function from `server.js` into that file. Then, below that, we''ll add a line
    that exports the `router` object as a module:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`routes/index.js`文件，并将`server.js`中的`import`语句和`main`函数移动到该文件中。然后，在下面，我们将添加一行将`router`对象导出为一个模块：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code is essentially the code we wrote in the first exercise being
    moved to a different file. The crucial difference is the very bottom line where
    it says `module.exports = router;`. This line takes the `router` object we create
    and makes it available for importing into another file. Every time we create a
    new route file, it will contain that same bottom line for exporting.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码本质上是我们在第一个练习中编写的代码移动到不同的文件中。关键的区别在于底部的一行，那里写着 `module.exports = router;`。这一行将我们创建的
    `router` 对象导出，并使其可以被导入到另一个文件中。每当我们创建一个新的路由文件时，它都会包含相同的底部导出行。
- en: 'Open `server.js` and delete lines 3 to 8, as the `app.get` method has been
    moved to the `/routes/index.js` file. Then, we''ll import the `path` and `fs`
    (filesystem) libraries. We''ll also import a library called `http-errors`, which
    will be used later on for managing HTTP errors. The top nine lines of `server.js`
    will read as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`server.js`并删除第3到第8行，因为`app.get`方法已经移动到`/routes/index.js`文件中。然后，我们将导入`path`和`fs`（文件系统）库。我们还将导入一个名为`http-errors`的库，稍后将用于管理HTTP错误。`server.js`的前九行将如下所示：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Below that, also in `server.js`, we''ll turn on URL encoding and tell `express`
    to use JSON:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在`server.js`中，我们将打开URL编码，并告诉`express`使用JSON：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we will import our index route and associate it with a path. After we''ve
    done that and the preceding steps, `server.js` should contain the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将导入我们的索引路由并将其与一个路径关联起来。在我们完成了这些步骤之后，`server.js`应该包含以下内容：
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can create a catch-all `404` error for any URL that is visited that doesn''t
    have a corresponding function. Inside the `app.use` method, we''ll set the HTTP
    status code to `404` and then use the `http-errors` library we imported in *step
    2* to create a catch-all `404` error (it''s important that the following code
    is underneath all other route declarations):'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以为任何访问的URL创建一个捕获所有的`404`错误，这些URL没有对应的函数。在`app.use`方法内部，我们将HTTP状态码设置为`404`，然后使用我们在*步骤2*中导入的`http-errors`库创建一个捕获所有的`404`错误（重要的是以下代码位于所有其他路由声明的下方）：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final line in the file should exist from our previous exercise:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件的最后一行应该存在于我们之前的练习中：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With this done, running our code should produce the following output, which
    is identical to the result in *Exercise 16, Creating an Express Project with an
    Index Route*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些步骤后，运行我们的代码应该产生以下输出，与*练习16，创建带有索引路由的Express项目*中的结果相同：
- en: '![Figure 4.6: Output message'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：输出消息'
- en: '](Images/C14587_04_06.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_06.jpg)'
- en: 'Figure 4.6: Output message'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：输出消息
- en: The advantage of having a `routes` folder is that it makes organizing our API
    easier as it grows. Every time we want to create a new route, we just have to
    make a new file in the `routes` folder, import it using `require` in `server.js`,
    and then use the Express `app.use` function to associate the file with an endpoint.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`routes`文件夹的优势在于，随着API的增长，它使得组织我们的API变得更容易。每当我们想要创建一个新的路由时，我们只需要在`routes`文件夹中创建一个新文件，使用`require`在`server.js`中导入它，然后使用Express的`app.use`函数将文件与一个端点关联起来。'
- en: '**Templating Engines**: In the preceding two lines where we used `app.use`,
    we were modifying the settings of `express` to use extended URL encoding and JSON.
    It can also be used to set a templating engine; for example, the **Embedded JavaScript**
    (**EJS**) templating engine:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**模板引擎**：在前两行中我们使用`app.use`时，我们修改了`express`的设置以使用扩展的URL编码和JSON。它也可以用于设置模板引擎；例如，**嵌入式JavaScript**（**EJS**）模板引擎：'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Templating engines allow Express to generate and serve dynamic HTML code for
    websites. Popular templating engines include EJS, Pug (Jade), and Handlebars.
    By using EJS, for example, we could generate HTML dynamically using a user object
    passed from a route to a view:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 模板引擎允许Express为网站生成和提供动态HTML代码。流行的模板引擎包括EJS、Pug（Jade）和Handlebars。例如，通过使用EJS，我们可以使用从路由传递到视图的用户对象动态生成HTML：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our case, we will not need to make use of `view` or templating engines. Our
    API will return and accept standard JSON exclusively. If you are interested in
    using Express for HTML-based websites, we encourage you to research the templating
    engines that are compatible with Express.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不需要使用`view`或模板引擎。我们的API将专门返回和接受标准的JSON。如果您有兴趣在HTML网站中使用Express，我们鼓励您研究与Express兼容的模板引擎。
- en: HTTP Status Codes
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HTTP状态代码
- en: In *step 6* of *Exercise 17*, *Creating and Importing a Route File*, we set
    the HTTP status code for our response to `404`. Most people have heard of a 404
    error as it is commonly seen when a page can't be found on a website. However,
    most people don't know what a status code is, or of any codes beyond `404`. So,
    we will start by explaining the concept of status codes and going over some of
    the most commonly used codes.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在*练习17*的*步骤6*中，*创建和导入路由文件*，我们将响应的HTTP状态代码设置为`404`。大多数人都听说过404错误，因为在网站上找不到页面时通常会看到它。然而，大多数人不知道状态代码是什么，也不知道除了`404`之外还有哪些代码。因此，我们将从解释状态代码的概念开始，并介绍一些最常用的代码。
- en: A status code is a three-digit number that is returned from a server in response
    to a client request over HTTP. Each three-digit code corresponds to a standardized
    status, for example, `not found`, `success`, and `server error`. These standardized
    codes make dealing with servers easier and more standardized. Often, a status
    code will be accompanied by some additional message text. These messages can be
    useful for humans, but when writing a script to deal with HTTP responses, it's
    much easier to simply account for status codes. For example, creating a case statement
    based on the status code returned.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 状态代码是服务器在HTTP响应中返回给客户端请求的三位数字。每个三位代码对应于一个标准化的状态，例如`未找到`、`成功`和`服务器错误`。这些标准化代码使处理服务器变得更加容易和标准化。通常，状态代码将附带一些额外的消息文本。这些消息对人类很有用，但在编写处理HTTP响应的脚本时，仅仅考虑状态代码会更容易。例如，基于返回的状态代码创建一个case语句。
- en: 'Response codes fall into categories that are determined by the first digit
    in a three-digit number:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 响应代码分为由三位数字中的第一位数字确定的类别：
- en: '![Figure 4.7: Table of HTTP response code categories'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：HTTP响应代码类别表'
- en: '](Images/C14587_04_07.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_07.jpg)'
- en: 'Figure 4.7: Table of HTTP response code categories'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：HTTP响应代码类别表
- en: Each of the categories of HTTP codes contains several specific codes that are
    to be used in certain situations. These standardized codes will help clients deal
    with responses even if they involve an unfamiliar API. For example, any 400-series
    client error code indicates to the client that the problem was with the request,
    whereas a 500-series error code indicates that the issue may be with the server
    itself.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP代码的每个类别都包含可在特定情况下使用的几个具体代码。这些标准化的代码将帮助客户端处理响应，即使涉及不熟悉的API。例如，任何400系列的客户端错误代码都表示问题出在请求上，而500系列的错误代码表示问题可能出在服务器本身。
- en: 'Let''s take a look at some of the specific HTTP status codes that exist in
    each of the categories from the following figure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下图中每个类别中存在的一些具体HTTP状态代码：
- en: '![Figure 4.8: Table of HTTP response codes'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.8：HTTP响应代码表'
- en: '](Images/C14587_04_08.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_08.jpg)'
- en: 'Figure 4.8: Table of HTTP response codes'
  id: totrans-132
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：HTTP响应代码表
- en: 'In the following figure, we can see a few more specific HTTP status codes:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们可以看到一些更具体的HTTP状态代码：
- en: '![Figure 4.9: Table of HTTP response codes continued'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.9：HTTP响应代码继续表'
- en: '](Images/C14587_04_09.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_09.jpg)'
- en: 'Figure 4.9: Table of HTTP response codes continued'
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.9：HTTP响应代码继续表
- en: The codes that are listed here are only a handful of the dozens of HTTP status
    codes that are available. When writing your API, it is useful to use status codes
    where appropriate. Status codes make responses easier to understand for both users
    and machines. When testing our application, we may want to write a script that
    matches a list of requests with the expected response status codes.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出的代码只是可用的数十种HTTP状态代码中的一小部分。在编写API时，使用适当的状态代码是有用的。状态代码使响应对用户和机器更容易理解。在测试我们的应用程序时，我们可能希望编写一个脚本，将一系列请求与预期的响应状态代码进行匹配。
- en: When using Express, the default status code is always `200`, so if you don't
    specify a code in your result, it will be `200`, which indicates a successful
    response. A full list of HTTP status codes can be found at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Express时，默认状态代码始终为`200`，因此如果您在结果中未指定代码，它将为`200`，表示成功的响应。完整的HTTP状态代码列表可以在[https://developer.mozilla.org/en-US/docs/Web/HTTP/Status](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status)找到。
- en: To set a status code error, use the preceding code section and replace `404`
    with any error code supported by the `http-errors` library, which is a sub-dependency
    of Express. A list of all supported error codes can be found in the project's
    GitHub at [https://github.com/jshttp/http-errors](https://github.com/jshttp/http-errors).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置状态代码错误，请使用上面的代码部分，并将`404`替换为`http-errors`库支持的任何错误代码，该库是Express的子依赖项。您可以在项目的GitHub上找到所有支持的错误代码列表[https://github.com/jshttp/http-errors](https://github.com/jshttp/http-errors)。
- en: 'You can also pass an additional string to `createError()` to set a custom message:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以向`createError()`传递一个额外的字符串来设置自定义消息：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you''re using a success code, simply use `res.status` and return your JSON
    object as you would with the default `200` status:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用成功代码，只需使用`res.status`并像使用默认的`200`状态一样返回您的JSON对象：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-144
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are many status codes that are rarely used; among these are some joke
    codes created throughout internet history:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多很少使用的状态代码；其中包括一些在互联网历史上创建的笑话代码：
- en: '418 – I''m a teapot: Made as an April Fool''s joke in 1998\. It indicates that
    the server refuses to brew coffee because it''s a teapot.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 418-我是一个茶壶：1998年愚人节的一个笑话。它表示服务器拒绝冲泡咖啡，因为它是一个茶壶。
- en: '420 – Enhance your calm: Used in the original version of Twitter when an app
    is being rate-limited. It is a reference to the movie Demolition Man.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 420-增强您的冷静：在Twitter的原始版本中使用，当应用程序被限制速率时。这是对电影《拆弹专家》的引用。
- en: Designing Your API
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计您的API
- en: It's important to consider the design of your API early on in the software design
    process. Changing the endpoints of your API after release will require updating
    any service that relies on those endpoints. If an API is released for public use,
    it is often required that it maintain backward compatibility. Time spent on planning
    endpoints, accepted HTTP methods, required input types, and structures of JSON
    returned will be saved in the long run.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件设计过程的早期考虑API的设计非常重要。在发布后更改API的端点将需要更新依赖于这些端点的任何服务。如果API发布供公众使用，则通常需要保持向后兼容。在规划端点、接受的HTTP方法、所需的输入类型和返回的JSON结构上花费的时间将在长远节省下来。
- en: Often, guidelines relating to your specific use case or industry can be found,
    so be sure to do your research on this beforehand. In our example of a smart-home
    API, we'll take inspiration from the **World Wide Web Consortium's** (**WC3's**)
    recommendation related to IoT devices. The WC3 is one of the most influential
    organizations working to develop web standards, and their IoT initiative is known
    as **Web of Things** (**WoT**). You can find out more about this at [https://www.w3.org/WoT/](https://www.w3.org/WoT/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，可以找到与您特定用例或行业相关的指南，因此请务必提前进行研究。在我们的智能家居API示例中，我们将从**万维网联盟**（**WC3**）关于IoT设备的推荐中汲取灵感。WC3是致力于制定Web标准的最有影响力的组织之一，他们的IoT倡议被称为**物联网**（**WoT**）。您可以在[https://www.w3.org/WoT/](https://www.w3.org/WoT/)了解更多信息。
- en: 'According to the WoT guidelines, each device should contain information about
    the model as well as a list of possible actions that can be used with the device.
    Here are some endpoints that are recommended by the WoT standard:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 根据WoT指南，每个设备都应包含有关模型的信息以及可与设备一起使用的操作列表。以下是WoT标准推荐的一些端点：
- en: '![Figure 4.10: Table of standard WoT routes'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.10：标准WoT路由表'
- en: '](Images/C14587_04_10.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_10.jpg)'
- en: 'Figure 4.10: Table of standard WoT routes'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.10：标准WoT路由表
- en: This design is useful for two reasons – firstly, because it conforms to a standard,
    which gives users a set of expectations. Secondly, the use of helper endpoints
    such as `/properties/` and `/actions/` give users the ability to discover how
    the API can be used by requesting additional information at those endpoints.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计有两个原因很有用-首先，因为它符合标准，这给用户一组期望。其次，使用诸如`/properties/`和`/actions/`之类的辅助端点使用户能够通过在这些端点请求附加信息来发现API的使用方式。
- en: Each device added to the house should have the `/model/`, `/properties/`, and
    `/actions/` endpoints. We'll map the endpoints shown in the preceding table onto
    each device in our API. The following tree diagram shows a map of our API stemming
    from the root endpoint.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到房屋的每个设备都应该有`/model/`、`/properties/`和`/actions/`端点。我们将在我们的API中将上表中显示的端点映射到每个设备上。以下树状图显示了从根端点开始的我们API的映射。
- en: 'The third level in the following figure shows the `/devices/light/` endpoint,
    and, stemming from that endpoint, we have the endpoints listed in the preceding
    table:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图中的第三级显示了`/devices/light/`端点，并且从该端点开始，我们有上表中列出的端点：
- en: '![Figure 4.11: A tree chart of the smart-house API design'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.11：智能家居API设计的树状图'
- en: '](Images/C14587_04_11.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_11.jpg)'
- en: 'Figure 4.11: A tree chart of the smart-house API design'
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.11：智能家居API设计的树状图
- en: 'As an example of the kind of JSON that would be returned by an endpoint, we''ll
    look more closely at the `/devices/light/actions` route defined in the preceding
    diagram. The following example shows the object of an action that contains a single
    action called `Fade`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为端点返回的JSON的示例，我们将更仔细地查看前图中定义的`/devices/light/actions`路由。以下示例显示了包含名为`Fade`的单个操作的操作对象：
- en: '[PRE19]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We're basing our `fade` action on the suggestions made by Mozilla in their WoT
    documentation at [https://iot.mozilla.org/wot](https://iot.mozilla.org/wot). They've
    created this documentation with the goal of complementing the standard proposed
    by W3C and have included many examples of JSON representing IoT devices and their
    associated actions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`fade`操作是基于Mozilla在其WoT文档中提出的建议。他们创建了这份文档，目标是补充W3C提出的标准，并包含了许多代表IoT设备及其相关操作的JSON示例。
- en: Notice that the object contains the name of the action, a description of the
    action, and the accepted values to use the action. It's also always a good idea
    to include the unit of measurement where applicable. With the duration, we know
    that it's measured in milliseconds; without this information, we'd have no idea
    what "1" really means.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意对象包含操作的名称、操作的描述以及使用操作的接受值。在适用的情况下，包含单位的度量单位也总是一个好主意。通过持续时间，我们知道它是以毫秒为单位的；如果没有这些信息，我们就不知道"1"实际上是什么意思。
- en: 'By reading the preceding JSON, we can see that we need to send a request with
    a number for the desired lighting level (0 to 100) and another number to specify
    the length of time for the dimming. Using `curl`, we might fade the lights as
    follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读前面的JSON，我们可以看到我们需要发送一个请求，其中包含所需的照明级别（0到100）的数字，以及另一个数字来指定调暗的时间长度。使用`curl`，我们可以这样淡化灯光：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: According to the API action description, the preceding request should cause
    the lightbulb to fade to 80% brightness over a period of 500 milliseconds.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 根据API操作描述，前面的请求应该导致灯泡在500毫秒的时间内淡出到80%的亮度。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Documentation with Swagger**: Although it won''t be covered in this book,
    another project you should look into is Swagger. This project helps automate the
    process of creating, updating, and displaying your API documentation and works
    well with Node.js and Express.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swagger文档**:虽然本书不涉及，但你应该了解的另一个项目是Swagger。这个项目有助于自动化创建、更新和显示API文档，并与Node.js和Express很好地配合。'
- en: An example of the kind of interactive documentation generated by Swagger can
    be seen at [https://petstore.swagger.io/](https://petstore.swagger.io/).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger生成的交互式文档示例可在[https://petstore.swagger.io/](https://petstore.swagger.io/)中看到。
- en: 'Exercise 18: Creating Action Routes'
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习18：创建操作路由
- en: In this exercise, our aim is to create a new route file that returns information
    about the `fade` action, which we looked at in the previous section. The starting
    point for this exercise will be where we left off at the end of *Exercise 17,
    Creating and Importing a Route File*.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们的目标是创建一个新的路由文件，返回关于`fade`操作的信息，这是我们在上一节中看到的。这个练习的起点将是我们在*练习17，创建和导入路由文件*结束时留下的地方。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this example can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise18](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise18).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise18](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise18)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Create a sub-folder in the `routes` folder called `devices`:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes`文件夹中创建一个名为`devices`的子文件夹：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Copy `routes/index.js` to `routes/devices/light.js`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`routes/index.js`复制到`routes/devices/light.js`：
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we''ll open up `/routes/devices/light.js` from the previous exercise
    and modify it. Find line 6, which should contain the following:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将打开上一个练习中的`/routes/devices/light.js`并修改它。找到第6行，应该包含以下内容：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will replace the preceding line with a large block of JSON that represents
    a list of all the device actions:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个大块的JSON代替前面的行，表示所有设备操作的列表：
- en: '[PRE24]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In our case, the only action is `fade`. This action will change the lightbulb's
    level of brightness over a defined period of time (measured in milliseconds).
    This endpoint won't contain the logic to implement the function, but it will return
    the details needed to interact with it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，唯一的操作是`fade`。这个操作将在一定的时间内（以毫秒为单位）改变灯泡的亮度级别。这个端点不包含实现功能的逻辑，但它将返回与之交互所需的细节。
- en: 'In the `server.js` file, import our newly created device route:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`文件中，导入我们新创建的设备路由：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll now use the preceding route by telling Express to use our `light` object
    for the `/devices/light` route:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将告诉Express使用我们的`light`对象来使用前面的路由：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run the program with `npm start`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`运行程序：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Test the route by using `curl` and `jq`:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`curl`和`jq`测试路由：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you copied the preceding code correctly, you should get a formatted JSON
    object representing the `fade` action as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正确复制了前面的代码，你应该得到一个格式化的JSON对象，表示`fade`操作如下：
- en: '![Figure 4.12: The cURL response for localhost:3000/devices/light'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.12：localhost:3000/devices/light的cURL响应'
- en: '](Images/C14587_04_12.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_12.jpg)'
- en: 'Figure 4.12: The cURL response for localhost:3000/devices/light'
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.12：localhost:3000/devices/light的cURL响应
- en: Further Modularizing
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 进一步模块化
- en: In the project files, we'll separate the light route further by making a `lightStructure.js`
    file, which contains only a JSON object representing the light. We won't include
    the long string of JSON that includes `model`, `properties`, and `action` descriptions.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目文件中，我们将通过创建一个`lightStructure.js`文件进一步分离灯路由，其中只包含表示灯的JSON对象。我们不会包括包含`model`、`properties`和`action`描述的长字符串的JSON。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There won't be an exercise for the changes made in this section, but you can
    find the code at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/Example18b](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/Example18b).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中对所做更改不会有练习，但你可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/Example18b](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/Example18b)找到代码。
- en: '*Exercise 19* will start off using the code found in the `Example18b` folder.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '*练习19*将使用在`Example18b`文件夹中找到的代码开始。'
- en: 'It''s useful to separate static data such as the endpoint object and the functions
    of separate files. `lightStructure.js` will contain the data representing the
    model, properties, and actions. This allows us to focus on the logic of endpoints
    in `light.js`. With this, we''ll have four endpoints that each return the relevant
    section of the JSON light object:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态数据（如端点对象和单独文件的函数）分离是有用的。`lightStructure.js`将包含表示模型、属性和操作的数据。这使我们能够专注于`light.js`中端点的逻辑。有了这个，我们将有四个端点，每个端点都返回JSON灯对象的相关部分：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When working on a large block of JSON like the one found in `lightStructure.js`,
    it can be useful to use a GUI visualization tool. One example is [https://jsoneditoronline.org/](https://jsoneditoronline.org/),
    which provides a tool that allows you to paste a block of JSON on the left-hand
    section of a page, and, on the right-hand side, visualize it as a tree-like object:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理像`lightStructure.js`中找到的大块JSON时，可以使用GUI可视化工具非常有用。一个例子是[https://jsoneditoronline.org/](https://jsoneditoronline.org/)，它提供了一个工具，允许您在页面的左侧部分粘贴一个JSON块，并在右侧将其可视化为类似树状对象的形式：
- en: '![](Images/C14587_04_13.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_04_13.jpg)'
- en: 'Figure 4.13: Online JSON explorer/editor'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：在线JSON资源管理器/编辑器
- en: Changes can be made on either side of the visualization and copied to the other.
    This is useful because the more complex a JSON object becomes, the more difficult
    it is to see how many levels exist within a property.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可在可视化的任一侧进行更改并复制到另一侧。这很有用，因为JSON对象变得越复杂，就越难以看到属性中存在多少级别。
- en: Type Checking and Validating the Input Sent to an Endpoint
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对发送到端点的输入进行类型检查和验证
- en: While type checking and validation are not strictly required for the creation
    of an API, using them can cut down on debugging time and help to avoid bugs. Having
    a guaranteed input for an endpoint means that code can be written with a focus
    on returning the desired result without considering the many edge cases that can
    be created by input outside that which is expected.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型检查和验证对于创建API并不是严格要求的，但使用它们可以减少调试时间并帮助避免错误。对端点的输入进行验证意味着可以专注于返回期望的结果的代码编写，而不必考虑输入超出预期范围所产生的许多边缘情况。
- en: 'Since this task is so common with the creation of APIs, a library has been
    created to make verifying the input of Express endpoints easy. With the **express-validator**
    middleware, we can simply pass the input requirements to our endpoint as an argument.
    For example, the requirements described by the JSON object returned in *Exercise
    18* for our lightbulb''s `fade` action can be represented with the following array:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个任务在创建API时非常常见，因此已经创建了一个库来简化验证Express端点的输入。使用**express-validator**中间件，我们可以简单地将输入要求作为参数传递给我们的端点。例如，我们在*练习18*中返回的JSON对象描述的要求，可以用以下数组表示：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, it contains an entry for each expected input. For each of these
    inputs, we perform two checks. The first is `.isNumeric()`, which checks that
    the input is a number. The second is `.isLength()`, which checks that the length
    is within the specified minimum to maximum range.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它包含了每个预期输入的条目。对于这些输入的每一个，我们执行两个检查。第一个是`.isNumeric()`，用于检查输入是否为数字。第二个是`.isLength()`，用于检查长度是否在指定的最小到最大范围内。
- en: 'Exercise 19: Creating a Route with Type Checking and Validation'
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习19：创建带有类型检查和验证的路由
- en: Note
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this example can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise19](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise19).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise19](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise19)找到。
- en: In this exercise, we'll expand on our `routes/devices/light.js` file by adding
    a route that accepts `PUT` requests in `/actions/fade`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将通过在`routes/devices/light.js`文件中添加一个接受`PUT`请求的路由`/actions/fade`来扩展。
- en: 'The route will check that the request conforms to the standards specified by
    the `fade` action object, which we added to the `devices/light` endpoint in *Exercise
    18, Returning JSON Representing Action Routes*. This includes the following aspects:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 路由将检查请求是否符合我们在*练习18，返回表示动作路由的JSON*中添加到`devices/light`端点的`fade`动作对象指定的标准。这包括以下方面：
- en: The request contains level and duration values.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求包含级别和持续时间值。
- en: The level and duration values are integers.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别和持续时间的值是整数。
- en: The level value is between 0 and 100.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 级别值介于0和100之间。
- en: The duration value is above 0.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间值大于0。
- en: 'Execute the following steps to complete the exercise:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Install `express-validator`, which is a middleware that wraps `validator.js`
    for the easy use of the `validation` and `sanitization` functions with `express`:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`express-validator`，这是一个中间件，用于在`express`中轻松使用`validation`和`sanitization`函数包装`validator.js`：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Import the `check` and `validationResult` functions from the `express-validator`
    library by putting `routes/devices/light` on line 2, just below the `require`
    statement for `express`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`routes/devices/light`放在第2行导入`express-validator`库中的`check`和`validationResult`函数，就在`express`的`require`语句下方：
- en: '[PRE32]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Below the `route.get` function we wrote in the last exercise, create the following
    function that will handle `PUT` requests:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一练习中编写的`route.get`函数下面，创建以下函数来处理`PUT`请求：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the API with `npm start`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`运行API：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Make a `PUT` request to `/devices/light/actions/fade` with the incorrect value
    (`na`) to test the validation:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`/devices/light/actions/fade`进行`PUT`请求，使用不正确的值(`na`)来测试验证：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `-d` flag indicates "data" values to be passed to the endpoint. The `-X`
    flag indicates the HTTP request type.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`标志表示要传递给端点的“数据”值。`-X`标志表示HTTP请求类型。'
- en: 'If the preceding steps were done correctly, we should get an error when we
    make a `PUT` request to `/devices/light/actions/fade` with non-numeric values
    for the level and duration:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的步骤执行正确，当我们对`/devices/light/actions/fade`进行`PUT`请求时，如果级别和持续时间的值为非数字，我们应该会收到错误：
- en: '![Figure 4.14: The cURL error response for the /device/light/actions/fade route
    with incorrect data'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.14：/device/light/actions/fade路由的cURL错误响应，数据不正确'
- en: '](Images/C14587_04_14.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_14.jpg)'
- en: 'Figure 4.14: The cURL error response for the /device/light/actions/fade route
    with incorrect data'
  id: totrans-237
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：/device/light/actions/fade路由的cURL错误响应
- en: 'Next, we''ll make a `PUT` request like before, but with the correct values
    of `50` and `60`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将像以前一样进行`PUT`请求，但使用正确的值`50`和`60`：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Sending a `PUT` request with values in the correct range should return the
    following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 发送具有正确范围内值的`PUT`请求应返回以下内容：
- en: '![Figure 4.15: The cURL response for the /device/light/actions/fade route with
    correct data'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.15：/device/light/actions/fade路由的cURL响应与正确数据'
- en: '](Images/C14587_04_15.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_15.jpg)'
- en: 'Figure 4.15: The cURL response for the /device/light/actions/fade route with
    correct data'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.15：/device/light/actions/fade路由的cURL响应与正确数据
- en: The preceding screenshot indicates that the `PUT` request was successful.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图表明`PUT`请求成功。
- en: Useful Defaults and Easy Inputs
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有用的默认值和简单的输入
- en: So, we've seen how enforcing restrictions on inputs to an endpoint can be helpful.
    However, excessive restrictions and requirements can hinder the user experience
    of an API. Let's take a closer look at the lightbulb fade action. In order to
    allow for the feature of fading over a period of time, we require the user to
    pass a value for the duration. Many people already have experience of using a
    fade action on a physical lightbulb.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了对端点输入施加限制如何有所帮助。然而，过多的限制和要求可能会妨碍API的用户体验。让我们更仔细地看一下灯泡淡入淡出动作。为了允许在一段时间内淡入淡出的功能，我们要求用户传递一个持续时间的值。许多人已经有使用物理灯泡上的淡入淡出动作的经验。
- en: With a physical lightbulb, we know that we input our desired brightness level
    by adjusting a physical switch or other input. The duration is not necessarily
    part of that process or consciously thought about by the user. This creates the
    expectation that you should be able to fade the light by only the desired level.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物理灯泡，我们知道我们通过调节物理开关或其他输入来输入我们期望的亮度级别。持续时间不一定是这个过程的一部分，或者用户有意识地考虑过。这会导致期望您应该能够仅通过所需级别来淡化光线。
- en: For this reason, we should consider making the `duration` value optional. In
    the case that a `duration` value is not received, the script will fall back to
    a default value. This allows us to meet user expectations while still allowing
    fine-grained control for users who want to specify a duration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该考虑使`duration`值变为可选。如果没有收到`duration`值，脚本将退回到默认值。这使我们能够满足用户的期望，同时仍允许那些想要指定持续时间的用户进行精细控制。
- en: 'Exercise 20: Making the Duration Input Optional'
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习20：使持续时间输入变为可选
- en: Note
  id: totrans-250
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this example can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise20](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise20).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise20](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise20)找到。
- en: 'In this exercise, we''ll modify the fade action to make the duration an optional
    input. We''ll modify our fade action endpoint to use a default value of 500 milliseconds
    if no duration value is provided:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将修改淡入淡出动作，使持续时间成为可选输入。如果没有提供持续时间值，我们将修改我们的淡入淡出动作端点，使用默认值500毫秒：
- en: 'In `routes/devices/light.js`, modify the line that validates `duration` by
    adding `.optional()` to the chain of functions. It should look like this:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/devices/light.js`中，通过在函数链中添加`.optional()`来修改验证`duration`的行。它应该是这样的：
- en: '[PRE37]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `routes/devices/light.js`, delete the `return` statement and add the following
    in the same location:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/devices/light.js`中，删除`return`语句，并在相同位置添加以下内容：
- en: '[PRE38]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code creates a `level` variable using `level` input and initializes
    an empty variable for the duration. Next, we check whether the user provided a
    `duration` input. If so, we set the duration to that value. If not, we set `duration`
    to `500`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`level`输入创建了一个`level`变量，并初始化了一个空变量用于持续时间。接下来，我们检查用户是否提供了`duration`输入。如果是，我们将持续时间设置为该值。如果没有，我们将`duration`设置为`500`。
- en: 'Now, we''ll create a `message` object called `message` using our `level` and
    `duration` variables. Then, we''ll return that `message` object to the client:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用我们的`level`和`duration`变量创建一个名为`message`的`message`对象。然后，我们将将该`message`对象返回给客户端：
- en: '[PRE39]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we''ll associate a second route with our function so that sending
    a `PUT` request to `/devices/light` executes the same function as `/devices/light/actions/fade`.
    This is accomplished by changing the first argument of `router.put` with an array
    that contains the old value and a new one of `/`. The opening of the `router.put`
    section should look like this:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将将第二个路由与我们的函数关联起来，以便向`/devices/light`发送`PUT`请求执行与`/devices/light/actions/fade`相同的功能。这是通过将`router.put`的第一个参数更改为包含旧值和新值`/`的数组来实现的。`router.put`部分的开头应该是这样的：
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now that we''re done with the coding part, we''ll turn on the server for testing:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了编码部分，我们将打开服务器进行测试：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'With the server running in one Terminal, open another to perform a few tests
    using `curl`. In the first command, we''ll check that our new default endpoint
    is working and that our default value for the duration is used when no duration
    is provided:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个终端中运行服务器，打开另一个终端使用`curl`进行一些测试。在第一条命令中，我们将检查我们的新默认端点是否正常工作，并且在没有提供持续时间时使用我们的默认值：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you''ve copied everything correctly, you should see an output like this:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经正确复制了所有内容，您应该会看到这样的输出：
- en: '![Figure 4.16: The cURL response for the /device/light route without a specified
    duration'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.16：/device/light路由的cURL响应，没有指定持续时间'
- en: '](Images/C14587_04_16.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_16.jpg)'
- en: 'Figure 4.16: The cURL response for the /device/light route without a specified
    duration'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：/device/light路由的cURL响应，没有指定持续时间
- en: 'We''ll also want to make sure that providing a `duration` value overrides the
    default value. We can test this by making a cURL request that specifies a `duration`
    value:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望确保提供`duration`值会覆盖默认值。我们可以通过进行cURL请求来测试这一点，该请求指定了`duration`值：
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When specifying `250` as the `duration` value, we should see a confirmation
    that `level` will change to over 250 milliseconds in the response:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`250`指定为`duration`值时，我们应该在响应中看到`level`将会变为250毫秒以上的确认：
- en: '![Figure 4.17: The cURL response for the /device/light route with a specified
    duration'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.17：/device/light路由的cURL响应，指定了持续时间'
- en: '](Images/C14587_04_17.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_17.jpg)'
- en: 'Figure 4.17: The cURL response for the /device/light route with a specified
    duration'
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：指定持续时间的/device/light路由的cURL响应
- en: 'With these changes, we''ve now made fade the default action for `/devices/light`
    and given the duration input a default value if not provided. It''s worth noting
    that we now have two functions associated with the `/devices/light` endpoint:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些更改，我们现在已经将`fade`设置为`/devices/light`的默认操作，并且如果未提供持续时间输入，则给出了默认值。值得注意的是，我们现在有两个与`/devices/light`端点相关联的函数：
- en: '`HTTP GET /devices/light`: This returns information about interacting with
    the light.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP GET /devices/light`：这将返回与灯交互的信息。'
- en: '`HTTP PUT /devices/light`: This performs the default action of the light.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP PUT /devices/light`：这执行灯的默认操作。'
- en: 'The reuse of the same endpoint with multiple methods is a good practice. Another
    common example is that of blog entries, where an API might have a single endpoint
    with four functions based on the method used:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 多种方法重复使用相同的端点是一个很好的做法。另一个常见的例子是博客条目，其中API可能具有基于使用的方法的四个函数的单个端点：
- en: '`HTTP POST /blog/post/42`: This creates a blog post with an ID of 42.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP POST /blog/post/42`：这将创建ID为42的博客文章。'
- en: '`HTTP GET /blog/post/42`: This returns blog post #42 as a JSON object.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP GET /blog/post/42`：这将以JSON对象返回博客文章＃42。'
- en: '`HTTP PUT /blog/post/42`: This edits blog post #42 by sending new content.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP PUT /blog/post/42`：这通过发送新内容编辑博客文章＃42。'
- en: '`HTTP DELETE /blog/post/42`: This deletes blog post #42.'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP DELETE /blog/post/42`：这将删除博客文章＃42。'
- en: This makes sense logically using the REST model, where each endpoint represents
    a resource that can be interacted with in various ways.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这在逻辑上使用REST模型是有意义的，其中每个端点代表可以以各种方式进行交互的资源。
- en: In our case, we have made a `PUT` request to the `/devices/light` route that
    triggers the `fade` function. Arguably, a `switch` function that turns the light
    on and off would be more in line with most people's expectations of the default
    action of light. In addition to this, the switch would be a better default because
    it requires no inputs from the client. Fade was only chosen for this project because
    the switch was thought to be too simplistic.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们已经向`/devices/light`路由发出了`PUT`请求，触发了`fade`函数。可以说，一个打开和关闭灯的`switch`函数更符合大多数人对灯的默认操作的期望。此外，开关将是更好的默认选项，因为它不需要客户端的任何输入。Fade之所以被选择是因为认为开关过于简单。
- en: 'We won''t go into much depth on the `switch` function, but it would likely
    contain something like the following code section, which allows the client to
    specify the desired state. If no state is specified, it becomes the opposite of
    the current value:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论`switch`函数，但它可能包含类似以下代码段的内容，允许客户端指定所需的状态。如果未指定状态，则它将成为当前值的相反值：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Middleware
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: Middleware functions in Express are functions that run before the function associated
    with an endpoint. Some common examples of this include logging a request or checking
    for authentication before running the main function of an endpoint. In these cases,
    the logging and authentication functions will be common among all the endpoints
    that use them. By using middleware, we can reuse code that is common across endpoints.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 'Express中的中间件函数是在与端点关联的函数之前运行的函数。一些常见的例子包括在运行端点的主函数之前记录请求或检查身份验证。在这些情况下，记录和身份验证函数将在使用它们的所有端点中是常见的。通过使用中间件，我们可以重用在端点之间常见的代码。 '
- en: 'With Express, we can have middleware functions that run for all endpoints by
    using `app.use()`. For example, if we wanted to create a function that logs a
    request to the console before running the main route, we could write a `logger`
    middleware:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Express，我们可以通过使用`app.use()`来运行所有端点的中间件函数。例如，如果我们想要创建一个在运行主路由之前将请求记录到控制台的函数，我们可以编写一个`logger`中间件：
- en: '[PRE45]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To have the logger run with all endpoints, we tell our app to use it with the
    following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要使记录器在所有端点上运行，我们告诉我们的应用程序使用以下内容：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If, instead, we want our middleware function to run on only some routes, we
    could attach it directly:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望我们的中间件函数仅在某些路由上运行，我们可以直接附加它：
- en: '[PRE47]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is no limit to the number of middleware functions that can be used for
    some or all routes. When multiple middleware functions are used, they are called
    in the order that they are declared in your code. When one middleware function
    finishes, it passes the `req` and `res` objects on to the next function in the
    chain:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些或所有路由，可以使用多个中间件函数，没有限制。当使用多个中间件函数时，它们按照在代码中声明的顺序调用。当一个中间件函数完成时，它将`req`和`res`对象传递给链中的下一个函数：
- en: '![Figure 4.18: Diagram of middleware chaining'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.18：中间件链接图'
- en: '](Images/C14587_04_18.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_18.jpg)'
- en: 'Figure 4.18: Diagram of middleware chaining'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：中间件链接图
- en: The preceding diagram visualizes a request process where once a request has
    been received by the server, it runs the first middleware function, passes the
    results to a second middleware function, and, when that is complete, our `/devices/light`
    destination route is finally run.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表可视化了一个请求过程，其中一旦服务器接收到请求，它将运行第一个中间件函数，将结果传递给第二个中间件函数，当完成时，最终运行我们的`/devices/light`目标路由。
- en: In the next section, we'll create our own middleware for checking whether guests
    have checked in to get an authentication token.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建自己的中间件来检查客人是否已经签到以获取身份验证令牌。
- en: 'Exercise 21: Setting Up an Endpoint that Requires Authentication'
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习21：设置需要身份验证的端点
- en: Note
  id: totrans-303
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The complete code for this example can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise21](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise21).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的完整代码可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise21](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Exercise21)找到。
- en: 'In the following exercise, we''ll build on our project by adding an endpoint
    that requires authentication with a **JSON Web Token** (**JWT**). We''ll create
    two new endpoints: the first, `restricted light`, will be identical to `light`
    but requires authentication. The second endpoint, `check-in`, allows clients to
    get a token by sending the server their name.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，我们将通过添加一个需要身份验证的端点来完善我们的项目，该身份验证需要使用**JSON Web Token**（**JWT**）。我们将创建两个新的端点：第一个`restricted
    light`，与`light`相同，但需要身份验证。第二个端点`check-in`允许客户端通过向服务器发送他们的名称来获取令牌。
- en: Note
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**JWT and Security**: This exercise is meant to highlight how JWT authentication
    works. It wouldn''t be secure in production as there is no means of verifying
    that the name supplied by the client is authentic.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '**JWT和安全性**：此练习旨在突出JWT身份验证的工作原理。在生产中，这不是安全的，因为没有办法验证客户端提供的名称是否真实。'
- en: In production, a JWT should also contain an expiry date by which a client has
    to renew the token for continued use. For instance, a token given to a mobile
    app client might have an expiry date of 7 days. The client might check on startup
    whether the token is expiring soon. If so, it would request an updated token and
    the user of the application wouldn't notice the process.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，JWT还应包含一个到期日期，客户端必须在该日期之前更新令牌以继续使用。例如，给移动应用客户端的令牌可能具有7天的到期日期。客户端可能在启动时检查令牌是否即将到期。如果是这样，它将请求更新的令牌，应用程序的用户将不会注意到这个过程。
- en: If, however, the user of the mobile app hadn't opened it in many days, the app
    would require the user to sign in again. This adds security, since any third party
    that might find a JWT only has a very short period of time in which to use it.
    For example, in the case that a cell phone is lost and found several days later,
    many applications using JWTs with expiry dates will require signing in again to
    interact with the owner's account.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果移动应用的用户多天没有打开它，该应用将要求用户重新登录。这增加了安全性，因为任何可能找到JWT的第三方只有很短的时间来使用它。例如，如果手机丢失并在几天后被找到，许多使用带有到期日期的JWT的应用程序将需要再次登录以与所有者的帐户交互。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'Create a `config.js` file with a random secret value:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有随机密钥值的`config.js`文件：
- en: '[PRE48]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The preceding code creates a `config` object. It sets the secret attribute of
    `config` to a random string. Then, it exports the `config` object.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码创建了一个`config`对象。它将`config`的`secret`属性设置为一个随机字符串。然后，导出`config`对象。
- en: 'It''s important to remember that the secret is random and so yours should be
    unique to the one that is shown here. There is no set method for generating the
    random string but an easy way on the command line is to use `openssl`, which should
    be installed by default on most Linux and Mac operating systems:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，密钥是随机的，因此您的密钥应该与此处显示的密钥不同。没有固定的方法来生成随机字符串，但在命令行上的一个简单方法是使用`openssl`，它应该默认安装在大多数Linux和Mac操作系统上：
- en: '[PRE49]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Install `jwt-simple` with `npm`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm`安装`jwt-simple`：
- en: '[PRE50]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create the `routes/check-in.js` file for the `check-in` endpoint. Import the
    following modules, which we will need to make use of:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`check-in`端点创建`routes/check-in.js`文件。导入以下模块，我们将需要使用它们：
- en: '[PRE51]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Below the import, in `routes/check-in.js`, we''ll create a `post` route that
    requires a string value for `name`. We''ll then encode all the information that
    has been sent into a JWT. This JWT is then returned to the client to use for authentication:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/check-in.js`中的导入下面，我们将创建一个需要`name`的字符串值的`post`路由。然后，我们将对发送的所有信息进行编码成JWT。然后将此JWT返回给客户端用于身份验证：
- en: '[PRE52]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'In `server.js`, also import `config.js` and `jwt-simple`, and set the secret
    value:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`中，还要导入`config.js`和`jwt-simple`，并设置密钥值：
- en: '[PRE53]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In `server.js`, add a middleware function to see whether a user has a valid
    token:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`中，添加一个中间件函数，以查看用户是否具有有效令牌：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `server.js`, add the `check-in` endpoint and a second light to the `restricted-light`
    endpoint:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`server.js`中，添加`check-in`端点和第二个`restricted-light`端点的light：
- en: '[PRE55]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The section of `server.js` where routes are imported and set up should look
    like the preceding code, with three new lines added. You can see that there is
    one line to import the `check-in` route and two for creating our new routes. Notice
    that we don't need to import `restricted-light` as it reuses the `light` object.
    The crucial difference with `restricted-light` is the use of the `isCheckedIn`
    middleware function. This tells `express` to run that function before serving
    the light route.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`server.js`的部分，其中导入和设置路由的代码应该看起来像前面的代码，添加了三行新代码。您可以看到有一行用于导入`check-in`路由，另外两行用于创建我们的新路由。请注意，我们不需要导入`restricted-light`，因为它重用了`light`对象。`restricted-light`与`light`的关键区别在于使用了`isCheckedIn`中间件函数。这告诉`express`在提供light路由之前运行该函数。'
- en: 'Turn the server on with `npm start`:'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`npm start`打开服务器：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Open another Terminal window and run the following command to get a signed
    JWT token:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口，并运行以下命令以获取签名的JWT令牌：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding command uses `curl` to post a name to the `check-in` endpoint.
    It takes the result from the server and saves it to a Bash variable called `TOKEN`.
    The `TOKEN` variable is local to the Terminal window in which the command was
    run; so, if you close the Terminal, you''ll need to run it again. To check that
    it was saved correctly, tell the Bash shell to print the value:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令使用`curl`将名称发布到`check-in`端点。它获取服务器的结果并将其保存到名为`TOKEN`的Bash变量中。`TOKEN`变量是在运行该命令的终端窗口中本地的；因此，如果关闭终端，则需要再次运行。要检查它是否正确保存，告诉Bash
    shell打印该值：
- en: '[PRE58]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following is the output of the preceding code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Figure 4.19: Checking the value of $TOKEN in the Bash shell'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.19：在Bash shell中检查$TOKEN的值'
- en: '](Images/C14587_04_19.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_19.jpg)'
- en: 'Figure 4.19: Checking the value of $TOKEN in the Bash shell'
  id: totrans-338
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：在Bash shell中检查$TOKEN的值
- en: You should see a JWT token, as shown in the preceding figure.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到一个JWT令牌，如前面的图所示。
- en: 'Send a cURL request to `restricted-light`, with an authentication token, by
    running the following command in your Terminal:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中运行以下命令，向`restricted-light`发送带有身份验证令牌的cURL请求：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'It should return a successful fade, as shown in the following figure:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该返回一个成功的淡入效果，如下图所示：
- en: '![Figure 4.20: A successful cURL request to restricted-light using JWT'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.20：使用JWT成功向restricted-light发送cURL请求'
- en: '](Images/C14587_04_20.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_20.jpg)'
- en: 'Figure 4.20: A successful cURL request to restricted-light using JWT'
  id: totrans-345
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：使用JWT成功向restricted-light发送cURL请求
- en: 'Send a `curl` request to `restricted-light`, without an authentication token,
    in your Terminal:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中向`restricted-light`发送不带身份验证令牌的`curl`请求：
- en: '[PRE60]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In comparison, sending the same request without the endpoint returns an error:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，发送相同的请求但不带端点会返回错误：
- en: '![Figure 4.21: Trying to cURL restricted-light without a JWT'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.21：尝试在没有JWT的情况下cURL restricted-light'
- en: '](Images/C14587_04_21.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_21.jpg)'
- en: 'Figure 4.21: Trying to cURL restricted-light without a JWT'
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：尝试在没有JWT的情况下cURL restricted-light
- en: We now have an endpoint set up to distribute authentication tokens and a protected
    endpoint that requires them. We can now add additional routes that require authentication
    tokens by reusing our `isCheckedIn` function with any new endpoint. We just need
    to pass the function to Express as the second argument, as done in `server.js`.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经设置了一个端点来分发身份验证令牌，并且有一个需要这些令牌的受保护的端点。我们现在可以通过重用我们的`isCheckedIn`函数与任何新的端点来添加需要身份验证令牌的额外路由。我们只需要将该函数作为第二个参数传递给Express，就像在`server.js`中所做的那样。
- en: The Contents of a JWT
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT的内容
- en: In the previous exercise, during *step 7*, we requested a token from the server
    and saved the value to our local Terminal session. For the exercise to have worked,
    the JWT should have the three parts separated by a period. If we take the JWT
    that was returned from our `echo $TOKEN` command and put it into the website jwt.io,
    we can look at the contents of the JWT more closely.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，在*步骤7*期间，我们从服务器请求了一个令牌，并将该值保存到我们的本地终端会话中。为了使练习有效，JWT应该有三个部分，由句点分隔。如果我们将从`echo
    $TOKEN`命令返回的JWT放入网站jwt.io中，我们可以更仔细地查看JWT的内容。
- en: 'Additionally, paste your secret value into the bottom-right corner of the GUI,
    which should display **Signature Verified** in the bottom-left corner. This tells
    us that the JWT being viewed was created using the private signature:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将您的秘密值粘贴到GUI的右下角，应在左下角显示“签名已验证”。这告诉我们，查看的JWT是使用私有签名创建的：
- en: '![Figure 4.22: Showing JWT.io with JWT data'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.22：显示JWT.io与JWT数据'
- en: '](Images/C14587_04_22.jpg)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_22.jpg)'
- en: 'Figure 4.22: Showing JWT.io with JWT data'
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：显示JWT.io与JWT数据
- en: The JWT website allows us to easily visualize what the three sections of the
    JWT represent. The first section in red is the header, that is, information that
    describes the encoding standard used. The purple section is the payload – it contains
    the data that was verified by the server when the token was created, which, in
    our case, is just a name. Finally, the blue section is the signature, which is
    the result of hashing the contents of the other two sections with the server's
    secret.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: JWT网站允许我们轻松地可视化JWT的三个部分代表什么。红色的第一部分是标头，即描述所使用的编码标准的信息。紫色部分是有效载荷-它包含在创建令牌时服务器验证的数据，在我们的情况下只是一个名称。最后，蓝色部分是签名，它是使用服务器的秘密对其他两个部分的内容进行哈希的结果。
- en: 'In the preceding example, the **PAYLOAD** section is the smallest of the three.
    This won''t always be the case as the red and blue sections are fixed in size,
    while the purple section is dependent on the size of the payload. If we request
    another token from our server using the `check-in` endpoint, then instead of just
    providing a name, we also provide an email and phone number. This means we will
    see a resulting token that has a larger purple section:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，**有效载荷**部分是三个部分中最小的。这并不总是这样，因为红色和蓝色部分的大小是固定的，而紫色部分取决于有效载荷的大小。如果我们使用`check-in`端点从服务器请求另一个令牌，那么我们不仅提供一个名称，还提供电子邮件和电话号码。这意味着我们将看到一个具有较大紫色部分的结果令牌：
- en: '![Figure 4.23: JWT.io with a token that has a larger payload'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.23：JWT.io显示具有较大负载的令牌'
- en: '](Images/C14587_04_23.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '](Images/C14587_04_23.jpg)'
- en: 'Figure 4.23: JWT.io with a token that has a larger payload'
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：JWT.io显示具有较大负载的令牌
- en: MongoDB
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MongoDB
- en: Many APIs make use of a database for keeping track of the underlying data being
    read and written by the API. In other cases, such as IoT, the functions at endpoints
    may update a real object. Even when a real object or event is being tracked or
    triggered, it is a good idea to track the expected state in a database. A database
    representation can be accessed and manipulated quickly.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 许多API使用数据库来跟踪API读取和写入的基础数据。在其他情况下，例如物联网，端点的功能可能会更新真实对象。即使在跟踪或触发真实对象或事件时，跟踪数据库中的预期状态也是一个好主意。可以快速访问和操作数据库表示。
- en: We won't go into depth on the use and design of a database; however, we'll briefly
    talk about how you could use one to extend the functionality of an API. It is
    rare that you will have an API that goes beyond `hello world` without making use
    of a database of some sort.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论数据库的使用和设计；但是，我们将简要讨论如何使用数据库来扩展API的功能。很少会有一个API在不使用某种数据库的情况下超越`hello
    world`。
- en: The most popular database used with Node.js is MongoDB. MongoDB is an object-oriented
    library with a convenient syntax for working with JSON objects. In addition to
    storing data as JSON-like objects, it doesn't require the use of a schema. This
    means that the attributes for an object can change over time without you having
    to do any configuration on the database.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 与Node.js一起使用最广泛的数据库是MongoDB。MongoDB是一个面向对象的库，具有方便的语法，可用于处理JSON对象。除了将数据存储为类似JSON的对象之外，它不需要使用模式。这意味着对象的属性可以随时间改变，而无需对数据库进行任何配置。
- en: 'For example, we may start tracking events in our database that simply contain
    the request body and a timestamp:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以开始在数据库中跟踪事件，这些事件只包含请求正文和时间戳：
- en: '[PRE61]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We might start out with a very simple event log, and later decide that additional
    details should be saved along with each event. For example, if we include authorization
    data and the exact path of the request, our log objects would look like the following:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会从一个非常简单的事件日志开始，然后决定随着每个事件保存额外的细节。例如，如果我们包括授权数据和请求的确切路径，我们的日志对象将如下所示：
- en: '[PRE62]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If a SQL database was used instead, we would first need to add `path` and `token`
    columns to the database schema. The flexibility of MongoDB is one of its great
    features along with the simplicity of adding it to a project that already uses
    JSON for data manipulation.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用SQL数据库，我们首先需要向数据库模式添加`path`和`token`列。MongoDB的灵活性是其伟大特性之一，以及将其添加到已经使用JSON进行数据操作的项目的简单性。
- en: Often, APIs will be completely based around a database, as is the case for most
    social-media style apps. For example, with Twitter, Facebook, and Instagram, each
    user, post, and comment is ultimately an entry in a database that is made accessible
    to the client-side software through an API.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，API将完全基于数据库，就像大多数社交媒体应用一样。例如，对于Twitter、Facebook和Instagram，每个用户、帖子和评论最终都是数据库中的一个条目，通过API向客户端软件提供访问。
- en: We won't go into depth on the use of databases with an API, but an extra folder
    explaining how to set up MongoDB and use it with this API for logging events has
    been included with the project files (see the following note).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入讨论如何在API中使用数据库，但是额外的文件夹包含了如何设置MongoDB并将其与此API一起使用以记录事件的说明（请参见下面的注释）。
- en: The use of event logging with JWT would allow us to associate any malicious
    use of restricted endpoints with a specific JWT. By using a logging system and
    enforcing the use of JWTs on all endpoints, we could associate any requested action
    to `smartHouse` with a specific user. In the case of malicious use, a JWT could
    be blacklisted. Of course, this would require more stringent requirements for
    issuing a JWT; for example, requiring a guest to present government-issued photo
    identification.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JWT进行事件记录将允许我们将受限端点的任何恶意使用与特定的JWT关联起来。通过使用日志系统并强制在所有端点上使用JWT，我们可以将任何请求的操作与`smartHouse`关联到特定用户。在恶意使用的情况下，JWT可以被列入黑名单。当然，这将需要更严格的要求来发放JWT；例如，要求客人出示政府发行的照片身份证明。
- en: Note
  id: totrans-376
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: '**Middleware with MongoDB logging example**: You can refer to the folder called
    `extra/mongo_logger_middleware` in the project file for an example of creating
    a catch-all middleware that logs information about each request including the
    methods, data, and user information. Something like this could be used to track
    which requests were made by who.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有MongoDB日志记录示例的中间件**：您可以参考项目文件中名为`extra/mongo_logger_middleware`的文件夹，了解创建一个捕获所有信息的中间件的示例，包括请求的方法、数据和用户信息。类似的东西可以用来跟踪由谁发出的请求。'
- en: When running this code, you'll need to first run `npm install`. In addition
    to this, make sure you have MongoDB installed locally and running. For more details,
    see the README file in the folder at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/extra/mongo_logger_middleware](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/extra/mongo_logger_middleware).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，您需要首先运行`npm install`。除此之外，确保您已经在本地安装并运行了MongoDB。有关更多详细信息，请参阅文件夹中的README文件[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/extra/mongo_logger_middleware](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson04/Example/extra/mongo_logger_middleware)。
- en: 'Activity 5: Creating an API Endpoint for a Keypad Door Lock'
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动5：为键盘门锁创建API端点
- en: In this activity, you need to create an API endpoint for a keypad door lock.
    The device needs a new endpoint to support the use case of authenticated users
    being able to create one-time passcodes to open the door.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您需要为键盘门锁创建一个API端点。该设备需要一个新的端点来支持经过身份验证的用户能够创建一次性密码来打开门的用例。
- en: 'Perform the following steps to complete the activity:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成活动：
- en: Create a new project folder and change directories going to it.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹并切换到该文件夹。
- en: Initialize an `npm` project and install `express`, `express-validator`, and
    `jwt-simple`. Then, make a directory for `routes`.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个`npm`项目并安装`express`，`express-validator`和`jwt-simple`。然后，创建一个`routes`目录。
- en: Create a `config.js` file, which should contain a randomly generated secret
    value.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`config.js`文件，其中应包含一个随机生成的秘密值。
- en: Make the `routes/check-in.js` file, in order to create a check-in route.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`routes/check-in.js`文件，以创建一个签到路由。
- en: Create a second route file called `routes/lock.js`. Start the file off by importing
    the required libraries and modules, and create an empty array to hold our valid
    passcodes.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`routes/lock.js`的第二个路由文件。首先导入所需的库和模块，然后创建一个空数组来保存我们的有效密码。
- en: Below the code in `routes/lock.js`, create a `GET` route for `/code` that requires
    a `name` value.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/lock.js`中的代码下面，创建一个`GET`路由，用于`/code`，需要一个`name`值。
- en: Create another route in `routes/lock.js`. This one will be for `/open` and requires
    a four-digit code that will be checked against the `passCodes` array to see whether
    it is valid. Below that route, make sure to export `router`, so that it can be
    used in `server.js`.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`routes/lock.js`中创建另一个路由。这个路由将是`/open`，需要一个四位数的代码，将被检查是否在`passCodes`数组中有效。在该路由下面，确保导出`router`，以便在`server.js`中使用。
- en: Create the main file where our routes will be used in `server.js`. Start by
    importing the libraries needed and also setting URL encoding the JSON.
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建主文件，在其中我们的路由将在`server.js`中使用。首先导入所需的库，还有设置URL编码的JSON。
- en: Next, in `server.js`, import the two routes, implement a `404` catch-all, and
    tell the API to listen on port `3000`.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`server.js`中，导入这两个路由，实现一个`404`捕获，并告诉API监听端口`3000`。
- en: Test the API to ensure it was done correctly. Start by running your program.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试API以确保它被正确完成。首先运行您的程序。
- en: With the program running, open a second Terminal window and use the `/check-in`
    endpoint to get a JWT and save the value as `TOKEN`. Then, echo that value to
    ensure it was successful.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序运行时，打开第二个终端窗口，使用`/check-in`端点获取JWT并将值保存为`TOKEN`。然后，回显该值以确保成功。
- en: Use our JWT to use the `/lock/code` endpoint to get a one-time passcode for
    a new name.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们的JWT来使用`/lock/code`端点获取新名称的一次性验证码。
- en: Send the code to the `/lock/open` endpoint twice to get an error for the second
    instance.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两次向`/lock/open`端点发送代码，以获取第二个实例的错误。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found on page 594.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第594页找到。
- en: Summary
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've explored the use of Node.js for creating RESTful APIs.
    We've considered various uses of APIs and some techniques for designing them.
    Looking at aspects such as HTTP codes and input validation, we've considered common
    problems that are dealt with when creating and maintaining APIs. Despite this,
    there are still many areas of API design and development that haven't been considered.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Node.js创建RESTful API的用途。我们考虑了API的各种用途以及一些设计技巧。通过查看诸如HTTP代码和输入验证之类的方面，我们考虑了在创建和维护API时处理的常见问题。尽管如此，仍有许多API设计和开发领域尚未考虑。
- en: The best way to continue improving your knowledge about API design and creation
    is to start making your own, whether at work or through personal projects. The
    code we've created throughout the exercises in this chapter can be used as a jumping-off
    point. Try expanding on what we've done here to create your own endpoints and
    eventually your own APIs.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 继续提高您关于API设计和创建的知识的最佳方法是开始制作自己的API，无论是在工作中还是通过个人项目。我们在本章的练习中创建的代码可以用作起点。尝试扩展我们在这里所做的工作，创建您自己的端点，最终创建您自己的API。
- en: In the next chapter, we'll talk about code quality. This will include techniques
    for writing readable code as well as techniques that can be used to test our code.
    Those techniques can be used in conjunction with what you've learned here to ensure
    that the endpoints you create continue to return the correct values as your project
    grows.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论代码质量。这将包括编写可读代码的技术，以及用于测试我们代码的技术。这些技术可以与您在这里学到的内容结合使用，以确保您创建的端点在项目增长时继续返回正确的值。
