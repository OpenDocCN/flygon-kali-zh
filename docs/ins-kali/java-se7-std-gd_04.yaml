- en: Chapter 4. Using Arrays and Collections
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。使用数组和集合
- en: This chapter, when boiled down to its essence, is about data structures. Specifically,
    it is about arrays—the `java.util.Arrays` and `java.util.ArrayList` classes. An
    array is a region of memory that can be addressed using a single variable name.
    It provides an efficient technique for accessing data in a sequential or random
    fashion. The `Arrays` class provides support for arrays while the `ArrayList`
    class provides array-like behavior but is not fixed in size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章，归根结底，是关于数据结构。具体来说，它是关于数组——`java.util.Arrays`和`java.util.ArrayList`类。数组是可以使用单个变量名寻址的内存区域。它提供了一种有效的访问数据的技术，可以按顺序或随机方式访问数据。`Arrays`类提供了对数组的支持，而`ArrayList`类提供了类似数组的行为，但大小不固定。
- en: We are concerned with how to create and use these data structures. A common
    operation is the traversal of an array or collection. We will see that Java supports
    several approaches permitting us to move through the elements of an array or an
    `ArrayList` object. Common to both arrays and collections is the ability to use
    the for-each statement. Iterators provide an alternate approach for accessing
    collections such as the `ArrayList`, and will also be discussed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关心如何创建和使用这些数据结构。一个常见的操作是遍历数组或集合。我们将看到Java支持几种方法，允许我们遍历数组或`ArrayList`对象的元素。数组和集合都可以使用for-each语句。迭代器提供了访问集合的另一种方法，比如`ArrayList`，我们也会讨论到。
- en: We will start by examining arrays in detail. This will include the creation
    and use of single and multidimensional arrays. Common array operations such as
    copying and sorting will be demonstrated.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从详细讨论数组开始。这将包括创建和使用单维和多维数组。将演示常见的数组操作，比如复制和排序。
- en: As arrays are a simple data structure, most languages do not provide much support
    for operations on them. The `java.util.Arrays` class fills this void and supports
    important operations against arrays. These include copying, filling, and sorting
    the arrays.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组是一种简单的数据结构，大多数语言对它们的操作提供的支持不多。`java.util.Arrays`类填补了这一空白，并支持对数组的重要操作。这些操作包括复制、填充和排序数组。
- en: The `java.util` package contains a number of interfaces and classes that can
    make working with collections of data easier. In this chapter we will examine
    the use of iterators and the `ArrayList` class which are part of this package.
    Iterators provide a technique for traversing over collections which can be very
    useful. The `ArrayList` class is frequently used instead of arrays when the size
    of the collection may change. It provides a number of valuable methods for the
    modification of collections. We will also examine how to encapsulate a collection,
    such as the `ArrayList`, in another class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util`包含许多接口和类，可以使处理数据集合变得更加容易。在本章中，我们将研究迭代器和`ArrayList`类的使用，它们是这个包的一部分。迭代器提供了一种遍历集合的技术，这可能非常有用。`ArrayList`类经常用于代替数组，当集合的大小可能会改变时。它提供了许多有价值的方法来修改集合。我们还将研究如何将集合（比如`ArrayList`）封装在另一个类中。'
- en: Arrays
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: An array allows multiple values to be accessed using a single variable name.
    Each element of an array is of the same type. The element type can be a simple
    primitive data type or a reference to an object.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数组允许使用单个变量名访问多个值。数组的每个元素都是相同类型的。元素类型可以是简单的原始数据类型或对象的引用。
- en: One-dimensional arrays are allocated to a contiguous region of memory. This
    means that the elements of the array can be accessed efficiently as they are adjacent
    to each other. Arrays use an integer index to access an element in the array.
    Indexes range from 0 to the length of the array minus one. We are able to access
    the elements of an array directly, in any order as needed by the application,
    without having to visit each element.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组分配到内存的连续区域。这意味着可以有效地访问数组的元素，因为它们是相邻的。数组使用整数索引来访问数组中的元素。索引范围从0到数组长度减一。我们能够直接访问数组的元素，按照应用程序需要的任何顺序，而无需访问每个元素。
- en: 'Though Java supports multidimensional arrays, one-dimensional arrays are most
    commonly used. Arrays can be used for a variety of purposes including:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Java支持多维数组，但一维数组最常用。数组可用于各种目的，包括：
- en: A collection of numbers representing ages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表年龄的数字集合
- en: A list of employee names
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 员工姓名列表
- en: A list of prices for an item in a store
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店商品价格列表
- en: The main disadvantage of arrays is that they have a fixed size. This makes it
    more difficult and less efficient to add, remove, or resize any list or collection
    of data represented by an array.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的主要缺点是它们具有固定的大小。这使得向数组表示的任何列表或集合添加、删除或调整大小更加困难和低效。
- en: Our discussion will begin with the coverage of one-dimensional and multidimensional
    arrays. This is followed by discussions of common array techniques such as traversing
    an array and copying arrays. In the first two sections, we will use simple "for
    loops" to traverse array elements. Alternative methods are covered in the *Traversing
    arrays* section.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论将从一维和多维数组的覆盖开始。接下来是关于常见数组技术的讨论，比如遍历数组和复制数组。在前两个部分中，我们将使用简单的“for循环”来遍历数组元素。替代方法在*遍历数组*部分中介绍。
- en: One-dimensional arrays
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一维数组
- en: 'A one-dimensional array is intended to represent a simple linear list. The
    following code snippet illustrates the declaration and use of a one-dimensional
    array. The array, `ages`, is declared in the first statement as an array of the
    `int` type. In the second statement, memory is allocated for the array using the
    `new` operator. In this example, the array consists of `5` elements:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组旨在表示一个简单的线性列表。以下代码片段说明了一维数组的声明和使用。数组`ages`在第一条语句中声明为`int`类型的数组。在第二条语句中，使用`new`运算符为数组分配内存。在这个例子中，数组由`5`个元素组成：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `ages` array has `5` elements allocated to it. The first index of any array
    is 0\. The largest index of an array is its length - 1\. Thus, the last index
    of the array is 4\. A runtime exception will be generated if an index used is
    outside the legal range of values for an array. The array could have been declared
    and created using a single statement, shown as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ages`数组有`5`个元素分配给它。任何数组的第一个索引都是0。数组的最大索引是其长度-1。因此，数组的最后一个索引是4。如果使用的索引超出了数组的合法值范围，将生成运行时异常。数组可以使用单个语句声明和创建，如下所示：'
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As an array name is a reference to an array, it is possible to assign a different
    array to the variable later in the program. We will demonstrate this later in
    the discussion.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组名称是对数组的引用，因此可以在程序的后期将不同的数组分配给变量。我们将在讨论中稍后演示这一点。
- en: 'An array is an object that is allocated from an area of memory known as the
    **heap** . The heap and program stack were introduced in the *Stack and heap*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*. In the following example, the first element
    of `ages` is assigned the value `35` and then displayed:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是从称为**堆**的内存区域分配的对象。堆和程序堆栈在[第2章](ch02.html "第2章。Java数据类型及其使用")的*堆栈和堆*部分中介绍，*Java数据类型及其使用*。在以下示例中，`ages`的第一个元素被赋予值`35`，然后显示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Arrays possess the `length` property that returns the number of elements in
    the array. When the next code sequence is executed, it will return `5`. Notice
    that `length` is not a method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有`length`属性，返回数组中的元素数。当执行下一个代码序列时，它将返回`5`。请注意，`length`不是一个方法：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Arrays are represented in Java as objects. In the previous example, `ages`
    is an object reference variable which references the array that has been allocated
    to the heap. This is illustrated in the following diagram:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，数组表示为对象。在上一个示例中，`ages`是一个对象引用变量，引用了分配给堆的数组。这在下图中有所说明：
- en: '![One-dimensional arrays](img/7324_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![一维数组](img/7324_04_01.jpg)'
- en: In this example, each element of the array was initialized to 0, by default,
    and then the first element was assigned a value of 35.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，数组的每个元素都默认初始化为0，然后将第一个元素赋值为35。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any attempt to use an index that is outside the bounds of the array will generate
    a `java.lang.ArrayIndexOutOfBoundsException` exception.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 任何尝试使用超出数组范围的索引都将生成`java.lang.ArrayIndexOutOfBoundsException`异常。
- en: The placement of array brackets
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组括号的放置
- en: 'There is a second option with regards to the placement of brackets when declaring
    an array. We can also place the brackets after the name of the array, shown as
    follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明数组时，括号的放置还有第二种选择。我们还可以在数组名称后放置括号，如下所示：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To the compiler, this is equivalent to the previous declaration. However, the
    placement of brackets with other uses of an array name is restricted. For example,
    we have to place the brackets after the array name when we are declaring or referencing
    elements of the array. If we attempt the following when declaring an array:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编译器来说，这等同于先前的声明。但是，括号与数组名称的其他用法的放置是受限制的。例如，当我们声明或引用数组的元素时，必须在数组名称后放置括号。如果我们在声明数组时尝试以下操作：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will get a syntax error as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下语法错误：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Likewise, if we try to use the brackets before the array name when referencing
    an element of the array, such as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们尝试在引用数组的元素时在数组名称之前使用括号，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We get the following syntax error message:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下语法错误消息：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It is more common to see brackets used after the data type of the array. For
    example, most IDEs will at some point generate a `main` method. It frequently
    appears below with the brackets following the data type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是在数组的数据类型后使用括号。例如，大多数IDE在某个时候都会生成一个`main`方法。它经常出现在数据类型后面跟着括号的下面：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, consider the declaration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，考虑以下声明：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Both `arr1` and `arr2` are declared as arrays. This is a simpler way of declaring
    more than one array on a single line. However, it can be argued that the following
    is a better format as it is more explicit:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr1`和`arr2`都声明为数组。这是在单行上声明多个数组的简单方法。然而，可以说以下格式更好，因为它更明确：'
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It can be also argued that declaring more than one variable on a line is a
    bad form. The best way of declaring these two arrays is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以说，在同一行声明多个变量是一种不好的形式。声明这两个数组的最佳方法如下：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Initializing arrays
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化数组
- en: 'The elements of an array are initialized to default values as shown in the
    following table. This table is duplicated from the *Initializing identifiers*
    section of [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*, for your convenience:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的元素被初始化为默认值，如下表所示。此表是从[第2章](ch02.html "第2章。Java数据类型及其使用")的*初始化标识符*部分中复制的，*Java数据类型及其使用*，以方便您查看：
- en: '| Data type | Default value (for fields) |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 默认值（对于字段） |'
- en: '| --- | --- |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `boolean` | false |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | false |'
- en: '| `byte` | 0 |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `byte` | 0 |'
- en: '| `char` | ''\u0000'' |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `char` | ''\u0000'' |'
- en: '| `short` | 0 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `short` | 0 |'
- en: '| `int` | 0 |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 0 |'
- en: '| `long` | 0L |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `long` | 0L |'
- en: '| `float` | 0.0f |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 0.0f |'
- en: '| `double` | 0.0d |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `double` | 0.0d |'
- en: '| `String` (or any object) | null |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `String`（或任何对象） | null |'
- en: In the previous example, we assigned a value of 35 to the first element of the
    array. This is a simple, yet tedious way of initializing the array to values other
    than the default value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们将值35赋给了数组的第一个元素。这是一种简单但繁琐的初始化数组的方法，以便将数组初始化为除默认值之外的值。
- en: 'An alternate technique is to use a block statement to initialize the array.
    This is illustrated in the following example, where `ages` is initialized to five
    different values. It is not necessary to specify the array size when using the
    block statement to initialize an array:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术是使用块语句初始化数组。在下面的示例中，`ages`初始化为五个不同的值。在使用块语句初始化数组时，不需要指定数组大小：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'A syntax error will be generated if you try to specify the size of the array,
    shown as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试指定数组的大小，将生成语法错误，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The message will appear as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将显示如下：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If we want to display the content of an array, there are several methods available.
    Here, we will use simple indexes and the `length` property. In the *Traversing
    arrays* section we will demonstrate other techniques.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要显示数组的内容，有几种方法可用。在这里，我们将使用简单的索引和`length`属性。在*遍历数组*部分，我们将演示其他技术。
- en: 'The following code sequence shows the difference between using the `toString`
    method and a for loop to display an array:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列显示了使用`toString`方法和for循环显示数组之间的区别：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When executed, we get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice the use of the `toString` method does not return the contents of the
    array. Rather, it returns a strange representation of the array. We have no control
    over the string returned by the `toString` method. However, the for loop gives
    us what we expected.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`toString`方法的使用并不返回数组的内容。相反，它返回数组的奇怪表示。我们无法控制`toString`方法返回的字符串。然而，for循环给了我们预期的结果。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that arrays in Java always begin with an index of 0.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，Java中的数组始终从索引0开始。
- en: 'Instead of hard coding the size of the array as `5`, as we did in an earlier
    example, a better approach is to use a constant. For example, the entire sequence
    could be rewritten as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 与在之前的示例中硬编码数组的大小为`5`不同，更好的方法是使用一个常量。例如，整个序列可以重写如下：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use named constants for array sizes. However, using the `length` attribute once
    the array is declared is preferred, as it is more maintainable should the array
    size change.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名常量来表示数组大小。但是，一旦数组声明后，使用`length`属性更可取，因为如果数组大小发生变化，它更易于维护。
- en: Arrays of objects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象数组
- en: 'It is important to keep a clear distinction between an object reference variable
    and the object itself. An array of objects uses a reference variable, such as
    the `names` variable declared below, which is a single memory location that contains
    a reference to an array object. Each element of the array is another reference
    which may reference a string. Initially, they are assigned a `null` value:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 保持对象引用变量和对象本身之间的清晰区分是很重要的。对象数组使用引用变量，例如下面声明的`names`变量，它是包含对数组对象引用的单个内存位置。数组的每个元素是另一个引用，可能引用一个字符串。最初，它们被分配了`null`值。
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The allocation of memory for this example is illustrated in the following diagram.
    However, we did not include the indexes for the array in the diagram. We can assume
    that the top element is at index 0 and the last element is at index 4:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的内存分配如下图所示。但是，我们没有在图中包含数组的索引。我们可以假设顶部元素的索引为0，最后一个元素的索引为4：
- en: '![Arrays of objects](img/7324_04_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![对象数组](img/7324_04_02.jpg)'
- en: 'When a string is assigned to an element of the array, the array element is
    modified to reference that string as illustrated as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当将字符串分配给数组的一个元素时，该数组元素将被修改为引用该字符串，如下所示：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following diagram illustrates the modification of the reference at index
    2 so that it references the string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了将索引2处的引用修改为引用字符串：
- en: '![Arrays of objects](img/7324_04_03.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![对象数组](img/7324_04_03.jpg)'
- en: 'Be careful when using arrays that might contain null values. Consider the following
    code sequence where we display the contents of the `names` array:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用可能包含空值的数组时要小心。考虑以下代码序列，其中我们显示`names`数组的内容：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'When executed, we will get the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们将得到以下输出：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Multidimensional arrays
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: Many applications require the use of arrays with two or more dimensions. Tabular
    data with rows and columns or one that uses the x/y coordinate system are good
    candidates for representation using a two-dimensional array. Three or more higher
    dimensions are not as common, but a coordinate system using an x, y, and z value
    would use three dimensions. In this section, we will demonstrate multidimensional
    arrays using integers. However, the techniques are equally applicable to arrays
    of objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序需要使用具有两个或更多维度的数组。具有行和列的表格数据或使用x/y坐标系的数据是使用二维数组表示的良好候选。三个或更多的高维度不太常见，但使用x、y和z值的坐标系将使用三个维度。在本节中，我们将使用整数来演示多维数组。然而，这些技术同样适用于对象数组。
- en: 'An example of how a two-dimensional array is declared is shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 二维数组的声明示例如下所示：
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will create an array with 2 rows and 3 columns depicted logically, as
    shown in the following diagram:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有2行3列的数组，逻辑上如下图所示：
- en: '![Multidimensional arrays](img/7324_04_04.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![多维数组](img/7324_04_04.jpg)'
- en: 'Notice that the indexes start with a zero. We can initialize each element using
    a series of assignment statements as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，索引从零开始。我们可以使用一系列赋值语句初始化每个元素，如下所示：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This is a bit tedious, but it illustrates the placement of numbers into the
    array, as shown in the following diagram:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点繁琐，但它说明了将数字放入数组的位置，如下图所示：
- en: '![Multidimensional arrays](img/7324_04_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![多维数组](img/7324_04_05.jpg)'
- en: 'Nested loops are useful for working with two-dimensional arrays. For example,
    to display the contents of such arrays, we will use a set of nested for loops
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套循环对于处理二维数组非常有用。例如，要显示这些数组的内容，我们将使用一组嵌套的for循环，如下所示：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When executed, we get the output as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Actually, Java does not support two-dimensional arrays in the strictest sense.
    In reality they are arrays of arrays. In languages such as C, two-dimensional
    arrays are stored in row-column order. This means that the two-dimensional array
    is mapped to a one-dimensional space where the first row is stored in the memory,
    followed by the second row and then the third and so forth. This is not applicable
    to Java.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Java不严格支持二维数组。实际上它们是数组的数组。在诸如C之类的语言中，二维数组按行列顺序存储。这意味着二维数组被映射到一个一维空间，其中第一行存储在内存中，然后是第二行，然后是第三行，依此类推。这在Java中不适用。
- en: 'Instead, what we actually have is a one-dimensional array of references to
    a series of other one-dimensional arrays. For example, we could have created the
    same `grades` array as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们拥有的是一个一维数组，其中包含对一系列其他一维数组的引用。例如，我们可以创建相同的`grades`数组：
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The array is allocated in the memory, as shown in the following diagram:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在内存中分配，如下图所示：
- en: '![Multidimensional arrays](img/7324_04_06.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![多维数组](img/7324_04_06.jpg)'
- en: In a two-dimensional array, the rows do not necessarily have to be the same
    size. In the following code sequence, we create an array with different row lengths.
    Arrays of this type are called **ragged arrays** .
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维数组中，行不一定要具有相同的大小。在以下代码序列中，我们创建了一个具有不同行长度的数组。这种类型的数组称为**不规则数组**。
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The memory allocation is similar to the previous example, except for the difference
    in array lengths, as shown in the following diagram:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 内存分配与前面的示例类似，只是数组长度不同，如下图所示：
- en: '![Multidimensional arrays](img/7324_04_07.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![多维数组](img/7324_04_07.jpg)'
- en: Array techniques
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组技术
- en: 'There are numerous techniques for working with arrays. In this section, we
    will examine many of these, including:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多处理数组的技术。在本节中，我们将研究其中许多技术，包括：
- en: Traversing arrays
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数组
- en: Comparing arrays
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较数组
- en: Copying arrays
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数组
- en: Passing an array
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递数组
- en: Using command-line arguments
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令行参数
- en: We will demonstrate variations to each technique as appropriate. Passing a variable
    number of arguments to a method is covered in [Chapter 6](ch06.html "Chapter 6. Classes,
    Constructors, and Methods"), *Classes, Constructors, and Methods*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据需要演示每种技术的变化。将可变数量的参数传递给方法在[第6章](ch06.html "第6章。类、构造函数和方法")*类、构造函数和方法*中有介绍。
- en: Traversing arrays
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历数组
- en: 'Traversing an array is the process of visiting each element of an array. This
    is frequently done starting with the first element and moving element by element
    until the end of the array is reached. However, it is also possible to move backwards
    or to skip elements. Here, we will focus on showing how we can traverse an array
    from beginning to end using two different techniques:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组是访问数组的每个元素的过程。通常从第一个元素开始，逐个元素移动，直到到达数组的末尾。但是，也可以向后移动或跳过元素。在这里，我们将重点介绍如何使用两种不同的技术从头到尾遍历数组：
- en: Using simple for loops
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用简单的for循环
- en: Using the for-each statement
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用for-each语句
- en: 'We will use the `ages` array, declared as follows, to illustrate how to traverse
    an array:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用如下声明的`ages`数组来说明如何遍历数组：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In each example, we will use this code to initialize each element of the array
    to 5.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个示例中，我们将使用此代码将数组的每个元素初始化为5。
- en: Using simple loops
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用简单循环
- en: 'Any simple loop can be used to traverse an array. Looping constructs are covered
    in more detail in [Chapter 5](ch05.html "Chapter 5. Looping Constructs"), *Looping
    Constructs*. Here, we will use a for loop and a while loop. First, ''let''s examine
    the for loop. In the following sequence, an integer variable starts at 0 and advances
    to the length of the array minus one:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 任何简单的循环都可以用来遍历数组。循环结构将在[第5章](ch05.html "第5章。循环结构")*循环结构*中更详细地介绍。在这里，我们将使用for循环和while循环。首先，让我们来看看for循环。在以下序列中，一个整数变量从0开始，逐步增加到数组长度减一：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The equivalent while loop follows. Note the `i` variable is declared outside
    of the loop:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 等效的while循环如下。请注意，`i`变量在循环外声明：
- en: '[PRE31]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The for loop is generally preferable because we know the length of the array
    and it is simpler for these types of problems. For both examples, we used the
    `length` property of the array to control the loop. This is preferable to using
    a constant variable that may have been used to declare the array. Consider the
    following situation where we redefine the array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，for循环是首选，因为我们知道数组的长度，并且对于这些类型的问题来说更简单。在这两个示例中，我们使用数组的`length`属性来控制循环。这比使用可能用于声明数组的常量变量更可取。考虑以下情况，我们重新定义数组：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The second for loop will not execute properly because we forgot to change the
    `SIZE` constant and may even throw an exception if the array is smaller than `SIZE`.
    If we had used the `length` property instead, there would not have been a problem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个for循环将无法正确执行，因为我们忘记更改`SIZE`常量，如果数组小于`SIZE`甚至可能抛出异常。如果我们使用`length`属性，就不会有问题。
- en: Notice, that the for loop, as written, declares the variable `i` within the
    for loop. This restricts access to the variable to only those statements within
    the for loop. In the while loop example, we declared `i` outside of the loop making
    it accessible inside, and outside, of the while loop. We could have rewritten
    the for loop to use an external `i` variable. However, it is considered to be
    better form to restrict access to a variable to only those statements that need
    access. Thus, if it is only needed inside of the loop then the for loop provides
    a better choice.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如写的for循环在循环内声明了变量`i`。这限制了对该变量的访问仅限于for循环内的语句。在while循环示例中，我们在循环外声明了`i`，使其在while循环内外都可以访问。我们可以重写for循环以使用外部的`i`变量。但是，最好的做法是将对变量的访问限制在只有需要访问的语句中。因此，如果只在循环内部需要它，那么for循环提供了更好的选择。
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using simple for statements can result in off-by-one errors (starting at the
    wrong beginning or ending index). For example, if the value used as the last index
    is larger than the size of the array minus one, then a `ArrayIndexOutOfBoundsException`
    exception will be thrown.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的for语句可能会导致偏移一个错误（从错误的开始或结束索引开始）。例如，如果用作最后一个索引的值大于数组大小减一，则会抛出`ArrayIndexOutOfBoundsException`异常。
- en: Using the for-each statement
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用for-each语句
- en: 'The for-each statement provides a more convenient method of traversing an array
    if we do not need explicit access to each element''s index value. The for-each
    parentheses'' body consists of a data type, a variable name, colon, and then an
    array (or collection). The statement will iterate through the array starting with
    the first element and ending with the last. During each iteration the variable
    references that array element. The following illustrates the use of this statement
    with the `ages` array. During the first iteration, `number` references `ages[0]`.
    During the second iteration, `number` references `ages[1]`. This continues for-each
    element of the array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不需要显式访问每个元素的索引值，for-each语句提供了一种更方便的遍历数组的方法。for-each括号的主体由数据类型、变量名、冒号，然后是一个数组（或集合）组成。该语句将从第一个元素开始迭代数组，并以最后一个元素结束。在每次迭代期间，变量引用该数组元素。以下是使用该语句与`ages`数组的示例。在第一次迭代中，`number`引用`ages[0]`。在第二次迭代中，`number`引用`ages[1]`。对数组的每个元素都是如此：
- en: '[PRE33]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The for-each statement makes it easy to traverse an array. However, if we need
    to use the index of an array element, the statement does not provide access to
    its value. The traditional for loop is needed to access the index.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句使得遍历数组变得容易。但是，如果我们需要使用数组元素的索引，该语句不提供对其值的访问。需要使用传统的for循环来访问索引。
- en: 'The following table summarizes the differences between the use of the for loop
    and the for-each loop:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了使用for循环和for-each循环的差异：
- en: '|   | for loop | for-each loop |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|   | for循环 | for-each循环 |'
- en: '| --- | --- | --- |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Provides access to the array element | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_10.jpg) |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 提供对数组元素的访问 | ![使用for-each语句](img/7324EN_04_10.jpg) | ![使用for-each语句](img/7324EN_04_10.jpg)
    |'
- en: '| Provides access to the array index | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_11.jpg) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 提供对数组索引的访问 | ![使用for-each语句](img/7324EN_04_10.jpg) | ![使用for-each语句](img/7324EN_04_11.jpg)
    |'
- en: '| Uses logical expression to control loop | ![Using the for-each statement](img/7324EN_04_10.jpg)
    | ![Using the for-each statement](img/7324EN_04_11.jpg) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 使用逻辑表达式来控制循环 | ![使用for-each语句](img/7324EN_04_10.jpg) | ![使用for-each语句](img/7324EN_04_11.jpg)
    |'
- en: '| Simplest | ![Using the for-each statement](img/7324EN_04_11.jpg) | ![Using
    the for-each statement](img/7324EN_04_10.jpg) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 最简单的 | ![使用for-each语句](img/7324EN_04_11.jpg) | ![使用for-each语句](img/7324EN_04_10.jpg)
    |'
- en: Comparing arrays
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较数组
- en: 'As an array variable is a reference variable, comparing array reference variables
    to determine equality will not always work. Here, we will examine several techniques
    for comparing arrays including:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于数组变量是引用变量，因此比较数组引用变量以确定相等性的方法并不总是有效。在这里，我们将研究几种比较数组的技术，包括：
- en: Element-by-element comparison
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个元素比较
- en: Using the equality operator
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等号运算符
- en: Using the `equals` method
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`equals`方法
- en: Using the `deepEquals` method
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`deepEquals`方法
- en: 'We will demonstrate these techniques by comparing two integer arrays. Consider
    the following example where two arrays, `arr1` and `arr2`, are equivalent after
    we initialize them to contain the same data:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过比较两个整数数组来演示这些技术。考虑以下示例，其中两个数组`arr1`和`arr2`在我们将它们初始化为包含相同数据后是等价的：
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following diagram shows how memory is allocated for both arrays:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了如何为两个数组分配内存：
- en: '![Comparing arrays](img/7324_04_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![比较数组](img/7324_04_08.jpg)'
- en: Element-by-element comparison
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 逐个元素比较
- en: 'This simple approach will compare the corresponding elements of each array
    to determine if the arrays are equal. It starts by assuming they are equal and
    assigns a `true` value to the `areEqual` variable. If any comparison is false,
    then the variable is assigned the value of `false`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简单的方法将比较每个数组的对应元素，以确定数组是否相等。它首先假定它们是相等的，并将`areEqual`变量赋值为`true`。如果任何比较为false，则变量将被赋值为`false`：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: When this sequence is executed, it will display `true`. This is not the best
    approach. Using indexes is an error prone and tedious approach.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此序列时，它将显示`true`。这不是最佳方法。使用索引是一种容易出错和繁琐的方法。
- en: Using the equality operator
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用等号运算符
- en: 'If we try to compare the two arrays using the equality operator, we find that
    the result of the comparison will be `false`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用等号运算符比较两个数组，我们会发现比较的结果将是`false`：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is because we are comparing `arr1` and `arr2` which are array reference
    variables and not the arrays. The variables, `arr1` and `arr2`, reference different
    objects in memory. The contents of these two reference variables are different,
    therefore, when they are compared to each other they are not equal. They don't
    reference the same object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们正在比较数组引用变量`arr1`和`arr2`而不是数组。变量`arr1`和`arr2`在内存中引用不同的对象。这两个引用变量的内容是不同的，因此当它们相互比较时它们是不相等的。它们不引用相同的对象。
- en: Using the equals method
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用equals方法
- en: We can use the `equals` method with arrays as we can with other objects. In
    the following example, the output will be false even though they are equivalent.
    This is because the `equals` method, as applied to arrays, tests for object equivalency
    and not object value equivalency.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像对其他对象一样对数组使用`equals`方法。在以下示例中，即使它们是等价的，输出也将是false。这是因为`equals`方法作用于数组时，测试的是对象的等价性而不是对象值的等价性。
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Object equivalency refers to the comparison of two object reference variables.
    If these variables reference the same object, they are considered to be equivalent.
    Object value equivalency refers to the condition where two distinct objects are
    considered to be equivalent because their internal values are the same.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对象等价性是指比较两个对象引用变量。如果这些变量引用相同的对象，则它们被视为等价的。对象值等价性是指当两个不同的对象被认为是等价的，因为它们的内部值相同。
- en: Using the deepEquals method
  id: totrans-176
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`deepEquals`方法
- en: To compare two arrays correctly we need to use the `Arrays` class' `equals`
    or `deepEquals` methods. The `equals` method performs a comparison using object
    identities. The `deepEquals` method performs a more in depth examination of the
    elements for value equivalency.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确比较两个数组，我们需要使用`Arrays`类的`equals`或`deepEquals`方法。`equals`方法使用对象标识进行比较。`deepEquals`方法对元素进行更深入的检查以进行值等价性的比较。
- en: 'The following statement will display `true`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语句将显示`true`：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `deepEquals` method requires an array of objects. The two-dimensional `grades`
    array, used in the *Multidimensional arrays* section, satisfies the requirement
    as it is an array of arrays, that is, an array that references other arrays (which
    are objects).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`deepEquals`方法需要一个对象数组。在*多维数组*部分使用的二维`grades`数组满足要求，因为它是一个数组的数组，即一个引用其他数组（即对象）的数组。'
- en: 'If we create a second grade array, `grades2`, and populate it with the same
    values as `grades`, we can use these methods to test for equality. The creation
    and initialization of the `grades2` array follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建第二个成绩数组`grades2`，并用与`grades`相同的值填充它，我们可以使用这些方法来测试它们是否相等。创建和初始化`grades2`数组如下：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If we execute the following sequence:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行以下序列：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We will get the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first three comparisons returned `false` because they did not adequately
    compare the two arrays. The fourth technique compared the arrays in depth and
    accurately determined their equivalency.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个比较返回`false`，因为它们没有充分比较两个数组。第四种技术对数组进行了深入比较，并准确确定了它们的等价性。
- en: 'The following table summarizes these techniques:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了这些技术：
- en: '| Technique | Comment |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 注释 |'
- en: '| --- | --- |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Element-by-element comparison | This will compare arrays properly, if implemented
    correctly. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 逐元素比较 | 如果正确实现，这将正确比较数组。 |'
- en: '| Using the equality operator | This only works properly if the two reference
    variables reference the same object. |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 使用等号运算符 | 只有当两个引用变量引用相同的对象时才有效。 |'
- en: '| Using the array''s `equals` method | This only works properly if the two
    reference variables reference the same object. |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 使用数组的`equals`方法 | 只有当两个引用变量引用相同的对象时才有效。 |'
- en: '| Using the `Array`''s class `equals` method | This will work for one-dimensional
    arrays. |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 使用`Array`类的`equals`方法 | 这将适用于一维数组。 |'
- en: '| Using the `Array`''s class `deepEquals` method | This performs a deeper comparison
    using the object''s `equals` method. |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 使用`Array`类的`deepEquals`方法 | 这使用对象的`equals`方法进行更深层次的比较。 |'
- en: Copying arrays
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复制数组
- en: 'There are times when we need to copy one array to another. In this section,
    we will examine various techniques to achieve this goal. These include:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要将一个数组复制到另一个数组。在本节中，我们将研究实现这一目标的各种技术。这些包括：
- en: Simple element-by-element copy
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的逐元素复制
- en: Using the `System.arraycopy` method
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`System.arraycopy`方法
- en: Using the `Arrays.copyOf` method
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Arrays.copyOf`方法
- en: Using the `Arrays.copyOfRange` method
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Arrays.copyOfRange`方法
- en: Using the `clone` method
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`clone`方法
- en: 'We will demonstrate the techniques using two one-dimensional arrays as declared
    below:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下声明的两个一维数组来演示这些技术：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will initialize each element of `arr1` to its index with the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下代码将`arr1`的每个元素初始化为其索引：
- en: '[PRE43]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this section's examples, the content of the destination array follows as
    a comment.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的示例中，目标数组的内容作为注释跟随。
- en: We will also use the terms, **shallow copy** and **deep copy**. Shallow copy
    refers to when only the reference values are copied. After the copy operation,
    the original object has not been duplicated. In a deep copy, the reference to
    the object is not copied. Instead, a new copy of the object is created. We will
    see how some of the techniques illustrated here only perform a shallow copy which
    may not always be desirable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用术语**浅复制**和**深复制**。浅复制是指只复制引用值。复制操作后，原始对象未被复制。在深复制中，对象的引用未被复制。相反，将创建对象的新副本。我们将看到这里演示的一些技术只执行浅复制，这可能并不总是理想的。
- en: Simple element-by-element copy
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 简单的逐元素复制
- en: 'A simple technique is to use a for loop as illustrated below:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的技巧是使用如下所示的for循环：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is a simple approach but you need to be careful to use the correct array
    indexes. This technique becomes more complicated with multidimensional arrays.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种简单的方法，但您需要小心使用正确的数组索引。这种技术在多维数组中变得更加复杂。
- en: Using the System.arraycopy method
  id: totrans-213
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`System.arraycopy`方法
- en: The `System` class' `arraycopy` method will attempt to copy all, or part, of
    one array to another. The beginning position in each array is specified, along
    with the number of elements to copy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`System`类的`arraycopy`方法将尝试将一个数组的所有或部分内容复制到另一个数组中。每个数组中的起始位置都有指定，并指定要复制的元素数量。'
- en: 'To copy all of the elements of `arr1` to `arr2` we can use the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`arr1`的所有元素复制到`arr2`，我们可以使用以下代码：
- en: '[PRE45]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The parameters of this method are detailed in the following table:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的参数在下表中详细说明：
- en: '| Parameter | Description |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `1` | The source array |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `1` | 源数组 |'
- en: '| `2` | The starting index in the source array |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `2` | 源数组中的起始索引 |'
- en: '| `3` | The destination array |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| `3` | 目标数组 |'
- en: '| `4` | The starting index in the destination array |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `4` | 目标数组中的起始索引 |'
- en: '| `5` | The number of elements to copy |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `5` | 要复制的元素数量 |'
- en: 'The next sequence copies the first three elements of `arr1` to the last three
    elements of `arr2`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个序列将`arr1`的前三个元素复制到`arr2`的最后三个元素：
- en: '[PRE46]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can also copy part of one array to other positions within the same array.
    Here we copy the first two elements to the last two elements of the `arr1` array:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将一个数组的一部分复制到同一数组的其他位置。在这里，我们将前两个元素复制到`arr1`数组的最后两个元素：
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There are numerous opportunities for exceptions to occur when using this technique.
    If either array reference is null, a `NullPointerException` exception is thrown.
    If the array indexes are invalid, then we will get a `IndexOutOfBoundsException`
    exception.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用这种技术时，有许多异常发生的机会。如果任一数组引用为null，则会抛出`NullPointerException`异常。如果数组索引无效，则会得到`IndexOutOfBoundsException`异常。
- en: 'The `arraycopy` method will copy the specified elements of the source array
    to the corresponding element of the destination array. There are two possible
    results depending on the data type of the array. They are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`arraycopy`方法将源数组的指定元素复制到目标数组的相应元素。根据数组的数据类型，可能会有两种可能的结果。它们如下：'
- en: If the array element type is a primitive data type, then the two arrays are
    effectively identical.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组元素类型是原始数据类型，则两个数组实际上是相同的。
- en: If the array element type is a reference, then both arrays will be identical
    but they will both reference the same objects. This is usually not the effect
    anticipated or desired.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数组元素类型是引用类型，则两个数组将是相同的，但它们都将引用相同的对象。这通常不是预期或期望的效果。
- en: 'In the following code sequence, an attempt is made to create an identical copy
    of the `StringBuilder` array, `arr3`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码序列中，尝试创建`StringBuilder`数组`arr3`的相同副本：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'However, `arr4` contains the same object reference variables used by `arr3`.
    The corresponding element of both arrays reference the same object. The creation
    of an identical array with references to distinct strings is achieved with the
    following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`arr4`包含与`arr3`使用的相同对象引用变量。两个数组的相应元素引用相同的对象。通过以下代码实现了具有对不同字符串的引用的相同数组的创建：
- en: '[PRE49]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We created a new `StringBuilder` object for-each element of the destination
    array. This approach is necessary if a deep copy is needed.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为目标数组的每个元素创建了一个新的`StringBuilder`对象。如果需要深复制，则需要使用这种方法。
- en: Using the Arrays.copyOf method
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Arrays.copyOf方法
- en: 'The `Arrays` class'' `copyOf` method will create a new array based on an existing
    array. The first argument of the method specifies the original array. Its second
    argument specifies how many elements to copy. In the following example, we create
    a new array based on the first three elements of `arr1`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrays`类的`copyOf`方法将基于现有数组创建一个新数组。该方法的第一个参数指定原始数组。它的第二个参数指定要复制的元素数量。在下面的示例中，我们基于`arr1`的前三个元素创建一个新数组：'
- en: '[PRE50]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The new array can be larger than the original array as illustrated with the
    following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 新数组可以比原始数组大，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The last five elements of `arr2` will be padded with zeros.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr2`的最后五个元素将填充为零。'
- en: If the array is an array of objects, a copy of the original object is assigned
    to the new array.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组是对象数组，则将原始对象的副本分配给新数组。
- en: Using the Arrays.copyOfRange method
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Arrays.copyOfRange方法
- en: 'The `Arrays` class'' `copyOfRange` method will create a new array based on
    a sub-range of elements in an existing array. The first argument of the method
    specifies the original array. Its second argument specifies the beginning index
    and the last argument specifies the ending index exclusive. In the following example,
    we create a new array based on the last two elements of `arr1`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrays`类的`copyOfRange`方法将基于现有数组中的子范围的元素创建一个新数组。该方法的第一个参数指定原始数组。它的第二个参数指定开始索引，最后一个参数指定结束索引（不包括）。在下面的示例中，我们基于`arr1`的最后两个元素创建一个新数组：'
- en: '[PRE52]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Notice that the last argument is not a valid index for the `arr1` array. This
    works here because the last argument is exclusive. It does not include that element.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后一个参数对于`arr1`数组不是有效的索引。这里有效是因为最后一个参数是排他的。它不包括该元素。
- en: 'In fact, if we specify a value such as `8` in the next example, the new array
    is padded with zeros:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果在下一个示例中指定一个值，比如`8`，新数组将填充为零：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Using the clone method
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用clone方法
- en: 'You can also use the `Object` class'' `clone` method to create a copy of an
    array:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Object`类的`clone`方法来创建数组的副本：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: However, this only makes a shallow copy of the original object. With an array
    of primitives such as the above integer array, this is not a problem. With an
    array of references to objects, both arrays will reference the same objects.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是对原始对象进行浅复制。对于原始数据类型的数组，比如上面的整数数组，这不是问题。对于对象的引用数组，两个数组将引用相同的对象。
- en: 'The following table summarizes the copying techniques introduced in this section:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了本节介绍的复制技术：
- en: '| Technique | Comment |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 技术 | 评论 |'
- en: '| --- | --- |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Simple element-by-element copy | Tedious but can implement either a shallow
    or deep copy |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 逐个元素简单复制 | 繁琐，但可以实现浅复制或深复制 |'
- en: '| Using the `System.arraycopy` method | Performs a shallow copy |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 使用`System.arraycopy`方法 | 执行浅复制 |'
- en: '| Using the `Arrays.copyOf` method | Performs a deep copy of the entire array
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 使用`Arrays.copyOf`方法 | 执行整个数组的深复制 |'
- en: '| Using the `Arrays.copyOfRange` method | Performs a deep copy of part of an
    array |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 使用`Arrays.copyOfRange`方法 | 对数组的一部分执行深复制 |'
- en: '| Using the `clone` method | Performs a shallow copy |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 使用`clone`方法 | 执行浅复制 |'
- en: Passing arrays
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递数组
- en: The advantage of passing an array to a method is that it allows us to perform
    the same operation against more than one array. To pass an array to a method,
    we use the array name in the method call and declare a reference to the passed
    array in the method. This is illustrated below with a call to the `displayArray`
    method. This method simply displays the array.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将数组传递给方法的优点是，它允许我们对一个以上的数组执行相同的操作。要将数组传递给方法，我们在方法调用中使用数组名称，并在方法中声明对传递数组的引用。下面通过调用`displayArray`方法来说明这一点。该方法只是显示数组。
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Notice that we are "passing a reference" to the `arr2` array "by value". That
    is, if we want, we can read and write the elements of the `arr2` array in the
    method. However, if we modify the `arr` parameter, the original `arr2` variable
    is not modified.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们是通过值“传递引用”到`arr2`数组的。也就是说，如果需要，我们可以在方法中读取和写入`arr2`数组的元素。但是，如果修改`arr`参数，则原始的`arr2`变量不会被修改。
- en: 'Consider the method in the following code that attempts to change what the
    `arr2` reference variable points to:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码中的方法，该方法尝试更改`arr2`引用变量指向的内容：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'When we execute this code, we get the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行此代码时，我们会得到以下输出：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The value of `arr` was changed but the value of `arr2` was not changed. The
    following diagram should help clarify this behavior:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr`的值被改变，但`arr2`的值没有改变。以下的图表应该有助于澄清这种行为：'
- en: '![Passing arrays](img/7324_04_09.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![传递数组](img/7324_04_09.jpg)'
- en: Using command-line arguments
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命令行参数
- en: When a Java application executes, the first method that is executed is the `main`
    method. This method passes an argument, an array of `String` objects called `args`.
    These strings correspond to those provided on the command line.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java应用程序执行时，执行的第一个方法是`main`方法。该方法传递一个参数，一个名为`args`的`String`对象数组。这些字符串对应于命令行提供的字符串。
- en: The `length` property of a Java array will tell us how many command-line arguments
    were used. The first argument of the array will contain the first command-line
    parameter. The second will contain the second command-line parameter, and so forth.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Java数组的`length`属性将告诉我们使用了多少个命令行参数。数组的第一个参数将包含第一个命令行参数。第二个将包含第二个命令行参数，依此类推。
- en: 'The following `CommandLineDemo` application illustrates the use of the `args`
    array:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`CommandLineDemo`应用程序演示了`args`数组的使用：
- en: '[PRE58]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Consider that the application is invoked with the following command-line arguments:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑应用程序使用以下命令行参数调用：
- en: '[PRE59]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output of the program would appear as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出将如下所示：
- en: '[PRE60]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The Arrays class
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组类
- en: 'The `java.util.Arrays` class possesses several methods useful for working with
    arrays. Every method of the class is a static method which means that we do not
    have to create an instance of the `Arrays` class before we use its methods. The
    class is designed to work with arrays and perform common operations on arrays.
    The types of operations available include:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.Arrays`类拥有几种对数组进行操作的有用方法。该类的每个方法都是静态方法，这意味着我们在使用其方法之前不必创建`Arrays`类的实例。该类旨在处理数组并对数组执行常见操作。可用的操作类型包括：'
- en: Returning a `List` based on an array
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于数组返回一个`List`
- en: Performing a binary search
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行二分搜索
- en: Making copies of an array
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复制数组
- en: Determining the equality of two arrays
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定两个数组的相等性
- en: Filling arrays
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充数组
- en: Sorting arrays
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数组进行排序
- en: We have seen the use of several of these techniques in earlier sections. Here
    we will demonstrate the use of the `asList` , `fill`, `toString` , and `deepToString`
    methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的部分看到了几种这些技术的使用。在这里，我们将演示`asList`，`fill`，`toString`和`deepToString`方法的使用。
- en: 'Consider the following declarations. We will declare an integer array and then
    an array list. Two strings will be added to the `ArrayList` object. We will also
    create an array of mixed objects and an array of strings. The `ArrayList` class
    is discussed in more detail in the *ArrayList* section:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下声明。我们将声明一个整数数组，然后声明一个数组列表。两个字符串将被添加到`ArrayList`对象中。我们还将创建一个混合对象数组和一个字符串数组。`ArrayList`类在*ArrayList*部分中有更详细的讨论：
- en: '[PRE61]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we will fill the integer array with the number `5` using the `fill` method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用`fill`方法用数字`5`填充整数数组：
- en: '[PRE62]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `asList` , `toString` , and `deepToString` methods are then used against
    these arrays, shown as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`asList`，`toString`和`deepToString`方法对这些数组进行操作，如下所示：
- en: '[PRE63]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When executed we get the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE64]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The `asList` method takes its array argument and returns a `java.util.List`
    object representing the array. If either the array or the list is modified, their
    corresponding elements are modified. This is demonstrated in the following example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`asList`方法接受其数组参数并返回表示数组的`java.util.List`对象。如果修改了数组或列表，它们对应的元素也会被修改。这在以下示例中得到了证明：'
- en: '[PRE65]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The output of this sequence follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE66]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `toString` method returns a string representation of the array. The `deepToString`
    method is intended to return a string representation of its array argument where
    the array is more complex. This was reflected in `arr2` which contains different
    objects including a list.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`toString`方法返回数组的字符串表示。`deepToString`方法旨在返回其数组参数的字符串表示，其中数组更复杂。这在`arr2`中得到了体现，其中包含了不同的对象，包括一个列表。'
- en: Key points to remember when using arrays
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在使用数组时要记住的关键点
- en: 'When working with arrays remember:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数组时，请记住：
- en: Array indexes start at 0
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组索引从0开始
- en: Indexes have to be integers
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引必须是整数
- en: An array can hold primitive data types or objects
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组可以保存原始数据类型或对象
- en: Arrays provide constant time random access which is an efficient way of accessing
    data
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组提供了常数时间的随机访问，这是一种访问数据的高效方式
- en: Arrays provide good locality of reference
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组提供良好的引用局部性
- en: Arrays are more difficult to insert or remove elements than other data structures
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他数据结构相比，数组更难插入或删除元素
- en: An index to an invalid element is possible
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能存在对无效元素的索引
- en: Locality of reference refers to the idea that if one data item is accessed,
    it is likely that another nearby data item will also be accessed. This results
    in faster read and write operations and is an important concept in virtual operating
    systems. Accessing elements of an array can be faster than accessing elements
    of a linked list when the linked list is spread across the memory.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 引用的局部性是指如果访问一个数据项，很可能也会访问附近的另一个数据项。这导致更快的读写操作，是虚拟操作系统中的一个重要概念。在内存中分布的链表的访问元素可能比链表的访问元素更快。
- en: Be careful when accessing elements of an array. If the array is not properly
    initialized, then the element being indexed may be invalid resulting in a run-time
    or logic error.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问数组元素时要小心。如果数组没有正确初始化，那么索引的元素可能无效，导致运行时或逻辑错误。
- en: Collections
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合
- en: 'The Collections Framework was introduced in Java 2 as a set of interfaces and
    classes that are superior to many of the interfaces and classes found in the earlier
    `java.util` package such as `Vector`, `Stack`, and `HashTable`. These interfaces
    and classes should always be used instead of the older ones whenever possible.
    Many of the Collection Framework interfaces and classes are summarized in the
    following table:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架是在Java 2中引入的一组接口和类，它们优于早期`java.util`包中找到的许多接口和类，如`Vector`、`Stack`和`HashTable`。这些接口和类应该在可能的情况下始终使用，而不是旧的接口和类。集合框架的许多接口和类在以下表中进行了总结：
- en: '| Interface | Class |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | 类 |'
- en: '| --- | --- |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Set | `HashSet``TreeSet` |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| 集合 | `HashSet``TreeSet` |'
- en: '| List | `ArrayList``LinkedList` |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| 列表 | `ArrayList``LinkedList` |'
- en: '| Map | `HashMap``TreeMap` |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| 映射 | `HashMap``TreeMap` |'
- en: The Collection Framework is covered in more detail at [http://java.sun.com/developer/onlineTraining/collections/Collection.html](http://java.sun.com/developer/onlineTraining/collections/Collection.html).
    Here, we will address the `ArrayList` class as it is a certification topic. It
    is recommended that the `ArrayList` class be used when a `List` is needed. As
    we will see, iterators are used with the `ArrayList` to support traversal of the
    list. We will start our discussion with coverage of this topic.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架在[http://java.sun.com/developer/onlineTraining/collections/Collection.html](http://java.sun.com/developer/onlineTraining/collections/Collection.html)中有更详细的介绍。在这里，我们将讨论`ArrayList`类，因为它是一个认证主题。建议在需要`List`时使用`ArrayList`类。正如我们将看到的，迭代器用于`ArrayList`来支持列表的遍历。我们将从这个主题的覆盖开始我们的讨论。
- en: Iterators
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器
- en: 'Iterators provide a means of traversing a set of data. It can be used with
    arrays and various classes in the Collection Framework. The `Iterator` interface
    supports the following methods:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器提供了遍历一组数据的方法。它可以与数组和集合框架中的各种类一起使用。`Iterator`接口支持以下方法：
- en: '`next`: This method returns the next element'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：该方法返回下一个元素'
- en: '`hasNext`: This method returns `true` if there are additional elements'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext`：如果有附加元素，则该方法返回`true`'
- en: '`remove`: This method removes the element from the list'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：该方法从列表中移除元素'
- en: The `remove` method is an optional `Iterator` method. If an attempt is made
    to use this method and the implementation of the interface does not support this
    method, then an `UnsupportedOperationException` exception is thrown.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove`方法是一个可选的`Iterator`方法。如果尝试使用此方法，而接口的实现不支持此方法，则会抛出`UnsupportedOperationException`异常。'
- en: 'The `ListIterator` interface , when available, is an alternative to the `Iterator`
    interface. It uses the same methods and provides additional capabilities including:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListIterator`接口，当可用时，是`Iterator`接口的替代品。它使用相同的方法并提供额外的功能，包括：'
- en: Traversal of the list in either direction
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任一方向上遍历列表
- en: Modification of its elements
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改其元素
- en: Access to the element's position
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问元素的位置
- en: 'The methods of the `ListIterator` interface include the following:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListIterator`接口的方法包括以下内容：'
- en: '`next`: This method returns the next element'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`next`：该方法返回下一个元素'
- en: '`previous`: This method returns the previous element'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previous`：该方法返回前一个元素'
- en: '`hasNext`: This method returns `true` if there are additional elements that
    follow the current one'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasNext`：如果有跟随当前元素的附加元素，则该方法返回`true`'
- en: '`hasPrevious`: This method returns `true` if there are additional elements
    that precede the current one'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hasPrevious`：如果有前面的附加元素，则该方法返回`true`'
- en: '`nextIndex`: This method returns the index of the next element to be returned
    by the `next` method'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nextIndex`：该方法返回`next`方法将返回的下一个元素的索引'
- en: '`previousIndex`: This method returns the index of the previous element to be
    returned by the `previous` method'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`previousIndex`：该方法返回`previous`方法将返回的上一个元素的索引'
- en: '`add`: This method inserts an element into the list (optional)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add`：该方法在列表中插入一个元素（可选）'
- en: '`remove`: This method removes the element from the list (optional)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：该方法从列表中移除元素（可选）'
- en: '`set`: This method replaces an element in the list (optional)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`：该方法替换列表中的一个元素（可选）'
- en: ArrayList
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ArrayList
- en: 'The `ArrayList` class has several useful characteristics:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类具有几个有用的特性：'
- en: It is flexible
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是灵活的
- en: Grows as needed
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要增长
- en: Possesses many useful methods
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有许多有用的方法
- en: Access is performed in constant time
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问在常数时间内执行
- en: Insertion/deletion is performed in linear time
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入/删除在线性时间内执行
- en: Can be traversed with indexes, for-each loops, or iterators
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用索引、for-each循环或迭代器遍历
- en: '`ArrayList` uses an array internally. When it needs to grow, elements are copied
    from the old array to the new array.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`在内部使用数组。当需要增长时，元素从旧数组复制到新数组。'
- en: The `ArrayList` class is not synchronized. When an iterator is obtained for
    a `ArrayList` object, it is susceptible to possible simultaneous overwrites with
    loss of data if modified in a concurrent fashion. When multiple threads access
    the same object, it is possible that they may all write to the object at the same
    time, that is, concurrently. When this simultaneous overwrite occurs, a `ConcurrentModificationException`
    exception is thrown.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类不是同步的。当为`ArrayList`对象获取迭代器时，如果以并发方式修改，可能会导致数据丢失的可能同时覆盖。当多个线程访问同一对象时，它们可能同时写入对象，即并发。当发生这种同时覆盖时，会抛出`ConcurrentModificationException`异常。'
- en: Creating ArrayList
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建ArrayList
- en: 'The `ArrayList` class possesses the following three constructors:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类具有以下三个构造函数：'
- en: A default constructor
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认构造函数
- en: One that accepts a `Collection` object
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受`Collection`对象
- en: One that accepts an initial capacity
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受初始容量
- en: 'The capacity of a `ArrayList` object refers to how many elements the list can
    hold. When more elements need to be added and the list is full, the size of the
    list will be automatically increased. The initial capacity of a `ArrayList` created
    with its default constructor is `10`. The following example creates two lists,
    one with a capacity of `10` and the second with a capacity of `20`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`对象的容量指的是列表可以容纳多少元素。当需要添加更多元素且列表已满时，列表的大小将自动增加。使用其默认构造函数创建的`ArrayList`的初始容量为`10`。以下示例创建了两个列表，一个容量为`10`，另一个容量为`20`：'
- en: '[PRE67]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `ArrayList` class supports generics. Here, a list of strings is created:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类支持泛型。在这里，创建了一个字符串列表：'
- en: '[PRE68]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We will use `list3` in the examples that follow.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的示例中使用`list3`。
- en: Adding elements
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加元素
- en: 'There are several methods available for adding elements to an `ArrayList`.
    They can be placed into one of the following two categories:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可用于向`ArrayList`添加元素。它们可以被放入以下两个类别之一：
- en: Appends one or more elements to the end of the list
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个或多个元素附加到列表的末尾
- en: Inserts one or more elements at a position within the list
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表中的位置插入一个或多个元素
- en: 'The simplest case is illustrated here where a string is added to the end of
    `creatures`:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的情况如下所示，其中一个字符串被添加到`creatures`的末尾：
- en: '[PRE69]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The output of the print statement follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 打印语句的输出如下：
- en: '[PRE70]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To insert an element at the index after the first element we use an index of
    1:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 要在第一个元素之后的索引处插入一个元素，我们使用索引1：
- en: '[PRE71]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Executing the code will verify the actions, as shown below:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码将验证操作，如下所示：
- en: '[PRE72]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The `addAll` method can also be used with `Collections`, as illustrated below:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAll`方法也可以与`Collections`一起使用，如下所示：'
- en: '[PRE73]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will result in the `cuddles` being placed after the second element in
    the list, as shown below:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致`cuddles`被放置在列表中第二个元素之后，如下所示：
- en: '[PRE74]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `addAll` method can also be used without an index argument. In this case,
    the new elements are added to the end of the list.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`addAll`方法也可以不带索引参数使用。在这种情况下，新元素将添加到列表的末尾。'
- en: Retrieving elements
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检索元素
- en: 'To retrieve an element at a given position, use the `get` method. This method
    takes a single integer index value. In the following example, we retrieve the
    third element of the list. Assuming that the creatures list contains `[Mutant,
    Godzilla, Tribbles, Ewoks, Alien, Zombie]`, the following statement will retrieve
    `Tribbles`:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索给定位置的元素，请使用`get`方法。此方法接受一个整数索引值。在下面的示例中，我们检索列表的第三个元素。假设creatures列表包含`[Mutant,
    Godzilla, Tribbles, Ewoks, Alien, Zombie]`，以下语句将检索`Tribbles`：
- en: '[PRE75]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The index of an element can be obtained using the `indexOf` method as illustrated
    in the next code sequence. If the element does not exist, the method will return
    a -1.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`indexOf`方法获取元素的索引，如下一个代码序列所示。如果元素不存在，该方法将返回-1。
- en: '[PRE76]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Executing this code will generate the following output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码将生成以下输出：
- en: '[PRE77]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `indexOf` method will return the index of the first element found. The `lastIndexOf`
    method will return the index of the last element found in the list.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`indexOf`方法将返回找到的第一个元素的索引。`lastIndexOf`方法将返回列表中找到的最后一个元素的索引。'
- en: The `toArray` method will return an array of the objects in the list. In this
    example, the `creatures` list is returned and assigned to the `complete` array.
    If the array is not large enough, as is the case here, a new array is created
    and returned.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '`toArray`方法将返回列表中对象的数组。在此示例中，返回`creatures`列表并将其分配给`complete`数组。如果数组不够大，就像这里一样，将创建并返回一个新数组。'
- en: '[PRE78]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When executed, we get the following output:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，我们得到以下输出：
- en: '[PRE79]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: There is also a `subList` method that returns part of the list given the starting
    and ending indexes.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`subList`方法，根据起始和结束索引返回列表的一部分。
- en: Traversing a ArrayList object
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历`ArrayList`对象
- en: 'To traverse a `ArrayList` object we can use one of several approaches:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 要遍历`ArrayList`对象，我们可以使用几种方法之一：
- en: A simple for statement
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的for语句
- en: A for-each statement
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个for-each语句
- en: Using `Iterator`
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Iterator`
- en: Using `ListIterator`
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListIterator`
- en: 'We can use a for loop but it is more prone to error. The following code will
    display the list from the beginning to the end:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用for循环，但更容易出错。以下代码将从头到尾显示列表：
- en: '[PRE80]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Notice the use of the `size` method, which returns the number of elements in
    the list.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`size`方法，它返回列表中的元素数。
- en: 'The for-each statement is the simplest approach, as illustrated in the following
    code snippet:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: for-each语句是最简单的方法，如下面的代码片段所示：
- en: '[PRE81]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The `iterator` method returns a `Iterator` object, as shown below:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`iterator`方法返回一个`Iterator`对象，如下所示：'
- en: '[PRE82]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `ListIterator` method returns a `ListIterator` object:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListIterator`方法返回一个`ListIterator`对象：'
- en: '[PRE83]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'All four of these techniques will produce the same output as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种技术都将产生以下相同的输出：
- en: '[PRE84]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'If we add the following code to the end of the previous code sequence, we can
    traverse the list in reverse order, as shown in the following code snippet:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将以下代码添加到上一个代码序列的末尾，我们可以按照逆序遍历列表，如下面的代码片段所示：
- en: '[PRE85]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output is as follows:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Sorting a ArrayList object
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对`ArrayList`对象进行排序
- en: 'While there are no specific methods in the `ArrayList` class for sorting, we
    can use the `Arrays` class'' `sort` method, as illustrated in the following code
    snippet:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ArrayList`类中没有特定的排序方法，但我们可以使用`Arrays`类的`sort`方法，如下面的代码片段所示：
- en: '[PRE87]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE88]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: An overloaded version of this method takes a `Comparator` object. This object
    determines how comparisons are made.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的重载版本使用`Comparator`对象。此对象确定如何进行比较。
- en: Other ArrayList methods
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他`ArrayList`方法
- en: 'We can modify an element of a list using the `set` method. This method takes
    an index of the element to replace, and the new value. For example, to replace
    the first element of the creatures list with the string `Ghoul` we can use the
    following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`set`方法修改列表的一个元素。此方法接受要替换的元素的索引和新值。例如，要用字符串`Ghoul`替换creatures列表的第一个元素，我们可以使用以下代码：
- en: '[PRE89]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The replacement is verified by the following output:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下输出验证了替换：
- en: '[PRE90]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We can remove all or some of the elements of a list. The `clear` method will
    remove all elements. The `remove` method removes a single element and the `removeAll`
    method removes all values in a given collection from the list. The following code
    sequence illustrates these methods. The `cuddles` `ArrayList` was defined in the
    *Adding elements* section:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以移除列表的所有或部分元素。`clear`方法将移除所有元素。`remove`方法将移除单个元素，`removeAll`方法将从列表中移除给定集合中的所有值。以下代码序列说明了这些方法。`cuddles`
    `ArrayList`在*添加元素*部分中被定义：
- en: '[PRE91]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The output of this sequence is as follows:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列的输出如下：
- en: '[PRE92]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'While `ArrayList` is a powerful class, arrays should still be used if:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`ArrayList`是一个强大的类，但如果：
- en: There is a known number of elements
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已知元素的数量
- en: It has a small fixed upper bound
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个小的固定上限
- en: Primitive data types are needed for efficiency
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要原始数据类型以提高效率
- en: No elements need to be inserted
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要插入元素
- en: Encapsulating collections
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装集合
- en: 'When using a collection within a class, hide the collection to prevent inadvertent
    modification of the collection. For example, if a class encapsulates an `ArrayList`
    of `Books`, then public methods should be provided to permit access to the collection.
    In the following example, a class called `Library` hides an `ArrayList` of `Book`
    objects:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中使用集合时，隐藏集合以防止无意修改集合。例如，如果一个类封装了一个`ArrayList`的`Books`，那么应该提供公共方法来允许访问集合。在下面的例子中，一个名为`Library`的类隐藏了`Book`对象的`ArrayList`：
- en: '[PRE93]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This is a good example of data encapsulation. However, be sure to not inadvertently
    expose private data. In the `getBook` method we returned a reference to the book.
    This reference allows the user to modify the book. If this modification should
    not be allowed, then a copy of the book can be returned instead, as shown below.
    This assumes that the `Book` class has a constructor that makes a new copy of
    a book based upon the constructor''s argument:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这是数据封装的一个很好的例子。但是，请确保不要无意中暴露私有数据。在`getBook`方法中，我们返回了对书的引用。这个引用允许用户修改书。如果不允许进行此修改，则可以返回书的副本，如下所示。这假设`Book`类有一个构造函数，根据构造函数的参数制作书的新副本：
- en: '[PRE94]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The same problem occurs with the `getBooks` method. It returns a reference
    to the private `books` reference variable of the `Library` class. This method
    can be replaced with the following implementation to ensure proper data encapsulation:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBooks`方法也存在相同的问题。它返回`Library`类的私有`books`引用变量的引用。可以用以下实现替换此方法以确保正确的数据封装：'
- en: '[PRE95]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Summary
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we examined the creation and use of arrays and instances of
    the `ArrayList` class. We also detailed the use of the `Arrays` class in support
    of various array operations.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了数组的创建和使用以及`ArrayList`类的实例。我们还详细介绍了`Arrays`类在支持各种数组操作方面的使用。
- en: Arrays contain one or more dimensions and are treated as objects. Care must
    be taken while using arrays to avoid problems accessing their elements. Problems
    can be avoided with a good understanding of how arrays are allocated in memory
    and of how to perform various operations, such as copying and comparing arrays,
    on them. Arrays are useful when we need a list of a fixed size as it allows efficient
    access of its elements.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 数组包含一个或多个维度，并被视为对象。在使用数组时必须小心，以避免访问其元素时出现问题。通过对内存中的数组分配以及如何执行各种操作（例如复制和比较数组）有很好的理解，可以避免出现问题。当我们需要一个固定大小的列表时，数组是很有用的，因为它允许高效地访问其元素。
- en: The `Arrays` class provides a number of static methods that support arrays.
    For example, we can use the `Arrays` class to make copies of arrays, sort arrays,
    and fill arrays.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`Arrays`类提供了许多支持数组的静态方法。例如，我们可以使用`Arrays`类来复制数组，对数组进行排序和填充数组。'
- en: The `ArrayList` class provides an alternate approach for dealing with lists
    of data. It provides numerous methods for manipulating a list and will grow as
    needed when new elements are added to the list. This is one of its primary advantages
    over arrays. As with most data structures, it is important to encapsulate information
    in a class to help reduce the complexity of software development.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArrayList`类提供了处理数据列表的另一种方法。它提供了许多用于操作列表的方法，并且在需要时会根据添加到列表中的新元素而增长。这是它相对于数组的主要优势之一。与大多数数据结构一样，将信息封装在类中以帮助减少软件开发的复杂性是很重要的。'
- en: Now that we've learned about arrays, we're ready to look more carefully at the
    various looping constructs available in Java. We will examine these constructs
    in the next chapter.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数组，我们准备更仔细地查看Java中可用的各种循环结构。我们将在下一章中详细讨论这些结构。
- en: The Collections Framework introduced several new interfaces and classes to replace
    older versions in the `java.util` package. We examined the `ArrayList` class and
    its methods used to manipulate its elements. The `ArrayList` class is more flexible
    than an array and is particularly useful for inserting and removing elements.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 集合框架引入了几个新的接口和类来替换`java.util`包中的旧版本。我们研究了`ArrayList`类及其用于操作其元素的方法。`ArrayList`类比数组更灵活，特别适用于插入和移除元素。
- en: Certification objectives covered
  id: totrans-448
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'In this chapter we covered the following certification objectives:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下认证目标：
- en: Using one-dimensional arrays
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一维数组
- en: Using multidimensional arrays
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多维数组
- en: Declaring and using `ArrayList`
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明和使用`ArrayList`
- en: Test your knowledge
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which of the following statements will compile without an error?
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个语句将编译而不会出错？
- en: a. `int arr[];`
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: a. `int arr[];`
- en: b. `int arr[5];`
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: b. `int arr[5];`
- en: c. `int arr[5] = {1,2,3,4,5};`
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: c. `int arr[5] = {1,2,3,4,5};`
- en: d. `int arr[] = {1,2,3,4,5};`
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: d. `int arr[] = {1,2,3,4,5};`
- en: Which of the following declares an array that supports two rows and a variable
    number of columns?
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个声明了一个支持两行和可变列数的数组？
- en: a. `int arr[][] = new int[2][3];`
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: a. `int arr[][] = new int[2][3];`
- en: b. `int arr[][] = new int[2][];`
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: b. `int arr[][] = new int[2][];`
- en: c. `int arr[][] = new int[][];`
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: c. `int arr[][] = new int[][];`
- en: d. `int arr[][] = new int[][3];`
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: d. `int arr[][] = new int[][3];`
- en: Given the following code, which of the following statements can be used to determine
    if `cat` can be found in the list?
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据以下代码，哪些语句可以用来确定列表中是否可以找到“cat”？
- en: '[PRE96]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: a. `list.contains("cat")`
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: a. `list.contains("cat")`
- en: b. `list.hasObject("cat")`
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: b. `list.hasObject("cat")`
- en: c. `list.indexOf("cat")`
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: c. `list.indexOf("cat")`
- en: d. `list.indexOf(1)`
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: d. `list.indexOf(1)`
