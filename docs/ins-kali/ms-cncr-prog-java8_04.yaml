- en: Chapter 3. Getting the Maximum from Executors
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。从执行者中获得最大效益
- en: 'In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we introduced the basic characteristics of executors as a way to
    improve the performance of concurrent applications that execute lots of concurrent
    tasks. In this chapter, we go a step further and explain advanced characteristics
    of executors that make them a powerful tool for your concurrent application. In
    this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba“第2章。管理大量线程-执行者”)中，*管理大量线程-执行者*，我们介绍了执行者的基本特性，作为改进执行大量并发任务的并发应用程序性能的一种方式。在本章中，我们将进一步解释执行者的高级特性，使它们成为您并发应用程序的强大工具。在本章中，我们将涵盖以下内容：
- en: Advanced characteristics of executors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行者的高级特性
- en: First example – an advanced server application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个例子-高级服务器应用程序
- en: Second example – executing periodic tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个例子-执行周期性任务
- en: Additional information about executors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关执行者的其他信息
- en: Advanced characteristics of executors
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行者的高级特性
- en: 'An executor is a class that allows the programmers to execute concurrent tasks
    without being worried about the creation and management of threads. Programmers
    create `Runnable` objects and send them to the executor that creates and manages
    the necessary threads to execute those tasks. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we introduced the basic characteristics of the executor framework:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 执行者是一个允许程序员执行并发任务而不必担心线程的创建和管理的类。程序员创建`Runnable`对象并将它们发送到执行者，执行者创建和管理必要的线程来执行这些任务。在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba“第2章。管理大量线程-执行者”)中，*管理大量线程-执行者*，我们介绍了执行者框架的基本特性：
- en: How to create an executor and the different options we have when we create one
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建执行者以及我们创建执行者时的不同选项
- en: How to send a concurrent task to an executor
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将并发任务发送到执行者
- en: How to control the resources used by the executor
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何控制执行者使用的资源
- en: How the executor, internally, uses a pool of threads to optimize the performance
    of the application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行者在内部如何使用线程池来优化应用程序的性能
- en: However, executors can give you many more options to make them a powerful mechanism
    in your concurrent application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，执行者可以为您提供更多选项，使其成为并发应用程序中的强大机制。
- en: Cancellation of tasks
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消任务
- en: You can cancel the execution of a task after you send it to an executor. When
    you send a `Runnable` object to an executor using the `submit()` method, it returns
    an implementation of the `Future` interface. This class allows you to control
    the execution of the task. It has the `cancel()` method, which attempts to cancel
    the execution of the task. It receives a boolean value as a parameter. If it takes
    the `true` value and the executor is executing this task, the thread executing
    the task will be interrupted.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在将任务发送到执行者后取消任务的执行。使用`submit()`方法将`Runnable`对象发送到执行者时，它返回`Future`接口的实现。这个类允许您控制任务的执行。它具有`cancel()`方法，尝试取消任务的执行。它接收一个布尔值作为参数。如果它采用`true`值并且执行者正在执行此任务，则将中断执行任务的线程。
- en: 'These are the situations when the task you want to cancel can''t be canceled:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您希望取消的任务无法取消的情况：
- en: The task has already been canceled
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务已经被取消
- en: The task has finished its execution
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务已经完成执行
- en: The task is running and you supplied `false` as a parameter to the `cancel()`
    method
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务正在运行，并且您向`cancel()`方法提供了`false`作为参数
- en: Other reasons not specified in the API documentation
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API文档中未指定的其他原因
- en: The `cancel()` method returns a boolean value to indicate whether the task has
    been canceled or not.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel()`方法返回一个布尔值，指示任务是否已取消。'
- en: Scheduling the execution of tasks
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安排任务的执行
- en: 'The `ThreadPoolExecutor` class is the basic implementation of the `Executor`
    and `ExecutorService` interfaces. But the Java concurrency API provides an extension
    of this class to allow the execution of scheduled tasks. It''s the `ScheduledThreadPoolExeuctor`
    class, and you can:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`类是`Executor`和`ExecutorService`接口的基本实现。但是，Java并发API提供了这个类的扩展，以允许执行计划任务。这是`ScheduledThreadPoolExeuctor`类，您可以：'
- en: Execute a task after a delay
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在延迟后执行任务
- en: Execute a task periodically; this includes the execution of tasks at a fixed
    rate or with a fixed delay
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定期执行任务；这包括以固定速率或固定延迟执行任务
- en: Overriding the executor methods
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写执行者方法
- en: 'The executor framework is a very flexible mechanism. You can implement your
    own executor extending one of the existing classes (`ThreadPoolExecutor` or `ScheduledThreadPoolExecutor`)
    to get the desired behavior. These classes include methods that make it easy to
    change how the executor works. If you override `ThreadPoolExecutor`, you can override
    the following methods:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 执行者框架是一个非常灵活的机制。您可以实现自己的执行者，扩展现有类（`ThreadPoolExecutor`或`ScheduledThreadPoolExecutor`）以获得所需的行为。这些类包括使更改执行者工作方式变得容易的方法。如果您重写`ThreadPoolExecutor`，可以重写以下方法：
- en: '`beforeExecute()`: This method is invoked before the execution of a concurrent
    task in an executor. It receives the `Runnable` object that is going to be executed
    and the `Thread` object that will execute them. The `Runnable` object that this
    method receives is an instance of the `FutureTask` class and not the `Runnable`
    object you sent to the executor using the `submit()` method.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`beforeExecute()`：此方法在执行者中的并发任务执行之前调用。它接收将要执行的`Runnable`对象和将执行它们的`Thread`对象。此方法接收的`Runnable`对象是`FutureTask`类的实例，而不是使用`submit()`方法将`Runnable`对象发送到执行者的`Runnable`对象。'
- en: '`afterExecute()`: This method is invoked after the execution of a concurrent
    task in the executor. It receives the `Runnable` object that has been executed
    and a `Throwable` object that stores a possible exception thrown inside the task.
    As in the `beforeExecute()` method, the `Runnable` object is an instance of the
    `FutureTask` class.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`afterExecute()`: 这个方法在执行器中的并发任务执行后被调用。它接收到已执行的`Runnable`对象和一个存储可能在任务内部抛出的异常的`Throwable`对象。与`beforeExecute()`方法一样，`Runnable`对象是`FutureTask`类的一个实例。'
- en: '`newTaskFor()`: This method creates the task that is going to execute the `Runnable`
    object you sent using the `submit()` method. It must return an implementation
    of the `RunnableFuture` interface. By default, Open JDK 8 and Oracle JDK 8 returns
    an instance of the `FutureTask` class, but this circumstance can change in future
    implementations.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newTaskFor()`: 这个方法创建将要执行`submit()`方法发送的`Runnable`对象的任务。它必须返回`RunnableFuture`接口的一个实现。默认情况下，Open
    JDK 8和Oracle JDK 8返回`FutureTask`类的一个实例，但这种情况在将来的实现中可能会改变。'
- en: If you extend the `ScheduledThreadPoolExecutor` class, you can override the
    `decorateTask()` method. This method is like the `newTaskFor()` for the scheduled
    tasks. It allows you to override the tasks executed by the executor.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您扩展了`ScheduledThreadPoolExecutor`类，可以重写`decorateTask()`方法。这个方法类似于用于计划任务的`newTaskFor()`方法。它允许您重写执行器执行的任务。
- en: Changing some initialization parameters
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改一些初始化参数
- en: 'You can also change the behavior of an executor by changing some parameters
    at its creation. The most useful ones are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过更改创建时的一些参数来更改执行器的行为。最有用的是：
- en: '`BlockingQueue<Runnable>`: Every executor uses an internal `BlockingQueue`
    to store the tasks that are waiting for its execution. You can pass any implementation
    of this interface as a parameter. For example, you can change the default order
    used by the executor to execute the tasks.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BlockingQueue<Runnable>`: 每个执行器都使用内部的`BlockingQueue`来存储等待执行的任务。您可以将此接口的任何实现作为参数传递。例如，您可以更改执行任务的默认顺序。'
- en: '`ThreadFactory`: You can specify an implementation of the `ThreadFactory` interface,
    and the executor will use that factory to create the threads that will execute
    the tasks. For example, you can use a `ThreadFactory` interface to create an extension
    of the `Thread` class that saves log information about the execution times of
    the tasks.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadFactory`: 您可以指定`ThreadFactory`接口的一个实现，执行器将使用该工厂来创建执行任务的线程。例如，您可以使用`ThreadFactory`接口来创建`Thread`类的扩展，该扩展保存有关任务执行时间的日志信息。'
- en: '`RejectedExecutionHandler`: After you call the `shutdown()` or the `shutdownNow()`
    method, all the tasks that are sent to the executor will be rejected. You can
    specify an implementation of the `RejectedExecutionHandler` interface to manage
    this situation.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RejectedExecutionHandler`: 在调用`shutdown()`或`shutdownNow()`方法之后，发送到执行器的所有任务都将被拒绝。您可以指定`RejectedExecutionHandler`接口的一个实现来管理这种情况。'
- en: The first example – an advanced server application
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一个示例 - 高级服务器应用程序
- en: In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, we presented an example of a client/server application. We implemented
    a server to search data over the World Development Indicators of the World Bank
    and a client that makes multiple calls to that server to test the performance
    of the executor.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba "第2章。管理大量线程
    - 执行器")中，*管理大量线程 - 执行器*，我们介绍了一个客户端/服务器应用程序的示例。我们实现了一个服务器来搜索世界银行的世界发展指标数据，并且一个客户端对该服务器进行多次调用以测试执行器的性能。
- en: 'In this section, we will extend that example to add to it the following characteristics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将扩展该示例以添加以下特性：
- en: You can cancel the execution of queries in the server, using a new cancellation
    query.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用新的取消查询取消服务器上的查询执行。
- en: You can control the order of execution of queries using a priority parameter.
    Tasks with higher priority will be executed first.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用优先级参数控制查询的执行顺序。具有更高优先级的任务将首先执行。
- en: The server will calculate the number of tasks and the total execution time used
    by the different users that use the server.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将计算使用服务器的不同用户使用的任务数量和总执行时间。
- en: 'To implement these new characteristics, we have made the following changes
    to the server:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这些新特性，我们对服务器进行了以下更改：
- en: 'We have added two parameters to every query. The first one is the name of the
    user that sends the query, and the other is the priority of the query. The new
    format of the queries are as follows:'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个查询添加了两个参数。第一个是发送查询的用户的名称，另一个是查询的优先级。查询的新格式如下：
- en: '**Query**: `q;username;priority;codCountry;codIndicator;year` where `username`
    is the name of the user, `priority` is the priority of the query, `codCountry`
    is the code of the country, `codIndicator` is the code of the indicator, and `year`
    is an optional parameter with the year you want to query.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**: `q;username;priority;codCountry;codIndicator;year`，其中`username`是用户的名称，`priority`是查询的优先级，`codCountry`是国家代码，`codIndicator`是指标代码，`year`是一个可选参数，用于查询的年份。'
- en: '**Report**: `r;username;priority;codIndicator` where `username` is the name
    of the user, `priority` is the priority of the query, and `codIndicator` is the
    code of the indicator you want to report.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告**: `r;username;priority;codIndicator`，其中`username`是用户的名称，`priority`是查询的优先级，`codIndicator`是您要报告的指标代码。'
- en: '**Status**: `s;username;priority` where `username` is the name of the user
    and `priority` is the priority of the query.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**: `s;username;priority`，其中`username`是用户的名称，`priority`是查询的优先级。'
- en: '**Stop**: `z;username;priority` where `username` is the name of the user, and
    `priority` is the priority of the query.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**: `z;username;priority`，其中`username`是用户的名称，`priority`是查询的优先级。'
- en: 'We have implemented a new query:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经实现了一个新的查询：
- en: '**Cancel**: `c;username;priority` where `username` is the name of the user,
    and `priority` is the priority of the query.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：`c;username;priority`，其中`username`是用户的名称，`priority`是查询的优先级。'
- en: 'We have implemented our own executor to:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们实现了自己的执行器来：
- en: Calculate the server use per user
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个用户的服务器使用情况
- en: Execute the tasks by priority
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按优先级执行任务
- en: Control the rejection of tasks
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制任务的拒绝
- en: We have adapted `ConcurrentServer` and `RequestTask` to take into account the
    new elements of the server
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经调整了`ConcurrentServer`和`RequestTask`以考虑服务器的新元素
- en: The rest of the elements of the server (the cache system, the log system, and
    the `DAO` class) are the same, so it won't be described again.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的其余元素（缓存系统、日志系统和`DAO`类）都是相同的，因此不会再次描述。
- en: The ServerExecutor class
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ServerExecutor类
- en: As we mentioned earlier, we have implemented our own executor to execute the
    tasks of the server. We also have implemented some additional but necessary classes
    to provide all the functionality. Let's describe these classes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们实现了自己的执行器来执行服务器的任务。我们还实现了一些额外但必要的类来提供所有功能。让我们描述这些类。
- en: The statistics object
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计对象
- en: 'Our server will calculate the number of tasks that every user executes on it
    and the total execution time of these tasks. To store this data, we have implemented
    the `ExecutorStatistics` class. It has two attributes to store the information:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务器将计算每个用户在其上执行的任务数量以及这些任务的总执行时间。为了存储这些数据，我们实现了`ExecutorStatistics`类。它有两个属性来存储信息：
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These attributes are `AtomicVariables` that support atomic operations on single
    variables. This allows you to use those variables in different threads without
    using any synchronization mechanisms. Then, it has two methods to increment the
    number of tasks and the execution time:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是`AtomicVariables`，支持对单个变量的原子操作。这允许您在不使用任何同步机制的情况下在不同的线程中使用这些变量。然后，它有两种方法来增加任务数量和执行时间：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we have added methods to get the value of both attributes, and we
    have overridden the `toString()` method to get the information in a readable way:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们添加了获取这两个属性值的方法，并重写了`toString()`方法以便以可读的方式获取信息：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The rejected task controller
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 被拒绝的任务控制器
- en: When you create an executor, you can specify a class to manage its rejected
    tasks. A task is rejected by the executor when you submit it after the `shutdown()`
    or `shutdownNow()` methods has been invoked in the executor.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个执行器时，可以指定一个类来管理其被拒绝的任务。当您在执行器中调用`shutdown()`或`shutdownNow()`方法后提交任务时，执行器会拒绝该任务。
- en: 'To control this circumstance, we have implemented the `RejectedTaskController`
    class. This class implements the `RejectedExecutionHandler` interface and implements
    the `rejectedExecution()` method:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制这种情况，我们实现了`RejectedTaskController`类。这个类实现了`RejectedExecutionHandler`接口，并实现了`rejectedExecution()`方法：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `rejectedExecution()` method is called once per task that is rejected and
    receives as parameters the task that has been rejected and the executor that has
    rejected the task.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`rejectedExecution()`方法每拒绝一个任务调用一次，并接收被拒绝的任务和拒绝任务的执行器作为参数。'
- en: The executor tasks
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行器任务
- en: When you submit a `Runnable` object to an executor, it doesn't execute that
    `Runnable` object directly. It creates a new object, an instance of the `FutureTask`
    class, and it's this task that is executed by the worker thread of the executor.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向执行器提交一个`Runnable`对象时，它不会直接执行该`Runnable`对象。它会创建一个新对象，即`FutureTask`类的实例，正是这个任务由执行器的工作线程执行。
- en: 'In our case, to measure the execution time of the tasks, we have implemented
    our own `FutureTask` implementation in the `ServerTask` class. It extends the
    `FutureTask` class and implements the `Comparable` interface as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，为了测量任务的执行时间，我们在`ServerTask`类中实现了我们自己的`FutureTask`实现。它扩展了`FutureTask`类，并实现了`Comparable`接口，如下所示：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Internally, it stores the query that is going to execute as a `ConcurrentCommand`
    object:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，它将要执行的查询存储为`ConcurrentCommand`对象：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the constructor, it uses the constructor of the `FutureTask` class and stores
    the `ConcurrentCommand` object:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，它使用`FutureTask`类的构造函数并存储`ConcurrentCommand`对象：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, it implements the `compareTo()` operation comparing the commands stored
    by the two `ServerTask` instances to compare. This can be seen in the following
    code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它实现了`compareTo()`操作，比较两个`ServerTask`实例存储的命令。这可以在以下代码中看到：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The executor
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行器
- en: 'Now that we have the auxiliary classes of the executor, we have to implement
    the executor itself. We have implemented the `ServerExecutor` class with this
    purpose. It extends the `ThreadPoolExecutor` class and has some internal attributes,
    as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了执行器的辅助类，我们必须实现执行器本身。我们实现了`ServerExecutor`类来实现这个目的。它扩展了`ThreadPoolExecutor`类，并具有一些内部属性，如下所示：
- en: '`startTimes`: This is a `ConcurrentHashMap` to store the start date of every
    task. The key of the class will be the `ServerTask` object (a `Runnable` object),
    and the value will be a `Date` object.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startTimes`：这是一个`ConcurrentHashMap`，用于存储每个任务的开始日期。类的键将是`ServerTask`对象（一个`Runnable`对象），值将是一个`Date`对象。'
- en: '`executionStatistics`: This is a `ConcurrentHashMap` to store the statistics
    of use per user. The key will be the username and the value will be a `ExecutorStatistics`
    object.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`executionStatistics`：这是一个`ConcurrentHashMap`，用于存储每个用户的使用统计。键将是用户名，值将是一个`ExecutorStatistics`对象。'
- en: '`CORE_POOL_SIZE`, `MAXIMUM_POOL_SIZE`, and `KEEP_ALIVE_TIME`: These are constants
    to define the characteristics of the executor.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CORE_POOL_SIZE`，`MAXIMUM_POOL_SIZE`和`KEEP_ALIVE_TIME`：这些是用于定义执行器特性的常量。'
- en: '`REJECTED_TASK_CONTROLLER`: This is a `RejectedTaskController` class attribute
    to control the tasks rejected by the executor.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`REJECTED_TASK_CONTROLLER`: 这是一个`RejectedTaskController`类的属性，用于控制执行器拒绝的任务。'
- en: 'This can be explained by the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下代码来解释：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The constructor of the class calls to the parent constructor creating a `PriorityBlockingQueue`
    class to store the tasks that will be executed in the executor. This class orders
    the elements according to the result of the execution of the `compareTo()` method
    (so the elements stored in it have to implement the `Comparable` interface). The
    utilization of this class will allow us to execute our tasks by priority.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的构造函数调用父类构造函数，创建一个`PriorityBlockingQueue`类来存储将在执行器中执行的任务。该类根据`compareTo()`方法的执行结果对元素进行排序（因此存储在其中的元素必须实现`Comparable`接口）。使用此类将允许我们按优先级执行任务。
- en: 'Then, we have overridden some methods of the `ThreadPoolExecutor` class. First
    is the `beforeExecute()` method. This method is executed before the execution
    of every task. It receives the `ServerTask` object as a parameter, and the thread
    that is going to execute the task. In our case, we store the actual date in the
    `ConcurrentHashMap` with the start dates of every task, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重写了`ThreadPoolExecutor`类的一些方法。首先是`beforeExecute()`方法。该方法在每个任务执行之前执行。它接收`ServerTask`对象作为参数，以及将要执行任务的线程。在我们的情况下，我们使用`ConcurrentHashMap`存储每个任务的开始日期：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next method is the `afterExecute()` method. This method is executed after
    the execution of every task in the executor and receives the `ServerTask` object
    that has been executed as parameter and a `Throwable` object. This last parameter
    will have value only when an exception is thrown during the execution of the task.
    In our case, we will use this method to:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法是`afterExecute()`方法。该方法在执行器中每个任务执行后执行，并接收已执行的`ServerTask`对象作为参数和一个`Throwable`对象。只有在任务执行过程中抛出异常时，最后一个参数才会有值。在我们的情况下，我们将使用此方法来：
- en: Calculate the execution time of the task.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算任务的执行时间。
- en: 'Update the statistics of the user in the following manner:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以以下方式更新用户的统计信息：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we have overridden the `newTaskFor()` method. This method will be
    executed to convert the `Runnable` object that we send to the executor, using
    the `submit()` method in the instance of `FutureTask` that will be executed by
    the executor. In our case, we replace the default `FutureTask` class with our
    `ServerTask` object:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们重写了`newTaskFor()`方法。该方法将被执行，将我们通过`submit()`方法发送到执行器的`Runnable`对象转换为由执行器执行的`FutureTask`实例。在我们的情况下，我们将默认的`FutureTask`类替换为我们的`ServerTask`对象：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have included an additional method in the executor to write all the statistics
    stored in the executor in the log system. This method will be called at the end
    of the execution of the server, as you will see later. We have the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在执行器中包含了一个额外的方法，用于将执行器中存储的所有统计信息写入日志系统。此方法将在服务器执行结束时调用，稍后您将看到。我们有以下代码：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The command classes
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令类
- en: 'The command classes execute the different queries you can send to the server.
    You can send five different queries to our server:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 命令类执行您可以发送到服务器的不同查询。您可以向我们的服务器发送五种不同的查询：
- en: '**Query**: This is to get information about a country, an indicator, and optionally
    a year. It''s implemented by the `ConcurrentQueryCommand` class.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询**：这是用于获取有关国家、指标和可选年份的信息的命令。由`ConcurrentQueryCommand`类实现。'
- en: '**Report**: This is to get information about an indicator. It''s implemented
    by the `ConcurrentReportCommand` class.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**报告**：这是用于获取有关指标的信息的命令。由`ConcurrentReportCommand`类实现。'
- en: '**Status**: This is to get information about the status of a server. It''s
    implemented by the `ConcurrentStatusCommand` class.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：这是用于获取服务器状态信息的命令。由`ConcurrentStatusCommand`类实现。'
- en: '**Cancel**: This is to cancel the execution of the tasks of a user. It''s implemented
    by the `ConcurrentCancelCommand` class.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消**：这是用于取消用户任务执行的命令。由`ConcurrentCancelCommand`类实现。'
- en: '**Stop**: This is to stop the execution of the server. It''s implemented by
    the `ConcurrentStopCommand` class.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止**：这是用于停止服务器执行的命令。由`ConcurrentStopCommand`类实现。'
- en: We also have the `ConcurrentErrorCommand` class to manage the situation when
    an unknown command arrives at the server, and `ConcurrentCommand` that is the
    base class of all the commands.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`ConcurrentErrorCommand`类，用于处理服务器接收到未知命令的情况，以及`ConcurrentCommand`类，它是所有命令的基类。
- en: The ConcurrentCommand class
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentCommand类
- en: 'This is the base class of every command. It includes the behavior common to
    all the commands that includes the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个命令的基类。它包括所有命令共有的行为，包括以下内容：
- en: Call the method that implements the specific logic of every command
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用实现每个命令特定逻辑的方法
- en: Write the results to the client
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果写入客户端
- en: Close all the resources used in the communication
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭通信中使用的所有资源
- en: 'The class extends the `Command` class and implements the `Comparable` and `Runnable`
    interfaces. In the example of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, the commands were simple classes, but in this example, the concurrent
    commands are `Runnable` objects that will be sent to the executor:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 该类扩展了`Command`类，并实现了`Comparable`和`Runnable`接口。在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程-执行器")的示例中，命令是简单的类，但在这个示例中，并发命令是将发送到执行器的`Runnable`对象：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'It has three attributes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它有三个属性：
- en: '`username`: This is to store the name of the user that sends the query.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`username`：这是用于存储发送查询的用户的名称。'
- en: '`priority`: This is to store the priority of the query. It will determine the
    order of execution of the query.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`priority`：这是用于存储查询的优先级。它将确定查询的执行顺序。'
- en: '`socket`: This is the socket used in the communication with the client.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socket`：这是与客户端通信中使用的套接字。'
- en: 'The constructor of the class initializes these attributes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的构造函数初始化了这些属性：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The main functionality of this class is in the abstract `execute()` method,
    which will be implemented by every concrete command to calculate and return the
    results of the query, and in the `run()` method. The `run()` method calls the
    `execute()` method, stores the result in the cache, writes the result in the socket,
    and closes all the resources used in the communication. We have the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的主要功能在抽象的`execute()`方法中，每个具体命令都将通过该方法来计算和返回查询的结果，并且在`run()`方法中。`run()`方法调用`execute()`方法，将结果存储在缓存中，将结果写入套接字，并关闭通信中使用的所有资源。我们有以下内容：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, the `compareTo()` method uses the priority attribute to determine
    the order of the tasks. This will be used by the `PriorityBlockingQueue` class
    to order the tasks, so the tasks with a higher priority will be executed first.
    Take into account that a task has higher priority when the `getPriority()` method
    returns a lower value. If the `getPriority()` of a task returns `1`, that task
    will have a higher priority than a task that `getPriority()` method returns `2`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`compareTo()`方法使用优先级属性来确定任务的顺序。这将被`PriorityBlockingQueue`类用来对任务进行排序，因此具有更高优先级的任务将首先执行。请注意，当`getPriority()`方法返回较低的值时，任务的优先级更高。如果任务的`getPriority()`返回`1`，那么该任务的优先级将高于`getPriority()`方法返回`2`的任务：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Concrete commands
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具体命令
- en: We have made minor changes in the classes that implement the different commands,
    and we added a new one implemented by the `ConcurrentCancelCommand` class. The
    main logic of these classes is included in the `execute()` method that calculates
    the response to the query and returns it as a string.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对实现不同命令的类进行了微小的更改，并添加了一个由`ConcurrentCancelCommand`类实现的新命令。这些类的主要逻辑包含在`execute()`方法中，该方法计算查询的响应并将其作为字符串返回。
- en: 'The `execute()` method of the new `ConcurrentCancelCommand` makes a call to
    the `cancelTasks()` method of the `ConcurrentServer` class. This method will stop
    the execution of all the pending tasks associated with the user passed as a parameter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`ConcurrentCancelCommand`的`execute()`方法调用`ConcurrentServer`类的`cancelTasks()`方法。此方法将停止与作为参数传递的用户相关的所有待处理任务的执行：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `execute()` method of `ConcurrentReportCommand` uses the `query()` method
    of the `WDIDAO` class to get the data requested by the user. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, you can find the implementation of this method. The implementation
    is almost the same. The only difference is command array indices as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentReportCommand`的`execute()`方法使用`WDIDAO`类的`query()`方法来获取用户请求的数据。在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程-执行者")中，*管理大量线程-执行者*，您可以找到此方法的实现。实现几乎相同。唯一的区别是命令数组索引如下：'
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `execute()` method of `ConcurrentQueryCommand` uses the `report()` method
    of the `WDIDAO` class to get the data. In [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, you also can find the implementation of this method. The implementation
    here is almost the same. The only difference is the command array index:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentQueryCommand`的`execute()`方法使用`WDIDAO`类的`report()`方法来获取数据。在[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程-执行者")中，*管理大量线程-执行者*，您还可以找到此方法的实现。这里的实现几乎相同。唯一的区别是命令数组索引：'
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`ConcurrentStatusCommand` has an additional parameter in its constructor: the
    `Executor` object, which will execute the commands. This command uses this object
    to obtain information about the executor and send it as a response to the user.
    The implementation is almost the same as in [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*. We have used the same methods to get the status of the `Executor`
    object.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentStatusCommand`在其构造函数中有一个额外的参数：`Executor`对象，它将执行命令。此命令使用此对象来获取有关执行程序的信息，并将其作为响应发送给用户。实现几乎与[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程-执行者")中的相同。我们使用相同的方法来获取`Executor`对象的状态。'
- en: The `ConcurrentStopCommand` and `ConcurrentErrorCommand` are also the same as
    in [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*, so we haven't included their source code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentStopCommand`和`ConcurrentErrorCommand`与[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程-执行者")中的相同，因此我们没有包含它们的源代码。'
- en: The server part
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务器部分
- en: 'The server part receives the queries from the clients of the server and creates
    the command classes that executes the queries and sends them to the executor.
    It is implemented by two classes:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器部分接收来自服务器客户端的查询，并创建执行查询的命令类，并将其发送到执行程序。由两个类实现：
- en: 'The `ConcurrentServer` class: It includes the `main()` method of the server
    and additional methods to cancel tasks and finish the execution of the system'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentServer`类：它包括服务器的`main()`方法和取消任务以及完成系统执行的其他方法。'
- en: 'The `RequestTask` class: This class creates the commands and sends them to
    the executor'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RequestTask`类：此类创建命令并将其发送到执行程序'
- en: The main difference with the example of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors* is the role of the `RequestTask` class. In the `SimpleServer` example,
    the `ConcurrentServer` class creates a `RequestTask` object per query and sends
    them to the executor. In this example, we will only have an instance of the `RequestTask`
    that will be executed as a thread. When the `ConcurrentServer` receives a connection,
    it stores the socket to communicate with the client in a concurrent list of pending
    connections. The `RequestTask` thread reads that socket, processes the data sent
    by the client, creates the corresponding command, and sends the command to the
    executor.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba "第2章。管理大量线程-执行器")的示例*管理大量线程-执行器*的主要区别是`RequestTask`类的作用。在`SimpleServer`示例中，`ConcurrentServer`类为每个查询创建一个`RequestTask`对象并将其发送到执行器。在这个例子中，我们只会有一个`RequestTask`的实例，它将作为一个线程执行。当`ConcurrentServer`接收到一个连接时，它将把用于与客户端通信的套接字存储在一个并发的待处理连接列表中。`RequestTask`线程读取该套接字，处理客户端发送的数据，创建相应的命令，并将命令发送到执行器。
- en: The main reason for this change is to leave in the tasks executed by the executor
    only the code of the queries and leave the preprocessed code outside the executor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变的主要原因是只在执行器中留下查询的代码，并将预处理的代码留在执行器之外。
- en: The ConcurrentServer class
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ConcurrentServer类
- en: 'The `ConcurrentServer` class needs some internal attributes to work properly:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentServer`类需要一些内部属性才能正常工作：'
- en: A `ParallelCache` instance to use the cache system.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ParallelCache`实例用于使用缓存系统。
- en: A `ServerSocket` instance to get the connections from the clients.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ServerSocket`实例用于接收来自客户端的连接。
- en: A `boolean` value to know when it has to stop its execution.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`boolean`值用于知道何时停止执行。
- en: A `LinkedBlockingQueue` to store the sockets of the clients that sends a message
    to the server. These sockets will be processed by the `RequestTask` class.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`LinkedBlockingQueue`用于存储发送消息给服务器的客户端的套接字。这些套接字将由`RequestTask`类处理。
- en: A `ConcurrentHashMap` to store the `Future` objects associated with every task
    executed in the executor. The key will be the username of the users that sends
    the queries, and the values will be another `Map` whose key will be the `ConcurrenCommand`
    objects, and the value will be the `Future` instance associated with that task.
    We use these `Future` instances to cancel the execution of tasks.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`ConcurrentHashMap`用于存储与执行器中的每个任务相关的`Future`对象。键将是发送查询的用户的用户名，值将是另一个`Map`，其键将是`ConcurrenCommand`对象，值将是与该任务相关联的`Future`实例。我们使用这些`Future`实例来取消任务的执行。
- en: A `RequestTask` instance to create the commands and sends them to the executor.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`RequestTask`实例用于创建命令并将其发送到执行器。
- en: A `Thread` object to execute the `RequestTask` object.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Thread`对象来执行`RequestTask`对象。
- en: 'The code for this is as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码如下：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `main()` method of this class initializes these objects and opens the `ServerSocket`
    instance to listen to the connections from the clients. In addition, it creates
    the `RequestTask` object and executes it as a thread. It will be in a loop until
    the `shutdown()` method changes the value of the stopped attribute. After this,
    it waits for the finalization of the `Executor` object, using the `endTermination()`
    method of the `RequestTask` object, and shuts down the `Logger` system and the
    `RequestTask` object with the `finishServer()` method:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的`main()`方法初始化这些对象，并打开`ServerSocket`实例以监听来自客户端的连接。此外，它创建`RequestTask`对象并将其作为线程执行。它将循环执行，直到`shutdown()`方法改变了stopped属性的值。之后，它等待`Executor`对象的完成，使用`RequestTask`对象的`endTermination()`方法，并使用`finishServer()`方法关闭`Logger`系统和`RequestTask`对象：
- en: '[PRE21]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It includes two methods to shut down the executor of the server. The `shutdown()`
    method changes the value of the `stopped` variable and closes the `serverSocket`
    instance. The `finishServer()` method stops the executor, interrupts the thread
    that executes the `RequestTask` object, and shuts downs the `Logger` system. We
    divided this process into two parts to use the `Logger` system until the last
    instruction of the server:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它包括两种方法来关闭服务器的执行器。`shutdown()`方法改变`stopped`变量的值，并关闭`serverSocket`实例。`finishServer()`方法停止执行器，中断执行`RequestTask`对象的线程，并关闭`Logger`系统。我们将这个过程分成两部分，以便在服务器的最后一条指令之前使用`Logger`系统：
- en: '[PRE22]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The server includes the method that cancels the tasks associated with a user.
    As we mentioned before, the `Server` class uses a nested `ConcurrentHashMap` to
    store all the tasks associated with a user. First, we obtain the `Map` with all
    the tasks of a user and then we process all the `Future` objects of those tasks
    calling to the `cancel()` method of the `Future` objects. We pass the value `true`
    as a parameter, so if the executor is running a task from that user, it will be
    interrupted. We have included the necessary code to avoid the cancellation of
    `ConcurrentCancelCommand`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器包括取消与用户关联的任务的方法。正如我们之前提到的，`Server`类使用嵌套的`ConcurrentHashMap`来存储与用户关联的所有任务。首先，我们获取一个用户的所有任务的`Map`，然后我们处理这些任务的所有`Future`对象，调用`Future`对象的`cancel()`方法。我们将值`true`作为参数传递，因此如果执行器正在运行该用户的任务，它将被中断。我们已经包括了必要的代码来避免`ConcurrentCancelCommand`的取消：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, we have included a method to eliminate the `Future` object associated
    with tasks from our nested map of `ServerTask` objects when that task finishes
    its execution normally. It''s the `finishTask()` method:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们已经包括了一个方法，当任务正常执行完毕时，从我们的`ServerTask`对象的嵌套映射中消除与任务相关的`Future`对象。这就是`finishTask()`方法：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The RequestTask class
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RequestTask类
- en: The `RequestTask` class is the intermediary between the `ConcurrentServer` class,
    which connects to the clients, and the `Executor` class, which executes the concurrent
    tasks. It opens the socket with the client, reads the query data, creates the
    adequate command, and sends it to the executor.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`RequestTask`类是`ConcurrentServer`类与客户端连接和`Executor`类执行并发任务之间的中介。它与客户端打开套接字，读取查询数据，创建适当的命令，并将其发送到执行器。'
- en: 'It uses some internal attributes:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一些内部属性：
- en: A `LinkedBlockingQueue` where the `ConcurrentServer` class stores the client
    sockets
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingQueue`，`ConcurrentServer`类在其中存储客户端套接字'
- en: A `ServerExecutor` to execute the commands as concurrent tasks
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ServerExecutor`用于执行命令作为并发任务。'
- en: A `ConcurrentHashMap` to store the `Future` objects associated with the tasks
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ConcurrentHashMap`存储与任务相关的`Future`对象
- en: 'The constructor of the class initializes all these objects:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的构造函数初始化了所有这些对象：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The main method of this class is the `run()` method. It executes a loop until
    the thread is interrupted processing the sockets stored in the `pendingConnections`
    object. In this object, the `ConcurrentServer` class stores the sockets to communicate
    with the different clients that sends a query to the server. It opens the socket,
    reads the data, and creates the corresponding command. This also sends the command
    to the executor and stores the `Future` object in the double `ConcurrentHashMap`
    associated with the `hashCode` of the task and with the user that sent the query:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的主要方法是`run()`方法。它执行一个循环，直到线程被中断，处理存储在`pendingConnections`对象中的套接字。在该对象中，`ConcurrentServer`类存储了与发送查询到服务器的不同客户端通信的套接字。它打开套接字，读取数据，并创建相应的命令。它还将命令发送到执行器，并将`Future`对象存储在与任务的`hashCode`和发送查询的用户相关联的双重`ConcurrentHashMap`中：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `storeController()` method is the one that stores the `Future` object in
    the double `ConcurrentHashMap`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`storeController()`方法是将`Future`对象存储在双重`ConcurrentHashMap`中的方法：'
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we have included two methods to manage the execution of the `Executor`
    class, one to call the `shutdown()` method for the executor and an other to wait
    for its finalization. Remember that you must explicitly call the `shutdown()`
    or `shutdownNow()` methods to end the execution of an executor. If not, the program
    won''t terminate. Look at the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们包含了两个方法来管理`Executor`类的执行，一个是调用`shutdown()`方法来关闭执行器，另一个是等待其完成。请记住，您必须显式调用`shutdown()`或`shutdownNow()`方法来结束执行器的执行。否则，程序将无法终止。请看下面的代码：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The client part
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端部分
- en: Now it's time to test our server. In this case, we won't worry much about the
    execution time. The main objective of our test is to check whether the new features
    work well.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是测试服务器的时候了。在这种情况下，我们不会太担心执行时间。我们测试的主要目标是检查新功能是否正常工作。
- en: 'We have split the client part into the following two classes:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将客户端部分分为以下两个类：
- en: '**The ConcurrentClient class**: This implements an individual client of the
    server. Each instance of this class has a different username. It makes 100 queries,
    90 of type query, and 10 of type report. The query queries have a priority of
    5, and the report queries have lower priority (10).'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcurrentClient类**：这实现了服务器的单个客户端。该类的每个实例都有不同的用户名。它进行了100次查询，其中90次是查询类型，10次是报告类型。查询查询的优先级为5，报告查询的优先级较低（10）。'
- en: '**The MultipleConcurrentClient class**: This measures the behavior of the multiple
    concurrent clients in parallel. We have tested the server with one to five concurrent
    clients. This class also tests the cancellation and the stop commands.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MultipleConcurrentClient类**：这测试了多个并发客户端的行为。我们已经测试了具有一到五个并发客户端的服务器。该类还测试了取消和停止命令。'
- en: We have included an executor to execute the concurrent requests to the server
    to increase the level of concurrency of the client.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了一个执行器来执行对服务器的并发请求，以增加客户端的并发级别。
- en: 'In the following image, you can see the results of the cancellation of tasks:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，您可以看到任务取消的结果：
- en: '![The client part](img/00008.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![客户端部分](img/00008.jpeg)'
- en: In this case, four tasks of the **USER_2** user have been canceled.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，**USER_2**用户的四个任务已被取消。
- en: 'The following image shows the final statistics about the number of tasks and
    the execution time of every user:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了关于每个用户的任务数量和执行时间的最终统计数据：
- en: '![The client part](img/00009.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![客户端部分](img/00009.jpeg)'
- en: The second example – executing periodic tasks
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二个示例 - 执行周期性任务
- en: In the previous examples with executors, the tasks were executed once, and they
    were executed as soon as possible. The executor framework includes other executor
    implementation that gives us more flexibility about the execution time of the
    tasks. It's the `ScheduledThreadPoolExecutor` class that allows us to execute
    tasks *periodically* and to execute tasks *after a delay*.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的执行器示例中，任务只执行一次，并且尽快执行。执行器框架包括其他执行器实现，使我们对任务的执行时间更加灵活。`ScheduledThreadPoolExecutor`类允许我们*周期性*执行任务，并在*延迟*后执行任务。
- en: 'In this section, you will learn how to execute periodic tasks implementing
    a **RSS feed** reader. This is a simple case where you need to make the same task
    (reading the news of a RSS feed) at regular intervals. Our example will have the
    following characteristics:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何执行周期性任务，实现**RSS订阅**阅读器。这是一个简单的情况，您需要定期执行相同的任务（阅读RSS订阅的新闻）。我们的示例将具有以下特点：
- en: Store the RSS sources in a file. We have chosen news about the world from some
    important newspapers, such as The New York Times, the Daily News, or The Guardian.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将RSS源存储在文件中。我们选择了一些重要报纸的世界新闻，如纽约时报、每日新闻或卫报。
- en: We sent a `Runnable` object to the executor per RSS source. Every time the executor
    runs the object, it parses the RSS source and converts it to a list of `CommonInformationItem`
    objects with the content of the RSS.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们为每个RSS源向执行器发送一个`Runnable`对象。每次执行器运行该对象时，它会解析RSS源并将其转换为包含RSS内容的`CommonInformationItem`对象列表。
- en: We use the **Producer/Consumer design pattern** to write the RSS news to disk.
    The producers will be the tasks of the executor that write every `CommonInformationItem`
    into a buffer. Only the new items will be stored in the buffer. The consumer will
    be an independent thread that reads the news from the buffer and writes them to
    a disk.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用**生产者/消费者设计模式**将RSS新闻写入磁盘。生产者将是执行器的任务，它们将每个`CommonInformationItem`写入缓冲区。只有新项目将存储在缓冲区中。消费者将是一个独立的线程，它从缓冲区中读取新闻并将其写入磁盘。
- en: The time between the finalization of the execution of a task and its next execution
    will be one minute.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务执行结束和下一次执行之间的时间将是一分钟。
- en: We also have implemented the advanced version of the example where the time
    between two executions of a task can vary.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了示例的高级版本，其中任务执行之间的时间可以变化。
- en: The common parts
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共同部分
- en: 'As we mentioned earlier, we read an RSS feed and convert them to a list of
    objects. To parse the RSS file, we treat them as an XML file, and we have implemented
    a **SAX** (short for **Simple API for XML**)parser in the `RSSDataCapturer` class.
    It parses the file and creates a list of `CommonInformationItem`. This class stores
    the following information for every RSS item:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们读取一个RSS源并将其转换为对象列表。为了解析RSS文件，我们将其视为XML文件，并在`RSSDataCapturer`类中实现了一个**SAX**（简单XML
    API）解析器。它解析文件并创建一个`CommonInformationItem`列表。这个类为每个RSS项存储以下信息：
- en: '**Title**: Title of the RSS item.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**：RSS项的标题。'
- en: '**Date**: Date of the RSS item.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期**：RSS项的日期。'
- en: '**Link**: Link to the RSS item.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接**：RSS项的链接。'
- en: '**Description**: The text of the RSS item.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：RSS项的文本。'
- en: '**ID**: The ID of the RSS item. If the item doesn''t include an ID, we calculate
    it.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ID**：RSS项的ID。如果该项不包含ID，我们将计算它。'
- en: '**Source**: The name of the RSS source.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源**：RSS来源的名称。'
- en: We store the news into a disk using the Producer/Consumer design pattern, so
    we need a buffer to store the news and a `Consumer` class that, in this case,
    reads the news from the buffer and stores them into the disk.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用生产者/消费者设计模式将新闻存储到磁盘中，因此我们需要一个缓冲区来存储新闻和一个`Consumer`类，该类从缓冲区中读取新闻并将其存储到磁盘中。
- en: 'We implemented the buffer in the `NewsBuffer` class. It has two internal attributes:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`NewsBuffer`类中实现了缓冲区。它有两个内部属性：
- en: '**A LinkedBlockingQueue**: This is a concurrent data structure with blocking
    operations. If we want to obtain an item from the list and it''s empty, the thread
    of the calling method will be blocked until there are elements in the list. We
    will use this structure to store `CommonInformationItems`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LinkedBlockingQueue**：这是一个带有阻塞操作的并发数据结构。如果我们想从列表中获取一个项目，而它是空的，调用方法的线程将被阻塞，直到列表中有元素为止。我们将使用这个结构来存储`CommonInformationItems`。'
- en: '**A ConcurrentHashMap**: This is a concurrent implementation of a `HashMap`.
    We will use it to store the IDs of the news items stored in the buffer before.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConcurrentHashMap**：这是`HashMap`的并发实现。我们将使用它来在缓冲区中存储之前存储的新闻项的ID。'
- en: 'We will only insert in the buffer the news that wasn''t inserted earlier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只会将以前未插入的新闻插入到缓冲区中：
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We have two methods in the `NewsBuffer` class: one to store an item in the
    buffer that checks whether the item has been inserted before, and the other to
    obtain the next item from the buffer. We use the `compute()` method to insert
    elements in the `ConcurrentHashMap`. This method receives a lambda expression
    as a parameter with the key and the actual value associated with this key (null
    if the key has no associated value). In our case, we add the item to the buffer
    it has not been processed before. We use the `add()` and `take()` methods to to
    insert, obtain, and delete elements from the queue:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewsBuffer`类中有两个方法：一个用于将项目存储在缓冲区中，并检查该项目是否已经插入，另一个用于从缓冲区中获取下一个项目。我们使用`compute()`方法将元素插入`ConcurrentHashMap`中。这个方法接收一个lambda表达式作为参数，其中包含与该键关联的实际值（如果键没有关联的值，则为null）。在我们的情况下，如果该项以前没有被处理过，我们将把该项添加到缓冲区中。我们使用`add()`和`take()`方法来向队列中插入、获取和删除元素：
- en: '[PRE30]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The items of the buffer will be written to disk by the `NewsWriter` class that
    will be executed as an independent thread. It only has an internal attribute that
    points to the `NewsBuffer` class used in the application:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区的项目将由`NewsWriter`类写入磁盘，该类将作为一个独立的线程执行。它只有一个内部属性，指向应用程序中使用的`NewsBuffer`类：
- en: '[PRE31]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `run()` method of this `Runnable` object takes `CommonInformationItem`
    instances from the buffer and saves them to a disk. As we use the blocking method
    `take`, if the buffer is empty, this thread will be blocked until there are elements
    in the buffer:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Runnable`对象的`run()`方法从缓冲区中获取`CommonInformationItem`实例并将它们保存到磁盘中。由于我们使用了阻塞方法`take`，如果缓冲区为空，这个线程将被阻塞，直到缓冲区中有元素为止。
- en: '[PRE32]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The basic reader
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本读取器
- en: 'The basic reader will use a standard `ScheduledThreadPoolExecutor` class to
    execute the tasks periodically. We will execute a task per RSS source, and there
    will be one minute between the termination of one execution of a task and the
    commencement of the next execution. These concurrent tasks are implemented in
    the `NewsTask` class. It has three internal attributes to store the name of the
    RSS feed, its URL, and the `NewsBuffer` class to store the news:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 基本读取器将使用标准的`ScheduledThreadPoolExecutor`类来定期执行任务。我们将为每个RSS源执行一个任务，并且在一个任务执行的终止和下一个任务执行的开始之间将有一分钟的时间。这些并发任务在`NewsTask`类中实现。它有三个内部属性来存储RSS源的名称、其URL和存储新闻的`NewsBuffer`类：
- en: '[PRE33]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `run()` method of this `Runnable` object simply parses the RSS feed, gets
    a list of CommonItemInterface instances, and stores them in the buffer. This method
    will be executed in a periodic way. In every execution, the `run()` method will
    be executed from the beginning to the end:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Runnable`对象的`run()`方法简单地解析RSS源，获取`CommonItemInterface`实例的列表，并将它们存储在缓冲区中。这个方法将定期执行。在每次执行中，`run()`方法将从头到尾执行：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In this example, we also have implemented another thread to implement the initialization
    of the executor and the tasks and the wait for the finalization of the execution.
    We have named this class `NewsSystem`. It has three internal attributes to store
    the path to the file with the RSS sources, the buffer to store the news, and a
    `CountDownLatch` object to control the end of its execution. The `CountDownLatch`
    class is a synchronization mechanism that allows you to make a thread wait for
    an event. We will detail the utilization of this class in [Chapter 9](part0056_split_000.html#1LCVG2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 9. Diving into Concurrent Data Structures and Synchronization Utilities"),
    *Diving into Concurrent Data Structures and Synchronization Utilities*. We have
    the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还实现了另一个线程来实现执行器和任务的初始化以及等待执行的结束。我们将这个类命名为`NewsSystem`。它有三个内部属性，用于存储带有RSS源的文件路径，用于存储新闻的缓冲区，以及用于控制其执行结束的`CountDownLatch`对象。`CountDownLatch`类是一种同步机制，允许您使一个线程等待一个事件。我们将在[第9章](part0056_split_000.html#1LCVG2-2fff3d3b99304faa8fa9b27f1b5053ba
    "第9章。深入并发数据结构和同步工具")中详细介绍这个类的使用，*深入并发数据结构和同步工具*。我们有以下代码：
- en: '[PRE35]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the `run()` method, we read all the RSS sources, create a `NewsTask` class
    for each one, and send them to our `ScheduledThreadPool` executor. We have created
    the executor using the `newScheduledThreadPool()` method of the `Executors` class,
    and we send the tasks to it using the `scheduleAtFixedDelay()` method. We also
    start the `NewsWriter` instance as a thread. The `run()` method waits for someone
    that tells it to finish its execution using the `await()` method of the `CountDownLatch`
    class and ends the execution of the `NewsWriter` task and of the `ScheduledExecutor`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在`run()`方法中，我们读取所有的RSS源，为每一个创建一个`NewsTask`类，并将它们发送到我们的`ScheduledThreadPool`执行器。我们使用`Executors`类的`newScheduledThreadPool()`方法创建了执行器，并使用`scheduleAtFixedDelay()`方法将任务发送到执行器。我们还启动了`NewsWriter`实例作为一个线程。`run()`方法等待有人告诉它结束执行，使用`CountDownLatch`类的`await()`方法，并结束`NewsWriter`任务和`ScheduledExecutor`的执行。
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We also have implemented the `shutdown()` method. This method will notify the
    `NewsSystem` class to end its execution using the `countDown()` method of the
    `CountDownLatch` class. This method will wake up the `run()` method, so it will
    shut down the executor that is running the `NewsTask` objects:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`shutdown()`方法。这个方法将使用`CountDownLatch`类的`countDown()`方法通知`NewsSystem`类结束执行。这个方法将唤醒`run()`方法，因此它将关闭运行`NewsTask`对象的执行器：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last class of this example is the `Main` class that implements the `main()`
    method of the example. It starts a `NewsSystem` instance as a thread, waits 10
    minutes, and notifies the thread of its finalization, and consequently finishes
    the execution of the entire system, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的最后一个类是实现了例子的`main()`方法的`Main`类。它启动了一个`NewsSystem`实例作为一个线程，等待10分钟，然后通知线程完成，从而结束整个系统的执行，如下所示：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When you execute this example, you see how the different tasks are executed
    in a periodic way and how the news items are written to a disk, as shown in the
    following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行这个例子时，您会看到不同的任务是如何周期性地执行的，以及新闻项目是如何写入磁盘的，如下面的截图所示：
- en: '![The basic reader](img/00010.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![基本阅读器](img/00010.jpeg)'
- en: The advanced reader
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级读者
- en: The basic news reader is an example of utilization of a `ScheduledThreadPoolExecutor`
    class, but we can go a step further. As occurs with `ThreadPoolExecutor`, we can
    implement our own `ScheduledThreadPoolExecutor` to obtain a particular behavior.
    In our case, we want that the delay time of our periodic task changes depending
    on the moment of the day. In this part, you will learn how to implement this behavior.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 基本新闻阅读器是`ScheduledThreadPoolExecutor`类的一个使用示例，但我们可以更进一步。与`ThreadPoolExecutor`一样，我们可以实现自己的`ScheduledThreadPoolExecutor`以获得特定的行为。在我们的例子中，我们希望周期性任务的延迟时间根据一天中的时间而变化。在这一部分，您将学习如何实现这种行为。
- en: 'The first step is to implement a class that tells us the delay between two
    executions of a periodic task. We named this the `Timer` class. It only has a
    static method named `getPeriod()`, which returns the number of milliseconds between
    the end of one execution and the start of the next one. This is our implementation,
    but you can make your own:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是实现一个告诉我们周期性任务两次执行之间延迟的类。我们将这个类命名为`Timer`类。它只有一个名为`getPeriod()`的静态方法，它返回一个执行结束和下一个开始之间的毫秒数。这是我们的实现，但您也可以自己制作：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we have to implement the internal tasks of our executor. When you send
    a `Runnable` object to an executor, externally, you see that object as the concurrent
    task but the executor converts this object into another task, an instance of the
    `FutureTask` class, that includes the `run()` method to execute the task and the
    methods of the `Future` interface to manage the execution of the task. To implement
    this example, we have to implement a class that extends the `FutureTask` class,
    and, as we will execute these tasks in a **scheduled executor**, it has to implement
    the `RunnableScheduledFuture` interface. This interface provides the `getDelay()`
    method that returns the time remaining to the next execution of a task. We have
    implemented these internal tasks in the `ExecutorTask` class. It has four internal
    attributes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须实现执行器的内部任务。当您将一个`Runnable`对象发送到执行器时，从外部来看，您会将这个对象视为并发任务，但执行器会将这个对象转换为另一个任务，即`FutureTask`类的一个实例，其中包括`run()`方法来执行任务以及`Future`接口的方法来管理任务的执行。为了实现这个例子，我们必须实现一个扩展`FutureTask`类的类，并且，由于我们将在**计划执行器**中执行这些任务，它必须实现`RunnableScheduledFuture`接口。这个接口提供了`getDelay()`方法，返回到下一个任务执行的剩余时间。我们在`ExecutorTask`类中实现了这些内部任务。它有四个内部属性：
- en: The original `RunnableScheduledFuture` internal task created by the `ScheduledThreadPoolExecutor`
    class
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`类创建的原始`RunnableScheduledFuture`内部任务'
- en: The scheduled executor that will execute the task
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行任务的计划执行器
- en: The start date of the next execution of the task
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的下一次执行的开始日期
- en: The name of the RSS feed
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSS订阅的名称
- en: 'The code for this is as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE40]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We have overridden or implemented different methods in this class. The first
    one, the `getDelay()` method that, as we told you before, returns the time remaining
    to the next execution of a task in the given unit time:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们重写或实现了不同的方法。首先是`getDelay()`方法，正如我们之前告诉过你的，它返回给定单位时间内任务下一次执行的剩余时间：
- en: '[PRE41]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The next one, the `compareTo()` method, compares two tasks, taking into account
    the start date of the next execution of the tasks:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的是`compareTo()`方法，它比较两个任务，考虑到任务的下一次执行的开始日期：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, the `isPeriodic()` method returns `true` if the task is periodic or `false`
    if not:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`isPeriodic()`方法返回`true`如果任务是周期性的，如果不是则返回`false`：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Finally, we have the `run()` method that implements the most important part
    of this example. First, we call the `runAndReset()` method of the `FutureTask`
    class. This method executes the task and resets its status, so it can be executed
    again. Then, we calculate the start date of the next execution using the `Timer`
    class, and finally, we have to insert the task again in the queue of the `ScheduledThreadPoolExecutor`
    class. If we don''t do this final step, the task won''t be executed again as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`run()`方法，它实现了这个示例的最重要部分。首先，我们调用`FutureTask`类的`runAndReset()`方法。这个方法执行任务并重置它的状态，这样它就可以再次执行。然后，我们使用`Timer`类计算下一次执行的开始日期，最后，我们必须再次将任务插入`ScheduledThreadPoolExecutor`类的队列中。如果不执行这最后一步，任务将不会再次执行，如下所示：
- en: '[PRE44]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Once we have the tasks for the executor, we have to implement the executor.
    We have implemented the `NewsExecutor` class that extends the `ScheduledThreadPoolExecutor`
    class. We have overridden the `decorateTask()` method. With this method, you can
    replace the internal task used by the scheduled executor. By default, it returns
    a default implementation of the `RunnableScheduledFuture` interface, but in our
    case, it will return an instance of the `ExecutorClass` instance:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了执行器的任务，我们就必须实现执行器。我们实现了`NewsExecutor`类，它扩展了`ScheduledThreadPoolExecutor`类。我们重写了`decorateTask()`方法。通过这个方法，你可以替换调度执行器使用的内部任务。默认情况下，它返回`RunnableScheduledFuture`接口的默认实现，但在我们的情况下，它将返回`ExecutorClass`实例的一个实例：
- en: '[PRE45]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We have to implement other versions of the `NewsSystem` and the `Main` classes
    to use the `NewsExecutor`. We have implemented `NewsAdvancedSystem` and `AdvancedMain`
    for this purpose.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现`NewsSystem`和`Main`类的其他版本来使用`NewsExecutor`。我们为此目的实现了`NewsAdvancedSystem`和`AdvancedMain`。
- en: Now you can run the advanced news system to see how the delay time between executions
    changes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行高级新闻系统，看看执行之间的延迟时间如何改变。
- en: Additional information about executors
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有关执行器的附加信息
- en: 'In this chapter, we have extended `ThreadPoolExecutor` and the `ScheduledThreadPoolExecutor`
    class and overridden some of their methods. But you can override more methods
    if you want a more particular behavior. These are some methods you can override:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们扩展了`ThreadPoolExecutor`和`ScheduledThreadPoolExecutor`类，并重写了它们的一些方法。但是，如果需要更特定的行为，你可以重写更多的方法。以下是一些你可以重写的方法：
- en: '`shutdown()`: You must explicitly call this method to end the execution of
    the executor. You can override it to add some code to free additional resources
    used by your own executor.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdown()`: 你必须显式调用这个方法来结束执行器的执行。你可以重写它来添加一些代码，以释放你自己的执行器使用的额外资源。'
- en: '`shutdownNow()`: The difference between `shutdown()` and `shutdownNow()` is
    that the `shutdown()` method waits for the finalization of all the tasks that
    are waiting in the executor.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shutdownNow()`: `shutdown()`方法和`shutdownNow()`方法的区别在于，`shutdown()`方法等待所有等待在执行器中的任务的最终处理。'
- en: '`submit()`, `invokeall()`, or `invokeany()`: you call these methods to send
    concurrent tasks to the executor. You can override them if you need to do some
    actions before or after a task is inserted in the task queue of the executor.
    Note that adding a custom action before or after the task is enqueued is different
    than adding a custom action before or after it''s executed, which we did while
    overriding `beforeExecute()` and `afterExecute()` methods.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`submit()`, `invokeall()`, 或 `invokeany()`: 你可以调用这些方法将并发任务发送到执行器中。如果需要在任务插入执行器的任务队列之前或之后执行一些操作，可以重写它们。请注意，在任务入队之前或之后添加自定义操作与在任务执行之前或之后添加自定义操作是不同的，我们在重写`beforeExecute()`和`afterExecute()`方法时已经做过。'
- en: 'In the news reader example, we use the `scheduleWithFixedDelay()` method to
    send tasks to the executor. But the `ScheduledThreadPoolExecutor` class has other
    methods to execute periodic tasks or tasks after a delay:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在新闻阅读器示例中，我们使用`scheduleWithFixedDelay()`方法将任务发送到执行器。但是`ScheduledThreadPoolExecutor`类还有其他方法来执行周期性任务或延迟任务：
- en: '`schedule()`: This method executes a task after the given delay. The task is
    executed only once.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`schedule()`: 这个方法在给定的延迟之后执行一次任务。'
- en: '`scheduleAtFixedRate()`: This method executes a periodic task with the given
    period. The difference with the s`cheduleWithFixedDelay()` method is that in the
    last one, the delay between two executions goes from the end of the first one
    to the start of the second one and in the first one the delay between two executions
    goes between the start of both.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scheduleAtFixedRate()`: 这个方法以给定的周期执行周期性任务。与`scheduleWithFixedDelay()`方法的区别在于，在后者中，两次执行之间的延迟从第一次执行结束到第二次执行开始，而在前者中，两次执行之间的延迟在两次执行的开始之间。'
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we presented two examples that explored advanced characteristics
    of executors. In the first example, we continued with the client/server example
    of [Chapter 2](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 2. Managing Lots of Threads – Executors"), *Managing Lots of Threads
    – Executors*. We implemented our own executor extending the `ThreadPoolExecutor`
    class to execute the tasks by priority and to measure the executing time of the
    tasks per user. We also included a new command to allow the cancellation of tasks.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了两个示例，探讨了执行器的高级特性。在第一个示例中，我们延续了[第2章](part0022_split_000.html#KVCC1-2fff3d3b99304faa8fa9b27f1b5053ba
    "第2章。管理大量线程 - 执行器")中的客户端/服务器示例，*管理大量线程 - 执行器*。我们实现了自己的执行器，扩展了`ThreadPoolExecutor`类，以按优先级执行任务，并测量每个用户任务的执行时间。我们还包括了一个新的命令，允许取消任务。
- en: In the second example, we explained how to use the `ScheduledThreadPoolExecutor`
    class to execute periodic tasks. We implemented two versions of a news reader.
    The first one showed how to use the basic functionality of the `ScheduledExecutorService,`
    and the second one showed how to override the behavior of the `ScheduledExecutorService`
    class to, for example, change the delay time between the two executions of a task.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们解释了如何使用`ScheduledThreadPoolExecutor`类来执行周期性任务。我们实现了两个版本的新闻阅读器。第一个版本展示了如何使用`ScheduledExecutorService`的基本功能，第二个版本展示了如何覆盖`ScheduledExecutorService`类的行为，例如，更改任务两次执行之间的延迟时间。
- en: In the next chapter, you will learn how to execute `Executor` tasks that return
    a result. If you extend the `Thread` class or implement the `Runnable` interface,
    the `run()` method doesn't return any result, but the executor framework includes
    the `Callable` interface that allows you to implement tasks that return a result.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何执行返回结果的`Executor`任务。如果您扩展`Thread`类或实现`Runnable`接口，`run()`方法不会返回任何结果，但执行器框架包括`Callable`接口，允许您实现返回结果的任务。
