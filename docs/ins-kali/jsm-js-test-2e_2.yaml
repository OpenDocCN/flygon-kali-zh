- en: Chapter 2. Your First Spec
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。你的第一个规范
- en: This chapter is about the basics, and we are going to guide you through how
    to write your first spec, think in test-first terms for development, and also
    show you all the available global Jasmine functions. By the end of the chapter,
    you should know how Jasmine works and be ready to start doing your first tests
    by yourself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了基础知识，我们将指导您如何编写您的第一个规范，以测试优先的术语进行开发，并向您展示所有可用的全局Jasmine函数。在本章结束时，您应该知道Jasmine的工作原理，并准备好自己进行第一次测试。
- en: The Investment Tracker application
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投资跟踪应用程序
- en: 'To get you started, we need an example scenario: consider that you are developing
    an application to track investments in the stock market.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让您开始，我们需要一个示例场景：考虑您正在开发一个用于跟踪股票市场投资的应用程序。
- en: 'The following screenshot of the form illustrates how a user might create a
    new investment on this application:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下的表单截图说明了用户可能如何在这个应用程序上创建一个新的投资：
- en: '![The Investment Tracker application](graphics/B04138_02_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![投资跟踪应用程序](graphics/B04138_02_01.jpg)'
- en: This is a form to add investments
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个添加投资的表单
- en: 'This form will allow the input of three values that define an investment:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表单将允许输入定义投资的三个值：
- en: First, we will input **Symbol**, which represents which company (stock) the
    user is investing in
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将输入**符号**，表示用户正在投资的公司（股票）
- en: Then, we will input how many **Shares** the user has bought (or invested in)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们将输入用户购买（或投资）了多少**股票**
- en: Finally, we will input how much the user has paid for each share (**Share price**)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将输入用户为每股支付的金额（**股价**）
- en: 'If you are unfamiliar with how the stock market works, imagine you are shopping
    for groceries. To make a purchase, you must specify what you are buying, how many
    items you are buying, and how much you are going to pay. These concepts translate
    to an investment as:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉股票市场的运作方式，请想象您在购物杂货。要购买商品，您必须指定您要购买什么，您要购买多少件商品，以及您将支付多少。这些概念可以转化为投资：
- en: A stock, which is defined by a symbol, such as `PETO`, can be understood to
    be a grocery type
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票由符号定义，例如`PETO`，可以理解为一种杂货类型
- en: The number of shares is the quantity of items you have purchased
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票数量是您购买的商品数量
- en: The share price is the unit price of each item
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股价是每件商品的单价
- en: 'Once the user has added an investment, it must be listed along with their other
    investments, as shown in the following screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户添加了一项投资，它必须与他们的其他投资一起列出，如下面的截图所示：
- en: '![The Investment Tracker application](graphics/B04138_02_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![投资跟踪应用程序](graphics/B04138_02_02.jpg)'
- en: This is a form and list of investments
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表单和投资列表
- en: The idea is to display how well their investments are going. Since the prices
    of the stocks fluctuate over time, the difference between the price the user has
    paid and the current price indicates whether it is a good (profit) or a bad (loss)
    investment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是展示他们的投资进展如何。由于股票价格随时间波动，用户支付的价格与当前价格之间的差异表明这是一个好（盈利）还是一个坏（亏损）的投资。
- en: 'In the preceding screenshot, we can see that the user has two investments:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到用户有两项投资：
- en: One is in the `AOUE` stock, which is scoring a profit of `101.80%`
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一项是`AOUE`股票，获利`101.80%`
- en: Another is in the `PETO` stock, which is scoring a loss of `-42.34%`
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一项是`PETO`股票，亏损`-42.34%`
- en: This is a very simple application, and we will get a deeper understanding of
    its functionality as we go on with its development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的应用程序，随着我们对其开发的进行，我们将更深入地了解其功能。
- en: Jasmine basics and thinking in BDD
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jasmine基础知识和BDD思维
- en: 'Based on the application presented previously, we can start writing acceptance
    criteria that define investment:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前介绍的应用程序，我们可以开始编写定义投资的验收标准：
- en: Given an investment, it should be of a stock
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，它应该是一种股票
- en: Given an investment, it should have the invested shares' quantity
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，它应该有投资的股票数量
- en: Given an investment, it should have the share price paid
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，它应该有支付的股价
- en: Given an investment, it should have a cost
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，它应该有成本
- en: 'Using the standalone distribution downloaded in the previous chapter, the first
    thing we need to do is create a new spec file. This file can be created anywhere,
    but it is a good idea to stick to a convention, and Jasmine already has a good
    one: specs should be in the `/spec` folder. Create an `InvestmentSpec.js` file
    and add the following lines:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章下载的独立分发版，我们需要做的第一件事是创建一个新的规范文件。这个文件可以在任何地方创建，但遵循一个约定是个好主意，而Jasmine已经有一个很好的约定：规范应该在`/spec`文件夹中。创建一个`InvestmentSpec.js`文件，并添加以下行：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `describe` function is a global Jasmine function used to define test contexts.
    When used as the first call in a spec, it creates a new test suite (a collection
    of test cases). It accepts two parameters, which are as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`函数是一个全局的Jasmine函数，用于定义测试上下文。当作为规范中的第一个调用时，它会创建一个新的测试套件（一组测试用例）。它接受两个参数，如下所示：'
- en: The name of the test suite—in this case, `Investment`
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试套件的名称——在本例中为“投资”
- en: A `function` that will contain all its specs
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含所有规范的`function`
- en: 'Then, to translate the first acceptance criterion (given an investment, it
    should be of a stock) into a Jasmine spec (or test case), we are going to use
    another global Jasmine function called `it`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要将第一个验收标准（给定一个投资，它应该是一种股票）翻译成Jasmine规范（或测试用例），我们将使用另一个全局的Jasmine函数，称为`it`：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It also accepts two parameters, which are as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它还接受两个参数，如下所示：
- en: The title of the spec—in this case, `should be of a stock`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规范的标题——在本例中为`应该是股票`
- en: A function that will contain the spec code
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含规范代码的`function`
- en: 'To run this spec, add it to the runner, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此规范，请将其添加到运行器中，如下所示：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute the spec by opening the runner on the browser. The following output
    can be seen:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在浏览器上打开运行器来执行规范。可以看到以下输出：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_03.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础知识和BDD思维](graphics/B04138_02_03.jpg)'
- en: This is the first spec's passing result on the browser
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是浏览器上第一个规范的通过结果
- en: It might sound strange to have an empty spec passing, but in Jasmine, as with
    other test frameworks, a failed assertion is required to make the spec fail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空的规范通过可能听起来很奇怪，但在Jasmine中，与其他测试框架一样，需要失败的断言才能使规范失败。
- en: An **assertion** (or expectation) is a comparison between two values that must
    result in a boolean value. The assertion is only considered a success if the result
    of the comparison is true.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**断言**（或期望）是两个值之间的比较，必须产生布尔值。只有在比较的结果为真时，断言才被认为是成功的。'
- en: In Jasmine, assertions are written using the global Jasmine function `expect`,
    along with a **matcher** that indicates what comparison must be made with the
    values.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jasmine中，使用全局Jasmine函数`expect`编写断言，以及指示要对值进行何种比较的**匹配器**。
- en: 'Regarding the current spec (it is expected that the investment is of a stock),
    in Jasmine this translates to the following code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于当前的规范（预期投资是股票），在Jasmine中，这对应以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Add the preceding highlighted code to the `InvestmentSpec.js` file. The `expect`
    function takes only one parameter, which defines the **actual value**, or in other
    words, what is going to be tested—`investment.stock`—and expects the chaining
    call to a matcher function, which in this case is `toBe`. That defines the **expected
    value**, `stock`, and the comparison method to be performed (to be the same).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面高亮的代码添加到`InvestmentSpec.js`文件中。`expect`函数只接受一个参数，它定义了**实际值**，或者换句话说，要进行测试的内容——`investment.stock`，并期望链接调用匹配器函数，这种情况下是`toBe`。这定义了**期望值**，`stock`，以及要执行的比较方法（要相同）。
- en: Behind the scenes, Jasmine makes a comparison to check whether the actual value
    (`investment.stock`) and expected value (`stock`) are the same, and if they are
    not, the test fails.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Jasmine进行比较，检查实际值（`investment.stock`）和期望值（`stock`）是否相同，如果它们不同，测试就会失败。
- en: 'With the assertion written, the spec that previously passed has now failed,
    as shown in the following screenshot:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有了写好的断言，先前通过的规范现在已经失败，如下截图所示：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_04.jpg)'
- en: This shows the first spec's failure results
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了第一个规范的失败结果
- en: This spec failed because, as the error message states, `investment is not defined`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规范失败了，因为错误消息表明`investment未定义`。
- en: 'The idea here is to do only what the error is indicating us to do, so although
    you might feel the urge to write something else, for now let''s just create this
    `investment` variable with an `Investment` instance in the `InvestmentSpec.js`
    file, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是只做错误提示我们要做的事情，所以尽管您可能会有写其他内容的冲动，但现在让我们在`InvestmentSpec.js`文件中创建一个`investment`变量，并使用`Investment`实例，如下所示：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Don''t worry that the `Investment()` function doesn''t exist yet; the spec
    is about to ask for it on the next run, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心`Investment()`函数尚不存在；规范即将在下一次运行时要求它，如下所示：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_05.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_05.jpg)'
- en: Here the spec asks for an Investment class
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规范要求一个Investment类
- en: 'You can see that the error has changed to `Investment is not defined`. It now
    asks for the `Investment` function. So, create a new `Investment.js` file in the
    `src` folder and add it to the runner, as shown in the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到错误已经改为`Investment未定义`。现在要求`Investment`函数。因此，在`src`文件夹中创建一个新的`Investment.js`文件，并将其添加到runner中，如下所示：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To define `Investment`, write the following constructor function in the `Investment.js`
    file inside the `src` folder:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义`Investment`，请在`src`文件夹中的`Investment.js`文件中编写以下构造函数：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This makes the error change. It now complains about the missing `stock` variable,
    as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会改变错误。现在它抱怨缺少`stock`变量，如下截图所示：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_06.jpg)'
- en: This shows a missing stock error
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个缺少stock的错误
- en: 'One more time, we feed the code it is asking for into the `InvestmentSpec.js`
    file, as shown in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们将代码输入到`InvestmentSpec.js`文件中，如下所示：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The error changes again; this time it is about the missing `Stock` function:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 错误再次改变；这次是关于缺少`Stock`函数：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_07.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_07.jpg)'
- en: Here the spec asks for a Stock class
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规范要求一个Stock类
- en: 'Create a new file in the `src` folder, name it `Stock.js`, and add it to the
    runner. Since the `Stock` function is going to be a dependency of `Investment`,
    we should add it just before `Investment.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中创建一个新文件，命名为`Stock.js`，并将其添加到runner中。由于`Stock`函数将成为`Investment`的依赖项，所以我们应该在`Investment.js`之前添加它：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Write the `Stock` constructor function to the `Stock.js` file:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Stock`构造函数写入`Stock.js`文件：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, the error is about the expectation, as shown in the following screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，错误是关于期望值，如下截图所示：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_08.jpg)'
- en: The expectation is undefined to be Stock
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 期望是未定义的Stock
- en: 'To fix this and complete this exercise, open the `Investment.js` file inside
    the `src` folder, and add the reference to the `stock` parameter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要修复这个问题并完成这个练习，打开`src`文件夹中的`Investment.js`文件，并添加对`stock`参数的引用：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the spec file, pass `stock` as a parameter to the `Investment` function:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范文件中，将`stock`作为参数传递给`Investment`函数：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, you will have a passing spec:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将有一个通过的规范：
- en: '![Jasmine basics and thinking in BDD](graphics/B04138_02_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine基础和BDD思维](graphics/B04138_02_09.jpg)'
- en: This shows an Investment spec that passes
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个通过的Investment规范
- en: This exercise was meticulously conducted to show how a developer works by feeding
    the spec with what it wants when doing test-first development.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习是精心进行的，以展示开发人员在进行测试驱动开发时如何满足规范的要求。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The drive to write code must come from a spec that has failed. You must not
    write code unless its purpose is to fix a failed spec.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码的动力必须来自一个失败的规范。除非其目的是修复失败的规范，否则不得编写代码。
- en: Setup and teardown
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置和拆卸
- en: 'There are three more acceptance criteria to be implemented. The next in the
    list is as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有三个要实现的验收标准。列表中的下一个是：
- en: '"Given an investment, it should have the invested shares'' quantity."'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个投资，它应该有投资的股份数量。”
- en: 'Writing it should be as simple as the previous spec was. In the `InvestmentSpec.js`
    file inside the `spec` folder, you can translate this new criterion into a new
    spec called `should have the invested shares'' quantity`, as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 写它应该和之前的规范一样简单。在`spec`文件夹内的`InvestmentSpec.js`文件中，您可以将这个新标准翻译成一个名为`should have
    the invested shares' quantity`的新规范，如下所示：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You can see that apart from having written the new spec, we have also changed
    the call to the `Investment` constructor to support the new `shares` parameter.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，除了编写了新的规范之外，我们还改变了对`Investment`构造函数的调用，以支持新的`shares`参数。
- en: To do so, we used an object as a single parameter in the constructor to simulate
    named parameters, a feature JavaScript doesn't have natively.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们在构造函数中使用了一个对象作为单个参数，以模拟命名参数，这是JavaScript本身没有的功能。
- en: 'Implementing this in the `Investment` function is pretty simple—instead of
    having multiple parameters on the function declaration, it has only one, which
    is expected to be an object. Then, the function probes each of its expected parameters
    from this object, making the proper assignments, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Investment`函数中实现这一点非常简单 - 在函数声明中不再有多个参数，而只有一个参数，预期是一个对象。然后，函数从这个对象中探测每个预期的参数，进行适当的赋值，如下所示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The code is now refactored. We can run the tests to see that only the new spec
    fails, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码已经重构。我们可以运行测试来看只有新的规范失败，如下所示：
- en: '![Setup and teardown](graphics/B04138_02_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](graphics/B04138_02_10.jpg)'
- en: This shows the failing shares spec
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了股份规范的失败
- en: 'To fix this, change the `Investment` constructor to make the assignment to
    the `shares` property, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，将`Investment`构造函数更改为对`shares`属性进行赋值，如下所示：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, everything on your screen is green:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您屏幕上的一切都是绿色的：
- en: '![Setup and teardown](graphics/B04138_02_11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](graphics/B04138_02_11.jpg)'
- en: This shows the passing shares spec
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过的股份规范
- en: 'But as you can see, the following code, which instantiates `Stock` and `Investment`,
    is duplicated on both specs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如您所看到的，实例化`Stock`和`Investment`的以下代码在两个规范中都是重复的：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To eliminate this duplication, Jasmine provides another global function called
    `beforeEach` that, as the name states, is executed once before each spec. So,
    for these two specs, it will run twice—once before each spec.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了消除这种重复，Jasmine提供了另一个全局函数叫做`beforeEach`，顾名思义，它在每个规范之前执行一次。因此，对于这两个规范，它将运行两次
    - 每个规范之前运行一次。
- en: 'Refactor the previous specs by extracting the setup code using the `beforeEach`
    function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`beforeEach`函数提取设置代码来重构先前的规范：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks much cleaner; we not only removed the code duplication, but also
    simplified the specs. They became much easier to read and maintain since their
    only responsibility now is to fulfill the expectation.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来干净多了；我们不仅消除了代码重复，还简化了规范。它们变得更容易阅读和维护，因为它们现在的唯一责任是满足期望。
- en: There is also a **teardown** function (`afterEach`) that sets the code to be
    executed after each spec. It is very useful in situations where a cleanup is required
    after each spec. We will see an example of its application in [Chapter 6](ch06.html
    "Chapter 6. Light Speed Unit Testing"), *Light Speed Unit Testing*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个**拆卸**函数（`afterEach`），它在每个规范之后设置要执行的代码。在每个规范之后需要清理时，它非常有用。我们将在[第6章](ch06.html
    "第6章。光速单元测试")中看到其应用的示例，*光速单元测试*。
- en: 'To finish the specification of `Investment`, add the remaining two specs to
    the `InvestmentSpec.js` file, inside the `spec` folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成`Investment`的规范，将剩下的两个规范添加到`spec`文件夹中的`InvestmentSpec.js`文件中：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Run the specs to see them fail, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 运行规范，看它们失败，如下截图所示：
- en: '![Setup and teardown](graphics/B04138_02_12.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](graphics/B04138_02_12.jpg)'
- en: This shows the failing cost and price specs
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了成本和价格规范的失败
- en: 'Add the following code to fix them in the `Investment.js` file inside the `src`
    folder:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`src`文件夹中的`Investment.js`文件中以修复它们：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Run the specs for the last time to see them pass:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一次运行规范，看它们通过：
- en: '![Setup and teardown](graphics/B04138_02_13.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![设置和拆卸](graphics/B04138_02_13.jpg)'
- en: This shows all four Investment specs passing
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了所有四个投资规范都通过了
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is important to always see a spec fail before writing the code to fix it;
    otherwise, how would you know that you really need to fix it? Imagine this as
    a way to test the test.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码来修复之前，始终要看到规范失败；否则，您怎么知道您真的需要修复它呢？把这看作是测试测试的一种方式。
- en: Nested describes
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套描述
- en: '**Nested describes** are useful when you want to describe similar behavior
    between specs. Suppose we want the following two new acceptance criteria:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**嵌套描述**在您想要描述规范之间相似行为时非常有用。假设我们想要以下两个新的验收标准：'
- en: Given an investment, when its stock share price valorizes, it should have a
    positive **return on investment** (**ROI**)
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，当其股票股价升值时，它应该有一个正的**投资回报率**（**ROI**）
- en: Given an investment, when its stock share price valorizes, it should be a good
    investment
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个投资，当其股票股价升值时，它应该是一个好的投资
- en: Both these criteria share the same behavior when the investment's stock share
    price valorizes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当投资的股票股价升值时，这两个标准都具有相同的行为。
- en: 'To translate this into Jasmine, you can nest a call to the `describe` function
    inside the existing one in the `InvestmentSpec.js` file (I removed the rest of
    the code for the purpose of demonstration; it is still there):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其翻译成Jasmine，您可以在`InvestmentSpec.js`文件中现有的`describe`函数内嵌套一个调用（我为演示目的删除了其余代码；它仍然存在）：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It should behave just like the outer one, so you can add specs (`it`) and use
    the setup and teardown functions (`beforeEach`, `afterEach`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该像外部规范一样工作，因此您可以添加规范（`it`）并使用设置和拆卸函数（`beforeEach`，`afterEach`）。
- en: Setup and teardown
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置和拆卸
- en: 'When using the setup and teardown functions, Jasmine respects the outer setup
    and teardown functions as well, so that they are run as expected. For each spec
    (`it`), the following actions are performed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用设置和拆卸函数时，Jasmine也会尊重外部设置和拆卸函数，以便按预期运行。对于每个规范（`it`），执行以下操作：
- en: Jasmine runs all setup functions (`beforeEach`) from the outside in
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine按照从外到内的顺序运行所有设置函数（`beforeEach`）
- en: Jasmine runs a spec code (`it`)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine运行规范代码（`it`）
- en: Jasmine runs all the teardown functions (`afterEach`) from the inside out
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jasmine按照从内到外的顺序运行所有拆卸函数（`afterEach`）
- en: 'So, we can add a setup function to this new `describe` function that changes
    the share price of the stock, so that it''s greater than the share price of the
    investment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以向这个新的`describe`函数添加一个设置函数，以更改股票的股价，使其大于投资的股价：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Coding a spec with shared behavior
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用共享行为编写规范
- en: 'Now that we have the shared behavior implemented, we can start coding the acceptance
    criteria described earlier. Each is, just as before, a call to the global Jasmine
    function `it`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了共享的行为，我们可以开始编写之前描述的验收标准。每个都是，就像以前一样，调用全局Jasmine函数`it`：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After adding the missing functions to `Investment` in the `Investment.js` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Investment.js`文件中添加缺失的函数之后：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can run the specs and see that they pass:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以运行规范并查看它们是否通过：
- en: '![Coding a spec with shared behavior](graphics/B04138_02_14.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用共享行为编写规范](graphics/B04138_02_14.jpg)'
- en: This shows the nested describe specs pass
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了嵌套的描述规范通过
- en: Understanding matchers
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解匹配器
- en: By now, you've already seen plenty of usage examples for matchers and probably
    can feel how they work.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了匹配器的许多用法示例，可能已经感受到它们的工作原理。
- en: You have seen how to use the `toBe` and `toEqual` matchers. These are the two
    base built-in matchers available in Jasmine, but we can extend Jasmine by writing
    matchers of our own.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何使用`toBe`和`toEqual`匹配器。这是Jasmine中提供的两个基本内置匹配器，但我们可以编写自己的匹配器来扩展Jasmine。
- en: So, to really understand how Jasmine matchers work, we need to create one ourselves.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要真正理解Jasmine匹配器的工作原理，我们需要自己创建一个。
- en: Custom matchers
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义匹配器
- en: 'Consider this expectation from the previous section:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下前一节中的期望：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Although it works, it is not very expressive. Imagine if we could instead rewrite
    it as:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它能够工作，但表达力不是很强。想象一下，如果我们可以改写成：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates a much better relation with the acceptance criterion:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与验收标准之间建立了更好的关系。
- en: So, here "should be a good investment" becomes "expect investment to be a good
    investment".
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，“should be a good investment”变成了“expect investment to be a good investment”。
- en: Implementing it is quite simple. You do so by calling the `jasmine.addMatchers`
    function—ideally inside a setup step (`beforeEach`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 实现它非常简单。您可以通过调用`jasmine.addMatchers`函数来实现这一点，最好是在设置步骤（`beforeEach`）中。
- en: Although you can put this new matcher definition inside the `InvestmentSpec.js`
    file, Jasmine already has a default place to add custom matchers, the `SpecHelper.js`
    file, inside the `spec` folder. If you are using Standalone Distribution, it already
    comes with a sample custom matcher; delete it and let's start from scratch.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以将这个新的匹配器定义放在`InvestmentSpec.js`文件中，但Jasmine已经有一个默认的位置来添加自定义匹配器，即`SpecHelper.js`文件，位于`spec`文件夹内。如果您使用独立发行版，它已经带有一个示例自定义匹配器；删除它，让我们从头开始。
- en: 'The `addMatchers` function accepts a single parameter—an object where each
    attribute corresponds to a new matcher. So, to add the following new matcher,
    change the contents of the `SpecHelper.js` file to the following:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`addMatchers`函数接受一个参数，即一个对象，其中每个属性对应一个新的匹配器。因此，要添加以下新的匹配器，请更改`SpecHelper.js`文件的内容如下：'
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The function being defined here is not the matcher itself but a factory function
    to build the matcher. Its purpose, once called is to return an object containing
    a compare function, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里定义的函数不是匹配器本身，而是一个工厂函数，用于构建匹配器。它的目的是一旦调用就返回一个包含比较函数的对象，如下所示：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `compare` function will contain the actual matcher implementation, and as
    can be observed by its signature, it receives both values being compared (the
    `actual` and `expected` values).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`compare`函数将包含实际的匹配器实现，并且可以通过其签名观察到，它接收要比较的两个值（`actual`和`expected`值）。'
- en: For the given example, the `investment` object will be available in the `actual`
    argument.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的示例，`investment`对象将在`actual`参数中可用。
- en: Then, Jasmine expects, as the result of this `compare` function, an object with
    a `pass` attribute with a boolean value `true` to indicate that the expectation
    passes and `false` if the expectation fails.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，Jasmine期望`compare`函数的结果是一个带有`pass`属性的对象，该属性具有布尔值`true`，以指示期望通过，如果期望失败则为`false`。
- en: 'Let''s have a look at the following valid implementation of the `toBeAGoodInvestment`
    matcher:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`toBeAGoodInvestment`匹配器的以下有效实现：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By now, this matcher is ready to be used by the specs:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个匹配器已经准备好被规范使用：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After the change, the specs should still pass. But what happens if a spec fails?
    What is the error message that Jasmine reports?
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 更改后，规范仍应通过。但是如果规范失败会发生什么？Jasmine报告的错误消息是什么？
- en: 'We can see it by deliberately breaking the `investment.isGood` implementation
    in the `Investment.js` file, in the `src` folder to always return `false`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过故意破坏`Investment.js`文件中`src`文件夹中的`investment.isGood`实现，使其始终返回`false`来看到它：
- en: '[PRE29]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When running the specs again, Jasmine generates an error message stating `Expected
    { stock: { sharePrice: 40 }, shares: 100, sharePrice: 20, cost: 2000 } to be a
    good investment`, as shown in the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '再次运行规范时，Jasmine会生成一个错误消息，指出`Expected { stock: { sharePrice: 40 }, shares: 100,
    sharePrice: 20, cost: 2000 } to be a good investment`，如下面的截图所示：'
- en: '![Custom matchers](graphics/B04138_02_15.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](graphics/B04138_02_15.jpg)'
- en: This is the custom matcher's message
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的消息
- en: 'Jasmine does a great job generating this error message, but it also allows
    its customization via the `result.message` property of the object returned as
    the result of the matcher. Jasmine expects this property to be a string with the
    following error message:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine在生成此错误消息方面做得很好，但它也允许通过匹配器结果对象的`result.message`属性进行自定义。Jasmine期望此属性是一个带有以下错误消息的字符串：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Run the specs again and the error message should change:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行规范，错误消息应该改变：
- en: '![Custom matchers](graphics/B04138_02_16.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](graphics/B04138_02_16.jpg)'
- en: This is the custom matcher's custom message
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的自定义消息
- en: 'Now, let''s consider another acceptance criterion:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑另一个验收标准：
- en: '"Given an investment, when its stock share price devalorizes, it should be
    a bad investment."'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “给定一个投资，当它的股票价格贬值时，它应该是一个坏的投资。”
- en: Although it is possible to create a new custom matcher (`toBeABadInvestment`),
    Jasmine allows the negation of any matcher by chaining `not` before the matcher
    call. So, we can write that "a bad investment" is "not a good investment"
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以创建一个新的自定义匹配器（`toBeABadInvestment`），Jasmine允许在调用匹配器之前通过在匹配器调用之前链接`not`来否定任何匹配器。因此，我们可以说“一个坏的投资”是“不是一个好的投资”。
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Implement this new acceptance criterion in the `InvestmentSpec.js` file inside
    the `spec` folder by adding new and nested `describe` and `spec`, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InvestmentSpec.js`文件的`spec`文件夹中添加新的和嵌套的`describe`和`spec`，以实现这个新的验收标准：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'But there is a catch! Let''s break the `investment` implementation in the `Investment.js`
    file code so that it is always a good investment, as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一个问题！让我们来破解`Investment.js`文件中的`investment`实现，使其始终是一个好的投资，如下所示：
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After running the specs again, you can see that this new spec fails, but the
    error message, `Expected investment to be a good investment`, is wrong, as shown
    in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行规范，您会发现这个新规范失败了，但错误消息`Expected investment to be a good investment`是错误的，如下面的截图所示：
- en: '![Custom matchers](graphics/B04138_02_17.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](graphics/B04138_02_17.jpg)'
- en: This is the custom matcher's wrong custom negated message
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是自定义匹配器的错误的自定义否定消息
- en: That is the message that was hardcoded inside the matcher. To fix this, you
    need to make the message dynamic.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是硬编码在匹配器内部的消息。要修复这个问题，您需要使消息动态化。
- en: 'Jasmine only shows the message if the matcher fails, so the proper way of making
    this message dynamic is to consider what message is supposed to be shown when
    the given comparison is invalid:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine只在匹配器失败时显示消息，因此使此消息动态化的正确方法是考虑在给定比较无效时应该显示什么消息：
- en: '[PRE34]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This fixes the message, as shown in the following screenshot:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这修复了消息，如下面的截图所示：
- en: '![Custom matchers](graphics/B04138_02_18.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![自定义匹配器](graphics/B04138_02_18.jpg)'
- en: This shows the custom matcher's custom dynamic message
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了自定义匹配器的自定义动态消息
- en: Now this matcher can be used anywhere.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个匹配器可以在任何地方使用。
- en: 'Before continuing in the chapter, change the `isGood` method back again to
    its correct implementation:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章之前，将`isGood`方法再次更改为正确的实现：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'What this example lacked was a way to show how to pass an expected value to
    a matcher like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子缺少的是展示如何将预期值传递给这样的匹配器的方法：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It turns out that a matcher can receive any number of expected values as parameters.
    So, for instance, the preceding matcher could be implemented in the `SpecHelper.js`
    file, inside the `spec` folder, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，匹配器可以接收任意数量的预期值作为参数。因此，例如，前面的匹配器可以在`SpecHelper.js`文件中的`spec`文件夹中实现如下：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: By implementing any matcher, check first whether there is one available that
    already does what you want.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现任何匹配器，首先检查是否已经有一个可用的匹配器可以实现你想要的功能。
- en: For more information, check the official documentation at the Jasmine website
    [http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请查看Jasmine网站上的官方文档[http://jasmine.github.io/2.1/custom_matcher.html](http://jasmine.github.io/2.1/custom_matcher.html)。
- en: Built-in matchers
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内置匹配器
- en: Jasmine comes with a bunch of default matchers covering the basis of value checking
    in the JavaScript language. To understand how they work and where to use them
    properly is a journey of how JavaScript handles type.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine带有一堆默认匹配器，涵盖了JavaScript语言中值检查的基础知识。了解它们的工作原理以及在何处正确使用它们是了解JavaScript处理类型的过程。
- en: The toEqual built-in matcher
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toEqual内置匹配器
- en: The `toEqual` matcher is probably the most commonly used matcher, and you should
    use it whenever you want to check equality between two values.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`toEqual`匹配器可能是最常用的匹配器，每当您想要检查两个值之间的相等性时，都应该使用它。'
- en: 'It works for all primitive values (number, string, and boolean) as well as
    any object (including arrays), as shown in the following code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 它适用于所有原始值（数字、字符串和布尔值）以及任何对象（包括数组），如下面的代码所示：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The toBe built-in matcher
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBe内置匹配器
- en: The `toBe` matcher has a very similar behavior to the `toEqual` matcher; in
    fact, it gives the same result while comparing primitive values, but the similarities
    stop there.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBe`匹配器的行为与`toEqual`匹配器非常相似；实际上，在比较原始值时，它给出相同的结果，但相似之处止步于此。'
- en: While the `toEqual` matcher has a complex implementation (you should take a
    look at the Jasmine source code) that checks whether all attributes of an object
    and all elements of an array are the same, here it is a simple use of the **strict
    equals operator** (`===`).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`toEqual`匹配器有一个复杂的实现（您应该查看Jasmine源代码），它检查对象的所有属性和数组的所有元素是否相同，但在这里它只是简单使用了**严格相等运算符**（`===`）。
- en: If you are unfamiliar with the strict equals operator, its main difference from
    the **equals operator** (`==`) is that the latter performs type coercion if the
    compared values aren't of the same type.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不熟悉严格相等运算符，它与**equals运算符**（`==`）的主要区别在于，如果比较的值不是相同类型，后者会执行类型强制转换。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The strict equals operator always considers false any comparison between values
    of distinct types.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 严格相等运算符始终将不同类型的值之间的比较视为false。
- en: 'Here are some examples of how this matcher (and the strict equals operator)
    works:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此匹配器（以及严格相等运算符）的工作示例：
- en: '[PRE39]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: It is advised that you use the `toEqual` operator in most cases and resort to
    the `toBe` matcher only when you want to check whether two variables reference
    the same object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在大多数情况下使用`toEqual`运算符，并且只有在要检查两个变量是否引用相同对象时才使用`toBe`匹配器。
- en: The toBeTruthy and toBeFalsy matchers
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBeTruthy和toBeFalsy匹配器
- en: Besides its primitive boolean type, everything else in the JavaScript language
    also has an inherent boolean value, which is generally known to be either **truthy**
    or **falsy**.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其原始布尔类型之外，JavaScript语言中的所有其他内容也都具有固有的布尔值，通常被称为“truthy”或“falsy”。
- en: 'Luckily in JavaScript, there are only a few values that are identified as falsy,
    as shown in the following examples for the `toBeFalsy` matcher:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在JavaScript中，只有少数值被识别为falsy，如`toBeFalsy`匹配器的以下示例所示：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Everything else is considered truthy, as demonstrated by the following examples
    of the `toBeTruthy` matcher:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 其他所有内容都被视为truthy，如`toBeTruthy`匹配器的以下示例所示：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: But, if you want to check whether something is equal to an actual boolean value,
    it might be a better idea to use the `toEqual` matcher.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果要检查某个东西是否等于实际的布尔值，可能更好的主意是使用`toEqual`匹配器。
- en: The toBeUndefined, toBeNull, and toBeNaN built-in matchers
  id: totrans-231
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBeUndefined、toBeNull和toBeNaN内置匹配器
- en: 'These matchers are pretty straightforward and should be used to check for `undefined`,
    `null`, and `NaN` values:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匹配器非常直观，应该用于检查`undefined`、`null`和`NaN`的值：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Both `toBeNull` and `toBeUndefined` can be written as `toBe(null)` and `toBe(undefined)`
    respectively, but that is not the case with `toBeNaN`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBeNull`和`toBeUndefined`都可以分别写为`toBe(null)`和`toBe(undefined)`，但`toBeNaN`不是这种情况。'
- en: 'In JavaScript, the `NaN` value is not equal to any value, not even `NaN`. So,
    trying to compare it to itself is always `false`, as shown in the following code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，`NaN`值不等于任何值，甚至不等于`NaN`。因此，尝试将其与自身进行比较总是`false`，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As good practice, try to use these matchers instead of their `toBe` counterparts
    whenever possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 作为良好的实践，尽量在可能的情况下使用这些匹配器，而不是它们的`toBe`对应物。
- en: The toBeDefined built-in matcher
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBeDefined内置匹配器
- en: 'This matcher is useful if you want to check whether a variable is defined and
    you don''t care about its value, as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要检查变量是否已定义，而不关心其值，可以使用这个匹配器。
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Anything except `undefined` will pass under this matcher, even `null`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`undefined`之外的任何内容都会通过这个匹配器，甚至是`null`。
- en: The toContain built-in matcher
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toContain内置匹配器
- en: 'Sometimes, it is desirable to check whether an array contains an element, or
    whether a string can be found inside another string. For these use cases, you
    can use the `toContain` matcher, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，希望检查数组是否包含元素，或者一个字符串是否可以在另一个字符串中找到。对于这些用例，可以使用`toContain`匹配器，如下所示：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The toMatch built-in matcher
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toMatch内置匹配器
- en: 'Although the `toContain` and `toEqual` matchers can be used in most string
    comparisons, sometimes the only way to assert whether a string value is correct
    is through a regular expression. For these cases, you can use the `toMatch` matcher
    along with a regular expression, as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`toContain`和`toEqual`匹配器可以在大多数字符串比较中使用，但有时唯一的断言字符串值是否正确的方法是通过正则表达式。对于这些情况，可以使用`toMatch`匹配器以及正则表达式，如下所示：
- en: '[PRE46]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The matcher works by testing the actual value (`"My big matched string"`) against
    the expected regular expression (`/My(.+)string/`).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配器通过测试实际值（`"My big matched string"`）与预期正则表达式（`/My(.+)string/`）进行比较。
- en: The toBeLessThan and toBeGreaterThan built-in matchers
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBeLessThan和toBeGreaterThan内置匹配器
- en: 'The `toBeLessThan` and `toBeGreaterThan` matchers are simple and used to perform
    numeric comparisons—something that is best described by the following examples:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`toBeLessThan`和`toBeGreaterThan`匹配器很简单，用于执行数字比较，最好通过以下示例进行描述：'
- en: '[PRE47]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The toBeCloseTo built-in matcher
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toBeCloseTo内置匹配器
- en: 'This is a special matcher used to compare floating-point numbers with a defined
    set of precision—something that is best explained by this example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个特殊的匹配器，用于比较具有一组定义精度的浮点数，最好通过以下示例进行解释：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The first parameter is the number being compared, and the second is the precision
    in the number of decimal cases.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是要比较的数字，第二个是小数位数的精度。
- en: The toThrow built-in matcher
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: toThrow内置匹配器
- en: Exceptions are a language's way of demonstrating when something goes wrong.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是语言在出现问题时展示的方式。
- en: So, for example, while coding an API, you might decide to throw an exception
    when a parameter is passed incorrectly. So, how do you test this code?
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，在编写API时，您可能决定在参数传递不正确时抛出异常。那么，如何测试这段代码呢？
- en: Jasmine has the built-in `toThrow` matcher that can be used to verify that an
    exception has been thrown.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine有内置的`toThrow`匹配器，可用于验证是否抛出了异常。
- en: The way it works is a little bit different from the other matchers. Since the
    matcher has to run a piece of code and check whether it throws an exception, the
    matcher's **actual** value must be a function.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式与其他匹配器有些不同。由于匹配器必须运行一段代码并检查是否抛出异常，因此匹配器的**actual**值必须是一个函数。
- en: 'Here is an example of how it works:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的工作示例：
- en: '[PRE49]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: When the test is run, the anonymous function is executed, and if it throws the
    `Some exception` exception, the test passes.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行测试时，将执行匿名函数，如果抛出`Some exception`异常，则测试通过。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to think in BDD and drive your code from your
    specs. You also became acquainted with the basic Jasmine global functions (`describe`,
    `it`, `beforeEach`, and `afterEach`) and have a good understanding of what is
    required to create a spec in Jasmine.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何以BDD方式思考并从规范中驱动代码。您还熟悉了基本的Jasmine全局函数（`describe`、`it`、`beforeEach`和`afterEach`），并且对在Jasmine中创建规范有了很好的理解。
- en: You got familiar with Jasmine matchers and know how powerful they are in describing
    a spec intent. You even learned to create a matcher of your own.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉了Jasmine匹配器，并知道它们在描述规范意图方面有多么强大。您甚至学会了创建自己的匹配器。
- en: By now, you should be familiar with creating new specs and driving the development
    of your new application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经熟悉了创建新规范并推动新应用程序的开发。
- en: In the next chapter, we are going to take a look at how we can use the concepts
    learned in this chapter to start testing web applications, which are most commonly
    jQuery and HTML forms.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看如何利用本章学到的概念来开始测试Web应用程序，这些应用程序最常见的是jQuery和HTML表单。
