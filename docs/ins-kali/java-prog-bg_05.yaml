- en: Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'In this chapter, we will start with a discussion of some of the basic concepts
    and terminologies used in the basics of Java programs. You will learn all these
    concepts with the help of simple programs. You''ll learn about the all-important
    Java method. If you''re an experienced programmer, you''ve probably run across
    functions in the past. As you progress with these basic concepts, you will grasp
    more about advanced Java functions. The following are the topics that we plan
    to cover in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从讨论Java程序基础知识中使用的一些基本概念和术语开始。你将通过简单的程序学习所有这些概念。你将了解到至关重要的Java方法。如果你是一名有经验的程序员，你可能以前遇到过函数。随着这些基本概念的进展，你将更多地了解高级Java函数。以下是我们计划在本章中涵盖的主题：
- en: The basics of a Java function
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java函数的基础知识
- en: Methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Advanced Java functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Java函数
- en: Operating Java variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作Java变量
- en: The basics of Java functions
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java函数的基础知识
- en: In Java, the terms "function" and "method" are basically used interchangeably,
    with "method" being the more technically correct term that you'll see in the documentation.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，“函数”和“方法”这两个术语基本上是可以互换使用的，而“方法”是更加技术上正确的术语，你会在文档中看到。
- en: Methods
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: '**Methods** are a tool that allow us to break the control flow of our program.
    They let us declare little **subroutines**, or sometimes we can think of them
    as smaller programs, that we can reference in our program so that we don''t have
    to write all of our program''s logical code in one single block:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**方法**是一种工具，允许我们打破程序的控制流。它们让我们声明一些小的**子程序**，有时我们可以把它们看作更小的程序，我们可以在我们的程序中引用它们，这样我们就不必把我们程序的所有逻辑代码都写在一个单一的块中：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An example of a method is the `.next` method found in the `Scanner` class. Rather
    than having to teach our `Scanner` object how to acquire the next set of user
    inputs in this program I've written, I can simply call the `next` method from
    the class that someone else has written in the past. This turns what would probably
    be a couple of hundred lines of program into a total of 22 lines approximately,
    illustrated in the preceding code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的一个例子是`Scanner`类中的`.next`方法。在我写的这个程序中，我们不必教`Scanner`对象如何获取用户输入的下一组数据，我只需从过去某人编写的类中调用`next`方法。这将把可能是几百行程序的东西转换成大约22行，如前面的代码所示。
- en: By writing our own methods, we can tackle complicated challenges by breaking
    them into much smaller and easier-to-manage parts. Programs that are properly
    modular and make use of methods are also much more human-readable. This is because
    we can give our methods our own names so our program can be much more self-explanatory
    and make use of a lot more English(or whatever language you are native to) words.
    To show you the power of methods right from the start, I've planned a pretty complicated
    program for us to write today.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写我们自己的方法，我们可以通过将复杂的挑战分解成更小、更易管理的部分来解决它们。正确模块化并使用方法的程序也更容易阅读。这是因为我们可以给我们的方法起自己的名字，这样我们的程序就可以更加自解释，并且可以使用更多的英语（或者你的母语）单词。为了向你展示方法的强大之处，我已经计划了一个相当复杂的程序，今天我们要写这个程序。
- en: Temperature conversion program
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 温度转换程序
- en: 'Our goal is to create a temperature conversion program, and I''ve set up the
    input portion of this program for us already:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建一个温度转换程序，我已经为我们设置了程序的输入部分：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'So far, this program takes three pieces of information from the user. The first
    is the temperature type: `F` for Fahrenheit, `C` for Celsius, and `K` for Kelvin.
    Then it takes another temperature type. This is the type that our user would like
    us to convert to; once again, it could be Fahrenheit, Celsius, or Kelvin. Finally,
    we take the value of the initial temperature from the user. With these three pieces
    of input, our program will convert the given temperature value from Fahrenheit,
    Celsius, or Kelvin to the temperature type the user desires.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这个程序从用户那里获取了三条信息。第一条是温度类型：`F`代表华氏度，`C`代表摄氏度，`K`代表开尔文。然后它获取另一种温度类型。这是我们的用户希望我们转换到的类型；再一次，它可以是华氏度、摄氏度或开尔文。最后，我们从用户那里获取初始温度的值。有了这三条输入，我们的程序将把给定的温度值从华氏度、摄氏度或开尔文转换为用户所需的温度类型。
- en: 'This is a challenging program for two reasons:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有挑战性的程序，原因有两个：
- en: First, there are six possible control flow cases because there are two sets
    of three user input. This means in the worst-case scenario, we might have to write
    six `if...else` blocks, which will get unwieldy pretty quick.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，因为有两组三个用户输入，所以有六种可能的控制流情况。这意味着在最坏的情况下，我们可能不得不写六个`if...else`块，这将很快变得笨拙。
- en: 'The second challenge is doing the actual conversion. I''ve gone ahead and looked
    up the conversion math for three temperature conversions, namely Fahrenheit to
    Celsius, Celsius to Kelvin, and Kelvin to Fahrenheit:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个挑战是进行实际的转换。我已经提前查找了三种温度转换的转换数学，即华氏度到摄氏度，摄氏度到开尔文，和开尔文到华氏度：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, while this isn't difficult math, it's certainly unwieldy and
    our programs are going to look pretty crazy if we start copying and pasting formula
    as shown in the preceding comments all over the place. You should also note that
    with the three conversions in the preceding comments section, we can make any
    of the possible conversions this program will be asked to do. This is because
    these three conversions create a circle of conversion, where we can get from a
    particular type to any other type by passing through one of the interim equations.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，虽然这不是困难的数学问题，但它肯定是笨拙的，如果我们开始在程序中到处复制和粘贴公式，我们的程序看起来会非常疯狂。你还应该注意，在前面的评论部分中，有三种转换，我们可以做出这个程序将被要求做的任何可能的转换。这是因为这三种转换创建了一个转换的循环，我们可以通过其中一个中间方程从一个特定类型到任何其他类型。
- en: With all said and done, let's just jump right into writing our program.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，让我们直接开始编写我们的程序吧。
- en: Setting up the control flow
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置控制流
- en: 'The first thing we need to do is set up some control flow. As I mentioned before,
    there''s six possible cases, and it might be tempting to just set up six `if`
    statements for each possible pairing of input and output types. This would be
    a little unwieldy though, so I have a slightly different plan. Instead of handling
    a different case for each possible pairing of types, the first thing I''m going
    to do is convert whatever value our user has given as the initial temperature
    value to a Celsius value. After I''ve done this, we''ll convert that Celsius value
    to whatever type the user was originally looking for. This can be done using the
    following code block:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是设置一些控制流。正如我之前提到的，有六种可能的情况，可能会诱人地为每种可能的输入和输出类型设置六个`if`语句。不过这会有点笨拙，所以我有一个稍微不同的计划。我将不同的情况转换为每种可能的类型配对，首先要做的是将用户给出的初始温度值转换为摄氏度值。在我这样做之后，我们将把摄氏度值转换为用户最初寻找的类型。可以使用以下代码块来完成这个操作：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Setting up the control flow has the advantage of letting us deal with two pieces
    of user input in complete isolation. It makes our program more modular because
    we start and finish one task before we begin the next one.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 设置控制流的优势在于让我们完全独立地处理两个用户输入。这使得我们的程序更加模块化，因为我们在开始下一个任务之前完成了一个任务。
- en: 'So to do this initial conversion, where we take whatever the user has given
    us as input and convert it into a Celsius value, we need to utilize a `switch`
    statement:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了进行这个初始转换，我们需要利用`switch`语句：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We'll be switching across the `inputType` character variable that tells us what
    type of temperature-Fahrenheit, Celsius, or Kelvin-our user has given us. Inside
    the `switch` statement, we'll manipulate `inputValue`, in which the value of that
    temperature would be stored.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`inputType`字符变量之间切换，该变量告诉我们用户给出的温度类型是华氏度、摄氏度还是开尔文。在`switch`语句内部，我们将操作`inputValue`，其中存储着温度的值。
- en: Exploring separate cases - C, K, and F
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索单独的情况-C、K和F
- en: 'So I guess we''re going to need separate cases for each of the possible or
    valid input types, that is, capital `F` for Fahrenheit, `C` for Celsius, `K` for
    Kelvin. We should probably also handle a `default` case. Let''s start off by writing
    the `default` case. We''ll use `System.exit` and exit with `1`, which is technically
    an error code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我想我们需要为每种可能或有效的输入类型编写单独的情况，即大写`F`代表华氏度，`C`代表摄氏度，`K`代表开尔文。我们可能还需要处理一个`default`情况。让我们先写`default`情况。我们将使用`System.exit`并以`1`退出，这在技术上是一个错误代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`System.exit` basically quits our program. It tells it to stop executing and
    passes to the operating system or whatever''s up in the hierarchy.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.exit`基本上退出我们的程序。它告诉程序停止执行并传递给操作系统或者更高级的东西。'
- en: In this case, the program will just stop. Because it's the `default` case, we
    only expect to enter it if the user has failed to enter `F`, `C`, or `K`, which
    are our valid input types. Now, let's go ahead and handle each of these input
    types.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，程序将停止。因为这是`default`情况，我们只期望在用户未能输入`F`、`C`或`K`时进入它，这些是我们有效的输入类型。现在，让我们处理每种输入类型。
- en: Celsius type
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄氏类型
- en: 'We''re going to use Celsius as our first point of conversion in all cases,
    so if our user has inputted a Celsius value, we can just go ahead and break out
    of this case because the value of `inputValue` is already OK with us:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在所有情况下使用摄氏度作为我们的第一个转换点，所以如果用户输入了摄氏值，我们可以直接跳出这种情况，因为`inputValue`的值对我们来说已经可以了。
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'What if the user has given us a Fahrenheit value? Well, let''s scroll to the
    top of the code; you''ll see that we have an explicit conversion from Fahrenheit
    to Celsius:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户给出了华氏值怎么办？好吧，让我们滚动到代码的顶部；你会看到我们有一个明确的从华氏到摄氏的转换：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can take the preceding block of code, which I''ve made pretty Java-friendly,
    and just change the value of this input variable to the conversion statement run
    on its value. So, we''ll replace the `t` placeholder with the input variable:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采用前面的代码块，我已经使其非常适合Java，并只需更改此输入变量的值为其值上运行的转换语句。因此，我们将用输入变量替换`t`占位符：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will properly store the Celsius equivalent of the original Fahrenheit value
    in this variable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这将正确地存储原始华氏值的摄氏等价值在这个变量中。
- en: Kelvin type
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开尔文类型
- en: 'We can do something similar for the Kelvin case. We don''t have an explicit
    conversion from Kelvin to Celsius, but we do know how to convert Kelvin to Fahrenheit
    and then how to convert Fahrenheit to Celsius. So we can get away with doing something
    like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对开尔文情况做类似的事情。我们没有一个明确的从开尔文到摄氏的转换，但我们知道如何将开尔文转换为华氏，然后再将华氏转换为摄氏。所以我们可以用以下方式做一些事情：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we converted our Kelvin value to a Fahrenheit value,
    surrounding it in parentheses, and did our Fahrenheit to Celsius conversion on
    that.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将开尔文值转换为华氏值，用括号括起来，并对其进行华氏到摄氏的转换。
- en: Now this is technically a functional line of code. If we run our program and
    enter a Kelvin input case, it will properly convert the Kelvin value to a Celsius
    value. But, let me say that if I'm a programmer and I'm at work and I run across
    a line of code like this, especially a line of code like this without any comments
    explaining it, I am not going to be very happy. There are a whole lot of magic
    numbers in here-numbers are really information in general; that's not in any way
    self-explanatory. Sure, we as the original programmer, at least when we write
    it, remember that our goal here is to convert a Kelvin value to a Celsius value;
    however, that's really not understandable to anyone else going through this program
    who doesn't really have time to sit down and look through the entire thing. So
    is there a better way to do this? Yes, there definitely is.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这在技术上是一行功能性的代码。如果我们运行程序并输入一个开尔文输入情况，它将正确地将开尔文值转换为摄氏度值。但是，让我说，如果我是一个程序员，我在工作中遇到这样一行代码，特别是没有任何解释的代码，我是不会很高兴的。这里有很多魔术数字-数字在一般情况下真的是信息；这并不是以任何方式自解释的。当然，作为原始程序员，至少当我们写它时，我们记得我们的目标是将开尔文值转换为摄氏度值；然而，对于任何没有时间坐下来查看整个程序的其他人来说，这真的是不可理解的。那么有没有更好的方法来做到这一点？是的，绝对有。
- en: Fahrenheit type
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 华氏度类型
- en: 'Now let''s try to understand the Fahrenheit case. Consider the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试理解华氏温度的情况。考虑以下代码：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding line of code is a little better than our Kelvin case simply because
    it contains fewer numbers, but it's still not programmer-friendly by any sense
    of the word. So what if in our initial implementation of this program, we could
    provide communication that would really look a lot nicer to a programmer? What
    if instead of printing out the equation right there, we put the equation somewhere
    else in our program and call a Fahrenheit to Celsius function?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码行比我们的开尔文情况好一点，因为它包含的数字更少，但从任何意义上来说，它仍然不够友好。那么，如果在我们最初实现这个程序时，我们可以提供真正对程序员友好的通信，会怎么样呢？如果我们不是在那里打印出等式，而是把等式放在程序的其他地方并调用一个华氏度到摄氏度的函数呢？
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll just type in `fToC` now to keep things short. This makes a lot more sense
    to someone looking at our program.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需输入 `fToC` 来保持简洁。这对于查看我们的程序的人来说更有意义。
- en: 'We can do something very similar down here for the Kelvin case:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这里做类似的事情来处理开尔文情况：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We could call a Kelvin to Celsius function (`kToC`) if we wanted to, or if we
    don't even want to write that, we can call a Kelvin to Fahrenheit function on
    our `inputValue` variable and then call the `fToC` function on top of that. That's
    what we did with all that math initially-conceptually-except that what we've done
    has abstracted away those numbers and put them somewhere else in our program.
    This is much more friendly to a programmer. Let's say we made a mistake in our
    math and another programmer wants to go through and check it. All they would need
    to do is find the functions that we're about to write, such as `fToC`, and `kToF`,
    and they can dive into all their dirty details there. So, of course, we do need
    to write these functions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，我们可以调用一个开尔文到摄氏度的函数（`kToC`），或者如果我们甚至不想写那个，我们可以在我们的 `inputValue` 变量上调用一个开尔文到华氏度的函数，然后在此基础上调用
    `fToC` 函数。这就是我们最初所做的所有数学概念上的事情，只是我们已经抽象出了那些数字，并把它们放在了程序的其他地方。这对程序员来说更友好。假设我们在数学上犯了一个错误，另一个程序员想要检查它。他们只需要找到我们即将编写的函数，比如
    `fToC` 和 `kToF`，然后他们就可以深入了解所有的细节。因此，当然，我们确实需要编写这些函数。
- en: 'When we create a new function, we''re actually going to do it outside of the
    function or method that we''re currently in:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新函数时，我们实际上是在当前的函数或方法之外进行的：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Currently, we''re in our program''s `main` method, which is a special method
    where the program begins its execution. So, to write our Fahrenheit to Celsius
    function, we''re going to step out of that method and declare a brand new one;
    essentially, we''re teaching our program how to run a new program called `fToC`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们在程序的 `main` 方法中，这是一个特殊的方法，程序从这里开始执行。因此，为了编写我们的华氏度到摄氏度函数，我们将退出该方法并声明一个全新的方法；基本上，我们正在教我们的程序如何运行一个名为
    `fToC` 的新程序：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: For now, go ahead and use the `public static` keywords in front of your methods.
    These keywords are going to be very important once we really jump into the object-oriented
    nature of Java, but for now, we'll utilize them on all the methods we declare.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续在你的方法前面使用 `public static` 关键字。一旦我们真正进入Java的面向对象的特性，这些关键字将非常重要，但现在，我们将在我们声明的所有方法上使用它们。
- en: For a more detailed explanation about what we plan to do next with our program,
    let's try to see things in much more detail by splitting the program further into
    two parts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们接下来计划如何处理程序的更详细解释，让我们尝试更详细地分割程序，分成两部分。
- en: Executing the first part of the program
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行程序的第一部分
- en: 'Your standard Java method also has one more keyword before we actually give
    it a name, and that is the type of information this method is going to return:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您标准的Java方法在我们给它一个名称之前还有一个关键字，那就是这个方法将返回的信息类型：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, we would like to be able to call `fToC` on our Kelvin to Fahrenheit
    function. When we do this, we''re basically treating the result of our Kelvin
    to Fahrenheit function as a floating-point variable of its own. This is a good
    sign that the return type we''re looking for in these functions is a `float` data
    type. What this means is when these little programs finish executing, they''re
    going to throw out a floating-point value to our `main` method, which called them.
    After we name a function, we follow it with two parentheses in the function declaration
    preceding to it. Between these parentheses, we''re going to tell our program what
    information this function is going to require to run. We do this by basically
    creating some variables, as shown in the following code block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们希望能够在我们的开尔文到华氏度函数上调用`fToC`。当我们这样做时，我们基本上将我们的开尔文到华氏度函数的结果视为自己的浮点变量。这表明我们在这些函数中寻找的返回类型是`float`数据类型。这意味着当这些小程序执行完毕时，它们将向我们调用它们的`main`方法抛出一个浮点值。在命名函数之后，我们在其前面的函数声明中跟随两个括号。在这些括号之间，我们将告诉我们的程序这个函数需要运行的信息。我们通过基本上创建一些变量来做到这一点，如下面的代码块所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''re going to want a variable that I''ll just call `fVal` because we''re
    starting with the Fahrenheit value. We also need to tell our program before each
    input variable what type of information that''s going to be; this way people won''t
    be able to improperly call our function and pass in something like a string, which
    wouldn''t make any sense:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个变量，我将其称为`fVal`，因为我们从华氏度值开始。在每个输入变量之前，我们还需要告诉我们的程序那将是什么类型的信息；这样人们就无法不正确地调用我们的函数并传递诸如字符串之类的东西，这是毫无意义的。
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, we''re going to tell our function that in order to run, it needs to be
    called with a `float` piece of information given as input. In the functions that
    we wrote before, they actually existed in the program. You''ll see that we did
    this: we provided `inputValue`, or the value of the temperature the user initially
    gave us, as input to these functions.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们要告诉我们的函数，为了运行，它需要以给定的`float`信息作为输入进行调用。在我们之前编写的函数中，它们实际上存在于程序中。您会看到我们这样做：我们将`inputValue`或用户最初给我们的温度值的值作为这些函数的输入。
- en: 'Now, we need our `fToC` function, our Fahrenheit to Celsius function, to perform
    some computation on this `fVal` variable in the code, which will contain the user-inputted
    temperature value. Since we''re going from Fahrenheit to Celsius, we can just
    copy and paste the string from the top of the program again and substitute the
    `fVal` with `t`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要我们的`fToC`函数，我们的华氏度到摄氏度函数，在代码中对`fVal`变量执行一些计算，其中将包含用户输入的温度值。由于我们从华氏度到摄氏度，我们可以只需复制并粘贴程序顶部的字符串，并将`fVal`替换为`t`：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, it may be tempting for us to ask our function to perform this operation
    to change the value of this variable. While we''re certainly allowed to do that,
    it''s not going to give us the result that we require. When our program hits the
    `inputValue = fToC(inputValue);` code line and runs our `fToC` function, giving
    `inputValue` as its input variable, this variable is not going to actually drop
    down to our function''s line of code. Rather, Java is simply going to copy the
    value of `inputValue` and store it in our new variable, as you can see in the
    following block of code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可能会诱惑我们的函数执行此操作来更改此变量的值。虽然我们当然可以这样做，但这不会给我们带来我们需要的结果。当我们的程序执行`inputValue
    = fToC(inputValue);`这行代码并运行我们的`fToC`函数时，将`inputValue`作为其输入变量，这个变量实际上不会降到我们函数的代码行中。相反，Java只是复制`inputValue`的值并将其存储在我们的新变量中，如下面的代码块所示：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So changes we make to this `fVal` variable will not map to our `inputValue`
    variable. Fortunately, we explicitly change the value of `inputValue` to be whatever
    this function we''re writing now returns. Once we''re ready to quit the execution
    of a function, we can have it throw out any value that''s equivalent to the value
    type that we told Java this function would return. We do this with the `return`
    keyword, followed by any statement that computes to, in our case, a floating-point
    value. So, when our `fToC` function runs on `inputValue`, it will print out a
    floating-point number equivalent to the Celsius value of our initial Fahrenheit
    value stored in the input variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对这个`fVal`变量所做的更改不会映射到我们的`inputValue`变量。幸运的是，我们明确地将`inputValue`的值更改为我们现在编写的函数返回的值。一旦我们准备退出函数的执行，我们可以让它丢弃任何与我们告诉Java此函数将返回的值类型相等的值。我们使用`return`关键字来做到这一点，后面跟着计算为我们的情况下浮点值的任何语句。因此，当我们的`fToC`函数在`inputValue`上运行时，它将打印出与存储在输入变量中的初始华氏值等效的浮点数：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Once we''ve written one of these functions, writing other similar functions
    becomes pretty easy. To write our Kelvin to Fahrenheit function, we''re simply
    going to do the same thing, but in this case take our Kelvin to Fahrenheit conversion
    equation and change the name of our variable. We could call it `fVal` if we wanted
    to-`kVal` is just more explanatory-and return that result:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了其中一个函数，编写其他类似的函数就变得非常容易。要编写我们的开尔文到华氏度的函数，我们只需要做同样的事情，但在这种情况下，我们需要采用我们的开尔文到华氏度转换方程并更改变量的名称。如果我们愿意，我们可以称之为`fVal`-`kVal`只是更具说明性，并返回该结果：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So that's the first half of our program where we convert whatever the user has
    given us into a Celsius value. So far, this has been much more elegant than six
    `if` statements, but we have only written half of our program.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序的第一部分，我们将用户提供的任何值转换为摄氏度值。到目前为止，这比使用六个`if`语句更加优雅，但我们只写了程序的一半。
- en: Executing the second part of the program
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行程序的第二部分
- en: 'Once we''re done with the Celsius conversion, we''ll use another `switch` statement.
    This time, we''ll use it on `outputType`, where the user has told us what temperature
    type they''d like to see the equivalent value of, or see the equivalent value
    in. Our cases are going to look very similar to the first half of our `switch`
    statement; however here instead of converting everything to Celsius, we''re always
    going to be converting from Celsius. Once again, that means case `C` can simply
    break in any instances where we''ve converted to Celsius and then we no longer
    need to convert from Celsius:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了摄氏度的转换，我们将使用另一个`switch`语句。这一次，我们将在`outputType`上使用它，用户告诉我们他们想要看到等值的温度类型，或者在哪种温度类型下看到等值。我们的情况将看起来非常类似于`switch`语句的前半部分；然而，这里我们不是将所有东西转换为摄氏度，而是总是从摄氏度转换。同样，这意味着`C`情况可以在我们转换为摄氏度的任何情况下简单地中断，然后我们不再需要从摄氏度转换：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, our explicit case here is the Celsius to Kelvin conversion. We know that
    formula, thanks to our nifty cheat sheet at the top of the code; we can build
    a function to do this pretty quick. We''ll call this function `cToK`; there''s
    our variable name, and there''s the logic:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们明确的情况是摄氏度到开尔文的转换。我们知道这个公式，多亏了我们在代码顶部的小抄；我们可以很快地构建一个函数来做到这一点。我们将这个函数称为`cToK`；这是我们的变量名，这是逻辑：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once we''ve declared our `cToK` function, we can call it on `inputValue` since
    `inputValue` now stores the modified original input value, which will be a Celsius
    number, to convert to a Kelvin value:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们声明了我们的`cToK`函数，我们可以在`inputValue`上调用它，因为`inputValue`现在存储了修改后的原始输入值，这将是一个摄氏度数字，要转换为开尔文值：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similar to the way we doubled up to convert from Kelvin to Fahrenheit to Celsius,
    when we make everything Celsius, we can get a Fahrenheit output by getting a Kelvin
    value from our Celsius value. Then, we can use the Kelvin to Fahrenheit function
    to convert this Kelvin value into a Fahrenheit one:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们将开尔文转换为华氏度再转换为摄氏度的方式，当我们将所有东西都转换为摄氏度时，我们可以通过从摄氏值获取一个开尔文值来获得一个华氏输出。然后，我们可以使用开尔文转换为华氏度的函数将这个开尔文值转换为华氏度：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is the second half of our program. Still, only two real lines of code
    that might cause anyone to pause, and they''re pretty self-explanatory. Yet, all
    of the logic and functionality of our program is still accessible to a curious
    programmer who wants to reaccess them:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们程序的第二部分。仍然只有两行真正的代码可能会让任何人停下来，它们都相当容易理解。然而，我们程序的所有逻辑和功能对于一个好奇的程序员来说仍然是可访问的，他想要重新访问它们：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Final touch to the program
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 程序的最后一步
- en: 'We can finish up our program here using `println` to throw out `inputValue`,
    which should now contain the proper conversion. Let''s run this program and give
    some input and output to see how we did:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `println` 来结束我们的程序，输出 `inputValue`，它现在应该包含正确的转换。让我们运行这个程序，输入一些值并输出，看看我们的表现如何：
- en: '![](img/3b90ab5d-c1a0-43a7-8c85-c9edc4df9cda.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b90ab5d-c1a0-43a7-8c85-c9edc4df9cda.png)'
- en: 'So, when we run our program, it asks what `inputType` we''re going to give
    it. Let''s give it a Fahrenheit value. Now let''s say we would like to get a Celsius
    value as the output. Let''s see what the Celsius value of `32` degrees Fahrenheit
    is. We see that the output result of `0`. The `32` degrees Fahrenheit is `0` degrees
    Celsius, so that''s a good sign. Let''s try some more edge cases. If we attempt
    to convert Celsius to Celsius, we get the same value as shown in the following
    screenshot, which is what we would expect:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们运行我们的程序时，它会询问我们要给它什么`inputType`。让我们给它一个华氏值。现在让我们说我们想要得到一个摄氏值作为输出。让我们看看`32`华氏度对应的摄氏值是多少。我们看到输出结果是`0`。`32`华氏度是`0`摄氏度，这是一个好迹象。让我们尝试一些更极端的情况。如果我们试图将摄氏度转换为摄氏度，我们得到的值与下面的截图中显示的值相同，这是我们所期望的：
- en: '![](img/470f1c0c-7f71-4fc9-a40f-09378870ebfa.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/470f1c0c-7f71-4fc9-a40f-09378870ebfa.png)'
- en: 'Let''s see what the Fahrenheit value of `1` degrees Kelvin is:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`1`开尔文度对应的华氏值是多少：
- en: '![](img/ab570c83-a707-4b65-952f-471542ba6293.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab570c83-a707-4b65-952f-471542ba6293.png)'
- en: And the good news is that's also the expected value in the preceding screenshot.
    We've employed functions to make an otherwise very complex and difficult-to-read
    program much more manageable. The program we've written here is somewhat complicated.
    It does some math and multifunction statements, so if you weren't 100 percent
    with us the first time through, I encourage you to go back and check what tripped
    you up. There's also other ways to approach this problem, and if you had a stroke
    of inspiration, I encourage you to explore it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，这也是前面截图中的预期值。我们使用函数使一个本来非常复杂和难以阅读的程序变得更加可管理。我们在这里编写的程序有些复杂。它进行了一些数学和多功能语句，所以如果你第一次没有完全理解，我鼓励你回去检查是什么让你困惑。还有其他方法来解决这个问题，如果你有灵感，我鼓励你去探索一下。
- en: Advanced Java functions
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Java函数
- en: 'In this section, I''d like you to take a deeper look into Java methods and
    also learn some really valuable things about how programming languages think about
    and manipulate information. To help us do this, I''d like to run an experiment
    of sorts, and to start that experiment off, I''ve written a really basic Java
    program:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我希望你深入了解Java方法，并学习一些关于编程语言如何思考和操作信息的非常有价值的东西。为了帮助我们做到这一点，我想进行一种实验，并且为了开始这个实验，我写了一个非常基本的Java程序：
- en: '[PRE27]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At the core of this Java program is the `magic` method, which is user-defined
    following the `main` method. When we come across a new Java method, there''s three
    real things we should notice about it:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Java程序的核心是`magic`方法，它是在`main`方法之后用户自定义的。当我们遇到一个新的Java方法时，有三件事情我们应该注意：
- en: First, we should ask, "what are its input values?". In the case of our `magic`
    method, it expects only a single integer as input.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该问，“它的输入值是什么？”在我们的`magic`方法中，它只期望一个整数作为输入。
- en: Then, we probably want to ask, "what does this method return?". In our case,
    the method is marked to return `void`. Void methods don't actually return any
    values at all; they simply execute their code and finish. You'll notice that when
    we reference `magic` in the main portion of our program, we don't attempt to store
    its return value in any location. This is, of course, because there would be no
    return value to store.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可能想问，“这个方法返回什么？”。在我们的情况下，该方法标记为返回`void`。Void方法实际上根本不返回任何值；它们只是执行它们的代码并完成。您会注意到，当我们在程序的主要部分引用`magic`时，我们并没有尝试将其返回值存储在任何位置。这是因为当然没有返回值可以存储。
- en: Then, the third thing to notice about our method is "what does it do?". In the
    case of our `magic` method, we simply take the value that we've gotten as `input`
    and increase that value by `10`.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，关于我们的方法要注意的第三件事是“它做什么？”。在我们的`magic`方法的情况下，我们只是取得我们作为`input`得到的值，并将该值增加`10`。
- en: What I'd like to ask you to do right now is take a minute and just look at this
    program, and try and figure out exactly what the program's output will be when
    we reach this `println` statement. The challenging question here is what happens
    to the value of the variable `x` when we run the `magic(x)` line of code and call
    our `magic` method? Does the variable `x` remain unaffected when we pass it as
    a value to the `magic` method or does the variable `x` get modified by the input
    line of the code in the `magic` method such that instead of printing out `5`,
    we print out the value `15`?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我想现在要求你做的是花一分钟时间，仔细看看这个程序，并尝试弄清楚当我们到达这个`println`语句时，程序的输出将是什么。这里的挑战性问题是当我们运行`magic(x)`代码行并调用我们的`magic`方法时，变量`x`的值会发生什么变化？当我们将其作为值传递给`magic`方法时，变量`x`是否保持不变，或者变量`x`是否被`magic`方法中的输入代码行修改，以至于我们打印出`15`而不是`5`的值？
- en: 'To answer this question, we simply have to run our program, and if we do this,
    we will see that we get the value of `5`, letting us know that running the `magic`
    method did not modify the value of the variable `x` within the context of our
    main method:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，我们只需要运行我们的程序，如果我们这样做，我们将看到我们得到了`5`的值，这让我们知道运行`magic`方法并没有修改主方法中变量`x`的值：
- en: '![](img/d0223233-6d3c-4f27-845e-94b6d995826e.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0223233-6d3c-4f27-845e-94b6d995826e.png)'
- en: In fact, we'll get the same output if we never run the `magic` method at all.
    So what does this tell us? This gives us a very important insight into how Java
    handles method input. To fully understand what's going on here, we need to take
    a deeper look into how Java variables operate.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们根本不运行`magic`方法，我们将得到相同的输出。那么这告诉我们什么？这为我们提供了一个非常重要的见解，即Java如何处理方法输入。要完全理解这里发生了什么，我们需要更深入地了解Java变量的操作。
- en: Operating java variables
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作java变量
- en: 'The following is a representation of the information stored by our variable
    `x`, that is, the variable in the `main` method of our Java program:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的变量`x`存储的信息的表示，即我们Java程序的`main`方法中的变量：
- en: '![](img/c151dbad-8fa2-482a-8226-0c0cbddfbb44.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c151dbad-8fa2-482a-8226-0c0cbddfbb44.png)'
- en: 'You''ll notice that this variable has three core components; let''s go through
    them quickly:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个变量有三个核心组件；让我们快速浏览一下：
- en: On the left-hand side, I put this variable's name, which is the keyword that
    we use to reference it within the scope, and a memory location. Our variables
    point to a memory location, and in this memory location, we store the variable's
    value.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在左侧，我放置了这个变量的名称，这是我们在范围内引用它所使用的关键字，以及一个内存位置。我们的变量指向一个内存位置，在这个内存位置中，我们存储变量的值。
- en: We can think of the name and memory location as being very static; they're not
    really going to change for this individual variable identifier throughout the
    course of our program's execution. However, we can, and often do, freely change
    the value stored in the variable's referenced memory location.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将名称和内存位置视为非常静态的；在我们程序执行过程中，这个单独的变量标识符不会真正改变。然而，我们可以自由地更改变量引用的内存位置中存储的值。
- en: 'So why is this important? Well, over the course of our program, we''re going
    to have to translate the information stored in our variable `x` into the information
    stored in the variable input that our `magic` method attempted to make use of.
    If we take a good look at how variables are set up, we quickly see that there''s
    two possible ways to go about doing this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 那么这为什么重要呢？好吧，在我们的程序过程中，我们将不得不将存储在变量`x`中的信息转换为我们的`magic`方法试图使用的变量输入中存储的信息。如果我们仔细看看变量的设置方式，我们很快就会发现有两种可能的方法来做到这一点：
- en: First, we can simply create a brand new variable named `input` with its own
    unique memory location, then simply place the same value that we found in the
    memory location referenced by `x` as the value in that memory location:![](img/a1dc02e8-ffbb-4715-80f2-2b985061044c.png)
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们可以简单地创建一个名为`input`的全新变量，具有其自己独特的内存位置，然后简单地将我们在`x`引用的内存位置中找到的相同值放置在该内存位置中的值中：![](img/a1dc02e8-ffbb-4715-80f2-2b985061044c.png)
- en: When we pass the variable `x` to a method, which is the technique that Java
    uses to create the variable `input`, we can say that Java has passed our variable
    `x` by value. This is because only the value is preserved across the creation
    of the new variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将变量`x`传递给一个方法时，这是Java用来创建变量`input`的技术，我们可以说Java通过值传递了我们的变量`x`。这是因为只有值在创建新变量时被保留。
- en: Another option would be for us to create a brand new variable `input`, but instead
    of simply copying the value from the variable `x` to the variable `input`, we
    could cause `input` to reference the same memory location as `x` does. This would
    be called passing the variable `x` by reference. In this case, because both `x`
    and `input` would share a memory location where they would store their values,
    modifying the value of the variable `input` would also modify the value of the
    variable `x`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选项是我们创建一个全新的变量`input`，但是我们不仅仅是将变量`x`的值复制到变量`input`，我们可以使`input`引用与`x`相同的内存位置。这将被称为通过引用传递变量`x`。在这种情况下，因为`x`和`input`都共享一个内存位置来存储它们的值，修改变量`input`的值也会修改变量`x`的值。
- en: So, given what you've just learned about Java variables and taking into account
    that executing the `magic` method on `magic(x)` code line does not modify the
    value of the variable `x`, we can correctly conclude that Java chooses to pass
    variables to its methods by value rather than by reference.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据您刚刚了解的关于Java变量的知识，并考虑到在`magic(x)`代码行上执行`magic`方法不会修改变量`x`的值，我们可以正确地得出结论，Java选择通过值而不是通过引用将变量传递给其方法。
- en: However, that's not really the end of the story, or rather, this fact has implications
    that might not be immediately apparent to us. If we were to rewrite our program
    so that our `magic` method would take character input, boolean input, or really
    any other primitive type, we would see the same behavior that we've been seeing
    already. Even if we modify the value of this `input` variable within the scope
    of the `magic` method, it would not modify the value of the variable `x` within
    the scope of the `main` method. So, things are not always so simple.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是故事的结束，或者说，这个事实可能对我们来说并不立即显而易见。如果我们重写我们的程序，使我们的`magic`方法接受字符输入、布尔输入或任何其他原始类型，我们将看到与我们已经看到的相同的行为。即使在`magic`方法的范围内修改此`input`变量的值，也不会修改`main`方法的范围内的变量`x`的值。所以，事情并不总是那么简单。
- en: Using variables in the program
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在程序中使用变量
- en: 'To see this, let''s create a brand new method, and in its declaration, we''ll
    have it the same as our existing `magic` method. However, instead of taking a
    single integer as input, we''ll provide it as input in the integer array:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到这一点，让我们创建一个全新的方法，在它的声明中，我们将它与我们现有的`magic`方法相同。但是，我们将以整数数组的形式提供它作为输入：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Remember that our array will be named as a single variable, so all we need to
    do to let Java know that we'd like to pass an array to the function is inform
    it that the variable being given is an array of a certain type. You'll also notice
    that we now have two methods by the name of `magic` within our program. This is
    called **method overloading**, and it's perfectly legitimate to do this as long
    as Java has a way of telling the methods apart. In this case, Java can tell the
    methods apart because both the methods are going to be given different objects
    as input.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们的数组将被命名为一个单一的变量，所以我们需要做的就是让Java知道我们想要将一个数组传递给函数，通知它给定的变量是某种类型的数组。您还会注意到，我们现在在程序中有两个名为`magic`的方法。这被称为**方法重载**，只要Java有办法区分这些方法，这样做就是完全合法的。在这种情况下，Java可以区分这些方法，因为这两个方法将被赋予不同的对象作为输入。
- en: 'One of our `magic` methods will execute if the input given to the `magic` call
    is a single integer, and our new `magic` method will execute if the input given
    to the method is an array of integers. Now, let''s write a quick `for` loop so
    that our new `magic` method will increment the value of every integer contained
    within our input array by `10`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给`magic`调用的输入是单个整数，则我们的`magic`方法之一将执行，如果给方法的输入是整数数组，则我们的新`magic`方法将执行。现在，让我们编写一个快速的`for`循环，这样我们的新`magic`方法将将输入数组中的每个整数的值增加`10`：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is extremely similar to the `magic` method we wrote originally, except
    that instead of operating on a single integer, it's going to operate on any number
    of them. However, something that may appear weird is going to happen when we modify
    our `main` method to utilize this new implementation of the `magic` method. In
    order to make this happen, we need to make a few quick modifications to our program.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们最初编写的`magic`方法非常相似，只是它不是操作单个整数，而是操作任意数量的整数。然而，当我们修改我们的`main`方法以利用`magic`方法的新实现时，可能会发生一些奇怪的事情。为了实现这一点，我们需要对我们的程序进行一些快速修改。
- en: 'Let''s change our variable `x` from an integer to an integer array so that
    our program will know how to utilize the newly written `magic` method, which runs
    when we give an integer array as input:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将变量`x`从整数更改为整数数组，这样我们的程序将知道如何利用新编写的`magic`方法，当我们给定整数数组作为输入时，它将运行：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We''ll also need to modify our `println` statement to make use of `Arrays.toString`
    so that we display the value stored in the `x` array properly. We''ll import `java.util`
    so that Java knows about the `Arrays` library:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改我们的`println`语句，以利用`Arrays.toString`来正确显示`x`数组中存储的值。我们将导入`java.util`，以便Java知道`Arrays`库：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now it''s time to ask ourselves another question: when we run the `magic` function
    on an integer array, will we see the same results we saw when we ran the `magic`
    function on a single integer value, a primitive type? To answer this question,
    all we need to do is run our program, and we''ll very quickly see that the output,
    or the final values, stored in the `x` array are not the same values that we assigned
    to the `x` array initially:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候问自己另一个问题了：当我们在整数数组上运行`magic`函数时，我们是否会看到与我们在单个整数值上运行`magic`函数时看到的相同结果，即原始类型？要回答这个问题，我们只需要运行我们的程序，我们很快就会看到，存储在`x`数组中的输出或最终值与我们最初分配给`x`数组的值不同：
- en: '![](img/0496807d-3c0e-4732-88a6-d5d773dc9050.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0496807d-3c0e-4732-88a6-d5d773dc9050.png)'
- en: 'This lets us know that our `magic` method is indeed modifying these values.
    So this is kind of weird. Why would our `magic` method operate differently depending
    on whether we gave it a single primitive type as input or an array of primitive
    types as input? To answer this question, let''s take a look at the variable `x`
    when it''s declared to be an array of integers as opposed to just a single integer
    as we had it before:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们知道我们的`magic`方法确实修改了这些值。这有点奇怪。为什么我们的`magic`方法会根据我们给它的是单个原始类型还是原始类型数组而有不同的操作？为了回答这个问题，让我们看看当变量`x`被声明为整数数组而不是我们之前的单个整数时会发生什么：
- en: '![](img/bcccfc80-e74f-404e-8fa1-3c2a3a78c4da.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bcccfc80-e74f-404e-8fa1-3c2a3a78c4da.png)'
- en: Note that `x` as an array of integers, as opposed to a single primitive type,
    still gets a name and memory location to identify it and a place where it can
    live; however, its value field looks drastically different than it did before.
    When `x` was just an integer, we could get away with simply storing an explicit
    integer in the value field of `x`, but as an array, `x` means to be able to reference
    a number of different values; that's what makes it a data structure. To make this
    happen, arrays-and really every other element more complicated than a primitive-point
    to a location in memory as opposed to a single explicit value. For arrays, all
    we need to do is point to the 0 index of the array in memory. Then, by following
    from that index, we can store a number of different values that our variable `x`
    knows how to access. So why is this important?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`x`作为一个整数数组，而不是单个原始类型，仍然具有名称和内存位置来标识它以及它可以存在的位置；但是，它的值字段看起来与以前大不相同。当`x`只是一个整数时，我们可以简单地将一个显式整数存储在`x`的值字段中，但是作为数组，`x`意味着能够引用许多不同的值；这就是它成为数据结构的原因。为了实现这一点，数组-实际上每个比原始类型更复杂的元素-指向内存中的一个位置，而不是单个显式值。对于数组，我们只需要指向内存中数组的0索引。然后，通过从该索引开始，我们可以存储许多不同的值，我们的变量`x`知道如何访问。那么这为什么重要呢？
- en: Understanding passing parameters
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解传递参数
- en: 'Well, let''s take a look at what happens when we pass `x` to a method by value.
    As we know, when we pass a variable by value, we''re telling Java to create a
    new variable in the context of the method that''s going to have its own unique
    name and memory location:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们看看当我们按值传递`x`到方法时会发生什么。我们知道，当我们按值传递一个变量时，我们告诉Java在方法的上下文中创建一个新变量，该变量将具有自己独特的名称和内存位置：
- en: '![](img/4b8e10e2-4b1b-4d2e-83ab-b27a38e1475d.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b8e10e2-4b1b-4d2e-83ab-b27a38e1475d.png)'
- en: However, this new variable-in our case, `input`-takes the value from the old
    variable as its own. When we were working with primitive types, these values were
    completely independent, but now both `input` and `x` have the values of the same
    location in memory. So, while modifying the value of input would not change the
    value of `x`, modifying the location of memory that input points to would still
    change that location of memory when `x` looks at it as well.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的例子中，这个新变量-`input`-获取了旧变量的值作为自己的值。当我们处理原始类型时，这些值是完全独立的，但现在`input`和`x`都具有相同内存位置的值。因此，修改输入的值不会改变`x`的值，但修改输入指向的内存位置仍会改变`x`查看时的内存位置。
- en: 'Within the context of a method, if we reference an input variable explicitly
    and then modify that variable, we''re going to be modifying only the variable
    within the context of the function, as we did in our first `magic` method. But,
    if we have to take an additional step to access the value that we''re modifying,
    as we have to do when declaring an index of an array, then we''ll probably have
    to modify it via a location of memory or by reference. In this instance, we will
    potentially affect the variable that provided the value for our function variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的上下文中，如果我们明确引用一个输入变量，然后修改该变量，我们将只修改函数上下文中的变量，就像我们在第一个`magic`方法中所做的那样。但是，如果我们必须采取额外的步骤来访问我们正在修改的值，就像我们在声明数组的索引时必须做的那样，那么我们可能必须通过内存位置或引用来修改它。在这种情况下，我们可能会影响为我们函数变量提供值的变量：
- en: '[PRE32]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If our `magic` function that took an array simply attempts to set the value
    of our integer array to a brand new set of integer values with an all-new starting
    memory location, we would see that we would no longer be modifying the value of
    `x` when we run this function on it:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的接受数组的`magic`函数尝试将我们的整数数组的值设置为全新的整数值集合，并具有全新的起始内存位置，我们会发现当我们在其上运行此函数时，我们将不再修改`x`的值：
- en: '![](img/3917bd79-b30a-405d-94ea-38d819081037.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3917bd79-b30a-405d-94ea-38d819081037.png)'
- en: This is because the creation of a new integer array caused us to explicitly
    change the value of input. After this line of code, `input` and `x` no longer
    share a value anymore. Thank you very much for your time. I hope you learned something.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为创建一个新的整数数组导致我们明确改变了输入的值。在这行代码之后，`input`和`x`不再共享值。非常感谢您的时间。希望您学到了一些东西。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Are you still with us? If so, congratulations. We started with some of the basic
    Java functions, such as methods, and then moved on to understand advanced Java
    functions. That's some complicated stuff we just went over. As you become a more
    experienced programmer, you'll begin to internalize concepts such as these and
    you won't have to really think about them explicitly when you're writing day-to-day
    code. For now, though, there's some logic shortcuts we can use to keep from getting
    too tripped up.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您还在吗？如果是的，恭喜。我们从一些基本的Java函数开始，比如方法，然后继续理解高级Java函数。我们刚刚讨论了一些复杂的东西。随着您成为更有经验的程序员，您将开始内化这些概念，当您编写日常代码时，您不必明确考虑它们。不过，现在有一些逻辑快捷方式可以帮助我们避免太多的困扰。
- en: In the next chapter, you will learn about modeling using object-oriented Java
    programs in detail.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将详细了解使用面向对象的Java程序进行建模。
