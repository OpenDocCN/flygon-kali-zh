- en: Chapter 4. Writing and Using Declaration Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。编写和使用声明文件
- en: One of the most appealing facets of JavaScript development is the myriad of
    external JavaScript libraries that have already been published, such as jQuery,
    Knockout, and Underscore. The TypeScript designers knew that introducing "syntactic
    sugar" to the TypeScript language would bring a range of benefits to the developer
    experience. These benefits include IDE features such as Intellisense, as well
    as detailed compile time error messages. We have already seen how to use this
    syntax for most of the TypeScript language features such as classes, interfaces,
    and generics, but how do we apply this "sugar" to existing JavaScript libraries?
    The answer is relatively simple—declaration files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript开发最吸引人的一个方面是已经发布的大量外部JavaScript库，比如jQuery、Knockout和Underscore。TypeScript的设计者知道，向TypeScript语言引入“语法糖”将为开发人员带来一系列好处。这些好处包括IDE功能，如智能感知，以及详细的编译时错误消息。我们已经看到了如何将这种语法应用于大多数TypeScript语言特性，比如类、接口和泛型，但是我们如何将这种“糖”应用于现有的JavaScript库呢？答案相对简单——声明文件。
- en: A declaration file is a special type of file used by the TypeScript compiler.
    It is marked with a `.d.ts` extension, and is then used by the TypeScript compiler
    within the compilation step. Declaration files are similar to header files used
    in other languages; they simply describe the syntax and structure of available
    functions and properties, but do not provide an implementation. Declaration files,
    therefore, do not actually generate any JavaScript code. They are there simply
    used to provide TypeScript compatibility with external libraries, or to fill in
    the gaps for JavaScript code that TypeScript does not know about. In order to
    use any external JavaScript library within TypeScript, you will need a declaration
    file.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文件是TypeScript编译器使用的一种特殊类型的文件。它以`.d.ts`扩展名标记，然后在编译步骤中由TypeScript编译器使用。声明文件类似于其他语言中使用的头文件；它们只是描述可用函数和属性的语法和结构，但不提供实现。因此，声明文件实际上不会生成任何JavaScript代码。它们只是用来提供TypeScript与外部库的兼容性，或者填补TypeScript不了解的JavaScript代码的空白。为了在TypeScript中使用任何外部JavaScript库，您将需要一个声明文件。
- en: In this chapter, we will explore declaration files, show the reasoning behind
    them, and build one based on some existing JavaScript code. If you are familiar
    with declaration files and how to use them, then you may be interested in the
    *Declaration Syntax Reference* section. This section is designed as a quick reference
    guide to the module definition syntax. Since writing declaration files is a rather
    small part of TypeScript development, we do not write them very often. The *Declaration
    Syntax Reference* section shows sample declaration file syntax for the equivalent
    JavaScript syntax.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨声明文件，展示它们背后的原因，并基于一些现有的JavaScript代码构建一个声明文件。如果您熟悉声明文件以及如何使用它们，那么您可能会对*声明语法参考*部分感兴趣。本节旨在作为模块定义语法的快速参考指南。由于编写声明文件只是TypeScript开发的一小部分，我们并不经常编写它们。*声明语法参考*部分展示了等效JavaScript语法的示例声明文件语法。
- en: Global variables
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局变量
- en: Most modern websites use some sort of server engine to generate the HTML for
    their web pages. If you are familiar with the Microsoft stack of technologies,
    then you would know that ASP.NET MVC is a very popular server-side engine, used
    to generate HTML pages based on master pages, partial pages, and MVC views. If
    you are a Node developer, then you may be using one of the popular Node packages
    to help you construct web pages through templates, such as Jade or Embedded JavaScript
    (EJS).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代网站都使用某种服务器引擎来生成它们的网页HTML。如果您熟悉微软技术栈，那么您会知道ASP.NET MVC是一个非常流行的服务器端引擎，用于基于主页面、部分页面和MVC视图生成HTML页面。如果您是Node开发人员，那么您可能正在使用其中一个流行的Node包来帮助您通过模板构建网页，比如Jade或嵌入式JavaScript（EJS）。
- en: 'Within these templating engines, you may sometimes need to set JavaScript properties
    on the HTML page as a result of your backend logic. As an example, let''s assume
    that you keep a list of contact e-mail addresses on your backend database, and
    then surface these to your frontend HTML page through a JavaScript global variable
    named `CONTACT_EMAIL_ARRAY`. Your rendered HTML page would then include a `<script>`
    tag that contains this global variable and contact e-mail addresses. You may have
    some JavaScript that reads this array, and then renders the values in a footer.
    The following HTML sample shows what a generated script within an HTML page may
    end up looking like:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些模板引擎中，您有时可能需要根据后端逻辑在HTML页面上设置JavaScript属性。举个例子，假设您在后端数据库中保存了一组联系人电子邮件地址，然后通过名为`CONTACT_EMAIL_ARRAY`的JavaScript全局变量将其呈现到前端HTML页面上。您的渲染的HTML页面将包含一个包含这个全局变量和联系人电子邮件地址的`<script>`标签。您可能有一些JavaScript代码来读取这个数组，然后在页脚中呈现这些值。以下HTML示例显示了HTML页面中生成的脚本可能看起来像什么：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This HTML has a script block and within this script block, some JavaScript.
    The JavaScript is simply a variable named `CONTACT_EMAIL_ARRAY` that contains
    some strings. Let''s assume that we wanted to write some TypeScript that can read
    this global variable. Consider the following TypeScript code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML文件有一个脚本块，在这个脚本块中有一些JavaScript。JavaScript只是一个名为`CONTACT_EMAIL_ARRAY`的变量，其中包含一些字符串。假设我们想编写一些TypeScript代码来读取这个全局变量。考虑以下TypeScript代码：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This code creates a class named `GlobalLogger` with a single static function
    named `logGlobalsToConsole`. The function simply iterates through the `CONTACT_EMAIL_ARRAY`
    global variable, and logs the items in the array to the console.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了一个名为`GlobalLogger`的类，其中包含一个名为`logGlobalsToConsole`的静态函数。该函数只是遍历`CONTACT_EMAIL_ARRAY`全局变量，并将数组中的项记录到控制台中。
- en: 'If we compile this TypeScript code, we will generate the following errors:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编译这段TypeScript代码，将会生成以下错误：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This error indicates that the TypeScript compiler does not know anything about
    the variable named `CONTACT_EMAIL_ARRAY`. It does not even know that it is an
    array. As this piece of JavaScript is outside any TypeScript code, we will need
    to treat it in the same way as "external" JavaScript.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表明TypeScript编译器对名为`CONTACT_EMAIL_ARRAY`的变量一无所知。它甚至不知道它是一个数组。由于这段JavaScript代码位于任何TypeScript代码之外，我们需要以与“外部”JavaScript相同的方式处理它。
- en: 'To solve our compilation problem, and make this `CONTACT_EMAIL_ARRAY` variable
    visible to TypeScript, we will need to use a declaration file. Let''s create a
    file named `globals.d.ts` and include the following TypeScript declaration within
    it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决我们的编译问题，并使`CONTACT_EMAIL_ARRAY`变量对TypeScript可见，我们需要使用一个声明文件。让我们创建一个名为`globals.d.ts`的文件，并在其中包含以下TypeScript声明：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first thing to notice is that we are using a new TypeScript keyword: `declare`.
    The `declare` keyword tells the TypeScript compiler that we want to define the
    type of something, but that the implementation of this object (or variable or
    function) will be resolved at runtime. We have declared a variable named `CONTACT_EMAIL_ARRAY`
    that is typed to be an array of strings. This `declare` keyword does two things
    for us: it allows the use of the variable `CONTACT_EMAIL_ARRAY` within TypeScript
    code, and it also strongly types this variable to be an array of strings.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们使用了一个新的TypeScript关键字：`declare`。`declare`关键字告诉TypeScript编译器，我们想要定义某个东西的类型，但这个对象（或变量或函数）的实现将在运行时解析。我们声明了一个名为`CONTACT_EMAIL_ARRAY`的变量，其类型为字符串数组。这个`declare`关键字为我们做了两件事：它允许在TypeScript代码中使用变量`CONTACT_EMAIL_ARRAY`，并且还将这个变量强类型为字符串数组。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The 1.0 version and upwards of the TypeScript compiler will scan our source
    code directory for `.d.ts` files and automatically include them in the compilation
    step. In previous versions, it was necessary to include a comment as a reference
    to these files, but this reference comment line is no longer necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器的1.0版本及更高版本将扫描我们的源代码目录以寻找`.d.ts`文件，并自动包含它们在编译步骤中。在以前的版本中，需要包含一个注释作为对这些文件的引用，但现在不再需要这个引用注释行。
- en: 'With this `globals.d.ts` file in place, our code compiles correctly. If we
    now run this in a browser, the output will be as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`globals.d.ts`文件，我们的代码可以正确编译。如果我们现在在浏览器中运行它，输出将如下所示：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, by using a declaration file named `globals.d.ts`, we have been able to describe
    the structure of an "external" JavaScript variable to the TypeScript compiler.
    This JavaScript variable is defined outside any of our TypeScript code, yet we
    are still able to work with the definition of this variable within TypeScript.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过使用名为`globals.d.ts`的声明文件，我们已经能够描述“外部”JavaScript变量的结构给TypeScript编译器。这个JavaScript变量是在我们的任何TypeScript代码之外定义的，但我们仍然能够在TypeScript中使用这个变量的定义。
- en: This is what declaration files are used for. We are basically telling the TypeScript
    compiler to use the definitions found within a declaration file within the compilation
    step, and that the actual variables themselves will only be available at runtime.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是声明文件的用途。基本上，我们告诉TypeScript编译器在编译步骤中使用声明文件中找到的定义，并且实际的变量本身只在运行时可用。
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Definition files also bring Intellisense or code completion functionality to
    our IDE for external JavaScript libraries and code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件还为我们的IDE带来了外部JavaScript库和代码的智能提示或代码补全功能。
- en: Using JavaScript code blocks in HTML
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML中使用JavaScript代码块
- en: The samples we have just seen are an example of tight coupling between the generated
    HTML content (that contains JavaScript code in script blocks) on your web page,
    and the actual running JavaScript. You may argue, however, that this is a design
    flaw. If the web page needed an array of contact e-mails, then the JavaScript
    application should simply send an AJAX request to the server for the same information
    in JSON format. While this is a very valid argument, there are cases where including
    content in the rendered HTML is actually faster.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的示例是在您的网页上生成的HTML内容（其中包含脚本块中的JavaScript代码）与实际运行的JavaScript之间紧密耦合的一个例子。然而，您可能会认为这是一个设计缺陷。如果网页需要一个联系人电子邮件数组，那么JavaScript应用程序应该简单地向服务器发送一个AJAX请求以获取相同的JSON格式信息。虽然这是一个非常合理的论点，但在某些情况下，将内容包含在呈现的HTML中实际上更快。
- en: There used to be a time where the Internet seemed to be capable of sending and
    receiving vast amounts of information in the blink of an eye. Bandwidth and speed
    on the Internet were growing exponentially, and desktops were getting larger amounts
    of RAM and faster and faster processors. As developers during this stage of the
    Internet highway, we stopped thinking about how much RAM a typical user had on
    their machine. We also stopped thinking about how much data we were sending across
    the wire. This was because Internet speeds were so fast and browser processing
    speed was seemingly limitless.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经有一个时代，互联网似乎能够在眨眼之间发送和接收大量信息。互联网的带宽和速度呈指数增长，台式机的内存和处理器速度也在不断提高。在互联网高速发展阶段，作为开发人员，我们不再考虑典型用户在其设备上拥有多少内存。我们也不再考虑我们通过网络发送了多少数据。这是因为互联网速度如此之快，浏览器处理速度似乎是无限的。
- en: Yeah, and then along came the mobile phone –and it felt like we were back in
    the 1990s -with incredibly slow Internet connections, tiny screen resolutions,
    limited processing power, very little RAM (and popular arcade gaming experiences
    like *Elevator Action*, found at [https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en](https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en).
    The point of this story is that as modern web developers, we still need to be
    mindful of browsers that run on mobile phones. These browsers are sometimes running
    on very limited Internet connections, meaning that we must carefully measure the
    size of our JavasScript libraries, JSON data, and HTML pages, to ensure that our
    applications are fast and usable, even on mobile browsers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，然后移动电话出现了，感觉就像我们回到了20世纪90年代，互联网连接非常缓慢，屏幕分辨率很小，处理能力有限，内存很少（还有像*Elevator Action*这样的流行街机游戏，可以在[https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en](https://archive.org/details/Elevator_Action_1985_Sega_Taito_JP_en)找到）。这个故事的要点是，作为现代网页开发人员，我们仍然需要注意运行在移动电话上的浏览器。这些浏览器有时在非常有限的互联网连接上运行，这意味着我们必须仔细测量我们的JavasScript库、JSON数据和HTML页面的大小，以确保我们的应用程序即使在移动浏览器上也是快速和可用的。
- en: This technique of including JavaScript variables or smaller static JSON data
    within the rendered HTML page often provides us with the fastest way to render
    a screen on an older browser, or in the modern age, a mobile phone. Many popular
    sites use this technique to quickly render the general structure of the page (header,
    side panels, footers, and so on) before the main content is delivered through
    asynchronous JSON requests. This technique works well because it renders the page
    faster and gives the user faster feedback.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染的HTML页面中包含JavaScript变量或较小的静态JSON数据的技术通常为我们提供了在旧浏览器或现代手机上快速渲染屏幕的最快方式。许多流行的网站使用这种技术在通过异步JSON请求传递主要内容之前，快速渲染页面的一般结构（标题、侧边栏、页脚等）。这种技术之所以有效，是因为它能更快地渲染页面，并为用户提供更快的反馈。
- en: Structured data
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结构化数据
- en: 'Let''s enhance this simple array of contact e-mails with a little more relevant
    data. For each of these e-mail addresses, we now want to include some text that
    we will render within the footer of our page, along with the e-mail addresses.
    Consider the following HTML code with a global variable that uses a JSON structure:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些更相关的数据增强这个简单的联系人电子邮件数组。对于这些电子邮件地址中的每一个，我们现在想要包含一些文本，我们将在页面的页脚中渲染，以及电子邮件地址。考虑以下使用JSON结构的全局变量的HTML代码：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we have defined a global variable named `CONTACT_DATA` that is an array
    of JSON objects. Each JSON object has a property named `DisplayText` and a property
    named `Email`. As we have done before, we will now need to include a definition
    of this variable in our `globals.d.ts` declaration file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`CONTACT_DATA`的全局变量，它是一个JSON对象数组。每个JSON对象都有一个名为`DisplayText`和一个名为`Email`的属性。与以前一样，我们现在需要在`globals.d.ts`声明文件中包含这个变量的定义：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We start with an interface definition named `IContactData` to represent the
    properties of an individual item in the `CONTACT_DATA` array. Each item has a
    `DisplayText` property that is of the type `string`, as well as an `Email` property
    which is also of type `string`. Our `IContactData` interface, therefore, matches
    the original object properties of a single item in the JSON array. We then declare
    a variable named `CONTACT_DATA` and set its type to be an array of the `IContactData`
    interfaces.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`IContactData`的接口定义开始，表示`CONTACT_DATA`数组中单个项目的属性。每个项目都有一个`DisplayText`属性，类型为`string`，以及一个`Email`属性，类型也为`string`。因此，我们的`IContactData`接口与JSON数组中单个项目的原始对象属性相匹配。然后，我们声明一个名为`CONTACT_DATA`的变量，并将其类型设置为`IContactData`接口的数组。
- en: 'This allows us to work with the `CONTACT_DATA` variable within TypeScript.
    Let''s now create a class to process this data, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在TypeScript中使用`CONTACT_DATA`变量。现在让我们创建一个处理这些数据的类，如下所示：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The class `ContactLogger` has a single static method named `logContactData`.
    Within this method, we loop through all of the items in the `CONTACT_DATA` array,
    using the `length` property that is inherent in all JavaScript arrays. We then
    create a variable named `contactDataItem` that is strongly typed to be of type
    `IContactData`, and assign the value of the current array item to it. Being of
    type `IContactData`, the `contactDataItem` will now have two properties, `DisplayText`
    and `Email`. We simply log these values to the console. The output of this code
    would be:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContactLogger`类有一个名为`logContactData`的静态方法。在这个方法中，我们循环遍历`CONTACT_DATA`数组中的所有项目，使用所有JavaScript数组中固有的`length`属性。然后，我们创建一个名为`contactDataItem`的变量，它的类型被强制为`IContactData`，并将当前数组项的值赋给它。作为`IContactData`类型，`contactDataItem`现在有两个属性，`DisplayText`和`Email`。我们只需将这些值记录到控制台。这段代码的输出将是：'
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing your own declaration file
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自己的声明文件
- en: In any development team, there will come a time when you will need to either
    bug-fix, or enhance a body of code that has already been written in JavaScript.
    If you are in this situation, then you would want to try and write new areas of
    code in TypeScript, and integrate them with your existing body of JavaScript.
    To do so, however, you will need to write your own declaration files for any existing
    JavaScript that you need to reuse. This may seem like a daunting and time-consuming
    task, but when you are faced with this situation, just remember to take small
    steps, and define small sections of code at a time. You will be surprised at how
    simple it really is.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何开发团队中，都会有一个时刻，你需要修复bug或增强已经编写的JavaScript代码。如果你处于这种情况，那么你会想尝试用TypeScript编写新的代码，并将其与现有的JavaScript代码集成。然而，为了这样做，你需要为任何需要重用的现有JavaScript编写自己的声明文件。这可能看起来是一项令人望而却步且耗时的任务，但当你面对这种情况时，只需记住采取小步骤，一次定义一小部分代码。你会惊讶地发现它实际上是多么简单。
- en: 'In this section, let''s assume that you need to integrate an existing helper
    class—one that is reused across many projects, is well-tested, and is a development
    team standard. This class has been implemented as a JavaScript closure as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，让我们假设您需要集成一个现有的辅助类——一个在许多项目中重复使用、经过充分测试并且是开发团队标准的类。这个类已经被实现为一个JavaScript闭包，如下所示：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This JavaScript code snippet defines a JavaScript object named `ErrorHelper`
    that has two methods. The `containsErrors` method takes an object named `response`
    as an argument, and tests to see whether it has a property called `responseText`.
    If it does, it then checks to see whether the `responseText` property itself has
    a property named `failure`. If this `failure` property is a string containing
    the text `"true"`, or if the `failure` property is a boolean with the value `true`,
    then this function returns `true`; in other words, we are evaluating the `response.responseText.failure`
    property. The `ErrorHelper` closure also has a function called `trace` that can
    be called with a string, or a response object similar to what the `containsErrors`
    function is expecting.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JavaScript代码片段定义了一个名为`ErrorHelper`的JavaScript对象，它有两个方法。`containsErrors`方法以一个名为`response`的对象作为参数，并测试它是否有一个名为`responseText`的属性。如果有，它然后检查`responseText`属性本身是否有一个名为`failure`的属性。如果这个`failure`属性是一个包含文本`"true"`的字符串，或者`failure`属性是一个值为`true`的布尔值，那么这个函数返回`true`；换句话说，我们正在评估`response.responseText.failure`属性。`ErrorHelper`闭包还有一个名为`trace`的函数，可以用一个字符串或类似`containsErrors`函数期望的响应对象来调用。
- en: 'Unfortunately, this `ErrorHelper` function is missing a key piece of documentation.
    What is the structure of the object being passed into these two methods, and what
    properties does it have? Without some form of documentation, we are forced to
    reverse engineer the code to determine what the structure of the `response` object
    looks like. If we can find some sample usages of the `ErrorHelper` class, this
    may help us to guess this structure. As an example of how this `ErrorHelper` is
    used, consider the following JavaScript code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个`ErrorHelper`函数缺少关键的文档部分。被传递到这两个方法中的对象的结构是什么，它有哪些属性？没有任何形式的文档，我们被迫反向工程代码来确定`response`对象的结构是什么样的。如果我们能找到`ErrorHelper`类的一些样本用法，这可能会帮助我们猜测这个结构。作为这个`ErrorHelper`的用法示例，考虑以下JavaScript代码：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we start with a variable named `failureMessage` that has a single property
    `reponseText`. The `responseText` property in turn has two child properties: `failure`
    and `errorMessage`. Our next variable `failureMessageString` has the same structure,
    but defines the `responseText.failure` property to be a string, instead of a boolean
    value. Finally, our `successMessage` object just defines the `responseText.failure`
    property to be `false`, but it does not have an `errorMessage` property.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先有一个名为`failureMessage`的变量，它有一个名为`responseText`的属性。`responseText`属性又有两个子属性：`failure`和`errorMessage`。我们的下一个变量`failureMessageString`具有相同的结构，但将`responseText.failure`属性定义为字符串，而不是布尔值。最后，我们的`successMessage`对象只定义了`responseText.failure`属性为`false`，但它没有`errorMessage`属性。
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In JavaScript JSON format, property names are required to have quotes around
    them, whereas in JavaScript these optional. Therefore, the structure `{"failure"
    : true}` is syntactically equivalent to the structure `{failure : true}`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '在JavaScript的JSON格式中，属性名需要用引号括起来，而在JavaScript中这是可选的。因此，结构`{"failure" : true}`在语法上等同于结构`{failure
    : true}`。'
- en: 'The last couple of lines of the preceding code snippet show how the `ErrorHelper`
    closure is used. All we need to do is call the `ErrorHelper.containsErrors` method
    with our variable, and if the result is `true`, log the message to the console
    via the `ErrorHelper.trace` function. Our output would be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的最后几行显示了`ErrorHelper`闭包的使用方式。我们只需要用我们的变量调用`ErrorHelper.containsErrors`方法，如果结果是`true`，则通过`ErrorHelper.trace`函数将消息记录到控制台。我们的输出将如下所示：
- en: '![Writing your own declaration file](img/9665OS_04_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![编写自己的声明文件](img/9665OS_04_01.jpg)'
- en: ErrorHelper console output
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ErrorHelper控制台输出
- en: The module keyword
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块关键字
- en: 'To test this JavaScript `ErrorHelper` closure using TypeScript, we will need
    an HTML page that includes both the `ErrorHelper.js` file, and a TypeScript generated
    JavaScript file. Assuming that our TypeScript file is called `ErrorHelperTypeScript.ts`,
    our HTML page would then be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用TypeScript测试这个JavaScript的`ErrorHelper`闭包，我们需要一个包含`ErrorHelper.js`文件和TypeScript生成的JavaScript文件的HTML页面。假设我们的TypeScript文件叫做`ErrorHelperTypeScript.ts`，那么我们的HTML页面将如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This HTML is very simple, and includes both the existing `ErrorHelper.js` JavaScript
    file, as well as the TypeScript generated `ErrorHelperTypeScript.js` file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML非常简单，包括了现有的`ErrorHelper.js` JavaScript文件，以及TypeScript生成的`ErrorHelperTypeScript.js`文件。
- en: 'Within the `ErrorHelperTypeScript.ts` file, let''s use the `ErrorHelper` as
    follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ErrorHelperTypeScript.ts`文件中，让我们如下使用`ErrorHelper`：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code snippet shows a stripped down version of our original JavaScript
    sample. In fact, we can just copy and paste the original JavaScript code into
    our TypeScript file. We first create a `failureMessage` object with the correct
    properties, and then simply call the `ErrorHelper.containsErrors` method, and
    the `ErrorHelper.trace` method. If we were to compile our TypeScript file at this
    stage, we would receive the following error:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码片段展示了我们原始JavaScript样本的简化版本。实际上，我们可以直接将原始JavaScript代码复制粘贴到我们的TypeScript文件中。我们首先创建一个具有正确属性的`failureMessage`对象，然后简单地调用`ErrorHelper.containsErrors`方法和`ErrorHelper.trace`方法。如果我们在这个阶段编译我们的TypeScript文件，我们将收到以下错误：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This error is indicating that there is no valid TypeScript type named `ErrorHelper`,
    even though we have the full source of `ErrorHelper` in our JavaScript file. TypeScript
    by default, will look through all the TypeScript files in our project to find
    class definitions, but it will not parse JavaScript files. We will need a new
    TypeScript definition file in order to correctly compile this code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误表明，虽然我们在JavaScript文件中有`ErrorHelper`的完整源代码，但没有有效的TypeScript类型名为`ErrorHelper`。默认情况下，TypeScript会查找项目中所有的TypeScript文件来找到类定义，但不会解析JavaScript文件。为了正确编译这段代码，我们需要一个新的TypeScript定义文件。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This definition file is not included in the HTML file at all; it is only used
    by the TypeScript compiler and does not generate any JavaScript.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义文件根本没有包含在HTML文件中；它只被TypeScript编译器使用，不会生成任何JavaScript。
- en: Without a set of helpful documentation on our `ErrorHelper` class, we will need
    to reverse-engineer a TypeScript definition purely by reading the source code.
    This is obviously not an ideal situation, and is not recommended, but at this
    stage, it is all we can do. In these situations, the best starting point is simply
    to look at the usage samples and work our way up from there.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ErrorHelper`类上没有一套有用的文档，我们需要通过阅读源代码来纯粹地逆向工程一个TypeScript定义。这显然不是一个理想的情况，也不推荐，但在这个阶段，这是我们能做的一切。在这些情况下，最好的起点就是简单地查看用法示例，然后从那里开始。
- en: 'Looking at the usage of the `ErrorHelper` closure in JavaScript, there are
    two key pieces that should be included in our declaration file. The first is a
    set of function definitions for the `containsErrors` and `trace` functions. The
    second is a set of interfaces to describe the structure of the `response` object
    that the `ErrorHelper` closure relies upon. Let''s start with the function definitions,
    and create a new TypeScript file named `ErrorHelper.d.ts` with the following code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看JavaScript中`ErrorHelper`闭包的用法，我们应该在我们的声明文件中包含两个关键部分。第一个是`containsErrors`和`trace`函数的一组函数定义。第二个是一组接口，用于描述`ErrorHelper`闭包依赖的`response`对象的结构。让我们从函数定义开始，创建一个名为`ErrorHelper.d.ts`的新的TypeScript文件，其中包含以下代码：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This declaration file starts with the `declare` keyword that we have seen before,
    but then uses a new TypeScript keyword: `module`. The `module` keyword must be
    followed by a module name, which in this case is `ErrorHelper`. This module name
    must match the closure name from the original JavaScript that we are describing.
    In all of our usages of the `ErrorHelper`, we have always pre-fixed the functions
    `containsErrors` and `trace` with the closure name `ErrorHelper` itself. This
    module name is also known as a namespace. If we had another class named `AjaxHelper`
    that also included a `containsErrors` function, we would be able to distinguish
    between the `AjaxHelper.containsErrors` and the `ErrorHelper.containsErrors` functions
    by using these namespaces, or module names.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个声明文件以我们之前见过的`declare`关键字开头，然后使用了一个新的TypeScript关键字：`module`。`module`关键字后面必须跟着一个模块名，这里是`ErrorHelper`。这个模块名必须与我们描述的原始JavaScript中的闭包名匹配。在我们所有对`ErrorHelper`的使用中，我们总是用闭包名`ErrorHelper`本身作为`containsErrors`和`trace`函数的前缀。这个模块名也被称为命名空间。如果我们有另一个名为`AjaxHelper`的类，它也包括一个`containsErrors`函数，我们可以通过使用这些命名空间或模块名来区分`AjaxHelper.containsErrors`和`ErrorHelper.containsErrors`函数。
- en: The second line of the preceding code snippet indicates that we are defining
    a function called `containsErrors` that takes one parameter. The third line of
    this module declaration indicates that we are defining another function named
    `trace` that takes one parameter. With this definition in place, our TypeScript
    code sample will compile correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的第二行指示我们正在定义一个名为`containsErrors`的函数，它接受一个参数。模块声明的第三行指示我们正在定义另一个名为`trace`的函数，它接受一个参数。有了这个定义，我们的TypeScript代码样本将能够正确编译。
- en: Interfaces
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Although we have correctly defined the two functions that are available to users
    of the `ErrorHelper` closure, we are missing the second piece of information about
    the functions available on the `ErrorHelper` closure—the structure of the `response`
    argument. We are not strongly typing the arguments for either of the `containsErrors`
    or `trace` functions. At this stage, our TypeScript code can pass anything into
    these two functions because it does not have a definition for the `response` or
    `message` arguments. We know, however, that both these functions query these arguments
    for a specific structure. If we pass in an object that does not conform to this
    structure, then our JavaScript code will cause runtime errors.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经正确定义了`ErrorHelper`闭包可用的两个函数，但我们缺少关于`ErrorHelper`闭包可用的函数的第二部分信息——`response`参数的结构。我们没有为`containsErrors`或`trace`函数中的任何一个强类型参数。在这个阶段，我们的TypeScript代码可以将任何东西传递给这两个函数，因为它没有`response`或`message`参数的定义。然而，我们知道这两个函数都查询这些参数的特定结构。如果我们传入一个不符合这个结构的对象，那么我们的JavaScript代码将会引起运行时错误。
- en: 'To solve this problem and to make our code more stable, let''s define an interface
    for these parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题并使我们的代码更稳定，让我们为这些参数定义一个接口：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We start with an interface named `IResponse` that has a single property of
    `responseText`—the same name as the original JSON object. This `responseText`
    property is strongly typed to be of type `IFailureMessage`. The `IFailureMessage`
    interface is strongly typed to have two properties: `failure`, which is a `boolean`,
    and `errorMessage`, which is of type `string`. These interfaces correctly describe
    the proper structure of the `response` argument for the `containsErrors` function.
    We can now modify our original declaration for the `containsErrors` function to
    use this interface on the `response` argument as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个名为`IResponse`的接口开始，它具有一个名为`responseText`的属性，与原始的JSON对象相同。这个`responseText`属性被强类型为`IFailureMessage`类型。`IFailureMessage`接口被强类型为具有两个属性：`failure`是`boolean`类型，`errorMessage`是`string`类型。这些接口正确描述了`containsErrors`函数的`response`参数的正确结构。现在我们可以修改`containsErrors`函数的原始声明，以在`response`参数上使用这个接口。
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The function definition for `containsErrors` now strongly types the response
    argument to be of type `IResponse`, which we defined earlier. This modification
    to the definition file will now force any further usage of the `containsErrors`
    function to send in a valid argument that conforms to the `IResponse` structure.
    Let''s write some intentionally incorrect TypeScript code and see what happens:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`containsErrors`的函数定义现在将响应参数强类型为我们之前定义的`IResponse`类型。对声明文件的这种修改现在将强制`containsErrors`函数的任何进一步使用发送一个符合`IResponse`结构的有效参数。让我们写一些故意不正确的TypeScript代码，看看会发生什么：'
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We start by creating a variable named `anotherFailure` and specify its type
    to be of type `IResponse`. Even though we are using a definition file to define
    this interface, the rules that are applied by the TypeScript compiler, are no
    different to what we have seen before. The first line in this code snippet will
    generate the following error:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`anotherFailure`的变量，并将其类型指定为`IResponse`类型。即使我们使用定义文件来定义这个接口，TypeScript编译器应用的规则与我们以前看到的没有什么不同。这段代码中的第一行将生成以下错误：
- en: '![Interfaces](img/9665OS_04_02.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![接口](img/9665OS_04_02.jpg)'
- en: Compile errors for an incorrect responseText object
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译错误的响应文本对象
- en: As can be seen from this fairly verbose but informative error message, the structure
    of the `anotherFailure` variable is causing all the errors. Even though we have
    correctly referenced the `responseText` property of `IResponse`, the `responseText`
    property is strongly typed to be of type `IFailureMessage`, which requires both
    a `failure` property and an `errorMessage` property; hence the error.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个相当冗长但信息丰富的错误消息中可以看出，`anotherFailure`变量的结构导致了所有的错误。即使我们正确引用了`IResponse`的`responseText`属性，`responseText`属性也被强类型为`IFailureMessage`类型，它要求`failure`属性和`errorMessage`属性都存在，因此会出现错误。
- en: 'We can fix these errors by including the required properties of `failure` and
    `errorMessage` within the variable `anotherFailure`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在变量`anotherFailure`中包含`failure`和`errorMessage`的必需属性来修复这些错误：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Our TypeScript now compiles correctly. The variable `anotherFailure` now has
    all of the required properties in order to use the `ErrorHelper` functions correctly.
    By creating a strongly typed declaration file for the existing `ErrorHelper` class,
    we can ensure that any further TypeScript usage of the existing `ErrorHelper`
    JavaScript closure will not generate runtime errors.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的TypeScript现在可以正确编译。变量`anotherFailure`现在具有所有必需的属性，以便正确使用`ErrorHelper`函数。通过为现有的`ErrorHelper`类创建一个强类型声明文件，我们可以确保对现有的`ErrorHelper`
    JavaScript闭包的任何进一步的TypeScript使用都不会生成运行时错误。
- en: Function overrides
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数重载
- en: 'We are not quite finished with the declaration file for the `ErrorHelper` just
    yet. If we take a look at the original JavaScript usage of the `ErrorHelper`,
    we will notice that the `containsErrors` function also allows for the `failure`
    property of `responseText` to be a string:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`ErrorHelper`的声明文件还没有完全完成。如果我们看一下`ErrorHelper`的原始JavaScript用法，我们会注意到`containsErrors`函数还允许`responseText`的`failure`属性是一个字符串：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we compile this code now, we will get the following compile error:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译这段代码，将会得到以下编译错误：
- en: '![Function overrides](img/9665OS_04_03.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![函数重载](img/9665OS_04_03.jpg)'
- en: Compile errors for multiple definitions of responseText
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 响应文本的多个定义的编译错误
- en: 'In the preceding definition of the variable `failureMessageString`, the type
    of the `"failure"` property is `"true"`, which is of type `string` , and not `true`,
    which is of type `boolean`. In order to allow for this variant on the original
    `IFailureMessage` interface, we will need to modify our declaration file. Firstly,
    we will need two new interfaces that specify the `failure` property to be of type
    `string`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在变量`failureMessageString`的先前定义中，“failure”属性的类型为“true”，这是一个`string`类型，而不是`boolean`类型的`true`。为了允许在原始`IFailureMessage`接口上进行这种变体，我们需要修改我们的声明文件。首先，我们需要两个新接口，指定`failure`属性的类型为`string`：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `IResponseString` interface is almost identical to the `IResponse` interface,
    except that it uses the `IFailureMessageString` type for the property `responseText`.
    This `IFailureMessageString` interface is also almost identical to the original
    `IFailureMessage` interface, except that the `failure` property is of type `string`.
    We will now need to modify our declaration file to allow both call signatures
    on the `containsErrors` function:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`IResponseString`接口与`IResponse`接口几乎相同，只是它使用`IFailureMessageString`类型作为`responseText`属性的类型。`IFailureMessageString`接口与原始的`IFailureMessage`接口几乎相同，只是`failure`属性的类型为`string`。现在我们需要修改我们的声明文件，以允许`containsErrors`函数上的两个调用签名：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As with interface and class definitions, modules also allow for function overrides.
    The module `ErrorHelper` now has one function definition for `containsErrors`
    that uses the original `IResponse` interface, and a second function definition
    that uses the new `IReponseString` interface. This new version of the module definition
    will allow both variants of the `failure` message structure to compile correctly.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 与接口和类定义一样，模块也允许函数覆盖。模块`ErrorHelper`现在有一个`containsErrors`函数定义，使用原始的`IResponse`接口，以及一个使用新的`IReponseString`接口的第二个函数定义。这个模块定义的新版本将允许`failure`消息结构的两种变体都正确编译。
- en: 'We can also take advantage of union types in this example, and simplify our
    previous declaration for the `containsErrors` function to a single definition:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们还可以利用联合类型，并简化我们先前对`containsErrors`函数的声明为单个定义：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Rounding out our definition file
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完善我们的定义文件
- en: 'We can now focus our attention on the `trace` function. The `trace` function
    can accept both versions of the `IResponse` interface, or it can simply accept
    a string. Let''s update the definition file for the `trace` function signatures:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将注意力集中在`trace`函数上。`trace`函数可以接受`IResponse`接口的两个版本，或者它可以简单地接受一个字符串。让我们更新`trace`函数签名的定义文件：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, we have updated the `trace` function to allow three different variants
    of the message type—a normal `string`, an `IResponse` type, or an `IResponseString`
    type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经更新了`trace`函数，以允许三种不同类型的消息类型——普通的`string`，一个`IResponse`类型，或一个`IResponseString`类型。
- en: This completes our definition file for the `ErrorHelper` JavaScript class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对`ErrorHelper`JavaScript类的定义文件。
- en: Module merging
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块合并
- en: As we now know, the TypeScript compiler will automatically search through all
    the `.d.ts` files in your project to pick up declaration files. If these declaration
    files contain the same module name, the TypeScript compiler will merge these two
    declaration files and use a combined version of the module declarations.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们现在所知，TypeScript编译器将自动搜索项目中所有`.d.ts`文件，以获取声明文件。如果这些声明文件包含相同的模块名称，TypeScript编译器将合并这两个声明文件，并使用模块声明的组合版本。
- en: 'If we have a file named `MergedModule1.d.ts` that contains the following definition:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`MergedModule1.d.ts`的文件，其中包含以下定义：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And a second file named `MergedModule2.d.ts` that contains the following definition:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 和一个名为`MergedModule2.d.ts`的第二个文件，其中包含以下定义：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The TypeScript compiler will merge these two modules as if they were a single
    definition:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript编译器将合并这两个模块，就好像它们是单个定义一样：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This will allow both `functionA` and `functionB` to be valid functions of the
    same `MergedModule` namespace and allow the following usage:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许`functionA`和`functionB`都是相同`MergedModule`命名空间的有效函数，并允许以下用法：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Modules can also merge with interfaces, classes, and enums. Classes, however,
    cannot merge with other classes, variables, or interfaces.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还可以与接口、类和枚举合并。但是，类不能与其他类、变量或接口合并。
- en: Declaration Syntax Reference
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明语法参考
- en: When creating declaration files and using the `module` keyword, there are a
    number of rules that can be used to mix and match definitions. We have covered
    one of them already—function overrides. As a TypeScript programmer, you will generally
    only write module definitions every now and then, and on occasion, need to add
    a new definition to an existing declaration file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建声明文件并使用`module`关键字时，可以使用一些规则来混合和匹配定义。我们已经涵盖了其中之一——函数覆盖。作为TypeScript程序员，你通常只会偶尔编写模块定义，并且偶尔需要向现有声明文件添加新的定义。
- en: This section, therefore, is designed to be a quick reference guide to this declaration
    file syntax, or a cheat-sheet. Each section contains a description of the module
    definition rule, a JavaScript syntax snippet, and then the equivalent TypeScript
    declaration file syntax.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，本节旨在成为此声明文件语法的快速参考指南，或者一张备忘单。每个部分包含模块定义规则的描述，JavaScript语法片段，然后是等效的TypeScript声明文件语法。
- en: 'To use this reference section, simply match the JavaScript that you are trying
    to emulate from the JavaScript syntax section, and then write your declaration
    file with the equivalent definition syntax. We will start with the function overrides
    syntax as an example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此参考部分，只需匹配JavaScript语法部分中要模拟的JavaScript，然后使用等效的定义语法编写您的声明文件。我们将以函数覆盖语法作为示例开始：
- en: Function overrides
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数覆盖
- en: Declaration files can include multiple definitions for the same function. If
    the same JavaScript function can be called with different types, you will need
    to declare a function override for each variant of the function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文件可以包含同一函数的多个定义。如果相同的JavaScript函数可以使用不同类型进行调用，则需要为函数的每个变体声明一个函数覆盖。
- en: The JavaScript syntax
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The declaration file syntax
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each function definition must have a unique function signature.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数定义必须具有唯一的函数签名。
- en: Nested namespaces
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套命名空间
- en: Module definitions can contain nested module definitions, which then translate
    to nested namespaces. If your JavaScript uses namespaces, then you will need to
    define nested module declarations to match the JavaScript namespaces.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 模块定义可以包含嵌套的模块定义，然后转换为嵌套的命名空间。如果您的JavaScript使用命名空间，则需要定义嵌套模块声明以匹配JavaScript命名空间。
- en: The JavaScript syntax
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The declaration file syntax
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Classes
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: Class definitions are allowed within module definitions. If your JavaScript
    uses classes, or the new operator, then the new-able classes will need to be defined
    in your declaration file.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义允许在模块定义内。如果您的JavaScript使用类或new操作符，则可实例化的类将需要在声明文件中定义。
- en: The JavaScript syntax
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The declaration file syntax
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Class namespaces
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类命名空间
- en: Class definitions are allowed within nested module definitions. If your JavaScript
    classes have a preceding namespace, you will need to declare nested modules to
    match the namespaces first, and then you can declare classes within the correct
    namespace.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义允许在嵌套模块定义中。如果您的JavaScript类具有前置命名空间，则需要先声明匹配命名空间的嵌套模块，然后可以在正确的命名空间内声明类。
- en: The JavaScript syntax
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The declaration file syntax
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Class constructor overloads
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类构造函数重载
- en: Class definitions can contain constructor overloads. If your JavaScript classes
    can be constructed using different types, or with multiple parameters, you will
    need to list each of these variants in your declaration file as constructor overloads.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义可以包含构造函数重载。如果您的JavaScript类可以使用不同类型或多个参数进行构造，则需要在声明文件中列出每个变体作为构造函数重载。
- en: The JavaScript syntax
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The declaration file syntax
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Class properties
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类属性
- en: Classes can contain properties. You will need to list each property of your
    class within your class declaration.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以包含属性。您需要在类声明中列出类的每个属性。
- en: The JavaScript syntax
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The declaration file syntax
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Class functions
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类函数
- en: Classes can contain functions. You will need to list each function of your JavaScript
    class within your class declaration, in order for the TypeScript compiler to accept
    calls to these functions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以包含函数。您需要在类声明中列出JavaScript类的每个函数，以便TypeScript编译器接受对这些函数的调用。
- en: The JavaScript syntax
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The declaration file syntax
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE41]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Functions or properties that are considered as private do not need to be exposed
    via the declaration file, and can simply be omitted.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 被视为私有的函数或属性不需要通过声明文件公开，可以简单地省略。
- en: Static properties and functions
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态属性和函数
- en: Class methods and properties can be static. If your JavaScript functions or
    properties can be called without needing an instance of an object to work with,
    then these properties or functions will need to be marked as static.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法和属性可以是静态的。如果您的JavaScript函数或属性可以在不需要对象实例的情况下调用，则这些属性或函数需要标记为静态。
- en: The JavaScript syntax
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The declaration file syntax
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Global functions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局函数
- en: Functions that do not have a namespace prefix can be declared in the global
    namespace. If your JavaScript defines global functions, these will need to be
    declared without a namespace.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不带命名空间前缀的函数可以在全局命名空间中声明。如果您的JavaScript定义了全局函数，则需要在没有命名空间的情况下声明这些函数。
- en: The JavaScript syntax
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE44]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The declaration file syntax
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Function signatures
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数签名
- en: A function can use a function signature as a parameter. JavaScript functions
    that use callback functions or anonymous functions, will need to be declared with
    the correct function signature.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以使用函数签名作为参数。使用回调函数或匿名函数的JavaScript函数，需要用正确的函数签名声明。
- en: The JavaScript syntax
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE46]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The declaration file syntax
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE47]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Optional properties
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选属性
- en: Classes or functions can contain optional properties. Where JavaScript object
    parameters are not mandatory, these will need to be marked as optional properties
    in the declaration.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 类或函数可以包含可选属性。在JavaScript对象参数不是必需时，这些参数需要在声明中标记为可选属性。
- en: The JavaScript syntax
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The declaration file syntax
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Merging functions and modules
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并函数和模块
- en: A function definition with a specific name can be merged with a module definition
    of the same name. This means that if your JavaScript function can be called with
    parameters and also has properties, then you will need to merge a function with
    a module.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 具有特定名称的函数定义可以与相同名称的模块定义合并。这意味着如果您的JavaScript函数可以使用参数调用并且还具有属性，则需要将函数与模块合并。
- en: The JavaScript syntax
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript语法
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The declaration file syntax
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明文件语法
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have outlined what you need to know in order to write and
    use your own declaration files. We discussed JavaScript global variables in rendered
    HTML and how to access them in TypeScript. We then moved on to a small JavaScript
    helper function and wrote our own declaration file for this JavaScript. We finished
    off the chapter by listing a few module definition rules, highlighting the required
    JavaScript syntax, and showing what the equivalent TypeScript declaration syntax
    would be. In the next chapter, we will look at how to use existing third-party
    JavaScript libraries, and how to import existing declaration files for these libraries
    into your TypeScript projects.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们概述了您需要了解的内容，以便编写和使用自己的声明文件。我们讨论了在呈现的HTML中的JavaScript全局变量以及如何在TypeScript中访问它们。然后，我们转向了一个小的JavaScript辅助函数，并为这个JavaScript编写了我们自己的声明文件。我们通过列出一些模块定义规则来结束本章，强调了所需的JavaScript语法，并展示了等效的TypeScript声明语法。在下一章中，我们将讨论如何使用现有的第三方JavaScript库，以及如何将这些库的现有声明文件导入到您的TypeScript项目中。
- en: 'Prepared for Bentham Chang, Safari ID bentham@gmail.com User number: 2843974
    © 2015 Safari Books Online, LLC. This download file is made available for personal
    use only and is subject to the Terms of Service. Any other use requires prior
    written consent from the copyright owner. Unauthorized use, reproduction and/or
    distribution are strictly prohibited and violate applicable laws. All rights reserved.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为Bentham Chang准备，Safari ID bentham@gmail.com 用户编号：2843974 © 2015 Safari Books
    Online，LLC。此下载文件仅供个人使用，并受到服务条款的约束。任何其他用途均需版权所有者的事先书面同意。未经授权的使用、复制和/或分发严格禁止并违反适用法律。保留所有权利。
