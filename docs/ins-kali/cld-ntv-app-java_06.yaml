- en: Extending Your Cloud-Native Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的云原生应用
- en: Having understood the design principles, let's take the skeleton services developed
    in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing Your First
    Cloud-Native Application*, and do some real work on them to make them production-ready.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了设计原则之后，让我们拿出在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中开发的骨架服务，*编写您的第一个云原生应用*，并对它们进行一些真正的工作，使它们能够投入生产。
- en: 'We defined two get services; `getProduct` for a given a product ID, and `getProducts`
    for a given category. These two services have highly non-functional requirements.
    They always have to be available and serve the data with the lowest possible latency.
    The following steps will take us there:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个获取服务；`getProduct`用于给定产品ID，`getProducts`用于给定类别。这两个服务具有高度的非功能性要求。它们必须始终可用，并以尽可能低的延迟提供数据。以下步骤将带领我们实现这一目标：
- en: '**Accessing data**: Service access to data across various resources'
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问数据：服务访问跨各种资源的数据
- en: '**Caching**: Options to do caching and their considerations'
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存：进行缓存的选项及其考虑因素
- en: '**Applying CQRS**: Enable us to have different data models to service different
    requests'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用CQRS：使我们能够拥有不同的数据模型来服务不同的请求
- en: '**Error handling**: How to recover, what return codes to send, and implementation
    of patterns such as a circuit breaker'
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误处理：如何恢复，发送什么返回代码，以及实现断路器等模式
- en: 'We will also look at adding methods to modify the data, such as `insert`, `update`,
    and `delete`. In this chapter, we will cover:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究添加修改数据的方法，例如`insert`，`update`和`delete`。在本章中，我们将涵盖：
- en: '**Validations**: Ensuring that the data is clean before being processed'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证：确保数据在处理之前是干净的
- en: '**Keeping two models of CQRS in sync**: For data consistency'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持两个CQRS模型同步：数据一致性
- en: '**Event driven and a****synchronous updates**: How it scales the architecture
    and decouples it at the same time'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件驱动和异步更新：它如何扩展架构并同时解耦
- en: Implementing the get services
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现获取服务
- en: Let's take our `product` project developed in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*, forward. We will incrementally
    enhance it while discussing the concepts.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续开发在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中开发的`product`项目，*编写您的第一个云原生应用*。我们将在讨论概念的同时逐步增强它。
- en: 'Let''s think carefully about the database of our two services. `getProduct`
    returns the product information, while `getProducts` searches a list of products
    that fall into this category. To begin with, for simple and standard requirements,
    both queries can be answered by a single data model in a relational database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细考虑一下我们两个服务的数据库。`getProduct`返回产品信息，而`getProducts`搜索属于该类别的产品列表。首先，对于简单和标准的要求，这两个查询都可以由关系数据库中的单个数据模型回答：
- en: You would store a product in a product table with a fixed number of columns.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在一个固定数量的列中的产品表中存储产品。
- en: You would then index the category so that the queries against it can run quickly.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将对类别进行索引，以便对其进行的查询可以快速运行。
- en: Now, this design will be fine for most requirements for an average-sized company.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个设计对于大多数中等规模公司的要求来说都是可以的。
- en: Simple product table
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的产品表
- en: Let's use a product table in a standard relational database and access it in
    our service using Spring Data. Spring Data provides excellent abstractions to
    use the **Java Persistence API** (**JPA**) and makes coding **data access objects**
    (**DAO**) much easier. Spring Boot further helps in writing minimal code to begin
    with and extending it as we go ahead.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在标准关系数据库中使用产品表，并使用Spring Data在我们的服务中访问它。Spring Data提供了优秀的抽象，以使用**Java持久化API**（**JPA**），并使编写**数据访问对象**（**DAO**）变得更加容易。Spring
    Boot进一步帮助我们开始时编写最少的代码，并在前进时进行扩展。
- en: Spring Boot can work with embedded databases, such as H2, HSQLDB, or the external
    database. In-process embedded database starts with our Java service in a process
    and then terminates when the process dies. This is fine to begin with. Later on,
    the dependencies and URLs can be changed to point to actual databases.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot可以与嵌入式数据库一起工作，例如H2、HSQLDB或外部数据库。进程内嵌入式数据库在我们的Java服务中启动一个进程，然后在进程终止时终止。这对于开始是可以的。稍后，依赖项和URL可以更改为指向实际数据库。
- en: 'You can take the project from [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* and add the following steps, or
    just download the completed code from GitHub ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中获取项目，*编写您的第一个云原生应用*，并添加以下步骤，或者只需从GitHub（[https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)）下载已完成的代码：
- en: '**Maven POM**: Including POM dependencies:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven POM：包括POM依赖项：
- en: '![](img/eea764ef-0caa-4040-a8bb-c3268da21093.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eea764ef-0caa-4040-a8bb-c3268da21093.png)'
- en: This will tell Spring Boot to include the Spring Boot starter JPA and use HSQLDB
    in embedded mode.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Spring Boot包含Spring Boot starter JPA并在嵌入模式下使用HSQLDB。
- en: '**Entity**: As per the JPA, we will start using the concept of entity. We already
    have a domain object named `Product` from our previous project. Refactor it to
    put in an entity package. Then, add the notations of `@Entity`, `@Id`, and `@Column`,
    as shown in the following `Product.java` file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体：根据JPA，我们将开始使用实体的概念。我们已经有一个名为`Product`的领域对象来自我们之前的项目。重构它以放入一个实体包中。然后，添加`@Entity`，`@Id`和`@Column`的标记，如下所示的`Product.java`文件：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The rest of the code, such as constructors and getters/setters, remains the
    same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的代码，如构造函数和getter/setter，保持不变。
- en: '**Repository**: Spring Data provides a repository, which is like a DAO class
    and provides methods to do **Create**, **Read**, **Update**, and **Delete** (**CRUD**)
    operations on the data. A lot of standard operations are already provided in the
    `CrudRepository` interface. We will be using only the query operations from now
    on.'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**存储库**：Spring Data提供了一个存储库，类似于DAO类，并提供了执行数据的**创建**、**读取**、**更新**和**删除**（**CRUD**）操作的方法。`CrudRepository`接口中已经提供了许多标准操作。从现在开始，我们将只使用查询操作。'
- en: 'In our case, since our domain entity is `Product`, the repository will be `ProductRepository`,
    which extends Spring''s `CrudRepository`, and manages the `Product` entity. During
    extension, the entity and the data type of the primary key needs to be specified
    using generics, as shown in the following `ProductRepository.java` file:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，由于我们的领域实体是`Product`，所以存储库将是`ProductRepository`，它扩展了Spring的`CrudRepository`，并管理`Product`实体。在扩展期间，需要使用泛型指定实体和主键的数据类型，如下面的`ProductRepository.java`文件所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first question that would come to mind is whether this code is sufficient
    enough to work. It has just one interface definition. How can it be enough to
    handle our two methods, namely `getProduct` (given a product ID) and `getProducts`
    (for a given category)?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要考虑的问题是，这段代码是否足够工作。它只有一个接口定义。如何能足够处理我们的两个方法，即`getProduct`（根据产品ID）和`getProducts`（根据类别）？
- en: The magic happens in Spring Data, which helps with the boilerplate code. The
    `CrudRepository` interface comes with a set of default methods to implement the
    most common operations. These include `save`, `delete`, `find`, `count`, and `exists`
    operations which suffice for most of the query and update tasks. We will look
    at the `update` operations in the second half of this chapter, but let's focus
    on the query operations first.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Data中发生的魔术有助于处理样板代码。`CrudRepository`接口带有一组默认方法来实现最常见的操作。这些包括`save`、`delete`、`find`、`count`和`exists`操作，这些操作足以满足大部分查询和更新任务。我们将在本章的后半部分讨论`update`操作，但让我们先专注于查询操作。
- en: The operation of finding a product given an ID is already present in the `CrudRepository`
    as a `findOne` method. Hence, we do not need to call it explicitly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`CrudRepository`中的`findOne`方法，已经存在根据ID查找产品的操作。因此，我们不需要显式调用它。
- en: The task of finding products for a given category is done by the `findByCatId`
    method in our `ProductRepository` interface. The query builder mechanism built
    into the Spring Data repository infrastructure is useful for building queries
    over entities of the repository. The mechanism strips the prefixes, such as `find`,
    `read`, `query`, `count`, and `get` from the method and starts parsing the rest
    of it based on the entity. This mechanism is very powerful because the choice
    of keywords and the combinations means the method name is enough to do most of
    the query operations including operators (`and`/`or`) distinct clauses, and so
    on. Do refer to the Spring Data reference documentation ([https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/))
    to see the details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`ProductRepository`接口中，根据给定类别查找产品的任务由`findByCatId`方法完成。Spring Data存储库基础设施内置的查询构建器机制对于构建存储库实体的查询非常有用。该机制会剥离方法的前缀，如`find`、`read`、`query`、`count`和`get`，然后根据实体解析剩余部分。该机制非常强大，因为关键字和组合的选择意味着方法名足以执行大部分查询操作，包括操作符（`and`/`or`）、distinct子句等。请参阅Spring
    Data参考文档（[https://docs.spring.io/spring-data/jpa/docs/current/reference/html/](https://docs.spring.io/spring-data/jpa/docs/current/reference/html/)）了解详细信息。
- en: These conventions allow Spring Data and Spring Boot to inject implementations
    of the methods based on parsing the interfaces.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约定允许Spring Data和Spring Boot根据解析接口来注入方法的实现。
- en: '**Changing the service**: In [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application,* our `product` service was returning
    dummy hard-coded data. Let''s change it to something useful that goes against
    the database. We achieve this by using the `ProductRepository` interface that
    we defined earlier, and injecting it through `@Autowiring` annotation into our
    `ProductService` class, as shown in the following `ProductService.java` file:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**更改服务**：在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中，*编写您的第一个云原生应用程序*，我们的`product`服务返回了虚拟的硬编码数据。让我们将其更改为针对数据库的有用内容。我们通过使用之前定义的`ProductRepository`接口，并通过`@Autowiring`注入到我们的`ProductService`类中来实现这一点，如下面的`ProductService.java`文件所示：'
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `findOne` method from the repository gets the object given a primary key,
    and the `findByCatId` method we defined helps to find products given a category.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库中的`findOne`方法根据主键获取对象，我们定义的`findByCatId`方法有助于根据类别查找产品。
- en: '**Schema definition**: For now, we will leave the schema creation to the `hibernate`
    capability to auto generate a script. Since we do want to see what script got
    created, let''s enable `logging` for the classes as follows in the `application.properties`
    file:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**模式定义**：目前，我们将模式创建留给`hibernate`自动生成脚本。由于我们确实想要看到生成的脚本，让我们在`application.properties`文件中启用对类的`logging`，如下所示：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Test data**: Since we are going to insert the products later, we need our
    database to be initialized with some products. Hence, add the following lines
    into `import.sql` and place it in resources (where the `application.properties`
    and bootstrap files reside):'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试数据**：由于我们将稍后插入产品，因此需要初始化数据库并添加一些产品。因此，请将以下行添加到`import.sql`中，并将其放在资源中（与`application.properties`和引导文件所在的位置）：'
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Leave Spring Data and Spring Boot to figure out the rest: **But in a production
    application, we would want to have fine-grained control over the connection URL,
    user ID, password, connection pool properties, and so on.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**让Spring Data和Spring Boot来解决其余问题：**但在生产应用程序中，我们希望对连接URL、用户ID、密码、连接池属性等进行精细控制。'
- en: Running the service
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行服务
- en: 'To run our `product` service, perform the following steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行我们的`product`服务，请执行以下步骤：
- en: Fire up the Eureka server (as we did in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml),
    *Writing Your First Cloud-Native Application*) using the `EurekaApplication` class.
    We are going to keep the Eureka service running at all times.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eureka服务器（就像我们在[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中所做的那样，*编写您的第一个云原生应用程序*），使用`EurekaApplication`类。我们将始终保持Eureka服务运行。
- en: Once the `Eureka` project starts, run the `product` service.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦“Eureka”项目启动，运行“product”服务。
- en: 'Notice the logs generated by `hibernate`. It first uses an HSQLDB dialect automatically, and
    then creates and runs the `Product` table SQL as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由`hibernate`生成的日志。它首先自动使用HSQLDB方言，然后创建并运行以下`Product`表SQL：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the service starts to listen on a port, fire a query in your browser: `http://localhost:8082/product/1`.
    This will return the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务开始监听端口，请在浏览器中发出查询：`http://localhost:8082/product/1`。这将返回以下内容：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you see the logs, you will observe the SQL that ran in the background:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您看到日志时，您会观察到后台运行的SQL：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, fire another query that returns products for a given category: `http://localhost:8082/products?id=1`.
    This will return the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次发出一个返回给定类别产品的查询：`http://localhost:8082/products?id=1`。这将返回以下内容：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The SQL that ran for this condition was as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为此条件运行的SQL如下：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And trying with a different category, `http://localhost:8082/products?id=2`,
    will return something as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用不同的类别，`http://localhost:8082/products?id=2`，将返回如下内容：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This completes a simple query service going against a data source.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了一个针对数据源的简单查询服务。
- en: For production purposes, this will need enhancement to take a standard database
    as an Oracle, PostgreSQL, or MySQL database. You will introduce an index on the
    category column so that the queries run faster.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生产目的，这将需要增强以将标准数据库作为Oracle、PostgreSQL或MySQL数据库。您将在类别列上引入索引，以便查询运行更快。
- en: Limitations of traditional databases
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统数据库的局限性
- en: But what happens as the company expands its products and customers in the following
    scenarios?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在以下情况下，公司扩大产品和客户会发生什么？
- en: The scalability of a relational database (in terms of volume of products and
    number of concurrent requests) becomes a bottleneck.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系数据库的可伸缩性（产品数量和并发请求数量）成为瓶颈。
- en: The product structure is different based on the category and is difficult to
    model in a fixed schema of a relational database.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品结构根据类别不同，在关系数据库的固定模式中很难建模。
- en: The search criteria starts increasing in scope. As of now, we are searching
    only by category; later on, we might want to search by product description, filter
    fields, and also by category description.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索条件开始扩大范围。目前，我们只按类别搜索；以后，我们可能希望按产品描述、过滤字段以及类别描述进行搜索。
- en: Will a single relational database suffice for all requirements?
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单个关系数据库是否足以满足所有需求？
- en: Let's address the concerns with a few design techniques.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一些设计技术来解决这些问题。
- en: Caching
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: As the service scales in terms of the amount of data and concurrency of requests,
    the database will start becoming a bottleneck. In order to scale, we can adopt
    a caching solution that will reduce the number of hits to the database by servicing
    the requests from a cache if the value is available in the cache.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着服务在数据量和并发请求方面的扩展，数据库将开始成为瓶颈。为了扩展，我们可以采用缓存解决方案，通过从缓存中服务请求来减少对数据库的访问次数，如果值在缓存中可用的话。
- en: Spring provides mechanisms to include caching through annotations, so that Spring
    can return cached values instead of calling the actual processing or retrieval
    methods.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了通过注解包含缓存的机制，以便Spring可以返回缓存值而不是调用实际处理或检索方法。
- en: Conceptually, caching comes in two types, as discussed in the following sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，缓存分为两种类型，如下节所讨论的。
- en: Local cache
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地缓存
- en: The local cache is present in the same JVM as that of the service. Its scope
    is limited as it can be accessed by the service instance and has to be entirely
    managed by the service instance.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本地缓存存在于与服务相同的JVM中。它的范围是有限的，因为它只能被服务实例访问，并且必须完全由服务实例管理。
- en: Let's start by making our products cacheable in a local cache.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使我们的产品在本地缓存中可缓存。
- en: Spring 3.1 introduced its own notations for returning cached entries, evicting,
    or populating entries. But later on, JSR 107 JCache introduced different notations.
    Spring 4.1 and higher supports these as well.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 3.1引入了自己的注释来返回缓存条目、清除或填充条目。但后来，JSR 107 JCache引入了不同的注释。Spring 4.1及更高版本也支持这些。
- en: 'Let''s use the Spring notations to begin with:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用Spring的注释：
- en: 'Tell the Spring application to enable caching and look for cacheable instances.
    This is a one-time declaration and hence is best done in the start-up class. Add
    the `@``EnableCaching` annotation into the main class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Spring应用程序启用缓存并寻找可缓存的实例。这是一次性声明，因此最好在启动类中完成。在主类中添加`@``EnableCaching`注释：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enable the cache in our `ProductRepository` for getting products by category,
    by adding a cacheable notation. We will give a cache name that is explicit and
    will be used for this method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`ProductRepository`中启用缓存以通过添加可缓存注释获取产品，我们将提供一个明确的缓存名称，并将用于此方法：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, run the service again and observe the logs when you run the following
    set of queries in your browser:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次运行服务，并观察当您在浏览器中运行以下一组查询时的日志：
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: 'You will see that the following SQL has been fired only twice:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到以下SQL只被触发了两次：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that the repository executed the `findByCatId` method only when it
    did not find a category entry in the cache.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着仓库只有在缓存中找不到类别条目时才执行了`findByCatId`方法。
- en: Under the hood
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 底层
- en: While it is nice that Spring handles a lot of concerns such as caching implementation
    under the hood, it is important to understand what is happening and be aware of
    the limitations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Spring在幕后处理了许多关注点，如缓存实现，但重要的是要了解正在发生的事情，并意识到其中的局限性。
- en: Internally, caching is implemented by internal classes such as cache manager
    and cache resolver. When no caching product or framework is supplied, Spring uses
    `ConcurrentHashMap` by default. Spring's caching implements many other local caches
    such as EHCache, Guava, and Caffeine.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，缓存是通过内部类（如缓存管理器和缓存解析器）实现的。当没有提供缓存产品或框架时，Spring默认使用`ConcurrentHashMap`。Spring的缓存实现了许多其他本地缓存，如EHCache、Guava和Caffeine。
- en: Check out the Spring documentation ([https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html))
    for more intricacies such as `sync=true` and conditional caching.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Spring文档（[https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html](https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/cache/annotation/Cacheable.html)）以获取更多诸如`sync=true`和条件缓存等复杂性。
- en: Limitations of a local cache
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地缓存的局限性
- en: Local cache is useful in limited use cases (such as non-changing static data)
    as the updates done in one service using Spring annotations such as `@CachePut`,
    `@CacheEvict`, and so on cannot be synchronized with a cache on the other instance
    of services if we are running more than one instance of a service for load balancing
    or resiliency purposes.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 本地缓存在有限的用例中很有用（例如非更改静态数据），因为使用Spring注释（如`@CachePut`、`@CacheEvict`等）在一个服务中进行的更新无法与运行多个服务实例的其他实例上的缓存同步，以实现负载平衡或弹性目的。
- en: Distributed cache
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: A distributed cache such as Hazelcast, Gemfire, and/or Coherence is network-aware
    and the cache instances operate either as an in-process model (peer-peer model),
    where the cache is part of the service runtime, or a client-server model, where
    the cache request goes from the service to separate dedicated cache instances.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Hazelcast、Gemfire和/或Coherence等分布式缓存是网络感知的，缓存实例作为进程模型（对等模型）运行，其中缓存是服务运行时的一部分，或者作为客户端-服务器模型运行，其中缓存请求从服务到单独的专用缓存实例。
- en: 'For this example, we have selected Hazelcast, as it is a very lightweight but
    powerful distributed caching solution. It also integrates very well with Spring
    Boot. Here is how:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们选择了Hazelcast，因为它是一个非常轻量但功能强大的分布式缓存解决方案。它还与Spring Boot集成得非常好。以下是如何操作的：
- en: 'In the POM (Maven file), add a dependency to `hazelcast-spring`. The `hazelcast-spring`
    has a `HazelcastCacheManager` that configures a Hazelcast instance to be used:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在POM（Maven文件）中，添加对`hazelcast-spring`的依赖。`hazelcast-spring`具有一个`HazelcastCacheManager`，用于配置要使用的Hazelcast实例：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Since Hazelcast is a distributed cache, it needs the elements to be serializable.
    Hence, we need to ensure that our `Product` entity is serializable:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Hazelcast是一个分布式缓存，它需要元素是可序列化的。因此，我们需要确保我们的`Product`实体是可序列化的：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'A simplified Hazelcast configuration file that tells the various Hazelcast
    instances to discover and synchronize with each other:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个简化的Hazelcast配置文件，告诉各种Hazelcast实例如何发现并与彼此同步：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let''s test these changes. For this, we have to run two instances of the
    `product` service to check if it works. We can run two instances by changing the
    port number:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试这些更改。为此，我们必须运行两个`product`服务的实例来检查它是否有效。我们可以通过更改端口号来运行两个实例：
- en: Run the service with port `8082` (which is configured).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用端口`8082`（已配置）运行服务。
- en: Change the `application.properties` to `8083`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`application.properties`更改为`8083`。
- en: Run the service again.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行服务。
- en: 'You will see Hazelcast messages on one service that starts as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在一个服务上看到Hazelcast消息，该服务启动如下：
- en: '[PRE17]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'But as soon as the second service is started, the member definitions get updated
    by `2`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦第二个服务启动，成员定义就会被`2`更新：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, on the browser, run the following queries and observe the logs in the
    console:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器上运行以下查询，并观察控制台中的日志：
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8082/products?id=1`'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=1`'
- en: '`http://localhost:8082/products?id=2`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8082/products?id=2`'
- en: '`http://localhost:8083/products?id=1`'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8083/products?id=1`'
- en: '`http://localhost:8083/products?id=2`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8083/products?id=2`'
- en: You will find that in the SQL, debug logs come only twice in the first service.
    The other four times, the cache entries are picked from Hazelcast. Unlike the
    previous local cache, the cache entries are synchronized between two instances.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您会发现在SQL中，调试日志只在第一个服务中出现两次。其他四次，缓存条目都是从Hazelcast中提取的。与以前的本地缓存不同，缓存条目在两个实例之间是同步的。
- en: Applying CQRS to separate data models and services
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CQRS应用于分离数据模型和服务
- en: A distributed cache is one way to solve the scaling problem. However, it introduces
    certain challenges, such as cache staleness (keeping the cache in sync with the
    database) and additional memory requirements.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存是解决扩展问题的一种方法。但是，它引入了某些挑战，例如缓存陈旧（使缓存与数据库同步）和额外的内存需求。
- en: Also, caching is the beginning of the transition to the CQRS paradigm. Revisit
    the concepts of CQRS that we discussed in Chapter 3, *Designing Your Cloud-Native
    Application*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，缓存是过渡到CQRS范例的开始。重新审视我们在第3章*设计您的云原生应用程序*中讨论的CQRS概念。
- en: The queries are answered from the cache (apart from the first hit), which is
    query segregation from the commands that go from the system of record (which is
    the database) and update the query model (cache update) later.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是从缓存中回答的（除了第一次命中），这是查询与从记录系统（即数据库）传递的命令进行分离，并稍后更新查询模型（缓存更新）。
- en: 'Let''s take the next step in CQRS to do this segregation cleanly. The complexity
    that CQRS introduces is:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在CQRS中迈出下一步，以便清晰地进行这种分离。CQRS引入的复杂性是：
- en: Having two (or multiple) models to maintain instead of one
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要维护两个（或多个）模型，而不是一个
- en: Overheads of updating all models when the data changes
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当数据发生变化时更新所有模型的开销
- en: Consistency guarantees between the different models
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同模型之间的一致性保证
- en: Hence, this model should be followed only if the use case demands separation
    for high concurrency, high volume, and rapid agility requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，只有在用例需要高并发、高容量和快速敏捷性需求的情况下才应遵循这种模式。
- en: Materialized views on a relational database
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系数据库上的物化视图
- en: Materialized views are the simplest form of CQRS. If we assume that the updates
    to products happen less frequently as compared to the reads on the product and
    category, then we can have two different models supporting the `getProduct` (for
    an ID) and `getProducts` (for a given category).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 物化视图是CQRS的最简单形式。如果我们假设对产品的更新发生的频率比对产品和类别的读取频率低，那么我们可以有两种不同的模型支持`getProduct`（根据ID）和`getProducts`（根据给定的类别）。
- en: The search query `getProducts` goes against this view, while the traditional
    `getProduct` based on the primary key goes to the regular table.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索查询`getProducts`针对此视图，而基于主键的传统`getProduct`则转到常规表。
- en: This should be pretty easy if supported by a database such as Oracle. If a database
    does not support a materialized view by default, it can be done manually if there
    is a need, by manually updating statistics or summary tables when the main product
    table is updated using triggers or better event-driven architecture, such as business
    events. We shall see this in the second half of this chapter, when we add `addProduct` functionality
    to our set of services.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库（例如Oracle）支持，这应该很容易。如果数据库不支持物化视图，默认情况下可以手动完成，如果有需要，可以通过手动更新统计信息或摘要表来完成，当主产品表使用触发器或更好的事件驱动架构（例如业务事件）更新时。我们将在本章的后半部分看到这一点，当我们为我们的服务集添加`addProduct`功能时。
- en: Elasticsearch and a document database
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elasticsearch和文档数据库
- en: 'To address limitations of flexible schema, high search ability, and higher
    volume handling, we can go for NoSQL technologies:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决灵活模式、高搜索能力和更高容量处理的限制，我们可以选择NoSQL技术：
- en: For serving different types of products, we could choose to use a document database
    with its flexible schema, for example, MongoDB.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了提供不同类型的产品，我们可以选择使用文档数据库及其灵活的模式，例如MongoDB。
- en: For serving search requests, Elasticsearch, a Lucene based technology, will
    be beneficial due to its powerful indexing capability.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理搜索请求，基于Lucene的Elasticsearch技术由于其强大的索引能力将是有益的。
- en: Why not use only a document database or Elasticsearch?
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么不仅使用文档数据库或Elasticsearch？
- en: 'It is quite possible to think of these options as well:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以考虑以下选项：
- en: Elasticsearch is typically a complementary technology and not used as a master
    database. Hence, the product information should be maintained in a reliable, relational,
    or NoSQL database.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elasticsearch通常是一种补充技术，而不是用作主数据库。因此，产品信息应该在可靠的关系型或NoSQL数据库中维护。
- en: A document database such as MongoDB can build indexes too. However, the performance
    or indexing capability cannot equal Elasticsearch.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像MongoDB这样的文档数据库也可以构建索引。但是，性能或索引能力无法与Elasticsearch相匹敌。
- en: 'This is a classic example for fit for purpose. Your choice will depend on your
    use case:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的适用场景示例。您的选择将取决于您的用例：
- en: Whether you have flexible schema needs
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论您是否需要灵活的模式
- en: Scalable and high volume applications
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可扩展和高容量的应用程序
- en: Highly flexible search requirements
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度灵活的搜索需求
- en: Core product service on a document database
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档数据库上的核心产品服务
- en: Keeping the REST interface the same, let's change the internal implementation
    from using a relational database (HSQLDB, in our example) to MongoDB. Instead
    of running MongoDB in a process such as HSQLDB, we will run it separately as a
    server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 保持REST接口不变，让我们将内部实现从使用关系数据库（例如我们的HSQLDB）更改为MongoDB。我们将MongoDB作为服务器单独运行，而不是在进程中运行，例如HSQLDB。
- en: Getting MongoDB ready with test data
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备MongoDB的测试数据
- en: 'The steps to download and install MongoDB are as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装MongoDB的步骤如下：
- en: Install MongoDB. It is fairly easy to follow the instructions for various platforms
    on the MongoDB website ([https://www.mongodb.com/](https://www.mongodb.com/)).
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装MongoDB。在MongoDB网站上（[https://www.mongodb.com/](https://www.mongodb.com/)）可以很容易地按照各种平台的说明进行操作。
- en: Run `mongod.exe` to start an instance of MongoDB.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`mongod.exe`启动MongoDB的一个实例。
- en: 'Create a test file with our sample data (similar to `import.sql`). This time,
    however, we will keep the data in JSON format instead of SQL statements. The `products.json`
    file is as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们示例数据的测试文件（类似于`import.sql`）。但是，这次我们将数据保留在JSON格式中，而不是SQL语句。`products.json`文件如下：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the `_id`, which is the primary key notation for MongoDB. If you do not
    provide an `_id`, MongoDB will auto generate that field with the `ObjectId` definition.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`_id`，这是MongoDB的主键表示法。如果您不提供`_id`，MongoDB将使用`ObjectId`定义自动生成该字段。
- en: 'Load the sample data into MongoDB. We will create a database called `masterdb`
    and load into a collection called `product`:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将示例数据加载到MongoDB。我们将创建一个名为`masterdb`的数据库，并加载到一个名为`product`的集合中：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Check whether the data got loaded on the command line, by using the `db.product.find()`
    command, after `use masterdb` as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用`use masterdb`后，通过命令行检查数据是否加载，使用`db.product.find()`命令如下：
- en: '![](img/dc4d8193-a647-4c3a-b209-b18fe87c4f86.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc4d8193-a647-4c3a-b209-b18fe87c4f86.png)'
- en: Creating the product service
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品服务
- en: 'The steps to create a `product` service are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`product`服务的步骤如下：
- en: It is better to start with a clean slate. Copy your project from the earlier
    example with Hazelcast and HSQLDB or pull from the GitHub repository ([https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最好从零开始。从之前的带有Hazelcast和HSQLDB的示例项目复制或从GitHub存储库中拉取（[https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java](https://github.com/PacktPublishing/Cloud-Native-Applications-in-Java)）。
- en: 'Adjust the Maven POM file to have the following dependencies. Remove the other
    ones since they are not required for our small example:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整Maven POM文件以具有以下依赖项。删除其他依赖项，因为它们对我们的小例子不是必需的：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Product` entity should just have an `@Id` field. It is optional to put
    a `@Document` annotation at the class level. If not, the first insert performance
    suffers. For now, let''s have the annotation in the `Product.java` file:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Product`实体应该只有一个`@Id`字段。在类级别放置`@Document`注解是可选的。如果不这样做，首次插入性能会受到影响。现在，让我们在`Product.java`文件中放置注解：'
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that the `id` here is `String` instead of `int`. The reason for that is
    that NoSQL databases are much better at generating the ID as a string (GUID) compared
    to incrementing integers in relational systems such as databases. The reason for
    that is databases are getting more distributed, so generating incrementing numbers
    reliably is a little more difficult compared to generating GUIDs.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的`id`是`String`而不是`int`。原因是NoSQL数据库在生成ID时（GUID）比关系系统（如数据库）中的递增整数更好。原因是数据库变得更加分布式，因此相对于生成GUID，可靠地生成递增数字稍微困难一些。
- en: 'The `ProductRepository` now extends the `MongoRepository` which has methods
    for retrieving the product from MongoDB as follows in the `ProductRepository.java`
    file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductRepository`现在扩展了`MongoRepository`，其中有从MongoDB检索产品的方法，如`ProductRepository.java`文件中所示：'
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just add one property to `application.properties` to tell the service to
    get our data from the `masterdb` database in MongoDB. Also, it is probably better
    to run it on a different port so that we can run the services in parallel if we
    want to do so later:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需向`application.properties`添加一个属性，告诉服务从MongoDB的`masterdb`数据库获取数据。此外，最好在不同的端口上运行它，这样我们以后可以并行运行服务，如果我们想这样做的话：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ProductService` class does not change as there is no change in the interface.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口没有更改，因此`ProductService`类也不会更改。
- en: 'Now, start the Eureka server, then the service, and fire the following queries
    in the browser:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Eureka服务器，然后启动服务，并在浏览器中执行以下查询：
- en: '`http://localhost:8085/products?id=1`'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=1`'
- en: '`http://localhost:8085/products?id=2`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=2`'
- en: '`http://localhost:8085/product/1`'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/product/1`'
- en: '`http://localhost:8085/product/2`'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/product/2`'
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到与以前相同的JSON。这是微服务的内部实现更改。
- en: Splitting the services
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分服务
- en: Let's go with a simple implementation of the suggested separation from a learning
    perspective. Since we are separating the master and search models, it makes sense
    to split the services, as the functionality of the search can be considered a
    downstream function to the **Product** master.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从学习的角度采用所建议的分离的简单实现。由于我们正在分离主模型和搜索模型，将服务拆分是有意义的，因为搜索功能可以被视为**产品**主模型的下游功能。
- en: The `getProducts` function for a category is part of the search functionality,
    which can become a complex and independent business area in itself. Hence, it
    is time to rethink whether it makes sense to keep them both in the same microservice
    or split them into core **Product** service and **Product Search** services.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类别的`getProducts`功能是搜索功能的一部分，它本身可以成为一个复杂且独立的业务领域。因此，现在是重新考虑是否有意义将它们保留在同一个微服务中，还是将它们拆分为核心**产品**服务和**产品搜索**服务的时候了。
- en: '![](img/ae3c783c-1df2-4e72-9162-7d4bb4cac904.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae3c783c-1df2-4e72-9162-7d4bb4cac904.jpg)'
- en: The product-search service
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品搜索服务
- en: Let's create a new microservice that specializes in high speed, high volume
    searches. The search data store backing the search microservice need not be a
    master of the product data, but can act as a complementary search model. Elasticsearch
    has been extremely popular for a variety of search use cases and fits the need
    for extreme search requirements.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门进行高速、高容量搜索的新微服务。支持搜索微服务的搜索数据存储不需要是产品数据的主数据，而可以作为补充的搜索模型。Elasticsearch在各种搜索用例中都非常受欢迎，并且符合极端搜索需求的需求。
- en: Getting Elasticsearch ready with test data
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备Elasticsearch的测试数据
- en: 'The following are the steps to get Elasticsearch ready with test data:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是准备Elasticsearch的测试数据的步骤：
- en: Install the Elastic version. Use version 2.4.3, since the recent 5.1 versions
    are not compatible with Spring Data. Spring Data uses Java drivers that communicate
    on port `9300` with the server, and hence having the same version on the client
    and server is important.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Elastic版本。使用版本2.4.3，因为最近的5.1版本与Spring Data不兼容。Spring Data使用在端口`9300`上与服务器通信的Java驱动程序，因此在客户端和服务器上具有相同的版本非常重要。
- en: 'Create a test file with our sample data (similar to `products.json`). The format
    is only slightly different from the previous case, but for Elasticsearch instead
    of MongoDB. The `products.json` file is as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含我们的样本数据的测试文件（类似于`products.json`）。格式与以前的情况略有不同，但是针对Elasticsearch而不是MongoDB。`products.json`文件如下：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use Postman or cURL to call a REST service on Elasticsearch to load the data.
    See the following screenshot for output in the Postman extension. In Elasticsearch,
    the equivalent of a database is an index, and we can name our index `product`.
    Elasticsearch also has a concept of type, but more on that later:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman或cURL调用Elasticsearch上的REST服务来加载数据。请参阅以下屏幕截图以查看Postman扩展中的输出。在Elasticsearch中，数据库的等价物是索引，我们可以命名我们的索引为`product`。Elasticsearch还有一个类型的概念，但稍后再说：
- en: '![](img/223b6d21-d33a-439d-aa8f-268b9c4872f7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/223b6d21-d33a-439d-aa8f-268b9c4872f7.png)'
- en: 'Check whether the data got loaded by running a simple `*` query in Postman,
    the browser, or cURL:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Postman、浏览器或cURL中运行简单的`*`查询来检查数据是否已加载：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As a result, you should get the four products added.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您应该得到添加的四个产品。
- en: Creating the product-search service
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建产品搜索服务
- en: 'With two databases done so far, you must be familiar with the drill by now.
    It is not very different from what we did for HSQLDB and MongoDB. Copy the Mongo
    project to create a `productsearch` service and make the changes as before to
    the Maven POM, entity, repository classes, and the application properties:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经完成了两个数据库，现在你一定对这个流程很熟悉了。这与我们为HSQLDB和MongoDB所做的并没有太大的不同。复制Mongo项目以创建`productsearch`服务，并像以前一样对Maven
    POM、实体、存储库类和应用程序属性进行更改：
- en: In the Maven POM, `spring-boot-starter-data-elasticsearch` replaces `spring-boot-starter-data-mongodb`
    or `spring-boot-starter-data-jpa` in the earlier two service examples.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Maven POM中，`spring-boot-starter-data-elasticsearch`取代了之前两个服务示例中的`spring-boot-starter-data-mongodb`或`spring-boot-starter-data-jpa`。
- en: 'In the `Product` entity, `@Document` now represents an Elasticsearch document.
    It should have an `index` and `type` defined the same since we used to load the
    test data as shown in the `Product.java` file:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Product`实体中，`@Document`现在表示一个Elasticsearch文档。它应该有一个定义相同的`index`和`type`，因为我们用来加载测试数据，如`Product.java`文件所示：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `ProductRepository` now extends `ElasticsearchRepository` as shown in the
    `ProductRepository.java` file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductRepository`现在扩展了`ElasticsearchRepository`，如`ProductRepository.java`文件所示：'
- en: '[PRE28]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Make changes in the `application.properties` to indicate a server model of `elasticsearch`
    (versus the embedded model, like we did for HSQLDB):'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application.properties`中进行更改，指示`elasticsearch`的服务器模型（与嵌入式模型相对，就像我们为HSQLDB所做的那样）：
- en: '[PRE29]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, start the Eureka server and then the `productsearch` service and fire
    the following queries in the browser, in the following order:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动Eureka服务器，然后启动`productsearch`服务，并按照以下顺序在浏览器中发出以下查询：
- en: '`http://localhost:8085/products?id=1`.'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=1`。'
- en: '`http://localhost:8085/products?id=2`.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`http://localhost:8085/products?id=2`。'
- en: You will get the same JSONs back as before. This is an internal implementation
    change of the microservice from the hard coded implementation in [Chapter 2](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml), *Writing
    Your First Cloud-Native Application,* to HSQLDB, MongoDB, and now Elasticsearch.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '你将得到与之前相同的JSON。这是微服务的内部实现变化，从[第2章](8a0a7cae-4aaa-460d-a760-59d0ffde9b48.xhtml)中的硬编码实现到HSQLDB、MongoDB，现在是Elasticsearch。 '
- en: 'Due to the Spring Data framework, the code to access the driver and communicate
    with it has been heavily abstracted from us, so all we need to do is add the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Spring Data框架，访问驱动程序并与其通信的代码已经被大大抽象化，所以我们只需要添加以下内容：
- en: Dependencies in the Maven POM file.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven POM文件中的依赖项。
- en: Base class to extend from in the case of a repository.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在存储库的情况下扩展的基类。
- en: Annotations to use for the entities.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于实体的注解。
- en: Properties to configure in application properties.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序属性中配置的属性。
- en: Data update services
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据更新服务
- en: So far, we have looked at getting the data. Let's look at some of the data modification
    operations, such as creating, updating, and deleting (CRUD operations).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看过了获取数据。让我们看一些数据修改操作，比如创建、更新和删除（CRUD操作）。
- en: Given the popularity of REST for cloud-based API operations, we will do our
    data manipulation through REST methods.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于REST在基于云的API操作中的流行度，我们将通过REST方法进行数据操作。
- en: Let's pick the HSQLDB example with Hazelcast that we worked on previously in
    this chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择在本章之前使用Hazelcast的HSQLDB示例。
- en: REST conventions
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST惯例
- en: 'The `GET` method was a no-brainer, but the choice of the methods for operations
    such as creating, inserting, and deleting require some deliberation. We will follow
    the conventions as per industry guidelines:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: GET方法是一个不用大脑思考的选择，但是对于创建、插入和删除等操作的方法的选择需要一些考虑。我们将遵循行业指南的惯例：
- en: '| **URL** | **HTTP operation** | **Service method** | **Description** |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| **URL** | **HTTP操作** | **服务方法** | **描述** |'
- en: '| `/product/{id}` | `GET` | `getProduct` | Gets a product given an ID |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `GET` | `getProduct` | 获取给定ID的产品 |'
- en: '| `/product` | `POST` | `insertProduct` | Inserts the product and returns a
    new ID |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| `/product` | `POST` | `insertProduct` | 插入产品并返回一个新的ID |'
- en: '| `/product/{id}` | `PUT` | `updateProduct` | Updates a product for a given
    ID with the data in the request body |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `PUT` | `updateProduct` | 使用请求体中的数据更新给定ID的产品 |'
- en: '| `/product/{id}` | `DELETE` | `deleteProduct` | Deletes the product with a
    provided ID |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| `/product/{id}` | `DELETE` | `deleteProduct` | 删除提供的ID的产品 |'
- en: Let's look at the implementations in the `ProductService` class. We already
    had the `getProduct` implementation from earlier in the chapter. Let's add the
    other methods.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ProductService`类中的实现。我们已经在本章前面有了`getProduct`的实现。让我们添加其他方法。
- en: Inserting a product
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入产品
- en: Leaving aside validations for a minute (which we will cover in a while), the
    insertion looks very simple to implementing the REST interface.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 暂且不考虑验证（我们一会儿会讨论），插入看起来非常简单，实现REST接口。
- en: 'We map the `POST` operation to the `insertProduct` method and in the implementation,
    we just call `save` on the repository that was already defined:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`POST`操作映射到`insertProduct`方法，在实现中，我们只需在已经定义的存储库上调用`save`：
- en: '[PRE30]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Notice a few differences from the `getProduct` method we coded earlier:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一下我们之前编码的`getProduct`方法有一些不同之处：
- en: We have added a `POST` method in `@RequestMapping` so that the URL will map
    to the `insertProduct` method when HTTP `POST` is used.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在`@RequestMapping`中添加了一个`POST`方法，这样当使用HTTP `POST`时，URL将映射到`insertProduct`方法。
- en: We are capturing the `product` details from the `@RequestBody` annotation. This
    is expected to be supplied when inserting a new product. Spring does the job of
    mapping JSON (or XML) to the `Product` class for us.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`@RequestBody`注解中捕获`product`的详细信息。这在插入新产品时应该提供。Spring会为我们将JSON（或XML）映射到`Product`类。
- en: We are returning a `ResponseEntity` instead of just a `Product` object as we
    did in the `getProduct` method. This allows us to customize the HTTP responses
    and headers, which is important in REST architecture. For a successful insert,
    we are returning an HTTP `OK` (`200`) response, telling the client that his request
    to add a product was successful.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们返回一个`ResponseEntity`而不是像`getProduct`方法中那样只返回一个`Product`对象。这使我们能够自定义HTTP响应和标头，在REST架构中这很重要。对于成功的插入，我们返回一个HTTP
    `OK`（`200`）响应，告诉客户端他添加产品的请求成功了。
- en: Testing
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'The steps to test our `insertProduct` method are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的`insertProduct`方法的步骤如下：
- en: Start the Eureka server, then the `product` service (assuming it is listening
    on `8082`).
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eureka服务器，然后启动`product`服务（假设它在`8082`上监听）。
- en: Note that a browser will not suffice now, as we want to indicate the HTTP methods
    and provide a response body. Use Postman or cURL instead.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，现在浏览器不够用了，因为我们想要指示HTTP方法并提供响应主体。改用Postman或cURL。
- en: Set the content-type to application/json, since we will be submitting the new
    product information as a JSON.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容类型设置为application/json，因为我们将以JSON格式提交新的产品信息。
- en: 'Provide the production information in JSON format, such as `{"name":"Grapes","catId":1}`.
    Note we are not providing a product ID:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以JSON格式提供产品信息，例如`{"name":"Grapes","catId":1}`。注意我们没有提供产品ID：
- en: '![](img/26243ae4-d45a-4ae7-8006-12028ba5a606.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/26243ae4-d45a-4ae7-8006-12028ba5a606.png)'
- en: Hit Send. You will get a response with the product JSON. This time, an ID will
    be populated. This is the ID generated by the repository (which in turn got it
    from the underlying database).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击发送。你会得到一个包含产品JSON的响应。这次，ID将被填充。这是存储库生成的ID（它又从底层数据库中获取）。
- en: Updating a product
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新产品
- en: 'Here, instead of `POST`, we will use a `PUT` method indicating the ID of the
    product to be updated in the URL pattern. Like the `POST` method, the details
    of the product to be updated are provided in the `@RequestBody` annotation:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用`PUT`方法，指示URL模式中要更新的产品的ID。与`POST`方法一样，要更新的产品的详细信息在`@RequestBody`注解中提供：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The implementation involves:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 实现包括：
- en: Retrieving an existing product from the repository.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从存储库中检索现有产品。
- en: Making changes to it as per business logic.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据业务逻辑对其进行更改。
- en: Saving it back to the repository.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其保存回存储库。
- en: Returning the updated product (for client verification) with an `OK` status
    as before.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回更新后的产品（供客户端验证），状态仍然是`OK`。
- en: If you hadn't noticed, the last two steps are exactly like the insert case.
    It is just the retrieval and update of the product that are the new steps.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有注意到，最后两个步骤与插入情况完全相同。只是检索和更新产品是新步骤。
- en: Testing
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'The steps to test our `insertProduct` method are as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 测试我们的`insertProduct`方法的步骤如下：
- en: As we did for inserting a product, fire up Eureka and `ProductService` again.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与插入产品一样，再次启动Eureka和`ProductService`。
- en: Let's change the product description of the first product to `Fuji Apples`.
    So, our JSON looks like `{"id":1,"name":"Fuji Apples","catId":1}`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将第一个产品的产品描述更改为`Fuji Apples`。所以，我们的JSON看起来像`{"id":1,"name":"Fuji Apples","catId":1}`。
- en: 'Prepare Postman to submit the `PUT` request as follows:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备Postman提交`PUT`请求如下：
- en: '![](img/f2d1f8ef-960a-431f-803a-8c92e2f6f31f.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f2d1f8ef-960a-431f-803a-8c92e2f6f31f.png)'
- en: Hit Send. You will get a response 200 OK with the body containing the JSON `{"id":1,"name":"Fuji
    Apples","catId":1}`.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击发送。你会得到一个包含JSON `{"id":1,"name":"Fuji Apples","catId":1}`的响应200 OK。
- en: Fire a `GET` request `http://localhost:8082/product/1` to check the change.
    You will find `apples` changed to `Fuji Apples`.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送一个`GET`请求`http://localhost:8082/product/1`来检查变化。你会发现`apples`变成了`Fuji Apples`。
- en: Deleting a product
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除产品
- en: 'The mapping and implementation for deleting a product looks as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 删除产品的映射和实现如下：
- en: '[PRE32]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We invoke the `delete` operation on the repository and return `OK` to the client,
    assuming everything is fine.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在存储库上调用`delete`操作，并假设一切正常向客户端返回`OK`。
- en: Testing
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'To test, fire a `DELETE` request through Postman on the product ID `1`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，在Postman上对产品ID `1` 发送一个`DELETE`请求：
- en: '![](img/77d19943-8481-434f-8cdb-1c02cbcfa091.png)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77d19943-8481-434f-8cdb-1c02cbcfa091.png)'
- en: You will get a 200 OK response. To check whether it really got deleted, try
    a `GET` request on the same product. You will get an empty response.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到一个200 OK的响应。要检查它是否真的被删除，尝试对同一产品进行`GET`请求。你会得到一个空的响应。
- en: Cache invalidation
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存失效
- en: If you do a get operation that populates the cache, then either the cache updates,
    or invalidation has to take place when `PUT`/`POST`/`DELETE` operations occur
    that update the data.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果进行填充缓存的获取操作，那么当进行`PUT`/`POST`/`DELETE`操作更新数据时，缓存要么更新，要么失效。
- en: If you recollect, we had a cache that held the products corresponding to a category
    ID. As we add and remove products using the APIs created for inserting, updating,
    and deleting, the cache needs to be refreshed. Our first preference is to check
    if we can update the cache entry. However, the business logic of pulling the categories
    corresponding to the cache is present in the database (through a `WHERE` clause).
    Hence, it is best to invalidate the cache containing the relations when a product
    update happens.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，我们有一个缓存，保存着与类别ID对应的产品。当我们使用为插入、更新和删除创建的API添加和移除产品时，缓存需要刷新。我们首选检查是否可以更新缓存条目。然而，拉取与缓存对应的类别的业务逻辑存在于数据库中（通过`WHERE`子句）。因此，最好在产品更新时使包含关系的缓存失效。
- en: The general assumption for a caching use case is that the reads are much higher
    than inserts and updates.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存使用情况的一般假设是读取远远高于插入和更新。
- en: 'To enable cache eviction, we have to add the methods in the `ProductRepository`
    class and provide an annotation. Hence, we add two new methods to the interface
    in addition to the existing `findByCatId` method, and mark eviction to be false:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用缓存驱逐，我们必须在`ProductRepository`类中添加方法并提供注释。因此，我们在接口中除了现有的`findByCatId`方法之外添加了两个新方法，并标记驱逐为false：
- en: '[PRE33]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Though the preceding code is a valid solution, it is not efficient. It clears
    the entire cache. Our cache could have 100s of categories and it is not right
    to clear the ones that are not related to the product being inserted, updated,
    or deleted.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码是有效的解决方案，但并不高效。它会清除整个缓存。我们的缓存可能有数百个类别，清除与插入、更新或删除产品无关的类别是不正确的。
- en: 'We could be a little more intelligent in only clearing the entries related
    to the category being operated upon:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更加智能地只清除与正在操作的类别相关的条目：
- en: '[PRE34]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The code is a little cryptic because of the **Spring Expression Language**
    (**SpEL**), and the documentation of `CacheEvict`:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**Spring表达式语言**（**SpEL**）和`CacheEvict`的文档，代码有点晦涩：
- en: '`key` indicates what cache entry we want to clear.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`key`表示我们要清除的缓存条目。'
- en: '`#result` indicates the return result. We extract the `catId` out of it and
    use it to clear the data.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#result`表示返回结果。我们从中提取`catId`并用它来清除数据。'
- en: '`#p0` indicates the first parameter in the method called. This is the `product`
    object that we want to use the category from and then delete the object.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`#p0`表示调用方法中的第一个参数。这是我们想要使用类别并删除对象的`product`对象。'
- en: 'To test whether cache removal is working fine, start the service and Eureka,
    fire the following requests, and observe the results:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试缓存清除是否正常工作，启动服务和Eureka，发送以下请求，并观察结果：
- en: '| **Request** | **Result** |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| **请求** | **结果** |'
- en: '| `http://localhost:8082/products?id=1` | Gets the product corresponding to
    category `1` and caches it. SQL will be displayed in the out log. |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `http://localhost:8082/products?id=1` | 获取与类别`1`对应的产品并将其缓存。SQL将显示在输出日志中。|'
- en: '| `http://localhost:8082/products?id=1` | Gets the products from cache. No
    entry in the SQL updated. |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `http://localhost:8082/products?id=1` | 从缓存中获取产品。SQL中没有更新条目。|'
- en: '| `POST` to `http://localhost:8082/product`Add `{"name":"Mango","catId":1}`
    as `application/json` | Adds the new Mango product to the database. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| `POST`到`http://localhost:8082/product`添加`{"name":"Mango","catId":1}`作为`application/json`
    | 将新的芒果产品添加到数据库。|'
- en: '| `http://localhost:8082/products?id=1` | Reflects the newly added Mango. SQL
    indicates the data was refreshed. |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| `http://localhost:8082/products?id=1` | 反映了新添加的芒果。SQL表明数据已刷新。|'
- en: Validations and error messages
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证和错误消息
- en: 'So far, we have been treading in very safe territory and assuming happy paths.
    But not everything will be right all the time. There are many scenarios such as:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在非常安全的领域中前行，假设一切都是顺利的。但并不是一切都会一直正确。有许多情景，例如：
- en: '`GET`, `PUT`, `DELETE` requests for products that don''t exist.'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GET`、`PUT`、`DELETE`请求的产品不存在。'
- en: '`PUT` and `POST` missing critical information, for example, no product name
    or category.'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PUT`和`POST`缺少关键信息，例如，没有产品名称或类别。'
- en: Business validations, such as products, should belong to known categories and
    names should be more than 10 characters.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 业务验证，例如产品，应属于已知类别，名称应超过10个字符。
- en: Incorrect formats of the data submitted, such as alphanumeric for category ID
    where only an integer was expected.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交的数据格式不正确，例如类别ID的字母数字混合，而预期只有整数。
- en: And these are not exhaustive. Therefore, it is always important to do validations
    and return appropriate error codes and messages when things go wrong.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这些还不是详尽无遗的。因此，当出现问题时，进行验证并返回适当的错误代码和消息是非常重要的。
- en: Format validations
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式验证
- en: If the request has errors in the format of the request body being submitted
    (for example, invalid JSON), then Spring throws an error before it reaches the
    method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的请求体格式有错误（例如，无效的JSON），那么Spring在到达方法之前就会抛出错误。
- en: 'For example, for a `POST` request to `http://localhost:8082/product`, if the
    submitted body is missing commas, such as `{"id":1 "name":"Fuji Apples" "catId":1}`,
    then the error returned is `400` as follows. This indicates it is a badly formed
    request:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于`POST`请求到`http://localhost:8082/product`，如果提交的主体缺少逗号，例如`{"id":1 "name":"Fuji
    Apples" "catId":1}`，那么返回的错误代码是`400`。这表示这是一个格式不正确的请求：
- en: '[PRE35]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Likewise, a letter instead of a number, for example, in ID, will be caught
    early enough. For example, `http://localhost:8082/product/A` will result in a
    `Failed to convert value` error:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，例如在ID中使用字母而不是数字，将会很早地被捕获。例如，`http://localhost:8082/product/A`将导致`无法转换值`错误：
- en: '![](img/be5bdaae-67c1-4cd8-820c-797df80d1548.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be5bdaae-67c1-4cd8-820c-797df80d1548.png)'
- en: Data validations
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据验证
- en: 'A few errors can be caught at the entity level, if they are not allowed. For
    example, not providing a product description when we have annotated the `Product`
    entity as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 一些错误可以在实体级别捕获，如果它们是不允许的。例如，当我们已经将`Product`实体注释为以下内容时，没有提供产品描述：
- en: '[PRE36]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will cause the error message while trying to save the product supplied
    in the request without the name, for example, `{"id":1, "catId":1}`.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致错误消息，尝试在请求中保存没有名称的产品，例如`{"id":1, "catId":1}`。
- en: 'The server returns a `500` internal server error and gives a detailed message
    as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器返回`500`内部服务器错误，并给出详细消息如下：
- en: '[PRE37]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is not a very clean message to return to the client. Therefore, it is better
    to catch the validations upfront and return a `400` error code back to the client.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个很清晰的消息返回给客户。因此，最好在前期捕获验证并向客户返回`400`错误代码。
- en: Business validations
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务验证
- en: 'This will typically be done in code, as it is specific to the functionality
    or business use case being addressed. For example, checking for a product before
    updating or deleting it. This is a simple code-based validation as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常会在代码中完成，因为它是特定于正在解决的功能或业务用例的。例如，在更新或删除产品之前检查产品。这是一个简单的基于代码的验证，如下所示：
- en: '[PRE38]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Exceptions and error messages
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常和错误消息
- en: In case of error, the simplest thing to begin with is to indicate an error message
    telling us what went wrong, especially in case of a bad input request or business
    validations since the client (or requestor) may have no idea of what went wrong.
    For example, in the preceding case, the `NOT_FOUND` status code is returned, But
    no other details are supplied.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在出现错误的情况下，最简单的开始是指示一个错误消息，告诉我们出了什么问题，特别是在出现错误的输入请求或业务验证的情况下，因为客户端（或请求者）可能不知道出了什么问题。例如，在前面的情况下，返回`NOT_FOUND`状态码，但没有提供其他细节。
- en: Spring provides interesting notations such as `ExceptionHandler` and `ControllerAdvice`
    to handle this error. Let's see how this works.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: Spring提供了有趣的注释，如`ExceptionHandler`和`ControllerAdvice`来处理这个错误。让我们看看这是如何工作的。
- en: 'Secondly, the service method earlier was directly manipulating the `ResponseEntity`
    by sending HTTP codes. We will revert it back to return business objects such
    as `Product` instead of `ResponseEntity`, making it more POJO-like. Revert back
    the `deleteProduct` code discussed earlier to the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，服务方法之前直接通过发送HTTP代码来操作`ResponseEntity`。我们将其恢复为返回业务对象，如`Product`，而不是`ResponseEntity`，使其更像POJO。将之前讨论的`deleteProduct`代码恢复如下：
- en: '[PRE39]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the preceding code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中：
- en: We are returning `Product` instead of `ResponseEntity`, as handling error codes
    and responses will be done externally.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们返回`Product`而不是`ResponseEntity`，因为处理错误代码和响应将在外部完成。
- en: An exception is thrown (a runtime exception or its extended version) that tells
    us what was wrong in the request.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抛出异常（运行时异常或其扩展版本），告诉我们请求出了什么问题。
- en: The scope of the `Product` method ends here.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Product`方法的范围到此结束。'
- en: 'The `BadRequestException` class is a simple class that provides an ID and extends
    from the `RuntimeException` class:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`BadRequestException`类是一个简单的类，提供了一个ID，并继承自`RuntimeException`类。'
- en: '[PRE40]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When you execute the service now, instead of just getting a `404 Not Found`
    status, we will get a proper message indicating what went wrong. See the screenshot
    of the request sent and the exception received:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当您现在执行服务时，不仅会得到`404 Not Found`状态，还会得到一个明确指出出了什么问题的消息。查看发送的请求和收到的异常的截图：
- en: '![](img/560efdc6-1e05-47da-ad36-c1a27415a0bf.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/560efdc6-1e05-47da-ad36-c1a27415a0bf.png)'
- en: However, sending `500` and getting an exception stack in the logs is not clean.
    `500` gives an indication that the error handling is not robust and stack traces
    are thrown around.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，发送`500`并在日志中得到异常堆栈并不干净。`500`表明错误处理不够健壮，堆栈跟踪被抛出。
- en: 'Therefore, we should capture and handle this error. Spring provides `@ExceptionHandler`
    that can be used in the service. This annotation on a method enables Spring to
    call the method to handle the error:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该捕获和处理这个错误。Spring提供了`@ExceptionHandler`，可以在服务中使用。在方法上使用这个注解，Spring就会调用这个方法来处理错误：
- en: '[PRE41]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When we execute the service now, and call the `DELETE` method with a product
    ID that is not available, the error code becomes more specific and looks clean
    enough:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在执行服务，并调用一个不可用的产品ID的`DELETE`方法时，错误代码变得更加具体和清晰：
- en: '![](img/4990398e-de85-4c46-a6e4-6752e4549d3c.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4990398e-de85-4c46-a6e4-6752e4549d3c.png)'
- en: Now, taking a step further, what if we want all our services to follow this
    pattern of raising a `BadRequestException` and returning the correct error codes?
    Spring provides a mechanism called `ControllerAdvice` which when used in a class,
    the exception handlers within the class can be applied universally to all services
    in the scope.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再进一步，如果我们希望所有的服务都遵循这种提出`BadRequestException`并返回正确的错误代码的模式呢？Spring提供了一种称为`ControllerAdvice`的机制，当在一个类中使用时，该类中的异常处理程序可以普遍应用于范围内的所有服务。
- en: 'Create a new class as follows and put it in the exception package:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的类如下，并将其放在异常包中：
- en: '[PRE42]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This allows the exceptions to be handled across the services in a consistent
    way.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许异常以一致的方式在服务之间处理。
- en: Data updates for CQRS
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS的数据更新
- en: As discussed in the previous chapter, and we saw in action in the previous section,
    the CQRS pattern provides an efficient and fit for purpose data model for handling
    commands and queries separately. To recap, we had a flexible document model in
    MongoDB to handle the command pattern with transaction guarantees. We had a flexible
    query model in Elasticsearch to handle complex search conditions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章讨论的，并且我们在前一节中看到的，CQRS模式为处理命令和查询提供了高效和合适的数据模型。回顾一下，我们在MongoDB中有一个灵活的文档模型来处理具有事务保证的命令模式。我们在Elasticsearch中有一个灵活的查询模型来处理复杂的搜索条件。
- en: Though this pattern allows easier queries due to fit for purpose query models,
    the challenge comes in updating data across the various models. In the previous
    chapter, we discussed multiple mechanisms of keeping the information updated across
    the models, such as distributed transactions, and eventually consistent models
    using Publish-Subscribe messaging.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种模式由于合适的查询模型而允许更容易的查询，但挑战在于跨各种模型更新数据。在前一章中，我们讨论了多种机制来保持信息在模型之间的更新，如分布式事务，使用发布-订阅消息的最终一致模型。
- en: In the following sections, we will look at using messaging and the asynchronous
    mechanism of updating data.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看看使用消息传递和异步更新数据的机制。
- en: Asynchronous messaging
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步消息
- en: HTTP/REST provides for a request response mechanism to execute the service.
    The client waits (or rather, blocks) till the processing is complete and uses
    the result provided at the end of the service. Therefore, the processing is said
    to be synchronous.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP/REST提供了请求响应机制来执行服务。客户端等待（或者说是阻塞），直到处理完成并使用服务结束时提供的结果。因此，处理被称为同步的。
- en: In asynchronous processing, the client does not wait for the response. Asynchronous
    processing can be used in two scenarios, such as **fire-and-forget** and **request/response**.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步处理中，客户端不等待响应。异步处理可以用于两种情况，如**发送和忘记**和**请求/响应**。
- en: In fire and forget, the client sends a command or request to the downstream
    service, and then does not require a response. It is used typically in pipeline
    processing architecture, where one service does enrichment and processing of the
    request and sends it to the other service, which sends to a third service, and
    so on.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在“发送并忘记”中，客户端向下游服务发送命令或请求，然后不需要响应。它通常用于管道处理架构，其中一个服务对请求进行丰富和处理，然后将其发送到另一个服务，后者发送到第三个服务，依此类推。
- en: In asynchronous request/response, the client sends a request to the service,
    but unlike synchronous processing, it does not wait or block for the response.
    When the service finishes processing, it has to notify the client so that the
    client can use the response.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步请求/响应中，客户端向服务发送请求，但与同步处理不同，它不会等待或阻塞响应。当服务完成处理时，必须通知客户端，以便客户端可以使用响应。
- en: In CQRS, we use messaging to send update events to the various services, so
    that the read or query models can be updated.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS中，我们使用消息传递将更新事件发送到各种服务，以便更新读取或查询模型。
- en: To begin with, we will use ActiveMQ as a reliable messaging mechanism in this
    chapter and then look at Kafka as a scalable distributed messaging system in the
    chapters ahead.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在本章中使用ActiveMQ作为可靠的消息传递机制，然后在接下来的章节中查看Kafka作为可扩展的分布式消息传递系统。
- en: Starting ActiveMQ
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动ActiveMQ
- en: 'The steps to set up ActiveMQ are as follows:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 设置ActiveMQ的步骤如下：
- en: Download ActiveMQ from the Apache website ([http://activemq.apache.org/](http://activemq.apache.org/)).
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Apache网站（[http://activemq.apache.org/](http://activemq.apache.org/)）下载ActiveMQ。
- en: Unzip it to a folder.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压到一个文件夹中。
- en: Navigate to the `bin` folder.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`bin`文件夹。
- en: Run the `activemq start` command.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`activemq start`命令。
- en: 'Open the console to see messages and manage ActiveMQ at `http://localhost:8161/admin`
    and log in with `admin/admin`. You should see the UI interface as follows:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 打开控制台查看消息并管理ActiveMQ，网址为`http://localhost:8161/admin`，使用`admin/admin`登录。您应该看到以下UI界面：
- en: '![](img/1cfc6980-39fc-4595-944b-cb0924b5375e.png)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cfc6980-39fc-4595-944b-cb0924b5375e.png)'
- en: Creating a topic
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个主题
- en: 'Click on the Topics link and create a topic named `ProductT`. You can follow
    the naming convention you are used to. This topic will get all the updates for
    a product. These updates can be used for various downstream processing purposes,
    such as keeping the local data models up to date. Once you create a topic, it
    will appear in the list of topics on the admin console which is shown as follows.
    The other two topics are ActiveMQ''s own topics and we will leave them alone:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“主题”链接，创建一个名为`ProductT`的主题。您可以按照您习惯的命名约定进行操作。此主题将获取产品的所有更新。这些更新可以用于各种下游处理目的，例如保持本地数据模型的最新状态。创建主题后，它将出现在管理控制台的主题列表中，如下所示。另外两个主题是ActiveMQ自己的主题，我们将不予理睬：
- en: '![](img/2a58660a-8356-411e-b92e-d158436391dd.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2a58660a-8356-411e-b92e-d158436391dd.png)'
- en: Golden source update
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黄金源更新
- en: 'When there are multiple models in CQRS, we follow the golden source pattern,
    as discussed earlier:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 当CQRS中有多个模型时，我们遵循之前讨论的黄金源模式：
- en: One model (command model) is considered the golden source.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个模型（命令模型）被认为是黄金源。
- en: All validations are performed before updating to the golden source.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在更新到黄金源之前进行所有验证。
- en: The update to the golden source happens in a transaction to avoid any inconsistent
    update and failure states. So, the update operation is automatic.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对黄金源的更新发生在一个事务中，以避免任何不一致的更新和失败状态。因此，更新操作是自动的。
- en: Once the update is complete, a broadcast message is put on a topic.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新完成后，将在一个主题上放置广播消息。
- en: If there is an error in putting the message on topic, the transaction is rolled
    back and the client is sent an error.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在将消息放在主题上时出现错误，则事务将被回滚，并向客户端发送错误。
- en: We did a CQRS implementation using MongoDB and Elasticsearch. In our case, MongoDB
    is the golden source of the product data (also the command model). Elasticsearch
    is the query model that contains the data organized from a search perspective.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用MongoDB和Elasticsearch进行了CQRS实现。在我们的情况下，MongoDB是产品数据的黄金源（也是命令模型）。Elasticsearch是包含从搜索角度组织的数据的查询模型。
- en: Let's first look at updating the command model or the golden source.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们来看看更新命令模型或黄金源。
- en: Service methods
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务方法
- en: 'We did three methods in HSQLDB implementation: inserting, updating, and deleting.
    Copy the same methods to the MongoDB-based project, so that the service class
    in this project is exactly the same as that in the HSQLDB project.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在HSQLDB实现中做了三种方法：插入、更新和删除。将相同的方法复制到基于MongoDB的项目中，以便该项目中的服务类与HSQLDB项目中的完全相同。
- en: 'Also, copy the exception class and `ControllerAdvice` that we did in the HSQLDB
    project. Your package structure should look identical to the HSQLDB project, which
    is shown as follows:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，复制在HSQLDB项目中完成的异常类和`ControllerAdvice`。您的包结构应该与HSQLDB项目完全相同，如下所示：
- en: '![](img/6f296550-226c-45be-add3-8137c49cb1f2.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f296550-226c-45be-add3-8137c49cb1f2.png)'
- en: The difference in this project is that the ID is a string, as that supports
    better native handling in MongoDB for ID creation. Therefore, the method signatures
    will be string for ID instead of integer as in our HSQLDB project.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中的不同之处在于ID是一个字符串，因为这样可以更好地在MongoDB中进行ID创建的本地处理。因此，方法签名将是字符串ID，而不是我们HSQLDB项目中的整数。
- en: 'A `PUT` operation that updates the MongoDB is shown as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 显示更新MongoDB的`PUT`操作如下：
- en: '[PRE43]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Test whether the get, insert, update, and delete operations run as they should.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 测试获取、插入、更新和删除操作是否按预期运行。
- en: Raising an event on data updates
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数据更新时引发事件
- en: 'When an insert, delete, or update operation happens, it is important for the
    golden source system to broadcast the change, so that a lot of downstream actions
    can happen. This includes:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 当插入、删除或更新操作发生时，黄金源系统广播更改是很重要的，这样许多下游操作就可以发生。这包括：
- en: Cache clearance by dependent systems.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 依赖系统的缓存清除。
- en: Update of the local data models in the system.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统中本地数据模型的更新。
- en: Doing further business processing, for example, sending emails to interested
    customers on the addition of a new product.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进一步进行业务处理，例如在添加新产品时向感兴趣的客户发送电子邮件。
- en: Using Spring JMSTemplate to send a message
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Spring JMSTemplate发送消息
- en: 'The steps to use JMSTemplate are as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JMSTemplate的步骤如下：
- en: 'Include Spring starter for ActiveMQ in our POM file:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的POM文件中包含Spring ActiveMQ的启动器：
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We have to enable JMS support for our Spring application. Therefore, include
    an annotation in the `ProductSpringApp.java` file as follows, and provide a message
    converter. The message converter will help convert objects to JSON and vice versa:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须为我们的Spring应用程序启用JMS支持。因此，请在`ProductSpringApp.java`文件中包括注解，并提供消息转换器。消息转换器将帮助将对象转换为JSON，反之亦然：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Create an entity that encapsulates the `Product` and the action, so that whoever
    gets the product message will also know if the action performed was delete or
    insert/update, by adding the entity in the `ProductUpdMsg.java` file as follows:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个封装`Product`和操作的实体，这样无论谁收到产品消息，都会知道执行的操作是删除还是插入/更新，通过在`ProductUpdMsg.java`文件中添加实体，如下所示：
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If there are more actions, feel free to change the `isDelete` flag to a string
    action flag based on your use case.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有更多操作，请随时根据您的用例将`isDelete`标志更改为字符串操作标志。
- en: 'Configure the JMS properties in the `application.properties` file. The `pub-sub-domain`
    indicates a topic should be used instead of a queue. Note that by default, the
    message is persistent:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`application.properties`文件中配置JMS属性。`pub-sub-domain`表示应使用主题而不是队列。请注意，默认情况下，消息是持久的：
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Create a message producer component that will do the job of sending messages:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个消息生产者组件，它将负责发送消息：
- en: This is based on Spring's `JmsMessagingTemplate`
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是基于Spring的`JmsMessagingTemplate`
- en: Uses `JacksonJmsMessageConverter` to convert from object to message structure
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`JacksonJmsMessageConverter`将对象转换为消息结构
- en: 'The `ProductMsgProducer.java` file is as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProductMsgProducer.java`文件如下：'
- en: '[PRE48]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, in your service, declare the `producer` and invoke it after finishing
    the insert, update, and delete operations and before returning the response. The
    `DELETE` method is shown in the following, where the flag `isDelete` is true.
    The other methods will have the flag as false. The `ProductService.java` file
    is as follows:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的服务中，声明`producer`，并在完成插入、更新和删除操作之后调用它，然后返回响应。`DELETE`方法如下所示，其中标志`isDelete`为true。其他方法的标志将为false。`ProductService.java`文件如下：
- en: '[PRE49]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will send the message on the topic, which you can see in the admin console
    under the topics section.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在主题上发送消息，您可以在管理控制台的主题部分看到。
- en: Query model update
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询模型更新
- en: On the `productsearch` project, we will have to make changes to update the records
    in Elasticsearch.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在`productsearch`项目中，我们将不得不进行更改以更新Elasticsearch中的记录。
- en: Insert, update, and delete methods
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插入、更新和删除方法
- en: 'These methods are very different from the ones we designed in MongoDB. Here
    are the differences:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法与我们在MongoDB中设计的方法非常不同。以下是区别：
- en: MongoDB methods had stringent validations. Validations are not required for
    Elasticsearch as the master (command model or golden source) is assumed to be
    updated and we have to apply the updates to the query model.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MongoDB方法有严格的验证。对于Elasticsearch，不需要验证，因为假定主服务器（命令模型或黄金源）已更新，我们必须将更新应用到查询模型中。
- en: Any error in updating the query model has to be alerted, and should not go unnoticed.
    We will look at that aspect in the chapters ahead.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新查询模型时的任何错误都必须得到警告，不应被忽视。我们将在后面的章节中看到这一方面。
- en: We do not separate the insert and update method. The single save method suffices
    for both purposes due to our `ProductRepository` class.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不分开插入和更新方法。由于我们的`ProductRepository`类，单个保存方法就足够了。
- en: Also, these methods do not have to be exposed as REST HTTP services, as they
    might not be called directly other than through message updates. We do that here
    only for convenience.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，这些方法不必暴露为REST HTTP服务，因为除了通过消息更新之外，可能不会直接调用它们。我们之所以在这里这样做，只是为了方便。
- en: In the `product-nosql` (MongoDB) project, we called our `ProductMsgProducer`
    class from the `ProductService` class. In this `productsearch-nosql` project,
    it will be the other way around, with the `ProductUpdListener` calling the service
    methods.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`product-nosql`（MongoDB）项目中，我们从`ProductService`类中调用了我们的`ProductMsgProducer`类。在`productsearch-nosql`项目中，情况将完全相反，`ProductUpdListener`将调用服务方法。
- en: 'Here are the changes:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更改：
- en: 'Maven POM—dependency on the ActiveMQ:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Maven POM—依赖于ActiveMQ：
- en: '[PRE50]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Application properties to include the topic and connection details:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序属性包括主题和连接详细信息：
- en: '[PRE51]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '`Product` service to include calls to repository save and delete methods:'
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Product`服务包括调用存储库保存和删除方法：'
- en: '[PRE52]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'JMS-related classes and changes as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: JMS相关的类和更改如下：
- en: In `ProductSpringApp`, include annotation `EnableJms`, as done in the MongoDB
    project.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProductSpringApp`中，包括`EnableJms`注解，就像在MongoDB项目中一样。
- en: 'Create a `ProductUpdListener` class that calls the service:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用服务的`ProductUpdListener`类：
- en: '[PRE53]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Testing the CQRS update scenario end to end
  id: totrans-411
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试CQRS更新场景端到端
- en: 'To test our scenario, perform the following steps:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的场景，请执行以下步骤：
- en: Start the three server processes on a local machine, such as Elasticsearch,
    MongoDB, and ActiveMQ, as discussed earlier.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地计算机上启动三个服务器进程，例如Elasticsearch、MongoDB和ActiveMQ，如前面所讨论的。
- en: Start the Eureka server.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Eureka服务器。
- en: Start the two applications, one connecting to MongoDB (golden source, command
    model), listening on `8085` and the other connecting to Elasticsearch (query model),
    listening on `8086`.
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动两个应用程序，一个连接到MongoDB（黄金源，命令模型），监听`8085`，另一个连接到Elasticsearch（查询模型），监听`8086`。
- en: Test the `GET` request on Elasticsearch—`http://localhost:8086/products?id=1`,
    and note the IDs and descriptions.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Elasticsearch上测试`GET`请求—`http://localhost:8086/products?id=1`，并注意ID和描述。
- en: 'Now, change the product description on the golden source by issuing the following
    on your Postman, assuming the service is listening on port `8085`:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在Postman上发出以下命令来更改黄金源上的产品描述，假设服务正在端口`8085`上监听：
- en: '![](img/b2aaaef2-606a-4c9f-a861-bf5f1e3325e0.png)'
  id: totrans-418
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2aaaef2-606a-4c9f-a861-bf5f1e3325e0.png)'
- en: Test the `GET` request on Elasticsearch again—`http://localhost:8086/products?id=1`.
    You will find the product description in Elasticsearch is updated.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次在Elasticsearch上测试`GET`请求——`http://localhost:8086/products?id=1`。您会发现Elasticsearch中的产品描述已更新。
- en: Summary
  id: totrans-420
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of core concepts, starting with adding a regular
    relational database to back our get requests. We enhanced its performance with
    a local cache and then a distributed cache, Hazelcast. We also looked at a CQRS
    pattern, replacing our relational databases with a MongoDB for flexible schema
    and Elasticsearch for flexible search and query capabilities.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了许多核心概念，从添加常规关系数据库来支持我们的GET请求开始。我们通过本地缓存和分布式缓存Hazelcast增强了其性能。我们还研究了CQRS模式，用MongoDB替换了我们的关系数据库，以实现灵活的模式和Elasticsearch的灵活搜索和查询功能。
- en: We added insert, update, and delete operations to our `product` service and
    ensured that the necessary cache invalidation happens in the case of the relational
    project. We added input validations and proper error messages to our APIs. We
    covered eventing to ensure that the query model stays up to date with the command
    model. This is achieved by command model services sending a broadcast of changes,
    and query model services listening to the changes and updating their data model.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为我们的`product`服务添加了插入、更新和删除操作，并确保在关系项目的情况下进行必要的缓存失效。我们为我们的API添加了输入验证和适当的错误消息。我们涵盖了事件处理，以确保查询模型与命令模型保持最新。这是通过命令模型服务发送更改的广播，以及查询模型服务监听更改并更新其数据模型来实现的。
- en: Up next, we will look at how to make these projects robust enough to work in
    a runtime environment.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使这些项目足够健壮，以在运行时环境中运行。
