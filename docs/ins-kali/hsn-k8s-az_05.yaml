- en: 3\. Application deployment on AKS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3. 在AKS上部署应用程序
- en: In this chapter, we will deploy two applications on **Azure Kubernetes Service**
    (**AKS**). An application consists of multiple parts, and you will build the applications
    one step at a time while the conceptual model behind them is explained. You will
    be able to easily adapt the steps in this chapter to deploy any other application
    on AKS.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将在**Azure Kubernetes Service**（**AKS**）上部署两个应用程序。一个应用程序由多个部分组成，您将一步一步地构建这些应用程序，同时解释它们背后的概念模型。您将能够轻松地将本章中的步骤调整为在AKS上部署任何其他应用程序。
- en: To deploy the applications and make changes to them, you will be using YAML
    files. YAML is the acronym for **YAML Ain't Markup Language**. YAML is a language
    that is used to create configuration files to deploy to Kubernetes. Although you
    can use either JSON or YAML files to deploy applications to Kubernetes, YAML is
    the most commonly used language to do so. YAML became popular because it is easier
    for a human to read when compared to JSON or XML. You will see multiple examples
    of YAML files throughout this chapter and throughout the book.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序并对其进行更改时，您将使用YAML文件。YAML是**YAML Ain't Markup Language**的首字母缩略词。YAML是一种用于创建配置文件以部署到Kubernetes的语言。虽然您可以使用JSON或YAML文件来部署应用程序到Kubernetes，但YAML是最常用的语言。YAML变得流行是因为与JSON或XML相比，人类更容易阅读它。在本章和整本书中，您将看到多个YAML文件的示例。
- en: 'During the deployment of the sample guestbook application, you will see Kubernetes
    concepts in action. You will see how a **deployment** is linked to a **ReplicaSet**,
    and how that is linked to the **Pods** that are deployed. A Deployment is an object
    in Kubernetes that is used to define the desired state of an application. A deployment
    will create a ReplicaSet. A ReplicaSet is an object in Kubernetes that guarantees
    that a certain number of Pods will always be available. Hence, a ReplicaSet will
    create one or more Pods. A Pod is an object in Kubernetes that is a group of one
    or more containers. Let''s revisit the relationship between Deployment, ReplicaSet,
    and Pods:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署示例guestbook应用程序时，您将看到Kubernetes概念的实际应用。您将看到**部署**与**ReplicaSet**的关联，以及它与部署的**Pods**的关联。部署是Kubernetes中用于定义应用程序期望状态的对象。部署将创建一个ReplicaSet。ReplicaSet是Kubernetes中保证一定数量的Pod始终可用的对象。因此，ReplicaSet将创建一个或多个Pods。Pod是Kubernetes中的一个对象，它是一个或多个容器的组。让我们重新审视部署、ReplicaSet和Pod之间的关系：
- en: '![The image describes how Deployments, ReplicaSets, and Pods are linked to
    each other.](image/Figure_3.1.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![该图描述了部署、ReplicaSet和Pod之间的关联。](image/Figure_3.1.jpg)'
- en: 'Figure 3.1: Relationship between a Deployment, a ReplicaSet, and Pods'
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.1：部署、ReplicaSet和Pod之间的关系
- en: While deploying the sample applications, you will use the **service object**
    to connect to the application. A service in Kubernetes is an object that is used
    to provide a static IP address and DNS name to an application. Since a Pod can
    be killed and moved to different nodes in the cluster, a service ensures you can
    connect to a static endpoint for your application.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署示例应用程序时，您将使用**服务对象**来连接应用程序。Kubernetes中的服务是用于为应用程序提供静态IP地址和DNS名称的对象。由于Pod可以在集群中被杀死并移动到不同的节点，服务确保您可以连接到应用程序的静态终点。
- en: You will also edit the sample applications to provide configuration details
    using a **ConfigMap**. A ConfigMap is an object that is used to provide configuration
    details to Pods. It allows you to keep configuration settings outside of the actual
    container. You can then provide these configuration details to your application
    by connecting the ConfigMap to your deployment.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将编辑示例应用程序，使用ConfigMap提供配置细节。ConfigMap是一个用于向Pod提供配置细节的对象。它允许您将配置设置保留在容器之外。然后，您可以通过将ConfigMap连接到部署来向应用程序提供这些配置细节。
- en: Finally, you will be introduced to Helm. Helm is a package manager for Kubernetes
    that helps to streamline the deployment process. You will deploy a WordPress site
    using Helm and gain an understanding of the value Helm brings to Kubernetes. WordPress
    installation makes use of persistent storage in Kubernetes. You will learn how
    persistent storage in AKS is set up.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将了解Helm。Helm是Kubernetes的包管理器，有助于简化部署过程。您将使用Helm部署WordPress网站，并了解Helm为Kubernetes带来的价值。WordPress安装在Kubernetes中使用持久存储。您将学习如何设置AKS中的持久存储。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Deploying the sample guestbook application
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署示例留言板应用程序
- en: Full deployment of the sample guestbook application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整部署示例留言板应用程序
- en: Using Helm to install complex Kubernetes applications
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm安装复杂的Kubernetes应用程序
- en: We'll begin with the sample guestbook application.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从示例留言板应用程序开始。
- en: Deploying the sample guestbook application
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署示例留言板应用程序
- en: In this chapter, you will deploy the classic guestbook sample Kubernetes application.
    You will be mostly following the steps from [https://Kubernetes.io/docs/tutorials/stateless-application/guestbook/](https://Kubernetes.io/docs/tutorials/stateless-application/guestbook/)
    with some modifications. You will employ these modifications to show additional
    concepts, such as ConfigMaps, that are not present in the original sample.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将部署经典的留言板示例Kubernetes应用程序。您将主要按照[https://Kubernetes.io/docs/tutorials/stateless-application/guestbook/](https://Kubernetes.io/docs/tutorials/stateless-application/guestbook/)中的步骤进行，但会进行一些修改。您将使用这些修改来展示额外的概念，比如ConfigMaps，这些概念在原始示例中并不存在。
- en: The sample guestbook application is a simple, multi-tier web application. The
    different tiers in this application will have multiple instances. This is beneficial
    for both high availability and for scale. The guestbook's front end is a stateless
    application because the front end doesn't store any state. The Redis cluster in
    the back end is stateful as it stores all the guestbook entries.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 示例留言板应用程序是一个简单的多层Web应用程序。该应用程序中的不同层将具有多个实例。这对于高可用性和扩展都是有益的。留言板的前端是一个无状态应用程序，因为前端不存储任何状态。后端的Redis集群是有状态的，因为它存储所有留言板条目。
- en: You will be using this application as the basis for testing out the scaling
    of the back end and the front end, independently, in the next chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章中使用这个应用程序作为测试后端和前端独立扩展的基础。
- en: Before we get started, let's consider the application that we'll be deploying.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们考虑一下我们将要部署的应用程序。
- en: Introducing the application
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: The application stores and displays guestbook entries. You can use it to record
    the opinion of all the people who visit your hotel or restaurant, for example.
    Along the way, we will explain Kubernetes concepts such as deployments and ReplicaSets.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序存储并显示留言板条目。您可以使用它来记录所有访问您的酒店或餐厅的人的意见。在此过程中，我们将解释Kubernetes概念，如部署和ReplicaSets。
- en: The application uses PHP as a front end. The front end will be deployed using
    multiple replicas. The application uses Redis for its data storage. Redis is an
    in-memory key-value database. Redis is most often used as a cache. It's among
    the most popular container images according to [https://www.datadoghq.com/docker-adoption/](https://www.datadoghq.com/docker-adoption/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用PHP作为前端。前端将使用多个副本进行部署。该应用程序使用Redis作为数据存储。Redis是一种内存中的键值数据库。Redis通常用作缓存。根据[https://www.datadoghq.com/docker-adoption/](https://www.datadoghq.com/docker-adoption/)，它是最受欢迎的容器映像之一。
- en: '![Overview of the guestbook application. A user connects to the frontend. The
    frontend then connects to either the Redis master or one of the Redis slaves.](image/Figure_3.2.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![guestbook应用的概述。用户连接到前端。前端然后连接到Redis主节点或Redis从节点之一。](image/Figure_3.2.jpg)'
- en: 'Figure 3.2: High-level overview of the guestbook application'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.2：guestbook应用的高级概述
- en: We will begin deploying this application by deploying the Redis master.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过部署Redis主节点来开始部署此应用程序。
- en: Deploying the Redis master
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署Redis主节点
- en: In this section, you are going to deploy the Redis master. You will learn about
    the YAML syntax that is required for this deployment. In the next section, you
    will make changes to this YAML. Before making changes, let's start by deploying
    the Redis master.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将部署Redis主节点。您将了解到此部署所需的YAML语法。在下一节中，您将对此YAML进行更改。在进行更改之前，让我们先部署Redis主节点。
- en: 'Perform the following steps to complete the task:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成任务：
- en: Open your friendly Cloud Shell, as highlighted in *Figure 3.3*:![To open the
    Cloud Shell, click on the icon that is on the right side of the search bar.](image/Figure_3.3.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开友好的Cloud Shell，如*图3.3*中所示：![要打开Cloud Shell，请单击搜索栏右侧的图标。](image/Figure_3.3.jpg)
- en: 'Figure 3.3: Opening the Cloud Shell'
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.3：打开Cloud Shell
- en: 'If you have not cloned the github repository for this book, please do so now
    by using the following command:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您尚未克隆此书的github存储库，请使用以下命令进行克隆：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Enter the following command to deploy the master:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下命令以部署主节点：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It will take some time for the application to download and start running. While
    you wait, let''s understand the command you just typed and executed. Let''s start
    by exploring the content of the YAML file that was used:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序下载和启动需要一些时间。在等待时，让我们了解您刚刚输入和执行的命令。让我们开始探索使用的YAML文件的内容：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s dive deeper into the code to understand the provided parameters:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解提供的参数的代码：
- en: '**Line 2**: This states that we are creating a `Deployment`. As explained in
    *Chapter 1*, *Introduction to Docker and Kubernetes*, a deployment is a wrapper
    around Pods that makes it easy to update and scale Pods.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2行：这说明我们正在创建一个“部署”。如《第1章》*Docker和Kubernetes简介*中所解释的，部署是围绕Pods的包装，使得更新和扩展Pods变得容易。
- en: '**Lines 4-6**: Here, the `Deployment` is given a name, which is `redis-master`.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4-6行：在这里，“部署”被赋予一个名称，即“redis-master”。
- en: '**Lines 7-12**: These lines let us specify the containers that this `Deployment`
    will manage. In this example, the `Deployment` will select and manage all containers
    for which labels match (`app: redis`, `role: master`, and `tier: backend`). The
    preceding label exactly matches the labels provided in lines 14-19.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '第7-12行：这些行让我们指定此“部署”将管理的容器。在此示例中，“部署”将选择和管理所有标签匹配的容器（`app: redis`，`role: master`和`tier:
    backend`）。前面的标签与第14-19行提供的标签完全匹配。'
- en: '**Line 13**: Tells Kubernetes that we need exactly one copy of the running
    Redis master. This is a key aspect of the declarative nature of Kubernetes. You
    provide a description of the containers your applications need to run (in this
    case, only one replica of the Redis master), and Kubernetes takes care of it.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13行**：告诉Kubernetes我们需要确切地运行一个Redis主节点的副本。这是Kubernetes声明性质的一个关键方面。您提供了应用程序需要运行的容器的描述（在本例中，只有一个Redis主节点的副本），Kubernetes会处理它。'
- en: '**Line 14-19**: Adds labels to the running instance so that it can be grouped
    and connected to other containers. We will discuss them later to see how they
    are used.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第14-19行**：为运行的实例添加标签，以便将其分组并连接到其他容器。我们将在后面讨论它们是如何使用的。'
- en: '**Line 22**: Gives this container a name, which is `master`. In the case of
    a multi-container Pod, each container in a Pod requires a unique name.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第22行**：为这个容器指定一个名字，即`master`。在多容器Pod的情况下，Pod中的每个容器都需要一个唯一的名字。'
- en: '**Line 23**: This line indicates the Docker image that will be run. In this
    case, it is the `redis` image tagged with `e2e` (the latest Redis image that successfully
    passed its end-to-end [`e2e`] tests).'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第23行**：这一行指示将要运行的Docker镜像。在这种情况下，它是使用`e2e`标记的`redis`镜像（最新通过端到端[`e2e`]测试的Redis镜像）。'
- en: '**Lines 28-29**: These two lines indicate that the container is going to listen
    on port `6379`.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第28-29行**：这两行表示容器将监听`6379`端口。'
- en: '**Lines 24-27**: Sets the `cpu/memory` resources requested for the container.
    In this case, the request is 0.1 CPU, which is equal to `100m` and is also often
    referred to as 100 millicores. The memory requested is `100Mi`, or 104857600 bytes,
    which is equal to ~105MB ([https://Kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/](https://Kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/)).
    You can also set CPU and memory limits in a similar way. Limits are caps on what
    a container can use. If your Pod hits the CPU limit, it''ll get throttled, whereas
    if it hits the memory limits, it''ll get restarted. Setting requests and limits
    is best practice in Kubernetes.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第24-27行**：设置容器请求的`cpu/memory`资源。在这种情况下，请求的是0.1 CPU，即`100m`，通常也被称为100毫核。请求的内存是`100Mi`，或104857600字节，大约等于105MB
    ([https://Kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/](https://Kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/))。您也可以以类似的方式设置CPU和内存限制。限制是容器可以使用的上限。如果您的Pod达到了CPU限制，它将被限制，而如果它达到了内存限制，它将被重新启动。在Kubernetes中设置请求和限制是最佳实践。'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Kubernetes YAML definition is similar to the arguments given to Docker
    to run a particular container image. If you had to run this manually, you would
    define this example in the following way:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes的YAML定义类似于Docker运行特定容器镜像时给出的参数。如果您必须手动运行这个例子，您可以这样定义：
- en: '`# Run a container named master, listening on port 6379, with 100M memory and
    100m CPU using the redis:e2e image.`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`# 运行一个名为master的容器，监听6379端口，使用redis:e2e镜像，内存为100M，CPU为100m。`'
- en: '`docker run --name master -p 6379:6379 -m 100M -c 100m -d k8s.gcr.io/redis:e2e`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run --name master -p 6379:6379 -m 100M -c 100m -d k8s.gcr.io/redis:e2e`'
- en: In this section, you have deployed the Redis master and learned about the syntax
    of the YAML file that was used to create this deployment. In the next section,
    you will examine the deployment and learn about the different elements that were
    created.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您已经部署了Redis主节点，并学习了用于创建此部署的YAML文件的语法。在下一部分，您将检查部署并了解创建的不同元素。
- en: '**Examining the deployment**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查部署**'
- en: 'The `redis-master` deployment should be complete by now. Continue in the Azure
    Cloud Shell that you opened in the previous section and type the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`redis-master`部署现在应该已经完成。继续在您在上一部分打开的Azure Cloud Shell中输入以下内容：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the output displayed in *Figure 3.4*:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到*图3.4*中显示的输出：
- en: '![Using the kubectl get all command, you will see that objects such as Pod,
    service, Deployment, and ReplicaSet are created.](image/Figure_3.4.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get all命令，您将看到创建了诸如Pod、service、Deployment和ReplicaSet等对象。](image/Figure_3.4.jpg)'
- en: 'Figure 3.4: Output displaying the objects that were created by your deployment'
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.4：显示部署创建的对象的输出
- en: You can see that we have a deployment named `redis-master`. It controls a ReplicaSet
    of `redis-master-<random id>`. On further examination, you will also find that
    the ReplicaSet is controlling a Pod, `redis- master-<replica set random id>-<random
    id>`. *Figure 3.1* has a graphical representation of this relationship.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我们有一个名为`redis-master`的部署。它控制着一个`redis-master-<随机id>`的ReplicaSet。进一步检查后，你还会发现ReplicaSet正在控制一个名为`redis-master-<replica
    set随机id>-<随机id>`的Pod。*图3.1*以图形方式展示了这种关系。
- en: 'More details can be obtained by executing the `kubectl describe <object> <instance-name>`
    command, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`kubectl describe <object> <instance-name>`命令，可以获得更多详细信息，如下所示：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will generate an output as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![By using the kubectl describe deployment/redis-master command, you will see
    more details of the deployment.](image/Figure_3.5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![通过使用kubectl describe deployment/redis-master命令，您将看到部署的更多细节。](image/Figure_3.5.jpg)'
- en: 'Figure 3.5: Output of describing the deployment'
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.5：描述部署的输出
- en: You have now launched a Redis master with the default configuration. Typically,
    you would launch an application with an environment-specific configuration.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经启动了一个具有默认配置的Redis主节点。通常，您会使用特定于环境的配置启动应用程序。
- en: 'In the next section, we will introduce a new concept called ConfigMaps and
    then recreate the Redis master. So, before proceeding, we need to clean up the
    current version, and we can do so by running the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍一个名为ConfigMaps的新概念，然后重新创建Redis主节点。因此，在继续之前，我们需要清理当前版本，可以通过运行以下命令来完成：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Executing this command will produce the following output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将产生以下输出：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this section, you examined the Redis master deployment you created. You saw
    how a deployment relates to a ReplicaSet and how a ReplicaSet relates to Pods.
    In the following section, you will recreate this Redis master with an environment-specific
    configuration provided via a ConfigMap.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您检查了您创建的Redis主节点部署。您看到了部署与ReplicaSet的关系，以及ReplicaSet与Pod的关系。在接下来的部分中，您将使用通过ConfigMap提供的特定于环境的配置重新创建这个Redis主节点。
- en: Redis master with a ConfigMap
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有ConfigMap的Redis主节点
- en: There was nothing wrong with the previous deployment. In practical use cases,
    it would be rare that you would launch an application without some configuration
    settings. In this case, we are going to set the configuration settings for `redis-master`
    using a ConfigMap.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的部署没有任何问题。在实际使用情况中，很少会启动一个没有一些配置设置的应用程序。在这种情况下，我们将使用ConfigMap为`redis-master`设置配置设置。
- en: A ConfigMap is a portable way of configuring containers without having specialized
    images for each configuration. It has a key-value pair for data that needs to
    be set on a container. A ConfigMap is used for non-secret configuration. Kubernetes
    has a separate object called a **Secret**. A Secret is used for configurations
    that contain critical data such as passwords. This will be explored in detail
    in *Chapter 10*, *Securing your AKS cluster* of this book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap是一种便携的配置容器的方式，而不需要为每个配置专门的镜像。它具有需要在容器上设置的数据的键值对。ConfigMap用于非机密配置。Kubernetes有一个名为**Secret**的单独对象。Secret用于包含关键数据的配置，如密码。这将在本书的*第10章*，*保护您的AKS集群*中详细探讨。
- en: 'In this example, we are going to create a ConfigMap. In this ConfigMap, we
    will configure `redis-config` as the key and the value will be:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将创建一个ConfigMap。在此ConfigMap中，我们将`redis-config`配置为键，值将为：
- en: '`maxmemory 2mb`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxmemory 2mb`'
- en: '`maxmemory-policy allkeys-lru`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`maxmemory-policy allkeys-lru`'
- en: 'Now, let''s create this ConfigMap. There are two ways to create a ConfigMap:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建此ConfigMap。有两种创建ConfigMap的方法：
- en: Creating a ConfigMap from a file
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件创建ConfigMap
- en: Creating a ConfigMap from a YAML file
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从YAML文件创建ConfigMap
- en: We will explore each one in detail.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细探讨每一个。
- en: '**Creating a ConfigMap from a file**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**从文件创建ConfigMap**'
- en: 'The following steps will help us create a ConfigMap from a file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助我们从文件创建ConfigMap：
- en: 'Open the Azure Cloud Shell code editor by typing `code redis-config` in the
    terminal. Copy and paste the following two lines and save it as `redis-config`:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在终端中键入`code redis-config`来打开Azure Cloud Shell代码编辑器。复制并粘贴以下两行，并将其保存为`redis-config`：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now you can create the ConfigMap using the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您可以使用以下代码创建ConfigMap：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should get an output as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can use the same command to describe this ConfigMap:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用相同的命令描述此ConfigMap：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The output will be as shown in *Figure 3.6*:![Using the kubectl describe configmap/example-redis-configcommand,
    output will be generated that provides details such as Name, Namespace, Labels,
    Annotations, Data, redis-config, memory, and events.](image/Figure_3.6.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将如*图3.6*所示：![使用kubectl describe configmap/example-redis-config命令，将生成提供名称、命名空间、标签、注释、数据、redis-config、内存和事件等详细信息的输出。](image/Figure_3.6.jpg)
- en: 'Figure 3.6: Output of describing the ConfigMap'
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.6：描述ConfigMap的输出
- en: In this example, you created the ConfigMap by referring to a file on disk. A
    different way to deploy ConfigMaps is by creating them from a YAML file. Let's
    have a look at how this can be done in the following section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您通过引用磁盘上的文件创建了ConfigMap。部署ConfigMaps的另一种方法是通过从YAML文件创建它们。让我们看看在以下部分如何完成这一点。
- en: '**Creating a ConfigMap from a YAML file**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**从YAML文件创建ConfigMap**'
- en: 'In this section, you will recreate the ConfigMap from the previous section
    using a YAML file:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将使用YAML文件从上一节重新创建ConfigMap：
- en: 'To start, delete the previously created ConfigMap:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，删除先前创建的ConfigMap：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Copy and paste the following lines into a file named `example-redis-config.yaml`,
    and then save the file:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行复制并粘贴到名为`example-redis-config.yaml`的文件中，然后保存该文件：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can now recreate your ConfigMap via the following command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以通过以下命令重新创建您的ConfigMap：
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You should get an output as follows:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, run the following command:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行以下命令：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This command returns the same output as the previous one:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此命令返回与先前相同的输出：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, using a YAML file, you were able to create the same ConfigMap.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用YAML文件，您能够创建相同的ConfigMap。
- en: 'Note:'
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: '`kubectl get` has the useful option `-o`, which can be used to get the output
    of an object in either YAML or JSON. This is very useful in cases where you have
    made manual changes to a system and want to see the resulting object in YAML format.
    You can get the current ConfigMap in YAML using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get`具有有用的选项`-o`，可用于以YAML或JSON格式获取对象的输出。这在您对系统进行手动更改并希望以YAML格式查看生成的对象时非常有用。您可以使用以下命令以YAML格式获取当前的ConfigMap：'
- en: '`kubectl get -o yaml configmap/example-redis-config`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get -o yaml configmap/example-redis-config`'
- en: Now that you have the ConfigMap defined, let's use it.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了ConfigMap，让我们使用它。
- en: '**Using a ConfigMap to read in configuration data**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用ConfigMap读取配置数据**'
- en: 'In this section, you will reconfigure the `redis-master` deployment to read
    configuration from the ConfgMap:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将重新配置`redis-master`部署以从ConfgMap读取配置：
- en: 'To start, modify `redis-master-deployment.yaml` to use the ConfigMap as follows.
    The changes you need to make will be explained after the source code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，修改`redis-master-deployment.yaml`以使用ConfigMap如下。在源代码之后将解释需要进行的更改：
- en: Note
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: If you downloaded the source code accompanying this book, there is a file in
    *Chapter 3*, *Application deployment on AKS*, called `redis-master-deployment_Modified.yaml`,
    which has the necessary changes applied to it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您下载了本书附带的源代码，在*第3章*，*在AKS上部署应用程序*中有一个名为`redis-master-deployment_Modified.yaml`的文件，其中已经应用了必要的更改。
- en: '[PRE17]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Let''s dive deeper into the code to understand the different sections:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以理解不同的部分：
- en: '**Lines 24-26**: These lines introduce a command that will be executed when
    your Pod starts. In this case, this will start the `redis-server` pointing to
    a specific configuration file.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第24-26行：这些行介绍了在Pod启动时将执行的命令。在这种情况下，这将启动指向特定配置文件的`redis-server`。
- en: '**Lines 27-29**: Shows how to pass configuration data to your running container.
    This method uses environment variables. In Docker form, this would be equivalent
    to `docker run -e "MASTER=true". --name master -p 6379:6379 -m 100M -c 100m -d
    Kubernetes /redis:v1`. This sets the environment variable `MASTER` to `true`.
    Your application can read the environment variable settings for its configuration.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第27-29行：显示如何将配置数据传递给正在运行的容器。这种方法使用环境变量。在Docker形式中，这相当于`docker run -e "MASTER=true".
    --name master -p 6379:6379 -m 100M -c 100m -d Kubernetes /redis:v1`。这将环境变量`MASTER`设置为`true`。您的应用程序可以读取环境变量设置以进行配置。
- en: '**Lines 30-32**: These lines mount the volume called `config` (this volume
    is defined in lines 39-45) on the `/redis-master` path on the running container.
    It will hide whatever exists on `/redis-master` on the original container.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第30-32行：这些行在运行的容器上的`/redis-master`路径上挂载名为`config`的卷（此卷在第39-45行中定义）。它将隐藏原始容器上`/redis-master`上存在的任何内容。
- en: In Docker terms, it would be equivalent to `docker run -v config:/redis-master.
    -e "MASTER=TRUE" --name master -p 6379:6379 -m 100M -c 100m -d Kubernetes /redis:v1`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以Docker术语来说，相当于`docker run -v config:/redis-master. -e "MASTER=TRUE" --name
    master -p 6379:6379 -m 100M -c 100m -d Kubernetes /redis:v1`。
- en: '**Line 40**: Gives the volume the name `config`. This name will be used within
    the context of this Pod.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第40行：为卷命名为`config`。此名称将在此Pod的上下文中使用。
- en: '**Lines 41-42**: Declare that this volume should be loaded from the `example-redis-config`
    ConfigMap. This ConfigMap should already exist in the system. You have already
    defined this, so you are good.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第41-42行：声明应该从`example-redis-config` ConfigMap加载此卷。此ConfigMap应该已经存在于系统中。您已经定义了这一点，所以没问题。
- en: '**Lines 43-45**: Here, you are loading the value of the `redis-config` key
    (the two-line `maxmemory` settings) as a `redis.conf` file.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第43-45行：在这里，您正在将`redis-config`键的值（两行`maxmemory`设置）加载为`redis.conf`文件。
- en: 'Let''s create this updated deployment:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建这个更新后的部署：
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should output the following:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该输出以下内容：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now make sure that the configuration was successfully applied. First,
    get the Pod''s name:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们确保配置已成功应用。首先，获取Pod的名称：
- en: '[PRE20]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then `exec` into the Pod and verify that the settings were applied:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后`exec`进入Pod并验证已应用设置：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To summarize, you have just performed an important and tricky part of configuring
    cloud-native applications. You will have also noticed that the apps have to be
    configured to read config dynamically. After you set up your app with configuration,
    you accessed a running container to verify the running configuration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，您刚刚执行了配置云原生应用程序的重要且棘手的部分。您还会注意到应用程序必须配置为动态读取配置。配置应用程序后，您访问了正在运行的容器以验证运行配置。
- en: Note
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Connecting to a running container is useful for troubleshooting and doing diagnostics.
    Due to the ephemeral nature of containers, you should never connect to a container
    to do additional configuration or installation. This should either be part of
    your container image or configuration you provide via Kubernetes (as we just did).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到运行中的容器对于故障排除和诊断非常有用。由于容器的短暂性质，您不应该连接到容器进行额外的配置或安装。这应该是您容器镜像的一部分，或者是您通过Kubernetes提供的配置（就像我们刚刚做的那样）。
- en: In this section, you configured the Redis Master to load configuration data
    from a ConfigMap. In the next section, we will deploy the end-to-end application.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您配置了Redis Master从ConfigMap加载配置数据。在下一节中，我们将部署端到端的应用程序。
- en: Complete deployment of the sample guestbook application
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例guestbook应用程序的完整部署
- en: Having taken a detour to understand the dynamic configuration of applications
    using a ConfigMap, we will now return to the deployment of the rest of the guestbook
    application. You will once again come across the concepts of deployment, ReplicaSets,
    and Pods for the back end and front end. Apart from this, you will also be introduced
    to another key concept, called a service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解使用ConfigMap动态配置应用程序的过程中，我们将现在返回到部署其余guestbook应用程序的过程中。您将再次遇到部署、ReplicaSets和后端和前端的Pods的概念。除此之外，您还将被介绍另一个关键概念，称为服务。
- en: To start the complete deployment, we are going to create a service to expose
    the Redis master service.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始完整的部署，我们将创建一个服务来公开Redis主服务。
- en: Exposing the Redis master service
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 公开Redis主服务
- en: When exposing a port in plain Docker, the exposed port is constrained to the
    host it is running on. With Kubernetes networking, there is network connectivity
    between different Pods in the cluster. However, Pods themselves are ephemeral
    in nature, meaning they can be shut down, restarted, or even moved to other hosts
    without maintaining their IP address. If you were to connect to the IP of a Pod
    directly, you might lose connectivity if that Pod was moved to a new host.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在普通Docker中公开端口时，公开的端口受限于其运行的主机。在Kubernetes网络中，集群中不同Pod之间存在网络连接。但是，Pod本身是短暂的，这意味着它们可以被关闭、重新启动，甚至移动到其他主机而不保留其IP地址。如果您直接连接到Pod的IP，如果该Pod被移动到新主机，您可能会失去连接。
- en: 'Kubernetes provides the `service` object, which handles this exact problem.
    Using label-matching selectors, it proxies traffic to the right Pods and does
    load balancing. In this case, the master has only one Pod, so it just ensures
    that the traffic is directed to the Pod independent of the node the Pod runs on.
    To create the Service, run the following command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了`service`对象，它处理了这个确切的问题。使用标签匹配选择器，它代理流量到正确的Pod，并进行负载平衡。在这种情况下，主服务只有一个Pod，因此它只确保流量被定向到独立于Pod所在节点的Pod。要创建服务，请运行以下命令：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The Redis master Service has the following content:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Redis主服务具有以下内容：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s now see what you have created using the preceding code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看您使用前面的代码创建了什么：
- en: '**Lines 1-8**: These lines tell Kubernetes that we want a service called `redis-master`,
    which has the same labels as our `redis-master` server Pod.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1-8行：**这些行告诉Kubernetes，我们想要一个名为`redis-master`的服务，它具有与我们的`redis-master`服务器Pod相同的标签。'
- en: '**Lines 10-12:** These lines indicate that the service should handle traffic
    arriving at port `6379` and forward it to port `6379` of the Pods that match the
    selector defined between lines 13 and 16\.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-12行：**这些行表示服务应该处理到达端口`6379`的流量，并将其转发到与第13行和第16行之间定义的选择器匹配的Pod的端口`6379`。'
- en: '**Lines 13-16**: These lines are used to find the Pods to which the incoming
    traffic needs to be proxied. So, any Pod with labels matching (`app: redis`, `role:
    master` and `tier: backend`) is expected to handle port `6379` traffic. If you
    look back at the previous example, those are the exact labels we applied to that
    deployment.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13-16行**：这些行用于查找需要代理传入流量的Pod。因此，任何具有匹配标签（`app: redis`、`role: master`和`tier:
    backend`）的Pod都应该处理端口`6379`的流量。如果您回顾前面的示例，这些标签正是我们应用于该部署的标签。'
- en: 'We can check the properties of the service by running the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行以下命令来检查服务的属性：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This will give you an output as shown in *Figure 3.7*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给您一个如*图3.7*所示的输出：
- en: '![With the help of kubectl get service command, you will see details such as
    Name, Type, Cluster-IP, External-IP, Port(s), and the age of each service.](image/Figure_3.7.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: 使用kubectl get service命令，您将看到每个服务的名称、类型、集群IP、外部IP、端口和年龄等详细信息。
- en: 'Figure 3.7: Output of the service that was created'
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.7：创建的服务的输出
- en: You see that a new service, named `redis-master`, has been created. It has a
    cluster-wide IP of `10.0.227.250` (in your case, the IP will likely be different).
    Note that this IP will work only within the cluster (hence the `ClusterIP` type).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到一个名为`redis-master`的新服务已创建。它具有集群范围的IP`10.0.227.250`（在您的情况下，IP可能会有所不同）。请注意，此IP仅在集群内部有效（因此是`ClusterIP`类型）。
- en: 'A service also introduces a **Domain Name Server** (**DNS**) name for that
    service. The DNS name is of the form `<service-name>.<namespace>.svc.cluster.local`;
    in our case, that would be `redis-master.default.svc.cluster.local`. To see this
    in action, we''ll do a name resolution on our `redis-master` VM. The default image
    doesn''t have `nslookup` installed, so we''ll bypass that by running a `ping`
    command. Don''t worry if that traffic doesn''t return; this is because you didn''t
    expose `ping` on your service, only the `redis` port. Let''s have a look:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 服务还为该服务引入了一个域名服务器（DNS）名称。DNS名称的格式为`<service-name>.<namespace>.svc.cluster.local`；在我们的情况下，那将是`redis-master.default.svc.cluster.local`。为了看到这一点，我们将在我们的`redis-master`
    VM上进行名称解析。默认镜像没有安装`nslookup`，所以我们将通过运行`ping`命令来绕过。如果该流量没有返回，不要担心；这是因为您没有在服务上公开`ping`，只有`redis`端口。让我们来看一下：
- en: '[PRE25]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This should output the resulting name resolution, showing you the **Fully Qualified
    Domain Name** (**FQDN**) of your service and the IP address that showed up earlier.
    You can exit out of the Pod via the `exit` command, as shown in *Figure 3.8*:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出结果名称解析，显示您服务的完全合格域名（FQDN）和之前显示的IP地址。您可以通过`exit`命令退出Pod，如*图3.8*所示：
- en: '![The output displays the FQDN of the service along with the IP address.](image/Figure_3.8.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: 输出显示了服务的FQDN以及IP地址。
- en: 'Figure 3.8: Using a ping command to view the FQDN of your service'
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.8：使用ping命令查看服务的FQDN
- en: In this section, you exposed the Redis master using a service. In the next section,
    you will deploy the Redis slaves.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您使用服务公开了Redis主服务器。在下一部分，您将部署Redis从服务器。
- en: Deploying the Redis slaves
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署Redis从服务器
- en: Running a single back end on the cloud is not recommended. You can configure
    Redis in a master-slave setup. This means that you can have a master that will
    serve write traffic and multiple slaves that can handle read traffic. It is useful
    for handling increased read traffic and high availability.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在云上运行单个后端是不推荐的。您可以在主从设置中配置Redis。这意味着您可以有一个主服务器用于写入流量，以及多个从服务器用于处理读取流量。这对于处理增加的读取流量和提高可用性非常有用。
- en: 'Let''s set this up:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来设置一下：
- en: 'Create the deployment by running the following command:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令创建部署：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Let''s check all the resources that have been created now:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在检查所有已创建的资源：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output would be as shown in *Figure 3.9*:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如*图3.9*所示：
- en: '![Using the kubectl get all command, you see new objects such as Pod, Deployment,
    and ReplicaSet.](image/Figure_3.9.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![使用kubectl get all命令，您会看到新的对象，如Pod、Deployment和ReplicaSet。](image/Figure_3.9.jpg)'
- en: 'Figure 3.9: Deploying the Redis slaves creates a number of new objects'
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.9：部署Redis从节点会创建一些新对象
- en: 'Based on the preceding output, you can see that you created two replicas of
    the `redis-slave` Pods. This can be confirmed by examining the `redis-slave- deployment.yaml`
    file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据前面的输出，您可以看到您创建了两个`redis-slave` Pod的副本。这可以通过检查`redis-slave-deployment.yaml`文件来确认：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Everything is the same except for the following:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以下内容之外，其他都是一样的：
- en: '**Line 13:** The number of replicas is `2`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第13行**：副本数量为`2`。'
- en: '**Line 23:** You are now using a specific slave image.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第23行**：您现在正在使用特定的从节点镜像。'
- en: '**Lines 29-30**: Setting `GET_HOSTS_FROM` to `dns`. As you saw in the previous
    example, DNS resolves in the cluster.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第29-30行**：将`GET_HOSTS_FROM`设置为`dns`。正如您在前面的示例中看到的，DNS在集群中解析。'
- en: 'Like the master service, you need to expose the slave service by running the
    following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与主服务一样，您需要通过运行以下命令公开从服务：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The only difference between this service and the `redis-master` service is that
    this service proxies traffic to Pods that have the `role:slave` label.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务和`redis-master`服务之间唯一的区别是，这个服务会将流量代理到具有`role:slave`标签的Pod。
- en: 'Check the `redis-slave` service by running the following command:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来检查`redis-slave`服务：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This should give you the output shown in *Figure 3.10*:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会给您显示*图3.10*中显示的输出：
- en: '![When you execute the kubectl get service command, the output screen will
    display a redis-master and a redis-slave.](image/Figure_3.10.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![当您执行kubectl get service命令时，输出屏幕将显示一个redis-master和一个redis-slave。](image/Figure_3.10.jpg)'
- en: 'Figure 3.10: Output displaying both a redis-master and a redis-slave service'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.10：输出显示了redis-master和redis-slave服务
- en: You now have a Redis cluster up and running, with a single master and two replicas.
    In the next section, you will deploy and expose the front end.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有一个Redis集群正在运行，有一个主节点和两个副本。在下一节中，您将部署和公开前端。
- en: Deploying and exposing the front end
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署和公开前端
- en: Up to now, you have focused on the Redis back end. Now you are ready to deploy
    the front end. This will add a graphical web page to your application that you'll
    be able to interact with.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经专注于Redis后端。现在您已经准备好部署前端。这将为您的应用程序添加一个图形网页，您将能够与之交互。
- en: 'You can create the front end using the following command:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令创建前端：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To verify the deployment, run this code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证部署，请运行此代码：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will display the output shown in *Figure 3.11*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示*图3.11*中显示的输出：
- en: '![When you execute the kubectl get pods command, the output screen displays
    a total of 6 Pods in the Running state.](image/Figure_3.11.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![当您执行kubectl get pods命令时，输出屏幕会显示总共6个处于运行状态的Pod。](image/Figure_3.11.jpg)'
- en: 'Figure 3.11: Output displaying the additional Pods running the front end'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.11：显示运行前端的额外Pod的输出
- en: 'You will notice that this deployment specifies `3` replicas. The deployment
    has the usual aspects with minor changes, as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到这个部署指定了`3`个副本。部署具有通常的方面，但有一些小的变化，如下面的代码所示：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s see these changes:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些变化：
- en: '**Line 11**: The replica count is set to `3`.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第11行**：副本数量设置为`3`。'
- en: '**Line 8-10 and 14-16:** The labels are set to `app: guestbook` and `tier:
    frontend`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第8-10行和14-16行**：标签设置为`app: guestbook`和`tier: frontend`。'
- en: '**Line 20:** `gb-frontend:v4` is used as the image.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第20行**：使用`gb-frontend:v4`作为镜像。'
- en: You have now created the front-end deployment. You now need to expose it as
    a service.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经创建了前端部署。现在您需要将其公开为服务。
- en: '**Exposing the front-end service**'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**公开前端服务**'
- en: 'There are multiple ways to define a Kubernetes service. The two Redis services
    we created were of the type `ClusterIP`. This means they are exposed on an IP
    that is reachable only from the cluster, as shown in *Figure 3.12*:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 定义Kubernetes服务的多种方式。我们创建的两个Redis服务都是`ClusterIP`类型。这意味着它们仅在集群内可访问，如*图3.12*所示：
- en: '![A service of type clusterIP is an IP that spans the whole cluster and connects
    to pods on each node. A ClusterIP is only available inside the cluster.](image/Figure_3.12.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![ClusterIP类型的服务是跨整个集群的IP，并连接到每个节点上的pod。ClusterIP仅在集群内可用。](image/Figure_3.12.jpg)'
- en: 'Figure 3.12: Kubernetes service of type ClusterIP'
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.12：类型为ClusterIP的Kubernetes服务
- en: 'Another type of service is the type `NodePort`. This service would be exposed
    on a static port on each node as shown in *Figure 3.13*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种服务类型是`NodePort`类型。这种服务将在每个节点上的静态端口上暴露，如*图3.13*所示：
- en: '![A Service of type NodePort will open a port on each node that will connect
    to the pods on each node. External users can use that port to connect to pods
    from outside the cluster.](image/Figure_3.13.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![NodePort类型的服务将在每个节点上打开一个端口，该端口将连接到每个节点上的Pod。外部用户可以使用该端口从集群外部连接到Pod。](image/Figure_3.13.jpg)'
- en: 'Figure 3.13: Kubernetes service of type NodePort'
  id: totrans-209
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.13：类型为NodePort的Kubernetes服务
- en: 'A final type – which we will use in our example – is the `LoadBalancer` type.
    This will create an **Azure load balancer** that will get a public IP that we
    can use to connect to, as shown in *Figure 3.14*:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种类型 - 我们将在示例中使用的类型 - 是`LoadBalancer`类型。这将创建一个**Azure负载均衡器**，我们可以使用它来连接的公共IP，如*图3.14*所示：
- en: '![A Service of type LoadBalancer will create an external load balancer that
    will connect to the Pods on each node. External users can use that load balancer
    to connect to the pods from outside the cluster.](image/Figure_3.14.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![LoadBalancer类型的服务将创建一个外部负载均衡器，该负载均衡器将连接到每个节点上的Pod。外部用户可以使用该负载均衡器从集群外部连接到Pod。](image/Figure_3.14.jpg)'
- en: 'Figure 3.14: Kubernetes service of type LoadBalancer'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.14：类型为LoadBalancer的Kubernetes服务
- en: 'The following code will help us to understand how a front-end service is exposed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将帮助我们了解如何暴露前端服务：
- en: '[PRE34]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now that you have seen how a front-end service is exposed, let''s make the
    guestbook application ready for use with the following steps:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在您已经看到了前端服务是如何暴露的，让我们通过以下步骤使guestbook应用程序准备好使用：
- en: 'To create the service, run the following command:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建服务，请运行以下命令：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This step takes some time to execute when you run it for the first time. In
    the background, Azure must perform a couple of actions to make it seamless. It
    has to create an Azure load balancer and a public IP and set the port-forwarding
    rules to forward traffic on port `80` to internal ports of the cluster.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当您首次运行此步骤时，执行此步骤需要一些时间。在后台，Azure必须执行一些操作以使其无缝。它必须创建一个Azure负载均衡器和一个公共IP，并设置端口转发规则，以将端口`80`上的流量转发到集群的内部端口。
- en: 'Run the following until there is a value in the `EXTERNAL-IP` column:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令，直到`EXTERNAL-IP`列中有值为止：
- en: '[PRE36]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This should display the output shown in *Figure 3.15*:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示*图3.15*中显示的输出：
- en: '![When the kubectl get service command is executed, it generates an output
    wherein the frontend, kubernetes, redis-master, and redis-slave all have a Cluster
    IP. However, here only the frontend has an External IP.](image/Figure_3.15.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get service命令时，会生成一个输出，其中前端、kubernetes、redis-master和redis-slave都有一个Cluster
    IP。但是，这里只有前端有一个External IP。](image/Figure_3.15.jpg)'
- en: 'Figure 3.15: Output displaying a value for External IP after a while'
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.15：一段时间后显示外部IP值的输出
- en: In the Azure portal, if you click on **All Resources** and filter on **Load
    balancer**, you will see a **kubernetes Load balancer**. Clicking on it shows
    you something similar to *Figure 3.16*. The highlighted sections show you that
    there is a load balancing rule accepting traffic on port `80` and you have 2 public
    IP addresses:![Upon opening the Kubernetes load balancer in the Azure portal,
    you will see a load balancing rule and twopublic IP addresses that appear towards
    the rightside of the screen.](image/Figure_3.16.jpg)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Azure门户中，如果您点击**所有资源**并过滤**负载均衡器**，您将看到一个**kubernetes负载均衡器**。点击它会显示类似于*图3.16*的内容。突出显示的部分显示了在端口`80`上接受流量的负载均衡规则，以及您有2个公共IP地址：![在Azure门户中打开Kubernetes负载均衡器，您将看到一个负载均衡规则和两个出现在屏幕右侧的公共IP地址。](image/Figure_3.16.jpg)
- en: 'Figure 3.16: Displaying the Kubernetes load balancer in the Azure portal'
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.16：在Azure门户中显示Kubernetes负载均衡器
- en: If you click through on the two public IP addresses, you'll see both IP addresses
    linked to your cluster. One of those will be the IP address of your actual service;
    the other one is used by AKS to make outbound connections.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击两个公共IP地址，您会看到这两个IP地址都链接到您的集群。其中一个将是您实际服务的IP地址；另一个是AKS用于进行出站连接的IP地址。
- en: Note
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: 'Azure has two types of load balancers: basic and standard.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Azure有两种类型的负载均衡器：基本和标准。
- en: Virtual machines behind a basic load balancer can make outbound connections
    without any specific configuration. Virtual machines behind a standard load balancer
    (which is the default for AKS now) need a specific configuration to make outbound
    connections. This is why you see a second IP address configured.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 基本负载均衡器后面的虚拟机可以在没有特定配置的情况下进行出站连接。标准负载均衡器后面的虚拟机（这是AKS的默认设置）需要特定配置才能进行出站连接。这就是为什么您会看到第二个IP地址配置的原因。
- en: We're finally ready to put our guestbook app into action!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于准备好让我们的guestbook应用程序投入使用！
- en: The guestbook application in action
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正在运行的guestbook应用程序
- en: 'Type the public IP of the service in your favorite browser. You should get
    the output shown in *Figure 3.17*:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的浏览器中输入服务的公共IP。您应该会得到*图3.17*中显示的输出：
- en: '![When you type in the IP address in your browser, you will see a white screen
    displaying the word Guestbook. This indicates that the Guestbook application is
    running.](image/Figure_3.17.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![当您在浏览器中输入IP地址时，您将看到一个显示单词Guestbook的白屏。这表明Guestbook应用程序正在运行。](image/Figure_3.17.jpg)'
- en: 'Figure 3.17: The guestbook application in action'
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.17：Guestbook应用程序正在运行
- en: Go ahead and record your messages. They will be saved. Open another browser
    and type the same IP; you will see all the messages you typed.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 继续记录您的消息。它们将被保存。打开另一个浏览器并输入相同的IP；您将看到您输入的所有消息。
- en: Congratulations – you have completed your first fully deployed, multi-tier,
    cloud-native Kubernetes application!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜 - 您已经完成了您的第一个完全部署的、多层、云原生的Kubernetes应用程序！
- en: 'To conserve resources on your free-trial virtual machines, it is better to
    delete the created deployments to run the next round of the deployments by using
    the following commands:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省您的免费试用虚拟机资源，最好删除创建的部署，然后使用以下命令运行下一轮部署：
- en: '[PRE37]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Over the course of the preceding sections, you have deployed a Redis cluster
    and deployed a publicly accessible web application. You have learned how deployments,
    ReplicaSets, and Pods are linked, and you have learned how Kubernetes uses the
    `service` object to route network traffic. In the next section of this chapter,
    you will use Helm to deploy a more complex application on top of Kubernetes.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您已经部署了一个Redis集群并部署了一个可公开访问的Web应用程序。您已经了解了部署、ReplicaSets和Pods之间的关联，以及Kubernetes如何使用`service`对象来路由网络流量。在本章的下一节中，您将使用Helm在Kubernetes上部署一个更复杂的应用程序。
- en: Installing complex Kubernetes applications using Helm
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Helm安装复杂的Kubernetes应用程序
- en: In the previous section, we used static YAML files to deploy our application.
    When deploying more complicated applications, across multiple environments (such
    as dev/test/prod), it can become cumbersome to manually edit YAML files for each
    environment. This is where the Helm tool comes in.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用静态YAML文件部署了我们的应用程序。当部署更复杂的应用程序跨多个环境（如开发/测试/生产）时，手动编辑每个环境的YAML文件可能会变得繁琐。这就是Helm工具的用武之地。
- en: Helm is the package manager for Kubernetes. Helm helps you deploy, update, and
    manage Kubernetes applications at scale. For this, you write something called
    Helm Charts.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的包管理器。Helm帮助您以规模部署、更新和管理Kubernetes应用程序。为此，您需要编写一种称为Helm Charts的东西。
- en: You can think of Helm Charts as parameterized Kubernetes YAML files. If you
    think about the Kubernetes YAML files we wrote in the previous section, those
    files were static. You would need to go into the files and edit them to make changes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将Helm Charts视为参数化的Kubernetes YAML文件。如果您考虑一下我们在上一节中编写的Kubernetes YAML文件，那些文件是静态的。您需要进入文件并编辑它们以进行更改。
- en: Helm charts allow you to write YAML files with certain parameters in them, which
    you can dynamically set. This setting of the parameters can be done through a
    values file or as a command-line variable when you deploy the chart.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Helm Charts允许您编写带有特定参数的YAML文件，您可以动态设置这些参数。可以通过值文件或在部署图表时作为命令行变量来设置这些参数。
- en: Finally, with Helm, you don't necessarily have to write Helm Charts yourself;
    you can also use a rich library of pre-written Helm Charts and install popular
    software in your cluster through a simple command such as `helm install --name
    my-release stable/mysql`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用Helm，您不一定需要自己编写Helm Charts；您还可以使用丰富的预先编写的Helm Charts库，并通过简单的命令（例如`helm
    install --name my-release stable/mysql`）在集群中安装流行的软件。
- en: This is exactly what you are going to do in the next section. You will install
    WordPress on your cluster by issuing only two commands. In the next chapters,
    you'll also dive into custom Helm Charts that you'll edit.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是您将在下一节中要做的。您将通过发出仅两个命令在您的集群上安装WordPress。在接下来的章节中，您还将深入研究自定义Helm Charts。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: On November 13, 2019 the first stable release of Helm v3 was released. We will
    be using Helm v3 in the following examples. The biggest difference between Helm
    v2 and Helm v3 is that Helm v3 is a fully client-side tool that no longer requires
    the server-side tool called `tiller`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年11月13日，Helm v3的第一个稳定版本发布。在接下来的示例中，我们将使用Helm v3。Helm v2和Helm v3之间最大的区别是，Helm
    v3是一个完全客户端工具，不再需要名为`tiller`的服务器端工具。
- en: 'If you want a more thorough introduction to writing your own Helm Charts, you
    can refer to the following blog post by one of the authors of this book: [https://blog.nillsf.com/index.php/2019/11/23/writing-a-helm-v3-chart/](https://blog.nillsf.com/index.php/2019/11/23/writing-a-helm-v3-chart/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想更全面地了解如何编写自己的Helm Charts，可以参考本书作者之一的博客文章：[https://blog.nillsf.com/index.php/2019/11/23/writing-a-helm-v3-chart/](https://blog.nillsf.com/index.php/2019/11/23/writing-a-helm-v3-chart/)。
- en: Let's start by installing WordPress on your cluster using Helm. In this section,
    you'll also learn about persistent storage in Kubernetes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从使用Helm在您的集群上安装WordPress开始。在本节中，您还将了解Kubernetes中的持久存储。
- en: Installing WordPress using Helm
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm安装WordPress
- en: 'As mentioned in the introduction, Helm has a rich library of pre-written Helm
    charts. To access this library, you''ll have to add a repo to your Helm client:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，Helm具有丰富的预先编写的Helm Charts库。要访问此库，您需要向Helm客户端添加一个存储库：
- en: 'Add the repo that contains the stable Helm Charts using the following command:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令添加包含稳定Helm Charts的存储库：
- en: '[PRE38]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'To install WordPress, we will run the following command:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要安装WordPress，我们将运行以下命令：
- en: '[PRE39]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This execution will cause Helm to install the chart detailed at [https://github.com/helm/charts/tree/master/stable/wordpress](https://github.com/helm/charts/tree/master/stable/wordpress).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作将导致Helm安装详细说明在[https://github.com/helm/charts/tree/master/stable/wordpress](https://github.com/helm/charts/tree/master/stable/wordpress)的图表。
- en: It takes some time for Helm to install and the site to come up. Let's look at
    a key concept, PersistentVolumeClaims, while the site is loading. After covering
    this, we'll go back and look at our site that got created.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Helm安装需要一些时间，网站才能启动。让我们在网站加载时看一下一个关键概念，即PersistentVolumeClaims。在介绍完这个概念后，我们将回过头来看看我们创建的网站。
- en: '**PersistentVolumeClaims**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**PersistentVolumeClaims**'
- en: A process requires compute, memory, network, and storage. In the guestbook example,
    we saw how Kubernetes helps us abstract the compute, memory, and network. The
    same YAML files work across all cloud providers, including a cloud-specific setup
    of public-facing load balancers. The WordPress example shows how the last piece,
    namely storage, is abstracted from the underlying cloud provider.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个进程需要计算、内存、网络和存储。在guestbook示例中，我们看到Kubernetes如何帮助我们抽象出计算、内存和网络。相同的YAML文件适用于所有云提供商，包括特定于云的公共负载均衡器的设置。WordPress示例显示了最后一部分，即存储，是如何从底层云提供商中抽象出来的。
- en: In this case, the WordPress Helm Chart depends on the MariaDB helm chart ([https://github.com/helm/charts/tree/master/stable/mariadb](https://github.com/helm/charts/tree/master/stable/mariadb))
    for its database installation.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，WordPress Helm Chart依赖于MariaDB helm chart（[https://github.com/helm/charts/tree/master/stable/mariadb](https://github.com/helm/charts/tree/master/stable/mariadb)）来进行数据库安装。
- en: Unlike stateless applications, such as our front ends, MariaDB requires careful
    handling of storage. To make Kubernetes handle stateful workloads, it has a specific
    object called a StatefulSet. A StatefulSet ([https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/))
    is like a deployment with the additional capability of ordering, and the uniqueness
    of the Pods. This means that Kubernetes will ensure that the Pod and its storage
    are kept together. Another way that StatefulSets help is with the consistent naming
    of Pods in a StatefulSet. The Pods are named `<pod-name>-#`, where `#` starts
    from `0` for the first Pod, and `1` for the second Pod.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与无状态应用程序（如我们的前端）不同，MariaDB需要对存储进行仔细处理。为了让Kubernetes处理有状态的工作负载，它有一个特定的对象称为StatefulSet。StatefulSet（[https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/](https://kubernetes.io/docs/concepts/workloads/controllers/statefulset/)）类似于部署，具有顺序的额外能力和Pod的唯一性。这意味着Kubernetes将确保Pod及其存储被保持在一起。StatefulSets的另一个帮助方式是一致地命名StatefulSet中的Pod。Pod的命名方式是`<pod-name>-#`，其中`#`从第一个Pod开始为`0`，第二个Pod为`1`。
- en: 'Running the following command, you can see that MariaDB has a predictable number
    attached to it, whereas the WordPress deployment has a random number attached
    to the end:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，您可以看到MariaDB附有可预测的编号，而WordPress部署附有随机编号：
- en: '[PRE40]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will generate the output shown in *Figure 3.18*:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成*图3.18*中显示的输出：
- en: '![When the kubectl get pods command is executed, you will see a predictable
    name for the MariaDB Pod and a random alpha-numeric name for the WordPress Pod.](image/Figure_3.18.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![当执行kubectl get pods命令时，您将看到MariaDB Pod的可预测名称和WordPress Pod的随机字母数字名称。](image/Figure_3.18.jpg)'
- en: 'Figure 3.18: Output displaying a predictable number for the MariaDB Pod, whereas
    a random name for the WordPress Pod'
  id: totrans-267
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.18：显示MariaDB Pod的可预测编号，而WordPress Pod的随机名称
- en: The numbering reinforces the ephemeral nature of the deployment Pods versus
    the StatefulSet Pods.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 编号强调了部署Pod与StatefulSet Pod的短暂性质。
- en: Another difference is how pod deletion is handled. When a deployment pod is
    deleted, Kubernetes will launch it again anywhere it can, whereas when a StatefulSet
    pod is deleted, Kubernetes will relaunch it only on the node it was running on.
    It will relocate the pod only if the node is removed from the Kubernetes cluster.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是如何处理pod的删除。当删除部署的pod时，Kubernetes会在任何可以的地方重新启动它，而当StatefulSet的pod被删除时，Kubernetes只会在它曾经运行的节点上重新启动它。只有在节点从Kubernetes集群中移除时，它才会重新定位pod。
- en: Often, you will want to attach storage to a StatefulSet. To achieve this, a
    StatefulSet requires a persistent volume. This volume can be backed by many mechanisms
    (including blocks, such as Azure Blob, EBS, and iSCSI, and network filesystems,
    such as AFS, NFS, and GlusterFS). Please refer to https://Kubernetes.io/docs/concepts/storage/volumes/#persistentvolumeclaim
    for more information.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望将存储附加到StatefulSet。为了实现这一点，StatefulSet需要一个持久卷。这个卷可以由许多机制支持（包括块，如Azure
    Blob、EBS和iSCSI，以及网络文件系统，如AFS、NFS和GlusterFS）。请参考https://Kubernetes.io/docs/concepts/storage/volumes/#persistentvolumeclaim获取更多信息。
- en: 'StatefulSets require either a pre-provisioned volume or a dynamically provisioned
    volume handled by a **PersistentVolumeClaim** (**PVC**). In our example, we are
    using a PVC. A PVC provides an abstraction over the underlying storage mechanism.
    Let''s look at what the MariaDB Helm Chart did for us by running the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: StatefulSets要求预先配置的卷或由**PersistentVolumeClaim**（**PVC**）处理的动态配置的卷。在我们的示例中，我们使用了PVC。PVC提供了对底层存储机制的抽象。让我们看看MariaDB
    Helm Chart通过运行以下命令为我们做了什么：
- en: '[PRE41]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will show us something similar to *Figure 3.19*:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向我们展示类似于*图3.19*的东西：
- en: '![Upon executing the kubectl get statefulsets command, the output screen will
    show you a MariaDB Pod inthe 1/1 Ready state.](image/Figure_3.19.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get statefulsets命令后，输出屏幕将显示一个处于1/1 Ready状态的MariaDB Pod。](image/Figure_3.19.jpg)'
- en: 'Figure 3.19: Output displaying the StatefulSet that created the MariaDB Pods'
  id: totrans-275
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.19：显示创建MariaDB Pods的StatefulSet的输出。
- en: 'Let''s have a more in-depth look by exporting the YAML definition of our StatefulSet:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 通过导出StatefulSet的YAML定义，让我们更深入地了解一下：
- en: '[PRE42]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let''s look at the most relevant parts of that YAML file. The code has been
    truncated to only show the most relevant parts:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下该YAML文件的最相关部分。代码已经被截断，只显示了最相关的部分：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Most of the elements of the preceding code have been covered earlier in the
    deployment. In the following block, we will highlight the key differences, to
    take a look at just the PVC:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的大部分元素在部署中已经涵盖过了。在接下来的块中，我们将突出显示关键的不同之处，只看PVC：
- en: Note
  id: totrans-281
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: PVC can be used by any Pod, not just StatefulSet Pods.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PVC可以被任何Pod使用，而不仅仅是StatefulSet Pods。
- en: 'Let''s discuss the different elements of the preceding code in detail:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论前面代码的不同元素：
- en: '**Line 4**: This line indicates the `StatefulSet` declaration.'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4行：此行指示了“StatefulSet”的声明。
- en: '**Lines 106-108**: Mount the volume defined as `data` and mount it under the
    `/bitnami/mariadb` path.'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第106-108行：挂载定义为“数据”的卷，并将其挂载在“/bitnami/mariadb”路径下。
- en: '**Lines 128-143**: Declare the PVC. Note specifically:'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第128-143行：声明PVC。特别注意：
- en: '**Line 136**: This line gives it the name `data`, which is reused at line 108.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第136行：此行将其命名为“数据”，在第108行重复使用。
- en: '**Line 139**: Gives the access mode `ReadWriteOnce`, which will create block
    storage, which on Azure is a disk.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第139行：给出了访问模式`ReadWriteOnce`，这将创建块存储，在Azure上是一个磁盘。
- en: '**Line 142**: Defines the size of the disk.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第142行：定义磁盘的大小。
- en: 'Based on the preceding information, Kubernetes dynamically requests and binds
    an 8Gi volume to this Pod. In this case, the default dynamic-storage provisioner
    backed by the Azure disk is used. The dynamic provisioner was set up by Azure
    when we created the cluster. To see the storage classes available on your cluster,
    you can run the following command:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的信息，Kubernetes动态请求并将8Gi卷绑定到此Pod。在这种情况下，使用了由Azure磁盘支持的默认动态存储provisioner。动态provisioner是在创建集群时由Azure设置的。要查看集群上可用的存储类，可以运行以下命令：
- en: '[PRE44]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This will show you an output similar to *Figure 3.20*:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似于*图3.20*的输出：
- en: '![The kubectl get storageclass command generates an output where you will see
    two storage classes, the default and managed premium. Both are of the provisioner
    type azure-disktype.](image/Figure_3.20.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get storageclass命令生成一个输出，您将看到两个存储类，即默认和托管高级。两者都是provisioner类型的azure-disktype。](image/Figure_3.20.jpg)'
- en: 'Figure 3.20: Output displaying the different storage classes in your cluster'
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.20：显示集群中不同存储类的输出
- en: 'We can get more details about the PVC by running the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，我们可以获取有关PVC的更多详细信息：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output generated is displayed in *Figure 3.21*:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出显示在*图3.21*中：
- en: '![When you execute the kubectl get pvc command, your output screen will display
    the Name, Status, Volume, Capacity, Access mode, Storageclass, and the age of
    each PVC.](image/Figure_3.21.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![当您执行kubectl get pvc命令时，输出屏幕将显示每个PVC的名称、状态、卷、容量、访问模式、存储类和年龄。](image/Figure_3.21.jpg)'
- en: 'Figure 3.21: Different PVCs in the cluster'
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.21：集群中不同的PVCs
- en: 'When we asked for storage in the StatefulSet description (lines 128-143), Kubernetes
    performed Azure-disk-specific operations to get the Azure disk with 8 GiB of storage.
    If you copy the name of the PVC and paste that in the Azure search bar, you should
    find the disk that was created:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在StatefulSet描述中请求存储（第128-143行）时，Kubernetes执行了Azure-disk特定的操作，以获取8 GiB存储的Azure磁盘。如果您复制PVC的名称并将其粘贴到Azure搜索栏中，您应该会找到已创建的磁盘：
- en: '![When you paste the PVC name that was generated from the previous command
    in the bar, you will see that a disk is created inthe Resources column.](image/Figure_3.22.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![当您将从上一个命令生成的PVC名称粘贴到栏中时，您将看到资源列中创建了一个磁盘。](image/Figure_3.22.jpg)'
- en: 'Figure 3.22: Getting the disk linked to a PVC'
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.22：获取与PVC关联的磁盘
- en: The concept of a PVC abstracts cloud provider storage specifics. This allows
    the same Helm template to work across Azure, AWS, or GCP. On AWS, it will be backed
    by **Elastic Block Store** (**EBS**), and on GCP it will be backed by Persistent
    Disk.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: PVC的概念抽象了云提供商的存储细节。这使得相同的Helm模板可以在Azure、AWS或GCP上工作。在AWS上，它将由**弹性块存储**（**EBS**）支持，在GCP上将由持久磁盘支持。
- en: Also, note that PVCs can be deployed without using Helm.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，可以在不使用Helm的情况下部署PVC。
- en: '**Checking the WordPress deployment**'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查WordPress部署**'
- en: 'After our analysis of the PVCs, let''s check back in with our Helm deployment.
    We can check the status of the deployment using:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析PVC之后，让我们再次检查Helm部署。我们可以使用以下命令检查部署的状态：
- en: '[PRE46]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This should return the output shown in *Figure 3.23*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回*图3.23*中显示的输出：
- en: '![On executing the helm ls command, the output screen will display the status
    of the deployment as deployed.](image/Figure_3.23.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![执行helm ls命令时，输出屏幕将显示部署的状态为已部署。](image/Figure_3.23.jpg)'
- en: 'Figure 3.23: Helm shows that our WordPress application has been deployed'
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.23：Helm显示我们的WordPress应用程序已部署
- en: 'We can get more info from our deployment in Helm using the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从Helm中获取更多信息：
- en: '[PRE47]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will return the output shown in *Figure 3.24*:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回*图3.24*中显示的输出：
- en: '![Using the helm status handsonakswp command, you can obtain more details about
    the application.](image/Figure_3.24.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: 使用helm status handsonakswp命令，您可以获取有关应用程序的更多详细信息。
- en: 'Figure 3.24: Getting more details about the application'
  id: totrans-315
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.24：获取有关应用程序的更多详细信息
- en: 'This shows us that our chart was successfully deployed. It also shows more
    info on how we can connect to our site. We won''t be using these steps for now;
    we will revisit these steps in *Chapter 5*, *Handling common failures in AKS*,
    in the section where we cover fixing storage mount issues. For now, we are going
    to look into everything that Helm created for us:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的图表已成功部署。它还显示了如何连接到我们的网站的更多信息。我们现在不会使用这些步骤；我们将在*第5章*“处理AKS中的常见故障”中重新讨论这些步骤，在该部分中我们将介绍如何修复存储挂载问题。现在，我们将查看Helm为我们创建的所有内容：
- en: '[PRE48]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will generate an output similar to *Figure 3.25*:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成类似于*图3.25*的输出：
- en: '![Executing the kubectl get all command generates an output screen that displays
    objects created by Helm such as Pod, Service, Deployment, ReplicaSet, and the
    StatefulSet, along with information about each of them. You will also get the
    external-ip of the WordPress service.](image/Figure_3.25.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: 图3.25：执行kubectl get all命令会生成一个输出屏幕，显示Helm创建的对象，如Pod、Service、Deployment、ReplicaSet和StatefulSet，以及每个对象的信息。您还将获得WordPress服务的外部IP。
- en: 'Figure 3.25: Output displaying all the objects created by Helm'
  id: totrans-320
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.25：显示Helm创建的所有对象的输出
- en: If you don't have an external IP yet, wait for a couple of minutes and retry
    the command.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有外部IP，请等待几分钟，然后重试该命令。
- en: 'You can then go ahead and connect to your external IP and access your WordPress
    site. The following screenshot is the resulting output:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以继续连接到您的外部IP并访问您的WordPress网站。以下截图是生成的输出：
- en: '![When you connect an external IP to the WordPress site, you will see a screen
    that displays Hello World! andencourages you to start writing a blog post.](image/Figure_3.26.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: 当您将外部IP连接到WordPress网站时，您将看到一个显示“Hello World！”并鼓励您开始撰写博客文章的屏幕。
- en: 'Figure 3.26: WordPress site being displayed on connection with the external
    IP'
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3.26：连接到外部IP时显示的WordPress网站
- en: 'To make sure we don''t run into issues in the following chapters, let''s delete
    the WordPress site. This can be done in the following way:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在接下来的章节中不会遇到问题，让我们删除WordPress网站。可以通过以下方式完成：
- en: '[PRE49]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'By design, our PVCs won''t be deleted. This ensures persistent data is kept.
    As we don''t have any persistent data, we can safely delete those as well:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，我们的PVCs不会被删除。这确保持久数据得到保留。由于我们没有任何持久数据，我们也可以安全地删除这些数据：
- en: '[PRE50]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-329
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Be very careful when executing `kubectl delete <object> --all` as it will delete
    all the objects in a namespace. This is not recommended on a production cluster.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`kubectl delete <object> --all`时要非常小心，因为它会删除命名空间中的所有对象。这在生产集群上是不推荐的。
- en: In this section, you have deployed a full WordPress site using Helm. You also
    learned how Kubernetes handles persistent storage using PVCs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您使用Helm部署了一个完整的WordPress网站。您还了解了Kubernetes如何使用PVC处理持久存储。
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we deployed two applications. We started the chapter by deploying
    the guestbook application. During that deployment, we looked into the details
    of Pods, ReplicaSets, and deployments. We also used dynamic configuration using
    ConfigMaps. Finally, we looked into how services are used to route traffic to
    the deployed applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们部署了两个应用程序。我们首先部署了guestbook应用程序。在部署过程中，我们查看了Pods、ReplicaSets和deployments的详细信息。我们还使用ConfigMaps进行动态配置。最后，我们了解了服务如何用于将流量路由到部署的应用程序。
- en: The second application we deployed was a WordPress application. We deployed
    it via the Helm package manager. As part of this deployment, PVCs were used, and
    we explored how these were used in the system.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部署的第二个应用是WordPress应用程序。我们通过Helm软件包管理器部署了它。作为部署的一部分，我们使用了PVC，并探讨了它们在系统中的使用方式。
- en: In the next chapter, we will look into scaling applications and the cluster
    itself. We will first look at the manual and automatic scaling of the application,
    and afterward, we'll look at the manual and automatic scaling of the cluster itself.
    Finally, we will explain different ways in which applications can be updated on
    Kubernetes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨应用程序和集群本身的扩展。我们将首先看一下应用程序的手动和自动扩展，然后再看一下集群本身的手动和自动扩展。最后，我们将解释在Kubernetes上更新应用程序的不同方式。
