- en: Hello OOP - Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程 - 类和对象
- en: '**Object-oriented programming** (**OOP**) is something special. If you search
    the internet for books on OOP, you''ll find hundreds of books on this topic. But
    still this topic will never become stale as it is the most efficient and most
    commonly used programming methodology in the industry. With the increase in the
    demand for software developers, there has also been an increase in the demand
    for good learning content. Our approach in this book is to describe the concepts
    of OOP in the simplest way. Understanding the basics of OOP is a must for developers
    who want to work with C#, as C# is a fully OOP language. In this chapter, we will
    try to understand what OOP actually is and the most basic concepts of OOP that
    are essential to begin our programming journey. Before anything else, let''s first
    start by analyzing the meaning of the term **object-oriented programming**.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向对象编程**（**OOP**）是特殊的。如果你在互联网上搜索关于OOP的书籍，你会发现数百本关于这个主题的书。但是这个主题永远不会变得陈旧，因为它是行业中最有效、最常用的编程方法。随着对软件开发人员的需求增加，对良好学习内容的需求也在增加。我们在这本书中的方法是以最简单的方式描述OOP的概念。理解OOP的基础对于想要使用C#工作的开发人员来说是必须的，因为C#是一种完全面向对象的语言。在本章中，我们将尝试理解OOP到底是什么，以及OOP的最基本概念，这些概念对我们开始编程之旅至关重要。在任何其他事情之前，让我们首先分析一下术语**面向对象编程**的含义。'
- en: The first word is **object**. According to the dictionary, an object is something
    that can be seen, felt, or touched; something that has physical existence in the
    real world. If an item is virtual, this means that it doesn't have any physical
    existence and is not considered an object. The second word is **oriented**, which
    indicates a direction or something to aim for. For example, when we say that we
    are oriented toward the building, we mean that we are facing towards it. The third
    word is **programming**. I believe I don't have to explain what programming is,
    but in case you are totally unaware of what programming is and are reading this
    book to learn, let me explain briefly what programming is. Programming is just giving
    instructions to the computer. As the computer doesn't speak our language, we humans
    have to give instructions to the computer in a language that the computer understands.
    We humans call these instructions **computer programs**, as we are guiding or
    instructing a computer to do a particular thing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个词是**对象**。根据词典的定义，对象是可以看到、感觉到或触摸到的东西；在现实世界中具有物理存在的东西。如果一个物品是虚拟的，这意味着它没有任何物理存在，不被视为对象。第二个词是**面向**，表示方向或目标。例如，当我们说我们面向建筑物时，我们的意思是我们正面朝它。第三个词是**编程**。我相信我不必解释什么是编程，但以防你完全不知道编程是什么并且正在阅读这本书来学习，让我简要解释一下编程是什么。编程只是给计算机指令。由于计算机不会说我们的语言，我们人类必须用计算机能理解的语言给它指令。我们人类称这些指令为**计算机程序**，因为我们正在引导或指导计算机做一件特定的事情。
- en: Now that we know the definitions of those three keywords, if we put all these
    words together, we can understand the meaning of the phrase *object-oriented programming*.
    OOP means that we write our computer programs by keeping objects at the center
    of our thinking. OOP is neither a tool nor a programming language—it is just a
    concept. Some programming languages are designed to follow this concept. C# is
    one of the most popular object-oriented languages. There are other object-oriented
    languages, such as Java, C++, and so on.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了这三个关键词的定义，如果我们把所有这些词放在一起，我们就能理解短语“面向对象编程”的含义。OOP意味着我们编写计算机程序时将对象置于思考的中心。OOP既不是工具也不是编程语言，它只是一个概念。一些编程语言是设计遵循这个概念的。C#是最流行的面向对象语言之一。还有其他面向对象的语言，比如Java、C++等等。
- en: In OOP, we try to think about our software components as small objects, and
    create relationships between them to solve a problem. You may have came across
    this approach with other programming concepts in the programming world, such as
    procedural programming, functional programming, and other kinds of programming.
    One of the most popular computer programming languages of all time—the C programming
    language—is a procedural programming language. F# is an example of a functional
    programming language.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，我们试图将软件组件看作小对象，并在它们之间建立关系来解决问题。你可能在编程世界中遇到过其他编程概念，比如过程式编程、函数式编程和其他类型的编程。有史以来最流行的计算机编程语言之一——C编程语言是一种过程式编程语言。F#是函数式编程语言的一个例子。
- en: 'In this chapter, we will cover the following topics of OOP:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖OOP的以下主题：
- en: Classes in OOP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP中的类
- en: The general form of a class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的一般形式
- en: What is an object?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是对象？
- en: Methods in a class
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类中的方法
- en: Characteristics of OOP
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OOP的特点
- en: Classes in OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP中的类
- en: In OOP, you derive objects from classes. In this section, we'll take a closer
    look at what a class actually is.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，你从类中派生对象。在本节中，我们将更仔细地看看类到底是什么。
- en: Classes are one of the most important concepts in OOP. You can say they are
    the building blocks of OOP. A class can be described as the blueprint of an object.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类是OOP中最重要的概念之一。你可以说它们是OOP的构建模块。类可以被描述为对象的蓝图。
- en: A class is like a template or blueprint that tells us what properties and behaviors
    an instance of this class will have. In most circumstances, a class itself can't
    actually do anything—it is just used to create objects. Let's look at an example
    to demonstrate what I am saying. Let's say we have a `Human` class. Here, when
    we say `Human`, we don't mean any particular person, but we are referring to a
    human being in general. A human that has two hands, two legs, and a mouth, and
    which can also walk, talk, eat, and think. These properties and their behaviors
    are applicable to most human beings. I know that this is not the case for disabled
    people, but for now, we will assume our generic human is able—bodied, keeping
    our example simple. So when we see the aforementioned properties and behaviors
    in an object, we can easily categorize that object as a human object or person.
    This classification is called a class in OOP.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于一个模板或蓝图，告诉我们这个类的实例将具有什么属性和行为。在大多数情况下，一个类本身实际上不能做任何事情——它只是用来创建对象的。让我们看一个例子来说明我所说的。假设我们有一个“Human”类。在这里，当我们说“Human”时，我们并不是指任何特定的人，而是指一般的人类。一个有两只手、两条腿和一个嘴巴的人，还可以走路、说话、吃饭和思考。这些属性及其行为适用于大多数人类。我知道这对于残疾人来说并非如此，但现在，我们将假设我们的一般人类是健全的，以保持我们的例子简单。因此，当我们在一个对象中看到上述属性和行为时，我们可以很容易地将该对象归类为人类对象或人。这种分类在面向对象编程中称为类。
- en: 'Let''s take a closer look at the properties and behaviors of a `Human` class.
    There are hundreds of properties that you can list for a human, but for the sake
    of simplicity, we can say that the following are the properties of a human being:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看“Human”类的属性和行为。人类可以列举数百种属性，但为了简单起见，我们可以说以下是人类的属性：
- en: Height
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度
- en: Weight
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体重
- en: Age
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: 'We can do the same for behavioral properties. There are hundreds of particular
    behaviors that a person can perform, but here we will only consider the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对行为属性做同样的事情。一个人可以执行数百种特定的行为，但在这里我们只考虑以下行为：
- en: Walk
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 走
- en: Talk
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谈
- en: Eat
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吃
- en: The general form of a class
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的一般形式
- en: 'To create a class in C#, you have to follow a particular syntax. The general
    form of this is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 要在C#中创建一个类，必须遵循特定的语法。其一般形式如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `class` phrase is a **reserved keyword** in C#, and it is used to tell
    the compiler that we want to create a class. To create a class, place the `class` keyword and
    then the name of the class after a space. The name of the class can be anything
    that starts with a character or an underscore. We can also include numbers in
    the class name, but not the first character of a class name. After the chosen
    name of the class, you have to put an opening curly brace, which denotes the start
    of the class body. You can add content in the class, such as properties and methods,
    and then finish the class with a closing curly brace, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: “class”短语是C#中的**保留关键字**，用于告诉编译器我们想要创建一个类。要创建一个类，需要在一个空格后放置`class`关键字，然后是类的名称。类的名称可以是以字符或下划线开头的任何内容。类名中也可以包括数字，但不能是类名的第一个字符。在选择的类名之后，必须放置一个开放的大括号，表示类体的开始。您可以在类中添加内容，例如属性和方法，然后用一个闭合的大括号结束类，如下所示：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There are other keywords that can be used with classes to add more functionality,
    such as access modifiers, virtual methods, partial methods, and so on. Don't worry
    about these keywords or their uses, as we will discuss these later in this book.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他关键字可以与类一起使用，以添加更多功能，例如访问修饰符、虚方法、部分方法等。不要担心这些关键字或它们的用途，因为我们将在本书的后面讨论这些内容。
- en: Writing a simple class
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写一个简单的类
- en: 'Now let''s create our first class. Let''s imagine that we are developing some
    software for a bank. Our application should keep track of the bank''s customers
    and their bank accounts, and perform some basic actions on those bank accounts.
    As we are going to design our application using C#, we have to think of our application
    in an object-oriented way. Some objects that we will need for this application
    could be a customer object, a bank account object, and other objects. So, to make
    blueprints of these objects, we have to create a `Customer` class and a `BankAccount`
    class, as well as the other classes that we will need. Let''s first create the
    `Customer` class using the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的第一个类。假设我们正在为一家银行开发一些软件。我们的应用程序应该跟踪银行的客户及其银行账户，并对这些银行账户执行一些基本操作。由于我们将使用C#设计我们的应用程序，因此我们必须以面向对象的方式思考我们的应用程序。我们将需要这个应用程序的一些对象，比如客户对象、银行账户对象和其他对象。因此，为了制作这些对象的蓝图，我们必须创建一个`Customer`类和一个`BankAccount`类，以及我们将需要的其他类。让我们首先使用以下代码创建`Customer`类：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We started with the `class` keyword and then the name of the class, which is
    `Customer`. After that, we added the class body inside curly braces, `{}`. The variables
    that the class has are `firstName`, `lastName`, `phoneNumber`, and `emailAddress`.
    The class also has a method called `GetFullName()`, which uses the `firstName`
    and the `lastName` fields to prepare the full name and return it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`class`关键字开始，然后是`Customer`类的名称。之后，我们在大括号`{}`内添加了类体。该类拥有的变量是`firstName`、`lastName`、`phoneNumber`和`emailAddress`。该类还有一个名为`GetFullName()`的方法，该方法使用`firstName`和`lastName`字段来准备全名并返回它。
- en: 'Now let''s create a `BankAccount` class using the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用以下代码创建一个`BankAccount`类：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we can see that we have followed a similar approach to create a class.
    We have used the `class` keyword and then the name of the `BankAccount` class .
    After the name, we started the class body with an opening curly brace and entered
    fields such as `bankAccountNumber`, `bankAccountOwnerName`, `amount`, and `openningDate`,
    followed by two methods, `Credit` and `Debit`. By placing a closing curly brace,
    we end the class body.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们已经遵循了创建类的类似方法。我们使用了`class`关键字，然后是`BankAccount`类的名称。在名称之后，我们用一个开放的大括号开始了类体，并输入了字段，如`bankAccountNumber`、`bankAccountOwnerName`、`amount`和`openningDate`，然后是两个方法，`Credit`和`Debit`。通过放置一个闭合的大括号，我们结束了类体。
- en: For now, don't get worried about keywords such as **public**; we will learn
    about these keywords later in the book when we talk about access specifiers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不要担心诸如**public**之类的关键字；当我们讨论访问修饰符时，我们将在本书的后面学习这些关键字。
- en: Objects in OOP
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程中的对象
- en: We now know what a **class** is. Now let's look at what **object** refers to
    in OOP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了**类**是什么。现在让我们来看看面向对象编程中**对象**是指什么。
- en: An object is an instance of a class. In other words, an object is an implementation
    of a class. For example, in our banking application, we have a `Customer` class,
    but that doesn't mean that we actually have a customer in our application. To
    create a customer, we have to create an object of the `Customer` class. Let's
    say that we have a customer called Mr. Jack Jones. For this customer, we have
    to create an object of the `Customer` class, where the name of the person is Jack
    Jones.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是类的一个实例。换句话说，对象是类的一个实现。例如，在我们的银行应用程序中，我们有一个`Customer`类，但这并不意味着我们实际上在我们的应用程序中有一个客户。要创建一个客户，我们必须创建`Customer`类的对象。假设我们有一个名为琼斯先生的客户。对于这个客户，我们必须创建`Customer`类的对象，其中人的名字是杰克琼斯。
- en: As Mr. Jones is our customer, this means that he also has an account in our
    bank. To create a bank account for Mr. Jones, we have to create an object of the `BankAccount` class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于琼斯先生是我们的客户，这意味着他也在我们的银行有一个账户。要为琼斯先生创建一个银行账户，我们必须创建一个`BankAccount`类的对象。
- en: How to create objects
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何创建对象
- en: 'In C#, to create an object of a class, you have to use the `new` keyword. Let''s
    look at an example of an object:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，要创建一个类的对象，您必须使用`new`关键字。让我们看一个对象的例子：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we started by writing `Customer`, which is the name of the class. This
    represents the type of the object. After that, we gave the name of the object,
    which in this case is `customer1`. You can give any name to that object. For example,
    if the customer is Mr. Jones, we could name the object `jackJones`. After the
    object name, we then inserted an equals sign (`=`), which means that we are assigning
    a value to the `customer1 `object. After that, we entered a keyword called `new`,
    which is a special keyword that tells the compiler to create a new object of the
    class that is given next to it. Here, we gave `Customer` again with `()` next
    to it. When we place `Customer()`, we are actually calling the constructor of
    that class. We will talk about constructors in subsequent chapters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先写了`Customer`，这是类的名称。这代表了对象的类型。之后，我们给出了对象的名称，在这种情况下是`customer1`。您可以给该对象任何名称。例如，如果客户是琼斯先生，我们可以将对象命名为`jackJones`。在对象名称之后，我们插入了一个等号（`=`），这意味着我们正在给`customer1`对象赋值。之后，我们输入了一个称为`new`的关键字，这是一个特殊的关键字，告诉编译器创建给定类的新对象。在这里，我们再次给出了`Customer`，并在其旁边加上了`()`。当我们放置`Customer()`时，我们实际上正在调用该类的构造函数。我们将在后续章节中讨论构造函数。
- en: 'We can create `jackJones` by using the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码创建`jackJones`：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Variables in C#
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C#中的变量
- en: In the previous code, you might have noticed that we created a few variables.
    A **variable** is something that varies, which means it is not constant. In programming,
    when we create a variable, the computer actually allocates a space in memory for
    it so that a value of the variable can be stored there.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，您可能已经注意到我们创建了一些变量。**变量**是一种变化的东西，这意味着它不是常数。在编程中，当我们创建一个变量时，计算机实际上会为其分配内存空间，以便可以将变量的值存储在那里。
- en: 'Let''s assign some values to the variables of the objects that we created in
    the previous section. We will first work with the `customer1` object, as shown
    in the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们在上一节中创建的对象的变量分配一些值。我们将首先处理`customer1`对象，如下所示的代码：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we are assigning values to the `customer1` object. The code instructs
    the computer to create a space in the memory and store the value in it. Later,
    whenever you access the variable, the computer will go to the memory location
    and find out the value of the variable. Now, if we write a statement that will
    print the value of the `firstName` variable with the additional string before
    it, it will look as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在给`customer1`对象赋值。该代码指示计算机在内存中创建一个空间并将值存储在其中。稍后，每当您访问变量时，计算机将转到内存位置并找出变量的值。现在，如果我们编写一个语句，将打印`firstName`变量的值以及其前面的附加字符串，它将如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of this code will be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出将如下所示：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Methods in a class
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类中的方法
- en: 'Let''s talk about another important topic—namely methods. A **method** is a
    piece of code that is written in the code file and can be reused. A method can
    hold many lines of code, which will be executed when it is called. Let''s take
    a look at the general form of a method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈另一个重要的话题——方法。**方法**是在代码文件中编写的可以重复使用的代码片段。一个方法可以包含许多行代码，在调用时将被执行。让我们来看一下方法的一般形式：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We can see that the first thing in the method declaration is an `access-modifier`.
    This will set the access permission of the method. Then, we have the `return-type`
    of the method, which will hold the type that the method will return, such as `string`,
    `int`, `double`, or another type. After that, we have the `method-name` and then
    brackets, `()`, which indicate that it is a method. In the brackets, we have the `parameter-list`.
    This can either be empty or can contain one or more parameters. Finally, we have
    curly brackets, `{}`, which hold the method body. The code that the method will
    execute goes inside here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到方法声明中的第一件事是`access-modifier`。这将设置方法的访问权限。然后，我们有方法的`return-type`，它将保存方法将返回的类型，例如`string`，`int`，`double`或其他类型。之后，我们有`method-name`，然后是括号`()`，表示这是一个方法。在括号中，我们有`parameter-list`。这可以是空的，也可以包含一个或多个参数。最后，我们有花括号`{}`，其中包含方法体。方法将执行的代码放在这里。
- en: Any code following this structure will be considered a method by the C# compiler.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种结构的任何代码将被C#编译器视为方法。
- en: Creating a method
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个方法
- en: 'Now that we know what a method is, let''s take a look at an example, as shown
    in the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道了方法是什么，让我们来看一个例子，如下所示的代码：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This code will create a method called `GetFullName`. This method takes two parameters,
    `firstName` and `lastName`, which are placed inside the parentheses. We can also
    see that we have to specify the types of those parameters. In this particular
    example, both the parameter types are `string`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将创建一个名为`GetFullName`的方法。这个方法接受两个参数，`firstName`和`lastName`，放在括号里。我们还可以看到，我们必须指定这些参数的类型。在这个特定的例子中，这两个参数的类型都是`string`。
- en: Now, take a look at the method body, which is the section between the curly
    brackets, `{}`. We can see that the code returns `firstName + lastName`, which
    means that it is concatenating the two parameters, `firstName` and `lastName`,
    and returning the `string`. As we are planning to return a `string` from this
    method, we set the return type of the method to `string`. Another thing to notice
    is that the access type is set to `public` for this method, which means that any
    other class can access it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一下方法体，即大括号之间的部分`{}`。我们可以看到，代码返回`firstName + lastName`，这意味着它正在连接这两个参数`firstName`和`lastName`，并返回`string`。因为我们打算从这个方法返回一个`string`，所以我们将方法的返回类型设置为`string`。另一个需要注意的是，这个方法的访问类型设置为`public`，这意味着任何其他类都可以访问它。
- en: Constructor of a class
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类的构造函数
- en: In every class, there is a special type of method, called a **constructor**.
    You can create a constructor in a class and program it. If you don't create one
    yourself, the compiler will create a very simple constructor and use that instead.
    Let's take a look at what the constructor is and what it does.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个类中，都有一种特殊类型的方法，称为**构造函数**。你可以在一个类中创建一个构造函数并对其进行编程。如果你自己不创建一个，编译器将创建一个非常简单的构造函数并使用它。让我们来看看构造函数是什么，它的作用是什么。
- en: A constructor is a method that gets triggered when an object of a class is created.
    A constructor is mainly used to set the prerequisites of the class. For example,
    if you are creating an object of the `Human` class, that human object must have
    a `date of birth`. Without a date of birth, no human would exist. You can set
    this requirement in the constructor. You can also configure the constructor to
    set the `date of birth` as today if no date of birth is given. This depends on
    the needs of your application. Another example could be a `bank account` object,
    for which you have to provide the bank account holder. No bank account can exist
    without an owner, so you can set this requirement in the constructor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是在创建类的对象时触发的方法。构造函数主要用于设置类的先决条件。例如，如果你正在创建`Human`类的对象，那个人的对象必须有一个`出生日期`。没有出生日期，就不会有人存在。你可以在构造函数中设置这个要求。你还可以配置构造函数，如果没有提供出生日期，则将出生日期设置为今天。这取决于你的应用程序的需求。另一个例子可能是`bank
    account`对象，你必须提供银行账户持有人。没有所有者，就不可能存在银行账户，所以你可以在构造函数中设置这个要求。
- en: 'Let''s take a look at the general form of a constructor, as shown in the following
    code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下构造函数的一般形式，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see that there is a difference between a constructor and a normal
    method, namely that a constructor doesn''t have a return type. This is because
    a constructor can''t return anything; it''s for initialization, not for any other
    type of action. Normally, the type of access is `public` for constructors, because
    otherwise no object can be instantiated. If you specifically want to prevent objects
    of a class from being instantiated, you can set the constructor as `private`.
    Let''s look at an example of a constructor, as shown in the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到构造函数和普通方法之间有一个区别，即构造函数没有返回类型。这是因为构造函数不能返回任何东西；它是用于初始化，而不是用于任何其他类型的操作。通常，构造函数的访问类型是`public`，因为否则无法实例化对象。如果你特别想阻止类的对象被实例化，你可以将构造函数设置为`private`。让我们看一个构造函数的例子，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this example, we can see that we have a class called `BankAccount` and that
    it has a variable called `owner`. As we know, no bank account can exist without
    an owner, so we need to assign a value to the `owner` when an object is created.
    In order to create a `constructor`, we just make the access type of the constructor
    `public`, as we want objects to get instantiated. We can also take the name of
    the owner of the bank account as a parameter in the constructor and use it to
    assign the variable, as shown in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到有一个名为`BankAccount`的类，它有一个名为`owner`的变量。正如我们所知，没有所有者的银行账户是不存在的，所以我们需要在创建对象时为`owner`赋值。为了创建一个`构造函数`，我们只需将构造函数的访问类型设置为`public`，因为我们希望对象被实例化。我们还可以在构造函数中将银行账户所有者的姓名作为参数，并将其用于赋值给变量，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you put parameters in the constructor, then, when initializing the object,
    the parameters need to be passed, as shown in the following code:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在构造函数中放入参数，那么在初始化对象时，需要传递参数，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Another interesting thing is that you can have multiple constructors in a class.
    You might have one constructor that takes one argument and another that doesn''t
    take any arguments. Depending on the way in which you are initializing the object,
    the respective constructor will be called. Let''s look at the following example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的事情是，你可以在一个类中有多个构造函数。你可能有一个构造函数带有一个参数，另一个不带任何参数。根据初始化对象的方式，将调用相应的构造函数。让我们看下面的例子：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding example, we can see that we have two constructors for the `BankAccount` class.
    If you pass a parameter when you create a `BankAccount` object, it will call the
    second constructor, which will set the value and create the object. If you don't
    pass a parameter while creating the object, the first constructor will be called.
    If you don't have either one of these constructors, this method of object creation
    won't be available.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们可以看到`BankAccount`类有两个构造函数。如果在创建`BankAccount`对象时传递参数，它将调用第二个构造函数，这将设置值并创建对象。如果在创建对象时不传递参数，将调用第一个构造函数。如果这两个构造函数都没有，那么这种对象创建方法将不可用。
- en: 'If you don''t create a class, then the compiler creates an empty constructor
    for that class, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不创建一个类，那么编译器会为该类创建一个空的构造函数，如下所示：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Characteristics of OOP
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的特点
- en: 'OOP is one of the most important programming methodologies nowadays. The whole
    concept depends on four main ideas, which are known as the **pillars of OOP**.
    These four pillars are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是当今最重要的编程方法之一。整个概念依赖于四个主要思想，被称为**面向对象编程的支柱**。这四个支柱如下：
- en: Inheritance
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Encapsulation
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 封装
- en: Polymorphism
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Abstraction
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象
- en: Inheritance
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: The word **inheritance** means receiving or deriving something from something
    else. In real life, we might talk about a child inheriting a house from his or
    her parents. In that case, the child has the same power over the house that his
    parents had. This concept of inheritance is one of the pillars of OOP. In programming,
    when one class is derived from another class, this is called inheritance. This
    means that the derived class will have the same properties as the parent class.
    In programming terminology, the class from which another class is derived is called
    the **parent class**, while the classes that inherit from these are called **child
    classes**.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**一词意味着从其他地方接收或衍生出某物。在现实生活中，我们可能会谈论一个孩子从父母那里继承房子。在这种情况下，孩子对房子拥有与父母相同的权力。这种继承的概念是面向对象编程的支柱之一。在编程中，当一个类从另一个类派生时，这被称为继承。这意味着派生类将具有与父类相同的属性。在编程术语中，从另一个类派生的类被称为**父类**，而继承自这些类的类被称为**子类**。'
- en: 'Let''s look at an example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, we used inheritance. We have a parent class, called
    `Fruit`. This class holds the common properties that every fruit has: a `Name`
    and a `Color`. We can use this `Fruit` class for all fruits.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用了继承。我们有一个名为`Fruit`的父类。这个类包含每种水果都有的共同属性：`Name`和`Color`。我们可以为所有水果使用这个`Fruit`类。
- en: If we create a new class, called `Apple`, this class can inherit the `Fruit`
    class because we know that an apple is a fruit. The properties of the `Fruit`
    class are also properties of the `Apple` class. If the `Apple` inherits the `Fruit`
    class, we don't need to write the same properties for the `Apple` class because
    it inherits these from the `Fruit` class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个名为`Apple`的新类，这个类可以继承`Fruit`类，因为我们知道苹果是一种水果。`Fruit`类的属性也是`Apple`类的属性。如果`Apple`继承`Fruit`类，我们就不需要为`Apple`类编写相同的属性，因为它从`Fruit`类继承了这些属性。
- en: Encapsulation
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: '**Encapsulation** means hiding or covering. In C#, encapsulation is achieved
    by **access modifiers**. The access modifiers that are available in C# are the
    following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装**意味着隐藏或覆盖。在C#中，封装是通过**访问修饰符**实现的。在C#中可用的访问修饰符如下：'
- en: Public
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共
- en: Private
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有
- en: Protected
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护
- en: Internal
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部
- en: Internal protected
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部保护
- en: Encapsulation is when you want to control other classes' access to a certain
    class. Let's say you have a `BankAccount` class. For security reasons, it isn't
    a good idea to make that class accessible to all classes. It's better to make
    it `Private` or use another kind of access specifier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是当您想要控制其他类对某个类的访问时使用的。比如说您有一个`BankAccount`类。出于安全原因，让这个类对所有类都可访问并不是一个好主意。最好将其设为`私有`或使用其他类型的访问修饰符。
- en: 'You can also limit access to the properties and variables of a class. For example,
    you might need to keep the `BankAccount` class `public` for some reason, but make
    the `AccountBalance` property `private` so that no other class can access this
    property except the `BankAccount` class. You can do this as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以限制对类的属性和变量的访问。例如，您可能需要保持`BankAccount`类对某些原因是`public`的，但将`AccountBalance`属性设为`private`，这样除了`BankAccount`类之外，其他类都无法访问这个属性。您可以这样做：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Like variables and properties, you can also use access specifiers for methods.
    You can write `private` methods that are not needed by other classes, or that
    you don''t want to expose to other classes. Let''s look at the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 像变量和属性一样，您还可以为方法使用访问修饰符。您可以编写不需要其他类使用的`private`方法，或者您不希望向其他类公开的方法。让我们看下面的例子：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding example, the `GetBalanceAfterTax` method is a method that will
    not be needed by other classes. We only want to provide the `AccountBalance` after
    tax, so we can make this method private.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`GetBalanceAfterTax`方法是一个其他类不需要的方法。我们只想提供税后的`AccountBalance`，所以我们可以将这个方法设为私有。
- en: Encapsulation is a very important part of OOP as it gives us control over code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是面向对象编程的一个非常重要的部分，因为它让我们对代码有控制权。
- en: Abstraction
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: 'If something is abstract, it means that it doesn''t have an instance in reality
    but does exist as an idea or concept. In programming, we use this technique to
    organize our thoughts. This is one of the pillars of OOP. In C#, we have `abstract`
    classes, which implement the concept of abstraction. **Abstract classes** are
    classes that don''t have any instances, classes that implement the `abstract`
    class will implement the properties and methods of that `abstract` class. Let''s
    look at an example of an `abstract` class, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某物是抽象的，意味着它在现实中没有实例，但作为一个想法或概念存在。在编程中，我们使用这种技术来组织我们的思想。这是面向对象编程的支柱之一。在C#中，我们有`abstract`类，它实现了抽象的概念。**抽象类**是没有任何实例的类，实现`abstract`类的类将实现该`abstract`类的属性和方法。让我们看一个`abstract`类的例子，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, we have an abstract class called `Vehicle`. It has
    one abstract method, called `GetNumberOfTyres()`. As it is an abstract method,
    this has to be overridden by the classes that implement the abstract class. Our `Bicycle`
    and `Car` classes implement the `Vehicle` abstract class, so they also override
    the abstract method `GetNumberOfTyres()`. If you take a look at the implementation
    of these methods in the two classes, you will see that the implementation is different,
    which is due to abstraction.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个名为`Vehicle`的抽象类。它有一个名为`GetNumberOfTyres()`的抽象方法。由于它是一个抽象方法，这个方法必须被实现抽象类的类所覆盖。我们的`Bicycle`和`Car`类实现了`Vehicle`抽象类，因此它们也覆盖了抽象方法`GetNumberOfTyres()`。如果你看一下这两个类中这些方法的实现，你会发现实现是不同的，这是由于抽象性。
- en: Polymorphism
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态性
- en: The word **polymorph** means many forms. To understand the concept of **polymorphism**
    properly, let's work with an example. Let's think about a person, such as Bill
    Gates. We all know that Bill Gates is a great software developer, businessman,
    philanthropist, and also a great human being. He is one individual, but he has
    different roles and performs different tasks. This is polymorphism. When Bill
    Gates was developing software, he was playing the role of a software developer.
    He was thinking about the code he was writing. Later, when he became the CEO of
    Microsoft, he started managing people and thinking about growing the business.
    He's the same person, but with different roles and different responsibilities.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 多态一词意味着许多形式。要正确理解多态的概念，让我们举个例子。让我们想想一个人，比如比尔·盖茨。我们都知道比尔·盖茨是一位伟大的软件开发者、商人、慈善家，也是一位伟大的人。他是一个人，但他有不同的角色和执行不同的任务。这就是多态性。当比尔·盖茨正在开发软件时，他扮演着软件开发者的角色。他在思考他正在编写的代码。后来，当他成为微软的首席执行官时，他开始管理人员并思考如何发展业务。他是同一个人，但担任不同的角色和不同的责任。
- en: 'In C#, there are two kind of polymorphism: **static polymorphism** and **dynamic
    polymorphism**. Static polymorphism is a kind of polymorphism where the role of
    a method is determined at compilation time, whereas, in dynamic polymorphism,
    the role of a method is determined at runtime. Examples of static polymorphism
    include **method overloading** and **operator overloading**. Let''s take a look
    at an example of method overloading:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，有两种多态性：静态多态性和动态多态性。静态多态性是一种多态性，其中方法的角色在编译时确定，而在动态多态性中，方法的角色在运行时确定。静态多态性的例子包括方法重载和运算符重载。让我们看一个方法重载的例子：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we can see that we have two methods with the same name, `AddNumbers`.
    Normally, we can't have two methods that have the same name; however, as the parameters
    of those methods are different, methods are allowed to have the same name by the
    compiler. Writing a method with the same name as another method, but with different
    parameters, is called method overloading. This is a kind of polymorphism.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到我们有两个同名的方法`AddNumbers`。通常情况下，我们不能有两个同名的方法；然而，由于这些方法的参数是不同的，编译器允许方法具有相同的名称。编写一个与另一个方法同名但参数不同的方法称为方法重载。这是一种多态性。
- en: 'Like method overloading, **operator overloading** is also a static polymorphism.
    Let''s look at an example of operator overloading to demonstrate this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 像方法重载一样，运算符重载也是一种静态多态性。让我们看一个运算符重载的例子来证明这一点：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we can see that the plus sign (`+`) is overloaded
    with another kind of calculation. So if you sum up two `MyCalc` objects, you will
    get an overloaded result instead of the normal sum, and this overloading happens
    at compile time, so it is static polymorphism.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们可以看到加号（+）被重载为另一种计算。因此，如果你对两个`MyCalc`对象求和，你将得到一个重载的结果，而不是正常的和，这种重载发生在编译时，因此它是静态多态性。
- en: '**Dynamic polymorphism** refers to the use of the abstract class. When you
    write an abstract class, no instance can be created from that abstract class.
    When any other class uses or implements that abstract class, the class also has
    to implement the abstract methods of that abstract class. As different classes
    can implement the abstract class and can have different implementations of abstract
    methods, polymorphic behavior is achieved. In this case, we have methods with
    the same name but different implementations.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**动态多态性**指的是使用抽象类。当你编写一个抽象类时，不能从该抽象类创建实例。当任何其他类使用或实现该抽象类时，该类也必须实现该抽象类的抽象方法。由于不同的类可以实现抽象类并且可以有不同的抽象方法实现，因此实现了多态行为。在这种情况下，我们有相同名称但不同实现的方法。'
- en: Summary
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covers classes and objects, the most important building blocks
    of OOP. These are the two things that we should learn before jumping into any
    other topics in OOP. It is important to make sure that these concepts are clear
    in our minds before moving on to other ideas. In this chapter, we learned about
    what a class is and why it's needed in OOP. We also looked at how to create a
    class in C# and how to define an object. After that, we looked at the relationship
    between classes and objects and how to instantiate a class and use it. We also
    talked about variables and methods in a class. Lastly, we covered the four pillars
    of OOP. In the next chapter, we will learn more about inheritance and class hierarchy.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章涵盖了类和对象，这是面向对象编程中最重要的构建模块。这些是我们在跳入面向对象编程的任何其他主题之前应该学习的两件事。在继续其他想法之前，确保我们的思想中清楚了这些概念是很重要的。在这一章中，我们了解了类是什么，以及为什么在面向对象编程中需要它。我们还看了如何在C#中创建一个类以及如何定义一个对象。之后，我们看了类和对象之间的关系以及如何实例化一个类并使用它。我们还讨论了类中的变量和方法。最后，我们涵盖了面向对象编程的四大支柱。在下一章中，我们将学习更多关于继承和类层次结构的知识。
