- en: '*Chapter 4*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第四章*'
- en: Testing JavaScript
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试JavaScript
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够做到以下几点：
- en: Analyze the benefit of tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析测试的好处
- en: Explain the various forms of code testing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释代码测试的各种形式
- en: Build code-testing environments
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建代码测试环境
- en: Implement tests for your JavaScript code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的JavaScript代码实施测试
- en: This chapter will cover the concepts of testing, test frameworks, and how to
    work with the different ways to effectively testing code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖测试的概念、测试框架以及如何有效地测试代码的不同方式。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: In the first chapter, we covered many of the new and powerful features released
    in ES6\. We discussed the evolution of JavaScript and highlighted the key additions
    in ES6\. We discussed scope rules, variable declaration, arrow functions, template
    literals, enhanced object properties, destructuring assignment, classes and modules,
    transpiling, and iterators and generators. In the second chapter, we covered JavaScript's
    asynchronous programming paradigm. We discussed the JavaScript event loop, callbacks,
    promises, and the async/await syntax. In the third chapter, we learned about the
    Document Object Model (DOM), the JavaScript Event object, and the jQuery library.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章中，我们介绍了ES6中发布的许多新功能和强大功能。我们讨论了JavaScript的发展历程，并突出了ES6中的关键添加。我们讨论了作用域规则、变量声明、箭头函数、模板文字、增强的对象属性、解构赋值、类和模块、转译以及迭代器和生成器。在第二章中，我们讨论了JavaScript的异步编程范式。我们讨论了JavaScript事件循环、回调、承诺和async/await语法。在第三章中，我们学习了文档对象模型（DOM）、JavaScript事件对象和jQuery库。
- en: In this chapter, we will learn about testing code and code-testing frameworks
    in JavaScript. In the first topic, we will introduce testing and discuss test-driven
    development. Then, we will discuss applying test-driven development and several
    different ways you can test your code and applications. In the final topic, we
    will discuss several JavaScript code-testing frameworks that you can use to build
    powerful tests for your code.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习有关JavaScript中测试代码和代码测试框架的知识。在第一个主题中，我们将介绍测试并讨论测试驱动开发。然后，我们将讨论应用测试驱动开发以及您可以测试代码和应用程序的几种不同方式。在最后一个主题中，我们将讨论几种JavaScript代码测试框架，您可以使用它们来为您的代码构建强大的测试。
- en: Testing
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试
- en: Testing code is a lot like going to the gym. You know it is good for you. All
    of the arguments make sense, but getting up and starting down the road to fitness
    is difficult. The initial rush feels amazing; however, it is closely followed
    by sore muscles and you begin to wonder if it was really worth it. You take an
    hour or more out of your day but all you have to show for it is sore arms and
    legs. But, after a few weeks, it gets easier. You start to notice the benefits
    of working out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码很像去健身房。你知道这对你有好处。所有的论点都说得通，但起身并开始健身之路是困难的。最初的冲动感觉很棒；然而，紧随其后的是酸痛的肌肉，你开始怀疑这是否真的值得。你花了一个小时甚至更多的时间，但你所能展示的只是酸痛的手臂和腿。但是，几周后，情况变得更容易。你开始注意到锻炼的好处。
- en: Much like going to the gym, you have probably heard how important testing code
    can be. Writing tests is an integral part of writing good and sustainable code.
    It can be difficult when you first start writing tests. Writing your first tests
    and having them run successfully brings a thrill or rush, but after a day or two
    of taking an hour out of your work day to write tests, you begin to wonder if
    it is really worth it. But you stick with it. After several weeks, it becomes
    less tedious and you begin to notice the small benefits testing your code brings.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 就像去健身房一样，您可能已经听说过测试代码有多么重要。编写测试是编写良好和可持续代码的一个重要部分。当您开始编写测试时可能会感到困难。编写您的第一个测试并使其成功运行会带来一种兴奋感，但在工作日中花费一个小时来编写测试后的一两天后，您开始怀疑这是否真的值得。但您坚持下去。几周后，这变得不那么乏味，您开始注意到测试代码带来的一些小好处。
- en: In this chapter, we will discuss the reasons to test code, the types of tests
    you may need to implement, and some JavaScript frameworks you may use to implement
    and run your tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论测试代码的原因，您可能需要实施的测试类型，以及您可能使用的一些JavaScript框架来实施和运行测试。
- en: Reasons to Test Code
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试代码的原因
- en: There are many reasons to test your code. These reasons include program correctness,
    agile development, code quality, bug catching, legal liability, gratification,
    and many more. We will briefly discuss each of the listed reasons and explain
    their benefits.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码有许多原因。这些原因包括程序正确性、敏捷开发、代码质量、错误捕捉、法律责任、满足感等等。我们将简要讨论列出的每个原因，并解释它们的好处。
- en: '**Correctness**'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**正确性**'
- en: The simplest and most important reason to test code is that testing code checks
    for code correctness. Intelligently written tests will test all the logic in your
    code against predetermined input values and their corresponding output values.
    By comparing the program's output with the expected output, we can verify that
    code works as expected, catching semantic or syntactic errors before they are
    integrated into code.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的最简单和最重要的原因是测试代码检查代码的正确性。智能编写的测试将针对预定的输入值和相应的输出值测试代码中的所有逻辑。通过将程序的输出与预期输出进行比较，我们可以验证代码是否按预期工作，捕捉语义或语法错误，然后将其集成到代码中。
- en: '**Agile Development**'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**敏捷开发**'
- en: Testing code makes the development process more agile. The **Agile Development
    Cycle** is one of the most popular and hottest development styles, and is being
    adopted by software companies including Lockheed Martin, Snapchat, and Google.
    Agile development relies on short duration goals. Changing old and tested code
    is a very slow process. If any old code needs to be refactored or needs to have
    features added or removed, we would need to go through the entire process of testing
    it again. With written code tests, we can automate them, and expedite the testing
    process, and save hours of time over doing manual tests. This could be the difference
    between meeting our Agile sprint goals and missing a deadline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码使开发过程更加敏捷。**敏捷开发周期**是最受欢迎和最热门的开发风格之一，被包括洛克希德·马丁、Snapchat和谷歌在内的软件公司采用。敏捷开发依赖于短期目标。更改旧的经过测试的代码是一个非常缓慢的过程。如果需要重构或添加或删除功能的任何旧代码，我们需要重新测试整个过程。有了编写的代码测试，我们可以自动化它们，加快测试过程，并节省大量时间。这可能是实现我们的敏捷冲刺目标和错过截止日期之间的区别。
- en: 'Note:'
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: The Agile Development Cycle focuses on short sprints to design, implement, and
    release new features. These sprints are usually two or three weeks in length.
    This short and speedy development strategy allows you to build a large product
    in smaller parts and manage potentially changing requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 敏捷开发周期专注于短期冲刺，设计、实施和发布新功能。这些冲刺通常为两到三周。这种短期和快速的开发策略使您能够将一个大型产品分解成较小的部分，并管理潜在的变化需求。
- en: '**Bug Catching**'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**捕获错误**'
- en: Testing code will allow you to find bugs earlier in the development cycle. Tests
    should be performed before integration into a product or module. This means that
    any bugs found by the tests will be found and fixed before they are integrated
    into a product. Debugging a module that has already been fully integrated into
    an application is much more difficult than debugging a module that is still in
    development. Writing and running tests before integration will allow you to find
    and fix these bugs before they interact with other code, saving large amounts
    of time. Catching errors before integration and pushing correct working code is
    one of the most important skills a developer can have, and code testing can greatly
    improve this skill.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码将使您能够在开发周期的早期发现错误。测试应该在集成到产品或模块之前进行。这意味着测试发现的任何错误将在集成到产品之前被发现和修复。调试已完全集成到应用程序中的模块比调试仍在开发中的模块要困难得多。在集成之前编写和运行测试将使您能够在它们与其他代码交互之前找到并修复这些错误，节省大量时间。在集成之前捕获错误并推送正确的工作代码是开发人员可以拥有的最重要的技能之一，代码测试可以极大地提高这一技能。
- en: '**Code Quality**'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**代码质量**'
- en: Code tests increase the quality of written code. When writing code with tests,
    we must design and implement our code explicitly with these tests in mind. Writing
    good tests helps us to think more completely about the problem we are trying to
    solve and the way we are going to go about solving the problem; we must consider
    things such as edge cases and design a good implementation that meets the test's
    requirements. Writing tests will help you better understand the design and implementation
    of your code, which will result in higher quality and better thought out code.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试提高了编写代码的质量。在编写带有测试的代码时，我们必须明确地考虑这些测试来设计和实施我们的代码。编写良好的测试有助于我们更全面地思考我们试图解决的问题以及我们将要解决问题的方式；我们必须考虑诸如边缘情况之类的事情，并设计一个满足测试要求的良好实现。编写测试将帮助您更好地理解代码的设计和实现，从而产生更高质量、更深思熟虑的代码。
- en: '**Legal Liability**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 法律责任
- en: Writing tests can help prevent and mitigate legal liability. In many jurisdictions
    and market areas, vendors are required to ensure or prove that the provided software
    is of marketable quality. A documented test process has the potential to limit
    your legal liability in some cases. This may prevent you from being sued for a
    software bug. In the worst of cases, a well-documented testing process can also
    be provided to prove that the software bug involved in litigation did not arise
    through malpractice. This could reduce your punitive damages or personal responsibility.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试可以帮助预防和减轻法律责任。在许多司法管辖区和市场领域，供应商被要求确保或证明所提供的软件具有市场质量。有记录的测试过程有可能在某些情况下限制您的法律责任。这可能会防止您因软件漏洞而被起诉。在最糟糕的情况下，充分记录的测试过程也可以用来证明诉讼中涉及的软件漏洞并非出于过失。这可能会减少您的惩罚性赔偿或个人责任。
- en: '**Gratification**'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**满足感**'
- en: The final reason to test code is often overlooked by most people. Testing code
    can be very gratifying. Tests can give you instant visual feedback about the correctness
    of your code. Seeing green check marks across the board is very satisfying. Releasing
    code that you know is well written and well tested, and will perform flawlessly,
    is very satisfying. Knowing your code is well tested can help you be confident
    about the release when the deadline comes up.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的最终原因经常被大多数人忽视。测试代码可以非常令人满意。测试可以立即给您关于代码正确性的视觉反馈。看到所有方面都有绿色的勾号是非常令人满意的。发布您知道写得很好、经过充分测试并且将会无故障运行的代码是非常令人满意的。知道您的代码经过了充分测试可以帮助您在截止日期到来时对发布感到自信。
- en: Test-driven Development
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试驱动开发
- en: '**Test-driven development** (**TDD**) is a form of software development focused
    around writing tests before implementing code. It is generally an Agile cycle
    and is one of the simplest ways to integrate tests into your code. TDD is a software
    development process that is built around a short and simple development cycle.
    In its most basic form, the cycle consists of adding a test that defines how the
    new function should work, and then writing code until the test''s requirements
    are met. This cycle is repeated until all functionality has been added.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）是一种以编写测试为重点的软件开发形式，先于实现代码。它通常是敏捷开发周期的一部分，也是将测试整合到代码中的最简单方式之一。TDD是围绕短而简单的开发周期构建的软件开发过程。在其最基本的形式中，该周期包括添加一个定义新功能应如何工作的测试，然后编写代码直到满足测试的要求。这个周期重复进行，直到所有功能都被添加。'
- en: Test-driven development requires that the automated tests are created by the
    developer. These tests should well define the code's requirements and should be
    defined before any code is written. The tests should cover all expected or potential
    use cases, especially edge cases. The passing of the tests will inform the developer
    when development is complete.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发要求开发人员创建自动化测试。这些测试应该清楚地定义代码的要求，并且应该在编写任何代码之前定义。测试应该覆盖所有预期或潜在的用例，特别是边界情况。测试的通过将通知开发人员开发何时完成。
- en: 'Note:'
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：
- en: An edge case is a situation that occurs at the extremes of operating parameters.
    In code, an edge case refers to valid input values that could require special
    handling. For example, the Fibonacci sequence algorithm (F(n)=F(n-1)+F(n-2)) requires
    special handling if the sequence value is 0 or 1.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 边界情况是发生在操作参数的极端情况。在代码中，边界情况指的是可能需要特殊处理的有效输入值。例如，斐波那契数列算法（F(n)=F(n-1)+F(n-2)）在序列值为0或1时需要特殊处理。
- en: TDD allows developers to break their code into small and manageable steps when
    necessary. This is possible because TDD requires that each function and feature
    added must have tests. We can write one small test, then write the code that makes
    that test pass. Large features and functions can be broken down into small pieces
    and built in increments. This can greatly help with understanding all the parts
    of a problem.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: TDD允许开发人员在必要时将其代码分解为小而可管理的步骤。这是可能的，因为TDD要求每个添加的函数和功能都必须有测试。我们可以编写一个小测试，然后编写使该测试通过的代码。大型功能和函数可以分解为小部分，并逐步构建。这可以极大地帮助理解问题的所有部分。
- en: TDD can also promote more modular and reusable code. Each piece of code must
    be tested, and large pieces of code can be broken down into smaller parts. This
    can lead to smaller, more focused classes and functions, and fewer cross-dependencies
    between code files. These smaller parts can be wrapped in a module with their
    tests and shared through a program. Updates to the module can simply be verified
    for correctness by running the attached test suite.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: TDD还可以促进更模块化和可重用的代码。每一部分代码都必须经过测试，大段的代码可以分解为小部分。这可以导致更小、更专注的类和函数，以及代码文件之间更少的交叉依赖。这些小部分可以被包装在一个带有它们的测试的模块中，并通过程序共享。对模块的更新可以通过运行附加的测试套件来简单地验证其正确性。
- en: TDD Cycle
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TDD周期
- en: 'The TDD cycle is generally a sequence of six steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TDD周期通常是一个六个步骤的序列：
- en: '**Add a test:** In TDD, every new feature should begin with test writing. To
    write a new test, you must clearly understand the feature''s specifications and
    requirements. The requirements for the feature must be thought out and broken
    into testable pieces that can be written as tests one at a time.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加测试：**在TDD中，每个新功能都应该以编写测试开始。要编写新测试，必须清楚地理解功能的规格和要求。功能的要求必须经过深思熟虑，并分解成可以逐一编写为测试的可测试部分。'
- en: '**Run all tests and see if any fail:** To check if the new test passes, the
    test should obviously fail because the feature we are adding has not been implemented
    yet. If the test does not fail, then the feature already exists or the test was
    written incorrectly. This serves as a sanity check of the written test. The test
    should fail for the intended purpose and serves to help check that the intended
    logic is being tested.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行所有测试并查看是否有失败：**为了检查新测试是否通过，测试显然应该失败，因为我们正在添加的功能尚未实现。如果测试没有失败，那么该功能已经存在，或者测试编写错误。这是对编写的测试进行理智检查。测试应该为预期目的而失败，并有助于检查所测试的逻辑是否正确。'
- en: '**Write code to fix tests:** The code does not need to be perfect at this stage.
    The test may be fixed in an inefficient way but this is acceptable because it
    can be refactored later in the process.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**编写代码修复测试：**在这个阶段，代码不需要完美。测试可能以低效的方式修复，但这是可以接受的，因为它可以在后续的过程中进行重构。'
- en: '**Run tests and make sure they pass:** The tests should all pass, including
    all the previously added tests. If new code has broken a test that previously
    passed, changes can be reverted to figure out what the breaking change may have
    been.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行测试并确保它们通过：**测试应该全部通过，包括之前添加的所有测试。如果新代码破坏了之前通过的测试，可以撤销更改以找出可能的破坏性变化。'
- en: '**Refactor/clean up code:** If any code cleanup is needed, it can be done in
    this step. Here, you can improve the implementation of the newly added code or
    fix any tests that may have broken when adding new code. After any refactoring,
    you should run the tests again to make sure all changes were correct. Repeat the
    refactor and run the test step as needed until the refactor is correct.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重构/清理代码：**如果需要进行任何代码清理，可以在这一步完成。在这里，您可以改进新添加的代码的实现，或者修复在添加新代码时可能已经破坏的任何测试。在任何重构之后，应该再次运行测试以确保所有更改都是正确的。根据需要重复重构和运行测试步骤，直到重构正确为止。'
- en: '**Repeat:** Add a new test and repeat the TDD cycle until the feature has been
    fully implemented and tested.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**重复：**添加一个新的测试，并重复TDD周期，直到功能已经完全实现和测试。'
- en: Test-driven development is a powerful way to ensure that all code is tested
    but it can lead to several pitfalls if the developers are not conscientious. TDD
    can be difficult to use when a full stack or functional test is required. A full
    stack or functional test is a test of multiple parts of a technology stack at
    once. Tests that require user interface elements, database calls, or network calls
    can be very difficult to write. Typically, outside world interaction for a test
    in your code can be spoofed by using mock data or network calls.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是确保所有代码都经过测试的强大方法，但如果开发人员不够谨慎，它可能会导致几个陷阱。当需要完整堆栈或功能测试时，TDD可能很难使用。完整堆栈或功能测试是一次对技术堆栈的多个部分进行测试。需要用户界面元素、数据库调用或网络调用的测试可能非常难编写。通常情况下，代码中测试的外部世界交互可以通过使用模拟数据或网络调用来欺骗。
- en: TDD can also begin to break down if tests are not run frequently or are poorly
    maintained. If tests are abandoned and never run, or only run infrequently, the
    entire purpose of TDD breaks down. The features added to a program are designed
    with tests in mind, and the tests are used to validate that the features are properly
    implemented. If the tests are never run, the entire purpose of TDD is ignored.
    Tests that are poorly maintained also prevent TDD from being effective. Poor maintenance
    can occur through either not being updated to meet adjusted feature requirements,
    or through not having new tests added that outline the requirements of new features.
    Poorly maintained tests will not properly inform you of whether the code written
    is performing in the way we want it to.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试不经常运行或维护不当，TDD也可能会开始崩溃。如果测试被放弃并且从不运行，或者只是偶尔运行，TDD的整个目的就会崩溃。添加到程序中的功能是根据测试设计的，并且测试用于验证功能是否被正确实现。如果测试从未运行，TDD的整个目的就被忽视了。维护不当的测试也会阻止TDD的有效性。维护不当可能是因为没有更新以满足调整后的功能要求，或者没有添加概述新功能要求的新测试。维护不当的测试将无法正确地告诉您编写的代码是否按照我们想要的方式执行。
- en: TDD can also fall prey to poorly or lazily written tests. If tests are too coarse,
    they will not be able to find bugs in the code. The tests must be written with
    enough specificity to test each bit of logic independently from the others. On
    the other end of the spectrum, if trivial tests are added, we waste time in our
    TDD Agile process. If tests are written that are trivial or that duplicate previous
    tests, we will decrease our development efficiency.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: TDD也可能会受到测试编写不当或懒散的影响。如果测试太粗糙，它们将无法找到代码中的错误。测试必须具有足够的特异性，以独立地测试每一点逻辑，而不受其他逻辑的影响。另一方面，如果添加了琐碎的测试，我们会在TDD敏捷过程中浪费时间。如果编写了琐碎的测试或重复了以前的测试，我们将降低开发效率。
- en: Finally, TDD can break down if any members of the team do not adopt the development
    strategy. If only part of a development team writes the tests before the addition
    of new code, we will only be able to test and validate a small part of the code
    base. For TDD to have the best results, it has to be fully adopted by all members
    of a development team.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果团队中的任何成员不采用开发策略，TDD可能会崩溃。如果只有部分开发团队在添加新代码之前编写测试，我们只能测试和验证代码库的一小部分。为了使TDD取得最佳结果，所有开发团队成员都必须完全采用它。
- en: Conclusion
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: Testing your code is the best way to ensure that it functions in the intended
    way. If you do not currently test your code, it can be very difficult to get started
    implementing tests; however, it should be done. Testing your code can make your
    code more correct, easy to write, and of higher quality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码是确保代码按预期方式运行的最佳方法。如果您目前不测试代码，要开始实施测试可能会非常困难；然而，这是必须要做的。测试代码可以使您的代码更正确、更容易编写和更高质量。
- en: 'Test-driven development is one of the simplest ways to begin integrating tests
    in a project. TDD revolves around writing tests that outline the requirements
    of any feature or function added before any implementation code is written. It
    forces the developer to understand exactly how each feature will be implemented.
    TDD is a simple six-step process: add a test, run tests, write code, run tests,
    refactor, repeat. This process ensures that each small piece of a feature gets
    tested.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 测试驱动开发是在项目中开始集成测试的最简单方法之一。TDD围绕着在编写任何实现代码之前添加概述任何功能或函数要求的测试。它迫使开发人员准确了解每个功能将如何实现。TDD是一个简单的六步过程：添加测试，运行测试，编写代码，运行测试，重构，重复。这个过程确保了每个功能的小部分都得到了测试。
- en: 'Exercise 24: Applying Test-Driven Development'
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习24：应用测试驱动开发
- en: 'You have been tasked to write a Fibonacci number generator. Use the test-driven
    development cycle to write tests and develop the Fibonacci algorithm. You can
    use the Fibonacci code written in *Chapter 1: Introducing ECMAScript 6*, Activity
    I, for reference (it may or may not need to be modified). You should write tests
    for the `n=0` condition, then implement the `n=0` condition, then write tests
    for and implement the `n=1` condition, then write tests for and implement the
    `n=2` condition, and finally the `n=5`, `n=7`, and `n=9` conditions. If the test
    passes, log `Test passed`. Otherwise, throw an error.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求编写一个斐波那契数生成器。使用测试驱动开发周期编写测试并开发斐波那契算法。您可以参考*第1章：介绍ECMAScript 6*中的斐波那契代码，进行修改。您应该为`n=0`条件编写测试，然后实现`n=0`条件，然后为`n=1`条件编写测试并实现，然后为`n=2`条件编写测试并实现，最后为`n=5`、`n=7`和`n=9`条件编写测试并实现。如果测试通过，则记录`测试通过`。否则，抛出错误。
- en: 'To develop and test an algorithm using TDD, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TDD开发和测试算法，执行以下步骤：
- en: By hand, calculate the values for the Fibonacci sequence at n=0, n=1, n=2, n=5,
    n=7, and n=9.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手工计算斐波那契数列在n=0，n=1，n=2，n=5，n=7和n=9时的值。
- en: Write a function called `fibonacci` that recursively calculates the Fibonacci
    sequence value where the value takes in a variable `i` and checks if `i<=0`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`fibonacci`的函数，该函数以变量`i`作为输入，递归计算斐波那契数列的值，并检查`i<=0`。
- en: If it is, return `1`, then it checks `if i==1`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，返回`1`，然后检查`if i==1`。
- en: If it is, then it returns `1`. Otherwise, it recursively gets the Fibonacci
    value.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，则返回`1`。否则，它会递归获取斐波那契值。
- en: It then returns `fibonacci(i-1) + fibonacci(i-2)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然后返回`fibonacci(i-1) + fibonacci(i-2)`。
- en: 'Write a general testing function called test that takes in two arguments: a
    calculated value (`value`) and an expected value (`expected`).'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个名为`test`的通用测试函数，它接受两个参数：计算出的值（`value`）和预期值（`expected`）。
- en: Check whether the two values are different. If they are, throw an error.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查两个值是否不同。如果它们不同，则抛出错误。
- en: If the two values are the same, print the `Test passed` message.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果两个值相同，请打印`测试通过`消息。
- en: For each condition to test (calculated in step 1, n=0, n=1, n=2, n=5, n=7, and
    n=9), write a test for the test condition using the `test` function.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个要测试的条件（在步骤1中计算，n=0，n=1，n=2，n=5，n=7和n=9），使用`test`函数编写测试条件的测试。
- en: Call the `test` function and pass in the value returned from the `fibonacci`
    function and the value calculated manually.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`test`函数，并传入从`fibonacci`函数返回的值和手动计算的值。
- en: Run the tests.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: If the test fails, fix the bugs in the `fibonacci` function.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试失败，请修复`fibonacci`函数中的错误。
- en: Run the test again until the bugs are fixed.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复错误后再次运行测试。
- en: If the test passes, continue to the next test condition.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试通过，请继续下一个测试条件。
- en: If the test fails, fix the bug and rerun the tests.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果测试失败，请修复错误并重新运行测试。
- en: '**Code**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: index.js
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: index.js
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: https://bit.ly/2H5CNv0
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2H5CNv0
- en: 'Snippet 4.1: Testing code'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段4.1：测试代码
- en: '**Output**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 4.1: Fibonacci test'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1：斐波那契测试'
- en: '](image/Figure_4.1.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1.jpg)'
- en: 'Figure 4.1: Fibonacci test'
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：斐波那契测试
- en: You have successfully applied test-driven development to develop and test an
    algorithm.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功应用测试驱动开发来开发和测试算法。
- en: Types of Testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试类型
- en: Software testing comes in many different forms. In this section, we will discuss
    the different methodologies for testing code and cover the most common types of
    code tests.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 软件测试有许多不同的形式。在本节中，我们将讨论测试代码的不同方法，并涵盖最常见的代码测试类型。
- en: Black Box and White Box Testing
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑盒和白盒测试
- en: There are two methodologies to testing code, black box and white box. The term
    **black box** signifies a system where the internal workings are not known. The
    only way the system can be observed is through its inputs and outputs. A **white
    box** system is a system where the internal workings are known. It can be observed
    through its inputs, outputs, and exact internal workings. Black box and white
    box systems could be anything from a software program, to a mechanical device,
    or any other system.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码有两种方法，黑盒和白盒。术语**黑盒**表示内部工作原理未知的系统。观察系统的唯一方法是通过其输入和输出。**白盒**系统是已知内部工作原理的系统。可以通过其输入、输出和确切的内部工作原理来观察。黑盒和白盒系统可以是任何东西，从软件程序到机械设备或任何其他系统。
- en: '**Black box testing** refers to software testing when the internal structure
    or implementation of the code is not known to the tester. We are only able to
    observe the inputs to, and outputs from the code system. **White box testing**
    refers to software testing when the internal structure or implementation is known
    to the tester. We are able to observe the inputs and outputs'' and exactly how
    the internal state changes at every step of the program. Nearly all forms of code
    testing are based on black box or white box testing principles. A visualization
    showing black box versus white box is shown in the following figure:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**黑盒测试**是指在测试软件时，测试人员不知道代码的内部结构或实现。我们只能观察代码系统的输入和输出。**白盒测试**是指在测试软件时，测试人员知道代码的内部结构或实现。我们能够观察输入和输出，并确切地了解程序每一步的内部状态如何改变。几乎所有形式的代码测试都基于黑盒或白盒测试原则。以下图示显示了黑盒与白盒的对比：'
- en: '![Figure 4.2: Black box and white box visualization'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2：黑盒和白盒可视化'
- en: '](image/Figure_4.2.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2.jpg)'
- en: 'Figure 4.2: Black box and white box visualization'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：黑盒和白盒可视化
- en: 'We will discuss three types of tests: **unit tests**, **functional tests**,
    and **integration tests**. Unit tests are designed to verify all pieces of testable
    code against the intended purpose. They test the smallest pieces of logic to ensure
    implementation correctness. Functional testing is designed to confirm functionality
    of a feature or component. Integration tests are designed to test integrated components
    to verify they work as intended together in an integrated system. These three
    types of code tests provide a good foundation from which you can approach testing
    code.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论三种类型的测试：**单元测试**，**功能测试**和**集成测试**。单元测试旨在验证所有可测试代码的预期目的。它们测试最小的逻辑片段，以确保实现的正确性。功能测试旨在确认功能或组件的功能。集成测试旨在测试集成的组件，以验证它们在集成系统中一起按预期工作。这三种代码测试为您提供了一个良好的基础，可以从中进行代码测试。
- en: Unit Tests
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: '**Unit testing** is one of the most common forms of testing. Unit tests are
    used to ensure that a specific piece of functionality of a function has met the
    requirements. Unit tests are generally built from a white box testing perspective
    and we will discuss unit tests in this chapter, assuming that the internal functionality
    of the code is known. While unit tests can be built from a black box perspective,
    this is closer to functional testing and will be talked about more in the next
    section.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**单元测试**是最常见的测试形式之一。单元测试用于确保函数的特定功能部分已满足要求。单元测试通常从白盒测试的角度构建，我们将在本章中讨论单元测试，假设已知代码的内部功能。虽然单元测试可以从黑盒的角度构建，但这更接近功能测试，并将在下一节中更多地讨论。'
- en: 'A unit test is simply a test that tests a piece of code in the smallest unit
    possible. A "unit" of code is a small piece that is logically isolated from other
    parts of code. In other words, it is a piece of code that does not logically depend
    on other parts of the code. The unit of code can be updated without affecting
    the way the code around it functions. For example, consider the code shown in
    the following snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试只是测试尽可能小的代码单元的测试。代码的“单元”是一个与代码的其他部分逻辑上隔离的小片段。换句话说，它是一段不依赖于代码其他部分的逻辑的代码。代码单元可以更新而不影响其周围代码的功能。例如，考虑以下代码片段中显示的代码：
- en: '[PRE1]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Snippet 4.2: Code unit example'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段4.2：代码单元示例
- en: 'The function `adjustValue()` takes in a number. If the number is greater than
    5, it subtracts 1 from the number, and if the value is less than -5, it adds 1
    to the number. We can break this code snippet into three logical units as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`adjustValue()`接受一个数字。如果数字大于5，则从数字中减去1，如果值小于-5，则向数字中添加1。我们可以将这段代码分解为三个逻辑单元，如下所示：
- en: The first unit is the `if` statement that checks if the value is greater than
    5 and the decrement operator (`value--`).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个单元是检查值是否大于5的`if`语句和减量运算符（`value--`）。
- en: The second unit is the else `if` statement that checks if the value is less
    than -5 and the increment operator (`value++`).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个单元是`else if`语句，检查值是否小于-5，并且增量运算符（`value++`）。
- en: The third unit of logic is the `return` statement. Changing any one of these
    three logic units does not affect the logical structure of the code around it.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三个逻辑单元是`return`语句。更改这三个逻辑单元中的任何一个都不会影响其周围代码的逻辑结构。
- en: We can create a unit test for each of these units to ensure that they function
    correctly. Our unit tests should test only one unit of code at a time. For this
    example we will need 3 unit tests. We will build tests to check the return value,
    the greater than 5 condition, and the less than -5 condition. To test the return
    condition, we simply need to pass in a value less than or equal to 5 and greater
    than or equal to -5\. The value returned should be the same as the value passed
    into the function. To test the greater than 5 condition, we must pass in a value
    greater than 5\. We know that the value returned must be 1 lower than the value
    entered. To test the less than condition, we must pass in a value less than -5\.
    We know that the value returned should be 1 higher than the value entered. These
    three unit tests can be put into a code file and run after we make modifications
    to our code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为每个单元创建一个单元测试，以确保它们的功能正确。我们的单元测试应该一次只测试一个代码单元。对于这个例子，我们将需要3个单元测试。我们将构建测试来检查返回值、大于5的条件和小于-5的条件。要测试返回条件，我们只需要传入一个小于或等于5且大于或等于-5的值。返回的值应该与传入函数的值相同。要测试大于5的条件，我们必须传入一个大于5的值。我们知道返回的值必须比输入的值低1。要测试小于条件，我们必须传入一个小于-5的值。我们知道返回的值应该比输入的值高1。这三个单元测试可以放入一个代码文件中，并在对代码进行修改后运行。
- en: Unit tests should be run as frequently as possible. The unit test should be
    put into files and run whenever any code logic is changed. Minor changes in the
    logic of a piece of code can result in major changes in the results. Continuous
    testing will help to ensure that no small bugs creep through the cracks. Many
    companies have automated testing systems that will run unit tests automatically
    on a Git repository commits or on a version release. This automated testing can
    be very good for helping to track down the commit and change that broke the code.
    This can drastically cut down on debug time and effort.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应尽可能频繁地运行。单元测试应该放入文件中，并在任何代码逻辑发生变化时运行。代码片段逻辑的微小变化可能导致结果的重大变化。持续测试将有助于确保没有小错误悄然产生。许多公司都有自动化测试系统，将在Git存储库提交或版本发布时自动运行单元测试。这种自动化测试对于帮助追踪破坏代码的提交和更改非常有用。这可以大大减少调试时间和精力。
- en: 'Exercise 25: Building Unit Tests'
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习25：构建单元测试
- en: 'You have been tasked with building unit tests for a piece of code. To complete
    this assignment, follow these instructions:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你被要求为一段代码构建单元测试。要完成这个任务，请按照以下说明进行操作：
- en: Reference the file provided in `exercises/exercise25/exercise.js` and look at
    the function titled `fakeRounding`. We will build unit tests for this function.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考`exercises/exercise25/exercise.js`中提供的文件，并查看名为`fakeRounding`的函数。我们将为这个函数构建单元测试。
- en: 'In that file, write a general testing function called `test` that takes in
    two arguments: a calculated value (`value`) and an expected value (`expected`).
    Check whether the two values are different. If they are, throw an error.'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，编写一个名为`test`的通用测试函数，该函数接受两个参数：计算出的值（`value`）和预期值（`expected`）。检查这两个值是否不同。如果它们不同，就抛出一个错误。
- en: If the two values are the same, print the test passed message. You may use the test
    function from *Exercise 24* if you wish.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这两个值相同，就打印测试通过的消息。如果愿意，可以使用*练习24*中的`test`函数。
- en: Reference the `fakeRounding` function, line by line, and analyze what the function
    does to the input and the resultant output.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 参考`fakeRounding`函数，逐行分析函数对输入和输出的影响。
- en: It obtains the decimal part of the absolute value of the number passed in. It returns
    the input rounded up to the nearest integer if the decimal is <=0.5\. Next, it
    returns the input rounded down to the nearest integer if the decimal is >0.5.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它获取传入数字的绝对值的小数部分。如果小数<=0.5，则返回最接近整数的输入。接下来，如果小数>0.5，则返回最接近整数的输入向下取整。
- en: Write tests to check the following cases using the `test` function we created.
    Calculate the expected value from the provided input.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用我们创建的`test`函数编写测试，检查以下情况。从提供的输入计算预期值。
- en: 'Write tests for multiple inputs, 0, 0.4999, 0.5, 0.5001, -0.4999, -0.5, and
    -0.5001:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为多个输入编写测试，0、0.4999、0.5、0.5001、-0.4999、-0.5和-0.5001：
- en: '**Code:**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '**solution.js**'
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**solution.js**'
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Snippet 4.3: Unit testing'
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段4.3：单元测试
- en: https://bit.ly/2Fjulqw
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2Fjulqw
- en: '**Output:**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Figure 4.3: Unit Test'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3：单元测试'
- en: '](image/Figure_4.3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3.jpg)'
- en: 'Figure 4.3: Unit Test'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：单元测试
- en: You have successfully built unit tests for a piece of code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经成功为一段代码构建了单元测试。
- en: Functional Testing
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能测试
- en: '**Functional testing** is a black box testing method done to determine whether
    a component of an application is working to the defined specification. Functional
    tests are generally more complex than unit tests. Where unit tests test the logic
    of the functions inside of a component, functional tests are designed to test
    whether the component meets the specifications defined in the specification sheet
    or data sheet. For example, if we had a form on a web page that only accepted
    numbers, we may do functional tests with numbers and strings to ensure that the
    number-only spec was met correctly.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能测试**是一种黑盒测试方法，用于确定应用程序的组件是否按照定义的规范工作。功能测试通常比单元测试更复杂。单元测试测试组件内部函数的逻辑，而功能测试旨在测试组件是否符合规范表或数据表中定义的规范。例如，如果我们在网页上有一个只接受数字的表单，我们可能会使用数字和字符串进行功能测试，以确保正确满足仅接受数字的规范。'
- en: 'Functional testing can be broken down into five steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试可以分为五个步骤：
- en: Determine functionality
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定功能
- en: Create input data
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建输入数据
- en: Determine output data
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定输出数据
- en: Compare input and output
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 比较输入和输出
- en: Fix bugs
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复错误
- en: The first step to building functional tests is determining the functionality
    that needs to be tested. Functional tests generally test for the main functionality,
    error conditions, usability, and many others. It is often easiest to determine
    what tests need to be built by looking at the feature/component specification
    or data sheet. You can take the required program behavior and error handling for
    the component from the data sheet, and break it into a series of tests.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 构建功能测试的第一步是确定需要测试的功能。功能测试通常测试主要功能、错误条件、可用性等。通常最容易确定需要构建的测试是通过查看特性/组件规范或数据表来确定的。您可以从数据表中获取组件的所需程序行为和错误处理，并将其分解为一系列测试。
- en: Once you have decided what functionality needs to be tested and how you will
    go about testing that functionality you must create input data to test with. The input
    data required for tests is heavily dependent on the component or feature being
    built, and therefore can be difficult to generalize for the purposes of a textbook.
    However, you should test with both values that you expect the program to accept
    and values that may be unexpected for the program. For example, if we are creating
    an email input form, we should test the input field with both a valid email (`xxxx@yyy.zzz`)
    and an invalid email (`12344312`). When generating arbitrary test data, it is
    often a good idea to test with non-sequential values in arrays, strings, or other
    data structures. Using random values can help you discover logic errors.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了需要测试的功能以及如何测试该功能，您必须创建输入数据进行测试。测试所需的输入数据严重依赖于正在构建的组件或特性，因此很难为教科书的目的进行概括。但是，您应该使用您期望程序接受的值和可能对程序来说意外的值进行测试。例如，如果我们正在创建一个电子邮件输入表单，我们应该使用有效的电子邮件（`xxxx@yyy.zzz`）和无效的电子邮件（`12344312`）来测试输入字段。在生成任意测试数据时，通常最好使用数组、字符串或其他数据结构中的非顺序值进行测试。使用随机值可以帮助您发现逻辑错误。
- en: Once you have determined the input data required for your tests, you must figure
    out the expected output from the feature. This part of the process is arguably
    the most important and should not be rushed. Output values should NEVER be calculated
    by putting the input through the program being tested. This will result in a tautology
    when running the tests and no bugs will be found. I have seen many tests fail
    because the programmer did not properly calculate the expected output values and
    the tests were invalid.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 确定测试所需的输入数据后，您必须确定特性的预期输出。这个过程的这一部分可以说是最重要的，不应该草率对待。输出值绝对不能通过将输入通过正在测试的程序来计算。这将导致在运行测试时出现重言，不会发现任何错误。我曾经看到许多测试失败，因为程序员没有正确计算预期的输出值，测试无效。
- en: Once the output values have been determined, we are ready to run our tests.
    The input values should be run through the feature or component and compared against
    the output values. A test passes if the output values from the component match
    the expected output values calculated in the previous step. If the values do not
    match, the test did not pass and a bug needs to be fixed.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了输出值，我们就可以运行我们的测试了。输入值应该通过特性或组件，并与输出值进行比较。如果组件的输出值与前一步计算的预期输出值相匹配，则测试通过。如果值不匹配，则测试未通过，需要修复错误。
- en: The final step in the process is bug fixing. If a test does not pass, then there
    is a bug somewhere in the component. Once the bugs have been fixed, the test can
    be re-run. If all of the tests pass for all of the functionality being tested,
    the component may be considered ready for integration.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的最后一步是修复错误。如果测试未通过，则组件中存在错误。修复错误后，可以重新运行测试。如果所有功能的所有测试都通过，则该组件可能被认为已准备好进行集成。
- en: 'Building tests can be one of the most difficult parts of functional testing.
    There are two different types of tests that we need to build: positive and negative
    tests. Positive tests test the expected program use flows and negative tests test
    the unexpected use flows.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 构建测试可能是功能测试中最困难的部分之一。我们需要构建两种不同类型的测试：正向测试和负向测试。正向测试测试预期的程序使用流程，而负向测试测试意外的使用流程。
- en: Positive tests are relatively easy to generate. Any action you might want or
    expect a user to do can be turned into a positive test case. For example, clicking
    a button on an application or entering information into a text field. These two
    use cases can be turned into a functional test for clicking the button and a functional
    test for typing in the text field. Since positive tests are designed to test the
    expected program flow, they should use valid and expected data. In a case where
    a test does not use data but instead uses some other functionality, such as a
    user's mouse click, we would only need to write positive tests for the expected
    behaviors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正面测试相对容易生成。任何您希望或期望用户执行的操作都可以转化为正面测试用例。例如，单击应用程序中的按钮或在文本字段中输入信息。这两个用例可以转化为单击按钮的功能测试和输入文本字段的功能测试。由于正面测试旨在测试预期的程序流程，因此应使用有效和预期的数据。在测试不使用数据而是使用其他功能的情况下，例如用户的鼠标点击，我们只需要为预期行为编写正面测试。
- en: Negative tests are more difficult to create. They require much more creativity
    to build and implement effectively because you must come up with weird ways to
    break your own code. It can often be difficult to anticipate how a user may misuse
    a feature. Negative tests are designed to test error paths and failures. For example,
    if we intend a user to click a button on our website, it may be prudent to write
    negative tests for the double-click condition. A double-click is unexpected behavior
    and may result in a form resubmission if not properly accounted for. Negative
    tests are essential to fully testing a feature.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 负面测试更难创建。它们需要更多的创造力来有效地构建和实施，因为你必须想出奇怪的方法来破坏自己的代码。往往很难预料用户可能如何误用功能。负面测试旨在测试错误路径和失败。例如，如果我们打算让用户在我们的网站上单击一个按钮，可能会明智地为双击条件编写负面测试。双击是意外行为，如果没有妥善考虑，可能会导致表单重新提交。负面测试对于充分测试一个功能是必不可少的。
- en: Integration Tests
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: Integration tests are a step back from functional tests. Integration tests are
    designed to test how modules and components work when they are fully integrated.
    Unit tests test functions one by one. Functional tests test full components or
    modules one by one. Integration tests test the combined components to make sure
    they interact with each other correctly. Integration tests are generally more
    complex than unit or functional tests. Integration tests can be written for something
    as simple as an individual web page once all the components have been built and
    integrated together, or for something as complex as a full frontend application
    with an API, multiple servers, and databases once all of the individual components
    are prepared and combined. Integration testing is often the most difficult and
    time consuming form of testing.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是从功能测试中退一步。集成测试旨在测试模块和组件在完全集成时的工作方式。单元测试逐个测试功能。功能测试逐个测试完整的组件或模块。集成测试测试组合的组件，以确保它们正确地相互交互。集成测试通常比单元测试或功能测试更复杂。一旦所有组件都建立并集成在一起，集成测试可以为简单的单个网页编写，也可以为包含API、多个服务器和数据库的完整前端应用程序编写。集成测试通常是最困难和耗时的测试形式。
- en: '**Integration testing** can be simplified and thought of like the process for
    manufacturing a ballpoint pen. The cap, body, ink, ballpoint, and tail cap with
    clip are all components of a ballpoint pen. They are all manufactured and tested
    separately to ensure that each component meets the specifications set for it.
    When the pieces are ready, they are put together for an integration test that
    will test whether the components function correctly together. For example, our
    integration test may test whether the ballpoint fits into the ink cartridge, the
    ink and ballpoint fit into the pen body, or the cap fits onto the body or not.
    If one of these tests fail, the integrated system (ballpoint pen) will not function
    to spec and one or more components must be updated.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**集成测试**可以简化并且可以像制造圆珠笔的过程一样思考。盖子、笔身、墨水、圆珠和带夹的尾盖都是圆珠笔的组成部分。它们都是分别制造和测试，以确保每个组件都符合其设定的规格。当这些部件准备好后，它们被放在一起进行集成测试，以测试这些组件是否能正确地一起运行。例如，我们的集成测试可能测试圆珠是否能放入墨水盒中，墨水和圆珠是否能放入笔身中，或者盖子是否能放在笔身上。如果其中一个测试失败，集成系统（圆珠笔）将无法按规格运行，一个或多个组件必须更新。'
- en: There are several methods to use to go about integration testing. They are big
    bang testing, bottom-up testing, top-down testing, and sandwich testing. Each
    has its advantages and disadvantages.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 进行集成测试有几种方法。它们包括大爆炸测试、自下而上测试、自上而下测试和夹层测试。每种方法都有其优点和缺点。
- en: Big bang testing consists of combining all of the components at once and then
    running your tests. It is called **big bang testing** because you throw everything
    together at once and get an explosion of (likely) failed integration tests. **Big
    bang testing** is very convenient for small systems that do not have very many
    component-to-component interactions. When applied to large systems, big bang testing
    can often break down. The first breakdown is that fault localization can be much
    more difficult in a very large and very complex system. If finding the source
    of a bug takes a long time, our test cycle will be very slow. The second breakdown
    is that some links between components can be missed and not tested because of
    the complexity of the system. If there are hundreds of component links that need
    to be tested, it can be difficult to keep track of them all if they are all linked
    at once. The third fault in big bang testing is that integration tests cannot
    start until all modules or components are designed and fully built. Since you
    must combine all the modules at once, a delay in one module pushes back integration
    testing for the entire system.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 大爆炸测试包括一次性组合所有组件，然后运行测试。它被称为**大爆炸测试**，因为你一次性将所有东西放在一起，然后会出现（很可能）失败的集成测试。**大爆炸测试**对于没有太多组件之间交互的小型系统非常方便。但是，当应用于大型系统时，大爆炸测试通常会出现问题。第一个问题是在非常大型和非常复杂的系统中，故障定位可能会更加困难。如果找到错误源需要很长时间，我们的测试周期将会非常缓慢。第二个问题是由于系统的复杂性，一些组件之间的链接可能会被忽略而未经测试。如果有数百个需要测试的组件链接，一旦它们全部同时链接起来，要跟踪它们可能会很困难。大爆炸测试的第三个问题是，集成测试无法在所有模块或组件被设计和完全构建之前开始。由于必须一次性组合所有模块，一个模块的延迟会推迟整个系统的集成测试。
- en: The second form of integration testing is **bottom up testing**. In **bottom
    up testing**, we must imagine the hierarchy of our system as a tree. We start
    by integrating the bottom layer of modules first. Then, once all the tests pass,
    we add the next layer of modules or components, until we have the full system
    being tested. To test in this manner, we must use drivers to simulate the upper
    layers and make calls to the modules or components in the bottom layers we are
    testing. Drivers are simply bits of code that simulate higher-level modules and
    the calls they make to lower-level modules for the purpose of tests. Bottom up
    testing has two main benefits. The first is that fault localization is very easy.
    Modules are integrated from the lowest level up. If a newly integrated module
    fails, then we can quickly pinpoint and blame the module that needs fixing. The
    second benefit is that there is no wasted time waiting for all modules to be developed.
    If the modules are also developed in a bottom up approach, we can simply add them
    to the integration tests once they are ready. We can integration test as pieces
    are ready, instead of waiting until the entire system is built. Bottom up testing
    has two main disadvantages. The first is that it can be difficult to create an
    early working prototype. Since modules are built and integrated from the bottom
    up, the user-facing features and modules are generally the last to be implemented
    and tested. It can be difficult to have an early prototype since the prototype
    components are generally ready last. The second disadvantage is that critical
    components and modules at the top level that control app flow are tested last
    and may not be tested as fully as the modules tested first. For large integrated
    systems, I generally believe that bottom up testing is better than big bang testing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的第二种形式是**自下而上的测试**。在**自下而上的测试**中，我们必须将系统的层次结构想象成一棵树。我们首先集成底层模块，然后一旦所有测试通过，我们就添加下一层模块或组件，直到整个系统都被测试。为了以这种方式进行测试，我们必须使用驱动程序来模拟上层并调用我们正在测试的底层模块或组件。驱动程序只是模拟高级模块和它们对低级模块的调用的代码片段，用于测试目的。自下而上的测试有两个主要好处。第一个是故障定位非常容易。模块从最低级别开始集成。如果新集成的模块失败，那么我们可以快速找出需要修复的模块。第二个好处是不需要等待所有模块都开发完成。如果模块也是按自下而上的方式开发的，那么一旦准备就绪，我们就可以将它们添加到集成测试中。我们可以在准备就绪时进行集成测试，而不是等到整个系统构建完成。自下而上的测试有两个主要缺点。第一个是很难创建早期的工作原型。由于模块是自下而上构建和集成的，用户界面功能和模块通常是最后实施和测试的。由于原型组件通常最后准备就绪，因此很难拥有早期原型。第二个缺点是控制应用程序流程的顶层关键组件和模块最后进行测试，可能无法像首先测试的模块那样进行充分测试。对于大型集成系统，我一般认为自下而上的测试比大爆炸测试更好。
- en: The third form of integration testing is **top down testing**. In **top down
    testing**, we must imagine our system hierarchy as a tree. We start by integrating
    the top layers of the system first. These are generally user-facing components
    and program flow modules. Top down testing requires the tester to build stubs
    to simulate the functionality of the modules at lower levels. The stubs imitate
    the undeveloped modules so that the modules being tested can make the calls they
    need to make. Top down testing has three major advantages. Like bottom up testing,
    the first major advantage is that fault localization is very easy, and we do not
    need to wait for the entire system to be built before we can start integration
    tests. Components can be added one at a time once they are built. The second advantage
    to top down testing is that an early prototype can be created very easily. The
    user-facing and most critical components are built and tested first, so it is
    very easy to integrate those into a prototype for early demos. The final major
    advantage is that critical modules are tested on priority. The critical modules
    are built first and therefore tested more frequently and usually more completely.
    Top down testing has two major drawbacks. The first is that many stubs are needed.
    Each module or component at a lower level must be built into a stub for testing.
    This can require a large amount of extra code to be written. The second disadvantage
    is that modules at lower levels are built and tested last. Generally, they are
    not as thoroughly tested.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的第三种形式是**自顶向下测试**。在**自顶向下测试**中，我们必须将系统层次结构想象成一棵树。我们首先集成系统的顶层。这些通常是面向用户的组件和程序流模块。自顶向下测试要求测试人员构建存根来模拟较低级别模块的功能。存根模仿未开发的模块，以便正在测试的模块可以进行所需的调用。自顶向下测试有三个主要优点。与自底向上测试一样，第一个主要优点是故障定位非常容易，我们不需要等待整个系统构建完成才能开始集成测试。组件可以一次添加一个，一旦它们被构建。自顶向下测试的第二个优点是可以非常容易地创建早期原型。首先构建和测试面向用户和最关键的组件，因此很容易将它们集成到早期演示的原型中。最后一个主要优点是对关键模块进行了优先测试。关键模块首先构建，因此更频繁地进行测试，通常更完整。自顶向下测试有两个主要缺点。第一个是需要许多存根。每个较低级别的模块或组件必须构建成一个用于测试的存根。这可能需要编写大量额外的代码。第二个缺点是较低级别的模块通常是最后构建和测试的。通常，它们没有经过如此彻底的测试。
- en: The final form of integration testing is **sandwich testing**. **Sandwich testing**
    is a combination of the top down and bottom up approaches. The most important
    and lowest-level modules are built and integrated at the same time. This approach
    has the benefit of providing a more general and big bang-like integration testing
    approach, while maintaining the benefits of both top down and bottom up testing.
    The largest drawback to sandwich testing is that both stubs and drivers need to
    be built. It can sometimes be difficult to follow what is a stub or a driver if
    the system is very convoluted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的最终形式是**夹层测试**。**夹层测试**是自顶向下和自底向上方法的结合。最重要和最低级别的模块同时构建和集成。这种方法的好处是提供了更一般和大爆炸式的集成测试方法，同时保持了自顶向下和自底向上测试的优点。夹层测试的最大缺点是需要构建存根和驱动程序。如果系统非常复杂，有时很难分清存根和驱动程序。
- en: Building Tests
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建测试
- en: Building tests can seem like a very daunting process. It can be very difficult
    to come up with an entire test suite from scratch. Test-driven development, however,
    provides us with a very good starting point for creating tests. As outlined previously,
    in the *Test-driven Development* section, building tests should always start with
    writing a requirements sheet.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 构建测试可能看起来是一个非常艰巨的过程。从头开始构建整个测试套件可能非常困难。然而，测试驱动开发为我们提供了一个非常好的测试起点。如前所述，在*测试驱动开发*部分，构建测试应始终从编写需求表开始。
- en: 'The requirements sheet is a data sheet for the function, feature, or entire
    system being built. The requirements sheet should break down the requirements
    for the feature into a very detailed and specific list. Writing requirements sheets
    for software applications is out of the scope of this book, but we will walk through
    a brief example. Imagine that we have been tasked to build a Facebook-style comment
    creation component. The component must have a text field with a character limit
    and a button that posts the comment. The two general requirements we can easily
    build from this scenario are a character limit for our text field and a button
    that makes an API call after a click event. These two requirements can then be
    refined into the following list of requirements:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 需求表是用于构建功能、特性或整个系统的数据表。需求表应将功能的要求细分为非常详细和具体的列表。为软件应用程序编写需求表超出了本书的范围，但我们将通过一个简要的示例进行介绍。假设我们被要求构建一个类似Facebook的评论创建组件。该组件必须具有一个带有字符限制的文本字段和一个在点击事件后发表评论的按钮。我们可以从这个场景中轻松构建出两个一般要求：文本字段的字符限制和按钮在点击事件后进行API调用。然后，这两个要求可以细化为以下要求列表：
- en: The text field must accept user-typed characters.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本字段必须接受用户输入的字符。
- en: No characters can be added to the text field when the text field contains 250
    or more characters.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文本字段包含250个或更多字符时，无法向文本字段添加字符。
- en: Any characters in the text field may be deleted by pressing the Backspace key.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本字段中，按下退格键可以删除任何字符。
- en: The button must respond to an `onclick` event.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮必须对`onclick`事件做出响应。
- en: On a click event, the component must make a call to the API with the test field data.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击事件中，组件必须使用文本字段数据调用API。
- en: This is not a full list of requirements for the feature or the components in
    the feature, but for this example, it is sufficient. With these requirements,
    we can begin to write our tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是功能或功能组件的完整需求列表，但对于这个示例来说，已经足够了。有了这些需求，我们就可以开始编写我们的测试了。
- en: We can begin to write tests, going item by item through our requirements list.
    Each requirement should be broken down into one or more tests. Each test should
    test exactly one thing and have a very specific success criterion.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以开始编写测试，逐项通过我们的需求列表。每个需求都应该分解为一个或多个测试。每个测试应该测试一件事，并具有非常具体的成功标准。
- en: The first requirement is that the text area must accept user-typed characters.
    If we press a key on the keyboard, the character pressed should be added to the
    text area, so our first test should be pressing a key on the keyboard and verifying
    that the same character was added to the text area.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个要求是文本区域必须接受用户输入的字符。如果我们在键盘上按键，按下的字符应该添加到文本区域，所以我们的第一个测试应该是在键盘上按键，并验证相同的字符是否添加到文本区域。
- en: 'The second requirement states that no characters can be added to the text field
    when the text field contains 250 or more characters. This can be broken into two
    tests: when the text area has 250 characters, no key presses can add to the text
    area, and when the text area has more than 250 characters, no key presses can
    add to the text area.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求规定，当文本区域包含250个或更多字符时，不能添加任何字符到文本字段。这可以分为两个测试：当文本区域有250个字符时，不能添加任何按键到文本区域，当文本区域有超过250个字符时，不能添加任何按键到文本区域。
- en: 'The third requirement states that any characters in the text field may be deleted
    by pressing the backspace key. This requirement can be converted into a test quite
    easily. We must test that if the backspace key is pressed, a character is removed
    from the text area. To properly test edge cases, we should run this test four
    times: once with an empty text area, once with a text area with more than 0 but
    fewer than 250 characters, once with 250 characters, and once with more than 250
    characters. Testing all of the operating conditions for our text area (even the
    test case with more than 250 character that we never expect to reach) will ensure
    that no failure can occur.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个要求规定，可以通过按下退格键删除文本字段中的任何字符。这个要求可以很容易地转化为一个测试。我们必须测试，如果按下退格键，一个字符将从文本区域中删除。为了正确测试边缘情况，我们应该运行这个测试四次：一次是空的文本区域，一次是有0个但少于250个字符的文本区域，一次是250个字符，一次是超过250个字符。测试文本区域的所有操作条件（甚至是我们从未预期达到的超过250个字符的测试用例）将确保不会发生任何故障。
- en: The fourth requirement states that the button must respond to an on-click event.
    This test is very easy to write. We simply need to add a test where the user clicks
    on the button. The final requirement states that a click event on the button must
    call the API. We can easily turn this into a test by simulating the on-click event
    and ensuring that the website makes the API call with the correct data.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个要求规定按钮必须响应点击事件。这个测试非常容易编写。我们只需要添加一个测试，用户点击按钮。最后一个要求规定，按钮上的点击事件必须调用API。我们可以很容易地将这转化为一个测试，通过模拟点击事件，并确保网站使用正确的数据调用API。
- en: We have outlined the list of five requirements in a series of tests. These tests
    can now be compiled together and written in code form in a test file. This test
    file will be used to verify that the requirements outlined in our requirements
    sheet are properly met.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在一系列测试中概述了五个要求的列表。现在可以将这些测试编译在一起，并以代码形式编写在一个测试文件中。这个测试文件将用于验证我们需求表中概述的需求是否得到了正确满足。
- en: 'Exercise 26: Writing Tests'
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习26：编写测试
- en: Your team has been tasked to build a registration page for your newsletter.
    The registration page must have three text fields for name, email, and age, as
    well as a **Submit** button. Your registration page must accept a name between
    1 and 50 characters (inclusive), an email between 1 and 50 characters (inclusive,
    and email format not validated), and the user's age (must be older than 13 years
    old). When the **submit** button is pressed, the user information must be validated
    (against the specification provided in the preceding section). If any part of
    the specification is not met, throw an error in the browser console. Write a very
    basic specification sheet detailing the requirements for each input and the submit
    button, then build tests from the specification sheet. Implement the page (use
    `exercises/exercise26/exercise.html` as a starting point) and perform the tests
    manually from the UI. The starter file contains hints for the tests you must write.
    Write the specification sheet and tests before opening the starter file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队被要求为你的通讯订阅建立一个注册页面。注册页面必须有三个文本字段，用于姓名、电子邮件和年龄，以及一个**提交**按钮。您的注册页面必须接受1到50个字符（包括）之间的姓名，1到50个字符（包括，不验证电子邮件格式）之间的电子邮件，以及用户的年龄（必须大于13岁）。当按下**提交**按钮时，用户信息必须经过验证（根据前一节提供的规格）。如果规格的任何部分未满足，就在浏览器控制台中抛出错误。编写一个非常基本的规格表，详细说明每个输入和提交按钮的要求，然后从规格表中构建测试。实现页面（使用`exercises/exercise26/exercise.html`作为起点），并从UI手动执行测试。起始文件包含了您必须编写的测试的提示。在打开起始文件之前编写规格表和测试。
- en: 'To build a basic specification sheet and run tests from the specification sheet,
    perform the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个基本的规格表，并从规格表中运行测试，执行以下步骤：
- en: Write the specification sheet by taking each sentence that contains specification
    information in the scenario description and break it into one or more requirements.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将包含场景描述中规格信息的每个句子拆分为一个或多个需求来编写规格表。
- en: Decompose the specification sheet into manual UI tests by taking each item on
    the spec sheet and write one or more tests for it.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将规格表分解为手动UI测试，方法是将规格表上的每一项都写成一个或多个测试。
- en: Open the starter HTML file at `exercises/exercise26/exercise.html`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`exercises/exercise26/exercise.html`中的起始HTML文件。
- en: 'Add the three input fields with the IDs `name`, `email`, and `age`. This is
    shown in the following figure:![Figure 4.4: Data Sheet (After step 4)'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加三个带有ID `name`、`email` 和 `age` 的输入字段。如下图所示：![图4.4：数据表（第4步后）
- en: '](image/Figure_4.4.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4.jpg)'
- en: 'Figure 4.4: Data sheet (after step 4)'
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：数据表（第4步后）
- en: Add the **Submit** button to the HTML document and have it call the `validate`
    function on click.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**提交**按钮添加到HTML文档中，并在单击时调用`validate`函数。
- en: In the validate function, get the `name` text field by email id and save its
    value in the `name` variable.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在验证函数中，通过id获取`name`文本字段并将其值保存在`name`变量中。
- en: Get the `email` text field by id and save its value in the `email` variable.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过id获取`email`文本字段并将其值保存在`email`变量中。
- en: Get the `age` text field by id, get its value, parse the value for a number,
    and then save the parsed value in the `age` variable.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 通过id获取`age`文本字段，获取其值，解析数字的值，然后将解析后的值保存在`age`变量中。
- en: Check the conditions on the specification sheet that relate to the `name` field.
    Also check if the name doesn't exist, or is false, and throw an error if it does
    not. Check if `name length <= 0 or > 50`, then throw an error if it is.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与`name`字段相关的规范表上的条件。还要检查名称是否不存在，或者为false，如果是，则抛出错误。检查`name length <= 0 or
    > 50`，如果是，则抛出错误。
- en: Check the conditions on the specification sheet that relate to the `email` field.
    Also, check if the email doesn't exist, or is falsy; throw an error if it is.
    Check if `email length is <=0 or > 50`, then throw an error if it is.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与`email`字段相关的规范表上的条件。还要检查电子邮件是否不存在，或者为假；如果是，则抛出错误。检查`email length is <=0 or
    > 50`，如果是，则抛出错误。
- en: Check the conditions on the specification sheet that relate to the `age` field.
    Also, check if age doesn't exist, or is falsy; then throw an error. Check if `age
    < 13` and throw an error if it is.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 检查与`age`字段相关的规范表上的条件。还要检查年龄是否不存在，或者为假；如果是，则抛出错误。检查`age < 13`，如果是，则抛出错误。
- en: Log the user details (`name`, `email`, and `age`) to the console.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 将用户详细信息（`name`，`email`和`age`）记录到控制台。
- en: For each test you wrote in the specification sheet, test it manually. Fill in
    the values in the text fields and then click **Submit**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于规范表中编写的每个测试，手动测试它。填写文本字段中的值，然后单击**提交**。
- en: Compare the errors logged to the console against the expected result of the test.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将记录在控制台的错误与测试的预期结果进行比较。
- en: If a test fails, then update the validate function to fix the bug and rerun
    the test.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，则更新验证函数以修复错误并重新运行测试。
- en: '**Code**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码**'
- en: solution.html
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: solution.html
- en: '[PRE3]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Snippet 4.4: Testing front-end input code'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段4.4：测试前端输入代码
- en: https://bit.ly/2H5E7OJ
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2H5E7OJ
- en: '**Output**'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 4.5: Data Sheet (Final Output)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5：数据表（最终输出）'
- en: '](image/Figure_4.5.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5.jpg)'
- en: 'Figure 4.5: Data sheet (final Output)'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：数据表（最终输出）
- en: You have successfully built a basic specification sheet and run tests from the
    specification sheet.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功构建了基本的规范表并从规范表中运行了测试。
- en: Test Tools and Environments
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试工具和环境
- en: Testing tools, frameworks, and environments are designed to make testing code
    simpler and quicker. There are many testing frameworks available for JavaScript
    and the most popular will be mentioned briefly. We then dive deeper into one of
    the frameworks and demonstrate how to use the framework to write good tests.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 测试工具、框架和环境旨在使测试代码更简单、更快速。JavaScript有许多可用的测试框架，最受欢迎的将会简要提到。然后我们将深入研究其中一个框架，并演示如何使用该框架编写良好的测试。
- en: Testing Frameworks
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试框架
- en: 'You will need to select a testing framework based on the types of tests you
    wish to conduct. JavaScript is generally tested in one of three ways: **general
    test**, **code coverage tests**, and **user interface tests**. When selecting
    a framework, you must decide what you are testing and how you wish to go about
    it.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据希望进行的测试类型选择测试框架。通常使用三种方式对JavaScript进行测试：**一般测试**，**代码覆盖测试**和**用户界面测试**。在选择框架时，必须决定要测试什么以及希望如何进行测试。
- en: General tests will include your unit tests, functional tests, and integration
    tests. It is a sort of catch-all for your tests. The most popular frameworks for
    tests are **Mocha**, **Jasmine**, and **Jest**. Jest is used by Facebook and is
    one of the simpler frameworks to set up. Mocha is the most popular testing framework
    available for JavaScript and it will be covered in much more detail later in this
    section.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一般测试将包括单元测试、功能测试和集成测试。这是您测试的一种综合方式。最受欢迎的测试框架是**Mocha**，**Jasmine**和**Jest**。Jest由Facebook使用，是设置最简单的框架之一。Mocha是JavaScript中最受欢迎的测试框架，并且稍后将更详细地介绍它。
- en: Code coverage tests are used to help check test completeness. Code coverage
    can be defined as the percentage of your code base covered, or tested, by your
    automated tests. Code coverage can be used as a general guideline for the completeness
    of your code tests. In theory, the more code coverage your application has, the
    more complete and better the tests. However, in practice, having 100% code coverage
    does not mean that the tests for the code are well thought out and valid. It just
    means that every code path is referenced somehow in a test. It is more important
    to write well thought out tests than throw together useless tests that hit every
    line of code. The most popular and simplest code coverage library is **Istanbul**.
    It is compatible with many testing frameworks and can be easily worked into most
    testing suites. If you need a third-party library for testing code coverage, I
    recommend using Istanbul.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖测试用于帮助检查测试的完整性。代码覆盖可以定义为您的自动化测试覆盖的代码基数的百分比。代码覆盖可以用作代码测试完整性的一般指导。理论上，应用程序的代码覆盖率越高，测试就越完整和更好。但是，在实践中，拥有100%的代码覆盖并不意味着代码的测试经过深思熟虑且有效。这只意味着每个代码路径在某种程度上都在测试中引用。编写深思熟虑的测试比随意组合的测试更重要，后者会触及每行代码。最受欢迎且最简单的代码覆盖库是**Istanbul**。它与许多测试框架兼容，并且可以轻松地融入大多数测试套件中。如果需要第三方库进行代码覆盖测试，我建议使用Istanbul。
- en: The final form of tests is **User Interface** (**UI**) tests. Like general tests,
    we can break UI tests into integration, functional, and unit tests. However, UI
    tests are generally not included under general tests because they require special
    and more complex frameworks. To perform UI tests, we must load the user view and
    simulate user interactions. Some of the more common UI test frameworks are Testcafe,
    WebdriverIO, and Casper.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的最终形式是**用户界面**（**UI**）测试。与一般测试一样，我们可以将UI测试分为集成测试、功能测试和单元测试。然而，UI测试通常不包括在一般测试中，因为它们需要特殊和更复杂的框架。要执行UI测试，我们必须加载用户视图并模拟用户交互。一些更常见的UI测试框架包括Testcafe、WebdriverIO和Casper。
- en: Mocha
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha
- en: '**Mocha** is a framework for testing JavaScript in Node.js. It is a simple
    library designed to simplify and automate the testing process. Mocha is designed
    to be simple, flexible, and extendable. My company uses Mocha for unit, functional,
    and integration tests. We will discuss some of the benefits to using Mocha over
    other frameworks, cover how to set up and run your first tests with Mocha, and
    explain some of the advanced functionality Mocha offers.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mocha**是一个用于在Node.js中测试JavaScript的框架。它是一个简单的库，旨在简化和自动化测试过程。Mocha被设计为简单、灵活和可扩展的。我的公司使用Mocha进行单元测试、功能测试和集成测试。我们将讨论使用Mocha而不是其他框架的一些好处，介绍如何设置和运行Mocha的第一个测试，并解释Mocha提供的一些高级功能。'
- en: Note
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The full documentation for Mocha can be found at [https://mochajs.org/](https://mochajs.org/).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha的完整文档可以在[https://mochajs.org/](https://mochajs.org/)找到。
- en: 'There are many benefits to Mocha. As stated earlier, Mocha is the most popular
    testing framework for Node.js. This immediately gives Mocha its largest advantage:
    Mocha has the largest development community. This is important for support and
    extensions. If you run into issues with your Mocha tests, this community can provide
    extensive support. The Stack Overflow community is prompt in answering questions
    about Mocha. The Mocha community also has built many plugins or extensions for
    unique test scenarios. If your project has unique testing needs, it is likely
    that a plugin has been built to suit your needs.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha有许多好处。正如前面所述，Mocha是Node.js最流行的测试框架。这立即给Mocha带来了最大的优势：Mocha拥有最大的开发社区。这对于支持和扩展非常重要。如果您在Mocha测试中遇到问题，这个社区可以提供广泛的支持。Stack
    Overflow社区很快就会回答关于Mocha的问题。Mocha社区还为独特的测试场景构建了许多插件或扩展。如果您的项目有独特的测试需求，很可能已经构建了适合您需求的插件。
- en: Aside from the large community support, Mocha also provides advantages such
    as simple setup, assertion, and simple asynchronous testing. Setting up Mocha
    can be done through the command line with npm. With any testing framework, we
    want to make sure that setting it up does not take too much of our time. Mocha
    also allows for the use of assertion modules. While not necessary, if your team
    wants to approach testing from an assertion standard, Mocha allows you to install
    and import many JavaScript assertion libraries. Finally, Mocha is designed for
    asynchronous tests. With any JavaScript testing module, we must rely on asynchronous
    support to write complete tests. Mocha is designed to work with callbacks, promises,
    and the ES6 async/await syntax. It can easily be integrated into most backend
    setups.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 除了庞大的社区支持外，Mocha还提供了简单的设置、断言和简单的异步测试等优势。通过npm可以通过命令行设置Mocha。对于任何测试框架，我们希望确保设置它不会花费太多时间。Mocha还允许使用断言模块。虽然不是必需的，但如果您的团队希望从断言标准来进行测试，Mocha允许您安装和导入许多JavaScript断言库。最后，Mocha专为异步测试而设计。对于任何JavaScript测试模块，我们必须依赖异步支持来编写完整的测试。Mocha被设计为与回调、promises和ES6
    async/await语法一起工作。它可以轻松地集成到大多数后端设置中。
- en: Setting Up Mocha
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置Mocha
- en: Installing Mocha is done with the npm command `npm install -g mocha`. This command
    will install Mocha globally on your system. Any Node.js project will now be able
    to use Mocha to run tests. Once installed globally, we will be able to run tests
    from the command line with the `mocha` keyword.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Mocha是通过npm命令`npm install -g mocha`完成的。这个命令会在系统上全局安装Mocha。任何Node.js项目现在都可以使用Mocha来运行测试。一旦全局安装，我们就可以使用命令行运行测试，使用`mocha`关键字。
- en: Once mocha has been installed on our system, we must add it to a project. If
    you do not have a Node.js project, create a path to the desired project directory
    and initialize the project with `npm init`. This is the same command used in *Chapter
    1* to set up a project when we were discussing transpiling and Babel. The `npm
    init` command will create a file called `package.json`. After we have created
    our JavaScript project, we need to create our project files. Create a file called
    `index.js` and a file called `test.js`. `index.js` will contain our project code
    and `test.js` will contain our test code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Mocha在我们的系统上安装好了，我们必须将其添加到一个项目中。如果您没有Node.js项目，请创建一个到所需项目目录的路径，并使用`npm init`初始化项目。这是在*第1章*中讨论转译和Babel时设置项目时使用的相同命令。`npm
    init`命令将创建一个名为`package.json`的文件。创建JavaScript项目后，我们需要创建项目文件。创建一个名为`index.js`的文件和一个名为`test.js`的文件。`index.js`将包含我们的项目代码，`test.js`将包含我们的测试代码。
- en: 'In the `package.json` file, there will be a field called `scripts`. To run
    our tests from npm, we must add a field to the `scripts` object. Replace the `scripts`
    object with the code shown in the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`package.json`文件中，将会有一个名为`scripts`的字段。要从npm运行我们的测试，我们必须向`scripts`对象添加一个字段。用以下片段中显示的代码替换`scripts`对象：
- en: '[PRE4]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Snippet 4.5: Test script in package.json'
  id: totrans-208
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 片段4.5：package.json中的测试脚本
- en: The code in the preceding snippet adds a script called `test` to the `package`
    object. We can run this script with the `npm run test` command. When we run this
    command, it calls the `mocha` keyword with the`./test.js` parameter. The mocha
    testing framework is run with the tests contained in the `test.js` file. We are
    now ready to start adding tests to `test.js`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 前面片段中的代码向`package`对象添加了一个名为`test`的脚本。我们可以使用`npm run test`命令运行此脚本。运行此命令时，它会调用`mocha`关键字和`./test.js`参数。Mocha测试框架将运行`test.js`文件中包含的测试。现在我们已经准备好开始向`test.js`添加测试了。
- en: Mocha organizes tests with the `describe` and `it` keywords. Both are functions
    that take in a string as the first parameter and a function as the second parameter.
    The `describe` function is used to group tests together. The `it` function is
    used to define a test. The function argument for `describe()` contains test declarations
    (with `it()`) or more description functions. The function argument for `it()`
    contains the test function to be run.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha使用`describe`和`it`关键字组织测试。两者都是以字符串作为第一个参数和函数作为第二个参数的函数。`describe`函数用于将测试分组在一起。`it`函数用于定义一个测试。`describe()`的函数参数包含测试声明（使用`it()`）或更多的描述函数。`it()`的函数参数包含要运行的测试函数。
- en: 'You can think of the describe function as a way to describe and group together
    a group of tests. For example, if we have a group of tests that all test a function
    called `calculateModifier`, we might group the tests together with a description
    using the describe function: `describe( ''calculateModifier tests'', () => { ...
    } )`. This groups the tests contained in the function under the description `calculateModifier`
    `test`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将describe函数视为描述和组合一组测试的方式。例如，如果我们有一组测试都测试一个名为`calculateModifier`的函数，我们可以使用describe函数将这些测试组合在一起，并使用描述：`describe(
    'calculateModifier tests', () => { ... } )`。这将把包含在函数中的测试分组在`calculateModifier`测试下。
- en: 'You can think of the `it` function as a way to define a test in the form "it
    should …". The string input to the `it` function describes the test, usually what
    the test is trying to accomplish. The function argument contains the actual test
    code. For example, if we want to define a test that checks whether two values
    are equal, we can use the `it function` to do this: `it( ''should have two inputs
    that are equal'', () => { ... } )`. The description tells us what should happen
    and the code to check the values will go in the function argument.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`it`函数视为定义测试的一种方式，形式为“它应该……”。传递给`it`函数的字符串描述了测试，通常是测试试图实现的内容。函数参数包含实际的测试代码。例如，如果我们想定义一个检查两个值是否相等的测试，我们可以使用`it`函数来做到这一点：`it(
    'should have two inputs that are equal', () => { ... } )`。描述告诉我们应该发生什么，检查值的代码将放在函数参数中。
- en: Mocha Basics
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha基础知识
- en: 'Understanding the basics of tests, we can look at the Mocha starter documentation
    and see the code shown in the following snippet:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 了解测试的基础知识后，我们可以查看Mocha入门文档，并查看以下代码片段中显示的代码：
- en: '[PRE5]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Snippet 4.6: Mocha basics'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段4.6：Mocha基础知识
- en: What do you think this code snippet is doing? First, we describe a set of tests
    with the description `Array`. Inside the function argument of the first `describe`
    block, we have another `describe` block. This new block describes a set of tests
    with the description `#indexOf`; because these describe blocks are nested, we
    can assume that we are testing the `indexOf` functionality of an array. Inside
    the second `describe` block, we define a test with the `it` function. We define
    a test that says `it should return -1 when the value is not present`. As expected
    from the description of the test, we would expect the `indexOf` function to return
    the value `-1` if the value is not present in an array. In this example, we use
    the assert library to assert that the expected value of `-1` is equal to the actual
    value. The assert library is not strictly necessary, but makes this example simpler
    to understand.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您认为这段代码在做什么？首先，我们用描述`Array`描述了一组测试。在第一个`describe`块的函数参数内部，我们有另一个`describe`块。这个新块描述了一个带有描述`#indexOf`的测试集；因为这些描述块是嵌套的，我们可以假设我们正在测试数组的`indexOf`功能。在第二个`describe`块内部，我们使用`it`函数定义了一个测试。我们定义了一个测试，说`当值不存在时应返回-1`。根据测试的描述，我们期望`indexOf`函数在数组中的值不存在时返回值`-1`。在这个例子中，我们使用assert库来断言预期值`-1`等于实际值。assert库并不是严格必要的，但使这个例子更容易理解。
- en: 'Exercise 27: Setting Up a Mocha Testing Environment'
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习27：设置Mocha测试环境
- en: 'The aim is to set up a Mocha testing environment and prepare a test file. To
    complete this assignment, follow these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是设置Mocha测试环境并准备一个测试文件。要完成此任务，请按照以下步骤操作：
- en: Run `npm` `init` to create a `package.json` file in the exercise directory.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm init`在练习目录中创建一个`package.json`文件。
- en: Run `npm` `install mocha -g` to install the testing package.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`npm install mocha -g`来安装测试包。
- en: Create a file called `test.js` where our tests will go.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`test.js`的文件，我们的测试将放在其中。
- en: Add a script to the `package.json` file that runs the mocha test suite on the
    `test.js` file.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`文件中添加一个脚本，以在`test.js`文件上运行mocha测试套件。
- en: Inside the `test.js` file, add a `describe()` block that describes tests as
    `My first test!`
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`test.js`文件中，添加一个`describe()`块，将测试描述为`My first test!`
- en: Inside the `describe` block's callback, add a test with `it()` that passes and
    has the description `Passing test!`
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`describe`块的回调内部，添加一个带有`it()`的测试，通过并具有描述`Passing test!`
- en: Run the tests by calling the `npm` script added to `package.json`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`package.json`中添加的`npm`脚本来运行测试。
- en: '**Code:**'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码：**'
- en: '**test.js**'
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**test.js**'
- en: '[PRE6]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Snippet 4.7: Mocha basics'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 代码片段4.7：Mocha基础知识
- en: https://bit.ly/2RhzNAy
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: https://bit.ly/2RhzNAy
- en: '**Output:**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出：**'
- en: '![Figure 4.6: Mocha Testing'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.6：Mocha测试'
- en: '](image/Figure_4.6.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.6.jpg)'
- en: 'Figure 4.6: Mocha Testing'
  id: totrans-235
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：Mocha测试
- en: You have successfully set up a Mocha testing environment and prepared a test
    file.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您已成功设置了Mocha测试环境并准备了一个测试文件。
- en: Mocha Async
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha异步
- en: 'Mocha supports asynchronous tests as well as synchronous tests. In the example
    shown in snippet 4.6, we perform synchronous tests. To support asynchronous tests,
    all we need to do is pass a done callback parameter into the function parameter
    of the `it()` function: `it( ''description'', ( done ) => {} )`. This tells mocha
    to wait until the `done` callback is called before proceeding to the next test.
    The `done` parameter is a function. If a test succeeds, done should be called
    with a `falsy` value (no error). If done is called with a `truthy` value, mocha
    will interpret that value as an error. It is best practice to pass an error object
    into the done callback but any value that evaluates to true will tell Mocha that
    the test failed.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha支持异步测试和同步测试。在Snippet 4.6中显示的示例中，我们执行同步测试。要支持异步测试，我们只需要将一个done回调参数传递到`it()`函数的函数参数中：`it(
    'description', ( done ) => {} )`。这告诉mocha在继续进行下一个测试之前等待`done`回调被调用。`done`参数是一个函数。如果测试成功，应该使用一个`falsy`值（没有错误）调用done。如果使用一个`truthy`值调用done，mocha将解释该值为错误。最佳实践是将错误对象传递给done回调，但任何评估为true的值都会告诉Mocha测试失败。
- en: Asynchronous tests are performed synchronously by Mocha in the order in which
    they are defined in the test file. The tests may query resources asynchronously,
    but the next test will not begin running until the previous test has completely
    finished (done has been called). Running tests synchronously is important. Even
    though running tests synchronously may result in longer testing times, it allows
    us to test asynchronous systems that may rely on some shared state. For example,
    we can test systems such as databases and database interfaces with Mocha. If we
    need to perform an integration test that tests the process of adding to and removing
    from a database, we can create a test to add an item to the database and a test
    to remove the added item from the database. If the tests run these two asynchronously,
    we might run into timing issues. Due to network lag, or some other unexpected
    error, the remove operation may be processed before the add operation and the
    tests would fail. Mocha prevents the need to debug problems like this by forcing
    tests to run synchronously.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Mocha以同步方式按照测试文件中定义的顺序同步执行异步测试。测试可能会异步查询资源，但在上一个测试完全完成（done已被调用）之前，下一个测试不会开始运行。同步运行测试非常重要。即使同步运行测试可能导致更长的测试时间，它也允许我们测试依赖于一些共享状态的异步系统。例如，我们可以使用Mocha测试数据库和数据库接口等系统。如果我们需要执行一个集成测试，测试向数据库添加和删除的过程，我们可以创建一个测试来向数据库添加项目，以及一个测试来从数据库中删除添加的项目。如果这两个测试异步运行，我们可能会遇到时间问题。由于网络延迟或其他意外错误，删除操作可能在添加操作之前被处理，测试将失败。Mocha通过强制测试同步运行来避免调试此类问题的需要。
- en: Mocha Hooks
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mocha Hooks
- en: 'For more complex tests, Mocha allows us to attach hooks to our tests. **Hooks**
    can be used to set up preconditions and post-conditions to our tests. In simpler
    terms, hooks allow us to set up before and clean up after tests. Mocha provides
    the following hooks: `before`, `after`, `beforeEach`, and `afterEach`. Hooks take
    in two arguments, a `description` and a `callback` function argument. This function
    argument can accept one parameter—a done function. An example of the syntax for
    the hooks is shown in the following snippet:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的测试，Mocha允许我们将钩子附加到我们的测试上。**Hooks**可以用于设置测试的前提条件和后置条件。简单来说，钩子允许我们在测试之前和之后进行设置。Mocha提供以下钩子：`before`，`after`，`beforeEach`和`afterEach`。钩子接受两个参数，一个`description`和一个`callback`函数参数。这个函数参数可以接受一个参数
    - 一个done函数。钩子的语法示例如下所示：
- en: describe( 'Array', () => {
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: describe( 'Array', () => {
- en: '[PRE7]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Snippet 4.8: Mocha hooks'
  id: totrans-244
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 'Snippet 4.8: Mocha hooks'
- en: Hooks are only run before or after the tests in the describe block they are
    contained within. The `before` hooks are run once before any of the defined tests
    are started. They can be used to set up a general shared state between tests.
    The `beforeEach` hooks are run before each test starts, inside the `describe`
    block. They can be used to set or reset a shared state or set of variables required
    for each test. The `after` hooks are run once after all tests have finished running.
    They can be used to clean up or reset a state shared between tests. The `afterEach`
    hook is run after each test completes but before the next starts. It can be used
    to clean up or reset test-specific shared states.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子只在它们所包含的描述块中的测试之前或之后运行。`before`钩子在任何定义的测试开始之前运行一次。它们可以用于在测试之间设置一个共享状态。`beforeEach`钩子在每个测试开始之前在`describe`块内运行。它们可以用于设置或重置每个测试所需的共享状态或变量集。`after`钩子在所有测试完成后运行一次。它们可以用于清理或重置测试之间共享的状态。`afterEach`钩子在每个测试完成后但下一个测试开始之前运行。它可以用于清理或重置特定于测试的共享状态。
- en: 'Activity 4: Utilizing Test Environments'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Activity 4: Utilizing Test Environments'
- en: 'You have been tasked to upgrade your Fibonacci sequence test code to use the
    Mocha test framework. Take the Fibonacci sequence code and test the code you created
    for *Activity 1: Implementing Generators* and upgrade it to use the Mocha test
    framework to test the code. You should write tests for the `n=0` condition, implement
    it, then write for tests and implement the `n=1` condition. Repeat this for `n=5`,
    `n=6`, as well as `n=8`. If the `it()` test passes, call the done callback with
    no argument, otherwise call the test done callback with an error or other `truthy`
    value.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '您的任务是将斐波那契序列测试代码升级为使用Mocha测试框架。取出斐波那契序列代码并测试您为*Activity 1: Implementing Generators*创建的代码，并升级为使用Mocha测试框架来测试代码。您应该为`n=0`条件编写测试，实现它，然后为`n=1`条件编写测试并实现。对于`n=5`，`n=6`以及`n=8`也重复这个过程。如果`it()`测试通过，调用没有参数的done回调，否则使用错误或其他`truthy`值调用测试完成回调。'
- en: 'To write and run tests using the Mocha test framework, perform the following
    steps:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Mocha测试框架编写和运行测试，请执行以下步骤：
- en: Set up the NPM project and install the mocha module.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置NPM项目并安装mocha模块。
- en: Add a test script to the `package.json` that runs mocha and the tests in `test.js`.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`package.json`中添加一个测试脚本，运行mocha和`test.js`中的测试。
- en: Create an `index.js` file with a Fibonacci sequence calculator function. Export
    this function.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`index.js`文件，其中包含一个斐波那契数列计算器函数。导出这个函数。
- en: Create `test.js`, which tests the Fibonacci sequence function using the mocha
    framework. Test `fibonacci` for n=0, n=1, n=2, n=5, n=7, and n=9.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`test.js`，使用mocha框架测试斐波那契数列函数。测试`fibonacci`，n=0，n=1，n=2，n=5，n=7和n=9。
- en: '**Output**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出**'
- en: '![Figure 4.7: Testing the Fibonacci sequence with Mocha'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.7：使用Mocha测试斐波那契数列'
- en: '](image/Figure_4.7.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.7.jpg)'
- en: 'Figure 4.7: Testing the Fibonacci sequence with Mocha'
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：使用Mocha测试斐波那契数列
- en: You have successfully utilized the Mocha test framework to write and run tests.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你已成功利用Mocha测试框架编写和运行测试。
- en: Note
  id: totrans-258
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '注意:'
- en: The solution for this activity can be found on page 288.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第288页找到。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'Code testing is one of the most important skills a developer can have. Testing
    code is like going to the gym. You know it''s good for you, but it can often be
    difficult to begin. In this chapter, we discussed the reasons to test code, several
    types of code tests, and several JavaScript code testing frameworks. Code tests
    need to be done to ensure program correctness. Test-Driven Development is one
    of the simplest ways to begin integrating tests into a project. TDD revolves around
    writing tests that outline the requirements of any feature or function added,
    before any implementation code is written. There are many forms of code tests.
    In this chapter, we covered unit tests, functional tests, and integration tests.
    These types of code tests are the most common and are generally built from one
    of two methodologies: black box and white box. Functional, unit, and integration
    tests can all be built in many of the frameworks covered in the previous topic.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 代码测试是开发人员可以拥有的最重要的技能之一。测试代码就像去健身房一样。你知道这对你有好处，但往往很难开始。在本章中，我们讨论了测试代码的原因，几种代码测试类型以及几种JavaScript代码测试框架。需要进行代码测试以确保程序的正确性。测试驱动开发是将测试整合到项目中的最简单方法之一。TDD围绕着编写测试来概述任何添加的功能或函数的要求，然后再编写任何实现代码。有许多形式的代码测试。在本章中，我们介绍了单元测试、功能测试和集成测试。这些类型的代码测试是最常见的，通常是从黑盒和白盒两种方法中构建的。功能、单元和集成测试都可以在前面主题中涵盖的许多框架中构建。
- en: In the next chapter, we will cover the functional programming coding principle
    and define object-oriented programming and functional programming.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍函数式编程编码原则，并定义面向对象编程和函数式编程。
