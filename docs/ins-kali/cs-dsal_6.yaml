- en: Exploring Graphs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索图
- en: In the previous chapter, you got to know trees. However, did you know that such
    data structures also belong to graphs? But what is a graph and how you can use
    it in your applications? You can find answers to these and many other questions
    in this chapter!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您了解了树。但是，您知道这样的数据结构也属于图吗？但图是什么，以及您如何在应用程序中使用它？您可以在本章中找到这些问题的答案以及许多其他问题的答案！
- en: At the beginning, the basic information about graphs will be presented, including
    an explanation of nodes and edges. Moreover, you will see the difference between
    directed and undirected edges, as well as between weighted and unweighted ones.
    As graphs are data structures that are commonly used in practice, you will also
    see some applications, such as for storing the data of friends in social media
    or finding a road in a city. Then, the topic of graph representation will be covered,
    namely using an adjacency list and matrix.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，将介绍有关图的基本信息，包括节点和边的解释。此外，您将看到有向和无向边之间的区别，以及加权和非加权边之间的区别。由于图是常用的数据结构，您还将看到一些应用，例如在社交媒体中存储朋友的数据或在城市中寻找道路。然后，将介绍图的表示主题，即使用邻接表和矩阵。
- en: After this short introduction, you will learn how to implement a graph in the
    C# language. This task involves the declaration of a few classes, such as regarding
    nodes and edges. The whole necessary code will be described in detail in the chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，您将学习如何在C#语言中实现图。这项任务涉及到声明一些类，例如节点和边。整个必要的代码将在本章中详细描述。
- en: Moreover, you will also have a chance to read the description of two modes of
    graph traversal, namely depth-first and breadth-first search. For both of them,
    the C# code and a detailed description will be shown.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还将有机会阅读两种图遍历模式的描述，即深度优先和广度优先搜索。对于两者，将显示C#代码和详细描述。
- en: The next part will present the subject of minimum spanning trees, as well as
    two algorithms for their creation, namely Kruskal's and Prim's. Such algorithms
    will be presented as textual description, C#-based code snippets, as well as easy-to-understand
    illustrations. Moreover, the example real-world application will be provided.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将介绍最小生成树的主题，以及用于创建它们的两种算法，即Kruskal和Prim。这些算法将以文本描述、基于C#的代码片段以及易于理解的插图的形式呈现。此外，还将提供一个实际的示例应用程序。
- en: Another interesting graph-related problem is the coloring of nodes, which will
    be taken into account in the following part of the chapter. At the end, the topic
    of finding the shortest path in a graph will be analyzed using Dijkstra's algorithm.
    Of course, the example real-world application will be shown as well, together
    with the C#-based implementation.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的与图相关的问题是节点的着色，这将在本章的后面部分中考虑。最后，将使用Dijkstra算法分析在图中找到最短路径的主题。当然，还将展示一个实际的示例应用程序，以及基于C#的实现。
- en: As you can see, the topic of graphs involves many interesting problems and only
    some of them will be mentioned in the book. However, the chosen subjects are suitable
    for the presentation of various graph-related aspects in the context of C#-based
    implementation. Are you ready to dive into the topic of graphs? If so, start reading
    this chapter!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，图的主题涉及许多有趣的问题，本书只提到了其中一些。但是，所选择的主题适合在基于C#的实现的背景下呈现各种与图相关的方面。您准备好深入研究图的主题了吗？如果是这样，请开始阅读本章！
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: Concept of graphs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的概念
- en: Applications
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用
- en: Representation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示
- en: Implementation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施
- en: Traversal
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历
- en: Minimum spanning tree
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小生成树
- en: Coloring
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 着色
- en: Shortest path
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最短路径
- en: Concept of graphs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图的概念
- en: 'Let''s start with the question *what is a graph?* Broadly speaking, a graph
    is a data structure that consists of **nodes** (also called **vertices**) and
    **edges**. Each edge connects two nodes. A graph data structure does not require
    any specific rules regarding connections between nodes, as shown in the following
    diagram:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从问题“什么是图？”开始。广义上说，图是由节点（也称为顶点）和边组成的数据结构。每条边连接两个节点。图数据结构不需要关于节点之间连接的任何特定规则，如下图所示：
- en: '![](img/a2f956e4-ed60-447e-961e-b32be6c7719d.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2f956e4-ed60-447e-961e-b32be6c7719d.png)'
- en: The afore mentioned concept seems very simple, doesn't it? Let's try to analyze
    the preceding graph to eliminate any doubts. It contains nine nodes with numbers
    between **1** and **9** as values. Such nodes are connected by 11 edges, such
    as between nodes **2** and **4**. Moreover, a graph can contain **cycles**, for
    example, with nodes indicated by **2**, **3**, and **4**, as well as separate
    groups of nodes, which are not connected together. However, what about the topic
    of parent and child nodes, which you know from learning about trees? As there
    are no specific rules about connections in a graph, such concepts are not used
    in this case.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面提到的概念似乎非常简单，不是吗？让我们尝试分析前面的图以消除任何疑虑。它包含九个节点，值在1和9之间。这些节点由11条边连接，例如节点2和4之间。此外，图可以包含循环，例如由节点2、3和4表示的循环，以及未连接在一起的单独节点组。但是，关于父节点和子节点的主题呢？这是您从树的学习中了解的。由于图中没有关于连接的特定规则，因此在这种情况下不使用这些概念。
- en: A graph can also contain **self-loops**. Each is an edge that connects a given
    node with itself. However, such a topic is out of the scope of this book and is
    not taken into account in examples shown in this chapter.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图还可以包含自环。每个自环都是连接给定节点与自身的边。但是，这样的主题超出了本书的范围，并且在本章中显示的示例中没有考虑。
- en: Some more comments are necessary for edges in a graph. In the preceding diagram,
    you can see a graph where all nodes are connected with **undirected edges**, that
    is, **bidirectional edges**. They indicate that it is possible to travel between
    nodes in both directions, for example, from the node **2** to **3** and from the
    node **3** to **2**. Such edges are presented graphically as straight lines. When
    a graph contains undirected edges, it is an **undirected graph**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于图中的边，还需要一些额外的说明。在前面的图中，你可以看到一个所有节点都通过**无向边**连接的图，也就是**双向边**。它们表示可以在两个方向之间旅行，例如，从节点**2**到**3**，从节点**3**到**2**。这些边在图形上呈现为直线。当一个图包含无向边时，它是一个**无向图**。
- en: However, what about a scenario when you need to indicate that traveling between
    nodes is possible only in one direction? In such a case, you can use **directed
    edges**, that is, **unidirectional edges**, which are presented graphically as
    straight lines with arrows indicating the direction of an edge. If a graph contains
    directed edges, it can be named a **directed graph**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你需要表明节点之间的旅行只能单向进行时怎么办？在这种情况下，你可以使用**有向边**，也就是**单向边**，在图形上呈现为带箭头的直线，箭头表示边的方向。如果一个图包含有向边，它可以被称为**有向图**。
- en: 'An example directed graph is presented in the following diagram on the right,
    while an undirected one is shown on the left:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有向图的例子在右侧的下图中展示，而一个无向图在左侧展示：
- en: '![](img/78f53bad-97f1-4052-bb70-124a43cdfbf3.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/78f53bad-97f1-4052-bb70-124a43cdfbf3.png)'
- en: Just as a short explanation, the directed graph (shown on the right in the preceding
    diagram) contains eight nodes connected by 15 unidirectional edges. For example,
    they indicate that it is possible to travel between the node **1** and **2** in
    both directions, but it is allowed to travel from the node **1** to **3** only
    in one direction, so it is impossible to reach the node **1** from **3** directly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简单解释一下，在前面图中右侧的有向图包含了8个节点，通过15条单向边连接。例如，它们表示可以在节点**1**和**2**之间双向旅行，但是只能从节点**1**到**3**单向旅行，所以无法直接从**3**到**1**。
- en: The division between undirected and directed edges is not the only one. You
    can also specify **weights** (also referred to as **costs**) for particular edges
    to indicate the cost of traveling between nodes. Of course, such weights can be
    assigned to both undirected and directed edges. If weights are provided, an edge
    is named a **weighted edge** and the whole graph a **weighted graph**. Similarly,
    if no weights are provided, **unweighted edges** are used in a graph that can
    be called an **unweighted graph**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 无向和有向边之间的区分并不是唯一的。你还可以为特定的边指定**权重**（也称为**成本**），以表示节点之间旅行的成本。当然，这样的权重可以分配给无向和有向边。如果提供了权重，边被称为**加权边**，整个图被称为**加权图**。同样，如果没有提供权重，图中使用**无权重边**，可以称为**无权重图**。
- en: 'The example weighted graphs with undirected (on the left) and directed (on
    the right) edges are presented in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了带有无向（左侧）和有向（右侧）边的例子加权图：
- en: '![](img/4a125b36-2efb-407e-8d60-b3cc03b89af7.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a125b36-2efb-407e-8d60-b3cc03b89af7.png)'
- en: The graphical presentation of a weighted edge only shows the addition of the
    weight of an edge next to the line. For example, the cost of traveling from the
    node **1** to **2**, as well as from the node **2** to **1**, is equal to **3**
    in the case of the undirected graph, shown on the left in the preceding diagram.
    The situation is a bit more complicated in the case of the directed graph (on
    the right). Here, you can travel from the node **1** to **2** with a cost equal
    to **9**, while traveling in the opposite direction (from the node **2** to **1**)
    is much cheaper and costs only **3**.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 加权边的图形表示只是在线旁边添加了边的权重。例如，在前面图中左侧的无向图中，从节点**1**到**2**的旅行成本，以及从节点**2**到**1**的成本都等于**3**。在有向图的情况下（右侧），情况稍微复杂一些。在这里，你可以从节点**1**到**2**旅行的成本等于**9**，而在相反方向（从节点**2**到**1**）旅行的成本要便宜得多，只有**3**。
- en: Applications
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用
- en: 'After the short introduction, you know some basic information about graphs,
    especially regarding nodes and various kinds of edges. However, why is the topic
    of graphs so important and why does it take up a whole chapter in this book? Could
    you use this data structure in your applications? The answer is obvious: yes!
    The graphs are commonly used while solving various algorithmic problems and have
    numerous real-world applications. Two examples are shown in the following diagrams.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 简短介绍之后，你已经了解了一些关于图的基本信息，特别是关于节点和各种边的信息。但是，为什么图的主题如此重要，为什么它在这本书中占据了一个完整的章节？你的应用程序可以使用这种数据结构吗？答案是显而易见的：可以！在解决各种算法问题和有许多现实世界应用中，图通常被使用。下面的图表中展示了两个例子。
- en: 'To start with, let''s think about a structure of friends available in social
    media. Each user has many contacts, but they also have many friends, and so on.
    What data structure should you choose to store such data? The graph is one of
    the simplest answers. In such a scenario, the nodes represent contacts, while
    edges depict relationships between people. As an example, let''s take a look at
    the following diagram of an undirected and unweighted graph:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑社交媒体中可用的朋友结构。每个用户都有许多联系人，但他们也有许多朋友，等等。你应该选择什么数据结构来存储这样的数据？图是最简单的答案之一。在这种情况下，节点代表联系人，而边表示人与人之间的关系。例如，让我们看一个无向且无权重图的下图：
- en: '![](img/64331293-09c6-49c6-b1f7-979bf9cd68c4.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64331293-09c6-49c6-b1f7-979bf9cd68c4.png)'
- en: 'As you can see, **Jimmy Stewart** has five contacts, namely **John Smith**,
    **Andy Wood**, **Eric Green**, **Ashley Lopez**, and **Paula Scott**. In the meantime,
    **Paula Scott** has two other friends: **Marcin Jamro** and **Tommy Butler**.
    With the usage of a graph as a data structure, you can easily check whether two
    people are friends or whether they have a common contact.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，**Jimmy Stewart**有五个联系人，分别是**John Smith**，**Andy Wood**，**Eric Green**，**Ashley
    Lopez**和**Paula Scott**。与此同时，**Paula Scott**还有另外两个朋友：**Marcin Jamro**和**Tommy
    Butler**。通过使用图作为数据结构，你可以轻松地检查两个人是否是朋友，或者他们是否有共同的联系人。
- en: 'Another common application of graphs involves the problem of searching for
    the shortest path. Let''s imagine a program that should find a path between two
    points in the city, taking into account the time necessary for driving particular
    roads. In such a case, you can use a graph to present a map of a city, where nodes
    depict intersections and edges represent roads. Of course, you should assign weights
    to edges to indicate the time necessary for driving a given road. The topic of
    searching the shortest path can be understood as finding the list of edges from
    the source to the target node, with the minimum total cost. The diagram of a city
    map, based on a graph, is shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图的另一个常见应用涉及搜索最短路径的问题。想象一下一个程序，它应该找到城市中两点之间的路径，考虑到行驶特定道路所需的时间。在这种情况下，你可以使用图来表示城市的地图，其中节点表示交叉路口，边表示道路。当然，你应该为边分配权重，以指示行驶给定道路所需的时间。搜索最短路径的主题可以理解为找到从源节点到目标节点的边的列表，其总成本最小。基于图的城市地图的图表如下所示：
- en: '![](img/65f4d4d1-604d-461d-89d8-745660ef781e.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65f4d4d1-604d-461d-89d8-745660ef781e.png)'
- en: As you can see, the directed and weighted graph was chosen. The application
    of directed edges makes it possible to support both two-way and one-way roads,
    while weighted edges allow for specifying the time necessary to travel between
    two intersections.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，选择了有向加权图。有向边的应用使得支持双向和单向道路成为可能，而加权边允许指定在两个交叉路口之间行驶所需的时间。
- en: Representation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示
- en: Now you know what a graph is and when it can be used, but how you can represent
    it in the memory of a computer? There are two popular approaches to solve this
    problem, namely using an **adjacency list** and an **adjacency matrix**. Both
    are described in detail in the following sections.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道了图是什么，以及它何时可以使用，但是你如何在计算机的内存中表示它呢？解决这个问题有两种流行的方法，即使用**邻接表**和**邻接矩阵**。这两种方法将在接下来的部分中详细描述。
- en: Adjacency list
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接表
- en: 'The first approach requires you to extend the data of a node by specifying
    a list of its neighbors. Thus, you can easily get all neighbors of a given node
    just by iterating through the adjacency list of a given node. Such a solution
    is space-efficient, because you only store the data of adjacent edges. Let''s
    take a look at the following diagram:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法要求你通过指定其邻居的列表来扩展一个节点的数据。因此，你可以通过迭代给定节点的邻接表来轻松获取给定节点的所有邻居。这样的解决方案是空间高效的，因为你只存储相邻边的数据。让我们看一下下面的图表：
- en: '![](img/8b5077b4-5ac8-4d23-b617-5de2c40cdb61.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b5077b4-5ac8-4d23-b617-5de2c40cdb61.png)'
- en: The example graph contains 8 nodes and 10 edges. For each node, a list of adjacent
    nodes (that is, neighbors) is created, as shown on the right-hand side of the
    diagram. For example, the node **1** has two neighbors, namely the nodes **2**
    and **3**, while the node **5** has four neighbors, namely the nodes **4**, **6**,
    **7**, and **8**. As you can see, the representation based on the adjacency list
    for an undirected and unweighted graph is really straightforward, as well as easy
    to use, understand, and implement.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例图包含8个节点和10条边。对于每个节点，创建了一个相邻节点（即邻居）的列表，如图表右侧所示。例如，节点**1**有两个邻居，即节点**2**和**3**，而节点**5**有四个邻居，即节点**4**，**6**，**7**和**8**。正如你所看到的，基于邻接表的无向无权图的表示非常直接，易于使用、理解和实现。
- en: 'However, how does the adjacency list work in the case of a directed graph?
    The answer is obvious, because the list assigned to each node just shows adjacent
    nodes that can be reached from the given node. The example diagram is shown as
    follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在有向图的情况下，邻接表是如何工作的呢？答案是显而易见的，因为分配给每个节点的列表只显示可以从给定节点到达的相邻节点。示例图如下所示：
- en: '![](img/a9587b8b-ee85-43e5-a6e1-c72e45ee7320.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a9587b8b-ee85-43e5-a6e1-c72e45ee7320.png)'
- en: Let's take a look at the node **3**. Here, the adjacency list contains only
    one element, that is, the node **4**. The node **1** is not included, because
    it cannot be reached directly from the node **3**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下节点**3**。在这里，邻接表只包含一个元素，即节点**4**。节点**1**没有包括在内，因为它不能直接从节点**3**到达。
- en: 'A bit more clarification may be necessary in the case of a weighted graph.
    In such a case, it is also necessary to store weights for particular edges. You
    can achieve this goal by extending data stored in the adjacency list, as shown
    in the following diagram:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权图的情况下可能需要更多的解释。在这种情况下，还需要存储特定边的权重。你可以通过扩展邻接表中存储的数据来实现这个目标，如下图所示：
- en: '![](img/3c37de49-bcb7-4f69-9509-2832cb82e959.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3c37de49-bcb7-4f69-9509-2832cb82e959.png)'
- en: The adjacency list for the node **7** contains two elements, namely regarding
    an edge to the node **5** (with a weight equal to **4**) and to the node **8**
    (with a weight equal to **6**).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 节点**7**的邻接表包含两个元素，即指向节点**5**的边（权重为**4**）和指向节点**8**的边（权重为**6**）。
- en: Adjacency matrix
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邻接矩阵
- en: Another approach to graph representation involves the adjacency matrix, which
    uses the two-dimensional array to show which nodes are connected by edges. The
    matrix contains the same number of rows and columns, which is equal to the number
    of nodes. The main idea is to store information about a particular edge in an
    element at a given row and column in the matrix. The index of the row and the
    column depends on the nodes connected with the edge. For example, if you want
    to get information about an edge between nodes with indices 1 and 5, you should
    check the element in the row with an index equal to 1 and in the column with an
    index set to 5.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图的另一种表示方法涉及邻接矩阵，它使用二维数组来显示哪些节点通过边相连。矩阵包含相同数量的行和列，即节点的数量。主要思想是在矩阵的给定行和列中存储关于特定边的信息。行和列的索引取决于与边相连的节点。例如，如果你想获取索引为1和5的节点之间边的信息，你应该检查矩阵中索引为1的行和索引为5的列的元素。
- en: Such a solution provides you with a fast way of checking whether two particular
    nodes are connected by an edge. However, it may require you to store significantly
    more data than the adjacency list, especially if the graph does not contain many
    edges between nodes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的解决方案可以快速检查两个特定节点是否通过边相连。然而，它可能需要存储的数据比邻接表要多得多，特别是如果图中节点之间的边不多的话。
- en: 'To start, let''s analyze the basic scenario of an undirected and unweighted
    graph. In such a case, the adjacency matrix may store only Boolean values. The
    `true` value placed in the element at `i` row and `j` column indicates that there
    is a connection between a node with an index equal to `i` and the node with index
    `j`. If it sounds complicated, take a look at the following example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们分析无向无权图的基本情况。在这种情况下，邻接矩阵可能只存储布尔值。在第`i`行和第`j`列的元素中放置的`true`值表示索引为`i`的节点和索引为`j`的节点之间存在连接。如果听起来很复杂，看看下面的例子：
- en: '![](img/94179e3f-bede-42b6-b542-7b579cf89c08.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94179e3f-bede-42b6-b542-7b579cf89c08.png)'
- en: Here, the adjacency matrix contains 64 elements (for eight rows and eight columns),
    because there are eight nodes in the graph. The values of many elements in the
    array are set to `false`, which is represented by missing indicators. The remaining
    are marked with crosses, representing `true` values. For example, such a value
    in the element at the fourth row and third column means that there is an edge
    between the node **4** and **3**, as shown in the preceding diagram of the graph.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，邻接矩阵包含64个元素（八行八列），因为图中有八个节点。数组中许多元素的值设置为`false`，表示缺失指示。其余的用叉号表示`true`值。例如，在第四行和第三列的元素中的这样一个值表示图中节点**4**和**3**之间有一条边，如前面图中所示。
- en: As the presented graph is undirected, the adjacency matrix is symmetric. If
    there is an edge between nodes `i` and `j`, there is also an edge between nodes
    `j` and `i`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所呈现的图是无向的，邻接矩阵是对称的。如果节点`i`和`j`之间有一条边，那么节点`j`和`i`之间也有一条边。
- en: 'The next example involves a directed and unweighted graph. In such a case,
    the same rules can be used, but the adjacency matrix does not need to be symmetric.
    Let''s take a look at the following diagram of the graph, presented together with
    the adjacency matrix:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个例子涉及有向无权图。在这种情况下，可以使用相同的规则，但邻接矩阵不需要对称。让我们看一下下图所示的图和邻接矩阵：
- en: '![](img/f1c3511f-6e80-4aa4-8199-fbb7c4ed7a53.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1c3511f-6e80-4aa4-8199-fbb7c4ed7a53.png)'
- en: Within the shown adjacency matrix you can find data of 15 edges, represented
    by 15 elements with `true` values, indicated by crosses in the matrix. For example,
    the unidirectional edge from the node **5** to **4** is shown as the cross at
    the fifth row and fourth column.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在所示的邻接矩阵中，你可以找到15条边的数据，用15个带有`true`值的元素表示，矩阵中用叉号表示。例如，从节点**5**到**4**的单向边在矩阵的第五行和第四列处用叉号表示。
- en: 'In both previous examples, you have learnt how to present an unweighted graph
    using an adjacency matrix. However, how you can store the data of the weighted
    graph, either undirected or directed? The answer is very simple—you just need
    to change the type of data stored in particular elements in the adjacency matrix
    from Boolean to numeric. Thus, you can specify the weight of edges, as shown in
    the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个例子中，你已经学会了如何使用邻接矩阵来表示无权图。然而，你如何存储加权图的数据，无论是无向还是有向的？答案很简单——你只需要将邻接矩阵中特定元素存储的数据类型从布尔值改为数字。因此，你可以指定边的权重，如下图所示：
- en: '![](img/5ac401e9-75be-451b-b89b-1df9a325af0c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5ac401e9-75be-451b-b89b-1df9a325af0c.png)'
- en: The preceding diagram and the adjacency matrix are self-explanatory. However,
    to eliminate any doubt, let's take a look at the edge between the node **5** and
    **6** with the weight set to **2**. Such an edge is represented by the element
    at the fifth row and sixth column. The value of the element is equal to the cost
    of traveling between such nodes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图和邻接矩阵都是不言自明的。然而，为了消除任何疑惑，让我们看一下节点**5**和**6**之间权重为**2**的边。这样的边由矩阵中第五行和第六列的元素表示。元素的值等于这些节点之间的旅行成本。
- en: Implementation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现
- en: You have already got to know some basic information about graphs, including
    nodes, edges, and two methods of representation, namely using an adjacency list
    and matrix. However, how you can use such a data structure in your applications?
    In this section, you will learn how to implement a graph using the C# language.
    To make your understanding of the presented content easier, two examples are provided.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了一些关于图的基本信息，包括节点、边以及邻接表和邻接矩阵两种表示方法。然而，你如何在应用程序中使用这样的数据结构呢？在本节中，你将学习如何使用C#语言实现图。为了让你更容易理解所呈现的内容，提供了两个例子。
- en: Node
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点
- en: 'To start with, let''s take a look at the code of the generic class representing
    a single node in a graph. Such a class is named `Node` and its code is shown as
    follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看一下表示图中单个节点的泛型类的代码。这样的类名为`Node`，其代码如下所示：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The class contains four properties. As all of these elements perform important
    roles in the code snippets shown in this chapter, let''s analyze them in detail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含四个属性。由于所有这些元素在本章中显示的代码片段中都扮演着重要角色，让我们详细分析它们：
- en: The first property (`Index`) stores an index of a particular node in a collection
    of nodes in a graph to simplify the process of accessing a particular element.
    Thus, it is possible to easily get an instance of the `Node` class, representing
    a particular node, by using an index.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个属性（`Index`）存储了图中特定节点在节点集合中的索引，以简化访问特定元素的过程。因此，可以通过使用索引轻松获取表示特定节点的`Node`类的实例。
- en: The next property is named `Data` and just stores some data in the node. It
    is worth mentioning that a type of such data is consistent with the type specified
    while creating an instance of the generic class.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个属性名为`Data`，只是在节点中存储一些数据。值得一提的是，此类数据的类型与创建泛型类实例时指定的类型一致。
- en: The `Neighbors` property represents the adjacency list for a particular node.
    Thus, it contains references to the `Node` instances representing adjacent nodes.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Neighbors`属性表示特定节点的邻接表。因此，它包含对表示相邻节点的`Node`实例的引用。'
- en: The last property is named `Weights` and stores weights assigned to adjacent
    edges. In the case of a weighted graph, the number of elements in the `Weights`
    list is the same as the number of neighbors (`Neighbors`). If a graph is unweighted,
    the `Weights` list is empty.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个属性名为`Weights`，用于存储分配给相邻边的权重。在加权图的情况下，`Weights`列表中的元素数量与相邻节点（`Neighbors`）的数量相同。如果图是无权的，则`Weights`列表为空。
- en: 'Apart from the properties, the class contains the overridden `ToString` method,
    which returns the textual representation of the object. Here, the string in the
    format `"Node with index [index]: [data], neighbors: [count]"` is returned.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '除了属性之外，该类还包含重写的`ToString`方法，该方法返回对象的文本表示。在这里，以格式`"Node with index [index]:
    [data], neighbors: [count]"`返回字符串。'
- en: Edge
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边
- en: 'As mentioned in the short introduction to the topic of graphs, a graph consists
    of nodes and edges. As a node is represented by an instance of the `Node` class,
    the `Edge` generic class can be used to represent an edge. The suitable part of
    code is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如在关于图的简短介绍中提到的，图由节点和边组成。由于节点由`Node`类的实例表示，因此`Edge`泛型类可用于表示边。代码的适当部分如下所示：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class contains three properties, namely representing nodes adjacent to the
    edge (`From` and `To`), as well as the weight of the edge (`Weight`). Moreover,
    the `ToString` method is overridden to present some basic information about the
    edge.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含三个属性，分别表示与边相邻的节点（`From`和`To`），以及边的权重（`Weight`）。此外，`ToString`方法被重写以呈现有关边的一些基本信息。
- en: Graph
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图
- en: The next class is named `Graph` and represents a whole graph, with either directed
    or undirected edges, as well as either weighted or unweighted edges. The implementation
    consists of various fields and methods, which are described in details as follows.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个类名为`Graph`，表示整个图，具有有向或无向边，以及加权或无权边。实现包括各种字段和方法，如下所述。
- en: 'Let''s take a look at the basic version of the `Graph` class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`Graph`类的基本版本：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class contains two fields indicating whether edges are directed (`_isDirected`)
    and weighted (`_isWeighted`). Moreover, the `Nodes` property is declared, which
    stores a list of nodes existing in the graph.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含两个字段，指示边是否有向（`_isDirected`）和加权（`_isWeighted`）。此外，声明了`Nodes`属性，该属性存储图中存在的节点列表。
- en: 'The class also contains the constructor, as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 该类还包含以下构造函数：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, only values of the `_isDirected` and `_isWeighted` private fields are
    set, according to the values of parameters passed to the constructor.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，根据传递给构造函数的参数的值，只设置了`_isDirected`和`_isWeighted`私有字段的值。
- en: 'The next interesting member of the `Graph` class is the indexer that takes
    two indices, namely indices of two nodes, to return an instance of the `Edge`
    generic class representing an edge between such nodes. The implementation is shown
    in the following code snippet:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`类的下一个有趣成员是索引器，它接受两个索引，即两个节点的索引，以返回表示这些节点之间边的`Edge`泛型类的实例。实现如下代码片段所示：'
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Within the indexer, you get instances of the `Node` class representing two nodes
    (`nodeFrom` and `nodeTo`), according to the indices. As you want to find an edge
    from the first node (`nodeFrom`) to the second one (`nodeTo`), you need to try
    to find the second node in the collection of neighbor nodes of the first node,
    using the `IndexOf` method. If such a connection does not exist, the `IndexOf`
    method returns a negative value and `null` is returned by the indexer. Otherwise,
    you create a new instance of the `Edge` class and set the values of its properties,
    including `From` and `To`. If the data regarding the weight of particular edges
    are provided, the value of the `Weight` property of the `Edge` class is set as
    well.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在索引器中，根据索引获取表示两个节点（`nodeFrom`和`nodeTo`）的`Node`类的实例。如果要找到从第一个节点（`nodeFrom`）到第二个节点（`nodeTo`）的边，需要尝试在第一个节点的相邻节点集合中找到第二个节点，使用`IndexOf`方法。如果这样的连接不存在，`IndexOf`方法将返回负值，并且索引器将返回`null`。否则，创建`Edge`类的新实例，并设置其属性的值，包括`From`和`To`。如果提供了关于特定边权重的数据，则还设置`Edge`类的`Weight`属性的值。
- en: 'Now you know how to store the data of nodes in the graph, but how can you add
    a new node? To do so, the `AddNode` method is implemented, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何存储图中节点的数据，但是如何添加新节点呢？为此，实现了`AddNode`方法，如下所示：
- en: '[PRE5]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Within this method, you create a new instance of the `Node` class and set a
    value of the `Data` property, according to the value of the parameter. Then, the
    newly-created instance is added to the `Nodes` collection, and the `UpdateIndices`
    method (described later) is called to update the indices of all nodes stored in
    the collection. At the end, the `Node` instance, representing the newly-added
    node, is returned.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，您创建`Node`类的新实例，并根据参数的值设置`Data`属性的值。 然后，新创建的实例被添加到`Nodes`集合中，并调用`UpdateIndices`方法（稍后描述）来更新集合中存储的所有节点的索引。
    最后，返回表示新添加节点的`Node`实例。
- en: 'You can remove the existing node as well. This operation is performed by the
    `RemoveNode` method, shown in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以移除现有节点。 这个操作是由`RemoveNode`方法执行的，如下面的代码片段所示：
- en: '[PRE6]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The method takes one parameter, namely an instance of the node that should be
    removed. First, you remove it from the collection of nodes. Then, you update the
    indices of the remaining nodes. At the end, you iterate through all nodes in the
    graph to remove all edges that are connected with the node that has been removed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个参数，即应该被移除的节点的实例。 首先，您将其从节点集合中移除。 然后，您更新剩余节点的索引。 最后，您遍历图中的所有节点，以删除与已删除节点相连的所有边。
- en: 'As you already know, a graph consists of nodes and edges. Thus, the implementation
    of the `Graph` class should provide developers with the method for adding a new
    edge. Of course, it should support various variants of edges, either directed,
    undirected, weighted, or unweighted. The proposed implementation is shown as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，图由节点和边组成。 因此，`Graph`类的实现应该为开发人员提供添加新边的方法。 当然，它应该支持各种边的变体，无论是有向的，无向的，加权的，还是无权重的。
    提议的实现如下所示：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AddEdge` method takes three parameters, namely two instances of the `Node`
    class representing nodes connected by the edge (`from` and `to`), as well as the
    weight of the connection (`weight`), which is set to `0` by default.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEdge`方法接受三个参数，即表示由边连接的两个`Node`类实例（`from`和`to`），以及连接的权重（`weight`），默认设置为`0`。'
- en: In the first line within the method, you add the `Node` instance representing
    the second node to the list of neighbor nodes of the first one. If the weighted
    graph is considered, a weight of the afore mentioned edge is added as well.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内的第一行，您将表示第二个节点的`Node`实例添加到第一个节点的邻居节点列表中。 如果考虑加权图，上述边的权重也将被添加。
- en: The following part of the code is taken into account only when the graph is
    undirected. In such a case, you need to automatically add an edge in the opposite
    direction. To do so, you add the `Node` instance representing the first node to
    the list of neighbor nodes of the second one. If the edges are weighted, a weight
    of the afore mentioned edge is added to the `Weights` list as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的以下部分仅在图是无向的情况下考虑。 在这种情况下，您需要自动在相反方向上添加一条边。 为此，您将表示第一个节点的`Node`实例添加到第二个节点的邻居节点列表中。
    如果边是加权的，那么上述边的权重也将添加到`Weights`列表中。
- en: 'The process of removing an edge from the graph is supported by the `RemoveEdge`
    method. The code is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从图中删除边的过程由`RemoveEdge`方法支持。 代码如下：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The method takes two parameters, namely two nodes (`from` and `to`), between
    which there is an edge that should be removed. To start, you try to find the second
    node in the list of neighbor nodes of the first one. If it is found, you remove
    it. Of course, you should also remove the weight data, if the weighted graph is
    considered.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受两个参数，即两个节点（`from`和`to`），它们之间有一条应该被移除的边。 首先，您尝试在第一个节点的邻居节点列表中找到第二个节点。 如果找到了，您将其移除。
    当然，如果考虑加权图，您还应该移除权重数据。
- en: 'The last public method is named `GetEdges` and makes it possible to get a collection
    of all edges available in the graph. The proposed implementation is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个公共方法名为`GetEdges`，它可以获取图中所有可用边的集合。 提议的实现如下：
- en: '[PRE9]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To start with, a new list of edges is initialized. Then, you iterate through
    all nodes in the graph, using the `foreach` loop. Within it, you use the `for`
    loop to create instances of the `Edge` class. The number of instances should be
    equal to the number of neighbors of the current node (the `from` variable in the
    `foreach` loop). In the `for` loop, the newly-created instance of the `Edge` class
    is configured by setting values of its properties, namely the first node (the
    `from` variable, that is, the current node from the `foreach` loop), the second
    node (to the currently-analyzed neighbor), and the weight. Then, the newly-created
    instance is added to the collection of edges, represented by the `edges` variable.
    At the end, the result is returned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化一个新的边列表。 然后，您使用`foreach`循环遍历图中的所有节点。 在其中，您使用`for`循环创建`Edge`类的实例。 实例的数量应该等于当前节点（`foreach`循环中的`from`变量）的邻居节点的数量。
    在`for`循环中，通过设置其属性的值来配置`Edge`类的新创建实例，即第一个节点（`from`变量，即`foreach`循环中的当前节点），第二个节点（当前分析的邻居节点），以及权重。
    然后，新创建的实例被添加到边的集合中，由`edges`变量表示。 最后，返回结果。
- en: 'In various methods, you use the `UpdateIndices` method. The code is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种方法中，您使用`UpdateIndices`方法。 代码如下：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The method just iterates through all nodes in the graph and updates the values
    of the `Index` property to the consecutive number, starting from `0`. It is worth
    noting that the iteration is performed using the `ForEach` method, instead of
    `foreach` or a `for` loop.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法只是遍历图中的所有节点，并更新`Index`属性的值为连续的数字，从`0`开始。 值得注意的是，迭代是使用`ForEach`方法执行的，而不是`foreach`或`for`循环。
- en: Now you know how to create a basic implementation of a graph. The next step
    is to apply it to represent some example graphs, as shown in the two following
    sections.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建图的基本实现。 下一步是将其应用于表示一些示例图，如下面的两个部分所示。
- en: Example – undirected and unweighted edges
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-无向且无权重的边
- en: 'Let''s try to use the previous implementation to create the undirected and
    unweighted graph, according to the following diagram:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用先前的实现来创建无向和无权图，如下图所示：
- en: '![](img/74eaa194-4d25-4862-bf52-87ab7b6bf942.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/74eaa194-4d25-4862-bf52-87ab7b6bf942.png)'
- en: 'As you can see, the graph contains 8 nodes and 10 edges. You can configure
    the example graph in the `Main` method in the `Program` class. The implementation
    starts with the following line of code, which initializes a new undirected graph
    (with `false` as the value of the first parameter) and an unweighted graph (with
    `false` as the value of the second parameter):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，图包含8个节点和10条边。您可以在`Program`类的`Main`方法中配置示例图。实现始于以下代码行，该行初始化了一个新的无向图（第一个参数的值为`false`）和一个无权图（第二个参数的值为`false`）：
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, you add the necessary nodes, and store references to them as new variables
    of the `Node<int>` type, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您添加必要的节点，并将它们存储为`Node<int>`类型的新变量，如下所示：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At the end, you only need to add edges between nodes, according to the preceding
    diagram of the graph. The necessary code is presented as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您只需要根据图的先前图表在节点之间添加边。必要的代码如下所示：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all! As you can see, configuration of a graph is very easy using the
    proposed implementation of this data structure. Now, let's proceed to a slightly
    more complex scenario with directed and weighted edges.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！如您所见，使用这种数据结构的建议实现非常容易配置图。现在，让我们继续进行一个稍微复杂一点的有向和加权边的场景。
- en: Example – directed and weighted edges
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 有向和加权边
- en: 'The next example involves the directed and weighted graph, as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例涉及有向加权图，如下所示：
- en: '![](img/37e3110d-10bd-43cf-8a81-fa6144a9e3de.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/37e3110d-10bd-43cf-8a81-fa6144a9e3de.png)'
- en: 'The implementation is very similar to the one described in the previous section.
    However, some modifications are necessary. To start with, different values of
    the parameters of the constructor are used, namely `true` instead of `false` to
    indicate that a directed and weighted variant of edges is being considered. The
    suitable line of code is as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 该实现与前一节中描述的实现非常相似。但是，需要进行一些修改。首先，构造函数的参数值不同，即使用`true`而不是`false`来指示正在考虑有向和加权的边。适当的代码行如下：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The part regarding adding nodes is exactly the same as in the previous example:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于添加节点的部分与前面的例子完全相同：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Some changes are easily visible in the lines of code regarding the addition
    of edges. Here, you specify directed edges together with their weights, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于添加边的代码行中，一些更改很容易看到。在这里，您指定了带有它们权重的有向边，如下所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You have just completed the basic implementation of a graph, shown in two examples.
    So, let's proceed to another topic, namely traversing a graph.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了图的基本实现，分别在两个示例中展示。因此，让我们继续另一个主题，即遍历图。
- en: Traversal
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历
- en: One of the useful operations performed on a graph is its **traversal**, that
    is, visiting all of the nodes in some particular order. Of course, the afore mentioned
    problem can be solved in various ways, such as using **depth-first search** (**DFS**)
    or **breadth-first search** (**BFS**) approaches. It is worth mentioning that
    the traversal topic is strictly connected with the task of searching for a given
    node in a graph.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图上执行的一个有用操作是其**遍历**，即以某种特定顺序访问所有节点。当然，前面提到的问题可以以各种方式解决，例如使用**深度优先搜索**（**DFS**）或**广度优先搜索**（**BFS**）方法。值得一提的是，遍历主题与在图中搜索给定节点的任务密切相关。
- en: Depth-first search
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深度优先搜索
- en: 'The first graph traversal algorithm described in this chapter is named DFS.
    Its steps, in the context of the example graph, are as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述的第一个图遍历算法称为DFS。在示例图的上下文中，其步骤如下：
- en: '![](img/a1e3f5de-294d-47ce-b2fe-0bdd4a626522.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1e3f5de-294d-47ce-b2fe-0bdd4a626522.png)'
- en: Of course, it can be a bit difficult to understand how the DFS algorithm operates
    just by looking at the preceding diagram. For this reason, let's try to analyze
    its stages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，仅仅通过查看前面的图表就很难理解DFS算法是如何操作的。因此，让我们尝试分析其各个阶段。
- en: In the first step, you see the graph with eight nodes. The node **1** is marked
    with a gray background (indicating that the node has been already visited), as
    well as with a red border (indicating that it is the node that is currently being
    visited). Moreover, an important role in the algorithm is performed by the neighbor
    nodes (shown as circles with dashed borders) of the current one. When you know
    the roles of particular indicators, it is clear that in the first step, the node
    **1** is visited. It has two neighbors (the nodes **2** and **3**).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，您可以看到具有八个节点的图。节点**1**用灰色背景标记（表示该节点已被访问），并用红色边框标记（表示当前正在访问的节点）。此外，算法中的邻居节点（以虚线边框显示为圆圈）起着重要作用。当您了解特定指示器的作用时，很明显，在第一步中访问了节点**1**。它有两个邻居（节点**2**和**3**）。
- en: 'Then, the first neighbor (the node **2**) is taken into account and the same
    operations are performed, that is, the node is visited and the neighbors (the
    nodes **1** and **4**) are analyzed. As the node **1** has been already visited,
    it is skipped. In the next step (shown as **Step #3**), the first suitable neighbor
    of the node **2** is taken into account—the node **4**. It has two neighbors,
    namely the node **2** (already visited) and **8**. Next, the node **8** is visited
    (**Step #4**) and, according to the same rules, the node **5** (**Step #5**).
    It has four neighbors, namely the nodes **4** (already visited), **6**, **7**,
    and **8** (already visited). Thus, in the next step, the node **6** is taken into
    account (**Step #6**). As it has only one neighbor (the node **7**), it is visited
    next (**Step #7**).'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，首个邻居（节点**2**）被考虑，并执行相同的操作，即访问节点并分析邻居（节点**1**和**4**）。由于节点**1**已经被访问过，所以它被跳过。在下一步（标为**步骤#3**）中，节点**2**的第一个合适的邻居被考虑——节点**4**。它有两个邻居，即节点**2**（已经被访问）和**8**。接下来，节点**8**被访问（**步骤#4**），根据相同的规则，访问节点**5**（**步骤#5**）。它有四个邻居，即节点**4**（已经被访问）、**6**、**7**和**8**（已经被访问）。因此，在下一步中，节点**6**被考虑（**步骤#6**）。由于它只有一个邻居（节点**7**），所以下一个被访问的是它（**步骤#7**）。
- en: 'Then, you check the neighbors of the node **7**, namely the nodes **5** and
    **8**. Both have already been visited, so you return to the node with an unvisited
    neighbor. In the example, the node **1** has one unvisited node, namely the node
    **3**. When it is visited (**Step #8**), all nodes are traversed and no further
    operations are necessary.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您检查节点**7**的邻居，即节点**5**和**8**。两者都已经被访问过，所以您返回到具有未访问邻居的节点。在这个例子中，节点**1**有一个未访问的节点，即节点**3**。当它被访问（**步骤#8**）时，所有节点都被遍历，不需要进行进一步的操作。
- en: 'Given this example, let''s try to create the implementation in the C# language.
    To start, the code of the `DFS` method (in the `Graph` class) is presented as
    follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这个例子，让我们尝试在C#语言中创建实现。首先，`DFS`方法的代码（在`Graph`类中）如下所示：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The important role is performed by the `isVisited` array. It has exactly the
    same number of elements as the number of nodes and stores values indicating whether
    a given node has already been visited. If so, the `true` value is stored, otherwise `false`.
    The list of traversed nodes is represented as a list in the `result` variable.
    What is more, another variant of the `DFS` method is called here, passing three
    parameters, namely a reference to the `isVisited` array, the first node to analyze,
    as well as the list for storing results.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`isVisited`数组发挥了重要作用。它的元素数量与节点数量相同，并存储指示给定节点是否已经被访问的值。如果是，就存储`true`值，否则存储`false`。遍历节点的列表以`result`变量的形式表示。此外，这里调用了`DFS`方法的另一个变体，传递了三个参数，即对`isVisited`数组的引用、要分析的第一个节点，以及用于存储结果的列表。'
- en: 'The code of the afore mentioned variant of the `DFS` method is presented as
    follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`DFS`方法的代码如下所示：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The shown implementation is very simple. At the beginning, the current node
    is added to the collection of traversed nodes and the element in the `isVisited`
    array is updated. Then, you use the `foreach` loop to iterate through all neighbors
    of the current node. For each of them, if it is not already visited, the `DFS`
    method is called recursively.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的实现非常简单。在开始时，当前节点被添加到遍历节点的集合中，并更新`isVisited`数组中的元素。然后，您使用`foreach`循环来遍历当前节点的所有邻居。对于每一个邻居，如果它还没有被访问过，就会递归调用`DFS`方法。
- en: You can find more information about DFS at [https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://en.wikipedia.org/wiki/Depth-first_search](https://en.wikipedia.org/wiki/Depth-first_search)找到有关DFS的更多信息。
- en: 'To finish, let''s take a look at the code that can be placed in the `Main`
    method in the `Program` class. Its main parts are presented in the following code
    snippet:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看一下可以放在`Program`类的`Main`方法中的代码。其主要部分如下代码片段所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, you initialize a directed and weighted graph. To start traversing the
    graph, you just need to call the `DFS` method, which returns a list of `Node`
    instances. Then, you can easily iterate through elements of the list to print
    some basic information about each node. The result is shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您初始化了一个有向加权图。要开始遍历图，您只需要调用`DFS`方法，它会返回一个`Node`实例的列表。然后，您可以轻松地遍历列表中的元素，打印每个节点的一些基本信息。结果如下所示：
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: That's all! As you can see, the algorithm tries to go as deep as possible and
    then goes back to find the next unvisited neighbor that can be traversed. However,
    the presented algorithm is not the only approach to the problem of graph traversal.
    In the next section, you will see another method, together with a basic example
    and its implementation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！正如您所看到的，该算法试图尽可能深入，然后返回以找到下一个可以遍历的未访问邻居。然而，所呈现的算法并不是解决图遍历问题的唯一方法。在下一部分，您将看到另一种方法，以及一个基本示例和其实现。
- en: Breadth-first search
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 广度优先搜索
- en: In the previous section, you learnt the DFS approach. Now you will see another
    solution, namely BFS. Its main aim is to first visit all neighbors of the current
    node and then proceed to the next level of nodes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分，您学习了DFS方法。现在您将看到另一种解决方案，即BFS。它的主要目的是首先访问当前节点的所有邻居，然后继续到下一级节点。
- en: 'If the previous description sounds a bit complicated, take a look at this diagram,
    which depicts the steps of the BFS algorithm:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的描述听起来有点复杂，请看一下这个图表，它描述了BFS算法的步骤：
- en: '![](img/c3e3596a-13bc-4a71-907f-4ca85b345502.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3e3596a-13bc-4a71-907f-4ca85b345502.png)'
- en: 'The algorithm starts by visiting the node **1** (**Step #1**). It has two neighbors,
    namely the nodes **2** and **3**, which are visited next (**Step #2** and **Step** **#3**).
    As the node **1** does not have more neighbors, the neighbors of its first neighbor
    (the node **2**) are considered. As it has only one neighbor (the node **4**),
    it is visited in the next step. According to the same method, the remaining nodes
    are visited in this order: **8**, **5**, **6**, **7**.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法从访问节点**1**（**步骤＃1**）开始。它有两个邻居，即节点**2**和**3**，接下来访问它们（**步骤＃2**和**步骤＃3**）。由于节点**1**没有更多的邻居，因此考虑其第一个邻居（节点**2**）的邻居。由于它只有一个邻居（节点**4**），它在下一步被访问。按照相同的方法，剩下的节点按照这个顺序被访问：**8**，**5**，**6**，**7**。
- en: 'It sounds very simple, doesn''t it? Let''s take a look at the implementation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，不是吗？让我们看一下实现：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `BFS` public method is added to the `Graph` class and is used just to start
    the traversal of a graph. It calls the private `BFS` method, passing the first
    node as the parameter. Its code is shown as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`BFS`公共方法被添加到`Graph`类中，仅用于启动图的遍历。它调用私有的`BFS`方法，将第一个节点作为参数传递。其代码如下所示：'
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The important role in the code is performed by the `isVisited` array, which
    stores Boolean values indicating whether particular nodes have been visited already.
    Such an array is initialized at the beginning of the `BFS` method, and the value
    of the element related to the current node is set to `true`, which indicates that
    the node has been visited.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的重要角色由`isVisited`数组发挥，它存储布尔值，指示特定节点是否已经被访问。这样的数组在`BFS`方法开始时被初始化，与当前节点相关的元素的值被设置为`true`，表示该节点已被访问。
- en: Then, the list for storing traversed nodes (`result`) and the queue for storing
    nodes that should be visited in the following iterations (`queue`) are created.
    Just after the initialization of the queue, the current node is added into it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建用于存储遍历节点的列表（`result`）和用于存储应在以下迭代中访问的节点的队列（`queue`）。就在初始化队列之后，当前节点被添加到队列中。
- en: 'The following operations are performed until the queue is empty: you get the
    first node from the queue (the `next` variable), add it to the collection of visited
    nodes, and iterate through the neighbors of the current node. For each of them,
    you check whether it has already been visited. If not, it is marked as visited
    by setting a proper value in the `isVisited` array, and the neighbor is added
    to the queue for analysis in one of the next iterations of the `while` loop.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 直到队列为空为止，执行以下操作：从队列中获取第一个节点（`next`变量），将其添加到已访问节点的集合中，并迭代当前节点的邻居。对于每个邻居，检查它是否已经被访问。如果没有，通过在`isVisited`数组中设置适当的值来标记为已访问，并将邻居添加到队列中，以便在`while`循环的下一次迭代中进行分析。
- en: You can find more information about the BFS algorithm and its implementation
    at [https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/](https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/)找到有关BFS算法及其实现的更多信息。
- en: 'At the end, the list of the visited nodes is returned. If you want to test
    the described algorithm, you can place the following code in the `Main` method
    in the `Program` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，返回已访问节点的列表。如果要测试所描述的算法，可以将以下代码放入`Program`类中的`Main`方法中：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The code initializes the graph, adds proper nodes and edges, and calls the
    `BFS` public method to traverse the graph according to the BFS algorithm. The
    last line is responsible for iterating through the result to present the data
    of the nodes in the console:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 代码初始化图形，添加适当的节点和边，并调用`BFS`公共方法来根据BFS算法遍历图形。最后一行负责迭代结果以在控制台中呈现节点的数据：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You have just learnt two algorithms for traversing a graph, namely DFS and BFS.
    To make your understanding of such topics easier, this chapter contains detailed
    descriptions, diagrams, and examples. Now, let's proceed to the next section to
    get to know another important topic, namely a minimum spanning tree, which has
    many real-world applications.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了两种遍历图的算法，即DFS和BFS。为了让你更容易理解这些主题，本章包含了详细的描述、图表和示例。现在，让我们继续到下一节，了解另一个重要主题，即最小生成树，它在现实世界中有许多应用。
- en: Minimum spanning tree
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小生成树
- en: 'While talking about graphs, it is beneficial to introduce the subject of a
    **spanning tree**. What is it? A spanning tree is a subset of edges that connects
    all nodes in a graph without cycles. Of course, it is possible to have many spanning
    trees within the same graph. For example, let''s take a look at the following
    diagram:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论图形时，介绍**生成树**的主题是有益的。什么是生成树？生成树是连接图中所有节点而没有循环的边的子集。当然，在同一个图中可能有许多生成树。例如，让我们看一下以下图表：
- en: '![](img/84d01292-80ee-4542-9afb-10e292ca0a0e.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/84d01292-80ee-4542-9afb-10e292ca0a0e.png)'
- en: 'On the left-hand side is a spanning tree that consists of the following edges:
    (**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**), (**5**, **6**),
    (**6**, **7**), and (**5**, **8**). The total weight is equal to 40\. On the right-hand
    side, another spanning tree is shown. Here, the following edges are taken into
    account: (**1**, **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**,
    **8**), (**5**, **6**), and (**6**, **7**). The total weight is equal to 31.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧是一个由以下边组成的生成树：(**1**, **2**), (**1**, **3**), (**3**, **4**), (**4**, **5**),
    (**5**, **6**), (**6**, **7**), 和 (**5**, **8**)。总权重等于40。右侧显示了另一个生成树。这里考虑了以下边：(**1**,
    **2**), (**1**, **3**), (**2**, **4**), (**4**, **8**), (**5**, **8**), (**5**,
    **6**), 和 (**6**, **7**)。总权重等于31。
- en: 'However, neither of the preceding spanning trees is the **minimum spanning
    tree** (**MST**) of this graph. What does it mean that a spanning tree is *minimum*?
    The answer is really simple: it is a spanning tree with the minimum cost from
    all spanning trees available in the graph. You can get the MST by replacing the
    edge (**6**, **7**) with (**5**, **7**). Then, the cost is equal to 30\. It is
    also worth mentioning that the number of edges in a spanning tree is equal to
    the number of nodes minus one.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前述的生成树都不是该图的最小生成树（MST）。生成树是*最小*的是什么意思？答案非常简单：它是图中所有生成树中成本最低的生成树。您可以通过用（5，7）替换（6，7）边来获得最小生成树。然后，成本等于30。还值得一提的是，生成树中的边数等于节点数减一。
- en: Why is the topic of the MST so important? Let's imagine a scenario when you
    need to connect many buildings to a telecommunication cable. Of course, there
    are various possible connections, such as from one building to another, or using
    a hub. What is more, environmental conditions can have a serious impact on the
    cost of the investment due to the necessity of crossing a road or even a river.
    Your task is to successfully connect all buildings to the telecommunication cable
    with the lowest possible cost. How should you design the connections? To answer
    this question, you just need to create a graph, where nodes represent connectors
    and edges indicate possible connections. Then, you find the MST, and that's all!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么最小生成树的主题如此重要？让我们想象一个场景，当您需要将许多建筑物连接到电信电缆时。当然，有各种可能的连接，例如从一个建筑物到另一个建筑物，或者使用中心。而且，环境条件可能会严重影响投资成本，因为需要穿越道路甚至河流。您的任务是以尽可能低的成本成功将所有建筑物连接到电信电缆。您应该如何设计连接？要回答这个问题，您只需要创建一个图，其中节点表示连接器，边表示可能的连接。然后，找到最小生成树，就这样！
- en: The afore mentioned problem of connecting many buildings to the telecommunication
    cable is presented in the example at the end of the section regarding the MST.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述连接许多建筑物到电信电缆的问题在最小生成树的相关部分结束时的示例中进行了介绍。
- en: The next question is how you can find the MST? There are various approaches
    to solve this problem, including the application of Kruskal's or Prim's algorithms,
    which are presented and explained in the following sections.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题是如何找到最小生成树？有各种方法来解决这个问题，包括应用Kruskal或Prim算法，这些算法在下面的部分中进行了介绍和解释。
- en: Kruskal's algorithm
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kruskal算法
- en: One of the algorithms for finding the MST was discovered by Kruskal. Its operation
    is very simple to explain. The algorithm takes an edge with the minimum weight
    from the remaining ones and adds it to the MST, only if adding it does not create
    a cycle. The algorithm stops when all nodes are connected.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 找到最小生成树的算法之一是由Kruskal发现的。它的操作非常简单。该算法从剩余的边中取出权重最小的边，并将其添加到最小生成树中，只有在添加它不会创建循环时才这样做。当所有节点连接时，算法停止。
- en: 'Let''s take a look at the diagram that presents the steps of finding the MST
    using **Kruskal''s algorithm**:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下使用Kruskal算法找到最小生成树的步骤的图表：
- en: '![](img/f5ee36e3-7ca4-425f-8907-e1830736b7bc.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5ee36e3-7ca4-425f-8907-e1830736b7bc.png)'
- en: In the first step, the edge (**5**, **8**) is chosen, because it has the minimum
    weight, namely **1**. Then, the edges (**1**, **2**), (**2**, **4**), (**5**,
    **6**), (**1**, **3**), (**5**, **7**), and (**4**, **8**) are selected. It is
    worth noting that before taking the (**4**, **8**) edge, the (**6**, **7**) one
    is considered, due to lower weight. However, adding it to the MST will introduce
    a cycle formed by (**5**, **6**), (**6**, **7**), and (**5**, **7**) edges. For
    this reason, such an edge is ignored and the algorithm chooses the edge (**4**,
    **8**). At the end, the number of edges in the MST is 7\. The number of nodes
    is equal to **8**, so it means that the algorithm can stop operating and the MST
    is found.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一步中，选择边（5，8），因为它的权重最小，即1。然后选择边（1，2），（2，4），（5，6），（1，3），（5，7）和（4，8）。值得注意的是，在选择（4，8）边之前，考虑了（6，7）边，因为它的权重更低。然而，将其添加到最小生成树中将会引入由（5，6），（6，7）和（5，7）边组成的循环。因此，忽略这样的边，算法选择了边（4，8）。最后，最小生成树中的边数为7。节点数等于8，这意味着算法可以停止运行并找到最小生成树。
- en: 'Let''s take a look at the implementation. It involves the `MinimumSpanningTreeKruskal`
    method, which should be added to the `Graph` class. The proposed code is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下实现。它涉及到`MinimumSpanningTreeKruskal`方法，应该添加到`Graph`类中。建议的代码如下：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The method does not take any parameters. To start, a list of edges is obtained
    by calling the `GetEdges` method. Then, the edges are sorted in ascending order
    by weight. Such a step is crucial, because you need to get an edge with the minimum
    cost in the following iterations of the algorithm. In the next line, a new queue
    is created and `Edge` instances are enqueued, using the constructor of the `Queue`
    class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法不接受任何参数。首先，通过调用`GetEdges`方法获得边的列表。然后，按权重升序对边进行排序。这一步非常关键，因为您需要在算法的后续迭代中获得具有最小成本的边。在下一行，创建一个新的队列，并使用`Queue`类的构造函数将`Edge`实例入队。
- en: In the next block of code, an array with data of subsets is created. By default,
    each node is added to a separate subset. It is the reason why the number of elements
    in the `subsets` array is equal to the number of nodes. The subsets are used to
    check whether an addition of an edge to the MST causes the creation of a cycle.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一段代码中，创建了一个包含子集数据的数组。默认情况下，每个节点都被添加到一个单独的子集中。这就是为什么`subsets`数组中的元素数量等于节点数的原因。这些子集用于检查将边添加到最小生成树是否会导致创建循环。
- en: Then, the list for storing edges from the MST is created (`result`). The most
    interesting part of code is the `while` loop, which iterates until the correct
    number of edges is found in the MST. Within the loop, you get the edge with the
    minimum weight, just by calling the `Dequeue` method on the `Queue` instance.
    Then, you check whether no cycles were introduced by adding the found edge to
    the MST. In such a case, the edge is added to the target list and the `Union`
    method is called to union two subsets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建用于存储来自MST的边的列表（`result`）。代码中最有趣的部分是`while`循环，它迭代直到在MST中找到正确数量的边。在循环内，通过在`Queue`实例上调用`Dequeue`方法来获取具有最小权重的边。然后，检查添加找到的边是否引入了循环。在这种情况下，将边添加到目标列表，并调用`Union`方法来合并两个子集。
- en: 'While analyzing the previous method, the `GetRoot` one is mentioned. Its aim
    is to update parents for subsets, as well as return the root node of the subset,
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析前面的方法时，提到了`GetRoot`方法。它的目的是更新子集的父节点，并返回子集的根节点。
- en: '[PRE26]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The last private method is named `Union` and performs the union operation (by
    a rank) of two sets. It takes three parameters, namely an array of `Subset` instances
    and two `Node` instances, representing root nodes for subsets on which the union
    operation should be performed. The suitable part of code is as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个私有方法名为`Union`，执行两个集合的联合操作（按秩）。它接受三个参数，即`Subset`实例的数组和两个`Node`实例，表示应在其上执行联合操作的子集的根节点。代码的适当部分如下：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the previous code snippets, you can see the `Subset` class, but what does
    it look like? Let''s take a look at its declaration:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您可以看到`Subset`类，但它是什么样子的呢？让我们看一下它的声明：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The class contains properties representing the parent node (`Parent`), as well
    as the rank of the subset (`Rank`). The class has also overridden the `ToString`
    method, which presents some basic information about the subset in textual form.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 该类包含代表父节点（`Parent`）和子集秩（`Rank`）的属性。该类还重写了`ToString`方法，以文本形式呈现有关子集的一些基本信息。
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/).
    You can also find more information about Kruskal's algorithm there.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的代码基于[https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/](https://www.geeksforgeeks.org/greedy-algorithms-set-2-kruskals-minimum-spanning-tree-mst/)中显示的实现。您还可以在那里找到有关Kruskal算法的更多信息。
- en: 'Let''s take a look at the usage of the `MinimumSpanningTreeKruskal` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`MinimumSpanningTreeKruskal`方法的用法：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MinimumSpanningTreeKruskal` method to find the
    MST using Kruskal's algorithm. At the end, you use the `ForEach` method to write
    the data of each edge from the MST in the console.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化一个无向加权图，并添加节点和边。然后，调用`MinimumSpanningTreeKruskal`方法，使用Kruskal算法找到MST。最后，使用`ForEach`方法将MST中每条边的数据写入控制台。
- en: Prim's algorithm
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Prim算法
- en: Another solution to solve the problem of finding the MST is **Prim's algorithm**.
    It uses two sets of nodes which are disjointed, namely the nodes located in the
    MST and the nodes that are not placed there yet. In the following iterations,
    the algorithm finds an edge with the minimum weight that connects a node from
    the first group with a node from the second group. The node of the edge, which
    is not already in the MST, is added to this set.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决查找MST问题的另一种方法是**Prim算法**。它使用两组不相交的节点，即位于MST中的节点和尚未放置在那里的节点。在接下来的迭代中，算法找到连接第一组节点和第二组节点的具有最小权重的边。尚未在MST中的边的节点将被添加到此集合中。
- en: 'The preceding description sounds quite simple, doesn''t it? Let''s see it in
    action by analyzing the diagram presenting the steps of finding the MST using
    Prim''s algorithm:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的描述听起来相当简单，不是吗？让我们通过分析图表，看看使用Prim算法找到MST的步骤：
- en: '![](img/ee23c538-4e24-4625-b17d-b734be8dabac.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee23c538-4e24-4625-b17d-b734be8dabac.png)'
- en: Let's take a look at the additional indicators added next to the nodes in the
    graph. They present the minimum weight necessary to reach such a node from any
    of its neighbors. By default, the starting node has such a value set to **0**,
    while all others are set to infinity.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一看图中节点旁边添加的额外指示器。它们表示从任何邻居到达该节点所需的最小权重。默认情况下，起始节点的此值设置为**0**，而其他所有节点均设置为无穷大。
- en: 'In **Step #2**, the starting node is added to the subset of nodes forming the
    MST and the distance to its neighbors is updated, namely **5** for reaching the
    node **3** and **3** for reaching the node **2**.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在**步骤#2**中，将起始节点添加到形成MST的节点子集中，并更新到其邻居的距离，即到达节点**3**的距离为**5**，到达节点**2**的距离为**3**。
- en: In the next step (that is **Step #3**), the node with the minimum cost is chosen.
    In this case, the node **2** is selected, because the cost is equal to **3**.
    Its competitor (namely the node **3**) has a cost equal to **5**. Next, you need
    to update the cost of reaching the neighbors of the current node, namely the node
    **4** with the cost set to **4**.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步（即**步骤#3**）中，选择具有最小成本的节点。在这种情况下，选择节点**2**，因为成本等于**3**。它的竞争对手（即节点**3**）的成本等于**5**。接下来，您需要更新到达当前节点的邻居的成本，即将节点**4**的成本设置为**4**。
- en: 'The next chosen node is obviously the node **4**, because it does not exist
    in the MST set and has the lowest reaching cost (**Step #4**). In the same way,
    you choose the next edges in the following order: (**1**, **3**), (**4**, **8**),
    (**8**, **5**), (**5**, **6**), and (**5**, **7**). Now, all nodes are included
    in the MST and the algorithm can stop its operation.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，下一个选择的节点是节点**4**，因为它不存在于MST集合中，并且具有最低的到达成本（**步骤#4**）。以相同的方式，按以下顺序选择下一个边：（**1**，**3**），（**4**，**8**），（**8**，**5**），（**5**，**6**）和（**5**，**7**）。现在，所有节点都包含在MST中，算法可以停止其操作。
- en: 'Given this detailed description of the steps of the algorithm, let''s proceed
    to the C#-based implementation. The majority of operations are performed in the
    `MinimumSpanningTreePrim` method, which should be added to the `Graph` class:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于对算法步骤的详细描述，让我们继续进行基于C#的实现。大部分操作都在`MinimumSpanningTreePrim`方法中执行，应将其添加到`Graph`类中：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `MinimumSpanningTreePrim` method does not take any parameters. It uses three
    auxiliary node-related arrays that assign additional data to the nodes of the
    graph. The first, namely `previous`, stores indices of the previous node, from
    which the given node can be reached. By default, values of all elements are equal
    to `0`, except the first one, which is set to `-1`. The `minWeight` array stores
    the minimum weight of the edge for accessing the given node. By default, all elements
    are set to the maximum value of the `int` type, while the value for the first
    element is set to `0`. The `isInMST` array indicates whether the given node is
    already in the MST. To start with, values of all elements should be set to `false`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`MinimumSpanningTreePrim`方法不接受任何参数。它使用三个辅助的与节点相关的数组，为图的节点分配附加数据。首先，即`previous`存储先前节点的索引，可以从该节点到达给定节点。默认情况下，所有元素的值都相等为`0`，除了第一个元素，它设置为`-1`。`minWeight`数组存储访问给定节点的边的最小权重。默认情况下，所有元素都设置为`int`类型的最大值，而第一个元素的值设置为`0`。`isInMST`数组指示给定节点是否已经在MST中。首先，所有元素的值都应设置为`false`。'
- en: The most interesting part of code is located in the `for` loop. Within it, the
    index of the node from the set of nodes not located in the MST, which can be reached
    with the minimum cost, is found. Such a task is performed by the `GetMinimumWeightIndex`
    method. Then, another `for` loop is used. Within it, you get an edge that connects
    nodes with the index `minWeightIndex` and `j`. You check whether the node is not
    already located in the MST and whether the cost of reaching the node is smaller
    than the previous minimum cost. If so, values of node-related elements in the
    `previous` and `minWeight` arrays are updated.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分位于`for`循环中。在其中，找到未位于MST中的节点集合中可以以最小成本到达的节点的索引。`GetMinimumWeightIndex`方法执行此任务。然后，使用另一个`for`循环。在其中，获取连接具有索引`minWeightIndex`和`j`的节点的边。检查节点是否尚未位于MST中，以及到达节点的成本是否小于先前的最小成本。如果是，则更新`previous`和`minWeight`数组中与节点相关的元素的值。
- en: The remaining part of the code just prepares the final results. Here, you create
    a new instance of the list with the data of edges that form the MST. The `for`
    loop is used to get the data of the following edges and to add them to the `result`
    list.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的其余部分只是准备最终结果。在这里，创建一个新的带有形成MST的边数据的列表的实例。使用`for`循环获取以下边的数据，并将它们添加到`result`列表中。
- en: 'While analyzing the code, the `GetMinimumWeightIndex` private method is mentioned.
    Its code is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析代码时，提到了`GetMinimumWeightIndex`私有方法。其代码如下：
- en: '[PRE31]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `GetMinimumWeightIndex` method just finds an index of the node, which is
    not located in the MST and can be reached with the minimum cost. To do so, you
    use the `for` loop to iterate through all nodes. For each of them, you check whether
    the current node is not located in the MST and whether the cost of reaching it
    is smaller than the already-stored minimum value. If so, values of the `minValue`
    and `minIndex` variables are updated. At the end, the index is returned.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetMinimumWeightIndex`方法只是找到一个索引，该索引是未位于MST中且可以以最小成本到达的节点的索引。为此，使用`for`循环遍历所有节点。对于每个节点，检查当前节点是否未位于MST中，以及到达它的成本是否小于已存储的最小值。如果是，则更新`minValue`和`minIndex`变量的值。最后，返回索引。'
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/).
    You can also find more information about Prim's algorithm there.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 所示的代码基于[https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/](https://www.geeksforgeeks.org/greedy-algorithms-set-5-prims-minimum-spanning-tree-mst-2/)中显示的实现。您还可以在那里找到有关Prim算法的更多信息。
- en: 'What is more, the auxiliary `Fill` method is used. It just sets the values
    of all elements in the array to the value passed as the second parameter. The
    code of the method is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还使用了辅助的`Fill`方法。它只是将数组中所有元素的值设置为作为第二个参数传递的值。该方法的代码如下：
- en: '[PRE32]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s take a look at the usage of the `MinimumSpanningTreePrim` method:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`MinimumSpanningTreePrim`方法的用法：
- en: '[PRE33]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: First, you initialize an undirected and weighted graph, as well as add nodes
    and edges. Then, you call the `MinimumSpanningTreePrim` method to find the MST
    using Prim's algorithm. At the end, you use the `ForEach` method to write the
    data of each edge from the MST in the console.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，初始化一个无向加权图，并添加节点和边。然后，调用`MinimumSpanningTreePrim`方法使用Prim算法找到MST。最后，使用`ForEach`方法将MST中每条边的数据写入控制台。
- en: Example – telecommunication cable
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-通信电缆
- en: 'As mentioned in the introduction to the topic of the MST, this problem has
    some important real-world applications, such as for creating a plan of connections
    between buildings to supply all of them with a telecommunication cable with the
    smallest cost. Of course, there are various possible connections, such as from
    one building to another or using a hub. What is more, environmental conditions
    can have serious impact on the cost of the investment due to the necessity of
    crossing a road or even a river. For example, let''s create the program that solves
    this problem in the context of the set of buildings, as shown in the following
    diagram:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在MST主题的介绍中提到的，这个问题有一些重要的现实应用，比如为建筑物之间的连接创建一个供给所有建筑物的通信电缆的计划，成本最小。当然，有各种可能的连接，比如从一个建筑物到另一个建筑物，或者使用一个中心。此外，环境条件可能会对投资成本产生严重影响，因为需要穿越道路甚至河流。例如，让我们创建一个解决这个问题的程序，该程序在以下图表中显示了建筑物集合的上下文：
- en: '![](img/d0d94024-3527-415b-b829-0f7ab8e73b81.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d0d94024-3527-415b-b829-0f7ab8e73b81.png)'
- en: As you can see, the estate community consists of 12 buildings, including blocks
    of flats and kiosks located by the river. The buildings are located on two sides
    of a small river with only one bridge. Moreover, two roads exist. Of course, there
    are different costs of connections between various points, depending both on the
    distance and the environmental conditions. For example, the direct connection
    between two buildings (**B1** and **B2**) has a cost equal to **2**, while using
    the bridge (between **R1** and **R5**) involves a cost equal to **75**. If you
    need to cross the river without a bridge (between **R3** and **R6**), the cost
    is even higher and equal to **100**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，房地产社区由12栋建筑组成，包括位于河边的公寓楼和小亭。建筑物位于一条小河的两侧，只有一座桥。此外，还有两条道路。当然，连接各个点之间的成本各不相同，这取决于距离和环境条件。例如，两栋建筑物（**B1**和**B2**）之间的直接连接成本为**2**，而使用桥（**R1**和**R5**之间）的成本为**75**。如果您需要在没有桥的情况下穿过河流（**R3**和**R6**之间），成本甚至更高，为**100**。
- en: 'Your task is to find the MST. Within this example, you will apply both Kruskal''s
    and Prim''s algorithms to solve this problem. To start, let''s initialize the
    undirected and weighted graph, as well as add nodes and edges, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 您的任务是找到MST。在此示例中，您将应用Kruskal和Prim算法来解决此问题。首先，让我们初始化无向加权图，并添加节点和边，如下所示：
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, you just need to call the `MinimumSpanningTreeKruskal` method to use
    Kruskal''s algorithm to find the MST. When the results are obtained, you can easily
    present them in the console, together with the presentation of the total cost.
    The suitable part of code is shown in the following block:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您只需要调用`MinimumSpanningTreeKruskal`方法来使用Kruskal算法找到MST。当结果获得时，您可以轻松地在控制台中呈现它们，同时呈现总成本。代码的适当部分如下所示：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The results presented in the console are shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中呈现的结果如下所示：
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you visualize such results on the map, the following MST is found:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在地图上可视化这样的结果，将找到以下MST：
- en: '![](img/83e8b4f4-5b14-4e99-a011-47a7f5e4e48d.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83e8b4f4-5b14-4e99-a011-47a7f5e4e48d.png)'
- en: 'In a similar way, you can apply Prim''s algorithm:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以应用Prim算法：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The obtained results are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的结果如下：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's all! You have just completed the example relating to the real-world application
    of the MST. Are you ready to proceed to another graph-related subject, which is
    named coloring?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您刚刚完成了与MST的实际应用相关的示例。您准备好继续进行另一个与图相关的主题了吗？它被称为着色。
- en: Coloring
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色
- en: The topic of finding the MST is not the only graph-related problem. Among others, **node
    coloring** exists. Its aim is to assign colors (numbers) to all nodes to comply
    with the rule that there cannot be an edge between two nodes with the same color.
    Of course, the number of colors should be as low as possible. Such a problem has
    some real-world applications, such as for coloring a map, which is the topic of
    the example shown later.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找MST并不是唯一与图相关的问题。其中包括**节点着色**。其目的是为所有节点分配颜色（数字），以符合不能存在相同颜色的两个节点之间的边的规则。当然，颜色的数量应尽可能少。这样的问题在现实世界中有一些应用，例如着色地图，这是稍后显示的示例的主题。
- en: Did you know that the nodes of each planar graph can be colored with no more
    than four colors? If you are interested in this topic, take a look at the **four-color
    theorem** ([http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html)).
    The implementation of the coloring algorithm shown in this chapter is simple and
    in some cases could use more colors than really necessary.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道每个平面图的节点最多可以用四种颜色着色吗？如果您对此话题感兴趣，请查看**四色定理**（[http://mathworld.wolfram.com/Four-ColorTheorem.html](http://mathworld.wolfram.com/Four-ColorTheorem.html)）。本章中所示的着色算法的实现简单，并且在某些情况下可能使用比实际需要更多的颜色。
- en: 'Let''s take a look at the following diagram:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下图表：
- en: '![](img/63167778-a260-403b-9e82-ff572d8b399f.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63167778-a260-403b-9e82-ff572d8b399f.png)'
- en: 'The first diagram (shown on the left) presents a graph that is colored using
    four colors: red (index equal to **0**), green (**1**), blue (**2**), and violet
    (**3**). As you can see, there are no nodes with the same colors connected by
    an edge. The graph shown on the right depicts the graph with two additional edges,
    namely (**2**, **6**) and (**2**, **5**). In such a case, the coloring has changed,
    but the number of colors remains the same.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个图表（左侧显示）呈现了使用四种颜色着色的图：红色（索引等于**0**），绿色（**1**），蓝色（**2**）和紫罗兰色（**3**）。如您所见，没有使用相同颜色的节点通过边连接。右侧显示的图表描绘了具有两条额外边的图，即（**2**，**6**）和（**2**，**5**）。在这种情况下，着色已更改，但颜色数量保持不变。
- en: 'The question is, how can you find colors for nodes to comply with the afore
    mentioned rule? Fortunately, the algorithm is very simple and its implementation
    is presented here. The code of the `Color` method, which should be added to the
    `Graph` class, is as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，您如何找到节点的颜色以符合上述规则？幸运的是，算法非常简单，其实现在此处呈现。应添加到`Graph`类的`Color`方法的代码如下：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Color` method uses two auxiliary node-related arrays. The first is named
    `colors` and stores indices of colors chosen for particular nodes. By default,
    values of all elements are set to `-1`, except the first one, which is set to
    `0`. It means that the color of the first node is automatically set to the first
    color (for example, red). The other auxiliary array (`availability`) stores information
    about the availability of particular colors.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color`方法使用两个辅助节点相关数组。第一个名为`colors`，存储为特定节点选择的颜色的索引。默认情况下，所有元素的值都设置为`-1`，除了第一个元素，它设置为`0`。这意味着第一个节点的颜色自动设置为第一个颜色（例如红色）。另一个辅助数组（`availability`）存储有关特定颜色的可用性的信息。'
- en: The most crucial part of the code is the `for` loop. Within it, you reset the
    availability of colors by setting `true` as the value of all elements within the
    `availability` array. Then, you iterate through the neighbor nodes of the current
    node to read their colors and mark such colors as unavailable by setting `false`
    as a value of a particular element in the `availability` array. The last inner
    `for` loop just iterates through the `availability` array and finds the first
    available color for the current node.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最关键部分是`for`循环。在其中，通过将`true`设置为`availability`数组中所有元素的值，重置颜色的可用性。然后，你遍历当前节点的相邻节点，读取它们的颜色，并通过将`false`设置为`availability`数组中特定元素的值，标记这些颜色为不可用。最后的内部`for`循环只是遍历`availability`数组，并找到当前节点的第一个可用颜色。
- en: The presented code is based on the implementation shown at [https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/](https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/).
    What is more, you can find more information about the coloring problem there.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现的代码基于[https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/](https://www.geeksforgeeks.org/graph-coloring-set-2-greedy-algorithm/)中展示的实现。此外，你可以在那里找到有关着色问题的更多信息。
- en: 'What is more, the auxiliary `Fill` method is used with exactly the same code,
    as explained in one of the previous examples. It just sets the values of all elements
    in the array to the value passed as the second parameter. The code of the method
    is as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，辅助的`Fill`方法与之前的示例中解释的完全相同的代码一起使用。它只是将数组中所有元素的值设置为作为第二个参数传递的值。方法的代码如下：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s take a look at the usage of the `Color` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`Color`方法的用法：
- en: '[PRE41]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, you create a new undirected and unweighted graph, add nodes and edges,
    and call the `Color` method to perform the node coloring. As a result, you receive
    an array with indices of colors for particular nodes. Then, you present the results
    in the console:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个新的无向无权图，添加了节点和边，并调用`Color`方法来执行节点着色。结果，你收到了一个包含特定节点颜色索引的数组。然后，你在控制台中呈现结果：
- en: '[PRE42]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: After this short introduction you are ready to proceed to the real-world application,
    namely for coloring the voivodeship map, which is presented next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，你已经准备好继续进行真实世界的应用，即对省份地图进行着色，接下来将会呈现。
- en: Example – voivodeship map
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例 - 省份地图
- en: Let's create a program that represents the map of voivodeships in Poland as
    a graph, and color such areas so that two voivodeships with common borders do
    not have the same color. Of course, you should limit the number of colors.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个代表波兰省份地图的程序，将其表示为一个图，并对这些区域进行着色，以便具有共同边界的两个省份不具有相同的颜色。当然，你应该限制颜色的数量。
- en: To start, let's think about the graph representation. Here, nodes represent
    particular voivodeships, while edges represent common borders between voivodeships.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑图的表示。在这里，节点代表特定的省份，而边代表省份之间的共同边界。
- en: 'The map of Poland with the graph already colored is shown in the following
    diagram:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 已经着色的波兰地图如下图所示：
- en: '![](img/876d451d-6a0b-47e8-b31c-d49027b05301.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/876d451d-6a0b-47e8-b31c-d49027b05301.png)'
- en: 'Your task is just to color nodes in the graph using the already-described algorithm.
    To do so, you create the undirected and unweighted graph, add nodes representing
    voivodeships, and add edges to indicate common borders. The code is as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务就是使用已经描述的算法对图中的节点进行着色。为此，你创建无向无权图，添加代表省份的节点，并添加边来表示共同的边界。代码如下：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then, the `Color` method is called on the `Graph` instance and the color indices
    for particular nodes are returned. At the end, you just present the results in
    the console. The suitable part of code is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Graph`实例上调用`Color`方法，并返回特定节点的颜色索引。最后，你只需在控制台中呈现结果。代码的适当部分如下所示：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Part of the results is presented as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 部分结果如下所示：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You have just learnt how to color nodes in the graph! However, this is not the
    end of the interesting topics regarding graphs that are presented within this
    book. Now, let's proceed to searching for the shortest path in the graph.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了如何给图中的节点着色！然而，这并不是本书中介绍的关于图的有趣主题的结束。现在，让我们继续搜索图中的最短路径。
- en: Shortest path
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最短路径
- en: A graph is a great data structure for storing the data of various maps, such
    as cities and the distances between them. For this reason, one of the obvious
    real-world applications of graphs is searching for the **shortest path** between
    two locations, which takes into account a specific cost, such as the distance,
    the necessary time, or even the amount of fuel required.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图是一个用于存储各种地图数据的优秀数据结构，例如城市和它们之间的距离。因此，图的一个明显的真实世界应用之一是搜索两个位置之间的**最短路径**，考虑到特定的成本，例如距离、所需时间，甚至所需燃料的数量。
- en: There are several approaches to the topic of searching for the shortest path
    in a graph. However, one of the common solutions is **Dijkstra's algorithm**,
    which makes it possible to calculate distance from a starting node to all nodes
    located in the graph. Then, you can easily get not only the cost of connection
    between two nodes, but also find nodes that are between the start and end nodes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在图中搜索最短路径有几种方法。然而，其中一个常见的解决方案是**Dijkstra算法**，它可以计算从起始节点到图中所有节点的距离。然后，你不仅可以轻松地获得两个节点之间的连接成本，还可以找到位于起始节点和结束节点之间的节点。
- en: Dijkstra's algorithm uses two auxiliary node-related arrays, namely for storing
    an identifier of the previous node—the node from which the current node can be
    reached with the smallest overall cost, as well as the minimum distance (cost),
    which is necessary for accessing the current node. What is more, it uses the queue
    for storing nodes that should be checked. During the consecutive iterations, the
    algorithm updates the minimum distances to particular nodes in the graph. At the
    end, the auxiliary arrays contain the minimum distance (cost) to reach all the
    nodes from the chosen starting node, as well as information on how to reach each
    node using the shortest path.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法使用两个辅助节点相关数组，分别用于存储前一个节点的标识符（可以通过最小总成本到达当前节点的节点），以及访问当前节点所需的最小距离（成本）。此外，它使用队列来存储应该被检查的节点。在连续的迭代中，算法更新图中特定节点的最小距离。最后，辅助数组包含了从选择的起始节点到达所有节点的最小距离（成本），以及如何使用最短路径到达每个节点的信息。
- en: 'Before proceeding to the example, let''s take a look at the following diagram
    presenting two various shortest paths found using Dijkstra''s algorithm. The left-hand
    side shows the path from the node **8** to **1**, while the right-hand side shows
    the path from the node **1** to **7**:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续示例之前，让我们看一下以下图表，展示了使用Dijkstra算法找到的两条不同的最短路径。左侧显示了从节点**8**到**1**的路径，而右侧显示了从节点**1**到**7**的路径：
- en: '![](img/8d62b464-51f2-48f8-a815-63207ac35c59.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d62b464-51f2-48f8-a815-63207ac35c59.png)'
- en: 'It is high time that you see some C# code, which can be used to implement Dijkstra''s
    algorithm. The main role is performed by the `GetShortestPathDijkstra` method,
    which should be added to the `Graph` class. The code is as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候看一些C#代码了，这些代码可以用来实现Dijkstra算法。主要作用由`GetShortestPathDijkstra`方法执行，该方法应添加到`Graph`类中。代码如下：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `GetShortestPathDijkstra` method takes two parameters, namely `source` and
    `target` nodes. To start, it creates two node-related auxiliary arrays for storing
    the indices of previous nodes, from which the given node can be reached with the
    smallest overall cost (`previous`), as well as for storing the current minimum
    distances to the given node (`distances`). By default, the values of all elements
    in the `previous` array are set to `-1`, while in the `distances` array they are
    set to the maximum value of the `int` type. Of course, the distance to the source
    node is set to `0`. Then, you create a new priority queue, and enqueue the data
    of all nodes. The priority of each element is equal to the current distance to
    such a node.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetShortestPathDijkstra`方法接受两个参数，即`source`和`target`节点。首先，它创建了两个与节点相关的辅助数组，用于存储前一个节点的索引，从中可以以最小总成本到达给定节点（`previous`），以及用于存储到给定节点的当前最小距离（`distances`）。默认情况下，`previous`数组中所有元素的值都设置为`-1`，而在`distances`数组中它们设置为`int`类型的最大值。当然，到源节点的距离设置为`0`。然后，创建一个新的优先队列，并将所有节点的数据入队。每个元素的优先级等于到达该节点的当前距离。'
- en: It is worth noting that the example uses the `OptimizedPriorityQueue` package
    from NuGet. More information about this package is available at [https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue)
    and in the *Priority queues* section in [Chapter 3](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml),
    *Stacks and Queues*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，示例使用了NuGet中的`OptimizedPriorityQueue`包。有关此包的更多信息，请访问[https://www.nuget.org/packages/OptimizedPriorityQueue](https://www.nuget.org/packages/OptimizedPriorityQueue)，以及[第3章](c0fd3ad7-ebfd-4df4-ae4a-fda9573a2b40.xhtml)中的*优先队列*部分。
- en: The most interesting part of the code is the `while` loop which is executed
    until the queue is empty. Within the `while` loop, you get the first node from
    the queue and iterate through all of its neighbors using the `for` loop. Inside
    such a loop, you calculate the distance to a neighbor by taking the sum of the
    distance to the current node and the weight of the edge. If the calculated distance
    is smaller than the currently-stored value, you update the values regarding the
    minimum distance to the given neighbor, as well as the index of the previous node,
    from which you can reach the neighbor. It is worth noting that the priority of
    the element in the queue should be updated as well.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中最有趣的部分是`while`循环，该循环执行直到队列为空。在`while`循环中，您从队列中获取第一个节点，并使用`for`循环迭代其所有邻居。在这样的循环内部，通过将当前节点的距离和边的权重相加来计算到邻居的距离。如果计算出的距离小于当前存储的值，则更新关于给定邻居的最小距离的值，以及可以到达邻居的前一个节点的索引。值得注意的是，队列中元素的优先级也应该更新。
- en: The remaining operations are used to resolve the path using the values stored
    in the `previous` array. To do so, you save indices of the following nodes (in
    the opposite direction) in the `indices` list. Then, you reverse it to achieve
    the order from the source node to the target one. At the end, you just create
    the list of edges to present the result in the form suitable for returning from
    the method.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 其余操作用于使用`previous`数组中存储的值解析路径。为此，您将下一个节点的索引（相反方向）保存在`indices`列表中。然后，您将其反转以获得从源节点到目标节点的顺序。最后，您只需创建边的列表，以便以适合从方法返回的形式呈现结果。
- en: The presented and described implementation is based on the pseudocode shown
    at [https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).
    You can find some additional information about Dijkstra's algorithm there.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 所呈现和描述的实现是基于[https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)上显示的伪代码。您可以在那里找到有关Dijkstra算法的一些额外信息。
- en: 'Let''s take a look at the usage of the `GetShortestPathDijkstra` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下`GetShortestPathDijkstra`方法的用法：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here, you create a new directed and weighted graph, add nodes and edges, and
    call the `GetShortestPathDijkstra` method to search the shortest path between
    two nodes, namely between the nodes `1` and `5`. As a result, you receive a list
    of edges forming the shortest path. Then, you just iterate through all edges and
    present the results in the console:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个新的有向加权图，添加了节点和边缘，并调用了`GetShortestPathDijkstra`方法来搜索两个节点之间的最短路径，即节点`1`和`5`之间的路径。
    结果，您将收到形成最短路径的边缘列表。 然后，您只需遍历所有边缘并在控制台中呈现结果：
- en: '[PRE48]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: After this short introduction, together with the simple example, let's proceed
    to the more advanced and interesting application related to game development.
    Let's go!
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的介绍之后，再加上简单的示例，让我们继续进行更高级和有趣的与游戏开发相关的应用。 让我们开始吧！
- en: Example – game map
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例-游戏地图
- en: The last example shown in this chapter involves the application of Dijkstra's
    algorithm for finding the shortest path in a game map. Let's imagine that you
    have a board with various obstacles. For this reason, the player can use only
    part of the board to move. Your task is to find the shortest path between two
    places located on the board.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中显示的最后一个示例涉及应用Dijkstra算法来查找游戏地图中的最短路径。 假设您有一个带有各种障碍物的棋盘。 因此，玩家只能使用棋盘的一部分移动。
    您的任务是找到棋盘上两个位置之间的最短路径。
- en: 'To start, let''s represent the board as a two-dimensional array where a given
    position on the board can be available for movement or not. The suitable part
    of code should be added to the `Main` method in the `Program` class, as follows:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将棋盘表示为一个二维数组，其中棋盘上的给定位置可以用于移动或不可用。 适当的代码部分应添加到`Program`类中的`Main`方法中，如下所示：
- en: '[PRE49]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: To improve the readability of code, the map is represented as an array of `string`
    values. Each row is presented as text, with the number of characters equal to
    the number of columns. The value of each character indicates the availability
    of the point. If it is equal to `0`, the position is available. Otherwise, it
    is not. The `string`-based map representation should be then converted into the
    Boolean two-dimensional array. Such a task is performed by a few lines of code,
    as shown in the preceding snippet.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高代码的可读性，地图被表示为一个`string`值的数组。 每一行都以文本形式呈现，字符数等于列数。 每个字符的值表示点的可用性。 如果等于`0`，则该位置可用。
    否则，不可用。 然后，基于`string`的地图表示应转换为布尔型二维数组。 此任务由几行代码执行，如前面的代码片段所示。
- en: 'The next step is the creation of the graph, as well as adding the necessary
    nodes and edges. The suitable part of code is presented as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建图表，以及添加必要的节点和边缘。 适当的代码部分如下所示：
- en: '[PRE50]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: First, you initialize a new undirected and weighted graph. Then, you use two
    `for` loops to iterate through all places on the board. Within such loops, you
    check whether the given place is available. If so, you create a new node (`from`).
    Then, you check whether the node placed immediately above the current one is also
    available. If so, a suitable edge is added with the weight equal to `1`. In a
    similar way you check whether the node placed on the left of the current one is
    available and add an edge, if necessary.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您初始化了一个新的无向加权图。 然后，您使用两个`for`循环来迭代棋盘上的所有位置。 在这些循环内，您检查给定位置是否可用。 如果是，您创建一个新节点（`from`）。
    然后，您检查当前节点上方是否也可用。 如果是，将添加权重为`1`的适当边缘。 以类似的方式检查当前节点左侧是否可用，并在必要时添加边缘。
- en: 'Now you just need to get the `Node` instances representing the source and the
    target nodes. You can do it by using the `Find` method and providing the textual
    representation of the node, such as `0-0` or `16-24`. Then, you just call the
    `GetShortestPathDijkstra` method. In this case, the algorithm will try to find
    the shortest path between the node in the first row and column and the node in
    the last row and column. The code is as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要获取表示源节点和目标节点的`Node`实例。 您可以通过使用`Find`方法并提供节点的文本表示（例如`0-0`或`16-24`）来实现。
    然后，只需调用`GetShortestPathDijkstra`方法。 在这种情况下，算法将尝试找到第一行和列中的节点与最后一行和列中的节点之间的最短路径。
    代码如下：
- en: '[PRE51]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The last part of code is related to the presentation of the map in the console:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的最后部分与在控制台中呈现地图有关：
- en: '[PRE52]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To start, you set the proper encoding in the console to be able to present Unicode
    characters as well. Then, you use two `for` loops to iterate through all places
    on the board. Inside such loops, you choose a color that should be used to represent
    a point in the console, either green (the point is available) or red (unavailable).
    If the currently-analyzed point is a part of the shortest path, the color is changed
    to white. At the end, you just set a proper color and write the Unicode character
    representing a bullet. When the program execution exits both loops, the default
    console color is set.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在控制台中设置适当的编码，以便能够呈现Unicode字符。 然后，您使用两个`for`循环来迭代棋盘上的所有位置。 在这些循环内，您选择应用于在控制台中表示点的颜色，可以是绿色（点可用）或红色（不可用）。
    如果当前分析的点是最短路径的一部分，则颜色将更改为白色。 最后，您只需设置适当的颜色并写入表示子弹的Unicode字符。 当程序执行退出两个循环时，将设置默认的控制台颜色。
- en: 'When you run the application, you will see the following result:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，您将看到以下结果：
- en: '![](img/249c8656-1962-4bf7-abdf-4742c051434e.png)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![](img/249c8656-1962-4bf7-abdf-4742c051434e.png)'
- en: Great work! Now, let's proceed to a short summary to conclude the topics you
    have learnt about while reading the current chapter.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！ 现在，让我们进行简短的总结，以总结您在阅读本章时学到的内容。
- en: Summary
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: You have just completed the chapter related to one of the most important data
    structures available while developing applications, namely graphs. As you have
    learnt, a graph is a data structure that consists of nodes and edges. Each edge
    connects two nodes. What is more, there are various variants of edges in a graph,
    such as undirected and directed, as well as unweighted and weighted. All of them
    have been described and explained in detail, together with diagrams and code samples.
    Two methods of graph representation, namely using an adjacency list and an adjacency
    matrix, have been explained as well. Of course, you have also learnt how to implement
    a graph using the C# language.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚完成了与开发应用程序时最重要的数据结构之一，即图相关的章节。正如您所学到的，图是由节点和边组成的数据结构。每条边连接两个节点。此外，图中有各种变体的边，如无向和有向，以及无权重和有权重。所有这些都已经被详细描述和解释，还有图表和代码示例。图的两种表示方法，即使用邻接表和邻接矩阵，也已经被解释。当然，您还学会了如何使用C#语言实现图。
- en: While talking about graphs, is also important to present some real-world applications,
    especially due to the common use of such a data structure. For example, the chapter
    contains the description of the structure of friends available in social media
    or the problem of searching for the shortest path in a city.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论图时，也很重要介绍一些现实世界的应用，特别是由于这种数据结构的常见使用。例如，本章包含了社交媒体中可用的朋友结构的描述，或者在城市中搜索最短路径的问题。
- en: Among the topics in this chapter, you have got to know how to traverse a graph,
    that is, visit all of the nodes in some particular order. Two approaches have
    been presented, namely DFS and BFS. It is worth mentioning that the traversal
    topic can be also applied for searching for a given node in a graph.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的主题中，您已经了解了如何遍历图，即以某种特定顺序访问所有节点。介绍了两种方法，即深度优先搜索和广度优先搜索。值得一提的是，遍历主题也可以应用于在图中搜索给定节点。
- en: In one of the other sections, the subject of a spanning tree, as well as a minimum
    spanning tree, was introduced. As a reminder, a spanning tree is a subset of edges
    that connects all nodes in a graph without cycles, while a MST is a spanning tree
    with the minimum cost from all spanning trees available in the graph. There are
    a few approaches to finding the MST, including the application of Kruskal's or
    Prim's algorithms.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一节中，介绍了生成树和最小生成树的主题。提醒一下，生成树是连接图中所有节点而没有循环的边的子集，而最小生成树是具有图中所有可用生成树中最小成本的生成树。有几种方法可以找到最小生成树，包括Kruskal或Prim算法的应用。
- en: Then, you learnt solutions for the next two popular graph-related problems.
    The first was the coloring of nodes, where you needed to assign colors (numbers)
    to all nodes to comply with the rule that there cannot be an edge between two
    nodes with the same color. Of course, the number of colors should have been as
    low as possible.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了下面两个流行的与图相关的问题的解决方案。第一个是节点的着色，您需要为所有节点分配颜色（数字），以符合不能存在相同颜色的两个节点之间的边的规则。当然，颜色的数量应该尽可能少。
- en: The other problem was searching for the shortest path between two nodes, which
    took into account a specific cost, such as the distance, the necessary time, or
    even the amount of fuel required. There are several approaches to the topic of
    searching for the shortest path in a graph. However, one of the common solutions
    is Dijkstra's algorithm, which makes it possible to calculate the distance from
    a starting node to all nodes located in the graph. This topic has been presented
    and explained within this chapter.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是在两个节点之间搜索最短路径，考虑了特定的成本，比如距离、所需时间，甚至所需燃料的数量。在图中搜索最短路径有几种方法。然而，其中一个常见的解决方案是Dijkstra算法，它可以计算从起始节点到图中所有节点的距离。这个主题已经在本章中进行了介绍和解释。
- en: Now, it is the high time to proceed to the overall summary to take a look at
    all of the data structures and algorithms that have been presented in the book
    so far. Let's turn the page and proceed to the last chapter!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进行总结，看看到目前为止在书中介绍的所有数据结构和算法。让我们翻开书页，继续到最后一章！
