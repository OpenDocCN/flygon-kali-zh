- en: Day 04 - Discussing C# Class Members
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第04天 - 讨论C#类成员
- en: We are in day four of our seven-day learning series. On day two, we discussed
    the typical C# program, and you understood how to compile and execute the program.
    We discussed the `Main` method and its use. We also discussed the reserved keywords
    of language C#, and then, we got an overview of classes and structures in C#.
    On day three, we discussed all the new features introduced in C#7.0.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在进行为期七天的学习系列的第四天。在第二天，我们讨论了典型的C#程序，并了解了如何编译和执行程序。我们讨论了`Main`方法及其用途。我们还讨论了语言C#的保留关键字，然后我们对C#中的类和结构进行了概述。在第三天，我们讨论了C#7.0中引入的所有新功能。
- en: In this chapter, the fundamentals of C# methods and properties will be explained,
    and we will also cover the concept of indexers in C#. The string manipulation
    discussed on day two will be extended through RegEx, and we will explain why it
    is powerful. File management will be covered along with some medium-level file
    system observers.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将解释C#方法和属性的基础知识，我们还将涵盖C#中索引器的概念。在第二天讨论的字符串操作将通过RegEx进行扩展，并解释为什么它很强大。文件管理将与一些中级文件系统观察者一起讨论。
- en: 'Today, we will cover C# classes in more depth. This chapter will cover the
    following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们将更深入地讨论C#类。本章将涵盖以下主题：
- en: Modifiers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修饰符
- en: Methods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性
- en: Indexers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引器
- en: File I/O
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件I/O
- en: Exception handling
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Discussing regular expression and its importance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论正则表达式及其重要性
- en: On day two, we discussed a typical C# program, and we discussed how a program
    can be compiled and executed. What is the use/importance of the `Main` method?
    We will carry forward the same discussion and start our day four.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二天，我们讨论了一个典型的C#程序，并讨论了程序如何编译和执行。`Main`方法的用途/重要性是什么？我们将继续讨论并开始我们的第四天。
- en: 'Before we start, let''s go through the steps of our program in the String calculator
    ([https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)).
    There is a simple requirement to add numbers that are provided as a string. Here
    is a simple code snippet on the basis of this one-liner requirement that does
    not mention how many numbers are needed to be supplied in a string:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们通过字符串计算器程序的步骤（[https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator](https://github.com/garora/TDD-Katas/tree/develop/Src/cs/StringCalculator)）进行一下。有一个简单的要求，即将作为字符串提供的数字相加。以下是一个简单的代码片段，基于这个一句要求，它没有提到需要在字符串中提供多少个数字：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We will get the following output when we run the preceding code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上述代码时，我们将获得以下输出：
- en: '![](img/00051.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00051.jpeg)'
- en: 'The preceding code is working fine and giving us the expected results. The
    requirements that we discussed previously are very limited and vague. Let''s elaborate
    on the initial requirement:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码运行良好，并给出了预期的结果。我们之前讨论的要求非常有限和模糊。让我们详细说明最初的要求：
- en: 'Create a simple String calculator with the `Add` operation:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用“Add”操作创建一个简单的字符串计算器：
- en: This operation should only accept input in a string data type.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此操作应仅接受字符串数据类型的输入。
- en: The `Add` operation can take zero, one, or two comma-separated numbers and will
    return their sum, for example, *1* or *1,2*.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Add`操作可以接受零个、一个或两个逗号分隔的数字，并返回它们的总和，例如*1*或*1,2*。'
- en: The `Add` operation should accept an empty string, but for an empty string,
    it will return zero.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “Add”操作应接受空字符串，但对于空字符串，它将返回零。
- en: The preceding requirements are unanswered in our previous code snippet. To achieve
    these requirements, we should tweak our code snippet, which we will discuss in
    the upcoming sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上述要求在我们之前的代码片段中没有得到解答。为了实现这些要求，我们应该调整我们的代码片段，我们将在接下来的部分中讨论。
- en: Modifiers
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修饰符
- en: Modifiers are nothing but special keywords in C# that are used to declare how
    a specific method, property, or variable could be accessible. In this section,
    we will discuss modifiers and discuss their usage with the use of code examples.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符只是C#中用于声明特定方法、属性或变量如何可访问的特殊关键字。在本节中，我们将讨论修饰符，并使用代码示例讨论它们的用法。
- en: The whole point of modifiers is encapsulation. It's about how objects get simplified
    by encapsulations, and modifiers are like knobs saying how much you want to show
    to some clients, and how much not to. To understand encapsulation, refer to day
    seven, *Encapsulation*.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符的整个目的是封装。这是关于对象如何通过封装变得简化的，修饰符就像旋钮一样，告诉客户想要展示多少，不想展示多少。要理解封装，请参考第七天，“封装”。
- en: Access modifiers and accessibility levels
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符和可访问级别
- en: Access modifiers tell us how and where a member, declared type, and so on can
    be accessed or available. The following discussion will give you a broader idea
    of all access modifiers and accessibility levels.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符告诉我们成员、声明类型等如何以及在哪里可以被访问或可用。以下讨论将为您提供对所有访问修饰符和可访问级别的更广泛理解。
- en: public
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: public
- en: A `public` modifier helps us define the scope of the member without any restrictions.
    This means if we define any class, method, property, or variable with a public
    access modifier, the member can be accessed without any restrictions for other
    members.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`修饰符帮助我们定义成员的范围，没有任何限制。这意味着如果我们使用公共访问修饰符定义任何类、方法、属性或变量，该成员可以在其他成员中无限制地访问。'
- en: The accessibility level of the type or the member of derived type that is declared
    using the public access modifier is unrestricted, which means it can be accessible
    anywhere.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公共访问修饰符声明的派生类型的类型或成员的可访问性级别是不受限制的，这意味着它可以在任何地方访问。
- en: 'To understand unrestricted accessibility levels, let''s consider following
    code example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解无限制的可访问级别，让我们考虑以下代码示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code snippet will run perfectly and produce the expected results.
    When you run the preceding code, it will show results, as in the following image:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将完美运行并产生预期的结果。当您运行上述代码时，它将显示结果，如下图所示：
- en: '![](img/00052.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00052.jpeg)'
- en: protected
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 受保护的
- en: A `protected` modifier helps us define the scope of the member without the class
    or type defined/created from the class where the member is defined. In other words,
    when we define the variable, property, or method with the access modifier `protected`,
    this means the scope of availability of these are within the class in which all
    these members are defined.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`修饰符帮助我们定义成员的范围，而不是从定义/创建成员的类中定义的类型。换句话说，当我们使用`protected`访问修饰符定义变量、属性或方法时，这意味着这些成员的可用范围在定义了所有这些成员的类内部。'
- en: The accessibility level of the type or the member of derived type that is declared
    using protected access modifiers is restricted, which means it can only be accessible
    within the class or from the derived types that are created from class of the
    member. The protected modifier is importantly and actively responsible in OOPS
    using C#. You should get an idea of inheritance. Refer to day seven, *Inheritance*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用受保护访问修饰符声明的派生类型的类型或成员的可访问性级别是受限制的，这意味着它只能在类内部或从成员类创建的派生类型中访问。受保护修饰符在面向对象编程中的C#中非常重要和活跃。您应该对继承有所了解。请参考第七天，*继承*。
- en: 'To understand protected accessibility levels, let''s consider the following
    code example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解受保护的可访问性级别，让我们考虑以下代码示例：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, we have two classes: `StringCalculator` and `StringCalculatorImplementation`.
    Properties are defined with the `protected` access modifier in the `StringCalculator`
    class. This means these properties are only accessible either from the `StringCalculator`
    class or the `StringCalculatorImplementation` (this is a derived type of the `StringCalculatorclass`).
    The preceding code will produce the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个类：`StringCalculator`和`StringCalculatorImplementation`。在`StringCalculator`类中，属性使用`protected`访问修饰符进行定义。这意味着这些属性只能从`StringCalculator`类或`StringCalculatorImplementation`（这是`StringCalculator`类的派生类型）中访问。前面的代码将产生以下输出：
- en: '![](img/00053.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00053.jpeg)'
- en: 'The following code will not work and will produce a compile-time error:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将不起作用，并将产生编译时错误：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, we tried to access `Num1` and `Num2` from the `StringCalculatorImplementation`
    class by creating an instance of the `StringCalculator` class. This is not possible
    and will not work. Refer to the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们尝试通过创建`StringCalculator`类的实例来从`StringCalculatorImplementation`类中访问`Num1`和`Num2`。这是不可能的，也不会起作用。请参考以下截图：
- en: '![](img/00054.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: internal
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内部
- en: An internal modifier helps us define the scope of the member for the same assembly.
    Members that are defined using internal access modifiers cannot access outside
    of the assembly where they are defined.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 内部修饰符帮助我们定义成员在同一程序集中的范围。使用内部访问修饰符定义的成员不能在定义它们的程序集之外访问。
- en: The accessibility level of the type or the member that is declared using internal
    access modifiers is restricted for outside the assembly. This means these members
    are not allowed to access from external assemblies.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内部访问修饰符声明的类型或成员的可访问性级别对于程序集外部是受限制的。这意味着这些成员不允许从外部程序集访问。
- en: 'To understand internal accessibility levels, let''s consider the following
    code example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解内部的可访问性级别，让我们考虑以下代码示例：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code belongs to the assembly `ExternalLib` that contains a `StringCalculatorExternal`
    class of internal access modifiers with two properties, `Num1` and `Num2`, defined
    with the `public` access modifier. It will not work if we call this code from
    some other assembly. Let''s consider the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码属于包含`StringCalculatorExternal`类的`ExternalLib`程序集，该类具有内部访问修饰符和两个属性`Num1`和`Num2`，使用了`public`访问修饰符。如果我们从其他程序集调用此代码，它将无法工作。让我们考虑以下代码片段：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code is of a separate assembly day four, and we are trying to
    call a `StringCalculatorExternal` class of assembly `ExternalLib` that is not
    possible, as we have defined this class as `internal`. This code will throw the
    following error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是一个单独的第四天的程序集，并且我们试图调用`ExternalLib`程序集的`StringCalculatorExternal`类，这是不可能的，因为我们已将此类定义为`internal`。这段代码将抛出以下错误：
- en: '![](img/00055.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: composite
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合
- en: When we use protected and internal access modifier jointly i.e. protected internal
    this combinition of modifiers known as composite modifier.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们联合使用受保护和内部访问修饰符，即`protected internal`，这些修饰符的组合称为复合修饰符。
- en: '`protected internal` means protected or internal and not protected and internal.
    This means a member can be accessed from any class within the same assembly.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected internal`表示受保护或内部，而不是受保护和内部。这意味着成员可以从同一程序集中的任何类中访问。'
- en: 'To understand protected internal accessibility levels, let''s consider the
    following code example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解受保护的内部可访问性级别，让我们考虑以下代码示例：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code is for assembly day four with a class `StringCalculatorImplement`,
    that is, the inherited `StringCalculator` class (this class has two properties
    with the `protected internal` access modifier). Let''s consider code from the
    same assembly:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是第四天的程序集，其中有一个`StringCalculatorImplement`类，即继承了`StringCalculator`类（这个类有两个属性，使用了`protected
    internal`访问修饰符）。让我们考虑一下来自同一程序集的代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding code will produce the following output:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '![](img/00056.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: private
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: private
- en: A `private` modifier is the lowest scope of the member. This means whenever
    a member is defined using the `private` modifier, that member is only accessible
    within the class where it is defined.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`修饰符是成员的最低范围。这意味着只有在定义了`private`修饰符的类内部才能访问该成员。'
- en: '`private` means restricted access, and the member can only be accessed from
    within class or its nested types, if defined.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`表示受限制的访问，成员只能从类内部或其嵌套类型中访问，如果定义了的话。'
- en: 'To understand private accessibility levels, let''s consider the following code
    example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解私有的可访问性级别，让我们考虑以下代码示例：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding code properties, `Num1` and `Num2` are not accessible to outside
    the `StringCalculator` class. The following code will not work:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，属性`Num1`和`Num2`对于`StringCalculator`类外部是不可访问的。下面的代码将无法工作：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code will throw a compile-time error as in the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将会抛出编译时错误，如下截图所示：
- en: '![](img/00057.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: Rules for the access modifier
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问修饰符的规则
- en: 'We have discussed the access modifier and accessibility with the use of this
    access modifier. Now, there are certain rules we should follow while working with
    these access modifiers that are discussed here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了访问修饰符和使用这些访问修饰符的可访问性。现在，我们应该遵循在使用这些访问修饰符时应该遵循的一些规则，这些规则在这里讨论：
- en: '**Combination restriction**: A restriction is there while using an access modifier.
    These modifiers should not be used in combination unless you are using access
    modifiers protected internal. Consider the code example discussed in the previous
    section.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组合限制**：在使用访问修饰符时有一个限制。除非使用了访问修饰符`protected internal`，否则不应该组合使用这些修饰符。考虑前一节中讨论的代码示例。'
- en: '**Namespace restriction**: These access modifiers should not be used with namespace.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命名空间限制**：这些访问修饰符不应该与命名空间一起使用。'
- en: '**Default accessibility restriction**: When, or if, a member is declared without
    an access modifier, then default accessibility is used. All classes are implicitly
    internal, and its members are private.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认可访问性限制**：当成员声明时，如果没有使用访问修饰符，则使用默认可访问性。所有类都是隐式内部的，其成员是私有的。'
- en: '**Top-level type restriction**: Top-level types are parent types that have
    immediate parent type objects. Parent or top-level types cannot use any accessibility
    other than `internal` or `public` accessibility. If no access modifier is applied,
    default accessibility will be internal.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶层类型限制**：顶层类型是具有直接父类型对象的父类型。父类型或顶层类型不能使用除了`internal`或`public`可访问性之外的任何可访问性。如果没有应用访问修饰符，则默认可访问性将是内部的。'
- en: '**Nested-type restriction**: Nested types are those that are members of other
    types, or have immediate parent types other than universal types, that is, an
    object. The accessibility of these can be declared as discussed in the following
    table ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels)):'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**嵌套类型限制**：嵌套类型是其他类型的成员，或者具有除了通用类型（即对象）以外的直接父类型。这些类型的可访问性可以根据以下表格中讨论的方式进行声明（[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/accessibility-levels)）：'
- en: '| **Nested Type** | **Default Accessibility for Members** | **Allowed Accessibility
    Can Be Declared** | **Description** |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **嵌套类型** | **成员的默认可访问性** | **允许声明的可访问性** | **描述** |'
- en: '| Enum | `public` | None | `enum` has public accessibility, and its members
    have only `public` accessibility. These are meant to be used for other types;
    hence, they are not allowed to set any accessibility explicitly. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 枚举 | `public` | 无 | `enum`具有公共可访问性，其成员只有`public`可访问性。这些是为其他类型使用的，因此它们不允许显式设置任何可访问性。
    |'
- en: '| Class | `private` | `public`, `internal`, `protected`, `private`, `protected
    internal` | Class is internal by default, and members are `private.` Refer to
    the previous section-Rules for access modifier for more details. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 类 | `private` | `public`、`internal`、`protected`、`private`、`protected internal`
    | 类默认是内部的，成员是`private`。有关访问修饰符的规则的更多细节，请参考前一节。 |'
- en: '| Interface | `public` | None | Interface is internal by default, and its members
    are `public.` Members of interface are meant to be utilized from inherited types,
    so there is no explicit accessibility allowed for interface. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 接口 | `public` | 无 | 接口默认是内部的，其成员是`public`。接口的成员是为了被继承类型使用的，因此接口不允许显式设置可访问性。
    |'
- en: '| struct | `private` | `public`, `internal`, `private` | The same as `class`,
    struct is internal by default and its members are `private`. We can explicitly
    apply accessibility of `public`, `internal`, and `private`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 结构体 | `private` | `public`、`internal`、`private` | 与`class`相同，结构体默认是内部的，其成员是`private`。我们可以显式应用`public`、`internal`和`private`的可访问性。
    |'
- en: abstract
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象
- en: In simple words, we can say that an abstract modifier indicates that things
    are yet to be completed. A `class` is only meant to be a base class for other
    classes when an abstract modifier is used to create a `class`. Members marked
    as abstract in this `class` should be implemented in the derive class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们可以说抽象修饰符表示事物尚未完成。当使用抽象修饰符创建一个`class`时，该`class`只能作为其他类的基类。在这个`class`中标记为抽象的成员应该在派生类中实现。
- en: The abstract modifier indicates incomplete things and can be used with class,
    method, property, indexer, and/or event. Members marked as abstract would not
    be allowed to define accessibility other than `public`, `protected`, `internal`
    and `protected internal`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象修饰符表示不完整的事物，可以用于类、方法、属性、索引器和/或事件。标记为抽象的成员不允许定义除`public`、`protected`、`internal`和`protected
    internal`之外的可访问性。
- en: Abstract classes are half-defined. This means these provide a way to override
    members to child classes. We should use base classes in the project where we need
    to have the same member for all child classes with its own implementations or
    need to override. For example, let's consider an abstract class car with an abstract
    method color and have child classes Honda car, Ford car, Maruti car, and so on.
    In this case, all child classes would have color member but with different implementations
    because the color method would be overridden in the child classes with their own
    implementations. The point to be noted here is that abstract classes represent
    is-a relation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是半定义的。这意味着这些类提供了一种方式来覆盖子类的成员。我们应该在项目中使用基类，其中我们需要所有子类都具有相同的成员，并且具有自己的实现或需要覆盖。例如，让我们考虑一个抽象类car，其中有一个抽象方法color，并且有子类Honda
    car，Ford car，Maruti car等。在这种情况下，所有子类都会有颜色成员，但具有不同的实现，因为颜色方法将在子类中被覆盖，具有自己的实现。这里需要注意的一点是，抽象类代表is-a关系。
- en: 'To understand the capacity of this modifier, let''s consider the following
    example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这个修饰符的能力，让我们考虑以下例子：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code snippet is an abstract class that contains abstract properties
    and a non-abstract method. Other classes can only implement this class. Please
    refer to the following code snippet:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是一个包含抽象属性和非抽象方法的抽象类。其他类只能实现这个类。请参考以下代码片段：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Rules of the abstract modifier
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象修饰符的规则
- en: 'There are certain rules we need to follow while working with abstract modifiers,
    and these rules are discussed as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用抽象修饰符时，我们需要遵循一些规则，这些规则如下所述：
- en: '**Instantiation**: If a class is marked as abstract, we cannot create the instance
    of it. In other words, object initialization is not allowed for abstract classes.
    We will get a compile-time error if we try to do this explicitly. Refer to the
    following screenshot, where we are trying to instantiate an abstract class:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实例化**：如果一个类被标记为抽象，我们不能创建它的实例。换句话说，抽象类不允许对象初始化。如果我们尝试显式地这样做，将会得到一个编译时错误。请参考以下截图，我们在尝试实例化一个抽象类：'
- en: '![](img/00058.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: '**Non-abstract**: A class may or may not contain abstract methods or members
    that are marked as abstract. This means there is no restriction when we have to
    create all abstract members and methods for abstract classes. The following code
    obeys this rule:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非抽象**：一个类可能包含或不包含被标记为抽象的抽象方法或成员。这意味着当我们必须为抽象类创建所有抽象成员和方法时，没有限制。以下代码遵守了这个规则：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Limit**-**inherit nature**: As we discussed, an abstract class is meant to
    be inherited by other classes. If we do not want to inherit the abstract class
    from other classes, we should use a sealed modifier. We will discuss this in detail
    in the upcoming sections.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制-继承性质**：正如我们讨论的，抽象类是用来被其他类继承的。如果我们不想将抽象类从其他类继承，我们应该使用sealed修饰符。我们将在接下来的章节中详细讨论这一点。'
- en: For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/abstract-and-sealed-classes-and-class-members)
- en: '**Implementation nature**: All members of an abstract class should be implemented
    in the child class that is inheriting the abstract class only if the child class
    is non-abstract. To understand this, let''s consider the following examples:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实现性质**：抽象类的所有成员应该在继承抽象类的子类中实现，只有当子类是非抽象的时候。为了理解这一点，让我们考虑以下例子：'
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, consider another example where the inherited class is non-abstract. In
    this case, the child class should implement all the abstract members of the abstract
    class; otherwise, it will throw a compile-time error. See the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑另一个例子，其中继承的类是非抽象的。在这种情况下，子类应该实现抽象类的所有抽象成员；否则，它将抛出编译时错误。请参阅以下截图：
- en: '![](img/00059.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00059.jpeg)'
- en: '**Virtual in nature**: Methods and properties marked as abstract for the `abstract`
    class are virtual, by default, in nature. These methods and properties will be
    overridden in inherited classes.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟性质**：对于`abstract`类标记为抽象的方法和属性，默认情况下是虚拟的。这些方法和属性将在继承类中被重写。'
- en: 'Here is the complete example of abstract class implementation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是抽象类实现的完整示例：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: async
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: async
- en: The `async` modifier provides a way to make a method of the anonymous type or
    a lambda expression as asynchronous. When it is used with a method, that method
    is called as the `async` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`修饰符提供了一种将匿名类型或lambda表达式的方法作为异步方法的方式。当它与一个方法一起使用时，该方法被称为`async`方法。'
- en: '`async` will be discussed in details on day six.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 将在第六天详细讨论。'
- en: 'Consider the following code example:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码示例：
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code will provide the same result as discussed in the code examples
    in the previous sections; the only difference is this method call is asynchronous.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将提供与前几节中讨论的代码示例相同的结果；唯一的区别是这个方法调用是异步的。
- en: const
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: const
- en: The `const` modifier gives the ability to define a constant field or constant
    local. When we defined fields or variables using `const`, these fields are not
    called variables anymore because `const` is not meant for change, while variables
    are. Constant fields are class-level constants that are accessible within or outside
    the `class` (depends upon their modifier), while constant locals are defined within
    a method.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`修饰符允许定义一个常量字段或常量局部变量。当我们使用`const`定义字段或变量时，这些字段不再被称为变量，因为`const`不允许改变，而变量允许。常量字段是类级常量，在类内外都可以访问（取决于它们的修饰符），而常量局部变量是在方法内定义的。'
- en: 'Fields and variables defined as `const` are not variables and may not be modified.
    These constants can be any of these: numbers, bool, string, or null references.
    A static modifier is not allowed while declaring constants.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`const`定义的字段和变量不是变量，不能被修改。这些常量可以是数字、bool、字符串或空引用。在声明常量时不允许使用静态修饰符。
- en: 'Here is the code snippet that shows the valid constant declaration:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示有效常量声明的代码片段：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: event
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: event
- en: The modifier `event` helps declare an event for the `publisher` class. We will
    discuss this in detail on day five. For more information on this modifier, refer
    to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event)
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`event`修饰符帮助声明`publisher`类的事件。我们将在第五天详细讨论这一修饰符。有关此修饰符的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/event)'
- en: extern
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: extern
- en: The modifier `extern` helps declare a method that uses an external library or
    dll. This is important when you want to use an external unmanaged library.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`extern`修饰符帮助声明一个使用外部库或dll的方法。当你想要使用外部不受管控的库时，这一点非常重要。'
- en: A method that is implementing external unmanaged libraries using the `extern`
    keyword must be declared as static. For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`extern`关键字实现外部不受管控库的方法必须声明为静态的。有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/extern)
- en: new
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: new
- en: 'The `new` operator can be a modifier, an operator, or modifier. Let''s discuss
    this in detail:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`操作符可以是一个修饰符、一个操作符或修饰符。让我们详细讨论一下：'
- en: '**Operator**: `new` as an operator helps us create an object instance of a
    `class` and invokes their constructors. For example, the following line is showing
    the use of `new` as an operator:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作符**：`new` 作为一个操作符，帮助我们创建一个`class`的对象实例，并调用它们的构造函数。例如，以下行展示了`new`作为一个操作符的使用：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Modifier**: The new modifier helps hide members inherited from a base class:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**修饰符**：`new`修饰符帮助隐藏从基类继承的成员：'
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is also known as hiding in C#.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这在C#中也被称为隐藏。
- en: '**Constraint**: The `new` operator as a constraint makes sure that in declaration
    of every generic class, it must have a public parameter-less constructor. This
    will be discussed in detail on day five.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束**：`new`操作符作为约束确保在每个泛型类的声明中，必须有一个公共的无参数构造函数。这将在第五天详细讨论。'
- en: override
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: override
- en: The `override` modifier helps extend the abstract or virtual implementation
    of inherited members (that is, method, property, indexer, or event). This will
    be discussed in detail on day seven.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`override`修饰符帮助扩展继承成员（即方法、属性、索引器或事件）的抽象或虚拟实现。这将在第七天详细讨论。'
- en: partial
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: partial
- en: 'With the help of the `partial` modifier, we can split a class, an interface,
    or a struct into multiple files. Look at the following code example:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`partial`修饰符，我们可以将一个类、一个接口或一个结构分割成多个文件。看下面的代码示例：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have two files, `Calculator.cs` and `Calculator1.cs`. Both files have
    `Calculator` as their partial class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个文件，`Calculator.cs`和`Calculator1.cs`。这两个文件都将`Calculator`作为它们的部分类。
- en: readonly
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: readonly
- en: 'The `readonly` modifier helps us create a field declaration as `readonly`.
    A `readonly` field can only be assigned a value at the time of declaration or
    as part of the declaration itself. To understand this better, consider the following
    code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`修饰符帮助我们创建一个字段声明为`readonly`。`readonly`字段只能在声明时或作为声明的一部分被赋值。为了更好地理解这一点，请考虑以下代码片段：'
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](img/00060.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00060.jpeg)'
- en: 'It will throw a compile-time error if we explicitly try to assign a value to
    the `Num1 readonly` field. See the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们明确尝试给`Num1 readonly`字段赋值，将会抛出编译时错误。请参阅以下截图：
- en: '![](img/00061.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00061.jpeg)'
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: sealed
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: sealed
- en: The modifier `sealed` is something that, when applied with a `class`, says,
    "I am not going to be available for any kind of inheritance further. Do not inherit
    me now." In simple words, this modifier restricts classes from being inherited
    by other classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`sealed`修饰符是当应用于一个`class`时，表示“我不会再被其他类继承。现在不要继承我。” 简单来说，这个修饰符限制了类被其他类继承。'
- en: The modifier sealed is used with override when applying abstract methods (which
    are virtual in default by nature) to derived or inherited class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于派生或继承类的抽象方法（默认情况下是虚拟的）时，`sealed`修饰符与`override`一起使用。
- en: 'To understand this better, let''s consider the following code example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们考虑以下代码示例：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](img/00062.jpeg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00062.jpeg)'
- en: 'You cannot apply a sealed modifier on an abstract classes. If we explicitly
    try this, it eventually throws a compile-time error. See the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在抽象类上应用`sealed`修饰符。如果我们明确尝试这样做，最终会抛出编译时错误。请参阅以下截图：
- en: '![](img/00063.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00063.jpeg)'
- en: static
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态的
- en: The modifier `static` helps us declare static members. These members are actually
    also known as class-level members and not object-level members. This means there
    is no need to create an instance of object to use these members.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`修饰符帮助我们声明静态成员。这些成员实际上也被称为类级成员，而不是对象级成员。这意味着不需要创建对象实例来使用这些成员。'
- en: Rules for the static modifier
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态修饰符的规则
- en: 'There are certain rules that need to be followed while working with the `static`
    modifier:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`static`修饰符时需要遵循一些规则：
- en: '**Restriction**: You can use the `static` modifier with only class, field,
    method, property, operator, event, and constructors. This modifier cannot be used
    with indexer and types other than `class`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**限制**：你只能在类、字段、方法、属性、操作符、事件和构造函数中使用`static`修饰符。这个修饰符不能用于索引器和除`class`之外的类型。'
- en: '**Nature by static**: When we declare a constant, it is implicitly static by
    nature. Consider the following code snippet:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态的性质**：当我们声明一个常量时，它本质上是静态的。考虑以下代码片段：'
- en: '[PRE25]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding `StringCalculator` class is has two constants, `Num1` and `Num2`.
    These are accessible by `class`, and there is no need to create an instance of
    `class.` See the following code snippet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`StringCalculator`类有两个常量，`Num1`和`Num2`。这些可以被`class`访问，不需要创建`class`的实例。请参考以下代码片段：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**Complete static**: If class is defined with the use of the `static` modifier,
    then all the members of this `static` class should be `static`. There will be
    a compile-time error if a `static` class is explicitly defined to create non-static
    members. Consider the following screenshot:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完全静态**：如果类使用`static`修饰符定义，那么这个`static`类的所有成员都应该是`static`的。如果一个`static`类明确定义为创建非静态成员，将会有一个编译时错误。请参考以下截图：'
- en: '![](img/00064.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00064.jpeg)'
- en: '**Availability**: No need to create an instance of class to access the `static`
    member.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可用性**：不需要创建类的实例来访问`static`成员。'
- en: The keyword `this` cannot be applied on `static` methods or properties. We have
    already discussed this, and base keywords, on day two.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`this`不能应用于`static`方法或属性。我们已经在第二天讨论过这一点，以及`base`关键字。
- en: unsafe
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不安全
- en: This modifier helps use unsafe code blocks. We will discuss this in detail on
    day six.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符帮助我们使用不安全的代码块。我们将在第六天详细讨论这个问题。
- en: virtual
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟
- en: 'This modifier helps us define virtual methods that are meant to be overridden
    in inherited classes. See the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个修饰符帮助我们定义虚拟方法，这些方法是为了在继承类中被重写。请看以下代码：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For more information, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/virtual)
- en: Methods
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: A block of statements that have the access modifier, name, return type, and
    parameters (which may or may not be there) are nothing but a method. A method
    is meant to perform some tasks.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 具有访问修饰符、名称、返回类型和参数（可能有也可能没有）的一组语句仅仅是一个方法。方法的目的是执行一些任务。
- en: Methods are meant to call either by another method or by another program.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的目的是被另一个方法或另一个程序调用。
- en: How to use a method?
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用方法？
- en: As said earlier, methods are meant to perform some actions. So, any method or
    program that needs to utilize these actions could call/consume/use the defined
    method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，方法的目的是执行一些操作。因此，任何需要利用这些操作的方法或程序都可以调用/使用定义的方法。
- en: 'A method has various element discussed as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 方法有各种元素，如下所述：
- en: '**Access modifier**: A method should have an access modifier (refer to the
    previous section for more details on modifier). The modifier helps us define the
    scope of method or the availability of the method, for example. A method defined
    using the `private` modifier can only be visible to its own class.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问修饰符**：方法应该有一个访问修饰符（有关修饰符的更多细节，请参考前一节）。这个修饰符帮助我们定义方法的范围或方法的可用性，例如。使用`private`修饰符定义的方法只能对其自己的类可见。'
- en: '**Return type**: After performing an action, a method may or may not return
    something. Method return type is based on the data types (refer to day two for
    information on datatypes). For example, if method is returning a number, its data
    type would be an int and its return type is `void` if the method does not return
    anything.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回类型**：执行操作后，方法可能会返回或不返回任何东西。方法的返回类型基于数据类型（有关数据类型的信息，请参考第二天）。例如，如果方法返回一个数字，它的数据类型将是int，如果方法不返回任何东西，它的返回类型是`void`。'
- en: '**Name**: A name is unique within the `class`. Names are case sensitive. In
    the class `StringCalculator`, we cannot define two methods with the name `Sum()`.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：名称在`class`内是唯一的。名称区分大小写。在`StringCalculator`类中，我们不能定义两个名称为`Sum()`的方法。'
- en: '**Parameter(s):** These are optional for any method. This means a method may
    or may not have a parameter. Parameters are defined based on the datatype.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：对于任何方法来说都是可选的。这意味着一个方法可能有也可能没有参数。参数是基于数据类型定义的。'
- en: '**Functioning body**: A part of instructions to be executed by a method is
    nothing but a functionality of the method.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能体**：方法要执行的一部分指令就是方法的功能。'
- en: 'The following screenshot shows a typical method:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了一个典型的方法：
- en: '![](img/00065.jpeg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00065.jpeg)'
- en: 'Before moving ahead, let''s recall the requirements we discussed at the start
    of day four, where we created a method to calculate the sum of a string parameter
    list. Here is the program that meets these requirements:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们回顾一下我们在第四天开始时讨论的要求，我们在那里创建了一个方法来计算字符串参数列表的总和。以下是满足这些要求的程序：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code produces output as expected. Refer to the following screenshot:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码产生了预期的输出。请参考以下截图：
- en: '![](img/00066.gif)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00066.gif)'
- en: 'The preceding code is working absolutely fine but needs refactoring, so lets
    split our code into small methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码完全正常工作，但需要重构，所以让我们将代码拆分成小方法：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Code refactoring is beyond the scope of this book. For more details on code
    refactoring, refer to [https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010.](https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构超出了本书的范围。有关代码重构的更多详细信息，请参阅[https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010.](https://www.packtpub.com/application-development/refactoring-microsoft-visual-studio-2010)
- en: Now, our code looks better and readable. This will produce the same output.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的代码看起来更好，更易读。这将产生相同的输出。
- en: Properties
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: Properties are members of a class, structure, or interface generally called
    as a named member. The intended behaviors of properties are similar to fields
    with the difference being that the implementation of properties is possible with
    the use of accessors.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是类、结构或接口的成员，通常称为命名成员。属性的预期行为类似于字段，不同之处在于可以使用访问器来实现属性。
- en: Properties are extensions to fields. The accessors get and set helps retrieve
    and assign value to property.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是字段的扩展。访问器get和set帮助检索和分配属性的值。
- en: 'Here is the typical property (also called property with auto-property syntax)
    of a class:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是类的典型属性（也称为具有自动属性语法的属性）：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For auto property, compiler generates the backup field, which is nothing but
    a storage field. So, the preceding property would be shown as follows, with a
    backup field:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自动属性，编译器会生成后备字段，这只是一个存储字段。因此，前面的属性将显示如下，带有后备字段：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The preceding property with an expression body looks like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 具有表达式主体的前面属性如下：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For more details on the expression bodies property, refer to [https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx.](https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有关表达式主体属性的更多详细信息，请参阅[https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx.](https://visualstudiomagazine.com/articles/2015/06/03/c-sharp-6-expression-bodied-properties-dictionary-initializer.aspx)
- en: Types of properties
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性类型
- en: There are multiple flavors of properties we can declare or play. We just discussed
    auto properties and discussed how compiler converts it with a backup storage field.
    In this section, we will discuss the other types of properties available.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明或使用多种属性。我们刚刚讨论了自动属性，并讨论了编译器如何将其转换为备份存储字段。在本节中，我们将讨论其他可用的属性类型。
- en: Read-write property
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读写属性
- en: A property that allows us to store and retrieve values is nothing but a read-write
    property. A typical read-write property with backing storage field would have
    both `set` and `get` accessors. The `set` accessor stores the data of the data
    type of the property. Note that for the set accessor, there's always a single
    parameter, that is, value, and this matches the storage data or data type of the
    property.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 允许我们存储和检索值的属性就是读写属性。具有后备存储字段的典型读写属性将具有`set`和`get`访问器。`set`访问器存储属性的数据类型的数据。请注意，对于set访问器，始终有一个参数，即value，并且这与属性的存储数据或数据类型匹配。
- en: Auto properties are automatically converted to property with backing storage
    fields by the compiler.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 自动属性会被编译器自动转换为带有后备存储字段的属性。
- en: 'See the following code snippet to understand this in detail:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看以下代码片段以了解详情：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Previously, we had two properties: one defined using the backing field and
    another by auto property. The accessor `set` is responsible for storing the data
    using the parameter value, and it matches the data type int, and `get` is responsible
    for retrieving the data of data type int.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们有两个属性：一个是使用后备字段定义的，另一个是使用自动属性定义的。访问器`set`负责使用参数值存储数据，并且与数据类型int匹配，`get`负责检索数据，数据类型为int。
- en: Read-only property
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读属性
- en: A property defined with only the `get` accessor or with a private `set` accessor
    is called a read-only property.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 只有`get`访问器或私有`set`访问器的属性称为只读属性。
- en: There is slight difference between read-only and `const`. Refer to [https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly](https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly)
    for more details.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 只读和`const`之间有细微差别。有关更多详细信息，请参阅[https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly](https://stackoverflow.com/questions/55984/what-is-the-difference-between-const-and-readonly)。
- en: 'As the name indicates, read-only properties only retrieve values. You cannot
    store the data in a read-only property. See the following code snippet for more
    details:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 顾名思义，只读属性只能检索值。您不能在只读属性中存储数据。有关更多详细信息，请参阅以下代码片段：
- en: '[PRE34]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we have three properties; all are read-only. `Num1` is
    a read-only property, and this is restricted by a constructor. This means you
    can set a property in a constructor only. `Num2` is a pure read-only property;
    this means it is meant to retrieve the data. Numbers is the auto-initializer read-only
    property; it has a default initialization for a property of collection.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有三个属性；所有都是只读的。`Num1`是一个只读属性，并且受构造函数限制。这意味着您只能在构造函数中设置属性。`Num2`是一个纯只读属性；这意味着它用于检索数据。Numbers是自动初始化的只读属性；它对集合属性进行了默认初始化。
- en: Computed property
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算属性
- en: A property that returns the results of an expression is called a computed property.
    The expression may be based on other properties of the same class or based on
    any valid expression with CLR-compliant data types (for data types, refer to day
    two) that should be the same as the property data type.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表达式结果的属性称为计算属性。该表达式可以基于同一类的其他属性或基于任何有效的CLR兼容数据类型的表达式（有关数据类型，请参考第二天），其应与属性数据类型相同。
- en: Computed properties return the results of an expression and cannot allow to
    set data, so these are some kind of read-only property.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性返回表达式的结果，并且不允许设置数据，因此这些是某种只读属性。
- en: 'To understand this in detail, let''s consider the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要详细了解，请考虑以下内容：
- en: Block-bodied members
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 块主体成员
- en: 'In the block-bodied computed property, calculations are returned with the get
    accessor. Refer to the following example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在块主体计算属性中，计算结果在get访问器中返回。请参考以下示例：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the preceding code, we have three properties: `Num3`, `Num4` and `Sum`.
    The property `Sum` is a computed property that returns an expression result from
    within the get accessor.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有三个属性：`Num3`，`Num4`和`Sum`。属性`Sum`是一个计算属性，它从get访问器中返回表达式结果。
- en: Expression-bodied members
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式主体成员
- en: 'In expression-bodied, the computed property calculations are returned using
    lambda expression, which is used by the expression-bodied members. Refer to the
    following example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式主体中，使用lambda表达式返回计算属性计算结果，这是由表达式主体成员使用的。请参考以下示例：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, our `Add` property is returning an expression of `Sum`
    for two other properties.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们的`Add`属性返回了另外两个属性的`Sum`表达式。
- en: Property using validation
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用验证的属性
- en: There may be scenarios when we want to validate certain data for properties.
    Then, we would use a few validations along with properties. These are not a special
    type of property, but complete properties with validation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有一些情况，我们想要验证某些属性的数据。然后，我们会在属性上使用一些验证。这些不是特殊类型的属性，而是带有验证的完整属性。
- en: Data annotation is a way to validate various properties and add custom validations.
    For more information, refer to [https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame.](https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 数据注释是一种验证各种属性并添加自定义验证的方法。有关更多信息，请参阅[https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame.](https://www.codeproject.com/Articles/826304/Basic-Introduction-to-Data-Annotation-in-NET-Frame)
- en: 'These properties are important in a scenario when we need to validate the input
    using properties. Consider the following code snippet:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要使用属性验证输入时，这些属性非常重要。考虑以下代码片段：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the preceding code, there is no need to apply any explicit validation on
    the client code for the preceding property. The property `Number` is self-validated
    whenever it is being called to store data. In the previous code, whenever the
    client code tries to enter any negative number, it implicitly throws out an exception
    that the number can't be negative. In this case, only positive numbers are entered
    by the client code. On the same node, you can apply as much as validation as you
    want.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，对于前面的属性，客户端代码不需要应用任何显式验证。每当调用存储数据时，属性`Number`会自我验证。在以前的代码中，每当客户端代码尝试输入任何负数时，它会隐式抛出一个异常，即数字不能为负数。在这种情况下，客户端代码只输入正数。在同一节点上，您可以应用尽可能多的验证。
- en: Indexers
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引器
- en: An indexer provides a way to access an object via an index like array. For instance,
    if we define an indexer for a class, that class works similarly to an array. This
    means the collection of this class can be accessed by index.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 索引器提供了一种通过索引访问对象的方式，就像数组一样。例如，如果我们为一个类定义了索引器，那么该类的工作方式类似于数组。这意味着可以通过索引访问该类的集合。
- en: Keyword `this` is used to define an indexer. The main benefit of indexer is
    that we can set or retrieve the indexed value without explicitly specifying a
    type.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`this`用于定义索引器。索引器的主要好处是我们可以在不显式指定类型的情况下设置或检索索引值。
- en: 'Consider the following code snippet:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code is a simpler one to represent the power of an indexer. We
    have a `PersonCollection` class having an indexer that makes this class accessible
    via indexer. Please refer to the following code:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是一个简单的表示索引器强大的示例。我们有一个`PersonCollection`类，其中有一个索引器，使得该类可以通过索引器访问。请参考以下代码：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can see the following output after executing the preceding code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，我们可以看到以下输出：
- en: '![](img/00067.jpeg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00067.jpeg)'
- en: For more information on indexers, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/)
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 有关索引器的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/indexers/)
- en: File I/O
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件I/O
- en: File is nothing but a collection of data that stores physically in a directory
    of the system. The data that file contains could be any information. In C#, whenever
    the file is available programmatically for information retrieval (read) or updating
    information (write), that is nothing but a stream.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 文件只是在系统目录中物理存储的数据集合。文件包含的数据可以是任何信息。在C#中，每当文件可供程序检索信息（读取）或更新信息（写入）时，那就是一个流。
- en: Stream is nothing but a sequence of bytes.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 流就是一系列字节。
- en: 'In the C# file, I/O is just a way to call input streams or output streams:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#文件中，I/O只是调用输入流或输出流的一种方式：
- en: '**Input stream**: This is nothing but a read operation. Whenever we programmatically
    read the data from the file, it is called an input stream or a read operation.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入流**：这只是一个读取操作。每当我们以编程方式从文件读取数据时，它被称为输入流或读取操作。'
- en: '**Output stream**: This is nothing but an update operation. Whenever we programmatically
    add data to the file, it is called an output stream or a write operation.'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出流**：这只是一个更新操作。每当我们以编程方式向文件添加数据时，它被称为输出流或写操作。'
- en: File I/O is a part of the `System.IO` namespace that contains various classes.
    In this section, we will discuss FileStream that we will use in our code example.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 文件I/O是`System.IO`命名空间的一部分，其中包含各种类。在本节中，我们将讨论我们将在代码示例中使用的FileStream。
- en: A complete list of System.IO classes is available at [https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的System.IO类列表可在[https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io?view=netcore-2.0)找到。
- en: FileStream
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件流
- en: 'As discussed previously, there are a couple of helpful classes that are available
    under the `System.IO` namespace. FileStream is one of these classes that helps
    us read/write data to/from a file. Before going on to discuss this `class`, let''s
    consider one short example where we will create a file:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在`System.IO`命名空间下有几个有用的类可用。FileStream是其中之一，它帮助我们读取/写入文件中的数据。在讨论这个`class`之前，让我们考虑一个简短的示例，我们将在其中创建一个文件：
- en: '[PRE40]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code first creates a file with specific text/data and then displays
    the same. Here is the output of the preceding code. Refer to the following screenshot:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先创建一个具有特定文本/数据的文件，然后显示相同的内容。以下是上述代码的输出。请参考以下截图：
- en: '![](img/00068.jpeg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00068.jpeg)'
- en: A complete reference of FileStream is available at [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的FileStream参考可在[https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)找到。
- en: Exception handling
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Exception is a kind of error that comes when methods do not work as expected
    or are not able to handle the situation as intended. Sometimes, there might be
    unknown situations where exceptions occurred; for instance, a method can have
    a situation divide by zero problem in division operation the situation was never
    expected while someone wrote the method, this is an unpredicted situational error.
    To handle these kind of situations and other unknown scenarios that can create
    such exceptions or error, C# provides a method that is called exception handling.
    In this section, we will discuss exceptions and exception handing using C# in
    details.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 异常是一种错误，当方法不按预期工作或无法处理预期的情况时出现。有时会出现未知情况导致异常；例如，一个方法可能在除法运算中出现除以零的问题，这种情况在编写方法时从未预料到，这是一种不可预测的情况错误。为了处理这种情况以及可能导致此类异常或错误的其他未知情况，C#提供了一种称为异常处理的方法。在本节中，我们将详细讨论使用C#处理异常和异常处理。
- en: Exceptions can be handled using the `try`...`catch`...`finally` block. Catch
    or finally blocks should be there with the try block to handle exceptions.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`try`...`catch`...`finally`块来处理异常。`try`块应该有catch块或finally块来处理异常。
- en: 'Consider the following code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE41]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The preceding code will throw an unhandled divide by zero exception if the
    divisor comes as zero once called using the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用以下代码调用时除数为零，上述代码将抛出未处理的除零异常：
- en: '[PRE42]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'See the following screenshot for the exception:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下屏幕截图以查看异常：
- en: '![](img/00069.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00069.jpeg)'
- en: To handle situations similar to the previous situation, we can use exception
    handling. In C#, exception handling has common components, which are discussed
    here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理类似于之前情况的情况，我们可以使用异常处理。在C#中，异常处理具有共同的组件，这里进行讨论。
- en: try block
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: try块
- en: The `try` block is a code of block that is the source of the exception. A `try`
    block can have multiple `catch` blocks and/or one final bock. This means a `try`
    block should have at least one catch block or one final block.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块是异常源的代码块。`try`块可以有多个`catch`块和/或一个最终块。这意味着`try`块应该至少有一个catch块或一个final块。'
- en: catch block
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: catch block
- en: The `catch` block is a code block where a particular or general exception is
    being handled. The `catch` has a parameter of `Exception` that tells us what exception
    has occurred.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`块是一个代码块，用于处理特定或一般异常。`catch`有一个`Exception`参数，告诉我们发生了什么异常。'
- en: finally block
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: finally block
- en: A `finally` block is one that executes in any case (if supplied) whether an
    exception is thrown or not. Generally, a `finally` block is meant to execute few
    cleanup tasks after exception.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`块是一个无论如何都会执行（如果提供）的块。通常，`finally`块用于在异常后执行一些清理任务。'
- en: The `throw` keyword helps to throw a system or a custom exception.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`关键字有助于抛出系统或自定义异常。'
- en: 'Now, let''s revisit the preceding code that threw an exception:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重新访问之前抛出异常的代码：
- en: '[PRE43]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, we have modified the code by adding `try`...`catch`...`finally` blocks.
    Now, whenever an exception occurs, it first goes to the `catch` block and then
    to the `finally` block. After putting the `finally` block, whenever we divide
    by zero an exception will occur, which will produce the following result:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过添加`try`...`catch`...`finally`块修改了代码。现在，每当发生异常时，首先进入`catch`块，然后进入`finally`块。在放置了`finally`块之后，每当我们除以零时都会发生异常，这将产生以下结果：
- en: '![](img/00070.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00070.jpeg)'
- en: Different compiler-generated exceptions in catch block
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: catch块中的不同编译生成的异常
- en: As we discussed previously, there may be multiple `catch` blocks within a `try`
    block. This means we can catch multiple exceptions. The different `catch` block
    could be written to handle a specific exception class. For example, an `exception`
    class for divide by zero exception is `System.DivideByZeroException`. A complete
    discussion of all these classes is beyond the scope of this book. For further
    study on these exception classes, refer to [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions)
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，`try`块内可能有多个`catch`块。这意味着我们可以捕获多个异常。不同的`catch`块可以编写来处理特定的异常类。例如，除零异常的`exception`类是`System.DivideByZeroException`。本书不涵盖所有这些类的完整讨论。有关这些异常类的进一步研究，请参阅[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions.](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/exceptions/compiler-generated-exceptions)
- en: User-defined exceptions
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的异常
- en: Custom exceptions created as per requirements are user exceptions, and when
    we create an `exception` class, to handle a specific scenario, it is called a
    user-defined exception. All user-defined `exception` classes are derived from
    the `Exception` class.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 根据要求创建的自定义异常是用户异常，当我们创建一个`exception`类来处理特定情况时，它被称为用户定义的异常。所有用户定义的`exception`类都派生自`Exception`类。
- en: 'Let''s create a user-defined `exception`. Recall the `StringCalculatorUpdated`
    class (discussed in the section **Methods**) that is responsible for calculating
    the sum of string numbers. Add one more scenario to the existing requirements,
    that is, throw the `NumberIsExceded` exception if any number is greater than 1,000:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用户定义的`exception`。回想一下`StringCalculatorUpdated`类（在**方法**部分讨论），它负责计算字符串数字的总和。在现有要求中添加一个场景，即如果任何数字大于1,000，则抛出`NumberIsExceded`异常：
- en: '[PRE44]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here is the code snippet that handles our newly created exception:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理我们新创建的异常的代码片段：
- en: '[PRE45]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, whenever the number exceeds 1,000, it throws an exception. Let''s write
    a client code that throws an exception, consider the preceding code is called:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，每当数字超过1,000时，它都会抛出异常。让我们编写一个客户端代码来抛出异常，考虑上述代码被调用： '
- en: '[PRE46]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding code will generate the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将生成以下输出：
- en: '![](img/00071.jpeg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00071.jpeg)'
- en: Discussing a regular expression and its importance
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论正则表达式及其重要性
- en: A regular expression or pattern matching is nothing but a way in which we can
    check whether an input string is correct or not. This is possible with the use
    of the `Regex` class of the `System.Text.RegularExpressions` namespace.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式或模式匹配只是一种我们可以检查输入字符串是否正确的方式。这是通过`System.Text.RegularExpressions`命名空间的`Regex`类实现的。
- en: The Importance of a regular expression
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式的重要性
- en: Pattern matching is very important while we are working to validate text input.
    Here, regular expression plays an important role.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证文本输入时，模式匹配非常重要。在这里，正则表达式发挥着重要作用。
- en: Flexible
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灵活
- en: Patterns are very flexible and provide us with a way to make our own pattern
    to validate the input.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 模式非常灵活，为我们提供了一种制定自己的模式来验证输入的方法。
- en: Constructs
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造
- en: There are various constructs that help us define the regular expression. Hence,
    we need to make them important in our programming where we need validated input.
    These constructs are character classes, character escapes, quantifiers, and so
    on.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种构造帮助我们定义正则表达式。因此，在需要验证输入的编程中，我们需要使它们变得重要。这些构造包括字符类、字符转义、量词等。
- en: Special characters
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊字符
- en: There is a huge usage of regular expressions in our day-to-day programmings
    and that why regular expressions are important. Here are various scenarios as
    per their usage, where special characters of regular expression helps us validate
    the input when it comes with a pattern.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们日常编程中，正则表达式的使用非常广泛，这就是为什么正则表达式很重要。根据它们的使用情况，特殊字符的正则表达式在验证输入时帮助我们。
- en: The period sign (.)
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 句号符（.）
- en: This is a wildcard character that matches any character besides the newline
    character.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通配符，匹配除换行符之外的任何字符。
- en: The word sign (w)
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单词符号（w）
- en: Backslash and a lowercase *w* is a character class that will match any word
    character.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 反斜杠和小写*w*是一个字符类，将匹配任何单词字符。
- en: The space sign (s)
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空格符（s）
- en: White space can be matched using *s* (backslash and *s*).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*s*（反斜杠和*s*）来匹配空格。
- en: The digit sign (d)
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字符号（d）
- en: The digits zero to nine can be matched using *d* (backslash and lowercase *d*).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用*d*（反斜杠和小写*d*）来匹配零到九的数字。
- en: The hyphen sign (-)
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连字符（-）
- en: Ranges of characters can be matched using the hyphen (*-*).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用连字符（*-*）来匹配字符范围。
- en: Specifying the number of matches
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定匹配的次数
- en: The minimum number of matches required for a character, group, or character
    class can be specified with curly brackets (*{n}*).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用大括号（*{n}*）指定字符、组或字符类所需的最小匹配次数。
- en: 'Here is the code snippet showing the previous special characters:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示先前特殊字符的代码片段：
- en: '[PRE47]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The preceding code allows `inputText` and `Regexpression` to be performed on
    it. Here is the calling code:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码允许对`inputText`和`Regexpression`进行操作。以下是调用代码：
- en: '[PRE48]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The preceding code generates the following output:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成以下输出：
- en: '![](img/00072.jpeg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00072.jpeg)'
- en: Regular expression is a broad topic. For more details, refer to [https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0)
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是一个广泛的主题。有关更多详细信息，请参阅[https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0.](https://docs.microsoft.com/en-us/dotnet/api/system.text.regularexpressions?view=netcore-2.0)
- en: Hands-on exercise
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手练习
- en: 'Here are the unsolved questions from what you learned up until day four:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是直到第四天学到的未解决问题：
- en: What are access modifiers and their accessibility?
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问修饰符及其可访问性是什么？
- en: Write a program to use `protected internal`.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序使用`protected internal`。
- en: What are abstract classes? Elaborate with the help of a program.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是抽象类？通过一个程序详细阐述。
- en: Does an abstract class have a constructor? If yes, the why can't we instantiate
    abstract class? (Refer to [https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created](https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created))
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 抽象类有构造函数吗？如果有，为什么我们不能实例化抽象类？（参考[https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created](https://stackoverflow.com/questions/2700256/why-cant-an-object-of-abstract-class-be-created)）
- en: Explain, with the help of a small program, how we can stop an abstract class
    from being inherited.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一个小程序，解释如何阻止抽象类被继承。
- en: Differentiate the `sync` and `async` methods.
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 区分`sync`和`async`方法。
- en: Differentiate the `const` and `readOnly` modifiers with the help of a small
    program.
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过一个小程序区分`const`和`readOnly`修饰符。
- en: 'Write a program to calculate string numbers in addition to the following rules
    to our `StringCalcuatorUpdated` example:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，计算字符串数字，以及我们的`StringCalcuatorUpdated`示例的以下规则：
- en: Throw an exception where the number is greater than 1,000.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数字大于1,000，则抛出异常。
- en: Ignore negative numbers by replacing them with zero.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用零替换负数来忽略负数。
- en: If the entered string is not a number, throw an exception.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果输入的字符串不是数字，则抛出异常。
- en: Write a small program to elaborate on property types.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个小程序详细说明属性类型。
- en: Create a property using validation to meet all rules discussed in *question
    8.*
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个属性，使用验证来满足*问题8*中讨论的所有规则。
- en: What is an exception?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是异常？
- en: How we can handle exceptions in C#? Elaborate using a small program.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在C#中处理异常？通过一个小程序详细阐述。
- en: Write a user-defined exception if a string contains special characters other
    than delimiters, as defined in the requirements of our class `StringCalculatorUpdated`.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个字符串包含除了定界符之外的特殊字符，根据我们的`StringCalculatorUpdated`类的要求，编写一个用户定义的异常。
- en: Write a program to create a file dynamically with the use of various classes
    of the `System.IO` namespace (refer to [https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)).
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个程序，使用`System.IO`命名空间的各种类动态创建文件（参考[https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0](https://docs.microsoft.com/en-us/dotnet/api/system.io.filestream?view=netcore-2.0)）。
- en: What are indexers? Write a short program to create a collection of paginated
    list.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是索引器？编写一个简短的程序来创建一个分页列表的集合。
- en: What are regular expressions and how are they helpful in string manipulation.
    Elaborate using a small program.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正则表达式是什么，它们如何在字符串操作中有帮助。使用一个小程序进行详细说明。
- en: Revisiting Day 04
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾第04天
- en: We are concluding our day four learning. Today, we discussed all available modifiers
    and went through the code examples of these modifiers; we also discussed accessor
    modifiers, namely `public`, `private`, `internal`, `protected`, and so on.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们结束了第四天的学习。今天，我们讨论了所有可用的修饰符，并通过这些修饰符的代码示例进行了讨论；我们还讨论了访问修饰符，即`public`，`private`，`internal`，`protected`等等。
- en: Then, we came to methods and properties, where we discussed various scenarios
    and dealt with programs. We also discussed the indexer and file I/O, and we concluded
    our day by learning regular expressions. We went through the constants and we
    discussed constant filed and constant local.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们来到了方法和属性，我们讨论了各种场景并处理了程序。我们还讨论了索引器和文件I/O，并通过学习正则表达式结束了我们的一天。我们讨论了常量，并讨论了常量字段和常量局部。
- en: Tomorrow, that is, on day five, we will discuss some advanced concepts covering
    reflection and understand how we can create and execute code dynamically.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 明天，也就是第五天，我们将讨论一些高级概念，涵盖反射，并了解如何动态创建和执行代码。
