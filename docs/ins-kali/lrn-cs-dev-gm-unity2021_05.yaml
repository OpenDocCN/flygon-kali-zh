- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Working with Classes, Structs, and OOP
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类、结构和OOP
- en: 'For obvious reasons, the goal of this book isn''t to give you a splitting headache
    from information overload. However, these next topics will take you out of the
    beginner''s cubicle and into the open air of **object-oriented programming** (**OOP**).
    Up to this point, we''ve been relying exclusively on predefined variable types
    that are part of the C# language: under-the-hood strings, lists, and dictionaries
    that are classes, which is why we can create them and use their properties through
    dot notation. However, relying on built-in types has one glaring weakness—the
    inability to deviate from the blueprints that C# has already set.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 出于明显的原因，本书的目标不是让您因信息过载而头痛欲裂。然而，接下来的主题将把您从初学者的小隔间带到**面向对象编程**（**OOP**）的开放空间。到目前为止，我们一直在依赖C#语言中预定义的变量类型：底层的字符串、列表和字典都是类，这就是为什么我们可以创建它们并通过点表示法使用它们的属性。然而，依赖内置类型有一个明显的弱点——无法偏离C#已经设定的蓝图。
- en: Creating your classes gives you the freedom to define and configure blueprints
    of your design, capturing information and driving action that is specific to your
    game or application. In essence, custom classes and OOP are the keys to the programming
    kingdom; without them, unique programs will be few and far between.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 创建您自己的类使您能够定义和配置设计的蓝图，捕获信息并驱动特定于您的游戏或应用程序的操作。实质上，自定义类和OOP是编程王国的关键；没有它们，独特的程序将寥寥无几。
- en: 'In this chapter, you''ll get hands-on experience creating classes from scratch
    and discuss the inner workings of class variables, constructors, and methods.
    You''ll also be introduced to the differences between reference and value type
    objects, and how these concepts can be applied inside Unity. The following topics
    will be discussed in more detail as you move along:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将亲身体验从头开始创建类，并讨论类变量、构造函数和方法的内部工作原理。您还将了解引用类型和值类型对象之间的区别，以及这些概念如何在Unity中应用。随着您的学习，以下主题将会更详细地讨论：
- en: Introducing OOP
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入OOP
- en: Defining classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义类
- en: Declaring structs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明结构
- en: Understanding reference and value types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解引用类型和值类型
- en: Integrating the object-oriented mindset
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合面向对象的思维方式
- en: Applying OOP in Unity
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity中应用OOP
- en: Introducing OOP
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入OOP
- en: OOP is the main programming paradigm that you'll use when coding in C#. If class
    and struct instances are the blueprints of our programs, then OOP is the architecture
    that holds everything together. When we refer to OOP as a programming paradigm,
    we are saying that it has specific principles for how the overall program should
    work and communicate.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#编程时，OOP是您将使用的主要编程范式。如果类和结构实例是我们程序的蓝图，那么OOP就是将所有东西都组合在一起的架构。当我们将OOP称为编程范式时，我们是说它对整个程序的工作和通信有特定的原则。
- en: Essentially, OOP focuses on objects rather than pure sequential logic—the data
    they hold, how they drive action, and, most importantly, how they communicate
    with each other.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 实质上，OOP关注的是对象而不是纯粹的顺序逻辑——它们所持有的数据，它们如何驱动行动，以及最重要的是它们如何相互通信。
- en: Defining classes
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义类
- en: Back in *Chapter 2*, *The Building Blocks of Programming*, we briefly talked
    about how classes are blueprints for objects and mentioned that they can be treated
    as custom variable types. We also learned that the `LearningCurve`script is a
    class, but a special one that Unity can attach to objects in the scene. The main
    thing to remember with classes is that they are *reference types*—that is, when
    they are assigned or passed to another variable, the original object is referenced,
    not a new copy. We'll get into this after we discuss structs. However, before
    any of that, we need to understand the basics of creating classes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第2章*，*编程的基本组成部分*，我们简要讨论了类是对象的蓝图，并提到它们可以被视为自定义变量类型。我们还了解到`LearningCurve`脚本是一个类，但是Unity可以将其附加到场景中的对象。关于类的主要事情要记住的是它们是*引用类型*——也就是说，当它们被分配或传递给另一个变量时，引用的是原始对象，而不是一个新的副本。在我们讨论结构之后，我们将深入讨论这一点。然而，在此之前，我们需要了解创建类的基础知识。
- en: 'For now, we''re going to set aside how classes and scripts work in Unity and
    focus on how they are created and used in C#. Classes are created using the `class`
    keyword, as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将暂时搁置Unity中类和脚本的工作方式，专注于它们在C#中是如何创建和使用的。类是使用`class`关键字创建的，如下所示：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any variables or methods declared inside a class belong to that class and are
    accessed through its unique class name.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类内声明的任何变量或方法都属于该类，并通过其独特的类名访问。
- en: To make the examples as cohesive as possible throughout this chapter, we'll
    be creating and modifying a simple `Character` class that a typical game would
    have. We'll also be moving away from code screenshots to get you accustomed to
    reading and interpreting code as you would see it "in the wild." However, the
    first thing we need is a custom class of our own, so let's create one.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章中的示例尽可能连贯，我们将创建和修改一个典型游戏可能拥有的简单`Character`类。我们还将摆脱代码截图，让您习惯于阅读和解释代码，就像在实际环境中看到的那样。然而，我们首先需要自己的自定义类，所以让我们创建一个。
- en: 'We''ll need a class to practice with before we can understand their inner workings,
    so let''s create a new C# script and start from scratch:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们理解它们的内部工作原理之前，我们需要一个类来进行实践，所以让我们创建一个新的C#脚本，从头开始。
- en: Right-click on the `Scripts` folder that you created in *Chapter 1*, *Getting
    to Know Your Environment*, and choose **Create** | **C# Script**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您在*第1章*中创建的`Scripts`文件夹，然后选择**创建** | **C#脚本**。
- en: Name the script `Character`, open it up in Visual Studio, and delete all the
    generated code.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本命名为`Character`，在Visual Studio中打开它，并删除所有生成的代码。
- en: 'Declare a public class called `Character` followed by a set of curly braces,
    and then save the file. Your class code should exactly match the following code:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`Character`的公共类，后面跟着一对花括号，然后保存文件。您的类代码应该与以下代码完全匹配：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We deleted the generated code because we won't need to attach this script to
    a Unity GameObject.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们删除了生成的代码，因为我们不需要将这个脚本附加到Unity游戏对象上。
- en: '`Character` is now registered as a public class blueprint. This means that
    any class in the project can use it to create characters. However, these are just
    the instructions—to create a character takes an additional step. This creational
    step is called *instantiation* and is the subject of the next section.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Character`现在被注册为一个公共类蓝图。这意味着项目中的任何类都可以使用它来创建角色。然而，这些只是指示——创建角色需要额外的步骤。这个创建步骤被称为*实例化*，并且是下一节的主题。'
- en: Instantiating class objects
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例化类对象
- en: Instantiation is the act of creating an object from a specific set of instructions,
    which is called an instance. If classes are blueprints, instances are the houses
    built from their instructions; every new instance of `Character` is its object,
    just like two houses built from the same instructions are still two different
    physical structures. What happens to one doesn't have any repercussions on the
    other.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化是根据特定一组指令创建对象的行为，这个对象被称为实例。如果类是蓝图，实例就是根据它们的指令建造的房屋；每个新的`Character`实例都是它的对象，就像根据相同指令建造的两个房屋仍然是两个不同的物理结构一样。一个的变化对另一个没有任何影响。
- en: In *Chapter 4*, *Control Flow and Collection Types*, we created lists and dictionaries,
    which are default classes that come with C#, using their types and the `new` keyword.
    We can do the same thing for custom classes such as `Character`, which you'll
    do next.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第4章*，*控制流和集合类型*中，我们创建了列表和字典，这些是C#默认的类，使用它们的类型和`new`关键字。我们可以对自定义类（比如`Character`）做同样的事情，这就是你接下来要做的。
- en: We declared the `Character` class as public, which means that a `Character`
    instance can be created in any other class. Since we have `LearningCurve`working
    already, let's declare a new character in the `Start()` method.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Character`类声明为公共的，这意味着在任何其他类中都可以创建`Character`实例。由于我们已经在`LearningCurve`中工作了，让我们在`Start()`方法中声明一个新的角色。
- en: 'Open `LearningCurve` and declare a new `Character` type variable, called `hero`,
    in the `Start()` method:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`方法中打开`LearningCurve`并声明一个名为`hero`的新的`Character`类型变量：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s break this down one step at a time:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来分解这个问题：
- en: The variable type is specified as `Character`, meaning that the variable is
    an instance of that class.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量类型被指定为`Character`，这意味着变量是该类的一个实例。
- en: The variable is named `hero`, and it is created using the `new` keyword, followed
    by the `Character` class name and two parentheses. This is where the actual instance
    is created in the program's memory, even if the class is empty right now.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名为`hero`，它是使用`new`关键字创建的，后面跟着`Character`类名和两个括号。这是实例在程序内存中创建的地方，即使类现在是空的。
- en: We can use the `hero` variable just like any other object we've worked with
    so far. When the `Character` class gets variables and methods of its own, we can
    access them from `hero` using dot notation.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以像处理到目前为止的任何其他对象一样使用`hero`变量。当`Character`类有了自己的变量和方法时，我们可以使用点符号从`hero`中访问它们。
- en: 'You could just as easily have used an inferred declaration when creating the
    `hero` variable, like so:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`hero`变量时，你也可以使用推断声明，就像这样：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now our character class can't do much without any class fields to work with.
    You'll be adding class fields, and more, in the next few sections.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的角色类没有任何类字段的话就不能做太多事情。在接下来的几节中，你将添加类字段，以及更多内容。
- en: Adding class fields
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加类字段
- en: 'Adding variables, or fields, to a custom class is no different than what we''ve
    already been doing with `LearningCurve`. The same concepts apply, including access
    modifiers, variable scope, and value assignments. However, any variables belonging
    to a class are created with the class instance, meaning that if there are no values
    assigned, they will default to zero or null. In general, choosing to set initial
    values comes down to what information they will store:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 向自定义类添加变量或字段与我们在`LearningCurve`中已经做过的事情没有什么不同。相同的概念适用，包括访问修饰符、变量作用域和值分配。然而，属于类的任何变量都是与类实例一起创建的，这意味着如果没有分配值，它们将默认为零或空。一般来说，选择设置初始值取决于它们将存储的信息：
- en: If a variable needs to have the same starting value whenever a class instance
    is created, setting an initial value is a solid idea. This would be useful for
    something like experience points or the starting score.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个变量在创建类实例时需要具有相同的起始值，设置初始值是一个很好的主意。这对于像经验点或起始分数之类的东西会很有用。
- en: If a variable needs to be customized in every class instance, like `CharacterName`,
    leave its value unassigned and use a class constructor (a topic that we'll get
    to in the *Using constructors* section).
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个变量需要在每个类实例中进行自定义，比如`CharacterName`，就将其值保持未分配，并使用类构造函数（这是我们将在*使用构造函数*部分讨论的一个主题）。
- en: Every character class is going to need a few basic fields; it's your job to
    add them in the following section.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色类都需要一些基本字段；在接下来的部分中，你需要添加它们。
- en: 'Let''s incorporate two variables to hold the character''s name and the number
    of starting experience points:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加入两个变量来保存角色的名称和起始经验点数：
- en: Add two `public` variables inside the `Character` class's curly braces—a `string`
    variable for the name, and an `integer` variable for the experience points.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Character`类的大括号内添加两个`public`变量——一个用于名称的`string`变量，一个用于经验点的`integer`变量。
- en: 'Leave the `name` value empty, but set the experience points to `0` so that
    every character starts from the bottom:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`name`值留空，但将经验点设置为`0`，这样每个角色都从零开始：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add a debug log in `LearningCurve`right after the `Character` instance was
    initialized. Use it to print out the new character''s `name` and `exp` variables
    using dot notation:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Character`实例初始化后，在`LearningCurve`中添加一个调试日志。使用它来打印出新角色的`name`和`exp`变量，使用点符号表示法：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When `hero` is initialized, `name` is assigned a null value that shows up as
    an empty space in the debug log, while `exp` prints out `0`. Notice that we didn't
    have to attach the `Character` script to any GameObjects in the scene; we just
    referenced them in `LearningCurve` and Unity did the rest. The console will now
    debug out our character information, which is referenced as follows:![](img/B17573_05_01.png)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`hero`被初始化时，`name`被分配一个空值，在调试日志中显示为空格，而`exp`打印出`0`。请注意，我们不需要将`Character`脚本附加到场景中的任何游戏对象上；我们只是在`LearningCurve`中引用它们，Unity会完成其余的工作。控制台现在将调试输出我们的角色信息，如下所示：![](img/B17573_05_01.png)
- en: 'Figure 5.1: Screenshot of custom class properties printed in the console'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：控制台中打印的自定义类属性的屏幕截图
- en: At this point, our class is working, but it's not very practical with these
    empty values. You'll need to fix that with what's called a class constructor.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的类可以工作，但是使用这些空值并不是很实用。您需要使用所谓的类构造函数来解决这个问题。
- en: Using constructors
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数
- en: 'Class constructors are special methods that fire automatically when a class
    instance is created, which is similar to how the `Start` method runs in `LearningCurve`.
    Constructors build the class according to its blueprint:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数是特殊的方法，当创建类实例时会自动触发，这类似于`LearningCurve`中`Start`方法的运行方式。构造函数根据其蓝图构建类：
- en: If a constructor is not specified, C# generates a default one. The default constructor
    sets any variables to their default type values—numeric values are set to zero,
    Booleans to false, and reference types (classes) to null.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有指定构造函数，C#会生成一个默认构造函数。默认构造函数将任何变量设置为它们的默认类型值——数值变量设置为零，布尔变量设置为false，引用类型（类）设置为null。
- en: Custom constructors can be defined with parameters, just like any other method,
    and are used to set class variable values at initialization.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义构造函数可以带有参数，就像任何其他方法一样，并且用于在初始化时设置类变量的值。
- en: A class can have multiple constructors.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以有多个构造函数。
- en: Constructors are written like regular methods but with a few differences; for
    instance, they need to be public, have no return type, and the method name is
    always the class name. As an example, let's add a basic constructor with no parameters
    to the `Character` class and set the name field to something other than null.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数的编写方式与常规方法相似，但有一些区别；例如，它们需要是公共的，没有返回类型，方法名始终是类名。例如，让我们向`Character`类添加一个没有参数的基本构造函数，并将名称字段设置为非null值。
- en: 'Add this new code directly underneath the class variables, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段新代码直接添加到类变量下面，如下所示：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the project in Unity and you''ll see the `hero` instance using this new
    constructor. The debug log will show the hero''s name as **Not assigned** instead
    of a null value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中运行项目，您将看到`hero`实例使用这个新的构造函数。调试日志将显示英雄的名称为**未分配**，而不是空值：
- en: '![](img/B17573_05_02.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_05_02.png)'
- en: 'Figure 5.2: Screenshot of unassigned custom class variables printed to the
    console'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：控制台中打印的未分配的自定义类变量的屏幕截图
- en: This is good progress, but we need the class constructor to be more flexible.
    This means that we need to be able to pass in values so that they can be used
    as starting values, which you'll do next.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的进展，但是我们需要使类构造函数更加灵活。这意味着我们需要能够传入值，以便它们可以作为起始值使用，接下来您将要做的就是这个。
- en: 'Now, the `Character` class is starting to behave more like a real object, but
    we can make this even better by adding a second constructor to take in a name
    at initialization and set it to the `name` field:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Character`类开始表现得更像一个真正的对象，但我们可以通过添加第二个构造函数来使其更好，以便在初始化时接受一个名称并将其设置为`name`字段：
- en: Add another constructor to `Character` that takes in a `string` parameter, called
    `name`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Character`中添加另一个接受`string`参数的构造函数，称为`name`。
- en: 'Assign the parameter to the class''s `name` variable using the `this` keyword.
    This is called *constructor overloading*:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`this`关键字将参数分配给类的`name`变量。这被称为*构造函数重载*：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For convenience, constructors will often have parameters that share a name with
    a class variable. In these cases, use the `this` keyword to specify which variable
    belongs to the class. In the example here, `this.name` refers to the class's name
    variable, while `name` is the parameter; without the `this` keyword, the compiler
    will throw a warning because it won't be able to tell them apart.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，构造函数通常会具有与类变量同名的参数。在这些情况下，使用`this`关键字指定变量属于类。在这个例子中，`this.name`指的是类的名称变量，而`name`是参数；如果没有`this`关键字，编译器会发出警告，因为它无法区分它们。
- en: 'Create a new `Character` instance in `LearningCurve`, called `heroine`. Use
    the custom constructor to pass in a name when it''s initialized and print out
    the details in the console:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中创建一个新的`Character`实例，称为`heroine`。在初始化时使用自定义构造函数传入一个名称，并在控制台中打印出详细信息：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When a class has multiple constructors or a method has multiple variations,
    Visual Studio will show a set of arrows in the autocomplete popup that can be
    scrolled through using the arrow keys:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类有多个构造函数或一个方法有多个变体时，Visual Studio会在自动完成弹出窗口中显示一组箭头，可以使用箭头键滚动浏览：
- en: '![](img/B17573_05_03.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_05_03.png)'
- en: 'Figure 5.3: Screenshot of multiple method constructors in Visual Studio'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：Visual Studio中多个方法构造函数的屏幕截图
- en: We can now choose between the basic and custom constructor when we initialize
    a new `Character` class. The `Character` class itself is now far more flexible
    when it comes to configuring different instances for different situations:![](img/B17573_05_04.png)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在初始化新的`Character`类时选择基本构造函数或自定义构造函数。`Character`类本身在配置不同情况下的不同实例时现在更加灵活了：![](img/B17573_05_04.png)
- en: 'Figure 5.4: Screenshot of multiple custom class instances printed in the console'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4：控制台中打印的多个自定义类实例的屏幕截图
- en: Now the real work starts; our class needs methods to be able to do anything
    useful besides acting as a storage facility for variables. Your next task is to
    put this into practice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在真正的工作开始了；除了作为变量存储设施之外，我们的类还需要方法才能做任何有用的事情。您的下一个任务是将这个付诸实践。
- en: Declaring class methods
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类方法
- en: Adding methods to custom classes is no different from adding them to `LearningCurve`.
    However, this is a good opportunity to talk about a staple of good programming—**Don't
    Repeat Yourself** (**DRY**). DRY is a benchmark of all well-written code. Essentially,
    if you find yourself writing the same line, or lines, over and over, it's time
    to rethink and reorganize. This usually takes the form of a new method to hold
    the repeated code, making it easier to modify and call that functionality elsewhere
    in the current script or even from other scripts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将自定义类添加方法与将它们添加到`LearningCurve`没有任何区别。然而，这是一个很好的机会来谈谈良好编程的基本原则——**不要重复自己**（**DRY**）。DRY是所有良好编写代码的基准。基本上，如果你发现自己一遍又一遍地写同样的代码行，那么是时候重新思考和重新组织了。这通常以创建一个新方法来保存重复的代码形式出现，这样可以更容易地修改和调用该功能，无论是在当前脚本中还是在其他脚本中。
- en: In programming terms, you'll see this referred to as **abstracting** out a method
    or feature.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，你会看到这被称为**抽象**出一个方法或特性。
- en: We have a fair bit of repeated code already, so let's take a look and see where
    we can increase the legibility and efficiency of our scripts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了相当多的重复代码，所以让我们看看在哪里可以增加脚本的可读性和效率。
- en: 'Our repeated debug logs are a perfect opportunity to abstract out some code
    directly into the `Character` class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重复的调试日志是一个很好的机会，可以将一些代码直接抽象到`Character`类中：
- en: Add a new `public` method with a `void` return type, called `PrintStatsInfo`,
    to the `Character` class.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`Character`类添加一个名为`PrintStatsInfo`的新`public`方法，返回类型为`void`。
- en: Copy and paste the debug log from `LearningCurve` into the method body.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LearningCurve`中的调试日志复制粘贴到方法体中。
- en: 'Change the variables to `name` and `exp`, since they can now be referenced
    from the class directly:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将变量更改为`name`和`exp`，因为现在可以直接从类引用它们。
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Replace the character debug log that we previously added to `LearningCurve`with
    method calls to `PrintStatsInfo`, and click on play:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用对`PrintStatsInfo`的方法调用替换我们之前添加到`LearningCurve`中的角色调试日志，然后点击播放：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that the `Character` class has a method, any instance can freely access
    it using dot notation. Since `hero` and `heroine` are both separate objects, `PrintStatsInfo`
    debugs their respective `name` and `exp` values to the console.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在`Character`类有了一个方法，任何实例都可以使用点表示法自由访问它。由于`hero`和`heroine`都是独立的对象，`PrintStatsInfo`会将它们各自的`name`和`exp`值调试到控制台。
- en: This behavior is better than having the debug logs directly in `LearningCurve`.
    It's always a good idea to group functionality into a class and drive action through
    methods. This makes the code more readable—as our `Character` objects are giving
    a command when printing out the debug logs, instead of repeating code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为比直接在`LearningCurve`中拥有调试日志要好。将功能组合到一个类中并通过方法驱动操作总是一个好主意。这样可以使代码更易读——因为我们的`Character`对象在打印调试日志时发出了命令，而不是重复代码。
- en: 'The entire `Character` class should look like the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`Character`类应该如下所示的代码：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With classes covered, you're well on your way to writing modularized code that's
    readable, lightweight, and reusable. Now it's time to tackle the class's cousin
    object —the struct!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对类的讲解，你已经可以写出可读性强、轻量级且可重用的模块化代码了。现在是时候来解决类的表亲对象——结构体了！
- en: Declaring structs
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明结构体
- en: '**Structs** are similar to classes in that they are also blueprints for objects
    you want to create in your programs. The main difference is that they are *value
    types*, meaning they are passed by value instead of reference, like classes are.
    When structs are assigned or passed to another variable, a new copy of the struct
    is created, so the original isn''t referenced at all. We''ll go into this in more
    detail in the next section. First, we need to understand how structs work and
    the specific rules that apply when creating them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**结构体**与类似，它们也是你想在程序中创建的对象的蓝图。主要区别在于它们是*值类型*，这意味着它们是按值传递而不是按引用传递的，就像类一样。当结构体被分配或传递给另一个变量时，会创建结构体的一个新副本，因此原始结构体根本没有被引用。我们将在下一节中更详细地讨论这一点。首先，我们需要了解结构体的工作原理以及创建它们时适用的具体规则。'
- en: 'Structs are declared in the same way as classes, and can hold fields, methods,
    and constructors:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的声明方式与类相同，可以包含字段、方法和构造函数。
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Like classes, any variables and methods belong exclusively to the struct and
    are accessed by its unique name.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与类一样，任何变量和方法都属于结构体，并且通过其唯一名称访问。
- en: 'However, structs have a few limitations:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构体有一些限制：
- en: Variables cannot be initialized with values inside the struct declaration unless
    they're marked with the `static` or `const` modifier—you can read more about this
    in *Chapter 10*, *Revisiting Types, Methods, and Classes*.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非标记为`static`或`const`修饰符，否则不能在结构体声明中使用值初始化变量——你可以在*第10章*，*重新审视类型、方法和类*中了解更多信息。
- en: Constructors without parameters aren't permitted.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许没有参数的构造函数。
- en: Structs come with a default constructor that will automatically set all variables
    to their default values according to their type.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体带有一个默认构造函数，它会自动将所有变量设置为它们的默认值，根据它们的类型。
- en: Every character requires a good weapon, and these weapons are the perfect fit
    for a struct object over a class. We'll discuss why that is in the *Understanding
    reference and value types* section of this chapter. However, first, you're going
    to create one to play around with.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色都需要一把好武器，这些武器是结构体对象的完美选择。我们将在本章的*理解引用和值类型*部分讨论为什么这样做。然而，首先，你要创建一个结构体来玩耍。
- en: 'Our characters are going to need good weapons to see them through quests, which
    are good candidates for a simple struct:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色需要好的武器来完成任务，这对于一个简单的结构体来说是一个很好的选择：
- en: Right-click on the `Scripts` folder, choose **Create**, and select **C# Script**.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Scripts`文件夹，选择**创建**，然后选择**C#脚本**。
- en: Name it `Weapon`, open it up in Visual Studio, and delete all the generated
    code after `using UnityEngine`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为`Weapon`，在Visual Studio中打开它，然后删除`using UnityEngine`后面生成的所有代码。
- en: Declare a public struct called `Weapon`, followed by a set of curly braces,
    and then save the file.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`Weapon`的公共结构体，然后保存文件。
- en: 'Add a field for `name` of type `string` and another field for `damage` of type
    `int`:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`string`类型的`name`字段和一个`int`类型的`damage`字段：
- en: You can have classes and structs nested within each other, but this is generally
    frowned upon because it clutters up the code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在彼此嵌套的类和结构中，但这通常是不被赞同的，因为它会使代码变得混乱。
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Declare a constructor with the `name` and `damage` parameters, and set the
    struct fields using the `this` keyword:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`name`和`damage`参数声明一个构造函数，并使用`this`关键字设置结构字段：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a debug method below the constructor to print out the weapon information:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数下面添加一个调试方法来打印武器信息：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `LearningCurve`, create a new `Weapon` struct using the custom constructor
    and the `new` keyword:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中，使用自定义构造函数和`new`关键字创建一个新的`Weapon`结构：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our new `huntingBow` object uses the custom constructor and provides values
    for both fields on initialization.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的新`huntingBow`对象使用了自定义构造函数，并在初始化时为两个字段提供了值。
- en: It's a good idea to limit scripts to a single class, but it's fairly common
    to see structs that are used exclusively by a class included in the file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将脚本限制为单个类是一个好主意，但看到仅由一个类专用的结构体包含在文件中是相当常见的。
- en: Now that we have an example of both reference (class) and value (struct) objects,
    it's time to get acquainted with each of their finer points. More specifically,
    you'll need to understand how each of these objects is passed and stored in memory.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了引用（类）和值（结构）对象的例子，是时候熟悉它们各自的细节了。更具体地说，你需要了解这些对象是如何在内存中传递和存储的。
- en: Understanding reference and value types
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解引用类型和值类型
- en: Other than keywords and initial field values, we haven't seen much difference
    between classes and structs so far. Classes are best suited for grouping together
    complex actions and data that will change throughout a program; structs are a
    better choice for simple objects and data that will remain constant for the most
    part. Besides their uses, they are fundamentally different in one key area—that
    is, how they are passed or assigned between variables. Classes are *reference
    types*, meaning that they are passed by reference; structs are *value types*,
    meaning that they are passed by value.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了关键字和初始字段值之外，到目前为止我们还没有看到类和结构之间有太大的区别。类最适合将复杂的操作和数据组合在一起，并且这些数据在程序运行过程中会发生变化；而结构更适合简单的对象和数据，这些数据在大部分时间内都保持不变。除了它们的用途之外，在一个关键领域它们有根本的不同——那就是它们是如何在变量之间传递或赋值的。类是*引用类型*，意味着它们是通过引用传递的；结构是*值类型*，意味着它们是通过值传递的。
- en: Reference types
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型
- en: When the instances of our `Character` class are initialized, the `hero` and
    `heroine` variables don't hold their class information—instead, they hold a reference
    to where the object is located in the program's memory. If we assigned `hero`
    or `heroine` to another variable in the same class, the memory reference is assigned,
    not the character data. This has several implications, the most important being
    that if we have multiple variables storing the same memory reference, a change
    to one affects them all.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的`Character`类的实例被初始化时，`hero`和`heroine`变量并不持有它们的类信息——相反，它们持有对象在程序内存中的位置的引用。如果我们将`hero`或`heroine`分配给同一类中的另一个变量，那么内存引用就会被分配，而不是角色数据。这有几个影响，其中最重要的是，如果我们有多个变量存储相同的内存引用，对其中一个的更改会影响它们全部。
- en: Topics like this are better demonstrated than explained; it's up to you to try
    this out in a practical example, next.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的话题最好是通过演示而不是解释来展示；接下来就由你来在实际例子中尝试一下。
- en: 'It''s time to test that the `Character` class is a reference type:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试`Character`类是引用类型了：
- en: Declare a new `Character` variable in `LearningCurve` called `hero2`. Assign
    `hero2` to the `hero` variable and use the `PrintStatsInfo` method to print out
    both sets of information.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中，声明一个名为`hero2`的新`Character`变量。将`hero2`分配给`hero`变量，并使用`PrintStatsInfo`方法打印出两组信息。
- en: 'Click playand take a look at the two debug logs that show up in the console:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并查看在控制台中显示的两个调试日志：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The two debug logs will be identical because `hero2` was assigned to `hero`
    when it was created. At this point, both `hero2` and `hero` point to where `hero`
    is located in memory:![](img/B17573_05_05.png)
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两个调试日志将是相同的，因为在创建`hero2`时它被赋值给了`hero`。此时，`hero2`和`hero`都指向内存中`hero`所在的位置！[](img/B17573_05_05.png)
- en: 'Figure 5.5: Screenshot of the struct stats printed to the console'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.5：控制台打印的结构体统计信息的屏幕截图
- en: 'Now, change the name of `hero2` to something fun and click playagain:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`hero2`的名字改成有趣的东西，然后再次点击播放：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You'll see that both `hero` and `hero2` now have the same name, even though
    only one of our characters' data was changed:![](img/B17573_05_06.png)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到现在`hero`和`hero2`都有相同的名字，即使只有一个角色的数据被改变了！[](img/B17573_05_06.png)
- en: 'Figure 5.6: Screenshot of class instance properties printed to the console'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.6：控制台打印的类实例属性的屏幕截图
- en: The lesson here is that reference types need to be treated carefully and not
    copied when assigned to new variables. Any change to one reference trickles through
    all other variables holding the same reference.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，引用类型需要小心处理，不要在分配给新变量时进行复制。对一个引用的任何更改都会影响所有持有相同引用的其他变量。
- en: If you're trying to copy a class, either create a new, separate instance or
    reconsider whether a struct might be a better choice for your object blueprint.
    You'll get a better glimpse of value types in the following section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想复制一个类，要么创建一个新的独立实例，要么重新考虑是否结构体可能是你对象蓝图的更好选择。在接下来的部分中，你将更好地了解值类型。
- en: Value types
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: When a struct object is created, all of its data is stored in its corresponding
    variable with no references or connections to its memory location. This makes
    structs useful for creating objects that need to be copied quickly and efficiently,
    while still retaining their separate identities. Try this out with our `Weapon`
    struct in the following exercise.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个结构对象时，它的所有数据都存储在相应的变量中，没有引用或连接到它的内存位置。这使得结构对于创建需要快速高效地复制的对象非常有用，同时仍保留它们各自的身份。在接下来的练习中，尝试使用我们的`Weapon`结构来实现这一点。
- en: 'Let''s create a new weapon object by copying `huntingBow` into a new variable
    and updating its data to see whether the changes affect both structs:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过将`huntingBow`复制到一个新变量中并更新其数据来创建一个新的武器对象，以查看更改是否影响两个结构体：
- en: 'Declare a new `Weapon` struct in `LearningCurve`, andassign `huntingBow` as
    its initial value:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中声明一个新的`Weapon`结构，并将`huntingBow`分配为其初始值：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Print out each weapon''s data using the debug method:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用调试方法打印出每个武器的数据：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The way they're set up now, both `huntingBow` and `warBow` will have the same
    debug logs, just like our two characters did before we changed any data:![](img/B17573_05_07.png)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在它们的设置方式是，`huntingBow`和`warBow`将有相同的调试日志，就像我们在改变任何数据之前的两个角色一样！
- en: 'Figure 5.7: Screenshot of the struct instances printed to the console'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.7：控制台中打印的结构体实例的屏幕截图
- en: 'Change the `warBow.name` and `warBow.damage` fields to values of your choice
    and click on play again:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`warBow.name`和`warBow.damage`字段更改为你选择的值，然后再次点击播放：
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The console will show that only the data relating to `warBow` was changed, and
    that `huntingBow` retains its original data.![](img/B17573_05_08.png)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制台将显示只有与`warBow`相关的数据被更改，而`huntingBow`保留其原始数据。
- en: 'Figure 5.8: Screenshot of updated struct properties printed to console'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8：打印到控制台的更新后的结构体属性的屏幕截图
- en: The takeaway from this example is that structs are easily copied and modified
    as their separate objects, unlike classes, which retain references to an original
    object. Now that we understand a little more about how structs and classes work
    under the hood, and confirmed how reference and value types behave in their natural
    habitat, we're in a good place to start talking about one of the most important
    coding topics, OOP, and how it fits into the programming landscape.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以得出的结论是，结构体很容易被复制和修改为它们各自的对象，而类则保留对原始对象的引用。现在我们对结构体和类在底层是如何工作有了一些了解，并确认了引用和值类型在它们的自然环境中的行为，我们可以开始谈论编程中最重要的一个主题，OOP，以及它如何适应编程领域。
- en: Integrating the object-oriented mindset
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合面向对象的思维方式
- en: Things in the physical world operate on a similar level to OOP; when you want
    to buy a soft drink, you grab a can of soda, not the liquid itself. The can is
    an object, grouping related information and actions together in a self-contained
    package. However, there are rules when dealing with objects, both in programming
    and the grocery store —for instance, who can access them. Different variations
    and generic actions all play into the nature of the objects all around us.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 物理世界中的事物在OOP的类似级别上运行；当你想要买一罐软饮料时，你拿的是一罐苏打水，而不是液体本身。这个罐子是一个对象，将相关信息和动作组合在一个自包含的包中。然而，在处理对象时有一些规则，无论是在编程中还是在杂货店——例如，谁可以访问它们。不同的变化和通用的动作都影响着我们周围所有对象的性质。
- en: 'In programming terms, these rules are the main tenets of OOP: *encapsulation*,
    *inheritance*, and *polymorphism*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程术语中，这些规则是OOP的主要原则：*封装*、*继承*和*多态*。
- en: Encapsulation
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: One of the best things about OOP is that it supports encapsulation—defining
    how accessible an object's variables and methods are to outside code (this is
    sometimes referred to as *calling code*). Take our soda can as an example—in a
    vending machine, the possible interactions are limited. Since the machine is locked,
    not just anyone can come up and grab one; if you happen to have the right change,
    you'll be allowed provisional access to it, but in a specified quantity. If the
    machine itself is locked inside a room, only someone with the door key will even
    know the soda can exists.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: OOP最好的一点是它支持封装——定义对象的变量和方法对外部代码的可访问性（有时被称为*调用代码*）。以我们的苏打罐为例——在自动售货机中，可能的互动是有限的。由于机器被锁住，不是每个人都可以过来拿一罐；如果你碰巧有合适的零钱，你将被允许有条件地访问它，但数量是有限制的。如果机器本身被锁在一个房间里，只有拿着门钥匙的人才会知道苏打罐的存在。
- en: The question you're asking yourself now is, how do we set these limitations?
    The simple answer is that we've been using encapsulation this entire time by specifying
    access modifiers for our object variables and methods.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在要问自己的问题是，我们如何设置这些限制？简单的答案是，我们一直在使用封装，通过为我们的对象变量和方法指定访问修饰符。
- en: If you need a refresher, go back and visit the *Access modifiers* section in
    *Chapter 3*, *Diving into Variables, Types, and Methods*.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复习，请回到*第3章*，*深入变量、类型和方法*中的*访问修饰符*部分。
- en: 'Let''s try out a simple encapsulation example to understand how this works
    in practice. Our `Character` class is public, as are its fields and methods. However,
    what if we wanted a method that can reset a character''s data to its initial values?
    This could come in handy, but could prove disastrous if it was accidentally called,
    making it a perfect candidate for a private object member:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个简单的封装示例，以了解这在实践中是如何工作的。我们的`Character`类是公共的，它的字段和方法也是公共的。但是，如果我们想要一个方法来将角色的数据重置为其初始值，会怎样呢？这可能会很方便，但如果意外调用了它，可能会造成灾难，这就是一个私有对象成员的完美候选者：
- en: 'Create a `private` method called `Reset`, with no return value inside the `Character`
    class. Set the `name` and `exp` variables back to `"Not assigned"` and `0`, respectively:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Character`类中创建一个名为`Reset`的`private`方法，没有返回值。将`name`和`exp`变量分别设置为`"Not assigned"`和`0`：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Try and call `Reset()` from `LearningCurve` after printing out the `hero2` data:![](img/B17573_05_09.png)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在打印出`hero2`数据后从`LearningCurve`中调用`Reset()`！
- en: 'Figure 5.9: Screenshot of an inaccessible method in the Character class'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9：Character类中一个无法访问的方法的屏幕截图
- en: If you're wondering whether Visual Studio is broken, it's not. Marking a method
    or variable as private will make it inaccessible inside this class or struct using
    dot notation; if you manually type it in and hover over `Reset()`, you'll see
    an error message regarding the method being protected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道Visual Studio是否出了问题，它没有。将方法或变量标记为私有将使其在这个类或结构体内部使用点表示法时无法访问；如果你手动输入并悬停在`Reset()`上，你会看到有关该方法受保护的错误消息。
- en: 'To actually call this private method, we could add a reset command inside the
    class constructor:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际调用这个私有方法，我们可以在类构造函数中添加一个重置命令：
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Encapsulation does allow more complex accessibility setups with objects; however,
    for now, we're going to stick with `public` and `private` members. As we begin
    to flesh out our game prototype in the next chapter, we'll add in different modifiers
    as needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 封装确实允许对象具有更复杂的可访问性设置；然而，现在我们将坚持使用 `public` 和 `private` 成员。在下一章中，当我们开始完善游戏原型时，我们将根据需要添加不同的修饰符。
- en: Now, let's talk about inheritance, which is going to be your best friend when
    creating class hierarchies in your future games.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈继承，在创建未来游戏中的类层次结构时，它将成为您的好朋友。
- en: Inheritance
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: A C# class can be created in the image of another class, sharing its member
    variables and methods, but able to define its unique data. In OOP, we refer to
    this as *inheritance*, and it's a powerful way of creating related classes without
    having to repeat code. Take the soda example again—there are generic sodas on
    the market that have all the same basic properties, and then there are special
    sodas. The special sodas share the same basic properties but have different branding,
    or packaging, that sets them apart. When you look at both side by side, it's obvious
    that they're both cans of soda—but they're also obviously not the same.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: C# 类可以按照另一个类的形象创建，共享其成员变量和方法，但能够定义其独特的数据。在面向对象编程中，我们将这称为*继承*，这是一种创建相关类的强大方式，而无需重复代码。再次以汽水为例，市场上有通用汽水，它们具有相同的基本属性，还有特殊汽水。特殊汽水共享相同的基本属性，但具有不同的品牌或包装，使它们与众不同。当您将两者并排看时，很明显它们都是汽水罐，但它们显然不是同一种。
- en: The original class is usually called the base or parent class, while the inheriting
    class is called the derived or child class. Any base class members marked with
    the `public`, `protected`, or `internal` access modifiers are automatically part
    of the derived class—except for constructors. Class constructors always belong
    to their containing class, but they can be used from derived classes to keep repeated
    code to a minimum. Don't worry too much about the different base class scenarios
    right now. Instead, let's try out a simple game example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 原始类通常称为基类或父类，而继承类称为派生类或子类。任何使用 `public`、`protected` 或 `internal` 访问修饰符标记的基类成员都自动成为派生类的一部分，除了构造函数。类构造函数始终属于其包含类，但可以从派生类中使用，以将重复的代码最小化。现在不要太担心不同的基类情况。相反，让我们尝试一个简单的游戏示例。
- en: 'Most games have more than one type of character, so let''s create a new class
    called `Paladin` that inherits from the `Character` class. You can add this new
    class to the `Character` script or create a new one. If you''re adding the new
    class to the `Character` script, make sure it''s outside the `Character` class''s
    curly brackets:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数游戏都有多种类型的角色，因此让我们创建一个名为 `Paladin` 的新类，该类继承自 `Character` 类。您可以将这个新类添加到 `Character`
    脚本中，也可以创建一个新的脚本。如果要将新类添加到 `Character` 脚本中，请确保它在 `Character` 类的花括号之外：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Just as `LearningCurve`inherits from `MonoBehavior`, all we need to do is add
    a colon and the base class we want to inherit from, and C# does the rest. Now,
    any `Paladin` instances will have access to a `name` property and an `exp` property
    along with a `PrintStatsInfo` method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `LearningCurve` 从 `MonoBehavior` 继承一样，我们只需要添加一个冒号和我们想要继承的基类，C# 就会完成剩下的工作。现在，任何
    `Paladin` 实例都可以访问 `name` 属性和 `exp` 属性，以及 `PrintStatsInfo` 方法。
- en: It's generally considered best practice to create a new script for different
    classes instead of adding them to existing ones. This separates your scripts and
    avoids having too many lines of code in any single file (called a bloated file).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好为不同的类创建新的脚本，而不是将它们添加到现有的脚本中。这样可以分离脚本，并避免在任何单个文件中有太多行代码（称为臃肿文件）。
- en: This is great, but how do inherited classes handle their construction? You can
    find out in the following section.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但继承类如何处理它们的构造？您可以在下一节中找到答案。
- en: Base constructors
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础构造函数
- en: 'When a class inherits from another class, they form a pyramid of sorts with
    member variables flowing down from the parent class to any of its derived children.
    The parent class isn''t aware of any of its children, but all children are aware
    of their parent. However, parent class constructors can be called directly from
    child constructors with a simple syntax modification:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类从另一个类继承时，它们形成一种金字塔结构，成员变量从父类流向任何派生子类。父类不知道任何子类，但所有子类都知道它们的父类。然而，父类构造函数可以直接从子类构造函数中调用，只需进行简单的语法修改：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `base` keyword stands in for the parent constructor—in this case, the default
    constructor. However, since `base` is standing in for a constructor, and a constructor
    is a method, a child class can pass parameters up the pyramid to its parent constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`base` 关键字代表父构造函数，这种情况下是默认构造函数。然而，由于 `base` 代表一个构造函数，构造函数是一个方法，子类可以将参数传递给其父类构造函数。'
- en: 'Since we want all `Paladin` objects to have a name, and `Character` already
    has a constructor that handles this, we can call the `base` constructor directly
    from the `Paladin` class and save ourselves the trouble of rewriting a constructor:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望所有 `Paladin` 对象都有一个名称，而 `Character` 已经有一个处理这个问题的构造函数，我们可以直接从 `Paladin`
    类调用 `base` 构造函数，而不必重写构造函数：
- en: 'Add a constructor to the `Paladin` class that takes in a `string` parameter,
    called `name`. Use a `colon` and the `base` keyword to call the parent constructor,
    passing in `name`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Paladin` 类添加一个构造函数，该构造函数接受一个 `string` 参数，称为 `name`。使用 `colon` 和 `base` 关键字调用父构造函数，传入
    `name`：
- en: '[PRE26]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In `LearningCurve`, create a new `Paladin` instance called `knight`. Use the
    base constructor to assign a value. Call `PrintStatsInfo` from `knight` and take
    a look at the console:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LearningCurve` 中，创建一个名为 `knight` 的新 `Paladin` 实例。使用基础构造函数来分配一个值。从 `knight`
    调用 `PrintStatsInfo`，并查看控制台：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The debug log will be the same as our other `Character` instances, but with
    the name that we assigned to the `Paladin` constructor:![](img/B17573_05_10.png)
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调试日志将与我们的其他“Character”实例相同，但名称将与我们分配给“Paladin”构造函数的名称相同：![](img/B17573_05_10.png)
- en: 'Figure 5.10: Screenshot of base character constructor properties'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10：基本角色构造函数属性的屏幕截图
- en: When the `Paladin` constructor fires, it passes the `name` parameter to the
    `Character` constructor, which sets the `name` value. Essentially, we used the
    `Character` constructor to do the initialization work for the `Paladin` class,
    making the `Paladin` constructor only responsible for initializing its unique
    properties, which it doesn't have at this point.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当“Paladin”构造函数触发时，它将“name”参数传递给“Character”构造函数，从而设置“name”值。基本上，我们使用“Character”构造函数来为“Paladin”类做初始化工作，使“Paladin”构造函数只负责初始化其独特的属性，而在这一点上它还没有。
- en: Aside from inheritance, there will be times when you want to make new objects
    out of a combination of other existing objects. Think of Lego; you don't start
    building from nothing—you already have blocks of different colors and structures
    to work with. In programming terms, this is called *composition*, which we'll
    discuss in the following section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承，有时你会想要根据其他现有对象的组合来创建新对象。想想乐高积木；你不是从零开始建造——你已经有了不同颜色和结构的积木块可以使用。在编程术语中，这被称为“组合”，我们将在下一节讨论。
- en: Composition
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构成
- en: 'Aside from inheritance, classes can be composed of other classes. Take our
    `Weapon` struct, for example. `Paladin` can easily contain a `Weapon` variable
    inside itself and have access to all its properties and methods. Let''s do that
    by updating `Paladin` to take in a starting weapon and assign its value in the
    constructor:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 除了继承，类还可以由其他类组成。以我们的“Weapon”结构为例，“Paladin”可以在自身内部轻松包含一个“Weapon”变量，并且可以访问其所有属性和方法。让我们通过更新“Paladin”来接受一个起始武器并在构造函数中分配其值：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Since `weapon` is unique to `Paladin` and not `Character`, we need to set its
    initial value in the constructor. We also need to update the `knight` instance
    to include a `Weapon` variable. So, let''s use `huntingBow`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于“weapon”是“Paladin”独有的，而不是“Character”的，我们需要在构造函数中设置其初始值。我们还需要更新“knight”实例以包含一个“Weapon”变量。所以，让我们使用“huntingBow”：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If you run the game now, you won't see anything different because we're using
    the `PrintStatsInfo` method from the `Character` class, which doesn't know about
    the `Paladin` class's `weapon` property. To tackle this problem, we need to talk
    about polymorphism.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行游戏，你不会看到任何不同，因为我们使用的是“Character”类的“PrintStatsInfo”方法，它不知道“Paladin”类的“weapon”属性。为了解决这个问题，我们需要谈谈多态性。
- en: Polymorphism
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: 'Polymorphism is the Greek word for *many-shaped* and applies to OOP in two
    distinct ways:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是希腊词“多形”的意思，在面向对象编程中有两种不同的应用方式：
- en: Derived class objects are treated the same as parent class objects. For example,
    an array of `Character` objects could also store `Paladin` objects, as they derive
    from `Character`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生类对象被视为与父类对象相同。例如，一个“Character”对象数组也可以存储“Paladin”对象，因为它们是从“Character”派生而来的。
- en: Parent classes can mark methods as `virtual`, meaning that their instructions
    can be modified by derived classes using the `override` keyword. In the case of
    `Character` and `Paladin`, it would be useful if we could debug different messages
    from `PrintStatsInfo` for each one.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 父类可以将方法标记为“virtual”，这意味着它们的指令可以被派生类使用“override”关键字修改。在“Character”和“Paladin”的情况下，如果我们可以为每个类从“PrintStatsInfo”中调试不同的消息，那将是有用的。
- en: Polymorphism allows derived classes to keep the structure of their parent class
    while also having the freedom to tailor actions to fit their specific needs. Any
    method you mark as `virtual` will give you the freedom of object polymorphism.
    Let's take this new knowledge and apply it to our character debug method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 多态性允许派生类保留其父类的结构，同时也可以自由地调整动作以适应其特定需求。你标记为“virtual”的任何方法都将给你对象多态性的自由。让我们利用这个新知识并将其应用到我们的角色调试方法中。
- en: 'Let''s modify `Character` and `Paladin` to print out different debug logs using
    `PrintStatsInfo`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改“Character”和“Paladin”以使用“PrintStatsInfo”打印不同的调试日志：
- en: 'Change `PrintStatsInfo` in the `Character` class by adding the `virtual` keyword
    between `public` and `void`:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Character”类中通过在“public”和“void”之间添加“virtual”关键字来更改“PrintStatsInfo”：
- en: '[PRE30]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Declare the `PrintStatsInfo` method in the `Paladin` class using the `override`
    keyword. Add a debug log to print out the `Paladin` properties in whatever way
    you like:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用“override”关键字在“Paladin”类中声明“PrintStatsInfo”方法。添加一个调试日志，以你喜欢的方式打印“Paladin”属性：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This might look like repeated code, which we already said is bad form, but this
    is a special case. What we've done by marking `PrintStatsInfo` as `virtual` in
    the `Character` class is to tell the compiler that this method can have many shapes
    according to the calling class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像重复的代码，我们已经说过这是不好的形式，但这是一个特殊情况。通过在“Character”类中将“PrintStatsInfo”标记为“virtual”，我们告诉编译器这个方法可以根据调用类的不同而有不同的形式。
- en: When we declared the overridden version of `PrintStatsInfo` in `Paladin`, we
    added the custom behavior that only applies to that class. Thanks to polymorphism,
    we don't have to choose which version of `PrintStatsInfo` we want to call from
    a `Character` or `Paladin` object—the compiler already knows:![](img/B17573_05_11.png)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在“Paladin”中声明了“PrintStatsInfo”的重写版本时，我们添加了仅适用于该类的自定义行为。多亏了多态性，我们不必选择从“Character”或“Paladin”对象调用哪个版本的“PrintStatsInfo”——编译器已经知道了：![](img/B17573_05_11.png)
- en: 'Figure 5.11: Screenshot of polymorphic character properties'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11：多态角色属性的屏幕截图
- en: 'This was a lot to take in, I know. So, let''s review some of the main points
    of OOP as we approach the finish line:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这是很多内容，所以让我们在接近终点时回顾一些面向对象编程的主要要点：
- en: OOP is all about grouping related data and actions into objects—objects that
    can communicate and act independently from each other.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象编程是将相关数据和操作分组到对象中——这些对象可以相互通信并独立行动。
- en: Access to class members can be set using access modifiers, just like variables.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用访问修饰符来设置对类成员的访问，就像变量一样。
- en: Classes can inherit from other classes, creating trickle-down hierarchies of
    parent/child relationships.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以继承自其他类，创建父/子关系的层级结构。
- en: Classes can have members of other class or struct types.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以拥有其他类或结构类型的成员。
- en: Classes can override any parent methods marked as `virtual`, allowing them to
    perform custom actions while retaining the same blueprint.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以覆盖任何标记为`virtual`的父方法，允许它们执行自定义操作同时保留相同的蓝图。
- en: 'OOP is not the only programming paradigm that can be used with C#—you can find
    practical explanations of the other main approaches here: [http://cs.lmu.edu/~ray/notes/paradigms](http://cs.lmu.edu/~ray/notes/paradigms).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: OOP并不是C#唯一可用的编程范式，你可以在这里找到其他主要方法的实际解释：[http://cs.lmu.edu/~ray/notes/paradigms](http://cs.lmu.edu/~ray/notes/paradigms)。
- en: All the OOP you've learned in this chapter is directly applicable to the C#
    world. However, we still need to put this into perspective with Unity, which is
    what you'll spend the rest of the chapter focusing on.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章学到的所有OOP都直接适用于C#世界。然而，我们仍需要将其与Unity放在适当的位置，这将是你在本章剩余时间里专注的内容。
- en: Applying OOP in Unity
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Unity中应用OOP
- en: If you're around OOP languages enough, you'll eventually hear the phrase *everything
    is an object* whispered like a secret prayer between developers. Following OOP
    principles, everything in a program should be an object, but GameObjects in Unity
    can represent your classes and structs. However, that's not to say all objects
    in Unity have to be in the physical scene, so we can still use our newfound programmed
    classes behind the scenes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在OOP语言中待得足够长，你最终会听到像*一切都是对象*这样的短语在开发者之间像秘密祈祷一样被低声诉说。遵循OOP原则，程序中的一切都应该是一个对象，但Unity中的GameObject可以代表你的类和结构。然而，并不是说Unity中的所有对象都必须在物理场景中，所以我们仍然可以在幕后使用我们新发现的编程类。
- en: Objects are a class act
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象是一个优秀的类
- en: Back in *Chapter 2*, *The Building Blocks of Programming*, we discussed how
    a script is transformed into a component when it's added to a GameObject in Unity.
    Think of this in terms of the OOP principle of composition—GameObjects are the
    parent containers, and they can be made up of multiple components. This might
    sound contradictory to the idea of one C# class per script but, in truth, that's
    more of a guideline for better readability than an actual requirement. Classes
    can be nested inside one another—it just gets messy fast. However, having multiple
    script components attached to a single GameObject can be very useful, especially
    when dealing with manager classes or behaviors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第2章*，*编程的基本组成部分*，我们讨论了当脚本添加到Unity中的GameObject时，脚本会被转换为组件。从OOP的组合原则来看，GameObject是父容器，它们可以由多个组件组成。这可能与每个脚本一个C#类的想法相矛盾，但事实上，这更多是为了更好的可读性而不是实际要求。类可以嵌套在彼此内部——只是会变得很混乱。然而，将多个脚本组件附加到单个GameObject上可能非常有用，特别是在处理管理类或行为时。
- en: Always try to boil down objects to their most basic elements, and then use composition
    to build bigger, more complex objects out of those smaller classes. It's easier
    to modify a GameObject made out of small, interchangeable components than one
    large, clunky one.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 总是试图将对象简化为它们最基本的元素，然后使用组合来构建更大、更复杂的对象。这样做比修改由大型笨重组成的GameObject更容易，因为GameObject由小型、可互换的组件组成。
- en: 'Let''s take a look at **Main Camera** to see this in action:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看**Main Camera**，看看它是如何运作的：
- en: '![](img/B17573_05_12.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_05_12.png)'
- en: 'Figure 5.12: Screenshot of the Main Camera object in the Inspector'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12：检视器中主摄像机对象的屏幕截图
- en: Each component in the preceding screenshot (**Transform**, **Camera**, **Audio
    Listener**, and the **Learning Curve** script) started as a class in Unity. Like
    instances of `Character` or `Weapon`, these components become objects in computer
    memory when we click on play, complete with their member variables and methods.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，每个组件（**Transform**、**Camera**、**Audio Listener**和**Learning Curve**脚本）最初都是Unity中的一个类。就像`Character`或`Weapon`的实例一样，当我们点击播放时，这些组件在计算机内存中变成对象，包括它们的成员变量和方法。
- en: If we were to attach `LearningCurve` (or any script or component) to 1,000 GameObjects
    and click on play, 1,000 separate instances of `LearningCurve` would be created
    and stored in memory.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`LearningCurve`（或任何脚本或组件）附加到1,000个GameObject上并点击播放，将创建并存储1,000个单独的`LearningCurve`实例。
- en: We can even create our instances of these components using their component name
    as the data type. Like classes, Unity component classes are reference types and
    can be created like any other variable. However, finding and assigning these Unity
    components is slightly different than what you've seen so far. For that, you'll
    need to understand a little more about how GameObjects work in the following section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用组件名称作为数据类型来创建这些组件的实例。与类一样，Unity组件类是引用类型，可以像其他变量一样创建。然而，查找和分配这些Unity组件与你迄今为止所见到的略有不同。为此，你需要在下一节更多地了解GameObject的工作原理。
- en: Accessing components
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问组件
- en: 'Now that we know how components act on GameObjects, how do we go about accessing
    their specific instances? Lucky for us, all GameObjects in Unity inherit from
    the `GameObject` class, which means we can use their member methods to find anything
    we need in a scene. There are two ways to assign or retrieve GameObjects that
    are active in the current scene:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了组件如何作用于GameObject，那么我们如何访问它们的特定实例呢？幸运的是，Unity中的所有GameObject都继承自`GameObject`类，这意味着我们可以使用它们的成员方法来在场景中找到我们需要的任何东西。有两种方法可以分配或检索当前场景中活动的GameObject：
- en: Through the `GetComponent()` or `Find()` methods in the `GameObject` class,
    which work with public and private variables.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过`GameObject`类中的`GetComponent()`或`Find()`方法，这些方法可以使用公共和私有变量。
- en: By dragging and dropping the GameObjects themselves from the `Project` panel
    directly into variable slots in the **Inspector** tab. This option only works
    with public variables in C#, since they are the only ones that will appear in
    the Inspector. If you decide you need a private variable displayed in the Inspector,
    you can mark it with the `SerializeField` attribute.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将游戏对象直接从**Project**面板拖放到**Inspector**选项卡中的变量槽中。这个选项只适用于C#中的公共变量，因为它们是唯一会出现在检查器中的变量。如果您决定需要在检查器中显示一个私有变量，可以使用`SerializeField`属性进行标记。
- en: 'You can learn more about attributes and `SerializeField` in the Unity documentation:
    [https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Unity文档中了解有关属性和`SerializeField`的更多信息：[https://docs.unity3d.com/ScriptReference/SerializeField.html](https://docs.unity3d.com/ScriptReference/SerializeField.html)。
- en: Let's take a look at the syntax of the first option.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第一个选项的语法。
- en: Accessing components in code
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在代码中访问组件
- en: 'Using `GetComponent` is fairly simple, but its method signature is slightly
    different from other methods that we''ve seen so far:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`GetComponent`相当简单，但它的方法签名与我们迄今为止看到的其他方法略有不同：
- en: '[PRE32]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All we need is the component type that we're looking for, and the `GameObject`
    class will return the component if it exists and null if it doesn't. There are
    other variations of the `GetComponent` method, but this one is the simplest because
    we don't need to know specifics about the `GameObject` class that we're looking
    for. This is called a `generic` method, which we'll discuss further in *Chapter
    13*, *Exploring Generics, Delegates, and Beyond*. However, for now, let's just
    work with the camera's transform.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要寻找的组件类型，`GameObject`类将返回该组件（如果存在）和`null`（如果不存在）。`GetComponent`方法还有其他变体，但这是最简单的，因为我们不需要了解我们要查找的`GameObject`类的具体信息。这被称为`通用`方法，我们将在*第13章*“探索泛型、委托和更多内容”中进一步讨论。然而，现在让我们只使用摄像机的变换。
- en: 'Since `LearningCurve`is already attached to the **Main Camera** object, let''s
    grab the camera''s `Transform` component and store it in a public variable. The
    `Transform` component controls an object''s position, rotation, and scale in Unity,
    so it''s a handy example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LearningCurve`已经附加到**Main Camera**对象上，让我们获取摄像机的`Transform`组件并将其存储在一个公共变量中。`Transform`组件控制Unity中对象的位置、旋转和缩放，因此这是一个很好的例子：
- en: 'Add a new public `Transform` type variable, called `CamTransform`, to `LearningCurve`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LearningCurve`中添加一个新的公共`Transform`类型变量，称为`CamTransform`：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Initialize `CamTransform` in `Start` using the `GetComponent` method from the
    `GameObject` class. Use the `this` keyword, since `LearningCurve`is attached to
    the same `GameObject` component as the `Transform` component.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`中使用`GetComponent`方法从`GameObject`类初始化`CamTransform`。使用`this`关键字，因为`LearningCurve`附加到与`Transform`组件相同的`GameObject`组件上。
- en: 'Access and debug the `localPosition` property of `CamTransform` using dot notation:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用点表示法访问和调试`CamTransform`的`localPosition`属性：
- en: '[PRE34]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We've added an uninitialized `public Transform` variable at the top of `LearningCurve`
    and initialized it using the `GetComponent` method inside `Start`. `GetComponent`
    finds the `Transform` component attached to this `GameObject` component and returns
    it to `CamTransform`. With `CamTransform` now storing a `Transform` object, we
    have access to all its class properties and methods—including `localPosition`
    in the following screenshot:![](img/B17573_05_13.png)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`LearningCurve`的顶部添加了一个未初始化的`public Transform`变量，并在`Start`中使用`GetComponent`方法进行了初始化。`GetComponent`找到了附加到此`GameObject`组件的`Transform`组件，并将其返回给`CamTransform`。现在`CamTransform`存储了一个`Transform`对象，我们可以访问它的所有类属性和方法，包括以下屏幕截图中的`localPosition`！[](img/B17573_05_13.png)
- en: 'Figure 5.13: Screenshot of the Transform position printed to the console'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.13：控制台中打印的Transform位置的屏幕截图
- en: The `GetComponent` method is fantastic for quickly retrieving components, but
    it only has access to components on the GameObject that the calling script is
    attached to. For instance, if we use `GetComponent` from the `LearningCurve` script
    attached to the **Main Camera**, we'll only be able to access the **Transform**,
    **Camera**, and **Audio Listener** components.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent`方法非常适用于快速检索组件，但它只能访问调用脚本所附加到的游戏对象上的组件。例如，如果我们从附加到**Main Camera**的`LearningCurve`脚本中使用`GetComponent`，我们只能访问**Transform**、**Camera**和**Audio
    Listener**组件。'
- en: If we want to reference a component on a separate GameObject, such as **Directional
    Light**, we would need to get a reference to the object first using the `Find`
    method. All it takes is the name of a GameObject, and Unity will kick back the
    appropriate GameObject for us to store or manipulate.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想引用另一个游戏对象上的组件，比如**Directional Light**，我们需要先使用`Find`方法获取对该对象的引用。只需要游戏对象的名称，Unity就会返回适当的游戏对象供我们存储或操作。
- en: 'For reference, the name of each GameObject can be found at the top of the **Inspector**
    tab with the object selected:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 要参考每个游戏对象的名称，可以在所选对象的**Inspector**选项卡顶部找到：
- en: '![](img/B17573_05_14.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_05_14.png)'
- en: 'Figure 5.14: Screenshot of the Directional Light object in the Inspector'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.14：检查器中的Directional Light对象的屏幕截图
- en: Finding objects in your game scenes is crucial in Unity, so you'll need to practice.
    Let's take the objects we have to work with and practice finding and assigning
    their components.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中找到游戏场景中的对象是至关重要的，因此您需要进行练习。让我们拿到手头的对象并练习查找和分配它们的组件。
- en: 'Let''s take the `Find` method out for a spin and retrieve the **Directional
    Light** object from `LearningCurve`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下`Find`方法，并从`LearningCurve`中检索**Directional Light**对象：
- en: 'Add two variables to `LearningCurve` underneath `CamTransform`—one of type
    `GameObject` and one of type `Transform`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CamTransform`下面的`LearningCurve`中添加两个变量，一个是`GameObject`类型，一个是`Transform`类型：
- en: '[PRE35]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Find the `Directional Light` component by name, and use it to initialize `DirectionLight`
    inside the `Start()` method:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称找到`Directional Light`组件，并在`Start()`方法中用它初始化`DirectionLight`：
- en: '[PRE36]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set the value of `LightTransform` to the `Transform` component attached to
    `DirectionLight`, and debug its `localPosition`. Since `DirectionLight` is its
    `GameObject` now, `GetComponent` works perfectly:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LightTransform`的值设置为附加到`DirectionLight`的`Transform`组件，并调试其`localPosition`。由于`DirectionLight`现在是它的`GameObject`，`GetComponent`完美地工作：
- en: '[PRE37]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Before running the game, it''s important to understand that method calls can
    be chained together to cut down the number of code steps. For instance, we could
    initialize `LightTransform` in a single line by combining `Find` and `GetComponent`
    without having to go through `DirectionLight`:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行游戏之前，重要的是要理解方法调用可以链接在一起，以减少代码步骤。例如，我们可以通过组合`Find`和`GetComponent`来在一行中初始化`LightTransform`，而不必经过`DirectionLight`：
- en: '[PRE38]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: A word of warning—long lines of chained code can lead to poor readability and
    confusion when working on complex applications. It's a good rule of thumb to avoid
    lines longer than this example.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 警告：长串链接的代码会导致可读性差和混乱，特别是在处理复杂应用程序时。避免超过这个示例的长行是个好的经验法则。
- en: While finding objects in code always works, you can also simply drag and drop
    the objects themselves into the **Inspector** tab. Let's demonstrate how to do
    that in the following section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在代码中查找对象总是有效的，但你也可以简单地将对象本身拖放到**Inspector**选项卡中。让我们在下一节中演示如何做到这一点。
- en: Drag and drop
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拖放
- en: Now that we've covered the code-intensive way of doing things, let's take a
    quick look at Unity's drag and drop functionality. Although dragging and dropping
    is much faster than using the `GameObject` class in code, Unity sometimes loses
    the connections between objects and variables made this way when saving or exporting
    projects, or when Unity updates.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经介绍了代码密集的做事方式，让我们快速看一下Unity的拖放功能。虽然拖放比在代码中使用`GameObject`类要快得多，但Unity有时会在保存或导出项目时，或者在Unity更新时，丢失通过这种方式建立的对象和变量之间的连接。
- en: When you need to assign a few variables quickly, then, by all means, take advantage
    of this feature. For most cases, I'd advise sticking with code.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要快速分配几个变量时，尽管利用这个功能。但大多数情况下，我建议坚持编码。
- en: 'Let''s change `LearningCurve`to show how to assign a `GameObject` component
    using drag and drop:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变`LearningCurve`来展示如何使用拖放来分配一个`GameObject`组件：
- en: 'Comment out the following line of code, where we used `GameObject.Find()` to
    retrieve and assign the `Directional Light` object to the `DirectionLight` variable:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉下面的代码行，我们使用`GameObject.Find()`来检索并将`Directional Light`对象分配给`DirectionLight`变量：
- en: '[PRE39]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Select the **Main Camera** GameObject, drag **Directional Light** to the `Direction
    Light` field in the **Learning Curve** component, and click on play:![](img/B17573_05_15.png)
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**Main Camera** GameObject，将**Directional Light**拖到**Learning Curve**组件的`Direction
    Light`字段中，然后点击播放：![](img/B17573_05_15.png)
- en: 'Figure 5.15: Screenshot of dragging Directional Light to the script property'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.15：将Directional Light拖到脚本属性的截图
- en: The **Directional Light** GameObject is now assigned to the `DirectionLight`
    variable. No code was involved because Unity assigned the variable internally,
    with no change to the `LearningCurve`class.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Directional Light** GameObject现在分配给了`DirectionLight`变量。没有涉及任何代码，因为Unity在内部分配了变量，而`LearningCurve`类没有发生变化。'
- en: It is important to understand a few things when deciding whether to assign variables
    using drag and drop or `GameObject.Find()`. First, the `Find()` method is marginally
    slower, leaving your game open to performance issues if you are calling the method
    multiple times in multiple scripts. Second, you need to be sure your GameObjects
    all have unique names in the scene hierarchy; if they don't, it may lead to some
    nasty bugs in situations where you have several objects of the same name or change
    the object names themselves.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是使用拖放还是`GameObject.Find()`来分配变量时，理解一些重要的事情是很重要的。首先，`Find()`方法速度较慢，如果在多个脚本中多次调用该方法，可能会导致性能问题。其次，你需要确保你的GameObject在场景层次结构中都有唯一的名称；如果没有，可能会在有多个相同名称的对象或更改对象名称本身的情况下导致一些严重的错误。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Our journey into classes, structs, and OOP marks the end of the first section
    on the fundamentals of C#. You've learned how to declare your classes and structs,
    which is the scaffolding for every application or game you'll ever make. You've
    also identified the differences in how these two objects are passed and accessed
    and how they relate to OOP. Finally, you got hands-on with the tenets of OOP—creating
    classes using inheritance, composition, and polymorphism.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对类、结构和面向对象编程的探索标志着C#基础知识的第一部分的结束。你已经学会了如何声明你的类和结构，这是你将来制作的每个应用程序或游戏的支架。你还确定了这两种对象在如何传递和访问上的差异，以及它们与面向对象编程的关系。最后，你通过继承、组合和多态来实现面向对象编程的原则。
- en: Identifying related data and actions, creating blueprints to give them shape,
    and using instances to build interactions are a strong foundation for approaching
    any program or game. Add the ability to access components to the mix, and you've
    got the makings of a Unity developer.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 识别相关的数据和操作，创建蓝图来赋予它们形状，并使用实例来构建交互，这是处理任何程序或游戏的坚实基础。再加上访问组件的能力，你就成为了一个Unity开发者的基础。
- en: The next chapter will segue into the basics of game development and scripting
    object behavior directly in Unity. We'll start by fleshing out the requirements
    of a simple open-world adventure game, work with GameObjects in the scene, and
    finish off with a white-boxed environment ready for our characters.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将过渡到游戏开发的基础知识，并直接在Unity中编写对象行为脚本。我们将从详细说明简单的开放世界冒险游戏的要求开始，在场景中使用GameObject，并最终完成一个为我们的角色准备好的白盒环境。
- en: Pop quiz – all things OOP
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验 - 面向对象编程的一切
- en: What method handles the initialization logic inside a class?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个方法处理类内的初始化逻辑？
- en: Being value types, how are structs passed?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为值类型，结构是如何传递的？
- en: What are the main tenets of OOP?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面向对象编程的主要原则是什么？
- en: Which `GameObject` class method would you use to find a component on the same
    object as the calling class?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个`GameObject`类方法来在调用类的同一对象上找到一个组件？
- en: JOIN us on Discord!
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户一起阅读本书，与Unity/C#专家和Harrison Ferrone一起阅读。提出问题，为其他读者提供解决方案，通过*问我任何事*与作者交流，等等。
- en: Join Now!
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
