- en: Chapter 5. Security and QoS for Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Docker容器的安全性和QoS
- en: In this chapter, we will learn how security is implemented in the context of
    containers in general and how QoS policies are implemented to make sure that resources
    such as CPU and IO are shared as intended. Most of the discussion will focus on
    the relevance of these topics in the context of Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习安全性是如何在容器的上下文中实现的，以及如何实施QoS策略以确保CPU和IO等资源按预期共享。大部分讨论将集中在这些主题在Docker上下文中的相关性。
- en: 'We will cover the following in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: File system restrictions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统限制
- en: Read-only mount points
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只读挂载点
- en: Copy on write
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 写时复制
- en: Linux capabilities and Docker
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Linux功能和Docker
- en: Securing containers in AWS ECS (EC2 container service)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS ECS（EC2容器服务）中保护容器
- en: Understanding Docker security I – kernel namespaces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Docker安全性I - 内核命名空间
- en: Understanding Docker security II – cgroups
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Docker安全性II - cgroups
- en: Using AppArmour to secure Docker containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AppArmour来保护Docker容器
- en: Docker security benchmark
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker安全基准
- en: Filesystem restrictions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件系统限制
- en: In this section, we are going to study filesystem restrictions with which Docker
    containers are started. The following section explains the read-only mount points
    and copy-on-write filesystems, which are used as a base for Docker containers
    and the representation of kernel objects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将研究Docker容器启动时的文件系统限制。下一节解释了只读挂载点和写时复制文件系统，这些文件系统被用作Docker容器的基础和内核对象的表示。
- en: Read-only mount points
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 只读挂载点
- en: Docker needs access to filesystems such as sysfs and proc for processes to function.
    But it doesn't necessarily need to modify these mount points.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Docker需要访问文件系统，如sysfs和proc，以使进程正常运行。但它不一定需要修改这些挂载点。
- en: 'Two primary mount points loaded in read-only mode are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要的只读挂载点是：
- en: '`/sys`'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sys`'
- en: '`/proc`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/proc`'
- en: sysfs
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sysfs
- en: 'The sysfs filesystem is loaded into mount point `/sys`. sysfs is a mechanism
    for representing kernel objects, their attributes, and their relationships with
    each other. It provides two components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: sysfs文件系统加载到挂载点`/sys`中。sysfs是一种表示内核对象、它们的属性和它们之间关系的机制。它提供了两个组件：
- en: A kernel programming interface for exporting these items via sysfs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于通过sysfs导出这些项目的内核编程接口
- en: A user interface to view and manipulate these items that maps back to the kernel
    objects that they represent
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户界面，用于查看和操作这些项目，它映射回它们所代表的内核对象
- en: 'The following code shows the mount points being mounted:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了挂载的挂载点：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A reference link for the preceding code is at [https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的参考链接在[https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/ecc3717cb17313186ee711e624b960b096a9334f/daemon/execdriver/native/template/default_template_linux.go)。
- en: procfs
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: procfs
- en: 'The proc filesystem (procfs) is a special file system in Unix-like operating
    systems, which presents information about processes and other systems information
    in a hierarchical file-like structure. It is loaded into `/proc`. It provides
    a more convenient and standardized method for dynamically accessing process data
    held in the kernel than traditional tracing methods or direct access to kernel
    memory. It is mapped to a mount point named `/proc` at boot time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: proc文件系统（procfs）是Unix-like操作系统中的一个特殊文件系统，它以分层文件样式的结构呈现有关进程和其他系统信息的信息。它加载到`/proc`中。它提供了一个更方便和标准化的方法来动态访问内核中保存的进程数据，而不是传统的跟踪方法或直接访问内核内存。它在引导时映射到名为`/proc`的挂载点：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Read-only paths with `/proc`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`/proc`的只读路径：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: /dev/pts
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /dev/pts
- en: This is another mount point that is mounted as read-write for the container
    during creation. `/dev/pts` lives purely in memory and nothing is stored on disk,
    hence it is safe to load it in read-write mode.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个在创建过程中作为读写挂载的挂载点。`/dev/pts`完全存在于内存中，没有任何内容存储在磁盘上，因此可以安全地以读写模式加载它。
- en: 'Entries in `/dev/pts` are pseudo-terminals (pty for short). Unix kernels have
    a generic notion of terminals. A terminal provides a way for applications to display
    output and to receive input through a terminal device. A process may have a controlling
    terminal. For a text mode application, this is how it interacts with the user:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`/dev/pts`中的条目是伪终端（简称pty）。Unix内核有终端的通用概念。终端提供了应用程序通过终端设备显示输出和接收输入的方式。一个进程可能有一个控制终端。对于文本模式应用程序，这是它与用户交互的方式：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: /sys/fs/cgroup
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: /sys/fs/cgroup
- en: 'This is the mount point where cgroups are implemented and is loaded as `MS_RDONLY`
    for the container:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是cgroups实现的挂载点，并且在容器中加载为`MS_RDONLY`：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Copy-on-write
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写时复制
- en: 'Docker uses union filesystems, which are copy-on-write filesystems. This means
    containers can use the same filesystem image as the base for the container. When
    a container writes content to the image, it gets written to a container-specific
    filesystem. It prevents one container from being able to access the changes of
    another container even if they are created from the same filesystem image. One
    container cannot change the image content to effect the processes in another container.
    The following figure explains this process:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用联合文件系统，这是写时复制文件系统。这意味着容器可以使用相同的文件系统镜像作为容器的基础。当容器向镜像写入内容时，它会被写入到特定于容器的文件系统中。即使它们是从相同的文件系统镜像创建的，一个容器也不能访问另一个容器的更改。一个容器不能改变镜像内容以影响另一个容器中的进程。以下图解释了这个过程：
- en: '![Copy-on-write](../images/00041.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![写时复制](../images/00041.jpeg)'
- en: Linux capabilities
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux功能
- en: Docker containers before 1.2 could either be given complete capabilities under
    privileged mode, or they can all follow a whitelist of allowed capabilities while
    dropping all others. If the flag `--privileged` is used, it will grant all capabilities
    to the container. This was not recommended for production use because it's really
    unsafe; it allowed Docker all privileges as a process under the direct host.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2版本之前的Docker容器可以在特权模式下获得完整的功能，或者它们可以遵循允许的功能白名单，同时放弃所有其他功能。如果使用`--privileged`标志，它将授予容器所有功能。这在生产中是不推荐的，因为它真的很不安全；它允许Docker作为直接主机下的进程拥有所有特权。
- en: 'With Docker 1.2, two flags have been introduced with `docker run`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker 1.2引入了两个`docker run`标志：
- en: '`--cap-add`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cap-add`'
- en: '`--cap-drop`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cap-drop`'
- en: 'These two flags provide fine-grain control to a container, for example, as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个标志为容器提供了细粒度的控制，例如：
- en: 'Change the status of the Docker container''s interface:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改Docker容器接口的状态：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Prevent any chown in the Docker container:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止Docker容器中的任何chown：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Allow all capabilities except `mknod`:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许除`mknod`之外的所有功能：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Docker starts containers with a restricted set of capabilities by default. Capabilities
    convert a binary mode of root and non-root to a more fine-grained access control.
    As an example, a web server which serves HTTP request needs to be bound to port
    80 for HTTP and 443 for HTTPs. These servers need not be run in the root mode.
    These servers can be granted `net_bind_service` capability.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Docker默认以受限的功能集启动容器。功能将根和非根的二进制模式转换为更精细的访问控制。例如，提供HTTP请求的Web服务器需要绑定到端口80进行HTTP和端口443进行HTTPs。这些服务器不需要以根模式运行。这些服务器可以被授予`net_bind_service`功能。
- en: Containers and servers are a little different in this context. Servers need
    to run a few processes in the root mode. For example, ssh, cron, and network configurations
    to handle dhcp, and so on. Containers, on the other hand, do not need this access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情境中，容器和服务器有一些不同。服务器需要以root模式运行一些进程。例如，ssh，cron和网络配置来处理dhcp等。另一方面，容器不需要这种访问。
- en: 'The following tasks need not happen in the container:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下任务不需要在容器中发生：
- en: ssh access is managed by Docker host
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ssh访问由Docker主机管理
- en: cron jobs should be run in the user mode
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cron作业应该在用户模式下运行
- en: Network configuration such as ipconfig and routing should not happen inside
    the container
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络配置，如ipconfig和路由，不应该在容器内发生
- en: We can safely deduce containers might not need root priviledges.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以安全地推断容器可能不需要root权限。
- en: 'Examples that can be denied are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 可以拒绝的示例如下：
- en: Do not allow mount operations
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许挂载操作
- en: Do not allow access to sockets
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许访问套接字
- en: Prevent access to filesystem operations such as changing file attributes or
    ownership of the files
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止对文件系统操作的访问，如更改文件属性或文件所有权
- en: Prevent the container from loading new modules
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止容器加载新模块
- en: 'Docker allows only the following capabilities:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker只允许以下功能：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A reference to the preceding code is at [https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对先前代码的引用在[https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go](https://github.com/docker/docker/blob/master/daemon/execdriver/native/template/default_template_linux.go)。
- en: A full list of available capabilities can be found in the Linux man-pages ([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html)).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在Linux man-pages中找到所有可用功能的完整列表([http://man7.org/linux/man-pages/man7/capabilities.7.html](http://man7.org/linux/man-pages/man7/capabilities.7.html))。
- en: One primary risk with running Docker containers is that the default set of capabilities
    and mounts given to a container may provide incomplete isolation, either independently
    or when used in combination with kernel vulnerabilities.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Docker容器的一个主要风险是，容器的默认功能和挂载集可能提供不完整的隔离，无论是独立使用还是与内核漏洞结合使用。
- en: Docker supports the addition and removal of capabilities, allowing the use of
    a non-default profile. This may make Docker more secure through capability removal
    or less secure through the addition of capabilities. The best practice for users
    would be to remove all capabilities except those explicitly required for their
    processes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持添加和删除功能，允许使用非默认配置文件。这可以通过删除功能或添加功能使Docker更安全或更不安全。用户的最佳做法是删除除了明确需要的功能之外的所有功能。
- en: Securing containers in AWS ECS
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS ECS中保护容器
- en: The Amazon **EC2 container service** (**ECS**) provides a highly scalable, high-performance
    container management service that supports Docker containers. It allows you to
    easily run applications on a managed cluster of Amazon EC2 instances. Amazon ECS
    eliminates the need for you to install, operate, and scale your own cluster management
    infrastructure. With simple API calls, you can launch and stop Docker-enabled
    applications and query the complete state of your cluster.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊**EC2容器服务**(**ECS**)提供了一个高度可扩展、高性能的容器管理服务，支持Docker容器。它允许您轻松地在一组托管的亚马逊EC2实例上运行应用程序。Amazon
    ECS消除了您安装、操作和扩展自己的集群管理基础设施的需要。通过简单的API调用，您可以启动和停止启用Docker的应用程序，并查询集群的完整状态。
- en: In the following example, we will see how to deploy a secured web application
    using two Docker containers, one containing a simple web application (application
    container), and the other containing a reverse proxy with throttling enabled (proxy
    container), which can be used to protect the web application. These containers
    will be deployed on the Amazon EC2 instance using ECS. As can be seen in the following
    diagram, all the network traffic will be routed through the proxy container that
    throttles requests. Also, we can perform activities such as filtering, logging,
    and intrusion detection at proxy containers using various security software.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将看到如何使用两个Docker容器部署一个安全的Web应用程序，一个包含一个简单的Web应用程序（应用程序容器），另一个包含启用了限流的反向代理（代理容器），可以用来保护Web应用程序。这些容器将在Amazon
    EC2实例上使用ECS部署。如下图所示，所有网络流量将通过限流请求的代理容器路由。此外，我们可以在代理容器上使用各种安全软件执行过滤、日志记录和入侵检测等活动。
- en: 'The following are the steps to do so:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这样做的步骤：
- en: 'We will build a basic PHP web application container from the GitHub project.
    The following steps can be performed on a separate EC2 instance or a local machine:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从GitHub项目构建一个基本的PHP Web应用程序容器。以下步骤可以在单独的EC2实例或本地机器上执行：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Change directories to the `ecs-demo-php-simple-app` folder:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`ecs-demo-php-simple-app`文件夹：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can examine `Dockerfile` as follows in order to understand the web application
    it will deploy:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以检查`Dockerfile`如下，以了解它将部署的Web应用程序：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Build the container image using Dockerfile and then push it in your Docker
    Hub account. The Docker Hub account is required as it helps to deploy the containers
    on the Amazon ECS service by just specifying the container name:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建容器镜像，然后将其推送到您的Docker Hub帐户。 Docker Hub帐户是必需的，因为它可以通过指定容器名称来在Amazon
    ECS服务上部署容器：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The image built over here is required to have `dockerhub-username` (correct
    without spaces) as the first parameter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此处构建的镜像需要将`dockerhub-username`（无空格）作为第一个参数。
- en: 'The following figure depicts a hacker not able to access the web application,
    as the request is filtered via a proxy container and access is blocked:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了黑客无法访问Web应用程序，因为请求通过代理容器进行过滤并且被阻止：
- en: '![Securing containers in AWS ECS](../images/00042.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![在AWS ECS中保护容器](../images/00042.jpeg)'
- en: 'Upload the Docker image to the Docker Hub account:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Docker镜像上传到Docker Hub帐户：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Check to ensure your login worked:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查以确保您的登录成功：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Push your image to the Docker Hub account:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的镜像推送到Docker Hub帐户：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'After creating the sample web application Docker container, we will now create
    the proxy container, which can also contain some security-related software, if
    required, in order to strengthen security. We will create a new proxy Docker container
    using a customized Dockerfile and then push the image to your Docker Hub account:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建示例Web应用程序Docker容器后，我们将创建代理容器，如果需要，还可以包含一些与安全相关的软件，以加强安全性。我们将使用定制的Dockerfile创建一个新的代理Docker容器，然后将镜像推送到您的Docker
    Hub帐户：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the previous Dockerfile we are using a base Ubuntu image and installing nginx
    and exposing it on port 80.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个Dockerfile中，我们使用了一个基本的Ubuntu镜像，并安装了nginx，并将其暴露在80端口。
- en: 'Next, we will create a customized `nginx.conf`, which will override the default
    `nginx.conf` in order to ensure the reverse proxy is configured properly:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个定制的`nginx.conf`，它将覆盖默认的`nginx.conf`，以确保反向代理配置正确：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Build the proxy Docker image and push the built image to the Docker Hub account:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建代理Docker镜像并将构建的镜像推送到Docker Hub帐户：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The ECS container service can be deployed by navigating to **AWS Management
    Console** ([https://aws.amazon.com/console/](https://aws.amazon.com/console/)).
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过转到AWS管理控制台（[https://aws.amazon.com/console/](https://aws.amazon.com/console/)）来部署ECS容器服务。
- en: Click **Task Definitions** in the left sidebar and then click **Create a New
    Task Definition**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧边栏中单击“任务定义”，然后单击“创建新任务定义”。
- en: Give your task definition a name, such as `SecurityApp`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你的任务定义起一个名字，比如`SecurityApp`。
- en: 'Next, click on **Add Container** and insert the name of the proxy web container
    pushed to the Docker Hub account, as well as the name of the application web container.
    View the contents of the JSON using **Configure via JSON** tab to see the task
    definition that you have created. It should be like this:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，单击“添加容器”，并插入推送到Docker Hub帐户的代理Web容器的名称，以及应用程序Web容器的名称。使用“通过JSON配置”选项卡查看JSON的内容，以查看您创建的任务定义。它应该是这样的：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Click the **Create** button in order to deploy the application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“创建”按钮以部署应用程序。
- en: Click **Clusters** in the left sidebar. If a default cluster does not exist,
    create one.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧边栏中单击“集群”。如果默认集群不存在，则创建一个。
- en: Launch an ECS-optimized **Amazon Machine Image** (**AMI**), ensuring it has
    a public IP address and a path to the Internet.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个ECS优化的Amazon机器映像（AMI），确保它具有公共IP地址和通往互联网的路径。
- en: When your instance is up and running, navigate to the **ECS** section of the
    **AWS Management Console** and click **Clusters**, then **default**. Now, we should
    be able to see our instance under the **ECS Instances** tab.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您的实例正在运行时，导航到AWS管理控制台的ECS部分，然后单击“集群”，然后单击“默认”。现在，我们应该能够在“ECS实例”选项卡下看到我们的实例。
- en: Navigate to the **TASK** definitions from the left side of the **AWS Management
    Console** tab and click **Run Task**.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从AWS管理控制台选项卡的左侧导航到任务定义，然后单击“运行任务”。
- en: On the next page, ensure the cluster is set to **Default** and the number of
    tasks is **1**, then click **Run Task**.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页上，确保集群设置为“默认”，任务数为“1”，然后单击“运行任务”。
- en: After the process completes we can see the state of the task from a pending
    state to a green running state.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程完成后，我们可以从挂起状态到绿色运行状态看到任务的状态。
- en: Clicking on the **ECS** tab, we can see the container instance created earlier.
    By clicking on it, we will get information about its public IP address. By hitting
    this public IP address via the browser we will be able to see our sample PHP application.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击“ECS”选项卡，我们可以看到先前创建的容器实例。单击它，我们将获得有关其公共IP地址的信息。通过浏览器点击此公共IP地址，我们将能够看到我们的示例PHP应用程序。
- en: Understanding Docker security I – kernel namespaces
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Docker安全性I—内核命名空间
- en: A namespace provides a wrapper around a global system resource of the kernel
    and makes the resource appear to the process within the namespace as if they have
    an isolated instance. Global resource changes are visible to processes in the
    same namespace but invisible to others. Containers are considered an excellent
    implementation of a kernel namespace.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间提供了对内核全局系统资源的包装器，并使资源对于命名空间内的进程看起来像是有一个隔离的实例。全局资源更改对于相同命名空间中的进程是可见的，但对其他进程是不可见的。容器被认为是内核命名空间的一个很好的实现。
- en: 'The following namespaces are implemented by Docker:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker实现了以下命名空间：
- en: '**pid namespace**: Used for process isolation (**PID**—**Process ID**)'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pid命名空间：用于进程隔离（PID—进程ID）
- en: '**net namespace**: Used for managing network interfaces (**NET**—**Networking**)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: net命名空间：用于管理网络接口（NET—网络）
- en: '**ipc namespace**: Used for managing access to IPC resources (**IPC**—**Inter
    Process Communication**)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPC命名空间：用于管理对IPC资源（IPC—进程间通信）的访问
- en: '**mnt namespace**: Used for managing mount points (**MNT**—**Mount**)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mnt命名空间：用于管理挂载点（MNT—挂载）
- en: '**uts namespace**: Used for isolating kernel and version identifiers (**UTS**—**Unix
    Time sharing System**)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**uts命名空间**：用于隔离内核和版本标识（**UTS**—**Unix Time sharing System**）'
- en: Adding namespace support in libcontainer required adding patches in the system
    layer of GoLang ([https://codereview.appspot.com/126190043/patch/140001/150001](https://codereview.appspot.com/126190043/patch/140001/150001)<emphsis>src/syscall/exec_linux.go</emphsis>)
    so that new data structures could be maintained for PIDs, user UIDs, and so on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在libcontainer中添加命名空间支持需要在GoLang的系统层中添加补丁（[https://codereview.appspot.com/126190043/patch/140001/150001](https://codereview.appspot.com/126190043/patch/140001/150001)<emphsis>src/syscall/exec_linux.go</emphsis>），以便可以维护新的数据结构用于PID、用户UID等。
- en: pid namespace
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pid命名空间
- en: pid namespaces isolate the process ID number space; processes in different pid
    namespaces can have the same pid. pid namespaces allow containers to provide functionality
    such as suspending/resuming the set of processes in the container, and migrating
    the container to a new host while the processes inside the container maintain
    the same pids.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: pid命名空间隔离了进程ID号空间；不同pid命名空间中的进程可以拥有相同的pid。pid命名空间允许容器提供功能，如暂停/恢复容器中的一组进程，并在容器内部的进程保持相同的pid的情况下将容器迁移到新主机。
- en: pids in a new namespace start with PID 1\. The kernel needs to be configured
    for the flag `CONFIG_PID_NS` for the namespace to work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新命名空间中的PID从1开始。内核需要配置标志`CONFIG_PID_NS`才能使命名空间工作。
- en: 'pid namespaces can be nested. Each pid namespace has a parent, except for the
    initial (root) pid namespace. The parent of a pid namespace is the pid namespace
    of the process that created the namespace using clone or unshare. pid namespaces
    form a tree, with all namespaces ultimately tracing their ancestry to the root
    namespace as shown in the following figure:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: pid命名空间可以嵌套。每个pid命名空间都有一个父命名空间，除了初始（根）pid命名空间。pid命名空间的父命名空间是使用clone或unshare创建命名空间的进程的pid命名空间。pid命名空间形成一棵树，所有命名空间最终都可以追溯到根命名空间，如下图所示：
- en: '![pid namespace](../images/00043.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![pid命名空间](../images/00043.jpeg)'
- en: net namespace
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: net命名空间
- en: net namespace provides isolation of the system resources associated with networking.
    Each network namespace has its own network devices, IP addresses, IP routing tables,
    `/proc/net` directory, port numbers, and so on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: net命名空间提供了与网络相关的系统资源隔离。每个网络命名空间都有自己的网络设备、IP地址、IP路由表、`/proc/net`目录、端口号等。
- en: 'Network namespaces make containers useful from a networking perspective: each
    container can have its own (virtual) network device and its own applications that
    bind to the per-namespace port number space; suitable routing rules in the host
    system can direct network packets to the network device associated with a specific
    container. Use of network namespaces requires a kernel that is configured with
    the `CONFIG_NET_NS` option ([https://lwn.net/Articles/531114/](https://lwn.net/Articles/531114/)).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 网络命名空间使容器在网络方面变得有用：每个容器可以拥有自己的（虚拟）网络设备和绑定到每个命名空间端口号空间的应用程序；主机系统中适当的路由规则可以将网络数据包定向到与特定容器关联的网络设备。使用网络命名空间需要内核配置`CONFIG_NET_NS`选项（[https://lwn.net/Articles/531114/](https://lwn.net/Articles/531114/)）。
- en: As each container has its own network namespace, which basically means its own
    network interface and routing tables, net namespace is also directly leveraged
    by Docker to isolate IP addresses, port numbers, and so on.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个容器都有自己的网络命名空间，基本上意味着拥有自己的网络接口和路由表，net命名空间也被Docker直接利用来隔离IP地址、端口号等。
- en: Basic network namespace management
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本网络命名空间管理
- en: 'Network namespaces are created by passing a flag to the `clone()` system call,
    `CLONE_NEWNET`. From the command line, though, it is convenient to use the IP
    networking configuration tool to set up and work with network namespaces:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向`clone()`系统调用传递一个标志`CLONE_NEWNET`来创建网络命名空间。不过，从命令行来看，使用IP网络配置工具来设置和处理网络命名空间是很方便的：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This command creates a new network namespace called `netns1`. When the IP tool
    creates a network namespace, it will create a bind mount for it under `/var/run/netns`,
    which allows the namespace to persist, even when no processes are running within
    it, and facilitates the manipulation of the namespace itself. Since network namespaces
    typically require a fair amount of configuration before they are ready for use,
    this feature will be appreciated by systems administrators.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令创建了一个名为`netns1`的新网络命名空间。当IP工具创建网络命名空间时，它将在`/var/run/netns`下为其创建一个绑定挂载，这样即使在其中没有运行任何进程时，命名空间也会持续存在，并且便于对命名空间本身进行操作。由于网络命名空间通常需要大量配置才能准备好使用，这个特性将受到系统管理员的赞赏。
- en: 'The `ip netns exec` command can be used to run network management commands
    within the namespace:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip netns exec`命令可用于在命名空间内运行网络管理命令：'
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This command lists the interfaces visible inside the namespace. A network namespace
    can be removed with the use of following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令列出了命名空间内可见的接口。可以使用以下命令删除网络命名空间：
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This command removes the bind mount referring to the given network namespace.
    The namespace itself, however, will persist for as long as any processes are running
    within it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令移除了指向给定网络命名空间的绑定挂载。然而，命名空间本身将持续存在，只要其中有任何进程在其中运行。
- en: Network namespace configuration
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 网络命名空间配置
- en: New network namespaces will have a loopback device but no other network devices.
    Aside from the loopback device, each network device (physical or virtual interfaces,
    bridges, and so on) can only be present in a single network namespace. In addition,
    physical devices (those connected to real hardware) cannot be assigned to namespaces
    other than the root. Instead, virtual network devices (for example, virtual Ethernet
    or vEth) can be created and assigned to a namespace. These virtual devices allow
    processes inside the namespace to communicate over the network; it is the configuration,
    routing, and so on that determines who they can communicate with.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 新的网络命名空间将拥有一个环回设备，但没有其他网络设备。除了环回设备外，每个网络设备（物理或虚拟接口，桥接等）只能存在于单个网络命名空间中。此外，物理设备（连接到真实硬件的设备）不能被分配到除根之外的命名空间。相反，可以创建虚拟网络设备（例如虚拟以太网或vEth）并分配给命名空间。这些虚拟设备允许命名空间内的进程通过网络进行通信；决定它们可以与谁通信的是配置、路由等。
- en: When first created, the `lo` loopback device in the new namespace is down, so
    even a loopback `ping` will fail.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建时，新命名空间中的`lo`环回设备是关闭的，因此即使是环回的`ping`也会失败。
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the previous command, we can see that since the net namespace for a Docker
    container is stored in a separate location, and thus a symlink is required to
    be created to `/var/run/netns`, it can be done in the following way:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们可以看到由于Docker容器的网络命名空间存储在单独的位置，因此需要创建到`/var/run/netns`的符号链接，可以通过以下方式完成：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, it is done by bringing that interface up, which will allow
    the pinging of the loopback address.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过启动该接口来实现，这将允许对环回地址进行ping。
- en: '[PRE25]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This still doesn't allow communication between `netns1` and the root namespace.
    To do that, virtual Ethernet devices need to be created and configured.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不允许`netns1`和根命名空间之间的通信。为了实现这一点，需要创建和配置虚拟以太网设备。
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The first command sets up a pair of virtual Ethernet devices that are connected.
    Packets sent to `veth0` will be received by `veth1` and vice versa. The second
    command assigns `veth1` to the `netns1` namespace.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令设置了一对连接的虚拟以太网设备。发送到`veth0`的数据包将被`veth1`接收，反之亦然。第二条命令将`veth1`分配给`netns1`命名空间。
- en: '[PRE27]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Then, these two commands set IP addresses for the two devices.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这两条命令为这两个设备设置了IP地址。
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Communication in both directions is now possible as the previous `ping` commands
    show.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以进行双向通信，就像之前的`ping`命令所示。
- en: 'As mentioned, though, namespaces do not share routing tables or firewall rules,
    as running route and `iptables -L` in `netns1` will attest:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，命名空间不共享路由表或防火墙规则，运行`route`和`iptables -L`在`netns1`中将证明这一点：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: User namespace
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户命名空间
- en: User namespaces allows per-namespace mappings of user and group IDs. This means
    that user IDs and group IDs of a process inside a user namespace can be different
    from its IDs outside of the namespace. A process can have a non-zero user ID outside
    a namespace while, at the same time, having a user ID of zero inside the namespace.
    The process is unprivileged for operations outside the user namespace but has
    root privileges inside the namespace.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 用户命名空间允许用户和组ID在命名空间内进行映射。这意味着命名空间内的进程的用户ID和组ID可以与其在命名空间外的ID不同。一个进程在命名空间外可以具有非零用户ID，同时在命名空间内可以具有零用户ID。该进程在用户命名空间外进行操作时没有特权，但在命名空间内具有root特权。
- en: Creating a new user namespace
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新的用户命名空间
- en: 'User namespaces are created by specifying the `CLONE_NEWUSER` flag when calling
    `clone()` or `unshare()`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在调用`clone()`或`unshare()`时指定`CLONE_NEWUSER`标志来创建用户命名空间：
- en: '`clone()` allows the child process to share parts of its execution context
    with the calling process, such as the memory space, the table of file descriptors,
    and the table of signal handlers.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone()` 允许子进程与调用进程共享其执行上下文的部分，例如内存空间、文件描述符表和信号处理程序表。'
- en: '`unshare()` allows a process (or thread) to disassociate parts of its execution
    context that are currently being shared with other processes (or threads). Part
    of the execution context, such as the mount namespace, is shared implicitly when
    a new process is created using `fork()` or `vfork()`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`unshare()` 允许进程（或线程）取消与其他进程（或线程）共享的执行上下文的部分。当使用`fork()`或`vfork()`创建新进程时，执行上下文的一部分，例如挂载命名空间，会隐式共享。'
- en: As mentioned previously, Docker containers are very similar to LXC containers
    as a set of namespaces and control groups are created separately for containers.
    Each container gets its own network stack and namespace. Until and unless containers
    do not have the privileged access, they are not allowed to access other hosts
    sockets or interfaces. If the host network mode is given to the container, then
    only it gets the ability to access the host ports and IP address, which can cause
    a potential threat to other programs running on the host.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker容器与LXC容器非常相似，因为为容器单独创建了一组命名空间和控制组。每个容器都有自己的网络堆栈和命名空间。除非容器没有特权访问权限，否则不允许访问其他主机的套接字或接口。如果将主机网络模式赋予容器，那么它才能访问主机端口和IP地址，这可能对主机上运行的其他程序造成潜在威胁。
- en: 'As shown in the following example, where we use the `host` network mode in
    the container and it is able to access all the hosts bridges:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如下例所示，在容器中使用`host`网络模式，并且能够访问所有主机桥接设备：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'While auditing, it should be checked that all the containers, by default, have
    network mode set to `default` and not `host`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在审核过程中，应该检查所有容器，默认情况下网络模式是否设置为`default`而不是`host`：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Each Docker container is connected to an Ethernet bridge in order to provide
    inter-connectivity between containers. They can ping each other to send/receive
    UDP packets and establish TCP connections, but that can be restricted if necessary.
    Namespace also provides a straightforward isolation in restricting the access
    of the processes running in the other container as well as the host.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Docker容器都连接到以太网桥，以便在容器之间提供互连性。它们可以相互ping以发送/接收UDP数据包并建立TCP连接，但如果有必要，可以进行限制。命名空间还提供了一种简单的隔离，限制了在其他容器中运行的进程以及主机的访问。
- en: We will be using the following `nsenter` command line utility in order to enter
    into namespaces. It is an open-source project on GitHub available at [https://github.com/jpetazzo/nsenter](https://github.com/jpetazzo/nsenter).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下`nsenter`命令行实用程序进入命名空间。它是GitHub上的一个开源项目，可在[https://github.com/jpetazzo/nsenter](https://github.com/jpetazzo/nsenter)上找到。
- en: Using it, we will try to enter existing container namespaces or try to spawn
    a new set of namespaces. It is different from the Docker `exec` command as `nsenter`
    doesn't enter the cgroups, which gives potential benefits for debugging and external
    audits by escaping the resource limitations using namespace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用它，我们将尝试进入现有容器的命名空间，或者尝试生成一组新的命名空间。它与Docker `exec`命令不同，因为`nsenter`不会进入cgroups，这可以通过使用命名空间来逃避资源限制，从而为调试和外部审计带来潜在好处。
- en: 'We can install `nsenter` from PyPI (it requires Python 3.4) and use the command
    line utility to connect to a running container:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从PyPI安装`nsenter`（它需要Python 3.4），并使用命令行实用程序连接到正在运行的容器：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To replace pid with the container''s pid, use the following command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令替换pid为容器的pid：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can use the `docker inspect` command to make it more convenient as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker inspect`命令使其更加方便：
- en: 'First start a new nginx server:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先启动一个新的nginx服务器：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then get pid of the container:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后获取容器的pid：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Connect to the running nginx container:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到正在运行的nginx容器：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`docker-enter` is also one of the wrappers that can be used to enter inside
    the container specifying the shell commands, and if no command is specified, a
    shell will be invoked instead. If it is required to inspect or manipulate containers
    without executing another command line tool, we can use context manager to do
    this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-enter`也是可以用来进入容器并指定shell命令的包装器，如果没有指定命令，将调用一个shell。如果需要在不执行其他命令行工具的情况下检查或操作容器，可以使用上下文管理器来实现：'
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Understanding Docker security II – cgroups
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Docker安全II - cgroups
- en: In this section, we look at how cgroups form the backbone of isolation for a
    container.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看cgroups如何构成容器隔离的基础。
- en: Defining cgroups
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义cgroups
- en: Control groups provide a mechanism for aggregating/partitioning sets of tasks
    (processes), and all their future children, into hierarchical groups.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 控制组提供了一种将任务（进程）及其所有未来的子任务聚合/分区到分层组中的机制。
- en: A cgroup associates a set a tasks with parameters from a subsystem. A subsystem
    itself is a resource controller used to define boundaries for cgroups or for provisioning
    a resource.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: cgroup将一组任务与子系统的参数关联起来。子系统本身是用于定义cgroups边界或为资源提供的资源控制器。
- en: A hierarchy is a set of cgroups arranged in a tree, such that every task in
    the system is in exactly one of the cgroups in the hierarchy and a set of subsystems.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 层次结构是一组以树状排列的cgroups，系统中的每个任务都恰好位于层次结构中的一个cgroup中，并且一组子系统。
- en: Why are cgroups required?
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么需要cgroups？
- en: There are multiple efforts to provide process aggregations in the Linux kernel,
    mainly for resource-tracking purposes.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核中有多个努力提供进程聚合，主要用于资源跟踪目的。
- en: Such efforts include cpusets, CKRM/ResGroups, UserBeanCounters, and virtual
    server namespaces. These all require the basic notion of a grouping/partitioning
    of processes, with newly forked processes ending up in the same group (cgroup)
    as their parent process.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这些努力包括cpusets、CKRM/ResGroups、UserBeanCounters和虚拟服务器命名空间。所有这些都需要基本的进程分组/分区概念，新分叉的进程最终进入与其父进程相同的组（cgroup）。
- en: The kernel cgroup patch provides essential kernel mechanisms to efficiently
    implement such groups. It has minimal impact on the system fast paths and provides
    hooks for specific subsystems such as cpusets to provide additional behavior as
    desired.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 内核cgroup补丁提供了必要的内核机制，以有效地实现这些组。它对系统快速路径的影响很小，并为特定子系统提供了钩子，例如cpusets，以提供所需的附加行为。
- en: Creating a cgroup manually
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建一个cgroup
- en: 'In the following steps, we will create a `cpuset` control group:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将创建一个`cpuset`控制组：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`tmpfs` is a file system that keeps all files in virtual memory. Everything
    in `tmpfs` is temporary in the sense that no files will be created on your hard
    drive. If you unmount a `tmpfs` instance, everything stored therein is lost:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`tmpfs`是一种将所有文件保存在虚拟内存中的文件系统。`tmpfs`中的所有内容都是临时的，即不会在硬盘上创建任何文件。如果卸载`tmpfs`实例，则其中存储的所有内容都会丢失：'
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Assign CPU and memory limits to this cgroup:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为此cgroup分配CPU和内存限制：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following command shows `/Charlie` as the cpuset cgroup:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '以下命令显示`/Charlie`作为cpuset cgroup： '
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Attaching processes to cgroups
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将进程附加到cgroups
- en: 'Add the process ID `PID{X}` to the tasks file as shown in the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将进程ID“PID{X}”添加到任务文件中，如下所示：
- en: '[PRE42]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that it is `PID`, not PIDs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这是`PID`，而不是PIDs。
- en: 'You can only attach one task at a time. If you have several tasks to attach,
    you have to do it one after another:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 您一次只能附加一个任务。如果有多个任务要附加，您必须一个接一个地执行：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Attach the current shell task by echoing `0`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过回显`0`将当前shell任务附加：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Docker and cgroups
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker和cgroups
- en: cgroups are managed as part of the libcontainer project under Docker's GitHub
    repo ([https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups](https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups)).
    There is a cgroup manager that manages the interaction with the cgroup APIs in
    the kernel.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: cgroups作为Docker的GitHub存储库（[https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups](https://github.com/opencontainers/runc/tree/master/libcontainer/cgroups)）下的libcontainer项目的一部分进行管理。有一个cgroup管理器，负责与内核中的cgroup
    API进行交互。
- en: 'The following code shows the lifecycle events managed by the manager:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了管理器管理的生命周期事件：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Using AppArmor to secure Docker containers
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AppArmor保护Docker容器
- en: AppArmor is a **Mandatory Access Control** (**MAC**) system that is a kernel
    enhancement to confine programs to a limited set of resources. AppArmor's security
    model is to bind access control attributes to programs rather than to users.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor是一种**强制访问控制**（**MAC**）系统，是内核增强功能，用于将程序限制在有限的资源集合中。AppArmor的安全模型是将访问控制属性绑定到程序，而不是用户。
- en: 'AppArmor confinement is provided via profiles loaded into the kernel, typically
    on boot. AppArmor profiles can be in one of two modes: enforcement or complain.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor约束是通过加载到内核中的配置文件提供的，通常在启动时加载。AppArmor配置文件可以处于两种模式之一：强制执行或投诉。
- en: Profiles loaded in enforcement mode will result in enforcement of the policy
    defined in the profile, as well as reporting policy violation attempts (either
    via syslog or auditd).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 以强制执行模式加载的配置文件将导致强制执行配置文件中定义的策略，并报告策略违规尝试（通过syslog或auditd）。
- en: Profiles in complain mode will not enforce policy but instead report policy
    violation attempts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 投诉模式下的配置文件不会强制执行策略，而是报告策略违规尝试。
- en: 'AppArmor differs from some other MAC systems on Linux: it is path-based, it
    allows mixing of enforcement and complain-mode profiles, it uses include files
    to ease development, and it has a far lower barrier to entry than other popular
    MAC systems. The following figure shows the AppArmour application profiles linked
    to apps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor与Linux上的其他一些MAC系统不同：它是基于路径的，允许混合强制和投诉模式配置文件，使用包含文件来简化开发，并且比其他流行的MAC系统具有更低的入门门槛。以下图显示了与应用程序相关联的AppArmour应用程序配置文件：
- en: '![Using AppArmor to secure Docker containers](../images/00044.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![使用AppArmor保护Docker容器](../images/00044.jpeg)'
- en: AppArmor is an established technology first seen in Immunix and later integrated
    into Ubuntu, Novell/SUSE, and Mandriva. Core AppArmor functionality is in the
    mainline Linux kernel from 2.6.36 onwards; work is ongoing by AppArmor, Ubuntu,
    and other developers to merge additional AppArmor functionality into the mainline
    kernel.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor是一项成熟的技术，最初出现在Immunix中，后来集成到Ubuntu、Novell/SUSE和Mandriva中。核心AppArmor功能从Linux内核2.6.36版本开始就已经在主线内核中；AppArmor、Ubuntu和其他开发人员正在进行工作，将其他额外的AppArmor功能合并到主线内核中。
- en: You can find more information about AppArmor at [https://wiki.ubuntu.com/AppArmor](https://wiki.ubuntu.com/AppArmor).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://wiki.ubuntu.com/AppArmor](https://wiki.ubuntu.com/AppArmor)找到有关AppArmor的更多信息。
- en: AppArmor and Docker
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AppArmor和Docker
- en: Applications running inside Docker can leverage AppArmor for defining policies.
    These profiles can either be created manually or loaded using a tool called bane.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker内运行的应用程序可以利用AppArmor来定义策略。这些配置文件可以手动创建，也可以使用一个名为bane的工具加载。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On Ubuntu 14.x, make sure systemd is installed for the following commands to
    work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu 14.x上，确保安装了systemd才能使以下命令生效。
- en: 'The following steps show how to use this tool:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤显示了如何使用这个工具：
- en: 'Download the bane project for GitHub:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从GitHub下载bane项目：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Make sure this is done in the directory in your GOPATH. For example, we used
    `/home/ubuntu/go` and the bane source was downloaded in `/home/Ubuntu/go/src/github.com/jfrazelle/bane`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这是在您的GOPATH目录中完成的。例如，我们使用了`/home/ubuntu/go`，bane源代码下载在`/home/Ubuntu/go/src/github.com/jfrazelle/bane`。
- en: 'Install toml parser needed by bane to be compiled:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装bane编译所需的toml解析器：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Go to the `/home/Ubuntu/go/src/github.com/jfrazelle/bane` directory and run
    the following command:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到`/home/Ubuntu/go/src/github.com/jfrazelle/bane`目录并运行以下命令：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You will find the bane binary in `/home/Ubuntu/go/bin`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将在`/home/Ubuntu/go/bin`中找到bane二进制文件。
- en: 'Use a `.toml` file to create a profile:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`.toml`文件创建配置文件：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Execute bane to load the profile. `sample.toml` is a file in the directory
    `/home/Ubuntu/go/src/github.com/jfrazelle/bane`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行bane加载配置文件。`sample.toml`是在`/home/Ubuntu/go/src/github.com/jfrazelle/bane`目录中的文件：
- en: '[PRE50]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This profile will make a whole lot of paths read only and allows only nginx
    execution in the container we are going to create. It disables TOP, PING, and
    so on.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件将使大量路径变为只读，并且只允许在我们将要创建的容器中执行nginx。它禁用了TOP、PING等。
- en: 'Once the profile is loaded you can create a nginx container:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦配置文件加载，您就可以创建一个nginx容器：
- en: '[PRE51]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Note, if AppArmor is not able to find the file, copy the file into the `/etc/apparmor.d`
    directory and reload the AppArmour profiles:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果AppArmor无法找到文件，将文件复制到`/etc/apparmor.d`目录并重新加载AppArmour配置文件：
- en: '[PRE52]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Create the nginx container with the AppArmor profile:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AppArmor配置文件创建nginx容器：
- en: '[PRE53]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The following figure shows how an nginx app running inside a container uses
    AppArmour application profiles:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了容器中运行的nginx应用程序如何使用AppArmour应用程序配置文件：
- en: '![AppArmor and Docker](../images/00045.jpeg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![AppArmor and Docker](../images/00045.jpeg)'
- en: Docker security benchmark
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker安全基准
- en: The following tutorial shows some of the important guidelines that should be
    followed in order to run Docker containers in secured and production environments.
    It is referred from the CIS Docker Security Benchmark [https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf](https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下教程展示了一些重要的准则，应遵循以在安全和生产环境中运行Docker容器。这是从CIS Docker安全基准[https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf](https://benchmarks.cisecurity.org/tools2/docker/CIS_Docker_1.6_Benchmark_v1.0.0.pdf)中引用的。
- en: Audit Docker daemon regularly
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定期审计Docker守护程序
- en: 'Apart from auditing your regular Linux filesystem and system calls, audit Docker
    daemon as well. Docker daemon runs with root privileges. It is thus necessary
    to audit its activities and usage:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了审计常规的Linux文件系统和系统调用外，还要审计Docker守护程序。Docker守护程序以root权限运行。因此，有必要审计其活动和使用情况：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Remove the audit log file, if it exists:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在审计日志文件，则删除：
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the audit rules for the Docker service and audit the Docker service:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为Docker服务添加审计规则并审计Docker服务：
- en: '[PRE56]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Create a user for the container
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为容器创建一个用户
- en: Currently, mapping the container's root user to a non-root user on the host
    is not supported by Docker. The support for user namespace would be provided in
    future releases. This creates a serious user isolation issue. It is thus highly
    recommended to ensure that there is a non-root user created for the container
    and the container is run using that user.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Docker不支持将容器的root用户映射到主机上的非root用户。用户命名空间的支持将在未来版本中提供。这会导致严重的用户隔离问题。因此，强烈建议确保为容器创建一个非root用户，并使用该用户运行容器。
- en: 'As we can see in the following snippet, by default, the `centos` Docker image
    has a `user` field as blank, which means, by default, the container will get a
    root user during runtime, which should be avoided:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在以下片段中所见，默认情况下，“centos” Docker镜像的“user”字段为空，这意味着默认情况下容器在运行时将获得root用户，这应该避免：
- en: '[PRE57]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'While building the Docker image, we can provide the `test` user, the less-privileged
    user, in the Dockerfile, as shown in the following snippet:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Docker镜像时，可以在Dockerfile中提供“test”用户，即权限较低的用户，如以下片段所示：
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'When we start the Docker container, we can see that it gets a `test` user,
    and the `docker inspect` command also shows the default user as `test`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动Docker容器时，可以看到它获得了一个“test”用户，而“docker inspect”命令也显示默认用户为“test”：
- en: '[PRE59]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Do not mount sensitive host system directories on containers
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在容器上挂载敏感主机系统目录
- en: If sensitive directories are mounted in read-write mode, it would be possible
    to make changes to files within those sensitive directories. The changes might
    bring down security implications or unwarranted changes that could put the Docker
    host in a compromised state.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果敏感目录以读写模式挂载，可能会对这些敏感目录内的文件进行更改。这些更改可能带来安全隐患或不必要的更改，可能使Docker主机处于受损状态。
- en: 'If the `/run/systemd` sensitive directory is mounted in the container then
    we can actually shutdown the host from the container itself:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在容器中挂载了“/run/systemd”敏感目录，那么我们实际上可以从容器本身关闭主机：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'It can be audited by using the following command, which returns the list of
    current mapped directories and whether they are mounted in read-write mode for
    each container instance:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用以下命令进行审计，该命令返回当前映射目录的列表以及每个容器实例是否以读写模式挂载：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Do not use privileged containers
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要使用特权容器
- en: Docker supports the addition and removal of capabilities, allowing the use of
    a non-default profile. This may make Docker more secure through capability removal,
    or less secure through the addition of capabilities. It is thus recommended to
    remove all capabilities except those explicitly required for your container process.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持添加和删除功能，允许使用非默认配置文件。这可能通过删除功能使Docker更安全，或者通过添加功能使其不太安全。因此建议除了容器进程明确需要的功能外，删除所有功能。
- en: 'As seen in the following, when we run the container without the privileged
    mode, we are unable to change the kernel parameters, but when we run the container
    in privileged mode using the `--privileged` flag, it is possible to change the
    kernel parameters easily, which can cause security vulnerability:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下所示，当我们在不使用特权模式的情况下运行容器时，我们无法更改内核参数，但是当我们使用`--privileged`标志在特权模式下运行容器时，可以轻松更改内核参数，这可能会导致安全漏洞。
- en: '[PRE62]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'So, while auditing, it should be made sure that all the containers should not
    have the privileged mode set to `true`:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在审核时，必须确保所有容器的特权模式未设置为`true`。
- en: '[PRE63]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Summary
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we took a deep dive into Docker security with an overview of
    cgroups and kernel namespace. We also went over some of the aspects of filesystems
    and Linux capabilities, which containers leverage in order to provide more features,
    such as the privileged containers, but at the cost of exposing itself more on
    the threat side. We also saw how containers can be deployed in a secured environment
    in AWS ECS (EC2 container service) using proxy containers to restrict vulnerable
    traffic. AppArmor also provides kernel-enhancement features in order to confine
    applications to a limited set of resources. Leveraging their benefits to Docker
    containers helps us to deploy them in a secured environment. Finally, we had a
    quick dive into Docker security benchmarks and some of the important recommendations
    that can be followed during auditing and Docker deployment in the production environment.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了Docker安全性，并概述了cgroups和内核命名空间。我们还讨论了文件系统和Linux功能的一些方面，容器利用这些功能来提供更多功能，例如特权容器，但代价是在威胁方面更容易暴露。我们还看到了如何在AWS
    ECS（EC2容器服务）中部署容器以在受限流量中使用代理容器来在安全环境中部署容器。AppArmor还提供了内核增强功能，以将应用程序限制在有限的资源集上。利用它们对Docker容器的好处有助于在安全环境中部署它们。最后，我们快速了解了Docker安全基准和在生产环境中进行审核和Docker部署期间可以遵循的一些重要建议。
- en: In the next chapter, we will learn about tuning and troubleshooting in the Docker
    network using various tools.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习使用各种工具在Docker网络中进行调优和故障排除。
