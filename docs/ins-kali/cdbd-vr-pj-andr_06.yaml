- en: Chapter 6. Solar System
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。太阳系
- en: When I was 8 years old, for a science project at school, I made a *Solar System*
    from wires, styrofoam balls, and paint. Today, 8-year olds all around the world
    will be able to make virtual Solar Systems in VR, especially if they read this
    chapter! This project creates a Cardboard VR app that simulates our Solar System.
    Well, maybe not with total scientific accuracy, but good enough for a kid's project
    and better than styrofoam balls.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我8岁的时候，在学校的一个科学项目中，我用电线、聚苯乙烯泡沫球和油漆制作了一个*太阳系*。今天，全世界的8岁孩子们都可以在VR中制作虚拟太阳系，特别是如果他们读了这一章！这个项目创建了一个模拟我们太阳系的Cardboard
    VR应用程序。也许不是完全科学准确，但对于一个孩子的项目来说已经足够好了，比聚苯乙烯泡沫球要好。
- en: 'In this chapter, you will create a new Solar System project with the `RenderBox`
    library by performing the following steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将使用“RenderBox”库创建一个新的太阳系项目，执行以下步骤：
- en: Setting up the new project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置新项目
- en: Creating a `Sphere` component and a solid color material
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个“Sphere”组件和一个纯色材料
- en: Adding an `Earth` texture material with lighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加带照明的“地球”纹理材料
- en: Arranging the Solar System geometry
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排太阳系的几何形状
- en: Animating the heavenly bodies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 天体的动画
- en: Interactively changing camera locations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交互式更改相机位置
- en: Updating the `RenderBox` library with our new code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们的新代码更新“RenderBox”库
- en: As we put these together, we will create planets and moons from a sphere. Much
    of the code, however, will be in the various materials and shaders for rendering
    these bodies.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它们放在一起时，我们将从一个球体创建行星和卫星。然而，大部分代码将用于渲染这些天体的各种材料和着色器。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code for this project can be found on the Packt Publishing website,
    and on GitHub at [https://github.com/cardbookvr/solarsystem](https://github.com/cardbookvr/solarsystem)
    (with each topic as a separate commit).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目的源代码可以在Packt Publishing网站上找到，并且在GitHub上也可以找到[https://github.com/cardbookvr/solarsystem](https://github.com/cardbookvr/solarsystem)（每个主题作为单独的提交）。
- en: Setting up a new project
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置新项目
- en: 'To build this project, we will use our `RenderBox` library created in [Chapter
    5](ch05.html "Chapter 5. RenderBox Engine"), *RenderBox Engine*. You can use yours,
    or grab a copy from the downloadable files provided with this book or our GitHub
    repository (use the commit tagged `after-ch5`—[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5)).
    For a more detailed description of how to import the `RenderBox` library, refer
    to the final *Using RenderBox in future projects* section of [Chapter 5](ch05.html
    "Chapter 5. RenderBox Engine"), *RenderBox Engine*. Perform the following steps
    to create a new project:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建此项目，我们将使用我们在[第5章](ch05.html "第5章。RenderBox引擎")中创建的“RenderBox”库，*RenderBox引擎*。您可以使用您自己的库，或者从本书提供的可下载文件或我们的GitHub存储库中获取副本（使用标记为`after-ch5`的提交——[https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5](https://github.com/cardbookvr/renderboxlib/releases/tag/after-ch5)）。有关如何导入“RenderBox”库的更详细说明，请参阅[第5章](ch05.html
    "第5章。RenderBox引擎")的最终*在未来项目中使用RenderBox*部分，*RenderBox引擎*。执行以下步骤创建新项目：
- en: With Android Studio opened, create a new project. Let's name it `SolarSystem`
    and target **Android 4.4 KitKat (API 19)** with an **Empty Activity**.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的Android Studio中创建一个新项目。让我们将其命名为“SolarSystem”，并针对**Android 4.4 KitKat (API
    19)**使用**空活动**。
- en: Create new modules for each of `renderbox`, `common` and `core` packages, using
    **File** | **New Module** | **Import .JAR/.AAR Package**.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`renderbox`、`common`和`core`包创建新模块，使用**文件** | **新建模块** | **导入.JAR/.AAR包**。
- en: Set the modules as dependencies for the app, using **File** | **Project Structure**.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将模块设置为应用程序的依赖项，使用**文件** | **项目结构**。
- en: Edit the `build.gradle` file as explained in [Chapter 2](ch02.html "Chapter 2. The
    Skeleton Cardboard Project"), *The Skeleton Cardboard Project*, to compile against
    SDK 22.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照[第2章](ch02.html "第2章。骨架Cardboard项目")中的说明编辑`build.gradle`文件，*骨架Cardboard项目*，以编译SDK
    22。
- en: Update `/res/layout/activity_main.xml` and `AndroidManifest.xml`, as explained
    in the previous chapters.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`/res/layout/activity_main.xml`和`AndroidManifest.xml`，如前几章所述。
- en: Edit `MainActivity` as `class MainActivity extends CardboardActivity implements
    IRenderBox`, and implement the interface method stubs (*Ctrl* + *I*).
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainActivity`编辑为`class MainActivity extends CardboardActivity implements IRenderBox`，并实现接口方法存根（*Ctrl*
    + *I*）。
- en: 'We can go ahead and define the `onCreate` method in `MainActivity`. The class
    now has the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续在`MainActivity`中定义`onCreate`方法。该类现在具有以下代码：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While we build this project, we will be creating new classes that could be
    good extensions to `RenderBox` lib. We''ll make them regular classes in this project
    at first. Then, at the end of the chapter, we''ll help you move them into the
    `RenderBox` lib project and rebuild the library:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建此项目时，我们将创建一些新的类，这些类可能是“RenderBox”库的良好扩展。我们将首先将它们作为常规类放入此项目。然后，在本章末尾，我们将帮助您将它们移入“RenderBox”库项目并重新构建该库：
- en: Right-click on the `solarsystem` folder (`com.cardbookvr.solarsystem`), select
    **New** | **Package**, and name it `RenderBoxExt`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击“solarsystem”文件夹（`com.cardbookvr.solarsystem`），选择**新建** | **包**，并命名为“RenderBoxExt”。
- en: Within `RenderBoxExt`, create package subfolders named `components` and `materials`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“RenderBoxExt”中，创建名为“components”和“materials”的包子文件夹。
- en: There's no real technical need to make it a separate package, but this helps
    organize our files, as the ones in `RenderBoxExt` will be moved into our reusable
    library at the end of this chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 没有真正的技术需要将其制作成一个单独的包，但这有助于组织我们的文件，因为“RenderBoxExt”中的文件将在本章末尾移入我们可重用的库中。
- en: 'You can add a cube to the scene, temporarily, to help ensure that everything
    is set up properly. Add it to the `setup` method as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个立方体临时添加到场景中，以确保一切设置正确。将其添加到“setup”方法中，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you remember, a cube is a component that's added to a transform. The cube
    defines its geometry (for example, vertices). The transform defines its position,
    rotation, and scale in 3D space.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，立方体是添加到变换中的一个组件。立方体定义了它的几何形状（例如，顶点）。变换定义了它在3D空间中的位置、旋转和缩放。
- en: You should be able to click on **Run 'app'** with no compile errors, and see
    the cube and Cardboard split screen view on your Android device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在Android设备上点击**Run 'app'**，并且看到立方体和Cardboard分屏视图，没有编译错误。
- en: Creating a Sphere component
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个球体组件
- en: Our Solar System will be constructed from spheres, representing planets, moons,
    and the Sun. Let's first create a `Sphere` component. We are going to define a
    sphere as a triangle mesh of vertices that form the surface of the sphere (For
    more information on a triangle mesh, refer to [https://en.wikipedia.org/wiki/Triangle_mesh](https://en.wikipedia.org/wiki/Triangle_mesh)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的太阳系将由球体构成，代表行星、卫星和太阳。让我们首先创建一个“Sphere”组件。我们将定义一个球体，它是由形成球体表面的顶点三角网格组成的（有关三角网格的更多信息，请参阅[https://en.wikipedia.org/wiki/Triangle_mesh](https://en.wikipedia.org/wiki/Triangle_mesh)）。
- en: 'Right-click on the `RenderBoxExt/components` folder, select **New** | **Java
    Class**, and name it `Sphere`. Define it as `public class Sphere extends RenderObject`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击“RenderBoxExt/components”文件夹，选择**New** | **Java Class**，并将其命名为“Sphere”。将其定义为“public
    class Sphere extends RenderObject”：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The constructor calls a helper method, `allocateBuffers`, which allocates buffers
    for vertices, normals, textures, and indexes. Let''s declare variables for these
    at the top of the class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数调用一个辅助方法“allocateBuffers”，该方法为顶点、法线、纹理和索引分配缓冲区。让我们在类的顶部声明这些变量：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we've decided to declare the buffers `public` to afford future flexibility
    in creating arbitrary texture materials for objects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们决定将缓冲区声明为“public”，以便在为对象创建任意纹理材料时具有未来的灵活性。
- en: 'We''ll define a sphere with a radius of 1\. Its vertices are arranged by 24
    longitude sections (as hours of the day) and 16 latitude sections, providing sufficient
    resolution for our purposes. The top and bottom caps are handled separately. This
    is a long method, so we''ll break it down for you. Here''s the first part of the
    code where we declare and initialize variables, including the vertices array.
    Similar to our `Material` setup methods, we only need to allocate the `Sphere`
    buffers once, and in this case, we use the vertex buffer variable to keep track
    of this state. If it is not null, the buffers have already been allocated. Otherwise,
    we should continue with the function, which will set this value:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个半径为1的球体。它的顶点由24个经度部分（如同一天中的小时）和16个纬度部分排列，为我们的目的提供了足够的分辨率。顶部和底部盖子分开处理。这是一个很长的方法，所以我们将为您分解它。这是代码的第一部分，我们在其中声明和初始化变量，包括顶点数组。与我们的“Material”设置方法类似，我们只需要一次性分配“Sphere”缓冲区，在这种情况下，我们使用顶点缓冲区变量来跟踪这种状态。如果它不为空，则已经分配了缓冲区。否则，我们应该继续执行该函数，该函数将设置这个值：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Calculate the vertex positions; first, the top and bottom ones and then along
    the latitude/longitude spherical grid:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 计算顶点位置；首先是顶部和底部，然后沿纬度/经度球形网格：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we calculate the vertex normals and then the UVs for texture mapping:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们计算顶点法线，然后进行纹理映射的UV：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This next part of the same `allocateBuffers` method generates the triangular
    indices, which connect the vertices:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 同一“allocateBuffers”方法的下一部分生成了连接顶点的三角形索引：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, apply these calculated values to the corresponding `vertexBuffer`,
    `normalBuffer`, `texCoordBuffer`, and `indexBuffer` arrays, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这些计算值应用到相应的“vertexBuffer”、“normalBuffer”、“texCoordBuffer”和“indexBuffer”数组中，如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a lot of code, and might be hard to read on the pages of a book; you
    can find a copy in the project GitHub repository if you prefer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多代码，可能在书页上很难阅读；如果您愿意，您可以在项目GitHub存储库中找到一份副本。
- en: 'Conveniently, since the sphere is centered at the origin (0,0,0), the normal
    vectors at each vertex correspond to the vertex position itself (radiating from
    the origin to the vertex). Strictly speaking, since we used a radius of 1, we
    can avoid the `normalize()` step to generate the array of normals as an optimization.
    The following image shows the 24 x 16 vertex sphere with its normal vectors:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，由于球体位于原点（0,0,0）处，每个顶点的法线向量对应于顶点位置本身（从原点辐射到顶点）。严格来说，由于我们使用了半径为1，我们可以避免“normalize（）”步骤来生成法线数组，以进行优化。以下图显示了24
    x 16顶点球体及其法线向量：
- en: '![Creating a Sphere component](img/B05144_06_01.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![创建球体组件](img/B05144_06_01.jpg)'
- en: Note that our algorithm includes an interesting fix that avoids a single vertex
    at the poles (where all the UVs converge at a single point and cause some swirling
    texture artifacts).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的算法包括一个有趣的修复，避免了极点处的单个顶点（所有UV汇聚在一个点上，导致一些旋转的纹理伪影）。
- en: 'We create *nLon-1* co-located vertices spread across the UV X, offset by *1/(nLon*2)*,
    drawing teeth at the top and bottom. The following image shows the flattened UV
    sheet for the sphere illustrating the polar teeth:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在UV X上创建*nLon-1*个共同位置的顶点，偏移量为*1/(nLon*2)*，在顶部和底部绘制齿。以下图显示了球体的展平UV图，说明了极点的齿状：
- en: '![Creating a Sphere component](img/B05144_06_02.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![创建球体组件](img/B05144_06_02.jpg)'
- en: A solid color lighted sphere
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实色光照的球体
- en: We are going to start by rendering our sphere in a solid color but with lighted
    shading. As usual, we start by writing the shader functions that, among other
    things, define the program variables they will need from the `Material` that uses
    it. Then, we'll define the `SolidColorLightingMaterial` class and add it to the
    `Sphere` component.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从以实色渲染我们的球体开始，但是使用光照着色。和往常一样，我们首先编写着色器函数，其中包括定义它所使用的“Material”中的程序变量。然后，我们将定义“SolidColorLightingMaterial”类，并将其添加到“Sphere”组件中。
- en: Solid color lighting shaders
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实色光照着色器
- en: In the previous chapters, where we used shaders with lighting, we did the lighting
    calculations in the vertex shader. That's simpler (and faster), but transitioning
    the calculations to the fragment shader yields better results. The reason is that,
    in the vertex shader, you only have one normal value to compare against the light
    direction. In the fragment, all vertex attributes are interpolated, meaning that
    the normal value at a given point between two vertices will be some point in between
    their two normals. When this is the case, you see a smooth gradient across the
    triangle face, rather than localized shading artifacts around each vertex. We
    will be creating a new `Material` class to implement lighting in the fragment
    shader.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们在顶点着色器中进行了光照计算。这更简单（也更快），但是将计算转移到片段着色器会产生更好的结果。原因是，在顶点着色器中，你只有一个法线值可以与光线方向进行比较。在片段着色器中，所有顶点属性都被插值，这意味着在两个顶点之间的给定点的法线值将是它们两个法线之间的某个点。当这种情况发生时，你会看到三角形面上的平滑渐变，而不是在每个顶点周围的局部阴影伪影。我们将创建一个新的“Material”类来在片段着色器中实现光照。
- en: 'If necessary, create an Android Resource Directory for the shaders (resource
    type: `raw`), `res/raw/`. Then, create the `solid_color_lighting_vertex.shader`
    and `res/raw/solid_color_lighting_fragment.shader` files and define them as follows.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，为着色器创建一个Android资源目录（资源类型：`raw`），`res/raw/`。然后，创建`solid_color_lighting_vertex.shader`和`res/raw/solid_color_lighting_fragment.shader`文件，并定义如下。
- en: 'File: `res/raw/solid_color_lighting_vertex.shader`'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/solid_color_lighting_vertex.shader`
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that we have separate uniform variables for `u_MV` and `u_MVP`. Also, if
    you remember that in the previous chapter, we separated the lighting model from
    the actual model because we did not want scale to affect lighting calculations.
    Similarly, the projection matrix is only useful to apply the camera FOV to vertex
    positions and will interfere with lighting calculations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们为“u_MV”和“u_MVP”分别有单独的统一变量。另外，如果你还记得，在上一章中，我们将光照模型与实际模型分开，因为我们不希望缩放影响光照计算。同样，投影矩阵只对将相机FOV应用于顶点位置有用，并且会干扰光照计算。
- en: 'File: `res/raw/solid_color_lighting_fragment.shader`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/solid_color_lighting_fragment.shader`
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Solid color lighting material
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯色光照材质
- en: 'Next, we define the `Material` class for the shaders. In the materials folder,
    create a new Java class named `SolidColorLightingMaterial` and define it as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们为着色器定义“Material”类。在materials文件夹中，创建一个名为“SolidColorLightingMaterial”的新Java类，并定义如下：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the variables for color, program references, and buffers, as shown in the
    following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 添加颜色、程序引用和缓冲区的变量，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can add a constructor, which receives a color (RGBA) value and sets
    up the shader program, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一个构造函数，它接收一个颜色（RGBA）值并设置着色器程序，如下所示：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we''ve seen earlier, the `setupProgram` method creates the shader program
    and obtains references to its parameters:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，“setupProgram”方法创建了着色器程序并获取了对其参数的引用：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Likewise, we add a `setBuffers` method that is called by the `RenderObject`
    component (`Sphere`):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们添加一个“setBuffers”方法，该方法由“RenderObject”组件（`Sphere`）调用：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Lastly, add the `draw` code, which will be called from the `Camera` component,
    to render the geometry prepared in the buffers (via `setBuffers`). The `draw`
    method looks like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加“draw”代码，该代码将从“Camera”组件中调用，以渲染在缓冲区中准备的几何图形（通过“setBuffers”）。“draw”方法如下所示：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now that we have a solid color lighting material and shaders, we can add them
    to the `Sphere` class to be used in our project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个纯色光照材质和着色器，我们可以将它们添加到“Sphere”类中，以在我们的项目中使用。
- en: Adding a Material to a Sphere
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向球体添加材质
- en: 'To use this `Material` with the `Sphere`, we''ll define a new constructor (`Sphere`)
    that calls a helper method (`createSolidColorLightingMaterial`) to create the
    material and set the buffers. Here''s the code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这个“Material”与“Sphere”一起使用，我们将定义一个新的构造函数（`Sphere`），它调用一个辅助方法（`createSolidColorLightingMaterial`）来创建材质并设置缓冲区。代码如下：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Okay, we can now add the sphere to our scene.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在我们可以将球体添加到我们的场景中。
- en: Viewing the Sphere
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看球体
- en: Let's see how this looks! We'll create a scene with a sphere, a light, and a
    camera. Remember that, fortunately, the `RenderBox` class creates the default
    `Camera` and `Light` instances for us. We just need to add the `Sphere` component.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是什么样子！我们将创建一个带有球体、灯光和相机的场景。请记住，幸运的是，“RenderBox”类为我们创建了默认的“Camera”和“Light”实例。我们只需要添加“Sphere”组件。
- en: 'Edit your `MainActivity.java` file to add the sphere in `setup`. We''ll color
    it yellowish and position it at *x*, *y*, *z* location (2, -2, 5):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的`MainActivity.java`文件，在`setup`中添加球体。我们将它着色为黄色，并将其定位在*x*、*y*、*z*位置（2，-2，5）：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here''s what it should look like, a stereoscopic pair of golden globes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它应该看起来的样子，一对金色的立体对球：
- en: '![Viewing the Sphere](img/B05144_06_03.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: 查看球体
- en: If you see what I see, you deserve an award for that!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到了我看到的，你就应该得到一个奖励！
- en: Adding the Earth texture material
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地球纹理材质
- en: Next, we'll terraform our sphere into a globe of the Earth by rendering a texture
    onto the surface of the sphere.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过在球体表面上渲染纹理来将我们的球体改造成地球的球体。
- en: Shaders can get quite complex, implementing all kinds of specular highlights,
    reflections, shadows, and so on. A simpler algorithm that still makes use of a
    color texture and lighting is a diffuse material. This is what we'll use here.
    The word diffuse refers to the fact that light diffuses across the surface, as
    opposed to being reflective or shiny (specular lighting).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器可能会变得非常复杂，实现各种高光、反射、阴影等。一个更简单的算法，仍然利用颜色纹理和光照的是漫反射材质。这就是我们将在这里使用的。漫反射一词指的是光线在表面上的扩散，而不是反射或闪亮（镜面光照）。
- en: 'A texture is just an image file (for example, `.jpg`) that can be mapped (projected)
    onto a geometric surface. Since a sphere isn''t easily flattened or unpeeled into
    a two-dimensional map (as centuries of cartographers can attest), the texture
    image will look distorted. The following is the texture we''ll use for the Earth.
    (A copy of this file is provided with the download files for this book and similar
    ones can be found on the Internet at [http://www.solarsystemscope.com/nexus/textures/](http://www.solarsystemscope.com/nexus/textures/)):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理只是一个可以映射（投影）到几何表面上的图像文件（例如`.jpg`）。由于球体不容易被扁平化或剥离成二维地图（正如几个世纪的制图师所证明的那样），纹理图像将会看起来扭曲。以下是我们将用于地球的纹理。（本书的下载文件中提供了此文件的副本，类似的文件也可以在互联网上找到[http://www.solarsystemscope.com/nexus/textures/](http://www.solarsystemscope.com/nexus/textures/)）：
- en: In our application, we plan to make use of the standard practice of packaging
    image assets into the `res/drawable` folder. If necessary, create this folder
    now.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们计划将图像资产打包到`res/drawable`文件夹中。如果需要，现在创建此文件夹。
- en: Add the `earth_tex.png` file to it.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`earth_tex.png`文件添加到其中。
- en: 'The `earth_tex` texture is shown in the following image:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`earth_tex`纹理如下图所示：'
- en: '![Adding the Earth texture material](img/B05144_06_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![添加地球纹理材质](img/B05144_06_04.jpg)'
- en: Loading a texture file
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载纹理文件
- en: 'We now need a function to load the texture into our app. We can add it to `MainActivity`.
    Or, you can add it directly to the `RenderObject` class of your `RenderBox` lib.
    (It''s fine in `MainActivity` for now, and we''ll move it along with our other
    extensions to the library at the end of this chapter.) Add the code, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个函数将纹理加载到我们的应用程序中。我们可以将其添加到`MainActivity`中。或者，您可以直接将其添加到`RenderBox`库的`RenderObject`类中。（现在将其添加到`MainActivity`中，我们将在本章末将其与其他扩展一起移动到库中。）添加以下代码：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `loadTexture` method returns an integer handle that can be used to reference
    the loaded texture data.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadTexture`方法返回一个整数句柄，该句柄可用于引用加载的纹理数据。'
- en: Diffuse lighting shaders
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漫反射光照着色器
- en: As you may now be familiar, we are going to create a new `Material`, which uses
    new shaders. We'll write the shaders now. Create the two files in the `res/raw`
    folder named `diffuse_lighting_vertex.shader` and `diffuse_lighting_fragment.shader`,
    and define them as follows.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可能已经熟悉了，我们将创建一个新的`Material`，它使用新的着色器。我们现在将编写着色器。在`res/raw`文件夹中创建两个文件，分别命名为`diffuse_lighting_vertex.shader`和`diffuse_lighting_fragment.shader`，并定义如下。
- en: 'File: `res/raw/diffuse_lighting_vertex.shader`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/diffuse_lighting_vertex.shader`
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'File: `res/raw/diffuse_lighting_fragment.shader`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`res/raw/diffuse_lighting_fragment.shader`
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: These shaders add attributes to a light source and utilize geometry normal vectors
    on the vertices to calculate the shading. You might have noticed that the difference
    between this and the solid color shader is the use of texture2D, which is a **sampler
    function**. Also, note that we declared `u_Texture` as sampler2D. This variable
    type and function make use of the texture units, which are built into the GPU
    hardware, and can be used with UV coordinates to return the color values from
    a texture image. There are a fixed number of texture units, depending on graphics
    hardware. You can query the number of texture units using OpenGL. A good rule
    of thumb for mobile GPUs is to expect eight texture units. This means that any
    shader may use up to eight textures simultaneously.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些着色器为光源添加属性，并利用顶点上的几何法向量来计算着色。您可能已经注意到，这与纯色着色器之间的区别在于使用了`texture2D`，这是一个**采样器函数**。另外，请注意我们将`u_Texture`声明为`sampler2D`。这种变量类型和函数利用了内置到GPU硬件中的纹理单元，并可以与UV坐标一起用于从纹理图像返回颜色值。根据图形硬件的不同，纹理单元的数量是固定的。您可以使用OpenGL查询纹理单元的数量。对于移动GPU来说，一个很好的经验法则是期望有八个纹理单元。这意味着任何着色器可以同时使用多达八个纹理。
- en: Diffuse lighting material
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漫反射光照材质
- en: 'Now we can write a `Material` to use a texture and shaders. In the `materials/`
    folder, create a new Java class, `DiffuseLightingMaterial`, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个使用纹理和着色器的`Material`。在`materials/`文件夹中，创建一个名为`DiffuseLightingMaterial`的新Java类，如下所示：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the variables for the texture ID, program references, and buffers, as shown
    in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加纹理ID、程序引用和缓冲区的变量，如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now we can add a constructor, which sets up the shader program and loads the
    texture for the given resource ID, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以添加一个构造函数，该构造函数设置着色器程序并为给定的资源ID加载纹理，如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we''ve seen earlier, the `setupProgram` method creates the shader program
    and obtains references to its parameters:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，`setupProgram`方法创建着色器程序并获取其参数的引用：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Likewise, we add a `setBuffers` method that is called by the `RenderObject`
    component (`Sphere`):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们添加一个`setBuffers`方法，该方法由`RenderObject`组件（`Sphere`）调用：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Lastly, add the `draw` code, which will be called from the `Camera` component,
    to render the geometry prepared in the buffers (via `setBuffers`). The `draw`
    method looks like this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，添加`draw`代码，该代码将从`Camera`组件调用，以渲染通过`setBuffers`准备的几何图形。`draw`方法如下所示：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Comparing this with the `SolidColorLightingMaterial` class that we defined earlier,
    you will notice that it's quite similar. We've replaced the single color with
    a texture ID, and we've added the requirements for a texture coordinate buffer
    (`texCoordBuffer`) given by a `Sphere` component. Also, note that we are setting
    the active texture unit to `GL_TEXTURE0` and binding the texture.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前定义的`SolidColorLightingMaterial`类进行比较，您会注意到它非常相似。我们用纹理ID替换了单一颜色，并添加了由`Sphere`组件给出的纹理坐标缓冲区（`texCoordBuffer`）的要求。另外，请注意我们将活动纹理单元设置为`GL_TEXTURE0`并绑定纹理。
- en: Adding diffuse lighting texture to a Sphere component
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向Sphere组件添加漫反射光照纹理
- en: To add the new material to the `Sphere` component, we'll make an alternative
    constructor that receives a texture handle. It then creates an instance of the
    `DiffuseLightingMaterial` class and sets the buffers from the sphere.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要将新的材质添加到`Sphere`组件中，我们将创建一个接收纹理句柄的替代构造函数。然后，它创建`DiffuseLightingMaterial`类的一个实例，并从球体设置缓冲区。
- en: 'Let''s add the material to the `Sphere` component by defining a new constructor
    (`Sphere`) that takes the texture ID and calls a new helper method named `createDiffuseMaterial`,
    as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义一个接受纹理ID并调用一个名为`createDiffuseMaterial`的新辅助方法的新构造函数(`Sphere`)，将材料添加到`Sphere`组件中，如下所示：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, we can use the textured material.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用纹理材料。
- en: Viewing the Earth
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看地球
- en: 'To add the Earth texture to our sphere, modify the `setup` method of `MainActivity`
    to specify the texture resource ID instead of a color, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要将地球纹理添加到我们的球体中，修改`MainActivity`的`setup`方法，以指定纹理资源ID而不是颜色，如下所示：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There you have it, *Home Sweet Home!*
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你看，*家，甜蜜的家！*
- en: '![Viewing the Earth](img/B05144_06_05.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: 查看地球
- en: 'That looks really cool. Oops, it''s upside down! Although there''s not really
    a specific up versus down in outer space, our Earth looks upside down from what
    we''re used to seeing. Let''s flip it in the `setup` method so that it starts
    at the correct orientation, and while we''re at it, let''s take advantage of the
    fact that the `Transform` methods return themselves, so we can chain the calls,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来真的很酷。哎呀，它是颠倒的！虽然在外太空中没有特定的上下，但我们的地球看起来颠倒了。让我们在`setup`方法中翻转它，以便它以正确的方向开始，而且在此过程中，让我们利用`Transform`方法返回它们自己的事实，这样我们就可以链接调用，如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Naturally, the Earth is supposed to spin. Let''s animate it to rotate it like
    we''d expect the Earth to do. Add this to the `preDraw` method, which gets called
    before each new frame. It uses the `Time` class''s `getDeltaTime` method, which
    returns the current fraction of a second change since the previous frame. If we
    want it to rotate, say, -10 degrees per second, we use *-10 * deltaTime*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，地球应该旋转。让我们对其进行动画处理，使其旋转，就像我们期望地球会做的那样。将此添加到`preDraw`方法中，该方法在每个新帧之前调用。它使用`Time`类的`getDeltaTime`方法，该方法返回自上一帧以来的当前秒数变化的分数。如果我们希望它每秒旋转-10度，我们使用*-10
    * deltaTime*：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That looks good to me! How about you?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这样很好！你觉得呢？
- en: Changing the camera position
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变相机位置
- en: One more thing. We seem to be looking at the Earth in line with the light source.
    Let's move the camera view so that we can see the Earth from the side. That way,
    we can see the lighted shading better.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件事。我们似乎是在与光源一致地观看地球。让我们移动相机视图，这样我们就可以从侧面看到地球。这样，我们可以更好地看到受光照的阴影。
- en: 'Suppose we leave the light source position at the origin, (0,0,0) as if it
    were the Sun at the center of the Solar System. The Earth is 147.1 million km
    from the Sun. Let''s place the sphere that many units to the right of the origin,
    and place the camera at the same relative position. Now, the `setup` method looks
    like the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将光源位置保留在原点(0,0,0)，就好像它是太阳在太阳系的中心。地球距离太阳1.471亿公里。让我们将球体放在原点右侧那么多单位，并将相机放在相同的相对位置。现在，`setup`方法看起来像以下代码：
- en: '[PRE32]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run it and this is what you will see:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它，你会看到这个：
- en: '![Changing the camera position](img/B05144_06_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![改变相机位置](img/B05144_06_06.jpg)'
- en: Does that look virtually realistic or what? NASA would be proud!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来几乎真实，是吗？NASA会感到自豪！
- en: Day and night material
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白天和夜晚材料
- en: Honestly though, the back of the Earth looks uncannily dark. I mean, this isn't
    the 18th century. So much nowadays is 24 x 7, especially our cities. Let's represent
    this with a separate Earth night texture that has city lights.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，地球的背面看起来异常黑暗。我的意思是，现在不是18世纪。现在很多东西都是24 x 7，尤其是我们的城市。让我们用一个单独的地球夜晚纹理来表示这一点，其中有城市灯光。
- en: We have a file for you to use named `earth_night_tex.jpg`. Drag a copy of the
    file into your `res/drawable/` folder.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个文件供您使用，名为`earth_night_tex.jpg`。将文件的副本拖入您的`res/drawable/`文件夹中。
- en: 'It may be a little difficult to discern on this book''s page, but this is what
    the texture image looks like:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的页面上可能有点难以辨认，但这就是纹理图像的样子：
- en: '![Day and night material](img/B05144_06_07.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![白天和夜晚材料](img/B05144_06_07.jpg)'
- en: Day/night shader
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 白天/夜晚着色器
- en: To support this, we will create a new `DayNightMaterial` class that takes both
    versions of the Earth texture. The material will also incorporate the corresponding
    fragment shader that takes into consideration the normal vector of the surface
    relative to the light source direction (using dot products, if you're familiar
    with vector math) to decide whether to render using the day or night texture image.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一点，我们将创建一个新的`DayNightMaterial`类，该类接受地球纹理的两个版本。该材料还将包含相应的片段着色器，该着色器考虑了表面相对于光源方向的法线向量（使用点积，如果您熟悉矢量数学）来决定是使用白天纹理图像还是夜晚纹理图像进行渲染。
- en: In your `res/raw/` folder, create files for `day_night_vertex.shader` and `day_night_fragment.shader`,
    and then define them, as follows.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`res/raw/`文件夹中，创建`day_night_vertex.shader`和`day_night_fragment.shader`文件，然后定义它们，如下所示。
- en: 'File: `day_night_vertex.shader`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`day_night_vertex.shader`
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Except for the addition of `v_Texcoordinate`, this is exactly the same as our
    `SolidColorLighting` shader.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加`v_Texcoordinate`之外，这与我们的`SolidColorLighting`着色器完全相同。
- en: 'File: `day_night_fragment.shader`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`day_night_fragment.shader`
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As always, for lighting, we calculate the dot product (`dotProd`) of the vertex
    normal vector and the light direction vector. When that value is negative, the
    vertex is facing away from the light source (the Sun), so we'll render using the
    night texture. Otherwise, we'll render using the regular daytime earth texture.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，对于照明，我们计算顶点法线向量和光线方向向量的点积(`dotProd`)。当该值为负时，顶点面向远离光源（太阳），因此我们将使用夜晚纹理进行渲染。否则，我们将使用常规白天地球纹理进行渲染。
- en: The lighting calculations also include a blend value. This is basically a way
    of squeezing the transitional zone closer around the terminator when calculating
    the `gl_FragColor` variable. We are multiplying the dot product by 2.0 so that
    it follows a steeper slope, but still clamping the blend value between 0 and 1\.
    It's a little complicated, but once you think about the math, it should make some
    sense.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 光照计算还包括混合值。这基本上是一种在计算`gl_FragColor`变量时将过渡区域压缩到终结器周围的方法。我们将点积乘以2.0，使其遵循更陡的斜率，但仍将混合值夹在0和1之间。这有点复杂，但一旦你考虑数学，它应该有些意义。
- en: We are using two textures to draw the same surface. While this might seem unique
    to this day/night situation, it is actually a very common method known as multitexturing.
    You may not believe it, but 3D graphics actually got quite far before introducing
    the ability to use more than one texture at a time. These days, you see multitexturing
    almost everywhere, enabling techniques such as normal mapping, decal textures,
    and displacement/parallax shaders, which create greater detail with simpler meshes.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两种纹理来绘制相同的表面。虽然这可能看起来是独特的白天/黑夜情况，但实际上这是一种非常常见的方法，称为多重纹理。你可能不相信，但在引入一次使用多个纹理的能力之前，3D图形实际上已经取得了相当大的进展。如今，你几乎可以在任何地方看到多重纹理，实现诸如法线贴图、贴花纹理和位移/视差着色器等技术，这些技术可以在简单的网格上创建更多的细节。
- en: The DayNightMaterial class
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DayNightMaterial类
- en: Now we can write the `DayNightMaterial` class. It's basically like the `DiffuseLightingMaterial`
    class that we created earlier but supports both the textures. Therefore, the constructor
    takes two texture IDs. The `setBuffers` method is identical to the earlier one,
    and the `draw` method is nearly identical but with the added binding of the night
    texture.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写`DayNightMaterial`类。它基本上类似于我们之前创建的`DiffuseLightingMaterial`类，但支持两种纹理。因此，构造函数接受两个纹理ID。`setBuffers`方法与之前的方法相同，`draw`方法几乎相同，但增加了夜间纹理的绑定。
- en: 'Here''s the complete code, highlighting the lines that differ from `DiffuseLightingMaterial`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码，突出显示与`DiffuseLightingMaterial`不同的行：
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As with our other materials, declare the variables we''ll need, including the
    texture ID for both the day and night:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们其他材料一样，声明我们需要的变量，包括白天和夜晚的纹理ID：
- en: '[PRE36]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Define the constructor that takes both the resource IDs and the `setupProgram`
    helper method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 定义接受资源ID和`setupProgram`辅助方法的构造函数：
- en: '[PRE37]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Lastly, the `draw` method that cranks it all out to the screen:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`draw`方法将所有内容输出到屏幕上：
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Rendering with day/night
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染白天/黑夜
- en: Now we're ready to integrate the new material into our `Sphere` component and
    see how it looks.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将新材料整合到我们的`Sphere`组件中，看看效果如何。
- en: 'In `Sphere.java`, add a new constructor and the `createDayNightMaterial` helper
    method, as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Sphere.java`中，添加一个新的构造函数和`createDayNightMaterial`辅助方法，如下：
- en: '[PRE39]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s call it from the `setup` method of `MainActivity`, and replace the call
    with the new `Sphere` instance passing both the textures'' resource IDs:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`MainActivity`的`setup`方法中调用它，并用新的`Sphere`实例替换调用，传递两个纹理的资源ID：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run it now. That looks really cool! Classy! Unfortunately, it doesn't make a
    lot of sense to paste a screenshot here because the city night lights won't show
    very well. You'll just have to see it for yourself in your own Cardboard viewer.
    Believe me when I tell you, it's worth it!
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行。看起来真酷！高雅！不幸的是，在这里粘贴屏幕截图并没有太多意义，因为城市夜间灯光不会显示得很好。你只能在自己的Cardboard观看器中看到它。相信我，这是值得的！
- en: Next, *here comes the Sun, and I say, it's alright...*
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*太阳来了，我说，没问题...*
- en: Creating the Sun
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建太阳
- en: The Sun will be rendered as a textured sphere. However, it's not shaded with
    front and back sides like our Earth. We need to render it unlit or rather unshaded.
    This means we need to create the `UnlitTextureMaterial`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳将被渲染为一个带纹理的球体。然而，它不像我们的地球那样有正面和背面的阴影。我们需要以未照亮或者说未着色的方式渲染它。这意味着我们需要创建`UnlitTextureMaterial`。
- en: We have a texture file for the Sun, too (and all the planets as well).We won't
    show all of them in the chapter although they're included with the downloadable
    files for the book.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有太阳的纹理文件（以及所有行星）。尽管它们包含在本书的可下载文件中，但我们不会在本章中展示它们。
- en: Drag a copy of the `sun_tex.png` file onto your `res/drawable/` folder.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将`sun_tex.png`文件拖到`res/drawable/`文件夹中。
- en: Unlit texture shaders
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未照亮的纹理着色器
- en: As we've seen earlier in this book, unlit shaders are much simpler than ones
    with lighting. In your `res/raw/` folder, create files for `unlit_tex_vertex.shader`
    and `unlit_tex_fragment.shader`, and then define them, as follows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中早些时候看到的那样，未照亮的着色器比带照明的着色器简单得多。在`res/raw/`文件夹中，创建`unlit_tex_vertex.shader`和`unlit_tex_fragment.shader`文件，并定义它们如下。
- en: 'File: `unlit_tex_vertex.shader`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`unlit_tex_vertex.shader`
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'File: `unlit_tex_fragment.shader`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 文件：`unlit_tex_fragment.shader`
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Yup, that's simpler than our earlier shaders.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这比我们之前的着色器简单。
- en: Unlit texture material
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未照亮的纹理材料
- en: 'Now, we can write the `UnlitTexMaterial` class. Here''s the initial code:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写`UnlitTexMaterial`类。以下是初始代码：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here are the constructor, `setupProgram`, and `setBuffers` methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是构造函数，`setupProgram`和`setBuffers`方法：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'It will be handy to have getter and setter methods for the texture ID (in later
    projects, not used here):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续项目中，为纹理ID添加获取器和设置器方法会很方便（这里不使用）：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Lastly, here''s the `draw` method:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这是`draw`方法：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Rendering with an unlit texture
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用未照亮的纹理进行渲染
- en: We're ready to integrate the new material into our `Sphere` class and see how
    it looks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备将新材料整合到我们的`Sphere`类中，看看效果如何。
- en: 'In `Sphere.java`, add a new constructor that takes a `boolean` parameter, indicating
    that the texture should be lighted, and the `createUnlitTexMaterial` helper method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Sphere.java`中，添加一个新的构造函数，该构造函数接受一个`boolean`参数，指示纹理是否应该被照亮，并添加`createUnlitTexMaterial`辅助方法：
- en: '[PRE47]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Notice that the way in which we've defined constructors, you can call either
    new `Sphere(texId)` or `Sphere(texId, true)` to get lighted renders. But for unlit,
    you must use the second one as `Sphere(texId, false)`. Also note that setting
    up the whole component in the constructor is not the only way to go. We only do
    it this way because it keeps our `MainActivity` code concise. In fact, as we start
    expanding our use of `RenderBox` and its shader library, it will become necessary
    to put most of this code into our `MainActivity` class. It would be impossible
    to create a constructor for every type of material. Ultimately, a materials system
    is necessary to allow you to create and set materials without having to create
    a new class for each one.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们定义构造函数的方式，您可以调用`new Sphere(texId)`或`new Sphere(texId, true)`来获得有光的渲染。但对于未照明的渲染，您必须使用第二个`Sphere(texId,
    false)`。还要注意，构造函数中设置整个组件并不是唯一的方法。我们之所以这样做，是因为这样可以使我们的`MainActivity`代码简洁。实际上，随着我们开始扩展对`RenderBox`及其着色器库的使用，将有必要将大部分代码放入我们的`MainActivity`类中。为每种材料创建构造函数是不可能的。最终，需要一个材料系统，以允许您创建和设置材料，而无需为每个材料创建一个新类。
- en: Adding the Sun
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加太阳
- en: Now, all we need to do is add the Sun sphere to the `setup` method of `MainActivity`.
    Let's make it big, say, at a scale of 6.963 (remember that's in millions of kms).
    This value may seem arbitrary now, but you'll see where it comes from when we
    run the calculations on the Solar System geometry and scale the planets as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要将太阳球添加到`MainActivity`的`setup`方法中。让它变大，比如说，按照6.963的比例（记住这是以百万公里为单位）。现在这个值可能看起来是任意的，但当我们对太阳系的几何进行计算并缩放行星时，您将看到它的来源。
- en: 'Add the following code to the `setup` method of `MainActivity`:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`MainActivity`的`setup`方法中：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We start by defining an origin transform that will be the center of the Solar
    System. Then, we create the Sun, parented to the origin, with the given scale.
    Then, add a new sphere component with the Sun texture. We've also given our light
    a slightly yellowish color, which will blend with the Earth's texture colors.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个原点变换，它将是太阳系的中心。然后，我们创建太阳，将其作为原点的父级，并给定比例。然后，添加一个具有太阳纹理的新球组件。我们还给了我们的光一个略带黄色的颜色，这将与地球的纹理颜色混合。
- en: 'Here''s what the rendered Sun looks like, which seems to illuminate the Earth:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染后的太阳的样子，它似乎照亮了地球：
- en: '![Adding the Sun](img/B05144_06_08.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![添加太阳](img/B05144_06_08.jpg)'
- en: Now, let's move on to the rest of the Solar System.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续进行太阳系的其余部分。
- en: Creating a Planet class
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Planet类
- en: As we build our Solar System, it will be useful to abstract out a `Planet` class
    to be used for each planet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的太阳系时，将有助于将`Planet`类抽象出来用于每个行星。
- en: Planets have a number of different attributes that define their unique characteristics
    in addition to their texture resource IDs. Planets have a distance from the Sun,
    size (radius), and an orbital speed. Planets all orbit around the Sun as their
    origin.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 行星有许多不同的属性，除了它们的纹理资源ID外，还定义了它们独特的特征。行星与太阳的距离、大小（半径）和轨道速度。行星都围绕太阳作为它们的原点进行轨道运行。
- en: The distance will be its distance from the Sun measured in millions of kilometers.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离将是其距离太阳的距离，以百万公里为单位进行测量。
- en: The radius will be the planet's size in kilometers (actually in millions of
    kilometers, to be consistent).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 半径将是行星的大小，以公里为单位（实际上是以百万公里为单位，以保持一致）。
- en: Rotation is the rate at which the planet rotates about its own axis (one of
    its days).
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转是行星绕其自身轴旋转的速率（其一天之一）。
- en: Orbit is the rate at which the planet rotates about the Sun (one of its years).
    We will assume a perfectly circular orbit.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨道是行星绕太阳运行的速率（其一年之一）。我们将假设轨道是完全圆形的。
- en: '`TexId` is the resource ID of the texture image for the planet.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TexId`是行星纹理图像的资源ID。'
- en: '`origin` is the center of its orbit. For planets, this will be the Sun''s transform.
    For a moon, this will be the moon''s planet.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`origin`是其轨道的中心。对于行星，这将是太阳的变换。对于卫星，这将是卫星的行星。'
- en: The Solar System is a really big thing. The distances and radii are measured
    in millions of kilometers. The planets are really far apart and relatively small
    compared to the size of their orbits. The rotation and orbit values are relative
    rates. You'll note that we'll normalize them to 10 seconds per Earth day.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 太阳系是一个非常庞大的东西。距离和半径以百万公里为单位进行测量。行星之间的距离非常遥远，相对于它们的轨道大小来说，它们的大小相对较小。旋转和轨道值是相对速率。您会注意到，我们将它们标准化为每地球日10秒。
- en: 'From these attributes, a planet maintains two transforms: one transform for
    the planet itself and another transform that describes its location in orbit.
    In this way, we can rotate each planet''s separate parent transform which, when
    the planet is at a local position whose magnitude is equal to the orbital radius,
    causes the planet to move in a circular pattern. Then we can rotate the planet
    itself using its transform.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些属性，行星保持两个变换：一个变换用于行星本身，另一个变换描述其在轨道上的位置。通过这种方式，我们可以旋转每个行星的单独父级变换，当行星处于局部位置时，其大小等于轨道半径，会导致行星以圆形运动。然后我们可以使用其变换旋转行星本身。
- en: For the Moon, we'll also use the `Planet` class (yeah, I know, maybe we should
    have named it `HeavenlyBody`?) but set its origin as the Earth. The moon does
    not rotate.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 对于月球，我们还将使用`Planet`类（是的，我知道，也许我们应该将其命名为`HeavenlyBody`？），但将其原点设置为地球。月球不会旋转。
- en: 'In your app (for example, `app/java/com/cardbookvr/solarsystem/`), create a
    Java class and name it `Planet`. Add variables for its attributes (`distance`,
    `radius`, `rotation`, `orbit`, `orbitTransform`, and `transform`), as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中（例如`app/java/com/cardbookvr/solarsystem/`），创建一个Java类并命名为`Planet`。添加其属性（`distance`，`radius`，`rotation`，`orbit`，`orbitTransform`和`transform`）的变量，如下所示：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Define a constructor that takes the planet''s attribute values, initializes
    the variables, and calculates the initial transforms:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个构造函数，该构造函数接受行星的属性值，初始化变量并计算初始变换：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The constructor generates an initial transform for the planet and adds a `Sphere`
    component with the given texture.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数为行星生成初始变换，并添加一个带有给定纹理的`Sphere`组件。
- en: 'On each new frame, we will update the `orbitTransform` rotation around the
    Sun (year) and the planet''s rotation about its own axis (day):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一帧新的画面中，我们将更新`orbitTransform`绕太阳的旋转（年）和行星绕自身轴的旋转（日）：
- en: '[PRE51]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also provide a couple of accessor methods for the `Planet` class''s
    transforms:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为`Planet`类的变换提供一些访问器方法：
- en: '[PRE52]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Now, let's take a look at the geometry of our Solar System.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看我们太阳系的几何形状。
- en: Formation of the Solar System
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 太阳系的形成
- en: This is our chance to throw some real science into our project. The following
    table shows the actual distance, size, rotation, and orbit values for each of
    the planets. (Most of this data came from [http://www.enchantedlearning.com/subjects/astronomy/planets/](http://www.enchantedlearning.com/subjects/astronomy/planets/).)
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将真正的科学投入到我们的项目中的机会。以下表格显示了每个行星的实际距离、大小、旋转和轨道值。（大部分数据来自[http://www.enchantedlearning.com/subjects/astronomy/planets/](http://www.enchantedlearning.com/subjects/astronomy/planets/)。）
- en: '| Planet | Distance from Sun (millions km) | Radius size (km) | Day length
    (Earth hours) | Year length (Earth years) |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 行星 | 距离太阳（百万公里） | 半径大小（公里） | 白天长度（地球小时） | 年长度（地球年） |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| Mercury | 57.9 | 2440 | 1408.8 | 0.24 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 水星 | 57.9 | 2440 | 1408.8 | 0.24 |'
- en: '| Venus | 108.2 | 6052 | 5832 | 0.615 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 金星 | 108.2 | 6052 | 5832 | 0.615 |'
- en: '| Earth | 147.1 | 6371 | 24 | 1.0 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 地球 | 147.1 | 6371 | 24 | 1.0 |'
- en: '| Earth''s Moon | 0.363 (from Earth) | 1737 | 0 |   |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 地球的月亮 | 0.363（来自地球） | 1737 | 0 |   |'
- en: '| Mars | 227.9 | 3390 | 24.6 | 2.379 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 火星 | 227.9 | 3390 | 24.6 | 2.379 |'
- en: '| Jupiter | 778.3 | 69911 | 9.84 | 11.862 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| 木星 | 778.3 | 69911 | 9.84 | 11.862 |'
- en: '| Saturn | 1427.0 | 58232 | 10.2 | 29.456 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 土星 | 1427.0 | 58232 | 10.2 | 29.456 |'
- en: '| Uranus | 2871.0 | 25362 | 17.9 | 84.07 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 天王星 | 2871.0 | 25362 | 17.9 | 84.07 |'
- en: '| Neptune | 4497 | 24622 | 19.1 | 164.81 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 海王星 | 4497 | 24622 | 19.1 | 164.81 |'
- en: '| Pluto (still counts) | 5913 | 1186 | 6.39 | 247.7 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 冥王星（仍然计数） | 5913 | 1186 | 6.39 | 247.7 |'
- en: 'We also have texture images for each of the planets. These files are included
    with the downloads for this book. They should be added to the `res/drawable` folder,
    named `mercury_tex.png`, `venus_tex.png`, and so on. The following table identifies
    the sources we have used and where you can find them as well:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还为每个行星准备了纹理图像。这些文件包含在本书的下载中。它们应该被添加到`res/drawable`文件夹中，命名为`mercury_tex.png`，`venus_tex.png`等等。以下表格标识了我们使用的来源以及您可以找到它们的位置： '
- en: '| Planet | Texture |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 行星 | 纹理 |'
- en: '| --- | --- |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Mercury | [http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg)
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 水星 | [http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/mercury/mercury/mercury_rgb_cyl_www.jpg)
    |'
- en: '| Venus | [http://csdrive.srru.ac.th/55122420119/texture/venus.jpg](http://csdrive.srru.ac.th/55122420119/texture/venus.jpg)
    |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 金星 | [http://csdrive.srru.ac.th/55122420119/texture/venus.jpg](http://csdrive.srru.ac.th/55122420119/texture/venus.jpg)
    |'
- en: '| Earth | [http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg)Night:
    [http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg)
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| 地球 | [http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_daymap.jpg)夜晚：[http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg](http://www.solarsystemscope.com/nexus/content/tc-earth_texture/tc-earth_nightmap.jpg)
    |'
- en: '| Earth''s Moon | [https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg](https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg)
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| 地球的月亮 | [https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg](https://farm1.staticflickr.com/120/263411684_ea405ffa8f_o_d.jpg)
    |'
- en: '| Mars | [http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg](http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg)
    |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 火星 | [http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg](http://lh5.ggpht.com/-2aLH6cYiaKs/TdOsBtnpRqI/AAAAAAAAAP4/bnMOdD9OMjk/s9000/mars%2Btexture.jpg)
    |'
- en: '| Jupiter | [http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg)
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| 木星 | [http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg](http://laps.noaa.gov/albers/sos/jupiter/jupiter/jupiter_rgb_cyl_www.jpg)
    |'
- en: '| Saturn | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg)
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| 土星 | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_saturn.jpg)
    |'
- en: '| Uranus | [http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg](http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg)
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| 天王星 | [http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg](http://www.astrosurf.com/nunes/render/maps/full/uranus.jpg)
    |'
- en: '| Neptune | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg)
    |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| 海王星 | [http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg](http://www.solarsystemscope.com/nexus/content/planet_textures/texture_neptune.jpg)
    |'
- en: '| Pluto | [http://www.shatters.net/celestia/files/pluto.jpg](http://www.shatters.net/celestia/files/pluto.jpg)
    |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 冥王星 | [http://www.shatters.net/celestia/files/pluto.jpg](http://www.shatters.net/celestia/files/pluto.jpg)
    |'
- en: '| Sun | [http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg](http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg)
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| 太阳 | [http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg](http://www.solarsystemscope.com/nexus/textures/texture_pack/assets/preview_sun.jpg)
    |'
- en: '| Milky Way | [http://www.geckzilla.com/apod/tycho_cyl_glow.png](http://www.geckzilla.com/apod/tycho_cyl_glow.png)
    (by Judy Schmidt, [http://geckzilla.com/](http://geckzilla.com/)) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| 银河系 | [http://www.geckzilla.com/apod/tycho_cyl_glow.png](http://www.geckzilla.com/apod/tycho_cyl_glow.png)（由Judy
    Schmidt，[http://geckzilla.com/](http://geckzilla.com/)） |'
- en: Setting up planets in MainActivity
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在MainActivity中设置行星
- en: We're going to set up all the planets in `MainActivity` using a `setupPlanets`
    method that will be called from `setup`. Let's go for it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`MainActivity`中设置所有行星，使用一个`setupPlanets`方法，该方法将从`setup`中调用。让我们开始吧。
- en: 'At the top of the class, declare a `planets` array:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的顶部，声明一个 `planets` 数组：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then, we declare a number of constants which we''ll explain in a moment:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们声明了一些常量，我们将在下面解释：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `setupPlanets` method uses our celestial data and builds new planets accordingly.
    First, let''s define the physical data, as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupPlanets` 方法使用我们的天体数据并相应地构建新的行星。首先，让我们定义物理数据，如下所示：'
- en: '[PRE55]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `distances` array has the distance of each planet from the Sun in millions
    of km. This is really huge, especially for the outer planets that are really far
    away and are not very visible relative to other planets. To make things more interesting,
    we'll fudge the distance of those planets (Jupiter through Pluto), so the values
    that we'll use are in the `fudged_distances` array.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`distances` 数组包含每个行星距离太阳的距离，单位为百万公里。这实际上非常巨大，尤其是对于那些非常遥远且相对于其他行星不太可见的外行星。为了使事情更有趣，我们将调整这些行星（从木星到冥王星）的距离，因此我们将使用的值在
    `fudged_distances` 数组中。'
- en: The `radii` array has the actual size of each planet in kms.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`radii` 数组包含每个行星的实际大小（以公里为单位）。'
- en: The `rotations` array has the day length, in Earth hours. Since Mercury and
    Venus spin really fast compared to the Earth, we'll artificially slow them down
    by arbitrary scale factors.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotations` 数组包含地球小时的长度。由于水星和金星的自转速度相对于地球非常快，我们将通过任意比例因子人为地减慢它们的速度。'
- en: The `orbits` array has the length of each planet's year in Earth years and the
    time it takes for one complete rotation around the Sun.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`orbits` 数组包含每个行星的年份长度和绕太阳一周所需的时间。'
- en: 'Now, let''s set up the texture IDs for each planet''s materials:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为每个行星的材质设置纹理 ID：
- en: '[PRE56]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now initialize the `planets` array, creating a new `Planet` object for each:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在初始化 `planets` 数组，为每个创建一个新的 `Planet` 对象：
- en: '[PRE57]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: While we fudged some of the planets' actual distances so that they'd be closer
    to the inner Solar System, we also multiply all the distances by a `DISTANCE_FACTOR`
    scalar, mostly to not blow up our float precision calculations. We scale all the
    planet sizes by a different `SCALE_FACTOR` variable to make them relatively larger
    than life (a factor of 0.0001 is actually a factor of 100 because radii are calculated
    in km while the distance is calculated in millions of km).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们对一些行星的实际距离进行了调整，使它们更接近内太阳系，但我们还将所有距离乘以 `DISTANCE_FACTOR` 标量，主要是为了不使我们的浮点精度计算失真。我们通过不同的
    `SCALE_FACTOR` 变量来缩放所有行星的大小，使它们相对于实际尺寸更大（0.0001实际上是100的因子，因为半径是以公里计算的，而距离是以百万公里计算的）。
- en: The rotation animation rate is the actual length of the day of the planet scaled
    by how fast we want to animate a day in VR. We default to 10 seconds per Earth
    day.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转动画速率是行星的实际日长度，乘以我们希望在 VR 中动画化一天的速度。我们默认为每个地球日10秒。
- en: Lastly, the planetary orbit animation has its own scale factor. We've sped it
    up about 2 X. You can also adjust the orbit rate of the distance fudge factors
    (for example, Pluto orbits the Sun once every 247 Earth years, but we've moved
    it a lot closer so it needs to slow down).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，行星轨道动画有自己的比例因子。我们加快了大约2倍。您还可以调整距离调整因子的轨道速率（例如，冥王星绕太阳运行一次需要247个地球年，但我们已经将其移动得更接近，因此它需要减速）。
- en: 'Then, we add the Earth''s moon. We''ve used some artistic license here as well,
    adjusting the distance and radius and speeding up its orbit rate to make it compelling
    to watch in VR:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了地球的月球。我们在这里也使用了一些艺术许可，调整了距离和半径，并加快了其轨道速率，使其在 VR 中观看更有吸引力。
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s take a look at one more method: `goToPlanet`. It''ll be convenient to
    position the `Camera` near a specific planet. Since the planets are located at
    data-driven positions and will be moving in orbit, it''s best to make the camera
    a child of the planet''s transform. This is one of the reasons why we separated
    out the orbiting transform from the planet''s transform. We don''t want the camera
    to spin around with the planet—you might get sick! Here''s the implementation:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看另一个方法：`goToPlanet`。将摄像机方便地定位在特定行星附近。由于行星位于数据驱动的位置并且将在轨道上移动，最好将摄像机设置为行星变换的子级。这是我们将轨道变换与行星变换分开的原因之一。我们不希望摄像机随着行星旋转而旋转——您可能会晕！这是实现方式：
- en: '[PRE59]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the scale and distance values we finally use in the code are derived
    from but not the actual celestial measurements. For a lovely VR experience of
    the Solar System with real educational value, check out Titans of Space ([http://www.titansofspacevr.com/](http://www.titansofspacevr.com/)).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们最终在代码中使用的比例和距离值是从而不是实际的天体测量中得出的。要体验真正有教育价值的太阳系 VR 体验，请查看《太空巨人》（[http://www.titansofspacevr.com/](http://www.titansofspacevr.com/)）。
- en: Camera's planet view
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摄像机的行星视图
- en: The `gotoPlanet` function is called with a planet index (for example, Earth
    is 2), so we can position the camera near the specified planet. The `Camera` component
    gets parented to the planet's `orbitTransform` variable as a way to obtain the
    planet's current orbit rotation. Then, it's positioned as the planet's distance
    from the Sun, and then offset a bit, relative to the planet's size.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`gotoPlanet` 函数被调用时带有一个行星索引（例如，地球是2），这样我们就可以将摄像机定位在指定行星附近。`Camera` 组件被作为行星的
    `orbitTransform` 变量的父级，以获取行星当前的轨道旋转。然后，它被定位为距离太阳的行星距离，然后相对于行星的大小进行偏移。'
- en: 'In `MainActivity` class''s setup method, we have already set up the Sun and
    the Earth. We''ll replace the Earth sphere with a call to a `setupPlanets` helper
    method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类的设置方法中，我们已经设置了太阳和地球。我们将用一个 `setupPlanets` 辅助方法替换地球球体：
- en: '[PRE60]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If you build and run the project now, you will see the Earth, the Sun, and maybe
    some of the planets. But not until they're moving in their orbits will they come
    to life.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在构建并运行项目，您将看到地球、太阳，可能还有一些行星。但直到它们在它们的轨道上运动时，它们才会活跃起来。
- en: Animating the heavenly bodies
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画天体
- en: 'Now that we have all the planets instantiated, we can animate their orbit and
    axis rotations. All it takes is updating their transforms in the `MainAcitvity`
    class''s `preDraw` method:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了所有行星，我们可以对它们的轨道和轴旋转进行动画处理。只需在 `MainAcitvity` 类的 `preDraw` 方法中更新它们的变换即可：
- en: '[PRE61]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Run! Oh, wow! I feel like a god. Well, not exactly, because it's dark outside.
    We need stars!
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 跑吧！哦，哇！我感觉自己像个神。嗯，不完全是，因为外面很黑。我们需要星星！
- en: A starry sky dome
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 星空天穹
- en: What if the Universe was just a giant ball and we're inside it? That's what
    we're going to imagine to implement a starry sky spherical background.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如果宇宙只是一个巨大的球，我们就在其中，那将是我们要想象的实现一个星空球形背景。
- en: In computer graphics, you can create backgrounds to make the scene look bigger
    than it really is. You can use a spherical texture, or skydome, as we will use
    here. (A common alternative in many game engines is a cuboid skybox, constructed
    from six internal faces of a cube.)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，您可以创建背景，使场景看起来比实际更大。您可以使用球形纹理或天穹，就像我们将在这里使用的一样。（许多游戏引擎中的常见替代品是由立方体的六个内部面构成的立方体天空盒。）
- en: Among the set of textures that we provided with this book is `milky_way_tex.png`.
    Drag a copy of this file into your `res/drawable/` directory, if it's not there
    already.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供的纹理集中，有`milky_way_tex.png`。如果`res/drawable/`目录中没有该文件，请将其拖入其中。
- en: 'Now, we can add the starry sky dome to our scene. Add the following code to
    `MainActivity.setup()`:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将星空天穹添加到我们的场景中。将以下代码添加到`MainActivity.setup()`中：
- en: '[PRE62]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This looks so much more celestial.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更加神圣。
- en: '![A starry sky dome](img/B05144_06_09.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![星空天穹](img/B05144_06_09.jpg)'
- en: You might be wondering what that 0.99 factor is all about. Different GPUs deal
    with floating point numbers differently. While some might render a vertex at the
    draw distance one way, others might exhibit render glitches when the geometry
    is "on the edge" due to a floating point precision. In this case, we just pull
    the skybox toward the camera by an arbitrarily small factor. It is especially
    important in VR that the skybox be as far away as possible, so that it is not
    drawn with parallax. The fact that the skybox is in the same exact place for the
    left and right eye is what tricks your brain into thinking that it's infinitely
    far away. You may find that you need to tweak this factor to avoid holes in the
    skybox.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道0.99因子是什么意思。不同的GPU对浮点数的处理方式不同。虽然有些可能以某种方式在绘制距离上渲染顶点，但其他可能会因为浮点精度而在几何图形“边缘”出现渲染故障。在这种情况下，我们只是通过一个任意小的因子将天空盒拉向相机。在VR中，天空盒尽可能远是非常重要的，这样它就不会因视差而被绘制。天空盒在左眼和右眼的确切位置相同，这就是让你的大脑误以为它是无限远的技巧。您可能会发现您需要调整这个因子以避免天空盒中的空洞。
- en: Fine tuning the Earth
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微调地球
- en: If you're a space geek, you might be thinking that there are a few things we
    could do to our Earth model. For one, we should add the night view texture. (Mars
    and the other planets don't need one because their cities shut off all their lights
    at night.) Also, the Earth is slightly tilted on its axis. We can fix that.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个太空迷，你可能会想到我们可以对我们的地球模型做一些事情。首先，我们应该添加夜景纹理。（火星和其他行星不需要，因为它们的城市在夜晚关闭了所有的灯光。）此外，地球在其轴上略微倾斜。我们可以修复这个问题。
- en: The night texture
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 夜晚纹理
- en: 'First, let''s add the night texture. To do this, let''s make an `Earth` Java
    class a subclass of a `Planet`. Right-click on your Java `solarsystem` folder,
    select **New** | **Java Class**, and name it `Earth`. Then, start defining it
    like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加夜景纹理。为此，让我们将`Earth` Java类作为`Planet`的子类。右键单击您的Java`solarsystem`文件夹，选择**新建**
    | **Java类**，并将其命名为`Earth`。然后，开始定义它如下：
- en: '[PRE63]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This requires that we add a new constructor to the `Planet` class, which omits
    `texId`, since the Earth constructor creates the new `Sphere` component, this
    time with two textures, `textId` and `nightTexId`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们向`Planet`类添加一个新的构造函数，省略`texId`，因为地球构造函数创建了新的`Sphere`组件，这次有两个纹理，`textId`和`nightTexId`。
- en: 'In `Planet.java`, add the following code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Planet.java`中，添加以下代码：
- en: '[PRE64]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, in `MainActivity`, let''s create an Earth separately from the other planets.
    In `setupPlanets`, modify the loop to handle this case:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`MainActivity`中，让我们单独创建一个地球，而不是其他行星。在`setupPlanets`中，修改循环以处理这种情况：
- en: '[PRE65]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Axis tilt and wobble
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 轴倾斜和摆动
- en: Among all its greatness, like all nature and mankind, the Earth is not perfect.
    In this case, we're talking about tilt and wobble. The Earth's axis of rotation
    is not exactly perpendicular to the orbital plane. It also suffers from a slight
    wobble as it rotates. We can show this in our virtual model.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的伟大之中，就像所有的自然和人类一样，地球并不完美。在这种情况下，我们谈论的是倾斜和摆动。地球的旋转轴并不完全垂直于轨道平面。它也在旋转时受到轻微的摆动。我们可以在我们的虚拟模型中展示这一点。
- en: 'Modify the `Earth` class constructor to read as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`Earth`类的构造函数如下：
- en: '[PRE66]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now, the Earth''s rotation on each frame is against this wobble transform,
    so give Earth its own `preDraw` method, as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，地球在每一帧的旋转都是针对这个摆动变换的，所以给地球自己的`preDraw`方法，如下所示：
- en: '[PRE67]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Changing the camera location
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改变相机位置
- en: The final feature of our Solar System is to make it more interactive. I mean
    all these planets look so cool, but you can't really see them from so far away.
    How about clicking on the Cardboard trigger to jump from planet to planet, nice
    and up close?
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们太阳系的最后一个特性是使它更具互动性。我的意思是所有这些行星看起来都很酷，但你实际上无法从那么远的地方看到它们。点击Cardboard触发器从行星跳到行星，近距离观察一下，怎么样？
- en: Fortunately, we already have a `goToPlanet` method that we used to set our initial
    view from the Earth. Because `MainActivity` extends `CardboardActivity`, we can
    use the Cardboard SDK's `onCardboardTrigger` method (refer to [https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger()](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger())).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们已经有一个`goToPlanet`方法，我们用它来设置我们从地球的初始视图。因为`MainActivity`扩展了`CardboardActivity`，我们可以使用Cardboard
    SDK的`onCardboardTrigger`方法（参考[https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger()](https://developers.google.com/cardboard/android/latest/reference/com/google/vrtoolkit/cardboard/CardboardActivity.html#onCardboardTrigger())）。
- en: 'Add the following code to `MainActivity`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`MainActivity`中：
- en: '[PRE68]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The app will start with the camera near the Earth (index 2). When the user presses
    the cardboard trigger (or touches the screen), it'll go to Mars (3). Then, Jupiter,
    and so on, and then cycle back to Mercury (0).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将从地球（索引2）附近的摄像机开始。当用户按下硬纸板触发器（或触摸屏幕）时，它将前往火星（3）。然后是木星，依此类推，然后循环回水星（0）。
- en: Possible enhancements
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可能的增强
- en: 'Can you think of other enhancements to this project? Here are a few you could
    consider and try to implement:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您能想到对这个项目的其他增强吗？以下是一些您可以考虑并尝试实现的增强：
- en: Add rings to Saturn. (A cheap way to implement might be a plane with transparency.)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为土星添加环。（一种廉价的实现方法可能是使用具有透明度的平面。）
- en: Improve `goToPlanet` so that your camera position animates between positions.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进`goToPlanet`，使摄像机位置在各个位置之间动画变化。
- en: Add controls to allow you to change the perspective or fly freely through space.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加控件，允许您改变透视或在太空中自由飞行。
- en: Add a top-down view option, for a "traditional" picture of the Solar System.
    (Be aware of float precision issues at scale.)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个俯视选项，以获得太阳系的“传统”图片。（注意在规模上的浮点精度问题。）
- en: Add moons to each of the other planets. (This can be implemented just like we
    did for the Earth's moon, with its mother planet as its origin.)
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个其他行星添加卫星。（这可以像我们为地球的月球所做的那样实现，以其母行星为原点。）
- en: Represent the asteroid belt between Mars and Jupiter.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示火星和木星之间的小行星带。
- en: Add tilt and wobble to the other planets. Did you know that Uranus spins on
    its side?
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其他行星添加倾斜和摆动。你知道天王星是侧着自转的吗？
- en: Add text labels to each planet that use the planet's transform but always face
    the camera. In lieu of 3D text objects, the labels could be prepared images.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个行星添加文本标签，使用行星的变换，但始终面向摄像机。在没有3D文本对象的情况下，标签可以是预先准备的图像。
- en: Add background music.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加背景音乐。
- en: Improve the positional accuracy in such a way that it accurately represents
    the relative positions of each planet on a given date.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以准确表示给定日期上每个行星的相对位置的方式改进位置精度。
- en: Updating the RenderBox library
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新RenderBox库
- en: With the Solar System project implemented and our code stabilized, you might
    realize that we've built some code that is not necessarily specific to this application,
    which can be reused in other projects, and ought to make its way back to the `RenderBox`
    library. That's what we'll do now.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 随着太阳系项目的实施和我们的代码稳定，您可能会意识到我们构建了一些不一定特定于此应用程序的代码，可以在其他项目中重用，并且应该回到`RenderBox`库。这就是我们现在要做的。
- en: 'We recommend you do this directly within Android Studio, selecting and copying
    from this project''s hierarchy view to the other''s. Perform the following steps:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议您直接在Android Studio中执行此操作，从此项目的层次结构视图中选择并复制到其他项目中。执行以下步骤：
- en: Move all the `.shader` files from the Solar System's `res/raw/` directory into
    the `res/raw/` directory of the `RenderBox` lib's `RenderBox` module. If you've
    been following along, there will be eight files for the vertex and fragment `.shader`
    files for `day_night`, `diffuse_lighting`, `solid_color_lighting`, and `unilt_tex`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将太阳系的`res/raw/`目录中的所有`.shader`文件移动到`RenderBox`库的`RenderBox`模块的`res/raw/`目录中。如果您一直在跟进，将会有八个文件，分别是`day_night`、`diffuse_lighting`、`solid_color_lighting`和`unilt_tex`的顶点和片段`.shader`文件。
- en: Move all the `Component` and `Material` `.java` files from the Solar System's
    `RenderBoxExt` module folder to the corresponding folders in `RenderBox` lib's
    `RenderBox` module. Remove all invalid references to `MainActivity` in the source
    code.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将太阳系的`RenderBoxExt`模块文件夹中的所有`Component`和`Material`的`.java`文件移动到`RenderBox`库的`RenderBox`模块中的相应文件夹中。删除源代码中对`MainActivity`的所有无效引用。
- en: In the Solar System project, we implemented a method named `loadTexture` in
    `MainActivity`. It rightfully belongs to the `RenderBox` library. Find the declaration
    for `loadTexture` in the Solar System's `MainActivity.java` file, and cut the
    code. Then, open the `RenderObject.java` file in `RenderBox` lib and paste the
    definition into the `RenderObject` class.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在太阳系项目中，我们在`MainActivity`中实现了一个名为`loadTexture`的方法。它应该属于`RenderBox`库。找到太阳系的`MainActivity.java`文件中`loadTexture`的声明，并剪切代码。然后，打开`RenderBox`库中的`RenderObject.java`文件，并将定义粘贴到`RenderObject`类中。
- en: In the `RenderBox` lib, replace (refactor) all the instances of `MainActivity.loadTexture`
    with `RenderObject.loadTexture`. These will be found in several `Material` Java
    files, where we load material textures.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RenderBox`库中，用`RenderObject.loadTexture`替换（重构）所有`MainActivity.loadTexture`的实例。这些将在几个`Material`
    Java文件中找到，我们在其中加载材质纹理。
- en: 'In `RenderBox.java`, the `reset()` method destroys the handles of any materials.
    Add the calls for the new materials that we just introduced:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RenderBox.java`中，`reset()`方法销毁任何材料的句柄。添加我们刚刚引入的新材料的调用：
- en: '`DayNightMaterial.destroy()`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DayNightMaterial.destroy()`'
- en: '`DiffuseLightingMaterial.destroy()`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DiffuseLightingMaterial.destroy()`'
- en: '`SolidColorLightingMaterial.destroy()`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SolidColorLightingMaterial.destroy()`'
- en: '`UnlitTexMaterial.destroy()`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UnlitTexMaterial.destroy()`'
- en: Resolve any package name mismatches, and fix any other compile-time errors,
    including removing any references to `solarsystem` throughout.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解决任何包名称不匹配的问题，并修复任何其他编译时错误，包括删除源代码中对`solarsystem`的任何引用。
- en: Now, you should be able to successfully rebuild the library (**Build** | **Make
    Module 'renderbox'**) to generate an updated `renderbox[-debug].aar` library file.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够成功重建库（**构建** | **生成模块'renderbox'**），以生成更新的`renderbox[-debug].aar`库文件。
- en: Lastly, the Solar System project can now use the new `.aar` library. Copy the
    `renderbox[-debug].aar` file from the `RenderBoxLib` project's `renderbox/build/output`
    folder into the SolarSystem `renderbox/` folder, replacing the older version of
    the same file with the newly built one. Build and run the Solar System project
    with this version of the library.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，太阳系项目现在可以使用新的`.aar`库。将`RenderBoxLib`项目的`renderbox/build/output`文件夹中的`renderbox[-debug].aar`文件复制到SolarSystem的`renderbox/`文件夹中，用新构建的文件替换同名文件。使用此版本的库构建和运行太阳系项目。
- en: Summary
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Congratulations! You received an "A" on your Solar System science project!
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你在太阳系科学项目中获得了“A”！
- en: In this chapter, we built a Solar System simulation that can be viewed in virtual
    reality using a Cardboard VR viewer and an Android phone. This project uses and
    expands the `RenderBox` library, as discussed in [Chapter 5](ch05.html "Chapter 5. RenderBox
    Engine"), *RenderBox Engine*.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们构建了一个太阳系模拟，可以在虚拟现实中使用Cardboard VR观看器和安卓手机查看。本项目使用并扩展了“RenderBox”库，如[第5章](ch05.html
    "第5章. RenderBox Engine") *RenderBox Engine*中所讨论的那样。
- en: To begin, we added a `Sphere` component to our repertoire. Initially, it was
    rendered using a solid color lighting material. Then, we defined a diffuse lighting
    material and rendered the sphere with an Earth image texture, resulting in a rendered
    globe. Next, we enhanced the material to accept two textures, adding an additional
    one to the back/"night" side of the sphere. And lastly, we created an unlit texture
    material, which is used for the Sun. Armed with actual sizes of the planets and
    distances from the Sun, we configured a Solar System scene with nine planets,
    the Earth's moon, and the Sun. We added a star field as a sky dome, and we animated
    the heavenly bodies for their appropriate rotation (day) and orbit (year). We
    also implemented some interaction, responding to Cardboard trigger events by moving
    the camera view from planet to planet.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们向我们的技能库中添加了一个“Sphere”组件。最初，它是使用纯色光照材质渲染的。然后，我们定义了一个漫反射光照材质，并使用地球图像纹理渲染了这个球体，结果呈现出了一个地球仪。接下来，我们增强了材质以接受两个纹理，为球体的背面/“夜晚”一侧添加了额外的纹理。最后，我们创建了一个未照明的纹理材质，用于太阳。凭借太阳系行星的实际大小和与太阳的距离，我们配置了一个太阳系场景，包括九大行星、地球的月亮和太阳。我们添加了一个星空作为天空圆顶，并为它们适当的自转（日）和公转（年）进行了动画处理。我们还实现了一些交互，通过对Cardboard触发事件的响应，将摄像机视图从行星移动到行星。
- en: In the next chapter, we'll get to use our sphere again, this time, to view your
    library of 360-degree photos.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将再次使用我们的球体，这次是为了查看您的360度照片库。
