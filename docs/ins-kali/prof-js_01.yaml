- en: '*Chapter 1*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*'
- en: JavaScript, HTML, and the DOM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript，HTML和DOM
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this chapter, you will be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将能够：
- en: Describe the HTML **Document Object Model** (**DOM**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述HTML文档对象模型（DOM）
- en: Use the Chrome DevTools source tab to explore the DOM of a web page
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Chrome DevTools源选项卡来探索网页的DOM
- en: Implement JavaScript to query and manipulate the DOM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现JavaScript来查询和操作DOM
- en: Build custom components using Shadow DOM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Shadow DOM构建自定义组件
- en: In this chapter, we will learn about the DOM and how to interact with and manipulate
    it using JavaScript. We will also learn how to build dynamic applications using
    reusable custom components.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习DOM以及如何使用JavaScript与其交互和操作。我们还将学习如何使用可重用的自定义组件构建动态应用程序。
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: HTML started as a markup language for static documents that was easy to use
    and could be written using any text editor. After JavaScript became a major player
    in the internet world, there was a need to expose the HTML documents to the JavaScript
    runtime. That's when the DOM, was created. The DOM is HTML mapped to a tree of
    objects that can be queried and manipulated using JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: HTML最初是用于静态文档的标记语言，易于使用，并且可以使用任何文本编辑器编写。在JavaScript成为互联网世界的主要角色之后，有必要将HTML文档暴露给JavaScript运行时。这就是创建DOM的时候。DOM是将HTML映射到可以使用JavaScript查询和操作的对象树。
- en: In this chapter, you'll learn what the DOM is and how to use JavaScript to interact
    with it. You'll learn how to find elements and data in a document, how to manipulate
    elements states, and how to modify their content. You'll also learn how to create
    DOM elements and append them to a page.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习DOM是什么以及如何使用JavaScript与其交互。您将学习如何在文档中查找元素和数据，如何操作元素状态以及如何修改其内容。您还将学习如何创建DOM元素并将其附加到页面上。
- en: After learning about the DOM and how to manipulate it, you'll build a dynamic
    application using some sample data. Lastly, you'll learn how to create custom
    HTML elements to build reusable components using Shadow DOM.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 了解DOM及其如何操作后，您将使用一些示例数据构建动态应用程序。最后，您将学习如何创建自定义HTML元素以构建可重用组件，使用Shadow DOM。
- en: HTML and the DOM
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML和DOM
- en: When a browser loads an HTML page, it creates a tree that represents that page.
    This tree is based on the DOM specification. It uses tags to determine where each
    node starts and ends.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器加载HTML页面时，它会创建代表该页面的树。这棵树基于DOM规范。它使用标记来确定每个节点的起始和结束位置。
- en: 'Consider the following piece of HTML code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下HTML代码片段：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The browser will create the following hierarchy of nodes:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将创建以下节点层次结构：
- en: '![Figure 1.1: A paragraph node contains a text node](Images/C14587_01_01.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：段落节点包含文本节点](Images/C14587_01_01.jpg)'
- en: 'Figure 1.1: A paragraph node contains a text node'
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.1：段落节点包含文本节点
- en: Everything becomes a node. Texts, elements, and comments, all the way up to
    the root of the tree. This tree is used to match styles from CSS and render the
    page. It's also transformed into an object and made available to the JavaScript
    runtime.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都变成了节点。文本，元素和注释，一直到树的根部。这棵树用于匹配CSS样式并渲染页面。它还被转换为对象，并提供给JavaScript运行时使用。
- en: 'But why is it called the DOM? Because HTML was originally designed to share
    documents and not to design the rich dynamic applications we have today. That
    means that every HTML DOM starts with a document element, to which all elements
    are attached. With that in mind, the previous illustration of the DOM tree actually
    becomes the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么它被称为DOM呢？因为HTML最初是设计用来共享文档，而不是设计我们今天拥有的丰富动态应用程序。这意味着每个HTML DOM都以一个文档元素开始，所有元素都附加到该元素上。考虑到这一点，前面的DOM树示意图实际上变成了以下内容：
- en: '![Figure 1.2: All DOM trees have a document element at the root](Images/C14587_01_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2：所有DOM树都有一个文档元素作为根](Images/C14587_01_02.jpg)'
- en: 'Figure 1.2: All DOM trees have a document element at the root'
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.2：所有DOM树都有一个文档元素作为根
- en: What does it mean when I say that the browser makes the DOM available to the
    JavaScript runtime? It means that if you write some JavaScript code in your HTML
    page, you can access that tree and do some pretty interesting things with it.
    For example, you can easily access the document root element and access all of
    the nodes on a page, which is what you're going to do in the next exercise.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我说浏览器使DOM可用于JavaScript运行时时，这意味着如果您在HTML页面中编写一些JavaScript代码，您可以访问该树并对其进行一些非常有趣的操作。例如，您可以轻松访问文档根元素并访问页面上的所有节点，这就是您将在下一个练习中要做的事情。
- en: 'Exercise 1: Iterating over Nodes in a Document'
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习1：在文档中迭代节点
- en: In this exercise, we'll write JavaScript code to query the DOM to find a button
    and add an event listener to it so that we can execute some code when the user
    clicks on it. When the event happens, we'll query for all paragraph elements,
    count and store their content, then show an alert at the end.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写JavaScript代码来查询DOM以查找按钮，并向其添加事件侦听器，以便在用户单击按钮时执行一些代码。事件发生时，我们将查询所有段落元素，计数并存储它们的内容，然后在最后显示一个警报。
- en: The code files for this exercise can be found at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise01](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise01).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码文件可以在[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise01](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise01)找到。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'Open the text editor of your preference and create a new file called `alert_paragraphs.html`
    containing the sample HTML from the previous section (which can be found on GitHub:
    [https://bit.ly/2maW0Sx](https://bit.ly/2maW0Sx)):'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的文本编辑器，并创建一个名为`alert_paragraphs.html`的新文件，其中包含上一节中的示例HTML（可以在GitHub上找到：[https://bit.ly/2maW0Sx](https://bit.ly/2maW0Sx)）：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'At the end of the `body` element, add a `script` tag such that the last few
    lines look like the following:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`body`元素的末尾，添加一个`script`标签，使最后几行看起来像下面这样：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inside the `script` tag, add an event listener for the click event of the button.
    To do that, you query the document object for all elements with the `button` tag,
    get the first one (there''s only one button on the page), then call `addEventListener`:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`script`标签内，为按钮的点击事件添加一个事件监听器。为此，你需要查询文档对象以找到所有带有`button`标签的元素，获取第一个（页面上只有一个按钮），然后调用`addEventListener`：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the event listener, query the document again to find all paragraph elements:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件监听器内部，再次查询文档以查找所有段落元素：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, create two variables inside the event listener to store how many
    paragraph elements you found and another to store their content:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，在事件监听器内创建两个变量，用于存储你找到的段落元素的数量和存储它们的内容：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Iterate over all paragraph elements, count them, and store their content:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代所有段落元素，计数它们，并存储它们的内容：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After the loop, show an alert that contains the number of paragraphs that were
    found and a list with all their content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环结束后，显示一个警报，其中包含找到的段落数和它们所有内容的列表：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see how the final code should look here: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise01/alert_paragraphs.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise01/alert_paragraphs.html).'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到最终的代码应该是什么样子的：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise01/alert_paragraphs.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise01/alert_paragraphs.html)。
- en: 'Opening the HTML document in the browser and clicking the button, you should
    see the following alert:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开HTML文档并点击按钮，你应该会看到以下警报：
- en: '![Figure 1.3: Alert box showing information about paragraphs on the page](Images/C14587_01_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3：显示页面上段落信息的警报框](Images/C14587_01_03.jpg)'
- en: 'Figure 1.3: Alert box showing information about paragraphs on the page'
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.3：显示页面上段落信息的警报框
- en: In this exercise, we wrote some JavaScript code that queried the DOM for specific
    elements. We collected the contents of the elements to show them in an alert box.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们编写了一些JavaScript代码，查询了特定元素的DOM。我们收集了元素的内容，以在警报框中显示它们。
- en: We're going to explore other ways to query the DOM and iterate over nodes in
    later sections of this chapter. But from this exercise, you can already see how
    powerful this is and start imagining the possibilities this opens up. For example,
    I frequently use this to count things or extract data that I need from web pages
    all around the internet.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后续部分探索其他查询DOM和迭代节点的方法。但是从这个练习中，你已经可以看到这是多么强大，并开始想象这开启了哪些可能性。例如，我经常使用它来计数或从互联网上的网页中提取我需要的数据。
- en: Developer Tools
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发者工具
- en: 'Now that we understand the relationship between the HTML source and the DOM,
    we can explore it in more detail using a very powerful tool: browser developer
    tools. In this book, we''re going to explore Google Chrome''s **DevTools**, but
    you can easily find equivalent tools in all other browsers.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了HTML源代码和DOM之间的关系，我们可以使用一个非常强大的工具来更详细地探索它：浏览器开发者工具。在本书中，我们将探索谷歌Chrome的**DevTools**，但你也可以在所有其他浏览器中轻松找到等效的工具。
- en: 'The first thing we''re going to do is explore the page we created in the previous
    section. When you open it in Google Chrome, you can find the developer tools by
    opening the **Chrome** menu. Then select **More Tools** and **Developer Tools**
    to open the developer tools:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是探索我们在上一节中创建的页面。当你在谷歌Chrome中打开它时，你可以通过打开**Chrome**菜单来找到开发者工具。然后选择**更多工具**和**开发者工具**来打开开发者工具：
- en: '![Figure 1.4: Accessing the developer tools in Google Chrome](Images/C14587_01_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：在谷歌Chrome中访问开发者工具](Images/C14587_01_04.jpg)'
- en: 'Figure 1.4: Accessing the developer tools in Google Chrome'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.4：在谷歌Chrome中访问开发者工具
- en: '**Developer Tools** will open a panel at the bottom of the page:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**开发者工具**将在页面底部打开一个面板：'
- en: '![Figure 1.5: Google Chrome DevTools panel when open](Images/C14587_01_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5：谷歌Chrome DevTools打开时的面板](Images/C14587_01_05.jpg)'
- en: 'Figure 1.5: Google Chrome DevTools panel when open'
  id: totrans-56
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.5：谷歌Chrome DevTools打开时的面板
- en: 'You can see at the top the various tabs that provide different perspectives
    on what''s happening on the loaded page. For this chapter, we''re going to be
    focusing mostly on three tabs:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在顶部看到提供加载页面上发生的不同视角的各种选项卡。在本章中，我们将主要关注三个选项卡：
- en: '**Elements** – Shows the DOM tree as the browser sees it. You can check how
    the browser is looking at your HTML, how CSS is being applied, and what selectors
    activated each style. You can also change the state of the nodes to simulate specific
    states such as `hover` or `visited`:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元素** – 显示浏览器看到的DOM树。你可以检查浏览器如何查看你的HTML，CSS如何被应用，以及哪些选择器激活了每个样式。你还可以改变节点的状态，模拟特定状态，比如`hover`或`visited`：'
- en: '![Figure 1.6: View of the Elements tab](Images/C14587_01_05.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6：元素选项卡的视图](Images/C14587_01_05.jpg)'
- en: 'Figure 1.6: View of the Elements tab'
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.6：元素选项卡的视图
- en: '**Console** – Gives access to a JavaScript runtime in the context of the page.
    The console can be used after loading the page to test short snippets of code.
    It can also be used to print important debugging information:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台** – 在页面的上下文中提供对JavaScript运行时的访问。在加载页面后，可以使用控制台来测试简短的代码片段。它还可以用于打印重要的调试信息：'
- en: '![Figure 1.7: View of the Console tab](Images/C14587_01_07.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7：控制台选项卡的视图](Images/C14587_01_07.jpg)'
- en: 'Figure 1.7: View of the Console tab'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.7：控制台选项卡的视图
- en: '**Sources** – Shows all the source code loaded for the current page. This view
    can be used to set breakpoints and start a debugging session:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源** – 显示当前页面加载的所有源代码。这个视图可以用来设置断点和开始调试会话：'
- en: '![](Images/C14587_01_08.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_01_08.jpg)'
- en: 'Figure 1.8: View of the Sources tab'
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.8：源选项卡的视图
- en: 'Select the **Elements** tab and you''ll see the DOM tree for the current document:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**元素**选项卡，你会看到当前文档的DOM树：
- en: '![Figure 1.9: DOM tree viewed inside the Elements tab in Chrome DevTools](Images/C14587_01_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9：在Chrome DevTools中查看的元素选项卡中的DOM树](Images/C14587_01_09.jpg)'
- en: 'Figure 1.9: DOM tree viewed inside the Elements tab in Chrome DevTools'
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.9：在Chrome DevTools中查看的元素选项卡中的DOM树
- en: 'Exercise 2: Manipulating the DOM from the Elements Tab'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习2：从元素选项卡操作DOM
- en: To get a sense of how powerful this tool is, we'll make some changes to the
    page from *Exercise 1, Iterating over Nodes in a Document*. We'll add a new paragraph
    to it and remove an existing one. Then, we'll use the **Styles** sidebar to change
    some styles of the element.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了感受到这个工具有多强大，我们将对*练习1：遍历文档中的节点*中的页面进行一些更改。我们将在其中添加一个新段落并删除一个现有的段落。然后，我们将使用**样式**侧边栏来更改元素的一些样式。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'To start, *right-click* the `body` element and select **Edit as HTML**:![Figure
    1.10: Editing the body element as HTML](Images/C14587_01_10.jpg)'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，*右键单击*`body`元素，然后选择**编辑为HTML**：![图1.10：编辑HTML主体元素](Images/C14587_01_10.jpg)
- en: 'Figure 1.10: Editing the body element as HTML'
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.10：编辑HTML主体元素
- en: 'That will change the node to a textbox that you can type in. Under the first
    paragraph, add another one with the text **Another paragraph**. It should look
    like the following:![Figure 1.11: Add a new paragraph in the body of the HTML](Images/C14587_01_11.jpg)'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将把节点更改为一个可以输入的文本框。在第一个段落下面，添加另一个文本为**另一个段落**的段落。它应该看起来像下面这样：![图1.11：在HTML主体中添加一个新段落](Images/C14587_01_11.jpg)
- en: 'Figure 1.11: Add a new paragraph in the body of the HTML'
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.11：在HTML主体中添加一个新段落
- en: Press *Ctrl + Enter* (or *Cmd + Enter* on a Mac) to save your changes.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl + Enter*（或Mac上的*Cmd + Enter*）保存您的更改。
- en: 'Click the **Click me!** button again and you should see that the new paragraph
    and its contents are now shown in the list:![Figure 1.12: Alert showing the content
    of all paragraphs, including the one added to the page](Images/C14587_01_12.jpg)'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击**点击我！**按钮，您会看到新段落及其内容现在显示在列表中：![图1.12：显示所有段落内容的警报，包括添加到页面中的段落](Images/C14587_01_12.jpg)
- en: 'Figure 1.12: Alert showing the content of all paragraphs, including the one
    added to the page'
  id: totrans-79
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.12：显示所有段落内容的警报，包括添加到页面中的段落
- en: 'You can also play around with the styles of the elements and see the changes
    reflected live on the page. Let''s change the background to black and the color
    to white for the first paragraph. First, we select it on the DOM tree by clicking
    on it; it will turn blue to indicate that it is selected:![Figure 1.13: DOM element
    selected on the Elements tab](Images/C14587_01_13.jpg)'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以玩弄元素的样式，并在页面上实时看到变化。让我们将第一个段落的背景更改为黑色，颜色更改为白色。首先，通过单击DOM树上的它来选择它；它会变成蓝色以表示已选择：![图1.13：在元素选项卡上选择DOM元素](Images/C14587_01_13.jpg)
- en: 'Figure 1.13: DOM element selected on the Elements tab'
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.13：在元素选项卡上选择DOM元素
- en: 'Now, on the right-hand side, you will see the **Styles** tab. It contains the
    styles already applied to the element and one empty placeholder for styles for
    the element. Clicking on it, you''ll get an input box. Type **background: black**,
    hit *Enter*, and then type **color: white**, and hit *Enter* again. You''ll see
    that the element changes as you type. In the end, it will look like the following:![Figure
    1.14: The styled paragraph on the left and the applied styles on the right](Images/C14587_01_14.jpg)'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在，在右侧，您会看到**样式**选项卡。它包含已应用于元素的样式和一个用于元素样式的空占位符。单击它，您将获得一个输入框。输入**background:
    black**，按下*Enter*，然后输入**color: white**，再次按下*Enter*。您会看到随着您的输入，元素会发生变化。最终，它将看起来像下面这样：![图1.14：左侧的样式化段落和右侧的应用样式](Images/C14587_01_14.jpg)'
- en: 'Figure 1.14: The styled paragraph on the left and the applied styles on the
    right'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.14：左侧的样式化段落和右侧的应用样式
- en: 'You can also create a new CSS rule to apply to the page by clicking on the
    **new rule button** at the top right of the **Styles** tab:![Figure 1.15: When
    you click to add a new rule, it will add a new rule based on the element selected
    – a paragraph, in this case](Images/C14587_01_15.jpg)'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以通过单击**样式**选项卡右上角的**新规则按钮**来创建一个应用于页面的新CSS规则：![图1.15：当您单击添加新规则时，它将基于所选元素（在本例中为段落）添加一个新规则](Images/C14587_01_15.jpg)
- en: 'Figure 1.15: When you click to add a new rule, it will add a new rule based
    on the element selected – a paragraph, in this case'
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.15：当您单击添加新规则时，它将基于所选元素（在本例中为段落）添加一个新规则
- en: 'Let''s add similar rules to affect all paragraphs by typing **background: green**,
    pressing *Enter*, entering **color: yellow**, and then press *Enter*. Now all
    paragraphs with the exception of the first will have a green background with yellow
    text. This is how the page should look now:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '让我们添加类似的规则来影响所有段落，输入**background: green**，按下*Enter*，输入**color: yellow**，然后按下*Enter*。现在除了第一个段落外，所有段落都将具有绿色背景和黄色文本。页面现在应该是这样的：'
- en: '![Figure 1.16: Adding rules to a paragraph](Images/C14587_01_16.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图1.16：向段落添加规则](Images/C14587_01_16.jpg)'
- en: 'Figure 1.16: Adding rules to a paragraph'
  id: totrans-88
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.16：向段落添加规则
- en: In this exercise, you changed the DOM from a page and saw the changes reflected
    live. You added elements to the page, changed the style of one element, and then
    added a new CSS rule to affect a wider group of elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您改变了页面的DOM，并实时看到了变化。您向页面添加了元素，更改了一个元素的样式，然后添加了一个新的CSS规则来影响更广泛的元素组。
- en: Manipulating the DOM in real-time like this is really useful for situations
    where you're trying to figure out a layout and test some code that iterates or
    manipulates DOM elements. In our case, we could easily test what would happen
    if we added a new paragraph element to the page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样实时操作DOM对于您试图弄清布局并测试一些迭代或操作DOM元素的代码的情况非常有用。在我们的情况下，我们可以轻松测试如果我们向页面添加一个新段落元素会发生什么。
- en: 'Exercise 3: Debugging Code from the Sources Tab'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习3：从源选项卡调试代码
- en: We mentioned previously that you can debug your code from the **Sources** tab.
    To do that, you just need to set a breakpoint and ensure that the code passes
    through that point. For this exercise, we'll explore the **Sources** tab while
    debugging our code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到过，您可以从**源**选项卡调试代码。要做到这一点，您只需要设置一个断点，并确保代码通过该点。在这个练习中，我们将在调试我们的代码时探索**源**选项卡。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'The first thing you''ll need to do is select the **Sources** tab in the **Developer
    Tools** panel. Then, open the one source file we have so far. You do that by clicking
    on it in the left-hand side panel:![Figure 1.17: Sources tab showing where to
    find your source files](Images/C14587_01_17.jpg)'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是在“开发者工具”面板中选择“源”选项卡。然后，打开我们目前拥有的一个源文件。您可以通过在左侧面板中点击它来实现这一点：![图1.17：源选项卡显示了如何找到您的源文件](Images/C14587_01_17.jpg)
- en: 'Figure 1.17: Sources tab showing where to find your source files'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.17：源选项卡显示了如何找到您的源文件
- en: 'To set a breakpoint in the source, you click on the gutter where the line numbers
    are, at the line you want to set a breakpoint at. For this exercise, we''ll set
    a breakpoint at the first line inside the event handler. A blue arrow-like symbol
    will appear on that line:![Figure 1.18: Breakpoints show as arrow-like markers
    on the gutter of the source file](Images/C14587_01_18.jpg)'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在源代码中设置断点，您需要点击行号所在的边栏，在您想要设置断点的行处点击。在这个练习中，我们将在事件处理程序内的第一行设置一个断点。一个蓝色的箭头符号将出现在那一行上：![图1.18：断点显示为源文件边栏上的箭头标记](Images/C14587_01_18.jpg)
- en: 'Figure 1.18: Breakpoints show as arrow-like markers on the gutter of the source
    file'
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.18：断点显示为源文件边栏上的箭头标记
- en: 'Click the **Click me!** button on the page to trigger the code execution. You''ll
    notice that two things happen – the browser window freezes and there''s a message
    indicating that the code is paused:![Figure 1.19: The browser pauses the execution
    when it hits a breakpoint](Images/C14587_01_19.jpg)'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击页面上的“点击我！”按钮来触发代码执行。您会注意到发生了两件事情 - 浏览器窗口冻结了，并且有一条消息表明代码已经暂停了：![图1.19：当浏览器遇到断点时，执行会暂停](Images/C14587_01_19.jpg)
- en: 'Figure 1.19: The browser pauses the execution when it hits a breakpoint'
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.19：当浏览器遇到断点时，执行会暂停
- en: 'Also, the line of code being executed gets highlighted in the **Sources** tab:![Figure
    1.20: Execution paused in the source code, highlighting the line that will be
    executed next](Images/C14587_01_20.jpg)'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，正在执行的代码行在“源”选项卡中得到了突出显示：![图1.20：源代码中的执行暂停，突出显示将要执行的下一行](Images/C14587_01_20.jpg)
- en: 'Figure 1.20: Execution paused in the source code, highlighting the line that
    will be executed next'
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.20：源代码中的执行暂停，突出显示将要执行的下一行
- en: 'In the side panel, notice the currently executing stack and everything that''s
    in the current scope, both globally and locally. This is the view of the right-hand
    panel, showing all the important information about the running code:![Figure 1.21:
    The right-hand side of the Sources tab shows the execution context and stack trace
    of the currently paused execution](Images/C14587_01_21.jpg)'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在侧边栏中，注意当前执行的堆栈和当前作用域中的所有内容，无论是全局还是局部。这是右侧面板的视图，显示了有关运行代码的所有重要信息：![图1.21：源选项卡右侧显示了当前暂停执行的执行上下文和堆栈跟踪](Images/C14587_01_21.jpg)
- en: 'Figure 1.21: The right-hand side of the Sources tab shows the execution context
    and stack trace of the currently paused execution'
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.21：源选项卡右侧显示了当前暂停执行的执行上下文和堆栈跟踪
- en: 'The bar at the top can be used to control code execution. This is what each
    button can do:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 顶部的工具栏可以用来控制代码执行。每个按钮的功能如下：
- en: '![](Images/C14587_01_21a.png) The **play** button ends the pause and continues
    execution normally.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: “播放”按钮结束暂停并正常继续执行。
- en: '![](Images/C14587_01_21b.png) The **step over** button executes the current
    line through completion and pauses again at the next line.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: “步过”按钮会执行当前行直到完成，并在下一行再次暂停。
- en: '![](Images/C14587_01_21c.png) The **step in** button will execute the current
    line and step in any function call, which means it will pause at the first line
    inside any function being called on that line.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“步入”按钮将执行当前行并步入任何函数调用，这意味着它将在被调用的函数内的第一行暂停。
- en: '![](Images/C14587_01_21d.png) The **step out** button will execute all of the
    steps required to exit the current function.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: “步出”按钮将执行所有必要的步骤以退出当前函数。
- en: '![](Images/C14587_01_21e.png) The **step button** will execute the next action.
    If it''s a function call, it will step in. If not, it will continue execution
    on the next line.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: “步”按钮将执行下一个操作。如果是函数调用，它将步入。如果不是，它将继续执行下一行。
- en: 'Press the **step over** the button until the execution gets to line 20:![Figure
    1.22: The highlighted line shows the execution paused for debugging](Images/C14587_01_22.jpg)'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下“步过”按钮，直到执行到第20行：![图1.22：突出显示的行显示了执行暂停以进行调试](Images/C14587_01_22.jpg)
- en: 'Figure 1.22: The highlighted line shows the execution paused for debugging'
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.22：突出显示的行显示了执行暂停以进行调试
- en: 'In the **Scope** panel on the right-hand side, you''ll see four scopes: two
    scopes for **Block**, then one **Local** and one **Global**. The scopes will vary
    depending on where you are in the code. In this case, the first **Block** scope
    includes only what''s inside the `for` loop. The second **Block** scope is the
    scope for the whole loop, including the variable defined in the `for` statement.
    **Local** is the function scope and **Global** is the browser scope. This is what
    you should see:![Figure 1.23: The Scope panel shows all the variables in the different
    scopes for the current execution context](Images/C14587_01_23.jpg)'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的“作用域”面板上，您会看到四个作用域：两个“块”作用域，然后一个“局部”作用域和一个“全局”作用域。作用域将根据您在代码中的位置而变化。在这种情况下，第一个“块”作用域仅包括`for`循环内的内容。第二个“块”作用域是整个循环的作用域，包括在`for`语句中定义的变量。“局部”是函数作用域，“全局”是浏览器作用域。这是您应该看到的：![图1.23：作用域面板显示了当前执行上下文中不同作用域中的所有变量](Images/C14587_01_23.jpg)
- en: 'Figure 1.23: The Scope panel shows all the variables in the different scopes
    for the current execution context'
  id: totrans-113
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.23：作用域面板显示了当前执行上下文中不同作用域中的所有变量
- en: 'Another interesting thing to notice at this point is that if you hover your
    mouse over a variable that is an HTML element in the current page, Chrome will
    highlight that element in the page for you:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时要注意的另一件有趣的事情是，如果你将鼠标悬停在当前页面中的HTML元素上，Chrome会为你突出显示该元素：
- en: '![Figure 1.24: Chrome highlights DOM elements when you hover over them in various
    places](Images/C14587_01_24.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图1.24：Chrome在不同位置悬停时突出显示DOM元素](Images/C14587_01_24.jpg)'
- en: 'Figure 1.24: Chrome highlights DOM elements when you hover over them in various
    places'
  id: totrans-116
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.24：Chrome在不同位置悬停时突出显示DOM元素
- en: Debugging code using the **Sources** tab is one of the most important things
    you'll do as a web developer. Understanding how the browser sees your code and
    what the values of variables in each line are is the easiest way to get to the
    root of problems in complex applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**源**选项卡调试代码是作为Web开发人员最重要的事情之一。了解浏览器如何看待你的代码，以及每行中变量的值是解决复杂应用程序中问题的最简单方法。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In-line values: As you step over the code in the **Sources** tab while debugging,
    you''ll notice that Chrome adds some light-orange highlights on the side of each
    line, showing the current values for variables that are being affected in that
    line.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 内联值：当你在**源**选项卡中调试时逐步执行代码时，你会注意到Chrome在每行的侧边添加了一些浅橙色的突出显示，显示了在该行中受影响的变量的当前值。
- en: The Console Tab
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制台选项卡
- en: Now that you know how to traverse and manipulate the DOM tree in the **Elements**
    tab, as well as how to explore and debug code in the **Sources** tab, let's explore
    the **Console** tab a bit.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何在**元素**选项卡中遍历和操作DOM树，以及如何在**源**选项卡中探索和调试代码，让我们来探索一下**控制台**选项卡。
- en: The **Console** tab can help you to debug issues and also explore and test code.
    To understand what it can do, we'll use the sample storefront in the `Lesson01/sample_002`
    folder in the code repository for this book.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制台**选项卡可以帮助你调试问题，也可以探索和测试代码。为了了解它能做什么，我们将使用本书代码库中`Lesson01/sample_002`文件夹中的示例商店。'
- en: 'Opening the storefront page, you can see that it''s a store for food products.
    This is how it looks:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 打开商店页面，你会看到这是一个食品产品的商店。它看起来是这样的：
- en: '![Figure 1.25: Screenshot of the storefront sample page](Images/C14587_01_25.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图1.25：商店示例页面的屏幕截图](Images/C14587_01_25.jpg)'
- en: 'Figure 1.25: Screenshot of the storefront sample page'
  id: totrans-125
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.25：商店示例页面的屏幕截图
- en: 'Underneath the hood, you can see that the DOM is very simple. It has a `section`
    element, which contains all the page content. Inside, it has a `div` tag with
    class items that represent the list of products and a `div` with a class item
    for each product. Looking in the **Elements** tab, this is what you would see:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，你可以看到DOM非常简单。它有一个`section`元素，其中包含所有的页面内容。里面有一个带有类项的`div`标签，代表产品列表，以及每个产品的一个带有类项的`div`。在**元素**选项卡中，你会看到这样的内容：
- en: '![Figure 1.26: The DOM tree for the storefront page is very simple](Images/C14587_01_26.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图1.26：商店页面的DOM树非常简单](Images/C14587_01_26.jpg)'
- en: 'Figure 1.26: The DOM tree for the storefront page is very simple'
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.26：商店页面的DOM树非常简单
- en: 'Back to the **Console** tab: you can run a few queries in this DOM to learn
    more about the elements and the content. Let''s write some code to list the prices
    for all of the products. First, we need to find where in the DOM tree the price
    is. We could look at the **Elements** tab, but for now, we''ll just stick to the
    **Console** tab to learn more. Running the following code in the **Console** tab
    would print an `HTMLCollection` object with 21 items in it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**控制台**选项卡：你可以在这个DOM中运行一些查询来了解更多关于元素和内容的信息。让我们写一些代码来列出所有产品的价格。首先，我们需要找到DOM树中的价格在哪里。我们可以查看**元素**选项卡，但现在，我们将只使用**控制台**选项卡来学习更多。在**控制台**选项卡中运行以下代码将打印一个包含21个项目的`HTMLCollection`对象：
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s unwrap the first one and see what''s inside:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开第一个，看看里面有什么：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you see that Chrome printed one DOM element, and if you hover over it,
    you''ll see it highlighted on the screen. You can also open the mini DOM tree
    that is shown in the **Console** tab to see what the element looks like, just
    like in the **Elements** tab:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你看到Chrome打印了一个DOM元素，如果你在上面悬停，你会看到它在屏幕上被突出显示。你也可以打开在**控制台**选项卡中显示的迷你DOM树，看看元素是什么样子的，就像在**元素**选项卡中一样：
- en: '![Figure 1.27: The Console tab printing elements from the DOM](Images/C14587_01_27.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图1.27：控制台选项印刷DOM中的元素](Images/C14587_01_27.jpg)'
- en: 'Figure 1.27: The Console tab printing elements from the DOM'
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.27：控制台选项印刷DOM中的元素
- en: You can see that the price is inside a `span` tag. To fetch the price, you can
    query an element just like you query the root document.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到价格在一个`span`标签内。要获取价格，你可以像查询根文档一样查询元素。
- en: 'Note: Autocomplete and previous commands'
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：自动完成和之前的命令
- en: In the **Console** tab, you can use autocomplete based on the current context
    by pressing *Tab* and quickly access previous commands by pressing the up/down
    arrow keys.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在**控制台**选项卡中，你可以通过按下*Tab*来使用基于当前上下文的自动完成，并通过按上/下箭头键快速访问之前的命令。
- en: 'Run the following code to fetch the price of the first product in the list:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码来获取列表中第一个产品的价格：
- en: '[PRE10]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The price of the product will show in the console as a string:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 产品的价格将显示在控制台中作为一个字符串：
- en: '![Figure 1.28: Querying for the DOM element that contains the price and fetching
    its content](Images/C14587_01_28.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图1.28：查询包含价格的DOM元素并获取其内容](Images/C14587_01_28.jpg)'
- en: 'Figure 1.28: Querying for the DOM element that contains the price and fetching
    its content'
  id: totrans-143
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.28：查询包含价格的DOM元素并获取其内容
- en: 'Activity 1: Extracting Data from a Page'
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动1：从页面中提取数据
- en: Suppose you're writing an application that needs the products and prices from
    Fresh Products Store. The store doesn't provide an API and its products and prices
    change about once a week – not frequent enough to justify automating the whole
    process, but also not slow enough that you could do it once manually. You also
    don't want to go through much trouble if they change the way their site looks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在编写一个需要来自Fresh Products Store的产品和价格的应用程序。商店没有提供API，其产品和价格大约每周变化一次-不够频繁以证明自动化整个过程是合理的，但也不够慢以至于您可以手动执行一次。如果他们改变了网站的外观方式，您也不想麻烦太多。
- en: You want to provide the data for your application in a way that is simple to
    generate and parse. You finally conclude that the simplest way to do that is to
    generate a CSV that you can feed to your application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望以一种简单生成和解析的方式为应用程序提供数据。最终，您得出结论，最简单的方法是生成一个CSV，然后将其提供给您的应用程序。
- en: In this activity, you'll write some JavaScript code that can be pasted inside
    the **Console** tab in the storefront page and use that to extract data from the
    DOM, printing it as a CSV that you can copy and paste for your application to
    consume.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您将编写一些JavaScript代码，可以将其粘贴到商店页面的**控制台**选项卡中，并使用它从DOM中提取数据，将其打印为CSV，以便您的应用程序消费。
- en: 'Note: Long code in the Console tab'
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：在控制台选项卡中的长代码
- en: When writing long snippets of code in the Chrome console, I recommend doing
    it inside a text editor and then pasting it when you want to test it. The console
    is not bad when editing the code, but it's easy to mess things up while trying
    to modify long codes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome控制台中编写长代码时，我建议在文本编辑器中进行，然后在想要测试时粘贴它。控制台在编辑代码时并不糟糕，但在尝试修改长代码时很容易搞砸事情。
- en: 'The following are the steps to perform:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Initialize a variable to store the entire content of the CSV.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个变量来存储CSV的整个内容。
- en: Query the DOM to find all the elements that represent each product.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询DOM以找到表示每个产品的所有元素。
- en: Iterate over each element found.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历找到的每个元素。
- en: From the `product` element, the query to find the price with the unit. Split
    the string using a slash.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`product`元素中，查询带有单位的价格。使用斜杠拆分字符串。
- en: Again, from the `product` element, query for the name.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，从`product`元素中查询名称。
- en: Append all information to the variable initialized in step 1, separating the
    values with commas. Don't forget to add newline characters to each line you append.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有信息附加到步骤1中初始化的变量中，用逗号分隔值。不要忘记为附加的每一行添加换行字符。
- en: Print the variable containing the accumulated data using the `console.log` function.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`console.log`函数打印包含累积数据的变量。
- en: Run the code in the **Console** tab with the storefront page open.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开商店页面的**控制台**选项卡中运行代码。
- en: 'You should see the following content in the **Console** tab:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在**控制台**选项卡中看到以下内容：
- en: '[PRE11]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 582.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第582页找到。
- en: In this activity, you were able to use the **Console** tab to query an existing
    page to extract data from it. Sometimes, extracting data from a page is very complicated
    and scraping can get very brittle. Depending on how frequently you'll need data
    from the page, it might be easier to run a script from the **Console** tab instead
    of writing a full-fledged application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您可以使用**控制台**选项卡查询现有页面并从中提取数据。有时，从页面中提取数据非常复杂，而且爬取可能会变得非常脆弱。根据您需要从页面获取数据的频率，可能更容易在**控制台**选项卡中运行脚本，而不是编写一个完整的应用程序。
- en: Nodes and Elements
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 节点和元素
- en: In previous sections, we learned about the DOM and how to interact with it.
    We saw that there's a global document object in the browser that represents the
    root of the tree. Then, we observed how to query it to fetch nodes and access
    their content.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了DOM以及如何与其交互。我们看到浏览器中有一个全局文档对象，表示树的根。然后，我们观察了如何查询它以获取节点并访问其内容。
- en: But while exploring the DOM in the previous sections, there were some object
    names, attributes, and functions that were accessed and called without introduction.
    In this section, we'll dig deeper into those and learn how to find the available
    properties and methods in each of those objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 但在前几节探索DOM时，有一些对象名称、属性和函数是在没有介绍的情况下访问和调用的。在本节中，我们将深入研究这些内容，并学习如何找到每个对象中可用的属性和方法。
- en: The best place to find documentation about what's going to be discussed in this
    section is the Mozilla Developer Network web documentation. You can find that
    at [developer.mozilla.org](http://developer.mozilla.org). They have detailed documentation
    about all the JavaScript and DOM APIs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本节将讨论的内容，最好的文档位置是Mozilla开发者网络网页文档。您可以在[developer.mozilla.org](http://developer.mozilla.org)找到。他们对所有JavaScript和DOM
    API都有详细的文档。
- en: 'The node is where everything starts. The node is an interface that represents
    in the DOM tree. As mentioned before, everything in the tree is a node. All nodes
    have a `nodeType` property, which describes what type of node it is. It is a read-only
    property with a value that is a number. The node interface has a constant for
    each of the possible values. The most frequently seen node types are the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一切的起点。节点是表示DOM树中的接口。如前所述，树中的一切都是节点。所有节点都有一个`nodeType`属性，用于描述节点的类型。它是一个只读属性，其值是一个数字。节点接口对于每个可能的值都有一个常量。最常见的节点类型如下：
- en: '`Node.ELEMENT_NODE` – HTML and SVG elements are of this type. In the storefront
    code, if you fetch the `description` element from the product, you''ll see its
    `nodeType` property is `1`, which means it''s an element:'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node.ELEMENT_NODE` - HTML和SVG元素属于这种类型。在商店代码中，如果您从产品中获取`description`元素，您将看到它的`nodeType`属性是`1`，这意味着它是一个元素：'
- en: '![Figure 1.29: The description element node type is Node.ELEMENT_NODE](Images/C14587_01_29.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图1.29：描述元素节点类型为Node.ELEMENT_NODE](Images/C14587_01_29.jpg)'
- en: 'Figure 1.29: The description element node type is Node.ELEMENT_NODE'
  id: totrans-171
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.29：描述元素节点类型为Node.ELEMENT_NODE
- en: 'This is the element we fetched from the DOM as viewed in the **Elements** tab:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从**元素**选项卡中获取的元素：
- en: '![Figure 1.30: The description node as seen in the Elements tab](Images/C14587_01_30.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图1.30：在元素选项卡中查看的描述节点](Images/C14587_01_30.jpg)'
- en: 'Figure 1.30: The description node as seen in the Elements tab'
  id: totrans-174
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.30：在元素选项卡中查看的描述节点
- en: '`Node.TEXT_NODE` – The text inside tags becomes text nodes. If you get the
    first child from the `description` node, you can see that it is of type `TEXT_NODE`:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node.TEXT_NODE` - 标签内的文本变成文本节点。如果您从`description`节点获取第一个子节点，您会发现它的类型是`TEXT_NODE`：'
- en: '![Figure 1.31: The text inside tags becomes text nodes](Images/C14587_01_31.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图1.31：标签内的文本变成文本节点](Images/C14587_01_31.jpg)'
- en: 'Figure 1.31: The text inside tags becomes text nodes'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.31：标签内的文本变成文本节点
- en: 'This is the node as viewed in the **Elements** tab:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在**元素**选项卡中查看的节点：
- en: '![Figure 1.32: The text node selected in the Elements tab](Images/C14587_01_32.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图1.32：在元素选项卡中选择的文本节点](Images/C14587_01_32.jpg)'
- en: 'Figure 1.32: The text node selected in the Elements tab'
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.32：在元素选项卡中选择的文本节点
- en: '`Node.DOCUMENT_NODE` – The root of every DOM tree is a `document` node:'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node.DOCUMENT_NODE` - 每个DOM树的根是一个`document`节点：'
- en: '![Figure 1.33: The root of the tree is always a document node](Images/C14587_01_33.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图1.33：树的根始终是文档节点](Images/C14587_01_33.jpg)'
- en: 'Figure 1.33: The root of the tree is always a document node'
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.33：树的根始终是文档节点
- en: 'One important thing to notice is that the `html` node is not the root. When
    a DOM is created, the `document` node is the root and it contains the `html` node.
    You can confirm that by fetching the first child of the `document` node:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的事情要注意的是`html`节点不是根节点。当创建DOM时，`document`节点是根节点，它包含`html`节点。您可以通过获取`document`节点的第一个子节点来确认：
- en: '![Figure 1.34: The html node is the first child of the document node](Images/C14587_01_34.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图1.34：html节点是文档节点的第一个子节点](Images/C14587_01_34.jpg)'
- en: 'Figure 1.34: The html node is the first child of the document node'
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.34：html节点是文档节点的第一个子节点
- en: '`nodeName` is another important property that nodes have. In `element` nodes,
    `nodeName` will give you the HTML tag for them. Other node types will return different
    things. The `document` node will always return `#document` (as seen in the preceding
    figure) and `Text` nodes will always return `#text`.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeName`是节点具有的另一个重要属性。在`element`节点中，`nodeName`将为您提供它们的HTML标签。其他节点类型将返回不同的内容。`document`节点将始终返回`#document`（如前图所示），而`Text`节点将始终返回`#text`。'
- en: For text-like nodes such as `TEXT_NODE`, `CDATA_SECTION_NODE`, and `COMMENT_NODE`,
    you can use `nodeValue` to get the text that they hold.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TEXT_NODE`、`CDATA_SECTION_NODE`和`COMMENT_NODE`等类似文本的节点，您可以使用`nodeValue`来获取它们所包含的文本。
- en: But the most interesting thing about nodes is that you can traverse them like
    a tree. They have child nodes and siblings. Let's practice using these properties
    a little bit in the following exercise.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 但节点最有趣的地方在于你可以像遍历树一样遍历它们。它们有子节点和兄弟节点。让我们在下面的练习中稍微练习一下这些属性。
- en: 'Exercise 4: Traversing the DOM Tree'
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习4：遍历DOM树
- en: In this exercise, we will traverse all the nodes in the sample page from *Figure
    1.1*. We'll use a recursive strategy to iterate over all nodes and print the whole
    tree.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将遍历*图1.1*中示例页面中的所有节点。我们将使用递归策略来迭代所有节点并打印整个树。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: The first step is to open your text editor and set it up to write some JavaScript
    code.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是打开文本编辑器并设置它以编写一些JavaScript代码。
- en: 'To use a recursive strategy, we''ll need a function that will be called for
    each node in the tree. This function will receive two arguments: the node to print
    and the depth that the node is at in the DOM tree. Here is how the declaration
    of the function looks:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用递归策略，我们需要一个函数，该函数将被调用以处理树中的每个节点。该函数将接收两个参数：要打印的节点和节点在DOM树中的深度。以下是函数声明的样子：
- en: '[PRE12]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first thing we''ll do inside the function is to start the message that
    will identify the opening of this node. For that, we''ll use `nodeName`, which
    for `HTMLElements` will give the tag, and for other types of nodes will give us
    a reasonable identifier:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数内部的第一件事是开始标识将要打开此节点的消息。为此，我们将使用`nodeName`，对于`HTMLElements`，它将给出标签，对于其他类型的节点，它将给出一个合理的标识符：
- en: '[PRE13]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If the node also has `nodeValue` associated with it, like `Text` and other
    text-line nodes, we''ll also append that to the message and then print it to the
    console:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果节点也有与之关联的`nodeValue`，比如`Text`和其他文本行节点，我们还将将其附加到消息中，然后将其打印到控制台：
- en: '[PRE14]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After that, we''ll fetch all the child nodes for the current node. For some
    node types, the `childNodes` property will return null, so we will add a default
    value of an empty array to make the code simpler:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们将获取当前节点的所有子节点。对于某些节点类型，`childNodes`属性将返回null，因此我们将添加一个空数组的默认值，以使代码更简单：
- en: '[PRE15]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we can iterate over the array using a `for` loop. For each child node we
    find, we''ll call the function again, initiating the recursive nature of the algorithm:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用`for`循环来遍历数组。对于我们找到的每个子节点，我们将再次调用该函数，启动算法的递归性质：
- en: '[PRE16]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The last thing we''ll do inside the function is print a closing message for
    nodes that have children:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数内部的最后一件事是打印具有子节点的节点的关闭消息：
- en: '[PRE17]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now we can initiate the recursion by calling the function and passing the document
    as the root node with level zero, just after the function declaration ends:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过调用该函数并将文档作为根节点传递，并在函数声明结束后立即将级别设置为零来启动递归：
- en: '[PRE18]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The final code should look like the following: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise04/open_close_tree_print.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise04/open_close_tree_print.js).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的代码应该如下所示：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise04/open_close_tree_print.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise04/open_close_tree_print.js)。
- en: 'Open the sample HTML in Chrome. This is where the file lives: [https://bit.ly/2maW0Sx](https://bit.ly/2mMje1K).'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Chrome中打开示例HTML。文件位于：[https://bit.ly/2maW0Sx](https://bit.ly/2mMje1K)。
- en: 'Open the **Developer Tools** panel, paste the JavaScript code in the **Console**
    tab, and run it. The following is the output you should see:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**开发者工具**面板，在**控制台**选项卡中粘贴JavaScript代码，然后运行。以下是您应该看到的输出：
- en: '![Figure 1.35: Traversing the DOM and printing all the nodes and its children
    recursively](Images/C14587_01_35.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: 图1.35：遍历DOM并递归打印所有节点及其子节点
- en: 'Figure 1.35: Traversing the DOM and printing all the nodes and its children
    recursively'
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.35：遍历DOM并递归打印所有节点及其子节点
- en: In this exercise, you learned how to use recursion to navigate the whole DOM
    tree, node by node. You also learned how to check the node for attributes since,
    when navigating the whole tree, you will see nodes that are not HTML, such as
    texts and comments.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您学会了如何使用递归来逐个节点地遍历整个DOM树。您还学会了如何检查节点的属性，因为在遍历整个树时，您会看到不是HTML的节点，比如文本和注释。
- en: 'One very interesting thing to notice is that the browser also preserves the
    whitespace you add to your HTML. The following screenshot compares the source
    code with the printed tree from the exercise:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 非常有趣的一点是浏览器还保留了您添加到HTML中的空格。以下截图将源代码与练习中打印的树进行了比较：
- en: '![Figure 1.36: Demonstration of how whitespaces also become nodes in your DOM
    tree](Images/C14587_01_36.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: 图1.36：演示空格也成为DOM树中的节点
- en: 'Figure 1.36: Demonstration of how whitespaces also become nodes in your DOM
    tree'
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.36：演示空格也成为DOM树中的节点
- en: 'You can see the mapping using color code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用颜色代码查看映射：
- en: Red marks the text node containing the text for the title.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色标记了包含标题文本的文本节点。
- en: Green marks the whole `title` element.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色标记了整个`title`元素。
- en: Blue boxes and arrows mark the whitespace before and after the `title` element.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色框和箭头标记了`title`元素之前和之后的空格。
- en: 'Note: Mind the gap'
  id: totrans-221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：注意间隔
- en: When dealing with DOM nodes, it's very important to keep in mind that not all
    nodes are HTML elements. Some might even be things that you didn't purposely put
    in your document, such as a line break.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理DOM节点时，非常重要的一点是要记住并非所有节点都是HTML元素。有些甚至可能是您没有故意放入文档中的东西，比如换行符。
- en: We've talked about nodes a lot. You can check the Mozilla Developer Network
    documentation for other node attributes and methods. But you will notice that
    the node interface focuses a lot on the relationship between nodes in the DOM
    tree, things such as siblings and children. They are very abstract. So, let's
    get more specific and explore the nodes of the `Element` type.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们谈论了很多关于节点的内容。您可以查看Mozilla开发者网络文档以了解其他节点属性和方法。但您会注意到节点接口主要关注DOM树中节点之间的关系，比如兄弟节点和子节点。它们非常抽象。因此，让我们更具体一些，探索`Element`类型的节点。
- en: All HTML elements are transformed into `HTMLElement` nodes, which inherit from
    `Element`, which inherits from a node. They inherit all attributes and methods
    of the parent type. That means that an element is a node and an `HTMLElement`
    instance is an element.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 所有HTML元素都被转换为`HTMLElement`节点，它们继承自`Element`，后者又继承自一个节点。它们继承了父类型的所有属性和方法。这意味着元素是一个节点，而`HTMLElement`实例是一个元素。
- en: 'Because `element` represents an element (a tag with all its attributes and
    inner tags), you can access its attributes. For example, in an `image` element,
    you can read the `src` attribute. The following is an example of getting the `src`
    attribute for the first `img` element of the storefront page:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`element`代表一个元素（带有其所有属性和内部标签的标签），所以您可以访问其属性。例如，在`image`元素中，您可以读取`src`属性。以下是获取商店页面第一个`img`元素的`src`属性的示例：
- en: '![Figure 1.37: Fetching the src attribute of the first image of a page](Images/C14587_01_37.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: 图1.37：获取页面第一个图像的src属性
- en: 'Figure 1.37: Fetching the src attribute of the first image of a page'
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.37：获取页面第一个图像的src属性
- en: 'Another useful attribute that HTML elements have is the `innerHTML` attribute.
    With it, you can get (and set) the HTML for an element. The following is an example
    of fetching the first `div` that has the `image` class and printing its `innerHTML`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: HTML元素还具有的另一个有用属性是`innerHTML`属性。使用它，您可以获取（和设置）元素的HTML。以下是获取具有`image`类的第一个`div`并打印其`innerHTML`的示例：
- en: '![Figure 1.38: innerHTML can be used to access the HTML inside an element](Images/C14587_01_38.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: 图1.38：innerHTML可用于访问元素内部的HTML
- en: 'Figure 1.38: innerHTML can be used to access the HTML inside an element'
  id: totrans-230
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.38：innerHTML可用于访问元素内部的HTML
- en: 'There''s also the `outerHTML` attribute, which will give the HTML for the element
    itself, including everything that''s inside it:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`outerHTML`属性，它将给出元素本身的HTML，包括其中的所有内容：
- en: '![Figure 1.39: outerHTML gives the HTML for the element and everything inside
    it](Images/C14587_01_39.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: 图1.39：outerHTML给出了元素及其内部的HTML
- en: 'Figure 1.39: outerHTML gives the HTML for the element and everything inside
    it'
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.39：outerHTML给出了元素及其内部的HTML
- en: 'And last but not least, there''s the `className` attribute, which gives you
    access to the classes applied to an element:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是`className`属性，它可以让您访问应用于元素的类：
- en: '![Figure 1.40: className gives access to the classes the element has](Images/C14587_01_40.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: 图1.40：className可以访问元素的类
- en: 'Figure 1.40: className gives access to the classes the element has'
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.40：className可以访问元素的类
- en: What's more important about these attributes is that they are read/write, which
    means you can use them to modify the DOM, adding classes and changing the content
    of an element. In the upcoming sections, we will use what we've looked at here
    to create dynamic pages that change based on user interaction.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些属性更重要的是它们是可读/可写的，这意味着您可以使用它们来修改DOM，添加类并更改元素的内容。在接下来的部分中，我们将使用这里所学到的内容来创建根据用户交互而变化的动态页面。
- en: Special Objects
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特殊对象
- en: So far, we've accessed the `document` object in many of our examples and exercises.
    But what exactly is it and what else can it do? A document is a global object
    that represents the page loaded in the browser. And as we have seen, it serves
    as an entry point to the elements in the DOM tree.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在许多示例和练习中都访问了`document`对象。但它到底是什么，还能做什么？文档是一个代表浏览器中加载的页面的全局对象。正如我们所见，它作为DOM树中元素的入口点。
- en: Another important role it has that we haven't discussed so far is the ability
    to create new nodes and elements in a page. These elements can then be attached
    to the tree in different positions to modify it after the page is already loaded.
    We're going to explore this ability in upcoming sections.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个我们到目前为止还没有讨论的重要作用，那就是在页面中创建新节点和元素的能力。这些元素可以附加到树的不同位置，以在页面加载后修改它。我们将在接下来的章节中探讨这种能力。
- en: 'Besides `document`, there''s another object that is part of the DOM specification,
    which is the `window` object. A `window` object is a global object that is also
    the bind target for all JavaScript code running in the browser that doesn''t have
    a bind target explicitly defined. That means that the variable is a pointer to
    the `window` object:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`document`，还有另一个对象是DOM规范的一部分，那就是`window`对象。`window`对象是一个全局对象，也是所有在浏览器中运行的JavaScript代码的绑定目标。这意味着该变量是指向`window`对象的指针：
- en: '![Figure 1.41: The global scope and default bind target in the browser is the
    window object](Images/C14587_01_41.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图1.41：浏览器中的全局范围和默认绑定目标是窗口对象](Images/C14587_01_41.jpg)'
- en: 'Figure 1.41: The global scope and default bind target in the browser is the
    window object'
  id: totrans-243
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.41：浏览器中的全局范围和默认绑定目标是窗口对象
- en: 'The `window` object contains everything you need to access from the browser:
    location, navigation history, other windows (popups), local storage, and much
    more. The `document` and `console` objects are also attributed to the `window`
    object. When you access the `document` object, you''re actually using the `window.document`
    object, but the binding is implicit, so you don''t need to write `window` all
    the time. And because the `window` is a global object, it means that it has to
    contain a reference to itself:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`window`对象包含您需要从浏览器访问的所有内容：位置、导航历史、其他窗口（弹出窗口）、本地存储等等。`document`和`console`对象也归属于`window`对象。当您访问`document`对象时，实际上是在使用`window.document`对象，但绑定是隐式的，因此您不需要一直写`window`。而且因为`window`是一个全局对象，这意味着它必须包含对自身的引用：'
- en: '![Figure 1.42: The window object contains a reference to itself](Images/C14587_01_42.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图1.42：窗口对象包含对自身的引用](Images/C14587_01_42.jpg)'
- en: 'Figure 1.42: The window object contains a reference to itself'
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.42：窗口对象包含对自身的引用
- en: Using JavaScript to Query the DOM
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JavaScript查询DOM
- en: We have been talking about querying the DOM through the `document` object. But
    all the methods we've used to query the DOM can also be called from elements in
    the DOM. The ones introduced in this section are also available from the elements
    in the DOM. We'll also see some that are only available in elements and not in
    the `document` object.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论通过`document`对象查询DOM。但是我们用来查询DOM的所有方法也可以从DOM中的元素中调用。本节介绍的方法也可以从DOM中的元素中调用。我们还将看到一些只能从元素中而不是`document`对象中使用的方法。
- en: Querying from elements is very handy since the scope of the query is limited
    to where it gets executed. As we saw in *Activity 1, Extracting Data from the
    DOM*, we can start with a query that finds all base elements – the product element,
    in that specific case, then we can execute a new query from the element that will
    only search for elements inside the element that query was executed from.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 从元素中查询非常方便，因为查询的范围仅限于执行查询的位置。正如我们在*Activity 1, Extracting Data from the DOM*中看到的，我们可以从一个查询开始，找到所有基本元素
    - 在这种特定情况下是产品元素，然后我们可以从执行查询的元素中执行一个新的查询，该查询将仅搜索在执行查询的元素内部的元素。
- en: The methods we used to query the DOM in the previous section include accessing
    elements from the DOM directly using the `childNodes` list, or using the `getElementsByTagName`
    and `getElementsByClassName` methods. Besides these methods, the DOM provides
    some other very powerful ways of querying for elements.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中用来查询DOM的方法包括直接从DOM中使用`childNodes`列表访问元素，或者使用`getElementsByTagName`和`getElementsByClassName`方法。除了这些方法，DOM还提供了一些其他非常强大的查询元素的方法。
- en: 'For starters, there is the `getElement*` methods family:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有`getElement*`方法系列：
- en: '`getElementsByTagName` – We''ve seen and used this one before. It fetches all
    elements for the specified tag.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementsByTagName` - 我们之前见过并使用过这个方法。它获取指定标签的所有元素。'
- en: '`getElementsByClassName` – This is a variant of `getElement` that returns all
    elements that have the specified class. Remember that an element can contain a
    list of classes by separating them with spaces. The following is a screenshot
    of code that ran in the storefront page, and you can see that selecting the `ui`
    class name will fetch elements that also have the `items`, `teal` (color), and
    `label` classes:'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementsByClassName` - 这是`getElement`的一个变体，它返回具有指定类的所有元素。请记住，一个元素可以通过用空格分隔它们来包含一个类的列表。以下是在商店页面中运行的代码的屏幕截图，您可以看到选择`ui`类名将获取还具有`items`、`teal`（颜色）和`label`类的元素：'
- en: '![](Images/C14587_01_43.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_01_43.jpg)'
- en: 'Figure 1.43: Fetching elements by class name usually returns elements that
    contain other classes'
  id: totrans-255
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.43：按类名获取元素通常返回包含其他类的元素
- en: '`getElementById` – Notice the singular in the name of this method. This method
    will fetch the only element that has the specified ID. That''s because IDs are
    expected to be unique on the page.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementById` - 注意该方法名称中的单数形式。该方法将获取具有指定ID的唯一元素。这是因为在页面上预期ID是唯一的。'
- en: 'The `getElement*` family of methods is very useful. But sometimes, specifying
    a class or tag name is not enough. This means you have to use a combination of
    actions that make your code very complicated: get all elements with this class,
    and then fetch the elements with this other tag, then fetch elements with this
    class, then pick the third, and so on.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElement*`方法族非常有用。但有时，指定类或标记名称是不够的。这意味着您必须使用一系列操作来使您的代码非常复杂：获取所有具有此类的元素，然后获取具有此其他标记的元素，然后获取具有此类的元素，然后选择第三个，依此类推。'
- en: For many years, jQuery was the only solution for that – until the `querySelector`
    and `querySelectorAll` methods were introduced. These two methods can be used
    to execute complex queries on the DOM tree. They work in exactly the same way.
    The only difference between the two is that `querySelector` will only return the
    first element that matches the query, while `querySelectorAll` will return a list
    that can be iterated over.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，jQuery是唯一的解决方案，直到引入了`querySelector`和`querySelectorAll`方法。这两种方法可以用来在DOM树上执行复杂的查询。它们的工作方式完全相同。两者之间唯一的区别是`querySelector`只会返回与查询匹配的第一个元素，而`querySelectorAll`会返回一个可以迭代的列表。
- en: The `querySelector*` methods use a CSS selector. You can use any CSS selector
    to query for elements. Let's explore that a bit more in the next exercise.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`querySelector*`方法使用CSS选择器。您可以使用任何CSS选择器来查询元素。让我们在下一个练习中更深入地探索一下。'
- en: 'Exercise 5: Querying the DOM Using querySelector'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习5：使用querySelector查询DOM
- en: In this exercise, we'll explore the various querying and node navigation techniques
    learned in previous sections. To do that, we'll use the storefront code as the
    base HTML to explore and we'll write JavaScript code to find the names of all
    the organic fruits available on the storefront page. To make things a bit harder,
    there's a blueberry muffin that is labeled as organic.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将探索在之前章节学到的各种查询和节点导航技术。为此，我们将使用商店代码作为基本HTML来探索，并编写JavaScript代码来查找商店页面上所有有机水果的名称。为了增加难度，有一个标记为有机的蓝莓松饼。
- en: 'Before we start, let''s take a look at the `product` element and its sub-elements.
    The following is the DOM tree for the `product` element as viewed from the `Elements`
    tab:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们看一下`product`元素及其子元素。以下是从`Elements`选项卡查看的`product`元素的DOM树：
- en: '![Figure 1.44: The product element and its sub-elements](Images/C14587_01_44.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图1.44：产品元素及其子元素](Images/C14587_01_44.jpg)'
- en: 'Figure 1.44: The product element and its sub-elements'
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.44：产品元素及其子元素
- en: 'You can see that the root element for each product is a `div` tag with a `class`
    item. The name and the tags are inside a sub-div with class content. The name
    of the product is inside an anchor with a class header. The tags are a group of
    `div` tags with three classes: `ui`, `label`, and `teal`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到每个产品的根元素是一个带有`class`项的`div`标记。名称和标记位于一个带有类content的子div中。产品的名称位于一个带有类header的锚点中。标记是一组带有三个类`ui`、`label`和`teal`的`div`标记。
- en: 'When dealing with a problem such as this, where you want to query and filter
    by a group of elements that are related to each other under one common parent,
    there are two common approaches:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理这样的问题时，您想要查询和过滤一组在一个共同父级下相关的元素时，有两种常见的方法：
- en: 'Start by querying for the root element, then filtering and finding the element
    you want. The following is a graphical representation of this approach:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先查询根元素，然后进行过滤和查找所需的元素。以下是这种方法的图形表示：
- en: '![Figure 1.45: The first approach involves starting from the root element](Images/C14587_01_45.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图1.45：第一种方法涉及从根元素开始](Images/C14587_01_45.jpg)'
- en: 'Figure 1.45: The first approach involves starting from the root element'
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.45：第一种方法涉及从根元素开始
- en: 'Start with a sub-element that matches one part of your filtering criteria,
    applying extra filtering if necessary, then navigate to the element you are looking
    for. The following is a graphical representation of this approach:'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从匹配过滤条件的子元素开始，如果需要，应用额外的过滤，然后导航到您要查找的元素。以下是这种方法的图形表示：
- en: '![Figure 1.46: The second approach involves starting from a filtering condition](Images/C14587_01_46.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图1.46：第二种方法涉及从过滤条件开始](Images/C14587_01_46.jpg)'
- en: 'Figure 1.46: The second approach involves starting from a filtering condition'
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.46：第二种方法涉及从过滤条件开始
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤完成练习：
- en: 'To solve the exercise using the first approach, we''ll need a function that
    checks whether a product contains a specified list of labels. The name of this
    function is going to be `the` and it receives two parameters – the product root
    element and a list of labels to check for:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用第一种方法解决练习，我们需要一个函数来检查产品是否包含指定的标签列表。这个函数的名称将是`the`，它接收两个参数-产品根元素和要检查的标签列表：
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Inside this function, we''ll use some array mapping and filtering to find the
    intersection between the labels specified in the parameters and the ones that
    the product being inspected has:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个函数中，我们将使用一些数组映射和过滤来找到参数中指定的标签和被检查产品的标签之间的交集：
- en: '[PRE20]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last thing in the function is to return the check that will tell us whether
    the product contains all the labels or not. The check tells us whether the size
    of the intersection is the same as the size of all labels to be checked if so
    we have a match:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数中的最后一件事是返回一个检查，告诉我们产品是否包含所有标签。检查告诉我们交集的大小是否与要检查的所有标签的大小相同，如果是，我们就有一个匹配：
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we can use the query methods to find the elements, add them to an array,
    filter, and map to what we want, then print to the console:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用查询方法来查找元素，将它们添加到数组中，进行过滤和映射到我们想要的内容，然后打印到控制台：
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To solve the problem using the second approach, we will need a function to
    find all the siblings of a specified element. Open your text editor and let''s
    start by declaring the function with an array to store all the siblings we find.
    Then, we''ll return the array:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用第二种方法解决问题，我们需要一个函数来查找指定元素的所有兄弟元素。打开您的文本编辑器，让我们从声明带有数组的函数开始存储我们找到的所有兄弟元素。然后，我们将返回数组：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we''ll iterate over all previous sibling elements using a `while` loop
    and the `previousElementSibling` attribute. As we iterate over the siblings, we''ll
    push them into the array:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`while`循环和`previousElementSibling`属性迭代所有先前的兄弟元素。在迭代兄弟元素时，我们将它们推入数组中：
- en: '[PRE24]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note: Mind the gap, again'
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意：再次注意间隙
- en: We use `previousElementSibling` instead of `previousNode` because that will
    exclude all text nodes and other nodes to avoid having to check `nodeType` for
    each one.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`previousElementSibling`而不是`previousNode`，因为这将排除所有文本节点和其他节点，以避免不得不为每个节点检查`nodeType`。
- en: 'We do the same for all the siblings coming after the specified element:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于指定元素之后的所有兄弟元素，我们做同样的操作：
- en: '[PRE25]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have our `getAllSiblings` function, we can start looking for the
    products. We can use the `querySelectorAll` function, and some array mapping and
    filtering to find and print the data that we want:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`getAllSiblings`函数，我们可以开始查找产品。我们可以使用`querySelectorAll`函数，以及一些数组映射和过滤来找到并打印我们想要的数据：
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Executing the code in the **Console** tab in **Developer Tools**, you''ll see
    the following output:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**开发者工具**的**控制台**选项卡中执行代码，您将看到以下输出：
- en: '![Figure 1.47: Output of the code from the exercise. Prints the names of all
    organic fruits.](Images/C14587_01_47.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图1.47：练习中代码的输出。打印所有有机水果的名称。](Images/C14587_01_47.jpg)'
- en: 'Figure 1.47: Output of the code from the exercise. Prints the names of all
    organic fruits.'
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.47：练习中代码的输出。打印所有有机水果的名称。
- en: Note
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code for this exercise can be found on GitHub. This is the path for the
    file that contains the code for the first approach: [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/first_approach.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/first_approach.js).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码可以在GitHub上找到。包含第一种方法代码的文件路径是：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/first_approach.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/first_approach.js)。
- en: 'The path for the file that contains the code for the second approach is this:
    [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/second_approach.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/second_approach.js).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 包含第二种方法代码的文件路径是：[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/second_approach.js](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise05/second_approach.js)。
- en: In this exercise, we used two different techniques to fetch data from a page.
    We used many querying and node navigation methods and attributes to find elements
    and move around the DOM tree.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用了两种不同的技术从页面中获取数据。我们使用了许多查询和节点导航方法和属性来查找元素并在DOM树中移动。
- en: These techniques are essential to know when building modern web applications.
    Navigating the DOM and fetching data are the most common tasks in this type of
    application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建现代Web应用程序时，了解这些技术是至关重要的。在这种类型的应用程序中，导航DOM和获取数据是最常见的任务。
- en: Manipulating the DOM
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作DOM
- en: Now that we know what the DOM is and how to query for elements and navigate
    around it, it's time to learn how to change it using JavaScript. In this section,
    we're going to rewrite the storefront to be more interactive by loading the list
    of products and creating the page elements using JavaScript.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了DOM是什么，以及如何查询元素和在其周围导航，是时候学习如何使用JavaScript来更改它了。在本节中，我们将重写商店前端，通过使用JavaScript加载产品列表并创建页面元素，使其更具交互性。
- en: The sample code for this section can be found on GitHub at [https://bit.ly/2mMje1K](https://bit.ly/2mMje1K).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的示例代码可以在GitHub上找到：[https://bit.ly/2mMje1K](https://bit.ly/2mMje1K)。
- en: 'The first thing we need to know when creating dynamic applications using JavaScript
    is how to create new DOM elements and append them to the tree. Since the DOM specification
    is all based on interfaces, there''s no concrete class to instantiate. When you
    want to create DOM elements, you need to use the `document` object. The `document`
    object has a method called `createElement`, which receives a tag name as a string.
    The following is an example of code that creates a `div` element:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用JavaScript创建动态应用程序时，我们需要知道的第一件事是如何创建新的DOM元素并将它们附加到树中。由于DOM规范完全基于接口，没有具体的类可实例化。当您想要创建DOM元素时，需要使用`document`对象。`document`对象有一个名为`createElement`的方法，它接收一个标签名称作为字符串。以下是创建`div`元素的示例代码：
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `product` item element has an `item` class. To add that class to it, we
    can just set the `className` attribute, as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`product`项元素具有`item`类。要将该类添加到它，我们只需设置`className`属性，如下所示：'
- en: '[PRE28]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'And now we can attach the element to where it needs to go. But first, we need
    to find where it needs to go. The HTML for this sample code can be found on GitHub
    at [https://bit.ly/2nKucVo](https://bit.ly/2nKucVo). You can see that it has an
    empty `div` element where the product items will be added:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将元素附加到需要去的地方。但首先，我们需要找到它需要去的地方。此示例代码的HTML可以在GitHub上找到[https://bit.ly/2nKucVo](https://bit.ly/2nKucVo)。您可以看到它有一个空的`div`元素，产品项将被添加到其中：
- en: '[PRE29]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can use `querySelector` to find that element and then call the `appendChild`
    method on it, which is a method that every node has, and pass the element node
    we just created to it so that it gets added to the DOM tree:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`querySelector`来找到该元素，然后在其上调用`appendChild`方法，这是每个节点都有的方法，并将刚刚创建的元素节点传递给它，以便将其添加到DOM树中：
- en: '[PRE30]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, `createProductItem` is the function that receives a product and creates
    the DOM element for it using the `createElement` function mentioned previously.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`createProductItem`是一个函数，它接收一个产品并使用先前提到的`createElement`函数为其创建DOM元素。
- en: 'Creating one DOM element is not very useful. For the dynamic storefront example,
    we have an array of objects with all the data we need to build the page. For each
    one of them, we need to create all the DOM elements and glue them together in
    the right place and order. But first, let''s take a look at how the data looks.
    The following shows how each `product` object looks:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个DOM元素并没有太大的用处。对于动态商店示例，我们有一个包含我们构建页面所需的所有数据的对象数组。对于每一个对象，我们需要创建所有的DOM元素，并将它们粘合在正确的位置和顺序上。但首先，让我们来看看数据是什么样子的。以下显示了每个`product`对象的外观：
- en: '[PRE31]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And the following is how the DOM for the same product looks in the static storefront
    code we used in previous sections:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们在之前章节中使用的静态商店代码中相同产品的DOM看起来的方式：
- en: '![Figure 1.48: The DOM tree section for a product](Images/C14587_01_48.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![图1.48：产品的DOM树部分](Images/C14587_01_48.jpg)'
- en: 'Figure 1.48: The DOM tree section for a product'
  id: totrans-316
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.48：产品的DOM树部分
- en: You can see that there are a lot of nested elements that need to be created
    to get to the desired final DOM tree. So, let's take a look at a few techniques
    that are very helpful when building complex applications using JavaScript.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到有许多嵌套的元素需要创建才能得到所需的最终DOM树。因此，让我们看看在使用JavaScript构建复杂应用程序时非常有用的一些技术。
- en: 'Let''s get started by taking a look at `createProductItem` in the sample code:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始看一下示例代码中的`createProductItem`：
- en: '[PRE32]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We start this method by creating the root element for the product tree, which
    is a `div` element. From the preceding screenshot, you see that this `div` needs
    an `item` class and that's what is happening on the next line after the element
    gets created, as described at the beginning of this section.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建产品树的根元素开始这个方法，这是一个`div`元素。从前面的截图中，您可以看到这个`div`需要一个`item`类，这就是在元素创建后的下一行发生的事情，就像本节开头描述的那样。
- en: 'After the element is ready, it''s time to start adding its children to it.
    Instead of doing everything in the same method, we create other functions that
    are responsible for creating each child and call them directly, appending the
    result of each function to the root element:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 元素准备好后，就可以开始向其添加子元素了。我们不是在同一个方法中完成所有操作，而是创建其他负责创建每个子元素的函数，并直接调用它们，将每个函数的结果附加到根元素：
- en: '[PRE33]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This technique is useful because it isolates the logic for each child in its
    own place.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术很有用，因为它将每个子元素的逻辑隔离在自己的位置上。
- en: 'Now let''s take a look at the `createProductImage` function. From the previous
    sample code, you can see that the function receives the path for the `product`
    image. This is the code for the function:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下`createProductImage`函数。从之前的示例代码中，您可以看到该函数接收`product`图像的路径。这是该函数的代码：
- en: '[PRE34]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The function is divided into two major parts:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数分为两个主要部分：
- en: It creates the container element for the image. From the DOM screenshot, you
    can see that the `img` element is inside a `div` with an `image` class.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建图像的容器元素。从DOM截图中，您可以看到`img`元素位于一个带有`image`类的`div`内。
- en: It creates the `img` element, sets the `src` attribute, and then appends it
    to the `container` element.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它创建`img`元素，设置`src`属性，然后将其附加到`container`元素。
- en: This style of code is simple, readable, and easy to understand. But that's because
    the HTML that needs to be generated is quite short. It's one `img` tag inside
    a `div` tag.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码风格简单、可读且易于理解。但这是因为需要生成的HTML相当简短。它只是一个`div`标签中的一个`img`标签。
- en: Sometimes, though, the tree becomes pretty complex and using this strategy makes
    the code almost unreadable. So, let's take a look at another strategy. The other
    child element appended to the product root is the `content` element. That is a
    `div` tag that has many children, including some nested ones.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，有时树变得非常复杂，使用这种策略使得代码几乎无法阅读。因此，让我们看看另一种策略。附加到产品根元素的另一个子元素是`content`元素。这是一个具有许多子元素的`div`标签，包括一些嵌套的子元素。
- en: 'We could have approached it the same way as the `createProductImage` function.
    But the method would have to do the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像`createProductImage`函数一样处理它。但是该方法需要执行以下操作：
- en: Create a `container` element and add a class to it.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`container`元素并为其添加一个类。
- en: Create the anchor element that stores the product name and append it to the
    container.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含产品名称的锚元素并将其附加到容器。
- en: Create the container for the price and append it to the root container.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建价格的容器并将其附加到根容器。
- en: Create the `span` element with the price and append it to the element created
    in the previous step.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建带有价格的`span`元素并将其附加到上一步中创建的元素。
- en: Create the element that contains the description and append it to the container.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建包含描述的元素并将其附加到容器。
- en: Create a `container` element for the `tag` element and append it to the root
    container.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`tag`元素创建`container`元素并将其附加到根容器。
- en: For each tag, create the `tag` element and append it to the container from the
    previous step.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个标签，创建`tag`元素并将其附加到上一步中的容器。
- en: 'It sounds like a long list of steps, doesn''t it? Instead of trying to write
    all that code, we can use a template string to generate the HTML and then set
    `innerHTML` for the `container` element. So, the steps would, instead, look like
    the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一长串步骤，不是吗？我们可以使用模板字符串来生成HTML，然后为容器元素设置`innerHTML`，而不是试图编写所有那些代码。因此，步骤看起来会像下面这样：
- en: Create the `container` element and add a class to it.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`container`元素并为其添加一个类。
- en: Create the HTML for the inner content using a string template.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用字符串模板创建内部内容的HTML。
- en: Set `innerHTML` on the `container` element.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`container`元素上设置`innerHTML`。
- en: That sounds much simpler than the previous method. And, as we'll see, it's going
    to be much more readable too. Let's take a look at the code.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来比以前的方法简单得多。而且，正如我们将看到的那样，它也会更加可读。让我们来看看代码。
- en: 'As stated before, the first step is to create the root container and add the
    class for it:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，第一步是创建根容器并为其添加类：
- en: '[PRE35]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we start by generating the HTML for the `tag` elements. For that, we
    have a function that receives the tag as a string and returns an HTML element
    for it. We use that to map all tags to elements using the `map` function on the
    `tags` array. Then, we map the element to HTML by using the `outerHTML` attribute
    from it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们开始生成`tag`元素的HTML。为此，我们有一个函数，它接收标签作为字符串并返回其HTML元素。我们使用它将所有标签映射到使用`tags`数组上的`map`函数的元素。然后，我们通过使用其`outerHTML`属性将元素映射到HTML：
- en: '[PRE36]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With the `container` element created and the HTML for the tags ready, we can
    set the `innerHTML` attribute of the `content` element using a template string
    and return it:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`container`元素创建和标签的HTML准备好后，我们可以使用模板字符串设置`content`元素的`innerHTML`属性并返回它：
- en: '[PRE37]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code is much shorter and easier to reason about compared to the many steps
    that generating HTML elements and appending them would require. When writing your
    dynamic applications, it is up to you to decide what's best in each case. In this
    case, the trade-offs are basically readability and conciseness. But for others,
    trade-offs can also be requirements to cache elements to add event listeners or
    to hide/show them based on some filter, for example.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 与生成HTML元素并附加它们所需的许多步骤相比，这段代码要简短得多，更容易理解。在编写动态应用程序时，您可以决定在每种情况下哪种方式最好。在这种情况下，权衡基本上是可读性和简洁性。但对于其他情况，权衡也可以是根据某些过滤器要求缓存元素以添加事件侦听器或隐藏/显示它们。
- en: 'Exercise 6: Filtering and Searching Products'
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习6：过滤和搜索产品
- en: 'In this exercise, we''ll add two features to our storefront application to
    help our customers to find products faster. First, we''ll start by making labels
    clickable, which will filter the list of products by the selected label. Then,
    we''ll add a search box at the top, for users to query by text in the name or
    description. This is how the page will look:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将为我们的商店应用程序添加两个功能，以帮助我们的客户更快地找到产品。首先，我们将使标签可点击，这将通过所选标签过滤产品列表。然后，我们将在顶部添加一个搜索框，供用户按名称或描述查询。页面将如下所示：
- en: '![Figure 1.49: New storefront with a search bar at the top](Images/C14587_01_49.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图1.49：顶部带有搜索栏的新商店前端](Images/C14587_01_49.jpg)'
- en: 'Figure 1.49: New storefront with a search bar at the top'
  id: totrans-354
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.49：顶部带有搜索栏的新商店前端
- en: 'In this new storefront, users can click on tags to filter products that have
    the same tag. When they do that, the tags being used to filter the list will show
    at the top, in orange. The user can click on the label in the search bar to remove
    the filter. This is how it looks:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新的商店前端，用户可以点击标签来过滤具有相同标签的产品。当他们这样做时，用于过滤列表的标签将显示在顶部，呈橙色。用户可以点击搜索栏中的标签以删除过滤器。页面如下所示：
- en: '![Figure 1.50: How the tag filtering at the top works](Images/C14587_01_50.jpg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![图1.50：顶部标签过滤的工作原理](Images/C14587_01_50.jpg)'
- en: 'Figure 1.50: How the tag filtering at the top works'
  id: totrans-357
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.50：顶部标签过滤的工作原理
- en: Users can also use the search box on the right-hand side to search for products
    by name or description. The list will be filtered as they type.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以使用右侧的搜索框按名称或描述搜索产品。随着他们的输入，列表将被过滤。
- en: The code for this exercise can be found on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise06](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise06).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习的代码可以在GitHub上找到：[https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise06](https://github.com/TrainingByPackt/Professional-JavaScript/tree/master/Lesson01/Exercise06)。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'The first thing we''ll do is write the base HTML code where all the other elements
    will be added later using JavaScript. This HTML now contains a base `div` container,
    where all the content will be. The content inside it is then divided into two
    parts: a section with the header, which contains the title and the search bar,
    and a `div`, which will contain all the product items. Create a file called `dynamic_storefront.html`
    and add the following code in it:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先编写基本的HTML代码，稍后将使用JavaScript添加所有其他元素。此HTML现在包含一个基本的`div`容器，其中将包含所有内容。其中的内容分为两部分：一个包含标题的部分，其中包含标题和搜索栏，以及一个`div`，其中将包含所有产品项目。创建一个名为`dynamic_storefront.html`的文件，并在其中添加以下代码：
- en: '[PRE38]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This HTML uses the `products.js` and `create_elements.js` scripts, which are
    the same as the sample code used in this section. It also uses the CSS files in
    the `Lesson01` folder. You can refer to them directly if you are in the same folder
    or copy and paste them into your project.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 此HTML使用了`products.js`和`create_elements.js`脚本，这与本节中使用的示例代码相同。它还使用了`Lesson01`文件夹中的CSS文件。如果您在同一个文件夹中，可以直接参考它们，或者将它们复制粘贴到您的项目中。
- en: 'Create a file called `filter_and_search.js`, which is the last JavaScript code
    loaded in the HTML code. This is where we''ll be adding all the code for this
    exercise. The first thing we need to do is to store the filter state. There will
    be two possible filters the user can apply to the page: selecting a tag and/or
    typing some text. To store them, we''ll use an array and a string variable:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`filter_and_search.js`的文件，这是在HTML代码中加载的最后一个JavaScript代码。这是我们将为此练习添加所有代码的地方。我们需要做的第一件事是存储过滤器状态。用户可以应用到页面的两种可能过滤器：选择标签和/或输入一些文本。为了存储它们，我们将使用一个数组和一个字符串变量：
- en: '[PRE39]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we''ll create a function that will add an event listener for all the tags
    in the page. This function will find all the `tag` elements, wrap them in an array,
    and add an event listener using the `addEventListener` method in `Element` to
    respond to the `click` event:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个函数，该函数将为页面中的所有标签添加事件侦听器。此函数将查找所有`tag`元素，将它们包装在一个数组中，并使用`Element`中的`addEventListener`方法添加事件侦听器以响应`click`事件：
- en: '[PRE40]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the event listener, we will check whether the tag is already in the
    array of tags to filter by. If not, we''ll add it and call another function, called
    `applyTagFilters`:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在事件侦听器中，我们将检查标签是否已经在要按其进行过滤的标签数组中。如果没有，我们将添加它并调用另一个名为`applyTagFilters`的函数：
- en: '[PRE41]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`applyFilters` is just a catch-all function that will contain all the logic
    related to updating the page when the filtering conditions change. You''ll just
    be calling functions we''re going to write in the next steps:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`applyFilters`只是一个包含与更新页面相关的所有逻辑的捕捉函数。您将只调用我们将在接下来的步骤中编写的函数：'
- en: '[PRE42]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Before we continue with the `applyFilters` function, we''ll add another function
    to handle the events on the input box for the text search. This handler will listen
    to `keyup` events, which are triggered when the user finishes typing each letter.
    The handler will just get the current text in the input, set the value to the
    `textToSearch` variable, and call the `applyFilters` function:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续`applyFilters`函数之前，我们将添加另一个函数来处理文本搜索输入框上的事件。这个处理程序将监听`keyup`事件，当用户完成输入每个字母时触发。处理程序将获取输入框中的当前文本，将值设置为`textToSearch`变量，并调用`applyFilters`函数：
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, back to the `applyFilters` function. The first function called in there
    is almost hidden. It''s the `filterByTags` function, which filters the list of
    products using the `tagsToFilterBy` array. It recursively filters the list of
    products passed in using the selected tags:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，回到`applyFilters`函数。在其中调用的第一个函数几乎是隐藏的。这就是`filterByTags`函数，它使用`tagsToFilterBy`数组对产品列表进行过滤。它使用递归的方式对传入的产品列表使用选择的标签进行过滤：
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Whatever comes out of the filter function is passed to another filter function,
    the one that filters the products based on the text search. The `filterByText`
    function transforms all text to lowercase before comparing. That way, the search
    will always be case-insensitive:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论过滤函数的输出是什么，都会传递给另一个过滤函数，即基于文本搜索过滤产品的函数。`filterByText`函数在比较之前将所有文本转换为小写。这样，搜索将始终不区分大小写：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: After filtering by the selected tags and filtering by the typed text, we pass
    the filtered values to `createListForProducts`, which is a function inside `create_elements.js`
    and was described during this section, before the exercise.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过选择的标签进行过滤和通过输入的文本进行过滤之后，我们将过滤后的数值传递给`createListForProducts`，这是`create_elements.js`中的一个函数，在本节练习之前已经描述过。
- en: 'Now that we have the new list of products already showing on the page, we need
    to re-register the tag filter event listener because the DOM tree elements were
    recreated. So, we call `addTagFilter` again. As shown previously, this is how
    the `applyFilters` function looks:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在页面上显示了新产品列表，我们需要重新注册标签过滤器事件监听器，因为DOM树元素已经被重新创建。所以我们再次调用`addTagFilter`。如前所示，这就是`applyFilters`函数的样子：
- en: '[PRE46]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The last function called in the `applyTagFilter` function is `updateTagFilterList`.
    This function will find the element that will hold the filter indicator, check
    whether there are tags selected to filter by, and update it accordingly, either
    setting the text to `No filters` or adding an indicator for each tag applied:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`applyTagFilter`函数中调用的最后一个函数是`updateTagFilterList`。此函数将找到将保存过滤器指示器的元素，检查是否有选定的标签进行过滤，并相应地进行更新，要么将文本设置为`无过滤器`，要么为每个应用的标签添加指示器：'
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last function we need to tie all of this together is the `createTagFilterLabel`
    function, which is used to create the indicator that a tag is selected in the
    search bar. This function will create the DOM element and add an event listener
    that, when clicked, will remove the tag from the array and call the `applyTagFilter`
    function again:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将所有这些联系在一起的最后一个函数是`createTagFilterLabel`函数，它用于在搜索栏中创建标签被选中的指示器。此函数将创建DOM元素并添加一个事件侦听器，当单击时，将从数组中删除标签并再次调用`applyTagFilter`函数：
- en: '[PRE48]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The last step you need to take to make the page work is to call the `applyTagFilter`
    function so that it will update the page to the initial state, which is no tags
    selected. Also, it will call `addTextSearchFilter` to add the event handler for
    the textbox:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使页面工作的最后一步是调用`applyTagFilter`函数，以便将页面更新到初始状态，即未选择任何标签。此外，它将调用`addTextSearchFilter`以添加文本框的事件处理程序：
- en: '[PRE49]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open the page in Chrome and you''ll see that the filter is empty at the top
    and all products are shown in the list. It looks like the screenshot at the beginning
    of this exercise. Click on a tag or type something in the textbox and you''ll
    see the page change to reflect the new state. For example, selecting the two **cookie**
    and **bakery** labels and typing **chocolate** in the textbox will make the page
    only show the products that have those two labels and **chocolate** in their name
    or description:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在Chrome中打开页面，您会看到顶部的过滤器为空，并且所有产品都显示在列表中。它看起来像本练习开头的截图。单击一个标签或在文本框中输入内容，您会看到页面更改以反映新状态。例如，选择两个**饼干**和**面包店**标签，并在文本框中输入**巧克力**，页面将只显示具有这两个标签和名称或描述中包含**巧克力**的产品：
- en: '![Figure 1.51: The storefront filtered by the two bakery and cookie tags and
    the word chocolate](Images/C14587_01_51.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![图1.51：商店前端通过两个面包店和饼干标签以及单词巧克力进行过滤](Images/C14587_01_51.jpg)'
- en: 'Figure 1.51: The storefront filtered by the two bakery and cookie tags and
    the word chocolate'
  id: totrans-389
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.51：商店前端通过两个面包店和饼干标签以及单词巧克力进行过滤
- en: In this exercise, you've learned how to respond to user events and change the
    page accordingly to reflect the state the user wants the page to be in. You've
    also learned that when elements get removed and re-added to the page, event handlers
    get lost and need to be re-registered.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本练习中，您已经学会了如何响应用户事件并相应地更改页面，以反映用户希望页面处于的状态。您还学会了当元素被移除并重新添加到页面时，事件处理程序会丢失并需要重新注册。
- en: Shadow DOM and Web Components
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 影子DOM和Web组件
- en: In previous sections, we've seen that a simple web application can require complex
    coding. When applications get bigger and bigger, they get harder and harder to
    maintain. The code starts to become tangled and a change in one place affects
    other unexpected places. That's because of the global nature of HTML, CSS, and
    JavaScript.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的部分中，我们已经看到一个简单的Web应用可能需要复杂的编码。当应用程序变得越来越大时，它们变得越来越难以维护。代码开始变得混乱，一个地方的变化会影响其他意想不到的地方。这是因为HTML、CSS和JavaScript的全局性质。
- en: A lot of solutions have been created to try to circumvent this problem, and
    the **World Wide Web Consortium** (**W3C**) started to work on proposals for a
    standard way of creating custom, isolated components that could have their own
    styles and DOM root. Shadow DOM and custom components are two standards born from
    that initiative.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 已经创建了许多解决方案来尝试规避这个问题，**万维网联盟**（**W3C**）开始着手提出标准的方式来创建自定义的、隔离的组件，这些组件可以拥有自己的样式和DOM根。Shadow
    DOM和自定义组件是从这一倡议中诞生的两个标准。
- en: Shadow DOM is a way for you to create an isolated DOM subtree that can have
    its own styles and is not affected by styles added to the parent tree. It also
    isolates the HTML, which means IDs used on the document tree can be reused multiple
    times in each shadow tree.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: Shadow DOM是一种创建隔离的DOM子树的方式，可以拥有自己的样式，并且不受添加到父树的样式的影响。它还隔离了HTML，这意味着在文档树上使用的ID可以在每个影子树中多次重用。
- en: 'The following figure illustrates the concepts involved when dealing with Shadow
    DOM:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了处理Shadow DOM时涉及的概念：
- en: '![Figure 1.52: Shadow DOM concepts](Images/C14587_01_52.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![图1.52：Shadow DOM概念](Images/C14587_01_52.jpg)'
- en: 'Figure 1.52: Shadow DOM concepts'
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.52：Shadow DOM概念
- en: 'Let''s describe what these concepts mean:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述一下这些概念的含义：
- en: '**Document Tree** is the main DOM tree for the page.'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档树**是页面的主要DOM树。'
- en: '**Shadow Host** is the node where the shadow tree is attached.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影子宿主**是附加影子树的节点。'
- en: '**Shadow Tree** is an isolated DOM tree attached to the document tree.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影子树**是附加到文档树的隔离DOM树。'
- en: '**Shadow Root** is the root element in the shadow tree.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**影子根**是影子树中的根元素。'
- en: The Shadow Host is an element in the document tree where the shadow tree is
    attached. The Shadow Root element is a node that is not displayed on the page,
    just like the document object in the main document tree.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 影子宿主是文档树中附加影子树的元素。影子根元素是一个不显示在页面上的节点，就像主文档树中的文档对象一样。
- en: 'To understand how this works, let''s start with some HTML with some strange
    styles:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这是如何工作的，让我们从一些具有奇怪样式的HTML开始：
- en: '[PRE50]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This would make every paragraph on the page have a greyish background with
    some blue color text in it. This is how a paragraph on this page would look:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使页面上的每个段落都具有灰色背景，并带有一些蓝色文字。这是页面上段落的样子：
- en: '![Figure 1.53: Paragraph with the styles applied](Images/C14587_01_53.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![图1.53：应用了样式的段落](Images/C14587_01_53.jpg)'
- en: 'Figure 1.53: Paragraph with the styles applied'
  id: totrans-408
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.53：应用了样式的段落
- en: 'Let''s add a shadow tree and add a paragraph into it to see how it behaves.
    We will wrap the paragraph element with a `div` element and add some text to it:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个影子树，并在其中添加一个段落，看看它的行为。我们将使用`div`元素将段落元素包装起来，并添加一些文本：
- en: '[PRE51]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then we can use the `attachShadow` method in an element to create a shadow
    root element:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在元素中使用`attachShadow`方法创建一个影子根元素：
- en: '[PRE52]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code selects the `div` element from the page and then calls the
    `attachShadow` method, passing a configuration object to it. The configuration
    says that this shadow tree is open, which means the shadow root for it can be
    accessed through the `shadowRoot` property of the element the shadow tree was
    attached to – `div`, in this case:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码选择了页面上的`div`元素，然后调用`attachShadow`方法，将配置对象传递给它。配置表示这个影子树是打开的，这意味着可以通过元素的`shadowRoot`属性访问它的影子根元素
    - 在这种情况下是`div`：
- en: '![Figure 1.54: Open shadow trees can be accessed through the element where
    the tree is attached](Images/C14587_01_54.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![图1.54：可以通过附加树的元素访问打开的影子树](Images/C14587_01_54.jpg)'
- en: 'Figure 1.54: Open shadow trees can be accessed through the element where the
    tree is attached'
  id: totrans-415
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.54：可以通过附加树的元素访问打开的影子树
- en: Shadow trees can be closed, but taking that approach is not recommended since
    it gives a false sense of security and it makes the user's life much harder.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 影子树可以关闭，但不建议采用这种方法，因为这会产生一种虚假的安全感，并且会让用户的生活变得更加困难。
- en: 'After we attach a shadow tree to the document tree, we can start manipulating
    it. Let''s copy the HTML from the shadow host into the shadow root and see what
    happens:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将影子树附加到文档树后，我们可以开始操纵它。让我们将影子宿主中的HTML复制到影子根中，看看会发生什么：
- en: '[PRE53]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, if you load the page in Chrome, you''ll see the following:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在Chrome中加载页面，您会看到以下内容：
- en: '![Figure 1.55: Page with the shadow DOM loaded](Images/C14587_01_55.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图1.55：加载了影子DOM的页面](Images/C14587_01_55.jpg)'
- en: 'Figure 1.55: Page with the shadow DOM loaded'
  id: totrans-421
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.55：加载了影子DOM的页面
- en: You can see that even though the styles added to the page are selecting all
    paragraphs, the paragraph added to the shadow tree is not affected by it. The
    elements in the Shadow DOM are completely isolated from the document tree.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，即使向页面添加了样式来选择所有段落，但向影子树添加的段落不受其影响。Shadow DOM中的元素与文档树完全隔离。
- en: 'If you look at the DOM now, you''ll see that something looks strange. The shadow
    tree replaces and wraps the paragraph that was inside the `div` element, which
    is the shadow host:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您查看DOM，您会发现有些地方看起来很奇怪。影子树替换并包装了原来在`div`元素内部的段落，这就是影子宿主：
- en: '![Figure 1.56: The shadow tree is at the same level as the other nodes in the
    shadow host](Images/C14587_01_56.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![图1.56：影子树与影子宿主中的其他节点处于同一级别](Images/C14587_01_56.jpg)'
- en: 'Figure 1.56: The shadow tree is at the same level as the other nodes in the
    shadow host'
  id: totrans-425
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.56：影子树与影子宿主中的其他节点处于同一级别
- en: 'But the original paragraph inside the shadow host is not rendered on the page.
    That is because when the browser renders the page, if the element contains a shadow
    tree with new content, it will replace the current tree under the host. That process
    is called flattening and the following diagram depicts how it works:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 但是影子宿主内部的原始段落不会在页面上呈现。这是因为当浏览器渲染页面时，如果元素包含具有新内容的影子树，它将替换宿主下的当前树。这个过程称为平铺，下面的图表描述了它的工作原理：
- en: '![](Images/C14587_01_57.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/C14587_01_57.jpg)'
- en: 'Figure 1.57: When flattened, the browser ignores the nodes under the shadow
    host'
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.57：平铺时，浏览器会忽略影子宿主下的节点
- en: Now that we understand what Shadow DOM is, we can start using it to build or
    own HTML elements. That's right! With custom component APIs, you can create your
    own HTML element and then use it just like any other element.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了Shadow DOM是什么，我们可以开始使用它来构建或者自己的HTML元素。没错！通过自定义组件API，你可以创建自己的HTML元素，然后像任何其他元素一样使用它。
- en: 'In the rest of this section, we''ll build a custom component called **counter**,
    which has two buttons and text in between. You can click the buttons to increment
    or decrement the value stored. You can also configure it to have an initial value
    and a different increment value. The following screenshot shows how the component
    will look when we are finished. The code for this lives on GitHub at [https://bit.ly/2mVy1XP](https://bit.ly/2mVy1XP):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们将构建一个名为**counter**的自定义组件，它有两个按钮和中间的文本。你可以点击按钮来增加或减少存储的值。你还可以配置它具有初始值和不同的增量值。下面的屏幕截图显示了组件完成后的外观。这个代码存放在GitHub上，网址是[https://bit.ly/2mVy1XP](https://bit.ly/2mVy1XP)：
- en: '![Figure 1.58: The counter component and how it is used in HTML](Images/C14587_01_58.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图1.58：计数器组件及其在HTML中的使用](Images/C14587_01_58.jpg)'
- en: 'Figure 1.58: The counter component and how it is used in HTML'
  id: totrans-432
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.58：计数器组件及其在HTML中的使用
- en: 'To define your custom component, you need to call the `define` method in the
    custom components registry. There''s a global instance of the registry called
    `customElements`. To register your component you call `define`, passing the string
    that your component will be referenced by. It needs to have at least one dash.
    You also need to pass the constructor that instantiates your component. Here is
    the code:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义你的自定义组件，你需要在自定义组件注册表中调用`define`方法。有一个名为`customElements`的全局注册表实例。要注册你的组件，你调用`define`，传递你的组件将被引用的字符串。它至少需要有一个破折号。你还需要传递实例化你的组件的构造函数。下面是代码：
- en: '[PRE54]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Your constructor can be a normal function or, as in this example, you can use
    the new JavaScript `class` definition. It needs to extend `HTMLElement`:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你的构造函数可以是一个普通函数，或者，就像这个例子中一样，你可以使用新的JavaScript `class`定义。它需要扩展`HTMLElement`：
- en: '[PRE55]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For custom components to be isolated from the rest of the page, you use a shadow
    tree where the shadow host is your components element. You don't need to use Shadow
    DOM to build custom components, but it is recommended for more complex components
    that will also wrap some styles.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使自定义组件与页面的其余部分隔离，你可以使用一个阴影树，其中阴影主机是你的组件元素。你不需要使用Shadow DOM来构建自定义组件，但建议对于更复杂的组件也包装一些样式。
- en: 'In the constructor of your element, you create the shadow root by calling `attachShadow`
    to your own instance:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的元素的构造函数中，通过调用`attachShadow`来创建自己的实例的阴影根：
- en: '[PRE56]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Remember that when you attach a shadow DOM to an element using the `open` mode,
    the element stores that shadow root in a `shadowRoot` property. So, we can refer
    to it using `this.shadowRoot` from now on.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当你使用`open`模式将阴影DOM附加到元素时，元素将把该阴影根存储在`shadowRoot`属性中。所以，从现在开始我们可以使用`this.shadowRoot`来引用它。
- en: 'In the preceding figure, you saw that the `counter` component has two attributes
    that it uses to configure itself: `value` and `increment`. Those are set in the
    beginning of the constructor using the `getAttribute` method of `Element` and
    setting reasonable defaults, if they are not available:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你看到`counter`组件有两个属性，它用来配置自身：`value`和`increment`。这些属性在构造函数的开始使用`Element`的`getAttribute`方法设置，并在没有可用时设置合理的默认值：
- en: '[PRE57]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'After that, we create all the DOM elements for this component and append them
    to the shadow root. We''re not going to dig into the details since you''ve seen
    enough DOM manipulation for now. In the constructor, we just call the functions
    that create those elements and append them using `this.shadowRoot.appendChild`:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们为这个组件创建了所有的DOM元素，并将它们附加到阴影根。我们不会深入细节，因为你现在已经看到了足够的DOM操作。在构造函数中，我们只是调用创建这些元素的函数，并使用`this.shadowRoot.appendChild`将它们附加：
- en: '[PRE58]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The first method creates a `link` element that imports the CSS file for the
    `counter` component. The second and fourth methods create the `decrement` and
    `increment` buttons and attach the event handlers. The third method creates a
    `span` element and keeps a reference to it under the `property` span.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法创建一个`link`元素，导入`counter`组件的CSS文件。第二和第四个方法创建`decrement`和`increment`按钮，并附加事件处理程序。第三个方法创建一个`span`元素，并在`property`下保留对它的引用。
- en: 'The `incrementValue` and `decrementValue` methods increment the current value
    by the specified amount and then call an `updateState` method, which synchronizes
    the state of the values to the DOM (the Shadow DOM, in this case). The code for
    the `incrementValue` and `updateState` methods is as follows:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`incrementValue`和`decrementValue`方法通过指定的数量增加当前值，然后调用`updateState`方法，将值的状态与DOM（在这种情况下是Shadow
    DOM）同步。`incrementValue`和`updateState`方法的代码如下：'
- en: '[PRE59]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the `incrementValue` function, we also call the function to trigger the event
    to notify users that the value changed. This function will be discussed later.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在`incrementValue`函数中，我们还调用函数来触发事件，通知用户值已经改变。这个函数将在后面讨论。
- en: 'Now that you have your new `HTMLElement` defined and registered, you can use
    it just like any other existing HTML element. You can add it via tags in the HTML
    code as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义并注册了你的新的`HTMLElement`，你可以像任何其他现有的HTML元素一样使用它。你可以通过HTML代码中的标签添加它，如下所示：
- en: '[PRE60]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Or, via JavaScript, by creating an element and appending it to the DOM:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过JavaScript，通过创建一个元素并将其附加到DOM中：
- en: '[PRE61]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To completely understand the power of web components, there are two last things
    you need to know about: callbacks and events.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解Web组件的强大之处，还有两件事情你需要知道：回调和事件。
- en: Custom components have life cycle callbacks that you can set in your class to
    get notified when things change around them. The two most important ones are `connectedCallback`
    and `attributeChangedCallback`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义组件有生命周期回调，你可以在你的类中设置它们，以便在它们周围的事情发生变化时得到通知。最重要的两个是`connectedCallback`和`attributeChangedCallback`。
- en: 'The first one is useful when you want to manipulate the DOM after your component
    gets appended to it. For the **counter** component, we''re just printing something
    on the console to show that the component is now connected to the DOM:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个对于当你想要在组件附加到DOM后操纵DOM时很有用。对于**counter**组件，我们只是在控制台上打印一些东西，以显示组件现在连接到了DOM：
- en: '[PRE62]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When the page loads, you can see the statements printed for each **counter**
    component added to the DOM:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当页面加载时，你可以看到为每个**counter**组件添加到DOM中打印的语句：
- en: '![Figure 1.59: Statement printed in the console when counter components are
    attached to the DOM](Images/C14587_01_59.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图1.59：当计数器组件附加到DOM时在控制台中打印的语句](Images/C14587_01_59.jpg)'
- en: 'Figure 1.59: Statement printed in the console when counter components are attached
    to the DOM'
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.59：当计数器组件附加到DOM时在控制台中打印的语句
- en: '`attributeChangedCallback` gets called when some attribute in your component
    is changed. But for it to work, you need a static getter that will tell what attributes
    you want to be notified about changes. The following is the code for the static
    getter:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`attributeChangedCallback`在组件中的某个属性被更改时被调用。但是为了让它工作，你需要一个静态的getter，它会告诉你想要被通知属性的更改。以下是静态getter的代码：'
- en: '[PRE63]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'It just returns an array with all the attributes we want to be notified about.
    `attributeChangedCallback` receives a few parameters: the name of the attribute
    that changed, the old value (this will be null if it wasn''t set), and the new
    value. Here is the callback code for the **counter** component:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 它只是返回一个包含我们想要被通知的所有属性的数组。`attributeChangedCallback`接收几个参数：更改的属性名称，旧值（如果没有设置，则为null），和新值。以下是**counter**组件的回调代码：
- en: '[PRE64]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Our callback checks for the attribute name ignores the old value since we don't
    need it, transforms it, parses it into an integer, and sets the new value accordingly
    based on the name of the attribute. Finally, it calls the `updateState` function,
    which will update the state of the component based on its properties.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的回调检查属性名称，忽略旧值，因为我们不需要它，将其转换为整数，解析为整数，并根据属性的名称相应地设置新值。最后，它调用`updateState`函数，该函数将根据其属性更新组件的状态。
- en: The last thing about web components that you need to know is how to dispatch
    events. Events are a big part of the standard components; they form the basis
    for all interaction with the user. Because of that, a big part of encapsulating
    logic into components is to understand what events the users of your components
    will be interested in.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络组件的最后一件事是你需要知道如何分发事件。事件是标准组件的重要部分；它们构成了与用户的所有交互的基础。因此，将逻辑封装到组件中的一个重要部分是理解你的组件的用户将对哪些事件感兴趣。
- en: For our **counter** component, it makes a lot of sense to have an event dispatched
    every time the value changes. It would also be useful to have the value passed
    in the event. That way, users won't need to query your component to get the current
    value.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的**counter**组件，每当值更改时分发事件是非常有意义的。在事件中传递值也是有用的。这样，用户就不需要查询你的组件来获取当前值。
- en: To dispatch custom events, we can use the `dispatchEvent` method of `Element`
    and use the `CustomEvent` constructor to build our event with the custom data.
    The name of our event will be `value-changed`. Users can add event handlers to
    listen to this event and be notified when the value changes.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 要分发自定义事件，我们可以使用`Element`的`dispatchEvent`方法，并使用`CustomEvent`构造函数来使用自定义数据构建我们的事件。我们的事件名称将是`value-changed`。用户可以添加事件处理程序来监听此事件，并在值更改时收到通知。
- en: 'The following code is for the `triggerValueChangedEvent` function, which was
    mentioned previously; this function is called from within the `incrementValue`
    and `decrementValue` functions:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '以下代码是`triggerValueChangedEvent`函数，之前提到过；这个函数从`incrementValue`和`decrementValue`函数内部调用： '
- en: '[PRE65]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This function creates an instance of `CustomEvent`, which bubbles through the
    DOM and contains the current value in the `detail` property. We could've just
    created a normal event instance and set the property directly on the object, but
    for custom events, it's recommended to use the `CustomEvent` constructor, which
    handles custom data correctly. With the event created, the `dispatchEvent` method
    is called, passing the event.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数创建了一个`CustomEvent`的实例，它在DOM中冒泡，并在`detail`属性中包含当前值。我们本可以创建一个普通的事件实例，并直接在对象上设置属性，但是对于自定义事件，建议使用`CustomEvent`构造函数，它可以正确处理自定义数据。创建事件后，调用`dispatchEvent`方法，传递事件。
- en: 'Now that we have the events getting published, we can register and show the
    information on the page. The following is the code that queries for all `counter-components`
    and adds an event listener for the `value-changed` event. The handler adds a paragraph
    to an existing `div` every time one of the components is clicked:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发布了事件，我们可以注册并在页面上显示信息。以下是查询所有`counter-components`并为`value-changed`事件添加事件侦听器的代码。处理程序在每次单击组件时向现有的`div`添加一个段落：
- en: '[PRE66]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This is how the page looks after clicking a few times on the different counters:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在不同计数器上点击几次后页面的外观：
- en: '![Figure 1.60: Paragraphs added to the page showing that the counters were
    clicked](Images/C14587_01_60.jpg)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![图1.60：页面上添加的段落，显示计数器被点击](Images/C14587_01_60.jpg)'
- en: 'Figure 1.60: Paragraphs added to the page showing that the counters were clicked'
  id: totrans-475
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.60：页面上添加的段落，显示计数器被点击
- en: 'Exercise 7: Replacing a Search Box with a Web Component'
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习7：用网络组件替换搜索框
- en: To fully understand the concept of web components, you need to see how an application
    can be decomposed into encapsulated, reusable components. The storefront page
    that we built in the previous exercise is a great place for us to start.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解网络组件的概念，你需要看看一个应用程序如何被分解为封装的、可重用的组件。我们在上一个练习中构建的商店页面是我们开始的好地方。
- en: 'In this exercise, we''ll write a web component to replace the search box at
    the top right-hand side of the page. This is the component we''re talking about:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个网络组件，以替换页面右上角的搜索框。这就是我们谈论的组件：
- en: '![Figure 1.61: Search box that will be transformed into a web component](Images/C14587_01_61.jpg)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![图1.61：将转换为Web组件的搜索框](Images/C14587_01_61.jpg)'
- en: 'Figure 1.61: Search box that will be transformed into a web component'
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图1.61：将转换为Web组件的搜索框
- en: 'The idea is that the component will handle its looks, rendering, and state,
    and it will emit events when the state changes. In this case, the search box only
    has one state: the **search** text.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将处理它的外观、渲染和状态，并在状态改变时发出事件。在这种情况下，搜索框只有一个状态：**搜索**文本。
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: Copy the code from `Exercise 6` into a new folder so that we can change it without
    affecting the existing storefront.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码从`Exercise 6`复制到一个新文件夹中，这样我们就可以在不影响现有 storefront 的情况下进行更改。
- en: 'Let''s start by creating a web component. Create a file called `search_box.js`,
    add a new class called `SearchBox`, and define a new component using this class:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们开始创建一个Web组件。创建一个名为`search_box.js`的文件，添加一个名为`SearchBox`的新类，并使用这个类定义一个新组件：
- en: '[PRE67]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In the class, add a constructor, call `super`, and attach the component to
    a shadow root. The constructor will also initialize the state by setting a variable
    called `_searchText to`:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中，添加一个构造函数，调用`super`，并将组件附加到一个影子根。构造函数还将通过设置一个名为`_searchText`的变量来初始化状态：
- en: '[PRE68]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To expose the current state, we''ll add a getter to the `_searchText` field:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了公开当前状态，我们将为`_searchText`字段添加一个getter：
- en: '[PRE69]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Still in the class, create a method called `render`, which will set `shadowRoot.innerHTML`
    to the template component we want. In this case, it will be the existing HTML
    for the search box plus a link to the semantic UI styles, so that we can reuse
    them:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在类中，创建一个名为`render`的方法，它将把`shadowRoot.innerHTML`设置为我们想要的模板组件。在这种情况下，它将是搜索框的现有HTML加上一个指向semantic
    UI样式的链接，以便我们可以重用它们：
- en: '[PRE70]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Create another method called `triggerTextChanged`, which will trigger an event
    to notify listeners that the search text changed. It receives the new text value
    and passes it to the listeners:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`triggerTextChanged`的方法，它将触发一个事件来通知监听器搜索文本已更改。它接收新的文本值并将其传递给监听器：
- en: '[PRE71]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the constructor, after attaching the shadow root, call the `render` method
    and register a listener to the input box so that we can trigger the changed event
    for our component. The constructor should now look like this:'
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，在附加影子根后，调用`render`方法并注册一个监听器到输入框，以便我们可以为我们的组件触发changed事件。构造函数现在应该是这样的：
- en: '[PRE72]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'With our web component ready, we can replace the old search box with it. In
    the `dynamic_storefront.html` HTML, replace the `div` tag with the `ui`, `icon`,
    and `input` classes, and all their content, with the new component we created:
    `search-box`. Also, add the new JavaScript file to the HTML, before all other
    scripts. You can see the final HTML on GitHub at [https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise07/dynamic_storefront.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise07/dynamic_storefront.html).'
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好我们的Web组件后，我们可以用它替换旧的搜索框。在`dynamic_storefront.html` HTML中，用我们创建的新组件`search-box`替换`div`标签和它们的所有内容。还要将新的JavaScript文件添加到HTML中，放在所有其他脚本之前。您可以在GitHub上查看最终的HTML，网址为[https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise07/dynamic_storefront.html](https://github.com/TrainingByPackt/Professional-JavaScript/blob/master/Lesson01/Exercise07/dynamic_storefront.html)。
- en: 'Save a reference to the `search-box` component by using the `querySelector`
    method from the document:'
  id: totrans-497
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用文档的`querySelector`方法保存对`search-box`组件的引用：
- en: '[PRE73]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Register an event listener for the changed event so that we know when a new
    value is available and call `applyFilters`:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注册一个changed事件的事件监听器，这样我们就知道何时有新值可用，并调用`applyFilters`：
- en: '[PRE74]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now we can clean the `filter_and_search.js` JavaScript since part of the logic
    was moved to the new component. We''ll do the following cleanup:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以清理`filter_and_search.js` JavaScript，因为部分逻辑已经移动到新组件中。我们将进行以下清理：
- en: Remove the `textToSearch` variable (line 2) and replace it with `searchBoxElement.searchText`
    (line 40).
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`textToSearch`变量（第2行），并将其替换为`searchBoxElement.searchText`（第40行）。
- en: Remove the `addTextSearchFilter` function (lines 16-22) and the call to it at
    the end of the script (line 70).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`addTextSearchFilter`函数（第16-22行）和脚本末尾对它的调用（第70行）。
- en: If everything went fine, opening the file in Chrome will result in the exact
    same storefront, which is exactly what we wanted.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，在Chrome中打开文件将得到完全相同的 storefront，这正是我们想要的。
- en: Now the logic to handle the search box and the search text is encapsulated,
    which means if we need to change it, we won't need to go around looking for pieces
    of code spread all around. And when we need to know the value of the search text,
    we can query the component that holds it for us.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，处理搜索框和搜索文本的逻辑已经封装起来，这意味着如果我们需要更改它，我们不需要四处寻找分散在各处的代码片段。当我们需要知道搜索文本的值时，我们可以查询保存它的组件。
- en: 'Activity 2: Replacing the Tag Filter with a Web Component'
  id: totrans-506
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动2：用Web组件替换标签过滤器
- en: Now that we've replaced the search box with a web component, let's replace the
    tag filter using the same technique. The idea is that we'll have a component that
    will store a list of selected tags.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用web组件替换了搜索框，让我们使用相同的技术替换标签过滤器。这个想法是我们将有一个组件来存储选定的标签列表。
- en: This component will encapsulate the list of selected tags that can be modified
    by using `mutator` methods (`addTag` and `removeTag`). When the internal state
    mutates, a changed event gets triggered. Also, when a tag in the list is clicked,
    a `tag-clicked` event will be triggered.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件将封装一个可以通过使用`mutator`方法（`addTag`和`removeTag`）来修改的选定标签列表。当内部状态发生变化时，会触发一个changed事件。此外，当列表中的标签被点击时，将触发一个`tag-clicked`事件。
- en: 'Steps:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: Start by copying the code from Exercise 7 into a new folder.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将代码从练习7复制到一个新文件夹中。
- en: Create a new file called `tags_holder.js` and in it add a class called `TagsHolder`
    that extends `HTMLElement`, then define a new custom component called `tags-holder`.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`tags_holder.js`的新文件，在其中添加一个名为`TagsHolder`的类，它扩展了`HTMLElement`，然后定义一个名为`tags-holder`的新自定义组件。
- en: 'Create two `render` methods: one to render the base state and one to render
    the tags or some text indicating that no tags are selected for filtering.'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`render`方法：一个用于渲染基本状态，另一个用于渲染标签或指示未选择任何标签进行过滤的文本。
- en: In the constructor, call `super`, attach the component to the shadow root, initialize
    the list of selected tags, and call both `render` methods.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，调用`super`，将组件附加到影子根，初始化所选标签列表，并调用两个`render`方法。
- en: Create a getter to expose the list of selected tags.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个getter来公开所选标签的列表。
- en: 'Create two trigger methods: one to trigger the `changed` event and one to trigger
    the `tag-clicked` event.'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个触发器方法：一个用于触发`changed`事件，另一个用于触发`tag-clicked`事件。
- en: 'Create two `mutator` methods: `addTag` and `removeTag`. These methods receive
    the tag name and add tag if not present, or remove the tag if present, in the
    list of selected tags. If the list was modified, trigger the `changed` event and
    call the method to re-render the list of tags.'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个`mutator`方法：`addTag`和`removeTag`。这些方法接收标签名称，如果不存在则添加标签，如果存在则删除标签。如果列表被修改，触发`changed`事件并调用重新渲染标签列表的方法。
- en: In the HTML, replace the existing code with the new component and add the new
    script file to it.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在HTML中，用新组件替换现有代码，并将新的脚本文件添加到其中。
- en: In `filter_and_search.js`, remove the `tagsToFilterBy` variable and replace
    it with the new `mutator` methods and events in the newly created component.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`filter_and_search.js`中，删除`tagsToFilterBy`变量，并用新创建的组件中的新`mutator`方法和事件替换它。
- en: Note
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意。
- en: The solution for this activity can be found on page 584.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可在第584页找到。
- en: Summary
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we explored the DOM specification by learning about its base
    interfaces, its properties, and its methods. We learned about the relationship
    between the HTML you write and the tree the browser generates from it. We queried
    the DOM and navigated the DOM tree. We learned how to create new elements, add
    them to the tree, and manipulate existing elements. Lastly, we learned how to
    use Shadow DOM to create isolated DOM trees and custom components that can be
    easily reused in HTML pages.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过学习基本接口、属性和方法来探索DOM规范。我们了解了你编写的HTML与浏览器从中生成的树之间的关系。我们查询了DOM并导航DOM树。我们学会了如何创建新元素，将它们添加到树中，并操作现有元素。最后，我们学会了如何使用Shadow
    DOM来创建隔离的DOM树和可以在HTML页面中轻松重用的自定义组件。
- en: In the next chapter, we'll switch gears to the backend world. We'll start learning
    about Node.js and the basic concepts around it. We'll go through how to install
    and manage multiple versions of Node.js using **nvm**, and last but not least,
    we'll also learn about **npm** and how to find and use external modules.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将转向后端世界。我们将开始学习有关Node.js及其基本概念。我们将学习如何使用**nvm**安装和管理多个Node.js版本，最后但同样重要的是，我们还将学习有关**npm**以及如何查找和使用外部模块。
