- en: Designing Functions - Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计函数-递归
- en: 'In [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml), *Connecting Functions
    - Pipelining And Composition*, we considered yet more ways to create new functions
    out of combining previous existing ones. Here, we are going to get into a different
    theme: how to actually design and write functions, in a typically functional way,
    by applying recursive techniques.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中，*连接函数-管道和组合*，我们考虑了更多的方法来通过组合现有的函数来创建新函数。在这里，我们将进入一个不同的主题：如何通过应用递归技术以典型的功能方式设计和编写函数。
- en: 'We will be covering the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Understanding what recursion is and how to think in order to produce recursive
    solutions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解递归是什么以及如何思考以产生递归解决方案
- en: Applying recursion to some well-known problems, such as making change or the
    *Tower of Hanoi*
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将递归应用于一些众所周知的问题，例如找零钱或*汉诺塔*
- en: Using recursion instead of iteration to re-implement some higher-order functions
    from earlier chapters
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用递归而不是迭代来重新实现早期章节中的一些高阶函数
- en: Writing search and backtrack algorithms with ease
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻松编写搜索和回溯算法
- en: Traversing data structures, such as trees, to work with file system directories
    or with the browser DOM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历数据结构，例如树，以处理文件系统目录或浏览器DOM
- en: Getting around some limitations caused by browser JS engine considerations
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决由浏览器JS引擎考虑引起的一些限制
- en: Using recursion
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用递归
- en: Recursion is a key technique in FP, to the degree that there are some languages
    that do not provide for any kind of iteration or loops and work exclusively with
    recursion (Haskell, which we already mentioned, is a prime example of that). A
    basic fact of computer science is that whatever you can do with recursion, you
    can also do with iteration (loops), and vice versa. The key concept is that there
    are many algorithms whose definition is far easier if you work recursively. On
    the other hand, recursion is not always taught, or many programmers, even knowing
    about it, prefer not to use it. So, in this section we shall see several examples
    of recursive thinking, so you can adapt it for your functional coding.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是FP中的关键技术，有些语言甚至不提供任何形式的迭代或循环，而完全使用递归（我们已经提到的Haskell就是一个典型例子）。计算机科学的一个基本事实是，无论您使用递归还是迭代（循环），您都可以使用递归完成的任何事情，反之亦然。关键概念是有许多算法的定义如果使用递归工作起来要容易得多。另一方面，递归并不总是被教授，或者许多程序员即使了解它，也宁愿不使用它。因此，在本节中，我们将看到几个递归思维的例子，以便您可以将其适应到您的功能编码中。
- en: 'A typical, oft-quoted, and very old, computer joke! *Dictionary definition:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的、经常引用的、非常古老的计算机笑话！*字典定义：
- en: '**recursion**: (n) see **recursion***'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**：（n）见**递归***'
- en: 'But, what is recursion? There are many ways to define what recursion is, but
    the simplest one I''ve seen runs along the lines of *a function calls itself,
    again and again, until it doesn''t*. Recursion is a natural technique for several
    kinds of problems, such as:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，什么是递归？有许多定义递归的方法，但我见过的最简单的一种是*一个函数一遍又一遍地调用自己，直到不再需要*。递归是解决几种问题的自然技术，例如：
- en: Mathematical definitions, such as the Fibonacci numbers or the Factorial of
    a number
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学定义，例如斐波那契数或阶乘
- en: Data structure related algorithms, with recursively defined structures, such
    as *lists* (a list is either empty or consist of a head node, followed by a list
    of nodes) or *trees* (a tree might be defined as a special node, called the root,
    linked to zero or more trees)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与递归定义的结构相关的数据结构算法，例如*列表*（列表要么为空，要么由一个头节点和一个节点列表组成）或*树*（树可以被定义为一个特殊节点，称为根节点，链接到零个或多个树）
- en: Syntax analysis for compilers, based on grammar rules which, themselves, depend
    on other rules, which also depend on other rules, and so on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于语法规则的编译器的语法分析，这些规则本身依赖于其他规则，这些规则又依赖于其他规则，依此类推
- en: And many more
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以及更多
- en: '![](assets/702ab100-d540-4e19-a179-027a0c040b90.png)Google itself jokes about
    it: if you ask about recursion, it answers Did you mean: recursion!'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/702ab100-d540-4e19-a179-027a0c040b90.png)Google本身就对此开玩笑：如果您询问递归，它会回答您是否想要：递归！'
- en: In any case, a recursive function, apart from some easy, *base*, cases, in which
    no further computation is required, always needs to call itself one or more times
    in order to perform part of the required calculations. This concept may be not
    very clear now, so let's see how we can think in a recursive fashion and then
    solve several common problems by applying that technique.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，递归函数除了一些简单的*基本*情况外，其中不需要进一步的计算，总是需要调用自身一次或多次以执行所需计算的一部分。这个概念现在可能不太清楚，所以让我们看看如何以递归的方式思考，然后通过应用该技术解决几个常见问题。
- en: Thinking recursively
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归思考
- en: 'The key to solving problems recursively is assuming that you already have a
    function that does whatever you need, and just call it normally. (Doesn''t this
    sound weird? Actually, it is quite appropriate: to solve a problem with recursion,
    you must first solve the problem...) On the other hand, if you try to work out
    in your head how the recursive calls work and attempt to follow the flow in your
    mind, you''ll probably just get lost. So, what you need to do is:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 递归解决问题的关键是假设您已经有一个可以满足您需求的函数，然后正常调用它。（这听起来奇怪吗？实际上，这是相当合适的：要使用递归解决问题，您必须首先解决问题...）另一方面，如果您试图在脑海中思考递归调用的工作方式并尝试在脑海中跟随流程，您可能会迷失方向。因此，您需要做的是：
- en: Assume you already have an appropriate function to solve your problem.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设您已经有一个适当的函数来解决您的问题。
- en: Then, see how the big problem can be solved by solving one (or more) smaller
    problems.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，看看如何通过解决一个（或多个）较小的问题来解决大问题。
- en: Solve those problems by using the imagined function from step 1.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用步骤1中想象的函数解决这些问题。
- en: Decide what are your *base cases*, simple enough that they be solved directly,
    not requiring any more calls.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定哪些是您的*基本情况*，足够简单，可以直接解决，不需要任何更多的调用。
- en: With these elements, you can solve problems by recursion, because you'll have
    the basic structure for your recursive solution.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些元素，你可以通过递归来解决问题，因为你将拥有递归解决方案的基本结构。
- en: 'There are three usual methods for solving problems by applying recursion:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用递归，有三种通常的方法来解决问题：
- en: '**Decrease and conquer** is the simplest case, in which solving a problem directly
    depends on solving a single, simpler case of itself'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少和征服**是最简单的情况，其中解决一个问题直接取决于解决其自身的一个更简单的情况'
- en: '**Divide and conquer** is a more general approach. The idea is to try to divide
    your problem into two or more smaller versions, solve them recursively, and use
    such solutions to solve the original problem. The only difference between *decrease
    and conquer* is that here, you have to solve two or more other problems, instead
    of only one'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分而治之**是一种更一般的方法。其思想是尝试将问题分解为两个或更多较小的版本，递归地解决它们，并使用这些解决方案来解决原始问题。*减少和征服*的唯一区别在于，这里你需要解决两个或更多其他问题，而不仅仅是一个问题'
- en: '**Dynamic programming** can be seen as a variant of d*ivide and conquer*: basically,
    you solve a complex problem by breaking it into a set of somewhat simpler versions
    of the same problem and solving each in order. However, a key idea in this strategy
    is to store previously found solutions, so whenever you find yourself needing,
    again, the solution to a simpler case, you won''t directly apply recursion, but
    rather use the stored result and avoid unnecessary repeated calculations'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态规划**可以被看作是*分而治之*的一种变体：基本上，你通过将一个复杂的问题分解为一系列稍微简单的相同问题的版本，并依次解决每个问题来解决它。然而，这种策略中的一个关键思想是存储先前找到的解决方案，因此每当你发现自己需要再次解决一个更简单的情况时，你不会直接应用递归，而是使用存储的结果，避免不必要的重复计算'
- en: In this section, we shall see a few problems and solve them by thinking in a
    recursive way. Of course, we shall see more applications of recursion in the rest
    of the chapter; here, we'll focus on the key decisions and questions needed to
    create such an algorithm.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看到一些问题，并通过递归的方式来解决它们。当然，在本章的其余部分，我们将看到递归的更多应用；在这里，我们将专注于创建这样一个算法所需的关键决策和问题。
- en: 'Decrease and Conquer: searching'
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少和征服：搜索
- en: 'The most usual case of recursion involves just a single simpler case. We have
    already seen some examples of this, such as the ubiquitous factorial calculation:
    to calculate the factorial of *n*, you previously needed to calculate the factorial
    of *n-1*. (See [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming
    Functional - Several Questions*.) Let''s turn now to a non-mathematical example.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的最常见情况涉及一个更简单的情况。我们已经看到了一些例子，比如普遍的阶乘计算：要计算*n*的阶乘，你之前需要计算*n-1*的阶乘。（见[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)，*成为函数式
    - 几个问题*。）现在让我们转向一个非数学的例子。
- en: 'To search for an element in an array, you would also use this *decrease and
    conquer* strategy. If the array is empty, obviously the searched value isn''t
    there. Otherwise, the result is in the array if, and only if, it''s the first
    element in it, or if it''s in the rest of the array:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要在数组中搜索一个元素，你也会使用这种*减少和征服*策略。如果数组为空，显然搜索的值不在其中。否则，结果在数组中，当且仅当它是数组中的第一个元素，或者它在数组的其余部分中：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This implementation directly mirrors our explanation and it's easy to verify
    its correctness.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现直接反映了我们的解释，很容易验证其正确性。
- en: By the way, just as a precaution, let's see two further implementations of the
    same concept. You can shorten the search function a bit -- is it still clear?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，作为一种预防措施，让我们看看相同概念的另外两种实现。你可以稍微缩短搜索函数 -- 这样还清晰吗？
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Sparseness can go even farther!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 稀疏性甚至可以更进一步！
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: I'm not really suggesting you code the function in this way -- rather, consider
    it a warning against the tendency that some FP developers show to try to go for
    the tightest, shortest, possible solution... and never mind clarity!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是真的建议你以这种方式编写函数 -- 相反，把它看作是对一些FP开发者倾向的一种警告，他们试图去寻求最紧凑、最简短的解决方案...而不在乎清晰度！
- en: 'Decrease and Conquer: doing powers'
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少和征服：做幂
- en: 'Another classic example has to do with calculating powers of numbers in an
    efficient way. If you want to calculate, say, 2 to the 13th power (2^(13)), you
    may do this with 12 multiplications. However, you can do much better by writing
    2^(13) as:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经典的例子涉及以高效的方式计算数字的幂。如果你想计算，比如说，2的13次方（2^(13)），你可能需要进行12次乘法。然而，你可以通过将2^(13)写成以下形式来做得更好：
- en: = 2 times 2^(12)
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: = 2乘以2^(12)
- en: = 2 times 4⁶
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: = 2乘以4⁶
- en: = 2 times 16³
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: = 2乘以16³
- en: = 2 times 16 times 16²
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: = 2乘以16乘以16²
- en: = 2 times 16 times 256¹
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: = 2乘以16乘以256¹
- en: = 8192
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: = 8192
- en: 'This reduction in the total number of multiplications may not look very impressive,
    but, in terms of algorithms complexity, it allows bringing down the order of the
    calculations from *O(n)* to *O(lg n)*. In some cryptographic related methods,
    which have to raise numbers to really high exponents, this makes a very important
    difference. We can implement this recursive algorithm in a few lines of code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 总乘法次数的减少可能看起来并不是很令人印象深刻，但是从算法复杂度的角度来看，它可以将计算的顺序从*O(n)*降低到*O(lg n)*。在一些与加密相关的方法中，这将产生非常重要的差异。我们可以用几行代码来实现这个递归算法：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When implemented for production, bit operations are used, instead of modulus
    and divisions. Checking if a number is odd can be written as `power & 1`, and
    division by 2 is achieved with `power > > 1`. These alternative calculations are
    way faster than the replaced operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中实现时，会使用位操作，而不是模数和除法。检查一个数字是否是奇数可以写为`power & 1`，而除以2可以用`power > > 1`来实现。这些替代计算比被替换的操作要快得多。
- en: Calculating a power is simple when the base case is reached (raising something
    to the zeroth power), or is based upon previously calculating some power for a
    smaller exponent. (If you wanted to, you could add another base case for raising
    something to the power of one.) These observations show that we are seeing a textbook
    case for the *decrease and conquer* recursive strategy.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当达到基本情况（将某物的零次方）或者基于先前计算较小指数的一些幂进行计算时，计算幂是简单的。（如果你愿意，你可以为将某物的一次方添加另一个基本情况。）这些观察表明，我们正在看到*减少和征服*递归策略的教科书案例。
- en: Finally, some of our higher-order functions, such as `map()`, `reduce()`, or
    `filter()`, also apply this technique; we'll look into this later on in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的一些高阶函数，比如`map()`、`reduce()`或`filter()`，也应用了这种技术；我们将在本章后面讨论这个问题。
- en: 'Divide and conquer: The Tower of Hanoi'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之：汉诺塔
- en: 'With this strategy, solving a problem requires two or more recursive solutions.
    For starters, let''s consider a classic puzzle, invented by a French mathematician,
    Édouard Lucas, in the XIX century. It seems that there is a temple in India, with
    three posts with 64 golden disks of decreasing diameter. The priests have to move
    the disks from the first post to the last one, following two rules: only one disk
    can be moved at a time, and a larger disk can never be placed on top of a smaller
    disk. According to the legend, when the 64 disks are moved, the world will end.
    This puzzle is usually marketed under the name *Towers of Hanoi* (yes, they changed
    countries!) with less than 10 disks. See figure 9.1:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种策略，解决一个问题需要两个或更多的递归解决方案。首先，让我们考虑一个经典的难题，由19世纪法国数学家Édouard Lucas发明。据说印度有一座寺庙，有三根柱子，上面有64个金质圆盘，直径递减。僧侣们必须将圆盘从第一根柱子移动到最后一根柱子，遵循两条规则：一次只能移动一个圆盘，较大的圆盘永远不能放在较小的圆盘上。根据传说，当64个圆盘移动时，世界将终结。这个难题通常以*汉诺塔*的名义（是的，他们换了国家！）在10个圆盘以下进行市场营销。见图9.1：
- en: '![](assets/bf050084-6ffd-480f-91c0-e04a23136daa.jpg)Figure 9.1- The classic
    Towers of Hanoi puzzle has a simple recursive solution.The solution for n disks
    requires *2^n-1* movements. The original puzzle, requiring *2^(64)-1* movements,
    at one movement per second, would take more than 584 billion years to finish ...
    a very long time, considering that the universe''s age is evaluated to *only*
    be 13.8 billion years!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/bf050084-6ffd-480f-91c0-e04a23136daa.jpg)图9.1-经典的汉诺塔难题有一个简单的递归解法。n个圆盘的解决方案需要*2^n-1*次移动。原始难题需要*2^(64)-1*次移动，以每秒一次的速度，需要超过5840亿年才能完成……这是一个非常长的时间，考虑到宇宙的年龄只有138亿年！'
- en: 'Suppose we already had a function that was able to solve the problem of moving
    any number of disks from a source post, to a destination post, using the remaining
    post as an extra aid. So, now think about solving the general problem, if you
    already had a function to solve that problem: `hanoi(disks, from, to, extra)`.
    If you wanted to move several disks from a post to another, you could solve it
    easily by using this (still unwritten!) function, by:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经有一个能够解决从源柱移动任意数量的圆盘到目标柱，使用剩余柱作为额外辅助的问题的函数。那么，现在考虑解决一般问题，如果你已经有一个解决该问题的函数：`hanoi(disks,
    from, to, extra)`。如果你想要从一个柱移动多个圆盘到另一个柱，你可以通过使用这个（尚未编写的！）函数轻松解决：
- en: Moving all of the disks but one to the extra post
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有圆盘但一个移动到额外柱
- en: Moving the larger disk to the destination post
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将较大的圆盘移动到目标柱
- en: Using your function, again, to move all of the disks from the extra post (where
    you had earlier placed them) to the destination
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 再次使用你的函数，将所有圆盘从额外柱（你之前放置它们的地方）移动到目标柱
- en: 'But, what about our bases cases? We could decide that to move a single disk,
    you needn''t use the function; you just go ahead and move it. Coded, it becomes:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们的基本情况呢？我们可以决定，要移动一个单独的圆盘，你不需要使用函数；你可以直接移动它。编码后变成：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can quickly verify this code works:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速验证这段代码是否有效：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's only a small detail to consider, which can simplify the function even
    further. In this code, our base case (the one that needs no further recursion)
    is when `disks` equal one. You could also solve it in a different way, by letting
    disks go down to zero and simply not doing anything -- after all, moving zero
    disks from a post to another is achieved by doing nothing at all!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个小细节需要考虑，可以进一步简化函数。在这段代码中，我们的基本情况（不需要进一步递归的情况）是`disks`等于1。你也可以以不同的方式解决它，让圆盘减少到零，然后根本不做任何事情——毕竟，从一个柱移动零个圆盘到另一个柱是通过根本不做任何事情来实现的！
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of checking if there are any disks to move before doing the recursive
    call, we can just skip the check and have the function test, at the next level,
    if there's something to be done.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以跳过检查是否有圆盘需要移动，而不是在进行递归调用之前进行检查，并让函数在下一级测试是否有事情要做。
- en: 'If you are doing the puzzle by hand, there''s a simple solution for that: on
    odd turns, always move the smaller disk to the next post (if the total number
    of disks is odd) or to the previous post (if the total number of disks is even).
    On even turns, do the only possible move that doesn''t imply the smaller disk.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在手动解决这个难题，有一个简单的解决方案：在奇数轮次，总是将较小的圆盘移动到下一个柱子（如果圆盘的总数是奇数）或者移动到前一个柱子（如果圆盘的总数是偶数）。在偶数轮次，做唯一可能的不涉及较小圆盘的移动。
- en: 'So, the principle for recursive algorithm design works: assume you already
    have your desired function and use it to build it!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，递归算法设计的原则是有效的：假设你已经有了你想要的函数，并用它来构建它！
- en: 'Divide and conquer: sorting'
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分而治之：排序
- en: 'We can see another example of the d*ivide and conquer* strategy, with sorting.
    A way to sort arrays, called q*uicksort*, is based upon the following premises:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到另一个例子，使用*分而治之*策略，进行排序。一种对数组进行排序的方法，称为*快速排序*，基于以下前提：
- en: If your array has 0 or 1 elements, do nothing; it's already sorted (this is
    the base case).
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的数组有0或1个元素，什么也不做；它已经排序好了（这是基本情况）。
- en: 'Otherwise, pick some element of the array (called the "pivot") and split the
    rest of the array into two sub-arrays: the elements less than your pick, and the
    elements greater than your pick, or equal to it.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，选择数组的某个元素（称为“枢轴”），并将数组的其余部分分成两个子数组：小于您选择的元素和大于或等于您选择的元素的元素。
- en: Recursively sort each sub-array.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 递归地对每个子数组进行排序。
- en: Concatenate both sorted results, with the pivot in-between, to produce the sorted
    version of the original array.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个排序后的结果连接起来，枢轴放在中间，以生成原始数组的排序版本。
- en: 'Let''s see a simple version of this -- there are some better-optimized implementations,
    but we are interested in the recursive logic now. Usually, picking a random element
    of the array is suggested, to avoid some bad performance border cases, but for
    our example, let''s just take the first one:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单版本的这个问题--有一些更好优化的实现，但我们现在对递归逻辑感兴趣。通常建议随机选择数组的一个元素，以避免一些性能不佳的边界情况，但是对于我们的例子，让我们只取第一个元素：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can see how this works in figure 9.2: the pivot for each array and sub-array
    is underlined. Splitting is shown with dotted arrows and is joined with full lines:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在图9.2中看到这是如何工作的：每个数组和子数组的枢轴都被划线标出。拆分用虚线箭头表示，并用实线连接：
- en: '![](assets/6a70f2e3-5083-417d-ba2b-a5eb0a3122e0.jpg)Figure 9.2\. Quicksort
    sorts an array recursively, applying the divide and conquer strategy, to reduce
    the original problem to smaller ones.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6a70f2e3-5083-417d-ba2b-a5eb0a3122e0.jpg)图9.2\. 快速排序递归地对数组进行排序，应用分而治之的策略，将原始问题减小为较小的问题。'
- en: 'Dynamic programming: making change'
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态规划：找零
- en: The third general strategy, *dynamic programming*, assumes that you will have
    to solve many smaller problems, but instead of using recursion each and every
    time, it depends on having stored the previously found solutions... memoization,
    in other terms! In [Chapter 4](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml), *Behaving
    Properly - Pure Functions*, and later in a better fashion in [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher - Order Functions*, we already saw how to optimize
    the calculations of the usual Fibonacci series, avoiding unnecessary repeated
    calls. Let's now consider another problem.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种一般策略，*动态规划*，假设您将不得不解决许多较小的问题，但是不是每次都使用递归，而是依赖于存储先前找到的解决方案...也就是记忆化！在[第4章](943d8f5d-2e39-409a-a1aa-26c1a5b36a6d.xhtml)中，*行为得当
    - 纯函数*，以及在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中以更好的方式，*生成函数 - 高阶函数*，我们已经看到了如何优化通常的斐波那契数列的计算，避免不必要的重复调用。现在，让我们考虑另一个问题。
- en: 'Given a certain amount of dollars and the list of existing bill values, calculate
    in how many different ways we can pay that amount of dollars with different combinations
    of bills. It is assumed that you have access to an unlimited number of each bill.
    How can we go about solving this? Let''s start by considering the base cases,
    where no further computation is needed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一定金额的美元和现有票面值列表，计算我们可以用不同的票据组合支付该金额的美元的方式有多少种。假设您可以无限使用每张票据。我们该如何解决这个问题？让我们从考虑基本情况开始，不需要进一步计算的情况：
- en: Paying negative values is not possible, so in such cases, we should return 0
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付负值是不可能的，因此在这种情况下，我们应该返回0
- en: Paying zero dollars is only possible in a single way (by giving no bills), so
    in this case, we should return 1
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付零美元只有一种可能的方式（不给任何票据），因此在这种情况下，我们应该返回1
- en: Paying any positive amount of dollars isn't possible if no bills are provided,
    so in this case, also return 0
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有提供任何票据，则无法支付任何正数金额的美元，因此在这种情况下也返回0
- en: 'Finally, we can answer the question: in how many ways can we pay `N` dollars
    with a given set of bills? We can consider two cases: we do not use the larger
    bill at all and pay the amount using only smaller denomination bills, or we can
    take one bill of the larger amount, and reconsider the question. (Let''s forget
    the avoidance of repeated calculations for now.)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以回答这个问题：用给定的票据集合，我们可以用多少种方式支付`N`美元？我们可以考虑两种情况：我们根本不使用更大的票据，只使用较小面额的票据支付金额，或者我们可以拿一张更大金额的票据，并重新考虑这个问题。（现在让我们忘记避免重复计算。）
- en: In the first case, we should invoke our supposedly existing function with the
    same value of `N`, but have pruned the largest bill denomination from the list
    of available bills
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第一种情况下，我们应该使用相同的`N`值调用我们假定存在的函数，但已经从可用票据列表中删除了最大面额的票据
- en: 'In the second case, we should invoke our function with `N` minus the largest
    bill denomination, keeping the list of bills the same:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们应该使用`N`减去最大面额的票据调用我们的函数，保持票据列表不变：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, let''s do some optimizing. This algorithm often needs to re-calculate
    the same values over and over. (To verify this, add `console.log(n, bills.length)`
    as the first line in `makeChange()` -- but be ready for plenty of output!) But,
    we already have a solution for this: memoization! Since we are applying this technique
    to a binary function, we''ll need a version of the memoization algorithm that
    deals with more than one parameter:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们进行一些优化。这种算法经常需要一遍又一遍地重新计算相同的值。（要验证这一点，在`makeChange()`的第一行添加`console.log(n,
    bills.length)`，但要准备大量的输出！）但是，我们已经有了解决方案：记忆化！由于我们正在将这种技术应用于二元函数，我们将需要一个处理多个参数的记忆化算法的版本：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The memoized version of `makeChange()` is far more efficient, and you can verify
    it with logging. While it is certainly possible to deal with the repetitions by
    yourself (for example, by keeping an array of already computed values), the memoization
    solution is, in my opinion, better, because it composes two functions to produce
    a better solution for the given problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeChange()`的记忆化版本要高效得多，您可以通过记录来验证。虽然您可以自己处理重复（例如，通过保留已计算的值的数组），但是记忆化解决方案在我看来更好，因为它由两个函数组合产生了给定问题的更好解决方案。'
- en: Higher order functions revisited
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数再探讨
- en: Classic FP techniques do not use iteration at all, but work exclusively with
    recursion as the only way to do some looping. Let's revisit some of the functions
    that we already saw in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),
    *Programming Declaratively - A Better Style*, such as `map()`, `reduce()`, `find()`,
    and `filter()`, to see how we can make do with the only recursion.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的FP技术根本不使用迭代，而是完全依赖递归作为唯一的循环方式。让我们重新审视一些我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中已经看到的函数，如`map()`、`reduce()`、`find()`和`filter()`，看看我们如何只使用递归就能完成。
- en: 'We are not planning to exchange the basic JS functions for ours, though: it''s
    highly likely that performance will be worse for our *recursive polyfills* and
    we won''t derive any advantages just from having the functions use recursion.
    Rather, we want to study how iterations are performed in a recursive way, so our
    efforts are more pedagogical than practical, OK?'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们并不打算用我们自己的*递归polyfills*替换基本的JS函数：很可能我们的性能会比*递归polyfills*差，而且我们不会因为函数使用递归而获得任何优势。相反，我们想研究如何以递归方式执行迭代，因此我们的努力更多是教学性的，好吗？
- en: Mapping and filtering
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 映射和过滤
- en: Mapping and filtering are quite similar, insofar both imply going through all
    the elements in an array and applying a callback to each to produce output. Let's
    work out first the mapping logic, which will have several points to solve, and
    then filtering will become almost trivially easy, requiring just small changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 映射和过滤非常相似，因为两者都意味着遍历数组中的所有元素，并对每个元素应用回调以产生输出。让我们首先解决映射逻辑，这将有几个要解决的问题，然后过滤将变得几乎轻而易举，只需要做一些小改动。
- en: 'For mapping, according to the way we are using to develop recursive functions,
    we need a base case. Fortunately, that''s easy: mapping an empty array just produces
    a new empty array. Mapping a non-empty array can be done by first applying the
    mapping function to the first element of the array, then recursively mapping the
    rest of the array, and finally producing a single array accumulating both results.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射，根据我们使用的递归函数开发方式，我们需要一个基本情况。幸运的是，这很容易：映射一个空数组只会产生一个新的空数组。映射一个非空数组可以通过首先将映射函数应用于数组的第一个元素，然后递归地映射数组的其余部分，最后产生一个累积两个结果的单一数组。
- en: 'Based on that idea, we can work out a simple initial version: let''s call it
    `mapR()` just to remember we are dealing with our own, recursive, version of `map()`.
    However, be careful: our polyfill has some bugs! We''ll deal with them one at
    a time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个想法，我们可以制定一个简单的初始版本：让我们称之为`mapR()`，只是为了记住我们正在处理我们自己的递归版本的`map()`。但是，要小心：我们的polyfill有一些错误！我们将逐个解决它们：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s test it out:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试一下：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Great! Our `mapR()` function seemingly produces the same results than `.map()`...
    but, shouldn't our callback function receive a couple more parameters, specifically
    the index at the array and the original array itself? Our implementation isn't
    quite ready yet.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的`mapR()`函数似乎产生了与`.map()`相同的结果...但是，我们的回调函数不应该接收更多的参数吗，特别是数组中的索引和原始数组本身？我们的实现还不够完善。
- en: 'Check out the definition for the callback function for `.map()` at: [https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`.map()`的回调函数的定义：[https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
- en: '[PRE12]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Generating the appropriate index position will require an extra parameter for
    the recursion, but is basically simple: when we start out, we have `index=0`,
    and when we call our function recursively, it''s starting at position `index+1`.
    Accessing the original array requires yet another parameter, which will never
    change:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 生成适当的索引位置将需要递归的额外参数，但基本上很简单：当我们开始时，我们有`index=0`，当我们递归调用我们的函数时，它从位置`index+1`开始。访问原始数组需要另一个参数，这个参数永远不会改变：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Great! When you do recursion instead of iteration, you don't have access to
    an index, so if you need it (as in our case), you'll have to generate it on your
    own. This is an often used technique, so working out our `.map()` substitute was
    a good idea.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！当你使用递归而不是迭代时，你就无法访问索引，所以如果你需要它（就像我们的情况一样），你就必须自己生成它。这是一种经常使用的技术，所以制定我们的`.map()`替代方案是一个好主意。
- en: 'However, having extra arguments in the function is not so good; a developer
    might accidentally provide them and then the results would be unpredictable. So,
    using another usual technique, let''s define an inner function, `mapLoop()`, to
    handle looping. This is, in fact, the usual way looping is achieved when you only
    use recursion:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，函数中有额外的参数并不是很好；开发人员可能会意外地提供它们，然后结果将是不可预测的。因此，使用另一种常用的技术，让我们定义一个内部函数`mapLoop()`来处理循环。实际上，这是唯一使用递归时实现循环的常规方式：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There''s only one pending issue: if the original array has some missing elements,
    they should be skipped during the loop:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一个未解决的问题：如果原始数组中有一些缺失的元素，在循环过程中它们应该被跳过：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Fortunately, fixing that is simple -- and be glad that all the experience gained
    here will help us write the other functions in this section!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，修复这个问题很简单——并且很高兴在这里获得的所有经验将帮助我们编写本节中的其他函数！
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wow! This was more than we bargained for, but we saw several techniques: replacing
    iteration with recursion, how to accumulate a result across iterations, how to
    generate and provide the index value -- good tips! Furthermore, writing filtering
    code will prove much easier, since we''ll be able to apply very much the same
    logic as for mapping. The main difference is that we use the callback function
    to decide whether an element goes into the output array, so the inner loop function
    is a tad longer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这比我们预期的要多得多，但我们看到了几种技巧：用递归替换迭代，如何在迭代中累积结果，如何生成和提供索引值——很好的建议！此外，编写过滤代码将会更容易，因为我们可以应用与映射几乎相同的逻辑。主要区别在于我们使用回调函数来决定元素是否进入输出数组，因此内部循环函数会稍微长一点：
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: OK, we managed to implement two of our basic higher-order functions with pretty
    similar recursive functions. What about others?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们成功实现了两个基本的高阶函数，使用了非常相似的递归函数。其他的呢？
- en: Other higher-order functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他高阶函数
- en: Programming `.reduce()` is, from the outset, a bit trickier, since you can decide
    to omit the initial value for the accumulator. Since we mentioned earlier that
    providing that value is generally better, let's work here under the assumption
    that it will be given; dealing with the other possibility wouldn't be too hard.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始，编写`.reduce()`就有点棘手，因为你可以决定省略累加器的初始值。既然我们之前提到提供该值通常更好，那么我们在这里假设它会被给出；处理其他可能性也不会太难。
- en: 'The base case is simple: if the array is empty, the result is the accumulator.
    Otherwise, we must apply the reduce function to the current element and the accumulator,
    update the latter, and then continue working with the rest of the array. This
    can be a bit confusing because of the ternary operators, but after all, we''ve
    seen, it should be clear enough:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 基本情况很简单：如果数组为空，结果就是累加器。否则，我们必须将reduce函数应用于当前元素和累加器，更新后者，然后继续处理数组的其余部分。这可能有点令人困惑，因为有三元运算符，但毕竟，我们已经看到了，应该足够清楚：
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On the other hand, `.find()` is particularly apt for recursive logic, since
    the very definition of how you (attempt to) find something, is recursive on its
    own:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`.find()`特别适用于递归逻辑，因为你（尝试）找到某物的定义本身就是递归的：
- en: You look at the first place you think of -- and if you find what you were seeking,
    you are done
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你首先看你想到的地方——如果你找到了你要找的东西，你就完成了
- en: Alternatively, you look at the other places, to see if what you seek is there
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你可以看看其他地方，看看你所寻找的东西是否在那里
- en: 'We are only missing the base case, but that''s simple: if you have no places
    left, where to look into, then you know you won''t be successful in your search:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只缺少基本情况，但那很简单：如果你没有地方可以查找，那么你知道你在搜索中不会成功：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Equivalently:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can quickly verify that it works:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以快速验证它的有效性：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's finish with our pipelining function. The definition of a pipeline lends
    itself to a quick implementation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们完成我们的管道函数。管道的定义本身适合快速实现。
- en: If we want to pipeline a single function, then that's the result of the pipeline
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要将单个函数串联起来，那么结果就是管道的结果
- en: Otherwise, if we want to pipeline several functions, then we must first apply
    the initial function, and then pass that result as input to the pipeline of the
    other functions
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果我们想要将几个函数串联起来，那么我们必须先应用初始函数，然后将该结果作为输入传递给其他函数的管道
- en: 'We can directly turn this into code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将这转化为代码：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can verify its correctness:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证它的正确性：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Doing the same for composition is easy, except that you cannot use the spread
    operator to simplify the function definition and you'll have to work with array
    indices - work it out!
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组合来说，做同样的事情很容易，只是你不能使用展开运算符来简化函数定义，而必须使用数组索引——自己解决吧！
- en: Searching and backtracking
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 搜索和回溯
- en: 'Searching for solutions to problems, especially when there is no direct algorithm
    and you must resort to trial-and-error, is particularly appropriate for recursion.
    Many of these algorithms fall into a scheme such as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找问题的解决方案，特别是当没有直接的算法，你必须诉诸反复试验时，递归特别适用。这些算法中的许多都属于这样的方案：
- en: Out of many choices available, pick one
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在众多可选项中，选择一个
- en: If no options are available, you've failed
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有其他选择，你就失败了
- en: If you could pick one, apply the same algorithm, but find a solution to the
    rest
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你能挑选一个，应用相同的算法，但找到其余部分的解决方案
- en: If you succeed, you are done
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你成功了，你就完成了
- en: Otherwise, try another choice
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，尝试另一个选择
- en: With small variants, you can also apply a similar logic to find a good--or possibly,
    optimum--solution to a given problem. Each time you find a possible solution,
    you match it with previous ones you might have found and decide which to keep.
    This may go on until all possible solutions have been evaluated, or until a good
    enough has been found.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微变种一下，你也可以应用类似的逻辑来找到一个好的——或者可能是最优的——解决方案。每当你找到一个可能的解决方案时，你都会将其与之前可能找到的解决方案进行匹配，并决定保留哪一个。这可能会一直持续下去，直到所有可能的解决方案都被评估，或者直到找到足够好的解决方案为止。
- en: 'There are many problems for which this logic applies:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多问题适用于这种逻辑：
- en: 'Finding a way out of mazes -- pick any path, mark it as *already followed*
    and try to find some way out of the maze that won''t re-use that path: if you
    succeed, you are done, and if not, go back to pick a different path'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到迷宫的出口——选择任何路径，标记为*已经跟随*，并尝试找到迷宫的出口，不要重复使用该路径：如果成功，你就完成了，如果没有，回去选择另一条路径
- en: Filling out Sudoku puzzles -- if an empty cell can contain only a single number,
    then assign it; otherwise, run through all of the possible assignments and, for
    each one, recursively try to see if the rest of the puzzle can be filled out
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充数独谜题——如果一个空单元格只能包含一个数字，那么分配它；否则，运行所有可能的分配，并对每一个进行递归尝试，看看是否可以填充谜题的其余部分
- en: Playing Chess -- where you aren't likely to be able to follow through all possible
    move sequences and so you rather opt for the best-estimated position
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下棋——你不太可能能够跟随所有可能的走法序列，所以你更愿意选择最佳估计的位置
- en: 'Let''s apply these techniques for two problems: solving the *8 Queens* puzzle
    and traversing a complete file directory.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这些技术应用于两个问题：解决*八皇后*问题和遍历完整的文件目录。
- en: The Eight Queens puzzle
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 八皇后问题
- en: The *Eight Queens* puzzle was invented in the XIX Century and requires placing
    eight chess queens on a standard chessboard. The special condition is that no
    queen may attack another -- implying that no pair of queens may share a row, column,
    or diagonal line. The puzzle may ask for any solution or, as we shall do it, for
    the total number of distinct solutions.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*八皇后*问题是在19世纪发明的，需要在标准国际象棋棋盘上放置八个国际象棋皇后。特殊条件是没有皇后可以攻击另一个——这意味着没有一对皇后可以共享一行、一列或对角线。这个谜题可能要求任何解决方案，或者，正如我们将要做的那样，要求不同解决方案的总数。'
- en: 'The puzzle may also be generalized to *n queens*, by working on an *nxn* square
    board. It is known that there are solutions for all values of n, except n=2 (pretty
    simple to see why: after placing one queen, all of the board is threatened) and
    n=3 (if you place a queen on the center, all of the board is threatened, and if
    you place a queen on a side, only two squares are unthreatened--but they threaten
    each other, making it impossible to place queens on them).'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个谜题也可以推广到*n皇后*，通过在*nxn*方格棋盘上工作。已知对于n的所有值都有解决方案，除了n=2（很容易看出为什么：放置一个皇后后，整个棋盘都受到威胁）和n=3（如果在中心放置一个皇后，整个棋盘都受到威胁，如果在一侧放置一个皇后，只有两个方块没有受到威胁--但它们互相威胁，这使得不可能在它们上面放置皇后）。
- en: 'Let''s start our solution with the top level logic. Because of the given rules,
    there will be a single queen in each column, so we use a `places()` array to take
    note of each queen''s row within the given column. The `SIZE` constant could be
    modified to solve a more general problem. We''ll count each found distribution
    of queens in the `solutions` variable. Finally, the `finder()` function will do
    the recursive search for solutions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶层逻辑开始解决我们的问题。由于给定的规则，每列中将有一个皇后，因此我们使用`places()`数组来记录每个皇后在给定列中的行。`SIZE`常量可以修改以解决更一般的问题。我们将在`solutions`变量中计算每个找到的皇后分布。最后，`finder()`函数将对解决方案进行递归搜索。
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we want to place a queen in a given row within a certain column, we must
    check if any of the previously placed queens was already placed on the same row,
    or in a diagonal with respect to it. Let''s write a `checkPlace(column, row)`
    function to verify if a queen can be safely placed in the given square. The most
    straightforward way is by using `.every()`, as in the following code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想在某一列的特定行放置一个皇后时，我们必须检查之前放置的任何一个皇后是否已经放在了同一行或对角线上。让我们编写一个`checkPlace(column,
    row)`函数来验证是否可以安全地在给定方块中放置皇后。最直接的方法是使用`.every()`，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This declarative fashion seems best: when we place a queen in a position, we
    want to make sure that every other previously placed queen is in a different row
    and diagonals. A recursive solution would have been possible, too, so let''s see
    that. How do we know that a square is safe?'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这种声明式的方式似乎是最好的：当我们在一个位置放置一个皇后时，我们希望确保每个先前放置的皇后都在不同的行和对角线上。递归解决方案也是可能的，所以让我们看看。我们怎么知道一个方块是安全的？
- en: 'A base case is: when there are no more columns to check, the square is safe'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本情况是：当没有更多的列可以检查时，方块是安全的
- en: If the square is in the same row or diagonal as any other queen, it's not safe
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方块与任何其他皇后在同一行或对角线上，那么它是不安全的
- en: 'If we have checked a column, and found no problem, we can recursively now check
    the following one:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们已经检查了一列，并且没有问题，我们现在可以递归地检查下一列：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The code works, but I wouldn''t be using that since the declarative version
    is clearer. Anyway, having worked out this check, we can pay attention to the
    main `finder()` logic, which will do the recursive search. The process proceeds
    as we described at the beginning: trying out a possible placement for a queen,
    and if that is acceptable, using the same search procedure to try and place the
    remaining queens. We start at column 0, and our base case is when we reach the
    last column, meaning that all queens have been successfully placed: we can print
    out the solution, count it, and go back to search for a new configuration.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以运行，但我不会使用它，因为声明版本更清晰。无论如何，经过这个检查，我们可以关注主`finder()`逻辑，它将进行递归搜索。过程如我们在开始时描述的那样进行：尝试为皇后找到可能的位置，如果可以接受，使用相同的搜索过程尝试放置剩余的皇后。我们从第0列开始，我们的基本情况是当我们到达最后一列时，这意味着所有皇后都已成功放置：我们可以打印出解决方案，计数它，并返回搜索新的配置。
- en: Check out how we use `.map()` and a simple arrow function to print the rows
    of the queens, column by column, as numbers between 1 and 8, instead of 0 and
    7\. In Chess, rows are numbered from 1 to 8 (and columns from *a* to *h*, but
    that doesn't matter here).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何使用`.map()`和一个简单的箭头函数来打印皇后的行，逐列，作为1到8之间的数字，而不是0到7。在国际象棋中，行编号从1到8（列从*a*到*h*，但这里并不重要）。
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The inner `testRowsInColumn()` function also fulfills an iterative role, but
    recursively. The idea is to attempt placing a queen in every possible row, starting
    at zero: if the square is safe, `finder()` is called to start searching from the
    next column onward. No matter whether a solution was or wasn''t found, all rows
    in the column are tried out, since we are interested in the total number of solutions;
    in other search problems, you might be content with finding just any solution
    and you would stop your search right there.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`testRowsInColumn()`函数也起到了迭代的作用，但是是递归的。想法是尝试在每一行放置一个皇后，从零开始：如果方块是安全的，就调用`finder()`从下一列开始搜索。无论是否找到解决方案，都会尝试列中的所有行，因为我们对解决方案的总数感兴趣；在其他搜索问题中，您可能只对找到任何解决方案感兴趣，并且会在那里停止搜索。
- en: We have come this far, let's find the answer to our problem!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经走到了这一步，让我们找到我们问题的答案！
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Each solution is given as the row positions for the queens, column by column
    -- and there are 92 solutions in all.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个解决方案都是以皇后的行位置，逐列给出的--总共有92个解决方案。
- en: Traversing a tree structure
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历树结构
- en: 'Data structures, which include recursion in their definition, are naturally
    appropriate for recursive techniques. Let''s consider here, for example, how to
    traverse a complete file system directory, listing all of its contents. Where''s
    the recursion? The answer follows if you consider that each directory can do either
    of the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 数据结构，其中包括递归在其定义中，自然适合递归技术。让我们在这里考虑一个例子，例如如何遍历完整的文件系统目录，列出其所有内容。递归在哪里？如果您考虑到每个目录都可以执行以下操作之一，答案就会出现：
- en: Be empty -- a base case, in which there's nothing to do
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为空--一个基本情况，在这种情况下，没有任何事情要做
- en: Include one or more entries, each of which is either a file or a directory itself
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括一个或多个条目，每个条目都是文件或目录本身
- en: 'Let''s work out a full recursive directory listing -- meaning, when we encounter
    a directory, we proceed to also list its contents and, if those include more directories,
    we also list them, and so on. We''ll be using the same Node.js functions as in
    `getDir()` (from the *Building Pipelines by Hand* section in [Chapter 8](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml),
    *Connecting Functions - Pipelining And Composition*), plus a few more in order
    to test whether a directory entry is a symbolic link (which we won''t follow,
    to avoid possible infinite loops), a directory (which will require a recursive
    listing), or a common file:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解决一个完整的递归目录列表--也就是说，当我们遇到一个目录时，我们继续列出它的内容，如果其中包括更多的目录，我们也列出它们，依此类推。我们将使用与`getDir()`中相同的Node.js函数（来自[第8章](8e0f575a-87f7-4601-b47c-6872aaacb954.xhtml)中的*手动构建管道*部分，*连接函数-管道和组合*），再加上一些函数，以便测试目录条目是否是符号链接（我们不会跟随它，以避免可能的无限循环），目录（这将需要递归列表）或普通文件：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The listing is long but correct. I opted to list the `/boot` directory in my
    own OpenSUSE Linux laptop:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表很长，但是正确的。我选择在我自己的OpenSUSE Linux笔记本电脑上列出`/boot`目录：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'By the way, we may apply the same structure to a similar problem: traversing
    a DOM structure. We could list all of the tags, starting from a given element,
    by using essentially the same approach: we list a node, and (by applying the same
    algorithm) all of its children. The base case is also the same as before: when
    a node has no children, no more recursive calls are done:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们可以将相同的结构应用于类似的问题：遍历DOM结构。我们可以从给定元素开始列出所有标签，使用基本相同的方法：我们列出一个节点，然后（通过应用相同的算法）列出它的所有子节点。基本情况也与以前相同：当一个节点没有子节点时，不再进行递归调用：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We are using the `depth` variable to know how many *levels below* the original
    element we are. We could also use it to make the traversing logic stop at a certain
    level, of course; in our case, we are using it only to add some bars and spaces
    to appropriately indent each element, according to its place in the DOM hierarchy.
    The result of this function is as follows. It would be easy to list more information
    and not just the element tag, but I wanted to focus on the recursive process:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`depth`变量来知道我们距离原始元素有多少*级别。当然，我们也可以使用它来使遍历逻辑在某个级别停止；在我们的情况下，我们只是使用它来添加一些竖线和空格，以适当地缩进每个元素，根据其在DOM层次结构中的位置。这个函数的结果如下。很容易列出更多的信息，而不仅仅是元素标签，但我想专注于递归过程：
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'However, there''s an ugly point there: why are we doing a loop to go through
    all of the children? We should know better! The problem is that the structure
    we get from the DOM isn''t really an array. However, there''s a way out: we can
    use `Array.from()` to create a real array out of it, and then write a more declarative
    solution:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个丑陋的地方：为什么我们要循环遍历所有子节点？我们应该更了解！问题在于我们从DOM中得到的结构实际上并不是一个数组。但是，有一个办法：我们可以使用`Array.from()`将其创建为一个真正的数组，然后编写一个更具声明性的解决方案：
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Writing `[...node.children].forEach()` would have worked as well, but I think
    using `Array.from()` makes it clearer to the would-be reader that we are trying
    to make an array out of something that looks like one, but really isn't.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 写`[...node.children].forEach()`也可以工作，但我认为使用`Array.from()`可以更清楚地告诉潜在的读者，我们试图从看起来像数组的东西中创建一个数组，但实际上并不是。
- en: Recursion techniques
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归技术
- en: While recursion is a very good technique, it may face some problems due to details
    in the actual implementations. Each function call, recursive or not, requires
    an entry in the internal JS stack. When you are working with recursion, each recursive
    call itself counts as another call and you might find some situations in which
    your code will crash and throw an error, due to having run out of memory, just
    because of multiple calls. On the other hand, with most current JS engines, you
    can probably have several thousand pending recursive calls without a problem (but
    with earlier browsers and smaller machines, the number could drop into the hundreds
    and could imaginably go even lower), so it could be argued that at present, you
    are not likely to suffer from any particular memory problems.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然递归是一种非常好的技术，但由于实际实现中的细节，它可能会遇到一些问题。每个函数调用，无论是递归还是非递归，都需要在内部JS堆栈中有一个条目。当您使用递归时，每个递归调用本身都计为另一个调用，您可能会发现在某些情况下，由于多次调用而导致代码崩溃并抛出错误，因为内存耗尽。另一方面，对于大多数当前的JS引擎，您可能可以有数千个待处理的递归调用而没有问题（但对于早期浏览器和较小的机器，这个数字可能会下降到数百，甚至可能更低），因此可以说，目前您不太可能遇到任何特定的内存问题。
- en: In any case, let's review the problem and go over some possible solutions because,
    even if you don't get to actually apply them, they represent valid FP ideas for
    which you may find place in yet other problems.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，让我们回顾一下问题，并讨论一些可能的解决方案，因为即使您可能无法真正应用它们，它们代表了有效的FP思想，您可能会在其他问题中找到它们的位置。
- en: Tail call optimization
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾调用优化
- en: 'When is a recursive call not a recursive call? Put in this way, the question
    may make little sense, but there''s a common optimization --for other languages,
    alas, but not JS!-- which explains the answer. If the recursive call is the very
    last thing a function will do, then the call could be transformed to a simple
    jump to the start of the function, without needing to create a new stack entry.
    (Why? The stack entry wouldn''t be required: after the recursive call is done,
    the function would have nothing else to do, so there was no need to further save
    any of the elements that had been pushed into the stack on entering the function.)
    The original stack entry would then no longer be needed and could simply be replaced
    by a new one, corresponding to the recent call.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用何时不是递归调用？以这种方式提出问题可能没有多少意义，但有一个常见的优化--对于其他语言来说，不幸的是，但不适用于JS！--可以解释答案。如果递归调用是函数将要执行的最后一件事，那么调用可以转换为简单地跳转到函数的开始，而无需创建新的堆栈条目。（为什么？不需要堆栈条目：在递归调用完成后，函数将没有其他事情要做，因此无需进一步保存进入函数时推入堆栈的任何元素。）原始堆栈条目将不再需要，可以简单地替换为新的堆栈条目，对应于最近的调用。
- en: The fact that a recursive call, a quintessential FP technique, is being implemented
    by a base imperative `GO TO` statement, may be considered an ultimate irony!
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用，作为典型的FP技术，被一个基本的命令式`GO TO`语句实现，这可能被认为是一个终极的讽刺！
- en: These calls are known as *tail calls* (for obvious reasons) and imply higher
    efficiency, not only because of the saved stack space, but also because a jump
    is quite faster than any alternative. If the browser implements this enhancement,
    it is doing a *Tail Call Optimization*, or TCO for short. However, a glance at
    compatibility tables at [http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)
    shows that now (mid-2017), the only browser that provides TCO is Safari.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些调用被称为*尾调用*（理由很明显），并且意味着更高的效率，不仅因为节省了堆栈空间，而且因为跳转比任何其他替代方案都要快得多。如果浏览器实现了这个增强功能，它就是在进行*尾调用优化*，简称TCO。然而，查看[http://kangax.github.io/compat-table/es6/](http://kangax.github.io/compat-table/es6/)上的兼容性表，现在（2017年中）唯一提供TCO的浏览器是Safari。
- en: '![](assets/d80bc118-3f87-4478-b8e2-9291a1c7361a.png)Figure 9.3\. To understand
    this joke, you must previously understand it!'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/d80bc118-3f87-4478-b8e2-9291a1c7361a.png)图9.3。要理解这个笑话，你必须事先理解它！'
- en: '(Note: this XKCD comic is available online at https://xkcd.com/1270/.)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: （注意：这张XKCD漫画可以在https://xkcd.com/1270/上在线获取。）
- en: 'There''s a simple (though non-standard) test that lets you to verify if your
    browser provides TCO. (I found this snippet of code at several places on the web,
    but I''m sorry to say I cannot attest to the original author. However, I believe
    it is Csaba Hellinger, from Hungary.) Calling `detectTCO()` lets you know if your
    browser does or does not use TCO:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单（虽然非标准）的测试，可以让您验证您的浏览器是否提供TCO。（我在网上的几个地方找到了这段代码片段，但很抱歉我不能证明原作者。不过，我相信这是来自匈牙利的Csaba
    Hellinger。）调用`detectTCO()`可以让您知道您的浏览器是否使用TCO：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `Error().stack` result is not a JS standard, but modern browsers support
    it, albeit in somewhat different ways. In any case, the idea is that when a function
    with a long name calls another function with a shorter name, the stack trace:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error().stack`的结果不是JS标准，但现代浏览器支持它，尽管方式有些不同。无论如何，这个想法是，当一个名字很长的函数调用另一个名字较短的函数时，堆栈跟踪：'
- en: Should get shorter if the browser implements TCO, since the old entry for the
    longer named function would be replaced with the entry for the shorter named one
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果浏览器实现了TCO，堆栈应该会变短，因为较长命名函数的旧条目将被较短命名函数的条目替换
- en: Should get longer without TCO, since a complete new stack entry would be created,
    without doing away with the original one
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有TCO，堆栈应该变长，因为会创建一个完全新的堆栈条目，而不会消除原始的条目
- en: 'I''m using Chrome at my Linux laptop and I added a `console.log()` statement
    to show `Error().stack`. You can see that both stack entries (for `inner()` and
    `detectTCO()`) are *live*, so there''s no TCO:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我在我的Linux笔记本上使用Chrome，并添加了一个`console.log()`语句来显示`Error().stack`。您可以看到`inner()`和`detectTCO()`的两个堆栈条目都是*活动的*，所以没有TCO：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Of course, there''s also another way of learning if your environment includes
    TCO: just try out the following function, which does nothing, with large enough
    numbers. If you manage to run it with numbers like, say, 100,000 or 1,000,000,
    you may be fairly sure that your JS engine is doing TCO!'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有另一种方法可以了解您的环境是否包括TCO：尝试运行以下函数，它什么也不做，使用足够大的数字。如果您能够使用100,000或1,000,000这样的数字运行它，您可能相当确定您的JS引擎正在执行TCO！
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Let's finish this section with a very short quiz, to be sure we understand what
    tail calls are. Is the recursive call in the factorial function that we saw in
    [Chapter 1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional-
    Several Questions*, a tail call?
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简短的测验来结束这一节，以确保我们理解了什么是尾调用。我们在[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)中看到的阶乘函数中的递归调用是否是尾调用？
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Think about it, because the answer is important! You might be tempted to answer
    in the affirmative, but the correct answer is a *no*. There''s good reason for
    this, and it''s a key point: after the recursive call is done, and the value for
    `fact(n-1)` has been calculated, the function *still* has work to do. (So, doing
    the recursive call wasn''t actually the last thing the function would do.) You
    would see it more clearly if you wrote the function in this equivalent way:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好好想想，因为答案很重要！您可能会倾向于肯定回答，但正确答案是*不是*。这有很好的理由，这是一个关键点：在递归调用完成之后，`fact(n-1)`的值已经被计算出来，函数*仍然*有工作要做。（因此，递归调用实际上不是函数将要做的最后一件事。）如果您用等价的方式编写函数，您会更清楚地看到它：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'So... the takeaways from this section should be two: TCO isn''t usually offered
    by browsers, and even if it were, you may not take advantage of it if your calls
    aren''t actual tail calls. Now that we know what the problem is, let''s see some
    FP ways of working around it!'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 所以...这一节的要点应该有两个：TCO通常不被浏览器支持，即使支持，如果您的调用不是实际的尾调用，您也可能无法利用它。既然我们知道问题所在，让我们看看一些FP解决方法！
- en: Continuation passing style
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继续传递风格
- en: If we have recursive calls stacked too high, we already know that our logic
    will fail. On the other hand, we know that tail calls should alleviate that problem...
    but don't, because of browser implementations! However, there's a way out for
    this. Let's first consider how we can transform recursive calls into tail calls,
    by using a well-known FP concept, *continuations*, and we'll leave the problem
    of solving TCO limitations for the next section. (We mentioned continuations in
    the *Callbacks, promises, and continuations* section of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml),
    *Starting Out With Functions - A Core Concept*, but we didn't go into detail at
    that point.)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的递归调用堆栈太高，我们已经知道我们的逻辑会失败。另一方面，我们知道尾调用应该缓解这个问题...但是，由于浏览器的实现，它并没有，但是有一种解决方法。让我们首先考虑如何将递归调用转换为尾调用，使用一个众所周知的FP概念，*continuations*，并且我们将在下一节解决TCO限制的问题。（我们在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*回调，承诺和continuations*部分提到了continuations，但当时我们没有详细讨论。）
- en: In FP parlance, a *continuation* is something that represents the state of a
    process and allows processing to continue. This may be too abstract, so let's
    get down to earth for our needs. The key idea is that, when you call a function,
    you also provide it with a continuation (in reality, a simple function) which
    will be called at return time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP术语中，*continuation*是表示进程状态并允许处理继续的东西。这可能太抽象了，所以让我们为我们的需求实际一些。关键思想是，当你调用一个函数时，你也会提供一个继续函数（实际上是一个简单的函数），它将在返回时被调用。
- en: 'Let''s see a trivial example. Suppose you have a function that returns the
    time of the day, and you want to show that on the console. The usual way to do
    it could be as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的例子。假设你有一个返回当天时间的函数，并且你想在控制台上显示出来。通常的做法可能如下：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'If you were doing CPS (**Continuation Passing Style**), you would pass a continuation
    to the `getTime()` function. Instead of returning a calculated value, the function
    would invoke the continuation, giving it the value as a parameter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用CPS（**Continuation Passing Style**），你会将一个继续函数传递给`getTime()`函数。函数不会返回计算出的值，而是会调用继续函数，将值作为参数传递给它：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'What''s the difference? The key is that we can apply this mechanism to make
    a recursive call into a tail call because all of the code *that comes after* will
    be provided in the recursive call itself. To make this clear, let''s revisit the
    factorial function, in the version that made it explicit that we weren''t doing
    tail calls:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么不同？关键在于我们可以应用这种机制将递归调用转换为尾调用，因为所有*之后的*代码都将在递归调用本身中提供。为了澄清这一点，让我们重新看一下阶乘函数，在明确表示我们没有进行尾调用的版本中：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We will add a new parameter to the function, for the continuation. What do
    we do with the result of the `fact(n-1)` call? We multiply it by `n`, so let''s
    provide a continuation that will do just that. I''ll rename the factorial function
    to `factC()` to make it clear we are working with continuations:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为函数添加一个新的参数，用于继续函数。对于`fact(n-1)`调用的结果我们该怎么办？我们将它乘以`n`，所以让我们提供一个将这样做的继续函数。我将阶乘函数重命名为`factC()`，以明确表示我们正在使用继续函数：
- en: '[PRE42]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'How would we get the final result? Easy: we can call `factC()` with a continuation
    that will just return whatever it''s given:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何得到最终结果？很简单：我们可以用一个继续函数调用`factC()`，这个继续函数将返回它所给出的任何东西：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In FP, a function that returns its argument as result is usually called `identity()`
    for obvious reasons. In combinatory logic (which we won't be using), we would
    speak of the **I** combinator.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在FP中，一个返回其参数作为结果的函数通常被称为`identity()`，原因是显而易见的。在组合逻辑中（我们不会使用），我们会谈到**I**组合子。
- en: 'Can you understand how it worked? Let''s then go for a more complex case, with
    the Fibonacci function, which has *two* recursive calls in it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你能理解它是如何工作的吗？那么我们来看一个更复杂的例子，使用斐波那契函数，其中有*两个*递归调用：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is trickier: we call `fibC()` with `n-2`, and a continuation that says
    that whatever that call returned, then, call `fibC()` with `n-1`, and when *that*
    call returns, then sum the results of both calls and pass that result to the original
    continuation.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这更加棘手：我们用`n-2`调用`fibC()`，并且一个继续函数表示无论那个调用返回了什么，然后调用`fibC()`用`n-1`，当*那个*调用返回时，然后将这两个调用的结果相加并将结果传递给原始的继续函数。
- en: 'Let''s just see one more example, one that involves a loop with an undefined
    number of recursive calls, and by then, you should have some idea about how to
    apply CPS to your code -- though I''ll readily admit, it can become really complex!
    We saw this function in the *Traversing a Tree Structure*section earlier in this
    chapter. The idea was to print out the DOM structure, like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看一个例子，涉及一个未定义数量的递归调用的循环，到那时，你应该对如何将CPS应用到你的代码有一些想法--尽管我愿意承认，它可能变得非常复杂！我们在本章的*遍历树结构*部分中已经看到了这个函数。这个想法是打印出DOM结构，就像这样：
- en: '[PRE45]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The function we ended designing was the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终设计的函数如下：
- en: '[PRE46]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Let''s start by making this fully recursive, getting rid of the `forEach()`
    loop. We have seen this technique before, so we can just move on to the result:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从完全递归开始，摆脱`forEach()`循环。我们之前已经看过这种技术，所以我们可以直接转向结果：
- en: '[PRE47]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, we have to add a continuation to `traverseDom3()`. The only difference
    with the previous cases is that the function doesn''t return anything, so we won''t
    be passing any arguments to the continuation. Also, it''s important to remember
    the implicit `return` at the end of the `traverseChildren()` loop: we must call
    the continuation:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要给`traverseDom3()`添加一个继续函数。与之前的情况唯一的区别是这个函数不返回任何东西，所以我们不会给继续函数传递任何参数。另外，重要的是要记住`traverseChildren()`循环结束时的隐式`return`：我们必须调用继续函数：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We opted to give a default value to `cont`, so we can simply call `traverseDom3C(document.body)`
    as before. If we try out this logic, it works -- but the problem with the potential
    high number of pending calls hasn't been solved; let's look for a solution for
    that now.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择给`cont`一个默认值，所以我们可以像之前一样简单地调用`traverseDom3C(document.body)`。如果我们尝试这种逻辑，它可以工作--但潜在的大量待处理调用的问题还没有解决；现在让我们寻找一个解决方案。
- en: Trampolines and thunks
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳板和thunks
- en: For the last key to our problem, we shall have to think about the cause of the
    problem. Each pending recursive call creates a new entry stack. Whenever the stack
    gets too empty, the program crashes and your algorithm is history. So, if we can
    work out a way to avoid the stack growth, we should be free. The solution, in
    this case, is quite sonorous and requires thunks and a trampoline -- let's see
    what these are!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们问题的最后一个关键点，我们必须考虑问题的原因。每个待处理的递归调用都会创建一个新的堆栈条目。每当堆栈变得太空，程序就会崩溃，你的算法也就结束了。因此，如果我们能找到一种避免堆栈增长的方法，我们就可以自由了。在这种情况下，解决方案相当响亮，需要thunks和一个跳板--让我们看看这些是什么！
- en: 'First, a *thunk* is really quite simple: it''s just a nullary function (so,
    with no parameters) that helps delay a computation, providing for a form of *lazy
    evaluation*. If you have a thunk, unless you call it, you won''t get its value.
    For example, if you want to get the current date and time in ISO format, you could
    get it with `new Date().toISOString()`. However, if you provide a thunk that calculates
    that, you won''t get the value until you actually invoke it.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*thunk*真的很简单：它只是一个无参数的函数（所以，没有参数），它有助于延迟计算，提供了一种*惰性评估*的形式。如果你有一个thunk，除非你调用它，否则你不会得到它的值。例如，如果你想要以ISO格式获取当前日期和时间，你可以用`new
    Date().toISOString()`得到它。然而，如果你提供一个计算它的thunk，你在实际调用它之前不会得到值。
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What's the use of this? The problem with recursion is that a function calls
    itself, and calls itself, and calls itself, and so on until the stack blows over.
    Instead of directly calling itself, we are going to have the function return a
    thunk -- which, when executed, will actually recursively call the function. So,
    instead of having the stack grow more and more, it will actually be quite flat,
    since the function will never get to actually call itself -- the stack will grow
    by one position, when you call the function, and then get back to its size, as
    soon as the function returns its thunk.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么用呢？递归的问题在于一个函数调用它自己，然后调用它自己，然后调用它自己，依此类推，直到堆栈溢出。我们不是直接调用它自己，而是让函数返回一个thunk——当执行时，实际上会递归调用函数。所以，堆栈不会越来越多地增长，它实际上会相当平坦，因为函数永远不会真正调用它自己——当你调用函数时，堆栈会增加一个位置，然后在函数返回它的thunk时，堆栈会恢复到原来的大小。
- en: But... who gets to do the recursion? That's where the concept of a *trampoline*
    gets in. A trampoline is just a loop that calls a function, gets its return, and
    if it is a thunk, then it calls it, so recursion will proceed -- but in a flat,
    linear, way! The loop is exited when the thunk evaluation returns an actual value,
    instead of a new function.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 但是...谁来做递归呢？这就是*蹦床*的概念介入的地方。蹦床只是一个调用函数的循环，获取它的返回值，如果它是一个thunk，那么它就调用它，所以递归将继续进行——但是以一种平坦、线性的方式！当thunk评估返回一个实际值时，循环退出，而不是一个新的函数。
- en: '[PRE50]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: How can we apply this to an actual function? Let's start with a simple one,
    that just sums all numbers from 1 to n, but in a recursive, guaranteed-to-cause-stack-crash,
    fashion.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将这个应用到一个实际的函数？让我们从一个简单的函数开始，它只是递归地求和从1到n的所有数字，但以一种保证会导致堆栈崩溃的方式。
- en: '[PRE51]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The stack problem will come up sooner or later depending on your machine, your
    memory size, and so on, but it will come, no doubt about that. Let's rewrite the
    function in continuation passing style, so it will become tail recursive.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈问题将根据你的机器、内存大小等的不同，迟早会出现，但它肯定会出现。让我们以延续传递风格重写函数，这样它将变成尾递归。
- en: '[PRE52]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s apply a simple rule: whenever you are going to return from a call,
    instead return a thunk that will, when executed, do the call that you actually
    wanted to do.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用一个简单的规则：每当你要从一个调用中返回时，而不是返回一个thunk，当执行时，它将执行你实际想要执行的调用。
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Whenever there would have been a call to a function, we now return a thunk.
    How do we get to run this function? This is the missing detail. You need an initial
    call that will invoke `sumAllT()` a first time and (unless the function was called
    with a zero argument) a thunk will be immediately returned. The trampoline function
    will call the thunk, and that will cause a new call, and so on until we eventually
    get a thunk that simply returns a value, and then the calculation will be ended.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每当应该调用一个函数时，我们现在返回一个thunk。我们如何运行这个函数？这是缺失的细节。你需要一个初始调用，它将首次调用`sumAllT()`，并且（除非函数是用零参数调用的）会立即返回一个thunk。蹦床函数将调用thunk，这将导致一个新的调用，依此类推，直到最终得到一个简单返回值的thunk，然后计算将结束。
- en: '[PRE54]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In fact, you wouldn''t probably want a separate `sumAllT()` function, so you''d
    go for something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可能不想要一个单独的`sumAllT()`函数，所以你可以选择这样的方式：
- en: '[PRE55]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'There''s only one problem left: what would we do if the result of our recursive
    function wasn''t a value, but rather a function? The problem there would be on
    the `trampoline()` code that, as long as the result of the thunk evaluation is
    a function, goes back again and again to evaluate it. The simplest solution would
    be to return a thunk, but wrapped in an object:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只剩下一个问题：如果我们递归函数的结果不是一个值，而是一个函数，我们该怎么办？问题在于`trampoline()`代码，只要thunk评估的结果是一个函数，它就会一次又一次地返回。最简单的解决方案是返回一个thunk，但包装在一个对象中：
- en: '[PRE56]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The difference now would be that, instead of returning a thunk, you'd write
    something as `return (v) => new Thunk(() => cont(v+n))`, so our new trampolining
    function can now distinguish an actual thunk (meant to be invoked and executed)
    from any other kind of result (meant to be returned).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的区别在于，你不再返回一个thunk，而是写成`return (v) => new Thunk(() => cont(v+n)`，所以我们的新蹦床函数现在可以区分一个实际的thunk（意味着要被调用和执行）和任何其他类型的结果（意味着要被返回）。
- en: 'So, if you happen to have a really complex algorithm, for which a recursive
    solution is best, but that won''t run because of stack limits, you can fix it
    in a reasonable way by:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你碰巧有一个非常复杂的算法，递归解决方案是最好的，但由于堆栈限制而无法运行，你可以通过一个合理的方式来修复它：
- en: Changing all recursive calls to tail recursion, by using continuations.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用延续，将所有递归调用改为尾递归。
- en: Replacing all return statements so they'll return thunks.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换所有的返回语句，使它们返回thunk。
- en: Replacing the call to the original function with a trampoline call, to start
    the calculations.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用蹦床调用替换对原始函数的调用，以开始计算。
- en: Of course, this doesn't come free. You'll notice that, when using this mechanism,
    there's extra work involving returning thunks, evaluating them, and so on, so
    you can expect the total time to go up. Nonetheless, this is a cheap price to
    pay if the alternative is having a non-working solution to a problem!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是免费的。你会注意到，当使用这种机制时，会有额外的工作涉及返回thunk，评估它们，等等，所以你可以期待总时间增加。尽管如此，这是一个便宜的代价，如果另一种选择是有一个不能工作的问题解决方案！
- en: Recursion elimination
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归消除
- en: 'There''s yet one other possibility you might want to explore, but that falls
    beyond the realm of FP, and rather into algorithm design. It''s a computer science
    fact that any algorithm that is implemented using recursion has an equivalent
    version that doesn''t use recursion at all and rather depends on a stack. There
    are ways to systematically transform recursive algorithms into iterative ones,
    so if you run out of all options (meaning: not even continuations or thunks help
    you) then you''d have a final opportunity, by replacing all recursion with iteration.
    We won''t be getting into it --as I said, this elimination has little to do with
    FP-- but it''s important to know that the tool exists and you might be able to
    use it.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种可能性你可能想探索，但这超出了FP的范围，而是算法设计的范畴。计算机科学事实是，任何使用递归实现的算法都有一个不使用递归而完全依赖于堆栈的等价版本。有方法可以将递归算法系统地转换为迭代算法，因此，如果你耗尽了所有选项（意思是：甚至连continuations或thunks也无法帮助你），那么你将有最后的机会，通过用迭代替换所有递归。我们不会深入讨论它--正如我所说的，这种消除与FP关系不大--但重要的是要知道这个工具存在，你可能能够使用它。
- en: Questions
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 9.1\. **Into reverse**. Can you program a `reverse()` function, but implement
    it in a recursive fashion? Obviously, the best way to go about this would be using
    the standard String `.reverse()` method, as detailed in [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse),
    but that wouldn't do as a question on recursion, would it...?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 9.1\. **逆转**。你能以递归的方式编写一个`reverse()`函数吗？显然，最好的方法是使用标准的String`.reverse()`方法，如[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse)中详细说明的，但这不适合作为递归问题的问题，是吗...？
- en: 9.2\. **Climbing steps**. Suppose you want to climb up a ladder with *n* steps.
    At each time, you may opt to take 1 or 2 steps. In how many different ways can
    you climb up that ladder? As an example, you may climb a four steps ladder in
    five different ways.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 9.2\. **爬楼梯**。假设你想要爬一个有*n*步的梯子。每次，你可以选择走1步或2步。你可以以多少种不同的方式爬上那个梯子？例如，你可以用五种不同的方式爬上一个有四步的梯子。
- en: Always taking one step at a time
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是一次走一步
- en: Always taking two steps at a time
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是一次走两步
- en: Taking two steps first, then one, and again one
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先走两步，然后一步，再一步
- en: Taking one step first, then two, and then one
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先走一步，然后两步，再走一步
- en: Taking one step first, then another one, and finishing with two
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先走一步，然后再一步，最后两步
- en: '9.3\. **Longest common subsequence**. A classic dynamic programming problem
    is as follows: given two strings, find the length of the longest subsequence present
    in both of them. Be careful: we define a subsequence as a sequence of characters
    that appear in the same relative order but not necessarily next to each other.
    For example, the longest common subsequence of INTERNATIONAL and CONTRACTOR is
    N...T...R...A...T...O. Try it out with or without memoizing and see the difference!'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 9.3\. **最长公共子序列**。一个经典的动态规划问题如下：给定两个字符串，找到它们共同存在的最长子序列的长度。注意：我们将子序列定义为以相同相对顺序出现但不一定相邻的字符序列。例如，INTERNATIONAL和CONTRACTOR的最长公共子序列是N...T...R...A...T...O。尝试使用或不使用记忆化，看看有什么区别！
- en: 9.4\. **Symmetrical queens**. In the Eight Queens puzzle that we solved above,
    there is only one solution which shows symmetry in the placement of the queens.
    Can you modify your algorithm to find it?
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 9.4\. **对称皇后**。在我们上面解决的八皇后问题中，只有一个解决方案显示了皇后的摆放对称性。你能修改你的算法找到它吗？
- en: 9.5\. **Sorting recursively**. There are many sorting algorithms that can be
    described with recursion; can you implement them?
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 9.5\. **递归排序**。有许多可以用递归描述的排序算法；你能实现它们吗？
- en: '**Selection sort**: find the maximum element of the array, remove it, recursively
    sort the rest, and then push the maximum element at the end of the sorted rest'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择排序**：找到数组的最大元素，移除它，递归地对剩下的部分进行排序，然后将最大元素推到排序好的剩余部分的末尾'
- en: '**Insertion sort**: take the first element of the array; sort the rest; finish
    by inserting the removed element into its correct place in the sorted rest'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插入排序**：取数组的第一个元素；对剩下的部分进行排序；最后将移除的元素插入到排序好的剩余部分的正确位置'
- en: '**Merge sort**: divide the array into two parts; sort each one; finish by merging
    the two sorted parts into a sorted list'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**归并排序**：将数组分成两部分；对每一部分进行排序；最后将两个排序好的部分合并成一个排序好的列表'
- en: 9.6\. **Completing callbacks**. In our `findR()` function, we did not provide
    all possible parameters to the `cb()` callback. Can you fix that? Your solution
    should be along the lines of what we did for `map()` and other functions.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 9.6\. **完成回调**。在我们的`findR()`函数中，我们没有为`cb()`回调提供所有可能的参数。你能修复吗？你的解决方案应该沿用我们为`map()`和其他函数所做的方式。
- en: '9.7\. **Recursive logic**. We didn''t get to code `.every()` and `.some()`
    using recursion: can you do that?'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 9.7\. **递归逻辑**。我们没有使用递归编写`.every()`和`.some()`：你能做到吗？
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how we can use recursion, a basic tool in FP,
    as a powerful technique to create algorithms, for problems that would probably
    require far more complex solutions otherwise. We started by considering what is
    recursion and how to think recursively in order to solve problems, then moved
    on to see recursive solutions to several problems in different areas, and ended
    by analyzing potential problems with deep recursion and how to solve them.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经看到了如何使用递归，这是FP中的一种基本工具，作为一种强大的技术来创建算法，对于其他问题，可能需要更复杂的解决方案。我们首先考虑了什么是递归以及如何递归思考来解决问题，然后继续看到了不同领域中几个问题的递归解决方案，最后分析了深度递归可能出现的问题以及如何解决这些问题。
- en: In [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring Purity
    - Immutability*, we shall get back to a concept we saw earlier in the book, function
    purity, and see some techniques that will help us guarantee that a function won't
    do any side effects, by ensuring the immutability of arguments and data structures.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中，“确保纯净性 - 不可变性”，我们将回顾本书中早前提到的一个概念，即函数纯净性，并了解一些技术，这些技术将帮助我们确保函数不会产生任何副作用，通过确保参数和数据结构的不可变性。
