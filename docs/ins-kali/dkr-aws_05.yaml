- en: Publishing Docker Images Using ECR
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ECR发布Docker镜像
- en: Docker registries are a critical component of the Docker and container ecosystem,
    providing a universal mechanism to publish and distribute your container applications,
    both publicly and privately.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker注册表是Docker和容器生态系统的关键组件，提供了一种通用机制来公开和分发您的容器应用程序，无论是公开还是私有。
- en: The ECR provides a fully-managed private Docker registry that features tight
    integration with the ECS components introduced in the previous chapter and other
    AWS services. ECR is highly scalable, secure, and offers tooling to integrate
    with the native Docker client that is used to build and publish Docker images.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ECR提供了一个完全托管的私有Docker注册表，具有与上一章介绍的ECS组件和其他AWS服务紧密集成的特性。ECR具有高度可扩展性，安全性，并提供工具来与用于构建和发布Docker镜像的本机Docker客户端集成。
- en: In this chapter, you will learn how to create ECR repositories to store your
    Docker images, using a variety of mechanisms, including the AWS console, AWS CLI,
    and CloudFormation. Once you have established your first ECR repository, you will
    learn how to authenticate with ECR, pull Docker images stored in your repositories,
    and build and publish Docker images to ECR using the Docker client. To close out
    this chapter, you will learn how to deal with more advanced scenarios of using
    and managing ECR, including configuring cross-account access to allow Docker clients
    running in other AWS accounts access to your ECR repositories, and configuring
    lifecycle policies, which ensure orphaned Docker images are periodically cleaned
    up, reducing administrating effort and cost.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何创建ECR存储库来存储您的Docker镜像，使用各种机制，包括AWS控制台，AWS CLI和CloudFormation。一旦您建立了第一个ECR存储库，您将学习如何使用ECR进行身份验证，拉取存储在您的存储库中的Docker镜像，并使用Docker客户端构建和发布Docker镜像到ECR。最后，您将学习如何处理更高级的ECR使用和管理场景，包括配置跨帐户访问以允许在其他AWS帐户中运行的Docker客户端访问您的ECR存储库，并配置生命周期策略，以确保孤立的Docker镜像定期清理，减少管理工作量和成本。
- en: 'The following topics will be covered:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 将涵盖以下主题：
- en: Understanding ECR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解ECR
- en: Creating ECR repositories
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建ECR存储库
- en: Logging into ECR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录到ECR
- en: Publishing Docker images to ECR
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Docker镜像发布到ECR
- en: Pulling Docker images from ECR
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从ECR拉取Docker镜像
- en: Configuring lifecycle policies
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置生命周期策略
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following lists the technical requirements to complete this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了完成本章所需的技术要求：
- en: Docker 18.06 or higher
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 18.06或更高版本
- en: Docker Compose 1.22 or higher
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 1.22或更高版本
- en: GNU Make 3.82 or higher
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make 3.82或更高版本
- en: jq
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: jq
- en: AWS CLI 1.15.71 or higher
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CLI 1.15.71或更高版本
- en: Administrator access to an AWS account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对AWS帐户的管理员访问权限
- en: Local AWS profile configured as per instructions in Chapter 3
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地AWS配置文件按第3章中的说明配置
- en: Working Docker workflow for the sample application as configured in Chapter
    2 (see [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2)).
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第2章中配置的示例应用程序的工作Docker工作流程（请参阅[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch2)）。
- en: 'This GitHub URL contains the code samples used in this chapter: [https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此GitHub URL包含本章中使用的代码示例：[https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5](https://github.com/docker-in-aws/docker-in-aws/tree/master/ch5)。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：
- en: '[http://bit.ly/2PKMLSP](http://bit.ly/2PKMLSP)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bit.ly/2PKMLSP](http://bit.ly/2PKMLSP)'
- en: Understanding ECR
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解ECR
- en: Before we get started creating and configuring ECR repositories, it is important
    to provide a brief introduction to the core concepts of ECR.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始创建和配置ECR存储库之前，重要的是要简要介绍ECR的核心概念。
- en: 'ECR is a fully-managed private Docker registry provided by AWS and offers tight
    integration with ECS and other AWS services. ECR consists of a number of components,
    as shown in the following diagram:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ECR 是由 AWS 提供的完全托管的私有 Docker 注册表，并与 ECS 和其他 AWS 服务紧密集成。ECR 包括许多组件，如下图所示：
- en: '![](assets/4472aae0-f99e-482d-a642-fad5cc753bfa.png)ECR architecture'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4472aae0-f99e-482d-a642-fad5cc753bfa.png)ECR 架构'
- en: 'The core components of ECR include:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ECR 的核心组件包括：
- en: '**Repositories**: A repository stores all versions of images for a given Docker
    image. Each repository is configured with a name and URI, which is unique to your
    AWS account and region.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仓库**: 仓库存储给定 Docker 镜像的所有版本。每个仓库都配置有名称和 URI，该 URI 对于您的 AWS 帐户和区域是唯一的。'
- en: '**Permissions**: Each repository includes permissions that allow you to grant
    access for various ECR operations, such as pushing or pulling Docker images.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限**: 每个仓库都包括权限，允许您授予各种 ECR 操作的访问权限，例如推送或拉取 Docker 镜像。'
- en: '**Lifecycle policy**: Each repository can be configured with an optional lifecycle
    policy, which can be used to clean up orphaned Docker images that have been superseded
    by newer versions, or remove older Docker images that you may no longer use.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期策略**: 每个仓库都可以配置一个可选的生命周期策略，用于清理已被新版本取代的孤立的 Docker 镜像，或者删除您可能不再使用的旧 Docker
    镜像。'
- en: '**Authentication service**: ECR includes an authentication service that includes
    a token service that can be used to authenticate your IAM credentials in exchange
    for a temporary authentication token compatible with the Docker client authentication
    process.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证服务**: ECR 包括一个认证服务，其中包括一个令牌服务，可用于以临时认证令牌交换您的 IAM 凭据以进行身份验证，与 Docker 客户端身份验证过程兼容。'
- en: 'It''s also important to consider the consumers of ECR. As shown in the previous
    diagram, these include:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑 ECR 的消费者也很重要。如前图所示，这些包括：
- en: '**Docker clients in the same local AWS account as your repositories**: This
    would most commonly include ECS container instances running in ECS clusters.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与您的仓库在同一本地 AWS 帐户中的 Docker 客户端**: 这通常包括在 ECS 集群中运行的 ECS 容器实例。'
- en: '**Docker clients in a different AWS account from your repositories**: This
    is a common scenario for larger organizations, and again would typically include
    ECS container instances running in ECS clusters in remote accounts.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不同 AWS 帐户中的 Docker 客户端**: 这是较大组织的常见情况，通常包括在远程帐户中运行的 ECS 集群中的 ECS 容器实例。'
- en: '**Docker clients used by AWS services**: Some AWS services can utilize your
    own Docker images published in ECR, such as the AWS CodeBuild service.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS 服务使用的 Docker 客户端**: 一些 AWS 服务可以利用您在 ECR 中发布的自己的 Docker 镜像，例如 AWS CodeBuild
    服务。'
- en: At the time of writing this book, ECR is only offered as a private registry
    - meaning if you want to publish public your Docker images publicly, then ECR
    is not the correct solution for you, at least in terms of publishing your public
    Docker images.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，ECR 仅作为私有注册表提供 - 这意味着如果您想公开发布您的 Docker 镜像，那么至少在发布您的公共 Docker 镜像方面，ECR
    不是正确的解决方案。
- en: Creating ECR repositories
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ECR 仓库
- en: Now that you have a basic overview of ECR, let's get started creating your first
    ECR repository. Recall in earlier chapters, you were introduced to the sample
    **todobackend** application for this book, and you built a Docker image in your
    local environment. To be able to run containers on your ECS clusters based from
    this image, you need to publish this image to a Docker registry that your ECS
    container instances can access, and ECR is the perfect solution for this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对ECR有了基本概述，让我们开始创建您的第一个ECR存储库。回想一下，在早期的章节中，您已经介绍了本书的示例**todobackend**应用程序，并在本地环境中构建了一个Docker镜像。为了能够在基于此镜像的ECS集群上运行容器，您需要将此镜像发布到ECS容器实例可以访问的Docker注册表中，而ECR正是这个问题的完美解决方案。
- en: 'To create an ECR repository for the **todobackend** application, we will focus
    on the three popular methods to create and configure your repositories:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为**todobackend**应用程序创建ECR存储库，我们将专注于三种流行的方法来创建和配置您的存储库：
- en: Creating ECR repositories using the AWS Console
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建ECR存储库
- en: Creating ECR repositories using the AWS CLI
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CLI创建ECR存储库
- en: Creating ECR repositories using the AWS CloudFormation
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation创建ECR存储库
- en: Creating ECR repositories using the AWS Console
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台创建ECR存储库
- en: 'Creating an ECR repository can be performed using the AWS Console by performing
    the following steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行以下步骤，可以在AWS控制台上创建ECR存储库：
- en: From the main AWS console, select **Services** | **Elastic Container Service**
    within the Compute section, select **Repositories** from the left menu, and then
    click on the Get Started button.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主AWS控制台中，选择**服务** | **弹性容器服务**，在计算部分中选择**存储库**，然后单击“开始”按钮。
- en: 'You will be prompted to configure a name for your repository. A standard convention
    is to name your repositories in the `<organization>/<application>` format, which
    will result in a fully-qualified repository URI of `<registry>/<organization>/<application>`.
    In the following example, I am calling the repository `docker-in-aws/todobackend`,
    but you can name your image whatever you like. Once complete, click on Next step
    to continue:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示配置存储库的名称。一个标准的约定是以`<organization>/<application>`格式命名您的存储库，这将导致一个完全合格的存储库URI为`<registry>/<organization>/<application>`。在下面的示例中，我将存储库命名为`docker-in-aws/todobackend`，但您可以根据自己的喜好命名您的镜像。完成后，点击“下一步”继续：
- en: '![](assets/b8a39b1e-b38f-4f4b-91d7-162b33f6f0ea.png)Configuring a Repository
    name'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b8a39b1e-b38f-4f4b-91d7-162b33f6f0ea.png)配置存储库名称'
- en: Your ECR repository will now be created and instructions on how to log in to
    ECR and publish your Docker image will be provided.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的ECR存储库现在将被创建，并提供如何登录到ECR并发布您的Docker镜像的说明。
- en: Creating ECR repositories using the AWS CLI
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI创建ECR存储库
- en: Creating an ECR repository can be performed using the AWS CLI by running the
    `aws ecr create-repository` command, however given you have already created your
    repository via the AWS console, let's see how you can check whether an ECR repository
    already exists and how to delete a repository using the AWS CLI.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行`aws ecr create-repository`命令可以创建ECR存储库，但是考虑到您已经通过AWS控制台创建了存储库，让我们看看如何检查ECR存储库是否已经存在以及如何使用AWS
    CLI删除存储库。
- en: 'To view a list of ECR repositories in your AWS account and local region, you
    can use the `aws ecr list-repositories` command, while to delete an ECR repository,
    you can use the `aws ecr delete-repository` command, as demonstrated here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您的AWS帐户和本地区域中的ECR存储库列表，您可以使用`aws ecr list-repositories`命令，而要删除ECR存储库，您可以使用`aws
    ecr delete-repository`命令，如下所示：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Describing and deleting an ECR Repository using the AWS CLI
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI描述和删除ECR存储库
- en: 'Now that you have deleted the repository you created earlier using the AWS
    console, you can re-create it, as demonstrated here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经使用AWS控制台删除了之前创建的仓库，您可以按照这里演示的方法重新创建它：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating an ECR Repository using the AWS CLI
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CLI创建ECR仓库
- en: Creating ECR repositories using AWS CloudFormation
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation创建ECR仓库
- en: AWS CloudFormation supports the creation of ECR repositories via the `AWS::ECR::Repository`
    resource type, and at the time of writing, this allows you to manage ECR resource
    policies and lifecycle policies, which we will cover later in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CloudFormation支持通过`AWS::ECR::Repository`资源类型创建ECR仓库，在撰写本文时，这允许您管理ECR资源策略和生命周期策略，我们将在本章后面介绍。
- en: As a general rule of thumb, given the critical nature of ECR repositories as
    a distribution mechanism for your Docker images, I typically recommend the various
    ECR repositories for your account and region are defined in a single, shared CloudFormation
    stack dedicated solely to the creation and management of ECR repositories.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个经验法则，鉴于ECR仓库作为Docker镜像分发机制的关键性质，我通常建议将您的帐户和区域中的各种ECR仓库定义在一个单独的共享CloudFormation堆栈中，专门用于创建和管理ECR仓库。
- en: 'In keeping with this recommendation and for future chapters, let''s create
    a repository called **todobackend-aws** that you can use to store the various
    infrastructure configurations you will create and manage throughout this book. 
    I will leave you to create the corresponding repository on GitHub, after which
    you can configure your GitHub repository as a remote:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这个建议，并为将来的章节，让我们创建一个名为**todobackend-aws**的仓库，您可以用来存储您将在本书中创建和管理的各种基础架构配置。我会让您在GitHub上创建相应的仓库，之后您可以将您的GitHub仓库配置为远程仓库：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can now configure a CloudFormation template file called `ecr.yml` that
    defines a single ECR repository for the `todobackend` Docker image:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以配置一个名为`ecr.yml`的CloudFormation模板文件，该文件定义了一个名为`todobackend`的单个ECR仓库：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining an ECR Repository using the AWS CloudFormation
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation定义ECR仓库
- en: As you can see in the previous example, defining an ECR repository is very simple
    using CloudFormation and only requires the `RepositoryName` property to be defined,
    which, as you might expect, defines the name of the repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的示例中所看到的，使用CloudFormation定义ECR仓库非常简单，只需要定义`RepositoryName`属性，这个属性定义了仓库的名称，正如您所期望的那样。
- en: 'Assuming you have deleted the current todobackend ECR repository, as demonstrated
    earlier, you can now use the `aws cloudformation deploy` command to create the
    todobackend repository using CloudFormation:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经删除了之前的todobackend ECR仓库，就像之前演示的那样，现在您可以使用`aws cloudformation deploy`命令使用CloudFormation创建todobackend仓库：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating an ECR Repository using the AWS CloudFormation
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation创建ECR仓库
- en: 'Once the stack deploys successfully, you can view the stack in the CloudFormation
    console, as shown in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦堆栈成功部署，您可以在CloudFormation控制台中查看堆栈，如下截图所示：
- en: '![](assets/355c6511-887a-4c48-a0d6-d563459b8ed9.png)ECR Repository CloudFormation
    stack'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/355c6511-887a-4c48-a0d6-d563459b8ed9.png)ECR仓库CloudFormation堆栈'
- en: If you now navigate back to the ECS console and select **Resources** from the
    left menu, you should see a single ECR repository called `docker-in-aws/todobackend`,
    as defined in your CloudFormation stack. If you click on the repository, you will
    be taken to the repository detail page, which provides you with the repository
    URI, a list of images published in the repository, ECR permissions, and lifecycle
    policy settings.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在返回ECS控制台，并从左侧菜单中选择**资源**，您应该会看到一个名为`docker-in-aws/todobackend`的单个ECR仓库，就像在您的CloudFormation堆栈中定义的那样。如果您点击该仓库，您将进入仓库详细页面，该页面为您提供了仓库URI、仓库中发布的镜像列表、ECR权限和生命周期策略设置。
- en: Logging into ECR
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 登录到ECR
- en: Once you have created a repository for your Docker image, the next step is to
    build and publish your images to ECR. Before you can do this, you must authenticate
    with ECR, given at the time of writing ECR is a private service that does not
    support public access.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Docker镜像的存储库后，下一步是构建并将您的镜像发布到ECR。在此之前，您必须对ECR进行身份验证，因为在撰写本文时，ECR是一个不支持公共访问的私有服务。
- en: The instructions and commands for logging into ECR were displayed as part of
    the ECR repository wizard, however you can view these instructions any time by
    selecting an appropriate repository and clicking the **View Push Commands** button,
    which will display the various commands required to log in, build, and publish
    Docker images to the repository.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到ECR的说明和命令显示在ECR存储库向导的一部分中，但是您可以随时通过选择适当的存储库并单击**查看推送命令**按钮来查看这些说明，该按钮将显示登录、构建和发布Docker镜像到存储库所需的各种命令。
- en: 'The first command displayed is the `aws ecr get-login` command, which will
    generate a `docker login` expression that includes temporary authentication token
    valid for logging into ECR for 12 hours (note the command output has been truncated
    in the interests of saving space):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 显示的第一个命令是`aws ecr get-login`命令，它将生成一个包含临时身份验证令牌的`docker login`表达式，有效期为12小时（请注意，出于节省空间的考虑，命令输出已被截断）：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Generating login commands for ECR
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为ECR生成登录命令
- en: The `--no-include-email` flag is required for Docker versions 17.06 and higher,
    as the `-e` Docker CLI email flag was deprecated from this release.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Docker版本17.06及更高版本，`--no-include-email`标志是必需的，因为从此版本开始，`-e` Docker CLI电子邮件标志已被弃用。
- en: 'Although you can copy and paste the generated command output in the preceding
    example, a faster method is to automatically execute the output of the `aws ecr
    get-login` command using a bash command substitution by surrounding the command
    with `$(...)`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以复制并粘贴前面示例中生成的命令输出，但更快的方法是使用bash命令替换自动执行`aws ecr get-login`命令的输出，方法是用`$(...)`将命令括起来：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Logging into ECR
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到ECR
- en: Publishing Docker images to ECR
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Docker镜像发布到ECR
- en: In earlier chapters, you learned how to build and tag Docker images locally,
    using the todobackend sample application as an example.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的章节中，您学习了如何使用todobackend示例应用程序在本地构建和标记Docker镜像。
- en: 'You can now extend this workflow to publish Docker images to ECR, which requires
    you to perform the following tasks:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以将此工作流程扩展到将Docker镜像发布到ECR，这需要您执行以下任务：
- en: Ensure you are logged into ECR
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已登录到ECR
- en: Build and tag your Docker image with the URI of your ECR repository
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您的ECR存储库的URI构建和标记您的Docker镜像
- en: Push your Docker image to ECR
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的Docker镜像推送到ECR
- en: Publishing Docker images using the Docker CLI
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker CLI发布Docker镜像
- en: You've already seen how to log into ECR, and building and tagging your Docker
    image is much the same as the local use case, except you need to specify the URI
    of your ECR repository when tagging the image.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何登录ECR，并且构建和标记您的Docker镜像与本地使用情况大致相同，只是在标记图像时需要指定ECR存储库的URI。
- en: 'The following example demonstrates building the `todobackend` image, tagging
    the image with the URI of your new ECR repository (for the actual URI of your
    repository), and verifying the image name using the `docker images` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了构建`todobackend`镜像，使用您的新ECR存储库的URI标记图像（用于您的存储库的实际URI），并使用`docker images`命令验证图像名称：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tagging an Image for ECR
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为ECR标记图像
- en: Once you have built and tagged your image, you can push your image to ECR.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 构建并标记了您的镜像后，您可以将您的镜像推送到ECR。
- en: Note that to publish an image to ECR, you require various ECR permissions. Because
    you are using the admin role in your account, you automatically have all the required
    permissions. We will discuss ECR permissions in more detail later on in this chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要将图像发布到ECR，您需要各种ECR权限。因为您在您的帐户中使用管理员角色，所以您自动拥有所有所需的权限。我们将在本章后面更详细地讨论ECR权限。
- en: 'Because you have already logged into ECR, this is as simple as using the `docker
    push` command and referencing the name of your Docker image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您已经登录到ECR，所以只需使用`docker push`命令并引用您的Docker图像的名称即可：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Pushing an image to ECR
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像推送到ECR
- en: If you now navigate to the todobackend repository in the ECS console, you should
    see your newly published image appear with the default `latest` tag, as shown
    in the following figure. Notice that when you compare the built size of the image
    (99 MB in my example) with the size of the image stored in ECR (34 MB in my example),
    you can see that ECR stores the image in a compressed format, which reduces storage
    costs.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在在ECS控制台中导航到todobackend存储库，您应该会看到您新发布的图像以默认的“latest”标签出现，如下图所示。请注意，当您比较图像的构建大小（在我的示例中为99
    MB）与存储在ECR中的图像大小（在我的示例中为34 MB）时，您会发现ECR以压缩格式存储图像，从而降低了存储成本。
- en: In terms of charges for using ECR, AWS charges for both data storage and data
    transfer out (that is, pulling a Docker image). See [https://aws.amazon.com/ecr/pricing/](https://aws.amazon.com/ecr/pricing/)
    for more details.![](assets/9cb36e30-9f49-412d-833c-93abf0e56183.png)Viewing ECR
    images
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用ECR时，AWS会对数据存储和数据传输（即拉取Docker图像）收费。有关更多详细信息，请参见[https://aws.amazon.com/ecr/pricing/](https://aws.amazon.com/ecr/pricing/)！[](assets/9cb36e30-9f49-412d-833c-93abf0e56183.png)查看ECR图像
- en: Publishing Docker images using Docker Compose
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose发布Docker图像
- en: In earlier chapters, you learned how to use Docker Compose to help simplify
    the number of CLI commands required to test and build your Docker images. At the
    moment, Docker Compose is only building Docker images locally, but of course you
    now want to be able to publish your Docker images and leverage your Docker Compose
    workflow.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您已经学会了如何使用Docker Compose来帮助简化测试和构建Docker图像所需的CLI命令数量。目前，Docker Compose只能在本地构建Docker图像，但当然您现在希望能够发布您的Docker图像并利用您的Docker
    Compose工作流程。
- en: 'Docker Compose includes a service configuration property called `image`, which
    is commonly used to specify the image of a container that you would like to run:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose包括一个名为`image`的服务配置属性，通常用于指定要运行的容器的图像：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example Docker Compose file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例Docker Compose文件
- en: 'Although this is a very common usage pattern for Docker Compose, another configuration
    and set of behaviors exist if you combine both the `build` and `image` properties,
    as demonstrated here, for the `docker-compose.yml` file in the todobackend repository:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是Docker Compose的一个非常常见的使用模式，但如果您结合`build`和`image`属性，还存在另一种配置和行为集，如在todobackend存储库的`docker-compose.yml`文件中所示：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Todobackend Docker Compose file
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Todobackend Docker Compose文件
- en: In the preceding example, the `image` and `build` properties are both specified
    for the `release` and `app` services. When these two properties are used together,
    Docker will still build the image from the referenced Dockerfile, but will tag
    the image with the value to specify for the `image` property.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，为`release`和`app`服务同时指定了`image`和`build`属性。当这两个属性一起使用时，Docker仍将从引用的Dockerfile构建图像，但会使用`image`属性指定的值对图像进行标记。
- en: You can apply multiple tags by creating new services that simply extend your
    release image and define a image property that includes the additional tag.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建新服务并定义包含附加标签的图像属性来应用多个标签。
- en: 'Notice that for the `app` service we reference the environment variable `APP_VERSION`,
    which is intended to tag the image with the current application version that is
    defined within the Makefile at the root of the todobackend repository:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于`app`服务，我们引用环境变量`APP_VERSION`，这意味着要使用在todobackend存储库根目录的Makefile中定义的当前应用程序版本标记图像：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Replace the repository URI in the preceding examples with the appropriate URI
    generated for your own AWS account.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，用您自己AWS账户生成的适当URI替换存储库URI。
- en: 'To demonstrate the tagging behavior when you combine the `image` and `build`
    properties, first delete the Docker image you created earlier in this chapter,
    as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示当您结合`image`和`build`属性时的标记行为，首先删除本章前面创建的Docker图像，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Deleting a Docker image
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 删除Docker图像
- en: 'If you now run the `docker-compose build release` command, once the command
    completes, Docker Compose will have built a new image tagged with your ECR repository
    URI:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行`docker-compose build release`命令，一旦命令完成，Docker Compose将构建一个新的图像，并标记为您的ECR存储库URI：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Building a tagged image using Docker Compose
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose构建带标签的图像
- en: 'With your image built and tagged correctly, you can now execute the `docker-compose
    push` command, which can be used to push services defined in the Docker Compose
    file that include a `build` and `image` property:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的图像构建并正确标记后，您现在可以执行`docker-compose push`命令，该命令可用于推送在Docker Compose文件中定义了`build`和`image`属性的服务：
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Publishing images using Docker Compose
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker Compose发布图像
- en: In the preceding example, the image associated with the service called `release`
    is pushed, given this is the service that you configured with the Docker image
    URI.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，与名为`release`的服务关联的图像被推送，因为这是您使用Docker图像URI配置的服务。
- en: Automating the publish workflow
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布工作流程
- en: In previous chapters, you learned how to automate testing and building a Docker
    image for the todobackend application, using a combination of Docker, Docker Compose,
    and Make.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，您学习了如何使用Docker、Docker Compose和Make自动化测试和构建todobackend应用程序的Docker图像。
- en: 'You can now enhance this workflow to perform the following additional actions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以增强此工作流程以执行以下附加操作：
- en: Log in and log out of ECR
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录和注销ECR
- en: Publish to ECR
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布到ECR
- en: To achieve this, you will create new tasks in the Makefile of the todobackend
    repository.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，您将在todobackend存储库的Makefile中创建新的任务。
- en: Automating login and logout
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化登录和注销
- en: 'The following example demonstrates adding a couple of new tasks called `login`
    and `logout`, which will perform these actions using the Docker client:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了添加名为`login`和`logout`的两个新任务，这些任务将使用Docker客户端执行这些操作：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Logging in and logging out of ECR
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 登录和注销ECR
- en: Notice that the `login` task uses a double dollar sign ($$), which is required
    as Make uses single dollar signs to define Make variables. When you specify a
    double dollar sign, Make will pass a single dollar sign to the shell, which in
    this case will ensure a bash command substitution is executed.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`login`任务使用双美元符号($$)，这是必需的，因为Make使用单美元符号来定义Make变量。当您指定双美元符号时，Make将向shell传递单美元符号，这将确保执行bash命令替换。
- en: When logging out with the `logout` task, notice that you need to specify the
    Docker registry, otherwise the Docker client assumes the default public Docker
    Hub registry.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`logout`任务注销时，请注意您需要指定Docker注册表，否则Docker客户端会假定默认的公共Docker Hub注册表。
- en: 'With these tasks in place, you can now easily log out and log in of ECR using
    the `make logout` and `make login` commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些任务，您现在可以轻松地使用`make logout`和`make login`命令注销和登录ECR：
- en: '[PRE17]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Running make logout and make login
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行make logout和make login
- en: Automating the publishing of Docker images
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化发布Docker图像
- en: 'To automate the publishing workflow, you can add a new task called `publish`
    to the Makefile, which simply calls the `docker-compose push` command for the
    tagged `release` and `app` services:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要自动化发布工作流，您可以在Makefile中添加一个名为`publish`的新任务，该任务简单地调用标记为`release`和`app`服务的`docker-compose
    push`命令：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Automating publishing to ECR
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 自动发布到ECR
- en: With this configuration in place, your Docker image will now be tagged with
    both the commit hash and latest tags, which you can then publish to ECR by simply
    running the `make publish` command.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，您的Docker镜像现在将被标记为提交哈希和最新标记，然后您只需运行`make publish`命令即可将其发布到ECR。
- en: 'Let''s now commit your changes and run the full Make workflow to test, build,
    and publish your Docker images, as demonstrated in the following example. Notice
    that an image tagged with the commit hash of `97e4abf` is published to ECR:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们提交您的更改并运行完整的Make工作流来测试、构建和发布您的Docker镜像，如下例所示。请注意，一个带有提交哈希`97e4abf`标记的镜像被发布到了ECR：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running the updated Make workflow
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行更新后的Make工作流
- en: Pulling Docker images from ECR
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从ECR中拉取Docker镜像
- en: 'Now that you have learned how to publish Docker images to ECR, let''s focus
    on how Docker clients running under a variety of scenarios can pull your Docker
    images from ECR. Recall from the introduction to ECR at the beginning of this
    chapter that a variety of scenarios exist for client access to ECR, and we will
    now focus on these scenarios in the context of ECS container instances as your
    Docker clients:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何将Docker镜像发布到ECR，让我们专注于在各种场景下运行的Docker客户端如何从ECR拉取您的Docker镜像。回想一下本章开头对ECR的介绍，客户端访问ECR存在各种场景，我们现在将重点关注这些场景，以ECS容器实例作为您的Docker客户端：
- en: ECS container instances running in the same account as your ECR repositories
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在与您的ECR存储库相同的账户中运行的ECS容器实例
- en: ECS container instances running in different accounts to your ECR repositories
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行在不同账户中的ECS容器实例访问您的ECR存储库
- en: AWS services that require access to your ECR repositories
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要访问您的ECR存储库的AWS服务
- en: ECS container instance access to ECR from the same account
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自相同账户的ECS容器实例对ECR的访问
- en: 'When your ECS container instances are running in the same account as your ECR
    repositories, the recommended method to enable the ECS agents running inside your
    ECS container instances to pull Docker images from ECR is to use IAM policies
    associated with the IAM instance role applied to EC2 instance that runs as an
    ECS container instance. You already saw this method in action in the previous
    chapter, where the ECS cluster wizard provided by AWS attached a managed policy,
    called `AmazonEC2ContainerServiceforEC2Role`, to the IAM instance role for ECS
    container instances in the cluster, and notice the following ECR permissions that
    are included in this policy:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的ECS容器实例在与您的ECR存储库相同的账户中运行时，推荐的方法是使用与运行为ECS容器实例的EC2实例应用的IAM实例角色相关联的IAM策略，以使在ECS容器实例内运行的ECS代理能够从ECR中拉取Docker镜像。您已经在上一章中看到了这种方法的实际操作，AWS提供的ECS集群向导附加了一个名为`AmazonEC2ContainerServiceforEC2Role`的托管策略到集群中ECS容器实例的IAM实例角色，并注意到此策略中包含的以下ECR权限：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: AmazonEC2ContainerServiceforEC2Role policy
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: AmazonEC2ContainerServiceforEC2Role策略
- en: 'In the preceding example, you can see four ECR permissions are granted, which
    collectively permit the ECS agent to login to ECR and pull Docker images:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，您可以看到授予了四个ECR权限，这些权限共同允许ECS代理登录到ECR并拉取Docker镜像：
- en: '`ecr:GetAuthorizationToken`: Permits retrieval of an authentication token that
    is valid for 12 hours and can be used to log in to ECR using the Docker CLI.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ecr:GetAuthorizationToken`：允许检索有效期为12小时的身份验证令牌，可用于使用Docker CLI登录到ECR。'
- en: '`ecr:BatchCheckLayerAvailability`: Checks the availability of multiple image
    layers in a given repository.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ecr:BatchCheckLayerAvailability`: 检查给定存储库中多个镜像层的可用性。'
- en: '`ecr:GetDownloadUrlForLayer`: Retrieves a pre-signed S3 download URL for a
    given layer in a Docker image.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ecr:GetDownloadUrlForLayer`: 为Docker镜像中的给定层检索预签名的S3下载URL。'
- en: '`ecr:BatchGetImage`: Retries detailed information for Docker images in a given
    repository.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ecr:BatchGetImage`: 重新获取给定存储库中Docker镜像的详细信息。'
- en: These permissions are sufficient to log into ECR and pull images, but notice
    that the `Resource` property in the previous example allows access to all repositories
    in your account.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权限足以登录到ECR并拉取镜像，但请注意前面示例中的`Resource`属性允许访问您帐户中的所有存储库。
- en: 'Depending on the security requirements of your organization, this broad access
    to all repositories may or may not be acceptable - if not, then you need to create
    custom IAM policies that restrict access to specific repositories, as demonstrated
    here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您组织的安全要求，对所有存储库的广泛访问可能是可以接受的，也可能不可以接受 - 如果不可以接受，则需要创建自定义IAM策略，限制对特定存储库的访问，就像这里演示的那样：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Granting ECR login and pull permissions to specific repositories
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 授予特定存储库的ECR登录和拉取权限
- en: In the preceding example, notice that the `ecr:GetAuthorizationToken` permission
    is still scoped to all resources, as you don't log into a specific ECR repository,
    rather you log into the ECR registry for your account in a given region. The other
    permissions required to pull Docker images however can be applied to individual
    repositories, and you can see that these permissions are only permitted to the
    ARN of your ECR repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意`ecr:GetAuthorizationToken`权限仍然适用于所有资源，因为您没有登录到特定的ECR存储库，而是登录到给定区域中您帐户的ECR注册表。然而，用于拉取Docker镜像的其他权限可以应用于单个存储库，您可以看到这些权限仅允许对您的ECR存储库的ARN进行操作。
- en: 'Note that if you also wanted to grant push access to the ECR repository in
    the preceding example, additional ECR permissions would be required:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您还想要在前面的示例中授予对ECR存储库的推送访问权限，则需要额外的ECR权限：
- en: '[PRE22]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Granting ECR push permissions to specific repositories
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 授予特定存储库的ECR推送权限
- en: ECS container instance access to ECR from a different account
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 来自不同帐户的ECS容器实例访问ECR
- en: In larger organizations, it is very common for resources and users to be split
    across multiple accounts, and a common pattern is to have a central build account,
    where application artifacts, such as Docker images, are centrally stored.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在较大的组织中，资源和用户通常分布在多个帐户中，一个常见的模式是拥有一个中央构建帐户，应用程序构件（如Docker镜像）在其中进行集中存储。
- en: 'The following diagram illustrates this scenario, where you may have several
    accounts running ECS container instances that need to pull Docker images that
    store in your central repositories:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了这种情况，您可能有几个帐户运行ECS容器实例，这些实例需要拉取存储在您中央存储库中的Docker镜像：
- en: '![](assets/5cf82ce0-1580-4267-aa6d-c6bf66054e75.png)Multiple accounts requiring
    access to central ECR repositories'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5cf82ce0-1580-4267-aa6d-c6bf66054e75.png)需要访问中央ECR存储库的多个帐户'
- en: 'When you need to grant other accounts access to your ECR repositories, there
    are two configuration tasks that need to be performed:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要授予其他帐户对您的ECR存储库的访问权限时，需要执行两项配置任务：
- en: Configure ECR *resource policies* in the account that hosts the repositories,
    which allow you to define policies that are scoped and applied to an individual
    ECR repository (this is the *resource*) and define *who* can access the repository
    (for example, AWS accounts) and *what* actions they can perform (for example,
    log in, push and/or pull images). This ability to define *who* can access a given
    repository is what allows for cross-account access to be enabled and controlled
    via resource policies. For example, in the preceding diagram, the repository is
    configured to permit access from accounts `333333444444` and `555555666666`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在托管存储库的帐户中配置ECR *资源策略*，允许您定义适用于单个ECR存储库（这是*资源*）的策略，并定义*谁*可以访问存储库（例如，AWS帐户）以及*他们*可以执行的*操作*（例如，登录，推送和/或拉取映像）。定义*谁*可以访问给定存储库的能力是允许通过资源策略启用和控制跨帐户访问的关键。例如，在前面的图中，存储库配置为允许来自帐户`333333444444`和`555555666666`的访问。
- en: Administrators in the remote account need to assign permissions in the form
    of IAM policies to pull images from your ECR repositories. This is a form of delegated
    access, where the account hosting the ECR repositories trusts access from the
    remote account as long as access has been explicitly granted via an IAM policy.
    For example, in the preceding diagram, ECS container instances have an IAM policy
    assigned that permits them access to the myorg/app-a repository in account `111111222222`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程帐户中的管理员需要以IAM策略的形式分配权限，以从您的ECR存储库中提取映像。这是一种委托访问的形式，即托管ECR存储库的帐户信任远程帐户的访问，只要通过IAM策略明确授予了访问权限。例如，在前面的图中，ECS容器实例分配了一个IAM策略，允许它们访问帐户`111111222222`中的myorg/app-a存储库。
- en: Configuring ECR resource policies using the AWS Console
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台配置ECR资源策略
- en: 'You can configure ECR resource policies via the ECS Console by opening the
    appropriate ECR repository, selecting the **Permissions** tab, and clicking **Add**
    to add a new set of permissions:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过打开适当的ECR存储库，在**权限**选项卡中选择**添加**来配置ECS控制台中的ECR资源策略，并单击**添加**以添加新的权限集：
- en: '![](assets/4dc40247-49ee-463d-ab22-2800808bfd0d.png)Configuring ECR resource
    policies'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/4dc40247-49ee-463d-ab22-2800808bfd0d.png)配置ECR资源策略'
- en: In the preceding figure, notice that you can configure AWS account IDs as principals
    via the Principal setting, and then easily permit pull access by selecting the
    **Pull only actions** option. With this configuration, you are permitting potentially
    any entity associated with the remote account the ability to pull Docker images
    from this repository.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，请注意您可以通过主体设置将AWS帐户ID配置为主体，然后通过选择**仅拉取操作**选项轻松允许拉取访问。通过此配置，您允许与远程帐户关联的任何实体从此存储库中拉取Docker映像。
- en: '![](assets/c0f530e0-0975-491a-8e31-390eedb7a484.png)Configuring ECR resource
    policies'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c0f530e0-0975-491a-8e31-390eedb7a484.png)配置ECR资源策略'
- en: 'Note that if you attempt to save the configuration shown in the previous figure
    and the preceding figure, you will receive an error because I have used an invalid
    account. Assuming you did use a valid account ID and you saved the policy, the
    following policy document would be generated for the configuration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您尝试保存前图和上图中显示的配置，您将收到错误，因为我使用了无效的帐户。假设您使用了有效的帐户ID并保存了策略，则将为配置生成以下策略文档：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Example ECR repository policy document
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 示例ECR存储库策略文档
- en: Configuring ECR resource policies using the AWS CLI
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI配置ECR资源策略
- en: 'You can configure ECR resource policies via the AWS CLI by using the `aws ecr
    set-repository-policy` command, as demonstrated here:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`aws ecr set-repository-policy`命令通过AWS CLI配置ECR资源策略，如下所示：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Configuring ECR resource Policies via the AWS CLI
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通过AWS CLI配置ECR资源策略
- en: As demonstrated in the preceding example, you must specify the repository name
    using the `--repository-name` flag, and configure the repository policy as a JSON-formatted
    document using the `--policy-text` flag.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，您必须使用`--repository-name`标志指定存储库名称，并使用`--policy-text`标志配置存储库策略为JSON格式的文档。
- en: Configuring ECR resource policies using AWS CloudFormation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation配置ECR资源策略
- en: 'When using AWS CloudFormation to define your ECR repositories, you can configure
    the `RepositoryPolicyText` property of the `AWS::ECR::Repository` resource you
    created in earlier example to define an ECR resource policy:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AWS CloudFormation定义ECR存储库时，您可以配置`AWS::ECR::Repository`资源的`RepositoryPolicyText`属性，以定义ECR资源策略：
- en: '[PRE25]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Configuring ECR resource policies using AWS CloudFormation
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation配置ECR资源策略
- en: The policy text in the preceding example expresses the JSON policy you configured
    in earlier examples in a YAML format, and you can deploy the changes to your stack
    by running the `aws cloudformation deploy` command.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，策略文本以YAML格式表达了您在之前示例中配置的JSON策略，并且您可以通过运行`aws cloudformation deploy`命令将更改部署到您的堆栈。
- en: Configuring IAM policies in remote accounts
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置远程帐户中的IAM策略
- en: With the ECR resource policies in place configured either by the console, CLI,
    or CloudFormation, you can proceed to create IAM policies in the remote account(s)
    specified in your ECR resource policies. These policies are configured exactly
    how you would configure an IAM policy for local access in your account, and if
    required, you can refer to the ARN of the remote ECR repository if you wish to
    only grant access to this repository.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制台、CLI或CloudFormation配置好ECR资源策略后，您可以继续在您的ECR资源策略中指定的远程帐户中创建IAM策略。这些策略的配置方式与您在本地帐户中配置IAM策略的方式完全相同，如果需要，您可以引用远程ECR存储库的ARN，以便仅授予对该存储库的访问权限。
- en: AWS service access to ECR
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS服务访问ECR
- en: One final scenario we will discuss is the ability for AWS services to access
    your ECR images. An example of this is the AWS CodeBuild service, which performs
    automated continuous integration tasks using a container-based build agent. CodeBuild
    allows you to define your own custom build agents, and a common practice is to
    publish the image for these build agents in ECR. This means that the AWS CodeBuild
    service now requires access to ECR, and you can use ECR resource policies to achieve
    this.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个场景是AWS服务访问您的ECR镜像的能力。一个例子是AWS CodeBuild服务，它使用基于容器的构建代理执行自动化持续集成任务。CodeBuild允许您定义自己的自定义构建代理，一个常见的做法是将这些构建代理的镜像发布到ECR中。这意味着AWS
    CodeBuild服务现在需要访问ECR，您可以使用ECR资源策略来实现这一点。
- en: 'The following example expands on the preceding example, adding the AWS CodeBuild
    service to the resource policy:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例扩展了前面的示例，将AWS CodeBuild服务添加到资源策略中：
- en: '[PRE26]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Configuring AWS service access to ECR repositories
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 配置AWS服务访问ECR存储库
- en: In the preceding example, notice that you can use the `Service` property within
    the `Principal` property to identify AWS services that that policy statement will
    be applied to. In later chapters, you will see an example of this in action when
    you create your own custom CodeBuild image that is published to ECR.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，请注意您可以在`Principal`属性中使用`Service`属性来标识将应用该策略语句的AWS服务。在后面的章节中，当您创建自己的自定义CodeBuild镜像并发布到ECR时，您将看到这一示例的实际操作。
- en: Configuring lifecycle policies
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置生命周期策略
- en: If you have followed along in this chapter, you will have published the todobackend
    image to your ECR repository several times, and chances are, you will have created
    what are known as *orphan images* in your ECR repository. In earlier chapters,
    we discussed orphaned images that were being created in your local Docker Engine,
    and defined these an image whose tag has been superseded by a newer image, effectively
    leaving the older images nameless and hence "orphaned."
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本章中跟随操作，您将已经多次将todobackend图像发布到您的ECR存储库，并且很可能已经在您的ECR存储库中创建了所谓的*孤立图像*。在早期的章节中，我们讨论了在本地Docker引擎中创建的孤立图像，并将其定义为其标记已被新图像取代的图像，从而使旧图像无名，并因此“孤立”。
- en: 'If you browse to your ECR repository and select the Images tab in the ECS console,
    you may notice that you have a few images that no longer have a tag, which will
    be because you pushed several images with the `latest` tag, that have superseded
    the now-orphaned images:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您浏览到您的ECR存储库并在ECS控制台中选择图像选项卡，您可能会注意到您有一些不再具有标记的图像，这是因为您推送了几个带有`latest`标记的图像，这些图像已经取代了现在孤立的图像：
- en: '![](assets/6396f20d-d78c-4511-ab1e-c3a676b92950.png)Orphaned ECR images'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/6396f20d-d78c-4511-ab1e-c3a676b92950.png)孤立的ECR图像'
- en: In the preceding figure, notice that your storage usage in ECR has now tripled,
    even though you only have one current `latest` image, which means you may also
    be paying triple the storage costs. Of course you can manually delete these images
    yourself, however this is prone to error and often will become a forgotten and
    neglected task.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，请注意您的ECR中的存储使用量现在已经增加了三倍，即使您只有一个当前的`latest`图像，这意味着您可能也要支付三倍的存储成本。当然，您可以手动删除这些图像，但这很容易出错，而且通常会成为一个被遗忘和忽视的任务。
- en: Thankfully, ECR supports a feature called *lifecycle policies*, which allows
    you to define a set of rules contained within a policy that manages the lifecycle
    of your Docker images. A standard use case for lifecycle policies that you should
    always apply to every repository you create is the periodic removal of orphaned
    images, so let's now see how you can create and apply such a policy.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，ECR支持一种称为*生命周期策略*的功能，允许您定义包含在策略中的一组规则，管理您的Docker图像的生命周期。您应该始终应用于您创建的每个存储库的生命周期策略的标准用例是定期删除孤立的图像，因此现在让我们看看如何创建和应用这样的策略。
- en: Configuring lifecycle policies using the AWS Console
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS控制台配置生命周期策略
- en: When configuring lifecycle policies, because these policies may actually delete
    your Docker images, it is a good idea to always use the AWS console to initially
    test your policies, as the ECS console includes a feature that allows you to simulate
    what would happen if you were to apply a lifecycle policy.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置生命周期策略时，因为这些策略可能实际删除您的Docker图像，最好始终使用AWS控制台来测试您的策略，因为ECS控制台包括一个功能，允许您模拟如果应用生命周期策略会发生什么。
- en: 'To configure lifecycle policies using the AWS console, select the **Dry run
    of lifecycle rules** tab within your ECR repository and then click the **Add**
    button to create a new Dry run rules. This allows you to test your lifecycle policy
    rules without actually deleting any images in your ECR repository. Once you are
    satisfied your rules are behaving safely and as expected, you can convert them
    into actual lifecycle policies that will be applied to your repository:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS控制台配置生命周期策略，选择ECR存储库中的**生命周期规则的干运行**选项卡，然后单击**添加**按钮以创建新的干运行规则。这允许您在不实际删除ECR存储库中的任何图像的情况下测试生命周期策略规则。一旦您满意您的规则安全地行为并符合预期，您可以将它们转换为实际的生命周期策略，这些策略将应用于您的存储库：
- en: '![](assets/b3d8f9fb-8e73-4b0a-9fca-b5e329a297df.png)ECR dry run rules'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/b3d8f9fb-8e73-4b0a-9fca-b5e329a297df.png)ECR干运行规则'
- en: 'You can now define a rule in the Add rule screen with the following parameters:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在“添加规则”屏幕中使用以下参数定义规则：
- en: '**Rule priority**: Determines the rule evaluation order when multiple rules
    are defined in a policy.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则优先级**：确定在策略中定义多个规则时的规则评估顺序。'
- en: '**Rule description**: A human-readable description of the rule.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则描述**：规则的可读描述。'
- en: '**Image status**: Defines which type of images the rule applies to. Note that
    you can only have a single rule that specifies **Untagged** images.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像状态**：定义规则适用于哪种类型的图像。请注意，您只能有一个指定**未标记**图像的规则。'
- en: '**Match criteria**: Defines the criteria as to when the rule should be applied.
    For example, you might configure the criteria to match untagged images that were
    pushed more than seven days since the last push to the ECR repository.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**匹配条件**：定义规则应何时应用的条件。例如，您可以配置条件以匹配自上次推送到ECR存储库以来超过七天的未标记图像。'
- en: '**Rule action**: Defines the action that should be performed to images that
    match the rule. At the time of writing, only the **expire** action is supported,
    which will delete matching images.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则操作**：定义应对匹配规则的图像执行的操作。目前，仅支持**过期**操作，将删除匹配的图像。'
- en: After clicking on the Save button, the new rule will be added to the **Dry run
    of lifecycle rules** tab. If you now click the **Save and perform dry run** button,
    any images that match your rule criteria will be displayed, which should include
    the orphaned images that were displayed earlier.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 单击保存按钮后，新规则将添加到**生命周期规则的模拟运行**选项卡。如果您现在单击**保存并执行模拟运行**按钮，将显示符合规则条件的任何图像，其中应包括先前显示的孤立图像。
- en: Now, depending on whether or not you have untagged images and how old they are
    in comparison to your last push to the repository, you may or may not see images
    that match your dry run rules. Regardless of the actual outcome, the key here
    is to ensure that whatever images were matched is what you expect, and that you
    are comfortable the dry run rules will not accidentally delete valid images that
    expect to be published and available.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，取决于您是否有未标记的图像以及它们与您最后推送到存储库的时间相比有多久，您可能会或可能不会看到与您的模拟运行规则匹配的图像。无论实际结果如何，关键在于确保与规则匹配的任何图像都是您期望的，并且您确信模拟运行规则不会意外删除您期望发布和可用的有效图像。
- en: 'If you are happy with the dry run rules, you can next click the **Apply as
    lifecycle policy** button, which will first display a dialog confirming the new
    rules, and once applied, if you navigate to the **Lifecycle policy** tab, you
    should see your lifecycle policy:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对模拟运行规则满意，接下来可以单击**应用为生命周期策略**按钮，首先会显示对新规则的确认对话框，一旦应用，如果您导航到**生命周期策略**选项卡，您应该会看到您的生命周期策略：
- en: '![](assets/5b82b40f-e3f7-4792-aece-cc70583abb0a.png)ECR lifecycle policies'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/5b82b40f-e3f7-4792-aece-cc70583abb0a.png)ECR生命周期策略'
- en: To confirm your lifecycle policy is working, you can click on any policy rule
    and select **View History** from the **Actions** dropdown, which will display
    any actions that have been performed by ECR in relation to the policy rule.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要确认您的生命周期策略是否起作用，您可以单击任何策略规则，然后从“操作”下拉菜单中选择**查看历史记录**，这将显示ECR执行的与策略规则相关的任何操作。
- en: Configuring lifecycle policies using the AWS CLI
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CLI配置生命周期策略
- en: 'The AWS CLI supports a similar workflow to configuring ECR lifecycle policies
    via the AWS console, which is outlined here:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CLI支持与通过AWS控制台配置ECR生命周期策略类似的工作流程，概述如下：
- en: '`aws ecr start-lifecycle-policy-preview --repository-name <*name*> --lifecycle-policy-text
    <*json*>`: Starts a dry run of the lifecycle policy against the repository'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr start-lifecycle-policy-preview --repository-name <*name*> --lifecycle-policy-text
    <*json*>`：对存储库启动生命周期策略的模拟运行'
- en: '`aws ecr get-lifecycle-policy-preview --repository-name <*name*>`: Obtains
    the status of the dry run'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr get-lifecycle-policy-preview --repository-name <*name*>`：获取试运行的状态'
- en: '`aws ecr put-lifecycle-policy --repository-name <*name*> --lifecycle-policy-text
    <*json*>`: Applies the lifecycle policy to the repository'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr put-lifecycle-policy --repository-name <*name*> --lifecycle-policy-text
    <*json*>`：将生命周期策略应用于存储库'
- en: '`aws ecr get-lifecycle-policy --repository-name <*name*>`: Displays the current
    lifecycle policy applied to the repository'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr get-lifecycle-policy --repository-name <*name*>`：显示应用于存储库的当前生命周期策略'
- en: '`aws ecr delete-lifecycle-policy --repository-name <*name*>`: Deletes the current
    lifecycle policy applied to the repository'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aws ecr delete-lifecycle-policy --repository-name <*name*>`：删除应用于存储库的当前生命周期策略'
- en: When working with the CLI, you need to specify lifecycle policies in a JSON
    format, which you can see an example of by clicking the View JSON action in the
    preceding screenshot.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CLI时，您需要以JSON格式指定生命周期策略，您可以通过单击前面截图中的“查看JSON”操作来查看示例。
- en: Configuring lifecycle policies using AWS CloudFormation
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation配置生命周期策略
- en: 'When using AWS CloudFormation to define your ECR repositories, you can configure
    the `LifecyclePolicy` property of the `AWS::ECR::Repository` resource you created
    earlier, to define an ECR lifecycle policy:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用AWS CloudFormation定义ECR存储库时，您可以配置之前创建的`AWS::ECR::Repository`资源的`LifecyclePolicy`属性，以定义ECR生命周期策略：
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Configuring ECR lifecycle policies using AWS CloudFormation
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AWS CloudFormation配置ECR生命周期策略
- en: The policy text in the preceding example, expresses the JSON policy you configured
    in earlier examples as a JSON string - note the use of the pipe (`|`) YAML operator,
    which allows you to enter multiline text for improved readability.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 前面示例中的策略文本表示您在之前示例中配置的JSON策略作为JSON字符串 - 请注意使用管道（`|`）YAML运算符，它允许您输入多行文本以提高可读性。
- en: With this configuration in place, you can apply the changes to your stack by
    running the `aws cloudformation deploy` command.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个配置，您可以通过运行`aws cloudformation deploy`命令将更改应用到您的堆栈。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to create and manage ECR repositories that
    you can use to store your Docker images securely and privately. After creating
    your first ECR repository, you learned how to authenticate to ECR using the AWS
    CLI and Docker client, and then successfully tagged and published your Docker
    image to ECR.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何创建和管理ECR存储库，您可以使用它来安全和私密地存储您的Docker镜像。创建了第一个ECR存储库后，您学会了如何使用AWS CLI和Docker客户端进行ECR身份验证，然后成功地给ECR打上标签并发布了您的Docker镜像。
- en: With your Docker image published, you then learned about the various scenarios
    for which Docker clients may need to access your repository, which included ECS
    container instance access from the same account as your ECR repository, ECS container
    instance from a different account as your ECR repository (that is, cross-account
    access), and finally granting access to AWS services such as CodeBuild. You created
    ECR resource policies, which are required when configuring cross-account access
    and when granting access to AWS services, and you learned that despite the creation
    of ECR resource policies in a central account that define remote accounts as trusted,
    you still need to create IAM policies in each remote account that explicitly grant
    access to your central account repositories.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 发布了您的Docker镜像后，您还了解了Docker客户端可能需要访问存储库的各种情况，包括来自与您的ECR存储库相同账户的ECS容器实例访问、来自与您的ECR存储库不同账户的ECS容器实例访问（即跨账户访问），以及最后授予对AWS服务（如CodeBuild）的访问权限。您创建了ECR资源策略，这在配置跨账户访问和授予对AWS服务的访问权限时是必需的，并且您了解到，尽管在定义远程账户为受信任的中央账户中创建了ECR资源策略，但您仍然需要在每个远程账户中创建明确授予对中央账户存储库访问权限的IAM策略。
- en: Finally, you created ECR lifecycle policy rules that allow you to automatically
    and periodically remove untagged (orphaned) Docker images, which helps to reduce
    your storage costs. In the next chapter, you will learn how to build and publish
    your own custom ECS container instance Amazon Machine Images (AMIs), using a popular
    open source tool called Packer.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您创建了ECR生命周期策略规则，允许您自动定期删除未标记（孤立）的Docker镜像，从而有助于减少存储成本。在下一章中，您将学习如何使用一种流行的开源工具Packer构建和发布自己的自定义ECS容器实例Amazon
    Machine Images（AMIs）。
- en: Questions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What command do you execute to obtain an authentication token for ECR?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您执行哪个命令以获取ECR的身份验证令牌？
- en: 'True/False: ECR allows you to publish and distribute Docker images publicly'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：ECR允许您公开发布和分发Docker镜像
- en: Which ECR feature should you configure if you notice you have a lot of untagged
    images in your repository?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您注意到存储库中有很多未标记的图像，您应该配置哪个ECR功能？
- en: 'True/False: ECR stores Docker images in a compressed format'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：ECR以压缩格式存储Docker镜像
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from ECS container instances in the same account'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：配置从相同帐户的ECS容器实例访问ECR需要ECR资源策略
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from ECS container instances in a remote account'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：配置从远程帐户的ECS容器实例访问ECR需要ECR资源策略
- en: 'True/False: ECR resource policies are required for configuring access to ECR
    from AWS CodeBuild'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：配置从AWS CodeBuild访问ECR需要ECR资源策略
- en: 'True/False: IAM policies are required for configuring access to ECR from ECS
    container instances in the same account'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：配置从相同帐户的ECS容器实例访问ECR需要IAM策略
- en: 'True/False: IAM policies are required for configuring access to ECR from ECS
    container instances in a remote account'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真/假：配置从远程帐户的ECS容器实例访问ECR需要IAM策略
- en: Further reading
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can check the following links for more information about the topics covered
    in this chapter:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看以下链接以获取有关本章涵盖的主题的更多信息：
- en: 'ECR user guide: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECR用户指南：[https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/what-is-ecr.html)
- en: 'ECR repository CloudFormation resource: [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECR存储库CloudFormation资源：[https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecr-repository.html)
- en: 'Identity-based vs resource-based policies: [https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html)'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于身份和基于资源的策略：[https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_identity-vs-resource.html)
- en: 'Resource-level permissions for ECR repositories : [https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html)'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECR存储库的资源级权限：[https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/ecr-supported-iam-actions-resources.html)
- en: 'Lifecycle policies for ECR: [https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ECR的生命周期策略：[https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html](https://docs.aws.amazon.com/AmazonECR/latest/userguide/LifecyclePolicies.html)
- en: 'AWS ECR CLI reference: [https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr](https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS ECR CLI 参考：[https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr](https://docs.aws.amazon.com/cli/latest/reference/ecr/index.html#cli-aws-ecr)
