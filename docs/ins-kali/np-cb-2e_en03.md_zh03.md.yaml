- en: Chapter 3. Getting to Grips with Commonly Used Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：掌握常用函数
- en: 'In this chapter, we will cover a number of commonly used functions:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍许多常用函数：
- en: '`sqrt()`, `log()`, `arange()`, `astype()`, and `sum()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt()`，`log()`，`arange()`，`astype()`和`sum()`'
- en: '`ceil()`, `modf()`, `where()`, `ravel()`, and `take()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ceil()`，`modf()`，`where()`，`ravel()`和`take()`'
- en: '`sort()` and `outer()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort()`和`outer()`'
- en: '`diff()`, `sign()`, and `eig()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`diff()`，`sign()`和`eig()`'
- en: '`histogram()` and `polyfit()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`histogram()`和`polyfit()`'
- en: '`compress()` and `randint()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compress()`和`randint()`'
- en: 'We will be discussing these functions in the following recipes:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下秘籍中讨论这些功能：
- en: Summing Fibonacci numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 斐波纳契数求和
- en: Finding prime factors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找质因数
- en: Finding palindromic numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找回文数
- en: The steady state vector
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳态向量
- en: Discovering a power law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现幂律
- en: Trading periodically on dips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逢低定期交易
- en: Simulating trading at random
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机模拟交易
- en: Sieving integers with the Sieve of Eratosthenes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用埃拉托色尼筛子来筛选质数
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter is about the commonly used NumPy functions. These are the functions
    that you will be using on a daily basis. Obviously, the usage may differ for you.
    There are so many NumPy functions that it is virtually impossible to know all
    of them, but the functions in this chapter are the bare minimum with which we
    should be familiar.
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍常用的 NumPy 函数。 这些是您每天将要使用的函数。 显然，用法可能与您不同。 NumPy 函数太多，以至于几乎不可能全部了解，但是本章中的函数是我们应该熟悉的最低要求。
- en: Summing Fibonacci numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 斐波纳契数求和
- en: In this recipe, we will sum the even-valued terms in the Fibonacci sequence
    whose values do not exceed 4 million. The **Fibonacci series** is a sequence of
    integers starting with zero, where each number is the sum of the previous two,
    except (of course) the first two numbers, zero and one (0, 1, 1, 2, 3, 5, 8, 13,
    21, 34, 55, 89 ...).
  prefs: []
  type: TYPE_NORMAL
  zh: 在此秘籍中，我们将求和值不超过 400 万的斐波纳契数列中的偶数项。**斐波那契数列**是从零开始的整数序列，其中每个数字都是前两个数字的和，但（当然）前两个数字除外
    ，零和一（0、1、1、2、3、5、8、13、21、34、55、89 ...）。
- en: The sequence was published by Fibonacci in 1202 and originally did not include
    zero. Actually, it was already known to Indian mathematicians in earlier centuries.
    Fibonacci numbers have applications in mathematics, computer science, and biology.
  prefs: []
  type: TYPE_NORMAL
  zh: 该序列由斐波那契（Fibonacci）在 1202 年发布，最初不包含零。 实际上，早在几个世纪以前，印度数学家就已经知道了它。 斐波那契数在数学，计算机科学和生物学中都有应用。
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information, read the Wikipedia article about Fibonacci numbers at
    [http://en.wikipedia.org/wiki/Fibonacci_number](http://en.wikipedia.org/wiki/Fibonacci_number).
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请阅读斐波那契数字的维基百科文章，位于[`en.wikipedia.org/wiki/Fibonacci_number`](http://en.wikipedia.org/wiki/Fibonacci_number)。
- en: 'This recipe uses a formula based on the **golden ratio**, which is an irrational
    number with special properties comparable to pi. The golden ratio is given by
    the following formula:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该秘籍使用基于**黄金比例**的公式，这是一个无理数，具有与`pi`相当的特殊性质。 黄金比例由以下公式给出：
- en: '![Summing Fibonacci numbers](img/0945_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![斐波纳契数求和](img/0945_03_06.jpg)'
- en: 'We will use the `sqrt()`, `log()`, `arange()`, `astype()`, and `sum()` functions.
    The Fibonacci sequence''s recurrence relation has the following solution, which
    involves the golden ratio:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`sqrt()`，`log()`，`arange()`，`astype()`和`sum()`函数。 斐波那契数列的递归关系具有以下解，涉及黄金比率：
- en: '![Summing Fibonacci numbers](img/0945_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![斐波纳契数求和](img/0945_03_07.jpg)'
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete code for this recipe from the `sum_fibonacci.py`
    file in this book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`sum_fibonacci.py`文件中此秘籍的完整代码：
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing to do is calculate the golden ratio (see [http://en.wikipedia.org/wiki/Golden_ratio](http://en.wikipedia.org/wiki/Golden_ratio)),
    also called the **golden section** or golden mean.
  prefs: []
  type: TYPE_NORMAL
  zh: 的第一件事是计算黄金分割率（见[`en.wikipedia.org/wiki/Golden_ratio`](http://en.wikipedia.org/wiki/Golden_ratio)），也称为**黄金分割**或黄金平均值。
- en: 'Use the `sqrt()` function to calculate the square root of `5`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sqrt()`函数计算`5`的平方根：
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This prints the golden mean:'
  prefs: []
  type: TYPE_NORMAL
  zh: 这印出了中庸之道：
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, in the recipe, we need to find the index of the Fibonacci number below
    4 million. A formula for this is given in the Wikipedia page, and we will compute
    it using that formula. All we need to do is convert log bases with the `log()`
    function. We don''t need to round the result down to the closest integer. This
    is automatically done for us in the next step of the recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在秘籍中，我们需要找到低于 400 万的斐波那契数的指数。 维基百科页面中提供了一个公式，我们将使用该公式进行计算。 我们需要做的就是使用`log()`函数转换对数。
    我们不需要将结果四舍五入为最接近的整数。 在秘籍的下一步中，这将自动为我们完成：
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The value of `n` is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`n`的值如下：'
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `arange()` function is a very basic function that many people know. Still,
    we will mention it here for completeness:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`arange()`函数是许多人都知道的非常基本的函数。 不过，出于完整性考虑，我们将在这里提及：'
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is a convenient formula we can use to calculate the Fibonacci numbers.
    We will need the golden ratio and the array from the previous step in this recipe
    as input parameters. Print the first nine Fibonacci numbers to check the result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用一个方便的公式来计算斐波那契数。 我们将需要黄金比例和该秘籍中上一步中的数组作为输入参数。 打印前九个斐波那契数字以检查结果：
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I could have made a unit test instead of a print statement. A unit test is a
    test that tests a small unit of code, such as a function. This variation of the
    recipe is left as an exercise for you.
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以进行单元测试而不是打印声明。 单元测试是测试一小段代码（例如函数）的测试。 秘籍的这种变化是您的练习。
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take a look at [Chapter 8](ch08.xhtml "Chapter 8. Quality Assurance"), *Quality
    Assurance*, for pointers on how to write a unit test.
  prefs: []
  type: TYPE_NORMAL
  zh: 查看第 8 章，“质量保证”，以获取有关如何编写单元测试的指针。
- en: 'We are not starting with the number 0 here, by the way. The aforementioned
    code gives us a series as expected:'
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，我们不是从数字 0 开始的。 上面的代码给了我们一系列预期的结果：
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can plug this right into a unit test, if you want.
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要将此权限插入单元测试。
- en: Convert to integers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换为整数。
- en: 'This step is optional. I think it''s nice to have an integer result at the
    end. Okay, I actually wanted to show you the `astype()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤是可选的。 我认为最后有一个整数结果是很好的。 好的，我实际上想向您展示`astype()`函数：
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code gives us the following result, after snipping a bit for brevity:'
  prefs: []
  type: TYPE_NORMAL
  zh: 为简短起见，此代码为我们提供了以下结果：
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Select the even-valued terms.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择偶数项。
- en: 'This recipe demands that we select the even-valued terms now. This should be
    easy for you if you followed the *Indexing with Booleans* recipe in [Chapter 2](ch02.xhtml
    "Chapter 2. Advanced Indexing and Array Concepts"), *Advanced Indexing and Array
    Concepts*:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此秘籍要求我们现在选择偶数项。 如果遵循第二章，“高级索引和数组概念”中的“布尔值索引”秘籍，这对您来说应该很容易 ：
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There we go:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始吧：
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'In this recipe, we used the `sqrt()`, `log()`, `arange()`, `astype()`, and
    `sum()` functions. Their description is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在此秘籍中，我们使用了`sqrt()`，`log()`，`arange()`，`astype()`和`sum()`函数。 其描述如下：
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `sqrt()` | This function calculates the square root of array elements (see
    [http://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `sqrt()` | 此函数计算数组元素的平方根（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sqrt.html)）
    |'
- en: '| `log()` | This function calculates the natural logarithm of array elements
    (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html#numpy.log](http://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html#numpy.log))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `log()` | 此函数计算数组元素的自然对数（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.log.html#numpy.log`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.log.html#numpy.log)）
    |'
- en: '| `arange()` | This function creates an array with the specified range (see
    [http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `arange()` | 此函数创建具有指定范围的数组（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.arange.html)）
    |'
- en: '| `astype()` | This function converts array elements to a specified data type
    (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `astype()` | 此函数将数组元素转换为指定的数据类型（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.chararray.astype.html)）
    |'
- en: '| `sum()` | This function calculates the sum of array elements (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `sum()` | 此函数计算数组元素的总和（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html)）
    |'
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Indexing with Booleans* recipe in [Chapter 2](ch02.xhtml "Chapter 2. Advanced
    Indexing and Array Concepts"), *Advanced Indexing and Array Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二章，“高级索引和数组概念”中的“布尔值索引”秘籍
- en: Finding prime factors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找质因数
- en: '**Prime** **factors** ([http://en.wikipedia.org/wiki/Prime_factor](http://en.wikipedia.org/wiki/Prime_factor))
    are prime numbers that exactly divide an integer without leaving a remainder.
    Finding prime factors seems almost impossible for big numbers. Therefore, prime
    factors have an application in cryptography. However, using the right algorithm—Fermat''s
    factorization method ([http://en.wikipedia.org/wiki/Fermat%27s_factorization_method](http://en.wikipedia.org/wiki/Fermat%27s_factorization_method))
    and NumPy—factoring becomes relatively easy for small numbers. The idea is to
    factor a number *N* into two numbers, *c* and *d*, according to the following
    equation:'
  prefs: []
  type: TYPE_NORMAL
  zh: '**质因数**（[`en.wikipedia.org/wiki/Prime_factor`](http://en.wikipedia.org/wiki/Prime_factor)）是质数，它们精确地除以整数而不会留下余数。 对于较大的数字，找到主要因子似乎几乎是不可能的。
    因此，质因数在密码学中具有应用。 但是，使用正确的算法，费马因式分解方法（[`en.wikipedia.org/wiki/Fermat%27s_factorization_method`](http://en.wikipedia.org/wiki/Fermat%27s_factorization_method)）和
    NumPy，对于小数而言，因式分解变得相对容易。 想法是将`N`分解为两个数字，`c`和`d`，根据以下等式：'
- en: '![Finding prime factors](img/0945_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![查找质因数](img/0945_03_01.jpg)'
- en: We can apply the factorization recursively until we get the required prime factors.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以递归应用因式分解，直到获得所需的素因子。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the entire code needed to solve the problem of finding the
    largest prime factor of 600851475143 (see the `fermatfactor.py` file in this book''s
    code bundle):'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是解决找到最大质数因子 600851475143 的问题所需的全部代码（请参见本书代码包中的`fermatfactor.py`文件）：
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The algorithm requires us to try a number of trial values for `a`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法要求我们为`a`尝试一些试验值：
- en: Create an array of trial values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建试验值的数组。
- en: 'It makes sense to create a NumPy array and eliminate the need for loops. However,
    you should be careful not to create an array that is too big in terms of memory
    requirements. On my system, an array of a million elements seems to be just the
    right size:'
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 NumPy 数组并消除循环需求是有意义的。 但是，应注意不要创建一个在内存需求方面太大的数组。 在我的系统上，一百万个元素的数组似乎正好合适：
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We used the `ceil()` function to return the ceiling of the input, element-wise.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ceil()`函数以元素为单位返回输入的上限。
- en: Get the fractional part of the `b` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取`b`数组的小数部分。
- en: 'We are now supposed to check whether `b` is a square. Use the NumPy `modf()`
    function to get the fractional part of the `b` array:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该检查`b`是否为正方形。 使用 NumPy `modf()`函数获取`b`数组的分数部分：
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Find `0` fractions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`0`分数。
- en: 'Call the `where()` NumPy function to find the indexes of zero fractions, where
    the fractional part is `0`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`where()` NumPy 函数以找到零分数的索引，其中小数部分是`0`：
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Find the first occurrence of a zero fraction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到零分数的第一个出现。
- en: 'First, call the `take()` NumPy function with the `indices` array from the previous
    step to get the values of zero fractions. Now latten this array with the `ravel()`
    NumPy function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用上一步中的`indices`数组调用`take()` NumPy 函数，以获取零分数的值。 现在，使用`ravel()` NumPy 函数将这个数组变得扁平：
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This line is a bit convoluted, but it does demonstrate two useful functions.
    It would have been simpler to write `a = a[indices][0]`.
  prefs: []
  type: TYPE_NORMAL
  zh: 这条线有些令人费解，但是确实演示了两个有用的功能。 写`a = a[indices][0]`会更简单。
- en: 'The output for this code is the following:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We applied the Fermat factorization recursively using the `ceil()`, `modf()`,
    `where()`, `ravel()`, and `take()` NumPy functions. The description of these functions
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`ceil()`，`modf()`，`where()`，`ravel()`和`take()` NumPy 函数递归地应用了费马分解。 这些函数的说明如下：
- en: '| Function | Desciption |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ceil()` | Calculates the ceiling of array elements (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `ceil()` | 计算数组元素的上限（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html)）
    |'
- en: '| `modf()` | Returns the fractional and integral part of floating-point numbers
    (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `modf()` | 返回浮点数数字的分数和整数部分（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.modf.html)）
    |'
- en: '| `where()` | Returns array indices based on condition (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `where()` | 根据条件返回数组索引（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.where.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html)）
    |'
- en: '| `ravel()` | Returns a flattened array (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `ravel()` | 返回一个扁平数组（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.ravel.html)）
    |'
- en: '| `take()` | Takes an element from an array (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html))
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `take()` | 从数组中获取元素（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.take.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.take.html)）
    |'
- en: Finding palindromic numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找回文数
- en: A palindromic number reads the same both ways. The largest palindrome made from
    the product of two 2-digit numbers is 9009 = 91 x 99\. Let's try to find the largest
    palindrome made from the product of two 3-digit numbers.
  prefs: []
  type: TYPE_NORMAL
  zh: 回文数字在两种方式下的读取相同。 由两个 2 位数字的乘积组成的最大回文为`9009 = 91 x 99`。让我们尝试查找由两个 3 位数字的乘积组成的最大回文。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete program from the `palindromic.py` file in this
    book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`palindromic.py`文件的完整程序：
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will create an array to hold three-digit numbers from 100 to 999 using our
    favorite NumPy function, `arange()`.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用最喜欢的 NumPy 函数`arange()`创建一个数组，以容纳从 100 到 999 的三位数。
- en: Create an array of three-digit numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个三位数的数字数组。
- en: 'Check the first and the last element of the array with the `assert_equal()`
    function from the `numpy.testing` package:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`numpy.testing`包中的`assert_equal()`函数检查数组的第一个和最后一个元素：
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Create the products array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建乘积数组。
- en: 'Now we will create an array to hold all the possible products of the elements
    of the three-digit array with itself. We can accomplish this with the `outer()`
    function. The resulting array needs to be flattened with `ravel()` to be able
    to easily iterate over it. Call the `sort()` method on the array to make sure
    that the array is properly sorted. After that, we can do some sanity checks:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个数组，以将三位数数组的元素的所有可能乘积与其自身保持在一起。 我们可以使用`outer()`函数来完成此操作。 需要使用`ravel()`将生成的数组弄平，以便能够轻松地对其进行迭代。
    在数组上调用`sort()`方法，以确保数组正确排序。 之后，我们可以进行一些检查：
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The code prints 906609, which is a palindromic number.
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码打印 906609，它是回文数。
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We saw the `outer()` function in action. This function returns the outer product
    of two arrays ([http://en.wikipedia.org/wiki/Outer_product](http://en.wikipedia.org/wiki/Outer_product)).
    The outer product of two vectors (one-dimensional lists of numbers) creates a
    matrix. This is the opposite of an inner product, which returns a scalar number
    for two vectors. The outer product is used in physics, signal processing, and
    statistics. The `sort()` function returns a sorted copy of an array.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`outer()`函数的作用。 此函数返回两个数组的外积（[`en.wikipedia.org/wiki/Outer_product`](http://en.wikipedia.org/wiki/Outer_product)）。
    两个向量的外积（一维数字列表）创建一个矩阵。 这与内积相反，该乘积返回两个向量的标量数。 外部产品用于物理，信号处理和统计。 `sort()`函数返回数组的排序副本。
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多
- en: It might be a good idea to check the result. Find out which two 3-digit numbers
    produce our palindromic number by modifying the code a bit. Try implementing the
    last step in the NumPy way.
  prefs: []
  type: TYPE_NORMAL
  zh: 检查结果可能是一个好主意。 稍微修改一下代码，找出哪两个 3 位数字产生我们的回文码。 尝试以 NumPy 方式实现最后一步。
- en: The steady state vector
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳态向量
- en: A **Markov chain** is a system that has at least two states. For detailed information
    on Markov chains, please refer to [http://en.wikipedia.org/wiki/Markov_chain](http://en.wikipedia.org/wiki/Markov_chain).
    The state at time `t` depends on the state at time `t-1`, and only the state at
    `t-1`. The system switches at random between these states. The chain doesn't have
    any memory about the states. Markov chains are often used to model phenomena in
    physics, chemistry, finance, and computer science. For instance, Google's PageRank
    algorithm uses Markov chains to rank web pages.
  prefs: []
  type: TYPE_NORMAL
  zh: '**马尔科夫链**是一个至少具有两个状态的系统。 有关马尔可夫链的详细信息，请参阅[`en.wikipedia.org/wiki/Markov_chain`](http://en.wikipedia.org/wiki/Markov_chain)。
    时间`t`的状态取决于时间`t-1`的状态，仅取决于`t-1`的状态。 系统在这些状态之间随机切换。 链没有关于状态的任何记忆。 马尔可夫链通常用于对物理，化学，金融和计算机科学中的现象进行建模。
    例如，Google 的 PageRank 算法使用马尔可夫链对网页进行排名。'
- en: I would like to define a Markov chain for a stock. Let's say that we have the
    states **flat**, **up**, and **down**. We can determine the steady state based
    on the end-of-the-day close prices.
  prefs: []
  type: TYPE_NORMAL
  zh: 我想为股票定义一个马尔可夫链。 假设状态为**震荡**，**上涨**和**下跌**的状态。 我们可以根据日末收盘价确定稳定状态。
- en: 'Far into the distant future or theoretically after an infinite amount of time,
    the state of our Markov chain system will not change anymore. This is called a
    steady state (see [http://en.wikipedia.org/wiki/Steady_state](http://en.wikipedia.org/wiki/Steady_state)).
    A dynamic equilibrium is a type of steady state. For a stock, achieving a steady
    state may mean that the related company has become stable. The **stochastic matrix**
    (see [http://en.wikipedia.org/wiki/Stochastic_matrix](http://en.wikipedia.org/wiki/Stochastic_matrix))
    *A* contains the state transition probabilities, and when applied to the steady
    state, it yields the same state `x`. The mathematical notation for this is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在遥远的未来，或理论上经过无限长的时间之后，我们的马尔可夫链系统的状态将不再改变。 这称为稳定状态（见[`en.wikipedia.org/wiki/Steady_state`](http://en.wikipedia.org/wiki/Steady_state)）。
    动态平衡是一种稳态。 对于股票而言，达到稳定状态可能意味着关联公司已变得稳定。 **随机矩阵**（见[`en.wikipedia.org/wiki/Stochastic_matrix`](http://en.wikipedia.org/wiki/Stochastic_matrix)）`A`包含状态转移概率，当应用于稳态时，它会产生相同的状态`x`。
    为此的数学符号如下：
- en: '![The steady state vector](img/0945_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![稳态向量](img/0945_03_02.jpg)'
- en: Another way to look at this is as the eigenvector (see [http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors](http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors))
    for eigenvalue 1\. Eigenvalues and eigenvectors are fundamental concepts of linear
    algebra with applications in quantum mechanics, machine learning, and other sciences.
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的另一种方法是特征值和特征向量（见[`en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors`](http://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors)）。特征值和特征向量是线性代数的基本概念，并且在量子力学，机器学习和其他科学中应用。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete code for the steady state vector example from
    the `steady_state_vector.py` file in this book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`steady_state_vector.py`文件中稳态向量示例的完整代码：
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now we need to obtain the data:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要获取数据：
- en: Obtain 1 year of data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取一年的数据。
- en: 'One way we can do this is with matplotlib (refer to the *Installing matplotlib*
    recipe in [Chapter 1](ch01.xhtml "Chapter 1. Winding Along with IPython"), *Winding
    Along with IPython*, if necessary). We will retrieve the data of the last year.
    Here is the code to do this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 一种实现方法是使用 Matplotlib（请参阅第一章的“安装 Matplotlib”秘籍，如有必要）。 我们将检索去年的数据。 这是执行此操作的代码：
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Select the close price.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择收盘价。
- en: We now have historical data from Yahoo! Finance. The data is represented as
    a list of tuples, but we are only interested in the close price.
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了雅虎金融的历史数据。 数据表示为元组列表，但我们仅对收盘价感兴趣。
- en: 'The first element in the tuple represents the date. It is followed by the open,
    high, low, and close prices. The last element is the volume. We can select the
    close prices as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 元组中的第一个元素代表日期。 其次是开盘价，最高价，最低价和收盘价。 最后一个元素是音量。 我们可以选择以下收盘价：
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The close price is the fifth number in each tuple. We should have a list of
    about 253 close prices now.
  prefs: []
  type: TYPE_NORMAL
  zh: 收盘价是每个元组中的第五个数字。 现在我们应该有大约 253 个收盘价的清单。
- en: Determine the states.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定状态。
- en: 'We can determine the states by subtracting the price of sequential days with
    the `diff()` NumPy function. The state is then given by the sign of the difference.
    The `sign()` NumPy function returns `-1` for a negative number, `1` for a positive
    number, and `0` otherwise:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`diff()` NumPy 函数减去连续天的价格来确定状态。 然后，通过差异的符号给出状态。 `sign()` NumPy 函数返回`-1`为负数，`1`为正数，否则返回`0`。
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Initialize the stochastic matrix to `0` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将随机矩阵初始化为`0`值。
- en: 'We have three possible start states and three possible end states for each
    transition. For instance, if we start from an up state, we could switch to:'
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个过渡，我们有三个可能的开始状态和三个可能的结束状态。 例如，如果我们从启动状态开始，则可以切换到：
- en: Up
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向上
- en: Flat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面
- en: Down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下
- en: 'Initialize the stochastic matrix with the `zeros()` NumPy function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`zeros()` NumPy 函数初始化随机矩阵：
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: For each sign, select the corresponding start state indices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个符号，选择相应的开始状态索引。
- en: 'Now the code becomes a bit messy. We will have to use actual loops! We will
    loop over the possible signs and select the start state indices corresponding
    to each sign. Select the indices with the `where()` NumPy function. Here, `k`
    is a smoothing constant, which we will discuss later on:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码变得有些混乱。 我们将不得不使用实际的循环！ 我们将遍历所有可能的符号，并选择与每个符号相对应的开始状态索引。 使用`where()` NumPy
    函数选择索引。 在这里，`k`是一个平滑常数，我们将在后面讨论：
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Smoothing and the stochastic matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平滑和随机矩阵。
- en: We can now count the number of occurrences of each transition. Dividing it by
    the total number of transitions for a given start state gives us the transition
    probabilities for our stochastic matrix. This is not the best method, by the way,
    since it could be overfitting.
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算每个过渡的出现次数。 将其除以给定开始状态的跃迁总数，就可以得出随机矩阵的跃迁概率。 顺便说一下，这不是最好的方法，因为它可能过度拟合。
- en: 'In real life, we could have a day when the close price does not change, although
    this is unlikely for liquid stock markets. One way to deal with zero occurrences
    is to apply additive smoothing ([http://en.wikipedia.org/wiki/Additive_smoothing](http://en.wikipedia.org/wiki/Additive_smoothing)).
    The idea is to add a certain constant to the number of occurrences we find, getting
    rid of zeroes. The following code calculates the values of the stochastic matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，我们可能有一天收盘价不会发生变化，尽管对于流动性股票市场来说这不太可能。 处理零出现的一种方法是应用加法平滑（[`en.wikipedia.org/wiki/Additive_smoothing`](http://en.wikipedia.org/wiki/Additive_smoothing)）。
    这个想法是在我们发现的出现次数上增加一个常数，以消除零。 以下代码计算随机矩阵的值：
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'What the aforementioned code does is compute the transition probabilities for
    each possible transition based on the number of occurrences and additive smoothing.
    On one of the test runs, I got the following matrix:'
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码所做的是基于出现次数和加性平滑计算每个可能过渡的过渡概率。 在其中一个测试运行中，我得到了以下矩阵：
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Eigenvalues and eigenvectors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特征值和特征向量。
- en: 'To get the eigenvalues and eigenvectors we will need the `linalg` NumPy module
    and the `eig()` function:'
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得特征值和特征向量，我们将需要`linalg` NumPy 模块和`eig()`函数：
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `eig()` function returns an array containing the eigenvalues and another
    array containing the eigenvectors:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`eig()`函数返回一个包含特征值的数组和另一个包含特征向量的数组：'
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Select the eigenvector for eigenvalue 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为特征值`1`选择特征向量。
- en: 'Currently, we are only interested in the eigenvector for eigenvalue `1`. In
    reality, the eigenvalue might not be exactly `1`, so we should build a margin
    for error. We can find the index for eigenvalue between `0.9` and `1.1`, as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只对特征值`1`的特征向量感兴趣。 实际上，特征值可能不完全是`1`，因此我们应该建立误差容限。 我们可以在`0.9`和`1.1`之间找到特征值的索引，如下所示：
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The rest of the output for this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的其余输出如下：
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The values for the eigenvector we get are not normalized. Since we are dealing
    with probabilities, they should sum up to one. The `diff()`, `sign()`, and `eig()`
    functions were introduced in this example. Their descriptions are as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得的特征向量的值未标准化。 由于我们正在处理概率，因此它们应该合计为一个。 在此示例中介绍了`diff()`，`sign()`和`eig()`函数。
    它们的描述如下：
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `diff()` | Calculates the discrete difference. By default, the first order
    (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `diff()` | 计算离散差。 默认情况下是一阶（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html)）。
    |'
- en: '| `sign()` | Returns the sign of array elements (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `sign()` | 返回数组元素的符号（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.sign.html)）。
    |'
- en: '| `eig()` | Returns the eigenvalues and eigenvectors of an array (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `eig()` | 返回数组的特征值和特征向量（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.eig.html)）。
    |'
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Installing matplotlib* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Winding
    Along with IPython"), *Winding Along with IPython*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一章，“使用 IPython”中的“安装 Matplotlib”秘籍
- en: Discovering a power law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索幂律
- en: For the purpose of this recipe, imagine that we are operating a hedge fund.
    Let it sink in; you are part of the one percent now!
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个秘籍目的，假设我们正在经营一家对冲基金。 让它沉入； 您现在是百分之一的一部分！
- en: 'Power laws occur in a lot of places; see [http://en.wikipedia.org/wiki/Power_law](http://en.wikipedia.org/wiki/Power_law)
    for more information. In such a law, one variable is equal to the power of another:'
  prefs: []
  type: TYPE_NORMAL
  zh: 幂律出现在很多地方。 有关更多信息，请参见[`en.wikipedia.org/wiki/Power_law`](http://en.wikipedia.org/wiki/Power_law)。 在这样的定律中，一个变量等于另一个变量的幂：
- en: '![Discovering a power law](img/0945_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![探索幂律](img/0945_03_08.jpg)'
- en: The Pareto principle (see [http://en.wikipedia.org/wiki/Pareto_principle](http://en.wikipedia.org/wiki/Pareto_principle))
    for instance, is a power law. It states that wealth is unevenly distributed. This
    principle tells us that if we group people by their wealth, the size of the groups
    will vary exponentially. To put it simply, there are not a lot of rich people,
    and there are even less billionaires; hence the one percent.
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，帕累托原理（见[`en.wikipedia.org/wiki/Pareto_principle`](http://en.wikipedia.org/wiki/Pareto_principle)）是幂律。 它指出财富分配不均。 这个原则告诉我们，如果我们按照人们的财富进行分组，则分组的规模将成倍地变化。
    简而言之，富人不多，亿万富翁更少。 因此是百分之一
- en: Assume that there is a power law in the closing stock prices log returns. This
    is a big assumption, of course, but power law assumptions seem to pop up all over
    the place.
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在收盘价对数回报中存在幂定律。 当然，这是一个很大的假设，但是幂律假设似乎到处都有。
- en: We don't want to trade too often, because of the involved transaction costs
    per trade. Let's say that we would prefer to buy and sell once a month based on
    a significant correction (with other words a big drop). The issue is to determine
    an appropriate signal given that we want to initiate a transaction for every 1
    out of about 20 days.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想交易太频繁，因为每笔交易涉及交易成本。 假设我们希望根据重大调整（换句话说就是大幅下降）每月进行一次买卖。 问题是要确定适当的信号，因为我们要在大约
    20 天内每 1 天启动一次交易。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete code from the `powerlaw.py` file in this book''s
    code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`powerlaw.py`文件的完整代码：
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'First let''s get the historical end-of-day data for the past year from Yahoo!
    Finance. After that, we extract the close prices for this period. These steps
    are described in the previous recipe:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们从雅虎金融获取过去一年的历史日末数据。 之后，我们提取该时段的收盘价。 在上一秘籍中描述了这些步骤：
- en: Get the positive log returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得正的对数回报。
- en: Now calculate the log returns for the close prices. For more information on
    log returns, refer to [http://en.wikipedia.org/wiki/Rate_of_return](http://en.wikipedia.org/wiki/Rate_of_return).
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，计算收盘价的对数回报。 有关对数回报中的更多信息，请参考[`en.wikipedia.org/wiki/Rate_of_return`](http://en.wikipedia.org/wiki/Rate_of_return)。
- en: 'First we will take the log of the close prices, and then compute the first
    difference of these values with the `diff()` NumPy function. Let''s select the
    positive values from the log returns:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将获取收盘价的对数，然后使用`diff()` NumPy 函数计算这些值的第一个差异。 让我们从对数回报中选择正值：
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Get the frequencies of the returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得回报的频率。
- en: 'We need to get the frequencies of the returns with the `histogram()` function.
    Counts and an array of the bins are returned. At the end, we need to take the
    log of the frequencies in order to get a nice linear relation:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`histogram()`函数获得回报的频率。 返回计数和垃圾箱数组。 最后，我们需要记录频率，以获得良好的线性关系：
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Fit the frequencies and returns into a line.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拟合频率并返回一条线。
- en: 'Use the `polyfit()` function to do a linear fit:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`polyfit()`函数进行线性拟合：
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Plot the results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制结果。
- en: 'Finally, we will plot the data and linearly fit it with matplotlib:'
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将绘制数据并将其与 Matplotlib 线性拟合：
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We get a nice plot of the linear fit, returns, and frequencies, like this:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到一个很好的线性拟合，收益率和频率图，如下所示：
- en: '![How to do it...](img/0945_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](img/0945_03_03.jpg)'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: The `histogram()` function calculates the histogram of a dataset. It returns
    the histogram values and bin edges. The `polyfit()` function fits data to a polynomial
    of a given order. In this case, we chose a linear fit. We discovered a power law—you
    have to be careful making such claims, but the evidence looks promising.
  prefs: []
  type: TYPE_NORMAL
  zh: '`histogram()`函数计算数据集的直方图。 它返回直方图值和桶的边界。 `polyfit()`函数将数据拟合给定阶数的多项式。 在这种情况下，我们选择了线性拟合。
    我们发现了幂律法——您必须谨慎地提出此类主张，但证据看起来很有希望。'
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Installing matplotlib* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Winding
    Along with IPython"), *Winding Along with IPython*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一章，“使用 IPython”中的“安装 Matplotlib”秘籍
- en: The documentation page for the `histogram()` function at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`histogram()`函数的文档页面位于[`docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.histogram.html)'
- en: The documentation page for the `polyfit()` function at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polyfit()`函数的文档页面位于[`docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.polyfit.html)'
- en: Trading periodically on dips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逢低定期交易
- en: Stock prices periodically dip and go up. We will take a look at the probability
    distribution of the stock price log returns and try a very simple strategy. This
    strategy is based on regression towards the mean. This is a concept originally
    discovered in genetics by Sir Francis Galton. It was discovered that children
    of tall parents tend to be shorter than their parents. Children of short parents
    tend to be taller than their parents. Of course, this is a statistical phenomenon
    and doesn't take into account fundamental factors and trends such as improvement
    in nutrition. Regression towards the mean is also relevant to the stock market.
    However, it gives no guarantees. If a company starts making bad products or makes
    bad investments, regression towards the mean will not save the stock.
  prefs: []
  type: TYPE_NORMAL
  zh: 股票价格周期性地下跌和上涨。 我们将研究股价对数收益的概率分布，并尝试一个非常简单的策略。 该策略基于对均值的回归。 这是弗朗西斯·高尔顿爵士最初在遗传学中发现的一个概念。
    据发现，高大父母的孩子往往比父母矮。 矮小父母的孩子往往比父母高。 当然，这是一种统计现象，没有考虑基本因素和趋势，例如营养改善。 均值回归也与股票市场有关。
    但是，它不提供任何保证。 如果公司开始生产不良产品或进行不良投资，则对均值的回归将无法节省股票。
- en: Let's start by downloading the historical data for a stock, for instance, AAPL.
    Next, we calculate the daily log returns ([http://en.wikipedia.org/wiki/Rate_of_return](http://en.wikipedia.org/wiki/Rate_of_return))
    of the close prices. We will skip these steps since they were already done in
    the previous recipe.
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先下载股票的历史数据，例如`AAPL`。 接下来，我们计算收盘价的每日对数回报率（[`en.wikipedia.org/wiki/Rate_of_return`](http://en.wikipedia.org/wiki/Rate_of_return)）。
    我们将跳过这些步骤，因为它们在上一个秘籍中已经完成。
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: If necessary, install matplotlib and SciPy. Refer to the *See also* section
    for the corresponding recipes.
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，安装 Matplotlib 和 SciPy。 有关相应的秘籍，请参见“另请参见”部分。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete code from the `periodic.py` file in this book''s
    code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`periodic.py`文件的完整代码：
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now comes the interesting part:'
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来了有趣的部分：
- en: Calculate the breakout and pullback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算突破和回调。
- en: Let's say we want to trade five times a year, or roughly, every 50 days. One
    strategy would be to buy when the price drops by a certain percentage (a pullback),
    and sell when the price increases by another percentage (a breakout).
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们要每年进行五次交易，大约每 50 天进行一次。 一种策略是在价格下跌一定百分比时进行买入（回调），而在价格上涨另一百分比时进行卖出（突破）。
- en: 'By setting the percentile appropriate for our trading frequency, we can match
    the corresponding log returns. SciPy offers the `scoreatpercentile()` function,
    which we will use:'
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置适合我们交易频率的百分比，我们可以匹配相应的对数回报。 SciPy 提供`scoreatpercentile()`函数，我们将使用：
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Generate buys and sells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 产生买卖。
- en: 'Use the `compress()` NumPy function to generate buys and sells for our close
    price data. This function returns elements based on a condition:'
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`compress()` NumPy 函数为我们的收盘价数据生成买卖。 该函数根据条件返回元素：
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output for AAPL and a 50-day period is as follows:'
  prefs: []
  type: TYPE_NORMAL
  zh: '`AAPL`和 50 天期间的输出如下：'
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Thus, we have a loss of 52 dollars if we buy and sell an AAPL share five times.
    When I ran the script, the entire market was in recovery mode after a correction.
    You may want to look at not just the AAPL stock price but maybe the ratio of AAPL
    and SPY. SPY can be used as a proxy for the U.S. stock market.
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们买卖`AAPL`股票五次，我们将损失 52 美元。 当我运行脚本时，经过更正后整个市场都处于恢复模式。 您可能不仅要查看`AAPL`的股价，还可能要查看`APL`和`SPY`的比率。
    `SPY`可以用作美国股票市场的代理。
- en: Plot a histogram of the log returns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制对数回报的直方图。
- en: 'Just for fun, let''s plot the histogram of the log returns with matplotlib:'
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，让我们用 Matplotlib 绘制对数回报的直方图：
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is what the histogram looks like:'
  prefs: []
  type: TYPE_NORMAL
  zh: 直方图如下所示：
- en: '![How to do it...](img/0945_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](img/0945_03_04.jpg)'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: We encountered the `compress()` function, which returns an array containing
    the array elements of the input that satisfy a given condition. The input array
    remains unchanged.
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遇到了`compress()`函数，该函数返回一个数组，其中包含满足给定条件的输入的数组元素。 输入数组保持不变。
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Installing matplotlib* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Winding
    Along with IPython"), *Winding Along with IPython*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一章，“使用 IPython”中的“安装 Matplotlib”秘籍
- en: The Installing SciPy recipe in [Chapter 2](ch02.xhtml "Chapter 2. Advanced Indexing
    and Array Concepts"), *Advanced Indexing and Array Concepts*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二章，“高级索引和数组概念”中的“安装 SciPy”秘籍
- en: The Discovering a power law recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的“发现幂律”秘籍
- en: The documentation page for the `compress()` function at [http://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`compress()`函数文档页面](http://docs.scipy.org/doc/numpy/reference/generated/numpy.compress.html)'
- en: Simulating trading at random
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机模拟交易
- en: In the previous recipe, we tried out a trading idea. However, we have no benchmark
    that can tell us whether the result we got was any good. It is common in such
    cases to trade at random under the assumption that we should be able to beat a
    random process. We will simulate trading by taking some random days from a trading
    year. This should illustrate working with random numbers using NumPy.
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的秘籍中，我们尝试了一种交易想法。 但是，我们没有基准可以告诉我们所获得的结果是否良好。 在这种情况下，通常以我们应该能够击败随机过程为前提进行随机交易。
    我们将从交易年度中随机抽出几天来模拟交易。 这应该说明使用 NumPy 处理随机数。
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: If necessary, install matplotlib. Refer to the *See also* section of the corresponding
    recipe.
  prefs: []
  type: TYPE_NORMAL
  zh: 如有必要，安装 Matplotlib。 请参考相应秘籍的“另请参见”部分。
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The following is the complete code from the `random_periodic.py` file in this
    book''s code bundle:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本书代码包中`random_periodic.py`文件的完整代码：
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'First we need an array filled with random integers:'
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个数组，其中填充了随机整数：
- en: Generate random indices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成随机索引。
- en: 'You can generate random integers with the `randint()` NumPy function. This
    will be linked to random days of a trading year:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`randint()` NumPy 函数生成随机整数。 这将与一个交易年度的随机日期相关联：
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Simulate trades.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟交易。
- en: 'You can simulate trades with the random indices from the previous step. Use
    the `take()` NumPy function to extract random close prices from the array of step
    1:'
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一步中的随机指数来模拟交易。 使用`take()` NumPy 函数从步骤 1 的数组中提取随机收盘价：
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Plot a histogram of the profits for a large number of simulations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制大量模拟的利润直方图：
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is a screenshot of the resulting histogram of 2,000 simulations for AAPL,
    with five buys and sells in a year:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`AAPL`的 2,000 个模拟结果的直方图的屏幕截图，一年内进行了五次买卖：
- en: '![How to do it...](img/0945_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](img/0945_03_05.jpg)'
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'We used the `randint()` function, which can be found in the `numpy.random`
    module. This module contains more convenient random generators, as described in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`randint()`函数，该函数可以在`numpy.random`模块中找到。 该模块包含更方便的随机生成器，如下表所述：
- en: '| Function | Desciption |'
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `rand()` | Creates an array from a uniform distribution over [0,1] with a
    shape based on dimension parameters. If no dimensions are specified, a single
    float is returned (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `rand()` | 从`[0,1]`上的均匀分布中创建一个数组，其形状基于大小参数。 如果未指定大小，则返回单个浮点数（见[`/docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.rand.html)）。
    |'
- en: '| `randn()` | Sample values from the normal distribution with mean `0` and
    variance `1`. The dimension parameters function the same as for `rand()` (see
    [http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `randn()` | 从均值`0`和方差`1`的正态分布中采样值。 大小参数的作用与`rand()`相同（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randn.html)）。
    |'
- en: '| `randint()` | Returns an integer array given a low boundary, an optional
    high bound, and an optional output shape (see [http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html)).
    |'
  prefs: []
  type: TYPE_TB
  zh: '| `randint()` | 返回一个给定下限，可选上限和可选输出形状的整数数组（见[`docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html`](http://docs.scipy.org/doc/numpy/reference/generated/numpy.random.randint.html)）。
    |'
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另见
- en: The *Installing matplotlib* recipe in [Chapter 1](ch01.xhtml "Chapter 1. Winding
    Along with IPython"), *Winding Along with IPython*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一章，“使用 IPython”中的“安装 Matplotlib”秘籍
- en: Sieving integers with the Sieve of Eratosthenes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用埃拉托色尼筛子筛选质数
- en: The **Sieve of** **Eratosthenes** (see [http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes))
    is an algorithm that filters prime numbers. It iteratively identifies multiples
    of found primes. The multiples are, by definition, not primes and can be eliminated.
    This sieve is efficient for primes less than 10 million. Let's now try to find
    the 10001st prime number.
  prefs: []
  type: TYPE_NORMAL
  zh: '埃拉托色尼筛子（[`en.wikipedia.org/wiki/Sieve_of_Eratosthenes`](http://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)）是一种过滤质数的算法。
    迭代地标识找到的质数的倍数。 根据定义，倍数不是质数，可以消除。 此筛子对于不到 1000 万的质数有效。 现在让我们尝试找到第 10001 个质数。'
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'The first mandatory step is to create a list of natural numbers:'
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建自然数列表：
- en: 'Create a list of consecutive integers. NumPy has the `arange()` function for
    that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连续整数列表。 NumPy 为此具有`arange()`函数：
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Sieve out the multiples of `p`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 筛选出`p`的倍数。
- en: 'We are not sure if this is what Eratosthenes wanted us to do, but it works.
    In the following code, we are passing a NumPy array and getting rid of all the
    elements that have a zero remainder when divided by `p`:'
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不确定这是否是埃拉托色尼想要我们做的，但是它有效。 在下面的代码中，我们传递 NumPy 数组，并去除除以`p`时余数为零的所有元素：
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the entire code for this problem:'
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是此问题的完整代码：
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
