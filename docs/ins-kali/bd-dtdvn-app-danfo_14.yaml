- en: '*Chapter 11*: Building a Recommendation System with Danfo.js and TensorFlow.js'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：使用Danfo.js和TensorFlow.js构建推荐系统'
- en: In the preceding chapter, we introduced you to TensorFlow.js and showed you
    how to create a simple regression model to predict sales prices. In this chapter,
    we'll take this a step further by creating a recommendation system that can recommend
    movies for different users while taking into account a user preference. By the
    end of this chapter, you will understand how recommendation systems work, as well
    as how to build one with JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们向您介绍了TensorFlow.js，并向您展示了如何创建一个简单的回归模型来预测销售价格。在本章中，我们将进一步创建一个推荐系统，可以根据用户的偏好向不同用户推荐电影。通过本章的学习，您将了解推荐系统的工作原理，以及如何使用JavaScript构建一个推荐系统。
- en: 'Specifically, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: What is a recommendation system?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推荐系统是什么？
- en: The neural network approach to creating a recommendation system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建推荐系统的神经网络方法
- en: Building a movie recommendation system
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建电影推荐系统
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along in this chapter, you will need the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在本章中跟进，您将需要以下内容：
- en: A modern browser such as Chrome, Safari, Opera, or Firefox
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代浏览器，如Chrome、Safari、Opera或Firefox
- en: '**Node.js**, **Danfo.js**, TensorFlow.js, and (optionally) **Dnotebook** installed
    on your system'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**、**Danfo.js**、TensorFlow.js和（可选）**Dnotebook**已安装在您的系统上'
- en: A stable internet connection for downloading a dataset
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 稳定的互联网连接用于下载数据集
- en: The code for this chapter is available and can be cloned from GitHub at [https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的代码可在GitHub上找到并克隆：[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)
- en: The installation instructions for Danfo.js, TensorFlow.js, and Dnotebook can
    be found in [*Chapter 3*](B17076_03_ePub_RK.xhtml#_idTextAnchor066)*, Getting
    Started with Danfo.js*, [*Chapter 10*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*,
    Introduction to TensorFlow.js*, and [*Chapter 2*](B17076_02_ePub_RK.xhtml#_idTextAnchor045)*,
    Dnotebook – An Interactive Computing Environment for JavaScript*, respectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Danfo.js、TensorFlow.js和Dnotebook的安装说明可以在[*第3章*](B17076_03_ePub_RK.xhtml#_idTextAnchor066)*，使用Danfo.js入门*，[*第10章*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*，TensorFlow.js简介*和[*第2章*](B17076_02_ePub_RK.xhtml#_idTextAnchor045)*，Dnotebook
    - JavaScript交互计算环境*中找到。
- en: What is a recommendation system?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是推荐系统？
- en: A **recommendation system** is any system that can predict a preference or a
    usefulness score given to an item by a user. Using this preference score, it can
    recommend items to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**推荐系统**是任何可以预测用户对物品的偏好或有用性评分的系统。利用这个偏好评分，它可以向用户推荐物品。'
- en: Items here can be digital products such as movies, music, books, and even clothes.
    The goal of every recommendation system is to be able to recommend items that
    the user will like.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的物品可以是数字产品，如电影、音乐、书籍，甚至衣服。每个推荐系统的目标是能够推荐用户会喜欢的物品。
- en: 'Recommendation systems are very popular and can be found almost everywhere;
    for example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统非常受欢迎，几乎无处不在；例如：
- en: Movie streaming platforms such as *Netflix*, *Amazon Prime*, *Hulu*, and *Disney+*
    use recommendation systems for recommending movies to you.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如*Netflix*、*Amazon Prime*、*Hulu*和*Disney+*等电影流媒体平台使用推荐系统向您推荐电影。
- en: Social media websites such as *Facebook*, *Twitter*, and *Instagram* use recommendation
    systems for recommending friends to connect with.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如*Facebook*、*Twitter*和*Instagram*等社交媒体网站使用推荐系统向用户推荐朋友。
- en: E-commerce websites such as *Amazon* and *AliExpress* use recommendation systems
    for recommending products such as clothes, books, and electronics.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如*Amazon*和*AliExpress*等电子商务网站使用推荐系统向用户推荐衣服、书籍和电子产品等产品。
- en: Recommendation systems are mostly built using data from user-item interaction.
    Hence, there are three major approaches that are followed when building recommendation
    systems. These are **collaborative filtering**, **content-based filtering**, and
    the **hybrid approach**. We'll briefly explain these approaches in the following
    sub-sections.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐系统主要是使用用户-物品互动的数据构建的。因此，在构建推荐系统时，通常遵循三种主要方法。这些方法是**协同过滤**、**基于内容的过滤**和**混合方法**。我们将在以下子章节中简要解释这些方法。
- en: Collaborative filtering approach
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协同过滤方法
- en: 'In the collaborative filtering approach, the recommendation system is modeled
    based on users'' past behavior or history. That is, this approach leverages existing
    user interactions such as ratings, likes, or reviews for items to model the user''s
    preference, thereby understanding what the user likes. The following diagram shows
    how the collaborative filtering approach helps with building a recommendation
    system:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在协同过滤方法中，推荐系统是基于用户的过去行为或历史建模的。也就是说，这种方法利用现有的用户互动，如对物品的评分、喜欢或评论，来建模用户的偏好，从而了解用户喜欢什么。下图显示了协同过滤方法如何帮助构建推荐系统：
- en: '![Figure 11.1 – Collaborative filtering approach to building a recommendation
    system'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.1 - 基于协同过滤的推荐系统构建方法'
- en: '](img/B17076_11_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_01.jpg)'
- en: Figure 11.1 – Collaborative filtering approach to building a recommendation
    system
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 - 基于协同过滤的推荐系统构建方法
- en: In the preceding diagram, you can see that two users who have seen the same
    movie, and probably rated the same way, are grouped as similar users, since the
    movie that's been seen by the person on the left has been recommended to the person
    on the right. In the content-based filtering approach, the recommendation system
    is modeled based on **item characteristics**. That is, items may be pre-tagged
    with certain characteristics such as category, price, genre, size, and ratings
    received, and using these characteristics, the recommendation system can recommend
    similar items.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到两个观看了相同电影，可能评分相同的用户被分为相似用户，因为左边的人看过的电影被推荐给了右边的人。在基于内容的过滤方法中，推荐系统是基于**物品特征**建模的。也就是说，物品可能预先标记有某些特征，比如类别、价格、流派、大小和收到的评分，利用这些特征，推荐系统可以推荐相似的物品。
- en: 'The following diagram shows how the content-based filtering approach to building
    a recommendation system works:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了基于内容的过滤方法构建推荐系统的工作原理：
- en: '![Figure 11.2 – Content-based filtering approach to building a recommendation
    system'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 - 基于内容的过滤方法构建推荐系统'
- en: '](img/B17076_11_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_02.jpg)'
- en: Figure 11.2 – Content-based filtering approach to building a recommendation
    system
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 - 基于内容的过滤方法构建推荐系统
- en: In the preceding diagram, you can observe that movies similar to each other
    get recommended to a user.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以观察到相互相似的电影会被推荐给用户。
- en: Hybrid filtering approach
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合过滤方法
- en: The hybrid approach, as its name suggests, is a combination of the collaborative
    and content-based filtering approaches. That is, it combines the best of both
    approaches to create an even better recommendation system. The majority of real-world
    recommendation systems today use this approach to mitigate the shortcomings of
    individual approaches.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 混合方法，顾名思义，是协同和基于内容的过滤方法的结合。也就是说，它结合了两种方法的优点，创建了一个更好的推荐系统。大多数现实世界的推荐系统今天都使用这种方法来减轻各种方法的缺点。
- en: 'The following diagram shows one way of combining the content-based filtering
    approach with the collaborative filtering approach to create a hybrid recommendation
    system:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了将基于内容的过滤方法与协同过滤方法相结合，创建混合推荐系统的一种方式：
- en: '![Figure 11.3 – The hybrid approach to building a recommendation system'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 - 构建推荐系统的混合方法'
- en: '](img/B17076_11_03.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_03.jpg)'
- en: Figure 11.3 – The hybrid approach to building a recommendation system
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 - 构建推荐系统的混合方法
- en: In the preceding diagram, you can see that we have two inputs feeding the hybrid
    system. These inputs go into the collaborative (**CF**) and content-based systems,
    and then the output from these systems gets combined. This combination can be
    customized and can even serve as input to other advanced systems such as neural
    networks. The overall goal here is to create a powerful hybrid system by combining
    multiple recommendation systems.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，您可以看到我们有两个输入输入混合系统。这些输入进入协同(**CF**)和基于内容的系统，然后这些系统的输出被结合起来。这种组合可以定制，甚至可以作为其他高级系统的输入，比如神经网络。总体目标是通过结合多个推荐系统来创建一个强大的混合系统。
- en: It is worth mentioning that any approach that's used in creating a recommendation
    system will need one form of data or the other. For example, in the collaborative
    filtering approach, you will need the *user-item interaction* history, while for
    the content-based approach, you'll need *item metadata*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，任何用于创建推荐系统的方法都需要某种形式的数据。例如，在协同过滤方法中，您将需要*用户-物品交互*历史记录，而在基于内容的方法中，您将需要*物品元数据*。
- en: If you have enough data to train a recommendation system, you can leverage numerous
    machine and non-machine learning techniques to model the data before making recommendations.
    Some popular algorithms you can use are **K-nearest neighbor** ([https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm)),
    **clustering algorithms** ([https://en.wikipedia.org/wiki/Cluster_analysis](https://en.wikipedia.org/wiki/Cluster_analysis)),
    **decision trees** ([https://en.wikipedia.org/wiki/Decision_trees](https://en.wikipedia.org/wiki/Decision_trees)),
    **Bayesian** **classifiers** ([https://en.wikipedia.org/wiki/Naive_Bayes_classifier](https://en.wikipedia.org/wiki/Naive_Bayes_classifier)),
    and even **artificial neural networks** ([https://en.wikipedia.org/wiki/Artificial_neural_networks](https://en.wikipedia.org/wiki/Artificial_neural_networks)).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有足够的数据来训练一个推荐系统，您可以利用众多的机器学习和非机器学习技术来对数据进行建模，然后再进行推荐。您可以使用一些流行的算法，比如**K最近邻**([https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm](https://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm))、**聚类算法**([https://en.wikipedia.org/wiki/Cluster_analysis](https://en.wikipedia.org/wiki/Cluster_analysis))、**决策树**([https://en.wikipedia.org/wiki/Decision_trees](https://en.wikipedia.org/wiki/Decision_trees))、**贝叶斯分类器**([https://en.wikipedia.org/wiki/Naive_Bayes_classifier](https://en.wikipedia.org/wiki/Naive_Bayes_classifier))，甚至**人工神经网络**([https://en.wikipedia.org/wiki/Artificial_neural_networks](https://en.wikipedia.org/wiki/Artificial_neural_networks))。
- en: In this chapter, we'll use the **neural network** approach to build a recommendation
    system. We'll explain this in detail in the following section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用**神经网络**方法来构建推荐系统。我们将在下一节中详细解释这一点。
- en: The neural network approach to creating a recommendation system
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建推荐系统的神经网络方法
- en: In recent years, neural networks have been the Swiss army knife when it comes
    to solving many problems in the field of **machine learning** (**ML**). This is
    evident in areas of ML breakthroughs such as **image classification**/**segmentation**
    and **natural language processing**. With the availability of data, neural networks
    have been successfully used to build large-scale recommendation systems such as
    the ones used at *Netflix* ([https://research.netflix.com/research-area/machine-learning](https://research.netflix.com/research-area/machine-learning))
    and *YouTube* ([https://research.google/pubs/pub45530/](https://research.google/pubs/pub45530/)).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，神经网络在解决机器学习（ML）领域的许多问题时已成为瑞士军刀。这在ML突破领域明显，如图像分类/分割和自然语言处理。随着数据的可用性，神经网络已成功用于构建大规模推荐系统，如Netflix（https://research.netflix.com/research-area/machine-learning）和YouTube（https://research.google/pubs/pub45530/）使用的系统。
- en: 'Although there are different approaches to building a recommendation system
    with neural networks, they all rely on one major fact: they need an efficient
    way to learn similarities between items or users. In this chapter, we''ll leverage
    a concept called **embeddings** to efficiently learn these similarities so that
    we can easily power our recommendation system.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有不同的方法来使用神经网络构建推荐系统，但它们都依赖于一个主要事实：它们需要一种有效的方法来学习项目或用户之间的相似性。在本章中，我们将利用一种称为嵌入的概念来有效地学习这些相似性，以便轻松地为我们的推荐系统提供动力。
- en: But first, what are embeddings and why are we using them? In the next sub-section,
    we'll briefly answer these questions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，嵌入是什么，为什么我们在使用它们？在下一小节中，我们将简要回答这些问题。
- en: What is an embedding?
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是嵌入？
- en: 'An embedding is a mapping of discrete variables to continuous or real-valued
    variables. That is, given a set of variables such as `[good, bad]`, an embedding
    can map each discrete item to a continuous vector of *n* dimensions – for example,
    good can be represented as `[0.1, 0.6, 0.1, 0.8]` and bad can be represented as
    `[0.8, 0.2, 0.6, 0.1]`, as shown in the following figure:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌入是将离散变量映射到连续或实值变量的映射。也就是说，给定一组变量，例如[好，坏]，嵌入可以将每个离散项映射到*n*维的连续向量 - 例如，好可以表示为[0.1,
    0.6, 0.1, 0.8]，坏可以表示为[0.8, 0.2, 0.6, 0.1]，如下图所示：
- en: '![Figure 11.4 – Representing discrete categories with real-valued variables'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 - 用实值变量表示离散类别'
- en: '](img/B17076_11_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_04.jpg)'
- en: Figure 11.4 – Representing discrete categories with real-valued variables
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 - 用实值变量表示离散类别
- en: If you're familiar with encoding schemes such as **one-hot encoding** ([https://en.wikipedia.org/wiki/One-hot](https://en.wikipedia.org/wiki/One-hot))
    or **label encoding** ([https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/](https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/)),
    then you might be wondering how embedding is different from them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉诸如独热编码（https://en.wikipedia.org/wiki/One-hot）或标签编码（https://machinelearningmastery.com/one-hot-encoding-for-categorical-data/）等编码方案，那么您可能想知道嵌入与它们有何不同。
- en: 'Well, there are two major differences and, technically, advantages of embedding:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '嗯，嵌入有两个主要的区别，技术上来说，是优势： '
- en: Embedding representations can be small or large, depending on the specified
    dimension. This is different from encoding schemes such as one-hot encoding, where
    the dimensionality of the representation increases with the number of discrete
    classes.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入表示可以是小的或大的，具体取决于指定的维度。这与独热编码等编码方案不同，其中表示的维度随着离散类的数量增加而增加。
- en: 'For example, the following figure shows how the dimension that''s used by the
    one-hot encoding representation increases with the number of unique countries:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下图显示了一个独热编码表示中使用的维度随着唯一国家数量的增加而增加：
- en: '![Figure 11.5 – Size comparison between embeddings and one-hot encoding'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 - 嵌入和独热编码之间的大小比较'
- en: '](img/B17076_11_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_05.jpg)'
- en: Figure 11.5 – Size comparison between embeddings and one-hot encoding
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 - 嵌入和独热编码之间的大小比较
- en: 'Embeddings can be learned alongside weights in neural networks. This is the
    major advantage over other encoding schemes because, with this property, learned
    embeddings become a similarity cluster of discrete classes, which means that you
    can easily find similar items or users. For example, looking at the following
    proofed, you can see that we have two groups of learned word embeddings:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入可以与神经网络中的权重一起学习。这是与其他编码方案相比的主要优势，因为具有此属性，学习的嵌入成为离散类的相似性集群，这意味着您可以轻松找到相似的项目或用户。例如，查看以下证明，您可以看到我们有两组学习的单词嵌入：
- en: '![Figure 11.6 – Embedding words and showing similarity in an embedding space
    (Redrawn from: https://medium.com/@hari4om/word-embedding-d816f643140)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.6 - 嵌入单词并在嵌入空间中显示相似性（重新绘制自：https://medium.com/@hari4om/word-embedding-d816f643140）'
- en: '](img/B17076_11_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_06.jpg)'
- en: 'Figure 11.6 – Embedding words and showing similarity in an embedding space
    (Redrawn from: https://medium.com/@hari4om/word-embedding-d816f643140)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.6 - 嵌入单词并在嵌入空间中显示相似性（重新绘制自：https://medium.com/@hari4om/word-embedding-d816f643140）
- en: In the preceding figure, you can see that the group depicting **man**, **woman**,
    **king**, and **queen** is being passed through an embedding and that the resulting
    output is an embedding space, where words that are closer in meaning are grouped.
    This is made possible by the learned word *embedding*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，您可以看到代表男人，女人，国王和皇后的组被传递到嵌入中，结果输出是一个嵌入空间，其中意义相近的单词被分组。这是通过学习的单词嵌入实现的。
- en: So, how do we leverage embeddings to create a recommendation system? Well, as
    we mentioned previously, embeddings can efficiently represent data, which means
    we can use them to learn or represent user-item interaction. As such, we can easily
    use learned embeddings to find similar items to recommend. We can even take this
    further by combining an embedding with a supervised machine learning task.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何利用嵌入来创建推荐系统呢？嗯，正如我们之前提到的，嵌入可以有效地表示数据，这意味着我们可以使用它们来学习或表示用户-项目的交互。因此，我们可以轻松地使用学习到的嵌入来找到相似的项目进行推荐。我们甚至可以进一步将嵌入与监督机器学习任务相结合。
- en: This approach of combining a learned embedding representation with a supervised
    ML task is what we'll do in the next section to create our movie recommendation
    system.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将学习到的嵌入表示与监督机器学习任务相结合的这种方法，将是我们在下一节中创建电影推荐系统的做法。
- en: Building a movie recommendation system
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建电影推荐系统
- en: To build a movie recommendation system, we need some kind of user-movie interaction
    dataset. Fortunately, we can use the `MovieLens 100k` dataset ([https://grouplens.org/datasets/movielens/100k/](https://grouplens.org/datasets/movielens/100k/))
    provided by **Grouplens** ([https://grouplens.org/](https://grouplens.org/)).
    This data contains 100,000 movie ratings given by 1,000 users on 1,700 movies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个电影推荐系统，我们需要某种用户-电影交互数据集。幸运的是，我们可以使用由**Grouplens**提供的`MovieLens 100k`数据集（[https://grouplens.org/datasets/movielens/100k/](https://grouplens.org/datasets/movielens/100k/)）。这个数据包含了1,000个用户对1,700部电影的100,000个电影评分。
- en: 'The following screenshot shows the first few rows of the dataset:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了数据集的前几行：
- en: '![Figure 11.7 – The first few rows of the MovieLens dataset'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.7 - MovieLens数据集的前几行'
- en: '](img/B17076_11_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_07.jpg)'
- en: Figure 11.7 – The first few rows of the MovieLens dataset
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.7 - MovieLens数据集的前几行
- en: From the preceding screenshot, you can see that we have `user_id`, `item_id`
    (movies), and the rating the user gave to the item (movie). With just this interaction
    and the use of embeddings, we can efficiently model the behavior of users and,
    as such, learn what kind of movies they like.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的截图中，您可以看到我们有`user_id`，`item_id`（电影）以及用户给予项目（电影）的评分。仅凭这种交互和使用嵌入，我们就可以有效地建模用户的行为，并因此了解他们喜欢什么类型的电影。
- en: 'To understand how we''ll build and learn this interaction with embeddings and
    a neural network, please refer to the following architecture diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们将如何构建和学习嵌入与神经网络的交互，请参考以下架构图：
- en: '![Figure 11.8 – High-level architecture of our recommendation system'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.8 - 我们推荐系统的高层架构'
- en: '](img/B17076_11_08.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_08.jpg)'
- en: Figure 11.8 – High-level architecture of our recommendation system
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 - 我们推荐系统的高层架构
- en: From the preceding diagram, you can see that we have two embedding layers, one
    for the users and the other for the items (movies). These two embedding layers
    are then combined before being passed to a dense layer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中，您可以看到我们有两个嵌入层，一个用于用户，另一个用于项目（电影）。这两个嵌入层然后在传递到一个密集层之前被合并。
- en: So, in essence, we are combining embeddings with a supervised learning task,
    where the output from the embeddings gets passed to a dense layer to predict ratings
    a user will give an item (movie).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实质上，我们将嵌入与监督学习任务相结合，其中来自嵌入的输出被传递到一个密集层，以预测用户将给出的项目（电影）的评分。
- en: You may be wondering, if we are learning to predict ratings a user will give
    a product, how does this help us make recommendations? Well, the trick is that
    if we can efficiently predict the rating a user will give a movie, then, using
    the learned similarity embedding, we can predict the rating the user will give
    to all movies. Then, with this information, we can recommend the movies with the
    highest predicted ratings to the user.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想，如果我们正在学习预测用户将给出的产品的评分，那么这如何帮助我们进行推荐呢？嗯，诀窍在于，如果我们能有效地预测用户将给一部电影的评分，那么，使用学习到的相似性嵌入，我们就可以预测用户将给所有电影的评分。然后，有了这个信息，我们就可以向用户推荐预测评分最高的电影。
- en: So, how can we build this seemingly complicated recommendation system in JavaScript?
    Well, in the next sub-section, we'll show you how you can easily use TensorFlow.js,
    combined with Danfo.js, to achieve this.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在JavaScript中构建这个看似复杂的推荐系统呢？嗯，在下一个小节中，我们将向您展示如何轻松地使用TensorFlow.js，结合Danfo.js，来实现这一点。
- en: Setting up your project directory
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目目录
- en: The code and the dataset you need to successfully follow this chapter are provided
    in the code repository for this chapter ([https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要成功跟进本章的代码和数据集，这些都可以在本章的代码存储库中找到（[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11)）。
- en: You can download the entire project to your computer to easily follow along.
    If you have downloaded the project code, then navigate to your root directory,
    where the `src` folder is visible.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以下载整个项目到您的计算机上以便轻松跟进。如果您已经下载了项目代码，那么请导航到您的根目录，其中`src`文件夹可见。
- en: 'Inside the `src` folder, you have the following folders/scripts:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src`文件夹中，您有以下文件夹/脚本：
- en: '`book_recommendation_model`: This is the folder where the trained model is
    saved to.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`book_recommendation_model`：这是保存训练模型的文件夹。'
- en: '`data`: This folder contains our training data.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data`：这个文件夹包含我们的训练数据。'
- en: '`data_proc.js`: This script contains all our data processing code.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data_proc.js`：这个脚本包含了我们所有的数据处理代码。'
- en: '`model.js`: This script defines and compiles the recommendation model.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`model.js`：这个脚本定义并编译了推荐模型。'
- en: '`recommend.js`: This script contains code for making recommendations.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recommend.js`：这个脚本包含制作推荐的代码。'
- en: '`train.js`: This script contains code for training the recommendation model.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`train.js`：这个脚本包含训练推荐模型的代码。'
- en: 'To quickly test the pre-trained recommendation model, first, install all the
    necessary packages using `yarn` (recommended) or `NPM`, and then run the following
    command:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速测试预训练的推荐模型，首先使用`yarn`（推荐）或`NPM`安装所有必要的包，然后运行以下命令：
- en: '[PRE0]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will recommend `10`, `5`, and `20` movies for users with user IDs of `196`,
    `880`, and `13`. If successful, you should see an output similar to the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为用户ID为`196`、`880`和`13`的用户推荐`10`、`5`和`20`部电影。如果成功，你应该看到类似以下的输出：
- en: '![Figure 11.9 – Recommended movies provided by the trained recommendation system'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.9 - 训练推荐系统提供的推荐电影'
- en: '](img/B17076_11_09.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_09.jpg)'
- en: Figure 11.9 – Recommended movies provided by the trained recommendation system
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 - 训练推荐系统提供的推荐电影
- en: 'You can also retrain the model by running the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过运行以下命令重新训练模型：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding command, by default, will retrain the model with a batch size
    of `128`, an epoch size of `5`, and, when done, will save the trained model to
    the `book_recommender_model` folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，上述命令将使用批量大小为`128`、时代大小为`5`来重新训练模型，并在完成时将训练好的模型保存到`book_recommender_model`文件夹中。
- en: Now that you have set up the project locally, we'll work through each section
    and explain how to build the recommendation system from scratch.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在本地设置了项目，我们将逐步解释每个部分，并解释如何从头开始构建推荐系统。
- en: Retrieving and processing the training dataset
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索和处理训练数据集
- en: The dataset we're using was retrieved from the Grouplens website. By default,
    the movies data (`https://files.grouplens.org/datasets/movielens/ml-100k.zip`)
    is a ZIP file containing tab-separated files. For the sake of simplicity, I have
    downloaded and converted the two files you'll need for this project into `CSV`
    format. You can get these files from the `data` folder in this project's code
    repository ([https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data)).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的数据集是从Grouplens网站检索的。默认情况下，电影数据（`https://files.grouplens.org/datasets/movielens/ml-100k.zip`）是一个包含制表符分隔文件的ZIP文件。为了简单起见，我已经下载并将你在这个项目中需要的两个文件转换成了`CSV`格式。你可以从这个项目的代码库的`data`文件夹中获取这些文件（[https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data](https://github.com/PacktPublishing/Building-Data-Driven-Applications-with-Danfo.js/tree/main/Chapter11/src/data)）。
- en: 'There are two main files:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两个文件：
- en: '`movieinfo.csv`: This file contains metadata about each movie, such as its
    title, description, and links.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movieinfo.csv`：这个文件包含了关于每部电影的元数据，比如标题、描述和链接。'
- en: '`movielens.csv`: This is the user ratings dataset.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`movielens.csv`：这是用户评分数据集。'
- en: To use the `movielens` dataset, we must read the dataset with Danfo.js, process
    it, and then convert it into a tensor that we can pass to our neural network.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`movielens`数据集，我们必须用Danfo.js读取数据集，处理数据，然后将其转换为我们可以传递给神经网络的张量。
- en: 'In your project''s code, open the `data_proc.js` script. This script exports
    one main function called `processData` with the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的代码中，打开`data_proc.js`脚本。这个脚本导出了一个名为`processData`的主要函数，代码如下：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, what are we doing in the preceding code? Well, thankfully, we do not need
    much data pre-processing because the `user_id`, `item_id`, and `ratings` columns
    are already in numeric form. So, we are simply doing two things:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在上述代码中我们在做什么呢？幸运的是，我们不需要进行太多的数据预处理，因为`user_id`、`item_id`和`ratings`列已经是数字形式。所以，我们只是做了两件事：
- en: Retrieving the maximum IDs from the item and user columns. This number, called
    the **vocabulary size**, will be passed to the embedding layer when creating our
    model.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索物品和用户列的最大ID。这个数字，称为**词汇量大小**，将在创建我们的模型时传递给嵌入层。
- en: Retrieving and returning the underlying tensors of the user, item, and rating
    columns. The user and item tensors will serve as our training input, while the
    rating tensors will become our supervised learning target.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索和返回用户、物品和评分列的基础张量。用户和物品张量将作为我们的训练输入，而评分张量将成为我们的监督学习目标。
- en: Now that you know how to process the data, let's start building the neural network
    using TensorFlow.js.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何处理数据了，让我们开始使用TensorFlow.js构建神经网络。
- en: Building the recommendation model
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建推荐模型
- en: The complete code for our recommendation model can be found in the `model.js`
    file. This model uses a hybrid approach, as we saw in the high-level architecture
    diagram (see *Figure 11.8*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推荐模型的完整代码可以在`model.js`文件中找到。这个模型使用了混合方法，就像我们在高级架构图中看到的那样（见*图11.8*）。
- en: Note
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We are using the Model API we introduced in [*Chapter 10*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*,
    Introduction to TensorFlow.js*, to create the network. This is because we are
    creating a complex architecture and we need more control in terms of inputs and
    outputs.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用我们在[*第10章*](B17076_10_ePub_RK.xhtml#_idTextAnchor180)*TensorFlow.js简介*中介绍的Model
    API来创建网络。这是因为我们正在创建一个复杂的架构，我们需要更多的控制输入和输出。
- en: 'In the following steps, we will explain the model and show the corresponding
    code for creating it:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，我们将解释模型并展示创建它的相应代码：
- en: '`user` and the other from the items:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`user`和另一个来自物品：'
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the input has a shape parameter set to `1`. This is because our
    input tensors are vectors with a dimension of `1`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输入的形状参数设置为`1`。这是因为我们的输入张量是具有`1`维的向量。
- en: '`InputDim`: This is the vocabulary size of the embedding vector. The maximum
    integer index is `+ 1`.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`InputDim`：这是嵌入向量的词汇量大小。最大整数索引为`+ 1`。'
- en: 'b) `OutputDim`: This is a user-specified output dimension. That is, it is used
    to configure the size of the embedding vector.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: b) `OutputDim`：这是用户指定的输出维度。也就是说，它用于配置嵌入向量的大小。
- en: Next, we'll merge these embedding layers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将合并这些嵌入层。
- en: '`dot` product, flattening the output, and passing the output to a dense layer:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`dot`乘积，将输出扁平化，并将输出传递给一个密集层：'
- en: '[PRE4]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the preceding output, we can now define our model using the Models API.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述输出，我们现在可以使用Models API定义我们的模型。
- en: 'Finally, we will define and compile the model, as shown in the following code
    snippet:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将定义并编译模型，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code uses the Models API to define the inputs and output, and
    then calls the compile method, which accepts a training optimizer (Adam optimizer)
    and a loss function (mean squared error). You can view the full model code in
    the `model.js` file.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用Models API来定义输入和输出，然后调用compile方法，该方法接受训练优化器（Adam优化器）和损失函数（均方误差）。您可以在`model.js`文件中查看完整的模型代码。
- en: With the model architecture defined, we can start training the model.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 有了模型架构定义，我们就可以开始训练模型。
- en: Training and saving the recommendation model
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 训练和保存推荐模型
- en: The training code for the model can be found in the `train.js` file. This code
    has two main sections. We'll look at both here.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的训练代码可以在`train.js`文件中找到。此代码有两个主要部分。我们将在这里看到两者。
- en: 'The first section, shown in the following code block, trains the model using
    a batch size of `128`, an epoch size of `5`, and a validation split of `0.1`-`10`%
    for the training data, which is reserved for model validation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分，如下面的代码块所示，使用批量大小为`128`，时代大小为`5`，并且将`10`%的数据用于模型验证的验证分割来训练模型，这部分数据是为了模型验证而保留的：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding training code, we printed the loss after each training epoch.
    This helps us track training progress.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述训练代码中，我们在每个训练时代之后打印了损失。这有助于我们跟踪训练进度。
- en: 'The following code block saves the trained model to the file path provided.
    In our case, we are saving it to the `movie_recommendation_model` folder:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块将训练好的模型保存到提供的文件路径。在我们的情况下，我们将其保存到`movie_recommendation_model`文件夹中：
- en: '[PRE7]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Take note of this folder's name as we'll be using it when we make recommendations
    in the next sub-section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意此文件夹的名称，因为我们将在下一小节中使用它进行推荐。
- en: 'To train the model, you can run the following command in the `src` folder:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要训练模型，您可以在`src`文件夹中运行以下命令：
- en: '[PRE8]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Alternatively, you can directly run `train.js` with `node`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以直接使用`node`运行`train.js`：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will start model training for the specified number of epochs and, once
    done, save the model to the specified folder. Once the training is complete, you
    should have an output similar to the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将开始指定数量的时代模型训练，并且一旦完成，将模型保存到指定的文件夹。训练完成后，您应该有类似以下的输出：
- en: '![Figure 11.10 – Training logs of the recommendation model'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.10 - 推荐模型的训练日志'
- en: '](img/B17076_11_10.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17076_11_10.jpg)'
- en: Figure 11.10 – Training logs of the recommendation model
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 - 推荐模型的训练日志
- en: Once you have a trained and saved model, you can start making movie recommendations.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了训练好并保存的模型，您就可以开始进行电影推荐。
- en: Making movie recommendations with the saved model
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用保存的模型进行电影推荐
- en: The `recommend.js` file contains the code for making recommendations. We have
    also included a utility function called `getMovieDetails`. This function maps
    a movie ID to the movie metadata so that we can display useful information, such
    as the name of a movie.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommend.js`文件包含了进行推荐的代码。我们还包括了一个名为`getMovieDetails`的实用函数。此函数将电影ID映射到电影元数据，以便我们可以显示有用的信息，例如电影的名称。'
- en: But how do we make recommendations? Well, since we have trained our model to
    predict the ratings a user will give a set of movies, we can simply pass a user
    ID and all the movies to the model to make ratings predictions.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们如何进行推荐呢？由于我们已经训练了模型来预测用户对一组电影的评分，我们可以简单地将用户ID和所有电影传递给模型来进行评分预测。
- en: With the ratings predictions for all movies, we can simply sort them in descending
    order and then return the top movies as recommendations.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有电影的评分预测，我们可以简单地按降序对它们进行排序，然后返回前几部电影作为推荐。
- en: 'To do this, follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请按照以下步骤进行：
- en: 'First, we must get all the unique movie IDs to predict for:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们必须获取所有唯一的电影ID进行预测：
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we must construct a user tensor that''s the same length as the movie
    ID tensor. The tensor will have the same user ID across all entries because for
    each movie, we are predicting the rating the same user will give:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须构建一个与电影ID张量长度相同的用户张量。该张量将在所有条目中具有相同的用户ID，因为对于每部电影，我们都在预测同一用户将给出的评分：
- en: '[PRE11]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, we must load the model and call the `predict` function by passing the
    movie and user tensors as input:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须加载模型并通过传递电影和用户张量作为输入来调用`predict`函数：
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will return a tensor of predicted ratings the user will give to each movie.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个张量，其中包含用户将给每部电影的预测评分。
- en: 'Next, we must construct a DataFrame with two columns called `movie_id` (unique
    movie IDs) and `ratings` (predicted ratings given by the user to each movie):'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须构建一个包含名为`movie_id`（唯一电影ID）和`ratings`（用户对每部电影的预测评分）的两列的DataFrame：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Storing the predicted ratings and the corresponding movie ID in a DataFrame
    helps us easily sort the ratings, as shown in the following code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将预测评分和相应的电影ID存储在DataFrame中有助于我们轻松地对评分进行排序，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we must pass the array of sorted movie IDs to the `getMovieDetails`
    utility function. This function will map each movie ID to the corresponding metadata
    and return a DataFrame with two columns (movie title and movie release date),
    as shown in the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须将排序后的电影ID数组传递给`getMovieDetails`实用函数。此函数将每个电影ID映射到相应的元数据，并返回一个包含两列（电影标题和电影发行日期）的DataFrame，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `recommend.js` script in the `src` folder contains the full code for making
    recommendations, including the utility function for mapping a movie ID to its
    metadata.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`recommend.js`文件在`src`文件夹中包含了完整的推荐代码，包括将电影ID映射到其元数据的实用函数。'
- en: 'To test a recommendation, you need to call the `recommend` function and pass
    a movie ID and the number of recommendations you want, as shown in the following
    example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试推荐，您需要调用`recommend`函数并传递电影ID和您想要的推荐数量，如下面的示例所示：
- en: '[PRE16]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code gives us the following output in the console:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码在控制台中给出了以下输出：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And that's it! You have successfully created a recommendation system using neural
    network embeddings, which can efficiently recommend movies to different users.
    Using the concepts you've learned about in this chapter, you can easily create
    different recommendation systems that can recommend different products, such as
    music, books, and videos.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！您已成功使用神经网络嵌入创建了一个推荐系统，可以高效地向不同用户推荐电影。利用本章学到的概念，您可以轻松地创建不同的推荐系统，可以推荐不同的产品，如音乐、书籍和视频。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we successfully built a recommendation system that can recommend
    movies to users based on their preferences. First, we defined what a recommendation
    model is before briefly talking about the three approaches to designing a recommendation
    system. Then, we talked about neural network embeddings and why we decided to
    use them to create our recommendation model. Finally, we put together all the
    concepts we've learned about by building a movie recommendation model that can
    recommend the specified number of movies to a user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们成功地构建了一个推荐系统，可以根据用户的偏好向他们推荐电影。首先，我们定义了推荐模型是什么，然后简要讨论了设计推荐系统的三种方法。接着，我们谈到了神经网络嵌入以及为什么决定使用它们来创建我们的推荐模型。最后，我们通过构建一个电影推荐模型，将学到的所有概念整合起来，可以向用户推荐指定数量的电影。
- en: With the knowledge you've gained in this chapter, you can easily create a recommendation
    system that can be embedded in your JavaScript applications.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章学到的知识，您可以轻松地创建一个可以嵌入到JavaScript应用程序中的推荐系统。
- en: In the next and final chapter, you'll build another hands-on application using
    Danfo.js and the **Twitter API**.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，您将使用Danfo.js和Twitter API构建另一个实际应用程序。
