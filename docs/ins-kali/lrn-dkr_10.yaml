- en: Advanced Docker Usage Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级Docker使用场景
- en: In the last chapter, we showed you how you can use tools to perform administrative
    tasks without having to install those tools on the host computer. We also illustrated
    the use of containers that host and run test scripts or code used to test and
    validate application services running in containers. Finally, we guided you through
    the task of building a simple Docker-based CI/CD pipeline using Jenkins as the
    automation server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向您展示了如何使用工具执行管理任务，而无需在主机计算机上安装这些工具。我们还说明了容器的使用，这些容器托管和运行用于测试和验证在容器中运行的应用程序服务的测试脚本或代码。最后，我们指导您构建了一个使用Jenkins作为自动化服务器的基于Docker的简单CI/CD流水线的任务。
- en: In this chapter, we will introduce advanced tips, tricks, and concepts that
    are useful when containerizing complex distributed applications, or when using
    Docker to automate sophisticated tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍在将复杂的分布式应用程序容器化或使用Docker自动化复杂任务时有用的高级技巧、窍门和概念。
- en: 'This is a quick overview of all of the subjects we are going to touch on in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本章中我们将涉及的所有主题的快速概述：
- en: All of the tips and tricks of a Docker pro
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有Docker专业人士的技巧和窍门
- en: Running your Terminal in a remote container and accessing it via HTTPS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程容器中运行终端并通过HTTPS访问它
- en: Running your development environment inside a container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内运行开发环境
- en: Running your code editor in a remote container and accessing it via HTTPS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程容器中运行代码编辑器并通过HTTPS访问它
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将能够执行以下操作：
- en: Successfully restore your Docker environment after it has been messed up completely
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完全混乱后成功恢复您的Docker环境
- en: Run a remote Terminal in a container and access it with your browser via HTTPS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行远程终端，并通过HTTPS在浏览器中访问它
- en: Edit code remotely with Visual Studio Code with your browser via HTTPS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过HTTPS在浏览器中使用Visual Studio Code远程编辑代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on your Mac or Windows machine and the Visual Studio Code editor.
    The example will also work on a Linux machine with Docker and Visual Studio Code
    installed. Docker Toolbox is not supported in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果您想跟着代码进行操作，您需要在Mac或Windows机器上安装Docker for Desktop和Visual Studio Code编辑器。该示例也适用于安装了Docker和Visual
    Studio Code的Linux机器。Docker Toolbox在本章中不受支持。
- en: All of the tips and tricks of a Docker pro
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有Docker专业人士的技巧和窍门
- en: In this section, I will present a few very useful tips and tricks that make
    the lives of advanced Docker users so much easier. We will start with some guidance
    on how to keep your Docker environment clean.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍一些非常有用的技巧和窍门，这些技巧和窍门可以让高级Docker用户的生活变得更加轻松。我们将从如何保持Docker环境清洁开始。
- en: Keeping your Docker environment clean
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持您的Docker环境清洁
- en: 'First, we want to learn how we can delete dangling images. According to Docker,
    dangling images are layers that have no relationship to any tagged images. Such
    image layers are certainly useless to us and can quickly fill up our disk—it''s
    better to remove them from time to time. Here is the command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想学习如何删除悬空镜像。根据Docker的说法，悬空镜像是与任何已标记镜像没有关联的层。这样的镜像层对我们来说肯定是无用的，并且可能会很快地填满我们的磁盘——最好定期将它们删除。以下是命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that I have added the `-f` parameter to the `prune` command. This
    is to prevent the CLI from asking for a confirmation that we really want to delete
    those superfluous layers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经向`prune`命令添加了`-f`参数。这是为了防止CLI询问我们是否真的要删除那些多余的层。
- en: 'Stopped containers can waste precious resources too. If you''re sure that you
    don''t need these containers anymore, then you should remove them, either individually
    with the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器也会浪费宝贵的资源。如果您确定不再需要这些容器，那么您应该使用以下命令逐个删除它们：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, you can remove them as a batch with the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令批量删除它们：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is worth mentioning once again that, instead of `<container-id>`, we can
    also use `<container-name>` to identify a container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次提到的是，除了`<container-id>`，我们还可以使用`<container-name>`来标识容器。
- en: 'Unused Docker volumes too can quickly fill up disk space. It is a good practice
    to tender your volumes, specifically in a development or CI environment where
    you create a lot of mostly temporary volumes. But I have to warn you, Docker volumes
    are meant to store data. Often, this data must live longer than the life cycle
    of a container. This is specifically true in a production or production-like environment
    where the data is often mission-critical. Hence, be 100% sure of what you''re
    doing when using the following command to prune volumes on your Docker host:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的Docker卷也可能很快填满磁盘空间。在开发或CI环境中，特别是在创建大量临时卷的情况下，妥善处理您的卷是一个好习惯。但是我必须警告您，Docker卷是用来存储数据的。通常，这些数据的生存周期必须比容器的生命周期长。这在生产或类似生产环境中尤其如此，那里的数据通常是至关重要的。因此，在使用以下命令清理Docker主机上的卷时，请务必百分之百确定自己在做什么：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I recommend using this command without the `-f` (or `--force`) flag. It is a
    dangerous and terminal operation and it's better to give yourself a second chance
    to reconsider your action. Without the flag, the CLI outputs the warning you see
    in the preceding. You have to explicitly confirm by typing `y` and pressing the
    *Enter* key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议不要使用`-f`（或`--force`）标志的这个命令。这是一个危险的终端操作，最好给自己第二次机会来重新考虑您的行动。没有这个标志，CLI会输出您在上面看到的警告。您必须通过输入`y`并按下*Enter*键来明确确认。
- en: 'On production or production-like systems, you should abstain from the preceding
    command and rather delete unwanted volumes one at a time by using this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产或类似生产系统中，您应该避免使用上述命令，而是使用以下命令逐个删除不需要的卷：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I should also mention that there is a command to prune Docker networks. But
    since we have not yet officially introduced networks, I will defer this to [chapter
    10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host Networking*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到有一个命令可以清理Docker网络。但由于我们尚未正式介绍网络，我将把这个推迟到[第10章]，*单主机网络*。
- en: In the next section, we are going to show how we can automate Docker from within
    a container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何可以从容器内部自动化Docker。
- en: Running Docker in Docker
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker中运行Docker
- en: At times, we may want to run a container hosting an application that automates
    certain Docker tasks. How can we do that? The Docker Engine and the Docker CLI
    are installed on the host, yet the application runs inside the container. Well,
    from early on, Docker has provided a means to bind-mount Linux sockets from the
    host into the container. On Linux, sockets are used as very efficient data communications
    endpoints between processes that run on the same host. The Docker CLI uses a socket
    to communicate with the Docker Engine; it is often called the Docker socket. If
    we can give access to the Docker socket to an application running inside a container
    then we can just install the Docker CLI inside this container, and we will then
    be able to run an application in the same container that uses this locally installed
    Docker CLI to automate container-specific tasks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要运行一个托管应用程序的容器，该应用程序自动化执行某些Docker任务。我们该怎么做呢？Docker引擎和Docker CLI已安装在主机上，但应用程序在容器内运行。早期，Docker就提供了一种将Linux套接字从主机绑定到容器的方法。在Linux上，套接字被用作在同一主机上运行的进程之间非常高效的数据通信端点。Docker
    CLI使用套接字与Docker引擎通信；它通常被称为Docker套接字。如果我们可以将Docker套接字授予在容器内运行的应用程序访问权限，那么我们只需在此容器内安装Docker
    CLI，然后我们将能够在相同的容器中运行使用本地安装的Docker CLI自动化特定于容器的任务的应用程序。
- en: It is important to note that here we are not talking about running the Docker
    Engine inside the container but rather only the Docker CLI and bind-mount the
    Docker socket from the host into the container so that the CLI can communicate
    with the Docker Engine running on the host computer. This is an important distinction.
    Running the Docker Engine inside a container, although possible, is not recommended.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这里我们不是在谈论在容器内运行Docker引擎，而是只运行Docker CLI并将Docker套接字从主机绑定到容器中，以便CLI可以与主机计算机上运行的Docker引擎进行通信。这是一个重要的区别。在容器内运行Docker引擎虽然可能，但不建议。
- en: 'Let''s assume we have the following script, called `pipeline.sh`, automating
    the building, testing, and pushing of a Docker image:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有以下脚本，名为`pipeline.sh`，自动化构建、测试和推送Docker镜像：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we're using four environment variables: `$HUB_USER` and `$HUB_PWD`
    being the credentials for Docker Hub and `$REPOSITORY` and `$TAG` being the name
    and tag of the Docker image we want to build. Eventually, we will have to pass
    values for those environment variables in the `docker run` command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在使用四个环境变量：`$HUB_USER`和`$HUB_PWD`是Docker Hub的凭据，`$REPOSITORY`和`$TAG`是我们要构建的Docker镜像的名称和标签。最终，我们将不得不在`docker
    run`命令中传递这些环境变量的值。
- en: 'We want to run that script inside a builder container. Since the script uses
    the Docker CLI, our builder container must have the Docker CLI installed, and
    to access the Docker Engine, the builder container must have the Docker socket
    bind-mounted. Let''s start creating a Docker image for such a builder container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在一个构建器容器内运行该脚本。由于该脚本使用Docker CLI，我们的构建器容器必须安装Docker CLI，并且要访问Docker引擎，构建器容器必须将Docker套接字绑定。让我们开始为这样一个构建器容器创建一个Docker镜像：
- en: 'First, create a `builder` folder and navigate to it:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`builder`文件夹并导航到它：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside this folder, create a `Dockerfile` that looks like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹里，创建一个看起来像这样的`Dockerfile`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now create a `pipeline.sh` file in the `builder` folder and add as content the
    pipeline script we have presented in the preceding file.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`builder`文件夹中创建一个`pipeline.sh`文件，并将我们在前面文件中呈现的流水线脚本添加为内容。
- en: 'Save and make the file an executable:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并使文件可执行：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Building an image is straightforward:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像很简单：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now ready to try `builder` out with a real Node.js application, for
    example, the sample app we defined in the `ch08/sample-app` folder. Make sure
    you replace `<user>` and `<password>` with your own credentials for Docker Hub:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备使用一个真实的Node.js应用程序来尝试`builder`，例如我们在`ch08/sample-app`文件夹中定义的示例应用程序。确保您用Docker
    Hub的自己的凭据替换`<user>`和`<password>`：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how, in the preceding command, we mounted the Docker socket into the
    container with `-v /var/run/docker.sock:/var/run/docker.sock`. If everything goes
    well, you should have a container image built for the sample application, the
    test should have been run, and the image should have been pushed to Docker Hub.
    This is only one of the many use cases where it is very useful to be able to bind-mount
    the Docker socket.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在上述命令中，我们使用`-v /var/run/docker.sock:/var/run/docker.sock`将Docker套接字挂载到容器中。如果一切顺利，您应该已经为示例应用程序构建了一个容器镜像，测试应该已经运行，并且镜像应该已经推送到Docker
    Hub。这只是许多用例中的一个，其中能够绑定挂载Docker套接字非常有用。
- en: 'A special notice to all those of you who want to try Windows containers. On
    Docker for Windows, you can create a similar environment by bind-mounting Docker''s **named
    pipe** instead of a socket. A named pipe on Windows is roughly the same as a socket
    on a Unix-based system. Assuming you''re using a PowerShell Terminal, the command
    to bind-mount a named pipe when running a Windows container hosting Jenkins looks
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，所有想尝试Windows容器的人。在Windows上的Docker中，您可以通过绑定挂载Docker的**命名管道**来创建类似的环境，而不是一个套接字。在Windows上，命名管道与基于Unix的系统上的套接字大致相同。假设您正在使用PowerShell终端，运行Windows容器托管Jenkins时，绑定挂载命名管道的命令如下：
- en: '`**PS>** **docker container run `** **--name jenkins `** **-p 8080:8080 `**
    **-v \\.\pipe\docker_engine:\\.\pipe\docker_engine `'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`**PS>** **docker container run `** **--name jenkins `** **-p 8080:8080 `**
    **-v \\.\pipe\docker_engine:\\.\pipe\docker_engine `'
- en: friism/jenkins**`
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: friism/jenkins**`
- en: Note the special syntax, `\\.\pipe\docker_engine`, to access Docker's named
    pipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特殊的语法`\\.\pipe\docker_engine`，用于访问Docker的命名管道。
- en: Formatting the output of common Docker commands
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化常见Docker命令的输出
- en: 'Have you at times wished that your Terminal window was infinitely wide since
    the output of a Docker command such as `docker container ps` is scrambled across
    several lines per item? Worry not, as you can customize the output to your liking.
    Almost all commands that produce an output have a `--format` argument, which accepts
    a so-called Go template as a parameter. If you wonder why a Go template, it''s
    because most of Docker is written in this popular low-level language. Let''s look
    at an example. Assume we want to only show the name of the container, the name
    of the image, and the state of the container, separated by tabs, output by the
    `docker container ps` command. The format would then look like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您是否希望您的终端窗口是无限宽的，因为像`docker container ps`这样的Docker命令的输出会在每个项目上跨越多行？不用担心，因为您可以根据自己的喜好自定义输出。几乎所有产生输出的命令都有一个`--format`参数，它接受一个所谓的Go模板作为参数。如果您想知道为什么是Go模板，那是因为Docker的大部分代码都是用这种流行的低级语言编写的。让我们看一个例子。假设我们只想显示`docker
    container ps`命令输出的容器名称、镜像名称和容器状态，用制表符分隔。格式将如下所示：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Please be aware that the `format` string is case sensitive. Also, note the
    addition of the `-a` parameter to include stopped containers in the output. A
    sample output could look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`format`字符串是区分大小写的。还要注意添加`-a`参数以包括已停止的容器在输出中。示例输出可能如下所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is definitely nicer to display even on a narrow Terminal window than the
    unformatted one scattering wildly over multiple lines.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对比未格式化的输出更好，即使在窄窄的终端窗口上也是如此，未格式化的输出会在多行上随意散开。
- en: Filtering the output of common Docker commands
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤常见Docker命令的输出
- en: 'Similar to what we have done in the previous section by pretty-printing the
    output of Docker commands, we can also filter what is output. There are quite
    a few filters that are supported. Please find the full list for each command in
    the Docker online documentation. The format of filters is straightforward and
    of the type `--filter <key>=<value>`. If we need to combine more than one filter,
    we can just combine multiple of these statements. Let''s do an example with the
    `docker image ls` command as I have a lot of images on my workstation:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在上一节中所做的内容类似，通过美化Docker命令的输出，我们也可以筛选输出内容。支持许多过滤器。请在Docker在线文档中找到每个命令的完整列表。过滤器的格式很简单，是`--filter
    <key>=<value>`的类型。如果我们需要结合多个过滤器，我们可以结合多个这些语句。让我们以`docker image ls`命令为例，因为我在我的工作站上有很多镜像：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding filter only outputs images that are not dangling, that is, real
    images whose fully qualified name is of the form `<registry>/<user|org><repository>:<tag>`,
    and the tag is equal to `latest`. The output on my machine looks like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过滤器只输出不悬空的镜像，也就是真实的镜像，其完全限定名称的形式为`<registry>/<user|org><repository>:<tag>`，并且标签等于`latest`。我的机器上的输出如下：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having shown how to pretty print and filter output generated by the Docker CLI,
    it is now time to talk once more about building Docker images and how to optimize
    this process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示了如何美化和筛选Docker CLI生成的输出之后，现在是时候再次谈论构建Docker镜像以及如何优化这个过程了。
- en: Optimizing your build process
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化构建过程
- en: 'Many Docker beginners make the following mistake when crafting their first
    `Dockerfile`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Docker初学者在编写他们的第一个`Dockerfile`时会犯以下错误：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Can you spot the weak point in this typical `Dockerfile` for a Node.js application?
    In [Chapter 4](527543ae-a569-47dc-975d-65c96d0f6ff0.xhtml), *Creating and Managing
    Container Images*, we have learned that an image consists of a series of layers.
    Each (logical) line in a `Dockerfile` creates a layer, except the lines with the
    `CMD` and/or `ENTRYPOINT` keyword. We have also learned that the Docker builder
    tries to do its best by caching layers and reusing them if they have not changed
    between subsequent builds. But the caching only uses cached layers that occur
    before the first changed layer. All subsequent layers need to be rebuilt. That
    said, the preceding structure of the `Dockerfile` busts the image layer cache!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个典型的Node.js应用程序的`Dockerfile`中的薄弱点吗？在[第4章](527543ae-a569-47dc-975d-65c96d0f6ff0.xhtml)中，*创建和管理容器镜像*，我们已经学到镜像由一系列层组成。`Dockerfile`中的每一行（逻辑上）都创建一个层，除了带有`CMD`和/或`ENTRYPOINT`关键字的行。我们还学到Docker构建器会尽力缓存层，并在后续构建之间重用它们。但是缓存只使用在第一个更改的层之前出现的缓存层。所有后续层都需要重新构建。也就是说，`Dockerfile`的前面结构破坏了镜像层缓存！
- en: 'Why? Well, from experience, you certainly know that `npm install` can be a
    pretty expensive operation in a typical Node.js application with many external
    dependencies. The execution of this command can take from seconds to many minutes.
    That said, each time one of the source files changes, and we know that happens
    frequently during development, line 3 in the `Dockerfile` causes the corresponding
    image layer to change. Hence, the Docker builder cannot reuse this layer from
    cache, nor can it reuse the subsequent layer created by `RUN npm install`. Any
    minor change in code causes a complete rerun of `npm install`. That can be avoided.
    The `package.json` file containing the list of external dependencies rarely changes.
    With all of that information, let''s fix the `Dockerfile`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？嗯，从经验上来说，你肯定知道在一个典型的具有许多外部依赖的 Node.js 应用程序中，`npm install` 可能是一个非常昂贵的操作。执行此命令可能需要几秒钟到几分钟。也就是说，每当源文件之一发生变化，我们知道在开发过程中这经常发生，`Dockerfile`
    中的第 3 行会导致相应的镜像层发生变化。因此，Docker 构建器无法重用缓存中的此层，也无法重用由 `RUN npm install` 创建的随后的层。代码的任何微小变化都会导致完全重新运行
    `npm install`。这是可以避免的。包含外部依赖列表的 `package.json` 文件很少改变。有了所有这些信息，让我们修复 `Dockerfile`：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, on line 3, we only copy the `package.json` file into the container,
    which rarely changes. Hence, the subsequent `npm install` command has to be executed
    equally rarely. The `COPY` command on line 5 then is a very fast operation and
    hence rebuilding an image after some code has changed only needs to rebuild this
    last layer. Build times reduce to merely a fraction of a second.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在第 3 行，我们只将 `package.json` 文件复制到容器中，这个文件很少改变。因此，随后的 `npm install` 命令也需要同样很少地执行。第
    5 行的 `COPY` 命令是一个非常快速的操作，因此在一些代码改变后重新构建镜像只需要重新构建这最后一层。构建时间减少到几乎只有一小部分秒数。
- en: The very same principle applies to most languages or frameworks, such as Python,
    .NET, or Java. Avoid busting your image layer cache!
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于大多数语言或框架，比如 Python、.NET 或 Java。避免破坏你的镜像层缓存！
- en: Limiting resources consumed by a container
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制容器消耗的资源
- en: 'One of the great features of a container, apart from encapsulating application
    processes, is the possibility of limiting the resources a single container can
    consume at. This includes CPU and memory consumption. Let''s have a look at how
    limiting the amount of memory (RAM) works:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个很棒的特性，除了封装应用程序进程外，还可以限制单个容器可以消耗的资源。这包括 CPU 和内存消耗。让我们来看看如何限制内存（RAM）的使用：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once inside the container, install the `stress` tool, which we will use to
    simulate memory pressure:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入容器，安装 `stress` 工具，我们将用它来模拟内存压力：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open another Terminal window and execute the `docker stats` command. You should
    see something like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口并执行 `docker stats` 命令。你应该会看到类似这样的东西：
- en: '![](assets/8a674500-7732-44f7-98fd-a13d1aa38450.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8a674500-7732-44f7-98fd-a13d1aa38450.png)'
- en: docker stats showing a resource-limited container
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: docker stats 显示了一个资源受限的容器
- en: 'Look at  `MEM USAGE` and `LIMIT`. Currently, the container uses only `1.87MiB` memory
    and has a limit of `512MB`. The latter corresponds to what we have configured
    for this container. Now, let''s use `stress` to simulate four workers, which try
    to `malloc()` memory in blocks of `256MB`. Run this command inside the container
    to do so:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 `MEM USAGE` 和 `LIMIT`。目前，容器只使用了 `1.87MiB` 的内存，限制为 `512MB`。后者对应我们为这个容器配置的内容。现在，让我们使用
    `stress` 来模拟四个尝试以 `256MB` 为块的工作进程。在容器内运行此命令以执行：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the Terminal running Docker stats, observe how the value for `MEM USAGE`
    approaches but never exceeds `LIMIT`. This is exactly the behavior we expected
    from Docker. Docker uses Linux `cgroups` to enforce those limits.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 Docker stats 的终端中，观察 `MEM USAGE` 的值如何接近但从未超过 `LIMIT`。这正是我们从 Docker 期望的行为。Docker
    使用 Linux `cgroups` 来强制执行这些限制。
- en: We could similarly limit the amount of CPU a container can consume with the
    `--cpu` switch.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`--cpu`开关类似地限制容器可以消耗的CPU数量。
- en: With this operation, engineers can avoid the noisy neighbor problem on a busy
    Docker host, where a single container starves all of the others by consuming an
    excessive amount of resources.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种操作，工程师可以避免在繁忙的Docker主机上出现嘈杂的邻居问题，即一个容器通过消耗过多的资源使其他所有容器陷入困境。
- en: Read-only filesystem
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读文件系统
- en: 'To protect your applications against malicious hacker attacks, it is often
    advised to define the filesystem of the container or part of it as read-only.
    This makes the most sense for stateless services. Assume that you have a billing
    service running in a container as part of your distributed, mission-critical application.
    You could run your billing service as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护您的应用免受恶意黑客攻击，通常建议将容器的文件系统或部分文件系统定义为只读。这对于无状态服务来说是最有意义的。假设您在作为分布式、关键任务应用的一部分运行的容器中有一个计费服务。您可以按以下方式运行计费服务：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `--read-only` flag mounts the container''s filesystem as read-only. If
    a hacker succeeds in entering your billing container and tries to change an application
    maliciously by, say, replacing one of the binaries with a compromised one, then
    this operation would fail. We can easily demonstrate that with the following commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`--read-only`标志将容器的文件系统挂载为只读。如果黑客成功进入您的计费容器并试图恶意更改应用程序，比如用一个受损的二进制文件替换其中一个，那么这个操作将失败。我们可以通过以下命令轻松演示：'
- en: '[PRE21]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first command runs a container with a read-only filesystem and the second
    command tries to execute another process in this container, which is supposed
    to write something to the filesystem—in this case, a simple text file. This fails,
    as we can see in the preceding output, with the error message `Read-only file
    system`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令以只读文件系统运行容器，第二个命令尝试在该容器中执行另一个进程，该进程应该向文件系统写入一些东西——在这种情况下是一个简单的文本文件。这会失败，正如我们在前面的输出中看到的，出现了错误消息`只读文件系统`。
- en: Another means to tighten the security of your applications running in containers
    is to avoid running them as `root`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 加强容器中运行应用程序安全性的另一种方法是避免以`root`身份运行它们。
- en: Avoid running a containerized app as root
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免以root身份运行容器化应用
- en: Most applications or application services that run inside a container do not
    need root access. To tighten security, it is helpful in those scenarios to run
    these processes with minimal necessary privileges. These applications should not
    be run as `root` nor assume that they have `root`-level privileges.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数运行在容器内的应用或应用服务不需要root访问权限。为了加强安全性，在这些情况下以最小必要权限运行这些进程是有帮助的。这些应用不应该以`root`身份运行，也不应该假设它们具有`root`级别的权限。
- en: 'Once again, let''s illustrate what we mean with an example. Assume we have
    a file with top-secret content. We want to secure this file on our Unix-based
    system using the `chmod` tool so that only users with root permission can access
    it. Let''s assume I am logged in as `gabriel` on the `dev` host and hence my prompt
    is `gabriel@dev $`. I can use `sudo su` to impersonate a superuser. I have to
    enter the superuser password though:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们通过一个例子来说明我们的意思。假设我们有一个包含绝密内容的文件。我们希望在我们的基于Unix的系统上使用`chmod`工具来保护这个文件，以便只有具有root权限的用户才能访问它。假设我以`dev`主机上的`gabriel`身份登录，因此我的提示符是`gabriel@dev
    $`。我可以使用`sudo su`来冒充超级用户。不过我必须输入超级用户密码：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, as the `root` user, I can create this file called `top-secret.txt` and
    secure it:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为`root`用户，我可以创建一个名为`top-secret.txt`的文件并保护它：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If I try to access the file as `gabriel`, the following happens:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试以`gabriel`的身份访问文件，会发生以下情况：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I get `Permission denied`, which is what we wanted. No other user except `root`
    can access this file. Now, let''s build a Docker image that contains this secured
    file and when a container is created from it, tries to output its content. The
    `Dockerfile` could look like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了“Permission denied”，这正是我们想要的。除了`root`之外，没有其他用户可以访问这个文件。现在，让我们构建一个包含这个受保护文件的Docker镜像，当从中创建一个容器时，尝试输出它的内容。`Dockerfile`可能是这样的：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can build an image from that Dockerfile (as `root`!) with the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从该Dockerfile构建一个镜像（以`root`身份！）：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, when running a container from that image we get:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从该镜像运行一个容器，我们得到：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OK, so although I am impersonating the `gabriel` user on the host and running
    the container under this user account, the application running inside the container
    automatically runs as `root`, and hence has full access to protected resources.
    That''s bad, so let''s fix it! Instead of running with the default, we define
    an explicit user inside the container. The modified `Dockerfile` looks like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，尽管我在主机上冒充`gabriel`用户并在该用户账户下运行容器，但容器内运行的应用程序自动以`root`身份运行，因此可以完全访问受保护的资源。这很糟糕，所以让我们来修复它！我们不再使用默认设置，而是在容器内定义一个显式用户。修改后的`Dockerfile`如下：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the `groupadd` tool to define a new group, `demo-group`, with the ID
    `3000`. Then, we use the `useradd` tool to add a new user, `demo-user`, to this
    group. The user has the ID `4000` inside the container. Finally, with the `USER
    demo-user` statement, we declare that all subsequent operations should be executed
    as `demo-user`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`groupadd`工具来定义一个新的组，`demo-group`，ID为`3000`。然后，我们使用`useradd`工具向这个组添加一个新用户，`demo-user`。用户在容器内的ID为`4000`。最后，通过`USER
    demo-user`语句，我们声明所有后续操作应该以`demo-user`身份执行。
- en: 'Rebuild the image—again as `root`—and then try to run a container from it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建镜像——再次以`root`身份——然后尝试从中运行一个容器：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And as you can see on the last line, the application running inside the container
    runs with restricted permissions and cannot access resources that need root-level
    access. By the way, what do you think would happen if I ran the container as `root`?
    Try it out!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在最后一行所看到的，容器内运行的应用程序以受限权限运行，无法访问需要root级别访问权限的资源。顺便问一下，如果我以`root`身份运行容器会发生什么？试一试吧！
- en: These have been a few tips and tricks for pros that are useful in the day-to-day
    usage of containers. There are many more. Google them. It is worth it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些对专业人士有用的日常容器使用技巧。还有很多。去Google搜索一下。值得的。
- en: Running your Terminal in a remote container and accessing it via HTTPS
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在远程容器中运行您的终端并通过HTTPS访问它
- en: There are situations where you need to access a remote server and only have
    the option to use a browser for that. Your laptop may be locked down by your employer
    so that you are not allowed to, for example, `ssh` into a server outside of the
    company's domain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要访问远程服务器，只能使用浏览器进行访问。您的笔记本电脑可能被雇主锁定，因此不允许您例如`ssh`到公司域之外的服务器。
- en: 'To test this scenario proceed as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这种情况，请按照以下步骤进行：
- en: Create a free account on Microsoft Azure, GCP, or AWS. Then, create a VM, preferably
    with Ubuntu 18.04 or higher as the operating system, to follow along more easily.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Microsoft Azure、GCP或AWS上创建一个免费账户。然后，创建一个虚拟机，最好使用Ubuntu 18.04或更高版本作为操作系统，以便更容易跟随操作。
- en: 'Once your VM is ready, SSH into it. The command to do so should look similar
    to this:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您的虚拟机准备就绪，就可以通过SSH登录。执行此操作的命令应该类似于这样：
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get access, you may need to open port `22` for ingress first for the VM.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得访问权限，您可能需要首先为虚拟机打开`22`端口以进行入口。
- en: The user I have defined during the provisioning of the VM is `gnschenker` and
    the public IP address of my VM is `40.115.4.249`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我在虚拟机配置期间定义的用户是`gnschenker`，我的虚拟机的公共IP地址是`40.115.4.249`。
- en: Install Docker on this VM using the description found here: [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此处找到的说明在VM上安装Docker：[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)。
- en: 'On a special note, do not forget to add your user (`gnschenker`, in my case)
    to the `docker` group on the VM with the following command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别注意，不要忘记使用以下命令将您的用户（在我的情况下是`gnschenker`）添加到VM上的`docker`组中：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this, you avoid having to constantly use `sudo` for all Docker commands.
    You need to log out from and log in to the VM to make this change work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，您可以避免不断使用`sudo`执行所有Docker命令。您需要注销并登录到VM以使此更改生效。
- en: 'Now, we are ready to run **Shell in a Box** ([https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox))
    in a container on the VM. There are quite a few people who have containerized
    Shell in a Box. We are using the Docker image, `sspreitzer/shellinabox`. At the
    time of writing, it is the most popular version by far on Docker Hub. With the
    following command, we are running the application with a user, `gnschenker`; password, `top-secret`;
    `sudo` for the user enabled; and with self-signed certificates:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在VM上的容器中运行**Shell in a Box**（[https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)）。有很多人将Shell
    in a Box容器化。我们使用的是Docker镜像，`sspreitzer/shellinabox`。在撰写本文时，这是Docker Hub上迄今为止最受欢迎的版本。使用以下命令，我们将以用户`gnschenker`、密码`top-secret`、启用用户的`sudo`和自签名证书运行应用程序：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that initially, we recommend running the container in interactive mode
    so that you can follow what's happening. Once you are more familiar with the service,
    consider running it in the background with the `-d` flag. Also, note that we are
    mounting the `~/dev` folder from the host to the `/usr/src/dev` folder inside
    the container. This is useful if we want to remotely edit code that we have, for
    example, cloned from GitHub into the `~/dev` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最初我们建议以交互模式运行容器，以便您可以跟踪发生的情况。一旦您更熟悉该服务，考虑使用`-d`标志在后台运行它。还要注意，我们将主机的`~/dev`文件夹挂载到容器内的`/usr/src/dev`文件夹。如果我们想要远程编辑我们从GitHub克隆的代码，这将非常有用，例如，克隆到`~/dev`文件夹中。
- en: Also, notice that we are mapping port `4200` of Shell in a Box to host port
    `4200`. This is the port over which we will be able to access the shell using
    a browser and HTTPS. Hence, you need to open port `4200` for ingress on your VM.
    As a protocol, select TCP.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们将Shell in a Box的端口`4200`映射到主机端口`4200`。这是我们将能够使用浏览器和HTTPS访问shell的端口。因此，您需要在VM上为入口打开端口`4200`。作为协议，选择TCP。
- en: 'Once the container is running and you have opened port `4200` for ingress,
    open a new browser window and navigate to `https://<public-IP>:4200`, where `<public-IP>`
    is the public IP address of your VM. Since we''re using a self-signed certificate,
    you will be greeted with a warning,here shown when using Firefox:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器正在运行，并且您已经为入口打开了端口`4200`，请打开一个新的浏览器窗口，导航到`https://<public-IP>:4200`，其中`<public-IP>`是您的VM的公共IP地址。由于我们使用的是自签名证书，您将收到一个警告，如在使用Firefox时所示：
- en: '![](assets/110c91ea-409e-47e7-b670-c5ab08fda9ba.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/110c91ea-409e-47e7-b670-c5ab08fda9ba.png)'
- en: Browser warning due to the use of self-signed certificates
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用自签名证书而导致的浏览器警告
- en: 'In our case, this is not a problem; we know the cause—it''s the self-signed
    certificate. Hence, click the **Advanced...** button and then Accept Risk and
    Continue. Now, you will be redirected to the login screen. Log in with your username
    and password:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，这不是问题；我们知道原因——就是自签名证书。因此，点击**高级...**按钮，然后接受风险并继续。现在，您将被重定向到登录屏幕。使用您的用户名和密码登录：
- en: '![](assets/6758f0cc-3405-4ede-b37e-8a0f2930a147.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6758f0cc-3405-4ede-b37e-8a0f2930a147.png)'
- en: Log in to the remote VM from your browser using HTTPS
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS从浏览器登录到远程VM
- en: We are logged in to the **Shell in a Box** application running on our remote
    VM, using the HTTPS protocol.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经登录到运行在远程VM上的**Shell in a Box**应用程序，使用HTTPS协议。
- en: 'Now, we have full access to, for example, the files and folder mapped from
    the host VM to `/usr/src/dev`. We can, for example, use the `vi` text editor to
    create and edit files, although we have to first install vi with this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以完全访问，例如，从主机VM映射到`/usr/src/dev`的文件和文件夹。例如，我们可以使用`vi`文本编辑器来创建和编辑文件，尽管我们必须首先安装vi，方法如下：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The possibilities are nearly endless. Please experiment with this setup.For
    example, run the Shell in a Box container with the Docker socket mounted, install
    Docker inside the container, and then try to use the Docker CLI from within the
    container. It is really cool because you can do all of this from within your browser!
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能性几乎是无穷无尽的。请尝试使用这个设置。例如，使用挂载了Docker套接字的Shell in a Box容器，安装容器内的Docker，然后尝试从容器内使用Docker
    CLI。这真的很酷，因为你可以在浏览器内完成所有这些操作！
- en: If you intend to use this Shell in a Box container often and need some additional
    software installed, do not hesitate to create your own custom Docker image inheriting
    from `sspreitzer/shellinabox`.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打算经常使用这个Shell in a Box容器，并且需要安装一些额外的软件，请毫不犹豫地创建你自己的自定义Docker镜像，继承自`sspreitzer/shellinabox`。
- en: Next, we will see how to run your development environment inside a container.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在容器内运行你的开发环境。
- en: Running your development environment inside a container
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内运行开发环境
- en: Imagine that you only have access to a workstation with Docker for Desktop installed,
    but no possibility to add or change anything else on this workstation. Now you
    want to do some proof of concepts and code some sample application using Python.
    Unfortunately, Python is not installed on your computer. What can you do? What
    if you could run a whole development environment inside a container, including
    code editor and debugger? What if, at the same time, you could still have your
    code files on your host machine?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你只能访问安装了Docker for Desktop的工作站，但无法在这台工作站上添加或更改任何其他内容。现在你想做一些概念验证，并使用Python编写一些示例应用程序。不幸的是，你的计算机上没有安装Python。你能做什么？如果你能在容器内运行整个开发环境，包括代码编辑器和调试器，同时仍然可以在主机上拥有你的代码文件呢？
- en: Containers are awesome and genius engineers have come up with solutions for
    exactly this kind of problem.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 容器很棒，聪明的工程师已经提出了解决这种问题的解决方案。
- en: 'Let''s try this for a Python application:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一下Python应用程序：
- en: 'We will be using Visual Studio Code, our favorite code editor, to show how
    to run a complete Python development environment inside a container. But first,
    we need to install the necessary Visual Studio Code extension. Open Visual StudioCode
    and install the extension called Remote Development:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用我们最喜欢的代码编辑器Visual Studio Code，来展示如何在容器内运行完整的Python开发环境。但首先，我们需要安装必要的Visual
    Studio Code扩展。打开Visual Studio Code并安装名为Remote Development的扩展：
- en: '![](assets/9cd9233c-6976-4204-b2ed-9a00693a4547.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9cd9233c-6976-4204-b2ed-9a00693a4547.png)'
- en: Remote Development extension for Visual Studio Code
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code的Remote Development扩展
- en: 'Then, click the green quick actions status bar item in the lower-left of the
    Visual Studio Code window. In the popup, select **Remote-Containers: Open Folder
    in Container...**:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，点击Visual Studio Code窗口左下角的绿色快速操作状态栏项。在弹出窗口中，选择**Remote-Containers: Open
    Folder in Container...**：'
- en: '![](assets/32c52f7a-da9f-4d2f-b82c-14343336162d.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/32c52f7a-da9f-4d2f-b82c-14343336162d.png)'
- en: Opening a project in a remote container
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程容器中打开一个项目
- en: 'Select the project folder you want to work with in the container. In our case,
    we selected the `~/fod/ch08/remote-app` folder. Visual StudioCode will start preparing
    the environment, which, the very first time, can take a couple of minutes or so.
    You will see a message like this while this is happening:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要在容器中使用的项目文件夹。在我们的案例中，我们选择了`~/fod/ch08/remote-app`文件夹。Visual Studio Code将开始准备环境，这在第一次可能需要几分钟左右。在此期间，您将看到如下消息：
- en: '![](assets/00fddd11-d359-4cae-8003-bf8206513e2c.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00fddd11-d359-4cae-8003-bf8206513e2c.png)'
- en: Visual Studio Code preparing the development container
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code正在准备开发容器
- en: 'By default, this development container runs as a non-root user—called `python`
    in our case. We learned, in a prior section, that this is a highly recommended
    best practice. You can change though, and run as `root` by commenting out the
    line with `"runArgs": [ "-u", "python" ],` in the `.devcontainer/devcontainer.json` file.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，此开发容器以非根用户身份运行，我们的情况下称为`python`。我们在之前的部分中了解到，这是一个强烈推荐的最佳实践。您可以通过注释掉`.devcontainer/devcontainer.json`文件中的`"runArgs":
    [ "-u", "python" ]`行来更改，并以`root`身份运行。'
- en: 'Open a Terminal inside Visual Studio Code with *Shift* + *Ctrl* + *` *and run
    the Flask app with the `env FLASK_APP=main.py flask run` command. You should see
    output like this:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Shift* + *Ctrl* + *`*在Visual Studio Code内打开一个终端，并使用`env FLASK_APP=main.py
    flask run`命令运行Flask应用程序。您应该会看到如下输出：
- en: '![](assets/d410a8ba-00c4-4722-a958-fba0fff9fcda.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d410a8ba-00c4-4722-a958-fba0fff9fcda.png)'
- en: Starting a Python Flask app from Visual Studio Code running inside a container
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 从Visual Studio Code在容器内运行的Python Flask应用程序开始
- en: The `python@df86dceaed3d:/workspaces/remote-app$` prompt indicates that we are
    **not** running directly on our Docker host but from within a development container
    that Visual Studio Code spun up for us. The remote part of Visual Studio Code
    itself also runs inside that container. Only the client part of Visual Studio
    Code—the UI—continues to run on our host.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`python@df86dceaed3d:/workspaces/remote-app$`提示表明我们**不是**直接在我们的Docker主机上运行，而是在Visual
    Studio Code为我们启动的开发容器内运行。Visual Studio Code本身的远程部分也运行在该容器内。只有Visual Studio Code的客户端部分——UI——继续在我们的主机上运行。'
- en: 'Open another Terminal window inside Visual Studio Code by pressing *Shift+Ctrl+`*.
    Then, use `curl` to test the application:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*Shift+Ctrl+`*在Visual Studio Code内打开另一个终端窗口。然后，使用`curl`测试应用程序：
- en: '![](assets/6fb04349-0556-43fa-a13b-bc21d70cfe9f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6fb04349-0556-43fa-a13b-bc21d70cfe9f.png)'
- en: Testing the remote Flask app
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 测试远程Flask应用程序
- en: Press *Ctrl* + *C* to stop the Flask application.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*停止Flask应用程序。
- en: We can also debug the application like we're used when working directly on the
    host. Open the `.vscode/launch.json` file to understand how the Flask app is started
    and how the debugger is attached.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以像在主机上直接工作时那样调试应用程序。打开`.vscode/launch.json`文件，了解Flask应用程序是如何启动的以及调试器是如何附加的。
- en: Open the `main.py` file and set a breakpoint on the `return` statement of the
    `home()` function.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.py`文件，并在`home()`函数的`return`语句上设置一个断点。
- en: 'Then, switch to the Debug view of Visual Studio Code and make sure the launch
    task, `Python: Flask`, is selected in the drop-down menu.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，切换到Visual Studio Code的调试视图，并确保在下拉菜单中选择启动任务`Python: Flask`。'
- en: 'Next, press the green start arrow to start debugging. The output in the Terminal
    should look like this:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按下绿色的启动箭头开始调试。终端中的输出应该如下所示：
- en: '![](assets/63424e41-5a80-476c-8a90-0415284ac839.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/63424e41-5a80-476c-8a90-0415284ac839.png)'
- en: Start debugging a remote app running in a container
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器中运行的远程应用程序开始调试
- en: 'Open another Terminal with *Shift* + *Ctrl* + *`* and test the application
    by running the `curl localhost:9000/` command. The debugger should hit the breakpoint
    and you can start analyzing:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用*Shift* + *Ctrl* + *`*打开另一个终端，并通过运行`curl localhost:9000/`命令来测试应用程序。调试器应该会触发断点，您可以开始分析：
- en: '![](assets/8d6e30fd-ec53-4dce-ae48-d9ec94e1d718.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8d6e30fd-ec53-4dce-ae48-d9ec94e1d718.png)'
- en: Line-by-line debugging in Visual Studio Code running inside a container
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的Visual Studio Code中逐行调试
- en: I cannot say strongly enough how cool that is. The backend (non-UI part) of
    Visual Studio Code is running inside a container, as is Python, the Python debugger,
    and the Python Flask application itself. At the same time, the source code is
    mounted from the host into the container and the UI part of Visual Studio Code
    also runs on the host. This opens up unlimited possibilities for developers even
    on the most restricted workstations. You can do the same for all popular languages
    and frameworks, such as .NET, C#, Java, Go, Node.js, and Ruby. If one language
    is not supported out of the box, you can craft your own development container
    that will then work the same way as what we have shown with Python.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我无法强调这有多酷。Visual Studio Code的后端（非UI部分）正在容器内运行，Python、Python调试器和Python Flask应用程序也是如此。同时，源代码从主机挂载到容器中，Visual
    Studio Code的UI部分也在主机上运行。这为开发人员在受限制最严格的工作站上打开了无限的可能性。您可以对所有流行的语言和框架执行相同的操作，比如.NET、C#、Java、Go、Node.js和Ruby。如果某种语言不受支持，您可以创建自己的开发容器，然后它将与我们展示的Python相同的方式工作。
- en: What if you are working on a workstation that does not have Docker for Desktop
    installed and is locked down even further? What are your options there?
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在没有安装Docker for Desktop并且受到更严格限制的工作站上工作，该怎么办？您有哪些选择？
- en: Running your code editor in a remote container and accessing it via HTTPS
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在远程容器中运行您的代码编辑器，并通过HTTPS访问它
- en: 'In this section, we will show how you can use Visual Studio Code to enable
    remote development inside a container. This is interesting when you are limited
    in what you can run on your workstation. Let''s follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用Visual Studio Code在容器内启用远程开发。当您在工作站上受限时，这是很有趣的。让我们按照以下步骤进行：
- en: 'Download and extract the latest version of `code-server`. You can find out
    the URL by navigating to [https://github.com/cdr/code-server/releases/latest](https://github.com/cdr/code-server/releases/latest).
    At the time of writing, it is `1.1156-vsc1.33.1`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并提取最新版本的`code-server`。您可以通过导航到[https://github.com/cdr/code-server/releases/latest](https://github.com/cdr/code-server/releases/latest)来找到URL。在撰写本文时，它是`1.1156-vsc1.33.1`：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Make sure to replace `<version>` with your specific version.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 确保用您的特定版本替换`<version>`
- en: 'Navigate to the folder with the extracted binary, make it executable, and start
    it:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到提取的二进制文件所在的文件夹，使其可执行，并启动它：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should look similar to this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于这样：
- en: '![](assets/ea928591-0b62-4b04-9281-7d2ac4e551b7.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea928591-0b62-4b04-9281-7d2ac4e551b7.png)'
- en: Starting Visual Studio Code remote-server on a remote VM
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程VM上启动Visual Studio Code远程服务器
- en: Code Server is using self-signed certificates to secure communication, so we
    can access it over HTTPS. Please make sure you note down the `Password` output
    on the screen since you need it when accessing Code Server from within your browser.
    Also note that we are using port `4200` to expose Code Server on the host, the
    reason being that we already opened that port for ingress on our VM. You can,
    of course, select any port you want—just make sure you open it for ingress.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Code Server使用自签名证书来保护通信，因此我们可以通过HTTPS访问它。请确保您记下屏幕上的`Password`输出，因为在浏览器中访问Code
    Server时需要它。还要注意，我们使用端口`4200`在主机上暴露Code Server，原因是我们已经为VM上的入口打开了该端口。当然，您可以选择任何端口
    - 只需确保您为入口打开它。
- en: 'Open a new browser page and navigate to `https://<public IP>:4200` ,where `<public
    IP>` is the public IP address of your VM. Since we are using self-signed certificates
    once again, the browser will greet you with a warning similar to what happened
    when we were using Shell in a Box earlier in this chapter. Accept the warning
    and you will be redirected to the login page of Code Server:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器页面，导航到`https://<public IP>:4200`，其中`<public IP>`是您的VM的公共IP地址。由于我们再次使用自签名证书，浏览器会出现警告，类似于我们在本章前面使用Shell
    in a Box时发生的情况。接受警告，您将被重定向到Code Server的登录页面：
- en: '![](assets/d465a2e6-484a-44ef-98e5-f2a793ed4f9e.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d465a2e6-484a-44ef-98e5-f2a793ed4f9e.png)'
- en: Login page of Code Server
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Code Server的登录页面
- en: 'Enter the password that you noted down before and click ENTER IDE. Now you
    will be able to use Visual Studio Code remotely via your browser over a secure
    HTTPS connection:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入您之前记录的密码，然后点击“进入IDE”。现在您将能够通过安全的HTTPS连接远程使用Visual Studio Code：
- en: '![](assets/119fd2f9-696d-40d1-a25c-8292f546b98e.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/119fd2f9-696d-40d1-a25c-8292f546b98e.png)'
- en: Visual Studio Code running in the browser over HTTPS
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器上运行的Visual Studio Code通过HTTPS
- en: Now you can do your development from, for example, a Chrome Book or a locked-down
    workstation, without restrictions. But wait a minute, you may say now! What does
    this have to do with containers? You're right—so far, there are no containers
    involved. I could say, though, that if your remote VM has Docker installed, you
    can use Code Server to do any container-specific development, and I would have
    saved the day. But that would be a cheap answer.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以从Chrome Book或受限制的工作站等设备进行开发，而不受限制。但等一下，您可能会说！这与容器有什么关系？您是对的——到目前为止，没有涉及到容器。不过，我可以说，如果您的远程VM安装了Docker，您可以使用Code
    Server来进行任何与容器相关的开发，我就可以解决问题了。但那将是一个廉价的答案。
- en: 'Let''s run Code Server itself in a container. That should be easy, shouldn''t
    it? Try using this command, which maps the internal port `8080` to the host port
    `4200` and mounts host folders containing Code Server settings and possibly your
    projects into the container:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在一个容器中运行Code Server本身。这应该很容易，不是吗？尝试使用这个命令，将内部端口`8080`映射到主机端口`4200`，并将包含Code
    Server设置和可能包含您的项目的主机文件夹挂载到容器中：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note, the preceding command runs Code Server in insecure mode as indicated
    in the output:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令以不安全模式运行Code Server，如输出所示：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can now access Visual Studio Code in your browser at `http://<public IP>:4200`.
    Please note the `HTTP` in the URL instead of `HTTPS`! Similarly to when running
    Code Server natively on the remote VM, you can now use Visual Studio Code from
    within your browser:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以在浏览器中访问`http://<public IP>:4200`中的Visual Studio Code。请注意URL中的`HTTP`而不是`HTTPS`！与在远程VM上本地运行Code
    Server时类似，您现在可以在浏览器中使用Visual Studio Code：
- en: '![](assets/c7e66138-3253-4388-a724-f50fe7f064fc.png) Developing within your
    browser'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/c7e66138-3253-4388-a724-f50fe7f064fc.png) 在浏览器中进行开发'
- en: With this, I hope you have got a feel for the near-unlimited possibilities that
    the use of containers offers to you.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个，我希望您对容器的使用提供了近乎无限的可能性有所了解。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have shown a few tips and tricks for the advanced Docker
    user that can make your life much more productive. We have also shown how you
    can leverage containers to serve whole development environments that run on remote
    servers and can be accessed from within a browser over a secure HTTPS connection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了一些高级Docker用户的技巧和窍门，可以让您的生活更加高效。我们还展示了如何利用容器来提供在远程服务器上运行并可以通过安全的HTTPS连接从浏览器中访问的整个开发环境。
- en: In the next chapter, we will introduce the concept of a distributed application
    architecture and discuss the various patterns and best practices that are required
    to run a distributed application successfully. In addition to that, we will list
    some of the concerns that need to be fulfilled to run such an application in production
    or a production-like environment.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍分布式应用架构的概念，并讨论运行分布式应用所需的各种模式和最佳实践。除此之外，我们还将列出在生产环境或类似生产环境中运行此类应用所需满足的一些问题。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name the reasons why you would want to run a complete development environment
    inside a container.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出你想在容器内运行完整开发环境的原因。
- en: Why should you avoid to run applications inside a container as `root`?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该避免以`root`身份在容器内运行应用程序？
- en: Why would you ever bind-mount the Docker socket into a container?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么要将Docker套接字绑定到容器中？
- en: When pruning your Docker resources to make space, why do you need to handle
    volumes with special care?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清理Docker资源以释放空间时，为什么需要特别小心处理卷？
- en: Further reading
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Using Docker in Docker at [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CI中不要在Docker中使用Docker：在[http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)中使用Docker
- en: Shell in a Box at [https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)上的Shell
    in a Box
- en: Remote development using SSH at [https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)上使用SSH进行远程开发
- en: Developing inside a container at [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)中在容器内开发
