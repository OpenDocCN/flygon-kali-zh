- en: Chapter 1. Instant Android Systems Development How-to
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。即时Android系统开发指南
- en: Welcome to *Instant Android Systems Development How-to*. This book will equip
    you with all the necessary skills needed to become a successful Android systems
    programmer. We will cover a range of topics right from building the source code
    to flashing actual Android phones. The book assumes familiarity and an understanding
    of the Android software development kit. The reader is requested to practically
    perform all the steps in each recipe to gain a better understanding of how to
    develop for the Android operating system.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎使用*Instant Android Systems Development How-to*。本书将为您提供成为成功的Android系统程序员所需的所有必要技能。我们将涵盖一系列主题，从构建源代码到刷写实际的Android手机。本书假定读者熟悉并了解Android软件开发工具包。要更好地了解如何为Android操作系统开发，请读者务必实际执行每个配方中的所有步骤。
- en: Building Android (Must know)
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Android（必须知道）
- en: This recipe sets up your build computer and instructs you on how to download
    and build the Android operating system from scratch.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方设置了您的构建计算机，并指导您如何从头开始下载和构建Android操作系统。
- en: Getting ready
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need Ubuntu 10.04 LTS or later (Mac OS X is also supported by the build
    system, but we will be using Ubuntu for this book). This is the supported build
    operating system, and the one for which you will get the most help from the online
    community. In my examples, I use Ubuntu 11.04, which is also reasonably well supported.
    You need approximately 6 GB of free space for the Android code files. For a complete
    build, you need 25 GB of free space. If you are using Linux in a virtual machine,
    make sure the RAM or the swap size is at least 16 GB, and you have 30 GB of disk
    space to complete the build.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要Ubuntu 10.04 LTS或更高版本（Mac OS X也受到构建系统的支持，但我们将在本书中使用Ubuntu）。这是受支持的构建操作系统，也是您将从在线社区获得最多帮助的操作系统。在我的示例中，我使用的是Ubuntu
    11.04，这个版本也得到了相当好的支持。您需要大约6GB的空闲空间来存储Android代码文件。对于完整的构建，您需要25GB的空闲空间。如果您在虚拟机中使用Linux，请确保RAM或交换空间至少为16GB，并且您有30GB的磁盘空间来完成构建。
- en: As of Android Versions 2.3 (Gingerbread) and later, building the system is only
    possible on 64-bit computers. Using 32-bit machines is still possible if you work
    with Froyo (Android 2.2). However, you can still build later versions on a 32-bit
    computer using a few "hacks" on the build scripts that I will describe later.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android版本2.3（姜饼）开始，只能在64位计算机上构建系统。在32位机器上仍然可以使用Froyo（Android 2.2）。但是，您仍然可以在32位计算机上使用构建脚本上的一些“技巧”构建后续版本，我稍后将描述。
- en: 'The following steps outline the process needed to set up a build environment
    and compile the Android framework and kernel:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤概述了设置构建环境和编译Android框架和内核所需的过程：
- en: Setting up a build environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置构建环境
- en: Downloading the Android framework sources
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载Android框架源代码
- en: Building the Android framework
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Android框架
- en: Building a custom kernel
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建自定义内核
- en: 'In general, your (Ubuntu Linux) build computer needs the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，您的（Ubuntu Linux）构建计算机需要以下内容：
- en: Git 1.7 or newer (GIT is a source code management tool), JDK 6 to build Gingerbread
    and later versions, or JDK 5 to build Froyo and older versions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 1.7或更新版本（GIT是一个源代码管理工具），用于构建Gingerbread和更高版本的JDK 6，或用于构建Froyo和旧版本的JDK 5
- en: Python 2.5 – 2.7
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 2.5 - 2.7
- en: GNU Make 3.81 – 3.82
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GNU Make 3.81 - 3.82
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will first set up the build environment with the help of the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过以下步骤设置构建环境：
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All of the following steps are targeted towards 64-bit Ubuntu.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下所有步骤都针对64位Ubuntu。
- en: 'Install the required JDK by executing the following command:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装所需的JDK：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Install the required library dependencies:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装所需的库依赖项：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[OPTIONAL]. On Ubuntu 10.10, a symlink is not created between `libGL.so.1`
    and `libGL.so`, which sometimes causes the build process to fail:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 【可选】在Ubuntu 10.10上，`libGL.so.1`和`libGL.so`之间没有创建符号链接，这有时会导致构建过程失败：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[OPTIONAL] On Ubuntu 11.10, an extra dependency is required:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 【可选】在Ubuntu 11.10上，需要额外的依赖项：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, we will download the Android sources from Google's repository.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将从Google的存储库中下载Android源代码。
- en: 'Install repo. Make sure you have a `/bin` directory and that it exists in your
    `PATH` variable:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装repo。确保您有一个`/bin`目录，并且它存在于您的`PATH`变量中：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Repo is a python script used to download the Android sources, among other tasks.
    It is designed to work on top of GIT.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Repo是一个用于下载Android源代码的Python脚本，还可以执行其他任务。它旨在在GIT之上工作。
- en: Initialize repo.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化repo。
- en: In this step, you need to decide the branch of the Android source you wish to
    download. If you wish to make use of Gerrit, which is the source code reviewing
    tool used, make sure you have a live Google mail address. You will be prompted
    to use this e-mail address when repo initializes.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此步骤中，您需要决定要下载的Android源代码的分支。如果您希望使用Gerrit，这是用于源代码审查的工具，请确保您拥有一个活动的Google邮箱地址。当repo初始化时，您将被提示使用此电子邮件地址。
- en: 'Create a working directory on your local machine. We will call this `android_src`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地计算机上创建一个工作目录。我们将其称为`android_src`：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following command will initialize repo to download the "master" branch:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将初始化repo以下载“master”分支：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following command will initialize repo to download the Gingerbread 2.3.4
    branch:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将初始化repo以下载Gingerbread 2.3.4分支：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-b` switch is used to specify the branch you wish to download.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`-b`开关用于指定要下载的分支。'
- en: 'Once repo is configured, we are ready to obtain the source files. The format
    of the command is as follows:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦配置好repo，我们就可以获取源文件。命令的格式如下：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`-jX` is optional, and is used for parallel fetch.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`-jX`是可选的，用于并行获取。'
- en: The following command will sync all the necessary source files for the Android
    framework. Note that these steps are only to download the Android framework files.
    Kernel download is a separate process.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将同步Android框架的所有必要源文件。请注意，这些步骤仅用于下载Android框架文件。内核下载是一个单独的过程。
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The source code access is anonymous, that is, you do not need to be registered
    with Google to be able to download the source code. The servers allocate a fixed
    quota to each IP address that accesses the source code. This is to protect the
    servers against excessive download traffic. If you happen to be behind a NAT and
    share an IP address with others, who also wish to download the code, you may encounter
    error messages from the source code servers warning about excessive usage. In
    this case, you can solve the problem with authenticated access. In this method,
    you get a separate quota based on your user ID, generated by the password generator
    system. The password generator and associated instructions are available at [https://android.googlesource.com/new-password](https://android.googlesource.com/new-password).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码访问是匿名的，也就是说，您无需向Google注册即可下载源代码。服务器为访问源代码的每个IP地址分配了固定的配额。这是为了保护服务器免受过多的下载流量。如果您恰好处于NAT之后并与其他人共享IP地址，而这些人也希望下载代码，您可能会遇到来自源代码服务器的错误消息，警告有关过度使用。在这种情况下，您可以通过经过身份验证的访问来解决问题。在这种方法中，您将获得一个基于密码生成系统生成的用户ID的单独配额。密码生成器和相关说明可在[https://android.googlesource.com/new-password](https://android.googlesource.com/new-password)找到。
- en: 'Once you have obtained a user ID/password and set up your system appropriately,
    you can force authentication by using the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦您获得了用户ID/密码并适当设置了系统，您可以通过使用以下命令强制进行身份验证：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice the `/a/` in the URI. This indicates authenticated access.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意URI中的`/a/`。这表示经过身份验证的访问。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Proxy issues**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**代理问题**'
- en: 'If you are downloading from behind a proxy, set the following environment variables:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是从代理后面下载的，请设置以下环境变量：
- en: '`export HTTP_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`export HTTP_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
- en: '`export HTTPS_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`export HTTPS_PROXY=http://<proxy_user_id>:<proxy_password>@<proxy_server>:<proxy_port>`'
- en: 'Next, we describe the steps needed to build the Android framework sources:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们描述构建Android框架源代码所需的步骤：
- en: Initialize the terminal environment.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化终端环境。
- en: 'Certain build-time tools need to be included in your current terminal environment.
    So, navigate to your source directory:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 某些构建时工具需要包含在当前终端环境中。因此，请导航到您的源目录：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The sources can be built for various targets. Each target descriptor has the
    `BUILD-BUILDTYPE` format:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为各种目标构建源代码。每个目标描述符都采用`BUILD-BUILDTYPE`格式：
- en: '`BUILD`: Refers to a specific combination of the source code for a certain
    device. For example, `full_maguro` targets Galaxy Nexus or `generic` targets the
    emulator.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILD`：指的是特定设备的源代码的特定组合。例如，`full_maguro`目标Galaxy Nexus或`generic`目标模拟器。'
- en: '`BUILDTYPE`: This can be one of the following three values:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BUILDTYPE`：可以是以下三个值之一：'
- en: '`user`: Suitable for production builds'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：适用于生产构建'
- en: '`userdebug`: Similar to `user`, with with root access in ADB for easier debugging'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userdebug`：与`user`类似，但在ADB中具有根访问权限，以便更容易进行调试'
- en: '`eng`: Development build only'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eng`：仅用于开发构建'
- en: 'We will be building for the emulator in our current example. Issue the following
    command to do so:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们当前的示例中，我们将为模拟器构建。发出以下命令来执行：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To actually build the code, we will use `make`. The format is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际构建代码，我们将使用`make`。格式如下：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Where `X` indicates the number of parallel builds. The usual rule is: `X` is
    the number of CPU cores + 2.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`X`表示并行构建的数量。通常的规则是：`X`是CPU核心数+2。
- en: This is an experimental formula, and the reader should feel free to test it
    with different values.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实验性的公式，读者可以随意测试不同的值。
- en: 'To build the code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建代码：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we must wait till the build is complete. Depending on your system''s specifications,
    this can take anywhere between 20 minutes and 1 hour. At the end of a successful
    build, the output looks similar to the following (note that this may vary depending
    on your target):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须等待构建完成。根据您系统的规格，这可能需要20分钟到1小时不等。在成功构建结束时，输出看起来类似于以下内容（请注意，这可能会因目标而异）：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: A better check for a successful build is to examine the newly created files
    inside the following directory.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的检查成功构建的方法是检查以下目录中新创建的文件。
- en: 'The build produces a few main files inside `android_src/out/target/product/<DEVICE>/`,
    which are as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 构建会在`android_src/out/target/product/<DEVICE>/`目录下生成一些主要文件，如下所示：
- en: '`system.img`: The system image file'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`system.img`：系统映像文件'
- en: '`boot.img`: Contains the kernel'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`boot.img`：包含内核'
- en: '`recovery.img`: Contains code for recovery partition of the device'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recovery.img`：包含设备恢复分区的代码'
- en: In the case of an emulator build, the preceding files will appear at `android_src/out/target/product/generic/`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器构建的情况下，前面的文件将出现在`android_src/out/target/product/generic/`中。
- en: 'Now, we can test our build simply by issuing the `emulator` command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过发出`emulator`命令来测试我们的构建：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This launches an Android emulator, as shown in the following screenshot, running
    the code we''ve just built:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个Android模拟器，如下截图所示，运行我们刚刚构建的代码：
- en: '![How to do it...](img/9762OS_01_01.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9762OS_01_01.jpg)'
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code we''ve downloaded contains prebuilt Linux kernels for each supported
    target. If you only wish to change the framework files, you can use the prebuilt
    kernels, which are automatically included in the build images. If you are making
    specific changes to the kernel, you will have to obtain a specific kernel and
    build it separately (shown here), which is explained later:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下载的代码包含每个支持的目标的预构建Linux内核。如果您只想更改框架文件，可以使用预构建的内核，这些内核会自动包含在构建映像中。如果您对内核进行特定更改，您将需要获取特定的内核并单独构建它（如下所示），稍后将对此进行解释：
- en: '`Faster Builds – CCACHE`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`更快的构建 - CCACHE`'
- en: The framework code contains C language and Java code. The majority of the C
    language code exists as shared objects that are built during the build process.
    If you issue the `make clean` command, which deletes all the built code (simply
    deleting the build output directory has the same effect as well) and then rebuild,
    it will take a significant amount of time. If no changes were made to these shared
    libraries, the build time can be sped up with `CCACHE`, which is a compiler cache.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 框架代码包含C语言和Java代码。大部分C语言代码存在为共享对象，在构建过程中构建。如果您发出`make clean`命令，它将删除所有构建的代码（仅删除构建输出目录也会产生相同的效果），然后重新构建，这将需要大量时间。如果对这些共享库没有进行任何更改，可以使用`CCACHE`来加快构建时间，这是一个编译器缓存。
- en: 'In the root of the source directory `android_src/`, use the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源目录`android_src/`的根目录中，使用以下命令：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To set a cache size:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存大小：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This reserves a cache size of 50 GB.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这将保留50GB的缓存大小。
- en: 'To watch how the cache is used during the build process, use the following
    command (navigate to your source directory in another terminal):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看缓存在构建过程中的使用情况，请使用以下命令（在另一个终端中导航到您的源目录）：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this part, we will obtain the sources and build the `goldfish` emulator kernel.
    Building kernels for devices is done in a similar way.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将获取源代码并构建`goldfish`模拟器内核。为设备构建内核的方式类似。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`goldfish` is the name of the kernel modified for the Android QEMU-based emulator.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`goldfish`是为Android QEMU模拟器修改的内核的名称。'
- en: 'Get the kernel sources:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取内核源代码：
- en: 'Create a subdirectory of `android_src`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`android_src`的子目录：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will clone `goldfish.git` into a folder named `goldfish` (created automatically)
    and then list the remote branches available. The output should look like the following
    (this is seen after the execution of the `git` branch):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将克隆`goldfish.git`到一个名为`goldfish`的文件夹中（自动创建），然后列出可用的远程分支。输出应该如下所示（在执行`git`分支后看到）：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here, in the following command, we notice `origin/android-goldfish-2.6.29`,
    which is the kernel we wish to obtain:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的命令中，我们注意到`origin/android-goldfish-2.6.29`，这是我们希望获取的内核：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will obtain the kernel code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取内核代码：
- en: Set up the build environment.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置构建环境。
- en: 'We need to initialize the terminal environment by updating the system `PATH`
    variable to point to a cross compiler which will be used to compile the Linux
    kernel. This cross compiler is already available as a prebuilt binary distributed
    with the Android framework sources:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通过更新系统`PATH`变量来初始化终端环境，以指向将用于编译Linux内核的交叉编译器。这个交叉编译器已经作为Android框架源代码的预构建二进制文件进行了分发：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Run an emulator (you may choose to run the emulator with the system image that
    we just built earlier. We need this to obtain the kernel configuration file. Instead
    of manually configuring it, we choose to pull the config file of a running kernel.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行模拟器（您可以选择使用我们之前构建的系统镜像运行模拟器。我们需要这样做来获取内核配置文件。而不是手动配置它，我们选择拉取正在运行内核的配置文件。
- en: Tip
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure ADB is still in your path. It will be in your `PATH` variable if you
    haven't closed the terminal window since building the framework code, otherwise
    execute the following steps sequentially.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 确保ADB仍然在您的路径中。如果您自从构建框架代码以来没有关闭终端窗口，它将在您的`PATH`变量中，否则按顺序执行以下步骤。
- en: (Note that you have to change directory to `ANDROID_SRC` to execute the following
    command).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，您必须更改目录到`ANDROID_SRC`以执行以下命令）。
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding command will copy the confi g fi le of the running kernel into
    our kernel build tree.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将把正在运行的内核的配置文件复制到我们的内核构建树中。
- en: 'Start the compilation process:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始编译过程：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If the following comes up:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现以下情况：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Enter `y` as the answer. This is some additional Android-specific configuration
    needed for the build.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`y`作为答案。这是构建所需的一些额外的特定于Android的配置。
- en: 'Now we have to wait till the build is complete. The final lines of the build
    output should look like the following (note that this can change depending on
    your target):'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们必须等待构建完成。构建输出的最后几行应该如下所示（请注意，这可能会根据您的目标而改变）：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As the last line states, the new `zImage` is available inside `arch/arm/boot/`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如最后一行所述，新的`zImage`可在`arch/arm/boot/`中找到。
- en: To test it, we boot the emulator with this newly built image.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试它，我们使用这个新构建的镜像启动模拟器。
- en: 'Copy `zImage` to an appropriate directory. I just copied it to `android_src/`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`zImage`复制到适当的目录。我只是将它复制到`android_src/`中：
- en: '[PRE28]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To verify that the emulator is indeed running our kernel, use the following
    command:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证模拟器确实正在运行我们的内核，请使用以下命令：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output will look like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is our custom kernel, since we observe the custom build string (`earlence@earlence-Satellite-L650`)
    present as well as the time of the compilation. The build string will be the name
    of your computer.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的自定义内核，因为我们观察到自定义构建字符串（`earlence@earlence-Satellite-L650`）以及编译时间都存在。构建字符串将是您计算机的名称。
- en: Once the emulator has booted up, you will see a window similar to the following:![How
    to do it...](img/9762OS_01_02.jpg)
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦模拟器启动，您将看到一个类似于以下内容的窗口：![如何做...](img/9762OS_01_02.jpg)
- en: 'Following are the steps required to build the framework on a 32-bit system:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在32位系统上构建框架所需的步骤：
- en: Make the following simple changes to build Gingerbread on 32-bit Ubuntu. Note
    that these steps assume that you have set up the system for a Froyo build. Assuming
    a Froyo build computer setup, the following steps guide you on incrementally making
    changes such that Gingerbread and later builds are possible. To set up for Froyo,
    please follow the steps explained at [http://source.android.com/source/initializing.html](http://source.android.com/source/initializing.html).
    In `build/core/main.mk`, change `ifneq (64,$(findstring 64,$(build_arch)))` to
    `ifneq (i686,$(findstring i686,$(build_arch)))`.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对32位Ubuntu进行以下简单更改以构建Gingerbread。请注意，这些步骤假设您已经为Froyo构建设置了系统。假设Froyo构建计算机设置，以下步骤将指导您逐步进行更改，使Gingerbread和以后的构建成为可能。要设置Froyo，请按照[http://source.android.com/source/initializing.html](http://source.android.com/source/initializing.html)中解释的步骤进行。在`build/core/main.mk`中，将`ifneq
    (64,$(findstring 64,$(build_arch)))`更改为`ifneq (i686,$(findstring i686,$(build_arch)))`。
- en: Note that there are two changes on that line.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意该行上有两个更改。
- en: 'In the following files:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下文件中：
- en: '`external/clearsilver/cgi/Android.mk`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external/clearsilver/cgi/Android.mk`'
- en: '`external/clearsilver/java-jni/Android.mk`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external/clearsilver/java-jni/Android.mk`'
- en: '`external/clearsilver/util/Android.mk`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external/clearsilver/util/Android.mk`'
- en: '`external/clearsilver/cs/Android.mk`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external/clearsilver/cs/Android.mk`'
- en: 'change:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'to:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Install the following packages (in addition to the packages you must have installed
    for the Froyo build):'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装以下软件包（除了Froyo构建必须安装的软件包）：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Install Java 1.6 using the following command:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令安装Java 1.6：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: How it works…
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The Android build system is a combination of several standard tools and custom
    wrappers. Repo is one such wrapper script that takes care of GIT operations and
    makes it easier for us to work with the Android sources.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Android构建系统是几个标准工具和自定义包装器的组合。Repo就是这样一个包装器脚本，它负责GIT操作，并使我们更容易地使用Android源代码。
- en: The kernel trees are maintained separately from the framework source trees.
    Hence, if you need to make customizations to a particular kernel, you will have
    to download and build it separately. The keen reader may be wondering how we are
    able to run the emulator if we never built a kernel in when we just compiled the
    framework. Android framework sources include prebuilt binaries for certain targets.
    These binaries are located in the `/prebuilt` directory under the framework source
    root directory.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 内核树与框架源树是分开维护的。因此，如果您需要对特定内核进行自定义，您将需要单独下载和构建它。热心的读者可能会想知道，如果我们在编译框架时从未构建过内核，我们是如何能够运行模拟器的。Android框架源代码包括某些目标的预构建二进制文件。这些二进制文件位于框架源根目录下的`/prebuilt`目录中。
- en: The kernel build process is more or less the same as building kernels for desktop
    systems. There are only a few Android-specific compilation switches, which we
    have shown to be easily configurable given an existing configuration file for
    the intended target.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 内核构建过程与构建桌面系统的内核几乎相同。只有少量特定于Android的编译开关，我们已经证明可以在现有配置文件的情况下轻松配置为适合预期目标。
- en: The sources consist of C/C++ and Java code. The framework does not include the
    kernel sources, as these are maintained in a separate GIT tree. In the next recipe,
    we will explain the framework code organization. It is important to understand
    how and where to make changes while developing custom builds.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码包括C/C++和Java代码。框架不包括内核源代码，因为这些源代码是在单独的GIT树中维护的。在下一个步骤中，我们将解释框架代码的组织。了解在开发自定义构建时如何以及在哪里进行更改是很重要的。
- en: Analyzing the source structure (Must know)
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析源代码结构（必须知道）
- en: In this recipe, we analyze the source structure of the framework sources.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将分析框架源代码的源代码结构。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to use a suitable code editor/viewer. I usually make use of gedit with
    several code-related options enabled. Some people prefer to use vi, emacs, or
    Eclipse. Use whatever you are comfortable with to view the sources.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用合适的代码编辑器/查看器。我通常使用gedit，并启用了几个与代码相关的选项。有些人更喜欢使用vi、emacs或Eclipse。使用您熟悉的工具查看源代码。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As you read the following table, refer to the directories of your Android source
    copy and feel free to explore the subdirectories. The top level folders are as
    follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读以下表格时，请参考您的Android源代码副本的目录，并随意探索子目录。顶层文件夹如下：
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: All folders are relative to the Android source root, unless specified otherwise.
    Also note that the source structure can and will change with the addition of new
    folders or subfolders in subsequent Android versions. This description is for
    Gingerbread.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除非另有说明，否则所有文件夹均相对于Android源代码根目录。还要注意，随着在后续Android版本中添加新文件夹或子文件夹，源代码结构可能会发生变化。这个描述是针对Gingerbread的。
- en: '| Directory name | Description |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 目录名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ANDROID_SRC/bionic/` | This contains the minimal libc (standard C library
    subset) implementation by Google, specifically for Android. It contains the sources
    for libm, libstdc++, and the dynamic linking library in addition to the linker.
    |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/bionic/` | 这包含了由谷歌专门为Android开发的最小的libc（标准C库子集）实现。除了链接器外，它还包含了libm、libstdc++和动态链接库的源代码。
    |'
- en: '| `ANDROID_SRC/bootable/` | Includes a bootloader example. It also contains
    the code for the recovery environment. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/bootable/` | 包括引导加载程序示例。它还包含了恢复环境的代码。 |'
- en: '| `ANDROID_SRC/build/` | Contains all the build scripts used to build and maintain
    an Android framework source distribution. Includes the `envsetup.h` file. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/build/` | 包含用于构建和维护Android框架源代码分发的所有构建脚本。包括`envsetup.h`文件。 |'
- en: '| `ANDROID_SRC/cts/` | Contains test cases to validate different parts of the
    framework. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/cts/` | 包含用于验证框架不同部分的测试用例。 |'
- en: '| `ANDROID_SRC/dalvik/` | Contains the Dalvik Virtual Machine sources, the
    `dx` tool (which converts Java `.class` files to `.dex` files), the dalvik support
    infrastructure, and the core class library implementation. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/dalvik/` | 包含Dalvik虚拟机源代码、`dx`工具（将Java `.class`文件转换为`.dex`文件）、dalvik支持基础设施和核心类库实现。
    |'
- en: '| `ANDROID_SRC/development/` | Contains various dev time tools, scripts to
    build an SDK version and an NDK version. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/development/` | 包含各种开发工具，用于构建SDK版本和NDK版本的脚本。'
- en: '| `ANDROID_SRC/device/` | Device specific code such as Platform libraries,
    Add-ons, Hardware abstraction code, and so on. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/device/` | 设备特定代码，如平台库、附加组件、硬件抽象代码等。'
- en: '| `ANDROID_SRC/external/` | This is a local copy of an open source external
    project used internally in Android, such as SQLite and WebKit. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/external/` | 这是安卓内部使用的开源外部项目的本地副本，如SQLite和WebKit。'
- en: '| `ANDROID_SRC/frameworks/` | Contains all of the core framework code. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/frameworks/` | 包含所有核心框架代码。'
- en: '| `frameworks/base/core` | Contains all Android class library code. This is
    linked with each Android application. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/base/core` | 包含所有安卓类库代码。这与每个安卓应用程序链接。'
- en: '| `frameworks/base/libs` | The most important item here is the `/binder` directory,
    which contains the sources for the binder IPC (inter-process communication) framework.
    |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/base/libs` | 这里最重要的是`/binder`目录，其中包含了binder IPC（进程间通信）框架的源代码。'
- en: '| `frameworks/base/services` | Runtime System Servers. This represents the
    core functionality provided by Android to user apps. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `frameworks/base/services` | 运行时系统服务器。这代表了安卓为用户应用程序提供的核心功能。'
- en: '| `ANDROID_SRC/packages/` | Contains various user space Android applications,
    including the system apps such as Settings, Clock, and so on. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/packages/` | 包含各种用户空间安卓应用程序，包括系统应用程序，如设置、时钟等。'
- en: '| `ANDROID_SRC/prebuilt/` | Contains binaries of compilers, linkers for different
    host environments, and also prebuilt linux kernel images for Android. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/prebuilt/` | 包含不同主机环境的编译器、链接器的二进制文件，以及安卓的预构建Linux内核映像。'
- en: '| `ANDROID_SRC/system/` | Contains several native code (`.C`) files that act
    as a minimal file system when the framework has booted up. These tools are needed
    for basic booting, operation, and debugging. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `ANDROID_SRC/system/` | 包含几个本地代码（`.C`）文件，当框架启动后充当最小文件系统。这些工具用于基本的引导、操作和调试。'
- en: How it works…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: All of these subdirectories are part of the Android framework (note that they
    also contain code which is not exactly part of the framework such as the code
    under `/system`, but the definition of what exactly is in the framework can be
    relaxed a bit). During a system build, most of these are pulled together with
    the help of Android make files that exist in these directories. Creating new folders
    is not advised, since all vendor-specific code can be added under the `/vendor`
    directory (not shown earlier). This directory is created when you build for a
    particular device and it contains proprietary binaries among other things, such
    as vendor-specific framework code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些子目录都是安卓框架的一部分（请注意，它们还包含不属于框架的代码，比如`/system`下的代码，但是框架的确切定义可以放宽一些）。在系统构建过程中，大多数这些都是通过这些目录中存在的安卓make文件一起拉在一起的。不建议创建新文件夹，因为所有特定于供应商的代码都可以添加到`/vendor`目录下（之前没有显示）。当为特定设备构建时，将创建此目录，并且其中包含专有二进制文件等内容，例如特定于供应商的框架代码。
- en: System booting sequence (Must know)
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统引导顺序（必须知道）
- en: In this recipe, we will go through the steps the system performs while booting
    up. Please refer to the files mentioned here as we walk you through the process.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将介绍系统在启动过程中执行的步骤。在我们引导您完成过程时，请参考这里提到的文件。
- en: Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Keep your code editor/viewer ready, as we will open a lot of source files and
    inspect their contents.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好你的代码编辑器/查看器，因为我们将打开许多源文件并检查它们的内容。
- en: 'There are three major phases for the bootup of an Android Phone, which are
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓手机的启动有三个主要阶段，如下所示：
- en: '**Phase 1 – firmware start**: After power up, the firmware starts executing.
    This is usually a first-stage bootloader. Eventually, the kernel is loaded into
    RAM, and a jump is executed to the kernel entry point.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一阶段-固件启动**：上电后，固件开始执行。这通常是第一阶段的引导加载程序。最终，内核被加载到RAM中，并且执行了一个跳转到内核入口点。'
- en: '**Phase 2 – kernel boot**: The kernel starts through its usual boot procedure.
    Memory and I/O is initialized. Interrupts are enabled, the process table is created,
    and eventually `init` is run.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二阶段-内核启动**：内核通过其通常的启动过程启动。内存和I/O被初始化。中断被启用，进程表被创建，最终运行`init`。'
- en: '**Phase 3 – user space framework boot**: There are three steps in this process.
    It begins with the execution of the `init.rc` script. This is located at `ANDROID_SRC/system/core/rootdir/init.rc`.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三阶段-用户空间框架启动**：这个过程有三个步骤。它从执行`init.rc`脚本开始。它位于`ANDROID_SRC/system/core/rootdir/init.rc`。'
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Whenever we refer to a source extract, open up that file in your code viewer.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们引用源代码时，都要在代码查看器中打开该文件。
- en: If we analyze the contents of the startup script, we observe that it sets up
    various environment variables—including `PATH` and `BOOTCLASSPATH`—that contain
    the paths to Java libraries needed by android processes.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们分析启动脚本的内容，我们会发现它设置了各种环境变量，包括`PATH`和`BOOTCLASSPATH`，其中包含了安卓进程所需的Java库的路径。
- en: 'After this, it creates a bunch of directories and sets up proper access rights.
    It also writes various configuration parameters for core services, such as `lowmemorykiller`,
    for example. It does this through the `/proc` kernel interface. Here is an example
    extract from `init.rc`:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，它创建了一堆目录并设置了适当的访问权限。它还为核心服务写入各种配置参数，例如`lowmemorykiller`。它通过`/proc`内核接口完成这些操作。以下是`init.rc`的一个示例提取：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Android has a specific `init` language, which is described in detail at the
    following location in the Android sources:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓有一种特定的`init`语言，详细描述在安卓源代码的以下位置：
- en: '[PRE36]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Following this, there is a startup procedure for `Zygote` and `system_server`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，`Zygote`和`system_server`有一个启动过程。
- en: Note
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`Zygote` is the second `init` process from the point of view of the kernel,
    and the first Android process from the point of view of the framework.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从内核的角度来看，`Zygote`是第二个`init`进程，从框架的角度来看，是第一个Android进程。
- en: 'The following extract from `init.rc` is the initialization of `Zygote`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`init.rc`中`Zygote`的初始化提取：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, `app_process` is a binary that fires up the `zygote` process during system
    initialization. The last flag (`--start-system-server`) indicates that the `system_server`
    process is to be started. The `system_server` process encompasses all the core
    services provided by the Android platform. Examples are the `ActivityManagerService`,
    `LocationManagerService`, and so on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`app_process`是一个二进制文件，在系统初始化期间启动`zygote`进程。最后一个标志(`--start-system-server`)表示要启动`system_server`进程。`system_server`进程包含Android平台提供的所有核心服务。例如`ActivityManagerService`、`LocationManagerService`等。
- en: The `app_process` binary invokes the functionality of `AndroidRuntime`, which
    is the entry point to start the dalvik environment; `AndroidRuntime.cpp` is located
    at `ANDROID_SRC/frameworks/base/core/jni/`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_process`二进制文件调用`AndroidRuntime`的功能，这是启动dalvik环境的入口点；`AndroidRuntime.cpp`位于`ANDROID_SRC/frameworks/base/core/jni/`。'
- en: 'The `app_process` binary''s code eventually comes down to the following in
    `AndroidRuntime.cpp`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`app_process`二进制代码最终归结为`AndroidRuntime.cpp`中的以下内容：'
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This then calls `int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv)`。
- en: The preceding line of code then loads the DVM into the native process, and results
    in a call to the `main` method of `ZygoteInit.java` located at `ANDROID_SRC/frameworks/base/core/java/com/android/internal/os`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，上述代码行将DVM加载到本机进程中，并导致调用位于`ANDROID_SRC/frameworks/base/core/java/com/android/internal/os`的`ZygoteInit.java`的`main`方法。
- en: 'The `ZygoteInit.main()` method is invoked, which causes the invocation of `startSystemServer`
    in that file. This method passes command-line arguments to the system server.
    An extract is shown as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`ZygoteInit.main()`方法，导致在该文件中调用`startSystemServer`。此方法将命令行参数传递给系统服务器。提取如下所示：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: After starting the system server (details to follow), the `zygote` socket is
    set up and then the process runs in "select loop mode". In this mode, the process
    spins waiting for requests to start up new Android processes.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 启动系统服务器（详细信息将在后面介绍）后，设置`zygote`套接字，然后进程以“选择循环模式”运行。在此模式下，进程会旋转等待启动新的Android进程的请求。
- en: We will now take a look at the `system_server` startup process. The code for
    this process can be located at `frameworks/base/services/java/com/android/server/SystemServer.java`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一下`system_server`的启动过程。该过程的代码可以在`frameworks/base/services/java/com/android/server/SystemServer.java`中找到。
- en: 'There are two methods called during startup, one of which is shown here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动期间调用了两种方法，其中一种在这里显示：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method is called by `zygote` (as we have seen earlier), and its job is
    to initialize native services which exist in the `android_servers` native object
    file. Examples of these native services are `SurfaceFlinger`, `AudioFlinger`,
    and so on. The `init1()` method is implemented at `ANDROID_SRC/frameworks/base/cmds/system_server/library/system_init.cpp`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法由`zygote`调用（如前所述），其工作是初始化存在于`android_servers`本机对象文件中的本机服务。这些本机服务的示例包括`SurfaceFlinger`、`AudioFlinger`等。`init1()`方法实现在`ANDROID_SRC/frameworks/base/cmds/system_server/library/system_init.cpp`中。
- en: 'The `init1()` method bootstraps `init2` via the following line in `system_init.cpp`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`init1()`方法通过`system_init.cpp`中的以下行引导`init2`：'
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, the execution is back inside `SystemServer.java`, and `init2` is run. It
    creates a thread and then proceeds to start up system servers.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行又回到了`SystemServer.java`内部，并运行了`init2`。它创建了一个线程，然后继续启动系统服务器。
- en: 'An example start sequence for the servers is as follows (based on Gingerbread
    2.3.4_r1):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的示例启动序列如下（基于Gingerbread 2.3.4_r1）：
- en: Entropy Service
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 熵服务
- en: Power Manager
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电源管理器
- en: Activity Manager
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 活动管理器
- en: Telephony Registry
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电话注册表
- en: Package Manager
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包管理器
- en: Account Manager
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 帐户管理器
- en: Content Manager
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内容管理器
- en: 'This code can be seen inside the `run()` method of `SystemServer.java`. Once
    the `ActivityManagerService` class is started (and boot is completed), the first
    few Android applications are started up, as shown here:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码可以在`SystemServer.java`的`run()`方法中看到。一旦启动`ActivityManagerService`类（并完成引导），就会启动前几个Android应用程序，如下所示：
- en: '[PRE42]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Zygote is forked every time a new android process is needed. So, when a user
    launches an application through the UI, zygote is forked and a process is created.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 每次需要新的Android进程时，都会分叉Zygote。因此，当用户通过UI启动应用程序时，Zygote会分叉并创建一个进程。
- en: 'The complete booting system sequence is shown in the following diagram:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的引导系统序列如下图所示：
- en: '![How it works…](img/9762OS_02_01.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/9762OS_02_01.jpg)'
- en: There's more
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: We will now take a look at some pointers on good and secure code style to be
    followed when writing code for Android.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看一下在为Android编写代码时应遵循的一些良好和安全的代码风格指针。
- en: Secure coding guidelines
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全编码指南
- en: 'Adherence to secure coding practice is of vital importance when modifying the
    system. As a developer, it is your responsibility to ensure that you do not inadvertently
    make the system insecure by your changes. To aid you in this process, here are
    a few points to keep in mind:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改系统时，遵守安全编码规范至关重要。作为开发人员，您有责任确保您的更改不会无意中使系统变得不安全。为了帮助您进行此过程，请记住以下几点：
- en: '**Always use permission strings to protect functionality**: Whenever you add
    new functionalities to the system, protect the methods with a `checkPermission(...)`
    call.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终使用权限字符串来保护功能**：每当您向系统添加新功能时，请使用`checkPermission(...)`调用来保护方法。'
- en: '**Ensure modified code does not evade permission checks**: The framework code
    usually invokes the `checkPermission(...)` method before the functionality of
    a method is executed. When you modify such code, make sure no code paths are introduced
    which bypass the checks. Do this using local test cases. If test cases exist for
    the method you are modifying, execute them after making your changes.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**确保修改的代码不会规避权限检查**：框架代码通常在执行方法的功能之前调用`checkPermission(...)`方法。当你修改这样的代码时，确保没有引入绕过检查的代码路径。使用本地测试用例来做到这一点。如果存在用于你正在修改的方法的测试用例，请在进行修改后执行它们。'
- en: '**Read the security documentation in the code**: Many system services—for example,
    `PackageManagerService.java`—have internal documentation in the form of comments.
    Just follow these instructions.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阅读代码中的安全文档**：许多系统服务，例如`PackageManagerService.java`，都有以注释形式的内部文档。只需按照这些说明。'
- en: '**Document your newly added code**: If there are specific security guidelines
    to be followed if someone modifies your code, mention these clearly.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**记录你新添加的代码**：如果有特定的安全指南需要遵循，如果有人修改了你的代码，清楚地提到这些。'
- en: Creating a basic interface file (Must know)
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个基本的接口文件（必须知道）
- en: We will apply previously learned concepts, such as working with the build system,
    the Android startup process, and the common Android systems design patterns, to
    build a complete working system with a custom system service. In our example,
    we will create a simple service to implement a small hashing function. We will
    then add this service to the startup process. As stated in the recipe on Common
    Design patterns, a system service is a long running task that implements some
    functionality such as providing the device's GPS co-ordinates, for example.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用先前学到的概念，比如与构建系统、Android启动过程和常见的Android系统设计模式的工作，来构建一个完整的工作系统，其中包括一个自定义的系统服务。在我们的示例中，我们将创建一个简单的服务来实现一个小的哈希函数。然后我们将把这个服务添加到启动过程中。正如在常见设计模式的配方中所述，系统服务是一个长时间运行的任务，实现一些功能，比如提供设备的GPS坐标。
- en: The interface file is written in **Android Interface Definition Language** (**AIDL**).
    The interface represents the public remote interface for the service.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接口文件是用**Android接口定义语言**（**AIDL**）编写的。该接口表示服务的公共远程接口。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 做好准备
- en: We will write the code at `ANDROID_SRC/frameworks/base/core/java/android/os/packt`.
    The code is written at this location because it follows the conventions of Android
    systems coding and, more importantly, the build system is designed to automatically
    pick up files from these pre-known locations. Hence, to avoid modifications to
    the build system, we write our code at standard locations. Another reason is that
    since we are writing framework-level extensions, they have to be tightly integrated
    with the framework, and the above location is where all such code is written.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`ANDROID_SRC/frameworks/base/core/java/android/os/packt`编写代码。代码写在这个位置是因为它遵循Android系统编码的惯例，更重要的是，构建系统被设计为自动从这些预先知道的位置中挑选文件。因此，为了避免对构建系统的修改，我们在标准位置编写我们的代码。另一个原因是，由于我们正在编写框架级扩展，它们必须与框架紧密集成，上述位置是所有这类代码的编写位置。
- en: Create a directory called `packt` under `/os`. This helps us to better organize
    the code and easily distinguish custom code from framework code. This is important
    since you are modifying an already tested open source system. Simply due to the
    sheer size of Android, making indiscriminate changes to the code can introduce
    really hard-to-find bugs. Hence, having a clear separation between newly added
    code and framework code is a good practice.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/os`下创建一个名为`packt`的目录。这有助于我们更好地组织代码，并轻松区分自定义代码和框架代码。这是很重要的，因为你正在修改一个已经经过测试的开源系统。仅仅因为Android的规模庞大，对代码进行不加区分的更改可能会引入非常难以找到的错误。因此，在新添加的代码和框架代码之间有一个明确的分隔是一个好的做法。
- en: How to do it…
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: The following code represents the Android interface definition of the system
    service. It specifies the methods that are exposed by the service for use by clients.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示系统服务的Android接口定义。它指定了服务为客户端使用暴露的方法。
- en: Our example exposes a single method named `getMD5(String)` that calculates the
    MD5 hash for the input parameter.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例暴露了一个名为`getMD5(String)`的单一方法，用于计算输入参数的MD5哈希。
- en: 'Save the following code file as `IPacktCrypto.aidl`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码文件保存为`IPacktCrypto.aidl`：
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have to communicate this new file to the build system. This is done by adding
    the following line to the `LOCAL_SRC_FILES` entry in the `Android.mk` file located
    at `ANDROID_SRC/frameworks/base`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将这个新文件传达给构建系统。这是通过在位于`ANDROID_SRC/frameworks/base`的`Android.mk`文件中的`LOCAL_SRC_FILES`条目中添加以下行来完成的。
- en: 'Scroll to the `LOCAL_SRC_FILES` directive. The last few lines should look like
    the following (GingerBread 2.3.4_r1):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`LOCAL_SRC_FILES`指令。最后几行应该如下所示（姜饼 2.3.4_r1）：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that we have specified our newly added interface definition file. Inclusion
    of the filename here results in the invocation of the AIDL compiler on the file
    to generate the proxy and stub classes (the proxy/stub classes contain marshalling
    code).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经指定了我们新添加的接口定义文件。在这里包含文件名会导致对文件进行AIDL编译，以生成代理和存根类（代理/存根类包含编组代码）。
- en: How it works…
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Proxy/stub marshalling code is needed because the system server runs in its
    own process. Thus, to invoke its functions from other processes, you need an intermediate
    layer that marshals calls from one process to another. In case of Android, generated
    stub/proxy classes constitute this layer.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 代理/存根编组代码是必需的，因为系统服务器在自己的进程中运行。因此，为了从其他进程调用它的函数，你需要一个中间层，将调用从一个进程编组到另一个进程。在Android的情况下，生成的存根/代理类构成了这一层。
- en: The AIDL file has to be compiled by the build system with the help of the AIDL
    compiler. Therefore, we list the name of our file towards the end of the existing
    framework files in the make file. When the system is being built, AIDL will be
    invoked on `IPacktCrypto.aidl`, and will result in the generation of proxy and
    stub classes. These classes are generated at `android_src/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: AIDL文件必须由构建系统借助AIDL编译器进行编译。因此，我们在make文件的现有框架文件末尾列出我们的文件名。当系统正在构建时，AIDL将在`IPacktCrypto.aidl`上调用，并将生成代理和存根类。这些类生成在`android_src/out/target/common/obj/JAVA_LIBRARIES/framework_intermediates/src/core/java/android/os`。
- en: Creating a system service skeleton (Must know)
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建系统服务骨架（必须知道）
- en: In this recipe, we will create the outline code of our custom system service.
    This will help us in understanding the basic mechanics and components of system
    services. To refresh your memory, a system service is a long running task that
    provides useful functionalities to Android applications. An example is the GPS
    services that interface with the GPS hardware and provide services such as proximity
    alerts.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建自定义系统服务的概要代码。这将帮助我们了解系统服务的基本机制和组件。为了提醒您，系统服务是提供有用功能给Android应用程序的长时间运行的任务。一个例子是与GPS硬件进行接口并提供诸如接近警报之类的服务的GPS服务。
- en: Getting ready
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will add our system server code to `ANDROID_SRC/frameworks/base/services/java/com/android`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把系统服务器代码添加到`ANDROID_SRC/frameworks/base/services/java/com/android`。
- en: Create a directory called `packt` at the preceding location. Inside that directory,
    create a file named `PacktCrypto.java`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述位置创建一个名为`packt`的目录。在该目录中，创建一个名为`PacktCrypto.java`的文件。
- en: How to do it…
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Write the following code and save it as `PacktCrypto.java`. This is the main
    system service class file:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下代码并将其保存为`PacktCrypto.java`。这是主要的系统服务类文件：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Downloading the example code**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.packtpub.com](http://www.packtpub.com)的帐户中下载您购买的所有Packt图书的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便直接通过电子邮件接收文件。
- en: The following method implements the functionality of the system service. You
    may have noticed that the method name and signature is identical to the one specified
    in the AIDL file. This is crucial as it has to match for the correct marshalling
    code to be generated.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方法实现了系统服务的功能。您可能已经注意到，方法名和签名与AIDL文件中指定的方法名和签名相同。这一点非常重要，因为它必须匹配才能生成正确的编组代码。
- en: '[PRE46]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code block represents the system service. It extends `IPacktCrypto.Stub`,
    which is a stub class that will be generated by the AIDL compiler when it is run
    on the `IPacktCrypto.aidl` file. We use a singleton pattern to instantiate the
    class to ensure that only one object of `PacktCrypto` exists in the system. We
    need to ensure this, as only one service will be entered into the service directory.
    The code also illustrates various other best practices. For example, the use of
    a log tag and the singleton pattern of service instantiation. These are common
    coding styles for system services.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块代表了系统服务。它扩展了`IPacktCrypto.Stub`，这是在运行`IPacktCrypto.aidl`文件时AIDL编译器将生成的存根类。我们使用单例模式来实例化该类，以确保系统中只存在一个`PacktCrypto`对象。我们需要确保这一点，因为只有一个服务将被输入到服务目录中。该代码还说明了各种其他最佳实践。例如，使用日志标签和服务实例化的单例模式。这些都是系统服务的常见编码风格。
- en: At this stage, we have created an interface definition for our service, created
    methods to obtain a reference to the service, and also we have implemented the
    functionality provided by the service, that is, the hashing function.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经为我们的服务创建了一个接口定义，创建了获取服务引用的方法，同时我们也实现了服务提供的功能，即哈希函数。
- en: 'Now we can run a test build to make sure everything compiles fine. Open up
    a terminal emulator and initiate a build for the emulator:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以运行一个测试构建，确保一切都编译正常。打开终端模拟器并为模拟器启动构建：
- en: '[PRE47]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works…
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Traditionally, proxy classes represent the code component that executes on the
    client side of a remote request. Likewise, stubs execute on the server side. Therefore,
    our system server extends `IPacktCrypto.Stub`, which was generated during the
    build process from the `IPacktCrypto.aidl` file. We also have to implement the
    `getMD5()` interface method as it will provide the required functionality to the
    client. We choose to utilize the singleton pattern for our service to guarantee
    that only one object of the service exists in the system. This makes sense, since
    only one copy of the system service may exist in the service directory.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，代理类代表在远程请求的客户端端执行的代码组件。同样，存根在服务器端执行。因此，我们的系统服务器扩展了从`IPacktCrypto.aidl`文件生成的`IPacktCrypto.Stub`。我们还必须实现`getMD5()`接口方法，因为它将为客户端提供所需的功能。我们选择利用单例模式来保证系统中只存在一个服务对象。这是有道理的，因为服务目录中可能只存在一个系统服务的副本。
- en: Adding a custom service to the SystemServer process (Must know)
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义服务添加到SystemServer进程（必须知道）
- en: We need to register our service with the Android system and create an object.
    The Service Manager is a component that maintains a mapping of the service name
    and the associated service object. Processes invoke the Service Manager to obtain
    a reference to the system server by name. The method invoked to obtain a reference
    to a service object is `ServiceManager.getService(String)`. You can think of the
    Service Manager as a directory service that is available to service consumers.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在Android系统中注册我们的服务并创建一个对象。Service Manager是一个组件，它维护服务名称和相关服务对象的映射。进程通过名称调用Service
    Manager来获取对系统服务器的引用。用于获取服务对象引用的方法是`ServiceManager.getService(String)`。您可以将Service
    Manager视为对服务消费者可用的目录服务。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will add our custom server to `SystemServer.java` located at `ANDROID_SRC/frameworks/base/services/java/com/android/server`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的自定义服务器添加到位于`ANDROID_SRC/frameworks/base/services/java/com/android/server`的`SystemServer.java`中。
- en: How to do it…
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The following code represents modifications you need to make to the `SystemServer.java`
    file. Locate the `run()` method and add the following lines at an appropriate
    location. For the purpose of illustration, we choose to add this after all services
    have been started.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示您需要对`SystemServer.java`文件进行的修改。找到`run()`方法，并在适当的位置添加以下行。为了举例说明，我们选择在所有服务启动后添加这些行。
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: How it works…
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding code modification obtains a reference to an object of type `PacktCrypto`.
    It then adds that object to the `ServiceManager` class, which, if you recall,
    is a directory service for all system services. It adds the `PacktCrypto` object
    to the directory by invoking the `addService()` method that takes as arguments
    a string service identifier and the object itself.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码修改获取了一个`PacktCrypto`类型对象的引用。然后将该对象添加到`ServiceManager`类中，如果您还记得的话，这是所有系统服务的目录服务。它通过调用`addService()`方法将`PacktCrypto`对象添加到目录中，该方法接受一个字符串服务标识符和对象本身作为参数。
- en: In the code fragment, we must create an object of `PacktCrypto` and add it to
    the Service Manager directory with a string name. We choose `PacktCryptoService`
    for our example. At this stage, our custom server will be created and registered
    with the Service Manager.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码片段中，我们必须创建一个`PacktCrypto`对象，并将其添加到带有字符串名称的Service Manager目录中。我们选择`PacktCryptoService`作为示例。在这个阶段，我们的自定义服务器将被创建并注册到Service
    Manager中。
- en: Testing the PacktCrypto service (Must know)
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试PacktCrypto服务（必须知道）
- en: At this stage, we are ready to test the custom service (`PacktCrypto`) which
    provides a hashing functionality to clients. Therefore, we will write a small
    test case inside the `SystemServer` process itself. This case is executed after
    the custom server has started.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经准备好测试自定义服务（`PacktCrypto`），该服务为客户端提供了哈希功能。因此，我们将在`SystemServer`进程中编写一个小的测试用例。此用例在自定义服务器启动后执行。
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Write the following test code inside `SystemServer.java` itself after the location
    where you created the service, that is, the location where changes were made in
    the *Adding a custom service to the SystemServer process* recipe.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SystemServer.java`中的服务创建位置，也就是在*向SystemServer进程添加自定义服务*配方中进行更改的位置后，编写以下测试代码。
- en: How to do it…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'The following lines of codes are a few lines added to `SystemServer.java`.
    Add it at a location after object creation of the service:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码行是添加到`SystemServer.java`的几行代码。将其添加到服务对象创建后的位置：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: After you have added the code, run a make and then start the emulator (for steps
    on how to do this, refer to the steps described in the first recipe).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在添加了代码之后，运行make，然后启动模拟器（有关如何执行此操作的步骤，请参考第一个配方中描述的步骤）。
- en: 'The output in logcat should look like the following (after applying the appropriate
    filters to the log output). For example, if we use the following logging command:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在logcat中的输出应该如下（在将适当的过滤器应用到日志输出之后）。例如，如果我们使用以下日志命令：
- en: '[PRE50]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output would be:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: How it works…
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The preceding code uses an instance of `IPacktCrypto` to store a reference of
    `PacktCrypto` that is obtained from the Service Manager. We then invoke the `getMD5()`
    method, passing in a test string. We then print the output. Since this is a cross-process
    call, a `RemoteException` can occur.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用`IPacktCrypto`的实例来存储从Service Manager获取的`PacktCrypto`的引用。然后我们调用`getMD5()`方法，传入一个测试字符串。然后我们打印输出。由于这是一个跨进程调用，可能会发生`RemoteException`。
- en: Analyzing Android system partitions (Must know)
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Android系统分区（必须知道）
- en: An Android phone contains a few basic partitions along with other supporting
    partitions. This knowledge is vital to understanding how and where code is flashed
    to devices.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Android手机包含一些基本分区以及其他支持分区。了解代码是如何以及在哪里刷入设备的知识至关重要。
- en: Getting ready
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: On our test device—Samsung Galaxy Nexus (or emulator)—we can view these partitions
    with the following command executed inside an adb shell. To obtain a shell on
    the device, you should connect the device via USB and you should make sure that
    the **USB Debugging** option is enabled (located at **Settings** | **Developer
    Options**).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试设备——三星Galaxy Nexus（或模拟器）上，我们可以使用以下命令在adb shell中执行以查看这些分区。要在设备上获取shell，您应该通过USB连接设备，并确保**USB调试**选项已启用（位于**设置**
    | **开发人员选项**）。
- en: Note
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using Jellybean or higher, the option is hidden, so you need to go
    to **Settings** | **About Phone** and keep tapping on the build number until a
    Toast pops up saying that you are now a developer. The **Developer Options** will
    appear at the usual location.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Jellybean或更高版本，则该选项是隐藏的，因此您需要转到**设置** | **关于手机**，并继续点击版本号，直到出现一个Toast，表示您现在是开发人员。**开发人员选项**将出现在通常的位置。
- en: Finally, to actually obtain a shell, while the device is connected, fire up
    a terminal and type in `adb shell` and press *Enter*.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要实际获取一个shell，在设备连接的情况下，启动终端并输入`adb shell`，然后按*Enter*。
- en: Note
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, Linux does not detect the Android device, and in these cases, you
    need to edit the USB rules file. Since this is not a systems development issue
    and is commonly encountered by SDK developers, we will not detail the steps here.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，Linux无法检测到Android设备，在这些情况下，您需要编辑USB规则文件。由于这不是一个系统开发问题，而是SDK开发人员经常遇到的问题，我们不会在这里详细介绍步骤。
- en: How to do it…
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Execute the following command in a terminal with Samsung Galaxy Nexus connected
    and with debugging enabled. The following output is generated when we list the
    device''s partitions:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在连接三星Galaxy Nexus并启用调试的终端中执行以下命令。当我们列出设备的分区时，将生成以下输出：
- en: '[PRE52]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Similarly, on the Nexus S and Nexus One device, we can view the partitions
    mounted with the command. The following command lists the contents of the `mtd`
    proc file:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在Nexus S和Nexus One设备上，我们可以使用以下命令查看已挂载的分区。以下命令列出了`mtd` proc文件的内容：
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The output looks similar to the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来类似于以下内容：
- en: '[PRE54]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The following output is observed when the same command is executed on Nexus
    One:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当在Nexus One上执行相同的命令时，观察到以下输出：
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note the output you see for your device may differ slightly.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您看到的设备输出可能略有不同。
- en: How it works…
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The main thing to notice here is the existence of a few common partitions which
    are important to flashing new software. The following are major partitions on
    most Android devices:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的主要是存在一些常见分区，这些分区对于刷写新软件非常重要。以下是大多数Android设备上的主要分区：
- en: '`/boot`: This contains the kernel image and the associated RAM disk. This is
    executed by the bootloader during the startup process. Any newly built kernel
    is written to this partition. The phone will not boot if this partition is empty.'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/boot`：这包含内核映像和相关的RAM磁盘。在启动过程中由引导加载程序执行。任何新构建的内核都将写入此分区。如果此分区为空，手机将无法启动。'
- en: '`/system`: This contains the Android framework and the related system applications.
    During system operation, this is mounted as read-only so that critical system
    files are never modified.'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/system`：这包含Android框架和相关的系统应用程序。在系统操作期间，这被挂载为只读，以便关键系统文件永远不会被修改。'
- en: '`/recovery`: Is an alternative boot partition used to boot the device into
    recovery mode. The recovery code is located at `ANDROID_SRC/bootable/recovery`.
    There are many custom recovery firmware images available. A notable example is
    `ClockWorkMod`.'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/recovery`：是用于将设备引导到恢复模式的备用引导分区。恢复代码位于`ANDROID_SRC/bootable/recovery`。有许多自定义恢复固件映像可用。一个著名的例子是`ClockWorkMod`。'
- en: There's more...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The three partitions just mentioned are the ones involved in flashing a new
    build of Android on to a device. In addition to these, there are a few other partitions
    that exist:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才提到的三个分区是刷写Android新版本到设备上所涉及的分区。除此之外，还有一些其他分区存在：
- en: '`/data`: This contains user data and is sometimes called the user-data partition.
    All user-installed applications, settings, and personal data are stored in this
    partition.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/data`：这包含用户数据，有时被称为用户数据分区。所有用户安装的应用程序、设置和个人数据都存储在此分区中。'
- en: '`/cache`: Will contain frequently accessed applications.'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/cache`：将包含频繁访问的应用程序。'
- en: '`/sdcard`: This is the SD card attached to the phone. It is not a partition
    on the internal device memory.'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/sdcard`：这是连接到手机的SD卡。这不是内部设备存储器上的分区。'
- en: Compiling for a specific device (Must know)
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为特定设备编译（必须知道）
- en: Device-specific binaries are flashed to the various partitions just described.
    The framework needs to be compiled for a specific target. The target represents
    the device to which you want to flash the binaries.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于设备的二进制文件被刷写到刚才描述的各个分区。框架需要为特定目标进行编译。目标代表要刷写二进制文件的设备。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Build variants: The build system provides several types of builds. These builds
    result in minor changes to the final binaries.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 构建变体：构建系统提供了几种类型的构建。这些构建会对最终二进制文件进行轻微更改。
- en: '`engineering` (`eng`): Is the default option. Plain make defaults to this.
    Includes all modules tagged `eng`, `user`, `debug`, and `userdebug`. ADB is enabled
    and will run commands as root user.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`engineering`（`eng`）：是默认选项。普通make默认为此。包括所有标记为`eng`、`user`、`debug`和`userdebug`的模块。ADB已启用，并将以root用户身份运行命令。'
- en: '`user`: This is intended for the final production build. ADB is disabled and
    will not run commands as the root user.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`：这是用于最终生产构建的。ADB被禁用，不会以root用户身份运行命令。'
- en: '`userdebug`: Basically, the same as `user`, but the system is debuggable and
    ADB is enabled by default.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`userdebug`：基本上与`user`相同，但系统是可调试的，并且ADB默认启用。'
- en: All of these tags are assigned to projects in the `Android.mk` file. If you
    open up any of these files, it is mentioned with the help of the `LOCAL_MODULE_TAGS`
    command.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些标签都分配给`Android.mk`文件中的项目。如果您打开其中任何一个文件，都会在`LOCAL_MODULE_TAGS`命令的帮助下提到它。
- en: Getting ready
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Navigate to your Android source directory and include the build environment
    as usual. (`source build/envsetup.sh`).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 转到您的Android源目录，并像往常一样包含构建环境（`source build/envsetup.sh`）。
- en: How to do it…
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'To obtain a list of available targets supported by the source version you are
    working with, use the `lunch` command in a terminal:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取您正在使用的源版本支持的可用目标列表，请在终端中使用`lunch`命令：
- en: '[PRE56]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Before you initiate a build for a particular target, you need to obtain the
    proprietary binaries for the phone and unzip them into your source directory.
    Usually, an agreement and unzipping script accompany the binaries. After scrolling
    through the agreement, type `I AGREE` and press *Enter*. The required files will
    be unzipped to the correct location in the source directory.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在为特定目标启动构建之前，您需要获取手机的专有二进制文件并将其解压缩到源目录中。通常，二进制文件附带协议和解压缩脚本。在浏览协议后，键入`I AGREE`并按*Enter*。所需的文件将解压缩到源目录中的正确位置。
- en: 'Here is an example of downloading the Orientation Sensor for Nexus S, Build
    GRJ22:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个下载Nexus S的Orientation Sensor，Build GRJ22的示例：
- en: Navigate to [https://developers.google.com/android/nexus/drivers#crespogrj22](https://developers.google.com/android/nexus/drivers#crespogrj22).
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到[https://developers.google.com/android/nexus/drivers#crespogrj22](https://developers.google.com/android/nexus/drivers#crespogrj22)。
- en: Download the ZIP file for Orientation Sensor and place it in the Android sources
    directory on your computer.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载方向传感器的ZIP文件，并将其放置在计算机上的Android源目录中。
- en: Unzip it to the current directory. A file called `extract-akm-crespo.sh` will
    be created.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其解压缩到当前目录。将创建一个名为`extract-akm-crespo.sh`的文件。
- en: Execute it and scroll down the agreement. At the end, type in `I AGREE`. Then
    the binaries will be extracted.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行它并滚动到协议。最后，输入`I AGREE`。然后将提取二进制文件。
- en: Follow a similar procedure for the other files of your device.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对设备的其他文件执行类似的过程。
- en: Note
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The binaries for the Nexus One have to be extracted from the device itself.
    In the source directory, `ANDROID_SRC/device/htc/passion`, a shell script exists
    to pull the needed binaries directly from the device. Connect your Nexus One to
    a computer and over adb execute the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus One的二进制文件必须从设备本身提取。在源目录`ANDROID_SRC/device/htc/passion`中，存在一个shell脚本，用于直接从设备中提取所需的二进制文件。将您的Nexus
    One连接到计算机，并通过adb执行以下操作：
- en: '`./extract-files.sh`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`./extract-files.sh`'
- en: This will pull various proprietary binaries and copy them to the appropriate
    location in the source directory (`ANDROID_SRC/vendor/`).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提取各种专有二进制文件并将其复制到源目录中的适当位置（`ANDROID_SRC/vendor/`）。
- en: How it works…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `lunch` command is part of the build environment. It provides a list of
    available targets you can build with your current source distribution. In all
    the distributions, the simulator and `generic-eng` targets are available. Simulator
    was used before the QEMU emulator became available. This target is now deprecated
    and should not be used.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`lunch`命令是构建环境的一部分。它提供了您可以使用当前源分发构建的可用目标列表。在所有分发中，模拟器和`generic-eng`目标都是可用的。在QEMU模拟器可用之前，曾使用模拟器。此目标现已过时，不应再使用。'
- en: We can build the code for a generic target (the emulator), or a simulator target
    (currently outdated, this existed when the QEMU emulator was not ready). The more
    interesting options are `full_passion-userdebug` and `full_crespo-userbedug`.
    The first one represents the Google Nexus One device. Passion is the code name
    for that device. Similarly, the latter represents the Google Nexus S.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为通用目标（模拟器）或模拟器目标构建代码（当前已过时，在QEMU模拟器尚未准备好时存在）。更有趣的选项是`full_passion-userdebug`和`full_crespo-userbedug`。第一个代表Google
    Nexus One设备。Passion是该设备的代号。类似地，后者代表Google Nexus S。
- en: Google Nexus One – Passion
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Nexus One – Passion
- en: Google Nexus S – Crespo + crespo4g
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Nexus S – Crespo + crespo4g
- en: Galaxy Nexus – Maguro + Toro
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Galaxy Nexus – Maguro + Toro
- en: Therefore, based on your target device, you can select the desired build target
    and execute a make.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据您的目标设备，您可以选择所需的构建目标并执行make命令。
- en: Although Android is an open source project, certain hardware drivers are closed
    source. These include the graphics drivers, the WiFi chipset drivers on certain
    models, orientation sensors, the radio baseband software, and camera drivers.
    Therefore, if you create a build just with the source downloaded from the Android
    GIT tree, certain phone functions will not work. For example, if the correct radio
    image was not included, you will not be able to make and receive phone calls.
    However, these drivers are made available in binary format for download from [https://developers.google.com/android/nexus/drivers](https://developers.google.com/android/nexus/drivers).
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Android是一个开源项目，但某些硬件驱动程序是闭源的。这些包括图形驱动程序，某些型号的WiFi芯片组驱动程序，方向传感器，无线电基带软件和摄像头驱动程序。因此，如果您只使用从Android
    GIT树下载的源代码构建，某些手机功能将无法正常工作。例如，如果没有包含正确的无线电图像，您将无法进行电话呼叫和接听电话。但是，这些驱动程序以二进制格式提供下载，网址为[https://developers.google.com/android/nexus/drivers](https://developers.google.com/android/nexus/drivers)。
- en: There's more...
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In the event that something went wrong with your custom code and the device
    becomes unusable, you will need to restore it to a working state. Google provides
    Factory images for its developer devices. They contain the usual `system.img`,
    `boot.img`, and `recovery.img` images that will restore the device to its factory
    state. These are available at [https://developers.google.com/android/nexus/images](https://developers.google.com/android/nexus/images).
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的自定义代码出现问题，设备变得无法使用，您需要将其恢复到工作状态。Google为其开发者设备提供了工厂映像。它们包含了通常的`system.img`，`boot.img`和`recovery.img`映像，可以将设备恢复到出厂状态。这些可以在[https://developers.google.com/android/nexus/images](https://developers.google.com/android/nexus/images)上找到。
- en: Note
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The files for the Nexus One are not available at that location, and you will
    need to obtain it from an alternate location, such as Cyanogen Mod or modaco.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus One的文件在该位置不可用，您需要从其他位置获取，例如Cyanogen Mod或modaco。
- en: 'You may need to execute the following command after including proprietary binaries
    to make sure they are included in the generated software images:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含专有二进制文件后，您可能需要执行以下命令，以确保它们包含在生成的软件映像中：
- en: '[PRE57]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Flashing with Fastboot (Must know)
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Fastboot刷写（必须了解）
- en: Fastboot is a tool and a protocol used to communicate with bootloaders. It exists
    as a binary and gets included in your path when you work with the Android sources.
    Fastboot is also a part of the standard SDK (under `platform-tools`).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Fastboot是一个用于与引导加载程序通信的工具和协议。它作为一个二进制文件存在，并在您使用Android源代码时包含在您的路径中。Fastboot也是标准SDK的一部分（位于`platform-tools`下）。
- en: Getting ready
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before you can flash any software, you need to boot the device into fastboot
    mode. There are two ways of doing this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以刷写任何软件之前，您需要将设备引导到快速启动模式。有两种方法可以做到这一点：
- en: 'Using key combinations:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用按键组合：
- en: First, power off the phone completely
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，完全关闭手机
- en: '(Nexus One) Passion: Press and hold the trackball, then press **Power**'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Nexus One）Passion：按住轨迹球，然后按**电源**
- en: '(Nexus S) Crespo: Press and hold **Volume Up**, then press and hold **Power**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Nexus S）Crespo：按住**音量增加**，然后按住**电源**
- en: '(Galaxy Nexus) Maguro: Press and hold both **Volume Up** and **Volume Down**,
    then press and hold **Power**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （Galaxy Nexus）Maguro：同时按住**音量增加**和**音量减少**，然后按住**电源**
- en: 'Using ADB commands: The following command reboots the device into recovery
    mode. This has the same effect as the key combinations.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用ADB命令：以下命令将设备重启到恢复模式。这与按键组合具有相同的效果。
- en: '[PRE58]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Unlock the bootloader: You can flash software only if the bootloader allows
    it. We need to unlock the bootloader with the following command once the device
    is in fastboot mode.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 解锁引导加载程序：只有在引导加载程序允许的情况下才能刷入软件。一旦设备处于快速启动模式，我们需要使用以下命令来解锁引导加载程序。
- en: '[PRE59]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Be sure to back up whatever files/data you need from the device, since this
    operation erases all device memory.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必备份设备中您需要的所有文件/数据，因为此操作会擦除设备所有的内存。
- en: And follow the onscreen instructions.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 并按照屏幕上的指示操作。
- en: Note
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On the Nexus One, this operation voids the warranty.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在Nexus One上，此操作会使保修失效。
- en: 'For the Galaxy Nexus and Nexus S devices, you can lock the bootloader via the
    following command:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Galaxy Nexus和Nexus S设备，您可以通过以下命令锁定引导加载程序：
- en: '`fastboot oem lock`'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`fastboot oem lock`'
- en: How to do it…
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'To flash, you need to ensure you are connected to the device in fastboot mode.
    The following command will display the device''s serial number on the terminal:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要刷写，您需要确保设备处于快速启动模式下连接。以下命令将在终端上显示设备的序列号：
- en: '[PRE60]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Then, execute the following in order:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按顺序执行以下操作：
- en: '[PRE61]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The device will boot into the custom operation system. For additional information
    on different fastboot commands and the flashing process in general, refer to [http://source.android.com/source/building-devices.html](http://source.android.com/source/building-devices.html).
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 设备将启动到自定义操作系统。有关不同的快速启动命令和刷写过程的更多信息，请参考[http://source.android.com/source/building-devices.html](http://source.android.com/source/building-devices.html)。
- en: Note
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: After a successful build, the required system images will be available at `ANDROID_SRC/target/out/product/<NAME>/`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建后，所需的系统镜像将可在`ANDROID_SRC/target/out/product/<NAME>/`中找到。
- en: Here, `<NAME>` refers to the target. For the emulator, it is `generic`, similarly,
    for the Nexus S, it will be `crespo`. The available images will be `system.img`,
    `boot.img`, and `recovery.img`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<NAME>`指的是目标。对于模拟器，它是`generic`，同样地，对于Nexus S，它将是`crespo`。可用的镜像将是`system.img`、`boot.img`和`recovery.img`。
- en: How it works…
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: Fastboot is a protocol to communicate with device bootloaders. This was designed
    such that flashing can be independent of the underlying bootloader. The process
    of unlocking the bootloader is available on developer devices. This is a recent
    feature starting with Nexus S. Relocking bootloaders allows you to lock the bootloader
    preventing the installation of new firmware.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Fastboot是一种与设备引导加载程序通信的协议。它的设计是使刷写操作与底层引导加载程序无关。解锁引导加载程序的过程仅适用于开发者设备。这是Nexus
    S开始的最新功能。重新锁定引导加载程序可以防止安装新固件。
- en: Google developer phones can be loaded with custom software that we have been
    building in the previous recipes (Google developer phones are special devices
    designed for platform developers and not for the typical consumer). Firmware can
    be written to these devices' flash memory as the bootloader is unlocked. Consumer
    devices normally lock their bootloaders and flashing is not possible. The workflow
    for all three of the developer phones (Nexus One, Nexus S, and Galaxy Nexus) is,
    for the most part, identical. Fastboot is a protocol and a flashing tool used
    to write new software images to the device.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌开发者手机可以加载我们在先前教程中构建的自定义软件（谷歌开发者手机是专为平台开发人员设计的特殊设备，而不是普通消费者）。只有在解锁引导加载程序后才能向这些设备的闪存写入固件。消费者设备通常会锁定其引导加载程序，因此无法刷写。开发者手机（Nexus
    One、Nexus S和Galaxy Nexus）的工作流程在很大程度上是相同的。Fastboot是一种协议和刷写工具，用于向设备写入新的软件镜像。
- en: For more details on the fastboot protocol, refer `ANDROID_SRC/bootable/bootloader/legacy/fastboot_protocol.txt`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 有关fastboot协议的更多细节，请参考`ANDROID_SRC/bootable/bootloader/legacy/fastboot_protocol.txt`。
- en: Building a system image with your custom server for Nexus S (Should know)
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Nexus S构建自定义系统镜像（应该知道）
- en: Now, we are ready to build a custom system image. We will re-use the previously
    written code and test it on an actual device. Therefore, you will need to build
    the custom system server code and flash it to the Nexus S device in this recipe.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备构建一个自定义系统镜像。我们将重复使用先前编写的代码，并在实际设备上进行测试。因此，您需要在本教程中构建自定义系统服务器代码并将其刷入Nexus
    S设备。
- en: Getting ready
  id: totrans-407
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Navigate to the `ANDROID_SRC` directory.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 导航至`ANDROID_SRC`目录。
- en: How to do it…
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Navigate to the proprietary binary page for the Nexus S and download all files
    for the GRJ22 build. Unzip and extract them.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航至Nexus S的专有二进制页面，并下载GRJ22版本的所有文件。解压并提取它们。
- en: Lunch the `full_crespo-userdebug` target.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`full_crespo-userdebug`目标。
- en: Execute a full make. Once successful, navigate to `ANDROID_SRC/target/out/product/crespo/`.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行完整的make。成功后，导航至`ANDROID_SRC/target/out/product/crespo/`。
- en: Flash `system.img`, `boot.img`, and `recovery.img` as described above.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照上述描述刷写`system.img`、`boot.img`和`recovery.img`。
- en: 'Reboot the phone. You can use:'
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动手机。您可以使用：
- en: '[PRE62]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How it works…
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The code images are cross compiled for an ARM architecture and the proprietary
    binaries are included in them. The appropriate prebuilt kernel image is picked
    up and included in `boot.img` during the build process.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 代码镜像是为ARM架构交叉编译的，并且专有二进制文件已包含在其中。在构建过程中，适当的预构建内核镜像将被选中并包含在`boot.img`中。
- en: In the preceding recipes, we created a custom service that can be invoked by
    obtaining a reference directly to the service via the Service Manager. In this
    recipe, we will create a class library that abstracts much of that code away into
    a clean interface. The advantage of creating a class library is that it acts like
    an SDK-API for our custom service. The example we go through here will also guide
    us in adding code to the Android class library. The code is generally independent
    of system services and can be used for other purposes as well. An example of an
    Android class library is `android.app.Activity`, which is a commonly used class
    to represent Android activities. This class is part of the Android class library.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了一个自定义服务，可以通过直接获取服务管理器的引用来调用。在这个示例中，我们将创建一个类库，将大部分代码抽象成一个清晰的接口。创建类库的优势在于它就像我们自定义服务的SDK-API。这里我们要做的示例还将指导我们如何向Android类库添加代码。这些代码通常独立于系统服务，也可以用于其他目的。Android类库的一个示例是`android.app.Activity`，这是一个常用的类，用于表示Android活动。这个类是Android类库的一部分。
- en: Creating the class library (Must know)
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类库（必须知道）
- en: In this recipe, we will create a class library which accesses our custom system
    server.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将创建一个访问我们自定义系统服务器的类库。
- en: Getting ready
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a directory at `ANDROID_SRC/frameworks/base/core/java/android`. We will
    name it `packt`. Inside it, we have the following code file.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ANDROID_SRC/frameworks/base/core/java/android`创建一个目录。我们将其命名为`packt`。在其中，我们有以下代码文件。
- en: How to do it…
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We need to write a wrapper around `PacktCryptoService`, which provides us the
    MD5 creation functionality. The wrapper we write will be the class library. I
    chose to wrap a service call, as this pattern is followed by many of Android''s
    class libraries, that is, they wrap the service functionality. However, you are
    not restricted to using this type of wrapper:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要写一个围绕`PacktCryptoService`的包装器，它为我们提供MD5创建功能。我们写的包装器将是类库。我选择包装一个服务调用，因为这种模式被许多Android类库所遵循，也就是说，它们包装了服务功能。但是，你并不局限于使用这种类型的包装器：
- en: For this recipe, we need to write the following code which wraps `PacktCryptoService`.
    Save it in a file named `PacktCryptoService.java`.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个示例，我们需要编写以下代码，它包装了`PacktCryptoService`。将其保存在一个名为`PacktCryptoService.java`的文件中。
- en: '[PRE63]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Now run `make update-api`, since we have modified the public API of the system.
    Android maintains a list of interfaces, permissions, and methods in the XML files
    under `ANDROID_SRC/frameworks/base/api`. The notable file is `current.xml`. This
    file represents the interfaces, methods, and permissions that are part of the
    public API supported by Android. Since our custom class library is intended to
    be a part of the public API, we need to update `current.xml`. Hence, use the following
    command:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行`make update-api`，因为我们已经修改了系统的公共API。Android在`ANDROID_SRC/frameworks/base/api`目录下的XML文件中维护着接口、权限和方法的列表。其中一个重要的文件是`current.xml`。这个文件代表了Android支持的公共API的接口、方法和权限。由于我们的自定义类库打算成为公共API的一部分，我们需要更新`current.xml`。因此，使用以下命令：
- en: '[PRE64]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In this example, we will do something slightly different to test our code. We
    will build our custom SDK. Building the SDK generates JAR files that contain the
    Android class library. For example, when using the SDK to build normal applications,
    there is the `android.jar` file located within our project hierarchy. This file
    is the SDK that provides Android framework classes. We need to build an updated
    `android.jar` file with our newly added class library. Note that the SDK does
    not need to include the services we add to the platform as these only exist on
    the Android OS. They are not needed for SDK-based development. To build a new
    SDK, issue the following command.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将做一些稍微不同的事情来测试我们的代码。我们将构建我们自定义的SDK。构建SDK会生成包含Android类库的JAR文件。例如，当使用SDK构建普通应用程序时，我们的项目层次结构中有一个名为`android.jar`的文件。这个文件是提供Android框架类的SDK。我们需要用我们新添加的类库构建一个更新的`android.jar`文件。请注意，SDK不需要包含我们添加到平台的服务，因为这些服务只存在于Android操作系统上。它们不需要用于基于SDK的开发。要构建一个新的SDK，请发出以下命令。
- en: '[PRE65]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This command builds the SDK. At the end of the build, the output should look
    similar to the following:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令构建了SDK。在构建结束时，输出应该类似于以下内容：
- en: '[PRE66]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: If you open up `android-sdk_eng.earlence_linux-x86.zip` and examine its contents,
    you'll find that it's basically the same as a normal Android SDK. The difference
    is that we have built this with our custom code additions. Using this SDK, we
    can build an APK which uses the custom class library.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打开`android-sdk_eng.earlence_linux-x86.zip`并检查它的内容，你会发现它基本上和普通的Android SDK一样。不同之处在于我们已经用我们的自定义代码进行了构建。使用这个SDK，我们可以构建一个使用自定义类库的APK。
- en: Copy the SDK ZIP file to some external location (external to `ANDROID_SRC`).
    Now run a normal build by issuing the `make` command as described in the earlier
    recipes. This will build system images that contain the custom system service.
    These system images are used to run an emulator on which we will test our code.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将SDK ZIP文件复制到某个外部位置（不在`ANDROID_SRC`内部）。现在通过发出`make`命令来运行正常的构建，如前面的示例所述。这将构建包含自定义系统服务的系统映像。这些系统映像用于运行模拟器，我们将在模拟器上测试我们的代码。
- en: How it works…
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our class library simply obtains a reference to the custom server from the Service
    Manager. It then invokes the `getMD5()` method. The advantage of this is that
    we have a simpler and more uniform API to access our custom server. The other
    advantage is that it can be packaged into an SDK without the need to package the
    actual system service itself. This makes sense, since no system services are ever
    packaged in the SDK, only the APIs that access them are packaged.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类库只是从服务管理器中获取自定义服务器的引用。然后调用`getMD5()`方法。这样做的好处是我们有一个更简单和更统一的API来访问我们的自定义服务器。另一个好处是它可以打包成一个SDK，而不需要打包实际的系统服务本身。这是有道理的，因为SDK中从来没有打包系统服务，只有访问它们的API被打包。
- en: Note
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The SDK build target is available with every source distribution.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: SDK构建目标在每个源代码分发中都是可用的。
- en: Building an Android application against the custom SDK (Should know)
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 针对自定义SDK构建Android应用程序（应该知道）
- en: We will write an Android application that utilizes our custom SDK build in the
    previous recipe.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个Android应用程序，利用我们在上一个配方中构建的自定义SDK。
- en: Note
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In this recipe, I assume that you have already installed Eclipse and a functional
    Android SDK is installed and configured with the ADT Eclipse plugin. These steps
    are the same as those found on the Android Developer site ([http://developer.android.com/index.html](http://developer.android.com/index.html)).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我假设您已经安装了Eclipse，并且已经安装并配置了一个功能齐全的Android SDK与ADT Eclipse插件。这些步骤与Android开发者网站上找到的步骤相同（[http://developer.android.com/index.html](http://developer.android.com/index.html)）。
- en: Getting ready
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We need to make our custom SDK visible to the existing Android SDK. So, unzip
    the generated custom SDK. Inside, there will be the `platforms/android-2.3.4`
    directory. We are interested in the `android-2.3.4` directory. Rename it to `android-packt`
    and copy it into `ANDROID_SDK/platforms/`, where `ANDROID_SDK` is the path to
    your Android SDK installation.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使我们的自定义SDK对现有的Android SDK可见。因此，解压生成的自定义SDK。在内部，将会有`platforms/android-2.3.4`目录。我们对`android-2.3.4`目录感兴趣。将其重命名为`android-packt`并将其复制到`ANDROID_SDK/platforms/`中，其中`ANDROID_SDK`是您的Android
    SDK安装路径。
- en: 'Next, we need to update the API level number, so as not to clash with an existing
    installation of the same API level. Inside `android-packt`, a file with the name
    `build.prop` exists. Change the following line:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新API级别号，以避免与相同API级别的现有安装发生冲突。在`android-packt`内，存在一个名为`build.prop`的文件。更改以下行：
- en: '[PRE67]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: to
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 至
- en: '[PRE68]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Getting ready](img/9762OS_06_04.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/9762OS_06_04.jpg)'
- en: Here, `-20` is an arbitrary number. This is needed to prevent clashes.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，“-20”是一个任意的数字。这是为了防止冲突。
- en: 'Start Eclipse and navigate to the SDK Manager. You should see something similar
    to the following:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Eclipse并导航到SDK Manager。您应该看到类似以下内容：
- en: '![Getting ready](img/9762OS_06_01.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](img/9762OS_06_01.jpg)'
- en: Notice that the plugin has detected a new installation of an SDK with an API
    level of `-20`, which is our custom SDK.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，插件已检测到具有API级别“-20”的新SDK安装，这是我们的自定义SDK。
- en: How to do it…
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now follow the usual steps to create a skeleton Android application. Be sure
    to select the correct target when prompted to do so. As shown in the following
    screenshot, API level `-20` has to be selected. This is our custom SDK:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按照通常的步骤创建一个骨架Android应用程序。在提示时确保选择正确的目标。如下截图所示，必须选择API级别“-20”。这是我们的自定义SDK：
- en: '![How to do it…](img/9762OS_06_02.jpg)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9762OS_06_02.jpg)'
- en: Now, we can access our `PacktCrypto` class library just like any other Android
    API.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以像访问任何其他Android API一样访问我们的`PacktCrypto`类库。
- en: 'Write the following simple test activity. Save the following code in a file
    named `PacktTestActivity.java`:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下简单的测试活动。将以下代码保存在名为`PacktTestActivity.java`的文件中：
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In the preceding code, we simply create an object of type `PacktCrypto`, initialize
    it, and then call the `getMD5` method that calls into our custom system server.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们只是创建了一个类型为`PacktCrypto`的对象，初始化它，然后调用`getMD5`方法，该方法调用我们的自定义系统服务器。
- en: How it works…
  id: totrans-461
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `PacktCrypto` class library methods are available in the new SDK `framework.jar`
    file. This helps in compiling the application. When deployed to the emulator,
    the class library obtains a reference to the `PacktCrypto` service that is running
    on the system and provides its functionality to the Android application.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`PacktCrypto`类库方法在新的SDK `framework.jar`文件中可用。这有助于编译应用程序。在部署到模拟器时，类库会获取对正在系统上运行的`PacktCrypto`服务的引用，并将其功能提供给Android应用程序。'
- en: Testing the class library (Should know)
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类库（应该知道）
- en: This is a very simple recipe, which we use to verify that the class library
    works as expected.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的配方，我们用它来验证类库是否按预期工作。
- en: Getting ready
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: If you haven't already started an emulator with our custom system image (explained
    earlier), do so now.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有使用我们的自定义系统映像启动模拟器（前面已经解释过），现在开始启动。
- en: How to do it…
  id: totrans-467
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Build the APK. Install it via the command line (`adb install`). The SDK will
    not detect the running emulator since the SDK we use is standard/unmodified, and
    hence will not understand the dummy API level `-20`. Therefore, a launch from
    Eclipse will not work. However, the installation procedure is no different from
    a normal app installation via the command line. As specified in the Android Developer
    documentation, an APK may be installed by specifying the `adb install` command
    with an APK filename. The output looks like the following:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 构建APK。通过命令行安装它（`adb install`）。由于我们使用的SDK是标准/未修改的，因此SDK不会检测到正在运行的模拟器，并且因此不会理解虚拟API级别“-20”。因此，从Eclipse启动将不起作用。但是，安装过程与通过命令行安装普通应用程序的安装过程没有区别。根据Android开发者文档的规定，可以通过指定带有APK文件名的`adb
    install`命令来安装APK。输出如下：
- en: '![How to do it…](img/9762OS_06_03.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/9762OS_06_03.jpg)'
- en: How it works…
  id: totrans-470
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The emulator is running an image of the firmware that contains the `PacktCrypto`
    service. This was started at the system boot time. The class library simply obtains
    a copy of the service object through the Service Manager and invokes the `getMD5()`
    method. This is abstracted away in the class library which allows development
    of applications independently of code that runs on an actual system.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器正在运行包含“PacktCrypto”服务的固件映像。这是在系统启动时启动的。类库只是通过服务管理器获取服务对象的副本，并调用“getMD5（）”方法。这在类库中被抽象化，允许应用程序的开发独立于在实际系统上运行的代码。
- en: In the preceding recipes, our modifications have been tightly integrated with
    the platform code. In certain cases, such levels of integration may not be needed,
    but new features need to be added to the system. In such cases, a developer can
    add code to the framework in the form of a platform library. In this recipe, we
    will learn how to create a platform library and learn how to write an application
    which uses it.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们的修改已经与平台代码紧密集成。在某些情况下，可能不需要这种级别的集成，但需要向系统添加新功能。在这种情况下，开发人员可以将代码添加到框架中，形成一个平台库。在这个示例中，我们将学习如何创建一个平台库，以及如何编写使用它的应用程序。
- en: Writing the platform library source code (Must know)
  id: totrans-473
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写平台库源代码（必须知道）
- en: We write simple methods to use the **Data Encryption Standard** (**DES**) to
    encrypt and decrypt a string using an 8-byte password. Our encryption library
    is named `PacktPlatformLibrary`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写简单的方法来使用**数据加密标准**（**DES**）来加密和解密一个字符串，使用8字节的密码。我们的加密库名为`PacktPlatformLibrary`。
- en: Getting ready
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Since this code is external to the framework and does not need to be tightly
    integrated with the system, we will place it in a separate directory called `/vendor`
    under `ANDROID_SRC`. Usually, inside this directory, vendor-specific files are
    added. Create `ANDROID_SRC/vendor/PacktVendor`. Inside that, include the following
    one-liner `Android.mk` file, so that subsequent make files are called during build.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段代码是外部的，不需要与系统紧密集成，我们将其放在一个名为`/vendor`的单独目录下`ANDROID_SRC`。通常，在这个目录中，会添加特定于供应商的文件。创建`ANDROID_SRC/vendor/PacktVendor`。在其中，包括以下一行的`Android.mk`文件，以便在构建期间调用后续的make文件。
- en: Note
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of Android 4.0 and later, the platform library code can be placed under `ANDROID_SRC/device/`.
    However, the reader should note that this is not a fundamental change in the way
    platform libraries work and the concepts here are easily extended to later versions
    of the Android source code.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从Android 4.0及更高版本开始，平台库代码可以放在`ANDROID_SRC/device/`下。然而，读者应该注意，这并不是平台库工作方式的根本变化，这里的概念很容易扩展到Android源代码的后续版本。
- en: How to do it…
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'We start out by writing a one-liner make file for the project. This file is
    saved as `Android.mk` and is the top-level make file:'
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编写一个一行的项目make文件。将此文件保存为`Android.mk`，这是顶级make文件：
- en: '[PRE70]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Under PacktVendor, create a directory named PacktPlatformLibrary. Inside this
    we will create the platform library and write its code.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PacktVendor下，创建一个名为PacktPlatformLibrary的目录。在其中，我们将创建平台库并编写其代码。
- en: Create a directory named `java/packt/platformlibrary` under `PacktPlatformLibrary/`.
    This will hold the source code for the library.
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PacktPlatformLibrary/`下创建一个名为`java/packt/platformlibrary`的目录。这将保存库的源代码。
- en: 'Save the following code as `PacktPlatformLibrary.java`:'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码保存为`PacktPlatformLibrary.java`：
- en: '[PRE71]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The preceding method simply DES encrypts a string. You can replace the function
    with anything you like. The point of the example is to demonstrate a platform
    library:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的方法只是对字符串进行了DES加密。您可以用任何您喜欢的函数替换这个函数。示例的重点是演示一个平台库：
- en: '[PRE72]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Similarly, `decryptDES` performs the opposite function of `encryptDES`. You
    can again choose to replace this with a function of your choice. If you choose
    to do so, keep in mind that later files will have to be adjusted a bit based on
    the new functions. However, no change is needed in any of the build files:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，`decryptDES`执行`encryptDES`的相反功能。您可以选择用自己喜欢的函数替换它。如果选择这样做，请记住后续文件将根据新函数进行一些调整。但是，在任何构建文件中都不需要进行更改：
- en: 'The Android system requires that an XML file is to be created for every new
    platform library. Create an XML file at `ANDROID_SRC/vendor/PacktVendor/PacktPlatformLibrary/`.
    Save this XML file as `PacktPlatformLibrary.xml`:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Android系统要求为每个新的平台库创建一个XML文件。在`ANDROID_SRC/vendor/PacktVendor/PacktPlatformLibrary/`创建一个XML文件。将这个XML文件保存为`PacktPlatformLibrary.xml`：
- en: '[PRE73]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Finally, we need a make file to pull all the components together. Create an
    `Android.mk` file in the same directory as the preceding file:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个make文件来将所有组件整合在一起。在与前面文件相同的目录中创建一个`Android.mk`文件：
- en: '[PRE74]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding file has three sections. The first compiles the java code for
    the library and creates a JAR file. The name of this JAR is specified in the `LOCAL_MODULE`
    tag. Next, if the project directory contains documentation, that is built. Finally,
    we need to ensure the XML file is added to `/system/etc/permissions/` in the system
    image. `LOCAL_MODULE_CLASS` is used to specify this. Now, we need to build the
    components. On a terminal, inside `ANDROID_SRC`, issue the following command:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件有三个部分。第一部分编译库的java代码并创建一个JAR文件。这个JAR的名称在`LOCAL_MODULE`标签中指定。接下来，如果项目目录包含文档，那么会进行构建。最后，我们需要确保XML文件被添加到系统映像中的`/system/etc/permissions/`中。`LOCAL_MODULE_CLASS`用于指定这一点。现在，我们需要构建组件。在终端中，进入`ANDROID_SRC`，发出以下命令：
- en: '[PRE75]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The following command will compile the java code, generate a signed JAR, and
    place it in `system/framework/`:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将编译java代码，生成一个签名的JAR，并将其放在`system/framework/`中：
- en: '[PRE76]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This will place the XML file at `/system/etc/permissions/`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把XML文件放在`/system/etc/permissions/`中。
- en: How it works…
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: The platform library has two main components. One is the library itself, which
    is written in Java or C, and is packaged into a JAR (with an optional shared object
    if native code is used). The second component is an XML file that declares the
    JAR to the system as a platform library. This component is important as it helps
    the system to identify the location of the platform library when it is needed
    for loading into an application.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 平台库有两个主要组件。一个是库本身，它是用Java或C编写的，并打包成一个JAR（如果使用本机代码，则可以选择共享对象）。第二个组件是一个XML文件，它将JAR声明为平台库。这个组件很重要，因为它帮助系统在需要加载到应用程序中时识别平台库的位置。
- en: The module class `ETC` specified in the make file for the XML file is used to
    place files into the `/system/etc` directory of the firmware image.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在为XML文件指定的make文件中指定的模块类`ETC`用于将文件放入固件映像的`/system/etc`目录中。
- en: Creating the platform client (Should know)
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建平台客户端（应该知道）
- en: To test the platform library created, we need to create an Android application
    that uses the library. To do this, we will create a new "System APK". A System
    APK is an Android application that lives in the Read-Only `/system` partition
    on the device, similar to applications such as settings and contacts. System applications
    live in `ANDROID_SRC/packages/apps`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试创建的平台库，我们需要创建一个使用该库的Android应用程序。为此，我们将创建一个新的“系统APK”。系统APK是一个Android应用程序，位于设备的只读`/system`分区中，类似于设置和联系人等应用程序。系统应用位于`ANDROID_SRC/packages/apps`中。
- en: Getting ready
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a directory named `PacktLibraryClient` at that location. Inside, we write
    a small Android application that accesses the platform library and invokes a method.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在该位置创建一个名为`PacktLibraryClient`的目录。在其中，我们编写一个小型的Android应用程序，访问平台库并调用一个方法。
- en: Create the following file at `ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient`创建以下文件。
- en: How to do it…
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We begin by writing the client file that will access our platform library.
    The following code is saved as `Client.java`:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先编写将访问我们平台库的客户端文件。以下代码保存为`Client.java`：
- en: '[PRE77]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Like any other Android application, we need a manifest file, which is created
    at `ANDROID_SRC/packages/apps/PacktLibraryClient/`. The following code is saved
    in a file named `AndroidManifest.xml`:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与任何其他Android应用程序一样，我们需要一个清单文件，该文件位于`ANDROID_SRC/packages/apps/PacktLibraryClient/`。以下代码保存在名为`AndroidManifest.xml`的文件中：
- en: '[PRE78]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The new addition here is the `<uses-library>` tag. Notice that we have to specify
    the name of our custom platform library to indicate to the runtime that it is
    to be loaded with our client application.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新添加是`<uses-library>`标签。请注意，我们必须指定我们自定义平台库的名称，以指示运行时加载我们的客户端应用程序。
- en: 'Finally, we need a make file at the same directory level as the preceding file.
    Save this make file as `Android.mk`:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在与前面文件相同的目录级别上创建一个make文件。将此make文件保存为`Android.mk`：
- en: '[PRE79]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-514
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the use of the `LOCAL_JAVA_LIBRARIES` tag that is used to specify the
    platform library against which we compile.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用`LOCAL_JAVA_LIBRARIES`标签来指定我们编译时使用的平台库。
- en: 'Now we are ready to build our client APK. In a terminal, execute the following
    command (assuming the terminal environment is properly set up; for instructions,
    refer to the first recipe of this book):'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们准备构建我们的客户端APK。在终端中，执行以下命令（假设终端环境已正确设置；有关说明，请参考本书的第一个教程）：
- en: '[PRE80]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, we need to build the system image for the emulator to test our code:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为模拟器构建系统镜像来测试我们的代码：
- en: '[PRE81]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Ensure that the following files are included in the system image. This is done
    by inspecting the contents of `installed-files.txt`, which is located at `ANDROID_SRC/out/target/product/generic/`
    in the case of an emulator build. Here, I have extracted the relevant contents
    from my copy:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保以下文件包含在系统镜像中。这是通过检查`installed-files.txt`的内容来完成的，该文件位于模拟器构建的情况下的`ANDROID_SRC/out/target/product/generic/`。在这里，我从我的副本中提取了相关内容：
- en: '[PRE82]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Therefore, all of the required pieces have been integrated into the system
    image. Start the emulator, and click on the `PlatformLibraryClient` application.
    Logcat should output something similar to the following:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，所有所需的部件都已集成到系统镜像中。启动模拟器，然后点击`PlatformLibraryClient`应用程序。Logcat应该输出类似以下内容：
- en: '[PRE83]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works…
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The platform client is simply another Android application. The only difference
    here is that it is bundled with the system image and is installed at `/system/app`—the
    read-only partition.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 平台客户端只是另一个Android应用程序。这里唯一的区别是它与系统镜像捆绑在一起，并安装在`/system/app`——只读分区。
- en: The most important line in the make file for the application is the `LOCAL_JAVA_LIBRARIES`
    tag. This specifies that we will use the functionality of the platform client.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的make文件中最重要的一行是`LOCAL_JAVA_LIBRARIES`标签。这指定了我们将使用平台客户端的功能。
- en: There's more...
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To help clarify the concepts presented in this recipe, it is often helpful to
    visualize the project structure. In the following text, we pictorially depict
    what platform libraries look like in the Android sources.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助澄清本教程中提出的概念，通常有助于可视化项目结构。在下文中，我们以图形方式描述了Android源代码中平台库的外观。
- en: Platform library project organization
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平台库项目组织
- en: Most platform libraries are structured as shown in the next figure. As stated
    earlier, the top-level directory can change from `ANDROID_SRC/vendor` to `ANDROID_SRC/device/`
    if you move from Gingerbread development to Ice Cream Sandwich development.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台库的结构如下图所示。如前所述，顶级目录可以从`ANDROID_SRC/vendor`更改为`ANDROID_SRC/device/`，如果您从Gingerbread开发转移到Ice
    Cream Sandwich开发。
- en: '![Platform library project organization](img/9762OS_07_01.jpg)'
  id: totrans-531
  prefs: []
  type: TYPE_IMG
  zh: '![平台库项目组织](img/9762OS_07_01.jpg)'
- en: System application project organization
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统应用项目组织
- en: System applications have the following structure within the Android Sources.
    This figure depicts the organization in terms of the `PacktLibraryClient` system
    application we just built, but the organization is similar to other system applications.
    The point to note here is that system applications live under `ANDROID_SRC/packages/apps`
    and for the most part, the directory structure is the same as a normal Android
    application.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应用在Android源代码中具有以下结构。此图描述了我们刚刚构建的`PacktLibraryClient`系统应用的组织方式，但组织方式与其他系统应用类似。这里要注意的是系统应用位于`ANDROID_SRC/packages/apps`下，并且在大多数情况下，目录结构与普通Android应用程序相同。
- en: '![System application project organization](img/9762OS_07_02.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![系统应用项目组织](img/9762OS_07_02.jpg)'
- en: Our previous system service contained only Java code; however, such services
    may also contain calls to native code. Developers may choose to use native code
    for a variety of reasons. The most common being speed over interpreted code and
    re-use of existing libraries. In the next recipe, we will show you how to use
    native functions inside our `PacktCrypto` system service.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先前的系统服务只包含Java代码；然而，这样的服务也可能包含对本地代码的调用。开发人员可能出于各种原因选择使用本地代码。最常见的原因是速度优于解释代码和重用现有库。在下一个示例中，我们将向您展示如何在我们的`PacktCrypto`系统服务中使用本地函数。
- en: 'Also, before jumping to the next recipe, I assume that you are comfortable
    with JNI technology. If not, I recommend reading the excellent book: *The Java
    Native Interface: Programmer''s Guide and Specification* by Sheng Liang. ([http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772](http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772)).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，在跳转到下一个示例之前，我假设您对JNI技术感到满意。如果不是，我建议阅读优秀的书籍：*Java Native Interface: Programmer''s
    Guide and Specification* by Sheng Liang. ([http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772](http://www.amazon.com/Java-Native-Interface-Programmers-Specification/dp/0201325772)).'
- en: Writing the native method and registration with the JNI Onload event (Should
    know)
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写本地方法并在JNI Onload事件中注册（应该知道）
- en: The native methods for system servers are implemented at `ANDROID_SRC/frameworks/base/services/jni`.
    This directory contains an `Android.mk` file.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 系统服务器的本地方法实现在`ANDROID_SRC/frameworks/base/services/jni`中。该目录包含一个`Android.mk`文件。
- en: How to do it...
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We start by implementing the native method in C code. In this example, I choose
    to implement the popular quick sort algorithm. Note that the file has to be named
    as per the naming conventions. This is simply the package name in reverse order,
    but with underscores instead of dots as delimiters.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过C代码实现本地方法。在本例中，我选择实现流行的快速排序算法。请注意，文件必须按照命名约定命名。这只是包名按相反顺序排列，但使用下划线而不是点作为分隔符。
- en: Fire up your favorite text/code editor.
  id: totrans-541
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的文本/代码编辑器。
- en: 'Write the following code in a file named `com_android_packt_PacktCrypto.cpp`;
    it contains the native method:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为`com_android_packt_PacktCrypto.cpp`的文件中编写以下代码；它包含本地方法：
- en: '[PRE84]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Next, modify the `onload.cpp` file. There are two locations where you need
    to make additions. The first is under the `namespace android {` block. There will
    be a list of registration functions, as shown in the following code snippet:'
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，修改`onload.cpp`文件。有两个位置需要进行添加。第一个是在`namespace android {`块下。将显示一系列注册函数，如下面的代码片段所示：
- en: '[PRE85]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We need to add a line with our custom registration function. Add the following
    line inside the `namespace` block towards the end:'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在自定义注册函数中添加一行。在`namespace`块的末尾添加以下行：
- en: '[PRE86]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This is the registration function we've written in `com_android_packt_PacktCrypto.cpp`.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`com_android_packt_PacktCrypto.cpp`中编写的注册函数。
- en: 'The second addition is inside `JNI_OnLoad` in the same file—`onload.cpp`. Add
    the following line towards the end of all the registration function calls:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个添加是在同一文件`onload.cpp`中的`JNI_OnLoad`内。在所有注册函数调用的末尾添加以下行：
- en: '[PRE87]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Finally, we need to communicate to the build system that some new code has
    been added. Modify the `Android.mk` file (in the same directory as all the other
    files we''ve been modifying) by adding the following line towards the end of the
    `LOCAL_SRC_FILES` tag:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要通知构建系统已添加了一些新代码。通过在`LOCAL_SRC_FILES`标签的末尾添加以下行来修改`Android.mk`文件（与我们一直在修改的所有其他文件位于同一目录中）：
- en: '[PRE88]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Therefore, the new tag would look like:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新标签将如下所示：
- en: '[PRE89]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: How it works...
  id: totrans-555
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The native methods we write have to be loaded and identified. The Android framework
    provides a function called `jniRegisterNativeMethods` that takes as input a method
    table and a fully qualified class name of the Java class that will call the native
    method. In this case, it is our `PacktCrypto` system service. The method table
    uses the JNI method descriptor notation to indicate the type of input/output parameters.
    It also includes a function pointer to the native method implementation. The `JNI_OnLoad`
    event is called whenever a native library is loaded into the virtual machine.
    At this point, we register our native methods, like other system servers. `NELEM`
    is a framework-provided macro to calculate the length of an array. It is defined
    as follows and is located inside the `frameworks/base/include/utils/misc.h` file:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的本地方法必须被加载和识别。Android框架提供了一个名为`jniRegisterNativeMethods`的函数，它以方法表和将调用本地方法的Java类的完全限定类名作为输入。在这种情况下，它是我们的`PacktCrypto`系统服务。方法表使用JNI方法描述符表示输入/输出参数的类型。它还包括指向本地方法实现的函数指针。`JNI_OnLoad`事件在本地库加载到虚拟机中时调用。在这一点上，我们像其他系统服务器一样注册我们的本地方法。`NELEM`是一个框架提供的宏，用于计算数组的长度。它定义如下，并位于`frameworks/base/include/utils/misc.h`文件中：
- en: '[PRE90]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Writing the Java driver (Should know)
  id: totrans-558
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写Java驱动程序（应该知道）
- en: To test our native library, we need to write some Java code that will call the
    native function. I will re-use code from an earlier example, where we created
    and tested the `PacktCrypto` system service.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的本地库，我们需要编写一些Java代码来调用本地函数。我将重用之前示例中的代码，其中我们创建并测试了`PacktCrypto`系统服务。
- en: We need to call the native code from the Java-based `PacktCrypto` service. Hence,
    in this recipe, we will modify the `PacktCrypto` system service so that it can
    call a native method.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从基于Java的`PacktCrypto`服务中调用本地代码。因此，在本示例中，我们将修改`PacktCrypto`系统服务，以便它可以调用本地方法。
- en: Getting ready
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open up the `PacktCrypto.java` file that is located in the `services/java/com/android/packt`
    directory and change it by adding the following lines towards the end of the file.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`services/java/com/android/packt`目录中的`PacktCrypto.java`文件，并通过在文件末尾添加以下行来进行更改。
- en: How to do it...
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: To test the `sort` method, I simply call the `sort()` method inside our existing
    `getMD5` method. I am doing this so that you can quickly test whether the native
    code works as expected without making too many changes. If you recall, we have
    already written a test harness for `getMD5` inside `SystemServer.java`. The first
    step is to modify the `PacktCrypto.java` file by adding the following lines towards
    the end of the file.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试`sort`方法，我只需在现有的`getMD5`方法中调用`sort()`方法。我这样做是为了让您能够快速测试本地代码是否按预期工作，而不必进行太多更改。如果您还记得，我们已经在`SystemServer.java`中为`getMD5`编写了一个测试工具。第一步是通过在文件末尾添加以下行来修改`PacktCrypto.java`文件。
- en: 'This is a fragment of the `PacktCrypto.java` file that tests our native function:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`PacktCrypto.java`文件的一个片段，用于测试我们的本地函数：
- en: '[PRE91]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'By adding the following lines to the `getMD5` method towards the end, we will
    be able to quickly test our native code. The new version of `getMD5()` is as follows:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向`getMD5`方法末尾添加以下行，我们将能够快速测试我们的本地代码。`getMD5()`的新版本如下：
- en: '[PRE92]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Notice the call to `sort()`.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 注意调用`sort()`。
- en: 'Now, we can build our code. In a terminal, as usual, issue the `make` command.
    Once the build is complete, run the emulator and observe the logs:'
  id: totrans-570
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以构建我们的代码。像往常一样，在终端中，输入`make`命令。构建完成后，运行模拟器并观察日志：
- en: '[PRE93]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: How it works...
  id: totrans-572
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Java code contains a native method definition. The framework loads the native
    code and during the `onload` event, our native implementation is loaded and registered.
    When `getMD5()` is called, our native code is executed and the output is visible
    on the logger.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: Java代码包含本地方法定义。框架加载本地代码，并在`onload`事件期间，加载和注册我们的本地实现。当调用`getMD5()`时，我们的本地代码被执行，并且输出可见于日志记录器。
- en: In the next recipe, we will learn how some of the most important core Android
    services are organized and how to make changes to these services. We will also
    learn how to secure our changes with custom permissions added to the framework.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个配方中，我们将学习一些最重要的核心Android服务是如何组织的，以及如何对这些服务进行更改。我们还将学习如何通过添加到框架的自定义权限来保护我们的更改。
- en: The Internet infrastructure on Android requires discussion as its design is
    non-conventional as compared to other services such as the Location Manager service.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: Android上的Internet基础设施需要讨论，因为其设计与其他服务（如位置管理器服务）相比是非常规的。
- en: Analyzing the ActivityManagerService class (Should know)
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析ActivityManagerService类（应该知道）
- en: The `ActivityManagerService` class is probably one of the most important of
    all services that exist in an Android system. In this recipe, we will go through
    its major functions and highlight peculiarities of the service.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityManagerService`类可能是Android系统中存在的所有服务中最重要的一个。在这个配方中，我们将介绍其主要功能，并突出该服务的特殊之处。'
- en: Getting ready
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: '`ActivityManagerService.java` is the source file and is located at `ANDROID_SRC/frameworks/base/services/java/com/android/server/am`.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityManagerService.java`是源文件，位于`ANDROID_SRC/frameworks/base/services/java/com/android/server/am`。'
- en: How to do it...
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open this file in a code editor of your choice. We will move through the `ActivityManagerService`
    file and understand its various components.
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的代码编辑器中打开此文件。我们将浏览`ActivityManagerService`文件并了解其各个组件。
- en: The Activity Manager extends a class known as `ActivityManagerNative`, which
    implements the binder protocol for remote invocation. This code is written manually
    like we've written in the recipe on using IPC with our system service code. This
    was done as the AIDL compiler did not exist the time the Activity Manager code
    was written by Google employees.
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Activity Manager扩展了一个名为`ActivityManagerNative`的类，该类实现了远程调用的绑定器协议。这段代码是手动编写的，就像我们在使用IPC与系统服务代码的配方中所写的那样。这是因为在Google员工编写Activity
    Manager代码时，AIDL编译器并不存在。
- en: 'In the beginning of the file, there are various control variables for different
    aspects related to activities. One such variable is:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件开头有各种与活动相关的不同方面的控制变量。其中一个变量是：
- en: '[PRE94]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This defines the maximum number of activities that can be in the stack. It means
    the maximum number of activities that could be running at a time.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了堆栈中可以存在的最大活动数。这意味着可以同时运行的最大活动数。
- en: Another interesting variable is the duration the system waits for a process
    to be launched.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个有趣的变量是系统等待启动进程的持续时间。
- en: '[PRE95]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'SDK developers will know that when using a broadcast receiver, the `onReceive()`
    method should finish fast. The timeout is governed by:'
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SDK开发人员将知道，使用广播接收器时，`onReceive()`方法应该快速完成。超时由以下规定：
- en: '[PRE96]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: which is around `10` seconds.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 大约`10`秒钟。
- en: 'Scroll down in the file, there is a handler which does the majority of the
    work that does not require immediate return. As you may know, Android has the
    concept of a handler, which basically is a mechanism to execute code in a separate
    thread and have it return results later. The handler is defined as:'
  id: totrans-591
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中向下滚动，有一个处理程序，它执行大部分不需要立即返回的工作。您可能知道，Android有一个处理程序的概念，基本上是一种在单独的线程中执行代码并稍后返回结果的机制。处理程序定义如下：
- en: '[PRE97]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Some example tasks performed are the ANR dialogs, indicated by case `SHOW_NOT_RESPONDING_MSG`
    and the sending of broadcasts to registered receivers.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行的一些示例任务包括ANR对话框，由`SHOW_NOT_RESPONDING_MSG`指示，以及向注册接收器发送广播。
- en: Other functionality is implemented as methods that return synchronously. An
    asynchronous return means that the results of a request are returned to the caller
    at a later time, and not immediately, like a synchronous call.
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他功能是作为同步返回的方法实现的。异步返回意味着请求的结果将在稍后返回给调用者，而不是立即返回，就像同步调用一样。
- en: 'There is a separate section in the sources for permissions manipulation and
    verification. The only public entry point for permissions checking is the method:'
  id: totrans-595
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源代码中有一个专门的部分用于权限操作和验证。权限检查的唯一公共入口点是该方法：
- en: '[PRE98]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: All permission checks that are executed in the system go through this one method.
    Hence it serves as a reliable checkpoint to understand what processes are doing
    with respect to protected data and operations.
  id: totrans-597
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统中执行的所有权限检查都通过此方法。因此，它作为一个可靠的检查点，可以了解进程在保护数据和操作方面的操作。
- en: Following this, the Activity Manager has a group of methods that manage tasks
    by manipulating the activity stack. The stack is a data structure defined in the
    `ActivityStack.java` file in the same directory as the activity manager service.
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，活动管理器有一组通过操作活动堆栈来管理任务的方法。堆栈是在与活动管理器服务相同目录中的`ActivityStack.java`文件中定义的数据结构。
- en: 'The following method is executed when the system has completely booted and
    is ready to start launching user processes:'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当系统完全启动并准备好开始启动用户进程时，将执行以下方法：
- en: '[PRE99]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: There are separate sections managing services, content providers, and broadcasts.
    At the start of each section, a comment indicates what type of methods follow.
    Various API methods such as `registerReceiver`, `startActivity`, and `startService`
    are implemented by the `ActivityManagerService` class in the same file.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 有单独的部分管理服务、内容提供程序和广播。在每个部分的开头，注释指示接下来的方法类型。`ActivityManagerService`类在同一文件中实现了各种API方法，如`registerReceiver`、`startActivity`和`startService`。
- en: How it works...
  id: totrans-602
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Activity Manager service is started early during the bootup process. At
    the end, when all the initialization tasks are complete, the `systemReady` method
    is executed and the system boot complete broadcast is fired. This method is called
    by the `SystemServer` service. It is used to notify the `ActivityManagerService`
    that the system is at a point where it is possible to start running third-party
    code. While the `ActivityManagerService` does not immediately do this, it gets
    itself ready when it receives the `systemReady` call.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 活动管理器服务在启动过程中早期启动。在结束时，当所有初始化任务完成时，将执行`systemReady`方法并触发系统启动完成广播。此方法由`SystemServer`服务调用。它用于通知`ActivityManagerService`系统已经到达可以开始运行第三方代码的点。虽然`ActivityManagerService`不会立即执行此操作，但它在接收到`systemReady`调用时准备就绪。
- en: There's more...
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Whenever you make changes to the `ActivityManagerService` class, make sure that
    you don't introduce code paths that make the service vulnerable or leak sensitive
    data to malicious applications. Always follow the principles of secure coding
    and protect your methods by permission checks. If you don't want third-party developers
    to access your functionality, assign a signature permission to that method. The
    keen reader will have noticed that the `ActivityManagerService` class is like
    any other system service and executes in the context of the `SystemServer` service.
    Hence, now you realize that your custom system service executes alongside such
    important services. Any bugs in your system service have the potential to bring
    down the whole framework. So be careful when writing such code!
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 每当对`ActivityManagerService`类进行更改时，请确保不要引入使服务容易受到攻击或泄露敏感数据给恶意应用程序的代码路径。始终遵循安全编码原则，并通过权限检查保护您的方法。如果不希望第三方开发人员访问您的功能，请为该方法分配签名权限。敏锐的读者会注意到`ActivityManagerService`类与任何其他系统服务一样，并在`SystemServer`服务的上下文中执行。因此，现在您意识到您的自定义系统服务与如此重要的服务一起执行。您的系统服务中的任何错误都有可能导致整个框架崩溃。因此，在编写此类代码时要小心！
- en: Adding a custom method to the Activity Manager service (Should know)
  id: totrans-606
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向Activity Manager服务添加自定义方法（应该知道）
- en: In this example, we will guide you through the steps needed to introduce a custom
    permission and learn how to make use of it to protect a method we add to the Activity
    Manager service.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将指导您完成引入自定义权限所需的步骤，并学习如何利用它来保护我们向Activity Manager服务添加的方法。
- en: Getting ready
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We will edit the following files:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑以下文件：
- en: '| Filename | Location |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 位置 |'
- en: '| --- | --- |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ActivityManagerService.java` | `ANDROID_SRC/frameworks/base/services/java/com/android/server/am`
    |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityManagerService.java` | `ANDROID_SRC/frameworks/base/services/java/com/android/server/am`
    |'
- en: '| `ActivityManagerNative.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityManagerNative.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
- en: '| `ActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| `ActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
- en: '| `IActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| `IActivityManager.java` | `ANDROID_SRC/frameworks/base/core/java/android/app`
    |'
- en: '| `AndroidManifest.xml` | `ANDROID_SRC/frameworks/base/core/res` |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| `AndroidManifest.xml` | `ANDROID_SRC/frameworks/base/core/res` |'
- en: '| `strings.xml` | `ANDROID_SRC/frameworks/base/core/res/res/values` |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| `strings.xml` | `ANDROID_SRC/frameworks/base/core/res/res/values` |'
- en: How to do it...
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We begin by adding a new transaction and method prototype to `IActivityManager.java`.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先要做的是向`IActivityManager.java`添加一个新的事务和方法原型。
- en: 'The following code is appended to `IActivityManager.java`:'
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码附加到`IActivityManager.java`：
- en: '[PRE100]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The number 118 is just 1 plus the last transaction number I have on my version
    of the source code. The ones you may see may differ. Use whatever number you see
    in your version and add one to it.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 数字118只是我在源代码版本中拥有的最后一个事务号加1。您可能看到的数字可能不同。使用您版本中看到的任何数字并加1。
- en: 'The preceding lines basically set a transaction number for our method. Since
    the underlying binder driver uses these numbers to match which methods need to
    be performed when an IPC call is made, we set our method''s transaction number
    to be one plus the last transaction known. Depending on the source code version
    you are working with, the number written above may have to be increased. The logic
    is simply adding 1 to the last transaction number you see. The IPC method needs
    to throw a `RemoteException` since this is mandated by the Binder IPC protocol.
    We then create the public interface for this method. To do this, add the following
    lines to `ActivityManager.java`, towards the end of the file:'
  id: totrans-623
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述行基本上为我们的方法设置了一个事务号。由于底层的 binder 驱动程序使用这些数字来匹配在进行 IPC 调用时需要执行哪些方法，我们将我们方法的事务号设置为上一个已知事务号加一。根据您正在使用的源代码版本，上面写的数字可能需要增加。逻辑很简单，就是在您看到的上一个事务号上加
    1。IPC 方法需要抛出`RemoteException`，因为这是 Binder IPC 协议规定的。然后我们为这个方法创建公共接口。为此，请在`ActivityManager.java`文件的末尾添加以下行：
- en: '[PRE101]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: This is a very simple method that does nothing useful. The aim of this recipe
    is to help you understand the mechanics of adding a new method to the Activity
    Manager service.
  id: totrans-625
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个非常简单的方法，没有任何实际用途。这个配方的目的是帮助您理解向 Activity Manager 服务添加新方法的机制。
- en: Next, we will implement the marshalling code for this method. The concept of
    marshalling is no different than other interprocess frameworks. The basic aim
    is to serialize complex structures.
  id: totrans-626
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为这个方法实现编组代码。编组的概念与其他进程间框架没有什么不同。基本目的是序列化复杂结构。
- en: Inside `ActivityManagerNative.java`, we make two changes. The first is inside
    the `ActivityManagerProxy` class that is inside the file. The code is organized
    in a way such that the `ActivityManagerProxy` class is towards the end of the
    file. Therefore, we write our proxy implementation of `packtSensitiveMethod` towards
    the end of the `ActivityManagerNative.java` file inside the scope of the `ActivityManagerProxy`
    class.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ActivityManagerNative.java`中，我们进行了两个更改。第一个是在文件中的`ActivityManagerProxy`类内部。代码组织得很好，`ActivityManagerProxy`类位于文件的末尾。因此，我们在`ActivityManagerNative.java`文件的末尾，在`ActivityManagerProxy`类的范围内，编写我们的`packtSensitiveMethod`的代理实现。
- en: 'The following code is added to `ActivityManagerNative.java` towards the end.
    It is the `packtSensitiveMethod` proxy implementation:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加到`ActivityManagerNative.java`文件的末尾。这是`packtSensitiveMethod`代理实现：
- en: '[PRE102]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The second change is made in the `onTransact` method of the file. At the last
    `case` statement, we add our `case` code:'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个更改是在文件的`onTransact`方法中进行的。在最后的`case`语句中，我们添加我们的`case`代码：
- en: '[PRE103]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Finally, we have to implement this method. The following implementation is
    written inside `ActivityManagerService.java`:'
  id: totrans-632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须实现这个方法。以下实现写在`ActivityManagerService.java`文件中：
- en: '[PRE104]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Note
  id: totrans-634
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We have written the check permission code to secure this method. In the next
    recipe, I will guide you through the process of introducing a custom permission
    into the framework.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了检查权限代码来保护这个方法。在下一个配方中，我将指导您介绍如何将自定义权限引入框架。
- en: How it works...
  id: totrans-636
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In Android, the `ActivityManagerService` class executes within the context of
    the system server process. Hence, calls into it will be remote calls. Therefore,
    we have to make use of the Binder IPC mechanism. The `IActivityManager.java` file
    contains the set of remote calls exposed by the Activity Manager service. Hence,
    we add a new interface method `packtSensitiveMethod()` and a transaction constant
    `PACKT_TRANSACTION` that will correspond to this method.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，`ActivityManagerService`类在系统服务器进程的上下文中执行。因此，对它的调用将是远程调用。因此，我们必须利用
    Binder IPC 机制。`IActivityManager.java`文件包含了 Activity Manager 服务公开的一组远程调用。因此，我们添加一个新的接口方法`packtSensitiveMethod()`和一个事务常量`PACKT_TRANSACTION`，它将对应于这个方法。
- en: '`ActivityManager.java` represents a class library that user applications use
    to access the functionality of the Activity Manager service. This is similar to
    the custom class library we added in the earlier recipe on creating custom class
    libraries. As I''ve stated before, our implementations follow the design guidelines
    used in the Android code. Therefore, you will see several existing parallels in
    the Android source code. This is just one of the many examples that exist. Hence,
    we add a shim method to that file that invokes the real method through a remote
    procedure call.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActivityManager.java`代表用户应用程序用来访问 Activity Manager 服务功能的类库。这类似于我们在早期的创建自定义类库配方中添加的自定义类库。正如我之前所说，我们的实现遵循
    Android 代码中使用的设计准则。因此，您将在 Android 源代码中看到几个现有的类似之处。这只是众多存在的例子之一。因此，我们向该文件添加一个 shim
    方法，通过远程过程调用调用真实方法。'
- en: As stated earlier, the Activity Manager service was written before the AIDL
    compiler existed, therefore the proxies and stubs for all remote calls are implemented
    manually. Hence, we add marshalling code to `ActivityManagerNative.java`.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Activity Manager 服务是在 AIDL 编译器存在之前编写的，因此所有远程调用的代理和存根都是手动实现的。因此，我们向`ActivityManagerNative.java`添加了编组代码。
- en: You may wonder why we still add the marshalling code manually. The answer is
    that even though the AIDL compiler is now available, the build process was never
    updated for the `ActivityManagerService` class to make use of the AIDL compiler.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想为什么我们仍然手动添加编组代码。答案是，即使 AIDL 编译器现在可用，构建过程也从未更新为`ActivityManagerService`类使用
    AIDL 编译器。
- en: Adding custom permissions to the framework (Must know)
  id: totrans-641
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向框架添加自定义权限（必须知道）
- en: In this recipe, we will add a custom permission to the framework so that only
    authorized processes may access and execute our newly added method to `ActivityManagerService`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将向框架添加自定义权限，以便只有经过授权的进程才能访问和执行我们向`ActivityManagerService`添加的新方法。
- en: Getting ready
  id: totrans-643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the `AndroidManifest.xml` file from the location specified in the preceding
    table.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 从上表中指定的位置打开`AndroidManifest.xml`文件。
- en: How to do it...
  id: totrans-645
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Now we will edit the manifest to insert a new permission object. Just add these
    code lines to `AndroidManifest.xml`:'
  id: totrans-646
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编辑清单以插入新的权限对象。只需将这些代码行添加到`AndroidManifest.xml`中：
- en: '[PRE105]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-648
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that you have to use string resources to specify the various text properties
    of a permission. These values are defined in `strings.xml`.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您必须使用字符串资源来指定权限的各种文本属性。这些值在`strings.xml`中定义。
- en: 'Therefore, open up the file (location given in the preceding table) and append
    the following code to `strings.xml`:'
  id: totrans-650
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，打开文件（在前面的表中给出的位置）并将以下代码附加到`strings.xml`：
- en: '[PRE106]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'At this stage, we should ensure that everything compiles fine. First issue
    the following command as we have changed the public API by adding methods to `ActivityManager.java`:'
  id: totrans-652
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们应该确保一切都编译正常。首先发出以下命令，因为我们通过向`ActivityManager.java`添加方法已更改了公共API：
- en: '[PRE107]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Next, issue a normal `make` command.
  id: totrans-654
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，发出正常的`make`命令。
- en: How it works...
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Even the Android framework has a manifest file. This file contains permission
    definitions for all permissions that exist in the system. The `permission` tag
    requires you to specify a permission description among other parameters. The system
    uses these strings for user display. For example, the permission description parameter
    is shown to a user while installing the application which asks for the permission
    in question.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 即使Android框架也有一个清单文件。该文件包含系统中存在的所有权限的权限定义。`permission`标签要求您在其他参数中指定权限描述。系统使用这些字符串进行用户显示。例如，权限描述参数在要求用户授予权限的应用程序安装时显示给用户。
- en: Using the custom method (Should know)
  id: totrans-657
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义方法（应该知道）
- en: We need to test our newly added method. Therefore, we make use of the `PacktLibraryClient`
    application that we created in the *Writing the platform library source code*
    recipe.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要测试我们新添加的方法。因此，我们使用了在*编写平台库源代码*中创建的`PacktLibraryClient`应用程序。
- en: Getting ready
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Open up `Client.java` from the `PacktLibraryClient` application, which is located
    at `ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient/`.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 从`PacktLibraryClient`应用程序中打开`Client.java`，该文件位于`ANDROID_SRC/packages/apps/PacktLibraryClient/src/com/packtclient/`。
- en: How to do it...
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following code represents the client code that makes use of the newly added
    method and is saved in a file named `Client.java`:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码代表使用新添加的方法的客户端代码，并保存在名为`Client.java`的文件中：
- en: '[PRE108]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: I have just commented the earlier code and added a method to execute `packtSensitiveMethod`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 我刚刚评论了之前的代码，并添加了一个执行`packtSensitiveMethod`的方法。
- en: Now, run a full system make and start the emulator.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行完整的系统构建并启动模拟器。
- en: Note
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, the emulator may complain that the partition size is too small and
    it has to be resized. In this case, you can use the memory and partition size
    switches. (Note that this command will work only if you issue it in the same window
    in which Android was built. Otherwise, you will have to use the fully qualified
    paths and specify the full paths to the emulator images—kernel image, system image
    as well.)
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，模拟器可能会抱怨分区大小太小，必须调整大小。在这种情况下，您可以使用内存和分区大小开关。（请注意，此命令仅在构建Android的同一窗口中发出才有效。否则，您将不得不使用完全限定的路径并指定模拟器映像的完整路径——内核映像、系统映像等。）
- en: For example, emulator memory as 512 and partition-size as 1024.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，模拟器内存为512，分区大小为1024。
- en: 'Launch the `PacktLibraryClient` application. Observe logcat. The output will
    be similar to the following:'
  id: totrans-669
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`PacktLibraryClient`应用程序。观察logcat。输出将类似于以下内容：
- en: '[PRE109]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'What went wrong here? On analyzing the logs, we notice that a security exception
    was thrown. So, our code works! The sensitive method is protected. But, if `PacktLibraryClient`
    is a legitimate application and needs access to `packtSensitiveMethod`, we need
    to do two things:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这里出了什么问题？在分析日志时，我们注意到抛出了安全异常。所以，我们的代码有效！敏感方法受到了保护。但是，如果`PacktLibraryClient`是一个合法的应用程序，并且需要访问`packtSensitiveMethod`，我们需要做两件事：
- en: Grant it `PACKT_PERMISSION`.
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予`PACKT_PERMISSION`。
- en: Sign the APK with the platform certificate since the permission is a signature
    level permission.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用平台证书对APK进行签名，因为权限是签名级别的权限。
- en: 'To do this, edit the `AndroidManifest.xml` file of `PacktLibraryClient` by
    adding the following tag outside the `application` tag:'
  id: totrans-674
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，请编辑`PacktLibraryClient`的`AndroidManifest.xml`文件，将以下标签添加到`application`标签之外：
- en: '[PRE110]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Next, edit its `Android.mk` file by adding the following line:'
  id: totrans-676
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过添加以下行来编辑其`Android.mk`文件：
- en: '[PRE111]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now we will use a shortcut to quickly build the APK. In a terminal, navigate
    to the root of your android sources and use the following command:'
  id: totrans-678
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将使用快捷方式快速构建APK。在终端中，导航到您的android源的根目录，并使用以下命令：
- en: '[PRE112]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This will build the APK, but won''t place it into the system image or push
    it into the emulator. To do this, we will remount the system partition as read/write
    and then push it manually. If you want to place it into the system image directly
    and have it rerun the emulator, use the following command:'
  id: totrans-680
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将构建APK，但不会将其放入系统映像或推送到模拟器中。为了做到这一点，我们将重新挂载系统分区为读/写，然后手动推送它。如果你想直接将其放入系统映像并重新运行模拟器，请使用以下命令：
- en: '[PRE113]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If you closed the emulator, start it again. Then drop into a shell via `adb`.
  id: totrans-682
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果关闭了模拟器，请重新启动。然后通过`adb`进入shell。
- en: 'To find out on which block device `/system` is mounted, use:'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要找出`/system`挂载在哪个块设备上，请使用：
- en: '[PRE114]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The output looks like:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE115]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Hence, `/system` is `mtd0`.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`/system`是`mtd0`。
- en: 'To remount as read/write:'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新挂载为读/写：
- en: '[PRE116]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Now exit the `adb` shell, and push the built APK. The APK will be available
    at `ANDROID_SRC/out/target/product/generic/system/app`.
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在退出`adb` shell，并推送构建的APK。APK将可在`ANDROID_SRC/out/target/product/generic/system/app`找到。
- en: The following command will automatically reinstall the APK onto the emulator.
    Start the application again and observe the logs.
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令将自动重新安装APK到模拟器上。再次启动应用程序并观察日志。
- en: '[PRE117]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We see that everything has worked fine.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到一切都运行正常。
- en: How it works...
  id: totrans-694
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application obtains a reference to the Activity Manager service. This reference
    is in the form of an `ActivityManager` object. The `packtSensitiveMethod` shim
    is executed in the client, which cause an RPC to be sent out to the Activity Manager
    service, which performs a permission check before executing the main body of the
    method. When our APK wasn't signed with the platform key and didn't include the
    correct `<uses-permission>` tag, this check failed and the application crashed.
    In the second instance, we made the appropriate changes and the permission check
    succeeded.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序获取对活动管理器服务的引用。这个引用是以`ActivityManager`对象的形式存在的。在客户端执行`packtSensitiveMethod`
    shim，这会导致一个RPC发送到活动管理器服务，在执行方法的主体之前执行权限检查。当我们的APK没有使用平台密钥签名并且没有包含正确的`<uses-permission>`标签时，这个检查失败，应用程序崩溃了。在第二个实例中，我们进行了适当的更改，权限检查成功了。
- en: Analyzing the PackageManagerService class (Should know)
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析PackageManagerService类（应该知道）
- en: The Package Manager service is a central service in the Android system and is
    one of the most important. It manages all the packages in the system and is central
    to platform security. It maintains a mapping between user/group identifiers and
    higher-level permission strings. In this recipe, we will see how permissions are
    managed and granted by the Package Manager service. As you may know, the fundamental
    aspect of the Android Security Model is the permissions system. This system is
    managed by the `PackageManagerService` class.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器服务是Android系统中的一个核心服务，也是最重要的服务之一。它管理系统中的所有软件包，并且对平台安全至关重要。它维护用户/组标识符和更高级别权限字符串之间的映射。在这个示例中，我们将看到软件包管理器服务如何管理和授予权限。正如您所知，Android安全模型的基本方面是权限系统。这个系统由`PackageManagerService`类管理。
- en: Getting ready
  id: totrans-698
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The source code of the Package Manager service is located at `ANDROID_SRC/frameworks/base/services/java/com/android/server/`.
    Open up the file named `PackageManagerService.java` in your favorite code editor.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器服务的源代码位于`ANDROID_SRC/frameworks/base/services/java/com/android/server/`。在您喜欢的代码编辑器中打开名为`PackageManagerService.java`的文件。
- en: How to do it...
  id: totrans-700
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作方法...
- en: 'Built-in permission UID mappings are stored on the filesystem at `/system/etc/permissions/platform.xml`.
    This is loaded into the Package Manager service into the following variable:'
  id: totrans-701
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 内置权限UID映射存储在文件系统中的`/system/etc/permissions/platform.xml`。这会加载到软件包管理器服务中的以下变量：
- en: '[PRE118]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The service maintains user application permissions in the filesystem at `/data/system/packages.xml`.
    Fire up the emulator and drop into an `adb` shell. We will inspect the contents
    of the `packages.xml` file. Obtain a copy with the following command:'
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '该服务在文件系统中维护用户应用程序权限，位于`/data/system/packages.xml`。启动模拟器并进入`adb` shell。我们将检查`packages.xml`文件的内容。使用以下命令获取副本： '
- en: '[PRE119]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Open up the file in a text editor and search for the term "packt":'
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开文件并搜索术语"packt"：
- en: '[PRE120]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Here we notice that `PacktLibraryClient` has been assigned a `userId` of `10010`.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们注意到`PacktLibraryClient`被分配了`userId`为`10010`。
- en: How it works...
  id: totrans-708
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Package Manager service stores and manages all configuration data in XML
    files with proper Linux permissions on these files. Internally, the service makes
    use of XML pull parsers to read and process these files. This service is interrogated
    by other services, most notably the Activity Manager service, as to whether a
    package possesses a certain permission or not.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 软件包管理器服务以适当的Linux权限将所有配置数据存储和管理在XML文件中。在内部，该服务利用XML pull解析器来读取和处理这些文件。其他服务会询问该服务，尤其是活动管理器服务，一个软件包是否拥有某个权限。
- en: There's more...
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Whenever you make changes to this service, please rethink your design carefully
    and only if there is no other way to accomplish the task, run the unit tests.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您对此服务进行更改时，请仔细重新考虑您的设计，只有在没有其他方法可以完成任务的情况下才运行单元测试。
- en: 'To run these tests, run the following command in a terminal (as always, I assume
    you have set up a build environment by including `build/envsetup.sh`):'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些测试，在终端中运行以下命令（一如既往，我假设您已经通过包括`build/envsetup.sh`来设置了构建环境）：
- en: '[PRE121]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Then start the emulator and execute this in a terminal over ADB:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 然后启动模拟器，并在ADB上执行以下命令：
- en: '[PRE122]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Finally drop into an `adb` shell and execute:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入`adb` shell并执行：
- en: '[PRE123]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The unit tests are part of the **Compatibility Test Suite** (**CTS**). The CTS
    is part of the Android compatibility program. The aim is to achieve standardization
    among Android vendor implementations. The interested reader is referred to an
    overview of the compatibility program at [http://source.android.com/compatibility/overview.html](http://source.android.com/compatibility/overview.html).
    Details on the CTS itself may be found at [http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html).
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是**兼容性测试套件**（**CTS**）的一部分。CTS是Android兼容性计划的一部分。其目标是在Android供应商实现之间实现标准化。有兴趣的读者可以在[http://source.android.com/compatibility/overview.html](http://source.android.com/compatibility/overview.html)上找到兼容性计划概述。CTS本身的详细信息可以在[http://source.android.com/compatibility/cts-intro.html](http://source.android.com/compatibility/cts-intro.html)上找到。
- en: Analyzing the Internet infrastructure (Should know)
  id: totrans-719
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析互联网基础设施（应该知道）
- en: Processes/applications access the network (WiFi-based or GSM-based networks)
    using network sockets. Java code makes use of the Apache Harmony socket implementation
    and native code uses standard bionic sockets that are identical to libc socket
    calls. There is no Internet service. In this recipe, we will analyze how the network
    is accessed and how these accesses are guarded.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 进程/应用程序使用网络套接字访问网络（基于WiFi或基于GSM的网络）。Java代码使用Apache Harmony套接字实现，本地代码使用标准的bionic套接字，与libc套接字调用相同。在这个示例中，我们将分析如何访问网络以及如何保护这些访问。
- en: Getting ready
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will look at a kernel source file in this recipe, so locate the kernel sources
    you had downloaded and built in the first recipe of this book.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将查看一个内核源文件，所以请找到您在本书第一个示例中下载和构建的内核源代码。
- en: The code for network access in Java is implemented in the Apache Harmony library
    in `OSNetworkSystem.java` located at `ANDROID_SRC/libcore/luni/src/main/java/org/apache/harmony/luni/platform`.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的网络访问代码是在`OSNetworkSystem.java`中的Apache Harmony库中实现的，位于`ANDROID_SRC/libcore/luni/src/main/java/org/apache/harmony/luni/platform`。
- en: This is the final point before native socket calls are invoked.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在调用本机套接字调用之前的最后一点。
- en: How to do it...
  id: totrans-725
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Navigate to the kernel sources we downloaded and built in the introductory recipe
    of this book.
  id: totrans-726
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们下载并在本书介绍中构建的内核源代码。
- en: Open the file `ANDROID_SRC/kernel_code/goldfish/goldfish/net/ipv4/af_inet.c`.
  id: totrans-727
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`ANDROID_SRC/kernel_code/goldfish/goldfish/net/ipv4/af_inet.c`。
- en: 'In this file, we observe the following addition:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，我们观察到以下添加：
- en: '[PRE124]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This function makes a check as to whether the process currently executing in
    a function call is part of the `AID_INET` group or not. For example, look at the
    function named `inet_create`.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数检查当前执行函数调用的进程是否属于`AID_INET`组。例如，看看名为`inet_create`的函数。
- en: There is a call to `current_has_network()` and, if not, it returns `-EACCES`.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个对`current_has_network()`的调用，如果没有，它会返回`-EACCES`。
- en: How it works...
  id: totrans-732
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `OSNetworkSystem.java` file contains native methods that ultimately make
    use of libc socket calls to perform I/O on the network. System library calls eventually
    invoke system calls implemented in the kernel. On Android, the network calls were
    changed to only allow execution if the process currently executing the system
    call belongs to a particular group. That group is named `inet`.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '`OSNetworkSystem.java`文件包含最终使用libc套接字调用在网络上执行I/O的本机方法。系统库调用最终会调用内核中实现的系统调用。在Android上，网络调用已更改为仅允许执行，如果当前执行系统调用的进程属于特定组。该组名为`inet`。'
- en: When an application requests `android.permission.INTERNET`, and when it is about
    to be run, the Package Manager service notifies Zygote that the application is
    to be run as part of the `inet` group.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序请求`android.permission.INTERNET`时，并且即将运行时，包管理器服务会通知Zygote应用程序将作为`inet`组的一部分运行。
- en: Later on, the modified system calls verify that the process is running as a
    member of `inet` and the call succeeds.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，修改后的系统调用将验证进程是否作为`inet`的成员运行，并且调用成功。
- en: The `current_has_network()` function makes use of the function `in_egroup_p(gid_t)`
    to check the group identifier of the process executing it. An Android process
    runs as a member of this group only if it has been granted `android.permission.INTERNET`.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '`current_has_network()`函数使用`in_egroup_p(gid_t)`函数来检查执行它的进程的组标识符。只有当Android进程被授予`android.permission.INTERNET`时，它才作为该组的成员运行。'
- en: 'The system applications are installed on the system/read-only partition of
    an Android device. The applications are signed with the one of system certificates
    (There are four certificates: testkey, platform, shared, and media) and perform
    certain privileged tasks. Examples include the Contacts application and the Settings
    application. Sometimes, your design may require a change of these system applications.
    In the next recipe, we will learn the purpose of the most important system applications
    and learn how to compile changes made to them.'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 系统应用程序安装在Android设备的系统/只读分区上。这些应用程序使用系统证书之一进行签名（有四个证书：testkey，platform，shared和media），并执行某些特权任务。示例包括联系人应用程序和设置应用程序。有时，您的设计可能需要更改这些系统应用程序。在下一个教程中，我们将学习最重要的系统应用程序的目的，并学习如何编译对它们所做的更改。
- en: Learning the functions of various system applications (Must know)
  id: totrans-738
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习各种系统应用程序的功能（必须知道）
- en: The source code for all system applications are located at `ANDROID_SRC/packages/`.
    In this recipe, we will learn the significance of the most important packages
    at this location.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 所有系统应用程序的源代码位于`ANDROID_SRC/packages/`。在本教程中，我们将了解此位置上最重要的包的重要性。
- en: Getting ready
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Navigate to the `/packages` directory under `ANDROID_SRC/`.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`ANDROID_SRC/`下的`/packages`目录。
- en: How to do it...
  id: totrans-742
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The following table summarizes the four top-level directories and the code
    they contain:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了四个顶级目录及其包含的代码：
- en: '| Directory name | Purpose |'
  id: totrans-744
  prefs: []
  type: TYPE_TB
  zh: '| 目录名称 | 目的 |'
- en: '| --- | --- |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Apps` | Contains code for Activity-based applications. Always contains a
    UI element. |'
  id: totrans-746
  prefs: []
  type: TYPE_TB
  zh: '| `Apps` | 包含基于Activity的应用程序的代码。始终包含UI元素。 |'
- en: '| `Experimental` | Random tools maintained by Googlers. Contents may be archived
    without notice. |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| `Experimental` | 由谷歌员工维护的随机工具。内容可能会被归档而不另行通知。 |'
- en: '| `Inputmethods` | The sources for the three default IMEs (as per 2.3.4_r1),
    that is LatinIME, OpenWnn, and PinyinIME |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '| `Inputmethods` | 三种默认输入法的来源（根据2.3.4_r1），即LatinIME，OpenWnn和PinyinIME |'
- en: '| `Providers` | Code for all major content providers including Contacts and
    SMS/MMS |'
  id: totrans-749
  prefs: []
  type: TYPE_TB
  zh: '| `Providers` | 所有主要内容提供程序的代码，包括联系人和短信/彩信 |'
- en: '| `Wallpapers` | Code for wallpapers that ship with the open source system
    |'
  id: totrans-750
  prefs: []
  type: TYPE_TB
  zh: '| `Wallpapers` | 与开源系统一起提供的壁纸的代码 |'
- en: Now, we will learn the purpose of the most important directories under `Apps`
    and `Providers`.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解`Apps`和`Providers`下最重要的目录的目的。
- en: 'Directories under `/Apps`:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/Apps`目录下：
- en: '| Directory name | Purpose |'
  id: totrans-753
  prefs: []
  type: TYPE_TB
  zh: '| 目录名称 | 目的 |'
- en: '| --- | --- |'
  id: totrans-754
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Browser/` | The frontend of the Android browser |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '| `Browser/` | Android浏览器的前端 |'
- en: '| `Camera/` | The camera app |'
  id: totrans-756
  prefs: []
  type: TYPE_TB
  zh: '| `Camera/` | 相机应用 |'
- en: '| `Contacts/` | Frontend Contacts application |'
  id: totrans-757
  prefs: []
  type: TYPE_TB
  zh: '| `Contacts/` | 前端联系人应用程序 |'
- en: '| `Gallery/` | Application that lets you view images and videos on your SD
    card |'
  id: totrans-758
  prefs: []
  type: TYPE_TB
  zh: '| `Gallery/` | 用于查看SD卡上的图像和视频的应用程序 |'
- en: '| `Launcher2/` | The default launcher screen |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '| `Launcher2/` | 默认的启动屏幕 |'
- en: '| `Mms/` | MMS/SMS application |'
  id: totrans-760
  prefs: []
  type: TYPE_TB
  zh: '| `Mms/` | MMS/SMS应用程序 |'
- en: '| `Nfc/` | NFC control application including native library that interacts
    with NFC chip. Includes the NFC manager and Nfc service |'
  id: totrans-761
  prefs: []
  type: TYPE_TB
  zh: '| `Nfc/` | NFC控制应用程序，包括与NFC芯片交互的本机库。包括NFC管理器和Nfc服务 |'
- en: '| `Phone/` | The dialer application and call-answering UI |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '| `Phone/` | 拨号应用程序和接听电话的用户界面 |'
- en: '| `Settings/` | System settings and secure settings application |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '| `Settings/` | 系统设置和安全设置应用程序 |'
- en: 'Directories under `/Providers`:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 在`/Providers`目录下：
- en: '| Directory name | Purpose |'
  id: totrans-765
  prefs: []
  type: TYPE_TB
  zh: '| 目录名称 | 目的 |'
- en: '| --- | --- |'
  id: totrans-766
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ApplicationsProvider/` | Maintains a database of all installed applications
    |'
  id: totrans-767
  prefs: []
  type: TYPE_TB
  zh: '| `ApplicationsProvider/` | 维护所有已安装应用程序的数据库 |'
- en: '| `ContactsProvider/` | Code that maintains the Contacts datastore that is
    used by innumerable services on the device |'
  id: totrans-768
  prefs: []
  type: TYPE_TB
  zh: '| `ContactsProvider/` | 用于维护设备上无数服务使用的联系人数据存储的代码 |'
- en: '| `TelephonyProvider/` | Stores three types of data: SMS content, MMS content,
    and current network configuration |'
  id: totrans-769
  prefs: []
  type: TYPE_TB
  zh: '| `TelephonyProvider/` | 存储三种类型的数据：短信内容、彩信内容和当前网络配置 |'
- en: How it works...
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All of the above applications have a make file that is picked up by the Android
    built system during a full system build. The built APKs are packaged into `system.img`
    and during system bootup they are installed into the `/system/app` directory.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 所有上述应用程序都有一个make文件，Android构建系统在进行完整系统构建期间会捡起它。构建的APK被打包到`system.img`中，并在系统启动时安装到`/system/app`目录中。
- en: Modifying the search widget application (Should know)
  id: totrans-772
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改搜索小部件应用程序（应该知道）
- en: In this recipe, we will modify the default search text in the quick search widget.
    The aim of this recipe is to make the reader comfortable with making changes,
    compiling them, and testing those changes.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将修改快速搜索小部件中的默认搜索文本。这个示例的目的是让读者熟悉进行更改、编译和测试这些更改。
- en: Getting ready
  id: totrans-774
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The search widget's code is in the directory named `QuickSearchBox` under `ANDROID_SRC/packages/apps/`.
    Navigate to this directory and open up `ANDROID_SRC/packages/apps/QuickSearchBox/res/drawable/text_field_search_empty_google.xml`.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索小部件的代码位于名为`QuickSearchBox`的目录下`ANDROID_SRC/packages/apps/`。导航到此目录，打开`ANDROID_SRC/packages/apps/QuickSearchBox/res/drawable/text_field_search_empty_google.xml`。
- en: How to do it...
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Edit the XML layout file by replacing:'
  id: totrans-777
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过替换XML布局文件来编辑：
- en: '[PRE125]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: with
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: with
- en: '[PRE126]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Now, use a popular image editor to create an icon of your choice with dimensions
    of 97 x 40 pixels. We create a Packt logo variant for this task in GIMP. Make
    sure you save the image as a PNG type. Copy this image to three locations: `drawable-hdpi`,
    `drawable-ldpi`, and `drawable-mdpi`.'
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用流行的图像编辑器创建一个尺寸为97 x 40像素的图标。我们在GIMP中为此任务创建了一个Packt标志变体。确保将图像保存为PNG类型。将此图像复制到三个位置：`drawable-hdpi`，`drawable-ldpi`和`drawable-mdpi`。
- en: Note
  id: totrans-782
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For each screen density, an image with different parameters should be stored.
    Otherwise, you might notice problems in rendering; images may not appear to be
    clear. As we are simply demonstrating a concept here, I do not focus on creating
    differently sized images.
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每种屏幕密度，应存储具有不同参数的图像。否则，您可能会注意到渲染问题；图像可能看起来不清晰。由于我们只是在这里演示一个概念，我不专注于创建不同尺寸的图像。
- en: 'Now we will build the new `QuickSearchWidget` application. In a terminal, as
    usual, navigate to the Android source directory, include the environment setup
    and lunch the emulator target. Issue the following command:'
  id: totrans-784
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将构建新的`QuickSearchWidget`应用程序。像往常一样，在终端中，导航到Android源代码目录，包括环境设置并启动模拟器目标。发出以下命令：
- en: '[PRE127]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This will build only the search widget. After building is complete, start the
    emulator and drop to an `adb` shell. We need to remount the system partition as
    read/write, since system applications are installed on to this partition which
    is mounted read-only. To be able to write a new executable of the `QuickSearchWidget`
    application, and without rebuilding and reflashing the entire operating system,
    we will simply "push" the generated APK onto the remounted directory.
  id: totrans-786
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将仅构建搜索小部件。构建完成后，启动模拟器并切换到`adb` shell。我们需要将系统分区重新挂载为读/写，因为系统应用程序安装在只读挂载的分区上。为了能够写入新的`QuickSearchWidget`应用程序的可执行文件，而不必重新构建和重新刷写整个操作系统，我们将简单地“推送”生成的APK到重新挂载的目录上。
- en: 'We need to find out where the `/system` partition is mounted. In an `adb` shell,
    execute the following command:'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要找出`/system`分区挂载在哪里。在`adb` shell中，执行以下命令：
- en: '[PRE128]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'The output will be similar to the following:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE129]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: On a real device, this will appear differently. The MTD mounts vary based on
    the manufacturer of the device. The output seen here is on an emulator, which
    is where you should be doing initial development and debugging before trying anything
    on a real device.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在真实设备上，这将显示不同。MTD挂载根据设备制造商而异。这里看到的输出是在模拟器上，这是您在尝试任何真实设备之前应该进行初始开发和调试的地方。
- en: 'We see that `/system` exists in `mtd0`. To remount as read/write, in an `adb`
    shell:'
  id: totrans-793
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到`/system`存在于`mtd0`中。要重新挂载为读/写，在`adb` shell中：
- en: '[PRE130]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Now, exit the `adb` shell and navigate to `ANDROID_SRC/out/target/product/generic/system/app`.
    This is where the built APK is stored.
  id: totrans-795
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，退出`adb` shell并导航到`ANDROID_SRC/out/target/product/generic/system/app`。这是构建的APK存储的位置。
- en: 'In a terminal, execute the following command:'
  id: totrans-796
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，执行以下命令：
- en: '[PRE131]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'This will install the new widget. The change should be visible on the emulator:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装新的小部件。更改应该在模拟器上可见：
- en: '![How to do it...](img/9762OS_10_01.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/9762OS_10_01.jpg)'
- en: How it works...
  id: totrans-800
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `mmm` command selectively builds code. The argument to it is the path to
    the source directory containing an `Android.mk` file. The path should end with
    the name of a target that can be built. For example, if you open the `Android.mk`
    file, the target is identified by the `LOCAL_PACKAGE_NAME` tag.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmm`命令有选择地构建代码。它的参数是包含`Android.mk`文件的源目录的路径。路径应以可以构建的目标名称结尾。例如，如果打开`Android.mk`文件，目标由`LOCAL_PACKAGE_NAME`标签标识。'
- en: As we have seen in earlier recipes, the system partition is mounted as read-only
    for security reasons. To install a system application, we need to remount this.
    The remount can only be done by a root user. On the emulator, ADB runs as root
    by default.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的示例中看到的，系统分区出于安全原因被挂载为只读。要安装系统应用程序，我们需要重新挂载。重新挂载只能由root用户完成。在模拟器上，ADB默认以root身份运行。
- en: The side effect of simply pushing an APK to `/system/app` results in its installation.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅将APK推送到`/system/app`会导致其安装的副作用。
- en: The different `drawable` directories are used based on different screen densities.
    This has the same meaning as the directories used when writing SDK-based apps.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 根据不同的屏幕密度使用不同的`drawable`目录。这与编写基于SDK的应用程序时使用的目录具有相同的含义。
- en: Using the CCACHE (Should know)
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CCACHE（应该知道）
- en: The CCACHE is a compiler cache for C/C++ code. The Android framework distribution
    consists of several native libraries that live in the `/external` directory. You
    may have noticed that on a clean build, these libraries are rebuilt, even if they
    were never changed. The rebuilding of these libraries takes a lot of time. To
    save you that time, you can use the CCACHE mechanism. In this recipe, we will
    highlight certain tips and tricks that make the life of an Android systems developer
    easier. In particular, we will explain how to use the CCACHE mechanism, how to
    selectively compile modules, and how to test them.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: CCACHE是用于C/C++代码的编译器缓存。Android框架分发包括几个位于`/external`目录中的本机库。您可能已经注意到，在干净的构建中，即使它们从未更改过，这些库也会被重新构建。重新构建这些库需要很长时间。为了节省您的时间，您可以使用CCACHE机制。在这个教程中，我们将介绍一些使Android系统开发人员生活更轻松的技巧和窍门。特别是，我们将解释如何使用CCACHE机制，如何选择性地编译模块以及如何测试它们。
- en: Getting ready
  id: totrans-807
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Navigate to your Android sources root and issue the `make clean` command. We
    want to build up the cache from scratch.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到您的Android源根目录，并发出`make clean`命令。我们想要从头开始构建缓存。
- en: How to do it...
  id: totrans-809
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'In a terminal at the Android sources root, execute the following commands:'
  id: totrans-810
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android源根目录的终端中，执行以下命令：
- en: '[PRE132]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The preceding two environment variables control whether we use CCACHE, and if
    so, where the CCACHE directory is located. You are free to use any directory for
    the CCACHE.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个环境变量控制我们是否使用CCACHE，如果使用的话，CCACHE目录的位置在哪里。您可以自由地使用任何目录作为CCACHE。
- en: 'Inside `prebuilt/linux-x86`, there is the `ccache` directory that contains
    the ccache binary. Just executing the following command presents us with options
    of what this binary can do:'
  id: totrans-813
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`prebuilt/linux-x86`目录中，有一个包含ccache二进制文件的`ccache`目录。只需执行以下命令，就会呈现出这个二进制文件可以做什么的选项：
- en: '[PRE133]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'This command provides an output like:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令提供的输出如下：
- en: '[PRE134]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Therefore, we can set the maximum cache size with the help of the following
    command:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过以下命令设置最大缓存大小：
- en: '[PRE135]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This will set it to be 20 GB.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把它设置为20GB。
- en: 'Now, if you start a make for any target (choose emulator since it''s the easiest),
    we can watch how the CCACHE is being used. In another terminal, use the following
    command:'
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果您为任何目标启动make（选择模拟器，因为它最容易），我们可以观察CCACHE是如何被使用的。在另一个终端中，使用以下命令：
- en: '[PRE136]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `watch` command is used to monitor the cache status and usage.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '`watch`命令用于监视缓存状态和使用情况。'
- en: 'The helper file should be saved as `build_helper.sh`:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 助手文件应保存为`build_helper.sh`：
- en: '[PRE137]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'An example invocation for the emulator target is:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器目标的一个示例调用是：
- en: '[PRE138]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'and it outputs the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 并且它输出如下：
- en: '[PRE139]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: How it works...
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The Android build system is written in such a way that if CCACHE is activated
    by the environment variable, it will be used automatically.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: Android构建系统是这样编写的，如果CCACHE被环境变量激活，它将自动使用。
- en: The above shell script is really simple and simplifies the developer's task
    of initializing an environment for further work. The commands within the shell
    script have to be executed whenever a new terminal is opened for Android systems
    development. Hence it is easier to execute one shell script instead of several
    individual commands.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的shell脚本非常简单，简化了开发人员初始化进一步工作环境的任务。每当为Android系统开发打开新终端时，必须执行shell脚本中的命令。因此，执行一个shell脚本比执行多个单独的命令更容易。
- en: Selectively compiling modules (Should know)
  id: totrans-832
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择性编译模块（应该知道）
- en: Sometimes, you do not need to compile the entire framework for one code change.
    In such a case, you can make use of selective compilation.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您不需要为一个代码更改编译整个框架。在这种情况下，您可以利用选择性编译。
- en: Getting ready
  id: totrans-834
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As an example, we will use selective compilation to rebuild the `Phone` application
    under `ANDROID_SRC/packages/apps/Phone`.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将使用选择性编译来重新构建`ANDROID_SRC/packages/apps/Phone`下的`Phone`应用程序。
- en: How to do it...
  id: totrans-836
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Make a small change, like adding a comment to one of the source files:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个小改变，比如在一个源文件中添加一个注释：
- en: 'To rebuild, use the following:'
  id: totrans-838
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新构建，请使用以下命令：
- en: '[PRE140]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: To test your changes on a running device/emulator, simply use the system partition
    remounting technique covered earlier.
  id: totrans-840
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在运行设备/模拟器上测试您的更改，只需使用之前介绍的系统分区重新挂载技术。
- en: How it works...
  id: totrans-841
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: '`mmm` invokes the build system only on the specified argument and places the
    output at the specified location (this is inferred from the make file of the module
    being compiled).'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: '`mmm`仅在指定的参数上调用构建系统，并将输出放在指定的位置（这是从正在编译的模块的make文件中推断出来的）。'
- en: You can follow this technique for any module as long as you replace all rebuilt
    components on the device/emulator.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您在设备/模拟器上替换所有重新构建的组件，就可以为任何模块使用这种技术。
- en: Building command tricks (Should know)
  id: totrans-844
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建命令技巧（应该知道）
- en: This recipe will equip you with some of the lesser known `make` command options.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程将为您提供一些较少为人知的`make`命令选项。
- en: Getting ready
  id: totrans-846
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: All you need is a terminal window with the build environment set up.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需要一个设置好构建环境的终端窗口。
- en: How to do it...
  id: totrans-848
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'The following table lists the command options for the standard make:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了标准make的命令选项：
- en: '| Command | Purpose |'
  id: totrans-850
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 目的 |'
- en: '| --- | --- |'
  id: totrans-851
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Make sdk` | Builds the SDK |'
  id: totrans-852
  prefs: []
  type: TYPE_TB
  zh: '| `Make sdk` | 构建SDK |'
- en: '| `Make snod` | Builds system image from currently available binaries |'
  id: totrans-853
  prefs: []
  type: TYPE_TB
  zh: '| `Make snod` | 从当前可用的二进制文件构建系统映像 |'
- en: '| `Make services` | Creates the services JAR that contains all system services
    |'
  id: totrans-854
  prefs: []
  type: TYPE_TB
  zh: '| `Make services` | 创建包含所有系统服务的服务JAR |'
- en: '| `Make runtime` | Builds native code which serves as the glue between the
    Java-based Android framework and native stuff used for its functionality |'
  id: totrans-855
  prefs: []
  type: TYPE_TB
  zh: '| `Make runtime` | 构建作为Java-based Android框架和用于其功能的本机内容之间粘合剂的本机代码 |'
- en: '| `Make droid` | The default make |'
  id: totrans-856
  prefs: []
  type: TYPE_TB
  zh: '| `Make droid` | 默认make |'
- en: '| `Make modules` | Shows a list of all modules that can be built by using `make
    <MODULE_NAME>` |'
  id: totrans-857
  prefs: []
  type: TYPE_TB
  zh: '| `Make modules` | 显示可以使用`make <MODULE_NAME>`构建的所有模块的列表 |'
- en: '| `Make clean` | Completely clears all compiled files |'
  id: totrans-858
  prefs: []
  type: TYPE_TB
  zh: '| `Make clean` | 完全清除所有已编译文件 |'
- en: '| `Make clobber` | Same as `rm -rf out/` |'
  id: totrans-859
  prefs: []
  type: TYPE_TB
  zh: '| `Make clobber` | 与`rm -rf out/`相同 |'
- en: '| `Make clean-<LOCAL_MODULE>` | Only cleans up any built files for `LOCAL_MODULE`
    |'
  id: totrans-860
  prefs: []
  type: TYPE_TB
  zh: '| `Make clean-<LOCAL_MODULE>` | 仅清理`LOCAL_MODULE`的任何已构建文件 |'
- en: How it works...
  id: totrans-861
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'These commands can be regularly used for several tasks during development.
    As an example, suppose I want to rebuild the Android framework and push it to
    the emulator, I can use the following sequence of commands written as a shell
    script:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令可以定期用于开发过程中的多个任务。例如，假设我想重新构建Android框架并将其推送到模拟器，我可以使用以下命令序列，编写为一个shell脚本：
- en: 'You can save this build file as `mk_frmwrk.sh`:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将此构建文件保存为`mk_frmwrk.sh`：
- en: '[PRE141]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: This will recompile the framework code, recompile the resources, rebuild `system.img`
    and sync it to the currently connected device.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 这将重新编译框架代码，重新编译资源，重建`system.img`并将其同步到当前连接的设备。
