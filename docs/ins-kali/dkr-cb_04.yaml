- en: Chapter 4. Network and Data Management for Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。容器的网络和数据管理
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Accessing containers from outside
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部访问容器
- en: Managing data in containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理容器中的数据
- en: Linking two or more containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接两个或多个容器
- en: Developing a LAMP application by linking containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过链接容器开发LAMP应用程序
- en: Networking of multihost container with Flannel
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flannel进行多主机容器的网络
- en: Assigning IPv6 addresses to containers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为容器分配IPv6地址
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Until now, we have worked with a single container and accessed it locally. But
    as we move to more real world use cases, we will need to access the container
    from the outside world, share external storage within the container, communicate
    with containers running on other hosts, and so on. In this chapter, we'll see
    how to fulfill some of those requirements. Let's start by understanding Docker's
    default networking setup and then go to advanced use cases.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用单个容器并在本地访问它。但是随着我们转向更多的真实用例，我们将需要从外部世界访问容器，在容器内共享外部存储，与在其他主机上运行的容器通信等。在本章中，我们将看到如何满足其中一些要求。让我们首先了解Docker的默认网络设置，然后转向高级用例。
- en: 'When the Docker daemon starts, it creates a virtual Ethernet bridge with the
    name `docker0`. For example, we will see the following with the `ip addr` command
    on the system that runs the Docker daemon:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker守护程序启动时，它会创建一个名为`docker0`的虚拟以太网桥。例如，我们将在运行Docker守护程序的系统上使用`ip addr`命令看到以下内容：
- en: '![Introduction](../Images/image00314.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00314.jpeg)'
- en: As we can see, `docker0` has the IP address 172.17.42.1/16\. Docker randomly
    chooses an address and subnet from a private range defined in RFC 1918 ([https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918)).
    Using this bridged interface, containers can communicate with each other and with
    the host system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`docker0`的IP地址为172.17.42.1/16。Docker随机选择一个地址和子网，来自RFC 1918（[https://tools.ietf.org/html/rfc1918](https://tools.ietf.org/html/rfc1918)）中定义的私有范围。使用这个桥接接口，容器可以彼此通信，也可以与主机系统通信。
- en: 'By default, every time Docker starts a container, it creates a pair of virtual
    interfaces, one end of which is attached to the host system and other end to the
    created container. Let''s start a container and see what happens:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每次Docker启动一个容器，它都会创建一对虚拟接口，其中一端连接到主机系统，另一端连接到创建的容器。让我们启动一个容器，看看会发生什么：
- en: '![Introduction](../Images/image00315.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00315.jpeg)'
- en: 'The end that is attached to the `eth0` interface of the container gets the
    172.17.0.1/16 IP address. We also see the following entry for the other end of
    the interface on the host system:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到容器的`eth0`接口的一端获得了172.17.0.1/16的IP地址。我们还在主机系统上的接口的另一端看到了以下条目：
- en: '![Introduction](../Images/image00316.jpeg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00316.jpeg)'
- en: 'Now, let''s create a few more containers and look at the `docker0` bridge with
    the `brctl` command, which manages Ethernet bridges:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建更多的容器，并使用管理以太网桥的`brctl`命令查看`docker0`桥接：
- en: '![Introduction](../Images/image00317.jpeg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00317.jpeg)'
- en: 'Every veth* binds to the `docker0` bridge, which creates a virtual subnet shared
    between the host and every Docker container. Apart from setting up the `docker0`
    bridge, Docker creates IPtables NAT rules, such that all containers can talk to
    the external world by default but not the other way around. Let''s look at the
    NAT rules on the Docker host:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个veth*都绑定到`docker0`桥接，这样就在主机和每个Docker容器之间创建了一个虚拟子网。除了设置`docker0`桥接之外，Docker还创建了IPtables
    NAT规则，以便所有容器默认可以与外部世界通信，但反之则不行。让我们看看Docker主机上的NAT规则：
- en: '![Introduction](../Images/image00318.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00318.jpeg)'
- en: 'If we try to connect to the external world from a container, we will have to
    go through the Docker bridge that was created by default:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从容器连接到外部世界，我们将不得不通过默认创建的Docker桥：
- en: '![Introduction](../Images/image00319.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00319.jpeg)'
- en: Later in this chapter, we will see how the external world can connect to a container.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将看到外部世界如何连接到容器。
- en: 'When starting a container, we have a few modes to select its networking:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动容器时，我们有几种模式可以选择其网络：
- en: '`--net=bridge`: This is the default mode that we just saw. So, the preceding
    command that we used to start the container can be written as follows:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net=bridge`：这是我们刚刚看到的默认模式。因此，我们用来启动容器的前面的命令可以写成如下形式：'
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`--net=host`: With this option, Docker does not create a network namespace
    for the container; instead, the container will network stack with the host. So,
    we can start the container with this option as follows:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net=host`：使用此选项，Docker不会为容器创建网络命名空间；相反，容器将与主机进行网络堆栈。因此，我们可以使用以下选项启动容器：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can then run the `ip addr` command within the container as seen here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在容器内运行`ip addr`命令，如下所示：
- en: '![Introduction](../Images/image00320.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00320.jpeg)'
- en: We can see all the network devices attached to the host. An example of using
    such a configuration is to run the `nginx` reverse proxy within a container to
    serve the web applications running on the host.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到所有连接到主机的网络设备。使用这种配置的一个例子是在容器中运行`nginx`反向代理，以提供在主机上运行的Web应用程序。
- en: '`--net=container:NAME_or_ID`: With this option, Docker does not create a new
    network namespace while starting the container but shares it from another container.
    Let''s start the first container and look for its IP address:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net=container:NAME_or_ID`：使用此选项，Docker在启动容器时不会创建新的网络命名空间，而是从另一个容器中共享它。让我们启动第一个容器并查找其IP地址：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Introduction](../Images/image00321.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00321.jpeg)'
- en: 'Now start another as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始另一个如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Introduction](../Images/image00322.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](../Images/image00322.jpeg)'
- en: As we can see, both containers contain the same IP address.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，两个容器包含相同的IP地址。
- en: Containers in a Kubernetes ([http://kubernetes.io/](http://kubernetes.io/))
    Pod use this trick to connect with each other. We will revisit this in [Chapter
    8](part0081.xhtml#aid-2D7TI1 "Chapter 8. Docker Orchestration and Hosting Platforms"),
    *Docker Orchestration and Hosting Platforms*.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes（[http://kubernetes.io/](http://kubernetes.io/)）Pod中的容器使用此技巧来相互连接。我们将在[第8章](part0081.xhtml#aid-2D7TI1
    "第8章。Docker编排和托管平台")中重新讨论这个问题，*Docker编排和托管平台*。
- en: '`--net=none`: With this option, Docker creates the network namespace inside
    the container but does not configure networking.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--net=none`：使用此选项，Docker在容器内创建网络命名空间，但不配置网络。'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information about the different networking we discussed in the preceding
    section, visit [https://docs.docker.com/articles/networking/#how-docker-networks-a-container](https://docs.docker.com/articles/networking/#how-docker-networks-a-container).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关我们在前面部分讨论的不同网络的更多信息，请访问[https://docs.docker.com/articles/networking/#how-docker-networks-a-container](https://docs.docker.com/articles/networking/#how-docker-networks-a-container)。
- en: From Docker 1.2 onwards, it is also possible to change `/etc/host`, `/etc/hostname`,
    and `/etc/resolv.conf` on a running container. However, note that these are just
    used to run a container. If it restarts, we will have to make the changes again.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker 1.2版本开始，还可以在运行的容器上更改`/etc/host`、`/etc/hostname`和`/etc/resolv.conf`。但是，请注意，这些只是用于运行容器。如果重新启动，我们将不得不再次进行更改。
- en: So far, we have looked at networking on a single host, but in the real world,
    we would like to connect multiple hosts and have a container from one host to
    talk to a container from another host. Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel)),
    Weave ([https://github.com/weaveworks/weave](https://github.com/weaveworks/weave)),
    Calio ([http://www.projectcalico.org/getting-started/docker/](http://www.projectcalico.org/getting-started/docker/)),
    and Socketplane ([http://socketplane.io/](http://socketplane.io/)) are some solutions
    that offer this functionality. Later in this chapter, we will see how to configure
    Flannel to multihost networking. Socketplane joined Docker Inc in March '15.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在单个主机上查看了网络，但在现实世界中，我们希望连接多个主机，并且让一个主机上的容器与另一个主机上的容器进行通信。Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel))，Weave
    ([https://github.com/weaveworks/weave](https://github.com/weaveworks/weave))，Calio
    ([http://www.projectcalico.org/getting-started/docker/](http://www.projectcalico.org/getting-started/docker/))和Socketplane
    ([http://socketplane.io/](http://socketplane.io/))是一些提供此功能的解决方案。在本章的后面，我们将看到如何配置Flannel进行多主机网络。Socketplane于'15年3月加入了Docker
    Inc。
- en: Community and Docker are building a **Container Network Model** (**CNM**) with
    libnetwork ([https://github.com/docker/libnetwork](https://github.com/docker/libnetwork)),
    which provides a native Go implementation to connect containers. More information
    on this development can be found at [http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/](http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 社区和Docker正在构建一个**容器网络模型**（**CNM**）与libnetwork ([https://github.com/docker/libnetwork](https://github.com/docker/libnetwork))，它提供了一个原生的Go实现来连接容器。有关此开发的更多信息，请访问[http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/](http://blog.docker.com/2015/04/docker-networking-takes-a-step-in-the-right-direction-2/)。
- en: Accessing containers from outside
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部访问容器
- en: Once the container is up, we would like to access it from outside. If you have
    started the container with the `--net=host` option, then it can be accessed through
    the Docker host IP. With `--net=none`, you can attach the network interface from
    the public end or through other complex settings. Let's see what happens in by
    default—where packets are forwarded from the host network interface to the container.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦容器启动，我们希望从外部访问它。如果您使用`--net=host`选项启动容器，则可以通过Docker主机IP访问它。使用`--net=none`，您可以通过公共端口或其他复杂的设置附加网络接口。让我们看看默认情况下会发生什么——从主机网络接口转发数据包到容器。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker守护程序在主机上运行，并且您可以通过Docker客户端进行连接。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s start a container with the `-P` option:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`-P`选项启动一个容器：
- en: '[PRE4]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![How to do it…](../Images/image00323.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00323.jpeg)'
- en: This automatically maps any network port of the container to a random high port
    of the Docker host between 49000 to 49900.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这会自动将容器的任何网络端口映射到Docker主机的49000到49900之间的随机高端口。
- en: 'In the `PORTS` section, we see `0.0.0.0:49159->80/tcp`, which is of the following
    form:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在`PORTS`部分，我们看到`0.0.0.0:49159->80/tcp`，格式如下：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So, in case any request comes on port `49159` from any interface on the Docker
    host, the request will be forwarded to port `80` of the `centos1` container.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果来自Docker主机上任何接口的端口`49159`的任何请求，请求将被转发到`centos1`容器的端口`80`。
- en: 'We can also map a specific port of the container to the specific port of the
    host using the `-p` option:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`-p`选项将容器的特定端口映射到主机的特定端口：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How to do it…](../Images/image00324.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00324.jpeg)'
- en: In this case, all requests coming on port `5000` from any interface on the Docker
    host will be forwarded to port `22` of the `centos2` container.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，来自Docker主机上任何接口的端口`5000`的所有请求都将被转发到`centos2`容器的端口`22`。
- en: How it works…
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: 'With the default configuration, Docker sets up the firewall rule to forward
    the connection from the host to the container and enables IP forwarding on the
    Docker host:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置，Docker设置防火墙规则，将连接从主机转发到容器，并在Docker主机上启用IP转发：
- en: '![How it works…](../Images/image00325.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理…](../Images/image00325.jpeg)'
- en: As we can see from the preceding example, a `DNAT` rule has been set up to forward
    all traffic on port `5000` of the host to port `22` of the container.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的例子所示，已经设置了一个`DNAT`规则，将主机上端口`5000`的所有流量转发到容器的端口`22`。
- en: There's more…
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'By default, with the `-p` option, Docker will forward all the requests coming
    to any interface to the host. To bind to a specific interface, we can specify
    something like the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`-p`选项，Docker将所有请求转发到主机的任何接口。要绑定到特定接口，可以指定如下内容：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this case, only requests coming to port `5000` on the interface that has
    the IP `192.168.1.10` on the Docker host will be forwarded to port `22` of the
    `f20` container. To map port `22` of the container to the dynamic port of the
    host, we can run following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有来自Docker主机上IP为`192.168.1.10`的接口的端口`5000`的所有请求都将被转发到`f20`容器的端口`22`。要将容器的端口`22`映射到主机的动态端口，可以运行以下命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can bind multiple ports on containers to ports on hosts as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将容器上的多个端口绑定到主机上的端口，如下所示：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can look up the public-facing port that is mapped to the container''s port
    as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查找映射到容器端口的公共端口，如下所示：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To look at all the network settings of a container, we can run the following
    command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看容器的所有网络设置，可以运行以下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Networking documentation on the Docker website at [https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的网络文档：[https://docs.docker.com/articles/networking/](https://docs.docker.com/articles/networking/)。
- en: Managing data in containers
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中管理数据
- en: 'Any uncommitted data or changes in containers get lost as soon as containers
    are deleted. For example, if you have configured the Docker registry in a container
    and pushed some images, as soon as the registry container is deleted, all of those
    images will get lost if you have not committed them. Even if you commit, it is
    not the best practice. We should try to keep containers as light as possible.
    The following are two primary ways to manage data with Docker:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器被删除时，任何未提交的数据或容器中的更改都会丢失。例如，如果您在容器中配置了Docker注册表并推送了一些镜像，那么一旦注册表容器被删除，所有这些镜像都会丢失，如果您没有提交它们。即使您提交了，也不是最佳做法。我们应该尽量保持容器的轻量化。以下是两种主要的管理Docker数据的方法：
- en: '**Data volumes**: From the Docker documentation ([https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/)),
    a data volume is a specially-designated directory within one or more containers
    that bypasses the Union filesystem to provide several useful features for persistent
    or shared data:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据卷**：来自Docker文档([https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/))，数据卷是一个专门指定的目录，位于一个或多个容器中，绕过联合文件系统，提供了几个有用的特性，用于持久或共享数据：'
- en: Volumes are initialized when a container is created. If the container's base
    image contains data at the specified mount point, that data is copied into the
    new volume.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建容器时初始化卷。如果容器的基本镜像包含指定挂载点的数据，则该数据将被复制到新卷中。
- en: Data volumes can be shared and reused between containers.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷可以在容器之间共享和重复使用。
- en: Changes to a data volume are made directly.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据卷的更改是直接进行的。
- en: Changes to a data volume will not be included when you update an image.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据卷的更改不会在更新镜像时包含在内。
- en: Volumes persist until no containers use them.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据卷会持久存在，直到没有容器在使用它们。
- en: '**Data volume containers**: As a volume persists until no container uses it,
    we can use the volume to share persistent data between containers. So, we can
    create a named volume container and mount the data to another container.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据卷容器**：由于卷会持久存在，直到没有容器在使用它，我们可以使用卷在容器之间共享持久数据。因此，我们可以创建一个命名的数据卷容器，并将数据挂载到另一个容器中。'
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that the Docker daemon is running on the host and you can connect
    through the Docker client.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker守护程序在主机上运行，并且可以通过Docker客户端进行连接。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Add a data volume. With the `-v` option with the `docker run` command, we add
    a data volume to the container:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加数据卷。使用`docker run`命令的`-v`选项，我们向容器添加数据卷：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can have multiple data volumes within a container, which can be created
    by adding `-v` multiple times:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在容器中拥有多个数据卷，可以通过多次添加`-v`来创建：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The `VOLUME` instruction can be used in a Dockerfile to add data volume as well
    by adding something similar to `VOLUME ["/data"]`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`VOLUME`指令可以在Dockerfile中使用，通过添加类似于`VOLUME ["/data"]`的内容来添加数据卷。'
- en: 'We can use the `inspect` command to look at the data volume details of a container:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`inspect`命令查看容器的数据卷详细信息：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![How to do it...](../Images/image00326.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00326.jpeg)'
- en: If the target directory is not there within the container, it will be created.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器中不存在目标目录，它将被创建。
- en: 'Next, we mount a host directory as a data volume. We can also map a host directory
    to a data volume with the `-v` option:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将主机目录挂载为数据卷。我们还可以使用`-v`选项将主机目录映射到数据卷：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Consider the following example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE16]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can be very useful in cases such as testing code in different environments,
    collecting logs in central locations, and so on. We can also map the host directory
    in read-only mode as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同环境中测试代码、在中央位置收集日志等情况下，这可能非常有用。我们还可以按照以下方式将主机目录映射为只读模式：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can also mount the entire root filesystem of the host within the container
    with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下命令将主机的整个根文件系统挂载到容器中：
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the directory on the host (`/srv`) does not exist, then it will be created,
    given that you have permission to create one. Also, on the Docker host where SELinux
    is enabled and if the Docker daemon is configured to use SELinux (`docker -d --selinux-enabled`),
    you will see the `permission denied` error if you try to access files on mounted
    volumes until you relabel them. To relabel them, use either of the following commands:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果主机上的目录（`/srv`）不存在，则将创建它，前提是您有权限创建。此外，在启用SELinux的Docker主机上，如果Docker守护程序配置为使用SELinux（`docker
    -d --selinux-enabled`），则在尝试访问挂载卷上的文件之前，如果您尝试访问挂载卷上的文件，您将看到`permission denied`错误。要重新标记它们，请使用以下命令之一：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Please visit [Chapter 9](part0092.xhtml#aid-2NNJO2 "Chapter 9. Docker Security"),
    *Docker Security*, for more detail.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请访问[第9章](part0092.xhtml#aid-2NNJO2 "第9章。Docker安全性")，*Docker安全性*，以获取更多详细信息。
- en: 'Now, create a data volume container. While sharing the host directory to a
    container through volume, we are binding the container to a given host, which
    is not good. Also, the storage in this case is not controlled by Docker. So, in
    cases when we want data to be persisted even if we update the containers, we can
    get help from data volume containers. Data volume containers are used to create
    a volume and nothing else; they do not even run. As the created volume is attached
    to a container (not running), it cannot be deleted. For example, here''s a named
    data container:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个数据卷容器。通过卷共享主机目录到容器时，我们将容器绑定到给定的主机，这是不好的。此外，在这种情况下，存储不受Docker控制。因此，在我们希望数据持久化即使更新容器时，我们可以从数据卷容器获得帮助。数据卷容器用于创建卷，仅此而已；它们甚至不运行。由于创建的卷附加到容器（未运行），因此无法删除。例如，这是一个命名的数据容器：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will just create a volume that will be mapped to a directory managed by
    Docker. Now, other containers can mount the volume from the data container using
    the `--volumes-from` option as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这将只创建一个将映射到Docker管理的目录的卷。现在，其他容器可以使用`--volumes-from`选项从数据容器中挂载卷，如下所示：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We can mount a volume from the data volume container to multiple containers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从数据卷容器挂载卷到多个容器：
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![How to do it...](../Images/image00327.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00327.jpeg)'
- en: We can also use `--volumes-from` multiple times to get the data volumes from
    multiple containers. We can also create a chain by mounting volumes from the container
    that mounts from some other container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以多次使用`--volumes-from`来从多个容器获取数据卷。我们还可以通过从某个其他容器挂载卷的容器来创建链。
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In case of data volume, when the host directory is not shared, Docker creates
    a directory within `/var/lib/docker/` and then shares it with other containers.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据卷的情况下，当主机目录未共享时，Docker在`/var/lib/docker/`中创建一个目录，然后与其他容器共享。
- en: There's more…
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Volumes are deleted with `-v` flag to `docker rm`, only if no other container
    is using it. If some other container is using the volume, then the container will
    be removed (with `docker rm`) but the volume will not be removed.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-v`标志删除卷以`docker rm`，只有当没有其他容器在使用它时。如果其他容器正在使用卷，则容器将被删除（使用`docker rm`），但卷将不会被删除。
- en: 'In the previous chapter, we saw how to configure the Docker registry, which
    by default starts with the `dev` flavor. In this registry, uploaded images were
    saved in the `/tmp/registry` folder within the container we started. We can mount
    a directory from the host at `/tmp/registry` within the registry container, so
    whenever we upload an image, it will be saved on the host that is running the
    Docker registry. So, to start the container, we run following command:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在上一章中，我们看到了如何配置Docker注册表，默认情况下以`dev` flavor启动。在此注册表中，上传的图像保存在我们启动的容器中的`/tmp/registry`文件夹中。我们可以在注册表容器中挂载主机上的`/tmp/registry`目录，因此每当我们上传图像时，它将保存在运行Docker注册表的主机上。因此，要启动容器，我们运行以下命令：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To push an image, we run the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送图像，我们运行以下命令：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After the image is successfully pushed, we can look at the content of the directory
    that we mounted within the Docker registry. In our case, we should see a directory
    structure as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 成功推送图像后，我们可以查看我们在Docker注册表中挂载的目录的内容。在我们的情况下，我们应该看到以下目录结构：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The documentation on the Docker website at [https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker网站上的文档位于[https://docs.docker.com/userguide/dockervolumes/](https://docs.docker.com/userguide/dockervolumes/)
- en: '[http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/](http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/](http://container42.com/2013/12/16/persistent-volumes-with-docker-container-as-volume-pattern/)'
- en: '[http://container42.com/2014/11/03/docker-indepth-volumes/](http://container42.com/2014/11/03/docker-indepth-volumes/)'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://container42.com/2014/11/03/docker-indepth-volumes/](http://container42.com/2014/11/03/docker-indepth-volumes/)'
- en: Linking two or more containers
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接两个或更多个容器
- en: With containerization, we would like to create our stack by running services
    on different containers and then linking them together. In the previous chapter,
    we created a WordPress container by putting both a web server and database in
    the same container. However, we can also put them in different containers and
    link them together. Container linking creates a parent-child relationship between
    them, in which the parent can see selected information of its children. Linking
    relies on the naming of containers.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过容器化，我们希望通过在不同的容器上运行服务，然后将它们链接在一起来创建我们的堆栈。在上一章中，我们通过将Web服务器和数据库放在同一个容器中来创建了一个WordPress容器。但是，我们也可以将它们放在不同的容器中并将它们链接在一起。容器链接在它们之间创建了一个父子关系，其中父容器可以看到其子容器的选定信息。链接依赖于容器的命名。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the Docker daemon is running on the host and you can connect through
    the Docker client.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker守护程序在主机上运行，并且您可以通过Docker客户端进行连接。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a named container called `centos_server`:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`centos_server`的命名容器：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to do it…](../Images/image00328.jpeg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '[如何操作…](../Images/image00328.jpeg)'
- en: 'Now, let''s start another container with the `name` client and link it with
    the `centos_server` container using the `--link` option, which takes the `name:alias`
    argument. Then look at the `/etc/hosts` file:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用`--link`选项启动另一个名为client的容器，并将其与`centos_server`容器进行链接，该选项接受`name:alias`参数。然后查看`/etc/hosts`文件：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![How to do it…](../Images/image00329.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '[如何操作…](../Images/image00329.jpeg)'
- en: How it works…
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In the preceding example, we linked the `centos_server` container to the client
    container with an alias server. By linking the two containers, an entry of the
    first container, which is `centos_server` in this case, is added to the `/etc/hosts`
    file in the client container. Also, an environment variable called `SERVER_NAME`
    is set within the client to refer to the server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们使用别名server将`centos_server`容器链接到客户端容器。通过链接这两个容器，第一个容器（在本例中为`centos_server`）的条目将被添加到客户端容器的`/etc/hosts`文件中。此外，在客户端中设置了一个名为`SERVER_NAME`的环境变量来引用服务器。
- en: '![How it works…](../Images/image00330.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '[工作原理…](../Images/image00330.jpeg)'
- en: There's more…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'Now, let''s create a `mysql` container:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`mysql`容器：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, let''s link it from a client and check the environment variables:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们从客户端链接它并检查环境变量：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![There''s more…](../Images/image00331.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '[还有更多…](../Images/image00331.jpeg)'
- en: 'Also, let''s look at the `docker ps` output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还让我们看一下`docker ps`的输出：
- en: '![There''s more…](../Images/image00332.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '[还有更多…](../Images/image00332.jpeg)'
- en: If you look closely, we did not specify the `-P` or `-p` options to map ports
    between two containers while starting the `client` container. Depending on the
    ports exposed by a container, Docker creates an internal secure tunnel in the
    containers that links to it. And, to do that, Docker sets environment variables
    within the linker container. In the preceding case, `mysql` is the linked container
    and client is the linker container. As the `mysql` container exposes port `3306`,
    we see corresponding environment variables (`MYSQL_SERVER_*`) within the client
    container.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细观察，我们在启动`client`容器时没有指定`-P`或`-p`选项来映射两个容器之间的端口。根据容器暴露的端口，Docker在链接到它的容器之间创建了一个内部安全隧道。为此，Docker在链接器容器内设置环境变量。在前面的情况下，`mysql`是链接的容器，client是链接器容器。由于`mysql`容器暴露端口`3306`，我们在客户端容器内看到相应的环境变量（`MYSQL_SERVER_*`）。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As linking depends on the name of the container, if you want to reuse a name,
    you must delete the old container.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 由于链接取决于容器的名称，如果要重用名称，必须删除旧容器。
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on the Docker website at [https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker网站上的文档，请访问[https://docs.docker.com/userguide/dockerlinks/](https://docs.docker.com/userguide/dockerlinks/)
- en: Developing a LAMP application by linking containers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过链接容器开发LAMP应用程序
- en: Let's extend the previous recipe by creating a LAMP application (WordPress)
    by linking the containers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过链接容器来扩展先前的食谱，创建一个LAMP应用程序（WordPress）。
- en: Getting ready
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'To pull MySQL and WordPress images from the Docker registry:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker注册表中拉取MySQL和WordPress镜像：
- en: 'For MySQL:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于MySQL：
- en: For image, visit [https://registry.hub.docker.com/_/mysql/](https://registry.hub.docker.com/_/mysql/)
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关镜像，请访问[https://registry.hub.docker.com/_/mysql/](https://registry.hub.docker.com/_/mysql/)
- en: For Dockerfile, visit [https://github.com/docker-library/docker-mysql](https://github.com/docker-library/docker-mysql)
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Dockerfile，请访问[https://github.com/docker-library/docker-mysql](https://github.com/docker-library/docker-mysql)
- en: 'For WordPress:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于WordPress：
- en: For image, visit [https://registry.hub.docker.com/_/wordpress/](https://registry.hub.docker.com/_/wordpress/)
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关镜像，请访问[https://registry.hub.docker.com/_/wordpress/](https://registry.hub.docker.com/_/wordpress/)
- en: For Dockerfile, visit [https://github.com/docker-library/wordpress](https://github.com/docker-library/wordpress)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Dockerfile，请访问[https://github.com/docker-library/wordpress](https://github.com/docker-library/wordpress)
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'First, start a `mysql` container:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，启动一个`mysql`容器：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, start the `wordpress` container and link it with the `mysql` container:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，启动`wordpress`容器并将其与`mysql`容器链接起来：
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![How to do it…](../Images/image00333.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](../Images/image00333.jpeg)'
- en: We have the Docker host's `8080` port to container `80` port, so we can connect
    WordPress by accessing the `8080` port on the Docker host with the `http://<DockerHost>:8080`
    URL.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将Docker主机的`8080`端口映射到容器的`80`端口，因此我们可以通过访问Docker主机上的`8080`端口和`http://<DockerHost>:8080`
    URL来连接WordPress。
- en: How it works…
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A link is created between the `wordpress` and `mysql` containers. Whenever the
    `wordpress` container gets a DB request, it passes it on to the `mysql` container
    and gets the results. Look at the preceding recipe for more details.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wordpress`和`mysql`容器之间创建了一个链接。每当`wordpress`容器收到一个数据库请求时，它将其传递给`mysql`容器并获取结果。查看前面的食谱以获取更多详细信息。
- en: Networking of multihost containers with Flannel
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flannel进行多主机容器的网络连接
- en: In this recipe, we'll use Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel))
    to set up multihost container networking. Flannel is a generic overlay network
    that can be used as an alternative to **Software Defined Networking** (**SDN**).
    It is an IP-based solution that uses **Virtual Extensible LAN** (**VXLAN**), in
    which unique IP addresses are assigned to each container on a unique subnet given
    to the host that is running that container. So, in this kind of a solution, a
    different subnet and communication occurs within each host in the cluster, using
    the overlay network. Flannel uses the `etcd` service ([https://github.com/coreos/etcd](https://github.com/coreos/etcd))
    for the key-value store.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用Flannel ([https://github.com/coreos/flannel](https://github.com/coreos/flannel))
    来设置多主机容器网络。Flannel是一个通用的覆盖网络，可以作为**软件定义网络**（**SDN**）的替代方案。它是一个基于IP的解决方案，使用**虚拟可扩展局域网**（**VXLAN**），为运行该容器的主机分配唯一的IP地址。因此，在这种解决方案中，每个主机在集群中使用覆盖网络内的不同子网进行通信。Flannel使用`etcd`服务
    ([https://github.com/coreos/etcd](https://github.com/coreos/etcd)) 作为键值存储。
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will require three VMs or physical machines with Fedora
    21 installed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个教程，我们将需要安装了Fedora 21的三个虚拟机或物理机。
- en: How to do it…
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: Let's call one machine/VM `master` and other two `minion1` and `minion2`. According
    to your system's IP addresses, update the `/etc/hosts` file as follows:![How to
    do it…](../Images/image00334.jpeg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们称一台机器/虚拟机为`master`，另外两台为`minion1`和`minion2`。根据您系统的IP地址，更新`/etc/hosts`文件如下：![如何做…](../Images/image00334.jpeg)
- en: 'Install `etcd`, `Flannel`, and `Docker` on all the systems we set up:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们设置的所有系统上安装`etcd`、`Flannel`和`Docker`：
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Modify the value of the `ETCD_LISTEN_CLIENT_URLS` to `http://master.example.com:4001`
    in the `/etc/etcd/etcd.conf` file as follows:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/etc/etcd/etcd.conf`文件中将`ETCD_LISTEN_CLIENT_URLS`的值修改为`http://master.example.com:4001`如下：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the master, start the `etcd` service and check its status:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在master中，启动`etcd`服务并检查其状态：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the master, create a file called `flannel-config.json` with the following
    content:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在master中，创建一个名为`flannel-config.json`的文件，内容如下：
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upload the preceding configuration file to `etcd` using `config` as the key:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`config`作为键将上述配置文件上传到`etcd`：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![How to do it…](../Images/image00335.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00335.jpeg)'
- en: In master, update `FLANNEL_OPTIONS` in the `/etc/sysconfig/flanneld` file to
    reflect the interface of the system. Also, update `FLANNEL_ETCD` to use hostname
    instead of the 127.0.0.1:4001 address.![How to do it…](../Images/image00336.jpeg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在master中，更新`/etc/sysconfig/flanneld`文件中的`FLANNEL_OPTIONS`以反映系统的接口。同时，更新`FLANNEL_ETCD`以使用主机名而不是127.0.0.1:4001地址。![如何做…](../Images/image00336.jpeg)
- en: 'To enable and start the `flanneld` service in master:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在master中，启用和启动`flanneld`服务：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '![How to do it…](../Images/image00337.jpeg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00337.jpeg)'
- en: 'From the minion systems, check the connectivity to master for `etcd`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从minion系统中，检查对`etcd`的与master的连接：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Update the `/etc/sysconfig/flanneld` file in both minions to point to the `etcd`
    server running in master and update `FLANNEL_OPTIONS` to reflect the interface
    of the minion host:![How to do it…](../Images/image00338.jpeg)
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新两个minion中的`/etc/sysconfig/flanneld`文件，指向master中运行的`etcd`服务器，并更新`FLANNEL_OPTIONS`以反映minion主机的接口：![如何做…](../Images/image00338.jpeg)
- en: 'To enable and start the `flanneld` service in both the minions:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在两个minion中启用和启动`flanneld`服务：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In any of the hosts in the cluster, run the following command:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在集群中的任何一台主机上运行以下命令：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![How to do it…](../Images/image00339.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00339.jpeg)'
- en: 'This tells us the number of hosts in the network and the subnets associated
    (look at the key for each node) with them. We can associate the subnet with the
    MAC address on the hosts. On each host, the `/run/flannel/docker` and `/run/flannel/subnet.env`
    files are populated with subnet information. For instance, in `minion2`, you would
    see something like the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们网络中主机的数量以及与它们关联的子网（查看每个节点的密钥）。我们可以将子网与主机上的MAC地址关联起来。在每个主机上，`/run/flannel/docker`和`/run/flannel/subnet.env`文件中填充了子网信息。例如，在`minion2`中，你会看到类似以下内容：
- en: '![How to do it…](../Images/image00340.jpeg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00340.jpeg)'
- en: 'To restart the Docker daemon in all the hosts:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在所有主机中重新启动Docker守护程序：
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, look at the IP address of the `docker0` and `flannel.1` interfaces. In
    `minion2`, it looks like the following:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，查看`docker0`和`flannel.1`接口的IP地址。在`minion2`中，看起来像下面这样：
- en: '![How to do it…](../Images/image00341.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](../Images/image00341.jpeg)'
- en: We can see that the `docker0` interface got the IP from the same subnet as the
    `flannel.1` interface, which is used to route all traffic.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`docker0`接口从与`flannel.1`接口相同的子网中获取了IP，该子网用于路由所有流量。
- en: We are all set to spawn two containers in any of the hosts and they should be
    able to communicate. Let's create one container in `minion1` and get its IP address:![How
    to do it…](../Images/image00342.jpeg)
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好在任何主机中生成两个容器，并且它们应该能够进行通信。让我们在`minion1`中创建一个容器并获取其IP地址：![如何做…](../Images/image00342.jpeg)
- en: Now create another container in `minion2` and ping the container running in
    `minion1` as follows:![How to do it…](../Images/image00343.jpeg)
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`minion2`中创建另一个容器，并像下面这样ping`minion1`中运行的容器：![如何做…](../Images/image00343.jpeg)
- en: How it works…
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: With Flannel, we first configure the overlay with the `10.0.0.0/16` network.
    Then, each host picks up a random `/24` network; for instance, in our case, `minion2`
    gets the `10.0.62.0/24` subnet and so on. Once configured, a container in the
    host gets the IP address from that chosen subnet. Flannel encapsulates the packets
    and sends it to remote hosts using UDP.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flannel，我们首先使用`10.0.0.0/16`网络配置覆盖。然后，每个主机选择一个随机的`/24`网络；例如，在我们的情况下，`minion2`获取`10.0.62.0/24`子网等等。配置完成后，主机中的容器将从所选的子网中获取IP地址。Flannel封装数据包并使用UDP将其发送到远程主机。
- en: Also, during installation, Flannel copies a configuration file (`flannel.conf`)
    within `/usr/lib/systemd/system/docker.service.d/`, which Docker uses to configure
    itself.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在安装过程中，Flannel会在`/usr/lib/systemd/system/docker.service.d/`中复制一个配置文件（`flannel.conf`），Docker使用该文件进行配置。
- en: See also
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The diagram from Flannel GitHub to help you understand the theory of operations
    at [https://github.com/coreos/flannel/blob/master/packet-01.png](https://github.com/coreos/flannel/blob/master/packet-01.png)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flannel GitHub上的图表可帮助您了解操作理论，网址为[https://github.com/coreos/flannel/blob/master/packet-01.png](https://github.com/coreos/flannel/blob/master/packet-01.png)
- en: The documentation on the CoreOS website at [https://coreos.com/blog/introducing-rudder/](https://coreos.com/blog/introducing-rudder/)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS网站上的文档位于[https://coreos.com/blog/introducing-rudder/](https://coreos.com/blog/introducing-rudder/)
- en: Scott Collier's blog post about setting Flannel on Fedora at [http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html](http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html)
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scott Collier在Fedora上设置Flannel的博客文章位于[http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html](http://www.colliernotes.com/2015/01/flannel-and-docker-on-fedora-getting.html)
- en: Assigning IPv6 addresses to containers
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为容器分配IPv6地址
- en: By default, Docker assigns IPv4 addresses to containers. With Docker 1.5, a
    feature has been added to support IPv6 addresses.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker为容器分配IPv4地址。Docker 1.5添加了一个功能来支持IPv6地址。
- en: Getting ready
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure the Docker daemon (version 1.5 and above) is running on the host and
    you can connect through the Docker client.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Docker守护进程（1.5版本及以上）正在主机上运行，并且您可以通过Docker客户端进行连接。
- en: How to do it…
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start the Docker daemon with the `--ipv6` option, we can add this option
    in the daemon''s configuration file (`/etc/sysconfig/docker` on Fedora) as follows:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`--ipv6`选项启动Docker守护进程，我们可以在守护进程的配置文件（在Fedora上为`/etc/sysconfig/docker`）中添加以下选项：
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, if we start Docker in daemon mode, then we can start it as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们以守护进程模式启动Docker，那么可以按以下方式启动：
- en: '[PRE43]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By running either of these commands, Docker will set up the `docker0` bridge
    with the IPv6 local link address `fe80::1`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行这些命令之一，Docker将使用IPv6本地链路地址`fe80::1`设置`docker0`桥。
- en: '![How to do it…](../Images/image00344.jpeg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](../Images/image00344.jpeg)'
- en: Let's start the container and look for the IP addresses assigned to it:![How
    to do it…](../Images/image00345.jpeg)
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们启动容器并查找分配给它的IP地址：![如何操作...](../Images/image00345.jpeg)
- en: 'As we can see, both the IPv4 and local link IPv6 addresses are available to
    the container. To ping on the IPv6 address of a container from the host machine,
    run the following command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，容器可以获得IPv4和本地链路IPv6地址。要从主机机器上ping容器的IPv6地址，请运行以下命令：
- en: '[PRE44]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To ping the `docker0` bridge from the container, run the following command:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要从容器中ping`docker0`桥，请运行以下命令：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works…
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Docker configures the `docker0` bridge to assign IPv6 addresses to containers,
    which enables us to use the IPv6 address of containers.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Docker配置`docker0`桥以向容器分配IPv6地址，这使我们能够使用容器的IPv6地址。
- en: There's more…
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多信息...
- en: 'By default, containers will get the link-local address. To assign them a globally
    routable address, you can pass the IPv6 subnet pick address with `--fixed-cidr-v6`
    as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，容器将获得链路本地地址。要为它们分配全局可路由地址，可以通过`--fixed-cidr-v6`选项传递IPv6子网选择地址，如下所示：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![There''s more…](../Images/image00346.jpeg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![更多信息...](../Images/image00346.jpeg)'
- en: From here, we can see that the globally routable address (GlobalIPv6Address)
    is now being set.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以看到全局可路由地址（GlobalIPv6Address）现在已经设置。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The Docker 1.5 release notes at [https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/](https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/).
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Docker 1.5版本的发布说明，请访问[https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/](https://blog.docker.com/2015/02/docker-1-5-ipv6-support-read-only-containers-stats-named-dockerfiles-and-more/)。
- en: The documentation on the Docker website at [http://docs.docker.com/v1.5/articles/networking/#ipv6](http://docs.docker.com/v1.5/articles/networking/#ipv6).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关Docker网站上的文档，请访问[http://docs.docker.com/v1.5/articles/networking/#ipv6](http://docs.docker.com/v1.5/articles/networking/#ipv6)。
- en: You might need to delete the exiting `docker0` bridge on the host before setting
    the IPv6 option. To understand how to do so, visit [http://docs.docker.com/v1.5/articles/networking/#customizing-docker0](http://docs.docker.com/v1.5/articles/networking/#customizing-docker0).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设置IPv6选项之前，您可能需要删除主机上现有的`docker0`桥接。要了解如何操作，请访问[http://docs.docker.com/v1.5/articles/networking/#customizing-docker0](http://docs.docker.com/v1.5/articles/networking/#customizing-docker0)。
