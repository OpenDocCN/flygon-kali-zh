- en: Configuration Management with Ansible
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible进行配置管理
- en: 'We have already covered the two most crucial phases of the Continuous Delivery
    process: the commit phase and the automated acceptance testing. In this chapter,
    we will focus on the configuration management, which connects the virtual containerized
    environment to the real server infrastructure.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了持续交付过程的两个最关键的阶段：提交阶段和自动接受测试。在本章中，我们将专注于配置管理，将虚拟容器化环境与真实服务器基础设施连接起来。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下要点：
- en: Introducing the concept of configuration management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍配置管理的概念
- en: Explaining the most popular configuration management tools
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释最流行的配置管理工具
- en: Discussing Ansible requirements and the installation process
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论Ansible的要求和安装过程
- en: Using Ansible with ad hoc commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible进行即时命令
- en: Showing the power of Ansible automation with playbooks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示Ansible自动化的强大力量与playbooks
- en: Explaining Ansible roles and Ansible Galaxy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Ansible角色和Ansible Galaxy
- en: Implementing a use case of the deployment process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施部署过程的用例
- en: Using Ansible together with Docker and Docker Compose
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ansible与Docker和Docker Compose一起
- en: Introducing configuration management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍配置管理
- en: 'Configuration management is a process of controlling configuration changes
    in a way that the system maintains integrity over time. Even though the term did
    not originate in the IT industry, currently it is broadly used to refer to the
    software and the hardware. In this context, it concerns the following aspects:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是一种控制配置更改的过程，以使系统随时间保持完整性。即使这个术语并非起源于IT行业，但目前它被广泛用来指代软件和硬件。在这个背景下，它涉及以下方面：
- en: '**Application configuration**: This involves software properties that decide
    how the system works, which are usually expressed in the form of flags or properties
    files passed to the application, for example, the database address, the maximum
    chunk size for file processing, or the logging level. They can be applied during
    different development phases: build, package, deploy, or run.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序配置**：这涉及决定系统如何工作的软件属性，通常以传递给应用程序的标志或属性文件的形式表达，例如数据库地址、文件处理的最大块大小或日志级别。它们可以在不同的开发阶段应用：构建、打包、部署或运行。'
- en: '**Infrastructure configuration**: This involves server infrastructure and environment
    configuration, which takes care of the deployment process. It defines what dependencies
    should be installed on each server and specifies the way applications are orchestrated
    (which application is run on which server and in how many instances).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施配置**：这涉及服务器基础设施和环境配置，负责部署过程。它定义了每台服务器应安装哪些依赖项，并指定了应用程序的编排方式（哪个应用程序在哪个服务器上运行以及有多少个实例）。'
- en: As an example, we can think of the calculator web service, which uses the Redis
    server. Let's look at the diagram presenting how the configuration management
    tool works.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，我们可以想象一个使用Redis服务器的计算器Web服务。让我们看一下展示配置管理工具如何工作的图表。
- en: '![](assets/886430b5-6e25-4fba-925d-5e18c53eea0d.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/886430b5-6e25-4fba-925d-5e18c53eea0d.png)'
- en: The configuration management tool reads the configuration file and prepares
    the environment respectively (installs dependent tools and libraries, deploys
    the applications to multiple instances).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理工具读取配置文件并相应地准备环境（安装依赖工具和库，将应用程序部署到多个实例）。
- en: In the preceding example, the **Infrastructure Configuration** specifies that
    the **Calculator** service should be deployed in two instances on **Server 1**
    and **Server 2** and that the **Redis** service should be installed on **Server
    3**. **Calculator Application Configuration** specifies the port and the address
    of the **Redis** server so that the services can communicate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，**基础设施配置**指定了**计算器**服务应该在**服务器1**和**服务器2**上部署两个实例，并且**Redis**服务应该安装在**服务器3**上。**计算器应用程序配置**指定了**Redis**服务器的端口和地址，以便服务之间可以通信。
- en: Configuration can differ depending on the type of the environment (QA, staging,
    production), for example, server addresses can be different.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 配置可能因环境类型（QA、staging、production）的不同而有所不同，例如，服务器地址可能不同。
- en: There are many approaches to configuration management, but before we look into
    concrete solutions, let's comment on what characteristics a good configuration
    management tool should have.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理有许多方法，但在我们研究具体解决方案之前，让我们评论一下一个好的配置管理工具应该具备的特征。
- en: Traits of good configuration management
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 良好配置管理的特点
- en: 'What should the modern configuration management solution look like? Let''s
    walk through the most important factors:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现代配置管理解决方案应该是什么样的？让我们来看看最重要的因素：
- en: '**Automation**: Each environment should be automatically reproducible, including
    the operating system, the network configuration, the software installed, and the
    applications deployed. In such an approach, fixing production issues means nothing
    more than an automatic rebuild of the environment. What''s more, that simplifies
    server replications and ensures that the staging and production environments are
    exactly the same.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：每个环境都应该自动可再现，包括操作系统、网络配置、安装的软件和部署的应用程序。在这种方法中，修复生产问题意味着自动重建环境。更重要的是，这简化了服务器复制，并确保暂存和生产环境完全相同。'
- en: '**Version control**: Every change in the configuration should be tracked, so
    that we know who made it, why, and when. Usually, that means keeping the configuration
    in the source code repository either together with the code or in a separate place.
    The former solution is recommended because configuration properties have a different
    lifecycle than the application itself. Version control also helps with fixing
    production issues—the configuration can always be rolled back to the previous
    version and the environment automatically rebuilt. The only exception to the version
    control-based solution is storing credentials and other sensitive information-these
    should be never checked in.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：配置的每个更改都应该被跟踪，这样我们就知道是谁做的，为什么，什么时候。通常，这意味着将配置保存在源代码存储库中，要么与代码一起，要么在一个单独的地方。前者的解决方案是推荐的，因为配置属性的生命周期与应用程序本身不同。版本控制还有助于修复生产问题-配置始终可以回滚到先前的版本，并自动重建环境。唯一的例外是基于版本控制的解决方案是存储凭据和其他敏感信息-这些信息永远不应该被检入。'
- en: '**Incremental changes**: Applying a change in the configuration should not
    require rebuilding the whole environment. On the contrary, a small change in the
    configuration should change only the related part of the infrastructure.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增量更改**：应用配置的更改不应该需要重建整个环境。相反，配置的小改变应该只改变基础设施的相关部分。'
- en: '**Server provisioning**: Thanks to automation, adding a new server should be
    as quick as adding its address to the configuration (and executing one command).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器配置**：通过自动化，添加新服务器应该像将其地址添加到配置（并执行一个命令）一样快。'
- en: '**Security**: The access to both, the configuration management tool and the
    machines under its control, should be well secured. When using the SSH protocol
    for communication, the access to the keys or credentials needs to be well protected.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：对配置管理工具和其控制下的机器的访问应该得到很好的保护。当使用SSH协议进行通信时，密钥或凭据的访问需要得到很好的保护。'
- en: '**Simplicity**: Every member of the team should be able to read the configuration,
    make a change, and apply it to the environment. The properties themselves should
    also be kept as simple as possible and the ones that are not subjected to change
    are better off kept hardcoded.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：团队的每个成员都应该能够阅读配置，进行更改，并将其应用到环境中。属性本身也应尽可能简单，不受更改影响的属性最好保持硬编码。'
- en: It is important to keep these points in mind while creating the configuration
    and, even before, while choosing the right configuration management tool.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建配置时以及在选择正确的配置管理工具之前，重要的是要牢记这些要点。
- en: Overview of configuration management tools
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理工具概述
- en: 'The most popular configuration management tools are Ansible, Puppet, and Chef.
    Each of them is a good choice; they are all open source products with free basic
    versions and paid enterprise editions. The most important differences between
    them are:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的配置管理工具是Ansible、Puppet和Chef。它们每个都是一个不错的选择；它们都是开源产品，有免费的基本版本和付费的企业版本。它们之间最重要的区别是：
- en: '**Configuration Language**: Chef uses Ruby, Puppet uses its own DSL (based
    on Ruby), and Ansible uses YAML.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置语言**：Chef使用Ruby，Puppet使用其自己的DSL（基于Ruby），而Ansible使用YAML。'
- en: '**Agent-based**: Puppet and Chef use agents for communication, which means
    that each managed server needs to have a special tool installed. Ansible, on the
    contrary, is agentless and uses the standard SSH protocol for communication.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于代理**：Puppet和Chef使用代理进行通信，这意味着每个受管服务器都需要安装特殊工具。相反，Ansible是无代理的，使用标准的SSH协议进行通信。'
- en: The agentless feature is a significant advantage because it implies no need
    to install anything on servers. What's more, Ansible is quickly trending upwards,
    which is why it was chosen for this book. Nevertheless, other tools can also be
    successfully used for the Continuous Delivery process.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 无代理的特性是一个重要的优势，因为它意味着不需要在服务器上安装任何东西。此外，Ansible正在迅速上升，这就是为什么选择它作为本书的原因。然而，其他工具也可以成功地用于持续交付过程。
- en: Installing Ansible
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Ansible
- en: Ansible is an open source, agentless automation engine for software provisioning,
    configuration management, and application deployment. Its first release was in
    2012 and its basic version is free for both, personal and commercial use. The
    enterprise version, called Ansible Tower, provides GUI management and dashboards,
    REST API, role-based access control, and some more features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是一个开源的、无代理的自动化引擎，用于软件供应、配置管理和应用部署。它于2012年首次发布，其基本版本对个人和商业用途都是免费的。企业版称为Ansible
    Tower，提供GUI管理和仪表板、REST API、基于角色的访问控制等更多功能。
- en: We present the installation process and a description of how it can be used
    separately as well as together with Docker.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了安装过程以及如何单独使用它以及与Docker一起使用的描述。
- en: Ansible server requirements
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible服务器要求
- en: Ansible uses the SSH protocol for communication and has no special requirements
    regarding the machine it manages. There is also no central master server, so it's
    enough to install the Ansible client tool anywhere and we can already use it to
    manage the whole infrastructure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible使用SSH协议进行通信，对其管理的机器没有特殊要求。也没有中央主服务器，因此只需在任何地方安装Ansible客户端工具，就可以用它来管理整个基础架构。
- en: The only requirement for the machines being managed is to have the Python tool
    and, obviously, the SSH server installed. These tools are, however, almost always
    available by default on any server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 被管理的机器的唯一要求是安装Python工具和SSH服务器。然而，这些工具几乎总是默认情况下在任何服务器上都可用。
- en: Ansible installation
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible安装
- en: 'The installation instructions differ depending on the operating system. In
    the case of Ubuntu, it''s enough to run the following commands:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 安装说明因操作系统而异。在Ubuntu的情况下，只需运行以下命令即可：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can find the installation guides for all operating systems on the official
    Ansible page at: [http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方Ansible页面上找到所有操作系统的安装指南：[http://docs.ansible.com/ansible/intro_installation.html](http://docs.ansible.com/ansible/intro_installation.html)。
- en: After the installation process is completed, we can execute the Ansible command
    to check that everything was installed successfully.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程完成后，我们可以执行Ansible命令来检查是否一切都安装成功。
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Docker-based Ansible client
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Docker的Ansible客户端
- en: 'It''s also possible to use Ansible as a Docker container. We can do it by running
    the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将Ansible用作Docker容器。我们可以通过运行以下命令来实现：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The Ansible Docker image is no longer officially supported, so the only solution
    is to use the community-driven version. You can read more on its usage on the
    Docker Hub page.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Docker镜像不再得到官方支持，因此唯一的解决方案是使用社区驱动的版本。您可以在Docker Hub页面上阅读更多关于其用法的信息。
- en: Using Ansible
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible
- en: In order to use Ansible, first we need to define the inventory, which represents
    the available resources. Then, we will be able to either execute a single command
    or define a set of tasks using the Ansible playbook.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Ansible，首先需要定义清单，代表可用资源。然后，我们将能够执行单个命令或使用Ansible playbook定义一组任务。
- en: Creating inventory
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建清单
- en: An inventory is a list of all the servers that are managed by Ansible. Each
    server requires nothing more than the Python interpreter and the SSH server installed.
    By default, Ansible assumes that the SSH keys are used for authentication; however,
    it is also possible to use the username and the password by adding the `--ask-pass` option
    to the Ansible commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是由Ansible管理的所有服务器的列表。每台服务器只需要安装Python解释器和SSH服务器。默认情况下，Ansible假定使用SSH密钥进行身份验证；但是，也可以通过在Ansible命令中添加`--ask-pass`选项来使用用户名和密码进行身份验证。
- en: SSH keys can be generated with the `ssh-keygen` tool and are usually stored
    in the `~/.ssh` directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SSH密钥可以使用`ssh-keygen`工具生成，并通常存储在`~/.ssh`目录中。
- en: 'The inventory is defined in the `/etc/ansible/hosts` file and it has the following
    structure:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 清单是在`/etc/ansible/hosts`文件中定义的，它具有以下结构：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The inventory syntax also accepts ranges of servers, for example, `www[01-22].company.com`.
    The SSH port should also be specified if it's anything other than 22 (the default
    one). You can read more on the official Ansible page at: [http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 清单语法还接受服务器范围，例如`www[01-22].company.com`。如果SSH端口不是默认的22端口，还应该指定。您可以在官方Ansible页面上阅读更多信息：[http://docs.ansible.com/ansible/intro_inventory.html](http://docs.ansible.com/ansible/intro_inventory.html)。
- en: There may be 0 or many groups in the inventory file. As an example, let's define
    two machines in one group of servers.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 清单文件中可能有0个或多个组。例如，让我们在一个服务器组中定义两台机器。
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can also create the configuration with server aliases and specify the remote
    user:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建带有服务器别名的配置，并指定远程用户：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding file defines a group called `webservers`, which consists of two
    servers. The Ansible client will log in as the user `admin` to both of them. When
    we have the inventory created, let's discover how we can use it to execute the
    same command on many servers.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件定义了一个名为`webservers`的组，其中包括两台服务器。Ansible客户端将作为用户`admin`登录到它们两台。当我们创建了清单后，让我们发现如何使用它来在许多服务器上执行相同的命令。
- en: Ansible offers a possibility to dynamically pull the inventory from the cloud
    provider (for example, Amazon EC2/Eucalyptus), LDAP, or Cobbler. Read more about
    dynamic inventories at: [http://docs.ansible.com/ansible/intro_dynamic_inventory.html](http://docs.ansible.com/ansible/intro_dynamic_inventory.html).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了从云提供商（例如Amazon EC2/Eucalyptus）、LDAP或Cobbler动态获取清单的可能性。在[http://docs.ansible.com/ansible/intro_dynamic_inventory.html](http://docs.ansible.com/ansible/intro_dynamic_inventory.html)了解更多关于动态清单的信息。
- en: Ad hoc commands
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时命令
- en: The simplest command we can run is a ping on all servers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行的最简单的命令是对所有服务器进行ping测试。
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We used the `-m <module_name>` option, which allows specifying the module that
    should be executed on the remote hosts. The result is successful, which means
    that the servers are reachable and the authentication is configured correctly.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`-m <module_name>`选项，允许指定应在远程主机上执行的模块。结果是成功的，这意味着服务器是可达的，并且身份验证已正确配置。
- en: 'A full list of modules available in Ansible can be found on the page: [http://docs.ansible.com/ansible/modules.htm](http://docs.ansible.com/ansible/modules.htm)l.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[http://docs.ansible.com/ansible/modules.htm](http://docs.ansible.com/ansible/modules.htm)找到Ansible可用模块的完整列表。
- en: Note that we used `all`, so that all servers would be addressed, but we could
    also call them by the group name `webservers` or by the single host alias. As
    a second example, let's execute a shell command only on one of the servers.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了`all`，以便可以处理所有服务器，但我们也可以通过组名`webservers`或单个主机别名来调用它们。作为第二个例子，让我们只在其中一个服务器上执行一个shell命令。
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `-a <arguments>` option specifies the arguments that are passed to the Ansible
    module. In this case, we didn't specify the module, so the arguments are executed
    as a shell Unix command. The result was successful and `hello` was printed.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`-a <arguments>`选项指定传递给Ansible模块的参数。在这种情况下，我们没有指定模块，因此参数将作为shell Unix命令执行。结果是成功的，并且打印了`hello`。'
- en: If the `ansible` command is connecting to the server for the first time (or
    the server is reinstalled), then we are prompted with the key confirmation message
    (SSH message when the host is not present in `known_hosts`). Since it may interrupt
    an automated script, we can disable the prompt message by uncommenting `host_key_checking
    = False` in the `/etc/ansible/ansible.cfg` file or by setting the environment
    variable `ANSIBLE_HOST_KEY_CHECKING=False`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ansible`命令第一次连接服务器（或服务器重新安装），那么我们会收到密钥确认消息（当主机不在`known_hosts`中时的SSH消息）。由于这可能会中断自动化脚本，我们可以通过取消注释`/etc/ansible/ansible.cfg`文件中的`host_key_checking
    = False`或设置环境变量`ANSIBLE_HOST_KEY_CHECKING=False`来禁用提示消息。
- en: 'In its simplistic form, the Ansible ad hoc command syntax looks as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在其简单形式中，Ansible临时命令的语法如下：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The purpose of ad hoc commands is to do something quickly when it is not necessary
    to repeat it. For example, we may want to check if a server is alive or to power
    off all the machines for the Christmas break. This mechanism can be seen as a
    command execution on a group of machines with the additional syntax simplification
    provided by the modules. The real power of Ansible automation, however, lies in
    playbooks.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 临时命令的目的是在不必重复时快速执行某些操作。例如，我们可能想要检查服务器是否存活，或者在圣诞假期关闭所有机器。这种机制可以被视为在一组机器上执行命令，并由模块提供的附加语法简化。然而，Ansible自动化的真正力量在于playbooks。
- en: Playbooks
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playbooks
- en: An Ansible playbook is a configuration file, which describes how servers should
    be configured. It provides a way to define a sequence of tasks that should be
    performed on each of the machines. A playbook is expressed in the YAML configuration
    language, which makes it human-readable and easy to understand. Let's start with
    a sample playbook and then see how we can use it.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook是一个配置文件，描述了服务器应该如何配置。它提供了一种定义一系列任务的方式，这些任务应该在每台机器上执行。Playbook使用YAML配置语言表示，这使得它易于阅读和理解。让我们从一个示例playbook开始，然后看看我们如何使用它。
- en: Defining a playbook
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个playbook
- en: 'A playbook is composed of one or many plays. Each play contains a host group
    name, tasks to perform, and configuration details (for example, remote username
    or access rights). An example playbook might look like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个playbook由一个或多个plays组成。每个play包含一个主机组名称，要执行的任务以及配置细节（例如，远程用户名或访问权限）。一个示例playbook可能如下所示：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This configuration contains one play which:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置包含一个play，其中：
- en: Is executed only on the host `web1`
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅在主机`web1`上执行
- en: Gains root access using the `sudo` command
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`sudo`命令获取root访问权限
- en: 'Executes two tasks:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行两个任务：
- en: 'Installing the latest version of `apache2`: The Ansible module `apt` (called
    with two parameters `name=apache2` and `state=latest`) checks whether the `apache2` package
    is installed on the server, and if not, then it uses the `apt-get` tool to install
    `apache2`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装最新版本的`apache2`：Ansible模块`apt`（使用两个参数`name=apache2`和`state=latest`）检查服务器上是否安装了`apache2`软件包，如果没有，则使用`apt-get`工具安装`apache2`
- en: 'Running the `apache2` service: The Ansible module `service` (called with three
    parameters `name=apache2`, `state=started`, and `enabled=yes`) checks whether
    the Unix service `apache2` is started, and if not, it uses the `service` command
    to start it'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`apache2`服务：Ansible模块`service`（使用三个参数`name=apache2`，`state=started`和`enabled=yes`）检查Unix服务`apache2`是否已启动，如果没有，则使用`service`命令启动它
- en: While addressing the hosts, you can also use patterns, for example, we could
    use `web*` to address both `web1` and `web2`. You can read more about Ansible
    patterns at: [http://docs.ansible.com/ansible/intro_patterns.html](http://docs.ansible.com/ansible/intro_patterns.html).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理主机时，您还可以使用模式，例如，我们可以使用`web*`来寻址`web1`和`web2`。您可以在[http://docs.ansible.com/ansible/intro_patterns.html](http://docs.ansible.com/ansible/intro_patterns.html)了解更多关于Ansible模式的信息。
- en: Note that each task has a human-readable name, which is used in the console
    output such that `apt` and `service` are Ansible modules and `name=apache2`, `state=latest`,
    and `state=started` are module arguments. We have already seen Ansible modules
    and arguments while using ad hoc commands. In the preceding playbook, we defined
    only one play, but there can be many of them and each can be related to different
    groups of hosts.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个任务都有一个易于阅读的名称，在控制台输出中使用，例如`apt`和`service`是Ansible模块，`name=apache2`，`state=latest`和`state=started`是模块参数。在使用临时命令时，我们已经看到了Ansible模块和参数。在前面的playbook中，我们只定义了一个play，但可以有很多play，并且每个play可以与不同的主机组相关联。
- en: 'For example, we could define two groups of servers in the inventory: `database` and
    `webservers`. Then, in the playbook, we could specify tasks that should be executed
    on all database-hosting machines and some different tasks that should be executed
    on all the web servers. By using one command, we could set up the whole environment.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在清单中定义两组服务器：`database`和`webservers`。然后，在playbook中，我们可以指定应该在所有托管数据库的机器上执行的任务，以及应该在所有web服务器上执行的一些不同的任务。通过使用一个命令，我们可以设置整个环境。
- en: Executing the playbook
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行playbook
- en: When playbook.yml is defined, we can execute it using the `ansible-playbook` command.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义了playbook.yml时，我们可以使用`ansible-playbook`命令来执行它。
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If the server requires entering the password for the `sudo` command, then we
    need to add the `--ask-sudo-pass` option to the `ansible-playbook` command. It's
    also possible to pass the `sudo` password (if required) by setting the extra variable `-e
    ansible_become_pass=<sudo_password>`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器需要输入`sudo`命令的密码，那么我们需要在`ansible-playbook`命令中添加`--ask-sudo-pass`选项。也可以通过设置额外变量`-e
    ansible_become_pass=<sudo_password>`来传递`sudo`密码（如果需要）。
- en: The playbook configuration was executed, and, therefore, the `apache2` tool
    was installed and started. Note that if the task changed something on the server,
    it is marked as `changed`. On the contrary, if there was no change, it's marked
    as `ok`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 已执行playbook配置，因此安装并启动了`apache2`工具。请注意，如果任务在服务器上做了一些改变，它会被标记为`changed`。相反，如果没有改变，它会被标记为`ok`。
- en: It is possible to run tasks in parallel using the `-f <num_of_threads>` option.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-f <num_of_threads>`选项并行运行任务。
- en: Playbook's idempotency
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playbook的幂等性
- en: We can execute the command again.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次执行命令。
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the output is slightly different. This time the command didn't change
    anything on the server. That is because each Ansible module is designed to be
    idempotent. In other words, executing the same module many times in a sequence
    should have the same effect as executing it only once.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意输出略有不同。这次命令没有在服务器上做任何改变。这是因为每个Ansible模块都设计为幂等的。换句话说，按顺序多次执行相同的模块应该与仅执行一次相同。
- en: The simplest way to achieve idempotency is to always first check if the task
    hasn't been executed yet, and execute it only if it hasn't. Idempotency is a powerful
    feature and we should always write our Ansible tasks this way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 实现幂等性的最简单方法是始终首先检查任务是否尚未执行，并且仅在尚未执行时执行它。幂等性是一个强大的特性，我们应该始终以这种方式编写我们的Ansible任务。
- en: If all tasks are idempotent, then we can execute them as many times as we want.
    In that context, we can think of the playbook as a description of the desired
    state of remote machines. Then, the `ansible-playbook` command takes care of bringing
    the machine (or group of machines) into that state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有任务都是幂等的，那么我们可以随意执行它们。在这种情况下，我们可以将playbook视为远程机器期望状态的描述。然后，`ansible-playbook`命令负责将机器（或一组机器）带入该状态。
- en: Handlers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理程序
- en: Some operations should be executed only if some other task changed. For example,
    imagine that you copy the configuration file to the remote machine and the Apache
    server should be restarted only if the configuration file has changed. How to
    approach such a case?
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 某些操作应仅在某些其他任务更改时执行。例如，假设您将配置文件复制到远程机器，并且只有在配置文件更改时才应重新启动Apache服务器。如何处理这种情况？
- en: For example, imagine that you copy the configuration file to the remote machine
    and the Apache server should be restarted only if the configuration file has changed.
    How to approach such a case?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您将配置文件复制到远程机器，并且只有在配置文件更改时才应重新启动Apache服务器。如何处理这种情况？
- en: 'Ansible provides an event-oriented mechanism to notify about the changes. In
    order to use it, we need to know two keywords:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一种基于事件的机制来通知变化。为了使用它，我们需要知道两个关键字：
- en: '`handlers`: This specifies the tasks executed when notified'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handlers`：指定通知时执行的任务'
- en: '`notify`: This specifies the handlers that should be executed'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`notify`：指定应执行的处理程序'
- en: Let's look at an example of how we could copy the configuration to the server
    and restart Apache only if the configuration has changed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子，我们如何将配置复制到服务器并且仅在配置更改时重新启动Apache。
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, we can create the `foo.conf` file and run the `ansible-playbook` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建`foo.conf`文件并运行`ansible-playbook`命令。
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Handlers are executed always at the end of the play and only once, even if triggered
    by multiple tasks.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序始终在play结束时执行，只执行一次，即使由多个任务触发。
- en: Ansible copied the file and restarted the Apache server. It's important to understand
    that if we run the command again, nothing will happen. However, if we change the
    content of the `foo.conf` file and then run the `ansible-playbook` command, the
    file will be copied again (and the Apache server will be restarted).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible复制了文件并重新启动了Apache服务器。重要的是要理解，如果我们再次运行命令，将不会发生任何事情。但是，如果我们更改`foo.conf`文件的内容，然后运行`ansible-playbook`命令，文件将再次被复制（并且Apache服务器将被重新启动）。
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We used the `copy` module, which is smart enough to detect if the file has changed,
    and then in such a case, make a change on the server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`copy`模块，它足够智能，可以检测文件是否已更改，然后在这种情况下在服务器上进行更改。
- en: There is also a publish-subscribe mechanism in Ansible. Using it means assigning
    a topic to many handlers. Then, a task notifies the topic to execute all related
    handlers. You can read more about it at: [http://docs.ansible.com/ansible/playbooks_intro.html](http://docs.ansible.com/ansible/playbooks_intro.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible中还有一个发布-订阅机制。使用它意味着将一个主题分配给许多处理程序。然后，一个任务通知主题以执行所有相关的处理程序。您可以在以下网址了解更多信息：[http://docs.ansible.com/ansible/playbooks_intro.html](http://docs.ansible.com/ansible/playbooks_intro.html)。
- en: Variables
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: While the Ansible automation makes things identical and repeatable for multiple
    hosts, it is inevitable that servers may require some differences. For example,
    think of the application port number. It can be different depending on the machine.
    Luckily, Ansible provides variables, which is a good mechanism to deal with server
    differences. Let's create a new playbook and define a variable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Ansible自动化使多个主机的事物变得相同和可重复，但不可避免地，服务器可能需要一些差异。例如，考虑应用程序端口号。它可能因机器而异。幸运的是，Ansible提供了变量，这是一个处理服务器差异的良好机制。让我们创建一个新的playbook并定义一个变量。
- en: For example, think of the application port number. It can be different depending
    on the machine. Luckily, Ansible provides variables, which is a good mechanism
    to deal with server differences. Let's create a new playbook and define a variable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑应用程序端口号。它可能因机器而异。幸运的是，Ansible提供了变量，这是一个处理服务器差异的良好机制。让我们创建一个新的playbook并定义一个变量。
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The configuration defines the `http_port` variable with the value `8080`. Now,
    we can use it using the Jinja2 syntax.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 配置定义了`http_port`变量的值为`8080`。现在，我们可以使用Jinja2语法来使用它。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Jinja2 language allows doing way more than just getting a variable. We can
    use it to create conditions, loops, and many more. You can find more details on
    the Jinja page at: [http://jinja.pocoo.org/](http://jinja.pocoo.org/).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja2语言不仅允许获取变量，还可以用它来创建条件、循环等。您可以在Jinja页面上找到更多详细信息：[http://jinja.pocoo.org/](http://jinja.pocoo.org/)。
- en: The `debug` module prints the message while executing. If we run the `ansible-playbook` command,
    we can see the variable usage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`debug`模块在执行时打印消息。如果我们运行`ansible-playbook`命令，就可以看到变量的使用情况。'
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Variables can also be defined in the inventory filing using the `[group_name:vars]` section.
    You can read more about it at: [http://docs.ansible.com/ansible/intro_inventory.html#host-variables](http://docs.ansible.com/ansible/intro_inventory.html#host-variables).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以在清单文件中的`[group_name:vars]`部分中定义。您可以在以下网址了解更多信息：[http://docs.ansible.com/ansible/intro_inventory.html#host-variables](http://docs.ansible.com/ansible/intro_inventory.html#host-variables)。
- en: Apart from user-defined variables, there are also predefined automatic variables.
    For example, the `hostvars` variable stores a map with the information regarding
    all hosts from the inventory. Using the Jinja2 syntax, we could iterate and print
    the IP addresses of all hosts in the inventory.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户定义的变量，还有预定义的自动变量。例如，`hostvars`变量存储了有关清单中所有主机信息的映射。使用Jinja2语法，我们可以迭代并打印清单中所有主机的IP地址。
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we can execute the `ansible-playbook` command.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以执行`ansible-playbook`命令。
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that with the use of the Jinja2 language, we can specify the flow control
    operations inside the Ansible playbook file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用Jinja2语言，我们可以在Ansible剧本文件中指定流程控制操作。
- en: 'An alternative to the Jinja2 templating language, for the conditionals and
    loops, is to use the Ansible built-in keywords: `when` and `with_items`. You can
    read more about it at: [http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件和循环，Jinja2模板语言的替代方案是使用Ansible内置关键字：`when`和`with_items`。您可以在以下网址了解更多信息：[http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html)。
- en: Roles
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: We can install any tool on the remote server using Ansible playbooks. Imagine
    we would like to have a server with MySQL. We could easily prepare a playbook
    similar to the one with the `apache2` package. However, if you think about it,
    a server with MySQL is quite a common case and, for sure, someone has already
    prepared a playbook for it, so maybe we could just reuse it? Here comes Ansible
    roles and Ansible Galaxy.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Ansible剧本在远程服务器上安装任何工具。想象一下，我们想要一个带有MySQL的服务器。我们可以轻松地准备一个类似于带有`apache2`包的playbook。然而，如果你想一想，带有MySQL的服务器是一个相当常见的情况，肯定有人已经为此准备了一个playbook，所以也许我们可以重用它？这就是Ansible角色和Ansible
    Galaxy的用武之地。
- en: Understanding roles
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解角色
- en: 'The Ansible role is a well-structured playbook part prepared to be included
    in the playbooks. Roles are separate units that always have the following directory
    structure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible角色是一个精心构建的剧本部分，准备包含在剧本中。角色是独立的单元，始终具有以下目录结构：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can read more about roles and what each directory means on the official
    Ansible page at: [http://docs.ansible.com/ansible/playbooks_roles.html](http://docs.ansible.com/ansible/playbooks_roles.html).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方Ansible页面上阅读有关角色及每个目录含义的更多信息：[http://docs.ansible.com/ansible/playbooks_roles.html](http://docs.ansible.com/ansible/playbooks_roles.html)。
- en: In each of the directories, we can define the `main.yml` file, which contains
    the playbook parts that can be included in the `playbook.yml` file. Continuing
    the MySQL case, there is a role defined on GitHub: [https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql).
    This repository contains kind-of task templates that can be used in our playbook.
    Let's look at a part of the `tasks/main.yml` file, which installs the `mysql` package.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个目录中，我们可以定义`main.yml`文件，其中包含可以包含在`playbook.yml`文件中的剧本部分。继续MySQL案例，GitHub上定义了一个角色：[https://github.com/geerlingguy/ansible-role-mysql](https://github.com/geerlingguy/ansible-role-mysql)。该存储库包含可以在我们的playbook中使用的任务模板。让我们看一下`tasks/main.yml`文件的一部分，它安装`mysql`包。
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is only one of the tasks defined in the `tasks/main.yml` file. Others are
    responsible for the MySQL configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是在`tasks/main.yml`文件中定义的任务之一。其他任务负责MySQL配置。
- en: The `with_items` keyword is used to create a loop over all the items. The `when` keyword
    means that the task is executed only under a certain condition.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`with_items`关键字用于在所有项目上创建循环。`when`关键字意味着任务仅在特定条件下执行。'
- en: 'If we use this role, then in order to install the MySQL on the server, it''s
    enough to create the following playbook.yml:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用这个角色，那么为了在服务器上安装MySQL，只需创建以下playbook.yml：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Such configuration installs the MySQL database to all servers using the `geerlingguy.mysql` role.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的配置使用`geerlingguy.mysql`角色将MySQL数据库安装到所有服务器上。
- en: Ansible Galaxy
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Galaxy
- en: Ansible Galaxy is to Ansible what Docker Hub is for Docker-it stores common
    roles, so that they can be reused by others. You can browse the available roles
    on the Ansible Galaxy page at: [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Galaxy是Ansible的角色库，就像Docker Hub是Docker的角色库一样，它存储常见的角色，以便其他人可以重复使用。您可以在Ansible
    Galaxy页面上浏览可用的角色：[https://galaxy.ansible.com/](https://galaxy.ansible.com/)。
- en: To install the role from Ansible Galaxy, we can use the `ansible-galaxy` command.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Ansible Galaxy安装角色，我们可以使用`ansible-galaxy`命令。
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command automatically downloads the role. In the case of the MySQL example,
    we could download the role by executing:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会自动下载角色。在MySQL示例中，我们可以通过执行以下命令下载角色：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The command downloads the `mysql` role, which can be later used in the playbook
    file.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令下载`mysql`角色，可以在playbook文件中后续使用。
- en: If you need to install a lot of roles at the same time, you can define them
    in the `requirements.yml` file and use `ansible-galaxy install -r requirements.yml`.
    Read more about that approach and about Ansible Galaxy at: [http://docs.ansible.com/ansible/galaxy.html](http://docs.ansible.com/ansible/galaxy.html).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要同时安装许多角色，可以在`requirements.yml`文件中定义它们，并使用`ansible-galaxy install -r requirements.yml`。了解更多关于这种方法和Ansible
    Galaxy的信息，请访问：[http://docs.ansible.com/ansible/galaxy.html](http://docs.ansible.com/ansible/galaxy.html)。
- en: Deployment with Ansible
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible进行部署
- en: We have covered the most fundamental features of Ansible. Let's now forget,
    just for a little while, about Docker and configure a complete deployment step
    using Ansible. We will run the calculator service on one server and the Redis
    service on the second server.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了Ansible的最基本功能。现在，让我们暂时忘记Docker，使用Ansible配置完整的部署步骤。我们将在一个服务器上运行计算器服务，而在第二个服务器上运行Redis服务。
- en: Installing Redis
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Redis
- en: 'We can specify a play in the new playbook. Let''s create the `playbook.yml` file
    with the following content:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在新的playbook中指定一个play。让我们创建`playbook.yml`文件，内容如下：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The configuration is executed on one server `web1`. It installs the `redis-server` package,
    copies the Redis configuration, and starts Redis. Note that each time we change
    the content of the `redis.conf` file and re-run the `ansible-playbook` command,
    the configuration is updated on the server and the Redis service is restarted.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 该配置在一个名为`web1`的服务器上执行。它安装`redis-server`包，复制Redis配置，并启动Redis。请注意，每次更改`redis.conf`文件的内容并重新运行`ansible-playbook`命令时，配置都会更新到服务器上，并且Redis服务会重新启动。
- en: 'We also need to create the `redis.conf` file with the following content:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建`redis.conf`文件，内容如下：
- en: '[PRE26]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This configuration runs Redis as a daemon and exposes it to all network interfaces
    under port number 6379\. Let's now define the second play, which sets up the calculator
    service.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将Redis作为守护程序运行，并将其暴露给端口号为6379的所有网络接口。现在让我们定义第二个play，用于设置计算器服务。
- en: Deploying a web service
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署Web服务
- en: 'We prepare the calculator web service in three steps:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分三步准备计算器Web服务：
- en: Configure the project to be executable.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置项目可执行。
- en: Change the Redis host address.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改Redis主机地址。
- en: Add calculator deployment to the playbook.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将计算器部署添加到playbook中。
- en: Configuring a project to be executable
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置项目可执行
- en: 'First, we need to make the build JAR executable, so that it can be easily run
    on the server as a Unix service. In order to do it, it''s enough to add the following
    code to the `build.gradle` file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使构建的JAR文件可执行，以便它可以作为Unix服务轻松在服务器上运行。为了做到这一点，只需将以下代码添加到`build.gradle`文件中：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Changing the Redis host address
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改Redis主机地址
- en: Previously, we've hardcoded the Redis host address as `redis`, so now we should
    change it in the `src/main/java/com/leszko/calculator/CacheConfig.java` file to
    `192.168.0.241`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，我们已将Redis主机地址硬编码为`redis`，所以现在我们应该在`src/main/java/com/leszko/calculator/CacheConfig.java`文件中将其更改为`192.168.0.241`。
- en: In real-life projects, the application properties are usually kept in the properties
    file. For example, for the Spring Boot framework, it's a file called `application.properties` or
    `application.yml`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，应用程序属性通常保存在属性文件中。例如，对于Spring Boot框架，有一个名为`application.properties`或`application.yml`的文件。
- en: Adding calculator deployment to the playbook
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将计算器部署添加到playbook中
- en: Finally, we can add the deployment configuration as a new play in the `playbook.yml`
    file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将部署配置作为`playbook.yml`文件中的新play添加。
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s walk through the steps we defined:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们走一遍我们定义的步骤：
- en: '**Prepare the environment**: This task ensures that the Java Runtime Environment
    is installed. Basically, it prepares the server environment, so that the calculator
    application would have all the necessary dependencies. With more complex applications,
    the list of dependent tools and libraries can be way longer.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准备环境**：此任务确保安装了Java运行时环境。基本上，它准备了服务器环境，以便计算器应用程序具有所有必要的依赖关系。对于更复杂的应用程序，依赖工具和库的列表可能会更长。'
- en: '**Configure application as a service**: We would like to have the calculator
    application running as a Unix service, so that it will be manageable in the standard
    way. In this case, it''s enough to create a link to our application in the `/etc/init.d/` directory.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将应用程序配置为服务**：我们希望将计算器应用程序作为Unix服务运行，以便以标准方式进行管理。在这种情况下，只需在`/etc/init.d/`目录中创建一个指向我们应用程序的链接即可。'
- en: '**Copy the new version**: The new version of the application is copied into
    the server. Note that if the source file didn''t change, then the file won''t
    be copied and therefore the service won''t be restarted.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复制新版本**：将应用程序的新版本复制到服务器上。请注意，如果源文件没有更改，则文件不会被复制，因此服务不会重新启动。'
- en: '**Restart the service**: As a handler, every time the new version of the application
    is copied, the service is restarted.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新启动服务**：作为处理程序，每次复制应用程序的新版本时，服务都会重新启动。'
- en: Running deployment
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行部署
- en: As always, we can execute the playbook using the `ansible-playbook` command.
    Before that, we need to build the calculator project with Gradle.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与往常一样，我们可以使用`ansible-playbook`命令执行playbook。在此之前，我们需要使用Gradle构建计算器项目。
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: After the successful deployment, the service should be available and we can
    check it's working at `http://192.168.0.242:8080/sum?a=1&b=2`. As expected, it
    should return `3` as the output.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 成功部署后，服务应该可用，并且我们可以在`http://192.168.0.242:8080/sum?a=1&b=2`上检查它是否正常工作。预期地，它应该返回`3`作为输出。
- en: Note that we have configured the whole environment by executing one command.
    What's more, if we need to scale the service, then it's enough to add a new server
    to the inventory and re-run the `ansible-playbook` command.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过执行一个命令配置了整个环境。而且，如果我们需要扩展服务，只需将新服务器添加到清单中并重新运行`ansible-playbook`命令即可。
- en: We have showed how to use Ansible for environment configuration and application
    deployment. The next step is to use Ansible together with Docker.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了如何使用Ansible进行环境配置和应用程序部署。下一步是将Ansible与Docker一起使用。
- en: Ansible with Docker
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible与Docker
- en: 'As you may have noticed, Ansible and Docker address similar software deployment
    issues:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，Ansible和Docker解决了类似的软件部署问题：
- en: '**Environment configuration**: Both Ansible and Docker provide a way to configure
    the environment; however, they use different means. While Ansible uses scripts
    (encapsulated inside the Ansible modules), Docker encapsulates the whole environment
    inside a container.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境配置**：Ansible和Docker都提供了配置环境的方式；然而，它们使用不同的方法。虽然Ansible使用脚本（封装在Ansible模块中），Docker将整个环境封装在一个容器中。'
- en: '**Dependencies**: Ansible provides a way to deploy different services on the
    same or different hosts and let them be deployed together. Docker Compose has
    a similar functionality, which allows running multiple containers at the same
    time.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**依赖性**：Ansible提供了一种在相同或不同的主机上部署不同服务并让它们一起部署的方式。Docker Compose具有类似的功能，允许同时运行多个容器。'
- en: '**Scalability**: Ansible helps to scale services providing the inventory and
    host groups. Docker Compose has a similar functionality to automatically increase
    or decrease the number of running containers.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：Ansible有助于扩展服务，提供清单和主机组。Docker Compose具有类似的功能，可以自动增加或减少运行容器的数量。'
- en: '**Automation with configuration files**: Both Docker and Ansible store the
    whole environment configuration and service dependencies in files (stored in the
    source control repository). For Ansible, this file is called `playbook.yml`. In
    the case of Docker, we have Dockerfile for the environment and docker-compose.yml
    for the dependencies and scaling.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件自动化**：Docker和Ansible都将整个环境配置和服务依赖关系存储在文件中（存储在源代码控制存储库中）。对于Ansible，这个文件称为`playbook.yml`。在Docker的情况下，我们有Dockerfile用于环境和docker-compose.yml用于依赖关系和扩展。'
- en: '**Simplicity**: Both tools are very simple to use and provide a way to set
    up the whole running environment with a configuration file and just one command
    execution.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：这两个工具都非常简单易用，并提供了一种通过配置文件和一条命令执行来设置整个运行环境的方式。'
- en: If we compare the tools, then Docker does a little more, since it provides the
    isolation, portability, and some kind of security. We could even imagine using
    Docker without any other configuration management tool. Then, why do we need Ansible
    at all?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较这些工具，那么Docker做了更多，因为它提供了隔离、可移植性和某种安全性。我们甚至可以想象在没有任何其他配置管理工具的情况下使用Docker。那么，我们为什么还需要Ansible呢？
- en: Benefits of Ansible
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible的好处
- en: 'Ansible may seem redundant; however, it brings additional benefits to the delivery
    process:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible可能看起来多余；然而，它为交付过程带来了额外的好处：
- en: '**Docker environment**: The Docker host itself has to be configured and managed.
    Every container is ultimately running on Linux machines, which needs kernel patching,
    Docker engine updates, network configuration, and so on. What''s more, there may
    be different server machines with different Linux distributions and the responsibility
    of Ansible is to make sure the Docker engine is up and running.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker环境**：Docker主机本身必须进行配置和管理。每个容器最终都在Linux机器上运行，需要内核打补丁、Docker引擎更新、网络配置等。而且，可能有不同的服务器机器使用不同的Linux发行版，Ansible的责任是确保Docker引擎正常运行。'
- en: '**Non-Dockerized applications**: Not everything is run inside a container.
    If part of the infrastructure is containerized and part is deployed in the standard
    way or in the cloud, then Ansible can manage it all with the playbook configuration
    file. There may be different reasons for not running an application as a container,
    for example performance, security, specific hardware requirements, Windows-based
    software, or working with the legacy software.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非Docker化应用程序**：并非所有东西都在容器内运行。如果基础设施的一部分是容器化的，另一部分以标准方式或在云中部署，那么Ansible可以通过playbook配置文件管理所有这些。不以容器方式运行应用程序可能有不同的原因，例如性能、安全性、特定的硬件要求、基于Windows的软件，或者与旧软件的工作。'
- en: '**Inventory**: Ansible offers a very friendly way to manage the physical infrastructure
    using inventories, which store the information about all servers. It can also
    split the physical infrastructure into different environments: production, testing,
    development.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清单**：Ansible提供了一种非常友好的方式来使用清单管理物理基础设施，清单存储有关所有服务器的信息。它还可以将物理基础设施分成不同的环境：生产、测试、开发。'
- en: '**GUI**: Ansible offers a (commercial) GUI manager called Ansible Tower, which
    aims to improve the infrastructure management for the enterprises.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI**：Ansible提供了一个（商业）名为Ansible Tower的GUI管理器，旨在改进企业的基础设施管理。'
- en: '**Improve testing process**: Ansible can help with the integration and acceptance
    testing and can encapsulate the testing scripts in a similar way that Docker Compose
    does.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**改进测试流程**：Ansible可以帮助集成和验收测试，并可以以与Docker Compose类似的方式封装测试脚本。'
- en: 'We can look at Ansible as the tool that takes care of the infrastructure, while
    Docker as a tool that takes care of the environment configuration. The overview
    is presented in the following diagram:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将Ansible视为负责基础设施的工具，而将Docker视为负责环境配置的工具。概述如下图所示：
- en: '![](assets/a8d7f1ee-0867-4b62-a53b-0ae730381cd1.png)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a8d7f1ee-0867-4b62-a53b-0ae730381cd1.png)'
- en: 'Ansible manages the infrastructure: Docker servers, Docker registry, servers
    without Docker, and cloud providers. It also takes care of the physical location
    of the servers. Using the inventory host groups, it can link the web services
    to the databases that are close to their geographic location.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible管理基础设施：Docker服务器、Docker注册表、没有Docker的服务器和云提供商。它还关注服务器的物理位置。使用清单主机组，它可以将Web服务链接到其地理位置附近的数据库。
- en: Ansible Docker playbook
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Docker playbook
- en: Ansible integrates smoothly with Docker because it provides a set of Docker-dedicated
    modules. If we create an Ansible playbook for Docker-based deployment, then the
    first tasks need to make sure that the Docker engine is installed on every machine.
    Then, it should run a container using Docker or a set of interacting containers
    using Docker Compose.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible与Docker集成得很顺利，因为它提供了一组专门用于Docker的模块。如果我们为基于Docker的部署创建一个Ansible playbook，那么第一个任务需要确保Docker引擎已安装在每台机器上。然后，它应该使用Docker运行一个容器，或者使用Docker
    Compose运行一组交互式容器。
- en: 'There are a few very useful Docker-related modules provided by Ansible: `docker_image`
    (build/manage images), `docker_container` (run containers), `docker_image_facts`
    (inspect images), `docker_login` (log into Docker registry), `docker_network`
    (manage Docker networks), and `docker_service` (manage Docker Compose).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible提供了一些非常有用的与Docker相关的模块：`docker_image`（构建/管理镜像）、`docker_container`（运行容器）、`docker_image_facts`（检查镜像）、`docker_login`（登录到Docker注册表）、`docker_network`（管理Docker网络）和`docker_service`（管理Docker
    Compose）。
- en: Installing Docker
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: We can install the Docker engine using the following task in the Ansible playbook.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Ansible playbook中的以下任务来安装Docker引擎。
- en: '[PRE30]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The playbook looks slightly different for each operating system. The one presented
    here is for Ubuntu 16.04.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的playbook看起来略有不同。这里介绍的是针对Ubuntu 16.04的。
- en: This configuration installs the Docker engine, enables the `admin` user to work
    with Docker, and installs Docker Compose with dependent tools.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置安装Docker引擎，使`admin`用户能够使用Docker，并安装了Docker Compose及其依赖工具。
- en: Alternatively, you may also use the `docker_ubuntu` role as described here: [https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible](https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以使用`docker_ubuntu`角色，如此处所述：[https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible](https://www.ansible.com/2014/02/12/installing-and-building-docker-with-ansible)。
- en: When Docker is installed, we can add a task, which will run a Docker container.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Docker后，我们可以添加一个任务，该任务将运行一个Docker容器。
- en: Running Docker containers
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Docker容器
- en: Running Docker containers is done with the use of the `docker_container` module
    and it looks very similar to what we presented for the Docker Compose configuration.
    Let's add it to the `playbook.yml` file.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker_container`模块来运行Docker容器，它看起来与我们为Docker Compose配置所呈现的非常相似。让我们将其添加到`playbook.yml`文件中。
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can read more about all of the options of the `docker_container` module
    on the official Ansible page at: [https://docs.ansible.com/ansible/docker_container_module.html](https://docs.ansible.com/ansible/docker_container_module.html).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方Ansible页面上阅读有关`docker_container`模块的所有选项的更多信息：[https://docs.ansible.com/ansible/docker_container_module.html](https://docs.ansible.com/ansible/docker_container_module.html)。
- en: We can now execute the playbook to observe that Docker has been installed and
    the Redis container started. Note that it's a very convenient way of using Docker,
    since we don't need to manually install Docker engine on every machine.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以执行playbook来观察Docker是否已安装并且Redis容器已启动。请注意，这是一种非常方便的使用Docker的方式，因为我们不需要在每台机器上手动安装Docker引擎。
- en: Using Docker Compose
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker Compose
- en: The Ansible playbook is very similar to the Docker Compose configuration. They
    even both share the same YAML file format. What's more, it is possible to use
    `docker-compose.yml` directly from Ansible. We will show how to do it, but first,
    let's define the `docker-compose.yml` file.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible playbook与Docker Compose配置非常相似。它们甚至共享相同的YAML文件格式。而且，可以直接从Ansible使用`docker-compose.yml`。我们将展示如何做到这一点，但首先让我们定义`docker-compose.yml`文件。
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is almost the same as what we defined in the previous chapter. This time
    we get the calculator image directly from the Docker Hub registry, and do not
    build it in `docker-compose.yml`, since we want to build the image once, push
    it to the registry, and then reuse it in every deployment step (on every environment),
    to make sure the same image is deployed on each Docker host machine. When we have
    `docker-compose.yml`, we are ready to add new tasks to `playbook.yml`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们在上一章中定义的内容相同。这一次，我们直接从Docker Hub注册表获取计算器镜像，并且不在`docker-compose.yml`中构建它，因为我们希望构建一次镜像，将其推送到注册表，然后在每个部署步骤（在每个环境中）重复使用它，以确保相同的镜像部署在每台Docker主机上。当我们有了`docker-compose.yml`，我们就准备好向`playbook.yml`添加新任务了。
- en: '[PRE33]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We first copy the docker-compose.yml file into the server and then execute
    `docker-compose`. As a result, Ansible creates two containers: calculator and
    redis.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将docker-compose.yml文件复制到服务器，然后执行`docker-compose`。结果，Ansible创建了两个容器：计算器和Redis。
- en: We have seen the most important features of Ansible. In the next sections, we
    write a little bit about the infrastructure and application versioning. At the
    end of this chapter, we will present how to use Ansible in order to complete the
    Continuous Delivery pipeline.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Ansible的最重要特性。在接下来的章节中，我们会稍微介绍一下基础设施和应用程序版本控制。在本章结束时，我们将介绍如何使用Ansible来完成持续交付流程。
- en: Exercises
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we have covered the fundamentals of Ansible and the way to
    use it together with Docker. As an exercise, we propose the following tasks:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了Ansible的基础知识以及与Docker一起使用它的方式。作为练习，我们提出以下任务：
- en: Create the server infrastructure and use Ansible to manage it.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建服务器基础设施并使用Ansible进行管理。
- en: Connect a physical machine or run a VirtualBox machine to emulate the remote
    server
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接物理机器或运行VirtualBox机器来模拟远程服务器
- en: Configure SSH access to the remote machine (SSH keys)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置SSH访问远程机器（SSH密钥）
- en: Install Python on the remote machine
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程机器上安装Python
- en: Create an Ansible inventory with the remote machine
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含远程机器的Ansible清单
- en: Run the Ansible ad hoc command (with the `ping` module) to check that the infrastructure
    is configured correctly
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Ansible的临时命令（使用`ping`模块）来检查基础设施是否配置正确
- en: Create a Python-based "hello world" web service and deploy it in a remote machine
    using Ansible playbook.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于Python的“hello world”网络服务，并使用Ansible剧本在远程机器上部署它。
- en: The service can look exactly the same as described in the exercises for the
    chapter
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以与本章练习中描述的完全相同
- en: Create a playbook, which deploys the service into the remote machine
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个部署服务到远程机器的剧本
- en: Run the `ansible-playbook` command and check whether the service was deployed
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行`ansible-playbook`命令并检查服务是否已部署
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have covered the configuration management process and its relation to Docker.
    The key takeaway from the chapter is as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了配置管理过程及其与Docker的关系。本章的关键要点如下：
- en: Configuration management is a process of creating and applying the configurations
    of the infrastructure and the application
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理是创建和应用基础设施和应用程序的配置的过程
- en: Ansible is one of the best trending configuration management tools. It is agentless
    and therefore requires no special server configuration
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible是最流行的配置管理工具之一。它是无代理的，因此不需要特殊的服务器配置
- en: Ansible can be used with ad hoc commands, but the real power lies in Ansible
    playbooks
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible可以与临时命令一起使用，但真正的力量在于Ansible剧本
- en: The Ansible playbook is a definition of how the environment should be configured
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible剧本是环境应该如何配置的定义
- en: The purpose of Ansible roles is to reuse parts of playbooks.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible角色的目的是重用剧本的部分。
- en: Ansible Galaxy is an online service to share Ansible roles
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Galaxy是一个在线服务，用于共享Ansible角色
- en: Ansible integrates well with Docker and brings additional benefits compared
    to using Docker and Docker Compose alone
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与仅使用Docker和Docker Compose相比，Ansible与Docker集成良好并带来额外的好处
- en: In the next chapter, we will wrap up the Continuous Delivery process and complete
    the final Jenkins pipeline.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将结束持续交付过程并完成最终的Jenkins流水线。
