- en: Testing Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试管理
- en: The important thing is not to stop questioning.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是不停地质疑。
- en: '*- Albert Einstein*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*- 阿尔伯特·爱因斯坦*'
- en: 'This is the final chapter of the book, and its objective is to guide how to
    understand when and how software testing activities are managed in a living software
    project. To that aim, this chapter is structured into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章，其目标是指导如何理解软件测试活动在一个活跃的软件项目中是如何管理的。为了达到这个目的，本章分为以下几个部分：
- en: '**Software development processes**: In this section we study when tests are
    executed in different methodologies: **Behavior-Driven Development** (**BDD**),
    **Test-Driven Development** (**TDD**), **Test-First Development** (**TFD**) and
    **Test-Last Development** (**TLD**).'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软件开发过程**：在本节中，我们研究了在不同方法论中何时执行测试：**行为驱动开发**（**BDD**）、**测试驱动开发**（**TDD**）、**先测试开发**（**TFD**）和**最后测试开发**（**TLD**）。'
- en: '**Continuous Integration** (**CI**): In this section, we will discover CI,
    the software development practice, in which the process of build, test, and integration
    is carried out continuously. The common trigger of this process is usually the
    commit of new changes (patches) to a source code repository (for example, GitHub).
    In addition, in this section, we will learn how to extend CI, reviewing the concept
    of Continuous Delivery and Continuous Deployment. Finally, we present two of the
    most important build server nowadays: Jenkins and Travis CI.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）：在本节中，我们将了解持续集成，这是软件开发实践，其中构建、测试和集成的过程是持续进行的。这个过程的常见触发器通常是向源代码库（例如GitHub）提交新更改（补丁）。此外，在本节中，我们将学习如何扩展持续集成，回顾持续交付和持续部署的概念。最后，我们介绍了目前两个最重要的构建服务器：Jenkins和Travis
    CI。'
- en: '**Test reporting**: In this section, we will first discover the XML format
    in which the xUnit framework usually reports the execution of tests. The problem
    with this format is that it is not human readable. For this reason, there are
    tools which covert this XML into a friendlier format, typically HTML. We review
    two alternatives: Maven Surefire Report and Allure.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试报告**：在本节中，我们将首先了解xUnit框架通常报告测试执行的XML格式。这种格式的问题在于它不易阅读。因此，有一些工具可以将这个XML转换成更友好的格式，通常是HTML。我们回顾了两种替代方案：Maven
    Surefire Report和Allure。'
- en: '**Defect tracking systems**: In this section, we review several issue trackes:
    JIRA, Bugzilla, Redmine, MantisBT, and GitHub issues.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺陷跟踪系统**：在本节中，我们回顾了几个问题跟踪系统：JIRA、Bugzilla、Redmine、MantisBT和GitHub问题。'
- en: '**Static analysis**: In this section, on the one hand we review several automated
    analysis tools (*linters*) such as Checkstyle, FindBugs, PMD, and SonarQube. On
    the other side, we describe several peer review tools, such as Collaborator, Crucible,
    Gerrit, and GitHub pull requests reviews.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态分析**：在本节中，一方面我们回顾了几种自动化分析工具（*linters*），如Checkstyle、FindBugs、PMD和SonarQube。另一方面，我们描述了几种同行评审工具，如Collaborator、Crucible、Gerrit和GitHub拉取请求审查。'
- en: '**Putting all, pieces together**: To conclude the book, in the final section
    we present a complete example application in which different types of tests (unit,
    integration, and end-to-end) are performed using some of the main concepts presented
    along this book.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将所有部分整合在一起**：为了结束本书，在最后一节中，我们展示了一个完整的示例应用程序，在这个应用程序中，使用了本书中介绍的一些主要概念进行了不同类型的测试（单元测试、集成测试和端到端测试）。'
- en: Software development processes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发过程
- en: 'In software engineering, the software development process (also known as the
    software development life cycle) is the name given to the workflow for the activities,
    actions, and tasks required to create software systems. As introduced in [Chapter
    6](part0148.html#4D4J80-ef8404ed083f459d860f84cc8198f8bb), *From Requirements
    to Test Cases*, the usual phases in any software development process are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，软件开发过程（也称为软件开发生命周期）是指用于创建软件系统所需的活动、行为和任务的工作流程。正如在[第6章](part0148.html#4D4J80-ef8404ed083f459d860f84cc8198f8bb)中介绍的，*从需求到测试用例*，任何软件开发过程中通常的阶段包括：
- en: 'Definition of *what*: Requirements elicitation, analysis and use case modeling.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*what*的定义：需求获取、分析和用例建模。'
- en: 'Definition of *how*: The system architecture and modeling of structural and
    behavioral diagrams.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*how*的定义：结构和行为图的系统架构和建模。'
- en: The actual software development (coding).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的软件开发（编码）。
- en: The set of activities that makes the software available for use (release, installation,
    activation, and so on).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使软件可供使用的一系列活动（发布、安装、激活等）。
- en: 'The timing in which tests are designed and implemented in the overall software
    development process results in different test methodologies, namely (see diagram
    after the list):'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个软件开发过程中设计和实施测试的时间安排导致了不同的测试方法论，即（见列表后的图表）：
- en: '**Behavior-Driven Development** **(BDD)**: At the beginning of the analysis
    phase, conversations between the software consumer (final user or costumer) and
    some of the development team (typically, project leader, manager, or analysts)
    took place. These conversations are used to concretize scenarios (that is, concrete
    examples to build up a common understanding of the system features). These examples
    form the basis to develop acceptance tests using tools such as Cucumber (for more
    details about it, take a look to [Chapter 5](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb),
    *Integration of JUnit 5 with external frameworks*.) The description of acceptance
    tests in BDD (for example, using Gherkin in Cucumber) produces both automated
    tests and documentation that accurately describe the application features. The
    BDD approach is naturally aligned with iterative or Agile methodologies, since
    it is very difficult to define requirements upfront, and these evolve as the team
    learns more about the project.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为驱动开发**（**BDD**）：在分析阶段开始时，软件消费者（最终用户或客户）与开发团队的一些成员（通常是项目负责人、经理或分析师）进行了对话。这些对话用于具体化场景（即，具体示例以建立对系统功能的共同理解）。这些示例构成了使用工具（如Cucumber）开发验收测试的基础（有关更多详细信息，请参阅[第5章](part0122.html#3KB4K0-ef8404ed083f459d860f84cc8198f8bb)，*JUnit
    5与外部框架的集成*）。在BDD中描述验收测试（例如，在Cucumber中使用Gherkin）产生了准确描述应用程序功能的自动化测试和文档。BDD方法自然地与迭代或敏捷方法论对齐，因为很难事先定义需求，并且随着团队对项目的了解而不断发展。'
- en: The term *agil**e* was popularized with the inception of the Agile manifesto
    in 2001 ([http://agilemanifesto.org/](http://agilemanifesto.org/)). It was written
    by 17 software practitioners (Kent Beck, James Grenning, Robert C. Martin, Mike
    Beedle, Jim Highsmith, Steve Mellor, Arie van Bennekum, Andrew Hunt, Ken Schwaber,
    Alistair Cockburn, Ron Jeffries, Jeff Sutherland, Ward Cunningham, Jon Kern, Dave
    Thomas, Martin Fowler, and Brian Marick), and includes a list of 12 principles
    to guide an iterative and people-centric software development process. Based on
    these principles, several software development frameworks emerged, such as SCRUM,
    Kanban, or extreme programming (XP).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 术语*敏捷*是在2001年敏捷宣言的诞生时被推广的（[http://agilemanifesto.org/](http://agilemanifesto.org/)）。它是由17位软件从业者（Kent
    Beck、James Grenning、Robert C. Martin、Mike Beedle、Jim Highsmith、Steve Mellor、Arie
    van Bennekum、Andrew Hunt、Ken Schwaber、Alistair Cockburn、Ron Jeffries、Jeff Sutherland、Ward
    Cunningham、Jon Kern、Dave Thomas、Martin Fowler和Brian Marick）撰写的，并包括一系列12条原则，以指导迭代和以人为中心的软件开发过程。基于这些原则，出现了几种软件开发框架，如SCRUM、看板或极限编程（XP）。
- en: '**Test-Driven Development** (**TDD**): TDD is a methodology in which tests
    are designed and implemented before the actual software design. The idea is to
    convert the requirements obtained in the analysis stage to specific test cases.
    Then, the software is designed and implemented to pass these tests. TDD is part
    of the XP methodology.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试驱动开发**（**TDD**）：TDD是一种方法，其中测试在实际软件设计之前被设计和实施。其思想是将分析阶段获得的需求转化为具体的测试用例。然后，软件被设计和实施以通过这些测试。TDD是XP方法的一部分。'
- en: '**Test-First Development** (**TFD**): In this methodology, tests are implemented
    after the design stage, but before the actual implementation of the SUT. This
    allows to assure that the software units have been understood correctly before
    its actual implementation. This methodology is followed in the Unified Process,
    which is a popular iterative and incremental software development process. The
    **Rational Unified Process** (**RUP**) is a well-known framework implementation
    of the Unified Process. In addition to TFD, RUP also supports other methodologies
    such as TDD and TLD.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试优先开发**（**TFD**）：在这种方法中，测试是在设计阶段之后但实际实施SUT之前实施的。这样可以确保在实际实施之前正确理解了软件单元。这种方法在统一过程中得到遵循，这是一种流行的迭代和增量软件开发过程。**统一过程**（**RUP**）是统一过程的一个知名框架实现。除了TFD，RUP还支持其他方法，如TDD和TLD。'
- en: '**Test-Last Development** (**TLD**): In this methodology, the implementation
    of the test is carried out after the implementation of the actual software (SUT).
    This test methodology is followed by classic software development processes, such
    as waterfall (sequential), incremental (multi-waterfall) or spiral (risk-oriented
    multi-waterfall).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试后开发**（**TLD**）：在这种方法论中，测试的实施是在实际软件（SUT）的实施之后进行的。这种测试方法遵循经典的软件开发流程，如瀑布（顺序）、增量（多瀑布）或螺旋（风险导向的多瀑布）。'
- en: '![](img/00140.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: Test methodologies during the software development processes
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发过程中的测试方法
- en: There is no universal accepted definitions of the terms presented so far. These
    concepts are subject to continuous evolution and debate, just like the software
    engineering itself. Consider this to be a proposal, which fits into a large number
    of software projects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些术语没有普遍接受的定义。这些概念不断发展和辩论，就像软件工程本身一样。请将其视为一个提议，适用于大量的软件项目。
- en: Regarding who is responsible for coding the tests, there is a universally accepted
    consensus. It is broadly recommended that unit tests should be written by SUT
    developers. In some cases, especially in small teams, these developers are also
    responsible for other kinds of tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于谁负责编写测试，有一个普遍接受的共识。广泛建议SUT开发人员应编写单元测试。在某些情况下，特别是在小团队中，这些开发人员还负责其他类型的测试。
- en: In addition, the role of an independent test group (often called testers or
    a QA team) is also a common practice, especially in large teams. One of the objective
    of this role separation is to remove the conflict of interests that may be present
    otherwise. We cannot forget that testing is understood as a destructive activity
    from a physiological point of view (the objective is finding defects). This independent
    test group is usually in charge on the integration, system, and non-functional
    tests. In this case, both groups of engineers should work closely; while tests
    are conducted, developers should be available to correct faults and minimize future
    errors.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，独立测试组的角色（通常称为测试人员或QA团队）也是一种常见的做法，特别是在大型团队中。这种角色分离的目标之一是消除可能存在的利益冲突。我们不能忘记，从生理学角度来看，测试被理解为一种破坏性的活动（目标是发现缺陷）。这个独立的测试组通常负责集成、系统和非功能测试。在这种情况下，两组工程师应该密切合作；在进行测试时，开发人员应该随时准备纠正错误并尽量减少未来的错误。
- en: Finally, high-level acceptance tests are usually conducted in heterogeneous
    groups involving non-programmers (customers, business analysis, managers, and
    so on) together with software engineers or testers (for example, for implement
    the step definition in Cucumber).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通常会在异构组中进行高级别的验收测试，包括非程序员（客户、业务分析、管理人员等）与软件工程师或测试人员（例如，在Cucumber中实现步骤定义）。
- en: Continuous Integration
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'The concept of CI was first coined on 1991 by Grady Booch (American software
    engineer, best known for the development of UML together with Ivar Jacobson and
    James Rumbaugh). The **Extreme Programming** (**XP**) methodology adopted this
    term, making it very popular. According to Martin Fowler, CI is defined as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: CI的概念最早是由Grady Booch（美国软件工程师，与Ivar Jacobson和James Rumbaugh一起开发UML而闻名）于1991年首次提出的。**极限编程**（**XP**）方法采用了这个术语，使其非常流行。根据Martin
    Fowler的说法，CI的定义如下：
- en: '*Continuous Integration is a software development practice where members of
    a team integrate their work frequently, usually each person integrates at least
    daily - leading to multiple integrations per day. Each integration is verified
    by an automated build (including test) to detect integration errors as quickly
    as possible.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*持续集成是一个软件开发实践，团队成员经常集成他们的工作，通常每个人至少每天集成一次 - 导致每天多次集成。每次集成都由自动构建（包括测试）进行验证，以尽快检测到集成错误。*'
- en: In CI systems, we can identify different parts. First, we need a source code
    repository, which is a file archive to host the source code of our software project,
    typically using a version control system. Nowadays, the preferred version control
    system is Git (originally developed by Linus Torvalds) over older solutions, such
    as CVS or SVN. At the moment of this writing, the leading version control repository
    is GitHub ([https://github.com/](https://github.com/)), which as its name indicates
    it is based on Git. Besides, there are other alternatives, such as GitLab ([https://gitlab.com](https://gitlab.com)),
    BitBucket ([https://bitbucket.org/](https://bitbucket.org/)), or SourceForge ([https://sourceforge.net/](https://sourceforge.net/)).
    The latter was the leading forge in the past, but is nowadays less used.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI系统中，我们可以识别出不同的部分。首先，我们需要一个源代码存储库，这是一个文件存档，用于托管软件项目的源代码，通常使用版本控制系统。如今，首选的版本控制系统是Git（最初由Linus
    Torvalds开发），而不是较早的解决方案，如CVS或SVN。在撰写本文时，领先的版本控制存储库是GitHub（[https://github.com/](https://github.com/)），正如其名称所示，它是基于Git的。此外，还有其他选择，如GitLab（[https://gitlab.com](https://gitlab.com)）、BitBucket（[https://bitbucket.org/](https://bitbucket.org/)）或SourceForge（[https://sourceforge.net/](https://sourceforge.net/)）。后者曾经是领先的开发平台，但现在使用较少。
- en: A copy of the source code repository is synchronized in the local environment
    of developers. The coding work is done against this local copy. Developers are
    supposed to commit new changes (known as *patches*) to the remote repository in
    a daily basis. Frequent commits allow to avoid conflict errors due to the mutual
    modification of the same parts of a given file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码存储库的副本与开发人员的本地环境同步。编码工作是针对这个本地副本进行的。开发人员应该每天提交新的更改（称为*补丁*）到远程存储库。频繁的提交可以避免由于对同一文件的相互修改而导致的冲突错误。
- en: 'The basic idea of CI is that every commit should execute the build and test
    the software with the new changes. For that reason, we need a server-side infrastructure
    which automates this process. This infrastructure is known as build server (or
    directly CI server). Two of the most important build servers nowadays are Jenkins
    and Travis CI. Details of both of them are provided in next subsections. As a
    result of the build process, the build server should notify the result of the
    process to the origin developer. If tests were successful, the patch is merged
    in the codebase:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: CI的基本理念是每次提交都应该执行构建并测试带有新更改的软件。因此，我们需要一个自动化这个过程的服务器端基础设施。这个基础设施被称为构建服务器（或直接CI服务器）。目前最重要的两个构建服务器是Jenkins和Travis
    CI。它们的详细信息将在下一小节中提供。作为构建过程的结果，构建服务器应该通知原始开发人员的处理结果。如果测试成功，补丁将合并到代码库中：
- en: '![](img/00141.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: Continuous Integration process
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成过程
- en: 'Close to CI, the term DevOps has gained momentum. DevOps comes from *development*
    and *operations*, and it is the name given to a software development process that
    emphasizes the communication and collaboration different teams in a project software:
    development (software engineering), QA (**quality assurance**), and operations
    (infrastructure). The term DevOps is also referred to a job position, typically
    in charge of the setup, monitoring an operation of the build servers:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 靠近CI，术语DevOps已经蓬勃发展。DevOps来自*开发*和*运维*，它是一个强调项目软件中不同团队之间沟通和协作的软件开发过程的名称：开发（软件工程）、QA（**质量保证**）和运维（基础设施）。DevOps这个术语也指的是一个工作职位，通常负责构建服务器的设置、监控和运行：
- en: '![](img/00142.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: DevOps are in between development, operations and QA
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps处于开发、运维和QA之间
- en: 'As shown in the next figure, the concept of CI can be extended to:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，CI的概念可以扩展到：
- en: '**Continuous Delivery**: When the CI pipeline finish correctly, at least a
    release of software will be deployed to a test environment (for instance, deploying
    an SNAPSHOT artifact to a Maven archiver). In this phase, acceptance tests can
    also be executed.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续交付**：当CI管道正确完成时，至少一个软件发布将部署到测试环境（例如，将SNAPSHOT工件部署到Maven存档器）。在此阶段，还可以执行验收测试。'
- en: '**Continuous Deployment**: As the final step in the automation toolchain, the
    release of the software can be released to a production environment (for example,
    deploying a web application to the production server for each commit, which achieves
    to pass the complete pipeline).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续部署**：作为自动化工具链的最后一步，软件的发布可以发布到生产环境（例如，将Web应用程序部署到每个提交的生产服务器，以通过完整的管道）。'
- en: '![](img/00143.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00143.jpeg)'
- en: Continuous Integration, Continuous Delivery, and Continuous Deployment chain
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成、持续交付和持续部署链
- en: Jenkins
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins ([https://jenkins.io/](https://jenkins.io/)) is an open source build
    server which supports building, deploying, and automating any project. Jenkins
    has been developed in Java, and it can be managed easily using its web interface.
    The global configuration of a Jenkins instance includes information about JDK,
    Git, Maven, Gradle, Ant, and Docker.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins ([https://jenkins.io/](https://jenkins.io/))是一个开源的构建服务器，支持构建、部署和自动化任何项目。Jenkins是用Java开发的，可以通过其Web界面轻松管理。Jenkins实例的全局配置包括关于JDK、Git、Maven、Gradle、Ant和Docker的信息。
- en: Jenkins was originally developed as the Hudson project by Sun Microsystems in
    2004\. After the acquisition of Sun by Oracle, the Hudson project was forked to
    an open source project, renamed to Jenkins. Both names (Hudson and Jenkins) were
    meant to sound like stereotypical English butler names. The idea is they help
    developers carry out tedious tasks, just like a helpful butler.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins最初是由Sun Microsystems于2004年开发的Hudson项目。在Sun被Oracle收购后，Hudson项目被分叉为一个开源项目，并更名为Jenkins。Hudson和Jenkins这两个名字都是为了听起来像典型的英国男仆名字。其想法是它们帮助开发人员执行乏味的任务，就像一个乐于助人的男仆一样。
- en: In Jenkins, builds are typically triggered by new commits in version control
    systems. In addition, builds can be started by other mechanisms, such as scheduled
    cron task or even manually using the Jenkins interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中，构建通常由版本控制系统中的新提交触发。此外，构建可以由其他机制启动，例如定期的cron任务，甚至可以通过Jenkins界面手动启动。
- en: Jenkins is highly extensible thanks to its plugin architecture. Thanks to those,
    Jenkins has been extended to a rich plugin ecosystem made by vast number of third-party
    frameworks, libraries, systems, and so on. This is maintained by the open source
    community. The Jenkins plugin portfolio is available on [https://plugins.jenkins.io/](https://plugins.jenkins.io/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins由于其插件架构而具有很高的可扩展性。由于这些插件，Jenkins已经扩展到由大量第三方框架、库、系统等组成的丰富插件生态系统。这是由开源社区维护的。Jenkins插件组合可在[https://plugins.jenkins.io/](https://plugins.jenkins.io/)上找到。
- en: 'At the heart of Jenkins, we find the concept of job. A job is a runnable entity
    monitored by Jenkins. As shown in the screenshot here, a Jenkins job is composed
    of four groups:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins的核心，我们找到了作业的概念。作业是由Jenkins监控的可运行实体。如此屏幕截图所示，Jenkins作业由四个组成：
- en: '**Source code management**: This is the URL of the source code repository (Git,
    SVN, and so on)'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源代码管理**：这是源代码存储库（Git、SVN等）的URL'
- en: '**Build trigger**: This is the mechanism starting the build process, such as
    new changes in the source code repository, external scripts, periodically, and
    so on.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建触发器**：这是启动构建过程的机制，例如源代码存储库中的新更改、外部脚本、定期等。'
- en: '**Build environment**: Optional setup, for example, delete workspace before
    build start, abort the build when stuck, and so on.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建环境**：可选设置，例如在构建开始前删除工作空间，卡住时中止构建等。'
- en: '**Collection of steps of the jobs**: These steps can be done with Maven, Gradle,
    Ant, or shell commands. After those, post-build actions can be configured, for
    example, to archive an artifact, to publish JUnit test report (we will describe
    this feature later in this chapter), email notifications, and so on.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业步骤的集合**：这些步骤可以使用Maven、Gradle、Ant或shell命令完成。之后，可以配置后构建操作，例如存档工件、发布JUnit测试报告（我们将在本章后面描述此功能）、电子邮件通知等。'
- en: '![](img/00144.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00144.jpeg)'
- en: Jenkins job configuration
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins作业配置
- en: 'Another interesting way of configuring a job is using a Jenkins *pipeline*,
    which is the description of the build workflow using the Pipeline DSL (a domain-specific
    language based on Groovy). A Jenkins pipeline description is typically stored
    in a file called Jenkinsfile, which can be under the control of the source code
    repository. In short, a Jenkins pipeline is declarative chain of stages composed
    of steps. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 配置作业的另一种有趣方式是使用Jenkins *pipeline*，它是使用Pipeline DSL（基于Groovy的特定领域语言）描述构建工作流程。Jenkins管道描述通常存储在一个名为Jenkinsfile的文件中，该文件可以受源代码存储库的控制。简而言之，Jenkins管道是由步骤组成的阶段的声明性链。例如：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Travis CI
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Travis CI
- en: Travis CI ([https://travis-ci.org/](https://travis-ci.org/)) is a distributed
    build server used to build and test software projects hosted on GitHub. Travis
    supports open source projects with no charge.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI ([https://travis-ci.org/](https://travis-ci.org/))是一个分布式构建服务器，用于构建和测试托管在GitHub上的软件项目。Travis支持无需收费的开源项目。
- en: 'The configuration of Travis CI is done using a file named *.travis.yaml*. The
    content of this file is structured using different keywords, including:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI的配置是使用名为*.travis.yaml*的文件完成的。该文件的内容使用不同的关键字进行结构化，包括：
- en: '`language`: Project language, that is, java, node_js, ruby, python, or php
    among others (the complete list is available on [https://docs.travis-ci.com/user/languages/](https://docs.travis-ci.com/user/languages/)).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`language`：项目语言，即java、node_js、ruby、python或php等（完整列表可在[https://docs.travis-ci.com/user/languages/](https://docs.travis-ci.com/user/languages/)上找到）。'
- en: '`sudo`: Flag value to set if superuser privileges are needed (for example to
    install Ubuntu packages).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo`：如果需要超级用户权限（例如安装Ubuntu软件包）的标志值。'
- en: '`dist`: Builds can be executed on Linux environments (Ubuntu Precise 12.04
    or Ubuntu Trusty 14.04).'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dist`：可以在Linux环境（Ubuntu Precise 12.04或Ubuntu Trusty 14.04）上执行构建。'
- en: '`addons`: Declarative shortcuts to basic operations of the apt-get commands.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addons`：apt-get命令的基本操作的声明性快捷方式。'
- en: '`install`: First part of the Travis build life cycle, in which the installation
    of the required dependencies is done. This part can be optionally initiated using
    `before_install`.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install`：Travis构建生命周期的第一部分，其中完成所需依赖项的安装。可以选择使用`before_install`来启动此部分。'
- en: '`script`: Actual execution of the build. This phase can be optionally surrounded
    by `before_script` and `after_script`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`script`：构建的实际执行。此阶段可以选择由`before_script`和`after_script`包围。'
- en: '`deploy`: Finally, the deployment of the build can be optionally made in this
    phase. This stage has its own life cycle controlled with `before_deploy` and `after_deploy`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy`：最后，可以选择在此阶段进行构建的部署。此阶段有其自己的生命周期，由`before_deploy`和`after_deploy`控制。'
- en: YAML is lightweight markup language used broadly for configuration files due
    to its minimalist syntax. It was originally defined as Yet Another Markup Language,
    but then it was repurposed to YAML Ain't Markup Language to distinguish its purpose
    as data oriented.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是一种轻量级标记语言，由于其简约的语法，广泛用于配置文件。最初它被定义为Yet Another Markup Language，但后来被重新定义为YAML
    Ain't Markup Language，以区分其作为数据导向的目的。
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Travis CI provides a web dashboard in which we can check the status of the
    current and past build generated in the projects using Travis CI of our GitHub
    account:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI提供了一个Web仪表板，我们可以在其中检查使用Travis CI生成的当前和过去构建的状态，这些构建是在我们的GitHub帐户中使用Travis
    CI的项目中生成的：
- en: '![](img/00145.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00145.jpeg)'
- en: Travis CI dashboard
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Travis CI仪表板
- en: Test reporting
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试报告
- en: From its initial versions, the JUnit testing framework introduced an XML file
    format to report the execution of test suites. Over the years, this XML format
    has become a *de facto* standard for reporting test results, broadly adopted in
    the xUnit family.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 从其最初版本开始，JUnit测试框架引入了一种XML文件格式来报告测试套件的执行情况。多年来，这种XML格式已成为报告测试结果的*事实*标准，在xUnit家族中广泛采用。
- en: These XML can be processed by different programs to display the results in a
    human-friendly format. This is for example what build servers do. For example,
    Jenkins implements a tool called `JUnitResultArchiver`*,* which parses to HTML
    the XML files resulting from the test execution of a job.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些XML可以由不同的程序处理，以以人类友好的格式显示结果。这就是构建服务器所做的事情。例如，Jenkins实现了一个名为`JUnitResultArchiver`的工具，它解析作业测试执行产生的XML文件为HTML。
- en: 'Despite the fact that this XML format has become pervasive, there is no universal
    formal definition for it. JUnit test executors (for example, Maven, Gradle, and
    so on) usually use its own XSD (XML Schema Definition). For instance, the structure
    of this XML report in Maven ([http://maven.apache.org/surefire/maven-surefire-plugin/](http://maven.apache.org/surefire/maven-surefire-plugin/))
    is as depicted in the following diagram. Note that a test suite is composed by
    a set of properties and a set of test cases. Each test case can be declared as
    a failure (test with some assertion failed), skipped (test ignored), and an error
    (test with an unexpected exception). If none of these states appear in the body
    of the test suite, then the test is interpreted as successful. Finally, for each
    test case the XML also stores the standard output (*system-out*) and the standard
    error output (*system-err*):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种XML格式已经变得普遍，但并没有普遍的正式定义。JUnit测试执行器（例如Maven，Gradle等）通常使用自己的XSD（XML模式定义）。例如，在Maven中，这种XML报告的结构如下图所示。请注意，测试套件由一组属性和一组测试用例组成。每个测试用例可以声明为失败（具有某些断言失败的测试），跳过（忽略的测试）和错误（具有意外异常的测试）。如果测试套件的主体中没有出现这些状态中的任何一个，那么测试将被解释为成功。最后，对于每个测试用例，XML还存储标准输出（*system-out*）和标准错误输出（*system-err*）：
- en: '![](img/00146.jpeg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00146.jpeg)'
- en: Schema representation for Maven Surefire XML reports
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Maven Surefire XML报告的模式表示
- en: The *rerunFailure* is a custom state implemented by Maven Surefire for retrying
    flaky (intermittent) tests ([http://maven.apache.org/surefire/maven-surefire-plugin/examples/rerun-failing-tests.html](http://maven.apache.org/surefire/maven-surefire-plugin/examples/rerun-failing-tests.html)).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`rerunFailure`是Maven Surefire为重试不稳定（间歇性）测试而实现的自定义状态（[http://maven.apache.org/surefire/maven-surefire-plugin/examples/rerun-failing-tests.html](http://maven.apache.org/surefire/maven-surefire-plugin/examples/rerun-failing-tests.html)）。'
- en: With regards to JUnit 5, the Maven and Gradle plugins used to run Jupiter tests
    (`maven-surefire-plugin` and `junit-platform-gradle-plugin` respectively) write
    the results of the test execution following this XML format. In the following
    sections, we are going to see how to transform this XML output to a human readable
    HTML report.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JUnit 5，用于运行Jupiter测试的Maven和Gradle插件（分别为`maven-surefire-plugin`和`junit-platform-gradle-plugin`）遵循此XML格式编写测试执行结果。在接下来的部分中，我们将看到如何将此XML输出转换为人类可读的HTML报告。
- en: Maven Surefire Report
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven Surefire报告
- en: 'By default, `maven-surefire-plugin` generates the XML resulting from a test
    suite execution as `${basedir}/target/surefire-reports/TEST-*.xml`. This XML output
    can be easily parsed to HTML using the plugin `maven-surefire-report-plugin`.
    To that, we simply need to declare this plugin in the reporting clause of our
    `pom.xml`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`maven-surefire-plugin`生成来自测试套件执行的XML结果为`${basedir}/target/surefire-reports/TEST-*.xml`。可以使用插件`maven-surefire-report-plugin`轻松将此XML输出解析为HTML。为此，我们只需要在`pom.xml`的报告子句中声明此插件，如下所示：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This way, when we invoque the Maven lifecycle for documentation (`mvn site`),
    an HTML page with the test result will be included in the general report.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们调用Maven生命周期以进行文档（`mvn site`）时，测试结果的HTML页面将包含在总体报告中。
- en: 'See an example of the report, made using the project `junit5-reporting` within
    the GitHub repository examples ([https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 查看报告的示例，使用GitHub存储库示例中的项目`junit5-reporting`（[https://github.com/bonigarcia/mastering-junit5](https://github.com/bonigarcia/mastering-junit5)）：
- en: '![](img/00147.jpeg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00147.jpeg)'
- en: HTML report generated by maven-surefire-report-plugin
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由maven-surefire-report-plugin生成的HTML报告
- en: Allure
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Allure
- en: Allure ([http://allure.qatools.ru/](http://allure.qatools.ru/)) is a light-weight
    open source framework for generating test reports for different programming languages,
    including Java, Python, JavaScript, Ruby, Groovy, PHP, .NET, and Scala. Generaliy
    speaking, Allure uses the XML test output and transforms it in an HTML5-rich report.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Allure（[http://allure.qatools.ru/](http://allure.qatools.ru/)）是一个轻量级的开源框架，用于为不同的编程语言生成测试报告，包括Java，Python，JavaScript，Ruby，Groovy，PHP，.NET和Scala。总的来说，Allure使用XML测试输出并将其转换为HTML5丰富报告。
- en: 'Allure provides support for JUnit 5 projects. This can be done using both Maven
    and Gradle. Regarding Maven, we need to do register a listener in `maven-surefire-plugin`.
    This listener will be the class AllureJunit5 (located in the library `io.qameta.allure:allure-junit5`),
    which is basically a implementation of the JUnit 5’s `TestExecutionListener`.
    As described in [chapter 2](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb),
    *What’s New In JUnit 5*, `TestExecutionListener` is part of the Launcher API,
    and it is used to receive events about the test execution. All in all, this listener
    allows to Allure to compile the test information, while it is generated in the
    JUnit platform. This information is stored as JSON files by Allure. After that,
    we can use the plugin `io.qameta.allure:allure-maven` to generate the HTML5 from
    these JSON files. The commands are:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Allure支持JUnit 5项目。这可以使用Maven和Gradle来完成。关于Maven，我们需要在`maven-surefire-plugin`中注册一个监听器。这个监听器将是类AllureJunit5（位于库`io.qameta.allure:allure-junit5`中），它基本上是JUnit
    5的`TestExecutionListener`的实现。正如在[第2章](part0051.html#1GKCM0-ef8404ed083f459d860f84cc8198f8bb)中所描述的，*JUnit
    5的新功能*，`TestExecutionListener`是Launcher API的一部分，用于接收有关测试执行的事件。总的来说，这个监听器允许Allure在生成JUnit平台时编译测试信息。这些信息由Allure存储为JSON文件。之后，我们可以使用插件`io.qameta.allure:allure-maven`从这些JSON文件生成HTML5。命令是：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The content of our `pom.xml` should contain the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`pom.xml`的内容应包含以下内容：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The same process can be done using Gradle, this time using the equivalent plugin,
    `io.qameta.allure:allure-gradle`. All in all, the content of our `build.gradle`
    file should contain:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Gradle也可以完成相同的过程，这次使用等效的插件`io.qameta.allure:allure-gradle`。总的来说，我们的`build.gradle`文件的内容应包含：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The following picture shows several screenshots of the Allure report generated
    using the above-mentioned steps (the final result is the same using Maven or Gradle).
    The project of this example is called `junit5-allure`, as usual hosted in GitHub.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了使用上述步骤生成的Allure报告的几个屏幕截图（使用Maven或Gradle生成的最终结果相同）。该示例项目称为`junit5-allure`，通常托管在GitHub上。
- en: '![](img/00148.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00148.jpeg)'
- en: Allure reports generated in a JUnit 5 project
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在JUnit 5项目中生成的Allure报告
- en: Defect-tracking systems
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺陷跟踪系统
- en: A defect-tracking system (also known as bug tracking system, bug tracker, or
    issue tracker) is a software system that keeps track of reported software defects
    in software projects. The main benefits of this kind of systems is to provide
    a centralized overview of development management, bug reporting, and even feature
    request. It is also common to maintain a list of pending items, often called backlog.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 缺陷跟踪系统（也称为bug跟踪系统，bug跟踪器或问题跟踪器）是一个软件系统，用于跟踪软件项目中报告的软件缺陷。这种系统的主要好处是提供开发管理，bug报告甚至功能请求的集中概览。通常还会维护一个待处理项目列表，通常称为积压。
- en: 'There are a bunch of defect-tracking systems available, both proprietary and
    open source. In this section, we make a brief of several of the most well-known:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多可用的缺陷跟踪系统，既有专有的也有开源的。在本节中，我们简要介绍了几个最知名的系统：
- en: '**JIRA** ([https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira)):
    It is a proprietary defect-tracking system created by Atlasian. In addition to
    bug and issue tracking, it provides managements capabilities such as SCRUM and
    Kanban boards, a language to query issues (JIRA Query Language), integration with
    external systems (for example, GitHub, Bitbucket), and an add-ons mechanism to
    extend JIRA with plugins from the Atlasian Marketplace ([https://marketplace.atlassian.com/](https://marketplace.atlassian.com/)).'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JIRA**（[https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira)）：这是由Atlasian创建的专有缺陷跟踪系统。除了错误和问题跟踪外，它还提供了管理功能，如SCRUM和Kanban板，用于查询问题的语言（JIRA查询语言），与外部系统的集成（例如GitHub，Bitbucket），以及通过Atlasian
    Marketplace（[https://marketplace.atlassian.com/](https://marketplace.atlassian.com/)）的插件机制来扩展JIRA的插件。'
- en: '**Bugzilla** ([https://www.bugzilla.org/](https://www.bugzilla.org/)): It is
    an open source web-based, defect-tracking system developed by the Mozilla Foundation.
    Among its features, we can find a database designed to improve performance and
    scalability, query mechanism for searching defects, integrated e-mail capabilities,
    and user roles management.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bugzilla**（[https://www.bugzilla.org/](https://www.bugzilla.org/)）：这是由Mozilla基金会开发的开源基于Web的缺陷跟踪系统。在其功能中，我们可以找到用于改善性能和可伸缩性的数据库，用于搜索缺陷的查询机制，集成电子邮件功能以及用户角色管理。'
- en: '**Redmine** ([http://www.redmine.org/](http://www.redmine.org/)): It is an
    open source, web-based defect-tracking system. It provides wikis, forums, time
    tracking, role-based access control, or Gantt charts for project management.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redmine**（[http://www.redmine.org/](http://www.redmine.org/)）：这是一个开源的基于Web的缺陷跟踪系统。它提供了维基，论坛，时间跟踪，基于角色的访问控制，或者用于项目管理的甘特图。'
- en: '**MantisBT** ([https://www.mantisbt.org/](https://www.mantisbt.org/)): It is
    another open source, web-based defect tracking system designed to be simple but
    effective. Among its features, we can highlight its event-driven plugin system
    to allows extensions both official that third-party, multi-channel notification
    system (e-mail, RSS feed, Twitter plugin, and so on), or role-based access control.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MantisBT**（[https://www.mantisbt.org/](https://www.mantisbt.org/)）：它是另一个开源的、基于Web的缺陷跟踪系统，旨在简单而有效。其中的特点包括事件驱动的插件系统，允许官方和第三方扩展，多通道通知系统（电子邮件、RSS订阅、Twitter插件等），或基于角色的访问控制。'
- en: '**GitHub issues** ([https://guides.github.com/features/issues/](https://guides.github.com/features/issues/)):
    It is the tracking system integrated in each GitHub repository. The approach of
    GitHub issues is to provide a generic tracking system for defects, task scheduling,
    discussions, and even feature request using GitHub issues. Each issue can be categorized
    using a customizable label system, participators management, and notifications.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub issues**（[https://guides.github.com/features/issues/](https://guides.github.com/features/issues/)）：它是集成在每个GitHub存储库中的跟踪系统。GitHub
    issues的方法是提供一个通用的缺陷跟踪系统，用于任务调度、讨论，甚至使用GitHub issues进行功能请求。每个问题都可以使用可自定义的标签系统进行分类，参与者管理和通知。'
- en: Static analysis
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态分析
- en: This book, which is finishing soon, has been focused on software testing. No
    surprises, JUnit is about testing. But as we seen in [Chapter 1](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb),
    *Retrospective on software quality and Java testing*, although software testing
    is the most commonly performed activities within **Verification & Validation**
    (**V&V**), it is not the only type. The other important group of activities is
    static analysis, in which there is no execution of the software testing.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这本即将完成的书主要关注软件测试。毫不奇怪，JUnit就是关于测试的。但正如我们在[第1章](part0021.html#K0RQ0-ef8404ed083f459d860f84cc8198f8bb)中所看到的，*关于软件质量和Java测试的回顾*，尽管软件测试是**验证和验证**（**V&V**）中最常见的活动，但并不是唯一的类型。另一个重要的活动组是静态分析，在这种活动中没有执行软件测试。
- en: 'There are different activities that can be categorized as static analysis.
    Among them, the automated software analysis is an alternative quite inexpensive
    in terms of required effort, and it can help to increase the internal code quality
    significantly. In this chapter, we are going to review several automated software
    analysis tools, known as **linters**, namely:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将不同的活动归类为静态分析。其中，自动化软件分析是一种相当廉价的替代方案，可以帮助显著提高内部代码质量。在本章中，我们将回顾几种自动化软件分析工具，即**linters**：
- en: '**Checkstyle** ([http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/)):
    It analyzes Java code following different rules, such as missing Javadoc comments,
    the use of magic numbers, naming conventions of variables and methods, method''s
    argument length and line lengths, the use of imports, the spaces between some
    characters, the good practices of class construction, or duplicated code. It can
    be used as Eclipse or IntelliJ plugin, among others.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Checkstyle**（[http://checkstyle.sourceforge.net/](http://checkstyle.sourceforge.net/)）：它分析Java代码遵循不同的规则，如缺少Javadoc注释，使用魔术数字，变量和方法的命名约定，方法的参数长度和行长度，导入的使用，一些字符之间的空格，类构造的良好实践，或重复的代码。它可以作为Eclipse或IntelliJ插件等使用。'
- en: '**FindBugs** ([http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)):
    It looks for three types of errors within Java code:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FindBugs**（[http://findbugs.sourceforge.net/](http://findbugs.sourceforge.net/)）：它在Java代码中查找三种类型的错误：'
- en: 'Correctness bug: Apparent coding mistake (for example, class defines `equal(Object)`
    instead of `equals(Object)`.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确性错误：明显的编码错误（例如，类定义了`equal(Object)`而不是`equals(Object)`）。
- en: 'Bad practice: Violations of recommended best practices (dropped exceptions,
    misuse of finalize, and so on).'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不良实践：违反推荐最佳实践（丢弃异常、滥用finalize等）。
- en: 'Dodgy errors: Confusing code or written in a way that leads to error (for example,
    class `literal` never used, switch fall through, unconfirmed type casts, and redundant
    null check.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可疑错误：混乱的代码或以导致错误的方式编写（例如，类`literal`从未被使用，switch穿透，未经确认的类型转换和多余的空指针检查）。
- en: '**PMD** ([https://pmd.github.io/](https://pmd.github.io/)): It is a cross-language
    static code analyzer, including Java, JavaScript, C++, C#, Go, Groovy, Perl, PHP,
    among others. It has a lot of plugins, including Maven, Gradle, Eclipse, IntelliJ,
    and Jenkins.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PMD**（[https://pmd.github.io/](https://pmd.github.io/)）：它是一个跨语言的静态代码分析器，包括Java、JavaScript、C++、C#、Go、Groovy、Perl、PHP等。它有许多插件，包括Maven、Gradle、Eclipse、IntelliJ和Jenkins。'
- en: '**SonarQube** ([https://www.sonarqube.org/](https://www.sonarqube.org/)): It
    (formerly just Sonar) is a web-based, open source continuous quality assessment
    dashboard. It supports a wide variety of languages, including Java, C/C++, Objective-C,
    C#, and many others. Offers reports on duplicated code, code smells, code coverage,
    complexity and security vulnerabilities. SonarQube has a distributed flavor called
    **SonarCloud** ([https://sonarcloud.io/](https://sonarcloud.io/)). It can be used
    for free in open source projects, providing a seamless integration with Travis
    CI through a few lines of configuration in `.travis.yml` (see the following snippet),
    including the SonarCloud organization identifier and secure token. These parameters
    can be obtained in the SonarCloud web administration panel, after associating
    out SonarCloud account with GitHub.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SonarQube**（[https://www.sonarqube.org/](https://www.sonarqube.org/)）：它（以前只是Sonar）是一个基于Web的、开源的持续质量评估仪表板。它支持多种语言，包括Java、C/C++、Objective-C、C#等。提供重复代码、代码异味、代码覆盖率、复杂性和安全漏洞的报告。SonarQube有一个名为**SonarCloud**（[https://sonarcloud.io/](https://sonarcloud.io/)）的分布式版本。它可以在开源项目中免费使用，通过在`.travis.yml`中进行几行配置，包括SonarCloud组织标识符和安全令牌，与Travis
    CI实现无缝集成。这些参数可以在将SonarCloud帐户与GitHub关联后，在SonarCloud Web管理面板中获取。'
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, we simply need to call SonarCloud, using Maven or using Gradle:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需要使用Maven或Gradle调用SonarCloud：
- en: '[PRE8]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following picture shows the SonarCloud dashboard for the example application
    Rate my cat!, described in the last section of this chapter:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了SonarCloud仪表板，用于上一章节中描述的示例应用程序“Rate my cat!”：
- en: '![](img/00149.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: SonarCloud report for the application Rate my cat!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SonarCloud报告应用程序“Rate my cat!”
- en: 'Another analysis static technique highly adopted in many software projects
    is **peer review**. This method is quite expensive in terms of time and effort
    required, but when correctly applied, it allows to maintain very good levels of
    internal code quality. Nowadays there is a wide range of tools aimed to ease the
    peer review process of software codebase. Among others, we find the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多软件项目中广泛采用的另一种分析静态技术是**同行审查**。这种方法在时间和精力方面相当昂贵，但正确应用时，可以保持非常高水平的内部代码质量。如今有许多旨在简化软件代码库的同行审查过程的工具。其中，我们找到了以下工具：
- en: '**Collaborator** ([https://smartbear.com/product/collaborator/](https://smartbear.com/product/collaborator/)):
    Peer code (and documentation) review propriety tool created by the company SmartBear.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collaborator**（[https://smartbear.com/product/collaborator/](https://smartbear.com/product/collaborator/)）：SmartBear公司创建的同行代码（和文档）审查专有工具。'
- en: '**Crucible** ([https://www.atlassian.com/software/crucible](https://www.atlassian.com/software/crucible)):
    On-premises code review propriety tool for enterprise products, created by Atlassian.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Crucible**（[https://www.atlassian.com/software/crucible](https://www.atlassian.com/software/crucible)）：Atlassian创建的企业产品的本地代码审查专有工具。'
- en: '**Gerrit** ([https://www.gerritcodereview.com/](https://www.gerritcodereview.com/)):
    Web-based code collaboration open source tool. It can be used with GitHub repository
    through GerritHub ([http://gerrithub.io/](http://gerrithub.io/)).'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gerrit**（[https://www.gerritcodereview.com/](https://www.gerritcodereview.com/)）：基于Web的开源代码协作工具。可以通过GerritHub（[http://gerrithub.io/](http://gerrithub.io/)）与GitHub存储库一起使用。'
- en: '**GitHub pull request reviews** ([https://help.github.com/articles/about-pull-request-reviews/](https://help.github.com/articles/about-pull-request-reviews/)):
    In GitHub, a pull request is a method for submitting contributions in third-party
    repositories. As part of the collaborative tools provided by GitHub, pull requests
    allows reviews and comments in a easy and integrated fashion.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub拉取请求审查**（[https://help.github.com/articles/about-pull-request-reviews/](https://help.github.com/articles/about-pull-request-reviews/)）：在GitHub中，拉取请求是向第三方存储库提交贡献的一种方法。作为GitHub提供的协作工具的一部分，拉取请求允许以简单和集成的方式进行审查和评论。'
- en: Putting all pieces together
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有部分整合在一起
- en: In this last section of the book, we are going to review some of the major aspects
    covered in this book with a practical example. To that aim, a complete application
    is developed together with different types of tests implemented with JUnit 5.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一节中，我们将通过一个实际示例回顾本书涵盖的一些主要方面。为此，我们将开发一个完整的应用程序，并使用JUnit 5实现不同类型的测试。
- en: Features and requirements
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能和需求
- en: 'The history of our application begins with a hypothetical person, which loves
    cats. This person owns a clowder, and he/she would like to get feedback about
    them from the external world. For that reason, this person (we can him/her our
    *client* from now on) contacts with us to implement a web application which satisfies
    his/her needs. The name for that application will be *"Rate my cat!"*. In a conversation
    with the client, we elicit a following list of features for the application to
    be developed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序的历史始于一个热爱猫的假设人物。这个人拥有一群猫，他/她希望从外部世界得到关于它们的反馈。因此，这个人（我们从现在开始称之为*客户*）与我们联系，要求我们实现一个满足他/她需求的Web应用程序。该应用程序的名称将是“Rate
    my cat!”。在与客户的对话中，我们得出了应用程序开发的以下功能列表：
- en: '**F1**: Each user shall rate a list of cats by watching its name and picture.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F1**：每个用户应通过观看其名称和图片对猫的列表进行评分。'
- en: '**F2**: The rate shall be done once per user using a star mechanism (from `0.5`
    to `5` stars per cat) and optionally comments could be included per cat.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**F2**：每个用户应使用星级机制（从`0.5`到`5`星）对每只猫进行一次评分，还可以选择包括每只猫的评论。'
- en: 'As part of the analysis phase in our development process, those features are
    refined as a list of **functional requirements** (**FR**) as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们开发过程中分析阶段的一部分，这些功能被细化为以下**功能需求**（**FR**）列表：
- en: '**FR1**: The application presents a list of cats (composed by name and picture)
    to the end user.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FR1**：应用程序向最终用户呈现猫的列表（由名称和图片组成）。'
- en: '**FR2**: Each cat can be rated individually.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FR2**：每只猫都可以单独评分。'
- en: '**FR3**: The range for rating cats is an interval from `0.5` to `5` (stars).'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FR3**：对猫进行评分的范围是从`0.5`到`5`（星）的区间。'
- en: '**FR4**: Optionally to the numeric rate per cat, users shall include some comments.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FR4**：除了每只猫的数字评分外，用户还应包括一些评论。'
- en: '**FR5**: Each end user only shall rate each cat (comments and/or stars) once.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FR5**：每个最终用户只能对每只猫（评论和/或星级）评分一次。'
- en: Design
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计
- en: 'Since our application is quite simple, we decide to stop the analysis phase
    here, without modeling our requirements as use cases. Instead, we move on making
    a high-level architectural design of the web application using the classical three-tier
    model: presentation, application (or business) logic, and data tier. Regarding
    the application logic, as the following picture depicts, two components are needed.
    First one, called `CatService` is charge of all the rating actions as described
    in the requirements list. Second one, called `CookiesServices` is needed to handle
    HTTP Cookies, needed to implement FR5*:*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序相当简单，我们决定在这里停止分析阶段，而不将我们的需求建模为用例。相反，我们继续使用经典的三层模型对Web应用程序进行高层架构设计：表示层、应用（或业务）逻辑和数据层。关于应用逻辑，如下图所示，需要两个组件。第一个称为`CatService`负责所有在需求列表中描述的评分操作。第二个称为`CookiesServices`用于处理HTTP
    Cookies，需要实现FR5*：
- en: '![](img/00150.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: High-level architectural design for the application Rate my cat!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: “Rate my cat!”应用程序的高层架构设计
- en: 'At this stage, in the development, we are able to decide the major technologies
    implied in the implementation our application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们能够决定实现我们的应用程序所涉及的主要技术：
- en: '**Spring 5**: This will be the foundation framework for our application. Concretely,
    we use Spring MVC through Spring Boot to simplify the creation of our web application.
    Moreover, we use Spring Data JPA using a simple H2 database to persist the application
    data, and Thymeleaf ([http://www.thymeleaf.org/](http://www.thymeleaf.org/)) as
    template engine (for views in MVC). Finally, we also use the Spring Test module
    to make in-container integration tests in an easy way.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 5：这将是我们应用程序的基础框架。具体来说，我们使用Spring Boot通过Spring MVC简化我们的Web应用程序的创建。此外，我们使用Spring
    Data JPA使用简单的H2数据库来持久化应用程序数据，并使用Thymeleaf ([http://www.thymeleaf.org/](http://www.thymeleaf.org/))作为模板引擎（用于MVC中的视图）。最后，我们还使用Spring
    Test模块以简单的方式进行容器内集成测试。
- en: '**JUnit 5**: Of course, we cannot use a different testing framework than JUnit
    5 for our tests cases. Moreover, to improve the readability of our assertions
    we use Hamcrest.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit 5：当然，我们不能使用与JUnit 5不同的测试框架来进行我们的测试用例。此外，为了提高我们断言的可读性，我们使用Hamcrest。
- en: '**Mockito**: In order to implement unit test cases, we will use the Mockito
    framework, isolating the SUT from its DOCs in several out-of-container unit tests.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mockito：为了实现单元测试用例，我们将使用Mockito框架，在几个容器外的单元测试中将SUT与其DOCs隔离开来。
- en: '**Selenium WebDriver**: We will also implement different end-to-end tests using
    Selenium WebDriver to exercise our web application from JUnit 5 tests.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Selenium WebDriver：我们还将使用Selenium WebDriver实现不同的端到端测试，以便从JUnit 5测试中执行我们的Web应用程序。
- en: '**GitHub**: Our source code repository will be hosted in a public GitHub repository.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub：我们的源代码存储库将托管在公共GitHub存储库中。
- en: '**Travis CI**: Our test suite will be executed each time a new patch is committed
    to our GitHub repository.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Travis CI：我们的测试套件将在每次提交新补丁到我们的GitHub存储库时执行。
- en: '**Codecov**: To track the code coverage of our test suite we will use Codecov.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codecov：为了跟踪我们测试套件的代码覆盖率，我们将使用Codecov。
- en: '**SonarCloud**: To provide a complete assessment of the internal quality of
    our source code, we complement our test process with some automatic static analysis
    using SonarCloud.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SonarCloud：为了提供对我们源代码内部质量的完整评估，我们通过SonarCloud补充我们的测试过程进行一些自动静态分析。
- en: The screenshot here shows the application GUI in action. It is not the main
    objective of this section to dig deeper in the implementation specifics of the
    application. Visit the GitHub repository of the application on [https://github.com/bonigarcia/rate-my-cat](https://github.com/bonigarcia/rate-my-cat)
    for details about it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的屏幕截图显示了应用程序GUI的操作。本节的主要目标不是深入挖掘应用程序的实现细节。有关详细信息，请访问[https://github.com/bonigarcia/rate-my-cat](https://github.com/bonigarcia/rate-my-cat)上的应用程序的GitHub存储库。
- en: '![](img/00151.jpeg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: Screenshot of the application Rate my cat!
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序Rate my cat的屏幕截图！
- en: The pictures used to implement this example have been downloaded from the free
    images gallery available on [https://pixabay.com/](https://pixabay.com/).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用于实现此示例的图片已从[https://pixabay.com/](https://pixabay.com/)上的免费图库中下载。
- en: Tests
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: 'Let’s focus now on the JUnit 5 tests of this application. We implement three
    types of tests: unit, integration, and end to end. As introduced before, for the
    unit test, we use Mockito to exercise the SUT in isolation. We decide to unit
    test the two major components of our application (`CatService` and `CookiesServices`)
    using Java classes containing different JUnit 5 tests.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们专注于这个应用程序的JUnit 5测试。我们实现了三种类型的测试：单元测试、集成测试和端到端测试。如前所述，对于单元测试，我们使用Mockito来隔离SUT。我们决定使用包含不同JUnit
    5测试的Java类来对我们应用程序的两个主要组件（`CatService`和`CookiesServices`）进行单元测试。
- en: 'Consider the first test (called `RateCatsTest`). As can be seen the code, in
    this class we are defining the class `CatService` as the SUT (using the annotation
    `@InjectMocks`) and the class `CatRepository` (which is used by `CatService` with
    dependency injection) as the DOC (using the annotation `@Mock`). The first test
    of this class (`testCorrectRangeOfStars`) is an example of parameterized JUnit
    5 tests. The objective of this test if to assess the rate method inside `CatService`
    (method `rateCate`). In order to select the test data (input) for this test, we
    follow a black-box strategy and therefore we use the information of the requirements
    definition. Concretely, *FR3* states the range of stars to be used in the rating
    mechanism for cats. Following a boundary analysis approach, we select the edges
    of the input range, that is, 0.5 and 5\. The second test case (`testCorrectRangeOfStars`)
    also tests the same method (`rateCat`), but this time the test evaluates the SUT
    response when out-of-range inputs exercise the SUT (negative test scenario). Then,
    two more tests are implemented in this class, this time aimed to assess *FR4*
    (that is, using also comments to rate cats). Notice that we are using the JUnit
    5 `@Tag` annotation to identify each test with its corresponding requirement:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第一个测试（称为`RateCatsTest`）。如代码所示，在这个类中，我们将类`CatService`定义为SUT（使用注解`@InjectMocks`），将类`CatRepository`（由`CatService`使用依赖注入）定义为DOC（使用注解`@Mock`）。这个类的第一个测试（`testCorrectRangeOfStars`）是一个参数化的JUnit
    5测试的示例。这个测试的目标是评估`CatService`内的rate方法（方法`rateCate`）。为了选择这个测试的测试数据（输入），我们遵循黑盒策略，因此我们使用需求定义的信息。具体来说，*FR3*规定了用于评价猫的评分机制的星级范围。遵循边界分析方法，我们选择输入范围的边缘，即0.5和5。第二个测试用例（`testCorrectRangeOfStars`）也测试相同的方法（`rateCat`），但这次测试评估了SUT在超出范围的输入时的响应（负面测试场景）。然后，在这个类中实现了另外两个测试，这次旨在评估*FR4*（即，还使用评论来评价猫）。请注意，我们使用JUnit
    5的`@Tag`注解来标识每个测试及其相应的需求：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, unit test evaluates the cookies service (*FR5*). To that aim, the following
    test use the class `CookiesService` as SUT, and this time we are going to mock
    the standard Java object, which manipulates the HTTP Cookies, that is, `javax.servlet.http.HttpServletResponse`.
    Inspecting the source code of this test class, we can see that the first test
    method (called `testUpdateCookies`) exercise the service method `updateCookies`,
    verifying whether or not the format of the cookies is as expected. Next two tests
    (`testCheckCatInCookies` and `testCheckCatInEmptyCookies`) evaluates the method
    `isCatInCookies` of the service using a positive strategy (that is the input cat
    corresponds with the format of the cookie) and a negative one (the opposite case).
    Finally, the last two tests (`testUpdateOpinionsWithCookies` and `testUpdateOpinionsWithEmptyCookies`)
    exercise the method `updateOpinionsWithCookiesValue` of the SUT following the
    same approach, that is, checking the response of the SUT using a valid and empty
    cookie. All these tests have been implemented following a white-box strategy,
    since its test data and logic relies completely in the specific internal logic
    of the SUT (in this case how the cookies are formatted and managed).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，单元测试评估了cookies服务（*FR5*）。为此，以下测试使用`CookiesService`类作为SUT，这次我们将模拟标准的Java对象，即操作HTTP
    Cookies的`javax.servlet.http.HttpServletResponse`。检查此测试类的源代码，我们可以看到第一个测试方法（称为`testUpdateCookies`）练习了服务方法`updateCookies`，验证了cookies的格式是否符合预期。接下来的两个测试（`testCheckCatInCookies`和`testCheckCatInEmptyCookies`）评估了服务的`isCatInCookies`方法，使用了积极的策略（即输入猫与cookie的格式相对应）和消极的策略（相反的情况）。最后，最后两个测试（`testUpdateOpinionsWithCookies`和`testUpdateOpinionsWithEmptyCookies`）练习了SUT的`updateOpinionsWithCookiesValue`方法，遵循相同的方法，即使用有效和空cookie检查SUT的响应。所有这些测试都是按照白盒策略实施的，因为它的测试数据和逻辑完全依赖于SUT的特定内部逻辑（在这种情况下，cookie的格式和管理方式）。
- en: This test does not follow pure white-box approach in the sense of its objective
    is to exercise all the possible paths within the SUT. It can be seen as white-box
    in the sense of it has been designed directly linked to the implementation rather
    than the requirements.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试并不是按照纯白盒方法进行的，因为它的目标是在SUT内部练习所有可能的路径。它可以被视为白盒，因为它直接与实现相关联，而不是与需求相关联。
- en: '[PRE11]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s move on to the next type of tests: integration. For this type of test,
    we are going to use the in-container test capabilities provided by Spring. Concretely,
    we use the Spring test object `MockMvc` to evaluate the HTTP responses of our
    application from the client-side. In each test, different requests are exercised
    verifying if the responses (status code and content type) are as expected:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个类型的测试：集成测试。对于这种类型的测试，我们将使用Spring提供的容器内测试功能。具体来说，我们使用Spring测试对象`MockMvc`来评估我们的应用程序的HTTP响应是否符合客户端的预期。在每个测试中，不同的请求被练习，以验证响应（状态码和内容类型）是否符合预期：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, we also implement several end-to-end tests using Selenium WebDriver.
    Inspecting the implementation of this test, we can see that this test is using
    two JUnit 5 extensions at the same time: `SpringExtension` (to start/stop the
    Spring context within the JUnit 5 tests’ lifecycle) and `SeleniumExtension` (to
    inject WebDriver objects aimed to control web browsers in the test methods). In
    particular, we use three different browsers in one of the tests:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还使用Selenium WebDriver实施了几个端到端测试。检查此测试的实现，我们可以看到这个测试同时使用了两个JUnit 5扩展：`SpringExtension`（在JUnit
    5测试生命周期内启动/停止Spring上下文）和`SeleniumExtension`（在测试方法中注入WebDriver对象，用于控制Web浏览器）。特别是，在一个测试中我们使用了三种不同的浏览器：
- en: PhantomJS (headless browser), to assess is the list of cats is properly rendered
    in the web GUI (FR1).
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PhantomJS（无头浏览器），以评估猫的列表是否在Web GUI中正确呈现（FR1）。
- en: Chrome, to rate cats using through the application GUI (FR2).
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chrome，通过应用程序GUI对猫进行评分（FR2）。
- en: Firefox, to rate cats using the GUI but getting an error as a result (FR2).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firefox，使用GUI对猫进行评分，但结果出现错误（FR2）。
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In order to make easier the traceability of the test executions, in all the
    implemented test, we have selected meaningful test names using `@DisplayName`.
    In addition, for parameterized tests, we use the element name to refine the test
    name of each execution of the test, depending on the test input. The following
    screenshot of the execution of the test suite in Eclipse 4.7 (Oxygen):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易追踪测试执行，在所有实施的测试中，我们使用`@DisplayName`选择了有意义的测试名称。此外，对于参数化测试，我们使用元素名称来细化每次测试执行的测试名称，具体取决于测试输入。以下是在Eclipse
    4.7（Oxygen）中执行测试套件的屏幕截图：
- en: '![](img/00152.jpeg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00152.jpeg)'
- en: Execution of the test suite for the application Rate my cat! in Eclipse 4.7
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在Eclipse 4.7中执行应用程序“评价我的猫！”的测试套件
- en: As introduced before, we use Travis CI as build server to execute our tests
    during the development process. In the configuration of Travis CI (file `.travis.yml`),
    we setup two additional tools to enhance the development and test process of our
    application. On the one hand, Codecov provides a comprehensive test coverage report.
    On the other hand, SonarCloud provides a complete static analysis. Both tools
    are triggered by Travis CI as part of the continuous integration build process.
    As a result, we can evaluate both the coverage test and the internal code quality
    of our application (such as code smells, duplicated blocks, or technical debt)
    along with our development process.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用Travis CI作为构建服务器，在开发过程中执行我们的测试。在Travis CI的配置（文件`.travis.yml`）中，我们设置了两个额外的工具，以增强我们应用程序的开发和测试过程。一方面，Codecov提供了全面的测试覆盖报告。另一方面，SonarCloud提供了完整的静态分析。这两个工具都由Travis
    CI触发，作为持续集成构建过程的一部分。因此，我们可以评估应用程序的测试覆盖率和内部代码质量（如代码异味、重复块或技术债务），以及我们的开发过程。
- en: 'The following picture shows a screenshot of the online report provided by Codecov
    (the report provided by SonarCloud was presented in the previous section of this
    chapter):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图片显示了Codecov提供的在线报告的屏幕截图（SonarCloud提供的报告在本章的前一部分中呈现）：
- en: '![](img/00153.jpeg)\'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/00153.jpeg)\'
- en: Codecov report for the application Rate my cat!
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Codecov报告应用程序Rate my cat！
- en: 'Last but not least, we are using several *badges* in the `README` of our GitHub
    repository. Concretely, we add badges for Travis CI (status of the last build
    process), SonarCloud (status of the last analysis), and Codecov (percentage of
    the last code coverage analysis):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的是，我们在GitHub存储库的`README`中使用了几个*徽章*。具体来说，我们为Travis CI（最后构建过程的状态）、SonarCloud（最后分析的状态）和Codecov（最后代码覆盖分析的百分比）添加了徽章：
- en: '![](img/00154.jpeg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: GitHub badges for the application Rate my cat!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub应用程序Rate my cat！的徽章
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we reviewed several concerns about the management side of
    the testing activities. First, we learned that testing can be made in different
    parts of the software development process (software lifecycle) depending on the
    test methodology: BDD (acceptance tests are defined before the requirement analysis),
    TDD (tests are defined before the design of the system), TFD (tests are implemented
    after the system design), and TLD (tests are implemented after the system implementation).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了测试活动管理方面的几个问题。首先，我们了解到测试可以在软件开发过程（软件生命周期）的不同部分进行，这取决于测试方法论：BDD（在需求分析之前定义验收测试），TDD（在系统设计之前定义测试），TFD（在系统设计之后实现测试）和TLD（在系统实现之后实现测试）。
- en: 'CI is a process more and more used in software development. It consists on
    the automated build and test of a codebase. This process is typically triggered
    with a new commit in a source code repository, such as GitHub, GitLab, or Bitbucket.
    CI is extended to Continuous Delivery (when releases are made to development environment)
    and to Continuous Deployment (when deployment to production environment is made
    continuously). We reviewed two of the most used build servers nowadays: Jenkins
    (*CI as a Service*) and Travis (in-premises).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: CI是在软件开发中越来越多地使用的一个过程。它包括对代码库的自动构建和测试。这个过程通常是由源代码存储库中的新提交触发的，比如GitHub、GitLab或Bitbucket。CI扩展到持续交付（当发布到开发环境）和持续部署（当不断地部署到生产环境）。我们回顾了当今最常用的两个构建服务器：Jenkins（*CI作为服务*）和Travis（内部）。
- en: There some other tools that can be used to improve the management of tests,
    for example, reporting tools (such as Maven Surefire Report or Allure) or defect
    tracking systems (such as JIRA, Bugzilla, Redmine, MantisBT, and GitHub issues).
    Automated static analysis is a great complement to testing, for example, using
    linters such as Checkstyle, FindBugs, PMD, or SonarQube, and also peer review
    tools such as Collaborator, Crucible, Gerrit, and GitHub pull requests reviews.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些其他工具可以用来改进测试的管理，例如报告工具（如Maven Surefire Report或Allure）或缺陷跟踪系统（如JIRA、Bugzilla、Redmine、MantisBT和GitHub问题）。自动静态分析是测试的一个很好的补充，例如使用诸如Checkstyle、FindBugs、PMD或SonarQube之类的代码检查工具，以及同行审查工具，如Collaborator、Crucible、Gerrit和GitHub拉取请求审查。
- en: To close this book, the final section of this chapter presents a complete web
    application (named *Rate my cat!*) and its corresponding JUnit 5 tests (unit,
    integration, and end-to-end). It consists on a web applications developed and
    assessed using different technologies presented throughout the book, namely, Spring,
    Mockito, Selenium, Hamcrest, Travis CI, Codecov, and SonarCloud.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了结束这本书，本章的最后一部分介绍了一个完整的Web应用程序（名为*Rate my cat!*）及其相应的JUnit 5测试（单元测试、集成测试和端到端测试）。它包括使用本书中介绍的不同技术开发和评估的Web应用程序，即Spring、Mockito、Selenium、Hamcrest、Travis
    CI、Codecov和SonarCloud。
