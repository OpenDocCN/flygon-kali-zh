- en: '*Chapter 9*: Learning Java Methods'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：学习Java方法'
- en: As we are starting to get comfortable with Java programming, in this chapter
    we will take a closer look at methods because although we know that you can **call**
    them to make them execute their code, there is more to them than we have discussed
    so far.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始逐渐熟悉Java编程，在本章中，我们将更仔细地研究方法，因为尽管我们知道可以**调用**它们来执行它们的代码，但它们比我们迄今讨论的更多。
- en: 'In this chapter, we will look at the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下内容：
- en: Method structure
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法结构
- en: Method overloading versus overriding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载与覆盖
- en: A method demo mini-app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个方法演示迷你应用程序
- en: How methods affect our variables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法如何影响我们的变量
- en: Method recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法递归
- en: First, let's go through a quick method recap.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们快速回顾一下方法。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中的代码文件[https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009](https://github.com/PacktPublishing/Android-Programming-for-Beginners-Third-Edition/tree/main/chapter%2009)。
- en: Methods revisited
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法重温
- en: 'This figure sums up where our understanding of methods is at the moment:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图总结了我们对方法的理解：
- en: '![Figure 9.1 – Understanding methods'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – 理解方法'
- en: '](img/Figure_9.1_B16773.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.1_B16773.jpg)'
- en: Figure 9.1 – Understanding methods
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 理解方法
- en: As we can see in the figure, there are still a couple of question marks around
    methods. We will totally take the lid off methods and see how they work and what
    exactly the other parts of the method are doing later in the chapter. In [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming,*
    and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More Object-Oriented
    Programming*, we will clear up the last few parts of the mystery of methods while
    discussing object-oriented programming.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图中所看到的，关于方法还有一些疑问。我们将彻底揭开方法的面纱，看看它们是如何工作的，以及方法的其他部分到底在做什么，这将在本章后面讨论。在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*和[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*，更多面向对象编程*中，我们将在讨论面向对象编程时澄清方法的最后几个部分的神秘之处。
- en: What exactly are Java methods?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 究竟什么是Java方法？
- en: A method is a collection of variables, expressions, and control flow statements
    bundled together inside an opening and closing curly brace preceded by a **signature**.
    We have already been using lots of methods, but we just haven't looked very closely
    at them yet.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是一组变量、表达式和控制流语句，它们被捆绑在一个以**签名**为前缀的大括号内。我们已经使用了很多方法，但我们还没有仔细地看过它们。
- en: Let's start with the method structure.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从方法结构开始。
- en: Method structure
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法结构
- en: 'The first part of a method that we write is called the signature. Here is a
    hypothetical method signature:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的方法的第一部分称为签名。这是一个假设的方法签名：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If we add an opening and closing pair of curly braces, `{}`, with some code
    that the method performs, then we have a complete method – a **definition**. Here
    is another made up yet syntactically correct method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一对大括号`{}`，并加入一些方法执行的代码，那么我们就有了一个完整的方法——一个**定义**。这是另一个虚构的但在语法上是正确的方法：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As we have seen, we could then use our new method from another part of our
    code like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们可以从代码的其他部分使用我们的新方法，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the point where we call the `setCoordinates` method, our program's execution
    would branch to the code contained within that method. The method would execute
    all the statements inside it, step by step, until it reaches the end, and then
    return control to the code that called it, or sooner if it hits a `return` statement.
    Then, the code would continue running from the first line after the method call.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们调用`setCoordinates`方法的时候，我们程序的执行将分支到该方法内部包含的代码。该方法将逐步执行其中的所有语句，直到达到结束，然后将控制返回给调用它的代码，或者如果它遇到`return`语句，则更早地返回。然后，代码将从方法调用后的第一行继续运行。
- en: 'Here is another example of a method complete with the code to make the method
    return to the code that called it:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个完整的方法示例，包括使方法返回到调用它的代码的代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The call to use the preceding method could look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面方法的调用可能如下所示：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Clearly, we don't need to write methods to add two `int` variables together,
    but the example helps us see a little more into the workings of methods. First,
    we pass in the values `2` and `4`. In the method signature, the value `2` is assigned
    to `int a` and the value `4` is assigned to `int b`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要编写方法来将两个“int”变量相加，但这个例子帮助我们更深入地了解方法的工作原理。首先，我们传入值`2`和`4`。在方法签名中，值`2`被赋给`int
    a`，值`4`被赋给`int b`。
- en: Within the method body, the variables `a` and `b` are added together and used
    to initialize the new variable, `int answer`. The line `return answer` returns
    the value stored in `answer` to the calling code, causing `myAnswer` to be initialized
    with the value `6`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法体内，变量`a`和`b`被相加，并用于初始化新变量`int answer`。行`return answer`将存储在`answer`中的值返回给调用代码，导致`myAnswer`被初始化为值`6`。
- en: Notice that each of the method signatures in the preceding examples varies a
    little. The reason for this is the Java method signature is quite flexible, allowing
    us to build exactly the methods we need.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面示例中的每个方法签名都有所不同。这是因为Java方法签名非常灵活，允许我们精确地构建我们需要的方法。
- en: Exactly how the method signature defines how the method must be called and how
    the method must return a value deserves further discussion.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 方法签名确切地定义了方法如何被调用以及方法如何返回值，这值得进一步讨论。
- en: Let's give each part of the signature a name so we can break it up into pieces
    and learn about the parts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们给签名的每个部分起一个名字，这样我们就可以把它分成几部分，并了解这些部分。
- en: 'The following bolded text is a method signature with its parts labeled up ready
    for discussion. Also, have a look at the table that follows the bolded text to
    further clarify which part of the signature is which. This will make the rest
    of our discussion on methods straightforward:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下加粗的文本是一个方法签名，其部分已经标记好以便讨论。另外，看一下接下来的表格，以进一步澄清签名的哪一部分是哪一部分。这将使我们对方法的讨论更加简单明了：
- en: '**modifier** | **return-type** | **name of method (parameters)**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**修饰符** | **返回类型** | **方法名称（参数）**'
- en: '![](img/B16773_09_Table_1.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16773_09_Table_1.jpg)'
- en: Modifier
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修饰符
- en: In our earlier examples, we only used a modifier in a couple of examples, partly
    because the method doesn't have to use a modifier. The modifier is a way of specifying
    what code can use (call) your method, by using modifiers such as `public` and
    `private`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们只在一些例子中使用了修饰符，部分原因是方法不必使用修饰符。修饰符是一种指定代码可以使用（调用）你的方法的方式，通过使用`public`和`private`等修饰符。
- en: 'Variables can have modifiers too, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 变量也可以有修饰符，如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Modifiers (for methods and variables) are an essential Java topic, but they
    are best dealt with when we are discussing the other vital Java topic we have
    skirted around a few times already – classes. We will do so in the next chapter.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符（用于方法和变量）是一个重要的Java主题，但最好在我们讨论其他重要的Java主题时处理，这些主题我们已经在几次中绕过了 - 类。我们将在下一章中这样做。
- en: Return type
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回类型
- en: 'Next in the table is the return type. Like a modifier, a return type is optional.
    So, let''s look at it a bit closer. We have seen that our methods do anything
    we can code in Java. But what if we need the results from what a method has done?
    The simplest example of a return type we have seen so far is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的下一个是返回类型。像修饰符一样，返回类型是可选的。所以，让我们仔细看一下。我们已经看到我们的方法可以做任何我们可以用Java编码的事情。但是如果我们需要方法所做的结果呢？到目前为止，我们所见过的返回类型的最简单的例子如下：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the return type in the signature is highlighted. The return type is an
    `int`. The `addAToB` method sends back (returns) to the code that called it a
    value that will fit in an `int` variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，签名中的返回类型被突出显示。返回类型是`int`。`addAToB`方法将一个值返回给调用它的代码，这个值将适合在一个`int`变量中。
- en: The return type can be any Java type we have seen so far. However, the method
    does not have to return a value at all. When the method does not return a value,
    the signature must use the `void` keyword as the return type. When the `void`
    keyword is used, the method body must not try to return a value as this will cause
    a compiler error. It can, however, use the `return` keyword without a value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 返回类型可以是我们到目前为止所见过的任何Java类型。然而，方法不一定要返回一个值。当方法不返回值时，签名必须使用`void`关键字作为返回类型。当使用`void`关键字时，方法体不得尝试返回一个值，否则会导致编译错误。但是，它可以使用没有值的`return`关键字。
- en: 'Here are some combinations of the return type and use of the `return` keyword
    that are valid:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些返回类型和使用`return`关键字的有效组合：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another combination is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个组合如下：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following code is yet another combination:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是另一个组合：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We could call each of the preceding methods in turn like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以依次调用前面的每个方法，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code would execute all the code in each method in turn.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将依次执行每个方法中的所有代码。
- en: Name of the method
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法的名称
- en: 'Next in the table is the name of the method. When we design our own methods,
    the method name is arbitrary. But it is the convention to use verbs that clearly
    explain what the method will do. Also, use the convention of the first letter
    of the first word of the name being lowercase and the first letter of any later
    words being uppercase. This is called camel case, as we learned while learning
    about variable names. Consider this next example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的下一个是方法的名称。当我们设计自己的方法时，方法名是任意的。但是惯例是使用清楚解释方法将要做什么的动词。此外，使用名称的第一个单词的第一个字母小写，后面的单词的第一个字母大写的约定。这被称为驼峰命名法，就像我们在学习变量名时学到的那样。考虑下一个例子：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding method is perfectly legitimate and will work; however, let''s
    look at three much clearer examples that use these conventions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法是完全合法的，并且可以工作；然而，让我们看看使用这些约定的三个更清晰的例子：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is much clearer as the names make it obvious what the methods will do.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更清晰，因为名称明确表明了方法将要做什么。
- en: Let's have a look at the parameters in methods.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看方法中的参数。
- en: Parameters
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数
- en: The final topic in the table is **parameters**. We know that a method can return
    a result to the calling code. But what if we need to share some data values *from*
    the calling code *with* the method?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的最后一个主题是**参数**。我们知道方法可以将结果返回给调用代码。但是如果我们需要从调用代码中*向*方法*共享*一些数据值呢？
- en: 'Parameters allow us to send values into the called method. We have already
    seen an example with parameters when we looked at return types. We will look at
    the same example but a little more closely at the parameters:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 参数允许我们将值发送到被调用的方法中。当我们查看返回类型时，我们已经看到了一个带有参数的例子。我们将看同样的例子，但更仔细地看一下参数：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the parameters are highlighted. Parameters are contained in parentheses,
    `(parameters go here)`, immediately after the method name.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，参数被突出显示。参数包含在括号中，`(参数放在这里)`，紧跟在方法名之后。
- en: 'Notice that in the first line of the method body, we use `a + b` as if they
    are already declared and initialized variables. That is because they are. The
    parameters of the method signature are their declaration and the code that calls
    the method initializes them, as highlighted in the next line of code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在方法体的第一行中，我们使用`a + b`，就好像它们已经被声明和初始化为变量一样。那是因为它们是。方法签名的参数是它们的声明，调用方法的代码初始化它们，就像下一行代码中突出显示的那样。
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Also, as we have partly seen in earlier examples, we don't have to just use
    `int` in our parameters. We can use any Java type, including types we design ourselves.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，正如我们在之前的例子中部分看到的，我们不仅仅在参数中使用`int`。我们可以使用任何Java类型，包括我们自己设计的类型。
- en: 'What is more, we can mix and match types as well. We can also use as many parameters
    as is necessary to solve our problem. An example might help:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也可以混合和匹配类型。我们还可以使用尽可能多的参数来解决我们的问题。一个例子可能会有所帮助。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding example would have four declared and initialized variables that
    are ready to use.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子将有四个声明和初始化的变量，准备好使用。
- en: Now we will look at the method body – what goes inside the method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看方法主体——放在方法内部的内容。
- en: The body
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主体
- en: 'In our previous examples, we have been pseudo-coding our method bodies with
    comments such as the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，我们一直在伪代码中使用注释来描述我们的方法主体，比如以下的注释：
- en: '[PRE16]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following has also been used:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 还有以下的用法：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `addToAddressBook` method has also been used:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`addToAddressBook`方法也被使用了。'
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: But we know exactly what to do in the body already. Any Java syntax we have
    learned about so far will work in the body of a method. In fact, if we think back,
    all the code we have written in this book so far *has* been in a method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们已经完全知道主体中要做的事情。到目前为止，我们学到的任何Java语法都可以在方法的主体中使用。事实上，如果我们回想一下，到目前为止我们在本书中编写的所有代码都*已经*在一个方法中。
- en: The best thing we can do next is to write a few methods that do something in
    the body.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来可以做的最好的事情是编写一些在主体中执行操作的方法。
- en: Using method demo apps
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用方法演示应用程序
- en: Here we will quickly build two apps to explore methods a bit further. First,
    we will explore the fundamentals with the `Real World Methods` app, and then we
    will glimpse a new topic, `Exploring Method Overloading` app.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将快速构建两个应用程序，以进一步探索方法。首先，我们将使用`Real World Methods`应用程序探索基础知识，然后我们将一窥新主题，`Exploring
    Method Overloading`应用程序。
- en: As usual, you can open the ready-typed code files in the usual way. The next
    two examples of methods can be found in the download bundle in the [*Chapter 9*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)
    folder and the `Real World Methods` and `Exploring Method Overloading` sub-folders.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，您可以以通常的方式打开已经输入的代码文件。下面的两个方法示例可以在[*第9章*](B16773_09_ePub_RK.xhtml#_idTextAnchor169)文件夹和`Real
    World Methods`和`Exploring Method Overloading`子文件夹中的下载包中找到。
- en: Real-world methods
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真实世界的方法
- en: First, let's make ourselves some simple working methods complete with return
    type parameters and fully functioning bodies.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一些简单的工作方法，包括返回类型参数和完全运作的主体。
- en: To get started, create a new Android project called `Real World Methods`, use
    the `MainActivity.java` file by left-clicking the **MainActivity.java** tab above
    the editor and we can start coding.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，创建一个名为`Real World Methods`的新Android项目，使用`MainActivity.java`文件，通过在编辑器上方的**MainActivity.java**标签上单击左键，我们可以开始编码。
- en: 'First, add these three methods to the `MainActivity` class. Add them just after
    the closing curly brace, `}`, of the `onCreate` method:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将这三个方法添加到`MainActivity`类中。将它们添加到`onCreate`方法的闭合大括号`}`后面。
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The first method we added is called `joinThese`. It will return a `String` value
    and needs three `String` variables passed into it. In the method body, there is
    only one line of code. The `return a + b + c` code will concatenate the three
    strings that are passed into it and return the joined strings as the result.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的第一个方法叫做`joinThese`。它将返回一个`String`值，并需要传入三个`String`变量。在方法主体中，只有一行代码。`return
    a + b + c`代码将连接传入的三个字符串，并将连接后的字符串作为结果返回。
- en: The next method, named `getAreaCircle`, takes a `float` variable as an argument
    and then returns a `float` variable too. The body of the method simply uses the
    formula for the area of a circle, incorporating the passed-in radius, and then
    returns the answer to the calling code. The odd-looking `f` on the end of `3.141`
    is to let the compiler know that the number is of the `float` type. Any floating-point
    number is assumed to be of the `double` type unless it has the trailing `f`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法名为`getAreaCircle`，接受一个`float`变量作为参数，然后也返回一个`float`变量。方法的主体简单地使用了圆的面积公式，结合传入的半径，然后将答案返回给调用代码。`3.141`末尾的奇怪的`f`是为了让编译器知道这个数字是`float`类型的。任何浮点数都被假定为`double`类型，除非它有尾随的`f`。
- en: The third and final method is the simplest of all the methods. Notice that it
    doesn't return anything; it has a `void` return type. We have included this method
    to make clear an important point that we want to remember about methods. But let's
    see it in action before we talk about it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个和最后一个方法是所有方法中最简单的。请注意，它不返回任何东西；它有一个`void`返回类型。我们包括了这个方法，以明确一个我们想要记住关于方法的重要观点。但在我们讨论它之前，让我们看看它的实际操作。
- en: 'Now, in the `onCreate` method, after the call to the `setContentView` method,
    add this code, which calls our three new methods and then outputs some text to
    the logcat window:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`onCreate`方法中，在调用`setContentView`方法之后，添加这段代码，调用我们的三个新方法，然后在logcat窗口中输出一些文本：
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the app and see the output in the logcat window, which is provided here
    for your convenience:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序，查看logcat窗口中的输出，这里为您提供方便：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the logcat output, the first thing we can see is the value of the `joinedString`
    string. As expected, it is the concatenation of the three words we passed into
    the `joinThese` method.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在logcat输出中，我们可以看到的第一件事是`joinedString`字符串的值。正如预期的那样，它是我们传入`joinThese`方法的三个单词的连接。
- en: Next, we can see that `getAreaCircle` has indeed calculated and returned the
    area of a circle based on the length of the radius passed in.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到`getAreaCircle`确实计算并返回了基于传入半径的圆的面积。
- en: The fact that the `a` variable still holds the value `0` even after it has been
    passed into the `changeA` method deserves a separate discussion.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`变量即使在传入`changeA`方法后仍保持值`0`的事实，值得单独讨论。'
- en: Discovering variable scope
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发现变量范围
- en: 'The final line of output is most interesting: `a=: 0`. In the `onCreate` method,
    we declared and initialized `int a` to `0`, and then we called the `changeA` method.
    In the body of `changeA`, we incremented `a` with the code `a++`. Yet, back in
    the `onCreate` method, we see that when we use the `Log.i` method to print the
    value of `a` to the logcat window, it is still **0**.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '输出的最后一行最有趣：`a=: 0`。在`onCreate`方法中，我们声明并初始化了`int a`为`0`，然后调用了`changeA`方法。在`changeA`的主体中，我们用代码`a++`增加了`a`。然而，在`onCreate`方法中，当我们使用`Log.i`方法将`a`的值打印到logcat窗口时，它仍然是**0**。'
- en: So, when we passed in `a` to the `changeA` method, we were actually passing
    the *value* *stored in* *a* not the *actual variable* *a*. This is referred to
    as passing by value in Java.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们将`a`传递给`changeA`方法时，实际上传递的是存储在`a`中的*值*，而不是*实际变量*`a`。这在Java中被称为按值传递。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: When we declare a variable in a method, it can only be *seen* in that method.
    When we declare a variable in another method, even if it has the exact same name,
    it is *not* the same variable. A variable only has **scope** within the method
    it was declared.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在一个方法中声明一个变量时，它只能在该方法中被*看到*。当我们在另一个方法中声明一个变量时，即使它具有完全相同的名称，它也*不是*同一个变量。变量只在声明它的方法内部具有**作用域**。
- en: With all primitive variables, this is how passing them to methods works. With
    reference variables, it works slightly differently and we will see how in the
    next chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有基本变量，将它们传递给方法的工作方式是这样的。对于引用变量，它的工作方式略有不同，我们将在下一章中看到。
- en: Important Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: I have talked about this scope concept with a number of people new to Java.
    To some, it seems blindingly obvious, even natural. To others, however, it is
    a cause of constant confusion. Should you fall into the latter category, don't
    worry, because we will talk a bit more about this later in this chapter, and in
    future chapters, we will go into greater depth with exploring scope and make sure
    it is no longer an issue.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经和一些刚接触Java的人谈过这个作用域概念。对一些人来说，这似乎是显而易见的，甚至是自然的。然而，对于其他人来说，这是一个持续困惑的原因。如果你属于后一种情况，不要担心，因为我们将在本章稍后再谈一些关于这个问题的内容，而在未来的章节中，我们将更深入地探讨作用域，并确保它不再是一个问题。
- en: Let's look at another practical example of methods and learn something new at
    the same time.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个关于方法的另一个实际例子，并同时学到一些新东西。
- en: Exploring method overloading
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索方法重载
- en: As we are beginning to realize, methods are quite deep as a topic. But hopefully,
    by taking them a step at a time, we will see that they are not daunting in any
    way. We will also be returning to methods in the next chapter. For now, let's
    create a new project to explore the topic of **method overloading**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们开始意识到，方法作为一个主题是相当深入的。但希望通过一步一步地学习，我们会发现它们并不令人畏惧。我们也将在下一章回到方法。现在，让我们创建一个新项目来探索**方法重载**的主题。
- en: Create a new `Exploring Method` `Overloading`, then we will get on with writing
    three methods, but with a slight twist.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`探索方法重载`，然后我们将继续编写三个方法，但稍微有些不同。
- en: As we will soon see, we can create more than one method with the same name provided
    that the parameters are different. The code in this project is simple. It is how
    it works that might appear slightly curious until we analyze it after.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将很快看到的，我们可以创建多个具有相同名称的方法，只要参数不同。这个项目中的代码很简单。它的工作方式可能看起来有点奇怪，直到我们分析它之后。
- en: In the first method, we will simply call it `printStuff` and pass in an `int`
    variable via a parameter to be printed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个方法中，我们将简单地称之为`printStuff`，并通过参数传递一个`int`变量进行打印。
- en: 'Insert this method after the closing `}` of the `onCreate` method but before
    the closing `}` of the `MainActivity` class. Remember to import the `Log` class
    in the usual way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将此方法插入在`onCreate`方法的`}`之后，但在`MainActivity`类的`}`之前。记得以通常的方式导入`Log`类：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In this second method, we will also call it `printStuff` but pass in a `String`
    variable to be printed. Insert this method after the closing `}` of the `onCreate`
    method but before the closing `}` of the `MainActivity` class:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个方法中，我们还将称之为`printStuff`，但传入一个`String`变量进行打印。将此方法插入在`onCreate`方法的`}`之后，但在`MainActivity`类的`}`之前：
- en: '[PRE23]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In this third method, we will call it `printStuff` yet again but pass in a
    `String` variable and an `int` value to be printed. Insert this method after the
    closing `}` of `onCreate` but before the closing `}` of the `MainActivity` class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这第三个方法中，我们将再次称之为`printStuff`，但传入一个`String`变量和一个`int`值进行打印。将此方法插入在`onCreate`的`}`之后，但在`MainActivity`类的`}`之前：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, insert this code just before the closing `}` of the `onCreate` method
    to call the methods and print some values to the logcat window:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`onCreate`方法的`}`之前插入这段代码，以调用方法并将一些值打印到logcat窗口：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can run the app on the emulator or a real device. Here is the output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在模拟器或真实设备上运行应用程序。这是输出：
- en: '[PRE26]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, Java has treated three methods with the same name as different
    methods. This, as we have just shown, can be useful. It is called **method overloading**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Java将具有相同名称的三个方法视为不同的方法。正如我们刚刚展示的那样，这是有用的。这被称为**方法重载**。
- en: Method overloading and overriding confusion
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 方法重载和覆盖的混淆
- en: '**Overloading** is when we have more than one method with the same name but
    different parameters.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**重载**是指当我们有多个具有相同名称但不同参数的方法时。'
- en: '**Overriding** is when we replace a method with the same name and the same
    parameter list.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖**是指用相同的名称和参数列表替换一个方法。'
- en: We know enough about overloading and overriding to complete this book; but if
    you are brave and your mind is wandering, yes, you can override an overloaded
    method, but that is something for another time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对重载和覆盖已经了解足够，可以完成这本书；但如果你勇敢而且思绪飘忽，是的，你可以覆盖一个重载的方法，但这是另一个时间的事情。
- en: 'This is how it all works. In each of the steps where we wrote code, we created
    a method called `printStuff`. But each `printStuff` method has different parameters,
    so each is actually a different method that can be called individually:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理。在我们编写代码的每个步骤中，我们创建了一个名为`printStuff`的方法。但是每个`printStuff`方法都有不同的参数，因此实际上是可以单独调用的不同方法：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The body of each of the methods is trivial and just prints out the passed-in
    parameters and confirms which version of the method is being called.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法的主体都是微不足道的，只是打印出传入的参数，并确认调用的方法版本。
- en: 'The next important part of our code is when we make it plain which version
    of the method we mean to call by using the specific arguments that match the parameters
    in the signature. In the final step, we call each method in turn, using the matching
    parameters so that Java knows the exact method required:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的下一个重要部分是当我们明确指出要调用的方法版本，使用与签名中参数匹配的特定参数。在最后一步，我们依次调用每个方法，使用匹配的参数，这样Java就知道需要调用的确切方法：
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We now know all we need to know about methods, so let's take a quick second
    look at the relationship between methods and variables. Then, we'll get our heads
    around this scope phenomenon a bit more.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道关于方法的所有需要知道的东西，让我们快速再看一下方法和变量之间的关系。然后，我们会更深入地了解这个作用域现象。
- en: Scope and variables revisited
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新访问作用域和变量
- en: You might remember in the `Real World Methods` project the slightly disturbing
    anomaly was that variables in one method were not apparently the same as those
    from another even if they do have the same name. If you declare a variable in
    a method, whether that is one of the life cycle methods or one of our own methods,
    it can only be used within that method.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得在`真实世界方法`项目中，稍微令人不安的异常是，一个方法中的变量似乎与另一个方法中的变量不同，即使它们有相同的名称。如果你在一个方法中声明一个变量，无论是生命周期方法还是我们自己的方法，它只能在该方法内使用。
- en: 'It is no use if we do this in `onCreate`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在`onCreate`中这样做是没有用的：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'And then, following that, we try to do this in `onPause` or some other method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`onPause`或其他方法中，我们尝试这样做：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We will get an error because `a` is only visible within the method it was declared.
    At first, this might seem like a problem, but surprisingly, it is actually an
    especially useful feature of Java.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会得到一个错误，因为`a`只在它声明的方法中可见。起初，这可能看起来像是一个问题，但令人惊讶的是，这实际上是Java的一个特别有用的特性。
- en: I have already mentioned that the term used to describe this is **scope**. A
    variable is said to be in scope when it is usable and out of scope when it is
    not. The topic of scope is best discussed along with classes, and we will do so
    in [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented
    Programming,* and [*Chapter 11*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*, More
    Object-Oriented Programming*, but as a sneak look at what lies ahead, you might
    like to know that a class can have its very own variables and when it does, they
    have scope for the whole class; that is, all its methods can "see" and use them.
    We call them **member** variables or **fields**.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经提到用来描述这一点的术语是**作用域**。当变量可用时，就说它在作用域内，当不可用时，就说它不在作用域内。作用域的主题最好与类一起讨论，我们将在[*第10章*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*，面向对象编程*和[*第11章*](B16773_11_ePub_RK.xhtml#_idTextAnchor201)*，更多面向对象编程*中这样做，但是作为对未来的一瞥，你可能想知道一个类可以有自己的变量，当它有时，它们对整个类都有作用域；也就是说，所有的方法都可以“看到”并使用它们。我们称它们为**成员**变量或**字段**。
- en: 'To declare a member variable, you simply use the usual syntax after the start
    of the class, outside of any method declared in the class. Say our app started
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个成员变量，只需在类的开始之后使用通常的语法，在类中声明的任何方法之外。假设我们的应用程序像这样开始：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We could use `mSomeVariable` anywhere, inside any method in this class. Our
    new variable, `mSomeVariable`, has `m` to the variable name simply to remind us
    when we see it that it is a **member** variable. This is not required by the compiler,
    but it is a useful convention.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在这个类的任何方法中使用`mSomeVariable`。我们的新变量`mSomeVariable`只是为了提醒我们它是一个**成员**变量，所以在变量名中加上了`m`。这不是编译器要求的，但这是一个有用的约定。
- en: Let's look at one more method topic before we move on to classes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讲解类之前，让我们再看一个方法的主题。
- en: Method recursion
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法递归
- en: Method recursion is when a method calls itself. This might at first seem like
    something that happens by mistake but is an efficient technique for solving some
    programming problems.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 方法递归是指一个方法调用自身。这乍一看可能像是一个错误，但实际上是解决一些编程问题的有效技术。
- en: 'Here is some code that shows a recursive method in its most basic form:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码展示了一个递归方法的最基本形式：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we call the `recursiveMethod` method, its only line of code will then call
    itself, which will then call itself, which will then call itself, and so on. This
    process will go on forever until the app crashes, giving the following error in
    Logcat:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`recursiveMethod`方法，它的唯一代码行将调用自身，然后再调用自身，然后再调用自身，依此类推。这个过程将永远持续下去，直到应用程序崩溃，在Logcat中会出现以下错误：
- en: '[PRE33]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When the method is called, its instructions are moved to an area of the processor
    called the stack, and when it returns, its instructions are removed. If the method
    never returns and yet more and more copies of the instructions are added, eventually
    the stack will run out of memory (or overflow) and we get `StackOverflowError`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法被调用时，它的指令被移动到处理器的一个区域，称为堆栈，当它返回时，它的指令被移除。如果方法从不返回，而是不断添加更多的指令副本，最终堆栈将耗尽内存（或溢出），我们会得到`StackOverflowError`。
- en: 'We can attempt to visualize the first four method calls using the next screenshot.
    Also, in the next screenshot, I have crossed out the call to the method to show
    that if we were able to, at some point, prevent the method call, eventually all
    the methods would return and be cleared from the stack:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试使用下一个截图来可视化前四个方法调用。此外，在下一个截图中，我划掉了对方法的调用，以显示如果我们能够在某个时刻阻止方法调用，最终所有的方法都将返回并从堆栈中清除：
- en: '![Figure 9.2 – Method calls'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 - 方法调用'
- en: '](img/Figure_9.2_B16773.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.2_B16773.jpg)'
- en: Figure 9.2 – Method calls
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 - 方法调用
- en: 'To make our recursive methods worthwhile, we need to enhance two aspects. We
    will look at the second aspect shortly. First and most obviously, we need to give
    it a purpose. How about we ask our recursive method to sum (add up) the values
    of numbers in a range from 0 to a given target value, say 10, 100, or more? Let''s
    modify the preceding method by giving it this new purpose and renaming it accordingly.
    We will also add a variable with class scope (outside the method) called `answer`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的递归方法有价值，我们需要增强两个方面。我们将很快看到第二个方面。首先，最明显的是，我们需要给它一个目的。我们可以让我们的递归方法求和（相加）从0到给定目标值（比如10、100或更多）范围内的数字的值。让我们通过给它这个新目的并相应地重命名它来修改前面的方法。我们还将添加一个具有类范围（在方法之外）的变量`answer`：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now we have a method called `computeSum` that takes an `int` as a parameter.
    If we wanted to compute the sum of all the digits between 0 and 10, we could call
    the method like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个名为`computeSum`的方法，它以一个`int`作为参数。如果我们想要计算0到10之间所有数字的总和，我们可以这样调用该方法：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here are the values of the `answer` variable at each function call:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个函数调用时`answer`变量的值：
- en: 'First call of `computeSum`: `answer` = 10'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`computeSum`：`answer` = 10
- en: 'Second call of `computeSum`: `answer` = 19'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次调用`computeSum`：`answer` = 19
- en: …
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: …
- en: 'Tenth call of `computeSum`: `answer` = 55'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第十次调用`computeSum`：`answer` = 55
- en: Apparent success – until you realize that the method continues to call itself
    beyond the `target` variable reaching 0\. In fact, we still have the same problem
    as our first recursive method and after tens of thousands of method calls, the
    app will crash with `StackOverflowError` again.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看成功 - 直到你意识到该方法在`target`变量达到0之后仍然继续调用自身。事实上，我们仍然面临着第一个递归方法的相同问题，经过数万次方法调用后，应用程序将再次崩溃并出现`StackOverflowError`。
- en: 'What we need is a way to stop the method calling itself once `target` is equal
    to 0\. The way we solve this problem is to check whether the value of `target`
    is 0 and if it is, we quit calling the method. Have a look at the additional highlighted
    code shown next:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来阻止方法在`target`等于0时继续调用自身。我们解决这个问题的方法是检查`target`的值是否为0，如果是，我们就停止调用该方法。看看下面显示的额外突出显示的代码：
- en: '[PRE36]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We have used an `if` statement to check whether the target variable is greater
    than 0\. We also have an additional `Log.d` code to output the value of `answer`
    when the method has been called for the last time. See whether you can work out
    what is happening before reading the explanation following the output.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`if`语句来检查目标变量是否大于0。当方法被最后一次调用时，我们还有额外的`Log.d`代码来输出`answer`的值。在阅读输出后的解释之前，看看你能否弄清楚发生了什么。
- en: 'The output of calling `computeSum(10)` would be as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`computeSum(10)`的输出如下：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`if(target > 0)` tells the code to first check whether the `target` variable
    is above 0\. If it is, only then does it call the method again and pass in the
    value of `target – 1`. If it isn''t, then it stops the whole process.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(target > 0)`告诉代码首先检查`target`变量是否大于0。如果是，然后才调用方法并传入`target - 1`的值。如果不是，那么它就停止整个过程。'
- en: Important Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We won't be using method recursion in this book, but it is an interesting concept
    to understand.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在本书中使用方法递归，但这是一个有趣的概念需要理解。
- en: We know more than enough about methods to complete all the projects in the book.
    Let's have a quick recap with some questions and answers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对方法了解得足够多，可以完成书中的所有项目。让我们通过一些问题和答案进行一个快速回顾。
- en: Questions
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is wrong with this method definition?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法定义有什么问题？
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'No return type is declared. You do not have to return a value from a method,
    but its return type must be `void` in this case. This is how the method should
    look:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 没有声明返回类型。你不必从方法中返回一个值，但在这种情况下它的返回类型必须是`void`。方法应该如下所示：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: What is wrong with this method definition?
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个方法定义有什么问题？
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The method returns a string (`userName`) but the signature states that it must
    return a `float` type. With a method name like `getBalance`, this code is what
    was likely intended:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法返回一个字符串(`userName`)，但签名规定它必须返回一个`float`类型。以`getBalance`这样的方法名，这段代码可能是原本想要的：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When do we call the `onCreate` method? (Trick question alert!)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们什么时候调用`onCreate`方法？（提示：这是一个诡计问题！）
- en: We don't. Android decides when to call the `onCreate` method, as well as all
    the other methods that make up the lifecycle of an Activity. We just override
    the ones that are useful to us. We do, however, call `super.onCreate` so that
    our overridden version and the original version both get executed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要。Android决定何时调用`onCreate`方法，以及构成Activity生命周期的所有其他方法。我们只覆盖对我们有用的方法。但是，我们会调用`super.onCreate`，以便我们的重写版本和原始版本都被执行。
- en: Important Note
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For the sake of complete disclosure, it is technically possible to call the
    lifecycle methods from our code, but we will never need to in the context of this
    book. It is best to leave these things to Android.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全披露，从我们的代码中技术上可以调用生命周期方法，但在本书的上下文中我们永远不需要这样做。最好将这些事情留给Android。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In the first five chapters, we got quite proficient with a whole array of widgets
    and other UI elements. We also built a broad selection of UI layouts. In this
    chapter and the previous three, we have explored Java and the Android activity
    lifecycle in quite significant depth, especially considering how quickly we have
    done it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前五章中，我们对各种小部件和其他UI元素变得相当熟练。我们还构建了广泛的UI布局选择。在本章和前三章中，我们已经相当深入地探索了Java和Android活动生命周期，尤其是考虑到我们完成得多么快。
- en: We have, to a small extent, created interaction between our Java code and our
    UI. We have called our methods by setting the `onClick` attribute and we have
    loaded our UI layouts using the `setContentView` method. We haven't, however,
    really made a proper connection between our UI and our Java code.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一定程度上创建了Java代码和UI之间的交互。我们通过设置`onClick`属性调用了我们的方法，并使用`setContentView`方法加载了我们的UI布局。然而，我们并没有真正建立UI和Java代码之间的适当连接。
- en: What we really need to do now is to bring these things together, so we can begin
    to display and manipulate our data using the Android UI. To achieve this, we need
    to understand a bit more about classes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在真正需要做的是将这些东西结合起来，这样我们就可以开始使用Android UI来显示和操作我们的数据。为了实现这一点，我们需要更多地了解类的知识。
- en: Classes have been lurking in our code since [*Chapter 1*](B16773_01_ePub_RK.xhtml#_idTextAnchor014)*,
    Beginning Android and Java*, and we have even used them a bit. Up until now, however,
    we haven't tackled them properly other than constantly referring to [*Chapter
    10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*, Object-Oriented Programming*.
    In the next chapter, [*Chapter 10*](B16773_10_ePub_RK.xhtml#_idTextAnchor187)*,
    Object-Oriented Programming*, we will quickly get to grips with classes, and then
    we can finally start to build apps where the UI designs and our Java code work
    in perfect harmony.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 自从《第1章》《开始Android和Java》以来，类一直潜伏在我们的代码中，我们甚至有点使用它们。然而，直到现在，除了不断地参考《第10章》《面向对象编程》之外，我们还没有适当地解决它们。在下一章《第10章》《面向对象编程》中，我们将快速掌握类的知识，然后我们终于可以开始构建应用程序，使UI设计和我们的Java代码完美地协同工作。
- en: Further reading
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'We have learned enough Java to proceed with the book. It is always beneficial,
    however, to see more examples of Java in action and to go beyond the minimum necessary
    knowledge to proceed. If you want a good source to learn Java in greater depth,
    then the official Oracle website is good. Note that you do not need to study this
    website to continue with this book. Also, note that the tutorials on the Oracle
    website are not set in an Android context. The site is a useful resource to bookmark
    and browse all the same:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到了足够的Java知识来继续阅读本书。然而，看到更多Java实例并超越最低必要的知识总是有益的。如果你想要一个学习Java更深入的好资源，那么官方的Oracle网站是一个不错的选择。请注意，您不需要学习这个网站来继续阅读本书。另外，请注意，Oracle网站上的教程并不是在Android环境中设置的。该网站是一个有用的资源，可以收藏并浏览：
- en: 'The official Java tutorials: [https://docs.oracle.com/javase/tutorial/](https://docs.oracle.com/javase/tutorial/)'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Java教程：[https://docs.oracle.com/javase/tutorial/](https://docs.oracle.com/javase/tutorial/)
- en: 'The official Android developer site: [https://developer.android.com/training/basics/firstapp](https://developer.android.com/training/basics/firstapp)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Android开发者网站：[https://developer.android.com/training/basics/firstapp](https://developer.android.com/training/basics/firstapp)
