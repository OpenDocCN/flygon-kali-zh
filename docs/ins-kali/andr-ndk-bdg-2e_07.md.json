["```kt\n    #ifndef _PACKT_SoundManager_HPP_\n    #define _PACKT_SoundManager_HPP_\n\n    #include \"Types.hpp\"\n\n    #include <android_native_app_glue.h>\n    #include <SLES/OpenSLES.h>\n\n    class SoundManager {\n    public:\n        SoundManager(android_app* pApplication);\n\n        status start();\n        void stop();\n\n    private:\n        android_app* mApplication;\n\n        SLObjectItf mEngineObj; SLEngineItf mEngine;\n        SLObjectItf mOutputMixObj;\n    };\n    #endif\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Resource.hpp\"\n    #include \"SoundManager.hpp\"\n\n    SoundManager::SoundManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mEngineObj(NULL), mEngine(NULL),\n        mOutputMixObj(NULL) {\n        Log::info(\"Creating SoundManager.\");\n    }\n    ...\n    ```", "```kt\n        ...\n        status SoundManager::start() {\n            Log::info(\"Starting SoundManager.\");\n            SLresult result;\n            const SLuint32      engineMixIIDCount = 1;\n            const SLInterfaceID engineMixIIDs[]   = {SL_IID_ENGINE};\n            const SLboolean     engineMixReqs[]   = {SL_BOOLEAN_TRUE};\n            const SLuint32      outputMixIIDCount = 0;\n            const SLInterfaceID outputMixIIDs[]   = {};\n            const SLboolean     outputMixReqs[]   = {};\n            ...\n        ```", "```kt\n            ...\n            // Creates OpenSL ES engine and dumps its capabilities.\n            result = slCreateEngine(&mEngineObj, 0, NULL,\n                engineMixIIDCount, engineMixIIDs, engineMixReqs);\n            if (result != SL_RESULT_SUCCESS) goto ERROR;\n            result = (*mEngineObj)->Realize(mEngineObj,SL_BOOLEAN_FALSE);\n            if (result != SL_RESULT_SUCCESS) goto ERROR;\n            result = (*mEngineObj)->GetInterface(mEngineObj, SL_IID_ENGINE,\n                &mEngine);\n            if (result != SL_RESULT_SUCCESS) goto ERROR;\n\n            // Creates audio output.\n            result = (*mEngine)->CreateOutputMix(mEngine, &mOutputMixObj,\n                outputMixIIDCount, outputMixIIDs, outputMixReqs);\n            result = (*mOutputMixObj)->Realize(mOutputMixObj,\n                SL_BOOLEAN_FALSE);\n\n            return STATUS_OK;\n\n        ERROR:\n            Log::error(\"Error while starting SoundManager\");\n            stop();\n            return STATUS_KO;\n        }\n        ...\n        ```", "```kt\n    ...\n    void SoundManager::stop() {\n        Log::info(\"Stopping SoundManager.\");\n\n        if (mOutputMixObj != NULL) {\n            (*mOutputMixObj)->Destroy(mOutputMixObj);\n            mOutputMixObj = NULL;\n        }\n        if (mEngineObj != NULL) {\n            (*mEngineObj)->Destroy(mEngineObj);\n            mEngineObj = NULL; mEngine = NULL;\n        }\n    }\n    ```", "```kt\n    ...\n    #include \"Resource.hpp\"\n    #include \"Ship.hpp\"\n    #include \"SoundManager.hpp\"\n    #include \"SpriteBatch.hpp\"\n    #include \"StarField.hpp\"\n    ...\n\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        TimeManager     mTimeManager;\n        GraphicsManager mGraphicsManager;\n        PhysicsManager  mPhysicsManager;\n        SoundManager    mSoundManager;\n        EventLoop mEventLoop;\n\n        ...\n    };\n    #endif\n    ```", "```kt\n    ...\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        mTimeManager(),\n        mGraphicsManager(pApplication),\n        mPhysicsManager(mTimeManager, mGraphicsManager),\n        mSoundManager(pApplication),\n        mEventLoop(pApplication, *this),\n        ...\n        mShip(pApplication, mTimeManager, mGraphicsManager) {\n        ...\n    }\n\n    ...\n\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n        if (mSoundManager.start() != STATUS_OK) return STATUS_KO;\n\n        mAsteroids.initialize();\n        ...\n    }\n\n    void DroidBlaster::onDeactivate() {\n        Log::info(\"Deactivating DroidBlaster\");\n        mGraphicsManager.stop();\n        mSoundManager.stop();\n    }\n    ```", "```kt\n    ...\n    LS_CPP=$(subst $(1)/,,$(wildcard $(1)/*.cpp))\n    LOCAL_MODULE := droidblaster\n    LOCAL_SRC_FILES := $(call LS_CPP,$(LOCAL_PATH))\n    LOCAL_LDLIBS := -landroid -llog -lEGL -lGLESv2 -lOpenSLES\n    LOCAL_STATIC_LIBRARIES := android_native_app_glue png\n    ...\n    ```", "```kt\nstruct SLObjectItf_ {\n    SLresult (*Realize) (SLObjectItf self, SLboolean async);\n    SLresult (*Resume) ( SLObjectItf self, SLboolean async);\n    ...\n}\n```", "```kt\n    ...\n    struct ResourceDescriptor {\n     int32_t mDescriptor;\n     off_t mStart;\n     off_t mLength;\n    };\n\n    class Resource {\n    public:\n        ...\n        status open();\n        void close();\n        status read(void* pBuffer, size_t pCount);\n\n        ResourceDescriptor descriptor();\n\n        bool operator==(const Resource& pOther);\n\n    private:\n        ...\n    };\n    #endif\n    ```", "```kt\n    ...\n    ResourceDescriptor Resource::descriptor() {\n        ResourceDescriptor lDescriptor = { -1, 0, 0 };\n        AAsset* lAsset = AAssetManager_open(mAssetManager, mPath,\n                                            AASSET_MODE_UNKNOWN);\n        if (lAsset != NULL) {\n            lDescriptor.mDescriptor = AAsset_openFileDescriptor(\n                lAsset, &lDescriptor.mStart, &lDescriptor.mLength);\n            AAsset_close(lAsset);\n        }\n        return lDescriptor;\n    }\n    ...\n    ```", "```kt\n        ...\n        #include <android_native_app_glue.h>\n        #include <SLES/OpenSLES.h>\n        #include <SLES/OpenSLES_Android.h>\n\n        class SoundManager {\n        public:\n            ...\n            status start();\n            void stop();\n\n            status playBGM(Resource& pResource);\n         void stopBGM();\n\n        private:\n            ...\n            SLObjectItf mEngineObj; SLEngineItf mEngine;\n            SLObjectItf mOutputMixObj;\n\n            SLObjectItf mBGMPlayerObj; SLPlayItf mBGMPlayer;\n         SLSeekItf mBGMPlayerSeek;\n        };\n        #endif\n        ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Resource.hpp\"\n    #include \"SoundManager.hpp\"\n\n    SoundManager::SoundManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mEngineObj(NULL), mEngine(NULL),\n        mOutputMixObj(NULL),\n        mBGMPlayerObj(NULL), mBGMPlayer(NULL), mBGMPlayerSeek(NULL) {\n        Log::info(\"Creating SoundManager.\");\n    }\n\n    ...\n\n    void SoundManager::stop() {\n        Log::info(\"Stopping SoundManager.\");\n        stopBGM();\n\n        if (mOutputMixObj != NULL) {\n            (*mOutputMixObj)->Destroy(mOutputMixObj);\n            mOutputMixObj = NULL;\n        }\n        if (mEngineObj != NULL) {\n            (*mEngineObj)->Destroy(mEngineObj);\n            mEngineObj = NULL; mEngine = NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    status SoundManager::playBGM(Resource& pResource) {\n        SLresult result;\n        Log::info(\"Opening BGM %s\", pResource.getPath());\n\n        ResourceDescriptor descriptor = pResource.descriptor();\n        if (descriptor.mDescriptor < 0) {\n            Log::info(\"Could not open BGM file\");\n            return STATUS_KO;\n        }\n\n        SLDataLocator_AndroidFD dataLocatorIn;\n        dataLocatorIn.locatorType = SL_DATALOCATOR_ANDROIDFD;\n        dataLocatorIn.fd          = descriptor.mDescriptor;\n        dataLocatorIn.offset      = descriptor.mStart;\n        dataLocatorIn.length      = descriptor.mLength;\n\n        SLDataFormat_MIME dataFormat;\n        dataFormat.formatType    = SL_DATAFORMAT_MIME;\n        dataFormat.mimeType      = NULL;\n        dataFormat.containerType = SL_CONTAINERTYPE_UNSPECIFIED;\n\n        SLDataSource dataSource;\n        dataSource.pLocator = &dataLocatorIn;\n        dataSource.pFormat  = &dataFormat;\n\n        SLDataLocator_OutputMix dataLocatorOut;\n        dataLocatorOut.locatorType = SL_DATALOCATOR_OUTPUTMIX;\n        dataLocatorOut.outputMix   = mOutputMixObj;\n\n        SLDataSink dataSink;\n        dataSink.pLocator = &dataLocatorOut;\n        dataSink.pFormat  = NULL;\n    ...\n    ```", "```kt\n    ...\n        const SLuint32 bgmPlayerIIDCount = 2;\n        const SLInterfaceID bgmPlayerIIDs[] =\n            { SL_IID_PLAY, SL_IID_SEEK };\n        const SLboolean bgmPlayerReqs[] =\n            { SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE };\n\n        result = (*mEngine)->CreateAudioPlayer(mEngine,\n            &mBGMPlayerObj, &dataSource, &dataSink,\n            bgmPlayerIIDCount, bgmPlayerIIDs, bgmPlayerReqs);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        result = (*mBGMPlayerObj)->Realize(mBGMPlayerObj,\n            SL_BOOLEAN_FALSE);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n\n        result = (*mBGMPlayerObj)->GetInterface(mBGMPlayerObj,\n            SL_IID_PLAY, &mBGMPlayer);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        result = (*mBGMPlayerObj)->GetInterface(mBGMPlayerObj,\n            SL_IID_SEEK, &mBGMPlayerSeek);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        result = (*mBGMPlayerSeek)->SetLoop(mBGMPlayerSeek,\n            SL_BOOLEAN_TRUE, 0, SL_TIME_UNKNOWN);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        result = (*mBGMPlayer)->SetPlayState(mBGMPlayer,\n            SL_PLAYSTATE_PLAYING);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error playing BGM\");\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void SoundManager::stopBGM() {\n        if (mBGMPlayer != NULL) {\n            SLuint32 bgmPlayerState;\n            (*mBGMPlayerObj)->GetState(mBGMPlayerObj,\n                &bgmPlayerState);\n            if (bgmPlayerState == SL_OBJECT_STATE_REALIZED) {\n                (*mBGMPlayer)->SetPlayState(mBGMPlayer,\n                    SL_PLAYSTATE_PAUSED);\n\n                (*mBGMPlayerObj)->Destroy(mBGMPlayerObj);\n                mBGMPlayerObj = NULL;\n                mBGMPlayer = NULL; mBGMPlayerSeek = NULL;\n            }\n        }\n    }\n    ```", "```kt\n    ...\n    class DroidBlaster : public ActivityHandler {\n        ...\n    private:\n        ...\n        Resource mAsteroidTexture;\n        Resource mShipTexture;\n        Resource mStarTexture;\n        Resource mBGM;\n        ...\n    };\n    #endif\n    ```", "```kt\n    ...\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        ...\n        mAsteroidTexture(pApplication, \"droidblaster/asteroid.png\"),\n        mShipTexture(pApplication, \"droidblaster/ship.png\"),\n        mStarTexture(pApplication, \"droidblaster/star.png\"),\n        mBGM(pApplication, \"droidblaster/bgm.mp3\"),\n        ...\n        mSpriteBatch(mTimeManager, mGraphicsManager) {\n        ...\n    }\n    ...\n    status DroidBlaster::onActivate() {\n        Log::info(\"Activating DroidBlaster\");\n\n        if (mGraphicsManager.start() != STATUS_OK) return STATUS_KO;\n        if (mSoundManager.start() != STATUS_OK) return STATUS_KO;\n        mSoundManager.playBGM(mBGM);\n\n        mAsteroids.initialize();\n        mShip.initialize();\n\n        mTimeManager.reset();\n        return STATUS_OK;\n    }\n    ...\n    ```", "```kt\n    ...\n    class Resource {\n    public:\n        ...\n\n        ResourceDescriptor descriptor();\n        off_t getLength();\n        ...\n    };\n\n    #endif\n    ```", "```kt\n    ...\n    off_t Resource::getLength() {\n        return AAsset_getLength(mAsset);\n    }\n    ...\n    ```", "```kt\n    #ifndef _PACKT_SOUND_HPP_\n    #define _PACKT_SOUND_HPP_\n\n    class SoundManager;\n\n    #include \"Resource.hpp\"\n    #include \"Types.hpp\"\n\n    class Sound {\n    public:\n        Sound(android_app* pApplication, Resource* pResource);\n\n        const char* getPath();\n        uint8_t* getBuffer() { return mBuffer; };\n        off_t getLength() { return mLength; };\n\n        status load();\n        status unload();\n\n    private:\n        friend class SoundManager;\n\n        Resource* mResource;\n        uint8_t* mBuffer; off_t mLength;\n    };\n    #endif\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"Sound.hpp\"\n\n    #include <SLES/OpenSLES.h>\n    #include <SLES/OpenSLES_Android.h>\n\n    Sound::Sound(android_app* pApplication, Resource* pResource) :\n        mResource(pResource),\n        mBuffer(NULL), mLength(0)\n    {}\n\n    const char* Sound::getPath() {\n        return mResource->getPath();\n    }\n\n    status Sound::load() {\n        Log::info(\"Loading sound %s\", mResource->getPath());\n        status result;\n\n        // Opens sound file.\n        if (mResource->open() != STATUS_OK) {\n            goto ERROR;\n        }\n\n        // Reads sound file.\n        mLength = mResource->getLength();\n        mBuffer = new uint8_t[mLength];\n        result = mResource->read(mBuffer, mLength);\n        mResource->close();\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error while reading PCM sound.\");\n        return STATUS_KO;\n    }\n\n    status Sound::unload() {\n        delete[] mBuffer;\n        mBuffer = NULL; mLength = 0;\n\n        return STATUS_OK;\n    }\n    ```", "```kt\n    #ifndef _PACKT_SOUNDQUEUE_HPP_\n    #define _PACKT_SOUNDQUEUE_HPP_\n\n    #include \"Sound.hpp\"\n\n    #include <SLES/OpenSLES.h>\n    #include <SLES/OpenSLES_Android.h>\n\n    class SoundQueue {\n    public:\n        SoundQueue();\n\n        status initialize(SLEngineItf pEngine, SLObjectItf pOutputMixObj);\n        void finalize();\n        void playSound(Sound* pSound);\n\n    private:\n        SLObjectItf mPlayerObj; SLPlayItf mPlayer;\n        SLBufferQueueItf mPlayerQueue;\n    };\n    #endif\n    ```", "```kt\n    #include \"Log.hpp\"\n    #include \"SoundQueue.hpp\"\n\n    SoundQueue::SoundQueue() :\n        mPlayerObj(NULL), mPlayer(NULL),\n        mPlayerQueue() {\n    }\n    ...\n    ```", "```kt\n    ...\n    status SoundQueue::initialize(SLEngineItf pEngine,\n            SLObjectItf pOutputMixObj) {\n        Log::info(\"Starting sound player.\");\n        SLresult result;\n\n        // Set-up sound audio source.\n        SLDataLocator_AndroidSimpleBufferQueue dataLocatorIn;\n        dataLocatorIn.locatorType =\n            SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\n        // At most one buffer in the queue.\n        dataLocatorIn.numBuffers = 1;\n\n        SLDataFormat_PCM dataFormat;\n        dataFormat.formatType = SL_DATAFORMAT_PCM;\n        dataFormat.numChannels = 1; // Mono sound.\n        dataFormat.samplesPerSec = SL_SAMPLINGRATE_44_1;\n        dataFormat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\n        dataFormat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\n        dataFormat.channelMask = SL_SPEAKER_FRONT_CENTER;\n        dataFormat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\n        SLDataSource dataSource;\n        dataSource.pLocator = &dataLocatorIn;\n        dataSource.pFormat = &dataFormat;\n\n        SLDataLocator_OutputMix dataLocatorOut;\n        dataLocatorOut.locatorType = SL_DATALOCATOR_OUTPUTMIX;\n        dataLocatorOut.outputMix = pOutputMixObj;\n\n        SLDataSink dataSink;\n        dataSink.pLocator = &dataLocatorOut;\n        dataSink.pFormat = NULL;\n    ...\n    ```", "```kt\n    ...\n        const SLuint32 soundPlayerIIDCount = 2;\n        const SLInterfaceID soundPlayerIIDs[] =\n            { SL_IID_PLAY, SL_IID_BUFFERQUEUE };\n        const SLboolean soundPlayerReqs[] =\n            { SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE };\n\n        result = (*pEngine)->CreateAudioPlayer(pEngine, &mPlayerObj,\n            &dataSource, &dataSink, soundPlayerIIDCount,\n            soundPlayerIIDs, soundPlayerReqs);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        result = (*mPlayerObj)->Realize(mPlayerObj, SL_BOOLEAN_FALSE);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n\n        result = (*mPlayerObj)->GetInterface(mPlayerObj, SL_IID_PLAY,\n            &mPlayer);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        result = (*mPlayerObj)->GetInterface(mPlayerObj,\n            SL_IID_BUFFERQUEUE, &mPlayerQueue);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n    ...\n    ```", "```kt\n    ...\n        result = (*mPlayer)->SetPlayState(mPlayer,\n            SL_PLAYSTATE_PLAYING);\n        if (result != SL_RESULT_SUCCESS) goto ERROR;\n        return STATUS_OK;\n\n    ERROR:\n        Log::error(\"Error while starting SoundQueue\");\n        return STATUS_KO;\n    }\n    ...\n    ```", "```kt\n    ...\n    void SoundQueue::finalize() {\n        Log::info(\"Stopping SoundQueue.\");\n\n        if (mPlayerObj != NULL) {\n            (*mPlayerObj)->Destroy(mPlayerObj);\n            mPlayerObj = NULL; mPlayer = NULL; mPlayerQueue = NULL;\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    void SoundQueue::playSound(Sound* pSound) {\n        SLresult result;\n        SLuint32 playerState;\n        (*mPlayerObj)->GetState(mPlayerObj, &playerState);\n        if (playerState == SL_OBJECT_STATE_REALIZED) {\n            int16_t* buffer = (int16_t*) pSound->getBuffer();\n            off_t length = pSound->getLength();\n\n            // Removes any sound from the queue.\n            result = (*mPlayerQueue)->Clear(mPlayerQueue);\n            if (result != SL_RESULT_SUCCESS) goto ERROR;\n            // Plays the new sound.\n            result = (*mPlayerQueue)->Enqueue(mPlayerQueue, buffer,\n                                              length);\n            if (result != SL_RESULT_SUCCESS) goto ERROR;\n        }\n        return;\n\n    ERROR:\n        Log::error(\"Error trying to play sound\");\n    }\n    ```", "```kt\n    ...\n    #include \"Sound.hpp\"\n    #include \"SoundQueue.hpp\"\n    #include \"Types.hpp\"\n    ...\n\n    class SoundManager {\n    public:\n        SoundManager(android_app* pApplication);\n        ~SoundManager();\n\n        ...\n\n        Sound* registerSound(Resource& pResource);\n     void playSound(Sound* pSound);\n\n    private:\n        ...\n        static const int32_t QUEUE_COUNT = 4;\n     SoundQueue mSoundQueues[QUEUE_COUNT]; int32_t mCurrentQueue;\n     Sound* mSounds[32]; int32_t mSoundCount;\n    };\n    #endif\n    ```", "```kt\n    ...\n    SoundManager::SoundManager(android_app* pApplication) :\n        mApplication(pApplication),\n        mEngineObj(NULL), mEngine(NULL),\n        mOutputMixObj(NULL),\n        mBGMPlayerObj(NULL), mBGMPlayer(NULL), mBGMPlayerSeek(NULL),\n        mSoundQueues(), mCurrentQueue(0),\n     mSounds(), mSoundCount(0) {\n        Log::info(\"Creating SoundManager.\");\n    }\n\n    SoundManager::~SoundManager() {\n     Log::info(\"Destroying SoundManager.\");\n     for (int32_t i = 0; i < mSoundCount; ++i) {\n     delete mSounds[i];\n     }\n     mSoundCount = 0;\n    }\n    ...\n    ```", "```kt\n    ...\n    status SoundManager::start() {\n        ...\n        result = (*mEngine)->CreateOutputMix(mEngine, &mOutputMixObj,\n            outputMixIIDCount, outputMixIIDs, outputMixReqs);\n        result = (*mOutputMixObj)->Realize(mOutputMixObj,\n            SL_BOOLEAN_FALSE);\n\n        Log::info(\"Starting sound player.\");\n     for (int32_t i= 0; i < QUEUE_COUNT; ++i) {\n     if (mSoundQueues[i].initialize(mEngine, mOutputMixObj)\n     != STATUS_OK) goto ERROR;\n        }\n\n        for (int32_t i = 0; i < mSoundCount; ++i) {\n     if (mSounds[i]->load() != STATUS_OK) goto ERROR;\n        }\n        return STATUS_OK;\n\n    ERROR:\n        ...\n    }\n    ...\n    ```", "```kt\n    ...\n    void SoundManager::stop() {\n        Log::info(\"Stopping SoundManager.\");\n        stopBGM();\n\n        for (int32_t i= 0; i < QUEUE_COUNT; ++i) {\n     mSoundQueues[i].finalize();\n        }\n\n        // Destroys audio output and engine.\n        ...\n\n        for (int32_t i = 0; i < mSoundCount; ++i) {\n     mSounds[i]->unload();\n        }\n    }\n    ...\n    ```", "```kt\n    ...\n    Sound* SoundManager::registerSound(Resource& pResource) {\n        for (int32_t i = 0; i < mSoundCount; ++i) {\n            if (strcmp(pResource.getPath(), mSounds[i]->getPath()) == 0) {\n                return mSounds[i];\n            }\n        }\n\n        Sound* sound = new Sound(mApplication, &pResource);\n        mSounds[mSoundCount++] = sound;\n        return sound;\n    }\n    ...\n    ```", "```kt\n    ...\n    void SoundManager::playSound(Sound* pSound) {\n        int32_t currentQueue = ++mCurrentQueue;\n        SoundQueue& soundQueue = mSoundQueues[currentQueue % QUEUE_COUNT];\n        soundQueue.playSound(pSound);\n    }\n    ```", "```kt\n    ...\n    #include \"GraphicsManager.hpp\"\n    #include \"Sprite.hpp\"\n    #include \"SoundManager.hpp\"\n    #include \"Sound.hpp\"\n\n    class Ship {\n    public:\n        Ship(android_app* pApplication,\n             GraphicsManager& pGraphicsManager,\n             SoundManager& pSoundManager);\n\n        void registerShip(Sprite* pGraphics, Sound* pCollisionSound);\n\n        void initialize();\n\n    private:\n        GraphicsManager& mGraphicsManager;\n        SoundManager& mSoundManager;\n\n        Sprite* mGraphics;\n        Sound* mCollisionSound;\n    };\n    #endif\n    ```", "```kt\n    ...\n    Ship::Ship(android_app* pApplication,\n            GraphicsManager& pGraphicsManager,\n            SoundManager& pSoundManager) :\n      mGraphicsManager(pGraphicsManager),\n      mGraphics(NULL),\n      mSoundManager(pSoundManager),\n     mCollisionSound(NULL) {\n    }\n\n    void Ship::registerShip(Sprite* pGraphics, Sound* pCollisionSound) {\n        mGraphics = pGraphics;\n        mCollisionSound = pCollisionSound;\n    }\n\n    void Ship::initialize() {\n        mGraphics->location.x = INITAL_X\n                * mGraphicsManager.getRenderWidth();\n        mGraphics->location.y = INITAL_Y\n                * mGraphicsManager.getRenderHeight();\n        mSoundManager.playSound(mCollisionSound);\n    }\n    ```", "```kt\n    ...\n    class DroidBlaster : public ActivityHandler {\n        ...\n\n    private:\n        ...\n        Resource mAsteroidTexture;\n        Resource mShipTexture;\n        Resource mStarTexture;\n        Resource mBGM;\n        Resource mCollisionSound;\n\n        ...\n    };\n    #endif\n    ```", "```kt\n    #include \"DroidBlaster.hpp\"\n    #include \"Sound.hpp\"\n    #include \"Log.hpp\"\n    ...\n    DroidBlaster::DroidBlaster(android_app* pApplication):\n        ...\n        mAsteroidTexture(pApplication, \"droidblaster/asteroid.png\"),\n        mShipTexture(pApplication, \"droidblaster/ship.png\"),\n        mStarTexture(pApplication, \"droidblaster/star.png\"),\n        mBGM(pApplication, \"droidblaster/bgm.mp3\"),\n        mCollisionSound(pApplication, \"droidblaster/collision.pcm\"),\n\n        mAsteroids(pApplication, mTimeManager, mGraphicsManager,\n                mPhysicsManager),\n        mShip(pApplication, mGraphicsManager, mSoundManager),\n        mStarField(pApplication, mTimeManager, mGraphicsManager,\n                STAR_COUNT, mStarTexture),\n        mSpriteBatch(mTimeManager, mGraphicsManager) {\n        Log::info(\"Creating DroidBlaster\");\n\n        Sprite* shipGraphics = mSpriteBatch.registerSprite(mShipTexture,\n                SHIP_SIZE, SHIP_SIZE);\n        shipGraphics->setAnimation(SHIP_FRAME_1, SHIP_FRAME_COUNT,\n                SHIP_ANIM_SPEED, true);\n        Sound* collisionSound =\n     mSoundManager.registerSound(mCollisionSound);\n     mShip.registerShip(shipGraphics, collisionSound);\n        ...\n    }\n    ...\n    ```", "```kt\n...\nvoid callback_sound(SLBufferQueueItf pBufferQueue, void *pContext) {\n // Context can be casted back to the original type.\n SoundService& lService = *(SoundService*) pContext;\n    ...\n    Log::info(\"Ended playing sound.\");\n}\n...\nstatus SoundService::start() {\n    ...\n    result = (*mEngine)->CreateOutputMix(mEngine, &mOutputMixObj,\n        outputMixIIDCount, outputMixIIDs, outputMixReqs);\n    result = (*mOutputMixObj)->Realize(mOutputMixObj,\n        SL_BOOLEAN_FALSE);\n\n    // Registers a callback called when sound is finished.\n result = (*mPlayerQueue)->RegisterCallback(mPlayerQueue,\n callback_sound, this);\n if (result != SL_RESULT_SUCCESS) goto ERROR;\n result = (*mPlayer)->SetCallbackEventsMask(mPlayer,\n SL_PLAYEVENT_HEADATEND);\n if (result != SL_RESULT_SUCCESS) goto ERROR;\n\n    Log::info(\"Starting sound player.\");\n    ...\n}\n...\n```", "```kt\nimport android.content.pm.PackageManager;\n...\nPackageManager pm = getContext().getPackageManager();\nboolean claimsFeature = pm.hasSystemFeature(PackageManager.FEATURE_AUDIO_LOW_LATENCY);\n```", "```kt\nimport android.media.AudioManager;\n...\nAudioManager am = (AudioManager) getSystemService(Context.AUDIO_SERVICE);\nString sampleRateStr =\n        am.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);\nint sampleRate = !TextUtils.isEmpty(sampleRateStr) ?\n                                Integer.parseInt(sampleRateStr) : -1;\nString framesPerBufferStr =\n        am.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER);\nint framesPerBuffer = !TextUtils.isEmpty(framesPerBufferStr) ?\n                           Integer.parseInt(framesPerBufferStr) : -1;\n```", "```kt\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest \n    package=\"com.packtpub.droidblaster2d\" android:versionCode=\"1\"\n    android:versionName=\"1.0\">\n    ...\n    <uses-permission android:name=\"android.permission.RECORD_AUDIO\"/>\n</manifest>\n```", "```kt\n    const SLuint32 soundRecorderIIDCount = 2;\n    const SLInterfaceID soundRecorderIIDs[] =\n            { SL_IID_RECORD, SL_IID_ANDROIDSIMPLEBUFFERQUEUE };\n    const SLboolean soundRecorderReqs[] =\n            { SL_BOOLEAN_TRUE, SL_BOOLEAN_TRUE };\n    SLObjectItf mRecorderObj;\n    (*mEngine)->CreateAudioRecorder(mEngine, &mRecorderObj,\n            &dataSource, &dataSink,\n            soundRecorderIIDCount, soundRecorderIIDs, soundRecorderReqs);\n    ```", "```kt\nSLDataLocator_AndroidSimpleBufferQueue dataLocatorOut;\ndataLocatorOut.locatorType =\n    SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE;\ndataLocatorOut.numBuffers = 1;\n\nSLDataFormat_PCM dataFormat;\ndataFormat.formatType = SL_DATAFORMAT_PCM;\ndataFormat.numChannels = 1;\ndataFormat.samplesPerSec = SL_SAMPLINGRATE_44_1;\ndataFormat.bitsPerSample = SL_PCMSAMPLEFORMAT_FIXED_16;\ndataFormat.containerSize = SL_PCMSAMPLEFORMAT_FIXED_16;\ndataFormat.channelMask = SL_SPEAKER_FRONT_CENTER;\ndataFormat.endianness = SL_BYTEORDER_LITTLEENDIAN;\n\nSLDataSink dataSink;\ndataSink.pLocator = &dataLocatorOut;\ndataSink.pFormat = &dataFormat;\n\nSLDataLocator_IODevice dataLocatorIn;\ndataLocatorIn.locatorType = SL_DATALOCATOR_IODEVICE;\ndataLocatorIn.deviceType = SL_IODEVICE_AUDIOINPUT;\ndataLocatorIn.deviceID = SL_DEFAULTDEVICEID_AUDIOINPUT;\ndataLocatorIn.device = NULL;\n\nSLDataSource dataSource;\ndataSource.pLocator = &dataLocatorIn;\ndataSource.pFormat = NULL;\n```", "```kt\nrecordSize   = 2 * 44100 * sizeof(int16_t);\nrecordBuffer = new int16_t[mRecordSize];\n```", "```kt\n(*mRecorder)->SetRecordState(mRecorder, SL_RECORDSTATE_STOPPED);\n(*mRecorderQueue)->Clear(mRecorderQueue);\n(*mRecorderQueue)->Enqueue(mRecorderQueue, recordBuffer,\n    recordSize * sizeof(int16_t));\n(*mRecorder)->SetRecordState(mRecorder,SL_RECORDSTATE_RECORDING);\n```", "```kt\n(*mRecorderQueue)->RegisterCallback(mRecorderQueue,\n                                    callback_recorder, this);\n(*mRecorder)->SetCallbackEventMask(mRecorder,\n                                   SL_RECORDEVENT_BUFFER_FULL);\n```"]