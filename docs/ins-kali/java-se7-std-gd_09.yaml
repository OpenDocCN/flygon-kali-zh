- en: Chapter 9. The Java Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。Java应用程序
- en: In this chapter we will examine the structure of a Java application from the
    perspective of packages. The use of the packages and import statements will be
    covered, along with the underlying directory structure used for packages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从包的角度来检查Java应用程序的结构。将介绍包和导入语句的使用，以及用于包的基础目录结构。
- en: We will also see how Java supports internationalization through the use of locales
    and resource bundles. An introduction to the use of JDBC will be presented, as
    well as examining how unused objects are reclaimed. This is commonly referred
    to as **garbage collection** .
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将看到Java如何通过使用区域设置和资源包支持国际化。将介绍JDBC的使用，以及如何回收未使用的对象。这通常被称为**垃圾回收**。
- en: Code organization
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码组织
- en: The organization of code is an essential part of an application. One can go
    as far as to say that it is this organization (along with data organization) that
    determines the quality of an application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的组织是应用程序的重要部分。可以说，正是这种组织（以及数据组织）决定了应用程序的质量。
- en: 'A Java application is organized around packages. Packages contain classes.
    Classes contain data and code. Code is found in either an initializer list or
    in a method. This basic organization is shown in the following diagram:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Java应用程序是围绕包组织的。包含类的包。类包含数据和代码。代码可以在初始化列表或方法中找到。这种基本组织如下图所示：
- en: '![Code organization](img/7324_09_01.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![代码组织](img/7324_09_01.jpg)'
- en: Code can be thought of as being both static and dynamic in nature. The organization
    of a Java program is structured statically around packages, classes, interfaces,
    initializer lists, and methods. The only change in this organization comes from
    different versions of an executing program. However, as a program executes, the
    myriad of different possible execution paths result in an often complex sequence
    of execution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以被认为在性质上既是静态的又是动态的。Java程序的组织在静态上围绕包、类、接口、初始化列表和方法进行结构化。这种组织的唯一变化来自执行程序的不同版本。然而，当程序执行时，不同的可能执行路径导致执行序列通常变得复杂。
- en: The Java API is organized into many packages of hundreds of classes. New packages
    and classes are being added on a regular basis making it challenging to keep up
    with all of the capabilities of Java.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Java API被组织成许多包，其中包含数百个类。新的包和类正在不断添加，使得跟上Java的所有功能变得具有挑战性。
- en: However, as mentioned in the *The Object class* section in [Chapter 7](ch07.html
    "Chapter 7. Inheritance and Polymorphism"), *Inheritance and Polymorphism*, all
    classes in Java have as a base class—`java.lang`.`Object`—either directly or indirectly.
    In the classes that you defined, if you do not explicitly extend another class,
    Java will automatically extend this class from the `Object` class.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如在[第7章](ch07.html "第7章。继承和多态")*继承和多态*中的*对象类*部分中提到的，Java中的所有类都有一个基类—`java.lang`.`Object`—直接或间接地。在您定义的类中，如果不明确扩展另一个类，Java将自动从`Object`类扩展此类。
- en: Packages
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: 'The purpose of a package is to group related classes and other elements together.
    Ideally, they form a cohesive set of classes and interfaces. A package can consist
    of:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包的目的是将相关的类和其他元素组合在一起。理想情况下，它们形成一组连贯的类和接口。一个包可以包括：
- en: Classes
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Interfaces
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Enumerations
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Exceptions
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: It is natural that classes with similar functionality should somehow be grouped
    together. Most of Java's IO classes are grouped together in the `java.io` or `java.nio`
    related packages. All of Java's network classes are found in the `java.net` package.
    This grouping mechanism provides us with a single logical grouping that is easier
    to talk about and to work with.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似功能的类应该自然地被组合在一起。大多数Java的IO类都被分组在`java.io`或`java.nio`相关的包中。所有Java的网络类都在`java.net`包中找到。这种分组机制为我们提供了一个更容易讨论和处理的单一逻辑分组。
- en: All classes belong to a package. If the package is not specified, then the class
    belongs to an unnamed default package. This package consists of all the classes
    in the directory that have not been declared as belonging to a package.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类都属于一个包。如果未指定包，则类属于一个未命名的默认包。该包包括未声明为属于某个包的目录中的所有类。
- en: The directory/file organization of packages
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包的目录/文件组织
- en: 'To place a class within a package it is necessary to:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要将类放入包中，有必要：
- en: Use the package statement in the class source file
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类源文件中使用包语句
- en: Move the corresponding `.class` file to the package directory
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将相应的`.class`文件移动到包目录中
- en: 'The package statement needs to be the first statement in the class'' source
    file. The statement consists of the keyword, `package`, followed by the name of
    the package. The following example declares that the class `Phone` belongs to
    the `acme.telephony` package:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 包语句需要是类源文件中的第一个语句。该语句由关键字`package`和包的名称组成。以下示例声明了类`Phone`属于`acme.telephony`包：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Java source code files are placed in a file with the same name as the class
    using a `.java` extension. If more than one class is saved in a file, only one
    class can be declared as public and the file must be named after this public class.
    The `java.lang` package contains many commonly used classes and is included automatically
    in every application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java源代码文件以`.java`扩展名保存在与类同名的文件中。如果一个文件中保存了多个类，则只能声明一个类为public，并且文件必须以此公共类命名。`java.lang`包包含许多常用的类，并且在每个应用程序中自动包含。
- en: 'The second requirement is to move the class file to the appropriate package
    directory. Somewhere on the system there must exist a directory structure that
    reflects the package name. For example, for a package name `employee.benefits`
    there needs to be a directory named `employee` that has a subdirectory named `benefits`.
    All of the class files for the `employee` package are placed in the `employee`
    directory. All of the class files for the `employee.benefits` package are placed
    in the `benefits` subdirectory. This is illustrated in the following diagram where
    the directories and files are located somewhere off in the `C` drive:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求是将类文件移动到适当的包目录中。系统中的某个地方必须存在一个反映包名的目录结构。例如，对于包名`employee.benefits`，需要有一个名为`employee`的目录，其中有一个名为`benefits`的子目录。`employee`包的所有类文件都放在`employee`目录中。`employee.benefits`包的所有类文件都放在`benefits`子目录中。下图显示了这一点，其中目录和文件位于`C`驱动器的某个地方：
- en: '![The directory/file organization of packages](img/7324_09_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![包的目录/文件组织](img/7324_09_02.jpg)'
- en: You may also find that a package's directories and classes are compressed into
    a **Java Archive** (**JAR**) or `.jar` file. If you look for a specific package
    structure in a directory system, you may find a JAR file instead. By compressing
    packages into a JAR file, memory can be minimized. If you find such files, do
    not unzip them because the Java compiler and JVM expect them to be in a JAR file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还会发现一个包的目录和类被压缩成一个**Java存档**（**JAR**）或`.jar`文件。如果您在目录系统中寻找特定的包结构，可能会找到一个JAR文件。通过将包压缩成JAR文件，可以最小化内存。如果找到这样的文件，请不要解压缩，因为Java编译器和JVM希望它们在JAR文件中。
- en: Most IDEs will separate the source files from the class files by placing them
    in separate directories. This separation makes them easier to work with and deploy.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数集成开发环境将源文件和类文件分开放置在不同的目录中。这种分离使它们更容易处理和部署。
- en: The import statement
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入语句
- en: 'The `import` statement provides information to the compiler in terms of where
    to find the definition of a class used in the program. There are several considerations
    regarding the import statement that we will examine:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句向编译器提供了关于在程序中使用的类的定义在哪里找到的信息。关于导入语句有几点需要考虑，我们将在下文中进行讨论：'
- en: Its use is optional
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的使用是可选的。
- en: Using the wildcard character
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通配符字符
- en: Accessing multiple classes with the same name
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问具有相同名称的多个类
- en: The static import statement
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态导入语句
- en: Avoiding the import statement
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用import语句
- en: 'The `import` statement is optional. In the following example, instead of using
    the `import` statement for the `BigDecimal` class we explicitly use the package
    name directly in code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句是可选的。在下面的例子中，我们没有使用`import`语句来导入`BigDecimal`类，而是直接在代码中明确使用包名：'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is more verbose but it is more expressive. It leaves no doubt that the
    `BigDecimal` class is the one found in the `java.math` package. However, if we
    used the class many times in the program then this becomes an annoyance. Normally,
    the `import` statement is used.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这更冗长，但更具表现力。它毫无疑问地表明`BigDecimal`类是在`java.math`包中找到的。但是，如果我们在程序中多次使用该类，这将变得很烦人。通常会使用`import`语句。
- en: Using the import statement
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用导入语句
- en: 'To avoid having to prefix each class with its package name, the `import` statement
    can be used to indicate to the compiler where the class can be found. In this
    example the class, `BufferedReader` of the `java.io` package, can be used without
    having to prefix the class name with its package name each time it is used:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每个类都要用其包名作为前缀，`import`语句可以用来指示编译器类的位置。在这个例子中，`java.io`包的`BufferedReader`类可以在使用时不必每次都用其包名作为前缀：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the wildcard character
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通配符字符
- en: 'If more than one class needs to be used, and they are found in the same package,
    an asterisk can be used instead of including multiple import statements, one for
    each class. For example, if we need to use both the `BufferedReader` and the `BufferedWriter`
    classes in an application we could use two import statements, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要使用多个类，并且它们在同一个包中，可以使用星号代替包括多个导入语句，每个类一个。例如，如果我们需要在应用程序中同时使用`BufferedReader`和`BufferedWriter`类，可以使用两个导入语句，如下所示：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By explicitly listing each class, the reader of the code will know immediately
    where to find the class. Otherwise, the reader might be left guessing from which
    package a class originates when the wild card character is used with multiple
    import statements.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过显式列出每个类，代码的读者将立即知道在哪里找到该类。否则，当通配符字符与多个导入语句一起使用时，读者可能会猜测一个类来自哪个包。
- en: While the explicit import of each class is better documentation, the import
    list can get quite long. Most IDEs support the ability to collapse, or otherwise
    hide the list.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个类的显式导入更好地记录了文档，但导入列表可能会变得很长。大多数集成开发环境支持折叠或隐藏列表的功能。
- en: 'The alternative approach is to use one import statement with the asterisk,
    shown as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用带有星号的单个导入语句，如下所示：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All of the package''s elements can now be used without using the package name.
    However, this does not mean that the classes of sub-packages can be used in the
    same way. For example, there are numerous packages that start with `java.awt`.
    A few of these with some of their elements are shown in the following diagram:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在不使用包名的情况下使用该包的所有元素。但是，这并不意味着子包的类可以以同样的方式使用。例如，有许多以`java.awt`开头的包。以下图表显示了其中一些及其元素：
- en: '![Using the wildcard character](img/7324_09_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![使用通配符字符](img/7324_09_03.jpg)'
- en: 'It may seem the wild card character should include those classes found in these
    additional packages when used against the "base" package, as shown in the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当针对“基本”包使用通配符字符时，可能会觉得通配符字符应该包括这些附加包中找到的类，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, it imports only those classes in the `java.awt` package and none of
    the classes in the `java.awt.font` or similar packages. In order to also reference
    all of the classes of `java.awt.font` also, a second import statement is necessary:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它只导入`java.awt`包中的那些类，而不导入`java.awt.font`或类似包中的任何类。为了还引用`java.awt.font`的所有类，需要第二个导入语句：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Multiple classes with the same name
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有相同名称的多个类
- en: As it is possible to have more than one class with the same name in different
    packages, the import statement is used to specify which class to use. However,
    the second class will need to explicitly use the package name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能在不同的包中有多个同名类，因此导入语句用于指定要使用的类。但是，第二个类将需要显式使用包名称。
- en: For example, let's assume that we have created a `BigDecimal` class in a `com.company.account`
    package and we need to use it and the `java.math.BigDecimal` class. We cannot
    use an import for both classes, as shown in the following code snippet, because
    this will generate a syntax error to the effect that the names collide.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们在`com.company.account`包中创建了一个`BigDecimal`类，并且我们需要使用它和`java.math.BigDecimal`类。我们不能为两个类使用导入，如下面的代码片段所示，因为这将生成一个语法错误，指出名称冲突。
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Instead, we need to either:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要：
- en: Declare one using the import statement and explicitly prefix the class name
    of the second when we use it, or
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用导入语句声明一个，并在使用时显式前缀第二个类名，或者
- en: d. not use the import statement at all and explicitly prefix both classes as
    we use them
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: d.根本不使用导入语句，并在使用它们时显式前缀两个类
- en: 'Assuming that we use the `import` statement with the `java.math` class, we
    use both classes in code, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`import`语句与`java.math`类，我们在代码中使用两个类，如下所示：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that we had to prefix both usages of `BigDecimal` in the second statement
    otherwise it would have assumed that the un-prefixed one was in the `java.math`
    package generating a type mismatch syntax error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须在第二个语句中为`BigDecimal`的两个用法添加前缀，否则它会假定未加前缀的那个在`java.math`包中，从而生成类型不匹配的语法错误。
- en: The static import statement
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态导入语句
- en: 'The static import statement can be used to simplify the use of methods. This
    is commonly used in conjunction with the `println` method. In the following example,
    we use the `println` method several times:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 静态导入语句可用于简化方法的使用。这通常与`println`方法一起使用。在下面的示例中，我们多次使用`println`方法：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In each case, the classname, `System`, was required. However, if we use the
    following `import` statement where we added the `static` keyword we will not need
    to use the `System` classname.:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，都需要`System`类名。但是，如果我们使用以下`import`语句，其中添加了`static`关键字，我们将不需要使用`System`类名：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following sequence of code statements achieves the same result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码语句序列实现了相同的结果：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While this approach saves the time spent in typing, it can be confusing to anyone
    who does not understand the use of the static import statement.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法节省了输入时间，但对于不了解静态导入语句的人来说可能会感到困惑。
- en: Garbage collection
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Java performs automatic garbage collection. When memory is allocated using the
    `new` keyword, the memory is obtained from the program heap. This is an area of
    memory above the program stack. The object allocated is held by the program until
    the program releases it. This is done by removing all references to the object.
    Once it is released, the garbage collection routine will eventually run and reclaim
    the memory allocated by the objects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Java执行自动垃圾回收。使用`new`关键字分配内存时，内存是从程序堆中获取的。这是程序堆栈上方的内存区域。分配的对象将由程序保留，直到程序释放它。这是通过删除对对象的所有引用来完成的。一旦释放，垃圾回收例程最终将运行并回收对象分配的内存。
- en: 'The following code sequence illustrates how a `String` object is created. It
    is then assigned to a second reference variable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列说明了如何创建`String`对象。然后将其分配给第二个引用变量：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'At this point, `s1` and `s2` both reference the string object. The following
    diagram illustrates the memory allocation for `s1` and `s2`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`s1`和`s2`都引用字符串对象。以下图表说明了`s1`和`s2`的内存分配：
- en: '![Garbage collection](img/7324_09_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/7324_09_04.jpg)'
- en: 'The `new` keyword was used in this situation to ensure that the string object
    is allocated from the heap. If we had used a string literal, as shown below, the
    object is allocated to an internal pool as discussed in the *String comparisons*
    section in [Chapter 2](ch02.html "Chapter 2. Java Data Types and Their Usage"),
    *Java Data Types and Their Usage*:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，使用`new`关键字确保从堆中分配了字符串对象。如果我们使用字符串文字，如下所示，对象将分配给内部池，如[第2章](ch02.html "第2章。Java数据类型及其用法")中的*字符串比较*部分所讨论的那样，*Java数据类型及其用法*：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next two statements illustrate how the references to the object can be
    removed:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个语句说明了如何删除对对象的引用：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following diagram shows the state of the application after these statements
    have been executed:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些语句后，应用程序的状态如下图所示：
- en: '![Garbage collection](img/7324_09_05.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾回收](img/7324_09_05.jpg)'
- en: 'There exists a JVM background thread, which executes periodically to reclaim
    the unused objects. At some point in the future, the thread will execute. When
    an object is ready to be reclaimed, the thread will do the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一个JVM后台线程，定期执行以回收未使用的对象。在将来的某个时候，线程将执行。当对象准备回收时，线程将执行以下操作：
- en: Execute the method's `finalize` method
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行方法的`finalize`方法
- en: Reclaim the memory for re-use by the heap manager
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回收内存以供堆管理器重用
- en: The `finalize` method is not normally implemented by a developer. Its original
    intent was to correspond to the destructor found in languages such as C++. They
    were used to perform cleanup activities.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`finalize`方法通常不由开发人员实现。它最初的目的是对应于诸如C++之类的语言中找到的析构函数。它们用于执行清理活动。'
- en: In Java, you should not rely on the method to execute. For small programs, the
    garbage collection routine may never run as the program may terminate before it
    has a chance to execute. Over the years, several attempts have been made to provide
    the ability for a programmer to force the method to execute. None of these attempts
    have been successful.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，不应依赖于方法执行。对于小型程序，垃圾回收例程可能永远不会运行，因为程序可能在有机会执行之前终止。多年来，已经尝试了几次提供程序员强制执行方法的能力。这些尝试都没有成功。
- en: Resource bundles and the Locale class
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源包和Locale类
- en: The `Locale` class is used to represent a part of the world. Associated with
    a locale is a set of conventions concerned with such activities as controlling
    the way currency or dates are displayed. The use of locales aids in the internationalization
    of an application. The developer specifies the locale and then uses the locale
    in various parts of the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Locale`类用于表示世界的一部分。与区域关联的是一组与货币或日期显示方式控制相关的约定。使用区域有助于应用的国际化。开发人员指定区域，然后在应用的各个部分中使用该区域。'
- en: In addition to the `Locale` class, we can also use resource bundles. They provide
    a way to customize the appearance based on the locale for data types other than
    numbers and dates. It is particularly useful when working with strings that change
    based on the locale.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Locale`类，我们还可以使用资源包。它们提供了一种根据区域设置自定义外观的方式，适用于除数字和日期之外的数据类型。在处理根据区域设置更改的字符串时特别有用。
- en: For example, a GUI application will have different visual components whose text
    should differ when used in different parts of the world. In Spain, the text and
    currency should be displayed in Spanish. In China, Chinese characters and conventions
    should be used. The use of locales can simplify the process of adapting an application
    to different regions of the world.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，GUI应用程序将具有不同的可视组件，其文本在世界不同地区使用时应有所不同。在西班牙，文本和货币应以西班牙语显示。在中国，应使用中文字符和约定。使用区域设置可以简化将应用程序适应世界不同地区的过程。
- en: 'In this section we will discuss three approaches used to support internationalization
    of an application:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论用于支持应用国际化的三种方法：
- en: Using the `Locale` class
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Locale`类
- en: Using a property resource file
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性资源文件
- en: Using the `ListResourceBundle` class
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListResourceBundle`类
- en: Using the Locale class
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Locale类
- en: 'To illustrate the use of locales we first create an instance of the `Locale`
    class. This class has a number of predefined locale constants. In the following
    example we will create a locale for the US and then display the locale:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明区域设置的使用，我们首先创建`Locale`类的实例。该类具有许多预定义的区域设置常量。在以下示例中，我们将创建一个美国的区域设置，然后显示该区域设置：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output appears as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The first part, `en_`, is short for English. The second part specifies US.
    If we change the locale to Germany as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分`en_`代表英语。第二部分指定为美国。如果我们将区域设置更改为德国如下：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'you will get the following output:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将得到以下输出：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can use locales to format currency values. In the following example we
    have used the static `getCurrencyInstance` method to return an instance of a `NumberFormat`
    class using the locale for the US. The `format` method is then used to `format`
    a double number:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用区域设置格式化货币值。在以下示例中，我们使用静态的`getCurrencyInstance`方法使用美国的区域返回`NumberFormat`类的实例。然后使用`format`方法对双精度数进行格式化：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output appears as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we had used the German locale, we would get the following output:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用德国区域设置，将得到以下输出：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Dates can also be formatted based on a locale. The `DateFormat` class'' `getDateInstance`
    method is used in the following code snippet, with the US locale. The `format`
    method uses a `Date` object to obtain a string representation of the date, as
    illustrated in the following code snippet:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 日期也可以根据区域设置进行格式化。在以下代码片段中，使用`DateFormat`类的`getDateInstance`方法，使用美国的区域设置。`format`方法使用`Date`对象获取日期的字符串表示，如以下代码片段所示：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output would be similar to the one that follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将类似于以下内容：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following code snippet we will use a locale for France:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，我们将使用法国的区域设置：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of this example is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using resource bundles
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用资源包
- en: Resource bundles are collections of objects organized by the locale. For example,
    we might have one resource bundle containing strings and GUI components for English
    speaker and another set for Spanish speakers. These language groups can be further
    divided into language subgroups such as US versus Canadian English speakers.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 资源包是按区域组织的对象集合。例如，我们可能有一个资源包，其中包含英语用户的字符串和GUI组件，另一个资源包适用于西班牙语用户。这些语言组可以进一步分为语言子组，例如美国英语用户与加拿大英语用户。
- en: A resource bundle can be stored as a file or may be defined as a class. A property
    resource bundle is stored in a `.properties` file and is restricted to strings.
    `ListResourceBundle` is a class and can hold strings and other objects.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 资源包可以存储为文件，也可以定义为类。属性资源包存储在`.properties`文件中，仅限于字符串。`ListResourceBundle`是一个类，可以保存字符串和其他对象。
- en: Using a property resource bundle
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用属性资源包
- en: 'A property resource bundle is a file consisting of a set of key-value string
    pairs where the file name ends with `.properties`. The string key is used to identify
    a specific string value. For example, a `WINDOW_CAPTION` key can be associated
    with a string value `Editor`. The following shows the content of a `ResourceExamples.properties`
    file:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 属性资源包是一个文件，包含一组以键值对形式存在的字符串，文件名以`.properties`结尾。字符串键用于标识特定的字符串值。例如，`WINDOW_CAPTION`键可以与字符串值`Editor`相关联。以下是`ResourceExamples.properties`文件的内容：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To access the value in a resource file, we need to create an instance of a
    `ResourceBundle` class. We can do this by using the `ResourceBundle` class'' static
    `getBundle` method, as shown in the following code snippet. Notice that the resource
    file name is used as an argument of the method, but it does not include the file
    extension. If we know the key, we can use it with the `getString` method to return
    its corresponding value:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问资源文件中的值，我们需要创建一个`ResourceBundle`类的实例。我们可以使用`ResourceBundle`类的静态`getBundle`方法来实现这一点，如下面的代码片段所示。请注意，资源文件名被用作方法的参数，但不包括文件扩展名。如果我们知道键，我们可以使用`getString`方法来返回其对应的值：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output will appear as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use the `getKeys` method to obtain an `Enumeration` object. As shown
    in the following code snippet, the enumeration to display all of the key-value
    pairs of the file, is used:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`getKeys`方法来获取一个`Enumeration`对象。如下面的代码片段所示，用于显示文件的所有键值对的枚举：
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of this sequence is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个序列的输出如下：
- en: '[PRE30]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the output does not match the order or the contents of the `ResourceExamples.properties`
    file. The order is controlled by the enumeration. The content is different for
    the `FILE_NOT_FOUND` and `FILE_EXISTS` keys. This is because it actually used
    a different file, `ResourceExamples_en_US.properties`. There is a hierarchical
    relationship between the property resource bundles. The code sequence was executed
    with a default locale of the US. The system looked for the `ResourceExamples_en_US.properties`
    file as it represents the strings specific to that locale. Any missing elements
    in a resource file are inherited from its "base" file.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，输出与`ResourceExamples.properties`文件的顺序或内容不匹配。顺序由枚举控制。`FILE_NOT_FOUND`和`FILE_EXISTS`键的内容不同。这是因为它实际上使用了不同的文件，`ResourceExamples_en_US.properties`。属性资源包之间存在层次关系。代码序列是在默认区域设置为美国的情况下执行的。系统查找`ResourceExamples_en_US.properties`文件，因为它代表特定于该区域设置的字符串。资源文件中的任何缺失元素都会从其“基本”文件中继承。
- en: 'We will create four different resource bundle files to illustrate the use of
    resource bundles and the hierarchical relationship between them:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将创建四个不同的资源包文件，以说明资源包的使用以及它们之间的层次关系： '
- en: '`ResourceExamples.properties`'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceExamples.properties`'
- en: '`ResourceExamples_en.properties`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceExamples_en.properties`'
- en: '`ResourceExamples_en_US.properties`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceExamples_en_US.properties`'
- en: '`ResourceExamples_sp.properties`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceExamples_sp.properties`'
- en: 'These are related to each other hierarchically, as depicted in the following
    diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在层次上是相关的，如下图所示：
- en: '![Using a property resource bundle](img/7324_09_06.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![使用属性资源包](img/7324_09_06.jpg)'
- en: 'These files will contain strings for four keys as summarized in the following
    table:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件将包含四个键的字符串，如下表所示：
- en: '| File | Key | Value |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 文件 | 键 | 值 |'
- en: '| --- | --- | --- |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|   | `WINDOW_CAPTION` | Editor |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|   | `WINDOW_CAPTION` | 编辑器 |'
- en: '| `FILE_NOT_FOUND` | The file could not be found |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_NOT_FOUND` | 文件找不到 |'
- en: '| `FILE_EXISTS` | The file already exists |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_EXISTS` | 文件已经存在 |'
- en: '| `UNKNOWN` | Unknown problem with application |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `UNKNOWN` | 应用程序出现未知问题 |'
- en: '| `en` | `WINDOW_CAPTION` | Editor |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `en` | `WINDOW_CAPTION` | 编辑器 |'
- en: '| `FILE_NOT_FOUND` | The English file could not be found |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_NOT_FOUND` | 英文文件找不到 |'
- en: '| `UNKNOWN` | Unknown problem with application |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `UNKNOWN` | 应用程序出现未知问题 |'
- en: '| `en_US` | `WINDOW_CAPTION` | Editor |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `en_US` | `WINDOW_CAPTION` | 编辑器 |'
- en: '| `FILE_NOT_FOUND` | The US file could not be found |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_NOT_FOUND` | 美国文件找不到 |'
- en: '| `FILE_EXISTS` | The US file already exists |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_EXISTS` | 美国文件已经存在 |'
- en: '| `UNKNOWN` | Unknown problem with application |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `UNKNOWN` | 应用程序出现未知问题 |'
- en: '| `sp` | `FILE_NOT_FOUND` | El archivo no se pudo encontrar |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `sp` | `FILE_NOT_FOUND` | El archivo no se pudo encontrar |'
- en: '| `FILE_EXISTS` | El archivo ya existe |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `FILE_EXISTS` | El archivo ya existe |'
- en: '| `UNKNOWN` | Problema desconocido con la aplicación |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `UNKNOWN` | Problema desconocido con la aplicación |'
- en: 'The `en` entry is missing a value for the `FILE_EXISTS` key and the `sp` entry
    is missing the `WINDOW_CAPTION` key. They will inherit the value for the default
    resource file, as illustrated below for the `en` locale:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`en`条目缺少`FILE_EXISTS`键的值，`sp`条目缺少`WINDOW_CAPTION`键。它们将继承默认资源文件的值，如下所示，对于`en`区域设置：'
- en: '[PRE31]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output lists a value for `FILE_EXISTS` even though it is not found in the
    `ResourceExamples_en.properties` file:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 输出列出了`FILE_EXISTS`的值，即使它在`ResourceExamples_en.properties`文件中找不到：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The inheritance behavior of these files allows the developer to create a hierarchy
    of resources files based on a base file name and then extend them by adding a
    locale suffix. This results in strings being used automatically that are specific
    for the current locale. If a locale other than the default one is needed, then
    the specific locale can be specified.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件的继承行为允许开发人员基于基本文件名创建资源文件的层次结构，然后通过添加区域设置后缀来扩展它们。这将导致自动使用特定于当前区域设置的字符串。如果需要的区域设置不同于默认区域设置，则可以指定特定的区域设置。
- en: Using the ListResourceBundle class
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`ListResourceBundle`类
- en: 'The `ListResourceBundle` class is also used to hold resources. Not only can
    it hold strings, it can also hold other types of objects. However, the keys are
    still string values. To demonstrate the use of this class, we will create the
    `ListResource` class which derives from the `ListResourceBundle` class as listed
    below. A static two dimensional array of objects is created containing key-value
    pairs. Notice the last pair contains an `ArrayList`. The class'' `getContents`
    method returns the resources as a two dimensional array of objects:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListResourceBundle`类也用于保存资源。它不仅可以保存字符串，还可以保存其他类型的对象。但是，键仍然是字符串值。为了演示这个类的使用，我们将创建一个从`ListResourceBundle`类派生的`ListResource`类，如下所示。创建一个包含键值对的静态二维对象数组。请注意，最后一对包含一个`ArrayList`。类的`getContents`方法将资源作为二维对象数组返回：'
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `ArrayList` created is intended to store various name prefixes. It is created
    using the `asList` method, which is passed a variable number of string arguments
    and it returns a `List` to the `ArrayList` constructor.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的“ArrayList”旨在存储各种名称前缀。它使用“asList”方法创建，该方法传递可变数量的字符串参数，并将一个“List”返回给“ArrayList”构造函数。
- en: 'The following code demonstrates how to use `ListResource`. An instance of `ListResource`
    is created and then the `getString` method is executed using string keys. For
    the `PREFIXES` key, the `getObject` method is used:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何使用“ListResource”。创建了一个“ListResource”的实例，然后使用字符串键执行了“getString”方法。对于“PREFIXES”键，使用了“getObject”方法：
- en: '[PRE34]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of this sequence is as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此序列的输出如下：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Using JDBC
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JDBC
- en: 'JDBC is used to connect to a database and manipulate tables in the database.
    The process to use JDBC includes the following steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC用于连接到数据库并操作数据库中的表。使用JDBC的过程包括以下步骤：
- en: Connecting to a database
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Creating an SQL statement to submit to the database
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建要提交到数据库的SQL语句
- en: Handling the results and any exceptions that may be generated
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理生成的结果和任何异常
- en: In Java 7, the use of JDBC has been enhanced with the addition of the try-with-resources
    block, which simplifies the opening and closing of connections. A detailed explanation
    of this block is found in the *Using the try-with-resource block* section in Chapter
    8.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 7中，使用JDBC已经通过添加try-with-resources块得到增强，该块简化了连接的打开和关闭。有关此块的详细说明，请参见第8章中的“使用try-with-resource块”部分。
- en: Connecting to a database
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Connecting to a database involves two steps:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 连接到数据库涉及两个步骤：
- en: Loading a suitable driver
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载适当的驱动程序
- en: Establishing a connection
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立连接
- en: This assumes that a database has been setup and is accessible. In the following
    examples, we will be using MySQL Version 5.5\. MySQL comes with the `Sakila` schema
    which contains a `customer` table. We will use this table to demonstrate various
    JDBC techniques.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设数据库已经设置并且可访问。在以下示例中，我们将使用MySQL Version 5.5。MySQL带有包含“customer”表的“Sakila”模式。我们将使用此表来演示各种JDBC技术。
- en: Loading a suitable driver
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载适当的驱动程序
- en: 'First we need to load a driver. JDBC supports a number of drivers, as discussed
    at [http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers).
    Here, we will use the `MySQLConnector/J` driver. We load the driver using the
    `Class` class'' `forName` method, as shown in the following code snippet:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们需要加载一个驱动程序。 JDBC支持多种驱动程序，如[http://developers.sun.com/product/jdbc/drivers](http://developers.sun.com/product/jdbc/drivers)中所讨论的。在这里，我们将使用“MySQLConnector/J”驱动程序。我们使用“Class”类的“forName”方法加载驱动程序，如下面的代码片段所示：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The method throws several exceptions which need to be caught.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法会抛出几个需要捕获的异常。
- en: Note that starting with JDBC 4.0 the above sequence is no longer needed, assuming
    that the JDBC drivers used support JDBC 4.0\. This is the case for the MySQL drivers
    used with MySQL Version 5.5\. This sequence is used here because you will probably
    run across this approach in older programs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从JDBC 4.0开始，不再需要上述序列，假设使用的JDBC驱动程序支持JDBC 4.0。这适用于与MySQL Version 5.5一起使用的MySQL驱动程序。这里使用此序列是因为您可能会在旧程序中遇到这种方法。
- en: Establishing a connection
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立连接
- en: 'Next, a connection to the database needs to be established. The `java.sql.Connection`
    represents a connection to a database. The `DriverManager` class'' static `getConnection`
    method will return a connection to a database. Its arguments include:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，需要建立与数据库的连接。 “java.sql.Connection”表示与数据库的连接。 “DriverManager”类的静态“getConnection”方法将返回与数据库的连接。它的参数包括：
- en: A URL representing the database
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表数据库的URL
- en: A user ID
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户ID
- en: A password
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个密码
- en: 'The following code sequence will use a try-with-resources block to establish
    a connection to the database. The first parameter is a MySQL specific connection
    string. Connection strings are vendor specific:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码序列将使用try-with-resources块来建立与数据库的连接。第一个参数是特定于MySQL的连接字符串。连接字符串是供应商特定的：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Creating a SQL statement
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建SQL语句
- en: 'Next, we need to create a `Statement` object that will be used to execute a
    query. The `Connection` class'' `createStatement` method will return a `Statement`
    object. We will add it to the try-with-resources block to create the object:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个“Statement”对象，用于执行查询。 “Connection”类的“createStatement”方法将返回一个“Statement”对象。我们将把它添加到try-with-resources块中以创建对象：
- en: '[PRE38]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A query string is then formed that will select the first and last name of those
    customers in the `customer` table whose `address_id` is less than 10\. We choose
    this query to minimize the size of the result set. The `executeQuery` method is
    used to execute the query and returns a `ResultSet` object that holds the rows
    of the table matching the selected query:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后形成一个查询字符串，该字符串将选择“customer”表中“address_id”小于10的那些客户的名字和姓氏。我们选择此查询以最小化结果集的大小。使用“executeQuery”方法执行查询并返回一个包含与所选查询匹配的表的行的“ResultSet”对象：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Handling the results
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理结果
- en: 'The last step is to use a while loop to iterate through the result set and
    display the rows returned. In the following example the `next` method will advance
    from row to row in the `resultset`. The `getString` method returns the value corresponding
    to the method''s argument that specifies the column to be accessed:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用while循环遍历结果集并显示返回的行。在下面的示例中，“next”方法将在“resultset”中从一行移到另一行。“getString”方法返回与指定要访问的列对应的值的方法参数：
- en: '[PRE40]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: JDBC supports the use of other SQL statements such as `update` and `delete`.
    In addition, it supports the use of parameterized queries and stored procedures.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: JDBC支持其他SQL语句的使用，如“update”和“delete”。此外，它支持使用参数化查询和存储过程。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we have re-examined the overall structure of a Java application.
    We examined the use of the `import` and `package` statements and discussed the
    relationship between a package library and its supporting directory/file underpinnings.
    We learned how to use the asterisk wildcard with the `import` statement. In addition,
    we saw the use of the static import statement.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们重新审视了Java应用程序的整体结构。我们讨论了`import`和`package`语句的使用，并讨论了包库与其支持的目录/文件之间的关系。我们学习了如何在`import`语句中使用星号通配符。此外，我们看到了静态导入语句的使用。
- en: We discussed the use of the initializer list and how garbage collection works
    in Java. This process results in the automatic recovery of objects once they are
    no longer needed.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了初始化程序列表的使用以及Java中垃圾回收的工作原理。这个过程导致对象在不再需要时自动回收。
- en: The support provided for internationalization was explored starting with the
    `Locale` class and then with resource bundles. Both, property resource bundles
    and the `ListResourceBundle` class were covered. We learned how inheritance works
    with property resource bundles when organized using a consistent naming convention.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了国际化的支持，从`Locale`类开始，然后是资源包。我们讨论了属性资源包和`ListResourceBundle`类。我们学习了当使用一致的命名约定组织时，属性资源包的继承如何工作。
- en: Finally, we covered the use of JDBC. We saw how a driver is needed to establish
    a connection to a database and how to use the `Statement` class to retrieve a
    `ResultSet` object. This object allowed us to iterate through the rows returned
    by a `select` query.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了JDBC的使用。我们看到需要驱动程序来建立与数据库的连接，以及如何使用`Statement`类来检索`ResultSet`对象。这个对象允许我们遍历`select`查询返回的行。
- en: Certification objectives covered
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涵盖的认证目标
- en: 'The certification objectives covered in this chapter include:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的认证目标包括：
- en: Defining the structure of a Java class
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Java类的结构
- en: Selecting a resource bundle based on locale
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据区域设置选择资源包
- en: Using the proper JDBC API to submit queries and read results from the database.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用适当的JDBC API提交查询并从数据库中读取结果。
- en: Test your knowledge
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: Which of the following will compile without an error?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个将不会出现编译错误？
- en: a. `package somepackage;`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: a. `package somepackage;`
- en: '`import java.nio.*;`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`import java.nio.*;`'
- en: '`class SomeClass {}`'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`class SomeClass {}`'
- en: b. `import java.nio.*;`
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: b. `import java.nio.*;`
- en: '`package somepackage;`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`package somepackage;`'
- en: '`class SomeClass {}`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`class SomeClass {}`'
- en: c. `/*This is a comment */`
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: c. `/*这是一个注释*/`
- en: '`package somepackage;`'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`package somepackage;`'
- en: '`import java.nio.*;`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`import java.nio.*;`'
- en: '`class SomeClass {}`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`class SomeClass {}`'
- en: For a hierarchy of a resource property file, if a key is missing from one of
    the derived files, which of the following are true about the value returned, based
    on a missing key?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于资源属性文件的层次结构，如果一个键在一个派生文件中丢失，根据丢失的键，以下哪些关于返回的值是真的？
- en: a. The return value will be an empty string
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: a. 返回值将是一个空字符串
- en: b. The return value will be a null value
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: b. 返回值将是一个空值
- en: c. The return value will be a string from a base resource bundle
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: c. 返回值将是来自基本资源包的字符串
- en: d. A runtime exception will be thrown
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: d. 会抛出运行时异常
- en: 'Which exception is not thrown by the `forName` method:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`forName`方法不会抛出哪个异常：'
- en: a. `InstantiationException`
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: a. `InstantiationException`
- en: b. `ClassNotFoundException`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: b. `ClassNotFoundException`
- en: c. `ClassDoesNotExistException`
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: c. `ClassDoesNotExistException`
- en: d. `IllegalAccessException`
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: d. `IllegalAccessException`
