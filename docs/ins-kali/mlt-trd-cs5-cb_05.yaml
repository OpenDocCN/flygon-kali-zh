- en: Chapter 5. Using C# 5.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用C# 5.0
- en: 'In this chapter, we will look through the native asynchronous programming support
    in the C# 5.0 programming language. You will learn about the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究C# 5.0编程语言中的本机异步编程支持。您将了解以下内容：
- en: Using the await operator to get asynchronous task results
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用await运算符获取异步任务结果
- en: Using the await operator in a lambda expression
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在lambda表达式中使用await运算符
- en: Using the await operator with consequent asynchronous tasks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用await运算符与随后的异步任务
- en: Using the await operator for the execution of parallel asynchronous tasks
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用await运算符执行并行异步任务
- en: Handling exceptions in asynchronous operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理异步操作中的异常
- en: Avoid using the captured synchronization context
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用捕获的同步上下文
- en: Working around the async void method
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决异步void方法的问题
- en: Designing a custom awaitable type
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计自定义可等待类型
- en: Using the dynamic type with await
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态类型与await
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Until now, we learned about Task Parallel Library, the latest asynchronous programming
    infrastructure from Microsoft. It allows us to design our program in a modular
    manner, combining different asynchronous operations together.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们了解了来自Microsoft的最新异步编程基础设施——任务并行库。它允许我们以模块化的方式设计程序，将不同的异步操作组合在一起。
- en: Unfortunately, it is still difficult to understand the actual program flow when
    reading such a program. In a large program, there will be numerous tasks and continuations
    that depend on each other, continuations that run other continuations, continuations
    for exception handling, and they are all gathered together in the program code
    in very different places. Therefore, to understand the sequence of which operation
    goes first and what happens next becomes a very challenging problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，当阅读这样的程序时，仍然很难理解实际的程序流程。在一个大型程序中，将会有许多任务和依赖于彼此的延续，运行其他延续的延续，用于异常处理的延续，它们都聚集在程序代码中的非常不同的地方。因此，理解哪个操作先进行，接下来发生什么的顺序成为一个非常具有挑战性的问题。
- en: Another issue to watch out for is to see if the proper synchronization context
    is propagated to each asynchronous task that could touch user interface controls.
    It is only permitted to use these controls from the UI thread; else, we would
    get a multithreaded access exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的问题是要查看是否将适当的同步上下文传播到可能触及用户界面控件的每个异步任务。只有从UI线程才允许使用这些控件；否则，我们将得到一个多线程访问异常。
- en: Speaking about exceptions, we also have to use separate continuation tasks to
    handle errors that occur inside the antecedent asynchronous operation or operations.
    This in turn results in complicated error-handling code that is spread through
    different parts in the code, not logically related to each other.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到异常，我们还必须使用单独的延续任务来处理发生在前置异步操作或操作中的错误。这反过来导致了复杂的错误处理代码，分散在代码的不同部分，彼此之间没有逻辑关联。
- en: To address these issues, the authors of C# 5.0 introduced new language enhancements
    called **asynchronous functions**. They really make asynchronous programming simple,
    but at the same time, it is a higher-level abstraction over TPL. As we mentioned
    in [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"), *Using Task
    Parallel Library*, abstraction hides important implementation details and makes
    asynchronous programming easier at the cost of taking away many important things
    from the programmer. It is very important to understand the concept behind asynchronous
    functions to create robust and scalable applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，C# 5.0的作者引入了称为**异步函数**的新语言增强功能。它们确实使异步编程变得简单，但同时，它是TPL的高级抽象。正如我们在[第4章](ch04.html
    "第4章。使用任务并行库")中提到的，*使用任务并行库*，抽象隐藏了重要的实现细节，并使异步编程更加容易，但却剥夺了程序员的许多重要内容。了解异步函数背后的概念对于创建健壮和可扩展的应用程序非常重要。
- en: 'To create an asynchronous function, first you mark a method with the `async`
    keyword. It is not possible to have the async property or event accessor methods
    and constructors without first doing this. The code will look as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个异步函数，首先要用`async`关键字标记一个方法。在没有这样做之前，不可能拥有带有async属性或事件访问器方法和构造函数。代码将如下所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Another important fact is that asynchronous functions must return the `Task`
    or `Task<T>` type. It is possible to have the `async void` methods, but it is
    preferable to use the `async Task` method instead. The only reasonable option
    to use `async void` functions is when using top-level UI control event handlers
    in your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事实是，异步函数必须返回`Task`或`Task<T>`类型。可以有`async void`方法，但最好使用`async Task`方法。只有在应用程序中使用顶层UI控件事件处理程序时，才能使用`async
    void`函数。
- en: Inside a method marked with the `async` keyword, you can use the `await` operator.
    This operator works with tasks from TPL and gets the result of the asynchronous
    operation inside the task. The details will be covered later in the chapter. You
    cannot use the `await` operator outside the `async` method; there will be a compilation
    error. In addition, asynchronous functions should have at least one `await` operator
    inside its code. However, it will lead to just a compilation warning, not an error.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记有`async`关键字的方法内部，可以使用`await`运算符。该运算符与TPL中的任务一起工作，并获取任务内部异步操作的结果。详细内容将在本章后面介绍。您不能在`async`方法之外使用`await`运算符；这将导致编译错误。此外，异步函数应该至少在其代码中有一个`await`运算符。但这只会导致编译警告，而不是错误。
- en: It is important to note that this method returns immediately after the line
    with the `await` call. In case of synchronous execution, the executing thread
    will be blocked for 2 seconds and then return a result. Here, we wait asynchronously
    while returning a worker thread to a thread pool, immediately after executing
    the `await` operator. After 2 seconds, we get the worker thread from a thread
    pool once again and run the rest of the asynchronous method on it. This allows
    us to re-use this worker thread to do some other work while these 2 seconds pass,
    which is extremely important for application scalability. With the help of asynchronous
    functions we have a linear program control flow, but it is still asynchronous.
    This is both very comfortable and very confusing. The recipes in this chapter
    will help you to learn every important aspect of asynchronous functions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在`await`调用的行之后，此方法立即返回。在同步执行的情况下，执行线程将被阻塞2秒，然后返回结果。在这里，我们在返回一个工作线程到线程池的同时异步等待，立即在执行`await`操作符后返回一个工作线程。2秒后，我们再次从线程池中获取工作线程，并在其上运行其余的异步方法。这使我们能够在这2秒内重复使用这个工作线程来做一些其他工作，这对应用程序的可伸缩性非常重要。通过异步函数的帮助，我们有一个线性的程序控制流，但它仍然是异步的。这既非常舒适又非常令人困惑。本章的食谱将帮助您学习异步函数的每个重要方面。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From my experience, there is a common misunderstanding about how programs work
    if there are two consecutive `await` operators in it. Many people think that if
    we use the `await` function on one asynchronous operation after another, they
    run in parallel. However, they actually run sequentially; the second one starts
    only when the first operation completes. It is very important to remember this,
    and later in the chapter, we will cover this topic in detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，如果程序中有两个连续的`await`操作符，人们普遍存在一个误解。许多人认为，如果我们在一个异步操作之后使用`await`函数，它们会并行运行。然而，它们实际上是顺序运行的；第二个操作只有在第一个操作完成后才开始。记住这一点非常重要，在本章的后面，我们将详细讨论这个话题。
- en: There are a number of limitations connected with using `async` and `await` in
    C# 5.0\. For example, it is not possible to mark the console application's `Main`
    method as `async`; you cannot have the `await` operator inside a `catch`, `finally`,
    `lock`, or `unsafe` block. It is not allowed to have `ref` and `out` parameters
    on an asynchronous function. There are more subtleties, but these are the major
    points.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 5.0中使用`async`和`await`存在一些限制。例如，不可能将控制台应用程序的`Main`方法标记为`async`；您不能在`catch`、`finally`、`lock`或`unsafe`块中使用`await`操作符。异步函数上不允许有`ref`和`out`参数。还有更多微妙之处，但这些是主要的要点。
- en: Asynchronous functions are turned into complex program constructs by the C#
    compiler behind the scenes. I intentionally will not describe this in detail;
    the resulting code is quite similar to another C# construct, called **iterators**,
    and is implemented as a sort of state machine. Since many developers have started
    to use the `async` modifier almost on every method, I would like to emphasize
    that there is no sense in marking a method as `async` if it is not intended to
    be used in an asynchronous or parallel manner. Calling the `async` method includes
    a significant performance hit, and the usual method call is going to be about
    40 to 50 times faster as compared to the same method marked with the `async` keyword.
    Please be aware of that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数在幕后由C#编译器转换为复杂的程序构造。我故意不会详细描述这一点；生成的代码与另一个C#构造，称为**迭代器**，非常相似，并且实现为一种状态机。由于许多开发人员几乎在每个方法上都开始使用`async`修饰符，我想强调的是，如果一个方法不打算以异步或并行方式使用，那么将方法标记为`async`是没有意义的。调用`async`方法会带来显著的性能损失，通常方法调用将比标记为`async`关键字的相同方法快40到50倍。请注意这一点。
- en: In this chapter, we will learn to use the C# 5.0 `async` and `await` keywords
    to work with asynchronous operations. We will cover how to await the asynchronous
    operations sequentially and in parallel. We will discuss how to use `await` in
    lambda expressions, how to handle exceptions, and how to avoid pitfalls when using
    the `async void` methods. To conclude the chapter, we will dive deep into synchronization
    context propagation and learn how to create our own awaitable objects instead
    of using tasks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用C# 5.0的`async`和`await`关键字来处理异步操作。我们将讨论如何顺序和并行等待异步操作。我们将讨论如何在lambda表达式中使用`await`，如何处理异常，以及在使用`async
    void`方法时如何避免陷阱。最后，我们将深入探讨同步上下文传播，并学习如何创建自己的可等待对象，而不是使用任务。
- en: Using the await operator to get asynchronous task results
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`await`操作符获取异步任务结果
- en: This recipe walks through the basic scenario of using asynchronous functions.
    We will compare how to get an asynchronous operation result with TPL and with
    the `await` operator.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱介绍了使用异步函数的基本场景。我们将比较如何使用TPL和`await`操作符获取异步操作结果。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe1`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个食谱，您需要Visual Studio 2012。没有其他先决条件。此食谱的源代码可以在`BookSamples\Chapter5\Recipe1`中找到。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To use the `await` operator to get asynchronous task results, perform the following
    steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`await`操作符获取异步任务结果的步骤如下：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run the program.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: When the program runs, we run two asynchronous operations. One of them is standard
    TPL-powered code, and the second one uses the new `async` and `await` C# features.
    The `AsynchronyWithTPL` method starts a task that runs for 2 seconds and then
    returns a string with information about the worker thread. Then, we define a continuation
    to print out the asynchronous operation result after the operation completes,
    and another one to print the exception details in case errors occur. Finally,
    we return a task representing one of the continuation tasks, and wait for its
    completion in the `Main` method.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们运行两个异步操作。其中一个是标准的TPL驱动代码，另一个使用新的`async`和`await` C#特性。`AsynchronyWithTPL`方法启动一个运行2秒钟的任务，然后返回一个包含有关工作线程信息的字符串。然后，我们定义一个继续打印异步操作结果的操作，另一个用于在发生错误时打印异常详细信息。最后，我们返回表示一个继续任务的任务，并在`Main`方法中等待其完成。
- en: In the `AsynchronyWithAwait` method, we achieve the same result by using `await`
    with the task. It is as if we write just usual synchronous code – we get the result
    from the task, print out the result, and catch an exception if the task is completed
    with errors. The key difference is that we actually have an asynchronous program.
    Immediately after using `await`, C# creates a task that has a continuation task
    with all the remaining code after the `await` operator, and deals with exception
    propagation as well. Then, we return this task to the `Main` method and wait until
    it completes.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AsynchronyWithAwait`方法中，我们通过使用`await`与任务实现了相同的结果。就好像我们只是编写了普通的同步代码-我们从任务中获取结果，打印结果，并在任务完成时捕获异常。关键区别在于我们实际上有一个异步程序。在使用`await`后立即，C#创建了一个任务，该任务具有在`await`运算符之后的所有剩余代码的继续任务，并处理异常传播。然后，我们将此任务返回给`Main`方法，并等待其完成。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that depending on the nature of the underlying asynchronous operation
    and the current synchronization context, the exact means of executing the asynchronous
    code may differ. We will explain this later in the chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，根据底层异步操作的性质和当前的同步上下文，执行异步代码的确切方式可能有所不同。我们将在本章后面解释这一点。
- en: Therefore, we can see that the first and the second parts of the program are
    conceptually equivalent, but in the second part the C# compiler does the work
    of handling asynchronous code implicitly. It is, in fact, even more complicated
    than the first part, and we will cover the details in the next few recipes of
    this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到程序的第一部分和第二部分在概念上是等价的，但在第二部分中，C#编译器隐式地处理异步代码。实际上，它甚至比第一部分更复杂，我们将在本章的接下来的几个食谱中详细介绍。
- en: Please remember that it is not recommended to use the `Task.Wait` and `Task.Result`
    methods in environments, such as Windows GUI or ASP.NET. This could lead to deadlocks
    if the programmer is not 100% aware of what is really going on in the code. This
    was illustrated in the *Tweaking tasks execution with TaskScheduler* recipe of
    [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"), *Using Task Parallel
    Library*, when we used `Task.Result` in the WPF application.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在诸如Windows GUI或ASP.NET之类的环境中，不建议使用`Task.Wait`和`Task.Result`方法。如果程序员对代码的实际情况不是100%了解，这可能会导致死锁。这在[第4章](ch04.html
    "第4章。使用任务并行库")的*使用任务并行库*中的*使用TaskScheduler调整任务执行*食谱中有所说明，当我们在WPF应用程序中使用`Task.Result`时。
- en: To test how exception handling works, just uncomment the `throw new Exception`
    line inside the `GetInfoAsync` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试异常处理的工作原理，只需取消注释`GetInfoAsync`方法中的`throw new Exception`行。
- en: Using the await operator in a lambda expression
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在lambda表达式中使用await运算符
- en: This recipe will show how to use `await` inside a lambda expression. We will
    write an anonymous method that uses `await`, and get a result of the method execution
    asynchronously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将展示如何在lambda表达式中使用`await`。我们将编写一个使用`await`的匿名方法，并异步地获得方法执行的结果。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe2`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个食谱进行操作，您需要Visual Studio 2012。没有其他先决条件。此食谱的源代码可以在`BookSamples\Chapter5\Recipe2`中找到。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To write an anonymous method that uses `await` and get a result of the method
    execution asynchronously by using the `await` operator in a lambda expression,
    perform the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写一个使用`await`的匿名方法，并通过在lambda表达式中使用`await`运算符异步地获得方法执行的结果，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the program.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, we move out the asynchronous function into the `AsynchronousProcessing`
    method since we cannot use `async` with `Main`. Then, we describe a lambda expression
    using the `async` keyword. As the type of any lambda expression cannot be inferred
    from the lambda itself, we have to specify its type to the C# compiler explicitly.
    In our case, the type means that our lambda accepts one string parameter, and
    returns a `Task<string>` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将异步函数移到`AsynchronousProcessing`方法中，因为我们不能在`Main`方法中使用`async`。然后，我们使用`async`关键字描述一个lambda表达式。由于任何lambda表达式的类型不能从lambda本身推断出来，我们必须明确地向C#编译器指定其类型。在我们的情况下，类型意味着我们的lambda接受一个字符串参数，并返回一个`Task<string>`对象。
- en: Then, we define the lambda expression body. One aberration is that the method
    is defined to return a `Task<string>` object, but we actually return a string,
    and get no compilation errors! The C# compiler automatically generates a task
    and returns it for us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义lambda表达式的主体。一个异常是，该方法被定义为返回一个`Task<string>`对象，但实际上我们返回一个字符串，并且没有编译错误！C#编译器会自动生成一个任务并为我们返回它。
- en: The last step is to await the asynchronous lambda expression execution and print
    out the result.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是等待异步lambda表达式的执行并打印出结果。
- en: Using the await operator with consequent asynchronous tasks
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用await操作符进行连续异步任务的执行
- en: This recipe will show how exactly the program flows when we have several consecutive
    `await` methods in the code. We will learn how to read the code with the `await`
    methods and understand why the `await` call is an asynchronous operation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个步骤将展示当代码中有几个连续的“await”方法时，程序流程是如何的。我们将学习如何阅读带有“await”方法的代码，并理解为什么“await”调用是一个异步操作。
- en: Getting ready
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe3`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤，你需要Visual Studio 2012。没有其他先决条件。这个步骤的源代码可以在“BookSamples\Chapter5\Recipe3”找到。
- en: How to do it...
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand a program flow in the presence of consecutive `await` methods,
    perform the following steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 理解在连续的“await”方法存在的情况下程序流程，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Program.cs”文件中，添加以下“using”指令：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法下面添加以下代码片段：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法内添加以下代码片段：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the program.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'When the program runs, we run two asynchronous operations just as in the first
    recipe. However, this time we shall start from the `AsynchronyWithAwait` method.
    It still looks like the usual synchronous code; the only difference is the two
    `await` statements. The most important point is that the code is still sequential,
    and the `Async 2` task will start only after the previous one completes. When
    we read the code, the program flow is very clear: we see what runs first, and
    what goes after. Then, how is this program asynchronous? Well, first, it is not
    always asynchronous. If a task is already complete when we use `await`, we will
    get its result synchronously. Otherwise, the common approach when we see an `await`
    statement inside the code is to note that at this point the method will return
    immediately and the rest of the code will be run in a continuation task. Since
    we do not block the execution waiting for the result of an operation, it is an
    asynchronous call. Instead of calling `t.Wait` in the `Main` method, we can perform
    any other task, while the code in `AsynchronyWithAwait` method is executing. However,
    the main thread must wait until all the asynchronous operations complete, or they
    will be stopped as they run on background threads.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，我们运行两个异步操作，就像在第一个步骤中一样。然而，这一次我们将从“AsynchronyWithAwait”方法开始。它看起来仍然像通常的同步代码；唯一的区别是两个“await”语句。最重要的一点是，代码仍然是顺序的，“Async
    2”任务只有在前一个任务完成后才会开始。当我们阅读代码时，程序流程非常清晰：我们看到什么先运行，然后是什么之后。那么，这个程序是如何异步的呢？嗯，首先，它并不总是异步的。如果一个任务在我们使用“await”时已经完成，我们将同步地得到它的结果。否则，当我们在代码中看到“await”语句时，通常的做法是注意到此时方法将立即返回，剩下的代码将在一个继续任务中运行。由于我们不阻塞等待操作的结果，这是一个异步调用。我们可以在“Main”方法中调用“t.Wait”之外的任何其他任务，而“AsynchronyWithAwait”方法中的代码正在执行。然而，主线程必须等待直到所有异步操作完成，否则它们将在后台线程上运行时被停止。
- en: The `AsynchronyWithTPL` method imitates the same program flow as the `AsynchronyWithAwait`
    method does. We need a container task to handle all the dependent tasks together.
    Then, we start the main task, and add a set of continuations to it. When the task
    is complete, we print out the result; we then start one more task, which in turn
    has more continuations to continue work after the second task completes. To test
    the exception handling, we throw an exception on purpose when running the second
    task and get its information printed out. This set of continuations creates the
    same program flow as in the first method, and when we compare it to the code with
    the `await` methods, we can see that it is much easier to read and understand.
    The only trick is to remember that asynchrony does not always mean parallel execution.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: “AsynchronyWithTPL”方法模拟了与“AsynchronyWithAwait”方法相同的程序流程。我们需要一个容器任务来一起处理所有依赖任务。然后，我们启动主任务，并为其添加一组继续任务。当任务完成时，我们打印出结果；然后，我们启动另一个任务，该任务在第二个任务完成后继续工作。为了测试异常处理，我们故意在运行第二个任务时抛出异常，并打印出其信息。这一系列的继续任务创建了与第一种方法相同的程序流程，当我们将其与带有“await”方法的代码进行比较时，我们可以看到它更容易阅读和理解。唯一的诀窍是要记住，异步并不总是意味着并行执行。
- en: Using the await operator for the execution of parallel asynchronous tasks execution
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用await操作符执行并行异步任务执行
- en: In this recipe, we will learn how to use `await` to run asynchronous operations
    in parallel instead of the usual sequential execution.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个步骤中，我们将学习如何使用“await”来并行运行异步操作，而不是通常的顺序执行。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe4`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个步骤，你需要Visual Studio 2012。没有其他先决条件。这个步骤的源代码可以在“BookSamples\Chapter5\Recipe4”找到。
- en: How to do it...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand the use of `await` operator for parallel asynchronous tasks execution,
    perform the following steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解使用“await”操作符进行并行异步任务执行，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#控制台应用程序项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Program.cs”文件中，添加以下“using”指令：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code below the `Main` method:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法下面添加以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Main”方法内添加以下代码片段：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the program.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here we define two asynchronous tasks running for 3 and 5 seconds respectively.
    Then, we use a `Task.WhenAll` helper method to create another task that will complete
    only when all of the underlying tasks complete. Then, we await the result of this
    combined task. After 5 seconds, we get all the results, which means that the tasks
    were running simultaneously.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了两个分别运行3秒和5秒的异步任务。然后，我们使用`Task.WhenAll`辅助方法创建另一个任务，只有当所有底层任务完成时才会完成。然后，我们等待此组合任务的结果。5秒后，我们得到了所有结果，这意味着任务是同时运行的。
- en: However, there is one interesting observation. When you run the program, you
    might notice that both tasks are likely to be served by the same worker thread
    from a thread pool. How is that possible when we have run the tasks in parallel?
    To make things even more interesting, let's comment out the `await Task.Delay`
    line inside the `GetIntroAsync` method and uncomment the `await Task.Run` line,
    and then run the program.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个有趣的观察。当您运行程序时，您可能会注意到两个任务很可能由线程池中的同一个工作线程提供服务。当我们并行运行任务时，这是如何可能的？为了使事情更有趣，让我们注释掉`GetIntroAsync`方法中的`await
    Task.Delay`行，并取消注释`await Task.Run`行，然后运行程序。
- en: 'We will see that in this case both the tasks will be served by different worker
    threads. The difference is that `Task.Delay` uses a timer under the hood, and
    the processing goes as follows: we get the worker thread from a thread pool, which
    awaits the `Task.Delay` method to return a result. Then, the `Task.Delay` method
    starts the timer and specifies a piece of code that will be called when the timer
    counts the number of seconds specified to the `Task.Delay` method. Then we immediately
    return the worker thread to a thread pool. When the timer event runs, we get any
    available worker thread from a thread pool once again (which could be the same
    thread we used first) and run the code provided to the timer on it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到在这种情况下，两个任务将由不同的工作线程提供服务。不同之处在于`Task.Delay`在内部使用了一个计时器，处理过程如下：我们从线程池中获取工作线程，它等待`Task.Delay`方法返回结果。然后，`Task.Delay`方法启动计时器，并指定在计时器计算`Task.Delay`方法指定的秒数时将调用的代码。然后我们立即将工作线程返回到线程池。当计时器事件运行时，我们再次从线程池中获取任何可用的工作线程（可能是我们首先使用的相同线程），并在其上运行计时器提供的代码。
- en: When we use the `Task.Run` method, we get a worker thread from a thread pool
    and make it block for a number of seconds, provided to the `Thread.Sleep` method.
    Then, we get a second worker thread and block it as well. In this scenario, we
    consume two worker threads and they do absolutely nothing, not being able to perform
    any other task while waiting.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Task.Run`方法时，我们从线程池中获取一个工作线程，并使其阻塞一段时间，提供给`Thread.Sleep`方法。然后，我们获取第二个工作线程并阻塞它。在这种情况下，我们消耗了两个工作线程，它们完全没有做任何事情，无法执行任何其他任务。
- en: We will talk in detail about the first scenario in [Chapter 9](ch09.html "Chapter 9. Using
    Asynchronous I/O"), *Using asynchronous I/O*, where we will discuss a large set
    of asynchronous operations working with data inputs and outputs. Using the first
    approach whenever possible is the key to creating scalable server applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第9章](ch09.html "第9章。使用异步I/O")中详细讨论第一种情况，*使用异步I/O*，在那里我们将讨论一大堆与数据输入和输出一起工作的异步操作。在可能的情况下始终使用第一种方法是创建可扩展服务器应用程序的关键。
- en: Handling exceptions in the asynchronous operations
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在异步操作中处理异常
- en: This recipe will describe how to deal with exception handling using asynchronous
    functions in C#. We will learn how to work with aggregate exceptions in case you
    use `await` with multiple parallel asynchronous operations.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将描述如何在C#中使用异步函数处理异常。我们将学习如何处理使用`await`进行多个并行异步操作时的聚合异常。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe5`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter5\Recipe5`中找到。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To understand handling exceptions in asynchronous operations, perform the following
    steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解异步操作中的异常处理，执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中添加以下代码片段：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We run three scenarios to illustrate the most common cases of error handling
    using `async` and `await` in C#. The first case is very simple, and almost identical
    to the usual synchronous code. We just use the `try`/`catch` statement and get
    the exception's details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行三个场景来说明在C#中使用`async`和`await`处理错误的最常见情况。第一种情况非常简单，几乎与通常的同步代码相同。我们只是使用`try`/`catch`语句并获取异常的详细信息。
- en: A very common mistake is using the same approach when more than one asynchronous
    operation is being awaited. If we use the `catch` block the same way as before,
    we will get only the first exception from the underlying `AggregateException`
    object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的错误是在等待多个异步操作时使用相同的方法。如果我们像以前一样使用`catch`块，我们将只从底层的`AggregateException`对象中得到第一个异常。
- en: To collect all the information, we have to use the awaited tasks' `Exception`
    property. In the third scenario, we flatten the `AggregateException` hierarchy,
    and then unwrap all the underlying exceptions from it using the `Flatten` method
    of `AggregateException`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了收集所有信息，我们必须使用等待任务的`Exception`属性。在第三种情况下，我们展平`AggregateException`层次结构，然后使用`AggregateException`的`Flatten`方法解开其中的所有异常。
- en: Avoid using the captured synchronization context
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免使用捕获的同步上下文
- en: This recipe talks about the details of synchronization context behavior when
    `await` is used to get asynchronous operation results. We will learn how and when
    to turn off the synchronization context flow.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程讨论了使用`await`获取异步操作结果时同步上下文行为的细节。我们将学习何时以及如何关闭同步上下文流。
- en: Getting ready
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe6`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照本教程进行，您需要Visual Studio 2012。没有其他先决条件。本教程的源代码可以在`BookSamples\Chapter5\Recipe6`中找到。
- en: How to do it...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To understand details of synchronization context behavior when `await` is used
    and to learn how and when to turn off the synchronization context flow, perform
    the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用`await`时同步上下文行为的细节，并学习何时以及如何关闭同步上下文流，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **Console Application**项目。
- en: Add references to Windows Presentation Foundation Library.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对Windows Presentation Foundation Library的引用。
- en: Right-click on the **References** folder in the project, and select the **Add
    reference…** menu option.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中右键单击**References**文件夹，然后选择**Add reference…**菜单选项。
- en: 'Add references to the following libraries: **PresentationCore**, **PresentationFramework**,
    **System.Xaml**, and **Windows.Base**. You can use the search function in the
    reference manager dialog as follows:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加对以下库的引用：**PresentationCore**，**PresentationFramework**，**System.Xaml**和**Windows.Base**。您可以使用引用管理器对话框中的搜索功能，如下所示：
- en: '![How to do it...](img/7644OT_05_01.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/7644OT_05_01.jpg)'
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Replace the `Main` method with the following code snippet:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码片段替换`Main`方法：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the program.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this example, we will study one of the most important aspects of an asynchronous
    function's default behavior. We already know about task schedulers and synchronization
    contexts from [Chapter 4](ch04.html "Chapter 4. Using Task Parallel Library"),
    *Using Task Parallel Library*. By default, the `await` operator tries to capture
    synchronization contexts, and executes the following code on it. As we already
    know, this helps us write asynchronous code by working with user interface controls.
    In addition, deadlock situations like those that were described in the previous
    chapter will not happen when using `await`, since we do not block the UI thread
    while waiting for the result.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将研究异步函数默认行为的最重要方面之一。我们已经从[第4章](ch04.html "第4章。使用任务并行库")*使用任务并行库*中了解了任务调度程序和同步上下文。默认情况下，`await`操作符会尝试捕获同步上下文，并在其上执行后续代码。正如我们已经知道的那样，这有助于我们通过使用用户界面控件编写异步代码。此外，使用`await`时不会发生死锁情况，因为我们在等待结果时不会阻塞UI线程，就像在上一章中描述的那样。
- en: It is reasonable, but let's see what can potentially happen. In this example,
    we create a Windows Presentation Foundation application programmatically and subscribe
    to its button-click event. When clicking the button, we run two asynchronous operations.
    One of them uses a regular `await` operator while the other uses the `ConfigureAwait`
    method with `false` as a parameter value. It explicitly instructs that we should
    not use captured synchronization contexts to run continuation code on it. Inside
    each operation, we measure the time they take to complete, and then we display
    the respective time and ratios on the main screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是合理的，但让我们看看可能发生的情况。在这个例子中，我们通过编程方式创建了一个Windows Presentation Foundation应用程序，并订阅了它的按钮点击事件。单击按钮时，我们运行两个异步操作。其中一个使用常规的`await`操作符，而另一个使用`ConfigureAwait`方法，并将`false`作为参数值。它明确指示我们不应该使用捕获的同步上下文来在其上运行继续代码。在每个操作中，我们测量它们完成所需的时间，然后在主屏幕上显示相应的时间和比率。
- en: As a result, we see that the regular `await` operator takes much more time to
    complete. This is because we post one hundred thousand continuation tasks on the
    UI thread, which uses its message loop to asynchronously work with those tasks.
    In this case, we do not need this code to run on the UI thread, since we do not
    access the UI components from the asynchronous operation; using `ConfigureAwait`
    with `false` will be a much more efficient solution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，我们看到常规的`await`操作符需要更长的时间才能完成。这是因为我们在UI线程上发布了十万个继续任务，它使用其消息循环来异步处理这些任务。在这种情况下，我们不需要此代码在UI线程上运行，因为我们不从异步操作中访问UI组件；使用`ConfigureAwait`和`false`将是一个更有效的解决方案。
- en: There is one more thing worth noting. Try to run the program by just clicking
    on the button and waiting for the results. Now do the same thing again, but this
    time click on the button and try to drag the application window from side-to-side
    in a random manner. You will notice that the code on the captured synchronization
    context becomes slower! This funny side-effect perfectly illustrates how dangerous
    asynchronous programming is. It is very easy to experience a situation like this,
    and it would be almost impossible to debug if you have never experienced such
    a behavior before.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件值得注意的事情。尝试只点击按钮运行程序并等待结果。现在再做同样的事情，但这次在点击按钮的同时尝试随机拖动应用程序窗口的一侧。您会注意到捕获的同步上下文中的代码变得更慢！这个有趣的副作用完美地说明了异步编程是多么危险。很容易遇到这样的情况，如果您以前从未经历过这样的行为，几乎不可能进行调试。
- en: To be fair, let's see the opposite scenario. In the preceding code snippet,
    inside the `Click` method, uncomment the commented line and comment its immediately
    preceding line. When running the application, we will get a multithreaded control
    access exception, because the code that sets the `Label` control text will not
    be posted on the captured context, but will be executed on a thread pool worker
    thread instead.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 公平起见，让我们看看相反的情况。在前面的代码片段中，在`Click`方法内部取消注释已注释的行，并注释其前面的行。运行应用程序时，我们将收到一个多线程控制访问异常，因为设置`Label`控件文本的代码不会发布在捕获的上下文上，而是在一个线程池工作线程上执行。
- en: Working around the async void method
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决`async void`方法的问题
- en: This recipe describes why `async void` methods are quite dangerous to use. We
    will learn in what situations it is acceptable to use this method, and what to
    use instead when possible.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例描述了为什么使用`async void`方法非常危险。我们将学习在什么情况下可以使用此方法，以及在可能的情况下应该使用什么。
- en: Getting ready
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe7`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter5\Recipe7`中找到。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to work with the `async void` method, perform the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要学习如何使用`async void`方法，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE19]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the program.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the program starts, we start two asynchronous operations by calling the
    two methods, `AsyncTask` and `AsyncVoid`. The first method returns a `Task` object
    while the other returns nothing since it is declared as `async void`. They both
    return immediately since they are asynchronous, but then the first one can be
    easily monitored with the returned task status or just by calling the `Wait` method
    on it. The only way to wait for the second method to complete is to literally
    wait for some time because we have not declared any object we can use to monitor
    the state of the asynchronous operation. Of course, it is possible to use some
    kind of shared state variable and set it from the `async void` method while checking
    it from the `calling` method, but it is better to just return a `Task` object
    instead.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 程序启动时，我们通过调用两个方法`AsyncTask`和`AsyncVoid`启动了两个异步操作。第一个方法返回一个`Task`对象，而另一个返回的是`async
    void`，因为它没有返回值。它们都立即返回，因为它们是异步的，但是第一个可以通过返回的任务状态轻松监视，或者只需调用其上的`Wait`方法。等待第二个方法完成的唯一方法是真正等待一段时间，因为我们没有声明任何可以用来监视异步操作状态的对象。当然，可以使用某种共享状态变量，并从`async
    void`方法中设置它，同时从`调用`方法中检查它，但最好还是返回一个`Task`对象。
- en: The most dangerous part is exception handling. In case of the `async void` method,
    the exception handling methods will be posted to a current synchronization context;
    in our case, a thread pool. An unhandled exception on a thread pool will terminate
    the whole process. It is possible to intercept unhandled exceptions using the
    `AppDomain.UnhandledException` event, but there is no way to recover the process
    from there. To experience this, we should uncomment the `try`/`catch` block inside
    the `Main` method, and then run the program.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的部分是异常处理。在`async void`方法的情况下，异常处理方法将被发布到当前同步上下文；在我们的情况下，是线程池。线程池上的未处理异常将终止整个进程。可以使用`AppDomain.UnhandledException`事件拦截未处理的异常，但没有办法从那里恢复进程。要体验这一点，我们应该取消注释`Main`方法内部的`try`/`catch`块，然后运行程序。
- en: 'Another fact about using the `async void` lambda expressions: they are compatible
    with the `Action` type, which is being widely used in the standard .NET Framework
    class library. It is very easy to forget about exception handling inside this
    lambda, which will crash the program again. To see an example of this, uncomment
    the second commented-out block inside the `Main` method.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用`async void` lambda表达式的另一个事实：它们与广泛使用的标准.NET Framework类库中的`Action`类型兼容。很容易忘记在此lambda内部进行异常处理，这将再次使程序崩溃。要查看此示例，请取消注释`Main`方法内部的第二个已注释的块。
- en: I strongly recommended using `async void` only in UI event handlers. In all
    other situations, use the methods that return `Task` instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议只在UI事件处理程序中使用`async void`。在所有其他情况下，请使用返回`Task`的方法。
- en: Designing a custom awaitable type
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计自定义可等待类型
- en: This recipe shows how to design a very basic awaitable type that is compatible
    with the `await` operator.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例展示了如何设计一个非常基本的可等待类型，与`await`运算符兼容。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. There are no
    other prerequisites. The source code for this recipe can be found at `BookSamples\Chapter5\Recipe8`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行此示例，您需要Visual Studio 2012。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter5\Recipe8`中找到。
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For designing a custom awaitable type, perform the following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要设计自定义可等待类型，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C#**控制台应用程序**项目。
- en: 'In the `Program.cs` file, add the following `using` directives:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，添加以下`using`指令：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Run the program.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To be compatible with the `await` operator, a type should comply with a number
    of requirements, stated in the C# 5.0 specification. If you have Visual Studio
    2012 installed, you may find the specifications document inside the `C:\Program
    Files\Microsoft Visual Studio 11.0\VC#\Specifications\1033` folder (assuming you
    have used the default installation path).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与`await`运算符兼容，类型应符合C# 5.0规范中规定的一些要求。如果您已安装Visual Studio 2012，则可以在`C:\Program
    Files\Microsoft Visual Studio 11.0\VC#\Specifications\1033`文件夹中找到规范文档（假设您已使用默认安装路径）。
- en: 'In paragraph 7.7.7.1, we find a definition of awaitable expressions:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7.7.7.1段中，我们找到了可等待表达式的定义：
- en: '*The task of an await expression is required to be awaitable. An expression
    t is awaitable if one of the following holds:*'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '*等待表达式的任务需要是可等待的。如果表达式t是可等待的，则满足以下条件之一：*'
- en: '*t is of compile time type dynamic*'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t是动态的编译时类型*'
- en: '*t has an accessible instance or extension method called GetAwaiter with no
    parameters and no type parameters, and a return type A for which all of the following
    hold:*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*t具有一个名为GetAwaiter的可访问的实例或扩展方法，没有参数和类型参数，并且返回类型A，对于该类型，满足以下所有条件：*'
- en: '*A implements the interface System.Runtime.CompilerServices.INotifyCompletion
    (hereafter known as INotifyCompletion for brevity)*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A实现了接口System.Runtime.CompilerServices.INotifyCompletion（以下简称INotifyCompletion）*'
- en: '*A has an accessible, readable instance property IsCompleted of type bool*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A具有可访问的、可读的bool类型的IsCompleted实例属性*'
- en: '*A has an accessible instance method GetResult with no parameters and no type
    parameters*'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A具有一个名为GetResult的可访问的实例方法，没有参数和类型参数*'
- en: This information is enough to get started. First, we define an awaitable type
    `CustomAwaitable` and implement the `GetAwaiter` method, that in turn returns
    an instance of the `CustomAwaiter` type. `CustomAwaiter` implements the `INotifyCompletion`
    interface; has the `IsCompleted` property of type `bool`, and has the `GetResult`
    method, which returns a `string` type. Finally, we write a piece of code that
    creates two `CustomAwaitable` objects and awaits both of them.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息足以让我们开始。首先，我们定义一个可等待类型`CustomAwaitable`并实现`GetAwaiter`方法，该方法反过来返回`CustomAwaiter`类型的实例。`CustomAwaiter`实现了`INotifyCompletion`接口；具有`bool`类型的`IsCompleted`属性，并且具有`GetResult`方法，该方法返回`string`类型。最后，我们编写了一段代码，创建了两个`CustomAwaitable`对象，并等待它们两个。
- en: Now we should understand the way `await` expressions are evaluated. This time,
    the specifications have not been quoted to avoid unnecessary details. Basically,
    if the `IsCompleted` property returns `true`, we just call the `GetResult` method
    synchronously. This prevents us from allocating resources for asynchronous task
    execution if the operation has already been completed. We cover this scenario
    by providing the `completeSynchronously` parameter to the constructor method of
    the `CustomAwaitable` object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该了解`await`表达式的评估方式。这次，为了避免不必要的细节，规范没有被引用。基本上，如果`IsCompleted`属性返回`true`，我们只需同步调用`GetResult`方法。这样，如果操作已经完成，我们就不需要为异步任务执行分配资源。我们通过向`CustomAwaitable`对象的构造方法提供`completeSynchronously`参数来覆盖这种情况。
- en: Otherwise, we register a callback action to the `OnCompleted` method of `CustomAwaiter`
    and start the asynchronous operation. When it completes, it calls the provided
    callback, which will get the result by calling the `GetResult` method on the `CustomAwaiter`
    object.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们将一个回调操作注册到`CustomAwaiter`的`OnCompleted`方法，并启动异步操作。当它完成时，它将调用提供的回调，该回调将通过在`CustomAwaiter`对象上调用`GetResult`方法来获取结果。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This implementation has been used for educational purposes only. Whenever you
    write asynchronous functions, the most natural approach is to use the standard
    `Task` type. You should define your own awaitable type only if you have a solid
    reason why you cannot use `Task`, and you know exactly what you are doing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现仅用于教育目的。每当编写异步函数时，最自然的方法是使用标准的`Task`类型。只有在您无法使用`Task`并且确切知道自己在做什么的情况下，才应该定义自己的可等待类型。
- en: There are many other topics related to designing custom awaitable types, such
    as the `ICriticalNotifyCompletion` interface implementation and synchronization
    context propagation. After understanding the basics of how an awaitable type is
    designed, you will be able to use the C# language specification and other information
    sources to find out the details you need with ease. But I would like to emphasize
    that you just use the `Task` type, unless you have a really good reason not to.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他与设计自定义可等待类型相关的主题，例如`ICriticalNotifyCompletion`接口实现和同步上下文传播。在了解了可等待类型的基本设计原理之后，您将能够使用C#语言规范和其他信息源轻松找到所需的详细信息。但我想强调的是，除非您有非常充分的理由，否则请使用`Task`类型。
- en: Using the dynamic type with await
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动态类型与等待
- en: This recipe shows how to design a very basic type that is compatible with the
    `await` operator and dynamic C# type.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了如何设计一个与`await`运算符和动态C#类型兼容的非常基本的类型。
- en: Getting ready
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To step through this recipe, you will need Visual Studio 2012\. You will need
    Internet access to download the NuGet package. There are no other prerequisites.
    The source code for this recipe can be found at `BookSamples\Chapter5\Recipe9`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照这个示例进行操作，您需要Visual Studio 2012。您需要互联网访问以下载NuGet包。没有其他先决条件。此示例的源代码可以在`BookSamples\Chapter5\Recipe9`中找到。
- en: How to do it...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To learn how to use the `dynamic` type with `await`, perform the following
    steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用`dynamic`类型与`await`，请执行以下步骤：
- en: Start Visual Studio 2012\. Create a new C# **Console Application** project.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Visual Studio 2012。创建一个新的C# **控制台应用程序**项目。
- en: 'Add references to the **ImpromptuInterface** NuGet package by following these
    steps:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下步骤添加对**ImpromptuInterface** NuGet包的引用：
- en: Right-click on the **References** folder in the project and select the Manage
    NuGet Packages… menu option.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中右键单击**引用**文件夹，然后选择**管理NuGet包...**菜单选项。
- en: 'Now add your preferred references to the **ImpromptuInterface NuGet** package.
    You can use the search function in the **Manage NuGet Packages** dialog as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将您喜欢的引用添加到**ImpromptuInterface NuGet**包中。您可以使用**管理NuGet包**对话框中的搜索功能，如下所示：
- en: '![How to do it...](img/7644OT_05_02.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/7644OT_05_02.jpg)'
- en: 'In the `Program.cs` file, use the following `using` directives:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，使用以下`using`指令：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code snippet below the `Main` method:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法下面添加以下代码片段：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the following code snippet inside the `Main` method:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部添加以下代码片段：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the program.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序。
- en: How it works...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Here, we repeat the trick from the previous recipe, but this time with the help
    of dynamic expressions. We can achieve this goal with the help of NuGet—a package
    manager that contains many useful libraries. This time we will use a library that
    dynamically creates wrappers, implementing the interfaces we need.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们重复了上一个示例中的技巧，但这次是借助动态表达式的帮助。我们可以通过NuGet来实现这个目标——一个包管理器，其中包含许多有用的库。这次我们将使用一个动态创建包装器并实现我们需要的接口的库。
- en: To start with, we create two instances of the `ExpandoObject` type and assign
    them to dynamic local variables. These variables will be our awaitable and awaiter
    objects. Since an awaitable object just requires having the `GetAwaiter` method,
    there are no problems with providing it. `ExpandoObject` combined with the `dynamic`
    keyword allows us to customize it and add properties and methods by assigning
    corresponding values. It is in fact a dictionary-type collection with keys of
    type `string` and values of type `object`. If you are familiar with the JavaScript
    programming language, you might notice that this is very similar to JavaScript
    objects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个`ExpandoObject`类型的实例，并将它们分配给动态局部变量。这些变量将是我们的awaitable和awaiter对象。由于awaitable对象只需要具有`GetAwaiter`方法，因此提供它没有问题。`ExpandoObject`与`dynamic`关键字结合使用，允许我们自定义它，并通过分配相应的值添加属性和方法。实际上，它是一种具有`string`类型键和`object`类型值的字典类型集合。如果您熟悉JavaScript编程语言，您可能会注意到这与JavaScript对象非常相似。
- en: Since `dynamic` allows us to skip compile-time checks in C#, `ExpandoObject`
    is written in such a way that if you assign something to a property, it creates
    a dictionary entry, where the key is the property name and a value is any value
    supplied. When you try to get the property value, it goes into the dictionary
    and provides the value that is stored in the corresponding dictionary entry. If
    the value is of the type `Action` or `Func`, we actually store a delegate, which
    in turn can be used like a method. Therefore, a combination of the `dynamic` type
    with `ExpandoObject` allows us to create an object and dynamically provide it
    with properties and methods.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`dynamic`允许我们在C#中跳过编译时检查，`ExpandoObject`是这样编写的，如果您将某些内容分配给属性，它会创建一个字典条目，其中键是属性名称，值是提供的任何值。当您尝试获取属性值时，它会进入字典并提供存储在相应字典条目中的值。如果值是`Action`或`Func`类型，我们实际上存储了一个委托，该委托反过来可以像方法一样使用。因此，`dynamic`类型与`ExpandoObject`的组合允许我们创建一个对象，并动态为其提供属性和方法。
- en: Now, we need to construct our awaiter and awaitable objects. Let's start with
    the awaiter. First, we provide a property called `Message` and an initial value
    to this property. Then, we define the `GetResult` method, by using a `Func<string>`
    type, we assign a lambda expression, which returns the `Message` property value.
    We next implement the `IsCompleted` property. If it is set to `true`, we can skip
    the rest of the work and proceed to our awaitable object, stored in the `result`
    local variable. We just need to add a method returning the `dynamic` object and
    return our awaiter from it. Then, we can use `result` as the await expression;
    however, it will run synchronously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要构建我们的awaiter和awaitable对象。让我们从awaiter开始。首先，我们提供一个名为`Message`的属性，并为该属性提供一个初始值。然后，我们定义`GetResult`方法，使用`Func<string>`类型，我们分配一个lambda表达式，该表达式返回`Message`属性的值。接下来，我们实现`IsCompleted`属性。如果设置为`true`，我们可以跳过其余的工作并继续进行我们的awaitable对象，存储在`result`局部变量中。我们只需要添加一个返回`dynamic`对象的方法，并从中返回我们的awaiter。然后，我们可以使用`result`作为await表达式；但是，它将以同步方式运行。
- en: The main challenge is implementing asynchronous processing on our dynamic object.
    C# language specifications state that an awaiter must implement the `INotifyCompletion`
    or `ICriticalNotifyCompletion` interface, which `ExpandoObject` does not do. And
    even when we implement the `OnCompleted` method dynamically, adding it to the
    awaiter object, we will not succeed because our object does not implement either
    of the mentioned interfaces.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 主要挑战是在我们的动态对象上实现异步处理。C#语言规范规定awaiter必须实现`INotifyCompletion`或`ICriticalNotifyCompletion`接口，而`ExpandoObject`并没有这样做。即使我们动态实现`OnCompleted`方法，并将其添加到awaiter对象中，我们也不会成功，因为我们的对象没有实现上述任何接口。
- en: To work around this problem, we use the `ImpromptuInterface` library that we
    obtained from NuGet. It allows us to use the `Impromptu.ActLike` method for dynamically
    creating proxy objects that will implement the required interface. If we try to
    create a proxy implementing the `INotifyCompletion` interface, we will still fail,
    because the proxy object is not dynamic anymore, and this interface has the `OnCompleted`
    method only, but does not have the `IsCompleted` property or the `GetResult` method.
    As the last workaround, we define a generic interface, `IAwaiter<T>`, which implements
    `INotifyCompletion` and adds all the required properties and methods. Now, we
    use it for proxy generation and change the `result` object to return a proxy instead
    of awaiter from the `GetAwaiter` method. The program now works; we have just constructed
    an awaitable object that is completely dynamic at runtime.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用了从NuGet获取的`ImpromptuInterface`库。它允许我们使用`Impromptu.ActLike`方法动态创建代理对象，这些对象将实现所需的接口。如果我们尝试创建一个实现`INotifyCompletion`接口的代理，我们仍然会失败，因为代理对象不再是动态的，而这个接口只有`OnCompleted`方法，但没有`IsCompleted`属性或`GetResult`方法。作为最后的解决方法，我们定义了一个通用接口`IAwaiter<T>`，它实现了`INotifyCompletion`并添加了所有必需的属性和方法。现在，我们将其用于代理生成，并将`result`对象更改为从`GetAwaiter`方法返回代理而不是awaiter。程序现在可以工作了；我们刚刚构建了一个在运行时完全动态的可等待对象。
