- en: Chapter 6. UDP and Multicasting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。UDP和多播
- en: '**User Datagram Protocol** (**UDP**) sits on top of IP and provides an unreliable
    counterpart to TCP. UDP sends individual packets between two nodes in a network.
    UDP packets do not have knowledge of other packets, and there is no guarantee
    that a packet will actually arrive at its intended destination. When multiple
    packets are sent, there is no guarantee of the arrival order. UDP messages are
    simply sent and then forgotten as there are no acknowledgements sent from a recipient.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户数据报协议**（**UDP**）位于IP之上，提供了TCP的不可靠对应。UDP在网络中的两个节点之间发送单独的数据包。UDP数据包不知道其他数据包，并且不能保证数据包实际到达其预期目的地。当发送多个数据包时，不能保证到达顺序。UDP消息只是被发送然后被遗忘，因为没有来自接收方的确认。'
- en: UDP is a connectionless protocol. There is no exchange of messages between two
    nodes to facilitate the packet transmission. No state information is maintained
    about the connection.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: UDP是一种无连接的协议。两个节点之间没有消息交换来促进数据包传输。关于连接的状态信息不会被维护。
- en: UDP is appropriate for services where delivery needs to be efficient, and no
    guarantee of delivery is needed. For example, it is used for **Domain Name System**
    (**DNS**) services, **Network** **Time Protocol** (**NTP**) services, **Voice
    Over IP** (**VOIP**), network communication coordination by P2P networks, and
    for video streaming. If a video frame is lost, then the viewer may never notice
    it if the loss does not occur frequently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: UDP适用于需要高效传递的服务，且不需要传递保证的情况。例如，它用于**域名系统**（**DNS**）服务，**网络时间协议**（**NTP**）服务，**语音传输**（**VOIP**），P2P网络的网络通信协调，以及视频流媒体。如果视频帧丢失，那么如果丢失不频繁，则观看者可能永远不会注意到。
- en: 'There are several protocols that use UDP, including:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种使用UDP的协议，包括：
- en: '**Real Time Streaming Protocol (RTSP)**: This protocol is used to control the
    streaming of media'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时流媒体协议（RTSP）**：该协议用于控制媒体的流媒体'
- en: '**Routing Information Protocol (RIP)**: This protocol determines the route
    that is used to transmit packets'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路由信息协议（RIP）**：该协议确定用于传输数据包的路由'
- en: '**Domain Name System (DNS)**: This protocol looks up an Internet domain name
    and returns its IP address'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**域名系统（DNS）**：该协议查找互联网域名并返回其IP地址'
- en: '**Network Time Protocol (NTP)**: This protocol synchronizes clocks across the
    Internet'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络时间协议（NTP）**：该协议在互联网上同步时钟'
- en: A UDP packet consists of an IP address and port number to identify its destination.
    The UDP packets have a fixed size and can be as large as 65,353 bytes. However,
    each packet uses a minimum of 20 bytes for an IP header and 8 bytes for a UDP
    header, limiting the size of a message to 65,507 bytes. If a message is larger
    than that, then multiple packets will need to be sent.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: UDP数据包由IP地址和端口号组成，用于标识其目的地。UDP数据包具有固定大小，最大可达65,353字节。然而，每个数据包使用最少20字节的IP头和8字节的UDP头，限制了消息的大小为65,507字节。如果消息大于这个大小，那么就需要发送多个数据包。
- en: UDP packets can also be multicast. This means that a packet is sent to every
    node that belongs to a UDP group. This is an efficient way of sending information
    to multiple nodes without having to explicitly target each node. Instead, the
    packet is sent to a group whose members are responsible for capturing its group's
    packets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: UDP数据包也可以进行多播。这意味着数据包被发送到属于UDP组的每个节点。这是一种有效的方式，可以将信息发送到多个节点，而无需明确地针对每个节点。相反，数据包被发送到一个负责捕获其组数据包的组。
- en: 'In this chapter, we will illustrate how the UDP protocol can be used to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将说明UDP协议如何被用于：
- en: Support the traditional client/server model
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持传统的客户端/服务器模型
- en: Use NIO Channels to perform UDP operations
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NIO通道执行UDP操作
- en: Multicast packets to group members
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多播数据包到组成员
- en: Stream media such as audio or video to a client
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户端流媒体，如音频或视频
- en: We will start with an overview of Java support for UDP and provide more UDP
    protocol details.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从Java对UDP的支持概述开始，并提供更多UDP协议的细节。
- en: Java support for UDP
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java对UDP的支持
- en: Java uses the `DatagramSocket` class to form socket connections between nodes.
    The `DatagramPacket` class represents a packet of data. Simple send and receive
    methods will transmit the packets across a network.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Java使用`DatagramSocket`类在节点之间形成套接字连接。`DatagramPacket`类表示数据包。简单的发送和接收方法将在网络中传输数据包。
- en: 'UDP uses an IP address and a port number to identify nodes. UDP port numbers
    range from `0` to `65535`. Port numbers are broken down into three types:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: UDP使用IP地址和端口号来标识节点。UDP端口号范围从`0`到`65535`。端口号分为三种类型：
- en: 'Well-known ports (`0` to `1023`): These are port numbers that are used for
    relatively common services.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知名端口（`0`到`1023`）：这些是用于相对常见服务的端口号。
- en: 'Registered ports (`1024` to `49151`): These are port numbers that are assigned
    by IANA to a process.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册端口（`1024`到`49151`）：这些是由IANA分配给进程的端口号。
- en: 'Dynamic/private ports (`49152` to `65535`): These are dynamically assigned
    to clients when a connection is initiated. These are normally temporary and cannot
    be assigned by IANA.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态/私有端口（`49152`到`65535`）：这些在连接初始化时动态分配给客户端。这些通常是临时的，不能由IANA分配。
- en: 'The following table is a short list of UDP specific port assignments. They
    illustrate how UDP is widely used to support many diverse applications and services.
    A more complete list of TCP/UDP port numbers is found at [https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格是UDP特定端口分配的简要列表。它们说明了UDP被广泛用于支持许多不同的应用和服务。TCP/UDP端口号的更完整列表可在[https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers](https://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers)找到：
- en: '| Well-known ports (0 to 1023) | Usage |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 知名端口（0到1023） | 用途 |'
- en: '| --- | --- |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `7` | This is the echo protocol |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `7` | 这是回显协议 |'
- en: '| `9` | This means wake-on-LAN |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `9` | 这意味着远程唤醒 |'
- en: '| `161` | This is the **Simple** **Network Management Protocol** (**SNMP**)
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `161` | 这是**简单** **网络管理协议**（**SNMP**）|'
- en: '| `319` | These are **Precision Time Protocol** (**PTP**) event messages |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `319` | 这些是**精密时间协议**（**PTP**）事件消息|'
- en: '| `320` | These are PTP general messages |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `320` | 这些是PTP通用消息|'
- en: '| `513` | This indicates who the user is |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `513` | 这表示用户是谁|'
- en: '| `514` | This is the syslog—used for system logging |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `514` | 这是syslog—用于系统日志|'
- en: '| `520` | This is the **Routing Information Protocol** (**RIP**) |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `520` | 这是**路由信息协议**（**RIP**）|'
- en: '| `750` | This is `kerberos-iv`, Kerberos version IV |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `750` | 这是`kerberos-iv`，Kerberos第四版|'
- en: '| `944` | This is the network file system service |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `944` | 这是网络文件系统服务|'
- en: '| `973` | This is the network file system over IPv6 service |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `973` | 这是IPv6上的网络文件系统服务|'
- en: 'The following table gives a list of the registered ports and their usage:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格列出了注册端口及其用途：
- en: '| Registered ports (1024 to 49151) | Usage |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 注册端口（1024到49151） | 用途 |'
- en: '| --- | --- |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `1534` | This is used for Eclipse **Target Communication Framework** (**TCF**)
    |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `1534` | 用于Eclipse**目标通信框架**（**TCF**）|'
- en: '| `1581` | This is used for MIL STD 2045-47001 VMF |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `1581` | 用于MIL STD 2045-47001 VMF|'
- en: '| `1589` | This is used for Cisco **VLAN Query Protocol** (**VQP**) / VMPS
    |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `1589` | 用于思科**虚拟局域网查询协议**（**VQP**）/ VMPS|'
- en: '| `2190` | This is used for TiVoConnect Beacon |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `2190` | 用于TiVoConnect Beacon|'
- en: '| `2302` | This is used for Halo: Combat Evolved multiplayer |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `2302` | 用于Halo：战斗进化多人游戏|'
- en: '| `3000` | This is used for BitTorrent sync |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `3000` | 用于BitTorrent同步|'
- en: '| `4500` | This is used for IPSec NAT traversal |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| `4500` | 用于IPSec NAT穿透|'
- en: '| `5353` | This is used for **Multicast DNS** (**mDNS**) |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| `5353` | 用于**多播DNS**（**mDNS**）|'
- en: '| `9110` | This is used for SSMP message protocol |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `9110` | 用于SSMP消息协议|'
- en: '| `27500` to `27900` | This is used for id Software''s QuakeWorld |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `27500`到`27900` | 用于id Software的QuakeWorld|'
- en: '| `29900` to `29901` | This is used for Nintendo Wi-Fi connection |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `29900`到`29901` | 用于任天堂Wi-Fi连接|'
- en: '| `36963` | This is used for Unreal Software multiplayer games |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `36963` | 用于虚幻软件多人游戏|'
- en: TCP versus UDP
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP与UDP
- en: 'There are several differences between TCP and UDP. These differences include
    the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP之间存在几个区别。这些区别包括以下内容：
- en: '**Reliability**: TCP is more reliable than UDP'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性：TCP比UDP更可靠
- en: '**Ordering**: TCP guarantees the order of packet transmission will be preserved'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺序**：TCP保证数据包传输的顺序将被保留'
- en: '**Header size**: The UDP header is smaller than the TCP header'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部大小**：UDP头部比TCP头部小'
- en: '**Speed**: UDP is faster than TCP'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：UDP比TCP更快'
- en: When a packet is sent using TCP, the packet is guaranteed to arrive. If it is
    lost, then it is re-sent. UDP does not offer this guarantee. If the packet does
    not arrive, then it is not re-sent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用TCP发送数据包时，数据包保证会到达。如果丢失，则会重新发送。UDP不提供此保证。如果数据包未到达，则不会重新发送。
- en: TCP preserves the order that packets are sent in, while UDP does not. If the
    TCP packets arrive at a destination in a different order than how they were sent,
    TCP will reassemble the packets in their original order. With UDP, this ordering
    is not preserved.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: TCP保留了发送数据包的顺序，而UDP则没有。如果TCP数据包到达目的地的顺序与发送时不同，TCP将重新组装数据包以恢复其原始顺序。而UDP则不保留此顺序。
- en: When a packet is created, header information is attached to assist in the delivery
    of the packet. With UDP the header consists of 8 bytes. The usual size of a TCP
    header is 32 bytes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据包时，会附加头信息以帮助传递数据包。使用UDP时，头部由8个字节组成。TCP头部的通常大小为32个字节。
- en: With a smaller header size and lack of the overhead to ensure reliability, UDP
    is more efficient than TCP. In addition, less effort is required to create a connection.
    This efficiency makes it a better choice to stream media.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于较小的头部大小和缺少确保可靠性的开销，UDP比TCP更有效率。此外，创建连接需要的工作量更少。这种效率使其成为流媒体的更好选择。
- en: Let's begin our UDP examples with how a traditional client/server architecture
    is supported.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从支持传统客户端/服务器架构的UDP示例开始。
- en: UDP client/server
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP客户端/服务器
- en: The UDP client/server applications are similar in structure to the structure
    used for TCP client/server applications. On the server side, a UDP server socket
    is created, which waits for client requests. The client will create a corresponding
    UDP socket and use it to send a message to the server. The server can then process
    the request and send back a response.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: UDP客户端/服务器应用程序的结构与TCP客户端/服务器应用程序所使用的结构类似。在服务器端，创建了一个UDP服务器套接字，等待客户端请求。客户端将创建相应的UDP套接字，并使用它向服务器发送消息。服务器随后可以处理请求并发送回响应。
- en: A UDP client/server will use the `DatagramSocket` class for the socket and a
    `DatagramPacket` to hold the message. There is no restriction on the message's
    content type. In our examples, we will be using a text message.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: UDP客户端/服务器将使用`DatagramSocket`类作为套接字，使用`DatagramPacket`来保存消息。消息的内容类型没有限制。在我们的示例中，我们将使用文本消息。
- en: The UDP server application
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP服务器应用程序
- en: 'Our server is defined next. The constructor will perform the work of the server:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来定义我们的服务器。构造函数将执行服务器的工作：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the constructor''s try-with-resources block, we create an instance of the
    `DatagramSocket` class. Several of the methods that we will be using may throw
    an `IOException` exception, which will be caught if necessary:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数的try-with-resources块中，我们创建了`DatagramSocket`类的实例。我们将使用的一些方法可能会抛出`IOException`异常，必要时将被捕获：
- en: '[PRE1]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'An alternate way of creating the socket is to use the `bind` method, as shown
    next. The `DatagramSocket` instance is created using `null` as the parameter.
    The port is then assigned with the `bind` method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 创建套接字的另一种方法是使用`bind`方法，如下所示。使用`null`作为参数创建`DatagramSocket`实例。然后使用`bind`方法分配端口：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Both approaches will create a `DatagramSocket` instance using port `9003`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都将使用端口`9003`创建`DatagramSocket`实例。
- en: 'The process of sending a message consists of the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息的过程包括以下步骤：
- en: Creating an array of bytes
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建字节数组
- en: Creating a `DatagramPacket` instance
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`DatagramPacket`实例
- en: Using the `DatagramSocket` instance to wait for a message to arrive
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DatagramSocket`实例等待消息到达
- en: 'The process is enclosed in a loop, as shown next, to allow multiple requests
    to be handled. The message that is received is simply echoed back to the client
    program. The `DatagramPacket` instance is created using the byte array and its
    length. It is used as the argument of the `DatagramSocket` class''s `receive`
    method. The packet does not hold any information at this time. This method will
    block until a request is made, and the packet will then be populated:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程被包含在一个循环中，如下所示，以允许处理多个请求。接收到的消息将简单地回显到客户端程序。使用字节数组及其长度创建`DatagramPacket`实例。它作为`DatagramSocket`类的`receive`方法的参数。此时数据包不包含任何信息。此方法将阻塞，直到有请求发出，然后数据包将被填充：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the method returns, the packet is converted into a string. If some other
    data type was sent, then some other conversion will be needed. The message that
    was sent is then displayed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法返回时，数据包将被转换为字符串。如果发送了其他数据类型，则需要其他转换。然后显示发送的消息：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To send a response, the address and port number of the client are needed. These
    are obtained using the `getAddress` and `getPort` methods, respectively, against
    the packet, which possesses this information. We will see this when we discuss
    the client. Also needed is the message that is represented as an array of bytes,
    which the `getBytes` method provides:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送响应，需要客户端的地址和端口号。这些分别使用`getAddress`和`getPort`方法从拥有这些信息的数据包中获取。我们将在讨论客户端时看到这一点。还需要的是表示为字节数组的消息，`getBytes`方法提供了这个消息：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A new `DatagramPacket` instance is created using the message, its length, and
    the client''s address and port number. The `send` method sends the packet to the
    client:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息、其长度和客户端的地址和端口号创建一个新的`DatagramPacket`实例。`send`方法将数据包发送到客户端：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: With the server defined, let's examine the client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了服务器，现在让我们来看看客户端。
- en: The UDP client application
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP客户端应用程序
- en: 'The client application will prompt the user for a message to send, and then
    it will send the message to the server. It will wait for a response and then display
    the response. It is declared here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序将提示用户输入要发送的消息，然后将消息发送到服务器。它将等待响应，然后显示响应。在这里声明：
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `Scanner` class supports getting user input. The try-with-resources block
    creates a `DatagramSocket` instance and handles exceptions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`类支持获取用户输入。try-with-resources块创建了一个`DatagramSocket`实例并处理异常：'
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The client''s current address is accessed using the `getByName` method, and
    a reference to an array of bytes is declared. This address will be used to create
    a packet:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getByName`方法访问客户端的当前地址，并声明一个字节数组的引用。此地址将用于创建数据包：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'An infinite loop is used to prompt the user for messages. When the user enters
    "quit", the application will terminate, as shown here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无限循环提示用户输入消息。当用户输入“quit”时，应用程序将终止，如下所示：
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To create a `DatagramPacket` instance holding the message, its constructor
    needs an array of bytes representing the message, its length, and the client''s
    address and port number. In the following code, the server''s port is `9003`.
    The `send` method will send the packet to the server:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个包含消息的`DatagramPacket`实例，其构造函数需要一个表示消息的字节数组，其长度以及客户端的地址和端口号。在下面的代码中，服务器的端口是`9003`。`send`方法将数据包发送到服务器：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To receive a response, a receive packet is created and used with the `receive`
    method in the same way that it was handled in the server. This method will block
    until the server responds, and then the message is displayed:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了接收响应，创建一个接收数据包，并与在服务器中处理方式相同地使用`receive`方法。此方法将阻塞，直到服务器响应，然后显示消息：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, let's see these applications at work.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这些应用程序是如何工作的。
- en: The UDP client/server in action
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP客户端/服务器在运行
- en: 'The server is started first. It will display the following message:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器。它将显示以下消息：
- en: '**UDP Server Started**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP服务器已启动**'
- en: 'Next, start the client application. It will display the following message:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端应用程序。它将显示以下消息：
- en: '**UDP Client Started**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP客户端已启动**'
- en: '**Enter a message:**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：**'
- en: 'Enter a message, such as the following one:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一条消息，例如以下消息：
- en: '**Enter a message: Top of the morning to you**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：早上好**'
- en: 'The server will display that it has received the message, as shown next. You
    will see several empty lines of output. This is the content of the 1024-byte array
    that is used to hold the message. The message is then echoed back to the client:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器将显示已收到消息，如下所示。您将看到几行空白的输出。这是用于保存消息的1024字节数组的内容。然后将消息回显到客户端：
- en: '**Received from client: [Top of the morning to you**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从客户端收到：[早上好**
- en: '**...**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '**]**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**]**'
- en: '**From: /127.0.0.1**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自：/127.0.0.1**'
- en: 'On the client side, the response is displayed. In this example, the users then
    enter "quit" to terminate the application:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端端，显示了响应。在这个例子中，用户然后输入“quit”来终止应用程序：
- en: '**Received from server [Top of the morning to you**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器收到：[早上好**
- en: '**...**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: '**]**'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**]**'
- en: '**from /127.0.0.1:9003**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自/127.0.0.1:9003**'
- en: '**Enter a message: quit**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入消息：quit**'
- en: '**UDP Client Terminating**'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP客户端终止**'
- en: 'As we are sending and receiving test messages, we can simplify the display
    of the message using the `trim` method when the message is displayed, as shown
    next. This code can be used on both the server and the client side:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在发送和接收测试消息，当显示消息时，可以使用`trim`方法简化消息的显示，如下所示。此代码可以在服务器和客户端两侧使用：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be easier to read, as shown here:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将更容易阅读，如下所示：
- en: '**Received from client: [Top of the morning to you]**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**从客户端收到：[早上好]**'
- en: '**From: /127.0.0.1**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**来自：/127.0.0.1**'
- en: This client/server application can be enhanced in a number of ways, including
    the use of threads, to enable it to work better with multiple clients. This example
    illustrates the basics of developing a UDP client/server application in Java.
    In the next section, we will see how channels support UDP.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个客户端/服务器应用程序可以通过多种方式进行增强，包括使用线程，以使其能够更好地与多个客户端一起工作。此示例说明了在Java中开发UDP客户端/服务器应用程序的基础知识。在下一节中，我们将看到通道如何支持UDP。
- en: Channel support for UDP
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP的通道支持
- en: The `DatagramChannel` class provides additional support for UDP. It can support
    nonblocking interchanges. The `DatagramChannel` class is derived from the `SelectableChannel`
    class that makes multithreaded application easier. We will examine its use in
    [Chapter 7](ch07.html "Chapter 7. Network Scalability"), *Network Scalability*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatagramChannel`类提供了对UDP的额外支持。它可以支持非阻塞交换。`DatagramChannel`类是从`SelectableChannel`类派生的，使多线程应用程序更容易。我们将在[第7章](ch07.html
    "第7章 网络可扩展性")中研究它的用法，*网络可扩展性*。'
- en: The `DatagramSocket` class binds a channel to a port. After this class is used,
    it is no longer used directly. Using the `DatagramChannel` class means, we do
    not have to use datagram packets directly. Instead, data is transferred using
    an instance of the `ByteBuffer` class. This class provides several convenient
    methods to access its data.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatagramSocket`类将通道绑定到端口。使用此类后，将不再直接使用。使用`DatagramChannel`类意味着我们不必直接使用数据报包。相反，数据是使用`ByteBuffer`类的实例进行传输。该类提供了几种方便的方法来访问其数据。'
- en: To demonstrate the use of the `DatagramChannel` class, we will develop an echo
    server and client application. The server will wait for a message from a client,
    and then send it back to the client.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示`DatagramChannel`类的用法，我们将开发一个回显服务器和客户端应用程序。服务器将等待来自客户端的消息，然后将其发送回客户端。
- en: The UDP echo server application
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP回显服务器应用程序
- en: 'The UDP echo server application declaration follows and uses port `9000`. In
    the `main` method a try-with-resources block opens the channel and creates a socket.
    The `DatagramChannel` class does not possess public constructors. To create a
    channel, we use the `open` method, which returns an instance of the `DatagramChannel`
    class. The channel''s `socket` method creates a `DatagramSocket` instance for
    the channel:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: UDP回显服务器应用程序声明如下，并使用端口`9000`。在`main`方法中，使用try-with-resources块打开通道并创建套接字。`DatagramChannel`类没有公共构造函数。要创建通道，我们使用`open`方法，它返回`DatagramChannel`类的实例。通道的`socket`方法为通道创建一个`DatagramSocket`实例：
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once created, we need to associate it with a port. This is done first by creating
    an instance of the `SocketAddress` class, which represents a socket address. The
    `InetSocketAddress` class is derived from the `SocketAddress` class and implements
    an IP address. Its use in the following code sequence will associate it with port
    `9000`. The `DatagramSocket` class''s `bind` method ties this address to the socket:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，我们需要将其与端口关联。首先通过创建`SocketAddress`类的实例来完成，该类表示套接字地址。`InetSocketAddress`类是从`SocketAddress`类派生的，并实现了IP地址。在以下代码序列中的使用将其与端口`9000`关联。`DatagramSocket`类的`bind`方法将此地址绑定到套接字：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ByteBuffer` class is central to using a datagram channel. We discussed
    its creation in [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"),
    *NIO Support for Networking*. In the next statement, an instance of this class
    is created with the `allocateDirect` method. This method will attempt to use native
    OS support directly on the buffer. This can be more efficient than using the datagram
    packet approach. Here, we created a buffer with the maximum size possible:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteBuffer`类是使用数据报通道的核心。我们在[第3章](ch03.html "第3章 NIO支持网络")中讨论了它的创建，*NIO支持网络*。在下一个语句中，使用`allocateDirect`方法创建了该类的一个实例。此方法将尝试直接在缓冲区上使用本机操作系统支持。这可能比使用数据报包方法更有效。在这里，我们创建了一个具有可能的最大大小的缓冲区：'
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the infinite loop that follows, which will receive a message from a client,
    display the message, and then send it back:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下无限循环，它将接收来自客户端的消息，显示消息，然后将其发送回去：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `receive` method is applied against a channel to get a client's message.
    It will block until the message is received. Its single argument is the byte buffer
    that is used to hold the incoming data. If the message exceeds the size of the
    buffer, the extra bytes are silently thrown away.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`receive`方法应用于通道以获取客户端的消息。它将阻塞直到消息被接收。它的单个参数是用于保存传入数据的字节缓冲区。如果消息超过缓冲区的大小，额外的字节将被静默丢弃。'
- en: 'The `flip` method enables the buffer to be processed. It sets the buffer''s
    limit to the current position in the buffer and then sets the position to `0`.
    Subsequent get type methods will start at the beginning of the buffer:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`flip`方法使缓冲区可以被处理。它将缓冲区的限制设置为缓冲区中的当前位置，然后将位置设置为`0`。随后的获取类型方法将从缓冲区的开头开始：'
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While not necessary for an echo server, the message that is received is displayed
    on the server. This allows us to verify that the message was received and suggests
    how messages can be modified to do more than simply echoing the message.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对于回显服务器来说并非必需，但接收到的消息会显示在服务器上。这样可以验证消息是否已接收，并建议如何修改消息以实现更多功能，而不仅仅是回显消息。
- en: In order to display the message, we need to use the `get` method to get each
    byte and then convert it to the appropriate type. The echo server is intended
    to echo simple strings. Thus, the byte needs to be cast to a char before it is
    displayed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示消息，我们需要使用`get`方法逐个获取每个字节，然后将其转换为适当的类型。回显服务器旨在回显简单的字符串。因此，在显示之前，需要将字节转换为字符。
- en: However, the `get` method modifies the current position in the buffer. We need
    to restore the position to its original state before we send the message back
    to the client. The buffer's `mark` and `reset` method are used for this purpose.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`get`方法修改了缓冲区中的当前位置。在将消息发送回客户端之前，我们需要将位置恢复到其原始状态。缓冲区的`mark`和`reset`方法用于此目的。
- en: 'All of this is performed in the following code sequence. The `mark` method
    sets the mark at the current position. A `StringBuilder` instance is used to recreate
    the string that was sent by the client. The buffer''s `hasRemaining` method controls
    the while loop. The message is displayed and the `reset` method restores the position
    to the previously marked value:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在以下代码序列中执行。`mark`方法在当前位置设置标记。使用`StringBuilder`实例重新创建客户端发送的字符串。缓冲区的`hasRemaining`方法控制while循环。消息被显示，`reset`方法将位置恢复到先前标记的值：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The last step is to send the byte buffer back to the client. The `send` method
    does this. A message indicating that the message has been sent is displayed, followed
    by the `clear` method. This method is used because we are through with the buffer.
    It will set the position to 0, set the limit of the buffer to its capacity, and
    discard the mark:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将字节缓冲区发送回客户端。`send`方法执行此操作。显示消息指示消息已发送，然后是`clear`方法。因为我们已经完成了缓冲区的使用，所以使用此方法。它将位置设置为0，将缓冲区的限制设置为其容量，并丢弃标记：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When the server is started, we will see a message to this effect, as shown
    here:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器启动时，我们将看到此效果的消息，如下所示：
- en: '**UDP Echo Server Started**'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP回声服务器已启动**'
- en: We are now ready to see how the client is implemented.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备看看客户端是如何实现的。
- en: The UDP echo client application
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP回显客户端应用程序
- en: 'The implementation of the UDP echo client is simple and uses these steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: UDP回显客户端的实现简单，并使用以下步骤：
- en: A connection to the echo server is established
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与回声服务器建立连接
- en: A byte buffer is created to hold the message
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个字节缓冲区来保存消息
- en: The buffer is sent to the server
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲区被发送到服务器
- en: The client blocks until the message is sent back
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端阻塞，直到消息被发送回来
- en: 'The client''s implementation details are similar to the server''s. We start
    with the declaration of the application, as shown here:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端的实现细节与服务器的类似。我们从应用程序的声明开始，如下所示：
- en: '[PRE21]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the server, the single argument `InetSocketAddress` constructor associates
    port `9000` with the current IP address. Within the client, we need to specify
    the IP address of the server along with the port. Otherwise, it will be unable
    to determine where to send the message. This is accomplished in the following
    statement using the class''s two-argument constructor. We use the address, `127.0.0.1`,
    assuming that the client and the server are on the same machine:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，单参数`InetSocketAddress`构造函数将端口`9000`与当前IP地址关联。在客户端中，我们需要指定服务器的IP地址和端口。否则，它将无法确定要发送消息的位置。这是在以下语句中使用类的两个参数构造函数来实现的。我们使用地址`127.0.0.1`，假设客户端和服务器在同一台机器上：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The channel is then created with the `open` method and connected to the socket
    address with the `connect` method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`open`方法创建通道，并使用`connect`方法连接到套接字地址：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the next code sequence, the message string is created, and the byte buffer
    is allocated. The size of the buffer is set to the length of the string. The `put`
    method then assigns the message to the buffer. As the `put` method expects an
    array of bytes, we use the `String` class''s `getBytes` method to obtain an array
    of bytes corresponding to the message''s contents:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个代码序列中，创建消息字符串，并分配字节缓冲区。将缓冲区的大小设置为字符串的长度。然后，`put`方法将消息分配给缓冲区。由于`put`方法需要一个字节数组，我们使用`String`类的`getBytes`方法获取与消息内容对应的字节数组：
- en: '[PRE24]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Before we send the buffer to the server, the `flip` method is called. It will
    set the limit to the current position and set the position to 0\. Thus, when received
    by the server it can be processed:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在将缓冲区发送到服务器之前，调用`flip`方法。它将设置限制为当前位置，并将位置设置为0。因此，当服务器接收时，可以进行处理：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To send the message to the server, the channel''s `write` method is called,
    as shown next. This will send the underlying packet directly to the server. However,
    this method only works if the channel''s socket is connected, which was achieved
    earlier:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要将消息发送到服务器，调用通道的`write`方法，如下所示。这将直接将底层数据包发送到服务器。但是，此方法仅在通道的套接字已连接时才有效，这是之前实现的：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, the buffer is cleared, allowing us to reuse the buffer. The `read` method
    will receive the buffer, and the buffer will be displayed using the same process
    that was used in the server:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，清除缓冲区，允许我们重用缓冲区。`read`方法将接收缓冲区，并且缓冲区将使用与服务器中使用的相同的过程显示：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We are now ready to use the client in conjunction with the server.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备与服务器一起使用客户端。
- en: The UDP echo client/server in action
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP回显客户端/服务器正在运行
- en: 'The server needs to be started first. We will see the initial server message,
    as shown here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要启动服务器。我们将看到初始服务器消息，如下所示：
- en: '**UDP Echo Server Started**'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP回声服务器已启动**'
- en: 'Next, start the client. The following output will be displayed showing the
    client sending the message and then showing the returned message:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端。将显示以下输出，显示客户端发送消息，然后显示返回的消息：
- en: '**UDP Echo Client Started**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP回显客户端已启动**'
- en: '**Sent: [The message]**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：[消息]**'
- en: '**Received: [The message]**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收：[消息]**'
- en: '**UDP Echo Client Terminated**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP回显客户端终止**'
- en: 'On the server side, we will see the message being received and then being sent
    back to the client:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们将看到消息被接收，然后被发送回客户端：
- en: '**Received: [The message]**'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收：[消息]**'
- en: '**Sent: [The message]**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：[消息]**'
- en: Using the `DatagramChannel` class can make UDP communications faster.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`DatagramChannel`类可以使UDP通信更快。
- en: UDP multicasting
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP多播
- en: Multicasting is the process of sending a message to multiple clients at the
    same time. Each client will receive the same message. In order to participate
    in this process, clients need to join a multicast group. When a message is sent,
    its destination address indicates that it is a multicast message. The multicast
    groups are dynamic with clients entering and leaving the group at any time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 多播是将消息同时发送给多个客户端的过程。每个客户端将接收相同的消息。为了参与此过程，客户端需要加入多播组。当发送消息时，其目标地址指示它是多播消息。多播组是动态的，客户端可以随时加入和离开组。
- en: Multicast is the old IPv4 CLASS D space and uses addresses `224.0.0.0` through
    `239.255.255.255`. The IPv4 Multicast Address Space Registry lists multicast address
    assignments and is found at [http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml](http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml).
    The *Host Extensions for IP Multicasting* document is found at [http://tools.ietf.org/html/rfc1112](http://tools.ietf.org/html/rfc1112).
    It defines the implementation requirements to support multicasting.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 多播是旧的IPv4 CLASS D空间，使用地址`224.0.0.0`到`239.255.255.255`。IPv4多播地址空间注册表列出了多播地址分配，并可在[http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml](http://www.iana.org/assignments/multicast-addresses/multicast-addresses.xml)找到。*IP多播主机扩展*文档可在[http://tools.ietf.org/html/rfc1112](http://tools.ietf.org/html/rfc1112)找到。它定义了支持多播的实现要求。
- en: The UDP multicast server
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP多播服务器
- en: 'The server application is declared next. This server is a time server that
    will broadcast the current data and time every second. This is a good use for
    multicast messages as there may be several clients interested in the same information,
    and reliability is not a concern. The try block will handle exceptions as they
    occur:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明服务器应用程序。这个服务器是一个时间服务器，每秒广播当前日期和时间。这是多播消息的一个很好的用途，因为可能有几个客户端对相同的信息感兴趣，可靠性不是一个问题。try块将处理异常：
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'An instance of the `MulticastSocket` class is needed along with an `InetAddress`
    instance holding the multicast IP address. In this example, the address, `228.5.6.7`,
    represents the multicast group. The `joinGroup` method is used to join this multicast
    group, as shown here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 需要`MulticastSocket`类的一个实例，以及保存多播IP地址的`InetAddress`实例。在本例中，地址`228.5.6.7`代表多播组。使用`joinGroup`方法加入此多播组，如下所示：
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to send a message, we need an array of bytes to hold the message and
    a packet. These are declared as shown here:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发送消息，我们需要一个字节数组来保存消息和一个数据包。如下所示声明：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The server application will use an infinite loop to broadcast a new date and
    time every second. The thread is paused for one second, and then a new date and
    time is created using the `Data` class. The `DatagramPacket` instance is created
    using this information. Port `9877` is assigned for this server and will need
    to be known by the client. The `send` method sends the packet to interested clients:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器应用程序将使用无限循环每秒广播一个新的日期和时间。线程暂停一秒，然后使用`Data`类创建一个新的日期和时间。使用此信息创建`DatagramPacket`实例。为此服务器分配端口`9877`，客户端需要知道该端口。`send`方法将数据包发送给感兴趣的客户端：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The client application is discussed next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论客户端应用程序。
- en: The UDP multicast client
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP多播客户端
- en: 'This application will join the multicast group as defined by the address `228.5.6.7`.
    It will block until a message is received, and then it will display the message.
    The application is defined as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将加入由地址`228.5.6.7`定义的多播组。它将阻塞直到接收到消息，然后显示消息。应用程序定义如下：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: An instance of the `MulticastSocket` class is created using the port number
    `9877`. This is needed so that it can connect to the UDP multicast server. An
    `InetAddress` instance is created using the multicast address of `228.5.6.7`.
    The client then joins the multicast group using the `joinGroup` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用端口号`9877`创建`MulticastSocket`类的实例。这是必需的，以便它可以连接到UDP多播服务器。使用多播地址`228.5.6.7`创建`InetAddress`实例。然后客户端使用`joinGroup`方法加入多播组。
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'A `DatagramPacket` instance is needed to receive messages that were sent to
    the client. An array of bytes is created and used to instantiate this packet,
    as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个`DatagramPacket`实例来接收发送到客户端的消息。创建一个字节数组并用于实例化此数据包，如下所示：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The client application then enters an infinite loop where it blocks at the
    `receive` method until the server sends a message. Once the message has arrived,
    the message is displayed:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后客户端应用程序进入无限循环，在`receive`方法处阻塞，直到服务器发送消息。一旦消息到达，消息将被显示：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we will demonstrate how the client and the server interact.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将演示客户端和服务器是如何交互的。
- en: The UDP multicast client/server in action
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP多播客户端/服务器正在运行
- en: 'Start the server. The output of the server will be similar to the following
    one, but the date and time will be different:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务器。服务器的输出将类似于以下内容，但日期和时间将不同：
- en: '**UDP Multicast Time Server Started**'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP多播时间服务器已启动**'
- en: '**Sending: [Sat Sep 19 13:48:42 CDT 2015]**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:42 CDT]
- en: '**Sending: [Sat Sep 19 13:48:43 CDT 2015]**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:43 CDT]
- en: '**Sending: [Sat Sep 19 13:48:44 CDT 2015]**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:44 CDT]
- en: '**Sending: [Sat Sep 19 13:48:45 CDT 2015]**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:45 CDT]
- en: '**Sending: [Sat Sep 19 13:48:46 CDT 2015]**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:46 CDT]
- en: '**Sending: [Sat Sep 19 13:48:47 CDT 2015]**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 发送：[2015年9月19日周六13:48:47 CDT]
- en: '**...**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: 'Next, start the client application. It will start receiving messages similar
    to the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来启动客户端应用程序。它将开始接收类似以下内容的消息：
- en: '**UDP Multicast Time Client Started**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**UDP多播时间客户端已启动**'
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:44 CDT 2015]**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：/192.168.1.7 消息：[2015年9月19日周六13:48:44 CDT]
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:45 CDT 2015]**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：/192.168.1.7 消息：[2015年9月19日周六13:48:45 CDT]
- en: '**Message from: /192.168.1.7 Message: [Sat Sep 19 13:48:46 CDT 2015]**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 来自：/192.168.1.7 消息：[2015年9月19日周六13:48:46 CDT]
- en: '**...**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the program is executed on a Mac, it may be through a socket exception. If
    this happens, use the `-Djava.net.preferIPv4Stack=true VM` option.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序在Mac上执行，可能会出现套接字异常。如果发生这种情况，请使用`-Djava.net.preferIPv4Stack=true VM`选项。
- en: If you start subsequent clients, each client will receive the same series of
    server messages.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果启动后续客户端，每个客户端将接收相同系列的服务器消息。
- en: UDP multicasting with channels
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用通道的UDP多播
- en: We can also multicast with channels. We will use IPv6 to demonstrate this process.
    The process is similar to our previous use of the `DatagramChannel` class, except
    that we need to use a multicast group. To do this, we need to know which network
    interfaces are available. Before we get into the specifics of using channels to
    multicast, we will demonstrate how to obtain a list of network interfaces for
    a machine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用通道进行多播。我们将使用IPv6来演示这个过程。这个过程类似于我们之前使用`DatagramChannel`类的过程，只是我们需要使用多播组。为此，我们需要知道哪些网络接口是可用的。在我们进入使用通道进行多播的具体细节之前，我们将演示如何获取机器的网络接口列表。
- en: 'The `NetworkInterface` class represents a network interface. This class was
    discussed in [Chapter 2](ch02.html "Chapter 2. Network Addressing"), *Network
    Addressing*. The following is a variation of the approach demonstrated in that
    chapter. It has been augmented to show whether a specific interface supports multicasting,
    as shown next:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: “NetworkInterface”类表示网络接口。这个类在[第2章](ch02.html "第2章。网络寻址")中讨论过，*网络寻址*。以下是该章节中演示的方法的变体。它已经增强，以显示特定接口是否支持多播，如下所示：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `displayNetworkInterfaceInformation` method is shown next. This approach
    has been adapted from [https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html](https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html):'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来显示`displayNetworkInterfaceInformation`方法。这种方法是从[https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html](https://docs.oracle.com/javase/tutorial/networking/nifs/listing.html)中改编的：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When this example is executed, you will get output similar to the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此示例时，您将获得类似以下的输出：
- en: '**Display name: Software Loopback Interface 1**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示名称：软件环回接口1**'
- en: '**Name: lo**'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称：lo**'
- en: '**Supports Multicast: true**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持多播：true**'
- en: '**InetAddress: /127.0.0.1**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/127.0.0.1**'
- en: '**InetAddress: /0:0:0:0:0:0:0:1**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/0:0:0:0:0:0:0:1**'
- en: '**Display name: Microsoft Kernel Debug Network Adapter**'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示名称：Microsoft Kernel 调试网络适配器**'
- en: '**Name: eth0**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：eth0
- en: '**Supports Multicast: true**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持多播：true**'
- en: '**Display name: Realtek PCIe FE Family Controller**'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示名称：Realtek PCIe FE Family Controller**'
- en: '**Name: eth1**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称：eth1**'
- en: '**Supports Multicast: true**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持多播：true**'
- en: '**InetAddress: /fe80:0:0:0:91d0:8e19:31f1:cb2d%eth1**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/fe80:0:0:0:91d0:8e19:31f1:cb2d%eth1**'
- en: '**Display name: Realtek RTL8188EE 802.11 b/g/n Wi-Fi Adapter**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示名称：Realtek RTL8188EE 802.11 b/g/n Wi-Fi 适配器**'
- en: '**Name: wlan0**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称：wlan0**'
- en: '**Supports Multicast: true**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持多播：true**'
- en: '**InetAddress: /192.168.1.7**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/192.168.1.7**'
- en: '**InetAddress: /2002:42be:6659:0:0:0:0:1001**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/2002:42be:6659:0:0:0:0:1001**'
- en: '**InetAddress: /fe80:0:0:0:9cdb:371f:d3e9:4e2e%wlan0**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**InetAddress：/fe80:0:0:0:9cdb:371f:d3e9:4e2e%wlan0**'
- en: '**...**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: For our client/server, we will use the `eth0` interface. You will need to choose
    the one most appropriate for you platform. For example, on a Mac this may be `en0`
    or `awdl0`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的客户端/服务器，我们将使用`eth0`接口。您需要选择最适合您平台的接口。例如，在Mac上，这可能是`en0`或`awdl0`。
- en: The UDP channel multicast server
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP通道多播服务器
- en: 'The UDP channel multicast server will:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: UDP通道多播服务器将：
- en: Set up the channel and multicast group
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置通道和多播组
- en: Create a buffer containing a message
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建包含消息的缓冲区
- en: Use an infinite loop to send and display the group message
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用无限循环来发送和显示组消息
- en: 'The definition of the server is as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器的定义如下：
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first task uses the `System` class''s `setProperty` method to specify that
    IPv6 be used. A `DatagramChannel` instance is then created, and the `eth0` network
    interface is created. The `setOption` method will associate the channel with the
    network interface that was used to identify the group. The group is represented
    by an `InetSocketAddress` instance using an IPv6 node-local scope multicast address,
    as shown next. More details about the *IPv6 Multicast Address Space Registry*
    document can be found at [http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml](http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个任务使用`System`类的`setProperty`方法指定要使用IPv6。然后创建一个`DatagramChannel`实例，并创建`eth0`网络接口。`setOption`方法将通道与用于标识组的网络接口相关联。该组由一个`InetSocketAddress`实例表示，使用IPv6节点本地范围的多播地址，如下所示。有关*IPv6多播地址空间注册表*文档的更多详细信息，请访问[http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml](http://www.iana.org/assignments/ipv6-multicast-addresses/ipv6-multicast-addresses.xhtml)：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'A byte buffer is then created, based on a message string. The buffer''s size
    is set to the length of the string and is assigned using a combination of the
    `put` and `getBytes` methods:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建一个基于消息字符串的字节缓冲区。缓冲区的大小设置为字符串的长度，并使用`put`和`getBytes`方法的组合进行分配：
- en: '[PRE40]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the while loop, the buffer is sent out to group members. To clearly
    see what was sent, the contents of the buffer is displayed using the same code
    that was used in the *The UDP echo server application* section. The buffer is
    reset so that it can be used again. The application pauses for one second to avoid
    excessive messages for this example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在while循环内，缓冲区被发送到组成员。为了清楚地看到发送了什么，使用了与*UDP回显服务器应用程序*部分中使用的相同代码来显示缓冲区的内容。缓冲区被重置，以便可以再次使用。应用程序暂停一秒钟，以避免对这个例子产生过多的消息：
- en: '[PRE41]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We are now ready for the client application.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好客户端应用程序。
- en: The UDP channel multicast client
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP通道多播客户端
- en: The UDP channel multicast client will join the group, receive a message, display
    it, and then terminate. As we will see, the `MembershipKey` class represents membership
    to a multicast group.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: UDP通道多播客户端将加入组，接收消息，显示消息，然后终止。正如我们将看到的，`MembershipKey`类表示对多播组的成员资格。
- en: 'The application is declared as follows. First, we specify that IPv6 is to be
    used. The network interface is then declared, which is the same one that was used
    by the server:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序声明如下。首先，我们指定要使用IPv6。然后声明网络接口，这是服务器使用的相同接口：
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `DatagramChannel` instance is created next. The channel is bound to port
    `9003` and is associated with the network interface instance:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来创建`DatagramChannel`实例。该通道绑定到端口`9003`，并与网络接口实例相关联：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The group is then created based on the same IPv6 address that was used by the
    server, and a `MembershipKey` instance is created using the channel''s `join`
    method, as shown next. The key and a waiting message is displayed to illustrate
    how the client works:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 然后基于服务器使用的相同IPv6地址创建组，并使用通道的`join`方法创建一个`MembershipKey`实例，如下所示。为了说明客户端的工作原理，显示密钥和等待消息：
- en: '[PRE44]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'A byte buffer is created with a size of `1024`. This size will be sufficient
    for this example, The `receive` method is then called, which will block until
    a message is received:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个大小为`1024`的字节缓冲区。这个大小对于这个例子来说足够了，然后调用`receive`方法，该方法将阻塞直到接收到消息：
- en: '[PRE45]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To display the contents of the buffer, we need to flip it. The contents are
    displayed as we did previously:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示缓冲区的内容，我们需要将其翻转。内容将如之前所做的那样显示：
- en: '[PRE46]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When we are done with a membership key, we should indicate that we are no longer
    interested in receiving group messages using the `drop` method:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成一个成员资格密钥时，应该使用`drop`方法指示我们不再对接收组消息感兴趣：
- en: '[PRE47]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Messages may still arrive if there are packets waiting to be processed by the
    socket.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有待处理的数据包，消息仍然可能到达。
- en: The UDP channel multicast client/server in action
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP通道组播客户端/服务器正在运行
- en: 'Start the server first. This server will display a series of messages every
    second, as shown here:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 首先启动服务器。该服务器将每秒显示一系列消息，如下所示：
- en: '**Sent the multicast message: The message**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送组播消息：消息**'
- en: '**Sent: [The message]**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：[消息]**'
- en: '**Sent the multicast message: The message**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送组播消息：消息**'
- en: '**Sent: [The message]**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：[消息]**'
- en: '**Sent the multicast message: The message**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送组播消息：消息**'
- en: '**Sent: [The message]**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**发送：[消息]**'
- en: '**...**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**...**'
- en: 'Next, start the client application. It will display the multicast group, wait
    for a message, and then display the message, as shown here:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，启动客户端应用程序。它将显示组播组，等待消息，然后显示消息，如下所示：
- en: '**Joined Multicast Group: <ff01:0:0:0:0:0:0:fc,eth1>**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**加入组播组：<ff01:0:0:0:0:0:0:fc,eth1>**'
- en: '**Waiting for a message...**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**等待消息...**'
- en: '**Received: [The message]**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**接收：[消息]**'
- en: The use of a channel can improve the performance of UDP multicast messages.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通道可以提高UDP组播消息的性能。
- en: UDP streaming
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP流
- en: Using UDP to stream audio or videos is common. It is efficient and any loss
    of packets or out-of-order packets will cause minimal problems. We will illustrate
    this technique by steaming live audio. A UDP server will capture the microphone's
    sound and send it to a client. The UDP client will receive the audio and play
    it on the system's speakers.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用UDP来流式传输音频或视频是常见的。它是高效的，任何数据包的丢失或乱序都会导致最小的问题。我们将通过实时音频流来说明这种技术。UDP服务器将捕获麦克风的声音并将其发送给客户端。UDP客户端将接收音频并在系统扬声器上播放。
- en: The idea of a UDP streaming server is to break up the stream into a series of
    packets that are sent to a UDP client. The client will then receive these packets
    and use them to reconstitute a stream.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: UDP流服务器的概念是将流分解为一系列数据包，然后发送给UDP客户端。客户端将接收这些数据包并使用它们来重建流。
- en: 'In order to illustrate streaming audio, we need to know a bit about how Java
    handles audio streams. Audio is handled by a series of classes that are found
    in the `javax.sound.sampled` package. The primary classes that are used to capture
    and play audio include the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明流式音频，我们需要了解一些关于Java处理音频流的知识。音频由`javax.sound.sampled`包中的一系列类处理。用于捕获和播放音频的主要类包括以下内容：
- en: '`AudioFormat`: This class specifies the characteristics of the audio format
    that is used. As there are several audio formats available, the system needs to
    know which one is being used.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioFormat`：这个类指定所使用的音频格式的特性。由于有几种音频格式可用，系统需要知道使用的是哪一种。'
- en: '`AudioInputStream`: This class represents the audio that is being recorded
    or played.'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioInputStream`：这个类代表正在录制或播放的音频。'
- en: '`AudioSystem`: This class provides access to the system''s audio devices and
    resources.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioSystem`：这个类提供对系统音频设备和资源的访问。'
- en: '`DataLine`: This interface controls operations applied against a stream, such
    as starting and stopping a stream.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataLine`：这个接口控制应用于流的操作，比如启动和停止流。'
- en: '`SourceDataLine`: This represents the destination of the sound, such as a speaker.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SourceDataLine`：这代表声音的目的地，比如扬声器。'
- en: '`TargetDataLine`: This represents the source of the sound, such as a microphone.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TargetDataLine`：这代表声音的来源，比如麦克风。'
- en: The terminology that is used for the `SourceDataLine` and `TargetDataLine` interfaces
    may be a bit confusing. The terms are from the perspective of a line and a mixer.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`SourceDataLine`和`TargetDataLine`接口的术语可能有点令人困惑。这些术语是从线路和混音器的角度来看的。'
- en: The UDP audio server implementation
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP音频服务器实现
- en: 'The declaration of the `AudioUDPServer` class is as follows. It uses a `TargetDataLine`
    instance for the source of the audio. It is declared as an instance variable because
    it is used in multiple methods. The constructor uses a `setupAudio` method to
    initialize the audio and a `broadcastAudio` method to send this audio to a client:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '`AudioUDPServer`类的声明如下。它使用`TargetDataLine`实例作为音频的来源。它被声明为实例变量，因为它在多个方法中被使用。构造函数使用`setupAudio`方法来初始化音频，并使用`broadcastAudio`方法将音频发送给客户端：'
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The following is the `getAudioFormat` method, and it is used in both the server
    and the client to specify the audio-stream characteristics. The analog audio signal
    is sampled 1,600 times a second. Each sample is a signed 16-bit number. The `channels`
    variable is assigned `1`, meaning that the audio is mono. The order of the bytes
    in the sample is important and is set to big endian:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`getAudioFormat`方法，它在服务器和客户端中都被用来指定音频流的特性。模拟音频信号每秒采样1,600次。每个样本是一个带符号的16位数字。`channels`变量被赋值为`1`，意味着音频是单声道。样本中字节的顺序很重要，设置为大端序：
- en: '[PRE49]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Big endian and little endian refers to the order of bytes. Big endian means
    that the most-significant byte of a word is stored at the smallest memory address
    and the least significant byte at the largest memory address. Little endian reverses
    this order. Different computer architectures use different orderings.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 大端和小端是指字节的顺序。大端意味着一个字的最高有效字节存储在最小的内存地址，最低有效字节存储在最大的内存地址。小端颠倒了这个顺序。不同的计算机架构使用不同的顺序。
- en: 'The `setupAudio` method initializes the audio. The `DataLine.Info` class uses
    the audio format information to create a line representing audio. The `AudioSystem`
    class''s `getLine` method returns a data line that corresponds to a microphone.
    The line is opened and started:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupAudio`方法初始化音频。`DataLine.Info`类使用音频格式信息创建代表音频的线路。`AudioSystem`类的`getLine`方法返回与麦克风对应的数据线。该线路被打开并启动：'
- en: '[PRE50]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `broadcastAudio` method creates the UDP packets. A socket is created using
    port `8000` and an `InetAddress` instance is created for the current machine:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcastAudio`方法创建了UDP数据包。使用端口`8000`创建了一个套接字，并为当前机器创建了一个`InetAddress`实例：'
- en: '[PRE51]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'An infinite loop is entered where the `read` method fills the `audioBuffer`
    array and returns the number of bytes read. For counts greater than `0`, a new
    packet is created using the buffer and is sent to the client listening on port
    `9786`:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 进入一个无限循环，`read`方法填充`audioBuffer`数组并返回读取的字节数。对于大于`0`的计数，使用缓冲区创建一个新的数据包，并发送到监听端口`9786`的客户端：
- en: '[PRE52]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: When executed, the sound from the microphone is sent to the client as a series
    of packets.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时，来自麦克风的声音被作为一系列数据包发送到客户端。
- en: The UDP audio client implementation
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UDP音频客户端实现
- en: 'The `AudioUDPClient` application is declared next. In the constructor, an `initiateAudio`
    method is called to start the process of receiving packets from the server:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来声明了`AudioUDPClient`应用程序。在构造函数中，调用了一个`initiateAudio`方法来开始从服务器接收数据包的过程：
- en: '[PRE53]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `initiateAudio` method creates a socket that is bound to port `9786`. An
    array of bytes is created to hold audio data contained in the UDP packet:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`initiateAudio`方法创建一个绑定到端口`9786`的套接字。创建一个字节数组来保存UDP数据包中包含的音频数据：'
- en: '[PRE54]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'An infinite loop will receive packets from the server, create an `AudioInputStream`
    instance, and then call the `playAudio` method to play the sound. The packet is
    created in the following code and then blocks until a packet is received:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无限循环将从服务器接收数据包，创建一个`AudioInputStream`实例，然后调用`playAudio`方法来播放声音。以下代码创建数据包，然后阻塞直到接收到数据包：
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Next, the audio stream is created. An array of bytes is extracted from the
    packet. It is used as the argument of the `ByteArrayInputStream` constructor,
    which is used, along with the audio format information, to create the actual audio
    stream. This is associated with the `SourceDataLine` instance, which is opened
    and started. The `playAudio` method is called to play the sound:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建音频流。从数据包中提取一个字节数组。它被用作`ByteArrayInputStream`构造函数的参数，该构造函数与音频格式信息一起用于创建实际的音频流。这与`SourceDataLine`实例相关联，该实例被打开并启动。调用`playAudio`方法来播放声音：
- en: '[PRE56]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The `getAudioFormat` method is used and is the same one that was declared in
    the `AudioUDPServer` application. The `playAudio` method follows. The `read` method
    of `AudioInputStream` populates a buffer, which is written to the source data
    line. This effectively plays the sound on the system''s speakers:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getAudioFormat`方法，该方法与`AudioUDPServer`应用程序中声明的方法相同。接下来是`playAudio`方法。`AudioInputStream`的`read`方法填充一个缓冲区，然后写入源数据线。这有效地在系统扬声器上播放声音：
- en: '[PRE57]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: With the server running, starting the client will play the sounds from the server.
    The play can be enhanced through the use of threads in the server and client to
    handle the recording and playback of the sound. This detail has been left out
    to simplify the example.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行时，启动客户端将播放来自服务器的声音。可以通过在服务器和客户端中使用线程来处理声音的录制和播放来增强播放。为简化示例，这些细节已被省略。
- en: In this example, the continuous analog sound is digitized and broken into packets.
    These packets were then sent to a client where they were converted back into a
    sound and played.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，连续的模拟声音被数字化并分成数据包。然后将这些数据包发送到客户端，在那里它们被转换回声音并播放。
- en: There is additional support for UDP streaming found in several other frameworks.
    The **Java Media Framework** (**JMF**) ([http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html](http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html))
    supports the processing of audio and video media. The **Real-time Transport Protocol**
    (**RTP**) ([https://en.wikipedia.org/wiki/Real-time_Transport_Protocol](https://en.wikipedia.org/wiki/Real-time_Transport_Protocol))
    is used to send audio and video data across a network.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他几个框架中还有对UDP流的额外支持。**Java媒体框架**（**JMF**）([http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html](http://www.oracle.com/technetwork/articles/javase/index-jsp-140239.html))支持音频和视频媒体的处理。**实时传输协议**（**RTP**）([https://en.wikipedia.org/wiki/Real-time_Transport_Protocol](https://en.wikipedia.org/wiki/Real-time_Transport_Protocol))用于在网络上发送音频和视频数据。
- en: Summary
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we examined the nature of the UDP protocol and how Java supports
    it. We contrasted TCP and UDP to provide some guidance in deciding which protocol
    was best for a given problem.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了UDP协议的性质以及Java如何支持它。我们对比了TCP和UDP，以提供一些指导，帮助决定哪种协议对于特定问题最合适。
- en: We started with a simple UDP client/server to demonstrate how the `DatagramPacket`
    and `DatagramSocket` classes are used. We saw how the `InetAddress` class was
    used to obtain addresses used by sockets and packets.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个简单的UDP客户端/服务器开始，以演示`DatagramPacket`和`DatagramSocket`类的使用方式。我们看到了`InetAddress`类是如何用来获取套接字和数据包使用的地址的。
- en: The `DatagramChannel` class supports using NIO techniques in a UDP environment,
    which can be more efficient than using the `DatagramPacket` and `DatagramSocket`
    approach. The approach used a byte buffer to hold messages that were sent between
    a server and a client. This example illustrated many of the techniques that were
    developed in [Chapter 3](ch03.html "Chapter 3. NIO Support for Networking"), *NIO
    Support for Networking*.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`DatagramChannel`类支持在UDP环境中使用NIO技术，这可能比使用`DatagramPacket`和`DatagramSocket`方法更有效。该方法使用字节缓冲区来保存服务器和客户端之间发送的消息。这个例子展示了[第3章](ch03.html
    "第3章 网络的NIO支持")中开发的许多技术，即*网络的NIO支持*。'
- en: This was followed by a discussion of how UDP multicasting works. This provides
    a simple technique to broadcast a message to members of a group. The use of the
    `MulticastSocket`, `DatagramChannel`, and `MembershipKey` classes were illustrated.
    The latter class is used to establish a group when the `DatagramChannel` class
    is used.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来讨论了UDP多播的工作原理。这提供了一种简单的技术，可以向组成员广播消息。演示了`MulticastSocket`、`DatagramChannel`和`MembershipKey`类的使用。当使用`DatagramChannel`类时，后者类用于建立一个组。
- en: We concluded with an example of how UDP is used to support the streaming of
    audio. We detailed the use of several classes in the `javax.sound.sampled` package,
    including the `AudioFormat` and `TargetDataLine` classes to gather and play audio.
    We used the `DatagramSocket` and `DatagramPacket` classes to transmit the audio.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们举了一个UDP用于支持音频流的例子。我们详细介绍了`javax.sound.sampled`包中几个类的使用，包括`AudioFormat`和`TargetDataLine`类用于收集和播放音频。我们使用了`DatagramSocket`和`DatagramPacket`类来传输音频。
- en: In the next chapter, we will examine the techniques that are available to improve
    the scalability of client/server applications.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨可用于改善客户端/服务器应用程序可伸缩性的技术。
