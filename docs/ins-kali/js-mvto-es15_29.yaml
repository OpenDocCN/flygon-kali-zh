- en: Chapter 1. Breaking into Microservices Architecture
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。进入微服务架构
- en: The architecture of server-side application development for complex and large
    applications (applications with huge number of users and large volume of data)
    shouldn't just involve faster response and providing web services for wide variety
    of platforms. It should be easy to scale, upgrade, update, test, and deploy. It
    should also be highly available, allowing the developers write components of the
    server-side application in different programming languages and use different databases.
    Therefore, this leads the developers who build large and complex applications
    to switch from the common monolithic architecture to microservices architecture
    that allows us to do all this easily. As microservices architecture is being widely
    used in enterprises that build large and complex applications, it's really important
    to learn how to design and create server-side applications using this architecture.
    In this chapter, we will discuss how to create applications based on microservices
    architecture with Node.js using the Seneca toolkit.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂和大型应用程序（用户数量庞大，数据量大的应用程序），服务器端应用程序开发的架构不应只涉及更快的响应和为各种平台提供Web服务。它应该易于扩展、升级、更新、测试和部署。它还应该具有高可用性，允许开发人员使用不同的编程语言编写服务器端应用程序的组件并使用不同的数据库。因此，这导致构建大型和复杂应用程序的开发人员从常见的单块架构转换到微服务架构，这使我们可以轻松地完成所有这些。由于微服务架构广泛应用于构建大型和复杂应用程序的企业中，学习如何使用这种架构设计和创建服务器端应用程序非常重要。在本章中，我们将讨论如何使用Seneca工具包基于Node.js创建基于微服务架构的应用程序。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding monolithic architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解单块架构
- en: Scaling, upgrading, deploying, and writing applications based on monolithic
    architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于单块架构的扩展、升级、部署和编写应用程序
- en: Discussing microservices architecture in depth
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入讨论微服务架构
- en: Scaling, upgrading, deploying, and writing applications based on microservices
    architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展、升级、部署和编写基于微服务架构的应用程序
- en: Getting started with Seneca
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用Seneca
- en: Creating and calling services using Seneca
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Seneca创建和调用服务
- en: What is monolithic architecture?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是单块架构？
- en: To understand microservices architecture, it's important to first understand
    monolithic architecture, which is its opposite.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解微服务架构，首先要了解它的对立面——单块架构。
- en: In monolithic architecture, different functional components of the server-side
    application, such as payment processing, account management, push notifications,
    and other components, all blend together in a single unit.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在单块架构中，服务器端应用程序的不同功能组件（如支付处理、帐户管理、推送通知等组件）都融合在一个单元中。
- en: For example, applications are usually divided into three parts. The parts are
    HTML pages or native UI that run on the user's machine, server-side application
    that runs on the server, and database that also runs on the server. The server-side
    application is responsible for handling HTTP requests, retrieving and storing
    data in a database, executing algorithms, and so on. If the server-side application
    is a single executable (that is, running is a single process) that does all these
    tasks, then we say that the server-side application is monolithic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，应用程序通常分为三个部分。这些部分是运行在用户机器上的HTML页面或本机UI，运行在服务器上的服务器端应用程序，以及也运行在服务器上的数据库。服务器端应用程序负责处理HTTP请求，在数据库中检索和存储数据，执行算法等。如果服务器端应用程序是单个可执行文件（即运行在单个进程中）执行所有这些任务，那么我们称服务器端应用程序是单块的。
- en: This is a common way of building server-side applications. Almost every major
    CMS, web servers, server-side frameworks, and so on are built using monolithic
    architecture.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建服务器端应用程序的常见方式。几乎每个主要的CMS、Web服务器、服务器端框架等都是使用单块架构构建的。
- en: This architecture may seem successful, but problems are likely to arise when
    your application is large and complex.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构可能看起来很成功，但在应用程序庞大而复杂时，问题可能会出现。
- en: Demerits of monolithic architecture
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单块架构的缺点
- en: The following are some of the issues caused by server-side applications built
    using the monolithic architecture.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用单块架构构建的服务器端应用程序引起的一些问题。
- en: Scaling monolithic architecture
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展单块架构
- en: As traffic to your server-side application increases, you will need to scale
    your server-side application to handle the traffic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 随着对服务器端应用程序的流量增加，您将需要扩展服务器端应用程序以处理流量。
- en: 'In case of monolithic architecture, you can scale the server-side application
    by running the same executable on multiple servers and place the servers behind
    a load balancer or you can use round robin DNS to distribute the traffic among
    the servers:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在单块架构的情况下，您可以通过在多台服务器上运行相同的可执行文件并将服务器放在负载均衡器后面，或者您可以使用轮询DNS将流量分发到服务器之间来扩展服务器端应用程序：
- en: '![Scaling monolithic architecture](img/00100.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![扩展单块架构](img/00100.jpeg)'
- en: In the preceding diagram, all the servers will be running the same server-side
    application.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，所有服务器将运行相同的服务器端应用程序。
- en: Although scaling is easy, scaling monolithic server-side application ends up
    with scaling all the components rather than the components that require greater
    resource. Thus, causing unbalanced utilization of resources sometimes, depending
    on the quantity and types of resources the components need.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管扩展很容易，但扩展单块服务器端应用程序最终会导致所有组件的扩展，而不是需要更多资源的组件。因此，有时会导致资源的不平衡利用，这取决于组件需要的数量和类型。
- en: 'Let''s consider some examples to understand the issues caused while scaling
    monolithic server-side applications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一些例子来了解在扩展单块服务器端应用程序时引起的问题：
- en: Suppose there is a component of server-side application that requires a more
    powerful or special kind of hardware, we cannot simply scale this particular component
    as all the components are packed together, therefore everything needs to be scaled
    together. So, to make sure that the component gets enough resources, you need
    to run the server-side application on some more servers with powerful or special
    hardware, leading to consumption of more resources than actually required.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设服务器端应用程序的一个组件需要更强大或特殊类型的硬件，我们不能简单地扩展这个特定的组件，因为所有组件都打包在一起，因此需要一起扩展。因此，为了确保组件获得足够的资源，你需要在一些具有更强大或特殊硬件的服务器上运行服务器端应用程序，这会导致消耗比实际需要更多的资源。
- en: Suppose we have a component that requires to be executed on a specific server
    operating system that is not free of charge, we cannot simply run this particular
    component in a non-free operating system as all the components are packed together
    and therefore, just to execute this specific component, we need to install the
    non-free operating system on all servers, increasing the cost greatly.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设我们有一个组件需要在一个特定的收费服务器操作系统上执行，我们不能简单地在一个非免费的操作系统上运行这个特定的组件，因为所有组件都打包在一起，因此，为了执行这个特定的组件，我们需要在所有服务器上安装非免费的操作系统，大大增加成本。
- en: These are just some examples. There are many more issues that you are likely
    to come across while scaling a monolithic server-side application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一些例子。在扩展单片服务器端应用程序时，你可能会遇到更多问题。
- en: So, when we scale monolithic server-side applications, the components that don't
    need more powerful or special kind of resource starts receiving them, therefore
    deceasing resources for the component that needs them. We can say that scaling
    monolithic server-side application involves scaling all components that are forcing
    to duplicate everything in the new servers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们扩展单片服务器端应用程序时，那些不需要更强大或特殊资源的组件开始接收它们，因此减少了需要这些资源的组件的资源。我们可以说，扩展单片服务器端应用程序涉及扩展所有需要在新服务器中复制所有内容的组件。
- en: Writing monolithic server-side applications
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写单片服务器端应用程序
- en: Monolithic server-side applications are written in a particular programming
    language using a particular framework. Enterprises usually have developers who
    are experts in different programming languages and frameworks to build server-side
    applications; therefore, if they are asked to build a monolithic server-side application,
    then it will be difficult for them to work together.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单片服务器端应用程序是用特定的编程语言和特定的框架编写的。企业通常有不同编程语言和框架的专家开发人员来构建服务器端应用程序；因此，如果他们被要求构建单片服务器端应用程序，那么他们将很难共同合作。
- en: The components of a monolithic server-side application can be reused only in
    the same framework using, which it's built. So, you cannot reuse them for some
    other kind of project that's built using different technologies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单片服务器端应用程序的组件只能在使用它构建的相同框架中重用。因此，你不能将它们用于使用不同技术构建的其他类型的项目。
- en: Other issues of monolithic architecture
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单片架构的其他问题
- en: 'Here are some other issues that developers might face, depending on the technology
    that is used to build the monolithic server-side application:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是开发人员可能面临的其他问题，这取决于用于构建单片服务器端应用程序的技术：
- en: It may need to be completely rebuild and redeployed for every small change made
    to it. This is a time-consuming task and makes your application inaccessible for
    a long time.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次对其进行小的更改都可能需要完全重建和重新部署。这是一项耗时的任务，会使你的应用程序长时间无法访问。
- en: It may completely fail if any one of the components fails. It's difficult to
    build a monolithic application to handle failure of specific components and degrade
    application features accordingly.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何一个组件失败，它可能会完全失败。很难构建一个单片应用程序来处理特定组件的故障，并相应地降低应用程序的功能。
- en: It may be difficult to find how much resources are each components consuming.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难找到每个组件消耗了多少资源。
- en: It may be difficult to test and debug individual components separately.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能很难单独测试和调试各个组件。
- en: Microservices architecture to the rescue
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构来拯救
- en: We saw the problems caused by monolithic architecture. These problems lead developers
    to switch from monolithic architecture to microservices architecture.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了单片架构带来的问题。这些问题导致开发人员从单片架构转向微服务架构。
- en: In microservices architecture, the server-side application is divided into services.
    A service (or microservice) is a small and independent process that constitutes
    a particular functionality of the complete server-side application. For example,
    you can have a service for payment processing, another service for account management,
    and so on; the services need to communicate with each other via a network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，服务器端应用程序被划分为服务。一个服务（或微服务）是一个独立的小进程，构成完整服务器端应用程序的特定功能。例如，你可以为支付处理创建一个服务，为账户管理创建另一个服务，依此类推；这些服务需要通过网络相互通信。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**What do you mean by "small" service?**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**你说的“小”服务是什么意思？**'
- en: You must be wondering how small a service needs to be and how to tell whether
    a service is small or not. Well, it actually depends on many factors such as the
    type of application, team management, availability of resources, size of application,
    and how small you think is small. However, a small service doesn't have to be
    the one that is written is fewer lines of code or provides a very basic functionality.
    A small service can be the one on which a team of developers can work independently,
    which can be scaled independently to other services, scaling it doesn't cause
    unbalanced utilization of recourses, and overall they are highly decoupled (independent
    and unaware) of other services.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您一定想知道一个服务需要多小，以及如何判断一个服务是否小。嗯，这实际上取决于许多因素，例如应用程序的类型，团队管理，资源的可用性，应用程序的大小，以及您认为多小才算小。但是，一个小的服务不一定是代码行数较少或提供非常基本功能的服务。一个小的服务可以是一个开发团队可以独立工作的服务，可以独立扩展到其他服务，扩展它不会导致资源利用不平衡，总体上它们高度解耦（独立且不知道）其他服务。
- en: You don't have to run each service in a different server, that is, you can run
    multiple services in a single computer. The ratio of server to services depends
    on different factors. A common factor is the amount and type of resources and
    technologies required. For example, if a service needs a lot of RAM and CPU time,
    then it would be better to run it individually on a server. If there are some
    services that don't need much resources, then you can run them all in a single
    server together.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必在不同的服务器上运行每个服务，也就是说，您可以在单台计算机上运行多个服务。服务器与服务的比例取决于不同的因素。一个常见的因素是所需资源和技术的数量和类型。例如，如果一个服务需要大量的RAM和CPU时间，那么最好单独在服务器上运行它。如果有一些不需要太多资源的服务，那么您可以将它们全部运行在单个服务器上。
- en: 'The following diagram shows an example of the microservices architecture:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了微服务架构的一个示例：
- en: '![Microservices architecture to the rescue](img/00101.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![微服务架构解救](img/00101.jpeg)'
- en: Here, you can think of **Service 1** as the web server with which a browser
    communicates and other services providing APIs for various functionalities. The
    web services communicate with other services to get data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以将**服务1**视为浏览器通信的Web服务器和提供各种功能API的其他服务。Web服务与其他服务通信以获取数据。
- en: Merits of microservices architecture
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的优点
- en: 'Due to the fact that services are small and independent and communicate via
    network, microservices architecture solves many problems that monolithic architecture
    had. Here are some of the benefits of microservices architecture:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 由于服务小而独立，并且通过网络通信，微服务架构解决了单块架构存在的许多问题。以下是微服务架构的一些好处：
- en: As the services communicate via a network, they can be written in different
    programming languages using different frameworks
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务通过网络通信，它们可以使用不同的编程语言和不同的框架编写
- en: Making a change to a service only requires that particular service to be redeployed
    instead of all the services, which is a faster procedure
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对服务进行更改只需要重新部署特定的服务，而不是所有服务，这是一个更快的过程
- en: It becomes easier to measure how much resources are consumed by each service
    as each service runs in a different process
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以更容易地衡量每个服务消耗了多少资源，因为每个服务都在不同的进程中运行
- en: It becomes easier to test and debug, as you can analyze each service separately
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它变得更容易测试和调试，因为您可以单独分析每个服务
- en: Services can be reused by other applications as they interact via network calls
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务可以被其他应用程序重用，因为它们通过网络调用进行交互
- en: Scaling services
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展服务
- en: Apart from the preceding benefits, one of the major benefits of microservices
    architecture is that you can scale individual services that require scaling instead
    of all the services, therefore preventing duplication of resources and unbalanced
    utilization of resources.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的好处之外，微服务架构的一个主要好处是您可以扩展需要扩展的单个服务，而不是所有服务，从而防止资源的重复使用和资源利用不平衡。
- en: 'Suppose we want to scale **Service 1** in the preceding diagram. Here is a
    diagram that shows how it can be scaled:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要扩展前面图表中的**服务1**。以下是一个显示如何扩展它的图表：
- en: '![Scaling services](img/00102.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![扩展服务](img/00102.jpeg)'
- en: Here, we are running two instances of **Service 1** on two different servers
    kept behind a load balancer, which distributes the traffic between them. All other
    services run the same way, as scaling them wasn't required. If you wanted to scale
    **Service 3**, then you can run multiple instances of **Service 3** on multiple
    servers and place them behind a load balancer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在两台不同的服务器上运行两个**服务1**的实例，并将它们放在负载均衡器后面，负载均衡器在它们之间分配流量。所有其他服务都以相同的方式运行，因为不需要扩展它们。如果您想要扩展**服务3**，那么您可以在多台服务器上运行多个**服务3**的实例，并将它们放在负载均衡器后面。
- en: Demerits of microservices architecture
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务架构的缺点
- en: 'Although there are a lot of merits of using microservices architecture compared
    to monolithic architecture, there are some demerits of microservices architecture
    as well:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与单块架构相比，使用微服务架构有许多优点，但微服务架构也有一些缺点：
- en: As the server-side application is divided into services, deploying, and optionally,
    configuring each service separately is a cumbersome and time-consuming task.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务器端应用程序被划分为服务，部署和可选地配置每个服务都是一项繁琐和耗时的任务。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that developers often use some sort automation technology (such as AWS,
    Docker, and so on) to make deployment somewhat easier; however, to use it, you
    still need a good level of experience and expertise with that technology.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，开发人员通常使用某种自动化技术（如AWS，Docker等）来使部署变得更加容易；但是，要使用它，您仍然需要具有该技术的丰富经验和专业知识。
- en: Communication between services is likely to lag as it's done via a network.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务之间的通信是通过网络进行的，因此通信可能会出现滞后。
- en: This sort of server-side applications more prone to network security vulnerabilities
    as services communicate via a network.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种服务器端应用更容易受到网络安全漏洞的影响，因为服务通过网络通信。
- en: Writing code for communicating with other services can be harder, that is, you
    need to make network calls and then parse the data to read it. This also requires
    more processing. Note that although there are frameworks to build server-side
    applications using microservices that make fetching and parsing data easier, it
    still doesn't deduct the processing and network wait time.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写用于与其他服务通信的代码可能更难，也就是说，您需要进行网络调用，然后解析数据以读取它。这也需要更多的处理。请注意，尽管有一些框架可以构建使用微服务的服务器端应用程序，使获取和解析数据变得更容易，但它仍然不能减少处理和网络等待时间。
- en: You will surely need some sort of monitoring tool to monitor services as they
    may go down due to network, hardware, or software failure. Although you may use
    the monitoring tool only when your application suddenly stops, to build the monitoring
    software or use some sort of service, monitoring software needs some level of
    extra experience and expertise.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您肯定需要某种监控工具来监视服务，因为它们可能会由于网络、硬件或软件故障而宕机。尽管您可能仅在应用程序突然停止时使用监控工具，但构建监控软件或使用某种服务，监控软件需要一定程度的额外经验和专业知识。
- en: Microservices-based server-side applications are slower than monolithic-based
    server-side applications as communication via networks is slower compared to memory.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于微服务的服务器端应用程序比基于单体的服务器端应用程序慢，因为通过网络进行通信比通过内存进行通信慢。
- en: When to use microservices architecture
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用微服务架构
- en: It may seem like its difficult to choose between monolithic and microservices
    architecture, but it's actually not so hard to decide between them.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 选择单体架构和微服务架构似乎很难，但实际上在它们之间做出决定并不那么困难。
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are unlikely to face any monolithic issues that we discussed
    earlier, then you can stick to monolithic architecture. In future, if you are
    facing issues that can be solved using microservices architecture, then you should
    switch to microservices architecture.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用单体架构构建服务器端应用程序，并且您觉得您不太可能面临我们之前讨论过的任何单体架构问题，那么您可以坚持使用单体架构。将来，如果您遇到可以使用微服务架构解决的问题，那么您应该切换到微服务架构。
- en: If you are switching from a monolithic architecture to microservices architecture,
    then you don't have to rewrite the complete application, instead you can only
    convert the components that are causing issues to services by doing some code
    refactoring. This sort of server-side applications where the main application
    logic is monolithic but some specific functionality is exposed via services is
    called microservices architecture with monolithic core. As issues increase further,
    you can start converting more components of the monolithic core to services.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从单体架构切换到微服务架构，则无需重写整个应用程序，而是可以通过一些代码重构将导致问题的组件转换为服务。这种服务器端应用程序的主要应用逻辑是单体的，但某些特定功能通过服务公开的架构称为具有单体核心的微服务架构。随着问题进一步增加，您可以开始将单体核心的更多组件转换为服务。
- en: '![When to use microservices architecture](img/00103.jpeg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![何时使用微服务架构](img/00103.jpeg)'
- en: If you are building a server-side application using monolithic architecture
    and you feel that you are likely to face any of the monolithic issues that we
    discussed earlier, then you should immediately switch to microservices architecture
    or microservices architecture with monolithic core, depending on what suits you
    the best.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用单体架构构建服务器端应用程序，并且您觉得您很可能会面临我们之前讨论过的任何单体架构问题，那么您应该立即切换到微服务架构或具有单体核心的微服务架构，具体取决于哪种更适合您。
- en: Data management
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据管理
- en: In microservices architecture, each service can have its own database to store
    data and can also use a centralized database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都可以拥有自己的数据库来存储数据，也可以使用集中式数据库。
- en: Some developers don't use a centralized database at all, instead all services
    have their own database to store the data. To synchronize the data between the
    services, the services omit events when their data is changed and other services
    subscribe to the event and update the data. The problem with this mechanism is
    that if a service is down, then it may miss some events. There is also going to
    be a lot of duplicate data, and finally, it is difficult to code this kind of
    system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员根本不使用集中式数据库，而是所有服务都有自己的数据库来存储数据。为了在服务之间同步数据，服务在其数据更改时省略事件，其他服务订阅该事件并更新数据。这种机制的问题在于，如果服务宕机，则可能会错过一些事件。还会有大量重复数据，最后，编写这种系统会很困难。
- en: Therefore, it's a good idea to have a centralized database and also let each
    service to maintain their own database if they want to store something that they
    don't want to share with others. Services should not connect to the centralized
    database directly, instead there should be another service called **database service**
    that provides APIs to work with the centralized database. This extra layer has
    many advantages, such as the underlying schema can be changed without updating
    and redeploying all the services that are dependent on the schema, we can add
    a caching layer without making changes to the services, you can change the type
    of database without making any changes to the services and there are many other
    benefits. We can also have multiple database services if there are multiple schemas,
    or if there are different types of database, or due to some other reason that
    benefits the overall architecture and decouples the services.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，拥有一个集中式数据库并让每个服务维护自己的数据库是一个好主意，如果他们想存储一些不想与他人共享的东西。服务不应直接连接到集中式数据库，而应该有另一个名为**数据库服务**的服务，该服务提供与集中式数据库一起工作的API。这个额外的层有很多优势，比如底层模式可以在不更新和重新部署所有依赖于模式的服务的情况下进行更改，我们可以添加一个缓存层而不必更改服务，您可以更改数据库类型而不必对服务进行任何更改，还有许多其他好处。如果有多个模式，或者有不同类型的数据库，或者由于其他原因有利于整体架构并解耦服务，我们还可以拥有多个数据库服务。
- en: Implementing microservices using Seneca
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Seneca实现微服务
- en: Seneca is a Node.js framework for creating server-side applications using microservices
    architecture with monolithic core.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca是一个用于使用微服务架构和单体核心创建服务器端应用程序的Node.js框架。
- en: Earlier, we discussed that in microservices architecture, we create a separate
    service for every component, so you must be wondering what's the point of using
    a framework for creating services that can be done by simply writing some code
    to listen to a port and reply to requests. Well, writing code to make requests,
    send responses, and parse data requires a lot of time and work, but a framework
    like Seneca makes all this easy. Also, converting the components of a monolithic
    core to services is also a cumbersome task as it requires a lot of code refactoring,
    but Seneca makes it easy by introducing the concepts of actions and plugins. Finally,
    services written in any other programming language or framework will be able to
    communicate with Seneca services.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们讨论了在微服务架构中，我们为每个组件创建一个单独的服务，所以您一定想知道使用框架创建服务的意义在哪里，这只需简单地编写一些代码来监听端口并回复请求就可以了。编写代码以发出请求、发送响应和解析数据需要大量的时间和工作，但是像Seneca这样的框架使所有这些变得容易。此外，将单体核心的组件转换为服务也是一项繁琐的任务，因为它需要大量的代码重构，但是Seneca通过引入操作和插件的概念使其变得容易。最后，使用任何其他编程语言或框架编写的服务都将能够与Seneca服务进行通信。
- en: In Seneca, an action represents a particular operation. An action is a function
    that's identified by an object literal or JSON string called the action pattern.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在Seneca中，操作代表特定的操作。操作是由操作模式来识别的函数。
- en: In Seneca, these operations of a component of monolithic core are written using
    actions, which we may later want to move from monolithic core to a service and
    expose it to other services and monolithic cores via a network.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在Seneca中，单体核心的组件的这些操作是使用操作来编写的，我们可能希望将其从单体核心移动到服务，并通过网络公开它们给其他服务和单体核心。
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why actions?**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用操作？**'
- en: You might be wondering what is the benefit of using actions instead of functions
    to write operations and how actions make it easy to convert components of monolithic
    core to services? Suppose you want to move an operation of monolithic core that
    is written using a function to a separate service and expose the function via
    a network, then you cannot simply copy and paste the function to the new service,
    instead you need to define a route (if you are using Express). To call the function
    inside the monolithic core, you will need to write code to make an HTTP request
    to the service. To call this operation inside the service, you can simply call
    a function so that there are two different code snippets depending from where
    you are executing the operation. Therefore, moving operations requires a lot of
    code refactoring. However, if you would have written the preceding operation using
    the Seneca action, then it would have been really easy to move the operation to
    a separate service.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道使用操作而不是函数来编写操作的好处，以及操作如何使将单体核心的组件转换为服务变得容易？假设您想将使用函数编写的单体核心的操作移动到一个单独的服务并通过网络公开该函数，那么您不能简单地将该函数复制粘贴到新服务中，而是需要定义一个路由（如果您使用Express）。要在单体核心内部调用该函数，您需要编写代码以向服务发出HTTP请求。要在服务内部调用此操作，您可以简单地调用一个函数，因此根据您执行操作的位置，有两种不同的代码片段。因此，移动操作需要大量的代码重构。但是，如果您使用Seneca操作编写了前面的操作，那么将操作移动到一个单独的服务将会变得非常容易。
- en: In case the operation is written using action, and you want to move the operation
    to a separate service and expose the operation via a network, then you can simply
    copy and paste the action to the new service. That's it. Obviously, we also need
    to tell the service to expose the action via the network and tell the monolithic
    core where to find the action, but all these require just couple of lines of code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作是使用动作来编写的，并且您想将操作移动到一个单独的服务并通过网络公开操作，那么您可以简单地将该动作复制粘贴到新服务中。显然，我们还需要告诉服务通过网络公开操作，并告诉单体核心在哪里找到该操作，但所有这些只需要几行代码。
- en: A Seneca service exposes actions to other services and monolithic cores. While
    making requests to a service, we need to provide a pattern matching an action's
    pattern to be called in the service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca服务向其他服务和单体核心公开操作。在向服务发出请求时，我们需要提供与操作模式匹配的模式，以便在服务中调用。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Why patterns?**'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么使用模式？**'
- en: Patterns make it easy to map a URL to an action. Patterns can overwrite other
    patterns for specific conditions, therefore it prevents editing the existing code,
    as editing the existing code in a production site is not safe and has many other
    disadvantages.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 模式使将URL映射到操作变得容易。模式可以覆盖特定条件下的其他模式，因此它可以防止编辑现有代码，因为在生产站点中编辑现有代码是不安全的，并且有许多其他缺点。
- en: Seneca also has a concept of plugins. A `seneca` plugin is actually a set of
    actions that can be easily distributed and plugged in to a service or monolithic
    core.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca还有一个插件的概念。`seneca`插件实际上是一组可以轻松分发并插入到服务或单体核心中的操作。
- en: As our monolithic core becomes larger and complex, we can convert components
    to services. That is, move actions of certain components to services.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的单体核心变得越来越大和复杂，我们可以将组件转换为服务。也就是说，将某些组件的操作移动到服务中。
- en: Creating your first Seneca application
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的第一个Seneca应用程序
- en: Let's create a basic application using Seneca to demonstrate how to use it.
    We will create an application that allows users to log in and register. This will
    be a demo application just to demonstrate how actions, plugins, and services can
    be created, and not how login and registration functionality works.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Seneca创建一个基本应用程序，以演示如何使用它。我们将创建一个允许用户登录和注册的应用程序。这将是一个演示应用程序，只是为了演示如何创建操作、插件和服务，而不是登录和注册功能的工作原理。
- en: 'Before you proceed further, create a directory named `seneca-example` and place
    a file named `package.json` in it. Inside the `seneca-example` directory, we will
    place our services and monolithic core. Inside the `package.json` file, place
    the following code so that npm will be able to download the dependencies for our
    application:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，创建一个名为`seneca-example`的目录，并在其中放置一个名为`package.json`的文件。在`seneca-example`目录中，我们将放置我们的服务和单体核心。在`package.json`文件中，放入以下代码，以便npm能够下载我们应用程序的依赖项：
- en: '[PRE0]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we are using Seneca version 0.6.5\. Make sure that you are also using the
    same version to avoid code incompatibility.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用的是Seneca版本0.6.5。确保您也使用相同的版本以避免代码不兼容。
- en: Now run the `npm install` command inside the `seneca-example` directory to install
    Seneca and other packages locally.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`seneca-example`目录中运行`npm install`命令，以在本地安装Seneca和其他软件包。
- en: Now create a file named `main.js` that will be the monolithic core of our server
    side application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为`main.js`的文件，它将是我们服务器端应用程序的单体核心。
- en: 'The monolithic core and services are all `seneca` instances programmatically.
    Place this code in the `main.js` file to create a `seneca` instance:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 单体核心和服务都是以编程方式创建的`seneca`实例。将此代码放入`main.js`文件中以创建一个`seneca`实例：
- en: '[PRE1]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now using this `seneca` object, we are going to add actions, call actions, add
    plugins, and everything.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用这个`seneca`对象，我们将添加动作，调用动作，添加插件等等。
- en: Creating actions
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动作
- en: Let's create actions for login and registration functionality and place them
    in the `main.js` file. To create actions, we need to use the `add` method of the
    `seneca` object. The first argument of the `add` method takes a JSON string or
    object that is the action identifier (called **pattern** to identify the action).
    The second argument is a callback that will be executed when the action is invoked.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为登录和注册功能创建动作，并将它们放在`main.js`文件中。要创建动作，我们需要使用`seneca`对象的`add`方法。`add`方法的第一个参数接受一个JSON字符串或对象，它是动作标识符（称为**模式**以标识动作）。第二个参数是动作调用时将执行的回调函数。
- en: 'Place this code in the `main.js` file that creates two actions for login and
    registration, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 将此代码放入`main.js`文件中，该文件创建了登录和注册两个动作，如下所示：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will see the code for the body of the actions later in this chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面看到动作主体的代码。
- en: There is nothing special about `role` and `cmd` properties. You can use any
    property names you wish too.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`role`和`cmd`属性没有特殊之处。您也可以使用任何属性名称。'
- en: The second argument is a callback, which will be invoked when the action is
    called.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个回调函数，当动作被调用时将被调用。
- en: If there are multiple actions with the same pattern, then the later overrides
    the others.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有多个具有相同模式的动作，那么后者将覆盖其他动作。
- en: We need to use the `act` method of the `seneca` object to invoke an action that's
    local to the instance or resides on some other service. The first argument of
    the `act` method is a pattern to match an action, and the second argument is a
    callback that will be executed once the action has been invoked.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`seneca`对象的`act`方法来调用实例本地的动作或驻留在其他服务上的动作。`act`方法的第一个参数是匹配动作的模式，第二个参数是动作调用后将执行的回调函数。
- en: 'Here is an example code that shows how to call the preceding two actions:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例代码，显示如何调用前面的两个动作：
- en: '[PRE3]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The callback passed to the `act` method is executed asynchronously once the
    result of the action arrives.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`act`方法的回调是在动作结果到达时异步执行的。
- en: Here, the object we passed to the `act` method has two extra properties than
    the action's pattern it is supposed to match. However, the action is still matched
    and invoked because in case the pattern passed to the `act` method has more properties
    than the action's pattern it is supposed to match, Seneca finds all the action's
    patterns whose properties are in the pattern passed to the `act` method and invokes
    the one that has the highest number of matching properties.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们传递给`act`方法的对象比它应该匹配的动作模式多了两个额外的属性。然而，该动作仍然匹配并被调用，因为如果传递给`act`方法的模式比它应该匹配的动作模式具有更多的属性，Seneca会找到所有动作模式中的属性与传递给`act`方法的模式相匹配的，并调用具有最多匹配属性的那个。
- en: If Seneca finds multiple action patterns with equal number of matching properties,
    then they are matched in ascending alphabetical order.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Seneca找到具有相同数量的匹配属性的多个动作模式，则它们将按字母顺序升序匹配。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about Seneca pattern matching at [http://senecajs.org/getting-started.html#patterns-unique-override](http://senecajs.org/getting-started.html#patterns-unique-override).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://senecajs.org/getting-started.html#patterns-unique-override](http://senecajs.org/getting-started.html#patterns-unique-override)了解更多有关Seneca模式匹配的信息。
- en: Creating plugins
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建插件
- en: A Seneca plugin is just a set of related actions packed together. Programmatically,
    a `seneca` plugin can be created using a function or module.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca插件只是一组相关的动作打包在一起。从程序上讲，可以使用函数或模块创建`seneca`插件。
- en: A plugin makes it easy to distribute a set of actions among applications. You
    will also find `seneca` plugins in online public package registry maintained by
    npm. For example, there is a `seneca` plugin that provides actions to work with
    the MongoDB database. This plugin can be inserted into monolithic cores or services
    with just a single line of code.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 插件使得在应用程序之间分发一组动作变得容易。您还会在npm维护的在线公共软件包注册表中找到`seneca`插件。例如，有一个`seneca`插件提供与MongoDB数据库一起使用的动作。这个插件可以通过一行代码插入到单体核心或服务中。
- en: By default, Seneca installs four built-in plugins when we create a `seneca`
    instance. These plugins are **basic**, **transport**, **web**, and **mem-store**.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当我们创建`seneca`实例时，Seneca会安装四个内置插件。这些插件是**basic**，**transport**，**web**和**mem-store**。
- en: Let's first create a plugin using a function. The function name is the plugin
    name, and a plugin can also have an initialization action, which will be invoked
    as soon as the plugin is attached to the `seneca` instance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先使用一个函数创建一个插件。函数名是插件名，插件也可以有一个初始化动作，一旦插件附加到`seneca`实例上就会被调用。
- en: 'So, let''s create a plugin named `account` and place the login and register
    actions in that, as later on, we will be creating a service and moving the actions
    there. Remove the actions we defined earlier in the `main.js` file and place the
    following code instead:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们创建一个名为`account`的插件，并将登录和注册操作放在其中，因为以后我们将创建一个服务并将操作移到那里。删除我们在`main.js`文件中之前定义的操作，并放置以下代码：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here we defined a function named `account` and attached it using the `use` method
    of the `seneca` object. To attach multiple plugins, we can call the `use` method
    multiple times.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为`account`的函数，并使用`seneca`对象的`use`方法附加了它。要附加多个插件，我们可以多次调用`use`方法。
- en: The `init:account` action is the initialization action invoked by Seneca once
    the plugin is added. This can be used to do things such as establishing database
    connection or other things that the actions of the plugin depend on.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`init:account`操作是Seneca添加插件后调用的初始化操作。这可以用于执行诸如建立数据库连接或插件操作所依赖的其他操作等任务。'
- en: The `this` keyword inside the plugin refers to the `seneca` instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 插件中的`this`关键字指的是`seneca`实例。
- en: 'Let''s create the same plugin using a module so that it''s easily distributable
    and can be put up in the `npm` registry. Create a file named `account.js` and
    place it in the `seneca-example` directory. `account.js` is the plugin module.
    Place this code inside the `account.js` file:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用模块创建相同的插件，以便它易于分发并可以放在`npm`注册表中。创建一个名为`account.js`的文件，并将其放在`seneca-example`目录中。`account.js`是插件模块。将以下代码放入`account.js`文件中：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here is the plugin name in the string returned by the anonymous function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是匿名函数返回的字符串中的插件名称。
- en: 'Remove the plugin code that we previously defined in the `main.js` file and
    place the following code instead:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 删除我们之前在`main.js`文件中定义的插件代码，并放置以下代码：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, to attach the plugin, we are providing the module path.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，为了附加插件，我们提供了模块路径。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about creating Seneca plugins at [http://senecajs.org/write-a-plugin.html](http://senecajs.org/write-a-plugin.html),
    and you can find all the Seneca plugins at [http://senecajs.org/plugins.html](http://senecajs.org/plugins.html).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://senecajs.org/write-a-plugin.html](http://senecajs.org/write-a-plugin.html)了解有关创建Seneca插件的更多信息，并且您可以在[http://senecajs.org/plugins.html](http://senecajs.org/plugins.html)找到所有Seneca插件。
- en: Creating services
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建服务
- en: A service is a seneca instance that exposes some actions via network. Let's
    create a service that exposes the login and register actions.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是通过网络公开一些操作的seneca实例。让我们创建一个暴露登录和注册操作的服务。
- en: 'Create an `account-service.js` file in the `seneca-example` directory that
    will act as the service. Then place the following code in it to create a service
    that exposes the login and register actions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`seneca-example`目录中创建一个`account-service.js`文件，它将作为服务。然后将以下代码放入其中以创建一个暴露登录和注册操作的服务：
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we first created a `seneca` instance. Then we added actions via a plugin.
    You can also manually add actions using the `add` method of the `seneca` object.
    Finally, we exposed the actions via an HTTP protocol. Seneca also supports other
    protocols, but we will stick to HTTP, as it's the most commonly used one.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建了一个`seneca`实例。然后我们通过插件添加了操作。您还可以使用`seneca`对象的`add`方法手动添加操作。最后，我们通过HTTP协议公开了这些操作。Seneca还支持其他协议，但我们将坚持使用HTTP，因为它是最常用的协议。
- en: '`seneca.listen` creates an HTTP server to listen to requests. We also provided
    the port number and pin, which are optional. The default port is `10101`, and
    by default, there is no pin if not provided.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`seneca.listen`创建一个HTTP服务器来监听请求。我们还提供了端口号和pin，它们是可选的。默认端口是`10101`，如果没有提供，则默认情况下没有pin。'
- en: You must be wondering what is a pin and what is it used for? Well, you may not
    always want to expose all the actions of the service via a network. In that case,
    you can provide a pattern to the `pin` property and the server will handle these
    requests that match the `pin` pattern.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道什么是pin以及它的用途是什么？嗯，您可能并不总是希望通过网络公开服务的所有操作。在这种情况下，您可以为`pin`属性提供一个模式，服务器将处理与`pin`模式匹配的请求。
- en: Now, for other services or monolithic cores to be able to call the actions of
    this service, they need to register this service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，其他服务或单体核心要能够调用该服务的操作，它们需要注册该服务。
- en: 'Remove the previous plugin attachment code from the `main.js` file and add
    the following code to register the service:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从`main.js`文件中删除先前的插件附加代码，并添加以下代码来注册服务：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here we are registering the service by providing the `port` number and `pin`.
    Both of them are optional. In case if we don't use any port number, then it defaults
    to `10101`. In case the service is on different server, then you should use the
    `host` property to provide the IP address.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过提供`port`号和`pin`来注册服务。它们都是可选的。如果我们不使用任何端口号，则默认为`10101`。如果服务在不同的服务器上，则应使用`host`属性来提供IP地址。
- en: The `pin` attached to the `client` method is used to tell the `seneca` instance
    about what actions are exposed by the service. It's completely optional. Seneca
    won't send requests to a service that doesn't match the `pin` pattern.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`client`方法附加的`pin`用于告诉`seneca`实例服务公开了哪些操作。这是完全可选的。Seneca不会向不匹配`pin`模式的服务发送请求。'
- en: You can add as many services as you want by calling the client method multiple
    times.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以多次调用`client`方法添加尽可能多的服务。
- en: When you call the `act` method to invoke an action, the `seneca` instance first
    looks for the action locally before requesting services. If it's not found locally,
    then it checks for the services that have a pin to see if it matches any. If a
    pin matches, then it sends request to this particular service. Finally, if any
    of the pin doesn't match, it sends the requests one by one to all other services
    that don't have a pin till it gets a valid response from one of them.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用`act`方法来调用一个操作时，`seneca`实例首先在本地查找操作，然后再请求服务。如果在本地找不到，它会检查具有pin的服务，看看是否有匹配的。如果pin匹配，则发送请求到特定服务。最后，如果任何pin都不匹配，它会将请求一个接一个地发送到所有其他没有pin的服务，直到从其中一个获得有效响应。
- en: 'You can also manually call an action of a service by sending the GET request
    to these types of URL:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过向这些类型的URL发送GET请求来手动调用服务的操作：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also call a service by using the POST request. Here is how to do it
    using CURL:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用POST请求调用服务。以下是使用CURL的方法：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Storing data
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存储数据
- en: Seneca provides a built-in mechanism to store data. Seneca provides some built-in
    actions that allow us to store data. The built-in actions use `mem-store` to store
    data by default. **mem-store** is an asynchronous in-memory storage system.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca提供了一种内置机制来存储数据。Seneca提供了一些内置操作，允许我们存储数据。内置操作默认使用`mem-store`来存储数据。**mem-store**是一种异步的内存存储系统。
- en: You can create your application using the default storing mechanism. In case
    you want to change the underlying store system, you just need to install plugin
    for this particular storage system that will overwrite the built-in storage actions,
    therefore you will not have to refactor any code.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用默认的存储机制创建您的应用程序。如果您想要更改底层存储系统，您只需要安装特定存储系统的插件，它将覆盖内置的存储操作，因此您不需要重构任何代码。
- en: 'The built-in actions to do the CRUD operations are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行CRUD操作的内置操作如下：
- en: '`role:entity,cmd:load,name:<entity-name>`: This is used to retrieve an entity
    using its ID. An entity can be thought of as a row in MySQL. Every entity gets
    a unique ID.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:load,name:<entity-name>`: 用于使用其ID检索实体。实体可以被视为MySQL中的一行。每个实体都有一个唯一的ID。'
- en: '`role:entity,cmd:save,name:<entity-name>`: This is used to update (if you provide
    entity ID) or add an entity if it does not exist. Entities are stored and retrieved
    in form of objects.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:save,name:<entity-name>`: 用于更新（如果提供实体ID）或添加一个实体（如果不存在）。实体以对象的形式存储和检索。'
- en: '`role:entity,cmd:list,name:<entity-name>`: This is used to list all the entities
    that are matching a query.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:list,name:<entity-name>`: 用于列出与查询匹配的所有实体。'
- en: '`role:entity,cmd:remove,name:<entity-name>`: This is used to remove an entity
    using its ID.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role:entity,cmd:remove,name:<entity-name>`: 用于使用其ID删除实体。'
- en: Seneca also provides some wrapper functions that extract these actions and make
    it easy to call these actions. These functions are `load$`, `save$`, `list$`,
    and `remove$`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca还提供了一些包装函数，用于提取这些操作并方便地调用这些操作。这些函数是`load$`、`save$`、`list$`和`remove$`。
- en: Let's implement the login and register actions to allow us to log in and also
    register new accounts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现登录和注册操作，以便我们可以登录并注册新账户。
- en: 'Here is the implementation of the account action. Update this code in the `account.js`
    file:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是账户操作的实现。将此代码更新到`account.js`文件中：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first argument of the callback passed to the `add` method holds reference
    to the object that matched against the pattern of the action.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`add`方法的回调的第一个参数保存了与操作模式匹配的对象的引用。
- en: Here we are first calling the `make` method of the `seneca` object. It's used
    to get reference of an entity's store. For example, in case of MySQL, the `make`
    method gets reference to a table.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先调用`seneca`对象的`make`方法。它用于获取实体存储的引用。例如，在MySQL的情况下，`make`方法获取到表的引用。
- en: Then, we will find whether there are any entities with the username and password
    passed by the `act` method. As entities are added as objects, to query for entities,
    we need to pass an object. Now `list$` looks for all entities with the same username
    and password.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将查找是否有任何使用`act`方法传递的用户名和密码的实体。由于实体是以对象的形式添加的，因此要查询实体，我们需要传递一个对象。现在，`list$`查找所有具有相同用户名和密码的实体。
- en: We are passing a callback to the `$list` method that will be invoked asynchronously
    once the data is retrieved. This callback takes two parameters, that is, the first
    parameter is an `error` object if there is an error, otherwise `null`.Similarly,
    the second parameter is an array of entities found matching the given object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将回调传递给`$list`方法，一旦数据被检索，就会异步调用该回调。这个回调接受两个参数，即，如果有错误，第一个参数是一个`error`对象，否则为`null`。同样，第二个参数是一个匹配给定对象的实体数组。
- en: For the action to respond back, it needs to call the second parameter of the
    action callback by passing it an object as the second argument. In case an error
    has occurred, we need to pass the error in the first argument.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使操作响应，它需要通过将对象作为第二个参数传递给操作回调的第二个参数来调用。如果发生错误，我们需要在第一个参数中传递错误。
- en: 'Similarly, now let''s write the code for the register action, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，现在让我们编写注册操作的代码，如下所示：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, most of the code is understandable as it works the same way as the previous
    action. To store data, we are creating a new entity store reference using the
    `data$` method by passing the entity we want to store. Then we are calling the
    `save$` method to save the entity.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，大部分代码都是可以理解的，因为它的工作方式与之前的操作相同。为了存储数据，我们使用`data$`方法创建一个新的实体存储引用，通过传递我们想要存储的实体。然后我们调用`save$`方法来保存实体。
- en: Note
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about storing data in Seneca, visit [http://senecajs.org/data-entities.html](http://senecajs.org/data-entities.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于在Seneca中存储数据的信息，请访问[http://senecajs.org/data-entities.html](http://senecajs.org/data-entities.html)。
- en: Integrating Express and Seneca
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成Express和Seneca
- en: We have completed creating our login and register actions. Now, as our backend
    will be used by an app or it may represent as a website, we need to provide URLs
    to the clients who will use them to talk to the server.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了创建登录和注册操作。现在，由于我们的后端将被应用程序使用，或者它可能代表网站，我们需要为将使用它们与服务器交谈的客户端提供URL。
- en: Monolithic core is the part of our server-side application that the client interacts
    with for most of the functionality. Clients can also interact with services directly
    for some specific functionality if required.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 单体核心是我们服务器端应用的一部分，客户端与其进行大部分功能交互。客户端也可以根据需要直接与服务进行交互以获取特定功能。
- en: So, we need to use some sort of website development framework in the monolithic
    core and services of our server-side application. We will be using Express, as
    it's the most popular one.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要在单体核心和服务器端应用的服务中使用某种网站开发框架。我们将使用Express，因为它是最流行的框架。
- en: Seneca also provides a built-in way to map the URLs to actions, that is, requests
    made to an HTTP server can be automatically mapped to a particular action to invoke
    them. This is done using a definition object whose properties define a route mapping
    from URLs to action patterns. This built-in method defines route mapping independent
    of the framework being used. Once we have defined the definition objects, we need
    a plugin specific to the web server framework that will capture and resolve the
    URLs to action patterns using the definition objects. Definition object allows
    you to attach callbacks that will get the response of the action via a parameter,
    and then the callbacks can return the data to the user in whatever format they
    want. This can be useful in case you are creating a plugin for distribution that
    exposes a few actions that need to be called for specific URL requests, then you
    will have to use the built-in method, as it defines route mapping independent
    of the framework being used.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Seneca还提供了一种内置的方法来将URL映射到操作，即，对HTTP服务器发出的请求可以自动映射到特定的操作以调用它们。这是使用定义对象来完成的，其属性定义了从URL到操作模式的路由映射。这种内置方法定义了独立于所使用的框架的路由映射。一旦我们定义了定义对象，我们需要一个特定于Web服务器框架的插件，它将使用定义对象捕获和解析URL到操作模式。定义对象允许您附加回调，通过参数获取操作的响应，然后回调可以以任何格式将数据返回给用户。如果您正在创建一个插件以公开需要针对特定URL请求调用的几个操作，那么您将不得不使用内置方法，因为它定义了独立于所使用的框架的路由映射。
- en: Note
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can learn more about how to use the built-in way to integrate Seneca and
    Express at [https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/rjrodger/seneca-web](https://github.com/rjrodger/seneca-web)了解有关如何使用内置方法集成Seneca和Express的更多信息。
- en: 'Add the following code to the `main.js` file to start the Express server in
    it:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`main.js`文件中以在其中启动Express服务器：
- en: '[PRE13]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: On the second line, we are exporting a middleware function provided by the `seneca-web`
    plugin. `seneca-web` is the plugin to integrate Seneca and Express directly, that
    is, to translate URLs into action patterns using the definition object for Express
    framework. This is only required if we use the definition object to define route
    mapping. We won't be using definition objects, but we should still use `seneca-web`,
    as some third-party plugins may use definition objects if we are using these plugins.
    For example, if you are using the `seneca-auth` plugin, then you will have to
    include second line.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们导出了`seneca-web`插件提供的中间件函数。`seneca-web`是将Seneca和Express直接集成的插件，即，使用Express框架的定义对象将URL转换为操作模式。只有在使用定义对象定义路由映射时才需要这样做。即使我们不使用定义对象，但我们仍应该使用`seneca-web`，因为某些第三方插件可能会使用定义对象。例如，如果您使用`seneca-auth`插件，则必须包括第二行。
- en: 'We want the user to be able to log in using the `/account/login` path and register
    using the `/account/register` path. The user will provide a username and password
    via query string. Here is the code to define routes to handle HTTP requests for
    login and registration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够使用`/account/login`路径登录，并使用`/account/register`路径注册。用户将通过查询字符串提供用户名和密码。以下是定义处理登录和注册的HTTP请求的路由的代码：
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here we are calling the appropriate actions depending on the path of the URL
    request.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据URL请求的路径调用适当的操作。
- en: Here, instead of using `seneca.act`, we are using `httpRequest.seneca.act` as
    the middleware function that we exported earlier adds a new `seneca` property
    to request the object of every HTTP requests. This property inherits the actual
    `seneca` instance. Actions in the third-party plugins add information in form
    of properties to the `seneca` property in order to share information related to
    a particular HTTP request with other route handers. The preceding code will behave
    in the same way even if we use `seneca.act`, but it's a good practice to use `httpRequest.seneca.act`
    as we may use such types of plugins. Your own route handlers can also use `httpRequest.seneca.act`
    to pass information related to `seneca` to each other.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是使用`seneca.act`，而是使用`httpRequest.seneca.act`，因为我们之前导出的中间件函数会向每个HTTP请求的请求对象添加一个新的`seneca`属性。此属性继承了实际的`seneca`实例。第三方插件中的操作会以属性的形式向`seneca`属性中添加信息，以便与其他路由处理程序共享与特定HTTP请求相关的信息。即使我们使用`seneca.act`，上述代码也会以相同的方式运行，但是最好使用`httpRequest.seneca.act`，因为我们可能会使用这种类型的插件。您自己的路由处理程序也可以使用`httpRequest.seneca.act`将与`seneca`相关的信息传递给彼此。
- en: 'Now, to run the application, first run the `account-service.js` file and then
    the `main.js` file. You can then log in and register using the following URLs:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要运行应用程序，首先运行`account-service.js`文件，然后运行`main.js`文件。然后您可以使用以下URL登录和注册：
- en: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/login?username=narayan&password=mypassword`'
- en: '`http://localhost:8080/account/register?username=x&password=mypassword`'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8080/account/register?username=x&password=mypassword`'
- en: Here, we saw how to create a web interface, which can be used by an app or to
    serve HTML pages in case it's a website.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到了如何创建一个Web界面，该界面可以被应用程序使用，或者在网站的情况下用于提供HTML页面。
- en: We can also move the routes of Express to a service if we want a different service
    to handle certain requests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望不同的服务处理某些请求，我们还可以将Express的路由移至服务。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw the difference between monolithic and microservices
    architecture. Then we discussed what microservices architecture with monolithic
    core means and its benefits. Finally, we jumped into the Seneca framework for
    implementing microservices architecture with monolithic core and discussed how
    to create a basic login and registration functionality to demonstrate various
    features of the Seneca framework and how to use it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了单片和微服务架构之间的区别。然后我们讨论了具有单片核心的微服务架构及其优势。最后，我们深入了解了Seneca框架，用于实现具有单片核心的微服务架构，并讨论了如何创建基本的登录和注册功能，以演示Seneca框架的各种功能及其使用方法。
- en: In the next chapter, we will create a fully functional e-commerce website using
    Seneca and Express frameworks.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用Seneca和Express框架创建一个完全功能的电子商务网站。
