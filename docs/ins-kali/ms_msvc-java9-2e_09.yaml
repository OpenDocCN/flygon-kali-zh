- en: Best Practices and Common Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和共同原则
- en: After all the hard work put in by you toward gaining the experience of developing
    a microservice sample project, you must be wondering how to avoid common mistakes
    and improve the overall process of developing microservice-based products and
    services. We can follow these principles or guidelines to simplify the process
    of developing microservices and avoid/reduce the potential limitations. We will
    focus on these key concepts in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在您为开发微服务样本项目而付出的辛苦努力之后，您一定想知道如何避免常见错误并改进开发基于微服务的产品和服务的整个流程。我们可以遵循这些原则或指南来简化开发微服务的过程，并避免/减少潜在的限制。我们将在本章重点讨论这些关键概念。
- en: 'This chapter is spread across the following three sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下三个部分：
- en: Overview and mindset
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概述和心态
- en: Best practices and principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践和原则
- en: Microservice frameworks and tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务框架和工具
- en: Overview and mindset
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述和心态
- en: You can implement microservice-based design on both new and existing products
    and services. Contrary to the belief that it is easier to develop and design a
    new system from scratch rather than making changes to an existing one that is
    already live, each approach has its own respective challenges and advantages.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在新产品和服务以及现有产品和服务上实施基于微服务的设计。与认为从头开始开发和设计新系统比对已经上线的现有系统进行更改更容易的观念相反，每种方法都有各自的挑战和优势。
- en: For example, since there is no existing system design for a new product or service,
    you have freedom and flexibility to design the system without giving any thought
    to its impact. However, you don't have the clarity on both functional and system
    requirements for a new system, as these mature and take shape over time. On the
    other hand, for mature products and services, you have detailed knowledge and
    information of the functional and system requirements. Nevertheless, you have
    a challenge to mitigate the risk of impact that design change brings to the table.
    Therefore, when it comes to updating a production system from monolithic to microservices,
    you will need to plan better than if you were building a system
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，由于新产品或服务没有现有的系统设计，您可以自由灵活地设计系统而不考虑其影响。然而，您对新系统的功能和系统要求都没有清晰的了解，因为这些要求会随着时间的推移而成熟和形成。另一方面，对于成熟的产品和服务，您对功能和系统要求有详细的了解和信息。然而，您面临着减轻设计更改带来的风险影响的挑战。因此，当涉及将生产系统从单片式升级到微服务时，您需要比构建系统时做出更好的计划。
- en: from scratch.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始。
- en: Experienced and successful software design experts and architects always evaluate
    the pros and cons and take a cautious approach to making any change to existing
    live systems. One should not make changes to existing live system design simply
    because it may be cool or trendy. Therefore, if you would like to update the design
    of your existing production system to microservices, you need to evaluate all
    the pros and cons before making this call.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 经验丰富且成功的软件设计专家和架构师总是评估利弊，并谨慎对待对现有上线系统的任何更改。一个人不应该仅仅因为它可能很酷或时髦而对现有的上线系统设计进行更改。因此，如果您想要将现有生产系统的设计更新为微服务，您需要在做出这个决定之前评估所有的利弊。
- en: I believe that monolithic systems provide a great platform to upgrade to a successful
    microservice-based design. Obviously, we are not discussing cost here. You have
    ample knowledge of the existing system and functionality, which enables you to
    divide the existing system and build microservices based on functionalities and
    how those would interact with each other. Also, if your monolithic product is
    already modularized in some way, then directly transforming microservices by exposing
    an API instead of an **Application Binary Interface** (**ABI**) is possibly the
    easiest way of achieving a microservice architecture. A successful microservice-based
    system is more dependent on microservices and their interaction protocol than
    anything else.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信单片式系统为升级到成功的基于微服务的设计提供了一个很好的平台。显然，我们在这里没有讨论成本。您对现有系统和功能有充分的了解，这使您能够将现有系统划分并基于功能构建微服务，以及它们之间的交互方式。此外，如果您的单片式产品已经以某种方式模块化，那么通过暴露API而不是应用二进制接口（ABI）直接转换微服务可能是实现微服务架构的最简单方式。成功的基于微服务的系统更依赖于微服务及其交互协议而不是其他任何因素。
- en: Having said that, it does not mean that you cannot have a successful microservice-based
    system if you are starting from scratch. However, it is recommended to start a
    new project based on monolithic design that gives you perspective and understanding
    of the system and functionality. It allows you to find bottlenecks quickly and
    guides you to identify any potential feature that can be developed using microservices.
    Here, we have not discussed the size of the project, which is another important
    factor. We'll discuss this in the next section.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，并不意味着如果您从零开始就不能拥有一个成功的基于微服务的系统。然而，建议基于单片式设计启动一个新项目，这可以让您对系统和功能有全面的了解和理解。它可以让您快速找到瓶颈，并指导您识别可以使用微服务开发的潜在功能。在这里，我们还没有讨论项目的规模，这是另一个重要因素。我们将在下一节中讨论这一点。
- en: In today's cloud age and agile development world, it takes an hour between making
    any change and the change going live. In today's competitive environment, every
    organization would like to have the edge for quickly delivering features to the
    user. Continuous development, integration, and deployment are part of the production
    delivery process, a completely automatic process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的云时代和敏捷开发世界，任何更改和更改上线之间需要一个小时。在当今竞争激烈的环境中，每个组织都希望能够快速向用户提供功能。持续开发、集成和部署是生产交付过程的一部分，是一个完全自动化的过程。
- en: It makes more sense if you are offering cloud-based products or services. Then,
    a microservice-based system enables the team to respond with agility to fix any
    issue or provide a new feature to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供基于云的产品或服务，这样做就更有意义。然后，基于微服务的系统使团队能够灵活地响应修复任何问题或为用户提供新功能。
- en: Therefore, you need to evaluate all the pros and cons before you make a call
    for starting a new microservice-based project from scratch or planning to upgrade
    the design of an existing monolithic system to a microservice-based system. You
    have to listen to and understand the different ideas and perspectives shared across
    your team, and you need to take a cautious approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在你从零开始启动一个新的基于微服务的项目或计划将现有的单体系统升级为基于微服务的系统之前，你需要评估所有的利弊。你必须倾听和理解团队中分享的不同想法和观点，并且需要谨慎对待。
- en: Finally, I would like to share the importance of having better processes and
    an efficient system in place for a successful production system. Having a microservice-based
    system does not guarantee a successful production system, and a monolithic application
    does not mean you cannot have a successful production system in today's age. Netflix,
    a microservice-based cloud video rental service, and Etsy, a monolithic e-commerce
    platform, are both examples of successful live production systems (see an interesting
    Twitter discussion link in the *References* section later in the chapter). Therefore,
    processes and agility are also key to a successful production system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想分享一下拥有更好的流程和高效的系统对于成功的生产系统的重要性。拥有基于微服务的系统并不意味着你一定会有一个成功的生产系统，而单体应用也不意味着你在当今时代不能拥有一个成功的生产系统。Netflix是一个基于微服务的云视频租赁服务，Etsy是一个单体的电子商务平台，它们都是成功的生产系统的例子（在本章后面的*参考*部分中可以看到一个有趣的Twitter讨论链接）。因此，流程和灵活性也是成功的生产系统的关键。
- en: Best practices and principles
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践和原则
- en: As we have learned from the first chapter, microservices are a lightweight style
    of implementing **Service Oriented Architecture** (**SOA**). On top of that, microservices
    are not strictly defined, which gives you the flexibility of developing microservices
    the way you want and according to need. At the same time, you need to make sure
    that you follow a few of the standard practices and principles to make your job
    easier and implement microservice-based architecture successfully.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一章我们学到，微服务是一种轻量级的实现**面向服务的架构**（**SOA**）的风格。除此之外，微服务并没有严格的定义，这使得你可以根据自己的需求和想法灵活地开发微服务。同时，你需要确保遵循一些标准实践和原则，以使你的工作更容易，并成功实现基于微服务的架构。
- en: Nanoservice, size, and monolithic
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纳米服务、大小和单体
- en: Each microservice in your project should be small in size and perform one functionality
    or feature (for example, user management), independently enough to perform the
    function on its own.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你项目中的每个微服务都应该体积小，执行一个功能或特性（例如，用户管理），足够独立地执行其功能。
- en: 'The following two quotes from Mike Gancarz (a member who designed the X Window
    system), which defines one of the paramount precepts of Unix philosophy, suits
    the microservice paradigm as well:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两句来自设计X Window系统的成员Mike Gancarz的引言，定义了Unix哲学的一个重要原则，也适用于微服务范式：
- en: '"Small is beautiful."'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: “小即是美。”
- en: '"Make each program do one thing well."'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: “让每个程序都做好一件事。”
- en: Now, how do we define the size, in today's age, when you have a framework (for
    example, Finangle) that reduces the **lines of code** (**LOC**)? In addition,
    many modern languages, such as Python and Erlang, are less verbose. This makes
    it difficult to decide whether you want to make this code microservice or not.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，在当今时代，当你有一个可以减少**代码行数**（**LOC**）的框架（例如，Finangle）时，如何定义大小呢？此外，许多现代语言，如Python和Erlang，都不那么冗长。这使得很难决定是否要将这段代码制作成微服务。
- en: Apparently, you may implement a microservice for a small number of LOC; that
    is actually not a microservice but a nanoservice.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你可能会为少量的LOC实现一个微服务；但实际上这不是一个微服务，而是一个纳米服务。
- en: 'Arnon Rotem-Gal-Oz defined a nanoservice as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Arnon Rotem-Gal-Oz定义了纳米服务如下：
- en: '"Nanoservice is an antipattern where a service is too fine-grained. A nanoservice
    is a service whose overhead (communications, maintenance, and so on) outweighs
    its utility."'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: “纳米服务是一种反模式，其中服务过于细粒化。纳米服务是一种开销（通信、维护等）超过其效用的服务。”
- en: Therefore, it always makes sense to design microservices based on functionality.
    Domain-driven design makes it easier to define functionality at a domain level.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据功能设计微服务总是有意义的。领域驱动设计使得在领域级别更容易定义功能。
- en: As discussed previously, the size of your project is a key factor when deciding
    whether to implement microservices or determining the number of microservices
    you want to have for your project. In a simple and small project, it makes sense
    to use monolithic architecture. For example, based on the domain design that we
    learned in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml), *Domain-Driven
    Design*, you would get a clear understanding of your functional requirements and
    it makes facts available to draw the boundaries between various functionalities
    or features. For example, in the sample project (online table reservation system;
    OTRS) we have implemented, it is very easy to develop the same project using monolithic
    design, provided you don't want to expose the APIs to the customer, or you don't
    want to use it as SaaS, or there are plenty of similar parameters that you want
    to evaluate before making a call.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，项目的规模是决定是否实现微服务或确定你想要为项目拥有的微服务数量的关键因素。在一个简单和小型的项目中，使用单体架构是有意义的。例如，根据我们在[第3章](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml)中学到的领域设计，*领域驱动设计*，你可以清楚地了解你的功能需求，并且可以根据事实划定各种功能或特性之间的边界。例如，在我们实现的示例项目（在线桌位预订系统；OTRS）中，使用单体设计非常容易开发相同的项目，前提是你不想向客户公开API，或者你不想将其用作SaaS，或者在做出决定之前有很多类似的参数需要评估。
- en: You can migrate the monolithic project to a microservices design later, when
    the need arises. Therefore, it is important that you should develop the monolithic
    project in modular fashion and have the loose coupling at every level and layer,
    and ensure there are predefined contact points and boundaries between different
    functionalities and features. In addition, your data source, such as DB, should
    be designed accordingly. Even if you are not planning to migrate to a microservice-based
    system, it would make bug fixes and enhancement easier to implement.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要时，您可以将单体项目迁移到微服务设计。因此，重要的是您应该以模块化的方式开发单体项目，并在每个级别和层次上实现松耦合，并确保不同功能和特性之间有预定义的接触点和边界。此外，您的数据源，如数据库，应该相应地设计。即使您没有计划迁移到基于微服务的系统，这样做也会使错误修复和增强更容易实现。
- en: Paying attention to the previous points will mitigate any possible difficulties
    you may encounter when you migrate to microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面的要点将有助于减轻您在迁移到微服务时可能遇到的任何困难。
- en: Generally, large or complex projects should be developed using microservices-based
    architecture, due to the many advantages it provides, as discussed in previous
    chapters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大型或复杂的项目应该使用基于微服务的架构进行开发，因为它提供了许多优势，如前几章所述。
- en: I even recommend developing your initial project as monolithic; once you gain
    a better understanding of project functionalities and project complexity, then
    you can migrate it to microservices. Ideally, a developed initial prototype should
    give you the functional boundaries that will enable you to make the right choice.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我甚至建议最初将项目开发为单体化；一旦您更好地了解了项目功能和项目复杂性，那么您可以将其迁移到微服务。理想情况下，开发的初始原型应该为您提供功能边界，从而使您能够做出正确的选择。
- en: Continuous integration and deployment
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成和部署
- en: You must have a continuous integration and deployment process in place. It gives
    you the edge to deliver changes faster and detect bugs early. Therefore, each
    service should have its own integration and deployment process. In addition, it
    must be automated. There are many tools available, such as Teamcity, Jenkins,
    and so on, that are used widely. It helps you to automate the build process—which
    catches build failure early, especially when you integrate your changes with the
    mainline (like either any release branch/tag or master branch).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须有一个持续集成和部署流程。这使您能够更快地交付变更并及早发现错误。因此，每个服务都应该有自己的集成和部署流程。此外，它必须是自动化的。有许多可用的工具，如Teamcity、Jenkins等，被广泛使用。它可以帮助您自动化构建过程，尤其是当您将变更与主干（例如任何发布分支/标签或主分支）集成时，可以及早捕获构建失败。
- en: You can also integrate your tests with each automated integration and deployment
    process. **Integration testing** tests the interactions of different parts of
    the system, such as between two interfaces (API provider and consumer), or between
    different components, or modules in a system, such as between DAO and database,
    and so on. Integration testing is important as it tests the interfaces between
    the modules. Individual modules are first tested in isolation. Then, integration
    testing is performed to check the combined behavior and validate that requirements
    are implemented correctly. Therefore, in microservices, integration testing is
    a key tool to validate the APIs. We will cover more about this in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将每个自动化集成和部署流程与您的测试集成。**集成测试**测试系统不同部分之间的交互，比如两个接口（API提供者和消费者）之间，或系统中不同组件或模块之间，比如DAO和数据库之间等。集成测试很重要，因为它测试模块之间的接口。首先对单个模块进行隔离测试，然后进行集成测试以检查组合行为并验证需求是否正确实现。因此，在微服务中，集成测试是验证API的关键工具。我们将在下一节中更多地介绍这个问题。
- en: Finally, you can see the updated mainline changes on your CD (continuous deployment)
    machine where this process deploys the build.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以在CD（持续部署）机器上看到更新的主干更改，该过程部署构建。
- en: 'The process does not end here: you can make a container, such as Docker, and
    hand it over to your WebOps team, or have a separate process that delivers to
    a configured location or deploys to a WebOps stage environment. From here, it
    could be deployed directly to your production system once approved by the designated
    authority.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 流程并不在此结束：您可以制作一个容器，比如Docker，并交给您的WebOps团队，或者有一个单独的流程将其交付到配置的位置或部署到WebOps阶段环境。从这里，一旦获得指定权限的批准，就可以直接部署到生产系统。
- en: System/end-to-end test automation
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统/端到端测试自动化
- en: Testing is a very important part of any product and service delivery. You do
    not want to deliver buggy applications to customers. Earlier, at the time when
    the waterfall model was popular, an organization used to take 1 to 6 months or
    more for the testing stage before delivering to the customer. In recent years,
    after the agile process became popular, more emphasis is given to automation.
    Similar to prior point testing, automation is also mandatory.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是任何产品和服务交付的非常重要的一部分。您不希望向客户交付有错误的应用程序。在瀑布模型流行的时候，组织通常需要花费1到6个月甚至更长的时间进行测试，然后才交付给客户。近年来，随着敏捷流程的流行，更加注重自动化。与前面的测试类似，自动化也是必不可少的。
- en: Whether you follow **test-driven development** (**TDD**) or not, we must have
    system or end-to-end test automation in place. It's very important to test your
    business scenarios and that is also the case with end-to-end testing that may
    start from your REST call to database checks, or from UI app to database checks.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您是否遵循**测试驱动开发**（TDD），我们都必须有系统或端到端的测试自动化。测试您的业务场景非常重要，端到端测试也是如此，可能从您的REST调用到数据库检查，或者从UI应用到数据库检查开始。
- en: Also, it is important to test your APIs if you have public APIs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您有公共API，测试API也很重要。
- en: Doing this makes sure that any change does not break any of the functionality
    and ensures seamless, bug-free production delivery. As discussed in the last section,
    each module is tested in isolation using unit testing to check everything is working
    as expected, then integration testing is performed between different modules to
    check the expected combined behavior and validate the requirements, whether implemented
    correctly or not. After integration tests, functional tests are executed that
    validate the functional and feature requirements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以确保任何更改不会破坏任何功能，并确保无缝、无故障的生产交付。正如上一节讨论的那样，每个模块都是使用单元测试在隔离状态下进行测试，以检查一切是否按预期工作，然后在不同模块之间执行集成测试，以检查预期的组合行为并验证需求是否正确实现。集成测试之后，执行功能测试以验证功能和特性需求。
- en: So, if unit testing makes sure individual modules are working fine in isolation,
    integration testing makes sure that interaction among different modules works
    as expected. If unit tests are working fine, it implies that the chances of integration
    test failure is greatly reduced. Similarly, integration testing ensures that functional
    testing is likely to be successful.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果单元测试确保单独模块在隔离状态下正常工作，集成测试则确保不同模块之间的交互按预期工作。如果单元测试正常工作，那么意味着集成测试失败的可能性大大降低。同样，集成测试确保功能测试有可能成功。
- en: It is presumed that one always keeps all types of tests updated, whether these
    are unit-level tests or end-to-end test scenarios.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 假定始终保持所有类型的测试更新，无论是单元级测试还是端到端测试场景。
- en: Self-monitoring and logging
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我监控和日志记录
- en: A microservice should provide service information about itself and the state
    of the various resources it depends on. Service information represents statistics
    such as the average, minimum, and maximum time to process a request, the number
    of successful and failed requests, being able to track a request, memory usage,
    and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务应该提供有关自身的服务信息以及其所依赖的各种资源的状态。服务信息表示统计数据，例如处理请求的平均、最小和最大时间，成功和失败请求的数量，能够跟踪请求，内存使用情况等等。
- en: 'Adrian Cockcroft highlighted a few practices which are very important for monitoring
    microservices at Glue Conference (Glue Con) 2015\. Most of them are valid for
    any monitoring system:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Adrian Cockcroft在Glue Conference（Glue Con）2015上强调了一些对于监控微服务非常重要的实践。其中大部分对于任何监控系统都是有效的：
- en: Spend more time working on code that analyzes the meaning of metrics than code
    that collects, moves, stores, and displays metrics. This helps to not only increase
    the productivity, but also provide important parameters to fine-tune the microservices
    and increase the system efficiency. The idea is to develop more analysis tools
    rather than developing more monitoring tools.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花更多时间编写分析指标含义的代码，而不是收集、移动、存储和显示指标的代码。这不仅有助于提高生产率，还提供了微调微服务和提高系统效率的重要参数。这个想法是开发更多的分析工具，而不是开发更多的监控工具。
- en: The metric to display latency needs to be less than the human attention span.
    That means less than 10 seconds, according to Adrian.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示延迟的指标需要小于人类的注意力持续时间。根据Adrian的说法，这意味着小于10秒。
- en: Validate that your measurement system has enough accuracy and precision. Collect
    histograms of response time.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证您的测量系统具有足够的准确性和精度。收集响应时间的直方图。
- en: Accurate data makes decision-making faster and allows you to fine-tune untill
    you reach precision level. He also suggests that the best graph to show the response
    time is a histogram.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准确的数据使决策更快，并允许您调整直到达到精度水平。他还建议显示响应时间的最佳图表是直方图。
- en: Monitoring systems need to be more available and scalable than the systems being
    monitored.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控系统需要比被监控的系统更加可用和可扩展。
- en: 'The statement says it all: you cannot rely on a system which itself is not
    stable or available 24/7.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这句话说得很清楚：您不能依赖一个自身不稳定或无法24/7可用的系统。
- en: Optimize for distributed, ephemeral, cloud-native, containerized microservices.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化分布式、短暂、云原生、容器化的微服务。
- en: Fit metrics to models to understand relationships.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将指标适应模型以了解关系。
- en: Monitoring is a key component of microservice architecture. You may have a dozen
    to thousands of microservices (true for a big enterprise's large project) based
    on project size. Even for scaling and high availability, organizations create
    a clustered or load balanced pool/pod for each microservice, even separate pools
    for each microservice based on versions. Ultimately, it increases the number of
    resources you need to monitor, including each microservice instance. In addition,
    it is important that you have a process in place so that whenever something goes
    wrong, you know it immediately, or better, receive a warning notification in advance
    before something goes wrong. Therefore, effective and efficient monitoring is
    crucial for building and using the microservice architecture. Netflix uses security
    monitoring using tools such as Netflix Atlas (real-time operational monitoring
    which processes 1.2 billion metrics), Security Monkey (for monitoring security
    on AWS-based environments), Scumblr (intelligence-gathering tool) and FIDO (for
    analyzing events and automated incident reporting).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是微服务架构的关键组成部分。根据项目规模，您可能会有十几个到数千个微服务（对于大型企业的大型项目而言是真实的）。即使为了扩展和高可用性，组织也会为每个微服务创建一个集群化或负载均衡的池/容器，甚至根据版本为每个微服务创建单独的池。最终，这增加了您需要监控的资源数量，包括每个微服务实例。此外，重要的是您有一个流程，以便每当出现问题时，您立即知道，或者更好的是，在出现问题之前提前收到警告通知。因此，对于构建和使用微服务架构来说，有效和高效的监控至关重要。Netflix使用诸如Netflix
    Atlas（实时操作监控，处理12亿个指标）、Security Monkey（用于监控基于AWS的环境安全性）、Scumblr（情报收集工具）和FIDO（用于分析事件和自动化事件报告）等工具进行安全监控。
- en: Logging is another important aspect for microservices that should not be ignored.
    Having effective logging makes all the difference. As there could be 10 or more
    microservices, managing logging is a huge task.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录是微服务中不容忽视的另一个重要方面。有效的日志记录可以产生重大影响。由于可能有10个或更多的微服务，管理日志记录是一项巨大的任务。
- en: For our sample project, we have used **Mapped Diagnostic Context** (**MDC**)
    logging, which is sufficient, in a way, for individual microservice logging. However,
    we also need logging for an entire system, or central logging. We also need aggregated
    statistics of logs. There are tools that do the job, such as Loggly or Logspout.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例项目，我们使用了足够的**映射诊断上下文**（**MDC**）日志记录，以某种方式，用于单个微服务的日志记录。然而，我们还需要整个系统的日志记录，或者中央日志记录。我们还需要日志的聚合统计数据。有一些工具可以完成这项工作，例如Loggly或Logspout。
- en: A request and generated correlated events gives you an overall view of the request.
    For tracing of any event and request, it is important to associate the event and
    request with service ID and request ID respectively. You can also associate the
    content of the event, such as message, severity, class name, and so on, to service
    ID.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请求和生成的相关事件为您提供了对请求的整体视图。对于任何事件和请求的跟踪，将事件和请求与服务ID和请求ID分别关联是很重要的。您还可以将事件的内容（例如消息、严重性、类名等）与服务ID关联起来。
- en: A separate data store for each microservice
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个微服务都有一个单独的数据存储
- en: If you remember, the most important characteristics of microservices you can
    find out about is the way microservices run in isolation from other microservices,
    most commonly as standalone applications.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您记得，您可以了解到微服务最重要的特征是微服务以与其他微服务隔离的方式运行，通常作为独立的应用程序。
- en: Abiding by this rule, it is recommended that you do not use the same database,
    or any other data store across multiple microservices. In large projects, you
    may have different teams working on the same project, and you want the flexibility
    to choose the database for each microservice that best suits the microservice.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这一规则，建议您不要在多个微服务之间使用相同的数据库或任何其他数据存储。在大型项目中，您可能有不同的团队在同一项目上工作，并且您希望灵活选择最适合微服务的数据库。
- en: Now, this also brings some challenges.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这也带来了一些挑战。
- en: For instance, the following is relevant to teams who may be working on different
    microservices within the same project, if that project shares the same database
    structure. There is a possibility that a change in one microservice may impact
    the other microservice models. In such cases, change in one may affect the dependent
    microservice, so you also need to change the dependent model structure.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下内容与可能在同一项目中工作在不同微服务上的团队相关，如果该项目共享相同的数据库结构。一个微服务的变化可能会影响其他微服务的模型。在这种情况下，一个微服务的变化可能会影响依赖的微服务，因此您还需要改变依赖模型结构。
- en: To resolve this issue, microservices should be developed based on an API-driven
    platform. Each microservice would expose its APIs, which could be consumed by
    the other microservices. Therefore, you also need to develop the APIs, which is
    required for the integration of different microservices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，微服务应该基于API驱动的平台进行开发。每个微服务都会暴露其API，其他微服务可以使用这些API。因此，您还需要开发API，用于集成不同的微服务。
- en: Similarly, due to different data stores, actual project data is also spread
    across multiple data stores and it makes data management more complicated, because
    the separate storage systems can more easily get out of sync or become inconsistent,
    and foreign keys can change unexpectedly. To resolve such an issue, you need to
    use **master data management** (**MDM**) tools. MDM tools operate in the background
    and fix inconsistencies if they find any. For the OTRS sample example, it might
    check every database that stores booking request IDs, to verify that the same
    IDs exist in all of them (in other words, that there aren't any missing or extra
    IDs in any one database). MDM tools available in the market include Informatica,
    IBM MDM Advance Edition, Oracle Siebel UCM, Postgres (master streaming replication),
    mariadb (master/master configuration), and so on.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于不同的数据存储，实际项目数据也分布在多个数据存储中，这使得数据管理变得更加复杂，因为单独的存储系统更容易失去同步或变得不一致，外键可能会意外更改。为了解决这样的问题，您需要使用**主数据管理**（**MDM**）工具。MDM工具在后台运行，如果发现任何不一致，就会修复它们。对于OTRS示例，它可能会检查存储预订请求ID的每个数据库，以验证这些ID在所有数据库中是否存在（换句话说，任何一个数据库中都没有缺少或额外的ID）。市场上可用的MDM工具包括Informatica、IBM
    MDM Advance Edition、Oracle Siebel UCM、Postgres（主流复制）、mariadb（主/主配置）等。
- en: If none of the existing products suits your requirements, or you are not interested
    in any proprietary product, then you can write your own. Presently, API-driven
    development and platforms reduce such complexities; therefore, it is important
    that microservices should be developed along with an API platform.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现有产品都不符合您的要求，或者您对任何专有产品都不感兴趣，那么您可以自己编写。目前，API驱动的开发和平台减少了这些复杂性；因此，微服务应该与API平台一起开发是非常重要的。
- en: Transaction boundaries
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务边界
- en: We went through domain-driven design concepts in [Chapter 3](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml),
    *Domain-Driven Design*. Please review this if you have not grasped it thoroughly,
    as it gives you an understanding of the state vertically. Since we are focusing
    on microservice-based design, the result is that we have a system of systems,
    where each microservice represents a system. In this environment, finding the
    state of a whole system at any given point in time is very challenging. If you
    are familiar with distributed applications, then you may be comfortable in such
    an environment, with respect to state.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](8d3fd180-4f27-4bf7-bb86-c180ac200687.xhtml)中介绍了领域驱动设计的概念，*领域驱动设计*。如果您还没有完全掌握它，请仔细阅读，因为它可以帮助您理解垂直状态。由于我们专注于基于微服务的设计，结果是我们有一个系统的系统，其中每个微服务代表一个系统。在这种环境中，要在任何给定时间找到整个系统的状态是非常具有挑战性的。如果您熟悉分布式应用程序，那么在这样的环境中，您可能会感到舒适，关于状态。
- en: It is very important to have transaction boundaries in place that describe which
    microservice owns a message at any given time. You need a way or process that
    can participate in transactions, transacted routes, and error handlers, idempotent
    consumers, and compensating actions. It is not an easy task to ensure transactional
    behavior across heterogeneous systems, but there are tools available that do the
    job for you.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何给定时间描述哪个微服务拥有消息的事务边界非常重要。您需要一种可以参与事务、事务路由和错误处理程序、幂等消费者和补偿操作的方式或流程。确保跨异构系统的事务行为并不是一件容易的任务，但有可用的工具可以为您完成这项工作。
- en: For example, Camel has great transactional capabilities that help developers
    easily create services with transactional behavior.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Camel具有出色的事务能力，可以帮助开发人员轻松创建具有事务行为的服务。
- en: Microservices frameworks and tools
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务框架和工具
- en: It is always better not to reinvent the wheel. Therefore, we would like to explore
    what tools are already available and provide the platform, framework, and features
    that make microservice development and deployment easier.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要重复造轮子。因此，我们想探索已经可用并提供使微服务开发和部署更加容易的平台、框架和功能的工具。
- en: 'Throughout the book, we have used Spring Cloud extensively, due to the same
    reason: it provides all of the tools and platforms required to make microservice
    development very easy. Spring Cloud uses Netflix **Open Source Software** (**OSS**).
    Let us explore Netflix OSS—a complete package.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们广泛使用了Spring Cloud，原因是它提供了使微服务开发变得非常容易所需的所有工具和平台。Spring Cloud使用Netflix
    **开源软件**（**OSS**）。让我们探索Netflix OSS - 一个完整的软件包。
- en: I have also added a brief overview about how each tool will help to build good
    microservice architecture.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我还添加了关于每个工具如何帮助构建良好的微服务架构的简要概述。
- en: Netflix Open Source Software (OSS)
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Netflix开源软件（OSS）
- en: Netflix OSS center is the most popular and widely used open source software
    for Java-based microservice open source projects. The world's most successful
    video renting service is dependent on it. Netflix has more than 40 million users
    and is used across the globe. Netflix is a pure cloud-based solution, developed
    on microservice-based architecture. You can say that whenever anybody talks about
    microservices, Netflix is the first name that comes to mind. Let us discuss the
    wide variety of tools it provides. We have already discussed many of them while
    developing the sample OTRS application. However, there are a few which we have
    not explored. Here, we'll cover only the overview of each tool, instead of going
    into detail. It will give you an overall idea of the practical characteristics
    of microservice architecture and its use in the cloud.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix OSS中心是基于Java的微服务开源项目中最受欢迎和广泛使用的开源软件。世界上最成功的视频租赁服务依赖于它。Netflix拥有超过4000万用户，并且在全球范围内使用。Netflix是一个纯粹的基于云的解决方案，基于微服务架构开发。可以说，每当有人谈论微服务时，Netflix都是首先想到的名字。让我们讨论它提供的各种工具。在开发示例OTRS应用程序时，我们已经讨论了其中许多工具。不过，还有一些我们没有探索过。在这里，我们将只概述每个工具，而不深入细节。这将让您对微服务架构的实际特性及其在云中的使用有一个整体的了解。
- en: Build - Nebula
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 - Nebula
- en: Netflix Nebula is a collection of Gradle plugins that makes your microservice
    builds easier using Gradle (a Maven-like build tool). For our sample project,
    we have made use of Maven, therefore we haven't had the opportunity to explore
    Nebula in this book. However, exploring it would be fun. The most significant
    Nebula feature for developers is eliminating the boilerplate code in Gradle build
    files, which allows developers to focus on coding.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix Nebula是一组Gradle插件，使用Gradle（一种类似于Maven的构建工具）使您的微服务构建更加容易。对于我们的示例项目，我们已经使用了Maven，因此在本书中我们没有机会探索Nebula。不过，探索它会很有趣。对开发人员来说，Nebula最重要的功能是消除Gradle构建文件中的样板代码，这使开发人员可以专注于编码。
- en: Having a good build environment, especially CI/CD (continuous integration and
    continuous deployment) is a must for microservice development and keeping aligned
    with agile development. Netflix Nebula makes your build easier and more efficient.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有良好的构建环境，特别是CI/CD（持续集成和持续部署），对于微服务开发和与敏捷开发保持一致是必不可少的。Netflix Nebula使您的构建更加容易和高效。
- en: Deployment and delivery - Spinnaker with Aminator
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署和交付 - 使用Aminator的Spinnaker
- en: Once your build is ready, you want to move that build to **Amazon Web Services**
    (**AWS**) EC2\. Aminator creates and packages images of builds in the form of
    **Amazon Machine Image** (**AMI**). Spinnaker then deploys these AMIs to AWS.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的构建准备就绪，您希望将该构建移至**亚马逊网络服务**（**AWS**）EC2。Aminator以**Amazon Machine Image**（**AMI**）的形式创建和打包构建的映像。然后Spinnaker将这些AMI部署到AWS。
- en: Spinnaker is a continuous delivery platform for releasing code changes with
    high velocity and efficiency. Spinnaker also supports other cloud services, such
    as Google Computer Engine and Cloud Foundry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Spinnaker是一个持续交付平台，用于以高速和高效率发布代码更改。Spinnaker还支持其他云服务，如Google计算引擎和Cloud Foundry。
- en: If you would like to deploy your latest microservice builds to cloud environments
    such as EC2, Spinnaker and Aminator help you to do that in an autonomous way.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将最新的微服务构建部署到EC2等云环境中，Spinnaker和Aminator可以帮助您以自主的方式进行部署。
- en: Service registration and discovery - Eureka
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务注册和发现 - Eureka
- en: Eureka, as we have explored in this book, provides a service that is responsible
    for microservice registration and discovery. On top of that, Eureka is also used
    for load balancing the middle tier (processes hosting different microservices).
    Netflix also uses Eureka, along with other tools, such as Cassandra or memcached,
    to enhance its overall usability.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书中所探讨的那样，Eureka提供了一个负责微服务注册和发现的服务。除此之外，Eureka还用于负载平衡中间层（托管不同微服务的进程）。Netflix还使用Eureka，以及其他工具，如Cassandra或memcached，以增强其整体可用性。
- en: Service registration and discovery is a must for microservice architecture.
    Eureka serves this purpose. Please refer to [Chapter 4](4561ba72-866e-45f9-88ac-761a62242e26.xhtml),
    *Implementing a Microservice*, for more information about Eureka.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 服务注册和发现对于微服务架构是必不可少的。Eureka用于这个目的。有关Eureka的更多信息，请参考[第4章](4561ba72-866e-45f9-88ac-761a62242e26.xhtml)，*实施微服务*。
- en: Service communication - Ribbon
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务通信 - Ribbon
- en: Microservice architecture is of no use if there is no interprocess or service
    communication. The Ribbon application provides this feature. Ribbon works with
    Eureka for load balancing and with Hystrix for fault tolerance or circuit breaker
    operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有进程间或服务通信，微服务架构就毫无意义。Ribbon应用程序提供了这个功能。Ribbon与Eureka一起用于负载平衡，并与Hystrix一起用于容错或断路器操作。
- en: Ribbon also supports TCP and UDP protocols, apart from HTTP. It provides these
    protocol supports in both asynchronous and reactive models. It also provides the
    caching and batching capabilities.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Ribbon还支持TCP和UDP协议，除了HTTP。它以异步和反应模型提供这些协议支持。它还提供缓存和批处理功能。
- en: Since you will have many microservices in your project, you need a way to process
    information using interprocess or service communication. Netflix provides the
    Ribbon tool for this purpose.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您的项目中将有许多微服务，您需要一种使用进程间或服务通信处理信息的方式。Netflix为此目的提供了Ribbon工具。
- en: Circuit breaker - Hystrix
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断路器 - Hystrix
- en: Hystrix tool is for circuit breaker operations, that is, latency and fault tolerance.
    Therefore, Hystrix stops cascading failures. Hystrix performs the real-time operations
    for monitoring the services and property changes, and supports concurrency.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Hystrix工具用于断路器操作，即延迟和容错。因此，Hystrix可以阻止级联故障。Hystrix执行实时操作来监控服务和属性更改，并支持并发。
- en: Circuit breaker, or fault tolerance, is an important concept for any project,
    including microservices. Failure of one microservice should not halt your entire
    system; to prevent this, and provide meaningful information to the customer on
    failure, is the job of Netflix Hystrix.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器或容错是任何项目（包括微服务）的重要概念。一个微服务的失败不应该使整个系统停止运行；防止这种情况发生，并向客户提供有意义的失败信息，这是Netflix
    Hystrix的工作。
- en: Edge (proxy) server - Zuul
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边缘（代理）服务器 - Zuul
- en: Zuul is an edge server or proxy server, and serves the requests of external
    applications such as UI client, Android/iOS application, or any third-party consumer
    of APIs offered by the product or service. Conceptually, it is a door to external
    applications.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul是一个边缘服务器或代理服务器，为外部应用程序提供服务，如UI客户端、Android/iOS应用程序或产品或服务提供的API的任何第三方消费者。在概念上，它是对外部应用程序的门户。
- en: Zuul allows dynamic routing and monitoring of requests. It also performs security
    operations such as authentication. It can identify authentication requirements
    for each resource and reject any request that does not satisfy them.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Zuul允许动态路由和请求监控。它还执行身份验证等安全操作。它可以识别每个资源的身份验证要求，并拒绝任何不满足要求的请求。
- en: You need an edge server or API gateway for your microservices. Netflix Zuul
    provides this feature. Please refer to [Chapter 5](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml),
    *Deployment and Testing,* for more information.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您的微服务需要一个边缘服务器或API网关。Netflix Zuul提供了这个功能。更多信息请参考[第5章](b1f93b4e-3475-4d8a-8c9f-697b0fd4410c.xhtml)，*部署和测试*。
- en: Operational monitoring - Atlas
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作监控 - Atlas
- en: Atlas is an operational monitoring tool that provides near-real-time information
    on dimensional time-series data. It captures operational intelligence that provides
    a picture of what is currently happening within a system. It features in-memory
    data storage, allowing it to gather and report very large numbers of metrics very
    quickly. At present, it processes 1.3 billion metrics for Netflix.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas是一个操作监控工具，提供关于维度时间序列数据的几乎实时信息。它捕获操作智能，提供了系统当前发生情况的图像。它具有内存数据存储功能，可以快速收集和报告大量的指标。目前，它为Netflix处理13亿个指标。
- en: Atlas is a scalable tool. This is why it can now process 1.3 billion metrics,
    from 1 million metrics a few years back. Atlas not only provides scalability in
    terms of reading the data, but also aggregating it as a part of graph request.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas是一个可扩展的工具。这就是为什么它现在可以处理13亿个指标，而几年前只能处理100万个指标。Atlas不仅在读取数据方面提供了可扩展性，而且作为图形请求的一部分进行了聚合。
- en: Atlas uses the Netflix Spectator library for recording dimensional time-series
    data.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Atlas使用Netflix Spectator库记录维度时间序列数据。
- en: Once you deploy microservices in a cloud environment, you need to have a monitoring
    system in place to track and monitor all microservices. Netflix Atlas does this
    job for you.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在云环境中部署了微服务，您需要一个监控系统来跟踪和监控所有微服务。Netflix Atlas为您完成了这项工作。
- en: Reliability monitoring service - Simian Army
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性监控服务 - Simian Army
- en: In Cloud, no single component can guarantee 100% uptime. Therefore, it is a
    requirement for successful microservice architecture to make the entire system
    available in case a single cloud component fails. Netflix has developed a tool
    named Simian Army to avoid system failure. Simian Army keeps a cloud environment
    safe, secure, and highly available. To achieve high availability and security,
    it uses various services (Monkeys) in the cloud for generating various kinds of
    failures, detecting abnormal conditions, and testing the cloud's ability to survive
    these challenges.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在云中，没有单个组件可以保证100%的正常运行时间。因此，成功的微服务架构需要使整个系统在单个云组件失败时仍然可用。Netflix开发了一个名为Simian
    Army的工具来避免系统故障。Simian Army使云环境安全、安全且高度可用。为了实现高可用性和安全性，它在云中使用各种服务（猴子）来生成各种故障、检测异常情况并测试云的能力来应对这些挑战。
- en: 'It uses the following services (Monkeys), which are taken from the Netflix
    blog:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用以下服务（猴子），这些服务来自Netflix博客：
- en: '**Chaos Monkey**: Chaos Monkey is a service which identifies groups of systems
    and randomly terminates one of the systems in a group. The service operates at
    a controlled time and interval. Chaos Monkey only runs in business hours with
    the intent that engineers will be alert and able to respond.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混沌猴子**：混沌猴子是一个识别系统组并随机终止组中一个系统的服务。该服务在受控时间和间隔内运行。混沌猴子只在工作时间运行，目的是工程师能够警觉并做出响应。'
- en: '**Janitor Monkey**: Janitor Monkey is a service which runs in the AWS cloud
    looking for unused resources to clean up. It can be extended to work with other
    cloud providers and cloud resources. The schedule of service is configurable.
    Janitor Monkey determines whether a resource should be a cleanup candidate, by
    applying a set of rules on it. If any of the rules determines that the resource
    is a cleanup candidate, Janitor Monkey marks the resource and schedules a time
    to clean it up. For exceptional cases, when you want to keep an unused resource
    longer, before Janitor Monkey deletes a resource, the owner of the resource will
    receive a notification a configurable number of days ahead of the cleanup time.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清洁工猴子**：清洁工猴子是一个在AWS云中运行的服务，寻找未使用的资源进行清理。它可以扩展到与其他云提供商和云资源一起工作。服务的计划是可配置的。清洁工猴子通过对资源应用一组规则来确定资源是否应该进行清理。如果任何规则确定资源是清理候选项，清洁工猴子会标记资源并安排时间进行清理。在特殊情况下，如果您希望保留未使用的资源更长时间，在清洁工猴子删除资源之前，资源的所有者将在清理时间的可配置天数之前收到通知。'
- en: '**Conformity Monkey**: Conformity Monkey is a service which runs in the AWS
    cloud looking for instances that are not conforming to predefined rules for the
    best practices. It can be extended to work with other cloud providers and cloud
    resources. The schedule of service is configurable. If any of the rules determines
    that the instance is not conforming, the monkey sends an email notification to
    the owner of the instance. There could be exceptional cases where you want to
    ignore warnings of a specific conformity rule for some applications.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符合性猴子**：符合性猴子是一个在AWS云中运行的服务，寻找不符合最佳实践预定义规则的实例。它可以扩展到与其他云提供商和云资源一起工作。服务的计划是可配置的。如果任何规则确定实例不符合，猴子会向实例的所有者发送电子邮件通知。也可能有特殊情况，您希望忽略某些应用程序的特定符合性规则的警告。'
- en: '**Security Monkey**: Security Monkey monitors policy changes and alerts on
    insecure configurations in an AWS account. The main purpose of Security Monkey
    is security, though it also proves a useful tool for tracking down potential problems,
    as it is essentially a change-tracking system.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全猴子**：安全猴子监视AWS帐户中的策略更改并警告不安全的配置。安全猴子的主要目的是安全，尽管它也是追踪潜在问题的有用工具，因为它本质上是一个变更跟踪系统。'
- en: Successful microservice architecture makes sure that your system is always up,
    and failure of a single cloud component should not fail the entire system. Simian
    Army uses many services to achieve high availability.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的微服务架构确保您的系统始终处于运行状态，并且单个云组件的故障不应导致整个系统失败。Simian Army使用许多服务来实现高可用性。
- en: AWS resource monitoring - Edda
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS资源监控 - Edda
- en: In a cloud environment, nothing is static. For example, virtual host instances
    change frequently, an IP address could be reused by various applications, or a
    firewall or related changes may take place.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在云环境中，没有什么是静态的。例如，虚拟主机实例经常更改，IP地址可能被各种应用程序重复使用，或者防火墙或相关更改可能发生。
- en: Edda is a service that keeps track of these dynamic AWS resources. Netflix named
    it Edda (meaning *a tale of Norse mythology*), as it records the tales of cloud
    management and deployments. Edda uses the AWS APIs to poll AWS resources and records
    the results. These records allow you to search and see how the cloud has changed
    over time. For instance, if any host of the API server is causing any issue, then
    you need to find out what that host is and which team is responsible for it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Edda是一个跟踪这些动态AWS资源的服务。Netflix将其命名为Edda（意为*北欧神话的故事*），因为它记录了云管理和部署的故事。Edda使用AWS
    API来轮询AWS资源并记录结果。这些记录允许您搜索并查看云随时间的变化。例如，如果API服务器的任何主机引起任何问题，那么您需要找出该主机是什么以及哪个团队负责它。
- en: 'These are the features it offers:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是它提供的功能：
- en: '**Dynamic querying**: Edda provides the REST APIs, and it supports the matrix
    arguments and provides fields selectors that let you retrieve only the desired
    data.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态查询**：Edda提供REST API，并支持矩阵参数，并提供字段选择器，让您只检索所需的数据。'
- en: '**History**/c**hanges**: Edda maintains the history of all AWS resources. This
    information helps you when you analyze the causes and impact of outage. Edda can
    also provide the different view of current and historical information about resources.
    It stores the information in MongoDB at the time of writing.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史**/ **更改**：Edda保留所有AWS资源的历史信息。这些信息在分析故障原因和影响时对您有所帮助。Edda还可以提供有关资源的当前和历史信息的不同视图。它在撰写时将信息存储在MongoDB中。'
- en: '**Configuration**: Edda supports many configuration options. In general, you
    can poll information from multiple accounts and multiple regions and can use the
    combination of account and regions that account points. Similarly, it provides
    different configurations for AWS, Crawler, Elector, and MongoDB.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：Edda支持许多配置选项。一般来说，您可以从多个帐户和多个区域中轮询信息，并可以使用帐户和区域的组合。同样，它为AWS、Crawler、Elector和MongoDB提供不同的配置。'
- en: If you are using the AWS for hosting your microservice-based product, then Edda
    serves the purpose of monitoring the AWS resources.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用AWS来托管基于微服务的产品，那么Edda可以用于监控AWS资源。
- en: On-host performance monitoring - Vector
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机性能监控 - Vector
- en: Vector is a static web application and runs inside a web browser. It allows
    it to monitor the performance of those hosts where **Performance Co-Pilot** (**PCP**)
    is installed. Vector supports PCP version 3.10+. PCP collects metrics and makes
    them available to Vector.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Vector是一个静态的Web应用程序，运行在Web浏览器中。它允许监视安装了**Performance Co-Pilot** (**PCP**)的主机的性能。Vector支持PCP版本3.10+。PCP收集指标并使其可供Vector使用。
- en: It provides high-resolution right metrics available on demand. This helps engineers
    to understand how a system behaves and correctly troubleshoot performance issues.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它提供了高分辨率的实时指标。这有助于工程师了解系统的行为并正确地解决性能问题。
- en: Vector is a monitoring tool that helps you to monitor the performance of a remote
    host.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Vector是一个监控工具，可帮助您监控远程主机的性能。
- en: Distributed configuration management - Archaius
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分布式配置管理 - Archaius
- en: 'Archaius is a distributed configuration management tool that allows you to
    do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Archaius是一个分布式配置管理工具，允许您执行以下操作：
- en: Use dynamic and typed properties.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动态和类型化的属性。
- en: Perform thread-safe configuration operations.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行线程安全的配置操作。
- en: Check for property changes using a polling framework.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用轮询框架检查属性更改。
- en: Use a callback mechanism in an ordered hierarchy of configurations.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有序的配置层次结构中使用回调机制。
- en: Inspect and perform operations on properties using JConsole, as Archaius provides
    the JMX MBean.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JConsole检查和操作属性，因为Archaius提供了JMX MBean。
- en: A good configuration management tool is required when you have a microservice-based
    product. Archaius helps to configure different types of properties in a distributed
    environment.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您拥有基于微服务的产品时，需要一个良好的配置管理工具。Archaius有助于在分布式环境中配置不同类型的属性。
- en: Scheduler for Apache Mesos - Fenzo
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apache Mesos的调度程序 - Fenzo
- en: 'Fenzo is a scheduler library for Apache Mesos frameworks written in Java. Apache
    Mesos frameworks match and assign resources to pending tasks. The following are
    its key features:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Fenzo是一个用Java编写的Apache Mesos框架的调度程序库。Apache Mesos框架匹配并为待处理的任务分配资源。以下是其主要特点：
- en: It supports long-running service style tasks and for batch
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持长时间运行的服务式任务和批处理
- en: It can auto-scale the execution host cluster, based on resource demands
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以根据资源需求自动扩展执行主机集群
- en: It supports plugins that you can create based on requirements
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持根据需求创建插件
- en: You can monitor resource-allocation failures, which allows you to debug the
    root cause
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以监视资源分配失败，从而可以调试根本原因
- en: Cost and cloud utilization - Ice
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成本和云利用率 - Ice
- en: Ice provides a bird's-eye view of cloud resources from a cost and usage perspective.
    It provides the latest information about provisioned cloud resource allocation
    to different teams that adds value for optimal utilization of the cloud resources.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Ice从成本和使用情况的角度提供了对云资源的鸟瞰图。它提供了有关为不同团队分配的云资源配置的最新信息，为云资源的最佳利用增加了价值。
- en: Ice is a grail project. Users interact with the Ice UI component that displays
    the information sent via the Ice reader component. The reader fetches information
    from the data generated by the Ice processor component. The Ice processor component
    reads data information from a detailed cloud billing file and converts it into
    data that is readable by the Ice reader component.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Ice是一个重要的项目。用户与Ice UI组件交互，该组件显示通过Ice读取器组件发送的信息。读取器从Ice处理器组件生成的数据中获取信息。Ice处理器组件从详细的云计费文件中读取数据信息，并将其转换为Ice读取器组件可读取的数据。
- en: Other security tools - Scumblr and FIDO
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他安全工具 - Scumblr和FIDO
- en: Along with Security Monkey, Netflix OSS also makes use of Scumblr and **Fully
    Integrated Defense** **Operation** (**FIDO**) tools.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Security Monkey，Netflix OSS还使用Scumblr和**Fully Integrated Defense** **Operation**
    (**FIDO**)工具。
- en: To keep track of and protect your microservices from regular threats and attacks,
    you need an automated way to secure and monitor your microservices. Netflix Scumblr
    and FIDO do this job for you.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪和保护您的微服务免受常规威胁和攻击，您需要一种自动化的方式来保护和监控您的微服务。Netflix Scumblr和FIDO为您完成了这项工作。
- en: Scumblr
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scumblr
- en: Scumblr is a Ruby on Rails based web application that allows you to perform
    periodic searches and store/take action on the identified results. Basically,
    it gathers intelligence that leverages internet-wide targeted searches to surface
    specific security issues for investigation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Scumblr是一个基于Ruby on Rails的Web应用程序，允许您定期进行搜索并存储/对识别的结果采取行动。基本上，它收集情报，利用全网定向搜索来发现特定的安全问题进行调查。
- en: 'Scumblr makes use of the Workflowable gem to allow flexible workflows to be
    set up for different types of results. Scumblr searches utilize plugins called
    **Search Providers**. It checks anomalies such as the following. Since it is extensible,
    you can add as many as you want:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Scumblr利用Workflowable gem允许为不同类型的结果设置灵活的工作流程。Scumblr搜索利用称为**Search Providers**的插件。它检查异常，例如以下情况。由于它是可扩展的，您可以添加任意数量的异常：
- en: Compromised credentials
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被盗的凭证
- en: Vulnerability/hacking discussion
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 漏洞/黑客讨论
- en: Attack discussion
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击讨论
- en: Security-relevant social media discussion
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与安全相关的社交媒体讨论
- en: Fully Integrated Defence Operation (FIDO)
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全集成的防御操作（FIDO）
- en: FIDO is a security orchestration framework for analyzing events and automating
    incident responses. It automates the incident response process by evaluating,
    assessing, and responding to malware. FIDO's primary purpose is to handle the
    heavy manual effort needed to evaluate threats coming from today's security stack
    and the large number of alerts generated by them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: FIDO是一个安全编排框架，用于分析事件并自动化事件响应。它通过评估、评估和响应恶意软件来自动化事件响应过程。FIDO的主要目的是处理来自当今安全堆栈的威胁和由此产生的大量警报所需的繁重手动工作。
- en: 'As an orchestration platform, FIDO can make using your existing security tools
    more efficient and accurate by heavily reducing the manual effort needed to detect,
    notify, and respond to attacks against a network. For more information, you can
    refer to the following links:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个编排平台，FIDO可以通过大大减少检测、通知和响应网络攻击所需的手动工作，使您现有的安全工具更加高效和准确。有关更多信息，您可以参考以下链接：
- en: '[https://github.com/Netflix/Fido](https://github.com/Netflix/Fido)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix/Fido](https://github.com/Netflix/Fido)'
- en: '[https://github.com/Netflix](https://github.com/Netflix)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Netflix](https://github.com/Netflix)'
- en: References
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Monolithic (Etsy) versus Microservices (Netflix) Twitter discussion: [https://twitter.com/adrianco/status/441169921863860225](https://twitter.com/adrianco/status/441169921863860225)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构（Etsy）与微服务（Netflix）Twitter讨论：[https://twitter.com/adrianco/status/441169921863860225](https://twitter.com/adrianco/status/441169921863860225)
- en: '*Monitoring Microservice and Containers Presentation* by Adrian Cockcroft:
    [http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge](http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adrian Cockcroft的*监控微服务和容器演示*：[http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge](http://www.slideshare.net/adriancockcroft/gluecon-monitoring-microservices-and-containers-a-challenge)
- en: 'Nanoservice Antipattern: [http://arnon.me/2014/03/services-microservices-nanoservices/](http://arnon.me/2014/03/services-microservices-nanoservices/%20)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳米服务反模式：[http://arnon.me/2014/03/services-microservices-nanoservices/](http://arnon.me/2014/03/services-microservices-nanoservices/%20)
- en: 'Apache Camel for Micro­service Architectures: [https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html](https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Camel用于微服务架构：[https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html](https://www.javacodegeeks.com/2014/09/apache-camel-for-micro%C2%ADservice-architectures.html)
- en: 'Teamcity: [https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Teamcity：[https://www.jetbrains.com/teamcity/](https://www.jetbrains.com/teamcity/)
- en: 'Jenkins: [https://jenkins-ci.org/](https://jenkins-ci.org/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins：[https://jenkins-ci.org/](https://jenkins-ci.org/)
- en: 'Loggly: [https://www.loggly.com/](https://www.loggly.com/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Loggly：[https://www.loggly.com/](https://www.loggly.com/)
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have explored various practices and principles which are
    best-suited for microservice-based products and services. Microservice architecture
    is a result of cloud environments, which are being used widely in comparison to
    on-premises-based monolithic systems. We have identified a few of the principles
    related to size, agility, and testing, that have to be in place for successful
    implementation.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了适用于基于微服务的产品和服务的各种实践和原则。微服务架构是云环境的结果，与基于内部系统的单片系统相比，广泛使用。我们已经确定了一些与大小、敏捷性和测试相关的原则，这些原则必须在成功实施中得到落实。
- en: We have also got an overview of different tools used by Netflix OSS for the
    various key features required for successful implementation of microservice-architecture-based
    products and services. Netflix offers a video rental service, using the same tools
    successfully.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还概述了Netflix OSS使用的不同工具，用于成功实施基于微服务架构的产品和服务所需的各种关键功能。Netflix提供视频租赁服务，并成功使用相同的工具。
- en: In the next chapter, readers may encounter issues and they may get stuck on
    those problems. The chapter explains the common problems encountered during the
    development of microservices, and their solutions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，读者可能会遇到问题，并可能会在这些问题上卡住。本章解释了在开发微服务过程中遇到的常见问题及其解决方案。
