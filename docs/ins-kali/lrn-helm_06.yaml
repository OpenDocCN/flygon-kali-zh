- en: '*Chapter 4*: Understanding Helm Charts'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：理解Helm图表
- en: In the previous chapter, you learned how to use Helm from an end user perspective,
    leveraging it as a package manager to install applications to Kubernetes. Using
    Helm in this fashion did not require any Kubernetes expertise or any deep understanding
    of the application since all of the resources and logic were included as part
    of a Helm chart. The only concept you needed to be familiar with were the values
    that the chart provided in order to customize your installation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何从最终用户的角度使用Helm，将其作为一个包管理器来安装应用程序到Kubernetes。以这种方式使用Helm不需要任何Kubernetes专业知识或对应用程序的深入理解，因为所有资源和逻辑都包含在Helm图表的一部分中。您需要熟悉的唯一概念是图表提供的值，以便自定义安装。
- en: We will now shift gears from using Helm charts to understanding how they work
    and are created.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将从使用Helm图表转向理解它们是如何工作和创建的。
- en: 'To do so, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将涵盖以下主题：
- en: Understanding the YAML format
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解YAML格式
- en: Understanding chart templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图表模板
- en: Understanding chart definitions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解图表定义
- en: Life cycle management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期管理
- en: Documenting a Helm chart
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录Helm图表
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This section requires the `helm` binary to be installed on your local machine.
    The installation and configuration of this tool are covered in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098),
    Preparing a Kubernetes and Helm Environment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节要求在本地机器上安装`helm`二进制文件。有关此工具的安装和配置在[*第2章*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098)中有介绍，准备Kubernetes和Helm环境。
- en: Understanding the YAML format
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解YAML格式
- en: '**YAML Ain''t Markup Language** **(YAML)** is a file format used to create
    human-readable configuration. It is the file format most commonly used to configure
    Kubernetes resources and is also the format used for many of the files in Helm
    charts.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: YAML不是一种标记语言（YAML）是一种用于创建可读性强的配置文件的文件格式。它是配置Kubernetes资源最常用的文件格式，也是Helm图表中许多文件的格式。
- en: YAML files follow a key-value format to declare configuration. Let's explore
    the YAML key-value construct.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件遵循键值格式来声明配置。让我们探索YAML键值构造。
- en: Defining key-value pairs
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义键值对
- en: 'One of the most basic examples of a YAML key-value pair is shown here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个最基本的YAML键值对示例：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, the `name` key is given a `LearnHelm` value. In YAML,
    keys and values are separated by a colon (:). Characters written to the left of
    the colon represent the key, while characters written to the right of the colon
    represent the value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`name`键被赋予了`LearnHelm`值。在YAML中，键和值由冒号（:）分隔。冒号左边的字符代表键，而冒号右边的字符代表值。
- en: 'Spacing matters in YAML format. The following line does not constitute a key-value
    pair:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在YAML格式中，间距很重要。以下行不构成键值对：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that a space is missing between the colon and the `LearnHelm` string.
    This would result in a parsing error. A space must exist between the colon and
    the value.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，冒号和`LearnHelm`字符串之间缺少空格。这将导致解析错误。冒号和值之间必须存在空格。
- en: 'While the preceding example represents a simple key-value pair, YAML allows
    users to configure more complex pairings with nested elements or blocks. An example
    is shown here:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的示例代表了一个简单的键值对，但YAML允许用户配置具有嵌套元素或块的更复杂的配对。下面是一个示例：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example demonstrates a resources object containing a map of two
    key-value pairs:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例演示了一个包含两个键值对的资源对象的映射：
- en: '![](image/012.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](image/012.jpg)'
- en: Keys are determined by following the indentation under a YAML block. Each indentation
    adds a dot (`.`) separator to the name of the key. The value of the key has been
    reached when there are no longer any indentations remaining in the YAML block.
    By common practice, indentations in YAML should use two spaces, but users can
    provide as many spaces as they desire as long as the spacing is consistent throughout
    the document.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 键是通过遵循YAML块下的缩进来确定的。每个缩进都会在键的名称中添加一个点（`.`）分隔符。当YAML块中不再有缩进时，就已经到达了键的值。按照通常的做法，YAML中的缩进应该使用两个空格，但用户可以提供任意多的空格，只要在整个文档中保持一致。
- en: 'Important note:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: '**Tabs** are not supported by YAML and their use will result in a parsing error.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: YAML不支持**制表符**，使用制表符会导致解析错误。
- en: With an understanding of YAML key-value pairs, let's now explore some of the
    common types that values can be defined as.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解YAML键值对，现在让我们来探索一些常见的值类型。
- en: Value types
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值类型
- en: 'Values in a YAML file can be of different types. The most common type is a
    string, which is a text value. Strings can be declared by wrapping a value in
    quotations, but this is not always required. If a value contains at least one
    alphabetical letter or special character, the value is considered a string, with
    or without quotation marks. Multi-line strings can be set by using the pipe (`|`)
    symbol, as shown:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: YAML文件中的值可以是不同的类型。最常见的类型是字符串，它是一个文本值。字符串可以通过用引号括起来来声明，但这并不总是必需的。如果一个值包含至少一个字母或特殊字符，那么这个值被认为是一个字符串，无论是否有引号。多行字符串可以通过使用管道（`|`）符号来设置，如下所示：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Values can also be integers. A value is an integer when it is a numeric character
    that is not wrapped in quotations. The following YAML declares an integer value:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以是整数。当一个数值字符没有用引号括起来时，它就是一个整数值。以下的YAML声明了一个整数值：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Compare this to the following YAML, which assigns replicas to a string value:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与以下YAML进行比较，该YAML将副本分配给一个字符串值：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Boolean values are often used as well, which can be declared with either true
    or false:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值也经常被使用，可以用true或false来声明：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This YAML sets `ingress.enable` to the `true` Boolean value. Other acceptable
    Boolean values are `yes`, `no`, `on`, `off`, `y`, `n`, `Y`, and `N`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML将`ingress.enable`设置为`true`布尔值。其他可接受的布尔值包括`yes`、`no`、`on`、`off`、`y`、`n`、`Y`和`N`。
- en: Values can also be set to more complex types, such as lists. Items in a list
    in YAML are identified by the dash (`-`) symbol.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值也可以设置为更复杂的类型，比如列表。在YAML中，列表中的项目由破折号（`-`）符号标识。
- en: 'The following demonstrates a YAML list:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示了一个YAML列表：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This YAML sets `servicePorts` to the list of integers (such as `8080` and `8443`).
    This syntax can also be used to describe a list of objects:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个YAML将`servicePorts`设置为整数列表（比如`8080`和`8443`）。这种语法也可以用来描述对象列表：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, `env` is set to a list of objects containing the `name` and `value`
    fields. Lists are often used in both Kubernetes and Helm configuration and understanding
    them is valuable to using Helm to its fullest potential.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`env`被设置为一个包含`name`和`value`字段的对象列表。列表在Kubernetes和Helm配置中经常被使用，理解它们对于充分利用Helm是很有价值的。
- en: While YAML is more commonly used in the worlds of Kubernetes and Helm for its
    ease of readability, the **JavaScript Object Notation** (**JSON**) format can
    be used as well. Let's briefly describe this format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然YAML在Kubernetes和Helm的世界中更常用，因为它易于阅读，但**JavaScript对象表示**（**JSON**）格式也可以使用。让我们简要描述一下这种格式。
- en: The JSON format
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: JSON格式
- en: YAML is a superset of another widely used format—JSON. JSON is a string of key-value
    pairs, similar to YAML. The key difference is that while YAML relies on spacing
    and indentation to properly configure key-value pairs, JSON relies on braces and
    brackets.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: YAML是另一种广泛使用的格式JSON的超集。JSON是一串键值对，类似于YAML。主要区别在于，YAML依赖于空格和缩进来正确配置键值对，而JSON依赖于大括号和方括号。
- en: 'The following example converts the previous YAML example into JSON format:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将前面的YAML示例转换为JSON格式：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All of the keys in JSON are wrapped in quotation marks and positioned before
    a colon:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: JSON中的所有键都用引号括起来，并放在冒号之前：
- en: Curly braces (`{`) denote a block in a similar way to how indentations denote
    a block in YAML.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花括号（`{`）以类似于YAML中缩进表示块的方式表示块。
- en: Square brackets (`[`) denote a list in a similar way to how dashes denote a
    list in YAML.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号（`[`）以类似于YAML中破折号表示列表的方式表示列表。
- en: There are many more constructs to the YAML and JSON formats, but this introduction
    provides more than enough information to understand how they can be used in Helm
    charts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: YAML和JSON格式有许多其他构造，但这个介绍提供了足够的信息来理解它们如何在Helm图表中使用。
- en: In the next section, we will discuss the Helm chart file structure, which you
    may notice contains several YAML and JSON files.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论Helm图表文件结构，您可能会注意到其中包含几个YAML和JSON文件。
- en: The Helm chart structure
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表结构
- en: 'As you will recall from previous chapters, a Helm chart is a packaging of Kubernetes
    resources, allowing users to deploy applications of varying complexities to Kubernetes.
    In order to be considered a Helm chart, however, a certain file structure must
    be followed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得之前的章节，Helm图表是Kubernetes资源的打包，允许用户将各种复杂性的应用程序部署到Kubernetes。然而，为了被视为Helm图表，必须遵循一定的文件结构：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It is best practice to name the top-level directory as the name of the Helm
    chart. This is not a technical requirement, but it makes identifying the name
    of a Helm chart much simpler. For the preceding example file structure, the Helm
    chart's name is likely to be `my-chart`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是将顶层目录命名为Helm图表的名称。这不是技术要求，但它可以更简单地识别Helm图表的名称。对于前面的示例文件结构，Helm图表的名称很可能是`my-chart`。
- en: 'Under the top-level directory are the files and directories that comprise the
    Helm chart. The following table shows each of these possible files and directories:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶层目录下是组成Helm图表的文件和目录。以下表格显示了每个可能的文件和目录：
- en: '![](image/021.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](image/021.jpg)'
- en: Throughout this chapter, we will explore each of these files to understand how
    a Helm chart is created. We'll first begin by understanding how chart templates
    work to allow Kubernetes resources to be dynamically generated.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这些文件，以了解如何创建Helm图表。我们将首先通过了解图表模板的工作原理来允许动态生成Kubernetes资源。
- en: Understanding chart templates
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解图表模板
- en: The primary purpose of a Helm chart is to create and manage the Kubernetes resources
    that make up an application. This is accomplished through chart templates, with
    values serving as parameters to customize those templates. In this section, we
    will discuss how Helm templates and values function.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表的主要目的是创建和管理组成应用程序的Kubernetes资源。这是通过图表模板实现的，值作为参数来自定义这些模板。在本节中，我们将讨论Helm模板和值的功能。
- en: 'Helm charts must contain a `templates/` directory that defines the Kubernetes
    resources to be deployed (although this directory is not strictly required if
    the chart declares dependencies). The contents under the `templates/` directory
    are YAML files that are made up of Kubernetes resources. The contents of a `templates/`
    directory may appear similar to the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表必须包含一个`templates/`目录，该目录定义要部署的Kubernetes资源（尽管如果图表声明了依赖项，则不严格需要此目录）。`templates/`目录下的内容是由Kubernetes资源组成的YAML文件。`templates/`目录的内容可能类似于以下内容：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `configmap.yaml` resource may then look as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`configmap.yaml`资源可能如下所示：
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You may question whether the prior example is a valid YAML syntax. It is because
    the `configmap.yaml` file is actually a Helm template that will modify the configuration
    of this resource based on a certain set of values to produce a valid YAML resource.
    The opening and closing curly braces represent input text for a **Golang** (**Go**)
    template that will be removed during an installation or upgrade.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会质疑先前的示例是否是有效的YAML语法。这是因为`configmap.yaml`文件实际上是一个Helm模板，它将根据一定的一组值修改此资源的配置，以生成有效的YAML资源。开放和关闭的大括号代表了**Golang**（**Go**）模板的输入文本，这些将在安装或升级过程中被移除。
- en: Let's learn more about Go templates and how they can be used to generate Kubernetes
    resource files.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更多地了解Go模板以及它们如何用于生成Kubernetes资源文件。
- en: Go templating
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go模板
- en: '**Go** is a programming language that was developed by Google in 2009\. It
    is the programming language used by Kubernetes, Helm, and many other tools in
    the Kubernetes and container community. A core component of the Go programming
    language is templates, which can be leveraged to generate files of different formats.
    In the case of Helm, Go templates are used to generate Kubernetes YAML resources
    under a Helm chart''s `templates/` directory.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**Go**是由Google于2009年开发的一种编程语言。它是Kubernetes、Helm和Kubernetes和容器社区中许多其他工具使用的编程语言。Go编程语言的核心组件是模板，可以用来生成不同格式的文件。在Helm的情况下，Go模板用于在Helm图表的`templates/`目录下生成Kubernetes
    YAML资源。'
- en: Go template controls structures and processing begin with two opening curly
    braces ( `{{` ) and ends with two ending curly braces ( `}}` ). While these punctuation
    marks may appear in a local file under the `templates/` directory, they are removed
    during the processing that takes place during an installation or upgrade.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Go模板控制结构和处理从两个开放的大括号（`{{`）开始，并以两个结束的大括号（`}}`）结束。虽然这些标点符号可能出现在`templates/`目录下的本地文件中，但它们在安装或升级过程中进行的处理过程中被移除。
- en: We will dive deeper into Go templating in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*, where you will build your own Helm chart. In
    this chapter, we will discuss common capabilities of Go templating as an introduction
    to this feature before getting some hands-on practice. We'll start our discussion
    with a list of capabilities that Go templating provides, beginning with parameterization.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《第5章》[*构建您的第一个Helm图表*]中深入探讨Go模板，您将在其中构建自己的Helm图表。在本章中，我们将讨论Go模板的常见功能，作为这一功能的介绍，然后进行一些实际操作。我们将从Go模板提供的一系列功能开始讨论，从参数化开始。
- en: Parameterizing fields with values and built-in objects
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用值和内置对象对字段进行参数化
- en: Helm charts contain a `values.yaml` file in their chart directories. This file
    declares all of a chart's default values, which are referenced by Go templates
    and processed by Helm to dynamically generate Kubernetes resources.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表在其图表目录中包含一个`values.yaml`文件。该文件声明了图表的所有默认值，这些值由Go模板引用，并由Helm处理以动态生成Kubernetes资源。
- en: 'A chart''s `values.yaml` file may have values defined as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的`values.yaml`文件可以定义如下的值：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Lines that begin with the pound symbol (`#`) are comments (which are ignored
    during execution) and should provide details about the values they describe so
    that the user understands how they should be applied. Comments can also include
    the name of the value to allow comments to appear when a value is searched upon.
    Other lines in the file represent key-value pairs. An introduction to the YAML
    format is described at the beginning of this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以井号（`#`）开头的行是注释（在执行过程中被忽略），应提供有关它们描述的值的详细信息，以便用户了解应如何应用它们。注释还可以包括值的名称，以便在搜索值时出现注释。文件中的其他行表示键值对。本章开头描述了YAML格式的介绍。
- en: Go templates beginning with `.Values` will reference values defined in a `values.yaml`
    file or passed in using the `--set` or `--values` flags during an installation
    or upgrade.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 以`.Values`开头的Go模板将引用在`values.yaml`文件中定义的值，或者在安装或升级期间使用`--set`或`--values`标志传递的值。
- en: 'The following example represents a template before it is processed:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例表示模板在处理之前的样子：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After the template is processed, a snippet of a YAML resource is rendered as
    in the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 模板处理后，YAML资源的片段呈现如下：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `.Values` construct used to refer to a chart''s values is a built-in object
    that can be used for parameterization. A full list of built-in objects can be
    found in the Helm docume[ntation (https://helm.sh/docs/chart_template_guide/builtin](https://helm.sh/docs/chart_template_guide/builtin_objects/)_objects/),
    but the most common objects are described in the following table:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用于引用图表值的`.Values`构造是一个内置对象，可用于参数化。Helm文档中可以找到内置对象的完整列表（https://helm.sh/docs/chart_template_guide/builtin_objects/），但最常见的对象在下表中描述：
- en: '![](image/new04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](image/new04.jpg)'
- en: The dot (`.`) prefixed to each object represents the object scope. A dot followed
    by an object name limits the scope to that object. For example, the `.Values`
    scope only makes a chart's values visible; the `.Release` scope only makes fields
    under the `Release` object visible; and the `.` scope represents global scope,
    making all of these objects visible, plus the common objects defined in the preceding
    table.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对象前面的点（`.`）表示对象范围。点后面跟着对象名称将范围限制为该对象。例如，`.Values`范围只能使图表的值可见；`.Release`范围只能使`Release`对象下的字段可见；而`.`范围表示全局范围，使所有这些对象可见，以及在前面的表中定义的常见对象。
- en: The values.schema.json file
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: values.schema.json文件
- en: While on the topic of values and parameterization, let's take a moment to discuss
    the `values.schema.json` file, which is one of the files that may be included
    in a chart's directory. The `values.schema.json` file is used to enforce a particular
    schema in a `values` file. This schema can be used to validate the provided values
    during an installation or an upgrade.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论值和参数化时，让我们花一点时间讨论`values.schema.json`文件，这是图表目录中可能包含的文件之一。`values.schema.json`文件用于在`values`文件中强制执行特定的模式。此模式可用于在安装或升级期间验证提供的值。
- en: 'The following snippet shows what the `values.schema.json` file looks like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段显示了`values.schema.json`文件的外观：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this schema file in place, the `replicas` value should be set to `0` as
    a minimum. Additional values added to this file place additional restrictions
    on the values that can be provided. This file is a good way of ensuring users
    only provide the values that are supported as parameters in the chart's templates.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个模式文件，`replicas`值应该设置为`0`作为最小值。添加到此文件的其他值会对可以提供的值施加额外的限制。这个文件是确保用户只提供图表模板中支持的值的好方法。
- en: While Go templates allow chart developers to parameterize Helm charts, they
    also allow developers to provide conditional logic into a YAML file. We will explore
    this feature next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Go 模板允许图表开发人员对 Helm 图表进行参数化，但它们也允许开发人员在 YAML 文件中提供条件逻辑。我们将在下面探讨这个特性。
- en: Fine-grained template processing with flow control
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用流程控制进行精细化模板处理
- en: 'While parameterization allows chart developers to substitute fields with certain
    values, Go templating also provides developers with the ability to control the
    flow and structure of their templates. This can be accomplished using the following
    keywords (referred to as `actions` in Go):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然参数化允许图表开发人员用特定值替换字段，但 Go 模板还提供了控制模板流程和结构的能力。这可以通过以下关键字（在 Go 中称为`actions`）来实现：
- en: '![](image/04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](image/04.jpg)'
- en: 'There are some occasions during chart templating where it may be necessary
    to include or exclude certain Kubernetes resources or certain parts of a resource.
    The `if…else` actions can be used for this purpose. The following snippet from
    a deployment template includes a conditional block:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表模板化过程中，有时需要包含或排除某些 Kubernetes 资源或某些资源的某些部分。`if…else`操作可以用于此目的。以下来自部署模板的片段包括一个条件块：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `if` block is used to conditionally set the `readinessProbe` stanza. If
    the `probeType.httpGet` value evaluates to `true` or is non-null, the `httpGet`
    `readinessProbe` will be templated. Otherwise, the `readinessProbe` that is created
    will be a `tcpSocket` `readinessProbe` type. The dashes used in the curly braces
    are used to indicate that whitespace should be removed after processing. Dashes
    used after the opening braces remove whitespace before the braces and dashes used
    immediately before the closing braces remove whitespace after the braces.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`块用于有条件地设置`readinessProbe`段。如果`probeType.httpGet`值计算为`true`或非空，则将模板化`httpGet`
    `readinessProbe`。否则，创建的`readinessProbe`将是`tcpSocket` `readinessProbe`类型。大括号中使用的破折号用于指示在处理后应删除空格。在开括号后使用破折号删除括号前的空格，在闭括号前使用破折号删除括号后的空格。'
- en: Chart developers can also use the `with` action to modify the scope of the values.
    This action is useful when a block of values that are referenced are deeply nested.
    It can simplify the readability and maintainability of a template file by reducing
    the amount of characters required to reference a deeply nested value.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图表开发人员还可以使用`with`操作来修改值的范围。当引用的值块深度嵌套时，这个操作非常有用。它可以通过减少引用深度嵌套值所需的字符数量来简化模板文件的可读性和可维护性。
- en: 'The following code describes a `values` file, which includes deeply nested
    values:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了一个`values`文件，其中包含了深度嵌套的值：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Without the `with` action, these values would be referenced in a `template`
    file, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`with`操作，这些值将在`template`文件中被引用，如下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `with` action allows a developer to modify the scope of these values and
    reference them with a shortened syntax:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`操作允许开发人员修改这些值的范围，并使用缩短的语法引用它们：'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, developers can perform repetitive actions using the `range` action.
    This action allows developers to loop over a list of values. Imagine that a chart
    has the following values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开发人员可以使用`range`操作执行重复的操作。这个操作允许开发人员循环遍历一个值列表。假设一个图表有以下值：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code provides a list of `servicePorts`, which can be looped over,
    shown in the following example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码提供了一个`servicePorts`列表，可以循环遍历，如下例所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `with` and `range` actions limit the scope to the object that is provided.
    In the `range` example, the `range` acts on the `.Values.servicePorts` object,
    limiting the scope of the dot (.) symbol to values defined under this object.
    To enact a global scope under `range` where all the values and built-in objects
    are referenced, developers should prefix references with the dollar sign (`$`)
    symbol, as shown:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`和`range`操作限制了提供的对象的范围。在`range`示例中，`range`作用于`.Values.servicePorts`对象，将点（.）符号的范围限制在此对象下定义的值。要在`range`下实施全局范围，其中所有值和内置对象都被引用，开发人员应该使用美元符号（`$`）符号作为前缀引用，如下所示：'
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to a chart's values, developers can also create variables to help
    render resources. We will explore this in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 除了图表的值，开发人员还可以创建变量来帮助渲染资源。我们将在下一节中探讨这一点。
- en: Template variables
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板变量
- en: Although they are not as commonly used as other templating features, chart developers
    can create variables in their chart templates to provide additional processing
    options. A common use for this approach is flow control, but template variables
    can serve other use cases as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们不像其他模板特性那样常用，但图表开发人员可以在他们的图表模板中创建变量，以提供额外的处理选项。这种方法的常见用途是流程控制，但模板变量也可以用于其他用例。
- en: 'A variable in a chart template is defined as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图表模板中的变量定义如下：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This sets the `myvar` variable to the `Hello World!` string. Variables can
    be assigned to objects as well, such as a chart''s values:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将`myvar`变量设置为`Hello World!`字符串。变量也可以分配给对象，比如图表的值：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A variable that is set is then referenced later in the template in the following
    way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在模板中以以下方式引用设置的变量：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'One of the best cases for using variables is in a range block, where variables
    are set to capture the index and value of list iterations:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量的最佳情况之一是在范围块中，其中变量被设置为捕获列表迭代的索引和值：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The result can be rendered as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以如下呈现：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Variables can also simplify the processing of map iterations, as shown:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 变量还可以简化地图迭代的处理，如下所示：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'A possible result may be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的结果可能如下所示：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, variables can be used to refer to a value outside of the current scope.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，变量可以用来引用当前范围之外的值。
- en: 'Consider the following `with` block:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下`with`块：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'A template such as this one would fail to process since `.Release.Name` is
    not under the scope of `.Values.application.configuration`. One way this can be
    remedied is by setting a variable to `.Release.Name` above the `with` block:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模板将无法处理，因为`.Release.Name`不在`.Values.application.configuration`的范围内。可以通过在`with`块上方设置一个变量为`.Release.Name`来解决这个问题：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While this is a possible solution to this problem, the approach of using a dollar
    sign to refer to the global scope is preferred as it requires less lines to configure
    and is easier to read as chart complexity increases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是解决这个问题的一种可能的方法，但使用美元符号来引用全局范围的方法更受欢迎，因为它需要更少的配置行，并且在图表复杂性增加时更容易阅读。
- en: Flow control and variables are powerful concepts that allow resources to be
    dynamically generated. In addition to flow control, chart developers can also
    leverage functions and pipelines to assist in resource rendering and formatting.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 流程控制和变量是强大的概念，可以动态生成资源。除了流程控制，图表开发人员还可以利用函数和管道来帮助资源的渲染和格式化。
- en: Complex processing with functions and pipelines
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用函数和管道进行复杂处理
- en: Go provides the concepts of functions and pipelines to enable complex processing
    of data within a template.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了函数和管道的概念，以在模板内对数据进行复杂处理。
- en: A Go template function is similar to other functions you may have encountered
    in other languages and constructs. Functions contain logic designed to consume
    certain inputs and provide an output based on the inputs that were provided.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go模板函数类似于您在其他语言和结构中遇到的其他函数。函数包含旨在消耗某些输入并根据提供的输入提供输出的逻辑。
- en: 'For Go templates, functions are called by using the following syntax:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Go模板，可以使用以下语法调用函数：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: One Go function that is commonly used is the `indent` function. This function
    is used to indent a string of a specified number of characters to ensure strings
    are properly formatted since YAML is a whitespace-sensitive markup language. The
    `indent` function takes the number of spaces to indent as input, as well as the
    string that should be indented.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 常用的一个Go函数是`indent`函数。此函数用于缩进指定数量的字符的字符串，以确保字符串格式正确，因为YAML是一种对空格敏感的标记语言。`indent`函数接受缩进的空格数和应该缩进的字符串作为输入。
- en: 'The following template illustrates this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模板说明了这一点：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This example indents the string contained in the `config` value by `4` spaces
    to ensure the string is properly indented under the `application-config` YAML
    key.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子通过`4`个空格缩进`config`值中包含的字符串，以确保该字符串在`application-config` YAML键下正确缩进。
- en: 'The other construct Helm provides is pipelines. A pipeline is a concept borrowed
    from **UNIX** where the output of one command is fed as input to a different command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供的另一个结构是管道。管道是从UNIX借鉴的概念，其中一个命令的输出被作为输入传递给另一个命令：
- en: '[PRE35]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding example displays a UNIX pipeline. On the left side of the pipe
    (`|`) is the first command and on the right side is the second command. The first
    command, `cat file.txt`, prints the contents of a file named `file.txt` and passes
    it as input to the `grep helm` command, which filters the first command's output
    for the word `helm`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示了UNIX管道。管道的左侧（`|`）是第一个命令，右侧是第二个命令。第一个命令`cat file.txt`打印名为`file.txt`的文件的内容，并将其作为输入传递给`grep
    helm`命令，该命令过滤第一个命令的输出以获取单词`helm`。
- en: 'Go pipelines work in a similar way. This can again be demonstrated with the
    `indent` function:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Go管道的工作方式类似。这可以再次通过`indent`函数来演示：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will also indent the `config` value by 4 spaces. Pipelines are best used
    to chain multiple commands together. A third command can be added to the pipeline,
    called `quote`, which quotation quote marks around the final templated product:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将`config`值缩进4个空格。管道最适合用于将多个命令链接在一起。第三个命令可以添加到管道中，称为`quote`，它在最终模板化产品周围添加引号引号：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Because this is written as a pipeline, it is easy and natural to read.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是以管道形式编写的，所以阅读起来很容易和自然。
- en: 'There are many different Go template functions that can be used in a Helm chart.
    These functions can be found in the Go documentation at https://golang.org/pkg/text/template/#hdr-Functions
    and in the Sprig template l[ibrary at http://masterminds.github](http://masterminds.github.io/sprig/).io/sprig/.
    Some common Go template functions that you may use during chart development are
    as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表中可以使用许多不同的Go模板函数。这些函数可以在Go文档https://golang.org/pkg/text/template/#hdr-Functions和Sprig模板库http://masterminds.github.io/sprig/中找到。您在图表开发过程中可能使用的一些常见Go模板函数如下：
- en: '`date`: To format a date'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`date`：格式化日期'
- en: '`default`: Set a default value'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：设置默认值'
- en: '`fail`: To fail template rendering'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fail`：失败的模板渲染'
- en: '`include`: To execute a Go template and return the results'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`include`：执行Go模板并返回结果'
- en: '`nindent`: Similar to indent, except prepends a new line before indenting'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nindent`：类似于indent，但在缩进之前添加一个新行'
- en: '`indent`: To indent text by a set number of spaces'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indent`：通过一定数量的空格缩进文本'
- en: '`now`: To display the current date/time'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`now`：显示当前日期/时间'
- en: '`quote`: To wrap a string in quotation marks'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quote`：将字符串用引号括起来'
- en: '`required`: To require user input'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required`：要求用户输入'
- en: '`splitList`: To split a string into a list of strings'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`splitList`：将字符串拆分为字符串列表'
- en: '`toYaml`: To convert a string into YAML format'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toYaml`：将字符串转换为YAML格式'
- en: 'The Go template language also consists of the following Boolean operators that
    can be used in `if` actions to further control the generation of YAML resources:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Go模板语言还包括以下布尔运算符，可以在`if`操作中使用，以进一步控制生成YAML资源：
- en: '`and`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`or`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`not`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`not`'
- en: '`eq` (short for equal)'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`eq`（等于的缩写）'
- en: '`ne` (short for not equal)'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ne`（不等于的缩写）'
- en: '`lt` (short for less than)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lt`（小于的缩写）'
- en: '`le` (short for less than or equal to)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`le`（小于或等于的缩写）'
- en: '`gt` (short for greater than)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gt`（大于的缩写）'
- en: '`ge` (short for greater than or equal to)'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ge`（大于或等于的缩写）'
- en: In addition to generating Kubernetes resources, Go templates can also be used
    to create functions that can be reused in YAML resources that have repetitive
    templating. This can be accomplished by creating named templates, described in
    the next section.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成Kubernetes资源外，Go模板还可以用于创建可以在具有重复模板的YAML资源中重用的函数。这可以通过创建命名模板来实现，下一节将对其进行描述。
- en: Enabling code reuse with named templates
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用命名模板实现代码重用
- en: When creating template files, there may be boilerplate or repetitive blocks
    of YAML in a Kubernetes resource.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建模板文件时，可能会有Kubernetes资源中的样板或重复的YAML块。
- en: 'One example of this is the labels of a resource, which can be specified as
    follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是资源的标签，可以指定如下：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For consistency, each of these labels can be added to each resource in a Helm
    chart. If the chart contains many different Kubernetes resources, it can be cumbersome
    to include the desired labels in each file, especially if a label needs to be
    modified or if a new label needs to be added to each resource in the future.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持一致，这些标签中的每一个都可以添加到Helm图表中的每个资源中。如果图表包含许多不同的Kubernetes资源，那么在每个文件中包含所需的标签可能会很麻烦，特别是如果需要修改标签或者将来需要向每个资源中添加新标签。
- en: Helm provides a construct called named templates that allows chart developers
    to create reusable templates that can be applied to reduce boilerplate. Named
    templates are defined under the `templates/` directory and are files that begin
    with underscores and end with the `.tpl` file extension. Many charts are created
    with a file called `_helpers.tpl` that contains the named templates, although
    the file does not need to be called `helpers`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供了一种称为命名模板的构造，允许图表开发人员创建可重用的模板，以减少样板文件。命名模板定义在`templates/`目录下，是以下划线开头并以`.tpl`文件扩展名结尾的文件。许多图表都使用名为`_helpers.tpl`的文件来包含命名模板，尽管文件不一定要被称为`helpers`。
- en: 'To create a named template in the `tpl` file, developers can leverage the `define`
    action. The following example creates a named template that can be used to encapsulate
    resource labels:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`tpl`文件中创建一个命名模板，开发人员可以利用`define`操作。以下示例创建了一个命名模板，可用于封装资源标签：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `define` action takes a template name as an argument. In the preceding example,
    the template name is called `mychart.labels`. The common convention for naming
    a template is `$CHART_NAME.$TEMPLATE_NAME`, where `$CHART_NAME` is the name of
    the Helm chart and `$TEMPLATE_NAME` is a short, descriptive name that describes
    the purpose of the template.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`define`操作以模板名称作为参数。在前面的示例中，模板名称称为`mychart.labels`。命名模板的常见约定是`$CHART_NAME.$TEMPLATE_NAME`，其中`$CHART_NAME`是Helm图表的名称，`$TEMPLATE_NAME`是一个简短的描述性名称，描述模板的目的。'
- en: The `mychart.labels` name implies that the template is native to the `mychart`
    Helm chart and will generate labels to resources that it is applied to.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`mychart.labels`名称意味着该模板是本地的`mychart` Helm图表，并将为应用到的资源生成标签。'
- en: 'To use a named template in a Kubernetes YAML template, you can use the `include`
    function, which has the following usage:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Kubernetes YAML模板中使用命名模板，可以使用`include`函数，其用法如下：
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `TEMPLATE_NAME` parameter is the name of the named template that should
    be processed. The `SCOPE` parameter is the scope of values and built-in objects
    that should be processed. Most of the time, this parameter is a dot (`.`) to denote
    the current top-level scope, but the dollar sign ( `$` ) symbol should be used
    if the named template references values outside of the current scope.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`TEMPLATE_NAME`参数是应该处理的命名模板的名称。`SCOPE`参数是应该处理的值和内置对象的范围。大多数情况下，这个参数是一个点（`.`）来表示当前顶层范围，但如果命名模板引用当前范围之外的值，则应该使用美元符号（`$`）。'
- en: 'The following example demonstrates how the `include` function is used to process
    a named template:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了如何使用`include`函数来处理命名模板：
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This example begins by setting the name of the resource to the name of the
    release. It then uses the `include` function to process the labels and indents
    each line by two spaces, as declared by the pipeline. When processing is finished,
    a resource within a release called `template-demonstration` may appear as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子首先将资源的名称设置为发布的名称。然后使用`include`函数来处理标签，并且通过管道声明每行缩进两个空格。处理完成后，发布中的资源`template-demonstration`可能如下所示：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Helm also provides a `template` action that can also expand named templates.
    This action has the same usage as `include`, but with one major limitation—it
    cannot be used in a pipeline to provide additional formatting and processing.
    The `template` action is used to simply display data inline. Because of this limitation,
    chart developers should use the `include` function over the `template` action
    since `include` has feature parity with `template` but also provides the additional
    benefit of pipeline processing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Helm还提供了一个`template`操作，可以扩展命名模板。这个操作与`include`具有相同的用法，但有一个主要限制——它不能在管道中用于提供额外的格式化和处理。`template`操作用于简单地内联显示数据。由于这个限制，图表开发者应该使用`include`函数而不是`template`操作，因为`include`具有与`template`相同的功能，但还提供了管道处理的额外好处。
- en: In the next section, we will learn how named templates can be used to reduce
    boilerplate across multiple different charts.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习如何使用命名模板来减少跨多个不同图表的样板文件。
- en: Library charts
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图书馆图表
- en: Helm charts have a `type` field defined in the `Chart.yaml` file that is set
    to either `application` or `library`. Application charts are used to deploy full
    applications to Kubernetes. This is the most common type of chart and is the default
    setting. However, charts can also be defined as library charts. This type of chart
    is not used to deploy applications but instead to provide named templates that
    may be used across multiple different charts. An example of this use case is the
    `labels` example defined in the previous section. Developers can maintain multiple
    different charts whose resources have the same labels. Rather than defining the
    same named templates in each chart's `_helpers.tpl` file, developers can declare
    a library chart that provides the named template for generating resource labels
    as a dependency.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表在`Chart.yaml`文件中定义了一个`type`字段，可以设置为`application`或`library`。应用程序图表用于将完整的应用程序部署到Kubernetes。这是最常见的图表类型，也是默认设置。但是，图表也可以定义为库图表。这种类型的图表不用于部署应用程序，而是用于提供可以在多个不同图表中使用的命名模板。在前一节中定义的`labels`示例中就是这种用例的一个例子。开发人员可以维护多个不同的图表，这些图表的资源具有相同的标签。开发人员可以声明一个库图表，该图表提供用于生成资源标签的命名模板作为依赖项，而不是在每个图表的`_helpers.tpl`文件中定义相同的命名模板。
- en: While Helm is most commonly used to create traditional Kubernetes resources,
    it can also create **Custom Resources** (**CRs**), which we will explain in the
    next section.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Helm最常用于创建传统的Kubernetes资源，但它也可以创建**Custom Resources**（**CRs**），我们将在下一节中解释。
- en: Templating CRs
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板CRs
- en: '**CRs** are used to create resources that are not native to the Kubernetes
    API. You may want to use this functionality to augment the abilities that Kubernetes
    provides. CRs can be created using Helm templates such as native Kubernetes resources,
    but there must first be a **Custom Resource Definition (CRD)** that defines the
    CR. If the CRD is not present before the CR is created, the installation will
    fail.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**CRs**用于创建不属于Kubernetes API的资源。您可能希望使用此功能来增强Kubernetes提供的功能。CRs可以使用Helm模板创建，例如本机Kubernetes资源，但必须首先有一个定义CR的**Custom
    Resource Definition (CRD)**。如果在创建CR之前不存在CRD，则安装将失败。'
- en: 'Helm charts can include a `crds/` folder, which consists of the CRDs that must
    be presented before templates are installed. An example `crds/` folder is shown
    here:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表可以包括一个`crds/`文件夹，其中包含必须在安装模板之前呈现的CRDs。这里显示了一个示例`crds/`文件夹：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The file `my-custom-resource-crd.yaml` may have the following contents:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 文件`my-custom-resource-crd.yaml`可能包含以下内容：
- en: '[PRE44]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The templates/ directory can then contain an instance of the MyCustomResource
    resource.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 模板/目录然后可以包含MyCustomResource资源的一个实例。
- en: '[PRE45]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A file structure such as this will ensure that the `MyCustomResource` CRD is
    installed before the CR defined under the `templates/` directory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的文件结构将确保在`templates/`目录下定义的CR之前安装`MyCustomResource` CRD。
- en: 'Important note:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明：
- en: This capability requires the user to be a cluster administrator as creating
    CRDs requires escalated privileges. If you are not a cluster administrator, it
    may be better to ask an admin to create your CRDs beforehand. If you do so, the
    `crds/` folder would not need to be included in your chart because the CRDs would
    already be present in the cluster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能要求用户是集群管理员，因为创建CRDs需要提升的权限。如果您不是集群管理员，最好请管理员事先创建您的CRDs。如果这样做，`crds/`文件夹就不需要包含在您的图表中，因为CRDs已经存在于集群中。
- en: By now, we have covered Helm templates in a large amount of detail. To summarize,
    Helm templates are the 'brains' of your Helm chart and are used to generate Kubernetes
    resources. We will get hands-on experience with writing Helm templates, along
    with other topics discussed in this chapter, in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经详细介绍了Helm模板。总之，Helm模板是您的Helm图表的“大脑”，用于生成Kubernetes资源。我们将亲自体验编写Helm模板，以及本章讨论的其他主题，在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中，*构建您的第一个Helm图表*。
- en: For now, let's continue our discussion on Helm chart fundamentals with a topic
    of equal importance to chart templates—the `Chart.yaml` file.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论Helm图表基础知识，与图表模板同等重要的一个主题是`Chart.yaml`文件。
- en: Understanding chart definitions
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解图表定义
- en: 'The `Chart.yaml` file, also known as the chart definition, is a resource that
    declares different metadata about a Helm chart. This file is required and if it
    is not included in a chart''s file structure, you''ll receive the following error:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart.yaml`文件，也称为图表定义，是声明有关Helm图表的不同元数据的资源。此文件是必需的，如果它没有包含在图表的文件结构中，您将收到以下错误：'
- en: '[PRE46]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147), *Installing
    Your First Helm Chart*, we explored the chart definition of **Bitnami''s WordPress
    chart** by running the `helm show chart` command. Recall this chart definition
    by running this command again. We will assume that the Bitnami chart repository
    has already been added since this task was performed in [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147),
    *Installing Your First Helm Chart*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147)，*安装您的第一个Helm图表*中，我们通过运行`helm
    show chart`命令来探索**Bitnami的WordPress图表**的图表定义。再次运行此命令来回忆这个图表定义。我们将假设Bitnami图表存储库已经被添加，因为这个任务是在[*第3章*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147)，*安装您的第一个Helm图表*中执行的：
- en: '[PRE47]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Below lists the chart definition of the wordpress chart.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出了wordpress图表的图表定义。
- en: '![Figure 4.1 – The output of the Bitnami chart repository'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.1 - Bitnami图表存储库的输出'
- en: '](image/Figure_4.1.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.1.jpg)'
- en: Figure 4.1 – The chart definition of the wordpress chart.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 - wordpress图表的图表定义。
- en: The chart definition, or the `Chart.yaml` file, can contain many different fields.
    Some of the fields are required while most of the other fields are optional and
    can be provided only if necessary.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图表定义，或`Chart.yaml`文件，可以包含许多不同的字段。一些字段是必需的，而大多数其他字段是可选的，只有在必要时才能提供。
- en: Now that we have a basic understanding of the `Chart.yaml` file, we will explore
    the file's required fields in the next section.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`Chart.yaml`文件有了基本的了解，接下来我们将在下一节中探讨文件的必填字段。
- en: Required fields
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必填字段
- en: 'A chart definition must contain the following fields that contain crucial chart
    metadata:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图表定义必须包含包含关键图表元数据的以下字段：
- en: '![](image/05.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![](image/05.jpg)'
- en: 'Let''s explore each of these required fields in more detail:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地探讨这些必填字段：
- en: 'The `apiVersion` field can be set to one of two different values:'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`apiVersion`字段可以设置为两个不同的值：'
- en: '`v1`'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`v1`'
- en: '`v2`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`v2`'
- en: If the `apiVersion` field is set to `v1`, this means that the chart follows
    a legacy chart structure. This is the `apiVersion` value that was used before
    the release of Helm 3, where an additional `requirement.yaml` file was supported
    in the chart structure and the `type` field in the chart definition was not supported.
    Helm 3 is backward-compatible with the `apiVersion` value `v1`, but new charts
    should be set to the `apiVersion` value `v2` to avoid deprecated features being
    used.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`apiVersion`字段设置为`v1`，这意味着该图表遵循传统的图表结构。这是在Helm 3发布之前使用的`apiVersion`值，在图表结构中支持了额外的`requirement.yaml`文件，并且在图表定义中不支持`type`字段。Helm
    3向后兼容`apiVersion`值`v1`，但新图表应该设置为`apiVersion`值`v2`，以避免使用废弃的功能。
- en: The `name` field is used to define the name of the Helm chart. This value should
    be equal to the name of the top-level directory containing the Helm chart's files.
    The name of the Helm chart appears in the search results from the `helm search`
    command, as well as the `helm list` command, to return the name of the chart used
    for a release. The value of this field should be concise yet descriptive, describing
    the application installed by the chart in a short name such as `wordpress` or
    `redis-cluster`. Kebab case, or separating words with dashes, is the common convention
    when distinguishing different words in a name. Sometimes, names will be written
    as one word, such as `rediscluster`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`字段用于定义Helm图表的名称。该值应等于包含Helm图表文件的顶级目录的名称。Helm图表的名称将出现在`helm search`命令的搜索结果中，以及`helm
    list`命令，以返回用于发布的图表的名称。该字段的值应该简洁而具有描述性，用一个简短的名称描述图表安装的应用程序，如`wordpress`或`redis-cluster`。在名称中区分不同单词时，使用短横线分隔单词是常见的约定。有时，名称将被写成一个单词，比如`rediscluster`。'
- en: The `version` field is used to determine the version of the Helm chart. Versions
    must follow the **Semantic Versioning** (**SemVer**) `2.0.0` format to be a valid
    chart version. SemVer describes a version based on a `Major.Minor.Patch` format,
    where the `Major` version should increase when a breaking change is introduced,
    the `Minor` version should increase when a backward-compatible feature is released,
    and the `Patch` version should increase when a bug is fixed. When the `Minor`
    version is increased, the `Patch` version is set back to `0`. When the `Major`
    version is increased, both the `Minor` and `Patch` versions are reset to `0`.
    Chart developers should take special care when incrementing chart versions as
    they are used to indicate when breaking changes, new features, and bug fixes are
    released.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version` 字段用于确定 Helm chart 的版本。版本必须遵循**语义化版本**（**SemVer**）`2.0.0` 格式才能成为有效的图表版本。SemVer
    根据 `Major.Minor.Patch` 格式描述版本，其中当引入破坏性更改时，`Major` 版本应增加，当发布向后兼容的功能时，`Minor` 版本应增加，当修复错误时，`Patch`
    版本应增加。当增加 `Minor` 版本时，`Patch` 版本设置为 `0`。当增加 `Major` 版本时，`Minor` 和 `Patch` 版本都重置为
    `0`。图表开发人员在增加图表版本时应特别小心，因为它们用于指示何时发布破坏性更改、新功能和错误修复。'
- en: While these three fields are the only fields required in the `Chart.yaml` file,
    there are many more optional fields that can be included to add additional metadata
    to the chart.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这三个字段是 `Chart.yaml` 文件中唯一需要的字段，但还有许多可选字段可以包含在其中，以向图表添加附加元数据。
- en: Let's take a look at the other possible `Chart.yaml` fields.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看其他可能的 `Chart.yaml` 字段。
- en: Optional metadata
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可选元数据
- en: 'In addition to the required fields, there are many optional fields that can
    be used to provide additional details about a chart, described in the following
    table:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 除了必填字段外，还有许多可选字段可用于提供有关图表的其他详细信息，如下表所述：
- en: '![](image/013.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](image/013.jpg)'
- en: Some of these fields provide simple metadata to display information to a user
    about the Helm chart. Other fields, however, are used to modify the behavior of
    the Helm chart. The first of these fields is the `type` field, which can be set
    to either `application` or `library`. If set to `application`, the chart deploys
    Kubernetes resources. If set to `library`, the chart provides functions to other
    charts through the form of helper templates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些字段提供简单的元数据，以向用户显示有关 Helm chart 的信息。然而，其他字段用于修改 Helm chart 的行为。其中第一个字段是 `type`
    字段，可以设置为 `application` 或 `library`。如果设置为 `application`，则图表部署 Kubernetes 资源。如果设置为
    `library`，则图表通过助手模板的形式为其他图表提供函数。
- en: The second field that can modify the behavior of the Helm chart is the `dependencies`
    field, which is discussed in the next section.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 可以修改 Helm chart 行为的第二个字段是 `dependencies` 字段，将在下一节中讨论。
- en: Managing chart dependencies
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理图表依赖项
- en: Chart dependencies are used to install other charts' resources that a Helm chart
    may depend on. An example of this is the `wordpress` chart, which declared the
    `mariaDB` chart as a dependency to save backend data. By using the `mariadb` dependency,
    the WordPress chart did not need to define its resources from scratch.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图表依赖项用于安装 Helm chart 可能依赖的其他图表资源。一个例子是 `wordpress` 图表，它将 `mariaDB` 图表声明为依赖项以保存后端数据。通过使用
    `mariadb` 依赖项，WordPress 图表无需从头开始定义其资源。
- en: 'Dependencies are declared in the `Chart.yaml` file by populating the `dependencies`
    field. The following is the relevant snippet from the `wordpress` chart''s definition:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填充 `dependencies` 字段在 `Chart.yaml` 文件中声明依赖项。以下是 `wordpress` 图表定义中的相关片段：
- en: '![Figure 4.2 – A snippet of the wordpress chart’s definition'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.2 – wordpress 图表定义的片段'
- en: '](image/Figure_4.2.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.2.jpg)'
- en: Figure 4.2 – The mariadb dependency declared in the wordpress Helm chart.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 - 在wordpress Helm图表中声明的mariadb依赖项。
- en: While this example displays a single dependency, `mariadb`, the dependencies
    block can define a list of multiple dependencies.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然此示例显示了单个依赖项`mariadb`，但`dependencies`块可以定义多个依赖项的列表。
- en: 'A `dependencies` block contains many different fields that can be applied to
    modify the behavior of a chart''s dependency management. These fields are defined
    in the following table:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`块包含许多不同的字段，可以应用于修改图表依赖项管理的行为。这些字段在下表中定义：'
- en: '![](image/022.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](image/022.jpg)'
- en: The minimum required fields under the `dependencies` blocks are the `name`,
    `repository`, and `version` fields. As shown in the preceding `wordpress` dependency
    snippet, the name of the dependency is mariadb and the repository can be found
    at [https://kubernetes-charts.storage.googleapis.com](https://kubernetes-charts.storage.googleapis.com/)/.
    This searches the provided repository for a Helm chart whose `name` field in the
    `Chart.yaml` file is `mariadb`. The `version` field of a `dependencies` block
    specifies the version of the chart that should be included. This can be pinned
    to a specific version, such as `7.0.0`, or it can specify a wildcard version.
    The dependency listed in the preceding example provides a wildcard version, `7.x.x`,
    which instructs Helm to download the latest version of the chart that matches
    the wildcard.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`dependencies`块下的最小必需字段是`name`、`repository`和`version`字段。如前面的`wordpress`依赖片段所示，依赖的名称是mariadb，存储库可以在[https://kubernetes-charts.storage.googleapis.com](https://kubernetes-charts.storage.googleapis.com/)找到。这将在提供的存储库中搜索一个Helm图表，其`Chart.yaml`文件中的`name`字段为`mariadb`。`dependencies`块的`version`字段指定应包含的图表版本。这可以固定到特定版本，如`7.0.0`，也可以指定通配符版本。前面示例中列出的依赖项提供了一个通配符版本`7.x.x`，它指示Helm下载与通配符匹配的图表的最新版本。'
- en: Now, with an understanding of the required dependencies fields, let's learn
    how the declared dependencies can be downloaded.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，了解了所需的依赖项字段，让我们学习如何下载声明的依赖项。
- en: Downloading dependencies
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载依赖项
- en: 'Dependencies can be downloaded using the `helm dependency` subcommand listed
    in the following table:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用下表中列出的`helm dependency`子命令下载依赖项：
- en: '![](image/03.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](image/03.jpg)'
- en: 'To download dependencies for the first time, you can run the `helm dependency
    update` command, which downloads each dependency into the `charts/` directory
    of the given Helm chart:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 要首次下载依赖项，可以运行`helm dependency update`命令，将每个依赖项下载到给定Helm图表的`charts/`目录中：
- en: '[PRE48]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `helm dependency update` command downloads dependencies from repositories
    in the form of `GZip` archives with the .`tgz` file extension. This command also
    generates a file called `Chart.lock`. The `Chart.lock` file is similar to the
    `Chart.yaml` file. However, while the `Chart.yaml` file contains the desired state
    of the chart dependencies, the `Chart.lock` file defines the actual state of the
    dependencies that were applied.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm dependency update`命令从存储库中下载以`.tgz`文件扩展名的`GZip`存档形式的依赖项。此命令还生成一个名为`Chart.lock`的文件。`Chart.lock`文件类似于`Chart.yaml`文件。但是，`Chart.yaml`文件包含图表依赖项的期望状态，而`Chart.lock`文件定义了应用的依赖项的实际状态。'
- en: 'An example of a `Chart.lock` file can be seen here:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这里看到一个`Chart.lock`文件的示例：
- en: '![Figure 4.3 – A Chart.lock file'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.3 - 一个Chart.lock文件'
- en: '](image/Figure_4.3.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.3.jpg)'
- en: Figure 4.3 – A `Chart.lock` file
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 - 一个`Chart.lock`文件
- en: 'Compare this to a simple corresponding `Chart.yaml` file:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 将其与一个简单的相应的`Chart.yaml`文件进行比较：
- en: '![Figure 4.4 – A corresponding Chart.yaml file'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.4 - 相应的Chart.yaml文件'
- en: '](image/Figure_4.4.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.4.jpg)'
- en: Figure 4.4 – A corresponding `Chart.yaml` file
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 - 相应的`Chart.yaml`文件
- en: In the `Chart.yaml` file, you can see that the version of the specified `mariadb`
    dependency was version `7.x.x`, but the version in the `Chart.lock` file is version
    `7.3.1`. This is because the `Chart.yaml` file instructed Helm to download the
    latest version of the `7.x.x` release, and the actual version that was downloaded
    was version `7.3.1`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chart.yaml`文件中，您可以看到指定的`mariadb`依赖项的版本是`7.x.x`，但是`Chart.lock`文件中的版本是`7.3.1`。这是因为`Chart.yaml`文件指示Helm下载`7.x.x`版本的最新版本，实际下载的版本是`7.3.1`。
- en: 'With the `Chart.lock` file in place, Helm is able to redownload the exact dependencies
    that were originally downloaded in the event that the `charts/` directory is removed
    or needs to be rebuilt. This can be done by running the `helm dependency build`
    command against a chart:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`Chart.lock`文件，Helm能够重新下载最初下载的确切依赖项，以防`charts/`目录被删除或需要重建。这可以通过针对图表运行`helm
    dependency build`命令来实现：
- en: '[PRE49]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Because you can download dependencies using the `helm dependency build` command,
    it is possible to omit the `charts/` directory from source control to reduce the
    size of repositories.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你可以使用`helm dependency build`命令下载依赖项，所以可以省略`charts/`目录，以减少存储库的大小。
- en: Over time, newer versions under the `7.x.x` release will be available. The `helm
    dependency update` command can be run again to reconcile this dependency, meaning
    the latest available version will be downloaded and the `Chart.lock` file will
    regenerate. If in the future you want to download from the `8.x.x` release or
    would like to pin the dependency to a specific release, such as `7.0.0`, you can
    set this in the `Chart.yaml` file and run `helm dependency update`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，`7.x.x`版本的新版本将可用。可以再次运行`helm dependency update`命令来协调此依赖项，这意味着将下载最新可用版本，并且`Chart.lock`文件将重新生成。如果将来想要从`8.x.x`版本下载或者想要将依赖项固定到特定版本，比如`7.0.0`，可以在`Chart.yaml`文件中设置并运行`helm
    dependency update`。
- en: 'The `helm dependency list` command can be used to view the downloaded dependencies
    of a Helm chart saved to your local machine:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm dependency list`命令可用于查看保存在本地计算机上的Helm图表的已下载依赖项：'
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You''ll see an output similar to the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到类似以下的输出：
- en: '![Figure 4.5 – The output of a CHART_NAME command'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '![图4.5 - CHART_NAME命令的输出'
- en: '](image/Figure_4.5.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_4.5.jpg)'
- en: Figure 4.5 – "helm dependency list" output
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5 - "helm dependency list"输出
- en: The `STATUS` column determines whether the dependency has been successfully
    downloaded to the `charts/` directory. It has been downloaded if the status reads
    `ok`. If the status reads as `missing`, the dependency has not been downloaded
    yet.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`STATUS`列确定了依赖项是否已成功下载到`charts/`目录。如果状态显示为`ok`，则已下载依赖项。如果状态显示为`missing`，则尚未下载依赖项。'
- en: By default, every declared dependency in the `Chart.yaml` file will be downloaded,
    but this can be modified by providing the `condition` or `tags` fields of the
    `dependencies` block, which we will discuss in the next section.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Chart.yaml`文件中声明的每个依赖项都将被下载，但可以通过提供`dependencies`块的`condition`或`tags`字段来修改，我们将在下一节讨论。
- en: Conditional dependencies
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件依赖
- en: 'The `condition` and `flags` fields can be leveraged to conditionally include
    dependencies during an installation or upgrade. Consider an example `dependencies`
    block in the `Chart.yaml` file:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`和`flags`字段可以在安装或升级过程中有条件地包含依赖项。考虑`Chart.yaml`文件中的一个示例`dependencies`块：'
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice the inclusion of the `condition` and `tags` fields. The `condition`
    field lists a value that should be provided by the user or set in the chart''s
    `values.yaml` file. If it evaluates to `true`, the `condition` field causes the
    chart to be included as a dependency. If `false`, the dependency will not be included.
    Multiple conditions can be defined by separating each condition with a comma,
    as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`condition`和`tags`字段的包含。`condition`字段列出了用户应提供的值，或者在图表的`values.yaml`文件中设置的值。如果评估为`true`，`condition`字段将导致图表作为依赖项被包括进来。如果为`false`，则不会包括依赖项。可以通过用逗号分隔每个条件来定义多个条件，如下所示：
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The best practice around setting a condition is to follow a `chartname.enabled`
    value format, where each dependency has a unique condition set depending on the
    dependency's chart name. This allows users to enable or disable individual charts
    by following an intuitive value schema. If the condition values are not included
    in the chart's `values.yaml` file or are not provided by the user, this field
    is ignored.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设置条件的最佳实践是遵循`chartname.enabled`值格式，其中每个依赖项根据依赖项的图表名称设置唯一的条件。这允许用户通过遵循直观的值模式来启用或禁用单个图表。如果条件值未包含在图表的`values.yaml`文件中，或者用户未提供该字段，则将忽略此字段。
- en: 'While the `condition` field is used to enable or disable individual dependencies,
    the `tags` field is used to enable or disable groups of dependencies. In the preceding
    `dependencies` block, both dependencies list a tag called `monitoring`. This means
    that if the `monitoring` tag is enabled, both dependencies are included. If the
    `monitoring` tag is set to `false`, the dependency is omitted. Tags are enabled
    or disabled by setting them under a `tags` YAML object in the parent chart''s
    `values.yaml` file, as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`condition`字段用于启用或禁用单个依赖项，`tags`字段用于启用或禁用依赖项组。在前面的`dependencies`块中，两个依赖项都列出了一个名为`monitoring`的标签。这意味着如果启用了`monitoring`标签，两个依赖项都会被包括进来。如果`monitoring`标签设置为`false`，则依赖项将被省略。通过在父图表的`values.yaml`文件中的`tags`
    YAML对象下设置它们来启用或禁用标签，如下所示：'
- en: '[PRE53]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: A dependency can define multiple tags in the `Chart.yaml` file by following
    the YAML syntax for lists. Only one tag needs to be evaluated to `true` for the
    dependency to be included.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项可以通过遵循列表的YAML语法在`Chart.yaml`文件中定义多个标签。只需要一个标签被评估为`true`，依赖项就会被包括进来。
- en: 'Important note:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: If all of a dependency's tags are ignored, the dependency will be included by
    default.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略了依赖项的所有标签，依赖项将默认包括进来。
- en: In this section, we discussed how dependencies can be declared conditionally.
    Next, we will discuss how values from a dependency can be overridden and referenced.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了如何有条件地声明依赖关系。接下来，我们将讨论如何覆盖和引用依赖项的值。
- en: Overriding and referencing values from a child chart
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖和引用子图表的值
- en: 'By default, the values belonging to a dependency chart (also referred to as
    a **child chart**) can be overridden or referenced by wrapping them in a map with
    a name set to the same as the child chart. Imagine a child chart called `my-dep`
    that supports the following values:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，属于依赖图表（也称为**子图表**）的值可以通过将它们包装在名称设置为与子图表相同的映射中来被覆盖或引用。想象一个名为`my-dep`的子图表，支持以下值：
- en: '[PRE54]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When this chart is installed as a dependency, these values can be overridden
    by setting them in a `my-dep` YAML object of the parent chart, as shown:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当此图表作为依赖项安装时，可以通过在父图表的`values.yaml`文件中设置`my-dep` YAML对象来覆盖这些值，如下所示：
- en: '[PRE55]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The preceding example overrides the `replicas` and `servicePorts` values defined
    in `my-dep` to set `3` for `replicas` and add `8778` to `servicePorts`. These
    values can be referenced in the parent chart's templates by following dot notation—for
    example, `my-dep.replicas`. In addition to overriding and referencing values,
    you can directly import dependency values by defining the `import-values` field,
    explained in the next section.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子覆盖了`my-dep`中定义的`replicas`和`servicePorts`的值，将`replicas`设置为`3`，并将`8778`添加到`servicePorts`中。这些值可以通过点表示法在父图的模板中引用，例如`my-dep.replicas`。除了覆盖和引用值之外，您还可以通过定义`import-values`字段直接导入依赖值，下一节将对此进行解释。
- en: Importing values with import-values
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`import-values`导入值
- en: 'The `dependencies` block of the `Chart.yaml` file supports an `import-values`
    field that can be used to import a child chart''s default values. This field works
    in a couple of ways. The first way is to provide a list of keys to import from
    the child chart. In order for this to work, the child chart must have values declared
    under an `exports` block, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`Chart.yaml`文件的`dependencies`块支持一个`import-values`字段，可用于导入子图的默认值。该字段有两种工作方式。第一种方式是提供要从子图导入的键列表。为了使其工作，子图必须在`exports`块下声明值，如下所示：'
- en: '[PRE56]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The parent chart can then define the `import-values` field in the `Chart.yaml`
    file:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然后父图可以在`Chart.yaml`文件中定义`import-values`字段：
- en: '[PRE57]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This allows default values under `exports.image` in the child chart to be referenced
    as follows in the parent chart:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许在父图中如下引用子图中`exports.image`下的默认值：
- en: '[PRE58]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Notice that this has removed the `image` map and left only the key-value pairs
    that were underneath it. If you don''t want this to happen, the `import-values`
    field can retain the `image` map by following what is referred to as the `child-parent`
    format. This allows chart developers to specify the values that should be imported
    from the child chart and provides the name that they should be referred to as
    in the parent chart. The `child-parent` format allows this to be done without
    the need for values in an `exports` block in the child chart. The following `dependencies`
    block demonstrates an example of this:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这已经删除了`image`映射，并且只留下了其下面的键值对。如果您不希望发生这种情况，`import-values`字段可以通过遵循所谓的`child-parent`格式保留`image`映射。这允许图表开发人员指定应从子图导入的值，并提供它们在父图中应被称为的名称。`child-parent`格式允许在不需要子图中的`exports`块中的值的情况下完成此操作。以下`dependencies`块演示了这种情况的示例：
- en: '[PRE59]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This example takes each value under the `image` block in the child chart and
    imports it under an `image` block in the parent chart.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例将子图中`image`块下的每个值导入到父图中的`image`块下。
- en: 'Important note:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The values imported using the `import-values` field cannot be overridden in
    the parent chart. If you need to override values in the child chart, you should
    not use the `import-values` field and should instead override the desired values
    by prefixing each one with the name of the child chart.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`import-values`字段导入的值不能在父图中被覆盖。如果您需要覆盖子图中的值，您不应该使用`import-values`字段，而应该通过在每个值的前缀中加上子图的名称来覆盖所需的值。
- en: In this section, we covered how dependencies can be managed in the `Chart.yaml`
    file. Now, let's learn about how life cycle management hooks can be defined in
    a Helm chart.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了如何在`Chart.yaml`文件中管理依赖关系。现在，让我们了解一下如何在Helm图中定义生命周期管理钩子。
- en: Life cycle management
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期管理
- en: One of the primary benefits of Helm charts and their associated releases is
    the ability to manage complex applications on Kubernetes. A release undergoes
    multiple phases during its life span. To provide additional management capabilities
    around the life cycle of a release, Helm features a `hooks` mechanism so that
    actions can be undertaken at different points in time within a release cycle.
    In this section, we will explore the different phases of a release's life span
    and introduce how `hooks` can be used to provide capabilities for interacting
    not only with the release but also the entire Kubernetes environment.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表及其相关发布的主要优势之一是能够在Kubernetes上管理复杂的应用程序。发布在其生命周期中经历多个阶段。为了提供关于发布生命周期的额外管理能力，Helm提供了一个`hooks`机制，以便可以在发布周期的不同时间点执行操作。在本节中，我们将探讨发布生命周期的不同阶段，并介绍如何使用`hooks`来提供与发布以及整个Kubernetes环境的交互能力。
- en: 'In [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147), *Installing
    Your First Helm Chart*, we encountered several phases that encompass the overall
    life span of a Helm release, including its installation, upgrade, removal, and
    rollback. Given that Helm charts can be complex, as they manage one or more applications
    that will be deployed to Kubernetes, there is often the need to perform additional
    actions besides just deploying resources. These can include the following:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147)中，*安装您的第一个Helm图表*，我们遇到了涵盖Helm发布整个生命周期的几个阶段，包括安装、升级、删除和回滚。鉴于Helm图表可能很复杂，因为它们管理将部署到Kubernetes的一个或多个应用程序，通常需要执行除了部署资源之外的其他操作。这些操作可能包括以下内容：
- en: Completing prerequisites that are needed by the application, such as managing
    certificates and secrets
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成应用程序所需的先决条件，例如管理证书和密钥
- en: Database management as part of a chart upgrade to either perform a backup or
    restoration
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为图表升级的一部分进行数据库管理，以执行备份或恢复
- en: Cleaning up assets before the removal of a chart
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除图表之前清理资产
- en: The list of potential options can be long and it is important to first understand
    the basics of Helm hooks as well as when they can be executed, which we will describe
    in the next section.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 潜在选项列表可能很长，首先了解Helm挂钩的基础知识以及它们何时可以执行是很重要的，我们将在下一节中描述。
- en: The basics of a Helm hook
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm挂钩的基础知识
- en: A hook executes as a one-time action at a designated point in time during the
    life span of a release. A hook, as with the majority of the features within Helm,
    is implemented as yet another Kubernetes resource and, more specifically, within
    a container. While the majority of workloads within Kubernetes are designed to
    long-living processes, such as an application serving API requests, workloads
    can also be made up of a single task or set of tasks executed using a script that
    indicates either success or failure once completed.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 挂钩在发布的生命周期中的指定时间点执行一次操作。与Helm中的大多数功能一样，挂钩被实现为另一个Kubernetes资源，更具体地说是在一个容器中。虽然Kubernetes中的大多数工作负载都设计为长时间运行的进程，比如提供API请求的应用程序，但工作负载也可以由一个单独的任务或一组任务组成，使用脚本执行，一旦完成就指示成功或失败。
- en: Two options that are typically used in a Kubernetes environment to create short-lived
    tasks are to make use of either a bare **pod** or a **job**. A bare pod is a pod
    that runs until completion and then terminates, but will not be rescheduled if
    the underlying node fails. For this reason, it may be preferred to run life cycle
    hooks as jobs, which reschedules the hook if the node fails or becomes unavailable.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes环境中通常用于创建短暂任务的两个选项是使用裸**pod**或**job**。裸pod是一个运行直到完成然后终止的pod，但如果底层节点失败，它将不会被重新调度。因此，可能更倾向于将生命周期钩子作为作业运行，如果节点失败或不可用，则重新调度钩子。
- en: Since hooks are simply defined as Kubernetes resources, they are also placed
    in the `templates/` folder and annotated with the helm.sh/hook annotation. The
    designation of this annotation ensures they are not rendered with the rest of
    the resources that are applied to a Kubernetes environment during standard processing.
    Instead, they are rendered and applied based on the value specified within the
    helm.sh/hook annotation, which determines when it should be executed within Kubernetes
    as part of the Helm release life cycle.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 由于钩子只是被定义为Kubernetes资源，它们也被放置在`templates/`文件夹中，并用helm.sh/hook注释进行标注。这个注释的指定确保它们不会与标准处理过程中应用于Kubernetes环境的其他资源一起渲染。相反，它们根据helm.sh/hook注释中指定的值进行渲染和应用，该值确定了它应该在Helm发布生命周期的Kubernetes中何时执行。
- en: 'Here''s an example of how a hook can be defined as a job:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何将钩子定义为作业的示例：
- en: '[PRE60]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This trivial example prints out the current date and time in the container before
    sleeping for 10 seconds. Helm executes this hook before and after installing the
    chart, as noted by the value of the 'helm.sh/hook' annotation. A use case for
    this type of hook is to tie into an auditing system that tracks the installation
    of applications to a Kubernetes environment. A similar hook can be added after
    the installation completes to track the total time it took to complete the chart
    installation process.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微不足道的例子在休眠10秒之前打印出容器中的当前日期和时间。Helm在安装图表之前和之后执行这个钩子，如'helm.sh/hook'注释的值所示。这种类型的钩子的一个用例是连接到一个审计系统，跟踪应用程序在Kubernetes环境中的安装。类似的钩子可以在安装完成后添加，以跟踪完成图表安装过程所花费的总时间。
- en: Now that we have explained the basics of Helm hooks, let's discuss how hooks
    can be defined in a Helm chart.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解释了Helm钩子的基础知识，让我们讨论如何在Helm图表中定义钩子。
- en: Hook execution
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 钩子执行
- en: As you saw in the `job` hook in the previous section, the value of the `helm.sh/hook`
    annotation was `pre-install`. `pre-install` is one of the points during the life
    span of a Helm chart where a hook can be executed.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前一节的`job`钩子中看到的，`helm.sh/hook`注释的值是`pre-install`。`pre-install`是Helm图表生命周期中可以执行钩子的时间点之一。
- en: 'The following table denotes the available options for the `helm.sh/hook` annotation,
    indicating when the hook is executed. The descriptions for each hook references
    the official Helm documentation, which can be found at https://helm.sh/docs/topics/charts_hooks/#the-available-hooks:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格表示了`helm.sh/hook`注释的可用选项，指示钩子的执行时间。每个钩子的描述都引用了官方Helm文档，可以在https://helm.sh/docs/topics/charts_hooks/#the-available-hooks找到。
- en: '![](image/041.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](image/041.jpg)'
- en: 'The `helm.sh/hook` annotation can contain multiple values indicating that the
    same resource is executed at different points in time within a chart''s release
    cycle. For example, for a hook to be executed before and after a chart installation,
    the following annotation can be defined on either the pod or job:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm.sh/hook`注释可以包含多个值，表示在图表发布周期内的不同时间点执行相同的资源。例如，为了在图表安装之前和之后执行钩子，可以在pod或作业上定义以下注释：'
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It is useful to understand how and when hooks are executed in order to determine
    the desired phase in a charts'' life cycle that needs to be selected. As described
    in the previous example, when a hook is denoted to run in the `pre-install` and
    `post-install` portions of an execution of the `helm install` command, the following
    actions take place:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 了解钩子何时以及如何执行是有用的，以确定需要选择的图表生命周期中的期望阶段。如前面的示例所述，当钩子被指定在执行“helm install”命令的“pre-install”和“post-install”部分时，将发生以下操作：
- en: The user installs a Helm chart (by running, for example, `helm install bitnami/wordpress
    --version 8.1.0`).
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户安装Helm图表（例如通过运行“helm install bitnami/wordpress --version 8.1.0”）。
- en: The Helm API is invoked.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用Helm API。
- en: CRDs in the `crds/` folder are loaded to the Kubernetes environment.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes环境中加载“crds/”文件夹中的CRD。
- en: Verification of the chart templates is performed and the resources are rendered.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行图表模板的验证并呈现资源。
- en: The `pre-install` hooks are ordered by weight, then are rendered and loaded
    to Kubernetes.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 预安装钩子按权重排序，然后呈现并加载到Kubernetes中。
- en: Helm waits until the hooks are ready.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm等待直到钩子准备就绪。
- en: Template resources are rendered and applied to the Kubernetes environment.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板资源被呈现并应用于Kubernetes环境。
- en: The `post-install` hooks are executed.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行“post-install”钩子。
- en: Helm waits until the `post-install` hooks are complete.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Helm等待直到“post-install”钩子完成。
- en: The results of the `helm install` command are returned.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回“helm install”命令的结果。
- en: With an understanding of the basics of Helm hook execution, let's cover some
    of the more advanced topics around Helm hooks.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 了解Helm钩子执行的基础知识后，让我们来讨论一些关于Helm钩子的更高级主题。
- en: Advanced hook concepts
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级钩子概念
- en: While minimal effort is needed to transform a standard Helm template resource
    into a hook, there are additional options that aid in chart execution and resource
    removal.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将标准Helm模板资源转换为钩子所需的工作量很小，但还有其他选项可帮助执行图表和删除资源。
- en: There is no limit to the number of hooks that can be executed during the life
    span of a Helm chart and there may be cases where multiple hooks are configured
    for the same life cycle phase. When this scenario arises, hooks, by default, are
    ordered alphabetically by name. However, you can define the order by specifying
    the weight of each hook using the `helm.sh/weight` annotation. Weights are sorted
    in ascending order, but if multiple hooks contain the same weight value, the default
    logic of sorting alphabetically by name is used.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在Helm图表的生命周期中执行的钩子数量没有限制，可能存在多个钩子为同一生命周期阶段配置的情况。当出现这种情况时，默认情况下，钩子按名称按字母顺序排序。但是，您可以通过使用“helm.sh/weight”注释指定每个钩子的权重来定义顺序。权重按升序排序，但如果多个钩子包含相同的权重值，则使用默认逻辑按名称按字母顺序排序。
- en: While hooks present a useful mechanism for life cycle management, you should
    keep in mind that hooks, unlike regular template resources, are not removed with
    the rest of the chart during an invocation of the `helm uninstall` command as
    they are not tracked or managed by Helm. Instead, a couple of strategies can be
    employed to remove hooks during a release's life cycle, such as configuring a
    deletion policy and setting a TTL on a job.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然钩子为生命周期管理提供了有用的机制，但应该记住，与常规模板资源不同，钩子在调用“helm uninstall”命令时不会随图表的其余部分一起删除，因为它们不受Helm跟踪或管理。相反，可以采用一些策略来在发布的生命周期中删除钩子，例如配置删除策略和设置作业的TTL。
- en: 'First, the `helm.sh/hook-delete-policy` annotation can be specified on the
    pod or job associated with the hook. This annotation determines when Helm should
    act on removing the resource from Kubernetes. The following options are available
    (the descriptions reference the Helm documentation, which can be found at https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies):'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，可以在与钩子相关的pod或job上指定`helm.sh/hook-delete-policy`注释。此注释确定Helm应何时对Kubernetes中的资源进行删除。有以下选项（描述参考Helm文档，可在https://helm.sh/docs/topics/charts_hooks/#hook-deletion-policies找到）：
- en: '![](image/10.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](image/10.jpg)'
- en: 'Additionally, Kubernetes provides the option of defining a **Time-To-Live**
    (**TTL**) mechanism to limit the amount of time a resource is retained for after
    completion using the `ttlSecondsAfterFinished` property of the job, as shown:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Kubernetes提供了定义**生存时间**（**TTL**）机制的选项，以限制资源在完成后保留的时间量，使用作业的`ttlSecondsAfterFinished`属性，如下所示：
- en: '[PRE62]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, the resources are removed in 60 seconds upon completion or
    failure.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，资源在完成或失败后的60秒内被删除。
- en: 'The final stage of a release''s life cycle is its deletion, and although standard
    chart templates are removed during the invocation of the `helm uninstall` command
    you may want certain resources to be retained so that Helm doesn''t take action
    on them. A common use case for this is when a new persistent volume via a `PersistentVolumeClaim`
    command is created at the beginning of a release''s life cycle but should not
    be removed alongside other resources at the end so that the volume''s data is
    retained. This option is enabled through the use of the `helm.sh/resource-policy`
    annotation, as shown:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 发布生命周期的最后阶段是删除，尽管在调用`helm uninstall`命令时会删除标准图表模板，但您可能希望保留某些资源，以便Helm不对其采取行动。一个常见的用例是，在发布生命周期的开始时通过`PersistentVolumeClaim`命令创建新的持久卷，但在结束时不应与其他资源一起删除，以便保留卷的数据。通过使用`helm.sh/resource-policy`注释启用此选项，如下所示：
- en: '[PRE63]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Helm will no longer consider removing this resource during the execution of
    the `helm uninstall` command. It is important to note that when a resource is
    no longer managed, it becomes orphaned once the remainder of the resources is
    removed. This can cause challenges if the `helm install` command is used as it
    may cause resource-naming conflicts with the existing resource that was not previously
    removed. The orphaned resource can be deleted manually by using the `kubectl delete`
    command.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Helm将不再在执行`helm uninstall`命令期间考虑删除此资源。需要注意的是，当资源不再受管理时，一旦其余资源被删除，它就变成了孤立的。如果使用`helm
    install`命令，可能会导致资源命名冲突，因为之前未删除的现有资源。可以使用`kubectl delete`命令手动删除孤立的资源。
- en: This section discussed how you can write hooks and automation to manage a chart's
    life cycle. In the next section, we will discuss how you can properly document
    a Helm chart to ensure its users have a smooth experience.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何编写钩子和自动化来管理图表的生命周期。在下一节中，我们将讨论如何适当地记录Helm图表，以确保其用户拥有流畅的体验。
- en: Documenting a Helm chart
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录Helm图表
- en: As with any other software that users interact with, a Helm chart should be
    properly documented so that users know how to interact with it. The Helm chart
    structure supports a `README.md` file for documenting usage, a `LICENSE` file
    for covering usage and distribution rights, and a `templates/NOTES.txt` file for
    generating usage instructions during chart installation.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户交互的任何其他软件一样，Helm图表应该有适当的文档，以便用户知道如何与其交互。Helm图表结构支持用于记录用法的`README.md`文件，用于覆盖用法和分发权利的`LICENSE`文件，以及用于在图表安装期间生成用法说明的`templates/NOTES.txt`文件。
- en: The README.md File
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: README.md文件
- en: '**README** is a file commonly used in software development to describe the
    installation, usage, and other details of a product. A Helm chart''s README file
    often contains the following details:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**README**是软件开发中常用的文件，用于描述产品的安装、使用和其他细节。 Helm图表的README文件通常包含以下细节：'
- en: '**Prerequisites**: A common example of a prerequisite is creating a `secret`
    or a set of secrets to the Kubernetes cluster before a chart is installed. for
    the purpose of mounting to a Kubernetes deployment. Users can be made aware of
    this requirement by referencing the README file.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先决条件**：先决条件的一个常见示例是在安装图表之前在Kubernetes集群中创建一个`secret`或一组secrets，以便挂载到Kubernetes部署中。
    用户可以通过参考README文件来了解这一要求。'
- en: '**Values**: Charts often consist of many different values, each of which should
    be described in a table in the `README` file. The table should specify the name
    of the value, its description or function, and its default value. You may also
    find it helpful to denote whether or not the value needs to be provided during
    an installation or upgrade.'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**值**：图表通常包含许多不同的值，每个值都应在`README`文件中以表格形式描述。 表格应指定值的名称，其描述或功能以及其默认值。 您还可能发现有帮助的是指示该值是否需要在安装或升级期间提供。'
- en: '**Application-specific information**: Once an application is installed using
    the Helm chart, you may need additional information on the application itself,
    such as how it can be accessed or how the application functions. These details
    can be provided in the `README` file as well.'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特定于应用程序的信息**：一旦使用Helm图表安装了应用程序，您可能需要有关应用程序本身的其他信息，例如如何访问它或应用程序的功能。 这些细节可以在`README`文件中提供。'
- en: Helm READMEs are written using the **Markdown** formatting language. Markdown
    is commonly used in GitHub projects and open source software and is a way of easily
    codifying text that can be displayed in an elegant format. Markdown can be explored
    further on the **Markdown Guide** website, loc[ated at https://www.markdowngu](https://www.markdownguide.org/)ide.org/.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Helm READMEs使用**Markdown**格式语言编写。 Markdown通常用于GitHub项目和开源软件，并且是一种可以以优雅格式显示的文本的简便编码方式。
    可以在**Markdown Guide**网站上进一步探索Markdown，位于https://www.markdownguide.org/。
- en: The LICENSE file
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许可证文件
- en: Apart from the technical instructions contained in a `README` file, chart maintainers
    may find it necessary to include a license that indicates the permissions users
    have around chart usage and distribution. These details can be composed in a file
    called `LICENSE` under the chart directory.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`README`文件中包含的技术说明之外，图表维护者可能发现有必要包含一个许可证，以指示用户在图表使用和分发方面的权限。 这些细节可以在图表目录下的名为`LICENSE`的文件中组成。
- en: The `LICENSE` file is a plaintext file containing a software license. The license
    may be custom-written or it can be a copy of a license commonly used in open source
    software, such as the Apache License 2.0 or the MIT License. Understanding the
    differences between licenses as well as the legality in using and distributing
    software is beyond the scope of this book, but you can begin exploring these details
    at the **Choose a License** [website (https://chooseali](https://choosealicense.com/)cense.com/),
    which will assist you in selecting an appropriate license for your Helm chart.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`LICENSE`文件是一个包含软件许可证的纯文本文件。 许可证可以是自定义编写的，也可以是常用于开源软件的许可证的副本，例如Apache许可证2.0或MIT许可证。
    理解许可证之间的区别以及使用和分发软件的合法性超出了本书的范围，但您可以开始在**选择许可证**网站（https://choosealicense.com/）上探索这些细节，该网站将帮助您选择适合您的Helm图表的合适许可证。'
- en: The templates/NOTES.txt file
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: templates/NOTES.txt文件
- en: Similar to the `README.md` file, the `templates/NOTES.txt` file is used to provide
    usage instructions for the application once installed using Helm. The difference
    is that while the `README.md` file is static, the `NOTES.txt` file can be dynamically
    generated using Go templating.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 与`README.md`文件类似，`templates/NOTES.txt`文件用于提供使用说明，一旦使用Helm安装应用程序。不同之处在于，`README.md`文件是静态的，而`NOTES.txt`文件可以使用Go模板动态生成。
- en: 'Imagine that a Helm chart has the following value configured in its `values.yaml`
    file:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Helm图表在其`values.yaml`文件中配置了以下值：
- en: '[PRE64]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Depending on the type of service that is set, the instructions to access the
    application will differ. If the service is a `NodePort` service, access will be
    gained by using a certain port number set on each Kubernetes node. If the service
    is set to `LoadBalancer`, the application will be accessed using the URL of a
    load balancer provisioned automatically on the creation of the service. Understanding
    how to access the application based on the type of service being used may be difficult
    for less experienced Kubernetes users, so the maintainer of this chart should
    provide a `NOTES.txt` file under the `templates/` directory that provides instructions
    on how the application can be accessed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设置的服务类型，访问应用程序的说明将有所不同。如果服务是`NodePort`服务，则可以使用在每个Kubernetes节点上设置的特定端口号来访问。如果服务设置为`LoadBalancer`，则将使用在创建服务时自动配置的负载均衡器的URL来访问应用程序。根据所使用的服务类型访问应用程序的方式可能对经验不足的Kubernetes用户来说有些困难，因此该图表的维护者应该在`templates/`目录下提供一个`NOTES.txt`文件，其中提供了关于如何访问应用程序的说明。
- en: 'The following example illustrates how a `templates/NOTES.txt` file can be used
    for this purpose:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了如何使用`templates/NOTES.txt`文件来实现此目的：
- en: '[PRE65]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This file will be generated and displayed during the application's install,
    upgrade, and rollback phases and can be recalled by running the `helm get notes`
    command. By providing this file, users will get a better understanding of how
    to use the application.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件将在应用程序的安装、升级和回滚阶段生成和显示，并且可以通过运行`helm get notes`命令来调用。通过提供此文件，用户将更好地了解如何使用应用程序。
- en: We have described the majority of the assets that comprise a Helm chart so far
    in this chapter, except for the actual packaging, which allows a chart to be easily
    distributable. This concept will be described in the next section.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经描述了Helm图表的大部分组成部分，除了实际的打包，这样可以使图表易于分发。这个概念将在下一节中描述。
- en: Packaging a Helm chart
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包Helm图表
- en: 'While Helm charts follow a common file structure, they should be packaged in
    order to be easily distributed. Charts are packaged in `tgz` archives. While this
    archives can be manually created by using the `tar` bash utility or an archive
    manager, Helm provides the `helm package` command to simplify this task. The syntax
    of the `helm package` command is shown here:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Helm图表遵循通用的文件结构，但它们应该打包以便于分发。图表以`tgz`存档的形式打包。虽然可以使用`tar` bash实用程序或存档管理器手动创建这些存档，但Helm提供了`helm
    package`命令来简化此任务。`helm package`命令的语法如下所示：
- en: '[PRE66]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The `helm package` command is run against a local chart directory. If this
    command is successful, it will generate a `tgz` archive with the following file
    format:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm package`命令针对本地图表目录运行。如果此命令成功，它将生成一个具有以下文件格式的`tgz`存档：'
- en: '[PRE67]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The archive can then be distributed by pushing to a chart repository, which
    is a task that is explored further in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 存档然后可以通过推送到图表存储库来分发，这是在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中进一步探讨的任务，*构建您的第一个Helm图表*。
- en: 'The `helm package` command includes every file under a chart directory. While
    this is often the preferred behavior, it may not always be desired if the directory
    contains files that are not essential to Helm. One example of a directory where
    this commonly occurs is the `.git/` directory, which is present in projects managed
    by **Git SCM**. If this file is packaged into the chart''s `tgz` archive, it will
    not serve any purpose and will only increase the size of the archive. Helm supports
    a file called `.helmignore` that can be used to omit certain files and folders
    from the Helm archive. The following describes an example `.helmignore` file:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm package`命令包括图表目录下的每个文件。虽然这通常是首选行为，但如果目录中包含对Helm不必要的文件，则可能并非总是如此。一个常见的例子是`.git/`目录，它存在于由**Git
    SCM**管理的项目中。如果将此文件打包到图表的`tgz`存档中，它将毫无意义，只会增加存档的大小。Helm支持一个名为`.helmignore`的文件，可用于从Helm存档中省略某些文件和文件夹。以下是一个示例`.helmignore`文件：'
- en: '[PRE68]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The preceding file indicates that if the `.git/` directory or the `.gitignore`
    files appear in a chart's directory, they will be ignored by the `helm package`
    command, meaning they will not be present in the resulting `tgz` archive. Lines
    that begin with the pound symbol (`#`) in this file serve as comments. Be sure
    to include a `.helmignore` file in your Helm charts if your chart's directory
    contains files and folders that are not necessary to the overall function of the
    chart.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 上述文件指示，如果`.git/`目录或`.gitignore`文件出现在图表目录中，它们将被`helm package`命令忽略，这意味着它们不会出现在生成的`tgz`存档中。在此文件中以井号符号(`#`)开头的行用作注释。如果您的图表目录包含对图表的整体功能不必要的文件和文件夹，请确保在Helm图表中包含一个`.helmignore`文件。
- en: Summary
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A Helm chart is a set of files, written primarily in the YAML format, that follows
    a certain file structure. The `Chart.yaml` file is used to set chart metadata
    and declare dependencies. The `templates/` directory is used to contain Kubernetes
    YAML resources that are Go-templated, allowing them to be dynamically generated.
    Kubernetes resources defined under the `templates/` directory can also contain
    certain hooks to configure stages in an application's life cycle. To provide documentation
    to users, charts can contain the `README.md` and `templates/NOTES.txt` files and
    can also contain the `LICENSE` file to declare chart usage and distribution rights.
    Finally, charts can contain a `.helmignore` file, which is used to omit declared
    files from the final packaged product.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表是一组文件，主要以YAML格式编写，遵循特定的文件结构。`Chart.yaml`文件用于设置图表元数据并声明依赖关系。`templates/`目录用于包含Kubernetes
    YAML资源，这些资源是Go模板化的，允许它们动态生成。在`templates/`目录下定义的Kubernetes资源还可以包含某些钩子，用于配置应用程序生命周期中的各个阶段。为了向用户提供文档，图表可以包含`README.md`和`templates/NOTES.txt`文件，还可以包含`LICENSE`文件以声明图表的使用和分发权利。最后，图表可以包含一个`.helmignore`文件，用于从最终打包的产品中省略声明的文件。
- en: In this chapter, you learned about the structure of a Helm chart and how to
    configure key chart components. With the knowledge from this chapter under your
    belt, you now have an understanding of the basic concepts of how to write your
    first Helm chart from scratch, which we will do in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your First Helm Chart*.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您了解了Helm图表的结构以及如何配置关键的图表组件。有了本章的知识，您现在了解了如何从头开始编写您的第一个Helm图表的基本概念，我们将在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中进行，*构建您的第一个Helm图表*。
- en: Further reading
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about the basics behind creating Helm charts, consult the Chart
    Template Guide page on the Helm d[ocumentation at https://helm.sh/docs/chart](https://helm.sh/docs/chart_template_guide/)_template_guide/.
    The Ch[arts section at https://helm.sh/doc](https://helm.sh/docs/topics/charts/a)s/topics/charts/
    also describes many of the topics discussed throughout this chapter, including
    chart file structure, dependencies, and the `Chart.yaml` file.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关创建Helm图表的基础知识，请参阅Helm文档中的Chart模板指南页面，网址为https://helm.sh/docs/chart_template_guide/。https://helm.sh/docs/topics/charts/中的“图表”部分还描述了本章中讨论的许多主题，包括图表文件结构、依赖关系和“Chart.yaml”文件。
- en: Questions
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the file format that is most commonly used in Kubernetes and Helm?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes和Helm中最常用的文件格式是什么？
- en: What are the three required fields in the `Chart.yaml` file?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Chart.yaml”文件中的三个必填字段是什么？
- en: How can the values from a chart dependency be referenced or overridden?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何引用或覆盖图表依赖项的值？
- en: Imagine you want to take a data snapshot of a database deployed with Helm. What
    can you do to ensure that a data `snapshot` is taken before upgrading the database
    to a newer version?
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，您想要对使用Helm部署的数据库进行数据快照。在将数据库升级到更新版本之前，您可以采取什么措施来确保在升级数据库之前进行数据“快照”？
- en: What files can you, as a chart developer, create to provide documentation and
    simplify the chart installation process for the end user?
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为图表开发人员，您可以创建哪些文件来为最终用户提供文档并简化图表安装过程？
- en: What Helm templating construct can you take advantage of to generate repeating
    YAML portions?
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以利用哪种Helm模板构造来生成重复的YAML部分？
- en: How does the `Chart.yaml` file differ from the `Chart.lock` file?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “Chart.yaml”文件与“Chart.lock”文件有什么不同？
- en: What is the name of the annotation that defines a resource as a hook?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是将资源定义为钩子的注释的名称？
- en: What is the purpose of functions and pipelines in chart templates? What are
    some common functions that can be used?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图表模板中的函数和管道的目的是什么？可以使用哪些常见函数？
