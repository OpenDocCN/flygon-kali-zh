- en: The Tenets of Clean Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁代码的原则
- en: 'In the last chapter, we discussed the purpose that sits at the very beginning
    of a piece of code: solving a problem for a user. We discussed the difficulties
    of catering to both the machine and the human. We reminded ourselves that, at
    its core, writing code is about communicating intent.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了代码开头的目的：为用户解决问题。我们讨论了迎合机器和人的困难。我们提醒自己，写代码的核心是传达意图。
- en: In this chapter, we will derive four core tenets from those foundations that
    are necessary to think about when creating software. These tenets are reliability,
    efficiency, maintainability, and usability. A good piece of software can be said
    to have all of these qualities. A bad piece of software can be said to have none
    of them. Crucially, however, these tenets are not rules. Instead, it is useful
    to see them as lenses through which you can look at your code. For each tenet,
    we will discover why it is important through a mix of analogies and JavaScript
    examples. You should come away from this chapter with an ability to apply these
    tenets to your code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从这些基础中得出四个核心原则，这些原则在创建软件时是必要考虑的。这些原则是可靠性、效率、可维护性和可用性。一个好的软件可以说具有所有这些品质。一个糟糕的软件可以说没有一个。然而，这些原则并不是规则。相反，将它们视为您可以查看代码的透镜是有用的。对于每个原则，我们将通过类比和JavaScript示例的混合来发现它的重要性。您应该能够从本章中学会将这些原则应用到您的代码中。
- en: 'Specifically, we will be covering the following tenets:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下原则：
- en: Reliability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可靠性
- en: Efficiency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效率
- en: Maintainability
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可维护性
- en: Usability
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性
- en: Reliability
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可靠性
- en: Reliability is the core underpinning of a good software system. Without reliability,
    the usefulness of technology quickly dissipates, leaving us in a position where
    we may have been better going without it. Technology's entire purpose can be undermined
    by unreliability.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 可靠性是一个良好软件系统的核心支柱。没有可靠性，技术的实用性很快就会消失，使我们陷入一种可能更好不使用它的境地。技术的整个目的可能会被不可靠性所破坏。
- en: 'Reliability, however, is not only a characteristic of large and complex software
    systems. Each and every line of code can be constructed to be either unreliable
    or reliable. But what do we mean by this? Reliability, the word, refers to the
    quality of being reliable. What does it mean to write code that people can rely
    on? It helps by defining reliability in terms of three distinct qualities: *Reliability
    is the quality of being correct, stable, and resilient*.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可靠性不仅仅是大型和复杂软件系统的特征。每一行代码都可以构建成不可靠或可靠的。但是这是什么意思呢？可靠性这个词指的是可靠的质量。编写可以让人们依赖的代码是什么意思呢？通过定义三个不同的特质来帮助定义可靠性：*可靠性是正确、稳定和有弹性的质量*。
- en: Correctness
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确性
- en: 'Code that is correct is code which conforms to a set of expectations and requirements.
    If I write a function to validate email addresses, then the expectation is that
    the function can be called with all types of email addresses and correctly establish
    their validity or invalidity as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的代码是符合一组期望和要求的代码。如果我编写一个函数来验证电子邮件地址，那么期望是该函数可以使用各种类型的电子邮件地址进行调用，并正确地确定它们的有效性或无效性，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To write correct code, we must first have an idea of what the requirements
    are. Requirements are our formalized expectations for how the code will behave.
    For the previous case of an email validation function, we might have the following
    requirements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写正确的代码，我们必须首先了解要求是什么。要求是我们对代码行为的正式期望。对于先前的电子邮件验证函数的情况，我们可能有以下要求：
- en: The function will return `true` when a valid email address is passed as the
    first argument
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当传递有效的电子邮件地址作为第一个参数时，该函数将返回`true`
- en: The function will otherwise return `false`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，该函数将返回`false`
- en: 'The first requirement is ambiguous though. We need to discern what it means
    for an email address to even be valid. Email addresses are a seemingly simple
    format; however, there are in fact many edge cases and oddly valid manifestations.
    For example, the following email addresses are technically valid according to
    the RFC 5322 specification:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第一个要求是模棱两可的。我们需要弄清楚电子邮件地址甚至是什么意思才能有效。电子邮件地址看起来是一个简单的格式；然而，实际上有许多边缘情况和奇怪的有效表现。例如，根据RFC
    5322规范，以下电子邮件地址在技术上是有效的：
- en: '`admin@mailserver1`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`admin@mailserver1`'
- en: '`example@s.example`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example@s.example`'
- en: '`john..doe@example.org`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`john..doe@example.org`'
- en: To know whether our function should align fully with the RFC specification,
    we first need to understand its true use case. Is it a utility for email client
    software, or is it perhaps utilized in user registration for a social media website?
    In the latter case, we may want to establish the more exotic email addresses as
    invalid, similar to those listed previously. We may even want to ping the mail
    server at the domain to confirm its existence. The point is to discern what exact
    requirements will provide for us the meaning of *correct*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道我们的函数是否应该完全符合RFC规范，我们首先需要了解它的真正用例。它是电子邮件客户端软件的实用程序，还是可能在社交媒体网站的用户注册中使用？在后一种情况下，我们可能希望将更奇特的电子邮件地址视为无效，类似于之前列出的那些。我们甚至可能希望ping一下域名的邮件服务器来确认其存在。关键是要弄清楚确切的要求将为我们提供*正确*的含义。
- en: Incidentally, composing your own email validation function is very ill-advised,
    as there are many edge cases that need to be taken into account. This highlights
    an important consideration in our quest for reliability; often, we can achieve
    the highest level of reliability by using existing *tried-and-tested* open source
    libraries and utilities. In [Chapter 17](0fe4d928-ff4f-4758-a54f-e8ee8dab6571.xhtml),
    *Other Peoples' Code*, we discuss the process of selecting third-party code in
    detail, and what to look out for.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，自己编写电子邮件验证函数是非常不明智的，因为有许多边缘情况需要考虑。这突显了我们追求可靠性时需要考虑的一个重要问题；通常，我们可以通过使用现有的*经过验证的*开源库和实用程序来实现最高级别的可靠性。在[第17章](0fe4d928-ff4f-4758-a54f-e8ee8dab6571.xhtml)中，*其他人的代码*，我们将详细讨论选择第三方代码的过程以及需要注意的事项。
- en: The requirements we are coding should always derive directly from how our code
    will be used. It is vital to start with the user and their problem; from that,
    we can establish a set of clear requirements that can be independently tested.
    Testing our code is necessary so that we can confirm, to ourselves and our stakeholders,
    that our code fulfills all of the distinct requirements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编码的要求应该始终直接源自我们的代码将如何使用。从用户及其问题开始非常重要；从那里，我们可以建立一组清晰的要求，可以进行独立测试。测试我们的代码是必要的，这样我们就可以确认，对自己和利益相关者来说，我们的代码是否满足所有不同的要求。
- en: 'With the previous example of email address validation, a good set of tests
    would encompass many variations of email addresses, ensuring that all edge cases
    are fully accounted for. In [Chapter 13](58d1cced-ee45-4200-b01b-9c02a40f1195.xhtml), *The
    Landscape of Testing,* we discuss testing in far more detail. For now, however,
    it''s sufficient to simply reflect on the importance of correctness and the ways
    in which we can establish and confirm it:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以前的电子邮件地址验证示例，一组良好的测试将包括许多电子邮件地址的变化，确保所有边缘情况都得到充分考虑。在[第13章](58d1cced-ee45-4200-b01b-9c02a40f1195.xhtml)中，*测试的景观*，我们将更详细地讨论测试。然而，现在，简单地反思正确性的重要性以及我们可以建立和确认的方式就足够了：
- en: Understand the problem being solved and what users want
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解正在解决的问题以及用户的需求
- en: Refine your requirements until it's explicitly clear what's required
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的要求细化，直到清楚明确需要什么
- en: Test your code to verify its correctness
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的代码以验证其正确性
- en: Stability
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 稳定性
- en: 'Stability is a characteristic that we desire in all technology. Without stability,
    things get precarious; we become unsure of whether things will break at any moment.
    Stability is best exemplified by a common piece of real-world technology. Compare
    these two bridges:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定性是我们在所有技术中都希望具备的特征。没有稳定性，事情就会变得不稳定；我们会不确定事情是否会在任何时刻发生故障。稳定性最好由现实世界技术的一个常见例子来说明。比较这两座桥：
- en: '![](assets/c224e100-b1c7-471e-a03c-953e8872b160.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/c224e100-b1c7-471e-a03c-953e8872b160.jpg)'
- en: '[Photos from Unsplash / by Zach Lezniewicz / by Jacalyn Beales]'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[来自Unsplash的照片/由Zach Lezniewicz/由Jacalyn Beales]'
- en: They both technically operate correctly as bridges. However, one has previously
    suffered damage and has been fixed with a simple plank of wood. Which bridge would
    you trust to safely convey a hundred people across? Probably the one on the right.
    It is firmly in place with guard rails, and, crucially, no gaps through which
    you can fall.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在技术上都是正确的桥梁。然而，其中一座之前曾遭受损坏，并且已经用一块简单的木板修复。你会相信哪座桥安全地运送一百人？可能是右边的那座。它牢固地固定在那里，有护栏，而且关键的是，没有可以掉下去的缝隙。
- en: In code, we can say that stability is about *the continued correct behavior
    given different valid inputs and situations*. JavaScript in the browser is especially
    liable to failures in this way. It has to run in a multitude of conditions, on
    different hardware, operating systems, screen sizes, and often in browsers that
    have varying capabilities.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们可以说稳定性是关于*在不同有效输入和情况下持续正确的行为*。浏览器中的JavaScript特别容易出现这种失败。它必须在多种条件下运行，包括不同的硬件、操作系统、屏幕尺寸，而且通常在具有不同功能的浏览器中。
- en: 'If we write code that is strongly dependent on certain conditions, then it
    may be unwieldy and undependable when those conditions do not exist. If, for example,
    we were designing and implementing a layout for a web application, we may forget
    to consider and cater for screen sizes less than 1,024 pixels wide, resulting
    in the following mess:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写的代码严重依赖于某些条件，那么当这些条件不存在时，它可能会变得笨拙和不可靠。例如，如果我们设计和实现网络应用程序的布局，可能会忘记考虑并适应小于1,024像素宽的屏幕尺寸，导致以下混乱：
- en: '![](assets/52ddaeae-50b9-42d0-868d-6b44f903c2ee.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52ddaeae-50b9-42d0-868d-6b44f903c2ee.png)'
- en: This is an example of instability. The web application cannot be depended upon
    to deliver its correct behavior when a certain environmental factor is different.
    A situation in which screen size is less than 1,024 pixels is entirely possible
    and reasonable in a world of increasing mobile device usage; it's an absolutely
    valid use case of our web application and failure to accommodate it has a negative
    effect on our user's ability to rely on it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不稳定的例子。当某个环境因素不同时，无法依赖网络应用程序提供其正确的行为。在移动设备使用不断增加的世界中，屏幕尺寸小于1,024像素的情况是完全可能和合理的；这是我们网络应用程序的绝对有效用例，而未能适应它会对用户依赖它的能力产生负面影响。
- en: Stability is gained through having a full understanding of all the different
    valid inputs and situations that your code may be exposed to. Similar to correctness,
    stability is best confirmed with a set of tests that expose your code to the full
    gamut of inputs and situations.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定性是通过充分了解代码可能暴露的所有不同有效输入和情况来获得的。与正确性类似，稳定性最好通过一组测试来确认，这些测试将代码暴露给各种输入和情况。
- en: Resilience
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性
- en: Resilience is about avoiding failure. Where stability mostly concerns itself
    with expected inputs, resilience concerns itself with what happens when your code
    is exposed to unexpected or nonroutine inputs. Resilience in software systems
    is also known as **fault tolerance** and is sometimes spoken about in terms of
    *redundancies* or *contingencies*. Fundamentally, these are all in service of
    the same goal—to minimize the effects of failure.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是关于避免失败的。稳定性主要关注预期输入，而弹性关注的是当您的代码暴露于意外或非例行输入时会发生什么。软件系统中的弹性也被称为**容错**，有时会以*冗余*或*应急措施*的形式讨论。从根本上讲，所有这些都是为了实现同样的目标——最小化失败的影响。
- en: For critical systems, where lives depend on ongoing functionality, various contingencies
    are often built into the system. If a failure or fault arises, the system can
    isolate and tolerate that failure by utilizing its contingencies.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关键系统，生命取决于持续功能的情况，通常会在系统中建立各种应急措施。如果出现故障或故障，系统可以利用其应急措施隔离和容忍该故障。
- en: NASA, when building flight control systems for the Space Shuttle, built resilience
    into the system by having a set of synchronized redundant machines. If one failed,
    due to an unforeseen circumstance or a bug, then another would take over. Back
    on earth, we build contingency into our hospitals, with backup power generators
    that'll activate immediately if the electricity grid is down. Similarly, some
    urban transport networks benefit from contingencies in the form of *replacement*
    bus services in the case of trains not operating.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在为航天飞机建造飞行控制系统时，美国国家航空航天局（NASA）通过使用一组同步冗余的机器来为系统构建了弹性。如果一个机器由于意外情况或错误而失败，那么另一个机器将接管。回到地球上，我们在医院中建立了备用发电机，如果电力网断电，备用发电机将立即启动。同样，一些城市交通网络在火车不运行的情况下会受益于*替代*公交车服务的应急措施。
- en: 'These large and complex systems may seem light years away from the world of
    JavaScript. But often, without realizing it, we are also routinely thinking about
    and implementing resilience into our code bases. One way we do this is via graceful
    degradation. When we write JavaScript for a browser environment, we have some
    key expectations:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些庞大而复杂的系统似乎与JavaScript的世界相去甚远。但通常情况下，我们也在不知不觉中经常考虑并在我们的代码库中实现弹性。我们实现这一点的一种方式是通过优雅降级。当我们为浏览器环境编写JavaScript时，我们有一些关键的期望：
- en: That the JavaScript will be correctly delivered via HTTP
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript将通过HTTP正确传递
- en: That the version of JavaScript is supported by the browser
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript的版本得到浏览器支持
- en: That JavaScript is not blocked by an ad-blocker or another add-on
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript没有被广告拦截器或其他附加组件阻止
- en: That the browser has not generally disabled JavaScript
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器通常没有禁用JavaScript
- en: If any of these conditions do not hold up, then the user might be faced with
    an entirely unusable website or web application. The way to alleviate these concerns
    is to build with graceful degradation in mind. Graceful degradation involves aspects
    of your application *degrading* to a state in which they can still be used, remaining
    useful to the user even in the face of unexpected failures.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件中的任何一个不成立，用户可能面临完全无法使用的网站或Web应用程序。缓解这些问题的方法是考虑优雅降级。优雅降级涉及应用程序的一些方面*降级*到仍然可以使用的状态，即使在面对意外故障时仍然对用户有用。
- en: 'Graceful degradation is often illustrated with a simple escalator:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅降级通常以一个简单的扶梯来说明：
- en: '![](assets/65cae2e4-2180-4240-a7e2-5c4b54bdbb0c.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/65cae2e4-2180-4240-a7e2-5c4b54bdbb0c.jpg)'
- en: '[Photo via Unsplash, taken by Teemu Laukkarinen]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[照片来自Unsplash，由Teemu Laukkarinen拍摄]'
- en: An escalator, when functioning correctly, will convey people via a set of moving
    metallic steps driven by a powerful gear system and motor. If the system fails
    for whatever reason, then the escalator remains static, acting as a regular flight
    of stairs. So, the escalators can be said to be resilient because, even when unexpected
    failures occur, they remain usable. Users can still convey themselves up and down
    the escalators, though, perhaps the journey will take longer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当扶梯正常运行时，它会通过一组由强大的齿轮系统和电动机驱动的移动金属台阶传送人们。如果系统由于任何原因失败，那么扶梯将保持静止，就像一般的楼梯一样。因此，可以说扶梯具有弹性，因为即使发生意外故障，它们仍然可用。用户仍然可以通过扶梯上下移动，尽管可能需要更长的时间。
- en: 'When writing JavaScript, we can build resilience into our code by detecting
    features we are relying upon and only employing them if they are available. For
    example, I might wish to play MP3 audio to a user. To accomplish this, I will
    make use of the HTML5 Audio element. Before doing this, however, I will detect
    whether the browser supports MP3 audio. If it doesn''t, I can notify the user
    and point them toward a transcript of the audio instead:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写JavaScript时，我们可以通过检测我们依赖的功能并仅在可用时使用它们来为我们的代码构建弹性。例如，我可能希望向用户播放MP3音频。为了实现这一点，我将使用HTML5音频元素。然而，在这之前，我将检测浏览器是否支持MP3音频。如果不支持，我可以通知用户并指引他们阅读音频的转录：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code uses the HTMLMediaElement's `canPlayType` method to discern
    support. We've abstracted this into a `detectAudioMP3Support` function, which
    we then call to decide whether we'll go ahead and play the audio, or alternatively,
    display the transcript of the audio. Displaying the transcript of the audio is
    a form of graceful degradation as it still allows users to gain some utility from
    the audio without being able to play it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用HTMLMediaElement的`canPlayType`方法来识别支持。我们将这一点抽象成一个`detectAudioMP3Support`函数，然后调用它来决定我们是否继续播放音频，或者显示音频的转录。显示音频的转录是一种优雅降级，因为它仍然允许用户在无法播放音频的情况下获得一些效用。
- en: It's important to note that feature detection by itself is not graceful degradation.
    If I detected MP3 support but then silently failed if it wasn't available, then
    that would not achieve much. However, the activation of an alternative pathway
    for our users—in this case, enabling the reading of the transcript—is a perfect
    example of graceful degradation and resilience to failure.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，仅仅进行功能检测本身并不是优雅降级。如果我检测到MP3支持，但如果不可用则默默失败，那就不会有太大作用。然而，为我们的用户激活替代路径——在这种情况下，启用音频的转录阅读——是优雅降级和对故障的弹性的完美例子。
- en: There's something curious about building resilience into the software. By thinking
    about and accommodating potential unexpected failure states, we are, in effect,
    making those failure states expected. This makes our software more stable and
    more usable. Over time, what we once had to be resilient towards will now be an
    everyday part of our software's stability.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 将弹性构建到软件中有一些奇怪之处。通过考虑和适应潜在的意外故障状态，我们实际上是在使这些故障状态变得可预期。这使我们的软件更加稳定和更加可用。随着时间的推移，我们曾经需要对其进行弹性处理的问题现在将成为软件稳定性的日常部分。
- en: Resilience is a vital part of writing clean, reliable code. Fundamentally, we
    write code to solve problems for users. If our code can tolerate and accommodate
    edge-cases, unforeseen circumstances, and unexpected inputs, then it will fulfill
    this purpose more effectively.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 韧性是编写清晰、可靠代码的重要组成部分。从根本上说，我们编写代码是为了解决用户的问题。如果我们的代码能够容忍和适应边缘情况、意想不到的情况和意外的输入，那么它将更有效地实现这一目的。
- en: Efficiency
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率
- en: We live in a world of scarcity. Resources are finite. In order to write the
    best possible code, we need to take this scarcity into account. So, when designing
    and implementing our ideas, we should be doing so with an eye toward efficiency.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个资源有限的世界中。为了编写最佳的代码，我们需要考虑到这种稀缺性。因此，在设计和实现我们的想法时，我们应该着眼于效率。
- en: In this section, we'll explore the different facets of efficiency and tie them
    into the world of JavaScript through examples. Hopefully, you will come away with
    an appreciation for how efficiency is not only about going fast but that it encompasses
    many indirect effects, spanning the gamut from economy to ecology.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过示例探讨效率的不同方面，并将它们与JavaScript的世界联系起来。希望您能对效率不仅仅是快速的概念有所了解，而是包含许多间接影响，从经济到生态的方方面面。
- en: Time
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间
- en: One key scarcity that we are always aware of is time. Time is a vital resource
    that we should seek to only spend with due consideration. In the world of programming,
    we should seek to optimize the amount of time, or CPU cycles, spent on any given
    task. This is to be accommodating to our end users, as they themselves have limited
    time, but also to be prudent with limited and expensive hardware.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 时间是我们一直关注的一个关键稀缺资源。时间是一种重要的资源，我们应该只在经过考虑后才使用。在编程世界中，我们应该寻求优化在任何给定任务上花费的时间或CPU周期的数量。这是为了迎合我们的最终用户，因为他们自己的时间有限，但也是为了谨慎使用有限且昂贵的硬件。
- en: 'Given almost any function in JavaScript, there are ways for it to be written
    more efficiently and less efficiently. Take, for example, this function, which
    removes duplicate strings within an array:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，几乎任何函数都有更高效和更低效的编写方式。例如，这个函数，它删除数组中的重复字符串：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code is reliable, fulfills the requirements, and, for most intents and
    purposes, is perfectly fine. But it is doing needless work. On every iteration
    of the array, it is reiterating the entire array, from the current index to discover
    whether duplicate values exist ahead of where it is currently. This may seem a
    somewhat intuitive approach, but it is wasteful.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是可靠的，满足要求，并且在大多数情况下都是完全可以的。但它做了不必要的工作。在数组的每次迭代中，它都会重新遍历整个数组，从当前索引开始发现是否存在重复值。这种方法可能看起来有点直观，但是很浪费。
- en: 'Instead of checking ahead of the entire input array, we can instead just check
    the existing output array for the specific value. If the output array already
    contains the value, then we know we don''t need to add it again. Here is our slightly
    optimized `if` condition:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不再检查整个输入数组，而是只需检查现有的输出数组是否包含特定值。如果输出数组已经包含该值，那么我们就知道不需要再添加它。这是我们稍微优化过的`if`条件：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are other ways to optimize this, depending on how many unique values there
    are, and how large the input array is. We could, for example, store found values
    as keys in an object (a *HashMap* approach), which would, in some scenarios, decrease
    the lookup time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他优化的方法，取决于有多少个唯一值，以及输入数组的大小。例如，我们可以将找到的值存储为对象中的键（*HashMap*方法），这在某些情况下可以减少查找时间。
- en: Be wary of making micro-optimizations to your code. They may not always be worth
    the cost. Instead, first measure your code's performance, then work on the real
    performance bottlenecks that exist.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要谨慎对代码进行微观优化。它们可能并不总是值得成本。相反，首先衡量代码的性能，然后解决真正存在的性能瓶颈。
- en: Spending too long on a task can end up having a significant effect on the user's
    ability to perform their tasks. Later in the chapter, we will discuss the tenet
    of usability, but, for now, it's just important to note that efficiency with time
    is not only important on principle; it's important because, at scale, these often
    tiny efforts of efficiency can have massively positive effects on usability.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 花费太长时间在一个任务上可能会对用户执行任务的能力产生重大影响。在本章的后面，我们将讨论可用性的原则，但现在重要的是要注意，时间效率不仅在原则上很重要；它之所以重要是因为在规模上，这些通常微小的效率努力可能对可用性产生巨大的积极影响。
- en: Space
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 空间
- en: Space is a type of scarcity and is concerned with the size of things. Data shuttles
    across networks and into machines where it is stored ephemerally in RAM and possibly
    saved to permanent storage in the form of hard or solid-state-drives (HDDs, SSDs).
    As proponents of efficiency, we are interested in only using the space necessary
    to do a given task, and part of this is using the available space in the most
    efficient manner, and only moving data when it is prudent to do so.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 空间是一种稀缺资源，与事物的大小有关。数据在网络和机器之间穿梭，在RAM中临时存储，可能以硬盘或固态驱动器（HDD、SSD）的形式保存到永久存储中。作为效率的倡导者，我们只对完成给定任务所需的空间感兴趣，其中一部分是以最有效的方式使用可用空间，并且只在有必要时移动数据。
- en: Due to the high-level nature of the JavaScript language and the applications
    it usually builds, we rarely have to think about ephemeral RAM usage or permanent
    storage. However, JavaScript has gained significant ground as a legitimate language
    in performance-sensitive environments, such as database infrastructure and HTTP
    middleware, so these concerns are far more relevant nowadays.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JavaScript语言的高级特性和通常构建的应用程序，我们很少需要考虑临时RAM使用或永久存储。然而，JavaScript在性能敏感的环境中已经取得了显著进展，例如数据库基础设施和HTTP中间件，因此这些问题现在更加相关。
- en: Furthermore, the demands of client-side applications, both in the browser and
    within native environments, has drastically increased. The complexity of these
    applications means that we must always be on our toes, thinking about how to optimize
    memory and bandwidth usage on servers, user devices, and across increasingly layered
    networks. The bandwidth we absorb in a web application will have a direct effect
    on the time the user has to wait for the application to become usable.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，客户端应用程序的需求在浏览器和本地环境中都大大增加。这些应用程序的复杂性意味着我们必须时刻保持警惕，考虑如何优化服务器、用户设备和日益复杂的网络上的内存和带宽使用。我们在Web应用程序中吸收的带宽将直接影响用户等待应用程序可用的时间。
- en: Time to first render is a common metric that we are interested in when developing
    frontend of web applications. This can be optimized by being prudent with large
    resources and not blocking the initial load time with unnecessary resources.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首次渲染时间是我们在开发Web应用程序前端时感兴趣的常见指标。通过谨慎使用大型资源并不阻塞初始加载时间来优化这一点。
- en: '*Time* and *space* efficiency are inextricably linked with both directly affecting
    the other. The overarching theme of efficiency is about only doing what''s necessary,
    avoiding waste, and being thrifty with the resources you have available.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '*时间*和*空间*效率是紧密相连的，两者直接影响彼此。效率的总体主题是只做必要的事情，避免浪费，并节约可用资源。'
- en: Efficiency's effects
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效率的影响
- en: Efficiency in terms of space and time is responsible for many other effects,
    both in the software itself and in the wider world. No optimization exists in
    isolation. The savings made in one area will always have knock-on effects in other
    areas. And likewise, any needless costs will often create bottlenecks and issues
    further down the line.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 时间和空间效率在软件本身和更广泛的世界中负责许多其他效应，两者都直接影响另一个。没有优化是孤立存在的。在一个领域节省的资源将总是在其他领域产生连锁效应。同样，任何不必要的成本通常会在后续产生瓶颈和问题。
- en: 'There are too many of these effects to list, but some of the most obvious ones
    in the world of software would include the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有太多这些效应可以列举，但在软件世界中一些最明显的效应包括以下内容：
- en: The ecological effects of power consumption (for example, climate change)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电力消耗的生态效应（例如气候变化）
- en: Cognitive burden of having to use slow software (for example, distraction and
    annoyance)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用慢软件所带来的认知负担（例如分散注意力和烦恼）
- en: The battery life of the user's devices and therefore what tasks they choose
    to prioritize
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户设备的电池寿命，因此他们选择优先考虑的任务
- en: It's essential to always consider the knock-on effects of the choices we make,
    whether those are made in the service of efficiency or some other requirement.
    None of what we create exists in a vacuum.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在做出选择时，始终要考虑我们所做选择的连锁效应，无论是为了效率还是其他要求。我们所创造的一切都不是孤立存在的。
- en: Maintainability
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可维护性
- en: Maintainability is the ease with which appropriate changes can be made to your
    code. Unlike a motor vehicle, code does not typically need routine maintenance
    to avoid things such as rust, but it does, nonetheless, need to be fixed from
    time to time. Changes to its functionality are also often required, especially
    when under active development. Much of the code we work on is also being actively
    worked on by others. This shared ownership relies heavily on the tenet of maintainability.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性是指可以对您的代码进行适当更改的容易程度。与机动车不同，代码通常不需要例行维护来避免生锈等问题，但它仍然需要不时修复。对其功能的更改也经常是必要的，特别是在积极开发时。我们所工作的大部分代码也正在被其他人积极开发。这种共享所有权在很大程度上依赖于可维护性的原则。
- en: Making code maintainable should not be a sidelined priority. It is as vital
    as any other requirement that the code is fulfilling. In the first chapter, we
    spoke a lot about the importance of considering who your users are. It would be
    disingenuous not to see that those who maintain and make changes to our code are
    also our users. They wish to wield what we have created to fulfill a purpose;
    therefore, they are our users. And, as such, we need to think about how we can
    best cater to their needs.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使代码易于维护不应该成为一个次要的优先事项。这与代码满足的任何其他要求一样重要。在第一章中，我们谈到了考虑用户是多么重要。如果我们不考虑维护和更改我们的代码的人也是我们的用户，那就是虚伪的。他们希望使用我们创建的东西来实现某种目的；因此，他们是我们的用户。因此，我们需要考虑如何最好地满足他们的需求。
- en: 'In this next section, we''ll explore two aspects of maintainability: adaptability
    and familiarity.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将探讨可维护性的两个方面：适应性和熟悉度。
- en: Adaptability
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适应性
- en: Arguably, the best type of maintenance is that which does not need to occur.
    Adaptability refers to the ability of your code to cater to and adapt to different
    needs and environments. The code cannot be infinitely adaptive. The very nature
    of code is that it is made for a specific purpose; to solve a specific problem
    for the user. We can and should provide a level of configuration in our code,
    allowing for varying needs, but we cannot foresee all possibilities. Eventually,
    someone with new requirements may need to come along and make changes to the underlying
    code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，最好的维护是不需要发生的维护。适应性是指您的代码适应和适应不同需求和环境的能力。代码不能无限适应。代码的本质是为特定目的而制定的；解决用户的特定问题。我们可以并且应该在我们的代码中提供一定程度的配置，以满足不同的需求，但我们无法预见所有可能性。最终，可能需要有新需求的人来进行更改底层代码。
- en: 'If we were to create a JavaScript component that displays a carousel of images
    (a slideshow), it''s obvious to imagine that users will want to configure the
    specific images displayed. We may, for example, also have a configuration option
    for enabling or disabling the *fade-in *or *fade-out* behavior of the carousel.
    Our complete set of configuration options may look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建一个显示图片轮播（幻灯片放映）的JavaScript组件，很明显可以想象用户会想要配置显示的特定图片。例如，我们还可以有一个配置选项来启用或禁用轮播的*淡入*或*淡出*行为。我们的完整配置选项可能如下所示：
- en: '**(Array) images**: The image URLs you wish to display in the carousel'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(数组) images**：您希望在轮播中显示的图像URL'
- en: '**(Boolean) fadeEffectEnabled**: Whether to fade between images'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(布尔值) fadeEffectEnabled**：是否在图像之间进行淡入淡出'
- en: '**(Number) imageTimeout**: The number of milliseconds a single image will display
    for'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(数字) imageTimeout**：单个图像显示的毫秒数'
- en: '**(Boolean) cycleEnabled**: Whether to keep repeating the slideshow'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**(布尔值) cycleEnabled**：是否保持幻灯片重复播放'
- en: These configuration options define the extent to which our component is adaptable.
    It can be used in a variety of different ways by wielding these options. If a
    user wants it to behave in a way that is not made possible by these options, then
    they may wish to change its behavior by modifying the underlying code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置选项定义了我们的组件的适应程度。通过使用这些选项，可以以多种不同的方式使用它。如果用户希望它以这些选项无法实现的方式行为，那么他们可能希望通过修改底层代码来改变其行为。
- en: 'When changes need to be made to the underlying code, it is important that they
    can be made with as little trouble as possible. Two harmful characteristics that
    might cause trouble are fragility and rigidity:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要对底层代码进行更改时，重要的是能够尽可能轻松地进行更改。可能会导致麻烦的两个有害特征是脆弱性和僵化：
- en: '**Fragility** is the characteristic of being brittle whenever changes are attempted.
    If one area of code is changed to make a bug fix or add a feature, and it affects
    several seemingly unrelated things in a different part of the code base, then
    we can say the code is *fragile*.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脆弱性**是在尝试更改时变得脆弱的特征。如果更改代码的某个区域以进行错误修复或添加功能，并且它影响了代码库中另一个部分中的几个看似无关的事物，那么我们可以说代码是*脆弱的*。'
- en: '**Rigidity** is the characteristic of failing to accommodate change easily.
    If one behavior needs to be changed, ideally, we should only have to make that
    change in one place. But if we have to rewrite code all over the place just to
    accomplish that one change, then we can say the code is *rigid*.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵化**是指难以轻松适应变化的特征。如果需要更改某个行为，理想情况下，我们应该只需要在一个地方进行更改。但如果我们不得不到处重写代码才能实现那个变化，那么我们可以说代码是*僵化的*。'
- en: Fragility and rigidity are usually symptoms of larger code bases, where there
    are many interdependencies between modules. This is why we say that modularity
    is so important. Modularity refers to the separation of concerns into distinct
    areas of code in a way that reduces intertwining code paths.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 脆弱性和僵化通常是较大代码库的症状，其中模块之间存在许多相互依赖。这就是为什么我们说模块化如此重要。模块化是指将关注点分离到代码的不同区域，以减少交织的代码路径。
- en: 'There are various principles and design patterns we can use to accomplish modularity.
    These are discussed in [Chapter 4](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml),
    *SOLID and Other Principles*, and, with more code examples, in [Chapter 11](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml), *Design
    Patterns*. Even at this early stage, it is useful to ask yourself: in what ways
    can I accomplish modularity?'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 有各种原则和设计模式可以用来实现模块化。这些在[第4章](98ac69ed-3848-4359-b9fb-1a9f8b8daed4.xhtml)中讨论，*SOLID和其他原则*，并且在[第11章](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml)中有更多的代码示例，*设计模式*。即使在这个早期阶段，问问自己：我可以以什么方式实现模块化？
- en: Working to avoid fragility and rigidity is a good goal and will make our code
    more accommodating to changes, but the most crucial aspect of a code base for
    a maintainer is its comprehensibility. That is, the extent to which it can be
    understood. Without understanding what, the maintainer cannot even begin to make
    changes. In fact, in obscure and confusing code bases, it is sometimes impossible
    to discern whether changes are even required. This is why we will now be exploring
    familiarity as an aspect of maintainability. By utilising familiar conventions
    and intuitive patterns, we can help to ensure a high level of understanding among
    our maintainers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 努力避免脆弱性和僵化是一个很好的目标，将使我们的代码更容易适应变化，但对于维护者来说，代码库最关键的方面是可理解性。也就是说，它可以被理解的程度。如果维护者不理解，甚至无法开始进行更改。事实上，在晦涩和令人困惑的代码库中，有时甚至无法确定是否需要进行更改。这就是为什么我们现在将探讨熟悉度作为可维护性的一个方面。通过使用熟悉的约定和直观的模式，我们可以帮助确保我们的维护者之间有高水平的理解。
- en: Familiarity
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 熟悉度
- en: Familiarity is a lovely feeling. It's a feeling of comfort where you know what's
    happening because you've seen it before. This is the feeling we should hope to
    instill in all maintainers that may come across our code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉是一种美好的感觉。这是一种让你感到舒适的感觉，因为你知道发生了什么，因为你以前见过。这是我们应该希望在所有可能遇到我们代码的维护者身上产生的感觉。
- en: Imagine for a moment that you are a skilled mechanic. You open the hood of an
    old car. You expect all of the various components to be visible in their respective
    places. You are adept at recognizing specific components, and, even without having
    to move things about, you can see how components are linked together.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你是一个技术娴熟的技师。你打开一辆旧车的引擎盖。你期望各种组件都能以各自的位置可见。你擅长识别特定的组件，即使不用移动东西，你也能看到组件是如何连接在一起的。
- en: 'Some minor modifications have been made; maybe the owner has previously installed
    a turbocharged engine or modified the gear ratios, but overall, you see that everything
    is more or less where it should be. For you, the mechanic, making changes is going
    to be nice and simple:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 进行了一些小的修改；也许车主之前安装了涡轮增压发动机或修改了齿轮比，但总的来说，你会发现一切都基本在应该的位置上。对于你这个技师来说，进行改变将会非常简单：
- en: '![](assets/0de08cc1-5bc2-4569-b607-36614e7c11b8.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/0de08cc1-5bc2-4569-b607-36614e7c11b8.jpg)'
- en: '[Unsplash image (Public Domain) by Hosea Georgeson]'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[Unsplash image (Public Domain) by Hosea Georgeson]'
- en: In this example, everything under the hood is in its expected and designated
    location. Even though cars vary in many ways, their underlying functionality is
    the same, and so it makes sense that the layout and design are familiar to the
    mechanic.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有的东西都在预期的指定位置。即使汽车在许多方面有所不同，它们的基本功能是相同的，因此布局和设计对于技师来说是熟悉的。
- en: When we think about it, software is not so dissimilar. Most software we end
    up creating is similar to other software in many ways. Most web applications,
    for example, will have a way for users to register, to login, and change their
    name. Most software, regardless of the problem domain, will have the concept of
    **creation, read, update, and delete** (**CRUD)**. These make up the famous verbs
    of persistent storage. Most software can be thought of as fancy middleware sitting
    atop persistent storage. So, even though we may consider all software applications
    to be quite different, their fundamentals are usually very similar. It should,
    therefore, not be so difficult for us to write code that caters to the *mechanic
    who opens the hood*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑软件时，它并不那么不同。我们最终创建的大多数软件在许多方面都类似于其他软件。例如，大多数网络应用程序都会有用户注册、登录和更改名称的方式。大多数软件，无论问题领域如何，都会有**创建、读取、更新和删除**（CRUD）的概念。这构成了持久存储的著名动词。大多数软件可以被认为是坐落在持久存储之上的花哨中间件。因此，即使我们可能认为所有软件应用都非常不同，它们的基本原理通常是非常相似的。因此，我们应该不难编写满足*打开引擎盖的技工*的代码。
- en: 'To make the mechanic''s work as simple as possible, we need to focus foremost
    on the familiarity of our code. It''s not simple to do this because different
    things are familiar to different people, but, on the whole, we can take heed from
    the following guides:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使技工的工作尽可能简单，我们需要首先关注我们的代码的熟悉度。这并不简单，因为不同的东西对不同的人来说是熟悉的，但总的来说，我们可以从以下指南中获得启示：
- en: Don't stray too far from common design patterns
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要偏离常见的设计模式
- en: Be consistent with syntax and presentation
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在语法和表现上保持一致
- en: Lend clarity to unfamiliar problem domains
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为陌生的问题领域提供清晰度
- en: The last point alludes to *unfamiliar problem domains*. This is something that
    you, as the programmer, will have to think about when it comes to each code base
    you work on. To discern if something can be considered unfamiliar, you can ask
    yourself: *Would another programmer working within another industry be able to
    understand this with little introduction?*
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点提到了*陌生的问题领域*。这是你作为程序员在每个你工作的代码库中都需要考虑的事情。要分辨某物是否可以被视为陌生的，你可以问自己：*另一个行业的程序员是否能够在很少的介绍下理解这个？*
- en: Usability
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用性
- en: 'While maintainability is predominantly about catering to other programmers,
    usability is about catering to *all* users, whoever they may be. We can say that
    there are two broad groups of users that are engaged in our service:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可维护性主要是关于迎合其他程序员，但可用性是关于迎合*所有*用户，无论他们是谁。我们可以说有两大类用户参与我们的服务：
- en: People wishing to wield the power of our code via interfaces (GUIs, APIs, and
    so on)
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望通过接口（GUI、API等）运用我们代码的人。
- en: People wishing to make changes to our code to accomplish new tasks or fix bugs
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 希望对我们的代码进行更改以完成新任务或修复错误的人
- en: Usability is about making our code, and the functions and interactions it enables,
    as useful and easy to use as possible for the full gamut of users. All code is
    written with at least one use case in mind, and so it is fair to judge code based
    on the extent to which it fulfills that purpose. Usability, however, goes further
    than this. Usability is not only about fulfillment of user requirements; it's
    about creating experiences that enable a user to achieve their goals with minimal
    hassle, time, and cognitive effort.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性是关于使我们的代码以及它所启用的函数和交互对于所有用户尽可能有用和易于使用。所有的代码都是至少针对一个用例编写的，因此根据它实现这一目的的程度来评判代码是公平的。然而，可用性不仅仅是关于满足用户需求；它是关于创造能够让用户以最小的麻烦、时间和认知努力实现他们目标的体验。
- en: Usability is vital whether we are creating user interfaces on the web or deeply
    embedded server infrastructure that'll rarely see the light of day. In both cases,
    there are users we are providing for, and so we must care about usability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是在网络上创建用户界面还是深度嵌入的服务器基础设施，可用性都是至关重要的，即使它们很少见光。在这两种情况下，我们都在为用户提供服务，因此我们必须关心可用性。
- en: 'Have a look at this function''s signature and try to discern how you would
    go about using it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个函数的签名，试着分辨你会如何使用它：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function is a real function signature from a code base I once worked on.
    It had no documentation and the code within it was spaghetti. It was used to calculate
    whether a given time could be considered a *new year* and would decide when a
    *Happy New Year* message would be shown to a user. It''s incredibly unclear how
    to use it though, or how it works. Some open questions I would have upon discovering
    this function might be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是我曾经工作过的一个代码库中的真实函数签名。它没有文档，其中的代码是混乱的。它被用来计算给定时间是否可以被视为*新年*，并决定何时向用户显示*新年快乐*的消息。然而，它的使用方式或工作原理非常不清楚。发现这个函数时我可能会有一些开放性问题，如下：
- en: What is *configuration* and what is available to configure in such a simple
    function?
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*配置*是什么，这样一个简单的函数中可以配置什么？'
- en: Presumably, SMH is *seconds, minutes, and hours*, but what kind of value is
    it expected to be? An object?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 据推测，SMH是*秒、分钟和小时*，但它预期是什么样的值？一个对象吗？
- en: Presumably, MDY is *months, days, and years*, but what kind of value is it expected
    to be? An object?
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 据推测，MDY是*月、日和年*，但它预期是什么样的值？一个对象吗？
- en: What year does the function compare the passed date for when discerning whether
    it is a *new year*?
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数比较传递的日期是哪一年，以判断它是否是*新年*？
- en: Would any date in the ostensible *new year* work or only, for example, January
    1?
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 假设在表面上的*新年*中任何日期都可以工作，还是只有比如说1月1日？
- en: Why are there *filter* and *formatter* arguments and what do they do? Are they
    optional?
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么有*过滤器*和*格式化程序*参数，它们是什么作用？它们是可选的吗？
- en: What does the function return? A Boolean? The *formatter* argument would suggest
    not.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个函数返回什么？一个布尔值吗？*格式化程序*参数似乎不是这样。
- en: Why can't I just pass a date object instead of individual date components?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我不能只传递一个日期对象而不是单独的日期组件？
- en: The function may do as required, but, as you can see, it's not very usable.
    It takes significant time and cognitive effort to figure out how it works. To
    figure it out fully, we'd have to study its usages in other parts of the code
    and try to decipher the spaghetti within. As a *user* of this function, I would
    personally find the entire process utterly painful.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可能会按要求执行，但是，正如你所看到的，它并不是非常易用。要弄清楚它的工作原理需要花费大量时间和认知努力。要完全弄清楚它，我们必须研究其在代码其他部分的用法，并尝试解密其中的混乱。作为这个函数的*用户*，我个人会觉得整个过程非常痛苦。
- en: Usability is, if anything, about avoiding this pain and burden. As programmers,
    we engage in the creation of abstractions to simplify complex tasks, but all the
    preceding code achieves is further complication of a simple problem.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果说有什么，易用性就是要避免这种痛苦和负担。作为程序员，我们参与创建抽象来简化复杂的任务，但前面的所有代码所实现的只是对一个简单问题的进一步复杂化。
- en: User stories
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户故事
- en: 'Usability is the degree to which something is easy to use for a given purpose.
    Its purpose is defined by a well-understood model of a problem and a set of clear
    requirements. A useful technique for articulating these purposes is via *user
    stories*, made famous by Scrum and Agile methodologies. User stories typically
    take the following form:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 易用性是指某物在特定目的下易于使用的程度。其目的由对问题的一个清晰的模型和一组明确的要求定义。表达这些目的的一个有用的技术是通过*用户故事*，这是Scrum和敏捷方法论所著名的。用户故事通常采用以下形式：
- en: As a {persona}, I want to {want}, so that {purpose}...
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为{角色}，我想要{愿望}，以便{目的}...
- en: 'Here are some examples of the types of user stories you''d expect if we were
    designing a *Contacts* application:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些用户故事的示例，如果我们设计一个*联系人*应用程序，你会期望看到这些类型的用户故事：
- en: As a **user**, I want to **add a new contact** so that **I can later recall
    that contact from my contacts list**.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为**用户**，我想要**添加一个新的联系人**，以便**我以后可以从我的联系人列表中回忆起该联系人**。
- en: As a **user**, I want to **delete a contact** so that **I will no longer see
    that contact in my contacts list**.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为**用户**，我想要**删除一个联系人**，以便**我将不再在我的联系人列表中看到该联系人**。
- en: As a **user**, I want to **easily find a contact by their surname** so that
    **I can contact them**.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为**用户**，我想要**通过他们的姓氏轻松找到一个联系人**，以便**我可以联系他们**。
- en: User stories help to define the purposes that you are catering towards and help
    to focus the mind on the perspective of the user. Whether you're creating a five-line
    function or a ten-thousand-line system, it's always worth planning out your user
    stories.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用户故事有助于定义你所满足的目的，并有助于集中精力关注用户的视角。无论你是创建一个五行函数还是一个一万行的系统，规划你的用户故事总是值得的。
- en: Intuitive design
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直观设计
- en: To design something intuitively is to design it so that users don't have to
    dedicate cognitive effort to figure out how something works. The idea at the core
    of intuitive design is that *it just works*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地设计某物意味着设计它，使用户不必花费认知努力来弄清楚它的工作原理。直观设计的核心理念是*它只是工作*。
- en: 'When we write code, we are partaking in its design, its grand architecture,
    its functionality, and its line-by-line syntax. All of these are vital parts of
    that design. Using intuitive patterns of design is vital to crafting usable code.
    All users are attuned to a set of patterns that are employed on their level of
    abstraction. Here are some examples:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写代码时，我们参与了它的设计，它的大体架构，它的功能和逐行语法。所有这些都是设计的重要部分。使用直观的设计模式对于编写可用的代码至关重要。所有用户都熟悉一组在他们的抽象层次上使用的模式。以下是一些例子：
- en: '**In a GUI**: Using an *X* button to indicate exiting a program or process'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在GUI中**：使用*X*按钮表示退出程序或进程'
- en: '**In code**: A function or method starting with *is* indicates a Boolean return
    value'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在代码中**：以*is*开头的函数或方法表示布尔返回值'
- en: '**In a GUI**: Using green for affirmative actions and red for negative actions'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在GUI中**：使用绿色表示肯定操作，红色表示否定操作'
- en: '**In code**: Upper-casing constants, for example, `VARIABLE_NAME`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在代码中**：大写常量，例如，`VARIABLE_NAME`'
- en: '**In a GUI**: Using a floppy disk icon to indicate the concept of saving'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在GUI中**：使用软盘图标表示保存的概念'
- en: These are the assumptions and expectations that many users carry around with
    them as they navigate software. Tapping into these assumptions means that your
    code and the interactions it facilitates can be monumentally easier to use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是许多用户在使用软件时携带的假设和期望。利用这些假设意味着你的代码和它所促成的交互可以更容易使用。
- en: Accessibility
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无障碍
- en: 'Accessibility is a key principle within usability that states the importance
    of catering to all users, regardless of their abilities and circumstances. Usability
    tends to concern itself with the user as if they are a single entity. We usually
    make specific assumptions about the user, bestowing them with a set of characteristics
    and capabilities that may not be reflected in reality. Accessibility, however,
    is about the real users who will end up having to use whatever you''ve created.
    These real users are a diverse set of individuals and may have all manner of differences.
    When we talk about accessibility in software, we are usually concerned with types
    of differences that directly affect a person''s ability to make use of that software.
    These may include the follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 无障碍是易用性中的一个关键原则，它强调满足所有用户的重要性，而不考虑他们的能力和环境。易用性往往关注用户，好像他们是一个单一的实体。我们通常对用户做出具体的假设，赋予他们一组特征和能力，这些特征和能力可能并不反映现实。然而，无障碍是关于真正将要使用你所创建的任何东西的用户。这些真正的用户是一个多样化的个体群体，可能有各种不同。当我们谈论软件的无障碍时，我们通常关注直接影响一个人使用该软件能力的差异。这些可能包括以下内容：
- en: Learning disorders or differences such as dyslexia.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习障碍或不同，如阅读障碍。
- en: Physical disabilities. For example, limited mobility of the hands or blindness.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身体残疾。例如，手部活动能力受限或失明。
- en: Developmental disorders such as Autism and ADHD.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自闭症和ADHD等发育障碍。
- en: Less access to technology due to mobility, economy, or infrastructure.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动性、经济或基础设施的限制导致技术的获取减少。
- en: In addition to these, there are many other differences that span the gamut of
    human existence, so we should always be ready to learn and adapt according to
    new needs and differences that we encounter among our users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还有许多其他差异涵盖了人类存在的方方面面，因此我们应该随时准备根据我们的用户遇到的新需求和差异进行学习和适应。
- en: 'We are engaged in the creation of web applications, both on the server and
    in the browser. As JavaScript programmers, we sit very close to the interfaces
    that are served to end users. Therefore, it''s vital that we have an excellent
    grasp of accessibility on the web. This includes an awareness of the **Web Content
    Accessibility Guidelines** (**WCAG 2.0**) published by the W3C, which include
    the following provisions:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们致力于在服务器和浏览器上创建Web应用程序。作为JavaScript程序员，我们与为最终用户提供的界面非常接近。因此，我们必须对Web上的可访问性有很好的把握。这包括对W3C发布的《Web内容可访问性指南》（WCAG
    2.0）的了解，其中包括以下规定：
- en: Provide text alternatives for any non-text content (guideline 1.1)
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为任何非文本内容提供文本替代方案（指南1.1）
- en: Make all functionality available from a keyboard (guideline 2.1)
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从键盘上使所有功能可用（指南2.1）
- en: Make text content readable and understandable (guideline 3.1)
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使文本内容可读和可理解（指南3.1）
- en: Accessibility is not only about the non-programmer end user. As mentioned, we
    should consider other programmers to also be our *users* in the same sense as
    the *end users* of GUIs or other web interfaces. It is vital that we cater to
    other programmers. Some programmers are blind or partially sighted. Some programmers
    have learning or cognitive difficulties. Not all programmers work on the latest
    and fastest hardware. Neither do all programmers understand all the things you
    may take for granted. It's important to take all of these things into consideration
    in the code we write.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性不仅仅是关于非程序员最终用户。正如前面提到的，我们应该将其他程序员也视为我们的*用户*，就像GUI或其他Web界面的*最终用户*一样。重要的是我们要迎合其他程序员。一些程序员是盲人或部分视障。一些程序员有学习或认知困难。并非所有程序员都在最新和最快的硬件上工作。也并非所有程序员都理解你可能认为理所当然的所有事情。在我们编写的代码中考虑所有这些事情是很重要的。
- en: Having now finished this chapter, you may have a sense of feeling overwhelmed
    by the number of tenets, principles, and guidelines. Things may seem complex,
    but they aren't if we follow one simple rule—**always focus on the user**. Also,
    remember that other programmers who may work on your code *are* your users as
    well.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在完成了这一章，你可能会感到被原则、原则和指南的数量所压倒。事情可能看起来很复杂，但如果我们遵循一个简单的规则——**始终关注用户**，那么就不会复杂。还要记住，可能会在你的代码上工作的其他程序员*也是*你的用户。
- en: 'As programmers, we sit in a position where we wield unprecedented power in
    helping to define the behaviors that people conduct in the execution of all manner
    of tasks. The original programmers who worked at Twitter, Google, or Microsoft
    likely did not foresee the number of times their code would run. They probably
    couldn''t have originally imagined how many humans their code would end up affecting.
    We should always remain humble to this power and try in earnest to be accountable
    to all of the users we serve, and all the myriad tasks they seek to carry out.
    If you were to come away with one thing from this chapter, I hope it would be
    simply this: a humble and continued consideration of the user, in every line of
    code you write.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们处于一个位置，拥有前所未有的力量，可以帮助定义人们在执行各种任务时的行为。最初在Twitter、Google或Microsoft工作的程序员可能没有预料到他们的代码会运行多少次。他们可能最初无法想象他们的代码会影响多少人。我们应该始终对这种力量保持谦卑，并努力对我们服务的所有用户和他们试图执行的各种任务负责。如果你从本章中得到一件事，我希望就是：在你写的每一行代码中，都谦卑地考虑用户。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've explored the vital tenets of reliability, efficiency,
    maintainability, and usability. Using these tenets as lenses through which we
    can look at our code bases ensures that we will be far more likely to write cleaner
    code. One of the most important things we've learned in this chapter is always
    to consider the human in the code we write. The user may be a human sitting on
    the other side of a GUI or a fellow programmer making use of our APIs. Either
    way, being constantly aware of this human is vital.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了可靠性、效率、可维护性和可用性的重要原则。通过这些原则作为我们审视代码库的透镜，可以确保我们更有可能编写更干净的代码。在本章中学到的最重要的一点是，始终考虑代码中的人。用户可能是坐在GUI另一侧的人，也可能是使用我们的API的其他程序员。无论如何，始终意识到这个人是至关重要的。
- en: In the next chapter, we'll continue the theme of studying the underlying characteristics
    of clean code by looking at the enemies to be aware of, such as cargo-cult programming
    and ego.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续研究干净代码的基本特征，例如要注意的敌人，如模仿式编程和自我。
