- en: Building Stacks for Application State Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用程序状态管理的堆栈
- en: Stacks are one of the most common data structures that one can think of. They
    are ubiquitous in both personal and professional setups. Stacks are a **last in
    first out** (**LIFO**) data structure, that provides some common operations, such
    as push, pop, peek, clear, and size.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈是我们可以想到的最常见的数据结构之一。它们在个人和专业设置中无处不在。堆栈是一种**后进先出**（**LIFO**）的数据结构，提供一些常见操作，如推送、弹出、查看、清除和大小。
- en: In most **object-oriented programming** (**OOP**) languages, you would find
    the stack data structure built-in. JavaScript, on the other hand, was originally
    designed for the web; it does not have stacks baked into it, yet. However, don't
    let that stop you. Creating a stacks using JS is fairly easy, and this is further
    simplified by the use of the latest version of JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数**面向对象编程**（**OOP**）语言中，您会发现堆栈数据结构是内置的。另一方面，JavaScript最初是为网络设计的；它没有内置堆栈。但是，不要让这阻止您。使用JS创建堆栈非常容易，而且使用最新版本的JavaScript可以进一步简化这一过程。
- en: 'In this chapter, our goal is to understand the importance of stack in the new-age
    web and their role in simplifying ever-evolving applications. Let''s explore the
    following aspects of the stack:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的目标是了解堆栈在新时代网络中的重要性以及它们在简化不断发展的应用程序中的作用。让我们探索堆栈的以下方面：
- en: A theoretical understanding of the stack
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对堆栈的理论理解
- en: Its API and implementation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的API和实现
- en: Use cases in real-world web
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在现实世界网络中的用例
- en: Before we start building a stack, let's take a look at some of the methods that
    we want our stack to have so that the behavior matches our requirements. Having
    to create the API on our own is a blessing in disguise. You never have to rely
    on someone else's library *getting it right* or even worry about any missing functionality.
    You can add what you need and not worry about performance and memory management
    until you need to.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建堆栈之前，让我们看一下我们希望堆栈具有的一些方法，以便行为符合我们的要求。必须自己创建API是一种幸事。你永远不必依赖别人的库*做得对*，甚至担心任何缺失的功能。您可以添加所需的内容，直到需要为止，不必担心性能和内存管理。
- en: Prerequisites
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先决条件
- en: 'The following are the requirements for the following chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是以下章节的要求：
- en: A basic understanding of JavaScript
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对JavaScript的基本理解
- en: A computer with Node.js installed (downloadable from[ https://nodejs.org/en/download/](https://nodejs.org/en/download/))
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了Node.js的计算机（可从[https://nodejs.org/en/download/](https://nodejs.org/en/download/)下载）
- en: The code sample for the code shown in this chapter can be found at [https://github.com/NgSculptor/examples](https://github.com/NgSculptor/examples).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所示代码示例的代码样本可以在[https://github.com/NgSculptor/examples](https://github.com/NgSculptor/examples)找到。
- en: Terminology
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: 'Throughout the chapter, we will use the following terminology specific to Stacks,
    so let''s get to know more about it:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用以下与堆栈相关的术语，让我们更多地了解它：
- en: '**Top**: Indicates the top of the stack'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶部**：指示堆栈的顶部'
- en: '**Base**: Indicates the bottom of the stack'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基底**：指示堆栈的底部'
- en: API
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API
- en: 'This is the tricky part, as it is very hard to predict ahead of time what kinds
    of method your application will require. Therefore, it''s usually a good idea
    to start off with whatever is the norm and then make changes as your applications
    demand. Going by that, you would end up with an API that looks something like
    this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是棘手的部分，因为很难预测应用程序将需要哪些方法。因此，通常最好的做法是从正常情况开始，然后根据应用程序的需求进行更改。按照这种方式，您最终会得到一个看起来像这样的API：
- en: '**Push**: Pushes an item to the top of the stack'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**：将项目推送到堆栈的顶部'
- en: '**Pop**: Removes an item from the top of the stack'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹出**：从堆栈的顶部移除一个项目'
- en: '**Peek**: Shows the last item pushed into the stack'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窥视**：显示推送到堆栈中的最后一个项目'
- en: '**Clear**: Empties the stack'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清除**：清空堆栈'
- en: '**Size**: Gets the current size of the stack'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：获取堆栈的当前大小'
- en: '![](assets/00895cb7-ce03-49c1-866a-6ebc7c158459.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/00895cb7-ce03-49c1-866a-6ebc7c158459.png)'
- en: Don't we have arrays for this?
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们难道没有数组吗？
- en: From what we have seen so far, you might wonder why one would need a stack in
    the first place. It's very similar to an array, and we can perform all of these
    operations on an array. Then, what is the real purpose of having a stack?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您可能会想知道为什么首先需要堆栈。它与数组非常相似，我们可以在数组上执行所有这些操作。那么，拥有堆栈的真正目的是什么？
- en: 'The reasons for preferring a stackover an array are multifold:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 更喜欢堆栈而不是数组的原因有很多：
- en: Using stacksgives a more semantic meaning to your application. Consider this
    analogy where you have a backpack (an array) and wallet (a stack). Can you put
    money in both the backpack and wallet? Most certainly; however, when you look
    at a backpack, you have no clue as to what you may find inside it, but when you
    look at a wallet, you have a very good idea that it contains money. What kind
    of money it holds (that is, the data type), such as Dollars, INR, and Pounds,
    is, however, still not known (supported, unless you take support from TypeScript).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用堆栈为您的应用程序提供更语义化的含义。考虑这样一个类比，您有一个背包（一个数组）和一个钱包（一个堆栈）。您可以在背包和钱包中都放钱吗？当然可以；但是，当您看着背包时，您不知道里面可能会找到什么，但是当您看着钱包时，您非常清楚它里面装着钱。它装着什么样的钱（即数据类型），比如美元、印度卢比和英镑，目前还不清楚（除非您从TypeScript获得支持）。
- en: Native array operations have varying time complexities. Let's take `Array.prototype.splice` and `Array.prototype.push`,for
    example. Splice has a worst-case time complexity of O(n), as it has to search
    through all the index and readjust it when an element is splicedout of the array.
    `Push` has a worst case complexity of O(n) when the memory buffer is full but
    is amortized O(1). Stacks avoid elements being accessed directly and internally
    rely on a `WeakMap()`, which is memory efficient as you will see shortly.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本机数组操作具有不同的时间复杂度。例如，让我们看一下`Array.prototype.splice`和`Array.prototype.push`。例如，`Splice`的最坏时间复杂度为O(n)，因为它必须搜索所有索引并在从数组中剪切元素时进行调整。`Push`在内存缓冲区已满时具有最坏情况的复杂度为O(n)，但是摊销为O(1)。堆栈避免直接访问元素，并在内部依赖于`WeakMap()`，这在内存上是高效的，您很快就会看到。
- en: Creating a stack
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个堆栈
- en: 'Now that we know when and why we would want to use a stack, let''s move on
    to implementing one. As discussed in the preceding section, we will use a `WeakMap()`for
    our implementation. You can use any native data type for your implementation,
    but there are certain reasons why `WeakMap()` would be a strong contender. `WeakMap()`
    retains a weak reference to the keys that it holds. This means that once you are
    no longer referring to that particular key, it gets garbage-collected along with
    the value. However, `WeakMap()`come with its own downsides: keys can only be nonprimitives
    and are not enumerable, that is, you cannot get a list of all the keys, as they
    are dependent on the garbage collector. However, in our case, we are more concerned
    with the values that our `WeakMap()` holds rather than keys and their internal
    memory management.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道何时以及为什么要使用堆栈，让我们继续实现一个。正如前一节中讨论的，我们将使用`WeakMap()`进行实现。您可以使用任何本机数据类型进行实现，但是有一些原因使`WeakMap()`成为一个强有力的竞争者。`WeakMap()`对其持有的键保留了弱引用。这意味着一旦您不再引用特定的键，它将与值一起被垃圾回收。然而，`WeakMap()`也有其自身的缺点：键只能是非原始类型，并且不可枚举，也就是说，您无法获取所有键的列表，因为它们依赖于垃圾回收器。然而，在我们的情况下，我们更关心`WeakMap()`持有的值，而不是键和它们的内部内存管理。
- en: Implementing stack methods
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现堆栈方法
- en: 'Implementing a stack is a rather easy task. We will follow a series of steps,
    where we will use the ES6 syntax, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 实现堆栈是一个相当简单的任务。我们将遵循一系列步骤，其中我们将使用ES6语法，如下所示：
- en: 'Define a `constructor`:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`constructor`：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `WeakMap()` to store the stack items:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`WeakMap()`来存储堆栈项：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the methods described in the preceding API  in the `Stack` class:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Stack`类中实现前面API中描述的方法：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, the final implementation of the `Stack` will look as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，`Stack`的最终实现将如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is an overarching implementation of a JavaScript stack, which by no means
    is comprehensive and can be changed based on the application's requirements. However,
    let's go through some of the principles employed in this implementation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是JavaScript堆栈的一个全面实现，这绝不是全面的，可以根据应用程序的要求进行更改。然而，让我们通过这个实现中采用的一些原则。
- en: We have used a `WeakMap()` here, which as explained in the preceding paragraph,
    helps with internal memory management based on the reference to the stack items.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了`WeakMap()`，正如前面的段萀中所解释的，它有助于根据对堆栈项的引用进行内部内存管理。
- en: 'Another important thing to notice is that we have wrapped the `Stack` class
    inside an IIFE, so the constants `items `and `sKey` are available to the `Stack`
    class internally but are not exposed to the outside world. This is a well-known
    and debated feature of the current JSClas*s *implementation, which does not allow
    class-level variables to be declared. TC39 essentially designed the ES6 Class
    in such a way that it should only define and declare its members, which are prototype
    methods in ES5\. Also, since adding variables to prototypes is not the norm, the
    ability to create class-level variables has not been provided. However, one can
    still do the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件重要的事情要注意的是，我们已经将`Stack`类包装在IIFE中，因此`items`和`sKey`常量在`Stack`类内部是可用的，但不会暴露给外部世界。这是当前JSClas*s*实现的一个众所周知和有争议的特性，它不允许声明类级变量。TC39基本上设计了ES6类，使其只定义和声明其成员，这些成员在ES5中是原型方法。此外，由于向原型添加变量不是常规做法，因此没有提供创建类级变量的能力。然而，人们仍然可以做到以下几点：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, this would make the `items`accessible also from outside our `Stack`methods,
    which is something that we want to avoid.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这将使`items`也可以从我们的`Stack`方法外部访问，这是我们想要避免的。
- en: Testing the stack
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试堆栈
- en: 'To test the `Stack` we have just created, let''s instantiate a new stack and
    call out each of the methods and take a look at how they present us with data:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们刚刚创建的`Stack`，让我们实例化一个新的堆栈，并调用每个方法，看看它们如何向我们呈现数据：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When we run the above script we see the logs as specified in the comments above.
    As expected, the stackprovides what appears to be the expected output at each
    stage of the operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行上面的脚本时，我们会看到如上面的注释中指定的日志。正如预期的那样，堆栈在每个操作阶段提供了看似预期的输出。
- en: Using the stack
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用堆栈
- en: 'To use the `Stack`class created previously, you would have to make a minor
    change to allow the stack to be used based on the environment in which you are
    planning to use it. Making this change generic is fairly straightforward; that
    way, you do not need to worry about multiple environments to support and can avoid
    repetitive code in each application:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前创建的`Stack`类，您需要进行一些微小的更改，以允许根据您计划使用的环境来使用堆栈。使这种更改通用相当简单；这样，您就不需要担心支持多个环境，并且可以避免在每个应用程序中重复编写代码：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we add this logic to the stack, it is multi-environment ready. For the
    purpose of simplicity and brevity, we will not add it everywhere we see the stack;
    however, in general, it's a good thing to have in your code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将这个逻辑添加到堆栈中，它就可以在多个环境中使用。为了简单和简洁起见，我们不会在看到堆栈的每个地方都添加它；然而，一般来说，在您的代码中拥有这个功能是件好事。
- en: If your technology stack comprises ES5, then you need to transpile the preceding
    stack code to ES5\. This is not a problem, as there are a plethora of options
    available online to transpile code from ES6 to ES5.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的技术堆栈包括ES5，则需要将先前的堆栈代码转译为ES5。这不是问题，因为在线有大量选项可用于将代码从ES6转译为ES5。
- en: Use cases
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例
- en: Now that we have implemented a `Stack` class, let's take a look at how we can
    employ this in some web development challenges.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了一个`Stack`类，让我们看看如何在一些Web开发挑战中使用它。
- en: Creating an Angular application
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Angular应用程序
- en: To explore some practical applications of the stackin web development, we will
    create an Angularapplication first and use it as a base application, which we
    will use for subsequent use cases.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索堆栈在Web开发中的一些实际应用，我们将首先创建一个Angular应用程序，并将其用作基础应用程序，我们将用于后续用例。
- en: 'Starting off with the latest version of Angularis pretty straightforward. All
    you need as a prerequisite is to have Node.js preinstalled in your system. To
    test whether you have Node.js installed on your machine, go to the Terminal on
    the Mac or the command prompt on Windows and type the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从最新版本的Angular开始非常简单。您只需要预先在系统中安装Node.js。要测试您的计算机上是否安装了Node.js，请转到Mac上的终端或Windows上的命令提示符，并键入以下命令：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That should show you the version of Node.js that is installed. If you have
    something like the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示已安装的Node.js版本。如果您看到以下内容：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that you do not have Node.js installed on your machine.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的计算机上没有安装Node.js。
- en: Once you have Node.js set up on your machine, you get access to `npm`, also
    known as the node package manager command-line tool, which can be used to set
    up global dependencies. Using the `npm`command, we will install the Angular CLI
    tool, which provides us with many Angular utility methods, including—but not limited
    to—creating a new project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在计算机上安装了Node.js，您就可以访问`npm`，也称为node包管理器命令行工具，它可以用于设置全局依赖项。使用`npm`命令，我们将安装Angular
    CLI工具，该工具为我们提供了许多Angular实用方法，包括但不限于创建新项目。
- en: Installing Angular CLI
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Angular CLI
- en: 'To install the Angular CLI in your Terminal, run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的终端中安装Angular CLI，请运行以下命令：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: That should install the Angular CLI globally and give you access to the `ng`command
    to create new projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将全局安装Angular CLI并让您访问`ng`命令以创建新项目。
- en: 'To test it, you can run the following command, which should show you a list
    of features available for use:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，您可以运行以下命令，这应该会显示可用于使用的功能列表：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Creating an app using the CLI
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CLI创建应用程序
- en: 'Now, let''s create the Angular application. We will create a new application
    for each example for the sake of clarity. You can club them into the same application
    if you feel comfortable. To create an Angular application using the CLI, run the
    following command in the Terminal:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建Angular应用程序。为了清晰起见，我们将为每个示例创建一个新应用程序。如果您感到舒适，您可以将它们合并到同一个应用程序中。要使用CLI创建Angular应用程序，请在终端中运行以下命令：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Replace `project-name`with the name of your project; if everything goes well,
    you should see something similar on your Terminal:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将`project-name`替换为您的项目名称；如果一切顺利，您应该在终端上看到类似的东西：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you run into any issues, ensure that you have angular-cli installed as described
    earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到任何问题，请确保您已按前面所述安装了angular-cli。
- en: Before we write any code for this application, let's import the stack that we
    earlier created into the project. Since this is a helper component, I would like
    to group it along with other helper methods under the `utils`directory in the
    root of the application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在为此应用程序编写任何代码之前，让我们将先前创建的堆栈导入项目中。由于这是一个辅助组件，我希望将其与其他辅助方法一起分组到应用程序根目录下的`utils`目录中。
- en: Creating a stack
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个堆栈
- en: Since the code for an Angularapplication is now in TypeScript, we can further
    optimize the stack that we created. Using TypeScript makes the code more readable
    thanks to the `private` variables that can be created in a TypeScript class.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于现在Angular应用程序的代码是TypeScript，我们可以进一步优化我们创建的堆栈。使用TypeScript使代码更易读，因为可以在TypeScript类中创建`private`变量。
- en: 'So, our TypeScript-optimized code would look something like the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们优化后的TypeScript代码看起来像以下内容：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To use the `Stack` created previously, you can simply import the stack into
    any component and then use it. You can see in the following screenshot that as
    we made the `WeakMap()`and the keyprivate members of the `Stack`class, they are
    no longer accessible from outside the class:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用先前创建的`Stack`，您只需将堆栈导入任何组件，然后使用它。您可以在以下截图中看到，由于我们将`WeakMap()`和`Stack`类的keyprivate成员，它们不再可以从类外部访问：
- en: '>![](assets/ae8a74de-f5d0-4369-93d7-75702f697ae2.png)Public methods accessible
    from the Stack class'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '>！[](assets/ae8a74de-f5d0-4369-93d7-75702f697ae2.png)从Stack类中访问的公共方法'
- en: Creating a custom back button for a web application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为Web应用程序创建自定义返回按钮
- en: 'These days, web applications are all about user experience, with flat design
    and small payloads. Everyone wants their application to be quick and compact.
    Using the clunky browser back button is slowly becoming a thing of the past. To
    create a custom Back button for our application, we will need to first create
    an Angularapplication from the previously installed `ng`cli client, as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，Web应用程序都关注用户体验，采用扁平设计和小负载。每个人都希望他们的应用程序快速而紧凑。使用笨重的浏览器返回按钮正在逐渐成为过去的事情。要为我们的应用程序创建自定义返回按钮，我们首先需要从先前安装的`ng`cli客户端创建一个Angular应用程序，如下所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting up the application and its routing
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用程序及其路由
- en: 'Now that we have the base code set up, let''s list the steps for us to build
    an app that will enable us to create a custom Back button in a browser:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了基本代码，让我们列出构建应用程序的步骤，以便我们能够在浏览器中创建自定义返回按钮：
- en: Creating states for the application.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为应用程序创建状态。
- en: Recording when the state of the application changes.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记录应用程序状态更改时的情况。
- en: Detecting a click on our custom Back button.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检测我们自定义返回按钮的点击。
- en: Updating the list of the states that are being tracked.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新正在跟踪的状态列表。
- en: Let's quickly add a few states to the application, which are also known as routesin Angular*. *All
    SPA frameworks have some form of routing module, which you can use to set up a
    few routes for your application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速向应用程序添加一些状态，这些状态也被称为Angular中的路由。所有SPA框架都有某种形式的路由模块，您可以使用它来为应用程序设置一些路由。
- en: 'Once we have the routes and the routing set up, we will end up with a directory
    structure, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们设置了路由和路由设置，我们将得到以下目录结构：
- en: '![](assets/f819036a-8697-4aed-b7ab-8a045a320b86.png)Directory structure after
    adding routes'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/f819036a-8697-4aed-b7ab-8a045a320b86.png)添加路由后的目录结构'
- en: 'Now let''s set up the navigation in such a way that we can switch between the
    routes. To set up routing in an Angular application, you will need to create the
    component to which you want to route and the declaration of that particular route.
    So, for instance, your `home.component.ts`would look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置导航，以便我们可以在各个路由之间切换。要在Angular应用程序中设置路由，您需要创建要路由到的组件以及该特定路由的声明。因此，例如，您的`home.component.ts`将如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `home.routing.ts`filewould be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.routing.ts`文件将如下所示：'
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We can set up a similar configuration for as many routes as needed, and once
    it's set up, we will create an app-level file for application routing and inject
    all the routes and the `navigatableComponents` in that file so that we don't have
    to touch our main module over and over.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为所需的路由设置类似的配置，并一旦设置完成，我们将创建一个应用程序级文件用于应用程序路由，并在该文件中注入所有路由和`navigatableComponents`，以便我们不必一遍又一遍地触及我们的主模块。
- en: 'So, your file `app.routing.ts`would look like the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您的`app.routing.ts`文件将如下所示：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You will note that we are doing something particularly interesting here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会注意到我们正在做一些特别有趣的事情：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is Angular*'*s way of setting default route redirects, so that, when the
    app loads, it's taken directly to the `/home` path, and we no longer have to set
    up the redirects manually.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Angular设置默认路由重定向的方式，因此当应用程序加载时，它会直接转到`/home`路径，我们不再需要手动设置重定向。
- en: Detecting application state changes
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测应用程序状态更改
- en: 'To detect a state change, we can, luckily, use the Angularrouter''s change
    event and take actions based on that. So, import the `Router`module in your `app.component.ts` and
    then use that to detect any state change:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用Angular路由器的更改事件来检测状态更改，并根据此进行操作。因此，在您的`app.component.ts`中导入`Router`模块，然后使用它来检测任何状态更改：
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Any action that the user takes that results in a state change is now being saved
    into our stack, and we can move on to designing our layout and the back button
    that transitions the states.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 用户采取的任何导致状态更改的操作现在都被保存到我们的堆栈中，我们可以继续设计我们的布局和过渡状态的返回按钮。
- en: Laying out the UI
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局UI
- en: 'We will use angular-material to style the app, as it is quick and reliable.
    To install `angular-material`,run the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用angular-material来为应用程序设置样式，因为它快速可靠。要安装`angular-material`，运行以下命令：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once angular-material is saved into the application, we can use the `Button` component
    provided to create the UI necessary, which will be fairly straightforward. First,
    import the `MatButtonModule` that we want to use for this view and then inject
    the module as the dependency in your main `AppModule`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将angular-material保存到应用程序中，我们可以使用提供的`Button`组件来创建所需的UI，这将非常简单。首先，导入我们想要在此视图中使用的`MatButtonModule`，然后将该模块注入到主`AppModule`中作为依赖项。
- en: 'The final form of `app.module.ts` would be as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.module.ts`的最终形式将如下所示：'
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will place four buttons at the top to switch between the four states that
    we have created and then display these states in the `router-outlet`directive
    provided by Angularfollowed by the back button. After all this is done, we will
    get the following result:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在顶部放置四个按钮，用于在我们创建的四个状态之间切换，然后在`router-outlet`指令中显示这些状态，然后是返回按钮。完成所有这些后，我们将得到以下结果：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Navigating between states
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在各个状态之间导航
- en: To add logic to the back button from here on is relatively simpler. When the
    user clicks on the Back button, we will navigate to the previous state of the
    application from the stack. If the stack was empty when the user clicks the Back
    button, meaning that the user is at the starting state, then we set it back into
    the stack because we do the `pop()` operation to determine the current state of
    the stack.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始为返回按钮添加逻辑相对较简单。当用户点击返回按钮时，我们将从堆栈中导航到应用程序的上一个状态。如果堆栈在用户点击返回按钮时为空，这意味着用户处于起始状态，则我们将其放回堆栈，因为我们执行`pop()`操作来确定堆栈的当前状态。
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note here that we are using `urlAfterRedirects`instead of plain `url`*. *This
    is because we do not care about all the hops a particular URL made before reaching
    its final form, so we can skip all the redirected paths that it encountered earlier
    and send the user directly to the final URL after the redirects. All we need is
    the final state to which we need to navigate our user because that's where they
    were before navigating to the current state.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在这里使用`urlAfterRedirects`而不是普通的`url`。这是因为我们不关心特定URL在达到最终形式之前经历了多少跳转，因此我们可以跳过它之前遇到的所有重定向路径，并直接将用户发送到重定向后的最终URL。我们只需要最终状态，以便将用户导航到他们之前所在的状态，因为那是他们导航到当前状态之前所在的位置。
- en: Final application logic
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终应用程序逻辑
- en: 'So, now our application is ready to go. We have added the logic to stack the
    states that are being navigated to and we also have the logic for when the user
    hits the Back button. When we put all this logic together in our `app.component.ts`*, *we
    have the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的应用程序已经准备就绪。我们已经添加了堆栈正在导航到的状态的逻辑，并且我们还有用户点击返回按钮时的逻辑。当我们将所有这些逻辑放在我们的`app.component.ts`中时，我们将得到以下内容：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We also have some supplementary stylesheets used in the application. These are
    obvious based on your application and the overall branding of your product; in
    this case, we are going with something very simple.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些在应用程序中使用的辅助样式表。这些样式表基于您的应用程序和产品的整体品牌；在这种情况下，我们选择了一些非常简单的东西。
- en: 'For the AppComponent styling, we can add component-specific styles in `app.component.scss`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对于AppComponent的样式，我们可以在`app.component.scss`中添加组件特定的样式：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'For the overall theme of the application, we add styles to the `theme.scss` file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序的整体主题，我们将在`theme.scss`文件中添加样式：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This preceding theme file is taken from the Angular material design documentation and
    can be changed as per your application's color scheme.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个前面的主题文件取自Angular材料设计文档，并可以根据您的应用程序的颜色方案进行更改。
- en: 'Once we are ready with all our changes, we can run our application by running
    the following command from the root folder of our application:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们准备好所有的更改，我们可以通过从应用程序的根文件夹运行以下命令来运行我们的应用程序：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: That should spin up the application, which can be accessed at `http://localhost:4200`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动应用程序，可以通过`http://localhost:4200`访问。
- en: '![](assets/1a715dff-96aa-4aaa-b8d8-9dd6e7c85b5a.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1a715dff-96aa-4aaa-b8d8-9dd6e7c85b5a.png)'
- en: From the preceding screenshot, we can see that the application is up-and-running,
    and we can navigate between the different states using the Back button we just
    created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的截图中，我们可以看到应用程序正在运行，并且我们可以使用我们刚刚创建的返回按钮在不同的状态之间导航。
- en: Building part of a basic JavaScript syntax parser and evaluator
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本JavaScript语法解析器和评估器的一部分
- en: The main intent of this application is to show concurrent usage of multiple
    stacksin a computation-heavy environment. We are going to parse and evaluate expressions
    and generate their results without having to use the evil eval.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序的主要目的是在计算密集的环境中展示多个堆栈的并发使用。我们将解析和评估表达式，并生成它们的结果，而不必使用eval。
- en: For example, if you want to build your own `plnkr.co`or something similar, you
    would be required to take steps in a similar direction before understanding more
    complex parsers and lexers, which are employed in a full-scale online editor.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你想构建自己的`plnkr.co`或类似的东西，你需要在更深入了解复杂的解析器和词法分析器之前，采取类似的步骤，这些解析器和词法分析器用于全面的在线编辑器。
- en: 'We will use a similar base project to the one described earlier. To create
    a new application with angular-cli we will be using the CLI tool we installed
    earlier. To create the app run the following command in the Terminal:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与之前描述的类似的基本项目。要使用angular-cli创建新应用程序，我们将使用之前安装的CLI工具。在终端中运行以下命令来创建应用程序：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Building a basic web worker
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建基本的Web Worker
- en: 'Once we have the app created and instantiated, we will create the `worker.js`file
    first using the following commands from the root of your app:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建并实例化了应用程序，我们将首先使用以下命令从应用程序的根目录创建`worker.js`文件：
- en: '[PRE29]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will generate the `utils` folder and the `worker.js` file in it.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`utils`文件夹中生成`worker.js`文件。
- en: 'Note the following two things here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下两点：
- en: It is a simple JS file and not a TypeScript file, even though the entire application
    is in TypeScript
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个简单的JS文件，而不是一个TypeScript文件，尽管整个应用程序都是用TypeScript编写的。
- en: It is called `worker.js`*, *which means that we will be creating a web worker
    for the parsing and evaluation that we are about to perform
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被称为`worker.js`，这意味着我们将为我们即将执行的解析和评估创建一个Web Worker
- en: Web workers are used to simulate the concept of **multithreading**in JavaScript,
    which is usually not the case. Also, since this threadruns in isolation, there
    is no way for us to provide dependencies to that. This works out very well for
    us because our main app is only going to accept the user's input and provide it
    to the worker on every key stroke while it's the responsibility of the workerto
    evaluate this expression and return the result or the error if necessary.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker用于模拟JavaScript中的**多线程**的概念，这通常不是情况。此外，由于此线程运行在隔离中，我们无法为其提供依赖项。这对我们来说非常有利，因为我们的主应用程序只会在每次按键时接受用户的输入并将其传递给worker，而工作人员的责任是评估这个表达式并返回结果或必要时返回错误。
- en: 'Since this is an external file and not a standard Angular file, we will have
    to load it up as an external script so that our application can use it subsequently.
    To do so, open your `.angular-cli.json` file and update the `scripts` option to
    look as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个外部文件，而不是标准的Angular文件，我们将不得不将其作为外部脚本加载，以便我们的应用程序随后可以使用它。为此，打开您的`.angular-cli.json`文件，并更新`scripts`选项如下所示：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we will be able to use the injected worker, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够使用注入的worker，如下所示：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: First, we will add the necessary changes to the `app.component.ts` file so that
    it can interact with `worker.js` as needed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将对`app.component.ts`文件进行必要的更改，以便它可以根据需要与`worker.js`进行交互。
- en: Laying out the UI
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局UI
- en: 'We will use angular-material once more as described in the preceding example.
    So, install and use the components as you see fit to style your application''s
    UI:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用angular-material，就像在前面的示例中描述的那样。因此，安装并使用组件，以便根据需要为应用程序的UI添加样式：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will use `MatGridListModule` to create our application''s UI. After importing
    it in the main module, we can create the template as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`MatGridListModule`来创建应用程序的UI。在主模块中导入它后，我们可以创建以下模板：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We are laying down two tiles; the first one contains the `textarea` to write
    the code and the second one displays the result generated.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在铺设两个瓷砖；第一个包含`textarea`用于编写代码，第二个显示生成的结果。
- en: We have bound the input area with `ngModel`, which is going to provide the two-way
    binding that we need `between` our view and the component. Further, we leverage
    the `keyup` event to trigger the method called `codeChange()`, which will be responsible
    for passing our expression into the worker.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将输入区域与`ngModel`绑定，这将为我们的视图和组件之间提供双向绑定。此外，我们利用`keyup`事件来触发名为`codeChange()`的方法，该方法将负责将我们的表达式传递给worker。
- en: The implementation of the `codeChange()` method will be relatively easy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`codeChange()`方法的实现将相对容易。'
- en: Basic web worker communication
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本Web Worker通信
- en: 'As the component loads, we will want to set up the worker so that it is not
    something that we have to repeat several times. So, imagine if there were a way
    in which you can set up something conditionally and perform an action only when
    you want it to. In our case, you can add it to the constructor or to any of the
    lifecycle hooks that denote what phase the component is in such as `OnInit`, OnContentInit,
    `OnViewInit` and so on, which are provided by Angular as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 组件加载时，我们将希望设置工作线程，以便不必多次重复。因此，想象一下，如果有一种方法可以有条件地设置并仅在需要时执行操作。在我们的情况下，您可以将其添加到构造函数或任何生命周期挂钩中，这些挂钩表示组件所处的阶段，例如`OnInit`、`OnContentInit`、`OnViewInit`等，这些由Angular提供如下：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once initialized, we then use the `addEventListener()` method to listen for
    any new messages—that is, results coming from our worker.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化后，我们使用`addEventListener()`方法来监听任何新消息，即来自工作线程的结果。
- en: 'Any time the code is changed, we simply pass that data to the worker that we
    have now set up. The implementation for this looks as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每当代码更改时，我们只需将数据传递给我们现在设置的工作线程。这样的实现如下所示：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can note, the main application component is intentionally lean. We are
    leveraging workers for the sole reason that CPU-intensive operations can be kept
    away from the main thread. In this case, we can move all the logic including the
    validations into the worker, which is exactly what we have done.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，主应用程序组件是有意保持简洁的。我们利用工作线程的唯一原因是，CPU密集型操作可以远离主线程。在这种情况下，我们可以将所有逻辑，包括验证，移动到工作线程中，这正是我们所做的。
- en: Enabling web worker communications
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Web Worker通信
- en: 'Now that the app component is set and ready to send messages, the worker needs
    to be enabled to receive the messages from the main thread. To do that, add the
    following code to your `worker.js` file:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序组件已经设置并准备好发送消息，工作线程需要启用以接收来自主线程的消息。为此，请将以下代码添加到您的`worker.js`文件中：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, we added the capability of listening for any messagethat might
    be sent to the workerand then the worker simply takes that data and applies some
    basic validation on it before trying to evaluate and return any value for the
    expression. In our validation, we simply rejected any characters that are alphabetic
    because we want our users to only provide valid numbers and operators.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们增加了监听可能发送到工作线程的任何消息的功能，然后工作线程只需获取该数据并在尝试评估并返回表达式的任何值之前对其进行基本验证。在我们的验证中，我们只拒绝了任何字母字符，因为我们希望用户只提供有效的数字和运算符。
- en: 'Now, start your application using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令启动应用程序：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You should see the app come up at `localhost:4200`*. *Now, simply enter any
    code to test your application; for example, enter the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在`localhost:4200`上看到应用程序启动。现在，只需输入任何代码来测试您的应用程序；例如，输入以下内容：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You would see the following error pop up on the screen:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下错误弹出在屏幕上：
- en: '![](assets/56deb8ae-ddfd-4ae8-a322-1437289322ae.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/56deb8ae-ddfd-4ae8-a322-1437289322ae.png)'
- en: 'Now, let''s get a detailed understanding of the algorithm that is in play.
    The algorithm will be split into two parts: parsing and evaluation*.  *A step-by-step
    breakdown of the algorithm would be as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们详细了解正在进行的算法。算法将分为两部分：解析和评估。算法的逐步分解如下：
- en: Converting input expression to a machine-understandable expression.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入表达式转换为机器可理解的表达式。
- en: Evaluating the `postfix` expression.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估后缀表达式。
- en: Returning the expression's value to the parent component.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将表达式的值返回给父组件。
- en: Transforming input to machine-understandable expression
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将输入转换为机器可理解的表达式
- en: 'The input (anything that the user types) will be an expression in the infix
    notation, which is human-readable. Consider this for example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输入（用户输入的任何内容）将是中缀表示法中的表达式，这是人类可读的。例如：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: However, this is not something that we can evaluate as it is, so we convert
    it into a `postfix` notation or reverse polish notation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这并不是我们可以直接评估的内容，因此我们将其转换为后缀表示法或逆波兰表示法。
- en: 'To convert an infix to a `postfix` notation is something that takes a little
    getting used to. What we have  is a watered-down version of that algorithm in
    Wikipedia, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将中缀表达式转换为后缀表达式是需要一点时间来适应的。我们在维基百科中有一个简化版本的算法，如下所示：
- en: Take the input expression (also known as, the infix expression) and tokenize
    it, that is, split it.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取输入表达式（也称为中缀表达式）并对其进行标记化，即拆分。
- en: 'Evaluate each token iteratively, as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 迭代评估每个标记，如下所示：
- en: Add the token to the output string (also known as the `postfix` notation) if
    the encountered character is a number
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果遇到数字，则将标记添加到输出字符串（也称为后缀表示法）中
- en: If it is `(` that is, an opening parenthesis, add it to the output string.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是`(`，即左括号，则将其添加到输出字符串中。
- en: If it is `)` that is, a closed parenthesis, pop all the operators as far as
    the previous opening parenthesis into the output string.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是`)`，即右括号，则将所有运算符弹出，直到前一个左括号为止，然后将其添加到输出字符串中。
- en: If the character is an operator, that is, `*`, `^`, `+`, `-`, `/`, and `,`then
    check the precedence of the operator first before popping it out of the stack.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果字符是运算符，即`*`、`^`、`+`、`-`、`/`和`,`，则在将其从堆栈中弹出之前，首先检查运算符的优先级。
- en: Pop all remaining operators in the tokenized list.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 弹出标记化列表中的所有剩余运算符。
- en: Return the resultant output string or the `postfix` notation.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回结果输出字符串或后缀表示法。
- en: Before we translate this into some code, let's briefly talk about the precedence
    and associativity of the operators, which is something that we need to predefine
    so that we can use it while we are converting the infix expression to `postfix`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其转换为一些代码之前，让我们简要讨论一下运算符的优先级和结合性，这是我们需要预先定义的内容，以便在将中缀表达式转换为后缀表达式时使用。
- en: 'Precedence, as the name suggests, determines the `priority` of that particular
    operator whereas associativity dictates whether the expression is evaluated from
    left to right or vice versa in the absence of a parenthesis. Going by that, since
    we are only supporting simple operators, let''s create a map of operators, their
    `priority`, and `associativity`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 优先级，顾名思义，确定了特定运算符的`优先级`，而结合性则决定了在没有括号的情况下表达式是从左到右还是从右到左进行评估。根据这一点，由于我们只支持简单的运算符，让我们创建一个运算符、它们的`优先级`和`结合性`的映射：
- en: '[PRE40]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, going by the algorithm, the first step is to tokenize the input string.
    Consider the following example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照算法，第一步是对输入字符串进行标记化。考虑以下示例：
- en: '[PRE41]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'It would be converted as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 它将被转换如下：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To achieve this, we basically remove all extra spaces, replace all white spaces
    with empty strings, and split the remaining string on any of the *`*`, `^`, `+`,
    `-`, `/` *operators and remove any occurrences of an empty string.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们基本上删除所有额外的空格，用空字符串替换所有空格，并在任何`*`，`^`，`+`，`-`，`/` *运算符上拆分剩下的字符串，并删除任何空字符串的出现。
- en: Since there is no easy way to remove all empty strings `""`from an array, we
    can use a small utility method called clean, which we can create in the same file.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有简单的方法可以从数组中删除所有空字符串`""`，我们可以使用一个称为clean的小型实用方法，我们可以在同一个文件中创建它。
- en: 'This can be translated into code as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以翻译成如下代码：
- en: '[PRE43]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, the final expression becomes as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终表达式如下：
- en: '[PRE44]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have the input string split, we are ready to analyze each of the
    tokens to determine what type it is and take action accordingly to add it to the `postfix`
    notation output string. This is *Step 2 *of the preceding algorithm, and we will
    use a Stack to make our code more readable. Let''s include the stack into our
    worker,as it cannot access the outside world. We simply convert our stack to ES5
    code, which would look as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将输入字符串拆分，我们准备分析每个标记，以确定它是什么类型，并相应地采取行动将其添加到`后缀`表示输出字符串中。这是前述算法的*第2步*，我们将使用一个堆栈使我们的代码更易读。让我们将堆栈包含到我们的工作中，因为它无法访问外部世界。我们只需将我们的堆栈转换为ES5代码，它将如下所示：
- en: '[PRE45]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, the methods are attached to the `prototype`and voilà we have
    our stack ready.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些方法都附加在`prototype`上，我们的堆栈就准备好了。
- en: 'Now, let''s consume this stack in the infix to postfix conversion. Before we
    do the conversion, we will want to check that the user-entered input is valid,
    that is, we want to check that the parentheses are balanced. We will be using
    the simple `isBalanced()` method as described in the following code, and if it
    is not balanced we will return an error:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在中缀转后缀转换中使用这个堆栈。在进行转换之前，我们将要检查用户输入是否有效，也就是说，我们要检查括号是否平衡。我们将使用下面代码中描述的简单的`isBalanced()`方法，如果不平衡，我们将返回错误：
- en: '[PRE46]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We are going to need the stack to hold the operators that we are encountering
    so that we can rearrange them in the `postfix` string based on their `priority`
    and `associativity`. The first thing we will need to do is check whether the token
    encountered is a number; if it is, then we append it to the `postfix` result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用堆栈来保存我们遇到的运算符，以便我们可以根据它们的`优先级`和`结合性`在`后缀`字符串中重新排列它们。我们需要做的第一件事是检查遇到的标记是否是一个数字；如果是，那么我们将它附加到`后缀`结果中：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we check whether the encountered token is an open bracket, and if it
    is, then we push it to the operators'' stack waiting for the closing bracket.
    Once the closing bracket is encountered, we group everything (operators and numbers)
    in between and pop into the `postfix` output, as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查遇到的标记是否是一个开括号，如果是，那么我们将它推到运算符堆栈中，等待闭括号。一旦遇到闭括号，我们将在`后缀`输出中组合所有内容（运算符和数字），如下所示：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last (and a slightly complex) step is to determine whether the token is
    one of `*`, `^`, `+`, `-`, `/`, and then we check the `associativity` of the current
    operator first. When it's left to right, we check to make sure that the priority
    of the current operator is *less than or equal* to the priority of the previous
    operator. When it's right to left, we check whether the priority of the current
    operator is *strictly less* than the priority of the previous operator. If any
    of these conditions are satisfied, we pop the operators until the conditions fail,
    append them to the `postfix` output string, and then add the current operator
    to the operators' stack for the next iteration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（稍微复杂）的一步是确定标记是否是`*`，`^`，`+`，`-`，`/`中的一个，然后我们首先检查当前运算符的`结合性`。当它是从左到右时，我们检查当前运算符的优先级是否*小于或等于*上一个运算符的优先级。当它是从右到左时，我们检查当前运算符的优先级是否*严格小于*上一个运算符的优先级。如果满足任何这些条件，我们将弹出运算符直到条件失败，将它们附加到`后缀`输出字符串，然后将当前运算符添加到下一次迭代的运算符堆栈中。
- en: The reason why we do a strict check for a right to left but not for a left to
    right `associativity` is that we have multiple operators of that `associativity`
    with the same `priority`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对从右到左的严格检查而不是从左到右的`结合性`进行严格检查的原因是，我们有多个具有相同`优先级`的`结合性`的运算符。
- en: After this, if any other operators are remaining, we then add them to the `postfix`
    output string.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，如果还有其他运算符剩下，我们将把它们添加到`后缀`输出字符串中。
- en: Converting infix to postfix expressions
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将中缀转换为后缀表达式
- en: 'Putting together all the code discussed above, the final code for converting
    the infix expression to `postfix` looks like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 将上面讨论的所有代码放在一起，将中缀表达式转换为`后缀`的最终代码如下：
- en: '[PRE49]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This converts the infix operator provided into the `postfix` notation.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把提供的中缀运算符转换为`后缀`表示法。
- en: Evaluating postfix expressions
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估后缀表达式
- en: 'From here on, executing this `postfix` notation is fairly easy. The algorithm
    is relatively straightforward; you pop out each of the operators onto a final
    result stack*. *If the operator is one of `*`*,* `^`*,* `+`*,* `-`*,* `/`*,* then
    evaluate it accordingly; otherwise, keep appending it to the output string:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，执行这种`后缀`表示法相当容易。算法相对简单；您将每个运算符弹出到最终结果堆栈上。*如果运算符是`*`、`,`、`^`、`+`、`-`、`/`中的一个，则相应地对其进行评估；否则，继续将其附加到输出字符串中：
- en: '[PRE50]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we use some helper methods such as `getParseMethod()`to determine whether
    we are dealing with an integer or float so that we do not round any number unnecessarily.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一些辅助方法，比如`getParseMethod()`来确定我们处理的是整数还是浮点数，以便我们不会不必要地四舍五入任何数字。
- en: 'Now, all we need to do is to instruct our worker to return the data result
    that it has just calculated. This is done in the same way as the error message
    that we return, so our `init()` method changes as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的就是指示我们的工作人员返回它刚刚计算的数据结果。这与我们返回的错误消息的方式相同，因此我们的`init()`方法如下更改：
- en: '[PRE51]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There we have it, real-world web examples using stacks*. *The important thing
    to note in both examples is that the majority of the logic as expected does not
    revolve around the data structure itself. It is a supplementary component, that
    greatly simplifies access and protects your data from unintentional code smells
    and bugs.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有使用堆栈的真实网络示例。*在这两个示例中需要注意的重要事情是，大部分逻辑不像预期的那样围绕数据结构本身。它是一个辅助组件，极大地简化了访问并保护您的数据免受意外的代码问题和错误。
- en: In this chapter, we covered the basics of why we need a specific stack data
    structure instead of in-built arrays, simplifying our code using the said data
    structure, and noted the applications of the data structure. This is just the
    exciting beginning, and there is a lot more to come.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了为什么我们需要一个特定的堆栈数据结构而不是内置数组的基础知识，使用所述数据结构简化我们的代码，并注意数据结构的应用。这只是令人兴奋的开始，还有更多内容要来。
- en: In the next chapter, we will explore the **queues** data structure along the
    same lines and analyze some additional performance metrics to check whether it's
    worth the hassle to build and/or use custom data structures.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将沿着相同的线路探索**队列**数据结构，并分析一些额外的性能指标，以检查是否值得麻烦地构建和/或使用自定义数据结构。
