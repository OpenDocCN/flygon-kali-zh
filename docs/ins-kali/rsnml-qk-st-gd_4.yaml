- en: BuckleScript, Belt, and Interoperability
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BuckleScript，Belt和互操作性
- en: 'In this chapter, we''ll take a closer look at the BuckleScript-specific features
    that are available to us. We''ll also learn about recursion and recursive data
    structures. By the end of this chapter, we''ll have come full circle in the introduction
    to Reason and its ecosystem. In doing so, we''ll have done the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更仔细地了解BuckleScript特定的功能。我们还将学习递归和递归数据结构。到本章结束时，我们将在Reason及其生态系统的介绍中完成一个完整的循环。在这样做的过程中，我们将完成以下工作：
- en: Learned more about Reason's module system
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多了解Reason的模块系统
- en: Explored more of Reason's primitive data structures (arrays and lists)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了Reason的原始数据结构（数组和列表）
- en: Seen how the various pipe operators can make code more readable
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看到各种管道运算符如何使代码更易读
- en: Become familiar with the Reason and Belt standard libraries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 熟悉Reason和Belt标准库
- en: Created bindings to a JavaScript module for use within Reason
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为在Reason中使用而创建了对JavaScript模块的绑定
- en: Added route transitions to our application by binding to React Transition Group
    components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过绑定到React Transition Group组件为我们的应用程序添加路由转换
- en: To follow along, use any environment you wish. Much of what we'll be doing is
    not ReasonReact-specific. Toward the end of the chapter, we'll resume building
    our ReasonReact app.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟进，请使用您希望的任何环境。我们将要做的大部分工作与ReasonReact无关。在本章末尾，我们将继续构建我们的ReasonReact应用程序。
- en: Module scope
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块范围
- en: 'As you now know, all `.re` files are modules and all modules are globally available—including
    nested ones. By default, all types and bindings can be accessed from anywhere
    by providing the namespace. However, doing this over and over quickly becomes
    tedious. Luckily, we have a few ways to make this more pleasant:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您现在所知，所有`.re`文件都是模块，所有模块都是全局可用的，包括嵌套的模块。默认情况下，可以通过提供命名空间从任何地方访问所有类型和绑定。然而，一遍又一遍地这样做很快变得乏味。幸运的是，我们有几种方法可以使这更加愉快：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, we''ll use the `Foo` module''s `fromFoo` type along with it''s bindings
    within another module in different ways:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将以不同的方式在另一个模块中使用`Foo`模块的`fromFoo`类型以及它的绑定：
- en: '**Option 1**: Without any sugar:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项1**：不使用任何语法糖：'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Option 2**: Alias the module to a shorter name. For example, we can declare
    a new module `F` and bind it to the existing module `Foo`:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项2**：将模块别名为更短的名称。例如，我们可以声明一个新模块`F`并将其绑定到现有模块`Foo`：'
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Option 3**: Locally open the module using the `Module.()` syntax. This syntax
    only works with a single expression:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项3**：使用`Module.()`语法在本地打开模块。此语法仅适用于单个表达式：'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Option 4**: In the OOP sense, have `Bar` extend `Foo` using `include`:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项4**：在面向对象编程意义上，使用`include`使`Bar`扩展`Foo`：'
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Option 5**: Globally `open` the module. Use `open` sparingly in large scopes,
    since it becomes hard to know which types and bindings belong to which modules:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项5**：全局`open`模块。在大范围内谨慎使用`open`，因为很难知道哪些类型和绑定属于哪些模块：'
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Prefer using `open` in local scopes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地范围内最好使用`open`：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding syntax will reformat (via `refmt`) to Option 3''s syntax, but
    remember that Option 3''s syntax only works with single expressions. For example,
    the following isn''t able to be converted into Option 3''s syntax:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语法将通过`refmt`重新格式化为选项3的语法，但请记住，选项3的语法仅适用于单个表达式。例如，以下内容无法转换为选项3的语法：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Reason standard library is found within a variety of modules that are already
    available to us. For example, Reason's standard library includes an `Array` module,
    and we can access its functions using the dot notation (that is, `Array.length`).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Reason标准库包含在我们已经可以使用的各种模块中。例如，Reason的标准库包括一个`Array`模块，我们可以使用点表示法（即`Array.length`）访问其函数。
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn how to hide a module's types and bindings so that they aren't globally
    available if we don't want them to be.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)中，*Effective ML*，我们将学习如何隐藏模块的类型和绑定，以便在不希望它们全局可用时不让它们全局可用。
- en: Data structures
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据结构
- en: We've already seen several of Reason's primitive data structures including strings,
    integers, floats, tuples, records, and variants. Let's explore a few more.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了Reason的几种原始数据结构，包括字符串、整数、浮点数、元组、记录和变体。让我们再探索一些。
- en: Array
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组
- en: 'Reason arrays compile to regular JavaScript arrays. Reason arrays are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Reason数组编译为常规的JavaScript数组。Reason数组如下：
- en: Homogeneous (all elements must be of the same type)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同种（所有元素必须是相同类型）
- en: Mutable
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变的
- en: Fast at random access and updates
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速随机访问和更新
- en: 'They look like this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来像这样：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Accessing and updating elements of an array are the same as in JavaScript:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 访问和更新数组的元素与JavaScript中的操作相同：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In JavaScript, we map over the array, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，我们对数组进行映射，如下所示：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To do the same in Reason, we have a few different options.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在Reason中执行相同操作时，我们有几种不同的选择。
- en: Using the Reason standard library
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Reason标准库
- en: 'The Reason standard library''s `Array` module contains several functions, but
    not all the ones you''d expect coming from JavaScript. It does have a `map` function,
    however:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Reason标准库的`Array`模块包含几个函数，但并非您从JavaScript中期望的所有函数。但它确实有一个`map`函数：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The type of `Array.map` is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`Array.map`的类型如下：'
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The type signature says `map` accepts a function of type `''a => ''b`, an array
    of type `''a`, and returns an array of type `''b`. Note that, `''a` and `''b`
    are **type variables**. Type variables are like normal variables, except for types.
    In the preceding example, `map` has a type:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名表示`map`接受类型为`'a => 'b`的函数，类型为`'a`的数组，并返回类型为`'b`的数组。请注意，`'a`和`'b`是**类型变量**。类型变量类似于普通变量，只不过是类型。在前面的示例中，`map`的类型为：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is because the `'a` and `'b` type variables were both consistently replaced
    with the concrete `string` type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`'a`和`'b`类型变量都被一致地替换为具体的`string`类型。
- en: 'Note that, when using `Array.map`, the compiled output does not compile to
    JavaScript''s `Array.prototype.map`—it has its own implementation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`Array.map`时，编译输出不会编译为JavaScript的`Array.prototype.map`——它有自己的实现：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The Reason standard library documentation can be found here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Reason标准库文档可以在这里找到：
- en: '[https://reasonml.github.io/api](https://reasonml.github.io/api)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reasonml.github.io/api](https://reasonml.github.io/api)'
- en: Using the Belt standard library
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Belt标准库
- en: 'The Reason standard library is actually the OCaml standard library. It was
    not created with JavaScript in mind. The Belt standard library was created by
    the same person who created BuckleScript—Hongbo Zhang—and ships with BuckleScript.
    Belt was made with JavaScript in mind and is especially known for its performance.
    The Belt standard library is accessed via the `Belt` module:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Reason标准库实际上是OCaml标准库。它并不是为JavaScript而创建的。Belt标准库是由创建BuckleScript的同一个人——张宏波——创建的，并且随BuckleScript一起发布。Belt是为JavaScript而创建的，尤其以其性能而闻名。Belt标准库通过`Belt`模块访问：
- en: '[PRE15]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The Belt standard library documentation can be found here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Belt标准库文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.html](https://bucklescript.github.io/bucklescript/api/Belt.html)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Belt.html](https://bucklescript.github.io/bucklescript/api/Belt.html)'
- en: Using BuckleScript's built-in JavaScript bindings
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BuckleScript内置的JavaScript绑定
- en: 'Another great option is to use BuckleScript''s built-in JavaScript bindings,
    found in the `Js` module:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的选择是使用BuckleScript内置的JavaScript绑定，可以在`Js`模块中找到：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This option has the advantage of not requiring any dependencies in the compiled
    output. It also has a very familiar API. However, since not all Reason data structures
    exist in JavaScript, you'll likely be using a standard library. If so, prefer
    Belt.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个选项的优势是在编译输出中不需要任何依赖项。它还具有非常熟悉的API。但是，由于并非所有Reason数据结构都存在于JavaScript中，您可能会使用标准库。如果是这样，请优先选择Belt。
- en: 'BuckleScript''s binding documentation can be found here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript的绑定文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Js.html](https://bucklescript.github.io/bucklescript/api/Js.html)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Js.html](https://bucklescript.github.io/bucklescript/api/Js.html)'
- en: Using a custom binding
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义绑定
- en: 'There''s nothing stopping you from writing your own custom bindings:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自己编写自定义绑定：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Of course, you should favor using the built-in bindings in the `Js` module instead.
    We'll explore more custom bindings later in this chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你应该更倾向于使用`Js`模块中的内置绑定。我们将在本章后面探讨更多自定义绑定。
- en: Using raw JavaScript
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始JavaScript
- en: 'A last-resort option is to use actual JavaScript within Reason:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的选择是在Reason中使用实际的JavaScript：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: BuckleScript lets us drop into raw JavaScript as a way to stay productive while
    we're learning. Of course, when doing this, we give up the safety that Reason
    provides us with. So, once you are ready, convert any raw JavaScript code back
    into more idiomatic Reason.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript让我们以原始JavaScript的方式保持高效学习。当然，这样做时，我们放弃了Reason提供的安全性。因此，一旦准备好，将任何原始JavaScript代码转换回更符合惯例的Reason。
- en: 'When it comes to using raw JavaScript, use `%` for expressions and `%%` for
    statements. Remember, the `{| |}` is Reason''s multiline string syntax:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用原始JavaScript时，对于表达式使用`%`，对于语句使用`%%`。记住，`{| |}`是Reason的多行字符串语法：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using the raw expression syntax, we''re also able to annotate types:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原始表达式语法，我们还可以注释类型：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can even annotate function types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以注释函数类型：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although arrays are familiar when coming from JavaScript, you'll likely find
    yourself using lists instead, as they are ubiquitous in functional programming.
    Lists are both immutable and recursive. Let's now see how to use this recursive
    data structure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管从JavaScript中来时数组很熟悉，但您可能会发现自己使用列表，因为它们在函数式编程中是无处不在的。列表既是**不可变的**又是**递归的**。现在让我们看看如何使用这种递归数据结构。
- en: List
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: 'Reason lists are as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Reason列表如下：
- en: Homogeneous
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同质的
- en: Immutable
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变的
- en: Fast at prepending and accessing the head of the list
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在列表的头部快速添加和访问
- en: 'They look like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来像这样：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The head of the list, in this case, is `"first"`. By now, we've seen that it's
    not difficult to work with immutable data structures. Instead of mutation, we
    create updated copies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的头，在这种情况下，是`"first"`。到目前为止，我们已经看到使用不可变数据结构并不困难。我们不是进行突变，而是创建更新后的副本。
- en: 'When working with lists, we can''t use JavaScript bindings directly, since
    lists do not exist in JavaScript as a primitive data structure. However, we can
    convert lists to arrays and vice versa:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理列表时，我们不能直接使用JavaScript绑定，因为列表在JavaScript中并不作为原始数据结构存在。但是，我们可以将列表转换为数组，反之亦然：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But we can also map over a list directly:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以直接映射列表：
- en: '[PRE24]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Logging `list` to the console shows that lists are represented as nested arrays
    in JavaScript where each array always has two elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将`list`记录到控制台显示，列表在JavaScript中表示为嵌套数组，其中每个数组始终有两个元素：
- en: '[PRE25]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This makes sense after understanding that a list is a recursive data structure.
    Reason lists are **singly linked lists**. Each element in a list is either **empty**
    (represented as `0` in JavaScript) or the **combination** of a value and another
    list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解列表是一个递归数据结构之后，这是有意义的。Reason列表是**单向链表**。列表中的每个元素要么是**空**（在JavaScript中表示为`0`），要么是值和另一个列表的**组合**。
- en: 'An example type definition for `list` reveals that `list` is a variant:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`的示例类型定义显示`list`是一个变体：'
- en: '[PRE26]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note: type definitions can be recursive.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：类型定义可以是递归的。
- en: 'Reason provides some syntactic sugar that simplifies its more verbose version:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Reason提供了一些语法糖，简化了更冗长的版本：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Recursion
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: Since list is a recursive data structure, we typically use recursion when working
    with it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列表是一个递归数据结构，我们通常在处理它时使用递归。
- en: 'To get warmed up, let''s write a (naive) function that sums a list of integers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了热身，让我们编写一个（天真的）函数，对整数列表求和：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is a recursive function and therefore requires the `rec` keyword (that
    is, `let rec` instead of just `let`)
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个递归函数，因此需要`rec`关键字（即`let rec`而不仅仅是`let`）
- en: We can pattern match on a list (just like any other variant and many other data
    structures)
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以对列表进行模式匹配（就像任何其他变体和许多其他数据结构一样）
- en: From the example type definition, `Empty` is represented as `[]` and `Head` is
    represented as `[hd, ...tl]` where `hd` is the **head** of the list and `tl` is
    the rest (that is, the **tail**) of the list
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从示例类型定义中，`Empty`表示为`[]`，`Head`表示为`[hd, ...tl]`，其中`hd`是列表的**头部**，`tl`是剩余部分（即列表的**尾部**）
- en: '`tl` could be `[]` (that is, `Empty`) and when it is, recursion stops'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tl`可能是`[]`（即`Empty`），当它是这样时，递归停止'
- en: 'Passing `sum` the list `[1, 2, 3]` results in the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 传入`sum`函数的列表`[1, 2, 3]`会产生以下步骤：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s get a bit more comfortable with lists and recursion by analyzing another
    (naive) function that reverses a list:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析另一个（朴素的）反转列表的函数，更加熟悉列表和递归：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, we use `rec` to define a recursive function
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们使用`rec`来定义一个递归函数
- en: Again, we use pattern matching on the list—if it's empty, stop recursion; otherwise,
    continue with a smaller list
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，我们在列表上使用模式匹配——如果它为空，则停止递归；否则，继续使用较小的列表
- en: The `@` operator appends the second list to the end of the first list
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@`操作符将第二个列表附加到第一个列表的末尾'
- en: 'Passing in the previously defined list (`["first", "second", "third"]`) results
    in the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 传入先前定义的列表(`["first", "second", "third"]`)会产生以下步骤：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This implementation of reverse is naive for two reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个reverse的实现方法有两个问题：
- en: It's not tail call optimized (nor is our `sum` function)
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不是尾调用优化的（我们的`sum`函数也不是）
- en: It uses `append` (`@`), which is slower than `prepend`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用`append`（`@`），这比`prepend`慢
- en: 'A better implementation would be to use a local helper function with an accumulator:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的实现方法是使用一个带有累加器的本地辅助函数：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, its tail call is optimized and it uses prepend instead of append. In Reason,
    you prepend to a list using the `...` syntax:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它的尾调用已经优化，并且它使用prepend而不是append。在Reason中，您可以使用`...`语法向列表前置：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Passing in the list (`["first", "second", "third"]`) roughly results in the
    following steps:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 传入列表(`["first", "second", "third"]`)大致会产生以下步骤：
- en: '[PRE34]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that in the non-tail recursive version, Reason cannot create the list
    until recursion completes. In the tail recursive version, the accumulator (that
    is, the second argument of `aux`) is updated after each iteration.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在非尾递归版本中，Reason无法创建列表直到递归完成。在尾递归版本中，累加器（即`aux`的第二个参数）在每次迭代后更新。
- en: Tail recursive (that is, tail call optimized) functions have the benefit of
    being able to reuse the current stack frame. As a result, tail recursive functions
    will never have a stack overflow, but non-tail recursive functions may have a
    stack overflow given enough iterations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归（即尾调用优化）函数的好处在于能够重用当前的堆栈帧。因此，尾递归函数永远不会发生堆栈溢出，但非尾递归函数在足够的迭代次数后可能会发生堆栈溢出。
- en: Pipe operators
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道操作符
- en: 'Reason has two pipe operators:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Reason有两个管道操作符：
- en: '[PRE35]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Both pipe operators pass arguments to functions. The `|>` pipe operator pipes
    to a function's last argument and the `->` fast pipe operator pipes to a function's
    first argument.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 两个管道操作符都将参数传递给函数。`|>`管道操作符将参数传递给函数的最后一个参数，而`->`快速管道操作符将参数传递给函数的第一个参数。
- en: 'Take a look at these:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这些：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'They are equivalent to this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 它们等价于这个：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the function only accepts one argument, then both pipes work the same, since
    the function's first argument is also the function's last argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数只接受一个参数，那么两个管道的工作方式是相同的，因为函数的第一个参数也是函数的最后一个参数。
- en: Using these pipe operators is quite popular, since, once you get the hang of
    it, it makes the code a lot more readable.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些管道操作符非常流行，因为一旦你掌握了它，代码会变得更加可读。
- en: 'We don''t need to use this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要使用这个：
- en: '[PRE38]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can write it in a way that doesn''t require the reader to read it inside
    out:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以一种不需要读者从内到外阅读的方式来编写它：
- en: '[PRE39]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, using fast pipe looks similar to chaining in JavaScript. Unlike
    JavaScript, we can pass reduce the `+` function, since it is just a normal function
    that accepts two arguments and adds them. The parentheses are necessary to tell
    Reason to treat the infix operator `(+)` as an identifier.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用快速管道看起来类似于JavaScript中的链式调用。与JavaScript不同的是，我们可以传递`+`函数，因为它只是一个接受两个参数并将它们相加的普通函数。括号是必要的，告诉Reason将中缀操作符`（+）`视为标识符。
- en: Using Belt
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Belt
- en: Let's use what we've learned so far in this chapter to write a small program
    that creates a deck of cards, shuffles it, and draws five cards from the top of
    the deck. To do so, we'll use Belt's `Option` and `List` modules, as well as the
    fast pipe operator.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们利用本章学到的知识来编写一个小程序，创建一副牌，洗牌，并从牌堆顶部抽取五张牌。为此，我们将使用Belt的`Option`和`List`模块，以及快速管道操作符。
- en: Option module
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Option模块
- en: 'Belt''s `Option` module is a collection of utility functions for working with
    the `option` type. For example, to unwrap an option and throw a runtime exception
    if the option''s value is `None`, we can use `getExn`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Belt的`Option`模块是用于处理`option`类型的实用函数集合。例如，要解包一个选项，并在选项的值为`None`时抛出运行时异常，我们可以使用`getExn`：
- en: '[PRE40]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Belt functions that are able to throw runtime exceptions always have the `Exn`
    suffix.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 能够抛出运行时异常的Belt函数总是带有`Exn`后缀。
- en: 'An alternative function to unwrap an option that isn''t able to throw a runtime
    exception is `getWithDefault`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解包选项的替代函数是`getWithDefault`，它不能抛出运行时异常：
- en: '[PRE41]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Option` module provides several other functions such as `isSome`, `isNone`,
    `map`, `mapWithDefault`, and more. Check the documentation for details.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`模块还提供了其他几个函数，如`isSome`、`isNone`、`map`、`mapWithDefault`等。查看文档以获取详细信息。'
- en: 'Belt Option module documentation can be found here:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Belt Option模块的文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.Option.html](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Belt.Option.html](https://bucklescript.github.io/bucklescript/api/Belt.Option.html)'
- en: List module
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: List模块
- en: List module are the utilities for list data types. To see what functions Belt
    provides for working with lists, inspect Belt's `List` modules documentation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: List模块是用于列表数据类型的实用程序。要查看Belt提供的用于处理列表的函数，请检查Belt的`List`模块文档。
- en: 'Belt List module documentation can be found here:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Belt List模块的文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Belt.List.html](https://bucklescript.github.io/bucklescript/api/Belt.List.html)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Belt.List.html](https://bucklescript.github.io/bucklescript/api/Belt.List.html)'
- en: Let's focus on a few of them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于其中的一些。
- en: make
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: make
- en: 'The `make` function is used to create a populated list. It accepts an integer
    for the length of the list and a value for each item in the list. Its type is
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`make` 函数用于创建一个填充列表。它接受一个整数作为列表的长度，以及列表中每个项目的值。它的类型如下：'
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '`Belt.List.t` is exposed as an alias of the `list` type, so we can say the
    type of `Belt.List.make` is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Belt.List.t` 被公开为 `list` 类型的别名，因此我们可以说 `Belt.List.make` 的类型如下：'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can use it to create a list containing ten strings, like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建一个包含十个字符串的列表，就像这样：
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we will learn about how to explicitly expose or hide types and bindings from a
    module.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 5 章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml) *Effective ML* 中，我们将学习如何显式地从模块中公开或隐藏类型和绑定。
- en: makeBy
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: makeBy
- en: The `makeBy` function is like the `make` function, except it accepts a function
    used to determine the value of each item given the item's index.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeBy` 函数类似于 `make` 函数，但它接受一个用于确定每个项目的值的函数，给定项目的索引。'
- en: 'The type of the `makeBy` function is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeBy` 函数的类型如下：'
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can use it to create a list of ten items, where each item is equal to its
    index:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建一个包含十个项目的列表，其中每个项目都等于它的索引：
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: shuffle
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: shuffle
- en: 'The `shuffle` function randomly shuffles a list. It has type:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`shuffle` 函数会随机洗牌一个列表。它的类型是：'
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'It accepts a list and returns a new list. Let''s use it to shuffle our list
    of integers:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个列表并返回一个新列表。让我们用它来洗牌我们的整数列表：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: take
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: take
- en: 'The `take` function accepts a list and a length and returns a subset of the
    list starting from the head of the list with length equal to the requested length.
    Since the requested length of the subset may exceed the original list''s length,
    the result is wrapped in an option. Its type is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`take` 函数接受一个列表和一个长度，并返回从列表头部开始的长度等于请求长度的子集。由于子集的请求长度可能超过原始列表的长度，结果被包装在一个选项中。它的类型如下：'
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can take the first two items from our shuffled list, like so:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从洗牌后的列表中取出前两个项目，就像这样：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Deck of cards example
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 卡牌组示例
- en: Now, we're ready to combine this with what we've learned from previous chapters.
    How would you write a program that creates a deck of cards, shuffles it, and draws
    the first five cards? Before looking at the following example, give it a shot
    yourself.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将这个与我们从前几章学到的内容结合起来。你会如何编写一个创建一副卡牌、洗牌并抽取前五张卡的程序？在看下面的例子之前，自己试一试。
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This yields an array of five cards at random in string format:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这会以字符串格式随机产生五张卡牌的数组：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Currying
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Some of the Belt standard library functions have a *U* suffix, such as this
    one:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Belt 标准库的一些函数带有 *U* 后缀，比如这个：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can see the suffix here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到后缀：
- en: '[PRE54]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The *U* suffix stands for *uncurried*. Before going further, let's define currying.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '*U* 后缀代表 *uncurried*。在继续之前，让我们定义一下柯里化。'
- en: 'In Reason, every function accepts exactly one argument. This seems to contradict
    many of our earlier examples:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，每个函数都只接受一个参数。这似乎与我们之前的许多例子相矛盾：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding `add` function looks as if it accepts two arguments, but it is
    actually just syntactic sugar for the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 前述的 `add` 函数看起来好像接受两个参数，但实际上只是以下的语法糖：
- en: '[PRE56]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `add` function accepts a single argument, `a`, which returns a function
    that accepts a single argument, `b`, and then returns the result of `a + b`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`add` 函数接受一个参数 `a`，返回一个接受一个参数 `b` 的函数，然后返回 `a + b` 的结果。'
- en: 'In Reason, both versions are valid and have the same compiled output. In JavaScript,
    both of the preceding versions are valid, but they are not the same; they would
    need to be used differently to get the same result. The second would need to be
    called like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Reason 中，两个版本都是有效的，并且具有相同的编译输出。在 JavaScript 中，前述两个版本都是有效的，但它们并不相同；它们需要以不同的方式使用才能获得相同的结果。第二个需要这样调用：
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is because `add` returns a function that then needs to be called again,
    hence the two sets of parenthesis. Reason would accept either usage:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `add` 返回一个需要再次调用的函数，因此有两组括号。Reason 可以接受任何一种用法：
- en: '[PRE58]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The benefit of currying is that it makes composing functions easier. You can
    easily create a function, `addOne`, that is partially applied:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化的好处在于它使得组合函数更容易。你可以轻松地创建一个部分应用的函数 `addOne`：
- en: '[PRE59]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This `addOne` function could then be passed to other functions such as `map`.
    Perhaps you'd like to use this feature to pass a function to a ReasonReact child
    component with the parent component's `self` partially applied.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以将这个 `addOne` 函数传递给其他函数，比如 `map`。也许你想使用这个功能将一个函数部分应用到 ReasonReact 子组件，而父组件的
    `self` 部分应用。
- en: 'Confusingly, the compiled output of either version of `add` is as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，`add` 的任一版本的编译输出如下：
- en: '[PRE60]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Where is the intermediate function? Wherever possible, BuckleScript optimizes
    the compiled output to avoid the unnecessary function allocation, which improves
    performance.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 中间函数在哪里？在可能的情况下，BuckleScript 优化编译输出，以避免不必要的函数分配，从而提高性能。
- en: 'Remember, since Reason''s infix operators are just normal functions, we could
    have just done the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于 Reason 的中缀运算符只是普通函数，我们可以这样做：
- en: '[PRE61]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Uncurried functions
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化的函数
- en: 'Due to JavaScript''s dynamic nature, BuckleScript cannot always optimize the
    compiled output to remove the intermediate functions. However, you can tell BuckleScript
    to uncurry a function using the following syntax:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 的动态特性，BuckleScript 不能总是优化编译输出以删除中间函数。但是，你可以告诉 BuckleScript 使用以下语法对函数进行
    uncurry：
- en: '[PRE62]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The uncurry syntax is the dot in the argument list. It needs to be present
    at both the declaration and call sites:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: uncurry 语法是参数列表中的点。它需要在声明和调用站点都存在：
- en: '[PRE63]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'BuckleScript will throw a compile time error if the call site isn''t using
    the uncurry syntax:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果调用站点没有使用 uncurry 语法，BuckleScript 将抛出编译时错误：
- en: '[PRE64]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Also, a compile time error is thrown if some of the function''s arguments are
    missing at the call site:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果在调用站点缺少某些函数的参数，则会抛出编译时错误：
- en: '[PRE65]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The term `arity` refers to the number of arguments a function accepts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 术语`arity`指的是函数接受的参数数量。
- en: makeByU
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: makeByU
- en: 'We can replace `makeBy` with `makeByU` if we uncurry its second argument. This
    will improve performance (a negligible amount in our example):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取消`makeBy`的第二个参数的柯里化，可以用`makeByU`替换它。这将提高性能（在我们的示例中可以忽略不计）：
- en: '[PRE66]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The dot syntax requires parentheses around `i`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 点语法需要在`i`周围加括号。
- en: JavaScript interoperability
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript互操作性
- en: The term **interoperability** refers to the ability for Reason programs to use
    existing JavaScript within Reason. BuckleScript provides an excellent system for
    using existing JavaScript code within Reason, and also makes it easy to use Reason
    code within JavaScript.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**互操作性**指的是Reason程序在Reason中使用现有JavaScript的能力。BuckleScript提供了一个出色的系统，用于在Reason中使用现有的JavaScript代码，并且还可以轻松地在JavaScript中使用Reason代码。
- en: Using JavaScript in Reason
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Reason中使用JavaScript
- en: We've already seen how we can use raw JavaScript in Reason. Let's now focus
    on how to bind to existing JavaScript. To bind a value to a named reference, we
    typically use `let`. That binding can then be used in subsequent code. When the
    value we want to bind to lives is JavaScript, we use `external`. The `external`
    binding is like a `let`, in the sense that it can be used in subsequent code.
    Unlike `let`, `external` is typically accompanied by BuckleScript decorators such
    as `[@bs.val]`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何在Reason中使用原始JavaScript。现在让我们专注于如何绑定到现有的JavaScript。要将值绑定到命名引用，通常使用`let`。然后可以在后续代码中使用该绑定。当我们要绑定的值位于JavaScript中时，我们使用`external`。`external`绑定类似于`let`，因为它可以在后续代码中使用。与`let`不同，`external`通常伴有BuckleScript装饰器，如`[@bs.val]`。
- en: Understanding the [@bs.val] decorator
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解[@bs.val]装饰器
- en: 'We can use `[@bs.val]` to bind to global values and functions. In general,
    the syntax is as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`[@bs.val]`绑定全局值和函数。一般来说，语法如下：
- en: '[PRE67]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: One or more BuckleScript decorators (that is, `[@bs.val]`)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BuckleScript的一个或多个装饰器（即`[@bs.val]`）
- en: The `external` keyword
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`external`关键字'
- en: The binding's named reference
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定的命名引用
- en: The type declaration
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型声明
- en: An equal sign
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等号
- en: A string
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个字符串
- en: 'The external keyword binds `alert` to a value of type `string => unit` and
    is bound to the string `alert`. The string `alert` is the value of the above external
    declaration and is what is going to be used in the compiled output. When the name
    of the external binding is equal to its string value, the string can be left empty:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`external`关键字将`alert`绑定到类型为`string => unit`的值，并绑定到字符串`alert`。字符串`alert`是上述外部声明的值，也是编译输出中要使用的值。当外部绑定的名称等于其字符串值时，字符串可以留空：'
- en: '[PRE68]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Using the binding is just like using any other binding:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用绑定就像使用任何其他绑定一样：
- en: '[PRE69]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Understanding the [@bs.scope] decorator
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解[@bs.scope]装饰器
- en: 'To bind to `window.location.pathname`, we add a scope using `[@bs.scope]`.
    This defines the scope for `[@bs.val]`. For example, if you want to bind to the
    `pathname` property of `window.location`, you can specify the scope as `[@bs.scope
    ("window", "location")]`:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定到`window.location.pathname`，我们使用`[@bs.scope]`添加一个作用域。这为`[@bs.val]`定义了作用域。例如，如果要绑定到`window.location`的`pathname`属性，可以指定作用域为`[@bs.scope
    ("window", "location")]`：
- en: '[PRE70]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Or, we could include the scope in the string using only `[@bs.val]`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以只使用`[@bs.val]`在字符串中包含作用域：
- en: '[PRE71]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Understanding the [@bs.send] decorator
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解[@bs.send]装饰器
- en: 'The `[@bs.send]` decorator is for binding to an object''s methods and properties.
    When using `[@bs.send]`, the first argument is always the object. If there are
    remaining arguments, they will get applied to the object''s method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`[@bs.send]`装饰器用于绑定对象的方法和属性。使用`[@bs.send]`时，第一个参数始终是对象。如果有剩余的参数，它们将被应用于对象的方法：'
- en: '[PRE72]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The `Dom` module is also provided by BuckleScript and provides type declarations
    for the DOM.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dom`模块也由BuckleScript提供，并为DOM提供类型声明。'
- en: 'The Dom module documentation can be found here:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Dom模块文档可以在这里找到：
- en: '[https://bucklescript.github.io/bucklescript/api/Dom.html](https://bucklescript.github.io/bucklescript/api/Dom.html)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Dom.html](https://bucklescript.github.io/bucklescript/api/Dom.html)'
- en: 'There is also a Node module for use with Node.js:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个用于Node.js的Node模块：
- en: '[https://bucklescript.github.io/bucklescript/api/Node.html](https://bucklescript.github.io/bucklescript/api/Node.html)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/bucklescript/api/Node.html](https://bucklescript.github.io/bucklescript/api/Node.html)'
- en: 'Be careful when writing external declarations since you can accidentally lie
    to the type system, which could result in runtime type errors. For example, we
    told Reason that our `getElementById` binding always returns a `Dom.element`,
    but it returns `undefined` when the DOM can''t find an element with the provided
    ID. A more correct binding would be this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写外部声明时要小心，因为您可能会意外地欺骗类型系统，这可能导致运行时类型错误。例如，我们告诉Reason我们的`getElementById`绑定总是返回`Dom.element`，但是当DOM找不到提供的ID的元素时，它返回`undefined`。更正确的绑定应该是这样的：
- en: '[PRE73]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Understanding the [@bs.module] decorator
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解[@bs.module]装饰器
- en: To import a node module, use `[@bs.module]`. The compiled output depends on
    the `package-specs` configuration used within `bsconfig.json`. We're using `es6` as
    the module format.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入一个节点模块，使用`[@bs.module]`。编译输出取决于`bsconfig.json`中使用的`package-specs`配置。我们使用`es6`作为模块格式。
- en: '[PRE74]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This compiles to the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成以下内容：
- en: '[PRE75]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Setting the module format to `commonjs` results in the following compiled output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将模块格式设置为`commonjs`会产生以下编译输出：
- en: '[PRE76]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When there is no string argument to `[@bs.module]`, the default value is imported.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当`[@bs.module]`没有字符串参数时，默认值被导入。
- en: Reasonable APIs
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合理的API
- en: When binding to existing JavaScript APIs, think about how you'd like to use
    the API in Reason. Even existing JavaScript APIs that rely heavily on JavaScript's
    dynamic typing can be used in Reason. BuckleScript leverages advanced type system
    techniques that let us take advantage of Reason's type system with such APIs.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定到现有的JavaScript API时，考虑一下你想在Reason中如何使用API。即使是依赖于JavaScript动态类型的现有JavaScript
    API也可以在Reason中使用。BuckleScript利用了高级类型系统技术，让我们能够利用Reason的类型系统来使用这样的API。
- en: 'From the BuckleScript documentation, take a look at the following JavaScript
    function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 从BuckleScript文档中，看一下以下JavaScript函数：
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'If we were to bind to this function in Reason, it would be nice to use `padding`
    as a variant. Here is how we would do that:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在Reason中绑定到这个函数，最好使用`padding`作为一个变体。这是我们将如何做到这一点：
- en: '[PRE78]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This compiles to the following:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这编译成了以下内容：
- en: '[PRE79]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The type of `padLeft` is `(string, some_variant) => string`, where `some_variant` uses
    an advanced type system feature called **polymorphic variant**, which that uses `[@bs.unwrap]`
    to get converted to something JavaScript can understand. We'll learn more about
    polymorphic variants in [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml),
    *Effective ML*.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`padLeft`的类型是`(string, some_variant) => string`，其中`some_variant`使用了一个称为**多态变体**的高级类型系统特性，它使用`[@bs.unwrap]`来转换为JavaScript可以理解的内容。我们将在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml)中了解更多关于多态变体的知识，*Effective
    ML*。'
- en: BuckleScript documentation
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BuckleScript文档
- en: Although this was just a brief introduction, you can see that BuckleScript has
    a lot of tools to help us communicate with idiomatic JavaScript. I highly encourage
    you to read the BuckleScript docs to learn more about JavaScript interoperability.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个简短的介绍，但你可以看到BuckleScript有很多工具可以帮助我们与惯用的JavaScript进行交流。我强烈建议你阅读BuckleScript文档，以了解更多关于JavaScript互操作性的知识。
- en: 'BuckleScript documentation can be found here:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript文档可以在这里找到：
- en: '[https://bucklescript.github.io/docs/interop-overview](https://bucklescript.github.io/docs/interop-overview)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bucklescript.github.io/docs/interop-overview](https://bucklescript.github.io/docs/interop-overview)'
- en: Binding to existing ReactJS components
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定到现有的ReactJS组件
- en: ReactJS components are not Reason components. To use an existing ReactJS component,
    we use `[@bs.module]` to import the node module, and then use the `ReasonReact.wrapJsForReason`
    helper function to convert the ReactJS component to a Reason component. There
    is also a `ReasonReact.wrapReasonForJs` helper function for using Reason in ReactJS.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS组件不是Reason组件。要使用现有的ReactJS组件，我们使用`[@bs.module]`来导入节点模块，然后使用`ReasonReact.wrapJsForReason`辅助函数将ReactJS组件转换为Reason组件。还有一个`ReasonReact.wrapReasonForJs`辅助函数用于在ReactJS中使用Reason。
- en: Let's resume building our app from where we left off in [Chapter 3](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml),
    *Creating ReasonReact Components:*
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从[第3章](21586d11-fa31-446f-99f1-dae3beecdb9b.xhtml)离开的地方继续构建我们的应用程序，*创建ReasonReact组件*：
- en: '[PRE80]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Here, we''ll add route transitions by binding to the existing React Transition
    Group components:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过绑定到现有的React Transition Group组件来添加路由转换：
- en: 'React Transition Group documentation can be found here:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: React Transition Group文档可以在这里找到：
- en: '[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://reactcommunity.org/react-transition-group/](https://reactcommunity.org/react-transition-group/)'
- en: Importing dependencies
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入依赖项
- en: Run `npm install --save react-transition-group` to install the dependency.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm install --save react-transition-group`来安装依赖。
- en: 'Let''s create a new file called `ReactTransitionGroup.re` to house these bindings.
    In this file, we''ll bind to the `TransitionGroup` and `CSSTransition` components:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`ReactTransitionGroup.re`的新文件来存放这些绑定。在这个文件中，我们将绑定到`TransitionGroup`和`CSSTransition`组件：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Creating the make functions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建make函数
- en: Next, we create the components' required `make` functions. This is where we
    use the `ReasonReact.wrapJsForReason` helper function.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建组件所需的`make`函数。这是我们使用`ReasonReact.wrapJsForReason`辅助函数的地方。
- en: 'For `TransitionGroup`, we won''t need any props. Since the `~props` argument
    is required, we pass `Js.Obj.empty()`. The `~reactClass` argument is passed the
    external binding we created in the previous step:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`TransitionGroup`，我们不需要任何props。由于`~props`参数是必需的，我们传递`Js.Obj.empty()`。`~reactClass`参数传递了我们在上一步中创建的外部绑定：
- en: '[PRE82]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Now, `ReactTransitionGroup.TransitionGroup` is a ReasonReact component that
    can be used in our app.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ReactTransitionGroup.TransitionGroup`是一个可以在我们的应用程序中使用的ReasonReact组件。
- en: Using [@bs.deriving abstract]
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用[@bs.deriving abstract]
- en: '`CSSTransitionGroup` will need the following props:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSSTransitionGroup`将需要以下props：'
- en: '`_in`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_in`'
- en: '`timeout`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`'
- en: '`classNames`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`classNames`'
- en: Since `in` is a reserved word in Reason, the convention is to use `_in` in Reason
    and have BuckleScript compile it to `in` for JavaScript using `[@bs.as "in"]`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`in`是Reason中的保留字，惯例是在Reason中使用`_in`，并让BuckleScript将其编译为JavaScript中的`in`，使用`[@bs.as
    "in"]`。
- en: 'BuckleScript provides `[@bs.deriving abstract]` for easily working with certain
    types of JavaScript objects. Instead of creating an object in JavaScript and binding
    to that object, we can create that object directly using BuckleScript:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript提供了`[@bs.deriving abstract]`，可以轻松地处理某些类型的JavaScript对象。我们可以直接使用BuckleScript创建对象，而不是在JavaScript中创建对象并绑定到该对象：
- en: '[PRE83]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Note: `cssTransitionProps` is not a record type, it just looks like one.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`cssTransitionProps`不是一个记录类型，它只是看起来像一个。
- en: 'When using `[@bs.deriving abstract]`, a helper function is automatically provided
    to create JavaScript objects of that shape. This helper function is also named
    `cssTransitionProps`. We use this helper function in the component''s `make` function
    to create the component''s props:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`[@bs.deriving abstract]`时，会自动提供一个辅助函数来创建具有该形状的JavaScript对象。这个辅助函数也被命名为`cssTransitionProps`。我们在组件的`make`函数中使用这个辅助函数来创建组件的props：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using the components
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用组件
- en: 'Now, in `App.re`, we can change the render function to use these components.
    We''ll change this:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`App.re`中，我们可以改变渲染函数来使用这些组件。我们将改变这个：
- en: '[PRE85]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Now it appears as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它看起来是这样的：
- en: '[PRE86]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Note: The key prop is a special ReactJS prop and should not be part of the
    component''s props argument in `ReasonReact.wrapJsForReason`. The same is true
    for the special ReactJS ref prop.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：key属性是一个特殊的ReactJS属性，不应该是组件props参数的一部分在`ReasonReact.wrapJsForReason`中。对于特殊的ReactJS
    ref属性也是如此。
- en: 'For completeness, here is the corresponding CSS, which can be found in `ReactTransitionGroup.scss`:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，以下是相应的CSS，可以在`ReactTransitionGroup.scss`中找到：
- en: '[PRE87]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Be sure to require the preceding in `ReactTransitionGroup.re`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保在`ReactTransitionGroup.re`中要求前述内容：
- en: '[PRE88]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Now, when changing routes, the old route's content animates down and fades out
    before the new route's content animates up and fades in.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当改变路由时，旧路由的内容会向下动画并淡出，然后新路由的内容会向上动画并淡入。
- en: Summary
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: BuckleScript is incredibly powerful because it lets us interoperate with idiomatic
    JavaScript in a very pleasant way. It also provides the Belt standard library,
    which was created with JavaScript in mind. We learned about arrays and lists,
    and we saw how easy it is to use existing ReactJS components within Reason.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: BuckleScript非常强大，因为它让我们以一种非常愉快的方式与惯用的JavaScript进行交互。它还提供了Belt标准库，这是为JavaScript而创建的。我们学习了数组和列表，看到了在Reason中如何轻松地使用现有的ReactJS组件。
- en: In [Chapter 5](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml), *Effective ML*,
    we'll learn about how to use module signatures to hide a component's implementation
    details while building an autocomplete input component. We'll start with hardcoded
    data at first, and in [Chapter 6](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml),
    *CSS-in-JS (in Reason)*, we'll move that data to `localStorage` (client-side web
    storage).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](86a6dec1-1340-4c6c-bdfa-95138e0d471b.xhtml) *Effective ML*中，我们将学习如何使用模块签名来隐藏组件的实现细节，同时构建一个自动完成输入组件。我们将首先使用硬编码数据，然后在[第6章](a6ac6581-d3bd-49f3-ad4d-bfed965287ca.xhtml)
    *CSS-in-JS (in Reason)*中，我们将把数据移到`localStorage`（客户端Web存储）。
