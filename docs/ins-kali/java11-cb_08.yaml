- en: Better Management of the OS Process
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更好地管理操作系统进程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下内容：
- en: Spawning a new process
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个新进程
- en: Redirecting the process output and error streams to file
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进程输出和错误流重定向到文件
- en: Changing the working directory of a subprocess
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更改子进程的工作目录
- en: Setting the environment variable for a subprocess
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为子进程设置环境变量
- en: Running shell scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行shell脚本
- en: Obtaining the process information of the current JVM
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前JVM的进程信息
- en: Obtaining the process information of the spawned process
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取生成的进程的进程信息
- en: Managing the spawned process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理生成的进程
- en: Enumerating live processes in the system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举系统中正在运行的进程
- en: Connecting multiple processes using pipe
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道连接多个进程
- en: Managing subprocesses
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理子进程
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: How often have you ended up writing code that spawns a new process? Not often.
    However, there may have been situations that necessitated the writing of such
    code. In such cases, you had to resort to using a third-party API such as **Apache
    Commons Exec** ([https://commons.apache.org/proper/commons-exec/](https://commons.apache.org/proper/commons-exec/)),
    among others. Why was this? Wasn't the Java API sufficient? No, it wasn't; at
    least not until Java 9\. Now, with Java 9 and above, we have many more features
    added to the process API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次编写了生成新进程的代码？不多。然而，可能有一些情况需要编写这样的代码。在这种情况下，您不得不使用第三方API，如**Apache Commons
    Exec**（[https://commons.apache.org/proper/commons-exec/](https://commons.apache.org/proper/commons-exec/)）等。为什么会这样？Java
    API不够用吗？不，不够用；至少在Java 9之前是这样。现在，有了Java 9及以上版本，我们在进程API中添加了更多功能。
- en: 'Until Java 7, redirecting the input, output, and error streams were not trivial.
    With Java 7, new APIs were introduced, which allowed the redirecting of the input,
    output, and error to other processes (pipe), to a file, or to a standard input/output.
    Then, in Java 8, a few more APIs were introduced. In Java 9, there are now new
    APIs for the following areas:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Java 7，重定向输入、输出和错误流并不是一件简单的事。在Java 7中，引入了新的API，允许将输入、输出和错误重定向到其他进程（管道）、文件或标准输入/输出。然后，在Java
    8中，又引入了一些新的API。在Java 9中，现在有了以下领域的新API：
- en: Getting the process information, such as **Process ID** (**PID**), the user
    who launched the process, the time it has been running for, and so on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取进程信息，如**进程ID**（**PID**）、启动进程的用户、运行时间等
- en: Enumerating the processes running in the system
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举系统中正在运行的进程
- en: Managing the subprocesses and getting access to the process tree by navigating
    up the process hierarchy
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导航到进程层次结构的上层来管理子进程并访问进程树
- en: In this chapter, we will look at a few recipes that will help you explore everything
    that is new in the process API, and you will also get to know the changes that
    have been introduced since the time of `Runtime.getRuntime().exec()`. And you
    all know that using that was a crime.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些配方，这些配方将帮助您探索进程API中的新内容，并了解自`Runtime.getRuntime().exec()`以来引入的更改。而且你们都知道使用那个是犯罪。
- en: 'All these recipes can only be executed on the Linux platform because we will
    be using Linux-specific commands while spawning a new process from Java code. There
    are two ways to execute the script `run.sh` on Linux:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些配方只能在Linux平台上执行，因为我们将在Java代码中使用特定于Linux的命令来生成新进程。在Linux上执行脚本`run.sh`有两种方法：
- en: '`sh run.sh`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sh run.sh`'
- en: '`chmod +x run.sh && ./run.sh`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod +x run.sh && ./run.sh`'
- en: Those who are on Windows 10 need not worry, as Microsoft has released Windows
    Subsystem For Linux, which allows you to run your favorite Linux distributions,
    such as Ubuntu, OpenSuse, and others, on Windows. For more details, check out
    this link: [https://docs.microsoft.com/en-in/windows/wsl/install-win10](https://docs.microsoft.com/en-in/windows/wsl/install-win10).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那些使用Windows 10的人不用担心，因为微软发布了Windows子系统用于Linux，它允许您在Windows上运行您喜欢的Linux发行版，如Ubuntu、OpenSuse等。有关更多详细信息，请查看此链接：[https://docs.microsoft.com/en-in/windows/wsl/install-win10](https://docs.microsoft.com/en-in/windows/wsl/install-win10)。
- en: Spawning a new process
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成新进程
- en: In this recipe, we will see how to spawn a new process using `ProcessBuilder`.
    We will also see how to make use of the input, output, and error streams. This
    should be a very straightforward and common recipe. However, the aim of introducing
    this is to make this chapter a bit more complete and not just to focus on Java
    9 features.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将看到如何使用`ProcessBuilder`生成新进程。我们还将看到如何使用输入、输出和错误流。这应该是一个非常简单和常见的配方。然而，引入这个的目的是为了使本章内容更加完整，而不仅仅是关注Java
    9的特性。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'There is a command in Linux called `free`, which shows the amount of RAM that
    is free and how much is being used by the system. It accepts an option, `-m`,
    to show the output in megabytes. So, just running free `-m` gives us the following
    output:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Linux中有一个名为`free`的命令，它显示系统中空闲的RAM量以及被系统使用的量。它接受一个选项`-m`，以便以兆字节显示输出。因此，只需运行free
    `-m`即可得到以下输出：
- en: '![](img/037b0235-fb00-4a78-8de8-fa94a9246c5b.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/037b0235-fb00-4a78-8de8-fa94a9246c5b.png)'
- en: We will be running the preceding code from within the Java program.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Java程序中运行上述代码。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create an instance of `ProcessBuilder` by providing the required command and
    its options:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过提供所需的命令和选项来创建`ProcessBuilder`的实例：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An alternative way to specify the command and options is as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 指定命令和选项的另一种方法如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Set up the input and output streams for the process builder and other properties,
    such as the directory of execution and environment variables. After that, invoke
    `start()` on the `ProcessBuilder` instance to spawn the process and get a reference
    to the `Process` object:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为进程生成器设置输入和输出流以及其他属性，如执行目录和环境变量。然后，在`ProcessBuilder`实例上调用`start()`来生成进程并获取对`Process`对象的引用：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `inheritIO()` function sets the standard I/O of the spawned subprocess to
    be the same as that of the current Java process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`inheritIO()`函数将生成的子进程的标准I/O设置为与当前Java进程相同。'
- en: 'We then wait for the completion of the process, or for one second (whichever
    is sooner), as shown in the following code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们等待进程的完成，或者等待一秒钟（以先到者为准），如下面的代码所示：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If this doesn't complete in the time specified, then we kill the process by
    invoking the `destroyForcibly()` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在指定的时间内没有完成，我们可以通过调用`destroyForcibly()`方法来终止进程。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output we get is as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/03ef0f79-588a-4721-ab8c-47305fac4e57.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03ef0f79-588a-4721-ab8c-47305fac4e57.png)'
- en: The code for this recipe can be found at `Chapter08/1_spawn_new_process`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的代码可以在`Chapter08/1_spawn_new_process`中找到。
- en: How it works...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'There are two ways to let `ProcessBuilder` know which command to run:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以让`ProcessBuilder`知道要运行哪个命令：
- en: By passing the command and its options to the constructor while creating the
    `ProcessBuilder` object
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在创建`ProcessBuilder`对象时将命令及其选项传递给构造函数
- en: By passing the command and its options as parameters to the `command()` method
    of the `ProcessBuilder` object
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将命令及其选项作为参数传递给`ProcessBuilder`对象的`command()`方法
- en: 'Before spawning the process, we can do the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成进程之前，我们可以执行以下操作：
- en: We can change the directory of execution by using the `directory()` method.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`directory()`方法更改执行目录。
- en: We can redirect the input stream, output stream, and error streams to file or
    to another process.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将输入流、输出流和错误流重定向到文件或另一个进程。
- en: We can provide the required environment variables for the subprocess.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为子进程提供所需的环境变量。
- en: We will see all these activities in their respective recipes in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的各自示例中看到所有这些活动。
- en: 'A new process is spawned when the `start()` method is invoked and the caller
    gets a reference to this subprocess in the form of an instance of the `Process`
    class. Using this `Process` object, we can do a lot of things, such as the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`start()`方法时，将生成一个新的进程，并且调用者以`Process`类的实例形式获得对该子进程的引用。使用这个`Process`对象，我们可以做很多事情，比如以下事情：
- en: Get information about the process, including its PID
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取有关进程的信息，包括其PID
- en: Get the output and error streams
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取输出和错误流
- en: Check for the completion of the process
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查进程的完成情况
- en: Destroy the process
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁进程
- en: Associate the tasks to be performed once the process completes
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任务与进程完成后要执行的操作关联起来
- en: Check for the subprocesses spawned by the process
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查进程生成的子进程
- en: Find the parent process of the process, if it exists
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找进程的父进程（如果存在）
- en: In our recipe, we `waitFor` one second, or for the process to complete (whichever
    occurs first). If the process has completed, then `waitFor` returns `true`; otherwise,
    it returns `false`. If the process doesn't complete, we can kill the process by
    invoking the `destroyForcibly()` method on the `Process` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们等待一秒钟，或者等待进程完成（以先到者为准）。如果进程已完成，则`waitFor`返回`true`；否则返回`false`。如果进程没有完成，我们可以通过在`Process`对象上调用`destroyForcibly()`方法来终止进程。
- en: Redirecting the process output and error streams to file
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将进程输出和错误流重定向到文件
- en: In this recipe, we will see how to deal with the output and error streams of
    a process spawned from the Java code. We will write the output or error produced
    by the spawned process to a file.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何处理从Java代码生成的进程的输出和错误流。我们将把生成的进程产生的输出或错误写入文件。
- en: Getting ready
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we will make use of the `iostat` command. This command is used
    for reporting the CPU and I/O statistics for different devices and partitions.
    Let''s run the command and see what it reports:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将使用`iostat`命令。此命令用于报告不同设备和分区的CPU和I/O统计信息。让我们运行该命令并查看它报告了什么：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In some Linux distributions, such as Ubuntu, `iostat` is not installed by default.
    You can install the utility by running `sudo apt-get install sysstat`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些Linux发行版（如Ubuntu）中，默认情况下未安装`iostat`。您可以通过运行`sudo apt-get install sysstat`来安装该实用程序。
- en: 'The output of the preceding command is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/3eedacb8-42e4-4082-ad1b-854d6f31be17.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3eedacb8-42e4-4082-ad1b-854d6f31be17.png)'
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create a new `ProcessBuilder` object by specifying the command to be executed:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过指定要执行的命令来创建一个新的`ProcessBuilder`对象：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Redirect the output and error streams to the file''s output and error, respectively:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输出和错误流重定向到文件的输出和错误流中：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Start the process and wait for it to complete:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待其完成：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the content of the output file:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取输出文件的内容：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Read the content of the error file. This is created only if there is an error
    in the command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取错误文件的内容。只有在命令出现错误时才会创建此文件：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Steps 4 and 5 are for our reference. This has nothing to do with `ProcessBuilder`
    or the process spawned. Using these two lines of code, we can inspect what was
    written to the output and error files by the process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤4和5是供我们参考的。这与`ProcessBuilder`或生成的进程无关。使用这两行代码，我们可以检查进程写入输出和错误文件的内容。
- en: The complete code can be found at `Chapter08/2_redirect_to_file`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在`Chapter08/2_redirect_to_file`中找到。
- en: 'Compile the code by using the following command:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译代码：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the code by using the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行代码：
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will get the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '![](img/5f927baa-5e79-4813-9aae-060d4d14536d.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5f927baa-5e79-4813-9aae-060d4d14536d.png)'
- en: We can see that as the command executed successfully, there is nothing in the
    error file.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，由于命令成功执行，错误文件中没有任何内容。
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can provide an erroneous command to `ProcessBuilder` and then see the error
    get written to the error file and nothing in the output file. You could do this
    by changing the `ProcessBuilder` instance creation as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以向`ProcessBuilder`提供错误的命令，然后看到错误被写入错误文件，输出文件中没有任何内容。您可以通过更改`ProcessBuilder`实例创建来实现这一点，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run by using the commands given earlier in the *How to do it...*
    section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面在*如何做...*部分中给出的命令进行编译和运行。
- en: 'You will see that there is an error reported in the error file but nothing
    in the output file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到错误文件中报告了一个错误，但输出文件中没有任何内容：
- en: '![](img/4153b745-4da2-4a5e-863c-c38d2f92b1f0.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4153b745-4da2-4a5e-863c-c38d2f92b1f0.png)'
- en: Changing the working directory of a subprocess
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改子进程的工作目录
- en: 'Often, you''ll want a process to be executed in the context of a path, such
    as listing the files in a directory. To do so, we will have to tell `ProcessBuilder`
    to launch the process in the context of a given location. We can achieve this
    by using the `directory()` method. This method serves two purposes:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您会希望在路径的上下文中执行一个进程，比如列出目录中的文件。为了做到这一点，我们将不得不告诉 `ProcessBuilder` 在给定位置的上下文中启动进程。我们可以通过使用
    `directory()` 方法来实现这一点。这个方法有两个目的：
- en: It returns the current directory of execution when we don't pass any parameters.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们不传递任何参数时，它返回执行的当前目录。
- en: It sets the current directory of execution to the passed value when we pass
    a parameter.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们传递参数时，它将执行的当前目录设置为传递的值。
- en: In this recipe, we will see how to execute the
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将看到如何执行
- en: '`tree` command to recursively traverse all the directories from the current
    directory and print it in the form of a tree.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令用于递归遍历当前目录中的所有目录，并以树形式打印出来。'
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Generally, the `tree` command doesn''t come preinstalled, so you will have
    to install the package that contains the command. To install on an Ubuntu/Debian-based
    system, run the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`tree` 命令不是预装的，因此您将不得不安装包含该命令的软件包。要在Ubuntu/Debian系统上安装，请运行以下命令：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To install on Linux, which supports the `yum` package manager, run the following
    command:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要在支持 `yum` 软件包管理器的Linux上安装，请运行以下命令：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To verify your installation, just run the `tree` command, and you should be
    able to see the current directory structure printed. For me, it''s something like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证您的安装，只需运行 `tree` 命令，您应该能够看到当前目录结构的打印。对我来说，它是这样的：
- en: '![](img/d9b3ca66-07fc-4a1d-9127-0f5ee9d94985.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d9b3ca66-07fc-4a1d-9127-0f5ee9d94985.png)'
- en: There are multiple options supported by the `tree` command. It's for you to
    explore.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree` 命令支持多个选项。这是供您探索的。'
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create a new `ProcessBuilder` object:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `ProcessBuilder` 对象：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Set the command to `tree` and the output and error to the same as that of the
    current Java process:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令设置为 `tree`，并将输出和错误设置为与当前Java进程相同的输出和错误：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set the directory to whatever directory you want. I set it as the root folder:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录设置为您想要的任何目录。我将其设置为根文件夹：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Start the process and wait for it to exit:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待其退出：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Compile and run using the following commands:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行编译和运行：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The output will be the recursive contents of the directory, specified in the
    `directory()` method of the `ProcessBuilder` object, printed in a tree-like format.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出将是指定在 `ProcessBuilder` 对象的 `directory()` 方法中的目录的递归内容，以树状格式打印出来。
- en: The complete code can be found at `Chapter08/3_change_work_directory`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在 `Chapter08/3_change_work_directory` 找到。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `directory()` method accepts the path of the working directory for `Process`.
    The path is specified as an instance of `File`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`directory()` 方法接受 `Process` 的工作目录的路径。路径被指定为 `File` 的实例。'
- en: Setting the environment variable for a subprocess
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为子进程设置环境变量
- en: Environment variables are just like any other variables that we have in our
    programming languages. They have a name and hold some value, which can be varied.
    These are used by the Linux/Windows commands or the shell/batch scripts to perform
    different operations. These are called **environment variables** because they
    are present in the environment of the process/command/script being executed. Generally,
    the process inherits the environment variables from the parent process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量就像我们在编程语言中拥有的任何其他变量一样。它们有一个名称并保存一些值，这些值可以变化。这些被Linux/Windows命令或shell/batch脚本用来执行不同的操作。它们被称为**环境变量**，因为它们存在于正在执行的进程/命令/脚本的环境中。通常，进程从父进程继承环境变量。
- en: They are accessed in different ways in different operating systems. In Windows,
    they are accessed as `%ENVIRONMENT_VARIABLE_NAME%`, and in Unix-based operating
    systems, they are accessed as `$ENVIRONMENT_VARIABLE_NAME`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 它们在不同的操作系统中以不同的方式访问。在Windows中，它们被访问为 `%ENVIRONMENT_VARIABLE_NAME%`，在基于Unix的操作系统中，它们被访问为
    `$ENVIRONMENT_VARIABLE_NAME`。
- en: In Unix-based systems, you can use the `printenv` command to print all the environment
    variables available for the process, and in Windows-based systems, you can use
    the `SET` command.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Unix的系统中，您可以使用 `printenv` 命令打印出进程可用的所有环境变量，在基于Windows的系统中，您可以使用 `SET` 命令。
- en: In this recipe, we will pass some environment variables to our subprocess and
    make use of the `printenv` command to print all the environment variables available.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将向子进程传递一些环境变量，并使用 `printenv` 命令打印所有可用的环境变量。
- en: How to do it...
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create an instance of `ProcessBuilder`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `ProcessBuilder` 的实例：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Set the command to `printenv` and the output and error streams to the same
    as that of the current Java process:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将命令设置为 `printenv`，并将输出和错误流设置为与当前Java进程相同的输出和错误：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Provide the environment variables `COOKBOOK_VAR1` with the value `First variable`, `COOKBOOK_VAR2` with
    the value `Second variable`, and `COOKBOOK_VAR3` with the value `Third variable`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供环境变量 `COOKBOOK_VAR1` 的值为 `First variable`，`COOKBOOK_VAR2` 的值为 `Second variable`，以及
    `COOKBOOK_VAR3` 的值为 `Third variable`：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Start the process and wait for it to complete:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待其完成：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The complete code for this recipe can be found at `Chapter08/4_environment_variables`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的完整代码可以在 `Chapter08/4_environment_variables` 找到。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output you get is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您得到的输出如下：
- en: '![](img/8dde13a3-73c4-4d9f-9978-c9157247592d.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8dde13a3-73c4-4d9f-9978-c9157247592d.png)'
- en: You can see the three variables printed among other variables.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到三个变量打印在其他变量中。
- en: How it works...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you invoke the `environment()` method on the instance of `ProcessBuilder`,
    it copies the environment variables of the current process, populates them in
    an instance of `HashMap`, and returns it to the caller code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在`ProcessBuilder`的实例上调用`environment()`方法时，它会复制当前进程的环境变量，将它们填充到`HashMap`的一个实例中，并将其返回给调用者代码。
- en: All the work of loading the environment variables is done by a package private
    final class, `ProcessEnvironment`, which actually extends `HashMap`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 加载环境变量的所有工作都是由一个包私有的最终类`ProcessEnvironment`完成的，它实际上扩展了`HashMap`。
- en: We then make use of this map to populate our own environment variables, but
    we need not set the map back to `ProcessBuilder` because we will have a reference
    to the map object and not a copy. Any changes made to the map object will be reflected
    in the actual map object held by the `ProcessBuilder` instance.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们利用这个映射来填充我们自己的环境变量，但我们不需要将映射设置回`ProcessBuilder`，因为我们将有一个对映射对象的引用，而不是一个副本。对映射对象所做的任何更改都将反映在`ProcessBuilder`实例持有的实际映射对象中。
- en: Running shell scripts
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行shell脚本
- en: We generally collect a set of commands used in performing an operation in a
    file, called a **shell script** in the Unix world and a **batch file** in Windows.
    The commands present in these files are executed sequentially, with the exceptions
    being when you have conditional blocks or loops in the scripts.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会收集在文件中执行操作的一组命令，称为Unix世界中的**shell脚本**和Windows中的**批处理文件**。这些文件中的命令按顺序执行，除非脚本中有条件块或循环。
- en: These shell scripts are evaluated by the shell in which they get executed. Different
    types of shells available are `bash`, `csh`, `ksh`, and so on. The `bash` shell
    is the most commonly used shell.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些shell脚本由它们执行的shell进行评估。可用的不同类型的shell包括`bash`、`csh`、`ksh`等。`bash` shell是最常用的shell。
- en: In this recipe, we will write a simple shell script and then invoke the same
    from the Java code using the `ProcessBuilder` and `Process` objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将编写一个简单的shell脚本，然后使用`ProcessBuilder`和`Process`对象从Java代码中调用它。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'First, let''s write our shell script. This script does the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写我们的shell脚本。这个脚本做了以下几件事：
- en: Prints the value of the environment variable, `MY_VARIABLE`
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印环境变量`MY_VARIABLE`的值
- en: Executes the `tree` command
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`tree`命令
- en: Executes the `iostat` command
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`iostat`命令
- en: 'Let''s create a shell script file by the name, `script.sh`, with the following
    commands in it:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`script.sh`的shell脚本文件，其中包含以下命令：
- en: '[PRE26]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can place the `script.sh` in your home folder; that is, in the `/home/<username>`.
    Now let's see how we can execute this from Java.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`script.sh`放在您的主文件夹中；也就是说，在`/home/<username>`中。现在让我们看看我们如何从Java中执行它。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create a new instance of `ProcessBuilder`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ProcessBuilder`的一个新实例：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Set the directory of execution to point to the directory of the shell script
    file:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将执行目录设置为指向shell脚本文件的目录：
- en: '[PRE28]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that the previous path passed, while creating the `File` object will depend
    on where you have placed your script `script.sh`. In our case, we had it placed
    in `/root`. You might have copied the script in `/home/yourname` and, accordingly,
    the `File` object will be created as `newFile("/home/yourname")`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在创建`File`对象时传递的先前路径将取决于您放置脚本`script.sh`的位置。在我们的情况下，我们将它放在`/root`中。您可能已经将脚本复制到了`/home/yourname`中，因此`File`对象将相应地创建为`newFile("/home/yourname")`。
- en: 'Set an environment variable that would be used by the shell script:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个将被shell脚本使用的环境变量：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Set the command to be executed, and also the arguments to be passed to the
    command. Also, set the output and error streams for the process to same as that
    of the current Java process:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置要执行的命令，以及要传递给命令的参数。还要将进程的输出和错误流设置为与当前Java进程相同的流：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Start the process and wait for it to execute completely:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动进程并等待它完全执行：
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can get the complete code from `Chapter08/5_running_shell_script`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/5_running_shell_script`获取完整的代码。
- en: 'You can compile and run the code by using the following commands:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令编译和运行代码：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output we get is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/c3f299bd-4969-4329-b0d4-14440e75e29b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3f299bd-4969-4329-b0d4-14440e75e29b.png)'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'You must make a note of two things in this recipe:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您必须记下两件事：
- en: Change the working directory of the process to the location of the shell script.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将进程的工作目录更改为shell脚本的位置。
- en: Use `/bin/bash` to execute the shell script.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`/bin/bash`执行shell脚本。
- en: If you don't make a note of step 1, then you'll have to use the absolute path
    for the shell script file. However, in this recipe, we did do this, and hence
    we just use the shell script name for the `/bin/bash` command.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有记下第一步，那么你将不得不使用shell脚本文件的绝对路径。然而，在这个示例中，我们做了这个，因此我们只需使用shell脚本名称来执行`/bin/bash`命令。
- en: 'Step 2 is basically how you would want to execute the shell script. The way
    to do so is to pass the shell script to the interpreter, which will interpret
    and execute the script. That is what the following line of code does:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步基本上是您希望执行shell脚本的方式。要执行此操作的方法是将shell脚本传递给解释器，解释器将解释和执行脚本。以下代码行就是这样做的：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Obtaining the process information of the current JVM
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取当前JVM的进程信息
- en: 'A running process has a set of attributes associated with it, such as the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的进程有一组与之关联的属性，例如以下内容：
- en: '**PID**: This uniquely identifies the process'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PID**：这个唯一标识进程'
- en: '**Owner**: This is the name of the user who launched the process'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有者**：这是启动进程的用户的名称'
- en: '**Command**: This is the command that runs under the process'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令**：这是在进程下运行的命令'
- en: '**CPU time**: This indicates the time for which the process has been active'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU时间**：这表示进程已经活动的时间'
- en: '**Start time**: This indicates the time when the process was launched'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始时间**：这表示进程启动的时间'
- en: These are a few attributes that we are generally interested in. Perhaps we would
    also be interested in CPU usage or memory usage. Now, getting this information
    from within Java was not possible prior to Java 9\. However, in Java 9, a new
    set of APIs has been introduced, which enables us to get the basic information
    about the process.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们通常感兴趣的一些属性。也许我们还对CPU使用率或内存使用率感兴趣。现在，在Java 9之前，从Java中获取这些信息是不可能的。然而，在Java
    9中，引入了一组新的API，使我们能够获取有关进程的基本信息。
- en: In this recipe, we will see how to get the process information for the current
    Java process; that is, the process that is executing your code.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在本示例中，我们将看到如何获取当前Java进程的进程信息；也就是说，正在执行您的代码的进程。
- en: How to do it...
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Create a simple class and use `ProcessHandle.current()` to get `ProcessHandle`
    for the current Java process:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个简单的类，并使用`ProcessHandle.current()`来获取当前Java进程的`ProcessHandle`：
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have added some code, which will add some running time to the code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一些代码，这将为代码增加一些运行时间：
- en: '[PRE35]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `info()` method on the instance of `ProcessHandle` to get an instance
    of `ProcessHandle.Info`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProcessHandle`实例上使用`info()`方法获取`ProcessHandle.Info`的实例：
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the instance of `ProcessHandle.Info` to get all the information made available
    by the interface:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle.Info`的实例获取接口提供的所有信息：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Use the `pid()` method of `ProcessHandle` to get the process ID of the current
    Java process:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle`的`pid()`方法获取当前Java进程的进程ID：
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will also print the end time using the time at which the code is about to
    end. This will give us an idea of the execution time of the process:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将打印结束时间，使用代码即将结束时的时间。这将让我们了解进程的执行时间：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can get the complete code from `Chapter08/6_current_process_info`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/6_current_process_info`获取完整的代码。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output you see will be something like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到的输出将类似于这样：
- en: '![](img/303f0d5c-4fbf-4752-8208-859e18cbe6d3.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303f0d5c-4fbf-4752-8208-859e18cbe6d3.png)'
- en: It will take some time until the program completes execution.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 程序执行完成需要一些时间。
- en: One observation to be made is that even if the program ran for around two minutes,
    the total CPU duration was 350 millisecond. This is the time period during which
    the CPU was busy.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，即使程序运行了大约两分钟，总CPU持续时间也只有350毫秒。这是CPU繁忙的时间段。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To give more control to the native processes and get its information, a new
    interface called `ProcessHandle` has been added to the Java API. Using `ProcessHandle`,
    you can control the process execution as well as get some information about the
    process. The interface has another inner interface called `ProcessHandle.Info`.
    This interface provides APIs to get information about the process.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给本地进程更多的控制并获取其信息，Java API中添加了一个名为`ProcessHandle`的新接口。使用`ProcessHandle`，您可以控制进程执行并获取有关进程的一些信息。该接口还有一个名为`ProcessHandle.Info`的内部接口。该接口提供了一些API来获取有关进程的信息。
- en: 'There are multiple ways to get hold of the `ProcessHandle` object for a process.
    Some of the ways are as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以获取进程的`ProcessHandle`对象。以下是其中一些方法：
- en: '`ProcessHandle.current()`: This is used to get the `ProcessHandle` instance
    for the current Java process.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessHandle.current()`: 用于获取当前Java进程的`ProcessHandle`实例。'
- en: '`Process.toHandle()`: This is used to get the `ProcessHandle` for a given `Process`
    object.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process.toHandle()`: 用于获取给定`Process`对象的`ProcessHandle`。'
- en: '`ProcessHandle.of(pid)`: This is used to get `ProcessHandle` for a process
    identified by the given PID.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessHandle.of(pid)`: 用于获取由给定PID标识的进程的`ProcessHandle`。'
- en: In our recipe, we make use of the first approach, that is, we use `ProcessHandle.current()`.
    This gives us a handle on the current Java process. Invoking the `info()` method
    on the `ProcessHandle` instance will give us an instance of the implementation
    of the `ProcessHandle.Info` interface, which we can make use of to get the process
    information, as shown in the recipe code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用第一种方法，即使用`ProcessHandle.current()`。这使我们可以处理当前的Java进程。在`ProcessHandle`实例上调用`info()`方法将为我们提供`ProcessHandle.Info`接口的实现的实例，我们可以利用它来获取进程信息，如示例代码所示。
- en: '`ProcessHandle` and `ProcessHandle.Info` are interfaces. The JDK provide either
    Oracle JDK or Open JDK, will provide implementations for these interfaces. Oracle
    JDK has a class called `ProcessHandleImpl`, which implements `ProcessHandle` and
    another inner class within `ProcessHandleImpl` called `Info`, which implements
    the `ProcessHandle.Info` interface. So, whenever you call one of the aforementioned
    methods to get a `ProcessHandle` object, an instance of `ProcessHandleImpl` is
    returned.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProcessHandle`和`ProcessHandle.Info`都是接口。JDK提供的Oracle JDK或Open JDK将为这些接口提供实现。Oracle
    JDK有一个名为`ProcessHandleImpl`的类，它实现了`ProcessHandle`，还有一个名为`Info`的`ProcessHandleImpl`内部类，它实现了`ProcessHandle.Info`接口。因此，每当调用上述方法之一来获取`ProcessHandle`对象时，都会返回`ProcessHandleImpl`的实例。'
- en: The same goes with the `Process` class as well. It is an abstract class and
    Oracle JDK provides an implementation called `ProcessImpl`, which implements the
    abstract methods in the `Process` class.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`类也是如此。它是一个抽象类，Oracle JDK提供了一个名为`ProcessImpl`的实现，该实现实现了`Process`类中的抽象方法。'
- en: In all the recipes in this chapter, any mention of the instance of `ProcessHandle`
    or the `ProcessHandle` object will refer to the instance or object of `ProcessHandleImpl`
    or any other implementation class provided by the JDK you are using.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的所有示例中，对`ProcessHandle`实例或`ProcessHandle`对象的任何提及都将指的是`ProcessHandleImpl`的实例或对象，或者是您正在使用的JDK提供的任何其他实现类。
- en: Also, any mention of the instance of `ProcessHandle.Info` or the `ProcessHandle.Info`
    object will refer to the instance or object of `ProcessHandleImpl.Info` or any
    other implementation class provided by the JDK you are using.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对`ProcessHandle.Info`的实例或`ProcessHandle.Info`对象的任何提及都将指的是`ProcessHandleImpl.Info`的实例或对象，或者是您正在使用的JDK提供的任何其他实现类。
- en: Obtaining the process information of the spawned process
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取生成的进程的进程信息
- en: In our previous recipe, we saw how to get the process information for the current
    Java process. In this recipe, we will look at how to get the process information
    for a process spawned by the Java code; that is, by the current Java process.
    The APIs used will be the same as we saw in the previous recipe, except for the
    way the instance of `ProcessHandle` is implemented.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们看到了如何获取当前Java进程的进程信息。在这个示例中，我们将看看如何获取由Java代码生成的进程的进程信息；也就是说，由当前Java进程生成的进程。使用的API与我们在之前的示例中看到的相同，只是`ProcessHandle`实例的实现方式不同。
- en: Getting ready
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will make use of a Unix command, `sleep`, which is used to
    pause the execution for a period of time in seconds.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用Unix命令`sleep`，它用于暂停执行一段时间（以秒为单位）。
- en: How to do it...
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Spawn a new process from the Java code, which runs the `sleep` command:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Java代码中生成一个新的进程，运行`sleep`命令：
- en: '[PRE41]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Get the `ProcessHandle` instance for this spawned process:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取此生成的进程的`ProcessHandle`实例：
- en: '[PRE42]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Wait for the spawned process to complete execution:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待生成的进程完成执行：
- en: '[PRE43]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use `ProcessHandle` to get the `ProcessHandle.Info` instance, and use its APIs
    to get the required information. Alternatively, we can even use the `Process`
    object directly to get `ProcessHandle.Info` by using the `info()` method in the
    `Process` class:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessHandle`获取`ProcessHandle.Info`实例，并使用其API获取所需信息。或者，我们甚至可以直接使用`Process`对象通过`Process`类中的`info()`方法获取`ProcessHandle.Info`：
- en: '[PRE44]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can get the complete code from `Chapter08/7_spawned_process_info`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/7_spawned_process_info`获取完整的代码。
- en: 'Compile and run the code by using the following commands:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令编译和运行代码：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Alternatively, there is a `run.sh` script in `Chapter08/7_spawned_process_info`,
    which you can run from any Unix-based system as `/bin/bash run.sh`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，在`Chapter08/7_spawned_process_info`中有一个`run.sh`脚本，您可以在任何基于Unix的系统上运行`/bin/bash
    run.sh`。
- en: 'The output you see will be something like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到的输出将类似于这样：
- en: '![](img/57dda7ad-1e90-4d94-b97b-c79d84cc1a8c.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57dda7ad-1e90-4d94-b97b-c79d84cc1a8c.png)'
- en: Managing the spawned process
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理生成的进程
- en: There are a few methods, such as `destroy()`, `destroyForcibly()` (added in
    Java 8), `isAlive()` (added in Java 8), and `supportsNormalTermination()` (added
    in Java 9), which can be used to control the process spawned. These methods are
    available on the `Process` object as well as on the `ProcessHandle` object. Here,
    controlling would be just to check whether the process is alive, and if it is,
    then destroy the process.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些方法，如`destroy()`、`destroyForcibly()`（在Java 8中添加）、`isAlive()`（在Java 8中添加）和`supportsNormalTermination()`（在Java
    9中添加），可以用于控制生成的进程。这些方法既可以在`Process`对象上使用，也可以在`ProcessHandle`对象上使用。在这里，控制只是检查进程是否存活，如果是，则销毁进程。
- en: 'In this recipe, we will spawn a long-running process and do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将生成一个长时间运行的进程，并执行以下操作：
- en: Check for its liveliness
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查其是否存活
- en: Check whether it can be stopped normally; that is, depending on the platform,
    the process has to be stopped by just using destroy or by using force destroy
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查它是否可以正常停止；也就是说，根据平台的不同，进程可以通过destroy或force destroy来停止
- en: Stop the process
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止进程
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Spawn a new process from the Java code, which runs the `sleep` command for,
    say, one minute, or 60 seconds:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Java代码中生成一个新的进程，运行`sleep`命令，比如一分钟或60秒：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Wait for, say, 10 seconds:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待，比如10秒：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Check whether the process is alive:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程是否存活：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Check whether the process can be stopped normally:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查进程是否可以正常停止：
- en: '[PRE49]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Stop the process and check for its liveliness:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止进程并检查其是否存活：
- en: '[PRE50]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can get the complete code from `Chapter08/8_manage_spawned_process`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/8_manage_spawned_process`获取完整的代码。
- en: We have provided a utility script called `run.sh`, which you can use to compile
    and run the code—`sh run.sh`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码——`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/6d0480b0-fdf0-4d29-b521-9fac1bba1855.png)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d0480b0-fdf0-4d29-b521-9fac1bba1855.png)'
- en: If we run the program on Windows, `supportsNormalTermination()` returns `false`,
    but on Unix `supportsNormalTermination()` returns `true` (as seen in the preceding
    output as well).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Windows上运行程序，`supportsNormalTermination()`返回`false`，但在Unix上，`supportsNormalTermination()`返回`true`（如前面的输出中所见）。
- en: Enumerating live processes in the system
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举系统中的活动进程
- en: In Windows, you open the Windows Task Manager to view the processes currently
    active, and in Linux you use the `ps` command with its varied options to view
    the processes along with other details, such as user, time spent, command, and
    so on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，您可以打开Windows任务管理器来查看当前活动的进程，在Linux中，您可以使用`ps`命令及其各种选项来查看进程以及其他详细信息，如用户、时间、命令等。
- en: In Java 9, a new API was added, called `ProcessHandle`, which deals with controlling
    and getting information about the processes. One of the methods of the API is `allProcesses()`,
    which returns a snapshot of all the processes visible to the current process.
    In this recipe, we will look at how the method works and what information we can
    extract from the API.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，添加了一个名为`ProcessHandle`的新API，用于控制和获取有关进程的信息。API的一个方法是`allProcesses()`，它返回当前进程可见的所有进程的快照。在这个示例中，我们将看看这个方法的工作原理以及我们可以从API中提取的信息。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤进行：
- en: 'Use the `allProcesses()` method on the `ProcessHandle` interface to get a stream
    of the currently active processes:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProcessHandle`接口上使用`allProcesses()`方法，以获取当前活动进程的流：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Iterate over the stream using `forEach()`, and pass a lambda expression to
    print the details available:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach()`迭代流，并传递lambda表达式以打印可用的详细信息：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can get the complete code from `Chapter08/9_enumerate_all_processes`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/9_enumerate_all_processes`获取完整的代码。
- en: We have provided a utility script called `run.sh`, which you can use to compile
    and run the code—`sh run.sh`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码——`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/0f66a1d3-6f82-42f0-83ec-d85d96fdda0a.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f66a1d3-6f82-42f0-83ec-d85d96fdda0a.png)'
- en: In the preceding output, we are printing the command name as well as the user
    of the process. We have shown a small part of the output.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们打印了命令名称以及进程的用户。我们展示了输出的一小部分。
- en: Connecting multiple processes using pipe
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用管道连接多个进程
- en: In Unix, it's common to pipe a set of commands together using the `|` symbol
    to create a pipeline of activities, where the input for the command is the output
    from the previous command. This way, we can process the input to get the desired
    output.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，通常使用`|`符号将一组命令连接在一起，以创建一系列活动的管道，其中命令的输入是前一个命令的输出。这样，我们可以处理输入以获得所需的输出。
- en: A common scenario is when you want to search for something or a pattern in the
    log files, or for an occurrence of some text in the log file. In such scenarios,
    you can create a pipeline, wherein you pass the required log file data via a series
    of commands, namely, `cat`, `grep`, `wc -l`, and so on.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的场景是当您想要在日志文件中搜索某些内容或模式，或者在日志文件中搜索某些文本的出现时。在这种情况下，您可以创建一个管道，通过一系列命令，即`cat`、`grep`、`wc
    -l`等，传递所需的日志文件数据。
- en: In this recipe, we will make use of the Iris dataset from the UCI machine learning
    repository available at [https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris) to
    create a pipeline, wherein we will count the number of occurrences of each type
    of flower.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用UCI机器学习库中提供的Iris数据集（[https://archive.ics.uci.edu/ml/datasets/Iris](https://archive.ics.uci.edu/ml/datasets/Iris)）创建一个管道，我们将统计每种花的出现次数。
- en: Getting ready
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We have already downloaded the Iris Flower Dataset ([https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)),
    which can be found at `Chapter08/10_connecting_process_pipe/iris.data` of the
    code download for this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经下载了Iris Flower数据集（[https://archive.ics.uci.edu/ml/datasets/iris](https://archive.ics.uci.edu/ml/datasets/iris)），可以在本书的代码下载中的`Chapter08/10_connecting_process_pipe/iris.data`中找到。
- en: 'If you happen to look at the `Iris` data, you will see there are 150 rows in
    the following format:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看`Iris`数据，您会看到以下格式的150行：
- en: '[PRE53]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, there are multiple attributes separated by a comma (`,`), and the attributes
    are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，有多个由逗号（`,`）分隔的属性，属性如下：
- en: Sepal length in cm
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼长度（厘米）
- en: Sepal width in cm
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花萼宽度（厘米）
- en: Petal length in cm
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣长度（厘米）
- en: Petal width in cm
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 花瓣宽度（厘米）
- en: 'Class:'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别：
- en: Iris setosa
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris setosa
- en: Iris versicolour
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris versicolour
- en: Iris virginica
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Iris virginica
- en: In this recipe, we will find the total number of flowers in each class, namely
    setosa, versicolour, and virginica.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将找到每个类别中花的总数，即setosa、versicolour和virginica。
- en: 'We will make use of a pipeline with the following commands (using a Unix-based
    operating system):'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令的管道（使用基于Unix的操作系统）：
- en: '[PRE54]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The output we get is as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '[PRE55]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The 1 at the end is for the new line available at the end of the file. So,
    there are 50 flowers of each class. Let''s dissect the above shell command pipeline
    and understand the function of each of them:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 末尾的1表示文件末尾有一个新行。所以每个类别有50朵花。让我们解析上面的shell命令管道并理解它们各自的功能：
- en: '`cat`: This command reads the file given as the argument.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cat`：此命令读取作为参数给定的文件。'
- en: '`cut`: This splits each line by using the character given in the `-d` option
    and returns the value in the column identified by the `-f` option.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cut`：这使用`-d`选项中给定的字符拆分每一行，并返回由`-f`选项标识的列中的值。'
- en: '`uniq`: This returns a unique list from the given values, and when the `-c`
    option is used, it returns how many times each unique value is present in the
    list.'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniq`：这从给定的值返回一个唯一列表，当使用`-c`选项时，它返回列表中每个唯一值的出现次数。'
- en: How to do it...
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤
- en: 'Create a list of `ProcessBuilder` objects, which will hold the `ProcessBuilder` instances
    participating in our pipeline. Also, redirect the output of the last process in
    the pipeline to the standard output of the current Java process:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ProcessBuilder`对象的列表，其中将保存参与我们的管道的`ProcessBuilder`实例。还将管道中最后一个进程的输出重定向到当前Java进程的标准输出：
- en: '[PRE56]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Use the `startPipeline()` method of `ProcessBuilder` and pass the list of `ProcessBuilder`
    objects to start the pipeline. It will return a list of `Process` objects, each
    representing a `ProcessBuilder` object in the list:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ProcessBuilder`的`startPipeline()`方法，并传递`ProcessBuilder`对象的列表以启动管道。它将返回一个`Process`对象的列表，每个对象代表列表中的一个`ProcessBuilder`对象：
- en: '[PRE57]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Get the last process in the list and `waitFor` it to complete:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取列表中的最后一个进程并`waitFor`它完成：
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can get the complete code from `Chapter08/10_connecting_process_pipe`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/10_connecting_process_pipe`获取完整的代码。
- en: We have provided a utility script called `run.sh`, which you can use to compile
    and run the code—`sh run.sh`.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码——`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/1a049dae-3fd1-4fc8-b049-ec623e088e4d.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1a049dae-3fd1-4fc8-b049-ec623e088e4d.png)'
- en: How it works...
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: 'The `startPipeline()` method starts a `Process` for each `ProcessBuilder` object
    in the list. Except for the first and the last processes, it redirects the output
    of one process to the input of another process by using `ProcessBuilder.Redirect.PIPE`.
    If you have provided `redirectOutput` for any intermediate process as something
    other than `ProcessBuilder.Redirect.PIPE`, then there will be an error thrown;
    something similar to the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`startPipeline()`方法为列表中的每个`ProcessBuilder`对象启动一个`Process`。除了第一个和最后一个进程外，它通过使用`ProcessBuilder.Redirect.PIPE`将一个进程的输出重定向到另一个进程的输入。如果您为任何中间进程提供了`redirectOutput`，而不是`ProcessBuilder.Redirect.PIPE`，那么将会抛出错误；类似于以下内容：'
- en: '[PRE59]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: It states that any builder except for the last should redirect its output to
    the next process. The same is applicable for `redirectInput`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 它指出除了最后一个之外的任何构建器都应将其输出重定向到下一个进程。对于`redirectInput`也是适用的。
- en: Managing subprocesses
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理子进程
- en: When a process launches another process, the launched process becomes the subprocess
    of the launching process. The launched process, in turn, can launch another process,
    and this chain can continue. This results in a process tree. Often, we would have
    to deal with a buggy subprocess and might want to kill that subprocess, or we
    might want to know the subprocesses that are launched and might want to get some
    information about them.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个进程启动另一个进程时，启动的进程成为启动进程的子进程。启动的进程反过来可以启动另一个进程，这个链条可以继续下去。这导致了一个进程树。通常，我们可能需要处理一个有错误的子进程，可能想要终止该子进程，或者可能想要知道启动的子进程并可能想要获取有关它们的一些信息。
- en: In Java 9, two new APIs in the `Process` class were added—`children()` and `descendants()`.
    The `children()` API allows you to get a list of the snapshot of processes that
    are the immediate children of the current process, and the `descendants()` API
    provides a snapshot of processes that are recursively `children()` of the current
    process; that is, they are invoking `children()` recursively on each child process.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 9中，`Process`类中添加了两个新的API——`children()`和`descendants()`。`children()` API允许您获取当前进程的直接子进程的快照列表，而`descendants()`
    API提供了当前进程递归`children()`的进程的快照；也就是说，它们在每个子进程上递归地调用`children()`。
- en: In this recipe, we will look at both the `children()` and `descendants()` APIs
    and see what information we can gather from the snapshot of the process.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看`children()`和`descendants()` API，并看看我们可以从进程的快照中收集到什么信息。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Let''s create a simple shell script, which we will be using in the recipe.
    This script can be found at `Chapter08/11_managing_sub_process/script.sh`:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的shell脚本，我们将在配方中使用它。此脚本可以在`Chapter08/11_managing_sub_process/script.sh`中找到：
- en: '[PRE60]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding script, we are running the commands, `tree` and `iostat`, separated
    by a sleep time of one minute. If you want to know about these commands, please
    refer to the *Running shell scripts* recipe of this chapter. The sleep command,
    when executed from within the bash shell, creates a new subprocess each time it
    is invoked.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述脚本中，我们运行了`tree`和`iostat`命令，中间用一分钟的睡眠时间分隔。如果您想了解这些命令，请参考本章的*运行shell脚本*配方。当从bash
    shell中执行时，睡眠命令每次被调用时都会创建一个新的子进程。
- en: We will create, say, 10 instances of `ProcessBuilder` to run the preceding shell
    script and launch them simultaneously.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建，比如说，10个`ProcessBuilder`实例来运行上述的shell脚本并同时启动它们。
- en: How to do it...
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will create 10 instances of `ProcessBuilder` to run our shell script (available
    at `Chapter08/11_managing_sub_process/script.sh`). We are not concerned with its
    output, so let''s discard the output of the commands by redirecting the output
    to a predefined redirect called `ProcessHandle.Redirect.DISCARD`:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建10个`ProcessBuilder`实例来运行我们的shell脚本（位于`Chapter08/11_managing_sub_process/script.sh`）。我们不关心它的输出，所以让我们通过将输出重定向到预定义的重定向`ProcessHandle.Redirect.DISCARD`来丢弃命令的输出：
- en: '[PRE61]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Get the handle for the current process:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前进程的句柄：
- en: '[PRE62]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use the current process to get its children using the `children()` API and
    iterate over each of its children to print their information. Once we have an
    instance of `ProcessHandle`, we can do multiple things, such as destroy the process,
    get its process information, and so on:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前进程通过`children()` API获取其子进程，并迭代每个子进程以打印它们的信息。一旦我们有了`ProcessHandle`的实例，我们可以做多种事情，比如销毁进程，获取其进程信息等。
- en: '[PRE63]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Use the current process to get all the subprocesses that are its descendants
    by using the `descendants()` API and iterate over each of them to print their
    information:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用当前进程通过使用`descendants()` API获取所有子进程，然后迭代每个子进程以打印它们的信息：
- en: '[PRE64]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: You can get the complete code from `Chapter08/11_managing_sub_process`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从`Chapter08/11_managing_sub_process`获取完整的代码。
- en: We have provided a utility script called `run.sh`, which you can use to compile
    and run the code—`sh run.sh`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个名为`run.sh`的实用脚本，您可以使用它来编译和运行代码——`sh run.sh`。
- en: 'The output we get is as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的输出如下：
- en: '![](img/2b31919e-2b42-449a-9838-34099c00b560.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2b31919e-2b42-449a-9838-34099c00b560.png)'
- en: How it works...
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The APIs `children()` and `descendants()` return the `Stream` of the `ProcessHandler`
    for each of the processes, which are either direct children or descendants of
    the current process. Using the instance of `ProcessHandler`, we can perform the
    following operations:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '`children()`和`descendants()` API返回当前进程的直接子进程或后代进程的`ProcessHandler`的`Stream`。使用`ProcessHandler`的实例，我们可以执行以下操作：'
- en: Get the process information
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取进程信息
- en: Check the status of the process
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查进程的状态
- en: Stop the process
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止进程
