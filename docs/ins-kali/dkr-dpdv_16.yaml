- en: '14: Deploying apps with Docker Stacks'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14：使用Docker堆栈部署应用程序
- en: Deploying and managing multi-service apps at scale is hard.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在规模上部署和管理多服务应用程序是困难的。
- en: Fortunately, Docker Stacks are here to help! They simplify application management
    by providing; *desired state, rolling updates, simple, scaling operations, health
    checks,* and more! All wrapped in a nice declarative model. Love it!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker堆栈在这里帮忙！它们通过提供*期望状态、滚动更新、简单的扩展操作、健康检查*等等来简化应用程序管理，所有这些都包含在一个很好的声明模型中。太棒了！
- en: Now then, if these buzzwords are new to you or sound complicated, don’t worry!
    You’ll understand them all by the end of the chapter!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果这些术语对您来说是新的或听起来很复杂，不要担心！在本章结束时，您将理解它们！
- en: 'We’ll split this chapter into the usual three parts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章分为通常的三个部分：
- en: The TLDR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之
- en: The deep dive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入了解
- en: The commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Deploying apps with Docker Stacks - The TLDR
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Docker堆栈部署应用程序-简而言之
- en: Testing and deploying simple apps on your laptop is easy. But that’s for amateurs.
    Deploying and managing multi-service apps, in real-world production environments…
    That’s for pro’s!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的笔记本电脑上测试和部署简单的应用程序很容易。但那是给业余爱好者的。在现实世界的生产环境中部署和管理多服务应用程序……那是给专业人士的！
- en: Fortunately, stacks are here to help!. They let you define complex multi-service
    apps in a single declarative file. They also provide a simple way deploy the app
    and manage its entire lifecycle — initial deployment > health checks > scaling
    > updates > rollbacks and more!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，堆栈在这里帮忙！它们让您在单个声明文件中定义复杂的多服务应用程序。它们还提供了一种简单的方式来部署应用程序并管理其整个生命周期-初始部署>健康检查>扩展>更新>回滚等等！
- en: The process is simple. Define your app in a *Compose file*, then deploy and
    manage it with the `docker stack deploy` command. That’s it!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程很简单。在*Compose文件*中定义您的应用程序，然后使用`docker stack deploy`命令部署和管理它。就是这样！
- en: The Compose file includes the entire stack of services that make up the app.
    It also includes all of the volumes, networks, secrets, and other infrastructure
    the app needs. You then use the `docker stack deploy` command to deploy the app
    from the file. Simple.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Compose文件包括组成应用程序的整个服务堆栈。它还包括应用程序需要的所有卷、网络、秘密和其他基础设施。然后，您可以使用`docker stack deploy`命令从文件部署应用程序。简单。
- en: To accomplish all of this, stacks build on top of Docker Swarm, meaning you
    get all of the security and advanced features that come with Swarm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成所有这些，堆栈建立在Docker Swarm之上，这意味着您可以获得与Swarm一起使用的所有安全性和高级功能。
- en: In a nutshell, Docker is great for development and testing. Docker Stacks are
    great for scale and production!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Docker非常适合开发和测试。Docker堆栈非常适合规模和生产！
- en: Deploying apps with Docker Stacks - The Deep Dive
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Docker堆栈部署应用程序-深入了解
- en: If you know Docker Compose, you’ll find Docker Stacks really easy. In fact,
    in many ways, stacks are what we always wished Compose was — fully integrated
    into Docker, and able to manage the entire lifecycle of applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您了解Docker Compose，您会发现Docker堆栈非常容易。实际上，在许多方面，堆栈是我们一直希望Compose是-完全集成到Docker中，并能够管理应用程序的整个生命周期。
- en: Architecturally speaking, stacks are at the top of the Docker application hierarchy.
    They build on top of *services*, which in turn build on top of containers. See
    Figure 14.1.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从架构上讲，堆栈位于Docker应用程序层次结构的顶部。它们建立在*服务*之上，而服务又建立在容器之上。见图14.1。
- en: '![Figure 14.1 AtSea Shop high level architecture](images/figure14-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 AtSea Shop高级架构](images/figure14-1.png)'
- en: Figure 14.1 AtSea Shop high level architecture
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 AtSea Shop高级架构
- en: 'We’ll divide this section of the chapter as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章的这一部分分为以下几个部分：
- en: Overview of the sample app
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例应用程序概述
- en: Looking closer at the stack file
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更仔细地查看堆栈文件
- en: Deploying the app
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: Managing the app
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序
- en: Overview of the sample app
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 示例应用程序概述
- en: For the rest of the chapter, we’ll be using the popular **AtSea Shop** demo
    app. It lives on [GitHub](https://github.com/dockersamples/atsea-sample-shop-app)
    and is open-sourced under the [Apache 2.0 license](https://github.com/dockersamples/atsea-sample-shop-app/blob/master/LICENSE).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将使用流行的**AtSea Shop**演示应用程序。它位于[GitHub](https://github.com/dockersamples/atsea-sample-shop-app)，并在[Apache
    2.0许可证](https://github.com/dockersamples/atsea-sample-shop-app/blob/master/LICENSE)下开源。
- en: We’re using this app because it’s moderately complicated without being too big
    to list and describe in a book. Beneath the covers, it’s a multi-technology microservices
    app that leverages certificates and secrets. The high-level application architecture
    is shown in Figure 14.2.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个应用程序，因为它在不太大到无法在书中列出和描述的情况下，具有适度的复杂性。在底层，它是一个利用证书和密钥的多技术微服务应用程序。高级应用程序架构如图14.2所示。
- en: '![Figure 14.2 AtSea Shop high level architecture](images/figure14-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 AtSea Shop高级架构](images/figure14-2.png)'
- en: Figure 14.2 AtSea Shop high level architecture
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 AtSea Shop高级架构
- en: As we can see, it comprises 5 *Services*, 3 networks, 4 secrets, and 3 port
    mappings. We’ll see each of these in detail when we inspect the stack file.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，它包括5个*服务*，3个网络，4个秘密和3个端口映射。当我们检查堆栈文件时，我们将详细了解每一个。
- en: '**Note:** When referring to *services* in this chapter, we’re talking about
    Docker Services (a collection of containers managed as a single object and the
    service object that exists in the Docker API).'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**在本章中提到*服务*时，我们指的是Docker服务（作为单个对象管理的容器集合和存在于Docker API中的服务对象）。'
- en: Clone the application’s GitHub repo so that you have all of the application
    source files on your local machine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆应用程序的GitHub存储库，以便在本地机器上拥有所有应用程序源文件。
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`The application consists of several directories and source files. Feel free
    to explore them all. However, we’re going to focus on the `docker-stack.yml` file.
    We’ll refer to this as the *stack file*, as this defines the app and its requirements.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`该应用程序由多个目录和源文件组成。请随意探索它们。但是，我们将专注于`docker-stack.yml`文件。我们将把它称为*堆栈文件*，因为它定义了应用程序及其要求。'
- en: At the highest level, it defines 4 top-level keys.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在最高级别，它定义了4个顶级键。
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`**Version** indicates the version of the Compose file format. This has to
    be 3.0 or higher to work with stacks. **Services** is where we define the stack
    of services that make up the app. **Networks** lists the required networks, and
    **secrets** defines the secrets the app uses.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`**版本**表示Compose文件格式的版本。这必须是3.0或更高才能与堆栈一起使用。**服务**是我们定义组成应用程序的服务堆栈的地方。**网络**列出了所需的网络，**秘密**定义了应用程序使用的秘密。'
- en: If we expand each top-level key, we’ll see how things map to Figure 14.1\. The
    stack file has five services called “reverse_proxy”, “database”, “appserver”,
    “visualizer”, and “payment_gateway”. So does Figure 14.1\. The stack file has
    three networks called “front-tier”, “back-tier”, and “payment”. So does Figure
    14.1\. Finally, the stack file has four secrets called “postgres_password”, “staging_token”,
    “revprox_key”, and “revprox_cert”. So does Figure 14.1.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们展开每个顶级键，我们将看到如何将事物映射到图14.1。堆栈文件有五个名为“reverse_proxy”、“database”、“appserver”、“visualizer”和“payment_gateway”的服务。图14.1也是如此。堆栈文件有三个名为“front-tier”、“back-tier”和“payment”的网络。图14.1也是如此。最后，堆栈文件有四个名为“postgres_password”、“staging_token”、“revprox_key”和“revprox_cert”的秘密。图14.1也是如此。
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`It’s important to understand that the stack file captures and defines many
    of the requirements of the entire application. As such, it’s a form of application
    self-documentation and a great tool for bridging the gap between dev and ops.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`重要的是要理解，堆栈文件捕获并定义了整个应用程序的许多要求。因此，它是一种应用程序自我文档化的形式，也是弥合开发和运维之间差距的重要工具。'
- en: Let’s take a closer look at each section of the stack file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看堆栈文件的每个部分。
- en: Looking closer at the stack file
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仔细查看堆栈文件
- en: The stack file is a Docker Compose file. The only requirement is that the `version:`
    key specify a value of “3.0” or higher. See the [the Docker docs](https://docs.docker.com/compose/compose-file/)
    for the latest information on Compose file versions.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈文件是一个Docker Compose文件。唯一的要求是`version:`键指定一个值为“3.0”或更高。有关Compose文件版本的最新信息，请参阅[Docker文档](https://docs.docker.com/compose/compose-file/)。
- en: One of the first things Docker does when deploying an app from a stack file,
    is check for, and create the networks listed under the `networks:` key. If the
    networks do not already exist, Docker will create them.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从堆栈文件部署应用程序时，Docker要做的第一件事是检查并创建`networks:`键下列出的网络。如果网络尚不存在，Docker将创建它们。
- en: Let’s see the networks defined in the stack file.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看堆栈文件中定义的网络。
- en: Networks
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 网络
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Three networks are defined; `front-tier`, `back-tier`, and `payment`. By default,
    they’ll all be created as overlay networks by the `overlay` driver. But the `payment`
    network is special — it requires an encrypted data plane.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`定义了三个网络; `front-tier`，`back-tier`和`payment`。默认情况下，它们都将由`overlay`驱动程序创建为覆盖网络。但是`payment`网络很特别
    - 它需要加密的数据平面。'
- en: 'By default, the control plane of all overlay networks is encrypted. To encrypt
    the data plane, you have two choices:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有覆盖网络的控制平面都是加密的。要加密数据平面，您有两个选择：
- en: Pass the `-o encrypted` flag to the `docker network create` command.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`-o encrypted`标志传递给`docker network create`命令。
- en: 'Specify `encrypted: ''yes''` under `driver_opts` in the stack file.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在堆栈文件中的`driver_opts`下指定`encrypted: ''yes''`。'
- en: The overhead incurred by encrypting the data plane depends on various factors
    such traffic type and traffic flow. However, expect it to be in the region of
    10%.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 加密数据平面所产生的开销取决于各种因素，如流量类型和流量流向。但是，预计它将在10%左右。
- en: As previously mentioned, all three networks will be created before the secrets
    and services.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在创建秘密和服务之前，将创建所有三个网络。
- en: Now let’s look at the secrets.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看秘密。
- en: Secrets
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 秘密
- en: 'Secrets are defined as top-level objects, and the stack file we’re using defines
    four:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密被定义为顶级对象，我们使用的堆栈文件定义了四个：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Notice that all four are defined as `external`. This means that they must
    already exist before the stack can be deployed.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`请注意，所有四个都被定义为`external`。这意味着它们必须在堆栈部署之前已经存在。'
- en: 'It’s possible for secrets to be created on-demand when the application is deployed
    — just replace `external: true` with `file: <filename>`. However, for this to
    work, a plaintext file containing the unencrypted value of the secret must already
    exist on the host’s filesystem. This has obvious security implications.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '秘密可以在部署应用程序时按需创建 - 只需用`file: <filename>`替换`external: true`。但是，为了使其工作，主机文件系统上必须已经存在包含秘密未加密值的明文文件。这显然具有安全影响。'
- en: We’ll see how to create these secrets when we come to deploy the app. For now,
    it’s enough to know that the application defines four secrets that need pre-creating.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始部署应用程序时，我们将看到如何创建这些秘密。现在，知道应用程序定义了需要预先创建的四个秘密就足够了。
- en: Let’s look at each of the services.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每个服务。
- en: Services
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务
- en: Services are where most of the action happens.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 服务是大部分操作发生的地方。
- en: Each service is a JSON collection (dictionary) that contains a bunch of keys.
    We’ll step through each one and explain what each of the options does.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都是一个包含一堆键的JSON集合（字典）。我们将逐个解释每个选项的作用。
- en: The reverse_proxy service
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 反向代理服务
- en: As we can see, the `reverse_proxy` service defines an image, ports, secrets,
    and networks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`reverse_proxy`服务定义了一个镜像、端口、秘密和网络。
- en: '[PRE5]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`The image key is the only mandatory key in the service object. As the name
    suggests, it defines the Docker image that will be used to build the replicas
    for the service.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`image`键是服务对象中唯一强制的键。顾名思义，它定义了将用于构建服务副本的Docker镜像。'
- en: Docker is opinionated, so unless you specify otherwise, the **image** will be
    pulled from Docker Hub. You can specify images from 3rd-party registries by prepending
    the image name with the DNS name of the registry’s API endpoint such as `gcr.io`
    for Google’s container registry.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有自己的见解，因此除非另有说明，**image**将从Docker Hub中拉取。您可以通过在镜像名称前加上注册表的DNS名称来指定来自第三方注册表的镜像，例如`gcr.io`用于Google的容器注册表。
- en: One difference between Docker Stacks and Docker Compose, is that stacks do not
    support **builds**. This means all images have to be built prior to deploying
    the stack.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Stacks和Docker Compose之间的一个区别是，堆栈不支持**构建**。这意味着在部署堆栈之前，所有镜像都必须构建。
- en: 'The **ports** key defines two mappings:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**ports**键定义了两个映射：'
- en: '`80:80` maps port 80 on the Swarm to port 80 on each service replica.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`80:80`将Swarm上的端口80映射到每个服务副本的端口80。'
- en: '`443:443` maps port 443 on the Swarm to port 443 on each service replica.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`443:443`将Swarm上的端口443映射到每个服务副本的端口443。'
- en: 'By default, all ports are mapped using *ingress mode*. This means they’ll be
    mapped and accessible from every node in the Swarm — even nodes not running a
    replica. The alternative is *host mode*, where ports are only mapped on Swarm
    nodes running replicas for the service. However, *host mode* requires you to use
    the long-form syntax. For example, mapping port 80 in *host mode* using the long-form
    syntax would be like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有端口都使用*入口模式*进行映射。这意味着它们将被映射并且可以从Swarm中的每个节点访问 - 即使节点没有运行副本。另一种选择是*主机模式*，在这种模式下，端口仅在运行服务副本的Swarm节点上映射。但是，*主机模式*要求您使用长格式语法。例如，使用长格式语法在*主机模式*下映射端口80将是这样的：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`The long-form syntax is recommended, as it’s easier to read and more powerful
    (it supports ingress mode **and** host mode). However, it requires at least version
    3.2 of the Compose file format.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`长格式语法是推荐的，因为它更容易阅读和更强大（支持入口模式**和**主机模式）。但是，它至少需要版本3.2的Compose文件格式。'
- en: The **secrets** key defines two secrets — `revprox_cert` and `revprox_key`.
    These must be defined in the top-level `secrets` key, and must exist on the system.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**secrets**键定义了两个秘密 - `revprox_cert`和`revprox_key`。这些必须在顶级`secrets`键中定义，并且必须存在于系统中。'
- en: Secrets get mounted into service replicas as a regular file. The name of the
    file will be whatever you specify as the `target` value in the stack file, and
    the file will appear in the replica under `/run/secrets` on Linux, and `C:\ProgramData\Docker\secrets`
    on Windows. Linux mounts `/run/secrets` as an in-memory filesystem, but Windows
    does not.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密作为常规文件挂载到服务副本中。文件的名称将是您在堆栈文件中指定为`target`值的内容，并且该文件将出现在Linux上的副本中的`/run/secrets`下，在Windows上为`C:\ProgramData\Docker\secrets`。Linux将`/run/secrets`挂载为内存文件系统，但Windows不会。
- en: 'The secrets defined in this service will be mounted in each service replica
    as `/run/secrets/revprox_cert` and `/run/secrets/revprox_key`. To mount one of
    them as `/run/secrets/uber_secret` you would define it in the stack file as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在此服务中定义的秘密将被挂载到每个服务副本中，如`/run/secrets/revprox_cert`和`/run/secrets/revprox_key`。要将其中一个挂载为`/run/secrets/uber_secret`，您可以在堆栈文件中定义如下：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`The **networks** key ensures that all replicas for the service will be attached
    to the `front-tier` network. The network specified here must be defined in the
    `networks` top-level key, and if it doesn’t already exist, Docker will create
    it as an overlay.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**networks**键确保服务的所有副本都将连接到`front-tier`网络。此处指定的网络必须在`networks`顶级键中定义，如果尚不存在，Docker将将其创建为覆盖。'
- en: The database service
  id: totrans-82
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 数据库服务
- en: The database service also defines; an image, a network, and a secret. As well
    as those, it introduces environment variables and placement constraints.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库服务还定义了一个镜像、一个网络和一个秘密。除此之外，它还引入了环境变量和放置约束。
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`The **environment** key lets you inject environment variables into services
    replica. This service uses three environment variables to define a database user,
    the location of the database password (a secret mounted into every service replica),
    and the name of the database.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**环境** 键允许您将环境变量注入服务副本。此服务使用三个环境变量来定义数据库用户、数据库密码的位置（挂载到每个服务副本中的秘密）和数据库的名称。'
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`> **Note:** It would be more secure to pass all three values in as secrets,
    as this would avoid documenting the database name and database user in plaintext
    variables.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`> **注意：** 将所有三个值作为秘密传递更安全，因为这样可以避免在明文变量中记录数据库名称和数据库用户。'
- en: The service also defines a *placement constraint* under the `deploy` key. This
    ensures that replicas for this service will always run on Swarm *worker* nodes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务还在 `deploy` 键下定义了 *放置约束*。这确保了该服务的副本始终在 Swarm *worker* 节点上运行。
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`Placement constraints are a form of topology-aware scheduling, and can be
    a great way of influencing scheduling decisions. Swarm currently lets you schedule
    against all of the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 放置约束是一种拓扑感知调度的形式，可以是影响调度决策的好方法。Swarm目前允许您针对以下所有进行调度：
- en: Node ID. `node.id == o2p4kw2uuw2a`
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点ID。`node.id == o2p4kw2uuw2a`
- en: Node name. `node.hostname == wrk-12`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点名称。`node.hostname == wrk-12`
- en: Role. `node.role != manager`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色。`node.role != manager`
- en: Engine labels. `engine.labels.operatingsystem==ubuntu 16.04`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎标签。`engine.labels.operatingsystem==ubuntu 16.04`
- en: Custom node labels. `node.labels.zone == prod1`
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义节点标签。`node.labels.zone == prod1`
- en: Notice that `==` and `!=` are both supported.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`==` 和 `!=` 都受支持。
- en: The appserver service
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: appserver服务
- en: The `appserver` service uses an image, attaches to three networks, and mounts
    a secret. It also introduces several additional features under the `deploy` key.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`appserver` 服务使用一个镜像，连接到三个网络，并挂载一个秘密。它还在 `deploy` 键下引入了几个其他功能。'
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Let’s take a closer look at the new stuff under the `deploy` key.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看 `deploy` 键下的新内容。
- en: First up, `services.appserver.deploy.replicas = 2` will set the desired number
    of replicas for the service to 2\. If omitted, the default value is 1\. If the
    service is running, and you need to change the number of replicas, you should
    do so declaratively. This means updating `services.appserver.deploy.replicas`
    in the stack file with the new value, and then redeploying the stack. We’ll see
    this later, but re-deploying a stack does not affect services that you haven’t
    made a change to.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`services.appserver.deploy.replicas = 2` 将设置服务的期望副本数为2。如果省略，则默认值为1。如果服务正在运行，并且您需要更改副本的数量，您应该以声明方式进行。这意味着在堆栈文件中更新
    `services.appserver.deploy.replicas` 为新值，然后重新部署堆栈。我们稍后会看到，但重新部署堆栈不会影响您没有进行更改的服务。
- en: '`services.appserver.deploy.update_config` tells Docker how to act when rolling-out
    updates to the service. For this service, Docker will update two replicas at-a-time
    (`parallelism`) and will perform a ‘rollback’ if it detects the update is failing.
    Rolling back will start new replicas based on the previous definition of the service.
    The default value for `failure_action` is `pause`, which will stop further replicas
    being updated. The other option is `continue`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`services.appserver.deploy.update_config` 告诉Docker在对服务进行更新时如何操作。对于此服务，Docker将一次更新两个副本（`parallelism`），如果检测到更新失败，将执行“回滚”。回滚将基于服务的先前定义启动新的副本。`failure_action`
    的默认值是 `pause`，这将停止进一步更新副本。另一个选项是 `continue`。'
- en: '[PRE12]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`The `services.appserver.deploy.restart-policy` object tells Swarm how to restart
    replicas (containers) if and when they fail. The policy for this service will
    restart a replica if it stops with a non-zero exit code (`condition: on-failure`).
    It will try to restart the failed replica 3 times, and wait up to 120 seconds
    to decide if the restart worked. It will wait 5 seconds between each of the three
    restart attempts.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`services.appserver.deploy.restart-policy`对象告诉Swarm如何重新启动副本（容器），如果它们失败的话。此服务的策略将在副本以非零退出代码停止时重新启动（`condition:
    on-failure`）。它将尝试重新启动失败的副本3次，并等待最多120秒来决定重新启动是否成功。在三次重新启动尝试之间将等待5秒。'
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`###### visualizer'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`###### visualizer'
- en: The visualizer service references an image, maps a port, defines an update config,
    and defines a placement constraint. It also and mounts a volume and defines a
    custom grace period for container stop operations.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: visualizer服务引用了一个镜像，映射了一个端口，定义了一个更新配置，并定义了一个放置约束。它还挂载了一个卷，并为容器停止操作定义了一个自定义宽限期。
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`When Docker stops a container, it issues a `SIGTERM` to the process with PID
    1 inside the container. The container (its PID 1 process) then has a 10-second
    grace period to perform any clean-up operations. If it doesn’t handle the signal,
    it will be forcibly terminated after 10 seconds with a `SIGKILL`. The `stop_grace_period`
    property overrides this 10 second grace period.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker停止一个容器时，它向容器内部的PID 1进程发出`SIGTERM`。容器（其PID 1进程）然后有10秒的宽限期来执行任何清理操作。如果它没有处理信号，它将在10秒后被强制终止，使用`SIGKILL`。`stop_grace_period`属性覆盖了这个10秒的宽限期。
- en: The `volumes` key is used to mount pre-created volumes and host directories
    into a service replica. In this case, it’s mounting `/var/run/docker.sock` from
    the Docker host, into `/var/run/docker.sock` inside of each service replica. This
    means any reads and writes to `/var/run/docker.sock` in the replica will be passed
    through to the same directory in the host.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`volumes`键用于将预先创建的卷和主机目录挂载到服务副本中。在这种情况下，它将`/var/run/docker.sock`从Docker主机挂载到每个服务副本中的`/var/run/docker.sock`。这意味着对副本中`/var/run/docker.sock`的任何读写都将通过传递到主机中的相同目录。'
- en: '`/var/run/docker.sock` happens to be the IPC socket that the Docker daemon
    exposes all of its API endpoints on. This means giving a container access to it
    allows the container to consume all API endpoints — essentially giving the container
    the ability to query and manage the Docker daemon. In most situations this is
    a huge “No!”. However, this is a demo app in a lab environment.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`/var/run/docker.sock`碰巧是Docker守护程序在其上公开所有API端点的IPC套接字。这意味着让容器访问它允许容器消耗所有API端点
    - 从本质上讲，这使得容器能够查询和管理Docker守护程序。在大多数情况下，这是一个巨大的“不行”。但是，在实验环境中，这是一个演示应用程序。'
- en: The reason this service requires access to the Docker socket is because it provides
    a graphical representation of services on the Swarm. To do this, it needs to be
    able to query the Docker daemon on a manager node. To accomplish this, a placement
    constraint forces all service replicas onto manager nodes, and the Docker socket
    is bind-mounted into each service replica. The *bind mount* is shown in Figure
    14.3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务需要访问Docker套接字的原因是因为它提供了Swarm上服务的图形表示。为了做到这一点，它需要能够查询管理节点上的Docker守护程序。为了实现这一点，一个放置约束强制所有服务副本进入管理节点，并且Docker套接字被绑定挂载到每个服务副本中。*绑定挂载*如图14.3所示。
- en: '![Figure 14.3](images/figure14-3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3](images/figure14-3.png)'
- en: Figure 14.3
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3
- en: payment_gateway
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: payment_gateway
- en: The `payment_gateway` service specifies an image, mounts a secret, attaches
    to a network, defines a partial deployment strategy, and then imposes a couple
    of placement constraints.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`payment_gateway`服务指定了一个镜像，挂载了一个秘密，连接到一个网络，定义了一个部分部署策略，然后施加了一些放置约束。'
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`We’ve seen all of these options before, except for the `node.label` in the
    placement constraint. Node labels are custom-defined labels added to Swarm nodes
    with the `docker node update` command. As such, they’re only applicable within
    the context of the nodes role in the Swarm (you can’t leverage them on standalone
    containers or outside of the Swarm).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`我们之前见过所有这些选项，除了在放置约束中的`node.label`。节点标签是使用`docker node update`命令添加到Swarm节点的自定义定义标签。因此，它们只适用于Swarm中节点的角色（您不能在独立容器或Swarm之外利用它们）。'
- en: In this example, the `payment_gateway` service performs operations that require
    it to run on a Swarm node that has been hardened to PCI DSS standards. To enable
    this, you can apply a custom *node label* to any Swarm node meeting these requirements.
    We’ll do this when we build the lab to deploy the app.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`payment_gateway`服务执行需要在符合PCI DSS标准的Swarm节点上运行的操作。为了实现这一点，您可以将自定义*节点标签*应用到满足这些要求的任何Swarm节点上。在构建实验室以部署应用程序时，我们将这样做。
- en: As this service defines two placement constraints, replicas will only be deployed
    to nodes that match both. I.e. a **worker** node with the `pcidss=yes` node label.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此服务定义了两个放置约束，副本将只部署到符合两者的节点。即具有`pcidss=yes`节点标签的**工作**节点。
- en: Now that we’re finished examining the stack file, we should have a good understanding
    of the application’s requirements. As mentioned previously, the stack file is
    a great piece of application documentation. We know that the application has 5
    services, 3 networks, and 4 secrets. We know which services attach to which networks,
    which ports need publishing, which images are required, and we even know that
    some services need to run on specific nodes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了检查堆栈文件，我们应该对应用程序的要求有一个很好的理解。如前所述，堆栈文件是应用程序文档的重要部分。我们知道应用程序有5个服务，3个网络和4个秘密。我们知道哪些服务连接到哪些网络，哪些端口需要发布，需要哪些镜像，甚至知道一些服务需要在特定节点上运行。
- en: Let’s deploy it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署它。
- en: Deploying the app
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'There’s a few pre-requisites that need taking care of before we can deploy
    the app:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署应用程序之前，有一些先决条件需要处理：
- en: '**Swarm mode:** We’ll deploy the app as a Docker Stack, and stacks require
    Swarm mode.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Swarm模式：**我们将应用程序部署为Docker Stack，堆栈需要Swarm模式。'
- en: '**Labels:** One of the Swarm worker nodes needs a custom node label.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签：**Swarm工作节点中的一个需要一个自定义节点标签。'
- en: '**Secrets:** The app uses secrets which need pre-creating before we can deploy
    it.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密：**应用程序使用需要在部署之前预先创建的秘密。'
- en: Building a lab for the sample app
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为示例应用程序构建实验室
- en: In this section we’ll build a three-node Linux-based Swarm cluster that satisfies
    all of the application’s pre-req’s. Once we’re done, the lab will look like this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将构建一个满足应用程序所有先决条件的三节点基于Linux的Swarm集群。一旦完成，实验室将如下所示。
- en: '![Figure 14.4 Sample lab](images/figure14-4.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图14.4 示例实验室](images/figure14-4.png)'
- en: Figure 14.4 Sample lab
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4 示例实验室
- en: 'We’ll complete the following three steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 完成以下三个步骤：
- en: Create a new Swarm
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的Swarm
- en: Add a node label
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个节点标签
- en: Create the secrets
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建秘密
- en: Let’s create a new three-node Swarm cluster.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的三节点Swarm集群。
- en: Initialize a new Swarm.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个新的Swarm。
- en: Run the following command on the node that you want to be your Swarm manager.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想要成为Swarm管理节点的节点上运行以下命令。
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`*   Add worker nodes.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 添加工作节点。'
- en: Copy the `docker swarm join` command that displayed in the output of the previous
    command. Paste it into the two nodes you want to join as workers.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 复制在上一个命令的输出中显示的`docker swarm join`命令。将其粘贴到要加入为工作节点的两个节点中。
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`*   Verify that the Swarm is configured with one manager and two workers.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`* 验证Swarm是否配置为一个管理节点和两个工作节点。'
- en: Run this command from the manager node.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从管理节点运行此命令。
- en: '[PRE18]``'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE18]``'
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: $ docker node update --label-add pcidss=yes wrk-1
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker node update --label-add pcidss=yes wrk-1
- en: '[PRE20]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: $ docker node inspect wrk-1
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker node inspect wrk-1
- en: '['
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '['
- en: '{'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"ID": "b74rzajmrimfv7hood6l4lgz3",'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “ID”：“b74rzajmrimfv7hood6l4lgz3”，
- en: '"Version": {'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: “版本”：{
- en: '"Index": 27'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: “索引”：27
- en: '},'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"CreatedAt": "2018-01-25T10:35:18.146831621Z",'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: “创建时间”：“2018-01-25T10:35:18.146831621Z”，
- en: '"UpdatedAt": "2018-01-25T10:47:57.189021202Z",'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “更新时间”：“2018-01-25T10:47:57.189021202Z”，
- en: '"Spec": {'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: “规格”：{
- en: '"Labels": {'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “标签”：{
- en: '"pcidss": "yes"'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “pcidss”：“是”
- en: '},'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: <Snip>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <Snip>
- en: '[PRE21]``'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]``'
- en: '[PRE22]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: $ git clone https://github.com/dockersamples/atsea-sample-shop-app.git
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: $ git clone https://github.com/dockersamples/atsea-sample-shop-app.git
- en: Cloning into `'atsea-sample-shop-app'`...
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆到`'atsea-sample-shop-app'`...
- en: 'remote: Counting objects: `636`, `done`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 远程：计算对象：`636`，`完成`。
- en: 'Receiving objects: `100`% `(``636`/636`)`, `7`.23 MiB `|` `3`.30 MiB/s, `done`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接收对象：`100`% `(``636`/636`)`, `7`.23 MiB `|` `3`.30 MiB/s，`完成`。
- en: 'remote: Total `636` `(`delta `0``)`, reused `0` `(`delta `0``)`, pack-reused
    `636`'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 远程：总共`636` `（增量`0``）`，重用`0` `（增量`0``）`，包重用`636`
- en: 'Resolving deltas: `100`% `(``197`/197`)`, `done`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 解决增量：`100`% `(``197`/197`)`, `完成`。
- en: Checking connectivity... `done`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 检查连通性... `完成`。
- en: $ `cd` atsea-sample-shop-app
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: $ `cd` atsea-sample-shop-app
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: $ docker stack deploy -c docker-stack.yml seastack
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用docker堆栈部署-docker-stack.yml seastack
- en: Creating network seastack_default
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络seastack_default
- en: Creating network seastack_back-tier
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络seastack_back-tier
- en: Creating network seastack_front-tier
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络seastack_front-tier
- en: Creating network seastack_payment
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建网络seastack_payment
- en: Creating service seastack_database
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务seastack_database
- en: Creating service seastack_appserver
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务seastack_appserver
- en: Creating service seastack_visualizer
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务seastack_visualizer
- en: Creating service seastack_payment_gateway
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务seastack_payment_gateway
- en: Creating service seastack_reverse_proxy
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 创建服务seastack_reverse_proxy
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: $ docker stack ls
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack ls
- en: NAME                SERVICES
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 服务
- en: seastack            `5`
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: seastack `5`
- en: $ docker stack ps seastack
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack ps seastack
- en: NAME                          NODE     DESIRED STATE    CURRENT STATE
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 节点 期望状态 当前状态
- en: seastack_reverse_proxy.1      wrk-2    Running          Running `7` minutes
    ago
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_reverse_proxy.1 wrk-2 运行 运行`7`分钟前
- en: seastack_payment_gateway.1    wrk-1    Running          Running `7` minutes
    ago
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_payment_gateway.1 wrk-1 运行 运行`7`分钟前
- en: seastack_visualizer.1         mgr-1    Running          Running `7` minutes
    ago
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_visualizer.1 mgr-1 运行 运行`7`分钟前
- en: seastack_appserver.1          wrk-2    Running          Running `7` minutes
    ago
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.1 wrk-2 运行 运行`7`分钟前
- en: seastack_database.1           wrk-2    Running          Running `7` minutes
    ago
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_database.1 wrk-2 运行 运行`7`分钟前
- en: seastack_appserver.2          wrk-1    Running          Running `7` minutes
    ago
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.2 wrk-1 运行 运行`7`分钟前
- en: '[PRE25]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: $ docker stack ps seastack
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack ps seastack
- en: NAME                NODE     DESIRED      CURRENT  ERROR
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 名称 节点 期望的 当前 错误
- en: STATE        STATE
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 状态 状态
- en: 'reverse_proxy.1     wrk-2    Shutdown     Failed   `"task: non-zero exit (1)"`'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: reverse_proxy.1 wrk-2 关机 失败 `"任务：非零退出（1）"`
- en: '`\_`reverse_proxy.1   wrk-2    Shutdown     Failed   `"task: non-zero exit
    (1)"`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`\_`reverse_proxy.1 wrk-2 关机 失败 `"任务：非零退出（1）"`'
- en: '[PRE26]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: $ docker service logs seastack_reverse_proxy
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker service logs seastack_reverse_proxy
- en: 'seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` `[`emerg`]` `1``#1: host not
    found...`'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 'seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` `[`emerg`]` `1``#1: 主机未找到...`'
- en: 'seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` `[`emerg`]` `1``#1: host not
    found...`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 'seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` `[`emerg`]` `1``#1: 主机未找到...`'
- en: 'seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` nginx: `[`emerg`]` host not
    found..'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_reverse_proxy.1.6m1nmbzmwh2d@wrk-2 `|` nginx：`[`emerg`]`主机未找到..
- en: 'seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` nginx: `[`emerg`]` host not
    found..'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_reverse_proxy.1.zhc3cjeti9d4@wrk-2 `|` nginx：`[`emerg`]`主机未找到..
- en: seastack_reverse_proxy.1.1tmya243m5um@mgr-1 `|` `10`.255.0.2 `"GET / HTTP/1.1"`
    `302`
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_reverse_proxy.1.1tmya243m5um@mgr-1 `|` `10`.255.0.2 `"GET / HTTP/1.1"`
    `302`
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <Snip>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: <Snip>
- en: 'appserver:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: appserver：
- en: 'image: dockersamples/atsea_app'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图像：dockersamples/atsea_app
- en: 'networks:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: '- front-tier'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '- front-tier'
- en: '- back-tier'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '- back-tier'
- en: '- payment'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '- payment'
- en: 'deploy:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 部署：
- en: 'replicas: 2             <<Updated value'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '副本: 2             <<更新值'
- en: <Snip>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <Snip>
- en: 'visualizer:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 'visualizer:'
- en: 'image: dockersamples/visualizer:stable'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '镜像: dockersamples/visualizer:stable'
- en: 'ports:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 端口：
- en: '- "8001:8080"'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '- "8001:8080"'
- en: 'stop_grace_period: 2m     <<Updated value'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 'stop_grace_period: 2m     <<更新值'
- en: <Snip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <Snip
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: $ docker stack deploy -c docker-stack.yml seastack
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack deploy -c docker-stack.yml seastack
- en: 'Updating service seastack_reverse_proxy `(`id: z4crmmrz7zi83o0721heohsku`)`'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '更新服务seastack_reverse_proxy `(`id: z4crmmrz7zi83o0721heohsku`)`'
- en: 'Updating service seastack_database `(`id: 3vvpkgunetxaatbvyqxfic115`)`'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '更新服务seastack_database `(`id: 3vvpkgunetxaatbvyqxfic115`)`'
- en: 'Updating service seastack_appserver `(`id: ljht639w33dhv0dmht1q6mueh`)`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '更新服务seastack_appserver `(`id: ljht639w33dhv0dmht1q6mueh`)`'
- en: 'Updating service seastack_visualizer `(`id: rbwoyuciglre01hsm5fviabjf`)`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '更新服务seastack_visualizer `(`id: rbwoyuciglre01hsm5fviabjf`)`'
- en: 'Updating service seastack_payment_gateway `(`id: w4gsdxfnb5gofwtvmdiooqvxs`)`'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '更新服务seastack_payment_gateway `(`id: w4gsdxfnb5gofwtvmdiooqvxs`)`'
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: $ docker stack ps seastack
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack ps seastack
- en: NAME                    NODE     DESIRED STATE   CURRENT STATE
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                    节点     期望状态   当前状态
- en: seastack_visualizer.1   mgr-1    Running         Running `1` second ago
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_visualizer.1   mgr-1    运行中         运行中 `1` 秒前
- en: seastack_visualizer.1   mgr-1    Shutdown        Shutdown `3` seconds ago
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_visualizer.1   mgr-1    关闭        关闭 `3` 秒前
- en: seastack_appserver.1    wrk-2    Running         Running `24` minutes ago
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.1    wrk-2    运行中         运行中 `24` 分钟前
- en: seastack_appserver.2    wrk-1    Running         Running `24` minutes ago
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.2    wrk-1    运行中         运行中 `24` 分钟前
- en: seastack_appserver.3    wrk-2    Running         Running `1` second ago
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.3    wrk-2    运行中         运行中 `1` 秒前
- en: seastack_appserver.4    wrk-1    Running         Running `1` second ago
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.4    wrk-1    运行中         运行中 `1` 秒前
- en: seastack_appserver.5    wrk-2    Running         Running `1` second ago
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.5    wrk-2    运行中         运行中 `1` 秒前
- en: seastack_appserver.6    wrk-1    Running         Starting `7` seconds ago
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.6    wrk-1    运行中         启动 `7` 秒前
- en: seastack_appserver.7    wrk-2    Running         Running `1` second ago
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.7    wrk-2    运行中         运行中 `1` 秒前
- en: seastack_appserver.8    wrk-1    Running         Starting `7` seconds ago
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.8    wrk-1    运行中         启动 `7` 秒前
- en: seastack_appserver.9    wrk-2    Running         Running `1` second ago
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.9    wrk-2    运行中         运行中 `1` 秒前
- en: seastack_appserver.10   wrk-1    Running         Starting `7` seconds ago
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: seastack_appserver.10   wrk-1    运行中         启动 `7` 秒前
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: $ docker stack rm seastack
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: $ docker stack rm seastack
- en: Removing service seastack_appserver
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务seastack_appserver
- en: Removing service seastack_database
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务seastack_database
- en: Removing service seastack_payment_gateway
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务seastack_payment_gateway
- en: Removing service seastack_reverse_proxy
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务seastack_reverse_proxy
- en: Removing service seastack_visualizer
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 删除服务seastack_visualizer
- en: Removing network seastack_front-tier
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 删除网络seastack_front-tier
- en: Removing network seastack_payment
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 删除网络seastack_payment
- en: Removing network seastack_default
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 删除网络seastack_default
- en: Removing network seastack_back-tier
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 删除网络seastack_back-tier
- en: '[PRE31][PRE32]`'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31][PRE32]`'
