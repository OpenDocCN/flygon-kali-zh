- en: Chapter 6. Running Services in a Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。在容器中运行服务
- en: We've reached so far, brick by brick, laying a strong and stimulating foundation
    on the fast-evolving Docker technology. We talked about the important building
    blocks of the highly usable and reusable Docker images. Further on, you can read
    the easy-to-employ techniques and tips on how to store and share Docker images
    through a well-designed storage framework. As usual, images will have to go through
    a series of verifications, validations, and refinements constantly in order to
    make them more right and relevant for the aspiring development community. In this
    chapter, we are going to take our learning to the next level by describing the
    steps towards creating a small web server, run the same inside a container, and
    connect to the web server from the external world.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一步步地走到了这一步，为快速发展的Docker技术奠定了坚实而令人振奋的基础。我们谈论了高度可用和可重复使用的Docker镜像的重要构建模块。此外，您可以阅读如何通过精心设计的存储框架存储和共享Docker镜像的易于使用的技术和提示。通常情况下，镜像必须不断经过一系列验证、验证和不断完善，以使它们更加正确和相关，以满足渴望发展的社区的需求。在本章中，我们将通过描述创建一个小型Web服务器的步骤，将其运行在容器内，并从外部世界连接到Web服务器，将我们的学习提升到一个新的水平。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Container networking
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器网络
- en: '**Container as a Service** (**CaaS**)—building, running, exposing, and connecting
    to container services'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器即服务**（**CaaS**）-构建、运行、暴露和连接到容器服务'
- en: Publishing and retrieving container ports
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布和检索容器端口
- en: Binding a container to a specific IP address
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将容器绑定到特定IP地址
- en: Auto-generating the Docker host port
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动生成Docker主机端口
- en: Port binding using the `EXPOSE` and `-P` options
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EXPOSE`和`-P`选项进行端口绑定
- en: A brief overview of container networking
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器网络简要概述
- en: Like any computing node, the Docker containers need to be networked, in order
    to be found and accessible by other containers and clients. In a network, generally,
    any node is being identified through its IP address. Besides, the IP address is
    a unique mechanism for any client to reach out to the services offered by any
    server node. Docker internally uses Linux capabilities to provide network connectivity
    to containers. In this section, we are going to learn about the container's IP
    address assignment and the procedure to retrieve the container's IP address.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何计算节点一样，Docker容器需要进行网络连接，以便其他容器和客户端可以找到并访问它们。在网络中，通常通过IP地址来识别任何节点。此外，IP地址是任何客户端到达任何服务器节点提供的服务的唯一机制。Docker内部使用Linux功能来为容器提供网络连接。在本节中，我们将学习有关容器IP地址分配和检索容器IP地址的过程。
- en: 'The Docker engine seamlessly selects and assigns an IP address to a container
    with no intervention from the user, when it gets launched. Well, you might be
    puzzled on how Docker selects an IP address for a container, and this puzzle is
    answered in two parts, which is as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，Docker引擎会无需用户干预地选择并分配IP地址给容器。您可能会对Docker如何为容器选择IP地址感到困惑，这个谜团分为两部分来解答，如下所示：
- en: During the installation, Docker creates a virtual interface with the name `docker0`
    on the Docker host. It also selects a private IP address range, and assigns an
    address from the selected range to the `docker0` virtual interface. This selected
    IP address is always outside the range of the Docker host IP address in order
    to avoid an IP address conflict.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装过程中，Docker在Docker主机上创建一个名为`docker0`的虚拟接口。它还选择一个私有IP地址范围，并从所选范围中为`docker0`虚拟接口分配一个地址。所选的IP地址始终位于Docker主机IP地址范围之外，以避免IP地址冲突。
- en: Later, when we spin up a container, the Docker engine selects an unused IP address
    from the IP address range selected for the `docker0` virtual interface. Then,
    the engine assigns this IP address to the freshly spun container.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 稍后，当我们启动一个容器时，Docker引擎会从为`docker0`虚拟接口选择的IP地址范围中选择一个未使用的IP地址。然后，引擎将这个IP地址分配给新启动的容器。
- en: 'Docker, by default, selects the IP address `172.17.42.1/16`, or one of the
    IP addresses that is within the range `172.17.0.0` to `172.17.255.255`. Docker
    will select a different private IP address range if there is a direct conflict
    with the `172.17.x.x` addresses. Perhaps, the good old `ifconfig` (the command
    to display the details of the network interfaces) comes in handy here to find
    out the IP address assigned to the virtual interface. Let''s just run `ifconfig`
    with `docker0` as an argument, as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker会选择IP地址`172.17.42.1/16`，或者在`172.17.0.0`到`172.17.255.255`范围内的IP地址之一。如果与`172.17.x.x`地址直接冲突，Docker将选择不同的私有IP地址范围。也许，老式的`ifconfig`（显示网络接口详细信息的命令）在这里很有用，可以用来找出分配给虚拟接口的IP地址。让我们用`docker0`作为参数运行`ifconfig`，如下所示：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The second line of the output will show the assigned IP address and its netmask:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第二行将显示分配的IP地址及其子网掩码：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Apparently, from the preceding text, `172.17.42.1` is the IP address assigned
    to the `docker0` virtual interface. The IP address `172.17.42.1` is one of the
    addresses in the private IP address range from `172.17.0.0` to `172.17.255.255`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，从前面的文本中，`172.17.42.1`是分配给`docker0`虚拟接口的IP地址。IP地址`172.17.42.1`是从`172.17.0.0`到`172.17.255.255`的私有IP地址范围中的一个地址。
- en: 'It''s now imperative that we learn how to find the IP address assigned to a
    container. The container should be launched in an interactive mode using the `-i`
    option. Of course, we can easily find the IP by running the `ifconfig` command
    within the container, as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在迫切需要我们学习如何找到分配给容器的IP地址。容器应该使用`-i`选项以交互模式启动。当然，我们可以通过在容器内运行`ifconfig`命令来轻松找到IP地址，如下所示：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ifconfig` command will display the details of all the interfaces in the
    Docker container, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`ifconfig`命令将显示Docker容器中所有接口的详细信息，如下所示：'
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Evidently, the preceding output of the `ifconfig` command shows that the Docker
    engine has virtualized two network interfaces for the container, which are as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`ifconfig`命令的前面输出显示Docker引擎为容器虚拟化了两个网络接口，如下所示：
- en: The first one is an `eth0` (Ethernet) interface for which the Docker engine
    assigned the IP address `172.17.0.12`. Obviously, this address also falls within
    the same IP address range of the `docker0` virtual interface. Besides, the address
    assigned to the `eth0` interface is used for intra-container communication and
    host-to-container communication.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是`eth0`（以太网）接口，Docker引擎分配了IP地址`172.17.0.12`。显然，这个地址也在`docker0`虚拟接口的相同IP地址范围内。此外，分配给`eth0`接口的地址用于容器内部通信和主机到容器的通信。
- en: The second interface is the `lo` (Loopback) interface for which the Docker engine
    assigned the loopback address `127.0.0.1`. The loopback interface is used for
    local communication within a container.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个接口是`lo`（环回）接口，Docker引擎分配了环回地址`127.0.0.1`。环回接口用于容器内部的本地通信。
- en: Easy, isn't it? However, the retrieval of an IP address gets complicated when
    the container is launched in the detached mode, using the `-d` option in the `docker
    run` subcommand. The primary reason for this complication in the detached mode
    is that there is no shell prompt to run the `ifconfig` command. Fortunately, Docker
    provides a `docker inspect` subcommand, which is as handy as a Swiss army knife,
    and allow us to dive deep into the low-level details of the Docker container or
    image. The `docker inspect` subcommand generates the requested details in the
    JSON array format.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？然而，当使用`docker run`子命令中的`-d`选项以分离模式启动容器时，检索IP地址变得复杂起来。分离模式中的这种复杂性的主要原因是没有shell提示符来运行`ifconfig`命令。幸运的是，Docker提供了一个`docker
    inspect`子命令，它像瑞士军刀一样方便，并允许我们深入了解Docker容器或镜像的低级细节。`docker inspect`子命令以JSON数组格式生成请求的详细信息。
- en: 'Here is a sample run of the `docker inspect` subcommand on the interactive
    container that we previously launched. The `4b0b567b6019` container ID is taken
    from the prompt of the container:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们之前启动的交互式容器上`docker inspect`子命令的示例运行。`4b0b567b6019`容器ID取自容器的提示符：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This command generates quite a lot of information about the container. Here,
    we show some excerpts of the container''s network configuration from the output
    of the `docker inspect` subcommand:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令生成有关容器的大量信息。在这里，我们展示了从`docker inspect`子命令的输出中提取的容器网络配置的一些摘录：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, the network configuration lists out the following details:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，网络配置列出了以下详细信息：
- en: '**Bridge**: This is the bridge interface to which the container is bound'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bridge**：这是容器绑定的桥接口'
- en: '**Gatewa**y: This is the gateway address of the container, which is the address
    of the bridge interface as well'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gateway**：这是容器的网关地址，也是桥接口的地址'
- en: '**IPAddres**s: This is the IP address assigned to the container'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPAddress**：这是分配给容器的IP地址'
- en: '**IPPrefixLen**: This is the IP prefix length, another way of representing
    the subnet mask'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IPPrefixLen**：这是IP前缀长度，表示子网掩码的另一种方式'
- en: '**PortMapping**: This is the port mapping field, which is now being deprecated,
    and its value is always null'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PortMapping**：这是端口映射字段，现在已经被弃用，其值始终为null'
- en: '**Ports**: This is the ports field that will enumerate all the port binds,
    which is introduced later in this chapter'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ports**：这是端口字段，将列举所有端口绑定，这将在本章后面介绍'
- en: There is no doubt that the `docker inspect` subcommand is quite convenient for
    finding the minute details of a container or an image. However, it's a tiresome
    job to go through the intimidating details and to find the right information that
    we are keenly looking for. Perhaps, you can narrow it down to the right information,
    using the `grep` command. Or even better, the `docker inspect` subcommand, which
    helps you pick the right field from the JSON array using the `--format` option
    of the `docker inspect` subcommand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，`docker inspect`子命令对于查找容器或镜像的细节非常方便。然而，浏览令人生畏的细节并找到我们渴望寻找的正确信息是一项繁琐的工作。也许，您可以使用`grep`命令将其缩小到正确的信息。或者更好的是，使用`docker
    inspect`子命令，它可以帮助您使用`docker inspect`子命令的`--format`选项从JSON数组中选择正确的字段。
- en: 'Notably, in the following example, we use the `--format` option of the `docker
    inspect` subcommand to retrieve just the IP address of the container. The IP address
    is accessible through the `.NetworkSettings.IPAddress` field of the JSON array:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在以下示例中，我们使用`docker inspect`子命令的`--format`选项仅检索容器的IP地址。IP地址可以通过JSON数组的`.NetworkSettings.IPAddress`字段访问：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Envisaging the Container as a Service
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将容器视为服务
- en: We laid a good foundation of the fundamentals of the Docker technology. In this
    section, we are going to focus on crafting an image with the HTTP service, launch
    the HTTP service inside the container using the crafted image, and then, demonstrate
    the connectivity to the HTTP service running inside the container.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为Docker技术的基础打下了良好的基础。在本节中，我们将专注于使用HTTP服务创建镜像，使用创建的镜像在容器内启动HTTP服务，然后演示连接到容器内运行的HTTP服务。
- en: Building an HTTP server image
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建HTTP服务器镜像
- en: In this section, we are going to craft a Docker image in order to install `Apache2`
    on top of the `Ubuntu 14.04` base image, and configure a `Apache HTTP Server`
    to run as an executable, using the `ENTRYPOINT` instruction.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个Docker镜像，以在`Ubuntu 14.04`基础镜像上安装`Apache2`，并配置`Apache HTTP Server`以作为可执行文件运行，使用`ENTRYPOINT`指令。
- en: In [Chapter 3](ch03.html "Chapter 3. Building Images"), *Building Images*, we
    illustrated the concept of the Dockerfile to craft an `Apache2` image on top of
    the `Ubuntu 14.04` base image. Here, in this example, we are going to extend this
    Dockerfile by setting the `Apache` log path and setting `Apache2` as the default
    execution application, using the `ENTRYPOINT` instruction. The following is a
    detailed explanation of the content of `Dockerfile`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。构建镜像")*构建镜像*中，我们演示了使用Dockerfile在`Ubuntu 14.04`基础镜像上创建`Apache2`镜像的概念。在这个例子中，我们将通过设置`Apache`日志路径和使用`ENTRYPOINT`指令将`Apache2`设置为默认执行应用程序来扩展这个Dockerfile。以下是`Dockerfile`内容的详细解释。
- en: 'We are going to build an image using `ubuntu:14.04` as the base image, using
    the `FROM` instruction, as shown in the `Dockerfile` snippet:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`FROM`指令以`ubuntu:14.04`作为基础镜像构建镜像，如`Dockerfile`片段所示：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Set authors' detail using MAINTAINER Instruction
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MAINTAINER指令设置作者详细信息
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using one `RUN` instruction, we will synchronize the `apt` repository source
    list, install the `apache2` package, and then clean the retrieved files:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个`RUN`指令，我们将同步`apt`仓库源列表，安装`apache2`包，然后清理检索到的文件：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Set the Apache log directory path using the `ENV` instruction:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ENV`指令设置Apache日志目录路径：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, the final instruction is to launch the `apache2` server using the `ENTRYPOINT`
    instruction:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后一条指令是使用`ENTRYPOINT`指令启动`apache2`服务器：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding line, you might be surprised to see the `FOREGROUND` argument.
    This is one of the key differences between the traditional and the container paradigm.
    In the traditional paradigm, the server applications are usually launched in the
    background either as a service or a daemon because the host system is a general-purpose
    system. However, in the container paradigm, it is imperative to launch an application
    in the foreground because the images are crafted for a sole purpose.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行中，您可能会惊讶地看到`FOREGROUND`参数。这是传统和容器范式之间的关键区别之一。在传统范式中，服务器应用通常在后台启动，作为服务或守护程序，因为主机系统是通用系统。然而，在容器范式中，必须在前台启动应用程序，因为镜像是为唯一目的而创建的。
- en: 'Having prescribed the image building instruction in the `Dockerfile`, now let''s
    move to the next logical step of building the image using the `docker build` subcommand
    by naming the image as `apache2`, as shown here:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dockerfile`中规定了构建镜像的指令后，现在让我们通过使用`docker build`子命令来构建镜像，将镜像命名为`apache2`，如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now do a quick verification of the images using the `docker images`
    subcommand:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用`docker images`子命令快速验证镜像：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we have seen in the previous chapters, the `docker images` command displays
    the details of all the images in the Docker host. However, in order to illustrate
    precisely the images created using the `docker build` subcommand, we highlight
    the details of `apache2:latest` (the target image) and `ubuntu:14.04` (the base
    image) from the complete image list, as shown in the following output snippet:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的章节中所看到的，`docker images`命令显示了Docker主机中所有镜像的详细信息。然而，为了准确说明使用`docker build`子命令创建的镜像，我们从完整的镜像列表中突出显示了`apache2:latest`（目标镜像）和`ubuntu:14.04`（基础镜像）的详细信息，如下面的输出片段所示：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having built the HTTP server image, now let's move on to the next session to
    learn how to run the HTTP service.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 构建了HTTP服务器镜像后，现在让我们继续下一节，学习如何运行HTTP服务。
- en: Running the HTTP server Image as a Service
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为服务运行HTTP服务器镜像
- en: 'In this section, we are going to launch a container using the Apache HTTP server
    image, we crafted in the previous section. Here, we launch the container in the
    detached mode (similar to a UNIX daemon process) using the `-d` option of the
    `docker run` subcommand:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将使用在上一节中制作的Apache HTTP服务器镜像来启动一个容器。在这里，我们使用`docker run`子命令的`-d`选项以分离模式（类似于UNIX守护进程）启动容器：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Having launched the container, let''s run the `docker logs` subcommand to see
    whether our Docker container generates any output on its `STDIN` (standard input)
    or `STDERR` (standard error):'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 启动了容器后，让我们运行`docker logs`子命令，看看我们的Docker容器是否在其`STDIN`（标准输入）或`STDERR`（标准错误）上生成任何输出：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we have not fully configured the Apache HTTP server; you will find the following
    warning, as the output of the `docker logs` subcommand:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们还没有完全配置Apache HTTP服务器，您将会发现以下警告，作为`docker logs`子命令的输出：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: From the preceding warning message, it is quite evident that the IP address
    assigned to this container is `172.17.0.13`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的警告消息中，很明显可以看出分配给这个容器的IP地址是`172.17.0.13`。
- en: Connecting to the HTTP service
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到HTTP服务
- en: 'In the preceding section, from the warning message, we found out that the IP
    address of the container is `172.17.0.13`. On a fully configured HTTP server container,
    no such warning is available, so let''s still run the `docker inspect` subcommand
    to retrieve the IP address using the container ID:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，从警告消息中，我们发现容器的IP地址是`172.17.0.13`。在一个完全配置好的HTTP服务器容器上，是没有这样的警告的，所以让我们仍然运行`docker
    inspect`子命令来使用容器ID检索IP地址：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Having found the IP address of the container as `172.17.0.13`, let''s quickly
    run a web request on this IP address from the shell prompt of the Docker host,
    using the `wget` command. Here, we choose to run the `wget` command with `-qO-`
    in order to run in the quiet mode and also display the retrieved HTML file on
    the screen:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker主机的shell提示符下，找到容器的IP地址为`172.17.0.13`，让我们快速在这个IP地址上运行一个web请求，使用`wget`命令。在这里，我们选择使用`-qO-`参数来以安静模式运行`wget`命令，并在屏幕上显示检索到的HTML文件：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, we are showcasing just the first five lines of the retrieved HTML file:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了检索到的HTML文件的前五行：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Awesome, isn't it? We got our first service running in a container, and we are
    able to reach out to our service from our Docker host.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒，不是吗？我们在一个容器中运行了我们的第一个服务，并且我们能够从Docker主机访问我们的服务。
- en: Furthermore, on a plain vanilla Docker installation, the service offered by
    one container is accessible by any other container within the Docker host. You
    can go ahead, launch a new Ubuntu container in the interactive mode, install the
    `wget` package using `apt-get`, and run the same `wget -qO - 172.17.0.13` command,
    as we did in the Docker host. Of course, you will see the same output.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在普通的Docker安装中，一个容器提供的服务可以被Docker主机内的任何其他容器访问。您可以继续，在交互模式下启动一个新的Ubuntu容器，使用`apt-get`安装`wget`软件包，并运行与我们在Docker主机中所做的相同的`wget
    -qO - 172.17.0.13`命令。当然，您会看到相同的输出。
- en: Exposing container services
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露容器服务
- en: So far, we have successfully launched an HTTP service and accessed the service
    from the Docker host as well as another container within the same Docker host.
    Furthermore, as demonstrated in the *Build images from containers* section of
    [Chapter 2](ch02.html "Chapter 2. Handling Docker Containers"), *Handling Docker
    Containers*, the container is able to successfully install the `wget` package
    by making a connection to the publicly available apt repository over the Internet.
    Nonetheless, the outside world cannot access the service offered by a container
    by default. At the outset, this might seem like a limitation in the Docker technology.
    However, the fact of the matter is, the containers are isolated from the outside
    world by design.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功启动了一个HTTP服务，并从Docker主机以及同一Docker主机内的另一个容器访问了该服务。此外，正如在[第2章](ch02.html
    "第2章。处理Docker容器")的*从容器构建镜像*部分所演示的，容器能够通过在互联网上连接到公共可用的apt仓库来成功安装`wget`软件包。然而，默认情况下，外部世界无法访问容器提供的服务。起初，这可能看起来像是Docker技术的一个限制。然而，事实是，容器是根据设计与外部世界隔离的。
- en: 'Docker achieves network isolation for the containers by the IP address assignment
    criteria, as enumerated:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Docker通过IP地址分配标准实现容器的网络隔离，具体列举如下：
- en: Assign a private IP address to the container, which is not reachable from an
    external network.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为容器分配一个私有IP地址，该地址无法从外部网络访问。
- en: Assign an IP address to the container outside the host's IP network.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为容器分配一个在主机IP网络之外的IP地址。
- en: Consequently, the Docker container is not reachable, even from the systems that
    are connected to the same IP network as the Docker host. This assignment scheme
    also provides protection from an IP address conflict that might otherwise arise.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker容器甚至无法从与Docker主机相同的IP网络连接的系统访问。这种分配方案还可以防止可能会出现的IP地址冲突。
- en: Now, you might wonder how to make the services run inside a container that is
    accessible to the outside world, in other words, exposing container services.
    Well, Docker bridges this connectivity gap in a classy manner by leveraging the
    Linux `iptables` functionality under the hood.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能想知道如何使服务在容器内运行，并且可以被外部访问，换句话说，暴露容器服务。嗯，Docker通过在底层利用Linux `iptables`功能来弥合这种连接差距。
- en: At the frontend, Docker provides two different building blocks to bridge this
    connectivity gap for its users. One of the building blocks is to bind the container
    port using the `-p` (publish a container's port to the host interface) option
    of the `docker run` subcommand. Another alternative is to use the combination
    of the `EXPOSE` Dockerfile instruction and the `-P` (publish all exposed ports
    to the host interfaces) option of the `docker run` subcommand.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端，Docker为用户提供了两种不同的构建模块来弥合这种连接差距。其中一个构建模块是使用`docker run`子命令的`-p`（将容器的端口发布到主机接口）选项来绑定容器端口。另一种选择是使用`EXPOSE`
    Dockerfile指令和`docker run`子命令的`-P`（将所有公开的端口发布到主机接口）选项的组合。
- en: Publishing container ports – the -p option
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布容器端口-使用-p选项
- en: 'Docker enables you to publish a service offered inside a container by binding
    the container''s port to the host interface. The `-p` option of the `docker run`
    subcommand enables you to bind a container port to a user-specified or auto-generated
    port of the Docker host. Thus, any communication destined for the IP address and
    the port of the Docker host would be forwarded to the port of the container. The
    `-p` option, actually, supports the following four formats of arguments:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使您能够通过将容器的端口绑定到主机接口来发布容器内提供的服务。`docker run`子命令的`-p`选项使您能够将容器端口绑定到Docker主机的用户指定或自动生成的端口。因此，任何发送到Docker主机的IP地址和端口的通信都将转发到容器的端口。实际上，`-p`选项支持以下四种格式的参数：
- en: '`<hostPort>:<containerPort>`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<hostPort>:<containerPort>`'
- en: '`<containerPort>`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<containerPort>`'
- en: '`<ip>:<hostPort>:<containerPort>`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ip>:<hostPort>:<containerPort>`'
- en: '`<ip>::<containerPort>`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ip>::<containerPort>`'
- en: Here, `<ip>` is the IP address of the Docker host, `<hostPort>` is the Docker
    host port number, and `<containerPort>` is the port number of the container. Here,
    in this section, we present you with the `-p <hostPort>:<containerPort>` format
    and introduce other formats in the succeeding sections.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<ip>`是Docker主机的IP地址，`<hostPort>`是Docker主机的端口号，`<containerPort>`是容器的端口号。在本节中，我们向您介绍了`-p
    <hostPort>:<containerPort>`格式，并在接下来的部分介绍其他格式。
- en: 'In order to understand the port binding process better, let''s reuse the `apache2`
    HTTP server image that we crafted previously, and spin up a container using a
    `-p` option of the `docker run` subcommand. The port `80` is the published port
    of the HTTP service, and as the default behavior, our `apache2` HTTP server is
    also available on port `80`. Here, in order to demonstrate this capability, we
    are going to bind port `80` of the container to port `80` of the Docker host,
    using the `-p <hostPort>:<containerPort>` option of the `docker run` subcommand,
    as shown in the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解端口绑定过程，让我们重用之前创建的`apache2` HTTP服务器镜像，并使用`docker run`子命令的`-p`选项启动一个容器。端口`80`是HTTP服务的发布端口，作为默认行为，我们的`apache2`
    HTTP服务器也可以在端口`80`上访问。在这里，为了演示这种能力，我们将使用`docker run`子命令的`-p <hostPort>:<containerPort>`选项，将容器的端口`80`绑定到Docker主机的端口`80`，如下命令所示：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have successfully launched the container, we can connect to our
    HTTP server using any web browser from any external system (provided it has network
    connectivity) to reach our Docker host. So far, we have not added any web pages
    to our `apache2` HTTP server image.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功启动了容器，我们可以使用任何外部系统的Web浏览器连接到我们的HTTP服务器（只要它具有网络连接），以访问我们的Docker主机。到目前为止，我们还没有向我们的`apache2`
    HTTP服务器镜像添加任何网页。
- en: 'Hence, when we connect from a web browser, we will get the following screen,
    which is nothing but the default page that comes along with the `Ubuntu Apache2`
    package:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从Web浏览器连接时，我们将得到以下屏幕，这只是随`Ubuntu Apache2`软件包一起提供的默认页面：
- en: '![Publishing container ports – the -p option](graphics/7937OT_06_01.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![发布容器端口- -p选项](graphics/7937OT_06_01.jpg)'
- en: Network Address Translation for containers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器的网络地址转换
- en: In the previous section, we saw how a `-p 80:80` option did the magic, didn't
    it? Well, in reality, under the hood, the Docker engine achieves this seamless
    connectivity by automatically configuring the **Network Address Translation**
    (**NAT**) rule in the Linux `iptables` configuration files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到`-p 80:80`选项是如何起作用的，不是吗？实际上，在幕后，Docker引擎通过自动配置Linux `iptables`配置文件中的**网络地址转换**（**NAT**）规则来实现这种无缝连接。
- en: 'To illustrate the automatic configuration of the NAT rule in Linux `iptables`,
    let''s query the Docker hosts `iptables` for its NAT entries, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在Linux `iptables`中自动配置NAT规则，让我们查询Docker主机的`iptables`以获取其NAT条目，如下所示：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The ensuing text is an excerpt from the `iptables` NAT entry, which is automatically
    added by the Docker engine:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的文本是从Docker引擎自动添加的`iptables` NAT条目中摘录的：
- en: '[PRE23]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'From the preceding excerpt, it is quite evident that the Docker engine has
    effectively added a `DNAT` rule. The following are the details of the `DNAT` rule:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的摘录中，很明显Docker引擎有效地添加了一个`DNAT`规则。以下是`DNAT`规则的详细信息：
- en: The `tcp` keyword signifies that this `DNAT` rule applies only to the TCP transport
    protocol.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tcp`关键字表示这个`DNAT`规则仅适用于TCP传输协议。'
- en: The first `0.0.0.0/0` address is a meta IP address of the source address. This
    address indicates that the connection can originate from any IP address.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个`0.0.0.0/0`地址是源地址的元IP地址。这个地址表示连接可以来自任何IP地址。
- en: The second `0.0.0.0/0` address is a meta IP address of the destination address
    on the Docker host. This address indicates that the connection could be made to
    any valid IP address in the Docker host.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`0.0.0.0/0`地址是Docker主机上目标地址的元IP地址。这个地址表示连接可以与Docker主机中的任何有效IP地址建立。
- en: Finally, `dpt:80 to:172.17.0.14:80` is the forwarding instruction used to forward
    any TCP activity on port `80` of the Docker host to the IP address `172.17.0.17`,
    the IP address of our container and port `80`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`dpt:80 to:172.17.0.14:80`是用于将Docker主机端口`80`上的任何TCP活动转发到IP地址`172.17.0.17`，即我们容器的IP地址和端口`80`的转发指令。
- en: Therefore, any TCP packet that the Docker host receives on port `80` will be
    forwarded to port `80` of the container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker主机接收到的任何TCP数据包都将转发到容器的端口`80`。
- en: Retrieving the container port
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索容器端口
- en: 'The Docker engine provides at least three different options to retrieve the
    containers port binding details. Here, let''s first explore the options, and then,
    move on to dissect the retrieved information. The options are as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎提供至少三种不同的选项来检索容器的端口绑定详细信息。在这里，让我们首先探索选项，然后继续分析检索到的信息。选项如下：
- en: 'The `docker ps` subcommand always displays the port binding details of a container,
    as shown here:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps`子命令始终显示容器的端口绑定详细信息，如下所示：'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `docker inspect` subcommand is another alternative; however, you have to
    skim through quite a lot of details. Run the following command:'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect`子命令是另一种选择；但是，你必须浏览相当多的细节。运行以下命令：'
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `docker inspect` subcommand displays the port binding related information
    in three JSON objects, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker inspect`子命令以三个JSON对象显示与端口绑定相关的信息，如下所示：'
- en: 'The `ExposedPorts` object enumerates all ports that are exposed through the
    `EXPOSE` instruction in `Dockerfile`, as well as the container ports that are
    mapped using the `-p` option in the `docker run` subcommand. Since we didn''t
    add the `EXPOSE` instruction in our `Dockerfile`, what we have is just the container
    port that was mapped using `-p80:80` as an argument to the `docker run` subcommand:'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExposedPorts`对象枚举了通过`Dockerfile`中的`EXPOSE`指令暴露的所有端口，以及使用`docker run`子命令中的`-p`选项映射的容器端口。由于我们没有在`Dockerfile`中添加`EXPOSE`指令，我们只有使用`-p80:80`作为`docker
    run`子命令的参数映射的容器端口：'
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `PortBindings` object is part of the `HostConfig` object, and this object
    lists out all the port binding done through the `-p` option in the `docker run`
    subcommand. This object will never list the ports exposed through the `EXPOSE`
    instruction in the `Dockerfile`:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PortBindings`对象是`HostConfig`对象的一部分，该对象列出了通过`docker run`子命令中的`-p`选项进行的所有端口绑定。该对象永远不会列出通过`Dockerfile`中的`EXPOSE`指令暴露的端口：'
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `Ports` object of the `NetworkSettings` object has the same level of detail,
    as the preceding `PortBindings` object. However, this object encompasses all ports
    that are exposed through the `EXPOSE` instruction in `Dockerfile`, as well as
    the container ports that are mapped using the `-p` option in the `docker run`
    subcommand:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkSettings`对象的`Ports`对象具有与先前的`PortBindings`对象相同级别的细节。但是，该对象包含通过`Dockerfile`中的`EXPOSE`指令暴露的所有端口，以及使用`docker
    run`子命令的`-p`选项映射的容器端口：'
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Of course, the specific port field can be filtered using the `--format` option
    of the `docker inspect` subcommand.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，可以使用`docker inspect`子命令的`--format`选项来过滤特定的端口字段。
- en: 'The `docker port` subcommand enables you to retrieve the port binding on the
    Docker host by specifying the container''s port number:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker port`子命令允许您通过指定容器的端口号来检索Docker主机上的端口绑定：'
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Evidently, in all the preceding output excerpts, the information that stands
    out is the IP address `0.0.0.0` and the port number `80`. The IP address `0.0.0.0`
    is a meta address, which represents all the IP addresses configured on the Docker
    host. In effect, the containers port `80` is bound to all the valid IP addresses
    on the Docker host. Therefore, the HTTP service is accessible through any of the
    valid IP addresses configured on the Docker host.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在所有先前的输出摘录中，突出显示的信息是IP地址`0.0.0.0`和端口号`80`。IP地址`0.0.0.0`是一个元地址，代表了Docker主机上配置的所有IP地址。实际上，容器端口`80`绑定到了Docker主机上所有有效的IP地址。因此，HTTP服务可以通过Docker主机上配置的任何有效IP地址访问。
- en: Binding a container to a specific IP address
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将容器绑定到特定的IP地址
- en: 'Until now, with the method that we have learnt, the containers always get bound
    to all the IP addresses configured in the Docker host. However, you may want to
    offer different services on different IP addresses. In other words, a specific
    IP address and port would be configured to offer a particular service. We can
    achieve this in Docker using the `-p <ip>:<hostPort>:<containerPort>` option of
    the `docker run` subcommand, as shown in the following example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，使用我们学到的方法，容器总是绑定到Docker主机上配置的所有IP地址。然而，您可能希望在不同的IP地址上提供不同的服务。换句话说，特定的IP地址和端口将被配置为提供特定的服务。我们可以在Docker中使用`docker
    run`子命令的`-p <ip>:<hostPort>:<containerPort>`选项来实现这一点，如下例所示：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here, the IP address must be a valid IP address on the Docker host. If the
    specified IP address is not a valid IP address on the Docker host, the container
    launch will fail with an error message, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，IP地址必须是Docker主机上的有效IP地址。如果指定的IP地址不是Docker主机上的有效IP地址，则容器启动将失败，并显示错误消息，如下所示：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, let's quickly review the port mapping as well as the NAT entry for the
    preceding example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速回顾一下前面示例的端口映射以及NAT条目。
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本是`docker ps`子命令的输出摘录，显示了此容器的详细信息：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本是`iptables -n nat -L -n`命令的输出摘录，显示了为此容器创建的`DNAT`条目：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, you will realize how elegantly the Docker engine has configured
    the service offered by the container on the IP address `198.51.100.73` and port
    `80` of the Docker host.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查`docker run`子命令的输出和`iptables`的`DNAT`条目之后，您将意识到Docker引擎如何优雅地配置了容器在Docker主机的IP地址`198.51.100.73`和端口`80`上提供的服务。
- en: Auto-generating the Docker host port
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成Docker主机端口
- en: The Docker containers are innately lightweight and due to their lightweight
    nature, you can run multiple containers with the same, or different services on
    a single Docker host. Particularly, auto scaling of the same service across several
    containers based on demand, is the need of IT infrastructure today. Here, in this
    section, you will be informed about the challenge in spinning up multiple containers
    with the same service, and also Docker's way of addressing this challenge.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器天生轻量级，由于其轻量级的特性，您可以在单个Docker主机上运行多个相同或不同服务的容器。特别是根据需求在多个容器之间自动扩展相同服务的需求是当今IT基础设施的需求。在本节中，您将了解在启动多个具有相同服务的容器时所面临的挑战，以及Docker解决这一挑战的方式。
- en: 'Earlier in this chapter, we launched a container using `apache2 http server`
    by binding it to port `80` of the Docker host. Now, if we attempt to launch one
    more container with the same port `80` binding, the container would fail to start
    with an error message, as you can see in the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们使用`apache2 http server`启动了一个容器，并将其绑定到Docker主机的端口`80`。现在，如果我们尝试再启动一个绑定到相同端口`80`的容器，容器将无法启动，并显示错误消息，如下例所示：
- en: '[PRE34]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Obviously, in the preceding example, the container failed to start because the
    previous container is already mapped to `0.0.0.0` (all the IP addresses of the
    Docker host) and port `80`. In the TCP/IP communication model, the combination
    of the IP address, port, and the Transport Protocols (TCP, UDP, and so on) has
    to be unique.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在上面的例子中，容器无法启动，因为先前的容器已经映射到`0.0.0.0`（Docker主机的所有IP地址）和端口`80`。在TCP/IP通信模型中，IP地址、端口和传输协议（TCP、UDP等）的组合必须是唯一的。
- en: 'We could have overcome this issue by manually choosing the Docker host port
    number (for instance, `-p 81:80` or `-p 8081:80`). Though this is an excellent
    solution, it does not perform well to auto-scaling scenarios. Instead, if we give
    the control to Docker, it would auto-generate the port number on the Docker host.
    This port number generation is achieved by underspecifying the Docker host port
    number, using the `-p <containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动选择Docker主机端口号（例如，`-p 81:80`或`-p 8081:80`）来解决这个问题。虽然这是一个很好的解决方案，但在自动扩展的场景下表现不佳。相反，如果我们把控制权交给Docker，它会在Docker主机上自动生成端口号。通过使用`docker
    run`子命令的`-p <containerPort>`选项来实现这种端口号生成，如下例所示：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Having successfully started the new container with the auto-generated port,
    let''s review the port mapping as well as the NAT entry for the preceding example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 成功启动了具有自动生成端口的新容器后，让我们回顾一下上面例子的端口映射以及NAT条目：
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是`docker ps`子命令的输出摘录，显示了该容器的详细信息：
- en: '[PRE36]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following text is an excerpt from the output of the `iptables -n nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本是`iptables -n nat -L -n`命令的输出摘录，显示了为该容器创建的`DNAT`条目：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After reviewing both the output of the `docker run` subcommand and the `DNAT`
    entry of `iptables`, what stands out is the port number `49158`. The port number
    `49158` is niftily auto-generated by the Docker engine on the Docker host, with
    the help of the underlying operating system. Besides, the meta IP address `0.0.0.0`
    implies that the service offered by the container is accessible from outside,
    through any of the valid IP addresses configured on the Docker host.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了`docker run`子命令的输出和`iptables`的`DNAT`条目之后，引人注目的是端口号`49158`。端口号`49158`是由Docker引擎在Docker主机上巧妙地自动生成的，借助底层操作系统的帮助。此外，元IP地址`0.0.0.0`意味着容器提供的服务可以通过Docker主机上配置的任何有效IP地址从外部访问。
- en: 'You may have a use case where you want to auto-generate the port number. However,
    if you still want to restrict the service to a particular IP address of the Docker
    host, you can use the `-p <IP>::<containerPort>` option of the `docker run` subcommand,
    as shown in the following example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有一个使用案例，您希望自动生成端口号。但是，如果您仍希望将服务限制在Docker主机的特定IP地址上，您可以使用`docker run`子命令的`-p
    <IP>::<containerPort>`选项，如下例所示：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding two scenarios, the Docker engine auto-generated the port number
    on the Docker host and exposed it to the outside world. The general norm for network
    communication is to expose any service through a predefined port number so that
    anybody can know the IP address, and the port number can easily access the offered
    service. Whereas, here, the port numbers are auto-generated and as a result, the
    outside world cannot directly reach the offered service. So, the primary purpose
    of this method of container creation is to achieve auto-scaling, and the container
    created in this fashion would be interfaced with a proxy or load balance service
    on a predefined port.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述的两种情况中，Docker引擎在Docker主机上自动生成了端口号并将其暴露给外部世界。网络通信的一般规范是通过预定义的端口号公开任何服务，以便任何人都可以知道IP地址，并且端口号可以轻松访问提供的服务。然而，在这里，端口号是自动生成的，因此外部世界无法直接访问提供的服务。因此，容器创建的这种方法的主要目的是实现自动扩展，并且以这种方式创建的容器将与预定义端口上的代理或负载平衡服务进行接口。
- en: Port binding using EXPOSE and the -P option
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EXPOSE和-P选项进行端口绑定
- en: So far, we have discussed the four distinct methods to publish a service running
    inside a container to the outside world. In all these four methods, the port binding
    decision is taken during the container launch time, and the image has no information
    about the ports on which the service is being offered. It has worked well so far
    because the image is being built by us, and we are pretty much aware of the port
    in which the service is being offered. However, in the case of third-party images,
    the port usage inside a container has to be published unambiguously. Besides,
    if we build images for third-party consumption or even for our own use, it is
    a good practice to explicitly state the ports in which the container offers its
    service. Perhaps, the image builders could ship a readme document along with the
    image. However, it is even better to embed the port details in the image itself
    so that you can easily find the port details from the image both manually as well
    as through automated scripts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了将容器内运行的服务发布到外部世界的四种不同方法。在这四种方法中，端口绑定决策是在容器启动时进行的，并且镜像对于提供服务的端口没有任何信息。到目前为止，这已经运作良好，因为镜像是由我们构建的，我们对提供服务的端口非常清楚。然而，在第三方镜像的情况下，容器内的端口使用必须明确发布。此外，如果我们为第三方使用或甚至为自己使用构建镜像，明确声明容器提供服务的端口是一个良好的做法。也许，镜像构建者可以随镜像一起提供一个自述文件。然而，将端口详细信息嵌入到镜像本身中会更好，这样您可以轻松地从镜像中手动或通过自动化脚本找到端口详细信息。
- en: 'The Docker technology allows us to embed the port information using the `EXPOSE`
    instruction in the `Dockerfile`, which we introduced in [Chapter 3](ch03.html
    "Chapter 3. Building Images"), *Building Images*. Here, let''s edit the `Dockerfile`
    we used to build the `apache2` HTTP server image earlier in this chapter, and
    add an `EXPOSE` instruction, as shown in the following code. The default port
    for the HTTP service is port `80`, hence port `80` is exposed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker技术允许我们使用`Dockerfile`中的`EXPOSE`指令嵌入端口信息，我们在[第3章](ch03.html "第3章。构建镜像")*构建镜像*中介绍过。在这里，让我们编辑之前在本章中使用的构建`apache2`
    HTTP服务器镜像的`Dockerfile`，并添加一个`EXPOSE`指令，如下所示。HTTP服务的默认端口是端口`80`，因此端口`80`被暴露：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that we have added the `EXPOSE` instruction to our `Dockerfile`, let''s
    move to the next step of building the image using the `docker build` command.
    Here, let''s reuse the image name `apache2`, as shown here:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在我们的`Dockerfile`中添加了`EXPOSE`指令，让我们继续使用`docker build`命令构建镜像的下一步。在这里，让我们重用镜像名称`apache2`，如下所示：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Having successfully built the image, let''s inspect the image to verify the
    effects of the `EXPOSE` instruction to the image. As we learnt earlier, we can
    resort to the `docker inspect` subcommand, as shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 成功构建了镜像后，让我们检查镜像以验证`EXPOSE`指令对镜像的影响。正如我们之前学到的，我们可以使用`docker inspect`子命令，如下所示：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'On close review of the output generated by the preceding command, you will
    realize that Docker stores the exposed port information in the `ExposedPorts`
    field of the `Config` object. The following is an excerpt to show how the exposed
    port information is being displayed:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细审查前面命令生成的输出后，您会意识到Docker将暴露的端口信息存储在`Config`对象的`ExposedPorts`字段中。以下是摘录，显示了暴露的端口信息是如何显示的：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, you can apply the format option to the `docker inspect` subcommand
    in order to narrow down the output to very specific information. In this case,
    the `ExposedPorts` field of the `Config` object is shown in the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将格式选项应用于`docker inspect`子命令，以便将输出缩小到非常特定的信息。在这种情况下，`Config`对象的`ExposedPorts`字段在以下示例中显示：
- en: '[PRE43]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: To resume our discussion on the `EXPOSE` instruction, we can now spin up containers
    using an `apache2` image, that we just crafted. Yet, the `EXPOSE` instruction
    by itself cannot create port binding on the Docker host. In order to create port
    binding for the port declared using the `EXPOSE` instruction, the Docker engine
    provides a `-P` option in the `docker run` subcommand.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 继续讨论`EXPOSE`指令，我们现在可以使用我们刚刚创建的`apache2`镜像启动容器。然而，`EXPOSE`指令本身不能在Docker主机上创建端口绑定。为了为使用`EXPOSE`指令声明的端口创建端口绑定，Docker引擎在`docker
    run`子命令中提供了`-P`选项。
- en: 'In the following example, a container is launched from the `apache2` image,
    which was rebuilt earlier. Here, the `-d` option is used to launch the container
    in the detached mode, and the `-P` option is used to create the port binding in
    the Docker host for all the ports declared, using the `EXPOSE` instruction in
    the `Dockerfile`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，从之前重建的`apache2`镜像启动了一个容器。在这里，使用`-d`选项以分离模式启动容器，并使用`-P`选项为Docker主机上声明的所有端口创建端口绑定，使用`Dockerfile`中的`EXPOSE`指令：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have started the new container with the image that was created
    using the `EXPOSE` instruction, like the previous containers, let''s review the
    port mapping as well as the NAT entry for the preceding example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用`EXPOSE`指令创建了新容器的镜像，就像之前的容器一样，让我们回顾一下端口映射以及前面示例的NAT条目：
- en: 'The following text is an excerpt from the output of the `docker ps` subcommand
    that shows the details of this container:'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本摘自`docker ps`子命令的输出，显示了此容器的详细信息：
- en: '[PRE45]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The following text is an excerpt from the output of the `iptables -t nat -L
    -n` command that shows the `DNAT` entry created for this container:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下文本摘自`iptables -t nat -L -n`命令的输出，显示了为该容器创建的`DNAT`条目：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `-P` option of the `docker run` subcommand does not take any additional
    arguments, such as an IP address or a port number; consequently, fine tuning of
    the port binding is not possible, such as the `-p` option of the `docker run`
    subcommand. You can always resort to the `-p` option of the `docker run` subcommand
    if fine tuning of the port binding is critical to you.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`子命令的`-P`选项不接受任何额外的参数，比如IP地址或端口号；因此，无法对端口绑定进行精细调整，如`docker run`子命令的`-p`选项。如果对端口绑定的精细调整对您至关重要，您可以随时使用`docker
    run`子命令的`-p`选项。'
- en: Summary
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Containers do not deliver anything in an isolated or solo way substantially.
    They need to be systematically built and provided with a network interface along
    with a port number. This leads to a standardized exposition of containers to the
    outside world, facilitating other hosts or containers to find, bind, and leverage
    their unique capabilities on any network. Thus, network-accessibility is paramount
    for containers to get noticed and utilized in innumerable ways. This chapter is
    dedicated to showcasing how containers are being designed and deployed as a service,
    and how the aspect of container networking comes in handy by precisely and profusely
    empowering the peculiar world of container services as the days unfold. In the
    forthcoming chapters, we will deal and dwell at length on the various capabilities
    of Docker containers in software-intensive IT environments.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 容器在实质上并不以孤立或独立的方式提供任何东西。它们需要系统地构建，并配备网络接口和端口号。这导致容器在外部世界中的标准化展示，使其他主机或容器能够在任何网络上找到、绑定和利用它们独特的能力。因此，网络可访问性对于容器被注意并以无数种方式被利用至关重要。本章专门展示了容器如何被设计和部署为服务，以及容器网络的方面如何在日益展开的日子里精确而丰富地赋予容器服务的独特世界力量。在接下来的章节中，我们将详细讨论Docker容器在软件密集型IT环境中的各种能力。
