- en: Chapter 8. Kotlin Decisions and Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 Kotlin 决策和循环
- en: We have just learned about variables and we now understand how to change the
    values that they hold with expressions, but how can we take a course of action
    that is dependent upon the value of a variable?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学会了变量，并且现在了解如何使用表达式更改它们所持有的值，但是我们如何根据变量的值采取行动呢？
- en: We can certainly add the number of new messages to the number of previously
    unread messages, but how can we, for example, trigger an action within our app
    when the user has read all their messages?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以将新消息的数量添加到先前未读消息的数量中，但是例如，当用户已读完所有消息时，我们如何在应用程序内触发一个操作呢？
- en: The first problem is that we need a way to test the value of a variable, and
    then respond when the value falls within a range of values or is equal to a specific
    value.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是我们需要一种方法来测试变量的值，然后在值落在一系列值范围内或等于特定值时做出响应。
- en: Another problem that is common in programming is that we need sections of our
    code to be executed a certain number of times (more than once or sometimes not
    at all) depending on the values of variables.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中常见的另一个问题是，我们需要根据变量的值来执行代码的某些部分一定次数（多次或有时根本不执行）。
- en: To solve the first problem, we will look at making decisions in Kotlin with
    `if`, `else`, and `when`. To solve the latter, we will look at loops in Kotlin
    with `while`, `do` – `while`, `for`, `continue`, and `break`.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第一个问题，我们将学习使用 `if`、`else` 和 `when` 在 Kotlin 中做决策。为了解决后者，我们将学习使用 `while`、`do`
    – `while`、`for`、`continue` 和 `break` 在 Kotlin 中做循环。
- en: 'Furthermore, we will learn that, in Kotlin, decisions are also expressions
    that produce a value. We will cover the following topics in this chapter:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将了解到，在 Kotlin 中，决策也是产生值的表达式。在本章中，我们将涵盖以下主题：
- en: Making decisions with `if`, `else`, `else` – `if`, and `switch`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `if`、`else`、`else` – `if` 和 `switch` 进行决策
- en: The `when` demo app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when` 演示应用程序'
- en: Kotlin `while` loops and `do` - `while` loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin `while` 循环和 `do` - `while` 循环
- en: Kotlin `for` loops
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin `for` 循环
- en: Now let's learn more about Kotlin.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更多地了解 Kotlin。
- en: Making decisions in Kotlin
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中做决策
- en: Our Kotlin code will constantly be making decisions. For example, we might need
    to know whether the user has new messages, or whether they have a certain number
    of friends. We need to be able to test our variables to see whether they meet
    certain conditions, and then execute a specific section of code depending upon
    whether they did or not.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Kotlin 代码将不断做出决策。例如，我们可能需要知道用户是否有新消息，或者他们是否有一定数量的朋友。我们需要能够测试我们的变量，看它们是否满足某些条件，然后根据它们是否满足条件来执行特定的代码部分。
- en: In this section, as our code gets more in-depth, it helps to present the code
    in a way that makes it more readable. Let's take a look at code indenting to make
    our discussion about making decisions easier.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，随着我们的代码变得更加深入，以一种更易读的方式呈现代码有助于使其更易读。让我们看一下代码缩进，以使我们关于做决策的讨论更加容易。
- en: Indenting code for clarity
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了清晰起见缩进代码
- en: 'You have probably noticed that the Kotlin code in our project is indented.
    For example, the first line of code inside the `MainActivity` class is indented
    by one tab. Additionally, the first line of code is indented inside each function
    by another tab; here is an annotated diagram to make this clear:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到我们项目中的 Kotlin 代码是缩进的。例如，在 `MainActivity` 类内的第一行代码被缩进了一个制表符。此外，每个函数内的第一行代码也被另一个制表符缩进；下面是一个带注释的图表，以便清楚地说明这一点：
- en: '![Indenting code for clarity](img/B12806_08_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![为了清晰起见缩进代码](img/B12806_08_01.jpg)'
- en: Notice that when the indented block has ended, often with a closing curly brace
    (`}`), it is indented to the same extent as the line of code that began the block.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当缩进块结束时，通常是以一个闭合大括号（`}`）结束，它的缩进程度与开始块的代码行相同。
- en: We do this to make the code more readable. It is not part of the Kotlin syntax,
    however, and the code will still compile if we don't bother to do this.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做是为了使代码更易读。然而，这并不是 Kotlin 语法的一部分，如果我们不去做这个，代码仍然会编译。
- en: As our code gets more complicated, indenting, along with comments, helps to
    keep the meaning and structure of our code clear. I mention this now because when
    we start to learn the syntax for making decisions in Kotlin, indenting becomes
    especially useful and it is recommended that you indent your code the same way.
    Most of this indenting is done for us by Android Studio, but not all of it.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的代码变得更加复杂，缩进和注释有助于保持代码的含义和结构清晰。我现在提到这一点是因为当我们开始学习 Kotlin 中做决策的语法时，缩进变得特别有用，建议您以相同的方式缩进代码。大部分缩进是由
    Android Studio 为我们完成的，但并非全部。
- en: Now that we know how to present our code more clearly, we can learn about more
    operators, and then we can get to work by making decisions with Kotlin.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何更清晰地呈现我们的代码，我们可以学习更多运算符，然后开始使用 Kotlin 做决策。
- en: More Kotlin operators
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多 Kotlin 运算符
- en: We can already add (`+`), take away (`-`), multiply (`*`), divide (`/`), assign
    (`=`), increment (`++`), and decrement (`--`) with operators. Now we will explore
    some more useful operators, and then we will go straight onto learning about how
    to use them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了使用运算符进行添加（+）、减去（-）、乘以（*）、除以（/）、赋值（=）、递增（++）和递减（--）。现在我们将探索一些更有用的运算符，然后我们将直接学习如何使用它们。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Don't worry about memorizing each of the following operators. Glance over them
    and their explanations, and then move on to the next section. There, we will put
    a few operators to use and they will become much clearer as we see the examples
    of what they allow us to do. They are presented here in a list just to make the
    variety and scope of operators clear from the start. The list will also be more
    convenient to refer to later when not intermingled with the discussion about implementation
    that follows it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不要担心记住以下每个运算符。简要浏览它们和它们的解释，然后继续下一节。在那里，我们将使用一些运算符，并且当我们看到它们允许我们做什么的示例时，它们将变得更加清晰。它们在此处以列表的形式呈现，只是为了从一开始就清晰地展示运算符的种类和范围。在后面关于实现的讨论中，这个列表也会更方便以后参考。
- en: 'We use operators to create an expression that is either true or false. We wrap
    that expression in parentheses or brackets like this: `(expression goes here)`.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用运算符创建一个表达式，这个表达式要么为真，要么为假。我们用括号或方括号括起这个表达式，就像这样：`(表达式放在这里)`。
- en: The comparison operator
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: 'This is the comparison operator. It tests for equality and is either true or
    false; it is of the `Boolean` type:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是比较运算符。它测试相等性，要么为真，要么为假；它是`Boolean`类型的：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An expression such as `(10 == 9)`, for example, is false. 10 is obviously not
    equal to 9\. However, an expression such as `(2 + 2 == 4)` is obviously true.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(10 == 9)`是假的。10显然不等于9。然而，表达式`(2 + 2 == 4)`显然是真的。
- en: Tip
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: That is, except in *1984*, when 2 + 2 == 5 ([https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four)).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除了在《1984》中，2 + 2 == 5（[https://en.wikipedia.org/wiki/Nineteen_Eighty-Four](https://en.wikipedia.org/wiki/Nineteen_Eighty-Four)）。
- en: The logical NOT operator
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑NOT运算符
- en: 'This is the logical NOT operator:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是逻辑NOT运算符：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is used to test the negation of an expression. If the expression is false,
    then the NOT operator causes the expression to be true.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它用于测试表达式的否定。如果表达式为假，那么NOT运算符会使表达式为真。
- en: For instance, the expression `(!(2+2 == 5))` evaluates to true because 2 + 2
    *is not* 5\. But, a further example of `(!(2 + 2 = 4))` is false. This is because
    2 + 2 *is* obviously 4.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(!(2+2 == 5))`为真，因为2 + 2 *不是* 5。但是，`(!(2 + 2 = 4))`的进一步例子是假的。这是因为2 +
    2 *显然是* 4。
- en: The NOT equal operator
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不等于运算符
- en: 'This is the NOT equal operator and it is another comparison operator:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不等于运算符，它是另一个比较运算符：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The NOT equal operator tests whether something is NOT equal; for example, the`(10
    != 9)` expression is true because 10 is not equal to 9\. On the other hand, `(10
    != 10)` is false because 10 is equal to 10.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于运算符测试是否不相等；例如，`(10 != 9)`表达式为真，因为10不等于9。另一方面，`(10 != 10)`为假，因为10等于10。
- en: The greater-than operator
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大于运算符
- en: 'Another comparison operator (and there are a few more as well) is the greater-than
    operator:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个比较运算符（还有一些其他的）是大于运算符：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This operator tests whether something is greater than something else. The expression
    `(10 > 9)` is true, but the expression `(9 > 10)` is false.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符测试一个值是否大于另一个值。表达式`(10 > 9)`为真，但是表达式`(9 > 10)`为假。
- en: The less-than operator
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小于运算符
- en: 'You can probably guess that this operator tests for values that are less than
    others; here is what the operator looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能猜到了，这个运算符测试一个值是否小于另一个值；这是这个运算符的样子：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The expression `(10 < 9)` is false because 10 is not less than 9, while the
    expression `(9 < 10)` is true.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(10 < 9)`为假，因为10不小于9，而表达式`(9 < 10)`为真。
- en: The greater-than-or-equal-to operator
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大于或等于运算符
- en: 'This operator tests whether one value is greater than or equal to the other,
    and if either is true, the result is true. This is what the operator looks like:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符测试一个值是否大于或等于另一个值，如果其中一个为真，结果就为真。这就是这个运算符的样子：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As an example, the expression `(10 >= 9)`is true, the expression `(10 >= 10)`
    is also true, but the expression `(10 >= 11)` is false because 10 is neither greater
    than nor equal to 11.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表达式`(10 >= 9)`为真，表达式`(10 >= 10)`也为真，但是表达式`(10 >= 11)`为假，因为10既不大于也不等于11。
- en: The less-than-or-equal-to operator
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小于或等于运算符
- en: 'Like the previous operator, this one tests for two conditions, but this time,
    **less** than or equal to; take a look at the following operator:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 像前一个运算符一样，这个运算符测试两个条件，但这次是**小于**或等于；看看下面的运算符：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The expression `(10 <= 9)` is false, the expression `(10 <= 10)` is true, and
    the expression `(10 <= 11)` is also true.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`(10 <= 9)`为假，表达式`(10 <= 10)`为真，表达式`(10 <= 11)`也为真。
- en: The logical AND operator
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑AND运算符
- en: 'This operator is known as logical AND. It tests two or more separate parts
    of an expression, and both or all parts must be true for the entire expression
    to be true:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符称为逻辑AND。它测试表达式的两个或多个独立部分，整个表达式的两个或所有部分都必须为真才能为真：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logical AND is usually used in conjunction with the other operators to build
    more complex tests. The expression `((10 > 9) && (10 < 11))` is true because both
    parts are true. On the other hand, the expression `((10 > 9) && (10 < 9))` is
    false because only one part of the expression is true – `(10 > 9)`, while the
    other is false – `(10 < 9)`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑AND通常与其他运算符一起使用，以构建更复杂的测试。表达式`((10 > 9) && (10 < 11))`为真，因为两个部分都为真。另一方面，表达式`((10
    > 9) && (10 < 9))`为假，因为表达式的一个部分为真-`(10 > 9)`，而另一个部分为假-`(10 < 9)`。
- en: The logical OR operator
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑OR运算符
- en: 'This operator is called logical OR and it is just like logical AND, except
    that only one of two or more parts of an expression needs to be true for the expression
    to be true:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个运算符叫做逻辑OR，它和逻辑AND一样，只是表达式的两个或多个部分中只有一个为真，整个表达式才为真：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Take another look at the previous example that we used for logical AND, but
    instead, replace `&&` with `||`. The expression `((10 > 9) || (10 < 9))` is now
    true because only one or more parts of the expression needs to be true.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 再看一下我们用于逻辑AND的上一个例子，但是，用`||`替换`&&`。表达式`((10 > 9) || (10 < 9))`现在为真，因为表达式的一个或多个部分需要为真。
- en: Seeing these operators in a more practical context, in this chapter and throughout
    the rest of the book, will help to clarify their different uses. Now we know how
    to form expressions with operators, variables, and values. Next, we can look at
    a way of structuring and combining expressions to make several deep decisions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和整本书的其余部分中，以更实际的情境看到这些运算符，将有助于澄清它们的不同用途。现在我们知道如何使用运算符、变量和值来形成表达式。接下来，我们可以看一种结构化和组合表达式的方法，以做出几个深刻的决定。
- en: How to use all these operators to test variables
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用所有这些运算符来测试变量
- en: All these operators are virtually useless without a way of properly using them
    to make real decisions that affect real variables and code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些运算符在没有正确使用它们来做出影响真实变量和代码的真实决定的方法时几乎是无用的。
- en: Now that we have all the information we need, we can look at a hypothetical
    situation, and then actually examine some code for decision making.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了所有需要的信息，我们可以看一个假设的情况，然后实际检查一些决策的代码。
- en: Using the if expression
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用if表达式
- en: As you have seen, operators serve very little purpose on their own, but it is
    useful to see just part of the wide and varied range that is available to us.
    Now when we look at putting the most common operator, `==`, to use, we can start
    to see the powerful, yet fine, control that they offer us.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，运算符本身的作用很小，但看到我们可以使用的广泛和多样的范围的一部分是很有用的。现在当我们开始使用最常见的运算符`==`时，我们可以开始看到它们为我们提供的强大而精细的控制。
- en: 'Let''s make the previous examples less abstract. Meet the **if** expression
    by examining the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过检查以下代码来使之前的示例不那么抽象。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code starts by declaring and initializing an `Int` type called
    `time` to the value of `9`. The next line of code is quite interesting as it does
    two things. The `if(time < 12)` expression is a test; we know that time is less
    than `12` because we just initialized it to `9`. As the condition is true, the
    `if` expression returns the `"am"` value and the first part of the line of code
    before the `if` expression declares and initializes a new `String` type called
    `amOrPm` with that value.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先声明并初始化了一个名为`time`的`Int`类型，其值为`9`。代码的下一行非常有趣，因为它做了两件事。`if(time < 12)`表达式是一个测试；我们知道时间小于`12`，因为我们刚刚将其初始化为`9`。由于条件为真，`if`表达式返回`"am"`值，并且在`if`表达式之前的代码行的第一部分声明并初始化了一个名为`amOrPm`的新`String`类型，并赋予了该值。
- en: 'Had we initialized the `time` variable to any value that was not less than
    12 (that is, 12 or higher) then the value returned would have been `"pm"` from
    the `else` block. If you copy and paste the preceding code into a project, such
    as the `onCreate` function, the output in logcat will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`time`变量初始化为不少于12的任何值（即12或更高），则从`else`块中返回的值将是`"pm"`。如果您将上述代码复制并粘贴到项目中，例如`onCreate`函数，logcat中的输出将如下所示：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `if` expression is evaluated and, if the condition is true, then the code
    in the first set of curly braces (`{…}`) is executed; if the condition is false,
    then the code in the `else {…}` block is executed.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`表达式被评估，如果条件为真，则执行第一组花括号中的代码（`{…}`）；如果条件为假，则执行`else {…}`块中的代码。'
- en: 'It is worth noting that `if` does not have to return a value, rather it could
    simply execute some code based on the result of the test; take a look at the following
    sample code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，`if`不一定要返回一个值，而是可以根据测试的结果执行一些代码；看一下以下示例代码：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding code, there is no returned value; we only care that the correct
    bit of code gets executed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，没有返回值；我们只关心正确的代码部分是否被执行。
- en: Tip
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Technically, there is still a value returned (in this case, true or false),
    but we chose not to do anything with it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，仍然返回一个值（在这种情况下为true或false），但我们选择不对其进行任何操作。
- en: Furthermore, our `if` expression can handle more than two outcomes, as we will
    see later.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的`if`表达式可以处理超过两个结果，我们稍后会看到。
- en: 'We can also use `if` in a String template. We saw in the previous chapter that
    we can insert an expression into a `String` type by inserting the expression between
    curly brackets following the `$` symbol. Here is a reminder of the code from the
    previous chapter:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在String模板中使用`if`。我们在上一章中看到，我们可以通过在`$`符号后的花括号之间插入表达式来将表达式插入到`String`类型中。以下是上一章的代码提醒：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The highlighted part in the preceding code will cause the value of `yearOfBirth`
    that is subtracted from `currentYear` being printed amongst the rest of the message.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中的突出部分将导致从`currentYear`中减去`yearOfBirth`的值被打印在消息的其余部分中。
- en: 'The following code sample shows how we can insert an entire `if` expression
    into a `String` template in the same way:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了我们如何以相同的方式将整个`if`表达式插入到`String`模板中：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding code uses `if` to test whether the `weight` variable was initialized
    to a value that was greater than or equal to 25\. Depending upon whether the expression
    is true, it will add the word `hold` or the word `cabin` into the `String` initialization.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用`if`来测试`weight`变量是否初始化为大于或等于25的值。根据表达式是否为真，它将单词`hold`或单词`cabin`添加到`String`初始化中。
- en: 'If you execute the preceding code, you will get the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行上述代码，您将获得以下输出：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you change the initialization of `weight` to any value under 25 and execute
    the code, you will get the following output:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将`weight`的初始化更改为25以下的任何值并执行代码，您将获得以下输出：
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's take a look at a more complicated example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更复杂的例子。
- en: If they come over the bridge, shoot them!
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果他们过桥，就射击他们！
- en: In the next example, we will use `if`, a few conditional operators, and a short
    story to demonstrate their use.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用`if`，一些条件运算符和一个简短的故事来演示它们的用法。
- en: The captain is dying and, knowing that his remaining subordinates are not very
    experienced, he decides to write a Kotlin program (what else?) to convey his last
    orders after he has died. The troops must hold one side of a bridge while awaiting
    reinforcements, but with a few rules that determine their actions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 船长快要死了，知道他剩下的下属经验不是很丰富，他决定写一个Kotlin程序（还能干什么？）在他死后传达他的最后命令。部队必须守住桥的一侧，等待增援，但有一些规则来决定他们的行动。
- en: 'The first command the captain wants to make sure his troops understand is as
    follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 船长想要确保他的部队理解的第一个命令如下：
- en: '**If they come over the bridge, shoot them.**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果他们过桥，就射击他们。**'
- en: So, how do we simulate this situation in Kotlin? We need a `Boolean` variable
    –`isComingOverBridge`. The next bit of code assumes that the `isComingOverBridge`
    variable has been declared and initialized to either `true` or `false`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何在Kotlin中模拟这种情况呢？我们需要一个`Boolean`变量-`isComingOverBridge`。下一部分代码假设`isComingOverBridge`变量已经被声明并初始化为`true`或`false`。
- en: 'We can then use `if` as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以这样使用`if`：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If the `isComingOverBridge` Boolean is true, the code inside the opening and
    closing curly braces will execute. If `isComingOverBridge` is false, the program
    continues after the `if` block and without running the code within it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`isComingOverBridge`布尔值为true，则大括号内的代码将执行。如果`isComingOverBridge`为false，则程序在`if`块之后继续执行，而不运行其中的代码。
- en: Else do this instead
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 否则，做这个代替
- en: The captain also wants to tell his troops what to do if the enemy is not coming
    over the bridge. In this situation, he wants them to stay where they are and wait.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 船长还想告诉他的部队，如果敌人不从桥上过来，他们应该待在原地等待。
- en: For this, we can use `else`. When we want to explicitly do something when the
    `if` expression does not evaluate to true, we use `else`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们可以使用`else`。当我们希望在`if`表达式不为true时明确执行某些操作时，我们使用`else`。
- en: 'For example, to tell the troops to stay put if the enemy is not coming over
    the bridge, we can write the following code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果敌人不从桥上过来，我们可以编写以下代码告诉部队待在原地：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The captain then realizes that the problem isn't as simple as he first thought.
    What if the enemy comes over the bridge, but has too many troops? His squad will
    be overrun and slaughtered.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然后船长意识到问题并不像他最初想的那么简单。如果敌人从桥上过来，但是部队太多怎么办？他的小队将被压制和屠杀。
- en: 'So, he comes up with the following code (this time, we''ll use some variables
    as well):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，他提出了以下代码（这次，我们也将使用一些变量）：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code has three possible paths of execution. The first is for
    if the enemy is coming over the bridge and the friendly troops are greater in
    number:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码有三条可能的执行路径。第一种情况是，如果敌人从桥上过来，友军数量更多：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The second is for if the enemy troops are coming over the bridge but outnumber
    the friendly troops:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况是，如果敌军正在从桥上过来，但数量超过友军：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The third and final possible outcome that will execute if neither of the other
    two paths are true is captured by the final `else` statement without an `if` condition.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果其他两条路径都不成立，第三种可能的结果是由最终的`else`语句捕获的，没有`if`条件。
- en: Tip
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Reader challenge**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**读者挑战**'
- en: 'Can you spot a flaw with the preceding code? One that might leave a bunch of
    inexperienced troops in complete disarray? The possibility of the enemy troops
    and friendly troops being exactly equal in number has not been handled explicitly
    and will, therefore, be handled by the final `else` statement, which is meant
    for when there are no enemy troops. Any self-respecting captain would expect his
    troops to fight in this situation, and he could have changed the first `if` statement
    to accommodate this possibility, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您能发现上述代码的一个缺陷吗？这可能会让一群经验不足的部队陷入完全混乱的状态？敌军和友军的数量恰好相等的可能性没有得到明确处理，因此将由最终的`else`语句处理，这是用于没有敌军的情况。任何自尊的船长都希望他的部队在这种情况下战斗，他可以改变第一个`if`语句以适应这种可能性，如下所示：
- en: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`if(isComingOverBridge && friendlyTroops >= enemyTroops)`'
- en: 'Finally, the captain''s last concern is that if the enemy comes over the bridge
    waving the white flag of surrender and are promptly slaughtered, then his men
    will end up as war criminals. The code required here is obvious; using the `wavingWhiteFlag`
    Boolean variable, he can write the following test:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，船长最后关心的是，如果敌人拿着白旗投降并立即被屠杀，那么他的士兵将成为战争罪犯。这里需要的代码是显而易见的；使用`wavingWhiteFlag`布尔变量，他可以编写以下测试：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, where to put this code is less clear. In the end, the captain opts
    for the following nested solution, and changing the test for `wavingWhiteFlag`
    to logical NOT, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，放置这段代码的位置不太清楚。最后，船长选择了以下嵌套解决方案，并将`wavingWhiteFlag`的测试更改为逻辑非，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This demonstrates that we can nest `if` and `else` statements inside one another
    in order to create deep and detailed decisions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们可以嵌套`if`和`else`语句以创建深入和详细的决策。
- en: We could go on making more and more complicated decisions with `if` and `else,`
    but what we have seen here is more than enough as an introduction.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续使用`if`和`else`做出更多更复杂的决定，但是我们在这里看到的已经足够作为介绍了。
- en: It is probably worth pointing out that, very often, there is more than one way
    to arrive at a solution to a problem. The *right* way will usually be the way
    that solves the problem in the clearest and simplest manner.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能值得指出的是，很多时候，解决问题有多种方法。*正确*的方法通常是以最清晰和最简单的方式解决问题。
- en: Now we will look at some other ways to make decisions in Kotlin, and then we
    can put them all together in an app.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一些其他在Kotlin中做决策的方法，然后我们可以将它们全部放在一个应用程序中。
- en: Using when to make decisions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`when`进行决策
- en: We have seen the vast and virtually limitless possibilities of combining the
    Kotlin operators with `if` and `else` statements. But, sometimes, a decision in
    Kotlin can be better made in other ways.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了将Kotlin运算符与`if`和`else`语句结合使用的广泛且几乎无限的可能性。但是，有时，在Kotlin中做出决策可能有其他更好的方法。
- en: 'When we want to make decisions and execute different sections of code based
    on a range of possible outcomes, we can use `when`. The following code declares
    and initializes the `rating` variable and then outputs a different response to
    the logcat window based on the value of `rating`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望根据一系列可能的结果做出决策并执行不同的代码段时，我们可以使用`when`。以下代码声明并初始化`rating`变量，然后根据`rating`的值向logcat窗口输出不同的响应：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If you copy and paste the preceding code into the `onCreate` function of an
    app, it will produce the following output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将上述代码复制并粘贴到应用程序的`onCreate`函数中，它将产生以下输出：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The code works by first initializing the `Int` variable, called `rating`, to
    `4`. The `when` block then uses `rating` as its condition:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码首先将名为`rating`的`Int`变量初始化为`4`。然后，`when`块使用`rating`作为条件：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, five separate possibilities for the values that rating could be initialized
    to are handled. For each of the values, `1` through `5`, a different message is
    output to the logcat window:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，处理了评分可能初始化为的五种不同可能性。对于每个值，从`1`到`5`，都会向logcat窗口输出不同的消息：
- en: '[PRE26]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, there is an `else` block that executes if none of the specified options
    are true:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果没有指定的选项为真，则会执行`else`块：
- en: '[PRE27]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Let's take a look at a slightly different usage of `when` by building a small
    demo app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过构建一个小型演示应用程序来看一下`when`的稍微不同的用法。
- en: The When Demo app
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: When Demo应用
- en: To get started, create a new Android project called `When Demo`. Use an **Empty
    Activity** project template and leave all the other options in their usual settings.
    Switch to the `MainActivity.kt` file by left-clicking on the **MainActivity.kt**
    tab above the editor and we can start coding.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，请创建一个名为`When Demo`的新Android项目。使用**空活动**项目模板，并将所有其他选项保持在通常的设置中。通过在编辑器上方单击**MainActivity.kt**标签，切换到`MainActivity.kt`文件，我们可以开始编码。
- en: You can get the code for this app in the `Chapter08/When Demo` folder of the
    download bundle. The file also includes code that is related to our previous discussions
    on expressions and `if`. Why not play around with the code, run the app, and study
    the output?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在下载包的`Chapter08/When Demo`文件夹中获取此应用的代码。该文件还包括与我们先前讨论的表达式和`if`相关的代码。为什么不尝试玩一下代码，运行应用程序并研究输出呢？
- en: 'Add the following code inside the `onCreate` function. The app demonstrates
    that multiple different values can trigger the same path of execution:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数内添加以下代码。该应用程序演示了多个不同的值可以触发相同执行路径：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, there are four possible paths of execution based on
    the value that the `name` variable is initialized to. If any of the `Atlantic`,
    `Pacific`, or `Arctic` values are used, then the following line of code is executed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，根据`name`变量初始化的值，有四条可能的执行路径。如果使用`Atlantic`、`Pacific`或`Arctic`的任何一个值，则执行以下代码行：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If any of the `Thames`, `Nile`, or `Mississippi` values are used, then the
    following line of code is executed:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`Thames`、`Nile`或`Mississippi`的任何一个值，则执行以下代码行：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If any of the = `Labrador`, `Beagle`, or `Jack Russel` values are used, then
    the following line of code is executed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用了`Labrador`、`Beagle`或`Jack Russel`的任何一个值，则执行以下代码行：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If none of the oceans, rivers, or dogs are used to initialize the `name` variable,
    then the app branches to the `else` block and executes this line of code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用海洋、河流或狗来初始化`name`变量，则应用程序将分支到`else`块并执行以下代码行：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you execute the app with `name` initialized to `Nile` (as the preceding
    code does), this is the output that you will see in the logcat window:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`name`初始化为`Nile`（如前面的代码所做的那样）执行应用程序，则将在logcat窗口中看到以下输出：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the app a few times and, each time, change the initialization of `name`
    to something new. Notice that when you initialize `name` to something that is
    explicitly handled by a statement, we get the expected output. Otherwise, we get
    the default output handled by the `else` block.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用几次，每次将`name`的初始化更改为新的内容。注意，当您将`name`初始化为一个明确由语句处理的内容时，我们会得到预期的输出。否则，我们会得到`else`块处理的默认输出。
- en: 'If we have a lot of code to execute for an option in a `when` block, we can
    contain it all in a function and then call that function. I have highlighted the
    changed line in the following hypothetical code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有很多代码要在`when`块中的选项中执行，我们可以将所有代码都放在一个函数中，然后调用该函数。我在以下假设的代码中突出显示了更改的行：
- en: '[PRE34]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Of course, we will then need to write the new `printFullDetailsOfOcean` function.
    Then, when `name` is initialized to one of the oceans explicitly handled, the
    `printFullDetailsOfOcean` function will be executed. The execution will then return
    to the first line of code outside the `when` block.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将需要编写新的`printFullDetailsOfOcean`函数。然后，当`name`初始化为一个明确由语句处理的海洋之一时，将执行`printFullDetailsOfOcean`函数。然后执行将返回到`when`块之外的第一行代码。
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You might be wondering about the significance of placing the `name` variable
    in the brackets of the `printFullDetailsOfOcean(name)` function call. What is
    happening is that we are passing the data stored in the `name` variable to the
    `printFullDetailsOfOcean` function. This then means that the `printFullDetailsOfOcean`
    function can use that data. This will be covered in more detail in the next chapter.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道将`name`变量放在`printFullDetailsOfOcean(name)`函数调用的括号中的意义。发生的情况是，我们将存储在`name`变量中的数据传递给`printFullDetailsOfOcean`函数。这意味着`printFullDetailsOfOcean`函数可以使用该数据。这将在下一章中更详细地介绍。
- en: Of course, one of the things that this code seriously lacks is interaction with
    a GUI. We have seen how we can call functions from button clicks, but even that
    isn't enough to make this code worthwhile in a real app. We will see how we solve
    this problem in [Chapter 12](ch12.html "Chapter 12. Connecting Our Kotlin to the
    UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这段代码严重缺乏与GUI的交互。我们已经看到如何从按钮点击中调用函数，但即使这样也不足以使这段代码在真正的应用程序中有价值。我们将在[第12章](ch12.html
    "第12章。将Kotlin连接到UI和可空性")中看到我们如何解决这个问题，*将我们的Kotlin连接到UI和可空性*。
- en: The other problem we have is that after the code has been executed, then that's
    it – the app won't do anything else! We need it to continually ask the user for
    instructions, not just once, but over and over. We will look at a solution to
    this problem next.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有另一个问题，那就是代码执行完毕后，就什么都不做了！我们需要它不断地询问用户的指令，不只是一次，而是一遍又一遍。我们将在下一步解决这个问题。
- en: Repeating code with loops
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用循环重复代码
- en: Here, we will learn how to repeatedly execute portions of our code in a controlled
    and precise way by looking at several types of **loop** in Kotlin. These include
    `while` loops, `do-while` loops, and `for` loops. We will also learn about the
    most appropriate situations in which to use these different types of loops.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将通过查看Kotlin中的几种**循环**类型，包括`while`循环、`do-while`循环和`for`循环，学习如何以受控且精确的方式重复执行代码的部分。我们还将了解在何种情况下使用这些不同类型的循环是最合适的。
- en: It is completely reasonable to ask what loops have to do with programming, but
    they are exactly what the name implies. They are a way of repeating the same part
    of the code more than once, or looping over the same part of code, although, potentially
    for a different outcome each time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 询问循环与编程有什么关系是完全合理的，但它们确实如其名称所示。它们是重复执行代码的一种方式，或者循环执行相同的代码部分，尽管每次可能会有不同的结果。
- en: This can simply mean doing the same thing until the code being looped over (**iterated**)
    prompts the loop to end. It could be a predetermined number of iterations as specified
    by the loop code itself. It might be until a predetermined situation or **condition**
    is met. Or, it could be a combination of these things. Along with `if`, `else`,
    and `when`, loops are part of the Kotlin **control flow statements**.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能意味着重复执行相同的操作，直到循环的代码提示循环结束。它可以是由循环代码本身指定的预定次数的迭代。它可能是直到满足预定情况或**条件**为止。或者，它可能是这些事情的组合。除了`if`、`else`和`when`，循环也是Kotlin**控制流语句**的一部分。
- en: We will look at all the major types of loop that Kotlin offers us to control
    our code, and we will use some of them to implement a working mini-app to make
    sure that we understand them completely. Let's take a look at the first and simplest
    loop type in Kotlin, the `while` loop.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习Kotlin提供的所有主要类型的循环，使用其中一些来实现一个工作的迷你应用程序，以确保我们完全理解它们。让我们先看一下Kotlin中的第一种和最简单的循环类型，即`while`循环。
- en: while loops
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: 'Kotlin `while` loops have the simplest syntax. Think back to the `if` statements
    for a moment; we could use virtually any combination of operators and variables
    in the conditional expression of the `if` statement. If the expression evaluated
    to true, then the code in the body of the `if` block is executed. With the `while`
    loop, we also use an expression that can evaluate to true or false:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的`while`循环具有最简单的语法。回想一下`if`语句；我们可以在`if`语句的条件表达式中使用几乎任何组合的运算符和变量。如果表达式评估为真，则执行`if`块中的代码。对于`while`循环，我们也使用一个可以评估为真或假的表达式：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Take a look at the preceding code; what happens here is as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下上述代码；这里发生的情况如下：
- en: Outside of the `while` loop, an `Int` type named `x` is declared and initialized
    to 10\.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`while`循环之外，声明了一个名为`x`的`Int`类型，并将其初始化为10。
- en: Then, the `while` loop begins; its condition is `x > 0`. So, the `while` loop
    will execute the code in its body.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`while`循环开始；它的条件是`x > 0`。因此，`while`循环将执行其主体中的代码。
- en: The code in its body will repeatedly execute until the condition evaluates to
    false.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 循环体中的代码将重复执行，直到条件评估为假。
- en: So, the preceding code will execute 10 times.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上述代码将执行10次。
- en: On the first pass, `x` equals 10 on the second pass it equals 9, then 8, and
    so on. But once `x` is equal to 0, it is, of course, no longer greater than 0\.
    At this point, the execution will exit the `while` loop and continue with the
    first line of code (if any) after the `while` loop.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次循环中，`x`等于10，在第二次循环中，它等于9，然后是8，依此类推。但一旦`x`等于0，它当然不再大于0。此时，执行将退出`while`循环，并继续执行`while`循环之后的第一行代码（如果有的话）。
- en: 'In the same way as an `if` statement, it is possible that the `while` loop
    will not execute even once. Take a look at the following example, where the code
    in the `while` loop will not execute:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，`while`循环可能甚至不会执行一次。看一下以下示例，`while`循环中的代码将不会执行：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Moreover, there is no limit to the complexity of the conditional expression
    or the amount of code that can go in the loop body; here is another example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，条件表达式的复杂度或循环体中的代码量没有限制；以下是另一个例子：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding `while` loop will continue to execute until both `newMessages`
    and `unreadMessages` are equal to, or less than, zero. As the condition uses the
    logical OR operator (`||`), either one of those conditions being true will cause
    the `while` loop to continue executing.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`while`循环将继续执行，直到`newMessages`和`unreadMessages`都等于或小于零。由于条件使用逻辑或运算符(`||`)，其中一个条件为真将导致`while`循环继续执行。
- en: 'It is worth noting that once the body of the loop has been entered, it will
    always complete, even if the expression evaluates to false part of the way through.
    This is because it is not tested again until the code tries to start another pass:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，一旦进入循环体，即使表达式在中途评估为假，循环体也会始终完成。这是因为直到代码尝试开始另一次循环时才会再次测试：
- en: '[PRE38]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding loop body will execute exactly once. We can also set a `while`
    loop that will run forever! This is called an **infinite loop**; here is an example
    of an infinite loop:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 上述循环体将执行一次。我们还可以设置一个永远运行的`while`循环！这被称为**无限循环**；以下是一个无限循环的例子：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding code will never end; it will loop round and round forever. We
    will see some solutions for controlling when to break out of a `while` loop shortly.
    Next, we will look at a variation on the `while` loop.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将永远不会结束；它将永远循环。我们将看到一些控制何时跳出`while`循环的解决方案。接下来，我们将看一下`while`循环的变体。
- en: do-while loops
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do-while循环
- en: 'The `do` – `while` loop works in the same way as the ordinary `while` loop
    except that the presence of a `do` block guarantees that the code will execute
    at least once, even when the condition of the `while` expression does not evaluate
    to true:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`do`-`while`循环的工作方式与普通的`while`循环相同，只是`do`块的存在保证了即使`while`表达式的条件不评估为真，代码也会至少执行一次：'
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If you copy and paste this code into one of your apps in the `onCreate` function,
    and then execute it, the output might not be what you expect. Here is the output:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将此代码复制并粘贴到`onCreate`函数中的一个应用程序中，然后执行它，输出可能不是您所期望的。以下是输出：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is a less-used but sometimes perfect solution for a problem. Even though
    the condition of the `while` loop is false, the `do` block executes its code,
    increments the `y` variable to 11, and prints a message to logcat. The condition
    of the `while` loop is `y < 10`, so the code in the `do` block is not executed
    again. If the expression in the `while` condition is true, however, then the code
    in the `do` block continues to execute as though it was a regular `while` loop.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个不太常用但有时是解决问题的完美方案。即使`while`循环的条件为假，`do`块也会执行其代码，将`y`变量递增到11，并打印一条消息到logcat。`while`循环的条件是`y
    < 10`，因此`do`块中的代码不会再次执行。但是，如果`while`条件中的表达式为真，则`do`块中的代码将继续执行，就像是常规的`while`循环一样。
- en: Ranges
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 范围
- en: In order to continue our discussion on loops, it is necessary to briefly introduce
    the topic of ranges. Ranges are intimately connected to the Kotlin topic of arrays,
    which we will discuss more fully in [Chapter 15](ch15.html "Chapter 15. Handling
    Data and Generating Random Numbers"), *Handling Data and Generating Random Numbers*.
    What follows is a quick introduction to ranges to enable us to then go on to cover
    `for` loops.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续讨论循环，有必要简要介绍范围的主题。范围与 Kotlin 的数组主题密切相关，我们将在[第15章](ch15.html "第15章。处理数据和生成随机数")*处理数据和生成随机数*中更全面地讨论。接下来是对范围的快速介绍，以便我们能够继续讨论`for`循环。
- en: 'Take a look at the following line of code that uses a range:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下使用范围的以下代码行：
- en: '[PRE42]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: What is happening is that we are using type inference to create a list of values
    that contains the values 1, 2, 3, and 4\.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的情况是，我们使用类型推断来创建一个值的列表，其中包含值1、2、3和4。
- en: 'We can also explicitly declare and initialize a list, as in the following code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以显式声明和初始化一个列表，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding code uses the `listOf` keyword to explicitly create a list containing
    the numbers 1 through to 10 inclusively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码使用`listOf`关键字来显式创建一个包含1到10的数字的列表。
- en: How these work under the hood will be explored in more depth when we learn about
    arrays in [Chapter 15](ch15.html "Chapter 15. Handling Data and Generating Random
    Numbers"), *Handling Data and Generating Random Numbers*. Then, we will see that
    there is much more to ranges, arrays, and lists than we have covered here. It
    is just helpful to have this quick introduction to complete our discussion of
    loops by looking at the `for` loop.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学习关于数组的更深入的知识时，我们将更深入地探讨它们的工作原理，[第15章](ch15.html "第15章。处理数据和生成随机数")*处理数据和生成随机数*。然后，我们将看到范围、数组和列表比我们在这里涵盖的要多得多。通过查看`for`循环，这个快速介绍有助于我们完成对循环的讨论。
- en: For loops
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: For循环
- en: 'To use a `for` loop, we need a range or list. We can then use a `for` loop
    to step through that list and execute some code in each step; take a look at the
    following example:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`for`循环，我们需要一个范围或列表。然后，我们可以使用`for`循环来遍历该列表，并在每一步执行一些代码；看一下以下示例：
- en: '[PRE44]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Take a look at the output this will produce if copied and pasted into an app:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下如果将此内容复制并粘贴到应用程序中会产生的输出：
- en: '[PRE45]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see from the output that the `list` variable does indeed contain all
    the values from 1 through to 10\. On each pass through the loop, the `i` variable
    holds the current value. You can also see that the `for` loop allows us to iterate
    through all those values and execute some code based on those values.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，`list`变量确实包含从1到10的所有值。在每次循环中，`i`变量保存当前值。您还可以看到，`for`循环允许我们遍历所有这些值，并根据这些值执行一些代码。
- en: 'Furthermore, we can use the opening and closing curly braces with a `for` loop
    when we want the loop to contain multiple lines of code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们希望循环包含多行代码时，可以在`for`循环中使用开放和关闭的大括号：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In Kotlin, the `for` loop is extremely flexible and can handle much more than
    just simple `Int` values. We will not explore all the options in this chapter
    because we need to learn more about classes first. We will, however, be returning
    to the `for` loop in a number of places throughout the rest of the book.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`for`循环非常灵活，可以处理的不仅仅是简单的`Int`值。在本章中，我们不会探讨所有选项，因为我们需要先了解更多关于类的知识。然而，在本书的其余部分，我们将在许多地方回到`for`循环。
- en: Controlling loops with break and continue
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`break`和`continue`控制循环
- en: Having just discussed all the ways that we can control looping through code,
    it is important to know that sometimes we need to break out of a loop earlier
    than the condition of the loop specifies.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚讨论了通过代码控制循环的所有方法，重要的是要知道，有时我们需要提前退出循环，而不是按照循环的条件指定的那样执行。
- en: 'For such occasions, Kotlin has the `break` keyword. Here is `break` in action
    with a `while` loop:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，Kotlin 有`break`关键字。以下是`break`在`while`循环中的作用：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, the condition of the `while` loop should make the code
    repeatedly execute while the `countDown` variable is greater than zero. However,
    inside the `while` loop, there is an `if` expression that checks to see whether
    `countDown` is equal to 5\. If it is equal to 5, the `break` statement is used.
    Also, inside the `while` loop, the value of `countDown` is printed to the logcat
    window and is decremented (reduced by 1). Take a look at the following output
    when this code is executed:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，`while`循环的条件应该使代码在`countDown`变量大于零时重复执行。然而，在`while`循环内部，有一个`if`表达式，检查`countDown`是否等于5。如果等于5，则使用`break`语句。此外，在`while`循环内部，`countDown`的值被打印到logcat窗口，并递减（减少1）。当执行此代码时，看一下以下输出：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can see from the preceding output that when `countDown` equals 5, the `break`
    statement executes, and execution exits the `while` loop before it gets to print
    to the logcat window.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的输出可以看出，当`countDown`等于5时，`break`语句执行，执行提前退出`while`循环，而不会打印到logcat窗口。
- en: 'Sometimes, we might want to execute only a part of the code within a loop but
    not stop looping entirely. For this, Kotlin has the `continue` keyword. Take a
    look at the following code with a `while` loop, which demonstrates how we can
    make use of `continue` in our apps:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能只想执行循环中的一部分代码，而不是完全停止循环。为此，Kotlin有`continue`关键字。看看下面的带有`while`循环的代码，它演示了我们如何在应用程序中使用`continue`：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In the preceding code, we initialize a variable called `countUp` to zero. We
    then set up a `while` loop to keep executing while `countUp` is less than 10\.
    Inside the `while` loop, we increment (increase by 1) `countUp`. The next line
    of code checks to see whether `countUp` is greater than 5 and, if it is, the `continue`
    statement is executed. The next line of code prints the value of `countUp` to
    the logcat window. The line of code that prints the value will only execute when
    `countUp` is 5 or lower because the `continue` statement sends the execution of
    the app back to the start of the loop. Take a look at the following output of
    code to verify what is happening:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将一个名为`countUp`的变量初始化为零。然后我们设置了一个`while`循环，当`countUp`小于10时继续执行。在`while`循环内部，我们增加（加1）`countUp`。下一行代码检查`countUp`是否大于5，如果是，就执行`continue`语句。下一行代码将`countUp`的值打印到logcat窗口。只有当`countUp`为5或更低时，打印值的代码行才会执行，因为`continue`语句将应用程序的执行返回到循环的开始。看看下面的代码输出，以验证发生了什么：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can see in the preceding output that `countUp` is printed while its value
    is 5 or lower. Once its value exceeds 5, the `continue` statement prevents the
    line of code that does the printing from being executed. However, the final line
    of code outside the loop prints the value of `countUp`, and you can see that its
    value is 10, indicating that the first line of code in the loop, which increments
    `countUp`, executed continuously through to the completion of the `while` loop
    condition.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在前面的输出中看到，当`countUp`的值为5或更低时，它被打印出来。一旦它的值超过5，`continue`语句将阻止执行打印的代码行。然而，循环外的最后一行代码打印了`countUp`的值，你可以看到它的值是10，这表明循环中的第一行代码，即增加`countUp`的代码，一直执行到`while`循环条件完成。
- en: The `break` and `continue` keywords can also be used in `for` loops and `do`
    – `while` loops.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`和`continue`关键字也可以用在`for`循环和`do`-`while`循环中。'
- en: Sample code
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: If you want to play around with loop code, you can create a new project called
    `Loops Demo` and copy any of the code from this chapter into the end of the `onCreate`
    function. I have placed the code that we have used throughout our discussion of
    loops in the `Chapter08/Loops Demo` folder.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想玩转循环代码，可以创建一个名为`Loops Demo`的新项目，并将本章中的任何代码复制到`onCreate`函数的末尾。我已经将我们在讨论循环时使用的代码放在了`Chapter08/Loops
    Demo`文件夹中。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we used `if`, `else`, and `when` to make decisions with expressions
    and branch our code. We saw and practiced with `while`, `for`, and `do`- `while`
    to repeat parts of our code. Furthermore, we used `break` for breaking out of
    a loop before the condition would otherwise allow, and we used `continue` to conditionally
    execute only part of the code in a loop.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用`if`、`else`和`when`来做出表达式的决策并分支我们的代码。我们看到并练习了`while`、`for`和`do`-`while`来重复我们代码的部分。此外，我们使用`break`在条件允许之前跳出循环，并使用`continue`有条件地执行循环中的部分代码。
- en: It doesn't matter if you don't remember everything straight away, as we will
    constantly be using all these techniques and keywords throughout the book. We
    will also explore a number of more advanced ways to use some of these techniques.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不记得所有内容也没关系，因为我们将不断地在整本书中使用所有这些技术和关键字。我们还将探索一些更高级的使用这些技术的方法。
- en: In the next chapter, we will take a much closer look at Kotlin functions, which
    is where all our tests and loops code will go.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将更仔细地研究Kotlin函数，这是我们所有测试和循环代码的去处。
