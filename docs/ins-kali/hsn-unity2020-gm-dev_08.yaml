- en: '*Chapter 8*: Lighting Using the Universal Render Pipeline'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：使用通用渲染管线进行照明'
- en: '**Lighting** is a complex topic and there are several possible ways to handle
    it, with each one having its pros and cons. In order to get the best possible
    quality at the best performance, you need to know exactly how your renderer handles
    it, and that is exactly what we are going to do in this chapter. We will discuss
    how lighting is handled in Unity''s **Universal Render Pipeline** (**URP**), as
    well as how to properly configure it to adapt our scene''s mood with proper lighting
    effects.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**照明**是一个复杂的主题，有几种可能的处理方式，每种方式都有其优缺点。为了在最佳性能下获得最佳质量，您需要确切了解您的渲染器如何处理它，这正是我们将在本章中要做的。我们将讨论Unity的**通用渲染管线**（**URP**）中如何处理照明，以及如何正确配置它以适应我们场景的氛围和适当的照明效果。'
- en: 'In this chapter, we will examine the following lighting concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下照明概念：
- en: Applying lighting
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用照明
- en: Applying shadows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用阴影
- en: Optimizing lighting
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化照明
- en: Applying lighting
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用照明
- en: 'When discussing ways to process lighting in a game, there are two main ways
    we can do so, known as **Forward Rendering** and **Deferred Rendering**. Both
    handle lighting in a different order, with different techniques, requirements,
    pros, and cons. Forward Rendering is usually recommended for performance, while
    Deferred Rendering is usually recommended for quality. The latter is used by the
    **High Definition Render Pipeline** of Unity, the renderer used for high-quality
    graphics in high-end devices. At the time of writing this book, Unity is developing
    a performant version for URP. Also, in Unity, Forward Renderer comes in two flavors:
    **Multi-Pass Forward**, which is used in the built-in renderer (the old Unity
    renderer), and **Single Pass Forward,** which is used in URP. Again, each has
    its pros and cons.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论游戏中处理照明的方式时，我们可以使用两种主要方式，称为**前向渲染**和**延迟渲染**。两者以不同的顺序处理照明，具有不同的技术、要求、优缺点。前向渲染通常推荐用于性能，而延迟渲染通常推荐用于质量。后者被Unity的**高清晰度渲染管线**使用，这是用于高端设备高质量图形的渲染器。在撰写本书时，Unity正在为URP开发一个高性能版本。此外，在Unity中，前向渲染有两种类型：**多通道前向**，用于内置渲染器（旧的Unity渲染器），以及**单通道前向**，用于URP。同样，每种方法都有其优缺点。
- en: Important information
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Actually, there are other options available, both official and third-party,
    such as **Vertex Lit**, but for now, we will focus on the three main ones – the
    ones you use 95% of the time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有其他可用的选项，包括官方和第三方的选项，比如**顶点光照**，但暂时我们将专注于三种主要的选项 - 您95%的时间使用的选项。
- en: Choosing between one or another depends on the kind of game you are creating
    and the target platform you need to run the game on. Your chosen option will change
    a lot due to the way you apply lighting to your scene, so it's crucial you understand
    which system you are dealing with.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 选择其中一种取决于您正在创建的游戏类型以及您需要在哪个目标平台上运行游戏。由于您应用照明到场景的方式，您选择的选项将发生很大变化，因此您必须了解您正在处理的系统。
- en: 'In this section, we will discuss the following Realtime lighting concepts:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论以下实时照明概念：
- en: Discussing lighting methods
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: Configuring ambient lighting with skyboxes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用天空盒配置环境光照
- en: Configuring lighting in URP
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URP中配置照明
- en: Let's start by comparing the previously mentioned lighting methods.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始比较先前提到的照明方法。
- en: Discussing lighting methods
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论照明方法
- en: 'To recap, we mentioned three main ways of processing lighting:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们提到了三种主要的处理照明的方式：
- en: Forward Rendering (Single Pass)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（单通道）
- en: Forward Rendering (Multi-Pass)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前向渲染（多通道）
- en: Deferred Rendering
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟渲染
- en: 'Before we look at the differences between each, let''s talk about the things
    they have in common. Those three renderers start drawing the scene by determining
    which objects can be seen by the camera; that is, the ones that fall inside the
    camera''s frustum, and provide a giant pyramid that can be seen when you select
    the camera:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论它们之间的差异之前，让我们谈谈它们共同的特点。这三种渲染器都通过确定相机可以看到哪些对象来开始绘制场景；也就是说，那些落在相机截锥体内的对象，并在选择相机时提供一个巨大的金字塔。
- en: '![Figure 8.1 – The camera''s frustum showing only the objects that can be seen
    by it'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 - 相机的截锥体只显示可以看到的对象'
- en: '](img/Figure_8.01_B14199.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B14199.jpg)'
- en: Figure 8.1 – The camera's frustum showing only the objects that can be seen
    by it
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - 相机的截锥体只显示可以看到的对象
- en: After that, Unity will order them from the nearest to the camera to the farthest
    (transparent objects are handled a little bit differently, but let's ignore that
    for now). It's done like this because it's more probable that objects nearer to
    the camera will cover most of the camera, so they will occlude others, preventing
    us from wasting resources calculating pixels for the occluded ones.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Unity将按照距离相机最近到最远的顺序对它们进行排序（透明对象处理方式略有不同，但暂时忽略）。这样做是因为更有可能靠近相机的对象将覆盖大部分相机，因此它们将遮挡其他对象，防止我们浪费资源计算被遮挡的像素。
- en: 'Finally, Unity will try to render the objects in that order. This is where
    differences start to arise between lighting methods, so let''s start comparing
    the two Forward Rendering variants. For each object, Single Pass Forward Rendering
    will calculate the object´s appearance, including all the lights that are affecting
    the object, in one shot, or what we call a **Draw Call**. A Draw Call is the exact
    moment when Unity asks the video card to actually render the specified object.
    All the previous work was just preparation for this moment. In the case of the
    Multi-Pass Forward Renderer, by simplifying a little bit of the actual logic,
    Unity will render the object once per light that affects the object. So, if the
    object is being lit by three lights, Unity will render the object three times,
    meaning that three Draw Calls will be issued, and three calls to the GPU will
    be made to execute the rendering process:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Unity将尝试按照这个顺序渲染对象。这就是光照方法之间开始出现差异的地方，所以让我们开始比较这两种前向渲染变体。对于每个对象，单次渲染将在一个绘制调用中计算对象的外观，包括所有影响对象的光源，或者我们称之为**绘制调用**。绘制调用是Unity要求显卡实际渲染指定对象的确切时刻。之前的所有工作只是为了这一刻做准备。在多次渲染前向渲染器的情况下，简化一点实际逻辑，Unity将为影响对象的每个光源渲染一次对象。因此，如果对象受到三个光源的照明，Unity将渲染对象三次，这意味着将发出三个绘制调用，并将执行渲染过程的GPU进行三次调用：
- en: '![Figure 8.2 – Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; right image, the
    combination of both Draw Calls'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 左图，多次渲染中受两个光源影响的球体的第一个绘制调用；中间图，球体的第二个绘制调用；右图，两个绘制调用的组合'
- en: '](img/Figure_8.02_B14199(Merged).jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B14199(Merged).jpg)'
- en: Figure 8.2 – Left image, first draw call of a sphere affected by two lights
    in Multi-Pass; middle image, second draw call of the sphere; right image, the
    combination of both Draw Calls
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 左图，多次渲染中受两个光源影响的球体的第一个绘制调用；中间图，球体的第二个绘制调用；右图，两个绘制调用的组合
- en: Now is when you are probably thinking, *"Why should I use Multi-Pass? Single-Pass
    is more performant!"* And yes, you are right! Single-Pass is way more performant
    than Multi-Pass, and here comes the great bit. A Draw Call in a GPU has a limited
    amount of operations that can be executed, so you have a limit to the complexity
    of the Draw Call. Calculating the appearance of an object and all the lights that
    affect it is very complex, and in order to make it fit in just one Draw Call,
    Single Pass executes simplified versions of lighting calculations, meaning less
    lighting quality and features. They also have a limit on how many lights can be
    handled in one shot, which, at the time of writing this book, is eight per object
    (four for low-end devices). This sounds like a small number, but it's usually
    just enough.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能在想，“为什么我要使用多次渲染？单次渲染更高效！”是的，你是对的！单次渲染比多次渲染更高效，这就是其中的好处。GPU中的绘制调用有一定数量的操作可以执行，因此绘制调用的复杂度有限。计算对象的外观和所有影响它的光源是非常复杂的，为了使其适应一个绘制调用，单次渲染执行了简化版本的光照计算，这意味着光照质量和功能较少。它们还有一个限制，即一次只能处理多少个光源，目前写作本书时，每个对象的限制是八个（低端设备为四个）。这听起来像是一个小数字，但通常足够了。
- en: 'On the other side, Multi-Pass can apply any number of lights you want and can
    execute different logic for each light. Let''s say our object has four lights
    that are affecting it, but there are two lights that are affecting it drastically
    because they are nearer or have higher intensity, while the remaining ones affecting
    the object are just enough to be noticeable. In this scenario, we can render the
    first two lights with higher quality and the remaining ones with cheap calculations
    – no one will be able to tell the difference. In this case, Multi-Pass can calculate
    the first two lights using **Pixel Lighting** and the remaining ones using **Vertex
    Lighting**. The difference is in their names; Pixel calculates light per object''s
    pixel, while Vertex calculates light per object vertex and fills the pixels between
    these vertexes, thereby interpolating information between vertexes. You can clearly
    see the difference in the following images:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多次渲染可以应用任意数量的光源，并且可以为每个光源执行不同的逻辑。假设我们的物体受到四个光源的影响，但有两个光源对其影响很大，因为它们更近或强度更高，而其余的光源对物体的影响只是足够让人注意到。在这种情况下，我们可以使用更高质量的方式渲染前两个光源，而用廉价的计算渲染其余的光源——没有人能够察觉到区别。在这种情况下，多次渲染可以使用像素光照计算前两个光源，而使用顶点光照计算其余的光源。它们的区别在于它们的名称；像素光照按对象像素计算光照，而顶点光照按对象顶点计算光照，并填充这些顶点之间的像素，从而在顶点之间插值信息。您可以清楚地看到以下图像中的区别：
- en: '![Figure 8.3 – Left image, a sphere being rendered with Vertex Lighting; right
    image, a sphere being rendered with Pixel Lighting)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 左图，使用顶点光照渲染的球体；右图，使用像素光照渲染的球体)'
- en: '](img/Figure_8.03_B14199(Merged).jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.03_B14199(Merged).jpg)'
- en: Figure 8.3 – Left image, a sphere being rendered with Vertex Lighting; right
    image, a sphere being rendered with Pixel Lighting)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 左图，使用顶点光照渲染的球体；右图，使用像素光照渲染的球体)
- en: In Single Pass, calculating everything in a single draw call forces you to use
    Vertex Lighting or Pixel Lighting; you cannot combine them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在单次渲染中，将所有内容都计算在一个绘制调用中会迫使你使用顶点光照或像素光照；你不能将它们结合起来。
- en: So, to summarize the differences between Single and Multi-Pass, in Single Pass,
    you have better performance because each object is just drawn once, but you are
    limited to the number of lights that can be applied, while in Multi-Pass, you
    need to render the object several times, but with no limits on the number of lights,
    and you can specify the exact quality you want for each light. There are other
    things to consider, such as the actual cost of a Draw Call (one Draw Call can
    be more expensive than two simple ones), and special lighting effects such as
    toon shading, but let's keep things simple.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下单通道和多通道之间的区别，在单通道中，性能更好，因为每个对象只绘制一次，但你只能应用有限数量的光照，而在多通道中，你需要多次渲染对象，但没有光照数量的限制，并且你可以为每个光源指定精确的质量。还有其他需要考虑的事情，比如绘制调用的实际成本（一个绘制调用可能比两个简单的绘制更昂贵），以及特殊的光照效果，比如卡通着色，但让我们保持简单。
- en: 'Finally, let''s briefly discuss Deferred. Even though we are not going to use
    it, it''s interesting to know why we are not doing that. After determining which
    objects fall inside the frustum and ordering them, Deferred will render the objects
    without any lighting, generating what is called a **G-Buffer**. A G-Buffer is
    a set of several images that contain different information about the objects of
    the scene, such as the colors of its pixels (without lighting), the direction
    of each pixel (known as **Normals**), and how far from the camera the pixels are.
    You can see a typical example of a G-Buffer in the following figure:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们简要讨论一下延迟渲染。尽管我们不打算使用它，但了解为什么我们不这样做是很有趣的。在确定哪些对象落在视锥体内并对它们进行排序之后，延迟将渲染对象而不进行任何光照，生成所谓的**G-Buffer**。G-Buffer是一组包含有关场景对象的不同信息的图像，例如其像素的颜色（不带光照），每个像素的方向（称为**法线**），以及离摄像机的距离。你可以在以下图中看到G-Buffer的典型示例：
- en: '![Figure 8.4 – Left image, plain colors of the object; middle image,'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 - 左图，对象的纯色；中图，'
- en: depths of each pixel; right image, normals of the pixels
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个像素的深度；右图，像素的法线
- en: '](img/Figure_8.04_B14199(Merged).jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B14199(Merged).jpg)'
- en: Figure 8.4 – Left image, plain colors of the object; middle image, depths of
    each pixel; right image, normals of the pixels
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - 左图，对象的纯色；中图，每个像素的深度；右图，像素的法线
- en: Important information
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: Normals are directions, and the (X,Y,Z) components of the directions are encoded
    in the RGB components of the colors.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 法线是方向，方向的（X，Y，Z）分量被编码在颜色的RGB分量中。
- en: 'After rendering all the objects in the scene, Unity will iterate over all lights
    that can be seen in the camera, thus applying a layer of lighting over the G-Buffer,
    taking information from it to calculate that specific light. After all the lights
    have been processed, you will get the following result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染场景中的所有对象之后，Unity将迭代所有可以在相机中看到的光源，从而在G-Buffer上应用一层光照，从中获取信息来计算特定的光照。在所有光源都被处理之后，你将得到以下结果：
- en: '![Figure 8.5 – Combination of the three lights that were applied to the G-Buffer
    shown in the previous image'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 - 应用于上一图像中的G-Buffer的三种光的组合'
- en: '](img/Figure_8.05_B14199.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.05_B14199.jpg)'
- en: Figure 8.5 – Combination of the three lights that were applied to the G-Buffer
    shown in the previous image
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - 应用于上一图像中的G-Buffer的三种光的组合
- en: As you can see, the Deferred part of this method comes from the idea of calculating
    lighting as the last stage of the rendering process. This is better because you
    won't waste resources calculating lighting from objects that could potentially
    be occluded. If the floor of the image is being rendered first in Forward, the
    pixels that the rest of the objects are going to occlude were calculated in vain.
    Also, there's the detail that Deferred just calculates lighting in the exact pixels
    that the light can reach. As an example, if you are using a flashlight, Unity
    will calculate lighting only in the pixels that fall inside the cone of the flashlight.
    The con here is that Deferred is not supported by some relatively old video cards
    and that you can't calculate lighting with Vertex Lighting quality, so you will
    need to pay the price of Pixel Lighting, which is not recommended on low-end devices
    (or even necessary in simple graphics games).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种方法的延迟部分来自于将照明计算作为渲染过程的最后阶段的想法。这样做更好，因为你不会浪费资源计算可能被遮挡的物体的照明。如果在前向渲染中首先渲染图像的底部，那么其余物体将遮挡的像素就是徒劳的计算。此外，延迟只计算光照能够到达的确切像素。例如，如果你使用手电筒，Unity只会在手电筒锥体内的像素中计算光照。缺点是，一些相对较旧的显卡不支持延迟，而且你无法使用顶点光照质量来计算照明，因此你将需要付出像素光照的代价，这在低端设备上不被推荐（甚至在简单的图形游戏中也不需要）。
- en: So, why are we using URP with Single Pass Forward? Because it offers the best
    balance between performance, quality, and simplicity. In this game, we won't be
    using too many lights, so we won't worry about the light number limitations of
    Single Pass, and we won't take advantage of the Deferred benefits too much, so
    it makes no sense to use more hardware to run the game.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么我们要使用URP和单通道前向渲染？因为它在性能、质量和简单性之间提供了最佳平衡。在这个游戏中，我们不会使用太多的光源，所以我们不会担心单通道的光源数量限制，而且我们也不会充分利用延迟的好处，所以使用更多的硬件来运行游戏是没有意义的。
- en: Now that we have a very basic notion of how URP handles lighting, let's start
    using it!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对URP处理光照的基本概念有了一个非常基本的了解，让我们开始使用它吧！
- en: Configuring ambient lighting with skyboxes
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置天空盒的环境光照
- en: 'There are different light sources that can affect the scene, such as the sun,
    torches, light bulbs, and more. Those are known as **Direct Lights**; that is,
    objects that emit light rays. Then, we have **Indirect Light**, light that usually
    represents bounces of Direct Lights. However calculating all the bounces of all
    the rays emitted by all the lights is impossible if you want to get a game running
    at least 30 FPS (or simply running). The problem is that not having Indirect Light
    will generate unrealistic results since our current scene lighting, where you
    can observe places where the sunlight doesn''t reach, is completely dark because
    no light is bouncing from other places where light hits:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的光源可以影响场景，如太阳、火炬、灯泡等。这些被称为**直接光**；也就是说，发射光线的物体。然后，我们有**间接光**，通常代表直接光的反射。然而，如果要让游戏以至少30
    FPS（或者只是运行）运行，计算所有光线发射的所有光线的所有反射是不可能的。问题在于没有间接光会产生不真实的结果，因为我们当前的场景照明中，你可以观察到阳光无法到达的地方完全黑暗，因为没有光从其他阳光照射的地方反射过来：
- en: '![Figure 8.6 – Shadows projected on a mountain without ambient lighting'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.6 – 没有环境光的山上投影的阴影'
- en: '](img/Figure_8.06_B14199.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.06_B14199.jpg)'
- en: Figure 8.6 – Shadows projected on a mountain without ambient lighting
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 没有环境光的山上投影的阴影
- en: To solve this problem, we can use approximations of those bounces. These are
    what we call **ambient light**. This represents a base layer of lighting that
    usually applies a little bit of light based on the color of the sky, but you can
    choose whatever color you want. As an example, on a clear night, we can pick a
    dark blue color to represent the tint from the moonlight.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以使用这些反弹的近似值。这就是我们所说的**环境光**。这代表了通常根据天空的颜色施加一点点光的基础光照层，但你可以选择任何你想要的颜色。例如，在晴朗的夜晚，我们可以选择深蓝色来代表月光的色调。
- en: 'By default, Unity won''t calculate ambient light from the sky, so we need to
    manually do that doing the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity不会从天空计算环境光，因此我们需要手动进行以下操作：
- en: Select the Terrain in the Hierarchy and uncheck Static at the top right part
    of the Inspector. Later we will explain why we did this:![Figure 8.7 – Terrain
    in Hierarchy
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择地形，并在检查器的右上角取消选择“静态”。稍后我们会解释为什么要这样做：![图8.7 – 层次结构中的地形
- en: '](img/Figure_8.07_B14199.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B14199.jpg)'
- en: Figure 8.7 – Terrain in Hierarchy
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 层次结构中的地形
- en: Click on **Window** | **Rendering** | **Lighting Settings**. This will open
    the **Scene Lighting Settings** window:![Figure 8.8 – Lighting Settings location
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**窗口** | **渲染** | **灯光设置**。这将打开**场景灯光设置**窗口：![图8.8 – 灯光设置位置
- en: '](img/Figure_8.08_B14199.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B14199.jpg)'
- en: Figure 8.8 – Lighting Settings location
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 灯光设置位置
- en: Click the **Generate Lighting** button at the bottom of the window. If you haven't
    saved the scene so far, a prompt will ask you to save it, which is necessary:![Figure
    8.9 – Generate Lighting button
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击窗口底部的**生成灯光**按钮。如果到目前为止你还没有保存场景，会提示你保存，这是必要的：![图8.9 – 生成灯光按钮
- en: '](img/Figure_8.09_B14199.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B14199.jpg)'
- en: Figure 8.9 – Generate Lighting button
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 生成灯光按钮
- en: See the bottom-right part of the Unity window to check the progress calculation
    bar to check when the process has finished:![Figure 8.10 – Lighting generation
    progress bar
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看Unity窗口右下角的进度计算栏，以检查进程何时完成：![图8.10 – 灯光生成进度条
- en: '](img/Figure_8.010_B14199.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.010_B14199.jpg)'
- en: Figure 8.10 – Lighting generation progress bar
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 灯光生成进度条
- en: 'You can now see how completely dark areas now have a little effect shown on
    them from the light being emitted by the sky:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以看到完全黑暗的区域现在有了一点光的效果：
- en: '![Figure 8.11 – Shadows with ambient lighting'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 带环境光的阴影'
- en: '](img/Figure_8.011_B14199.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.011_B14199.jpg)'
- en: Figure 8.11 – Shadows with ambient lighting
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 带环境光的阴影
- en: 'Now, by doing this, we have better lighting, but it still looks like a sunny
    day. Remember, we want to have rainy weather. In order to do that, we need to
    change the default sky so that it''s cloudy. You can do that by downloading a
    **skybox**. The current sky you can see around the scene is just a big cube containing
    textures on each side, and those have a special projection to prevent us from
    detecting the edges of the cube. We can download six images for each side of the
    cube and apply them to have whatever sky we want, so let''s do that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过这样做，我们有了更好的照明，但它看起来仍然像是一个晴天。记住，我们想要有雨天的天气。为了做到这一点，我们需要改变默认的天空，使其多云。你可以通过下载一个**天空盒**来实现。你可以在场景周围看到的当前天空只是一个包含每一面纹理的大立方体，这些纹理具有特殊的投影，以防止我们检测到立方体的边缘。我们可以为立方体的每一面下载六张图像并应用它们，以获得任何我们想要的天空，所以让我们这样做：
- en: You can download skybox textures from wherever you want, but here, I will choose
    the Asset Store. Open it by going to **Window** | **Asset Store** and going to
    the Asset Store website.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以从任何你想要的地方下载天空盒纹理，但在这里，我会选择资产商店。通过**窗口** | **资产商店** 打开它，并转到资产商店网站。
- en: Look for **2D** | **Textures & Materials** | **Sky** in the category list on
    the right. Remember that you need to make that window wider if you can't see the
    category list:![Figure 8.12 – Skybox category
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧的类别列表中查找**2D** | **纹理和材质** | **天空**。请记住，如果看不到类别列表，需要扩大窗口宽度：![图8.12 – 天空盒类别
- en: '](img/Figure_8.012_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.012_B14199.jpg)'
- en: Figure 8.12 – Skybox category
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 天空盒类别
- en: Remember to check the **Free Assets** checkbox in the **Pricing** section:![Figure
    8.13 – Free Assets filtering
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得在**定价**部分勾选**免费资产**复选框：![图8.13 – 免费资产过滤
- en: '](img/Figure_8.013_B14199.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.013_B14199.jpg)'
- en: Figure 8.13 – Free Assets filtering
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 免费资产过滤
- en: Pick any skybox you like for a rainy day. Take into account that there are different
    formats for skyboxes. We are using the six-image format, so check that before
    downloading one. In my case, I have chosen the skybox pack shown in the following
    figure. Download and import it, as we did in [*Chapter 5*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*,
    Importing and Integrating Assets*:![Figure 8.14 –Selected skybox set for this
    book
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择任何你喜欢的天空盒来模拟雨天。请注意，天空盒有不同的格式。我们使用的是六图格式，所以在下载之前要检查一下。在我的例子中，我选择了下图中显示的天空盒包。下载并导入它，就像我们在[*第5章*](B14199_05_Final_SK_ePub.xhtml#_idTextAnchor085)*，导入和整合资源*中所做的那样：![图8.14
    – 为本书选择的天空盒套装
- en: '](img/Figure_8.014_B14199.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.014_B14199.jpg)'
- en: Figure 8.14 –Selected skybox set for this book
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 为本书选择的天空盒套装
- en: Create a new material by using the **+** icon in the **Project** window and
    selecting **Material**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**Project**窗口中使用**+**图标并选择**Material**来创建一个新的材质。
- en: Set the **Shader** option of that material to **Skybox/6 sided**. Remember that
    the skybox is just a cube, so we can apply a material to change how it looks.
    The skybox shader is prepared to apply the six textures.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该材质的**Shader**选项设置为**Skybox/6 sided**。记住，天空盒只是一个立方体，所以我们可以应用一个材质来改变它的外观。天空盒着色器已经准备好应用这六个纹理。
- en: Drag the six textures to the **Front**, **Back**, **Left**, **Right**, **Up**,
    and **Down** properties of the material. The six downloaded textures will have
    descriptive names so that you know which textures go where:![Figure 8.15 – Skybox
    material settings
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将六个纹理拖到材质的**Front**、**Back**、**Left**、**Right**、**Up**和**Down**属性中。这六个下载的纹理将有描述性的名称，这样你就知道哪些纹理应该放在哪里：![图8.15
    – 天空盒材质设置
- en: '](img/Figure_8.015_B14199.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.015_B14199.jpg)'
- en: Figure 8.15 – Skybox material settings
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 天空盒材质设置
- en: Drag the material directly into the sky in the Scene View. Be sure you don't
    drag the material into an object because the material will be applied to it.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材质直接拖到场景视图中的天空中。确保你不要把材质拖到一个物体上，因为材质会被应用到它上面。
- en: 'Repeat *steps 1* to *4* of the ambient light calculation (**Lighting Settings**
    | **Generate Lighting**) to recalculate it based on the new skybox. In the following
    figure, you can see the result of my project so far:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复环境光计算的*步骤1*到*4*（**Lighting Settings** | **Generate Lighting**）以根据新的天空盒重新计算。在下图中，你可以看到目前我的项目的结果：
- en: '![Figure 8.16 – Applied skybox'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 – 应用的天空盒'
- en: '](img/Figure_8.016_B14199.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.016_B14199.jpg)'
- en: Figure 8.16 – Applied skybox
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 应用的天空盒
- en: Now that we have a good base layer of lighting, we can start adding light objects.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个良好的基础光照层，我们可以开始添加光源对象了。
- en: Configuring lighting in URP
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在URP中配置光照
- en: 'We have three main types of Direct Lights we can add to our scene:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在场景中添加三种主要类型的直射光：
- en: '**Directional Light**: This is a light that represents the sun. This object
    emits light rays in the direction it is facing, regardless of its position; the
    sun moving 100 meters to the right won''t make a big difference. As an example,
    if you slowly rotate this object, you can generate a day/night cycle:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Directional Light**：这是代表太阳的光。这个对象会向着它所面对的方向发出光线，而不受位置的影响；太阳向右移动100米不会有太大的影响。举个例子，如果你慢慢旋转这个对象，你可以生成一个昼夜循环：'
- en: '![Figure 8.17 – Directional Light results'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.17 – 定向光结果'
- en: '](img/Figure_8.017_B14199(Merged).jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.017_B14199(Merged).jpg)'
- en: Figure 8.17 – Directional Light results
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 定向光结果
- en: '**Point Light**: This light represents a light bulb, which emits rays in an
    omnidirectional way. The difference it has on the sun is that its position matters
    because it''s closer. Also, because it''s a weaker light, the intensity of this
    light varies according to the distance, so its effect has a range – the further
    the object from the light, the weaker the received intensity:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源**：这种光代表了一个发射光线的灯泡，以全向方式发出光线。它对太阳的影响与太阳不同，因为它的位置很重要，因为它更接近。此外，因为它是一个较弱的光源，这种光的强度会根据距离而变化，所以它的效果有一个范围
    – 距离光源越远，接收到的强度就越弱：'
- en: '![Figure 8.18 – Point Light results'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.18 – 点光结果'
- en: '](img/Figure_8.018_B14199(Merged).jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.018_B14199(Merged).jpg)'
- en: Figure 8.18 – Point Light results
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 点光结果
- en: '**Spotlight**: This kind of light represents a light cone, such as the one
    emitted by a flashlight. It behaves similarly to point lights in that its position
    and direction matters, and the light intensity decays over a certain distance:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Spotlight**：这种光代表了光锥，就像手电筒发出的光一样。它的行为类似于点光源，其位置和方向很重要，光强度会随着一定距离的衰减：'
- en: '![Figure 8.19 – Spotlight results'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.19 – 聚光灯结果'
- en: '](img/Figure_8.019_B14199(Merged).jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.019_B14199(Merged).jpg)'
- en: Figure 8.19 – Spotlight results
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 聚光灯结果
- en: 'So far, we have a nice, rainy, ambient lighting, but the only Direct Light
    we have in the scene, the Directional Light, won''t look like this, so let''s
    change that:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有了一个不错的、多雨的环境光照，但是我们场景中唯一的直射光，定向光，看起来不像这样，所以让我们改变一下：
- en: Select the **Directional Light** object in the **Hierarchy** window and then
    look at the **Inspector** window.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中选择**Directional Light**对象，然后查看**Inspector**窗口。
- en: Click the **Colour** property to open the Color Picker.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Colour**属性以打开颜色选择器。
- en: Select a dark gray color to achieve sun rays partially occluded by clouds.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择深灰色来实现部分被云层遮挡的阳光。
- en: 'Set **Shadow Type** to **No Shadows**. Now that we have a cloudy day, the sun
    does not project clear shadows, but we will talk more about shadows in a moment:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**Shadow Type**设置为**No Shadows**。现在我们有了多云的天气，太阳不会投射清晰的阴影，但我们稍后会更多地讨论阴影：
- en: '![Figure 8.20 – Soft directional light with no shadows'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.20 – 没有阴影的柔和定向光'
- en: '](img/Figure_8.020_B14199.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.020_B14199.jpg)'
- en: Figure 8.20 – Soft directional light with no shadows
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 没有阴影的柔和定向光
- en: 'Now that the scene is darker, we can add some lights to light up the scene,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景变暗了，我们可以添加一些灯光来照亮场景，如下所示：
- en: Create a Spotlight by going to **GameObject** | **Light** | **Spotlight**:![Figure
    8.21 – Creating a Spotlight
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**GameObject** | **Light** | **Spotlight**创建一个聚光灯：![图8.21 – 创建聚光灯
- en: '](img/Figure_8.021_B14199.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.021_B14199.jpg)'
- en: Figure 8.21 – Creating a Spotlight
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 创建聚光灯
- en: Select it. Then, in the `90` and `120`, which will increase the angle of the
    cone.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择它。然后，在`90`和`120`中，这将增加锥体的角度。
- en: Set `50`, meaning that the light can reach up to 50 meters, decaying along the
    way.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为`50`，表示光可以达到50米，沿途衰减。
- en: Set `1000`:![Figure 8.22 – Spotlight settings
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置为`1000`：![图8.22 – 聚光灯设置
- en: '](img/Figure_8.022_B14199.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.022_B14199.jpg)'
- en: Figure 8.22 – Spotlight settings
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 聚光灯设置
- en: Position the light at one corner of the base, pointing it at the center:![Figure
    8.23 – Spotlight placement
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光源放在基座的一个角落，指向中心：![图8.23 – 聚光灯放置
- en: '](img/Figure_8.023_B14199.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.023_B14199.jpg)'
- en: Figure 8.23 – Spotlight placement
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 聚光灯放置
- en: Duplicate that light by selecting it and pressing *Ctrl + D* (*command + D*
    on Mac).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择光源并按下*Ctrl + D*（Mac上为*command + D*）来复制该光源。
- en: 'Put it in the opposite corner of the base:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其放在基座的对角线上：
- en: '![Figure 8.24 –Two Spotlight results](img/Figure_8.024_B14199.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – 两个聚光灯的效果](img/Figure_8.024_B14199.jpg)'
- en: Figure 8.24 –Two Spotlight results
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – 两个聚光灯的效果
- en: You can keep adding lights to the scene but take care that you don't go too
    far – remember the light limits. Also, you can download some light posts to put
    in where the lights are located to visually justify the origin of the light. Now
    that we have achieved proper lighting, we can talk about shadows.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以继续向场景中添加光源，但要注意不要走得太远——记住光源的限制。此外，你可以下载一些灯柱放在光源位置，以视觉上证明光的来源。现在我们已经实现了适当的照明，我们可以谈论阴影了。
- en: Applying shadows
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用阴影
- en: 'Maybe you are thinking that we already have shadows in the scene, but actually,
    we don''t. The darker areas of the object, the ones that are not facing the lights,
    don''t have shadows – they are not being lit, and that''s quite different from
    a shadow. In this case, we are referring to the shadows that are projected from
    one object to another; for example, the shadow of the player being projected on
    the floor, or from the mountains to other objects. Shadows can increase the quality
    of our scene, but they also cost a lot to calculate, so we have two options: not
    using shadows (recommended for low-end devices such as mobiles) or finding a balance
    between performance and quality according to our game and the target device. In
    the first case, you can skip this whole section, but if you want to achieve performant
    shadows (as much as possible), keep reading.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会认为我们的场景中已经有阴影了，但实际上并没有。物体的较暗区域，也就是不面向光源的区域，没有阴影——它们没有被照亮，这与阴影是完全不同的。在这种情况下，我们指的是从一个物体投射到另一个物体的阴影；例如，玩家在地板上投射的阴影，或者从山上到其他物体的阴影。阴影可以提高我们场景的质量，但计算成本也很高，因此我们有两个选择：不使用阴影（建议用于移动设备等低端设备）或根据我们的游戏和目标设备在性能和质量之间找到平衡。在第一种情况下，你可以跳过整个部分，但如果你想要实现高性能的阴影，尽可能地继续阅读。
- en: 'In this section, we are going to discuss the following topics about shadows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论有关阴影的以下主题：
- en: Understanding shadow calculations
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: Configuring performant shadows
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: Let's start by discussing how Unity calculates shadows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论Unity如何计算阴影。
- en: Understanding shadow calculations
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解阴影计算
- en: In game development, it is well-known that shadows are costly in terms of performance,
    but why? An object has a shadow when a light ray hits another object before reaching
    it. In that case, no lighting is applied to that pixel from that light. The problem
    here is the same problem we have with the light that ambient lighting simulates
    – it would be too costly to calculate all possible rays and its collisions. So,
    again, we need an approximation, and here is where Shadow Maps kick in.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发中，众所周知，阴影在性能方面是昂贵的，但为什么呢？当光线射到另一个物体后再到达物体时，物体会产生阴影。在这种情况下，该像素不会受到来自该光源的照明。问题在于，这与环境光模拟的光照存在相同的问题——计算所有可能的光线及其碰撞将成本过高。因此，我们需要一个近似值，这就是阴影贴图发挥作用的地方。
- en: 'A Shadow Map is an image that''s rendered from the point of view of the light,
    but instead of drawing the full scene with all the color and lighting calculations,
    it will render all the objects in grayscale, where black means that the pixel
    is very far from the camera and whiter means that the pixel is nearer to the camera.
    If you think about it, each pixel contains information about where a **ray** of
    the light hits. By knowing the position and orientation of the light, you can
    calculate the position where each "ray" hit using the **Shadow Map**. In the following
    figure, you can see the Shadow Map of our Directional Light:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影贴图是从光的视角渲染的图像，但不是绘制带有所有颜色和光照计算的完整场景，而是以灰度渲染所有物体，其中黑色表示像素距离摄像机很远，白色表示像素距离摄像机较近。如果你仔细想一想，每个像素都包含了光线的碰撞信息。通过了解光的位置和方向，你可以使用阴影贴图计算出每个“光线”碰撞的位置。在下图中，你可以看到我们定向光的阴影贴图：
- en: '![Figure 8.25 – Shadow Map generated by the Directional Light of our scene'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.25 – 我们场景中定向光生成的阴影贴图'
- en: '](img/Figure_8.025_B14199.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.025_B14199.jpg)'
- en: Figure 8.25 – Shadow Map generated by the Directional Light of our scene
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.25 – 我们场景中定向光生成的阴影贴图
- en: Each type of light calculates Shadow Maps slightly differently, especially the
    Point Light. Since it's omnidirectional, it needs to render the scene several
    times in all its directions (front, back, up, down, right, and left) in order
    to gather information about all the rays it emits. We won't talk about this in
    detail here, though, as we could talk about it all day.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的光都会稍微不同地计算阴影贴图，尤其是点光源。由于它是全向的，它需要在所有方向（前、后、上、下、左、右）渲染场景多次，以收集关于它发射的所有光线的信息。不过，我们不会在这里详细讨论这个问题，因为我们可能会谈论一整天。
- en: 'Now, something important to highlight here is that Shadow Maps are textures,
    and hence they have a resolution. The higher the resolution, the more "rays" our
    Shadow Map calculates. You are probably wondering what a low-resolution shadow
    map looks like when it has only a few rays in it. Take a look at the following
    figure to see one:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里需要强调的一点是，阴影图是纹理，因此它们有分辨率。分辨率越高，我们的阴影图计算的“光线”就越多。您可能想知道当低分辨率阴影图中只有少量光线时会是什么样子。看看下图，看看一个低分辨率阴影图是什么样子：
- en: '![Figure 8.26 – Hard Shadow rendered with a low-resolution Shadow Map'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.26 - 使用低分辨率阴影图渲染的硬阴影'
- en: '](img/Figure_8.026_B14199.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.026_B14199.jpg)'
- en: Figure 8.26 – Hard Shadow rendered with a low-resolution Shadow Map
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.26 - 使用低分辨率阴影图渲染的硬阴影
- en: 'The problem here is that having fewer rays generates bigger shadow pixels,
    resulting in a pixelated shadow. Here, we have our first configuration to consider:
    what is the ideal resolution for our shadows? You will be tempted to just increase
    it until the shadows look smooth, but of course, that will increase how long it
    will take to calculate it, so it will impact the performance considerably unless
    your target platform can handle it (mobiles definitely can''t). Here, we can use
    the **Soft Shadows** trick, where we can apply a blurring effect over the shadows
    to hide the pixelated edges, as shown in the following figure:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于光线数量较少会生成更大的阴影像素，导致像素化阴影。在这里，我们有第一个要考虑的配置：我们的阴影的理想分辨率是多少？您可能会诱惑地增加它，直到阴影看起来平滑，但当然，这将增加计算所需的时间，因此除非您的目标平台可以处理它（移动设备肯定不能），否则它将大大影响性能。在这里，我们可以使用**软阴影**技巧，在阴影上应用模糊效果以隐藏像素化的边缘，如下图所示：
- en: '![Figure 8.27 – Soft Shadows rendered with a low-resolution Shadow Map](img/Figure_8.027_B14199.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图8.27 - 使用低分辨率阴影图渲染的软阴影](img/Figure_8.027_B14199.jpg)'
- en: Figure 8.27 – Soft Shadows rendered with a low-resolution Shadow Map
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 - 使用低分辨率阴影图渲染的软阴影
- en: Of course, the blurry effect is not free, but combining it with low-resolution
    shadow maps, if you accept its blurry result, can generate a nice balance between
    quality and performance.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，模糊效果并不是免费的，但是如果您接受其模糊结果，并将其与低分辨率阴影图结合使用，可以在质量和性能之间达到良好的平衡。
- en: 'Now, low-resolution Shadow Maps have another problem, which is called **Shadow
    Acne**. This is the lighting error you can see in the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，低分辨率阴影图还有另一个问题，称为**阴影痤疮**。这是您可以在下图中看到的照明错误：
- en: '![Figure 8.28 – Shadow Acne from a low-resolution Shadow Map'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.28 - 低分辨率阴影图的阴影痤疮'
- en: '](img/Figure_8.028_B14199.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.028_B14199.jpg)'
- en: Figure 8.28 – Shadow Acne from a low-resolution Shadow Map
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28 - 低分辨率阴影图的阴影痤疮
- en: 'A low-resolution shadow map generates false positives because it has fewer
    "rays" calculated. The pixels to be shaded between the rays need to interpolate
    information from the nearest ones. The lower the Shadow Map''s resolution, the
    larger the gap between the rays, which means less precision and more false positives.
    One solution would be to increase the resolution, but again, there will be performance
    issues (as always). We have some clever solutions to this, such as using **depth
    bias**. An example of this can be seen in the following figure:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 低分辨率阴影图会产生假阳性，因为计算的“光线”较少。需要在光线之间进行插值以对光线进行着色的像素需要从最近的光线中插值信息。阴影图的分辨率越低，光线之间的间隔就越大，这意味着精度越低，假阳性就越多。一种解决方法是增加分辨率，但同样会出现性能问题（一如既往）。我们有一些聪明的解决方案，比如使用**深度偏差**。可以在下图中看到这种情况的一个例子：
- en: '![Figure 8.29 – A false positive between two far “rays.” The highlighted area
    thinks the ray hit an object before reaching it.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.29 - 两个远处的“光线”之间的假阳性。突出显示的区域认为光线在到达之前就击中了物体。'
- en: '](img/Figure_8.029_B14199.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.029_B14199.jpg)'
- en: Figure 8.29 – A false positive between two far "rays." The highlighted area
    thinks the ray hit an object before reaching it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29 - 两个远处的“光线”之间的假阳性。突出显示的区域认为光线在到达之前就击中了物体。
- en: 'The concept of **depth bias** is simple – so simple that it seems like a big
    cheat, and actually, it is, but game development is full of them! To prevent false
    positives, we "push" the rays a little bit further, just enough to make the interpolated
    rays reach the hitting surface:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度偏差**的概念很简单 - 如此简单，以至于看起来像是一个大的欺骗，实际上确实如此，但游戏开发中充满了这些欺骗！为了防止假阳性，我们“推”光线再多一点，足以使插值光线达到击中表面：'
- en: '![Figure 8.30 – Rays with a depth bias to eliminate false positives'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.30 - 具有深度偏差的光线以消除假阳性'
- en: '](img/Figure_8.030_B14199.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.030_B14199.jpg)'
- en: Figure 8.30 – Rays with a depth bias to eliminate false positives
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30 - 具有深度偏差的光线以消除假阳性
- en: 'Of course, as you are probably expecting, they don''t solve this problem easily
    without having a caveat. Pushing depth generates false negatives in other areas,
    as shown in the following figure. It looks like the cube is floating, but actually,
    it is touching the ground – the false negatives generate the illusion that it
    is floating:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如您可能期望的那样，它们不能轻松解决这个问题而没有任何警告。推动深度会在其他区域产生假阴性，如下图所示。看起来立方体在漂浮，但实际上它是与地面接触的
    - 假阴性产生了它漂浮的错觉：
- en: '![Figure 8.31 – False negatives due to a high depth bias'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.31 - 由于深度偏差导致的假阴性'
- en: '](img/Figure_8.031_B14199.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.031_B14199.jpg)'
- en: Figure 8.31 – False negatives due to a high depth bias
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 - 由于深度偏差导致的假阴性
- en: 'Of course, we have a counter trick to this situation known as **normal bias**.
    It still pushes objects, but along the direction they are facing. This one is
    a little bit tricky, so we won''t go into too much detail here, but the idea is
    that combining a little bit of depth bias and another bit of normal bias will
    reduce the false positives, but not completely eliminate them. Therefore, we need
    to learn how to live with that and hide it by cleverly positioning objects:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们有一个对这种情况的反对技巧，称为**法线偏差**。它仍然推动物体，但沿着它们面对的方向。这有点棘手，所以我们不会在这里详细介绍，但是想法是结合一点深度偏差和另一点法线偏差将减少错误的阳性，但不会完全消除它们。因此，我们需要学会如何与之共存，并通过巧妙地定位物体来隐藏它：
- en: '![Figure 8.32 – Reduced false negatives, which is the result of combining depth
    and normal bias'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.32-减少假阴性，这是深度和法线偏差相结合的结果'
- en: '](img/Figure_8.032_B14199.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.032_B14199.jpg)'
- en: Figure 8.32 – Reduced false negatives, which is the result of combining depth
    and normal bias
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.32-减少假阴性，这是深度和法线偏差相结合的结果
- en: There are several other aspects that affect how Shadow Map works, with one of
    them being the light range. The smaller the light range, the less area the shadows
    will cover. The same Shadow Map resolution can add more detail to that area, so
    try to reduce the light ranges as much as you can.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个影响阴影图工作方式的方面，其中之一是光范围。光范围越小，阴影覆盖的区域就越小。相同的阴影图分辨率可以为该区域添加更多细节，因此尽量减少光范围。
- en: I can imagine your face right now, and yes, lighting is complicated, and we've
    only just scratched the surface! But keep your spirits up! After a little trial
    and error fiddling with the settings, you will understand it better. We'll do
    that in the next section.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以想象你现在的表情，是的，照明很复杂，我们只是刚刚触及到表面！但保持你的精神！在稍微调整设置后，你会更好地理解它。我们将在下一节中做到这一点。
- en: Important information
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重要信息
- en: If you are really interested in learning more about the internals of the shadow
    system, I recommend that you look at the concept of **Shadow Cascades**, an advanced
    topic about Directional Lights and Shadow Map generation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的对学习阴影系统的内部更多信息感兴趣，我建议您查看**阴影级联**的概念，这是有关定向光和阴影图生成的高级主题。
- en: Configuring performant shadows
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置高性能阴影
- en: 'Because we are targeting mid-end devices, we will try to achieve a good balance
    of quality and performance here, so let''s start enabling shadows just for the
    spotlights. The Directional Light shadow won''t be that noticeable, and actually,
    a rainy sky doesn''t generate clear shadows, so we will use that as an excuse
    to not calculate those shadows. In order to do this, do the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的目标是中端设备，所以我们将尝试在这里实现质量和性能的良好平衡，因此让我们开始仅为聚光灯启用阴影。定向光的阴影不会那么明显，实际上，雨天的天空不会产生清晰的阴影，因此我们将借此借口不计算那些阴影。为了做到这一点，请执行以下操作：
- en: Select both Point Lights by clicking them in the Hierarchy while pressing *Ctrl*
    (*Command* on Mac). This will ensure that any changes made in the **Inspector**
    window will be applied to both:![Figure 8.33 – Selecting multiple objects
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在层次结构中单击它们并同时按下*Ctrl*（Mac上的*Command*）来选择两个点光源。这将确保**检查器**窗口中所做的任何更改都将应用于两者：![图8.33-选择多个对象
- en: '](img/Figure_8.033_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.033_B14199.jpg)'
- en: Figure 8.33 – Selecting multiple objects
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.33-选择多个对象
- en: In the **Inspector** window, set **Shadow Type** to **Soft Shadows**. We will
    be using low-resolution shadow maps here:![Figure 8.34 – Soft Shadows setting](img/Figure_8.034_B14199.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，将**阴影类型**设置为**软阴影**。我们将在这里使用低分辨率阴影图：![图8.34-软阴影设置](img/Figure_8.034_B14199.jpg)
- en: Figure 8.34 – Soft Shadows setting
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.34-软阴影设置
- en: Select **Directional light** and set **Shadow Type** to **No Shadows** to prevent
    it from casting shadows:![Figure 8.35 – No Shadows setting](img/Figure_8.035_B14199.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**定向光**并将**阴影类型**设置为**无阴影**以防止其投射阴影：![图8.35-无阴影设置](img/Figure_8.035_B14199.jpg)
- en: Figure 8.35 – No Shadows setting
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.35-无阴影设置
- en: Create a cube (**GameObject** | **3D Object** | **Cube**) and place it near
    one of the lights, just to have an object that we can cast shadows on for testing
    purposes.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个立方体（**GameObject** | **3D Object** | **Cube**）并将其放在灯光附近，以便我们可以在其上投射阴影进行测试。
- en: 'Now that we have a base test scenario, let''s fiddle with the Shadow Maps resolution
    settings, preventing Shadow Acne in the process:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个基本的测试场景，让我们调整阴影图分辨率设置，同时防止阴影痤疮：
- en: Go to **Edit** | **Project Settings**.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到**编辑** | **项目设置**。
- en: In the left-hand side list, look for **Graphics** and click it:![Figure 8.36
    – Graphics settings
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，查找**图形**并单击它：![图8.36-图形设置
- en: '](img/Figure_8.036_B14199.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.036_B14199.jpg)'
- en: Figure 8.36 – Graphics settings
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.36-图形设置
- en: 'In the properties that appear after selecting this option, click in the box
    below **Scriptable Render Pipeline Settings** – the one that contains a name.
    In my case, this is **LWRP-HighQuality**, but yours may be different due to you
    having a different version of Unity:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择此选项后出现的属性中，单击下面的**可编写渲染管线设置**框中的一个名称。在我的情况下，这是**LWRP-HighQuality**，但由于您使用的Unity版本不同，您的情况可能不同：
- en: '![Figure 8.37 – Current Render Pipeline setting](img/Figure_8.037_B14199.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图8.37-当前渲染管线设置](img/Figure_8.037_B14199.jpg)'
- en: Figure 8.37 – Current Render Pipeline setting
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.37-当前渲染管线设置
- en: Doing that will highlight an asset in the Project window, so be sure that window
    is visible before selecting it. Select the highlighted asset:![Figure 8.38 – Current
    pipeline highlighted
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样做将在项目窗口中突出显示一个资产，因此在选择之前，请确保该窗口可见。选择突出显示的资产：![图8.38-突出显示当前管道
- en: '](img/Figure_8.038_B14199.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.038_B14199.jpg)'
- en: Figure 8.38 – Current pipeline highlighted
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.38-突出显示当前管道
- en: This asset has several graphics settings related to how URP will handle its
    rendering, including lighting and shadows. Expand the **Lighting** section to
    reveal its settings:![Figure 8.39 – Pipeline lighting settings
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个资产有几个与URP如何处理其渲染相关的图形设置，包括照明和阴影。展开**照明**部分以显示其设置：![图8.39 – 管道照明设置
- en: '](img/Figure_8.039_B14199.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.039_B14199.jpg)'
- en: Figure 8.39 – Pipeline lighting settings
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.39 – 管道照明设置
- en: The `Main Light`). Set it to **1024** if it's not already at that value.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Main Light`）。如果它的值还不是**1024**，将其设置为**1024**。'
- en: Under the `0.25` in order to reduce them as much as we can before we remove
    the Shadow Acne:![Figure 8.40 – Light shadows settings
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`0.25`下，为了尽量减少它们，我们需要在移除阴影痤疮之前尽可能减少它们：![图8.40 – 光影设置
- en: '](img/Figure_8.040_B14199.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.040_B14199.jpg)'
- en: Figure 8.40 – Light shadows settings
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.40 – 光影设置
- en: This isn't entirely related to shadows, but here, you can change the **Per Object
    Light** limit to increase or reduce the number of lights that can affect the object
    (no more than eight).
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这与阴影没有直接关联，但在这里，你可以更改**每个对象光**限制，以增加或减少可以影响对象的光的数量（不超过八个）。
- en: In case you followed the shadow cascades tip presented earlier, you can play
    with the **Cascades** value a little bit to enable shadows for Directional Light
    to notice the effect. Remember that those shadow settings only work for Directional
    Light.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你之前遵循了阴影级联提示，可以稍微调整**级联**值，以启用定向光的阴影以观察效果。请记住，这些阴影设置仅适用于定向光。
- en: 'Set both lights so that they have a 40-meter range. See how the shadows improve
    in quality before and after the change:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个灯光的范围设置为40米。看看在更改前后阴影的质量如何改善：
- en: '![Figure 8.41 – Bias settings'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.41 – 偏差设置'
- en: '](img/Figure_8.041_B14199.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.041_B14199.jpg)'
- en: Figure 8.41 – Bias settings
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.41 – 偏差设置
- en: Remember that those values only work in my case, so try to fiddle with the values
    a little bit to see how that changes the result – you may find a better setup
    for your PC. Also, remember that not having shadows is always an option, so always
    consider that in case your game is running low on FPS (and there isn't another
    performance problem lurking).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这些值只适用于我的情况，所以尝试稍微调整这些值，看看结果如何改变 – 你可能会找到更适合你的PC的设置。同时，请记住，不使用阴影始终是一个选择，所以在你的游戏运行时低于FPS时（并且没有其他性能问题潜伏）时，始终要考虑这一点。
- en: You probably think that that is all we can do about performance in terms of
    lighting, but luckily, that's not the case! We have another resource we can use
    to improve it further known as static lighting.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为这就是我们在照明性能方面所能做的一切，但幸运的是，情况并非如此！我们还有另一个资源可以用来进一步改善，即静态照明。
- en: Optimizing lighting
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化照明
- en: We mentioned previously that not calculating lighting is good for performance,
    but what about not calculating lights, but still having them? Yes, its sounds
    too good to be true, but it is actually possible (and, of course, tricky). We
    can use a technique called static lighting or baking, which allows us to calculate
    lighting once and use the cached result.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到不计算照明对性能有好处，但是不计算灯光，但仍然拥有它们呢？是的，这听起来太美好了，但实际上是可能的（当然，也很棘手）。我们可以使用一种称为静态照明或烘焙的技术，它允许我们计算一次照明并使用缓存的结果。
- en: 'In this section, we will cover the following concepts related to Static Lighting:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖与静态照明相关的以下概念：
- en: Understanding static lighting
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解静态照明
- en: Baking lightmaps
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烘焙光照图
- en: Applying static lighting to dynamic objects
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将静态照明应用于动态对象
- en: Understanding static lighting
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解静态照明
- en: 'The idea is pretty simple: just do the lighting calculations once, save the
    results, and then use those instead of calculating lighting all the time. You
    may be wondering why this isn''t the default technique to use. This is because
    it has some limitations, with the big one being dynamic objects. **Precalculating
    shadows** means that they can''t change once they''ve been calculated, but if
    an object that is casting a shadow is moved, the shadow will still be there, so
    the main thing to take into account here is that you can''t use this technique
    with moving objects. Instead, you will need to mix **static** or **baked lighting**
    for static objects and **Realtime lighting** for dynamic (moving) objects. Also,
    consider that aside from this technique being only valid for static objects, it
    is also only valid for static lights. Again, if a light moves, the precalculated
    data becomes invalid.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法非常简单：只需进行一次照明计算，保存结果，然后使用这些结果，而不是一直计算照明。你可能会想为什么这不是默认的技术。这是因为它有一些限制，其中最大的限制是动态对象。**预计算阴影**意味着一旦计算出来就不能改变，但如果投射阴影的对象移动了，阴影仍然会在那里，因此需要考虑的主要事情是你不能在移动对象上使用这种技术。相反，你需要为静态对象混合**静态**或**烘焙照明**，对于动态（移动）对象使用**实时照明**。此外，需要考虑的是，除了这种技术只适用于静态对象，它也只适用于静态光源。同样，如果光源移动，预先计算的数据就会变得无效。
- en: 'Another limitation you need to take into account is that that precalculated
    data can have a huge impact on memory. That data occupies space in RAM, maybe
    hundreds of MBs, so you need to consider whether your target platform has enough
    space. Of course, you can reduce the precalculated lighting quality to reduce
    the size of that data, but you need to consider whether the loss of quality deteriorates
    the look and feel of your game too much. As with all options regarding optimization,
    you need to balance two factors: performance and quality.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要考虑的另一个限制是，预先计算的数据可能会对内存产生巨大影响。这些数据占用了RAM的空间，也许有数百MB，因此你需要考虑你的目标平台是否有足够的空间。当然，你可以降低预先计算的照明质量以减小数据的大小，但你需要考虑失去的质量是否会过分恶化你的游戏的外观和感觉。就像所有关于优化的选项一样，你需要平衡两个因素：性能和质量。
- en: 'We have several kinds of precalculated data in our process, but the most important
    one is what we call **lightmaps**. A lightmap is a texture that contains all the
    shadows and lighting for all the objects in the scene, so when Unity applies the
    precalculated or baked data, it will look at this texture to know which parts
    of the static objects are lit and which aren''t. You can see an example of a lightmap
    in the following figure:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的过程中有几种预先计算的数据，但最重要的是我们所谓的**光照贴图**。光照贴图是一种纹理，其中包含场景中所有对象的阴影和光照，因此当Unity应用预先计算或烘焙的数据时，它将查看此纹理，以了解静态对象的哪些部分受到照明，哪些部分没有。您可以在以下图中看到光照贴图的示例：
- en: '![Figure 8.42 – Left, a scene with no lighting; middle, a lightmap holding
    precalculated data from that scene; right, the lightmap being applied to the scene'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.42 - 左边是没有光照的场景；中间是包含来自该场景的预先计算数据的光照贴图；右边是将光照贴图应用到场景中'
- en: '](img/Figure_8.042_B14199.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.042_B14199.jpg)'
- en: Figure 8.42 – Left, a scene with no lighting; middle, a lightmap holding precalculated
    data from that scene; right, the lightmap being applied to the scene
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.42 - 左边是没有光照的场景；中间是包含来自该场景的预先计算数据的光照贴图；右边是将光照贴图应用到场景中
- en: Anyway, having lightmaps has its own benefits. The baking process is executed
    in Unity, before the game is shipped to users, so you can spend plenty of time
    calculating stuff that you can't do at runtime, such as improved accuracy, light
    bounces, light occlusion in corners, and light from emissive objects. However,
    that can also be a problem. Remember, dynamic objects still need to rely on Realtime
    lighting, and that lighting will look very different compared to the static lighting,
    so we need to tweak them a lot for the user to not notice the difference.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，光照贴图也有其自身的好处。烘焙过程在Unity中执行，游戏发货给用户之前，因此您可以花费大量时间计算无法在运行时执行的内容，例如改进的准确性、光线反射、角落中的光遮挡以及来自发光对象的光线。然而，这也可能是一个问题。请记住，动态对象仍然需要依赖实时光照，而该光照看起来与静态光照非常不同，因此我们需要对其进行大量调整，以使用户注意不到差异。
- en: Now that we have a basic notion of what static lighting is, let's dive into
    how to use it.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对静态光照有了基本概念，让我们深入了解如何使用它。
- en: Baking lightmaps
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 烘焙光照贴图
- en: To use lightmaps, we need to make some preparations regarding the 3D models.
    Remember that meshes have **UVs**, which contain information about which part
    of the texture needs to be applied to each part of the model. Sometimes, to save
    texture memory you can apply the same piece of texture to different parts. For
    example, in a car's texture, you wouldn't have four wheels, you'd just have one,
    and you can apply that same piece of texture to all the wheels. The problem here
    is that static lighting uses textures the same way, but here, it will apply the
    lightmaps to light the object. In the wheel scenario, the problem would be that
    if one wheel receives shadows, all of them will have them, because all the wheels
    are sharing the same texture space. The usual solution is to have a second set
    of UVs in the model with no texture space being shared, just to use for lightmapping.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用光照贴图，我们需要对3D模型进行一些准备工作。记住，网格有**UV**，其中包含有关将纹理的哪个部分应用于模型的每个部分的信息。有时，为了节省纹理内存，您可以将相同的纹理片段应用于不同的部分。例如，在汽车的纹理中，您不会有四个车轮，只会有一个，您可以将相同的纹理片段应用于所有车轮。问题在于静态光照以相同的方式使用纹理，但在这里，它将应用光照贴图来照亮对象。在车轮的情况下，问题在于如果一个车轮接收阴影，所有车轮都会有阴影，因为所有车轮共享相同的纹理空间。通常的解决方案是在模型中有第二组UV，其中没有共享纹理空间，仅用于光照贴图。
- en: 'Sometimes, downloaded models are already prepared for lightmapping, and sometimes
    they aren''t, but luckily, Unity has us covered in those scenarios. To be sure
    a model will calculate lightmapping properly, let''s make Unity automatically
    generate the **Lightmapping UV** set by doing the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，下载的模型已经准备好进行光照贴图，有时没有，但幸运的是，Unity在这些情况下为我们提供了帮助。为了确保模型能够正确计算光照贴图，让我们通过以下步骤让Unity自动生成**光照贴图UV**集：
- en: Select the mesh asset (FBX) in the **Project** window.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中选择网格资产（FBX）。
- en: In the **Model** tab, look for the **Generate Lightmap** checkbox at the bottom
    and check it.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**模型**选项卡中，查找底部的**生成光照贴图**复选框并选中它。
- en: Click the **Apply** button at the bottom:![Figure 8.43 – Generate Lightmap setting
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击底部的**应用**按钮：![图8.43 - 生成光照贴图设置
- en: '](img/Figure_8.043_B14199.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.043_B14199.jpg)'
- en: Figure 8.43 – Generate Lightmap setting
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.43 - 生成光照贴图设置
- en: Repeat this process for every model. Technically, you can only do this in the
    models where you get artifacts and weird results after baking lightmaps, but for
    now, let's do this in all the models just in case.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个模型重复此过程。从技术上讲，您只能在烘焙光照贴图后在模型中出现伪影和奇怪结果时才能这样做，但现在，让我们在所有模型中都这样做以防万一。
- en: 'After preparing the models for being lightmapped, the next step is to tell
    Unity which objects are not going to move. To do so, do the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好模型进行光照贴图后，下一步是告诉Unity哪些对象不会移动。要做到这一点，按照以下步骤进行：
- en: Select the object that won't move.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择不会移动的对象。
- en: Check the **Static** checkbox in the topright of the **Inspector** window:![Figure
    8.44 – Static checkbox
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**窗口的右上角选中**静态**复选框：![图8.44 - 静态复选框
- en: '](img/Figure_8.044_B14199.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.044_B14199.jpg)'
- en: Figure 8.44 – Static checkbox
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.44 - 静态复选框
- en: Repeat this for every static object (this isn't necessary for lights; we will
    deal with those later).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对每个静态对象重复此过程（对灯光不需要这样做；我们稍后会处理）。
- en: 'Consider that you may not want every object, even if it''s static, to be lightmapped,
    because the more objects you lightmap, the more texture size you will require.
    As an example, the terrain is too large and will consume most of the lightmapping''s
    size. Usually, this is necessary, but in our case, the Spotlights are barely touching
    the terrain. Here, we have two options: leave the terrain as dynamic, or better,
    directly tell the Spotlights to not affect the terrain since one is only lit by
    ambient lighting and the Directional Light (which is not casting shadows). Remember
    that this is something we can do because of our type of scene; however, you may
    need to use other settings in other scenarios. You can exclude an object from
    both Realtime and Static lighting calculations by doing the following:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可能不希望每个对象，即使是静态的，都被烘焙，因为您烘焙的对象越多，您就需要更多的纹理大小。例如，地形太大，将占用大部分烘焙的大小。通常情况下，这是必要的，但在我们的情况下，聚光灯几乎没有触及地形。在这里，我们有两个选择：将地形保留为动态，或者更好地直接告诉聚光灯不要影响地形，因为一个只受环境光和定向光（不投射阴影）照亮。请记住，这是我们可以做的事情，因为我们的场景类型；然而，在其他情况下，您可能需要在其他情景中使用其他设置。您可以通过以下方式从实时和静态照明计算中排除对象：
- en: Select the object to exclude.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择要排除的对象。
- en: In the **Inspector** window, click the **Layer** dropdown and click on **Add
    Layer**:![Figure 8.45 – Layer creation button
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**窗口中，单击**图层**下拉菜单，然后单击**添加图层**：![图8.45 – 图层创建按钮
- en: '](img/Figure_8.045_B14199.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.045_B14199.jpg)'
- en: Figure 8.45 – Layer creation button
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.45 – 图层创建按钮
- en: Here, you can create a layer, which is a group of objects that's used to identify
    which objects are not going to be affected by lighting. In the **Layers** list,
    look for an empty space and type in any name for those kinds of objects. In my
    case, I will only exclude the terrain, so I have just named it **Terrain**:![Figure
    8.46 – Layers list
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您可以创建一个图层，这是一个用于识别哪些对象不会受到照明影响的对象组。在**图层**列表中，查找一个空白空间，并键入这些类型对象的任何名称。在我的情况下，我只会排除地形，所以我只是将其命名为**地形**：![图8.46
    – 图层列表
- en: '](img/Figure_8.046_B14199.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.046_B14199.jpg)'
- en: Figure 8.46 – Layers list
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.46 – 图层列表
- en: Once again, select the terrain, go to the **Layer** dropdown, and select the
    layer you created in the previous step. This way, you can specify that this object
    belongs to that group of objects:![Figure 8.47 – Changing a GameObject's layer
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次选择地形，转到**图层**下拉菜单，并选择在上一步中创建的图层。这样，您可以指定该对象属于该组对象：![图8.47 – 更改游戏对象的图层
- en: '](img/Figure_8.047_B14199.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.047_B14199.jpg)'
- en: Figure 8.47 – Changing a GameObject's layer
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.47 – 更改游戏对象的图层
- en: Select all the Spotlights lights, look for the **Culling Mask** in the **Inspector**
    window, click it, and uncheck the layer you created previously. This way, you
    can specify that those lights won't affect that group of objects:![Figure 8.48
    – Light Culling Mask
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有聚光灯，查找**检视器**窗口中的**剔除蒙版**，单击它，并取消选中之前创建的图层。这样，您可以指定这些灯不会影响该组对象：![图8.48 –
    光照剔除蒙版
- en: '](img/Figure_8.048_B14199.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.048_B14199.jpg)'
- en: Figure 8.48 – Light Culling Mask
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.48 – 光照剔除蒙版
- en: Now, you can see how those selected lights are not illuminating or applying
    shadows to the terrain.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以看到那些选定的灯不会照亮或对地形应用阴影。
- en: 'Now, it''s time for the lights since the **Static** checkbox won''t work for
    them. For them, we have the following three modes:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候处理灯光了，因为**静态**复选框对它们不起作用。对于它们，我们有以下三种模式：
- en: '**Realtime**: A light in Realtime mode will affect all objects, both static
    and dynamic, using Realtime lighting, meaning there''s no precalculation. This
    is useful for lights that are not static, such as the player''s flashlight, a
    lamp that is moving due to the wind, and so on.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实时**：实时模式下的光会影响所有对象，包括静态和动态对象，使用实时照明，这意味着没有预先计算。这对于不是静态的灯光非常有用，比如玩家的手电筒，因为风而移动的灯等等。'
- en: '**Baked**: The opposite of Realtime, this kind of light will only affect static
    objects with lightmaps. This means that if the player (dynamic) moves under a
    baked light on the street (static), the street will look lit, but the player will
    still be dark and won''t cast any shadows on the street. The idea is to use this
    on lights that won''t affect any dynamic object, or on lights that are barely
    noticeable on them, so that we can increase performance by not calculating them.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**烘焙**：与实时相反，这种类型的光只会影响具有光照贴图的静态对象。这意味着如果玩家（动态）在街道上的烘焙光下移动，街道看起来会被照亮，但玩家仍然会很暗，并且不会在街道上投下任何阴影。这个想法是在不影响任何动态对象的灯光上使用它，或者在它们上几乎不可察觉的灯光上使用它，这样我们就可以通过不计算它们来提高性能。'
- en: '**Mixed**: This is the preferred mode if you are not sure which one to use.
    This kind of light will calculate lightmaps for static objects, but will also
    affect dynamic objects, combining its Realtime lighting with the baked one (like
    Realtime lights also do).'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合**：如果不确定要使用哪种模式，则这是首选模式。这种类型的光会为静态对象计算光照贴图，但也会影响动态对象，将其实时照明与烘焙照明结合在一起（就像实时光也会做的那样）。'
- en: 'In our case, our Directional Light will only affect the terrain, and because
    we don''t have shadows, applying lighting to it is relatively cheap in URP, so
    we can leave the Directional Light in Realtime so that it won''t take up any lightmap
    texture area. Our spotlights are affecting the base, but actually, they are only
    applying lighting to it – we have no shadows because our base is empty. In this
    case, it is preferable to not calculate lightmapping whatsoever, but for learning
    purposes, I will add a few objects as obstacles to the base to cast some shadows
    and justify the use of lightmapping, as shown in the following figure:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们的定向光只会影响地形，而且因为我们没有阴影，在URP中应用照明相对便宜，所以我们可以将定向光保留在实时模式，这样它就不会占用任何光照贴图区域。我们的聚光灯影响了基地，但实际上，它们只是对其应用照明
    - 我们没有阴影，因为我们的基地是空的。在这种情况下，最好根本不计算光照贴图，但出于学习目的，我将添加一些障碍物作为基地的阴影，并证明使用光照贴图，如下图所示：
- en: '![Figure 8.49 – Adding objects to project light'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.49 – 添加对象以投射光线'
- en: '](img/Figure_8.049_B14199.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.049_B14199.jpg)'
- en: Figure 8.49 – Adding objects to project light
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.49 – 向项目添加对象以投射光线
- en: 'Here, you can see how the original design of our level changes constantly during
    the development of the game, and that''s something you can''t avoid – bigger parts
    of the game will change in time. Now, we are ready to set up the Light Modes and
    execute the baking process, as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们的关卡原始设计在游戏开发过程中不断变化，这是您无法避免的事情 - 游戏的更大部分将随时间改变。现在，我们已经准备好设置光照模式并执行烘焙过程，如下所示：
- en: Select **Directional Light**.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**定向光**。
- en: Set `Inspector` window to **Realtime** (if it's not already in that mode).
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`检视器`窗口设置为**实时**（如果尚未处于该模式）。
- en: Select both Spotlights.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个聚光灯。
- en: Set their **Render Mode** to **Mixed**:![Figure 8.50 – Mixed lighting setting
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们的**渲染模式**设置为**混合**：![图8.50 – 混合光照设置
- en: '](img/Figure_8.050_B14199.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.050_B14199.jpg)'
- en: Figure 8.50 – Mixed lighting setting
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.50 – 混合光照设置
- en: Open the **Lighting Settings** window (**Window** | **Rendering** | **Lighting
    Settings**).
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**照明设置**窗口（**窗口** | **渲染** | **照明设置**）。
- en: Click **Generate Lighting**, which is the same button we used previously to
    generate ambient lighting.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击**生成照明**，这是我们之前用来生成环境光照的相同按钮。
- en: Wait for the process to complete. You can do this by checking the progress bar
    at the bottom-right of the Unity Editor. Note that this process could take hours
    in large scenes, so be patient:![Figure 8.51 – Baking progress bar
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待进程完成。您可以通过检查Unity编辑器右下角的进度条来完成此操作。请注意，这个过程可能需要几个小时才能完成，所以请耐心等待：![图8.51 – 烘焙进度条
- en: '](img/Figure_8.051_B14199.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.051_B14199.jpg)'
- en: Figure 8.51 – Baking progress bar
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.51 – 烘焙进度条
- en: We want to change some of the settings of the baking process. In order to enable
    the controls for this, click the **New Lighting Settings** button. This will create
    an asset with lightmapping settings that can be applied to several scenes in case
    we want to share the same settings multiple times:![Figure 8.52 – Creating lighting
    settings
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要更改烘焙过程的一些设置。为了启用此控件，单击**新照明设置**按钮。这将创建一个具有光照设置的资源，可以应用于多个场景，以便我们多次共享相同的设置：![图8.52
    – 创建照明设置
- en: '](img/Figure_8.052_B14199.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.052_B14199.jpg)'
- en: Figure 8.52 – Creating lighting settings
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.52 – 创建照明设置
- en: Reduce the quality of lightmapping, just to make the process go faster. Just
    to iterate, the lighting can easily be reduced by using settings such as **Lightmap
    Resolution**, **Direct**, **Indirect,** and **Environment Samples**. In my case,
    I have those settings applied, as shown in the following figure. Note that even
    reducing those will take time; we have too many objects in the scene due to the
    modular level design:![Figure 8.53 – Scene lighting settings
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 降低光照质量，以加快进程。只需迭代，通过使用**光照贴图分辨率**、**直接**、**间接**和**环境样本**等设置，可以轻松降低照明。在我的情况下，我已经应用了这些设置，如下图所示。请注意，即使减少这些设置也需要时间；由于模块化关卡设计，我们的场景中有太多对象：![图8.53
    – 场景光照设置
- en: '](img/Figure_8.053_B14199.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.053_B14199.jpg)'
- en: Figure 8.53 – Scene lighting settings
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.53 – 场景光照设置
- en: After the process has completed, you can check the bottom part of the **Lighting
    Settings** window, where you can see how many lightmaps need to be generated.
    We have a maximum lightmap resolution, so we probably need several of them to
    cover the entire scene. Also, it informs us of their size so that we can consider
    their impact in terms of RAM. Finally, you can check out the **Baked Lightmaps**
    section to see them:![Figure 8.54 – Generated lightmaps
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进程完成后，您可以检查**照明设置**窗口的底部，您可以看到需要生成多少个光照贴图。我们有最大光照贴图分辨率，所以我们可能需要生成几个光照贴图来覆盖整个场景。此外，它还告诉我们它们的大小，以便我们可以考虑它们对RAM的影响。最后，您可以查看**烘焙光照贴图**部分来查看它们：![图8.54
    – 生成的光照贴图
- en: '](img/Figure_8.054_B14199.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.054_B14199.jpg)'
- en: Figure 8.54 – Generated lightmaps
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.54 – 生成的光照贴图
- en: 'Now, based on the results, you can move objects, modify light intensities,
    or make whatever correction you would need in order to make the scene look the
    way you want and recalculate the lighting every time you need to. In my case,
    those settings gave me good enough results, which you can see in the following
    figure:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，根据结果，您可以移动对象，修改光强度，或者进行任何您需要的修正，以使场景看起来符合您的要求，并在需要时重新计算照明。在我的情况下，这些设置给我带来了足够好的结果，您可以在下图中看到：
- en: '![Figure 8.55 – Lightmap result'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.55 – 光照贴图结果'
- en: '](img/Figure_8.055_B14199.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.055_B14199.jpg)'
- en: Figure 8.55 – Lightmap result
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.55 – 光照贴图结果
- en: We still have plenty of small settings to touch on, but I will leave you to
    discover those through trial and error or by reading the Unity documentation about
    lightmapping at this link. Reading the Unity manual is a good source of knowledge
    and I recommend that you start using it – any good developer, no matter how experienced,
    should read the manual.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍有许多小设置要处理，但我会让您通过试错或阅读Unity关于光照贴图的文档来发现这些设置。阅读Unity手册是获取知识的好途径，我建议您开始使用它
    - 任何经验丰富的好开发人员都应该阅读手册。
- en: Applying static lighting to static objects
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将静态光照应用于静态对象
- en: 'When marking objects as static in your scene, you''ve probably figured out
    that all the objects in the scene won''t move, so you probably checked the static
    checkbox for every one. That''s OK, but you should always put a dynamic object
    into the scene to really be sure that everything works OK – no games have totally
    static scenes. Try adding a capsule and moving it around to simulate our player,
    as shown in the following figure. If you pay attention to it, you will notice
    something odd – the shadows being generated by the lightmapping process are not
    being applied to our dynamic object:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当在场景中将对象标记为静态时，您可能已经发现场景中的所有对象都不会移动，因此您可能已经为每个对象都勾选了静态复选框。这没问题，但您应该始终将一个动态对象放入场景中，以确保一切正常
    - 没有游戏完全静态。尝试添加一个胶囊体并将其移动以模拟我们的玩家，如下图所示。如果您留意，您会注意到一些奇怪的事情 - 光照贴图过程生成的阴影未应用于我们的动态对象：
- en: '![Figure 8.56 – Dynamic object under a lightmap''s precalculated shadow'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.56 - 动态物体在烘焙阴影下'
- en: '](img/Figure_8.056_B14199.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.056_B14199.jpg)'
- en: Figure 8.56 – Dynamic object under a lightmap's precalculated shadow
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.56 - 动态物体在烘焙阴影下
- en: You may be thinking that Mixed Light Mode was supposed to affect both dynamic
    and static objects, and that is exactly what it's doing. The problem here is that
    everything related to static objects is precalculated into those lightmap textures,
    including the shadows they cast, and because our capsule is dynamic, it wasn't
    there when the precalculation process was executed. So, in this case, because
    the object that cast the shadow was static, its shadow won't affect any dynamic
    object.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为混合光模式应该影响动态和静态物体，这正是它所做的。问题在于，与静态物体相关的所有内容都预先计算到那些光照图纹理中，包括它们投射的阴影，因为我们的胶囊是动态的，在预计算过程执行时并不存在。所以，在这种情况下，因为投射阴影的对象是静态的，它的阴影不会影响任何动态物体。
- en: 'Here, we have several solutions. The first would be to change the Static and
    Realtime mixing algorithm to make everything near the camera use Realtime lighting
    and prevent this problem (at least near the focus of attention of the player),
    which would have a big impact on performance. The alternative is to use **Light
    Probes**. When we baked information, we only did that on lightmaps, meaning that
    we have information on lighting just over surfaces, not in empty spaces. Because
    our player is traversing the empty spaces between those surfaces, we don''t know
    exactly how the lighting would look in those spaces, such as the middle of a corridor.
    Light Probes are a set of points in those empty spaces where Unity also pre-calculates
    information, so when some dynamic object passes through it, it will sample information
    from it. In the following figure, you can see some Light Probes that have been
    applied to our scene. You will notice that the ones that are inside shadows are
    going to be dark, while the ones exposed to light will have a greater intensity.
    This effect will be applied to our dynamic objects:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有几种解决方案。第一种是改变静态和实时混合算法，使相机附近的所有东西都使用实时照明，并防止这个问题（至少在玩家的注意焦点附近），这对性能会有很大影响。另一种选择是使用**光探头**。当我们烘焙信息时，我们只在光照图上做了这个，这意味着我们只有表面上的光照信息，而不是空白空间中的光照信息。因为我们的玩家正在穿越这些表面之间的空白空间，我们不知道这些空间的光照会是什么样子，比如走廊中间。光探头是在这些空白空间中的一组点，Unity也会预先计算信息，所以当一些动态物体经过时，它会从中采样信息。在下图中，你可以看到一些应用到我们场景中的光探头。你会注意到那些在阴影中的光探头会变暗，而那些暴露在光线下的光探头会有更大的强度。这种效果将应用到我们的动态物体上：
- en: '![Figure 8.57 – Spheres representing Light Probes'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.57 - 代表光探头的球体'
- en: '](img/Figure_8.057_B14199.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.057_B14199.jpg)'
- en: Figure 8.57 – Spheres representing Light Probes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.57 - 代表光探头的球体
- en: 'If you move your object through the scene now, it will react to the shadows,
    as shown in the following two images, where you can see a dynamic object being
    lit outside a baked shadow and being dark inside:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在在场景中移动你的物体，它将对阴影做出反应，就像下面两张图片中所示，你可以看到一个动态物体在烘焙阴影外被照亮，而在内部变暗：
- en: '![Figure 8.58 – Dynamic object receiving baked lighting from Light Probes'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.58 - 动态物体接收来自光探头的烘焙照明'
- en: '](img/Figure_8.058_B14199(Merged).jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.058_B14199(Merged).jpg)'
- en: Figure 8.58 – Dynamic object receiving baked lighting from Light Probes
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.58 - 动态物体接收来自光探头的烘焙照明
- en: 'In order to create Light Probes, do the following:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建光探头，进行以下操作：
- en: Create a group of **Light** Probes by going to **GameObject** | **Light** |
    **Light Probe Group**:![Figure 8.59 – Creating a Light Probe Group
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**GameObject** | **Light** | **Light Probe Group**来创建一组**光**探头：![图8.59 -
    创建光探头组
- en: '](img/Figure_8.059_B14199.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.059_B14199.jpg)'
- en: Figure 8.59 – Creating a Light Probe Group
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.59 - 创建光探头组
- en: Fortunately, we have some guidelines on how to locate them. It is recommended
    to place them where the lighting changes, such as inside and outside shadow borders.
    However, that is pretty complicated. The simplest and recommended approach is
    to just drop a grid of Light Probes all over your playable area. To do that, you
    can simply copy and paste the Light Grid Group several times to cover the entire
    base:![Figure 8.60 – Light Probe grid
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一些关于如何定位它们的指导方针。建议将它们放在光照变化的地方，比如在内部和外部阴影边界。然而，这相当复杂。最简单和推荐的方法是在可玩区域上放置一个光探头网格。为此，你可以简单地多次复制和粘贴光网格组，以覆盖整个基地：![图8.60
    - 光探头网格
- en: '](img/Figure_8.060_B14199.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.060_B14199.jpg)'
- en: Figure 8.60 – Light Probe grid
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.60 - 光探头网格
- en: Another approach would be to select one group and click the **Edit Light Probes**
    button to enter Light Probe edit mode:![Figure 8.61 – Light Probe Group edit button
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是选择一组并点击**编辑光探头**按钮进入光探头编辑模式：![图8.61 - 光探头组编辑按钮
- en: '](img/Figure_8.061_B14199.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.061_B14199.jpg)'
- en: Figure 8.61 – Light Probe Group edit button
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.61 - 光探头组编辑按钮
- en: Click the **Select All** button and then **Duplicate Selected** to duplicate
    all the previously existing probes.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**全选**按钮，然后点击**复制所选**按钮，复制所有先前存在的探针。
- en: Using the translate gizmo, move them next to the previous ones, extending the
    grid in the process. Consider that the nearer the probes are, you will need more
    to cover the terrain, which will generate more data. However, Light Probes data
    is relatively cheap, so you can have lots of them.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用平移小工具，将它们移动到先前的位置旁边，同时扩展网格。请考虑到探针越近，你需要更多的探针来覆盖地形，这将产生更多的数据。然而，光探头数据相对便宜，所以你可以有很多。
- en: Repeat *steps 4* to *5* until you've covered the entire area.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤4*至*5*，直到覆盖整个区域。
- en: Regenerate lighting with the **Generate Lighting** button in **Lighting Settings**.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**光照设置**中的**生成照明**按钮重新生成照明。
- en: With that, you have precalculated lighting on the Light Probes affecting our
    dynamic objects, combining both worlds to get cohesive lighting.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你就预先计算了影响我们动态物体的光探头上的照明，将两个世界结合起来，获得了连贯的照明。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed several lighting topics, such as how Unity calculates
    lights, shadows, how to deal with different light sources such as direct and indirect
    lighting, how to configure shadows, how to bake lighting to optimize performance,
    and how to combine dynamic and static lighting so that the lights aren't disconnected
    from the world they affect. This was a long chapter, but lighting deserves that.
    It is a complex subject that can improve the look and feel of your scene drastically,
    as well as reducing your performance dramatically. It requires a lot of practice
    and, here, we tried to summarize all the important knowledge you will need to
    start experimenting with it. Be patient with this topic; it is easy to get incorrect
    results, but you are probably just one checkbox away from solving it.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几个照明主题，比如Unity如何计算光线、阴影，如何处理不同的光源，比如直接和间接照明，如何配置阴影，如何烘焙照明以优化性能，以及如何结合动态和静态照明，使光线不脱离影响其所在世界的环境。这是一个很长的章节，但照明值得如此。这是一个复杂的主题，可以显著改善场景的外观和感觉，同时大大降低性能。这需要大量的实践，我们在这里试图总结出你开始尝试的所有重要知识。对这个主题要有耐心；很容易得到不正确的结果，但你可能只差一个复选框就能解决问题。
- en: Now that we have improved all we can in the scene settings, in the next chapter,
    we will apply a final layer of graphic effects using the Unity Postprocessing
    Stack, which will apply full-screen image effects – ones that will give us that
    cinematic look and feel all games have nowadays.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在场景设置中做了所有可以改进的事情，在下一章中，我们将使用Unity后期处理堆栈应用最终的图形效果，这将应用全屏图像效果-这些效果将给我们带来当今所有游戏都具有的电影般的外观和感觉。
