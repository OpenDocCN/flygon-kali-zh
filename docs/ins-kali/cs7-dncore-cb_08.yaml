- en: High Performance Programming Using Parallel and Multithreading in C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行和多线程进行高性能编程
- en: 'This chapter takes a look at improving your code''s performance using multithreading
    and parallel programming. In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍如何使用多线程和并行编程来提高代码的性能。在本章中，我们将介绍以下内容：
- en: Creating and aborting a low-priority background thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和中止低优先级后台线程
- en: Increasing the maximum thread pool size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加最大线程池大小
- en: Creating multiple threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: Locking one thread until the contended resources are available
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定一个线程，直到争用的资源可用
- en: Invoking parallel calls to methods using Parallel.Invoke
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Parallel.Invoke调用方法的并行调用
- en: Using a parallel foreach loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行foreach循环
- en: Cancelling a parallel foreach loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行foreach循环
- en: Catching errors in parallel foreach loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行foreach循环中捕获错误
- en: Debugging multiple threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试多个线程
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: If you can find a single core CPU in a computer today, it will probably mean
    that you are standing in a museum. Every new computer today utilizes the advantages
    of multiple cores. Programmers can take advantage of this extra processing power
    in their own applications. As applications have grown in size and complexity,
    in many cases they actually need to utilize multithreading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您今天在一台计算机上找到了单核CPU，那可能意味着您站在一个博物馆里。今天的每台新计算机都利用了多核的优势。程序员可以在自己的应用程序中利用这种额外的处理能力。随着应用程序的规模和复杂性不断增长，在许多情况下，它们实际上需要利用多线程。
- en: While not every situation is always suited to the implementation of multithreaded
    code logic, it is good to know how to use multithreading to improve the performance
    of your applications. This chapter will take you through the fundamentals of this
    exciting technology in C# programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非每种情况都适合实现多线程代码逻辑，但了解如何使用多线程来提高应用程序性能是很有益的。本章将带您了解C#编程中这一激动人心的技术的基础知识。
- en: Creating and aborting a low-priority background thread
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和中止低优先级后台线程
- en: The reason we want to take a look at a background thread specifically is because,
    by default, all threads created by the main app thread or `Thread` class constructor
    are foreground threads. So, what exactly separates a foreground thread from a
    background thread? Well, background threads are identical to foreground threads
    with the exception that if all foreground threads are terminated, the background
    threads are stopped too. This is useful if you have a process in your application
    that must not stop the application from terminating. In other words, while your
    application is running, the background threads must continue to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以要专门研究后台线程，是因为默认情况下，由主应用程序线程或`Thread`类构造函数创建的所有线程都是前台线程。那么，前台线程和后台线程有什么区别呢？嗯，后台线程与前台线程相同，唯一的区别是如果所有前台线程终止，后台线程也会停止。如果您的应用程序中有一个进程不能阻止应用程序终止，这是很有用的。换句话说，在应用程序运行时，后台线程必须继续运行。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: We will create a simple application that defines the thread created as a background
    thread. It will then suspend, resume, and abort the thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，将创建的线程定义为后台线程。然后暂停、恢复和中止线程。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new console application in Visual Studio.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中创建一个新的控制台应用程序。
- en: Next, add a class called `Demo` to your console application.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在您的控制台应用程序中添加一个名为`Demo`的类。
- en: 'Inside the `Demo` class, add a method called `DoBackgroundTask()` with the
    `public void` modifiers, and add the following console output to it:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中，添加一个名为`DoBackgroundTask()`的方法，使用`public void`修饰符，并将以下控制台输出添加到其中：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make sure that you have added the `using` statements for `System.Threading`
    and `static System.Console` to your `using` statements.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经在`using`语句中添加了`System.Threading`和`static System.Console`的`using`语句。
- en: 'In the `void Main` method of your console application, create a new instance
    of your `Demo` class and add it to a new thread called `backgroundThread`. Define
    this newly created thread to be a background thread and then start it. Finally,
    set the thread to sleep for 5 seconds. We need to do this because we created a
    background thread that is set to sleep for 3 seconds. Background threads do not
    prohibit foreground threads from terminating. Therefore, if the main application
    thread (which is by default a foreground thread) terminates before the background
    thread completes, the application will terminate and also terminate the background
    thread:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的控制台应用程序的`void Main`方法中，创建一个`Demo`类的新实例，并将其添加到名为`backgroundThread`的新线程中。将这个新创建的线程定义为后台线程，然后启动它。最后，将线程休眠5秒。我们需要这样做是因为我们创建了一个后台线程，它被设置为休眠3秒。后台线程不会阻止前台线程终止。因此，如果主应用程序线程（默认情况下是前台线程）在后台线程完成之前终止，应用程序将终止并终止后台线程：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run your console application by pressing *F5*. You will see that we have created
    a background thread with a normal priority:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*F5*运行您的控制台应用程序。您将看到我们已经创建了一个具有普通优先级的后台线程：
- en: '![](img/B06434_09_06.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_06.png)'
- en: 'Let''s modify our thread and set its priority down to low. Add this line of
    code to your console application:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的线程，并将其优先级降低到低。将以下代码添加到您的控制台应用程序中：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This line will downgrade the thread priority:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码会降低线程优先级：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run your console application again. This time, you will see that the thread
    priority has been set to the lowest priority:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行您的控制台应用程序。这次，您将看到线程优先级已经设置为最低优先级：
- en: '![](img/B06434_09_07.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_07.png)'
- en: 'Go back to your `DoBackgroundTask()` method and add `Thread.CurrentThread.Abort();`
    right before `Thread.Sleep(3000);` is called. This line will prematurely kill
    the background thread. Your code should look like this:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到您的`DoBackgroundTask()`方法，并在调用`Thread.Sleep(3000);`之前添加`Thread.CurrentThread.Abort();`。这行代码将过早终止后台线程。您的代码应该如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you run your console application, you will see that the thread is aborted
    before the `Thread.Sleep` method is called. Aborting a thread in this way, however
    is, generally, not recommended:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行控制台应用程序时，您会发现在调用`Thread.Sleep`方法之前线程被中止。然而，通常不建议以这种方式中止线程：
- en: '![](img/B06434_09_08.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_08.png)'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Being able to create a background thread is a great way to work on a different
    thread from the main thread while not interfering with the process of the main
    application thread. Another added benefit is that the background thread is terminated
    as soon as the main application thread is completed. This process ensures that
    your application will terminate gracefully.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建后台线程是在与主线程不干扰主应用程序线程的情况下在不同线程上工作的好方法。另一个附加的好处是，后台线程在主应用程序线程完成后立即终止。这个过程确保您的应用程序将正常终止。
- en: Increasing the maximum thread pool size
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加最大线程池大小
- en: The thread pool in .NET resides in the `System.Threading.ThreadPool` class.
    Generally, there is a lot of discussion around creating your own threads, as opposed
    to using the thread pool. Popular thinking dictates that the thread pool should
    be used for brief jobs. This is because the thread pool is limited in size. There
    are many other processes in the system that will use the thread pool. You, therefore,
    do not want your application to hog all the threads in the thread pool.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的线程池位于`System.Threading.ThreadPool`类中。通常，人们对创建自己的线程和使用线程池进行了很多讨论。流行的观点规定，线程池应该用于短暂的工作。这是因为线程池的大小是有限的。系统中有许多其他进程将使用线程池。因此，您不希望您的应用程序占用线程池中的所有线程。
- en: The rule is that you can't set the number of maximum worker or completion threads
    to be fewer than the number of processors on your computer. You are also not allowed
    to set the maximum worker or completion threads to less than the minimum thread
    pool size.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是您不能将最大工作线程或完成线程的数量设置为少于计算机上的处理器数量。您也不允许将最大工作线程或完成线程的数量设置为小于最小线程池大小。
- en: Getting ready
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will read the number of processors on the current computer. Then, we will
    get the minimum and maximum allowable thread pool size, generate a random number
    between the minimum and maximum thread pool size, and set the maximum number of
    threads on the thread pool.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取当前计算机上的处理器数量。然后，我们将获取线程池大小的最小和最大允许值，生成在最小和最大线程池大小之间的随机数，并设置线程池中的最大线程数。
- en: How to do it...
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: Create a new method called `IncreaseThreadPoolSize()` in the `Demo` class.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中创建一个名为`IncreaseThreadPoolSize()`的新方法。
- en: 'Start by adding the code to read the number of processors on the current machine
    using `Environment.ProcessorCount`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加代码以使用`Environment.ProcessorCount`读取当前计算机上的处理器数量：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we retrieve the maximum and minimum threads available in the thread pool:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们检索线程池中可用的最大和最小线程：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we generate a random number between the maximum and minimum number of
    threads in the thread pool:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们生成在线程池中最大和最小线程数之间的随机数：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We now need to attempt to set the maximum number of threads in the thread pool
    by calling the `SetMaxThreads` method, and setting it to our new random maximum
    value for the worker threads and the completion port threads. Any requests above
    this maximum number will be queued until the thread pool threads become active
    again. If the `SetMaxThreads` method is successful, the method will return true;
    otherwise, it will return `false`. It is a good idea to ensure that the `SetMaxThreads`
    method is successful:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要尝试通过调用`SetMaxThreads`方法设置线程池中的最大线程数，并将其设置为我们新的随机最大值，以及工作线程和完成端口线程的最大值。超过此最大数量的任何请求都将排队，直到线程池线程再次变为活动状态。如果`SetMaxThreads`方法成功，该方法将返回true；否则，它将返回`false`。确保`SetMaxThreads`方法成功是一个好主意：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Worker threads is the maximum number of worker threads in the thread pool while
    the completion port threads is the maximum number of asynchronous I/O threads
    in the thread pool.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 工作线程是线程池中的工作线程的最大数量，而完成端口线程是线程池中异步I/O线程的最大数量。
- en: 'When you''ve added all the code in the steps listed, your `IncreaseThreadPoolSize()`
    method should look like this:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您按照列出的步骤添加了所有代码后，您的`IncreaseThreadPoolSize()`方法应该如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Head on over to your console application, create a new instance of your `Demo` class,
    and call the `IncreaseThreadPoolSize()` method:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您的控制台应用程序，创建`Demo`类的新实例，并调用`IncreaseThreadPoolSize()`方法：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, run your console application and take note of the output:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行您的控制台应用程序并注意输出：
- en: '![](img/B06434_09_09.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_09.png)'
- en: How it works...
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: From the console application, we can see that the processor count is `2`. The
    minimum number of thread pool threads, therefore, also equals `2`. We then read
    the maximum thread pool size and generate a random number between the minimum
    and maximum numbers. Lastly, we set the maximum thread pool size, to our randomly
    generated minimum and maximum.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台应用程序中，我们可以看到处理器数量为`2`。因此，线程池线程的最小数量也等于`2`。然后，我们读取最大线程池大小，并生成一个在最小和最大数字之间的随机数。最后，我们将最大线程池大小设置为我们随机生成的最小和最大值。
- en: While this is only a proof of concept and not something one would do in a production
    application (setting the thread pool to a random number), it clearly illustrates
    the ability to set the thread pool to a value specified by the developer.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个概念验证，而不是在生产应用程序中会做的事情（将线程池设置为随机数），但它清楚地说明了开发人员设置线程池为指定值的能力。
- en: The code in this recipe was compiled for 32-bit. Try changing your application
    to a 64-bit application and run the code again. See the difference a 64-bit makes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中的代码是为32位编译的。尝试将应用程序更改为64位应用程序，然后再次运行代码。看看64位的差异。
- en: Creating multiple threads
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: Sometimes, we need to create multiple threads. Before we can continue, however,
    we need to wait for these threads to complete doing whatever they need to do.
    For this, the use of tasks is best suited.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要创建多个线程。然而，在我们继续之前，我们需要等待这些线程完成它们需要做的事情。对于这一点，使用任务是最合适的。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you add the `using System.Threading.Tasks;` statement to the
    top of your `Recipes` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`Recipes`类的顶部添加`using System.Threading.Tasks;`语句。
- en: How to do it...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new method called `MultipleThreadWait()` in your `Demo` class. Then,
    create a second method called `RunThread()` with the `private` modifier that takes
    an integer of seconds to make the thread sleep. This will simulate the process
    of doing some work for a variable amount of time:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Demo`类中创建一个名为`MultipleThreadWait()`的新方法。然后，创建一个名为`RunThread()`的第二个方法，使用`private`修饰符，它以秒为参数使线程睡眠。这将模拟以可变时间做一些工作的过程：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In reality, you would probably not call the same method. You could, for all
    intents and purposes, call three separate methods. Here, however, for simplicity's
    sake, we will call the same method with different sleep durations.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可能不会调用相同的方法。您可以出于所有目的和目的，调用三个单独的方法。然而，在这里，为了简单起见，我们将调用相同的方法，但睡眠持续时间不同。
- en: 'Add the following code to your `MultipleThreadWait()` method. You will notice
    that we are creating three tasks that then create three threads. We then fire
    off these three threads and make them sleep for `3`, `5`, and `2` seconds. Finally,
    we call the `Task.WaitAll` method to wait before continuing the execution of the
    application:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`MultipleThreadWait()`方法中添加以下代码。您会注意到我们创建了三个任务，然后创建了三个线程。然后我们启动这三个线程，并让它们分别睡眠`3`、`5`和`2`秒。最后，我们调用`Task.WaitAll`方法等待后续执行应用程序：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, in the `RunThread()` method, we read the current thread ID and then make
    the thread sleep for the amount of milliseconds supplied. This is just the integer
    value for the seconds multiplied by `1000`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`RunThread()`方法中，我们读取当前线程ID，然后使线程睡眠所提供的毫秒数。这只是秒数乘以`1000`的整数值：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When you have completed the code, your `Demo` class should look like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成代码后，您的`Demo`类应该如下所示：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, add a new instance of the `Demo` class to your console application
    and call the `MultipleThreadWait()` method:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在您的控制台应用程序中添加一个`Demo`类的新实例并调用`MultipleThreadWait()`方法：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Run your console application and view the output produced:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并查看生成的输出：
- en: '![](img/B06434_09_10.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_10.png)'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You will notice that three threads (`thread 3`, `thread 4`, and `thread 5`)
    are created. These are then paused by making them sleep for various amounts of
    time. After each thread wakes, the code waits for all three threads to complete
    before continuing the execution of the application code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到创建了三个线程（`thread 3`，`thread 4`和`thread 5`）。然后通过让它们睡眠不同的时间来暂停它们。每个线程唤醒后，代码会等待所有三个线程完成后才继续执行应用程序代码。
- en: Locking one thread until the contended resources are available
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一个线程锁定，直到有争用的资源可用
- en: There are instances where we want to give sole access to a process to a specific
    thread. We can do this using the `lock` keyword. This will, therefore, execute
    this process in a thread-safe manner. Hence, when a thread runs the process it
    will gain exclusive access to the process for the duration of the lock scope.
    If another thread tries to gain access to the process inside the locked code,
    it will be blocked and have to wait its turn until the lock is released.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们希望将特定线程的进程独占访问。我们可以使用`lock`关键字来实现这一点。因此，这将以线程安全的方式执行此进程。因此，当一个线程运行进程时，它将在锁定范围内获得对进程的独占访问。如果另一个线程尝试在锁定的代码内部访问进程，它将被阻塞并必须等待其轮到释放锁定。
- en: Getting ready
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, we will use tasks. Make sure that you've added the `using
    System.Threading.Tasks;` statement to the top of your `Demo` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，我们将使用任务。确保在您的`Demo`类的顶部添加`using System.Threading.Tasks;`语句。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `Demo` class, add an object called `threadLock` with the `private` modifier.
    Then, add two methods called `LockThreadExample()` and `ContendedResource()` that
    take an integer of seconds to sleep as a parameter:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中，添加一个名为`threadLock`的对象，并使用`private`修饰符。然后，添加两个名为`LockThreadExample()`和`ContendedResource()`的方法，它们以秒为参数来睡眠：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It is considered to be a best practice to define the object to lock on as private.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将要锁定的对象定义为私有是最佳实践。
- en: 'Add three tasks to the `LockThreadExample()` method. They will create threads
    that try to access the same section of code simultaneously. This code will wait
    until all the threads have completed before terminating the application:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LockThreadExample()`方法中添加三个任务。它们将创建尝试同时访问相同代码部分的线程。此代码将等待所有线程完成后才终止应用程序：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `ContendedResource()` method, create a lock using the `private threadLock`
    object and then make the thread sleep for the amount of seconds passed to the
    method as a parameter:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContendedResource()`方法中，使用`private threadLock`对象创建一个锁，然后使线程睡眠传递给方法的秒数：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Back in the console application, add the following code to instantiate a new
    `Demo` class and call the `LockThreadExample()` method:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到控制台应用程序，添加以下代码来实例化一个新的`Demo`类并调用`LockThreadExample()`方法：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the console application and look at the information output to the console
    window:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序并查看控制台窗口中的输出信息：
- en: '![](img/B06434_09_11-1.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_11-1.png)'
- en: How it works...
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We can see that `thread 4` gained exclusive access to the contended resource.
    At the same time, `thread 3` and `thread 5` tried to access the contended resource
    locked by `thread 4`. This then caused the other two threads to wait until `thread
    4` had completed and released the lock. The result of this is that the code is
    executed in an orderly manner, as can be seen in the console window output. Each
    thread waits its turn until it can access the resource and lock its thread.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`线程4`获得了对争用资源的独占访问。与此同时，`线程3`和`线程5`试图访问被`线程4`锁定的争用资源。这导致另外两个线程等待，直到`线程4`完成并释放锁。其结果是代码按顺序执行，可以在控制台窗口输出中看到。每个线程都等待轮到自己访问资源并锁定其线程。
- en: Invoking parallel calls to methods using Parallel.Invoke
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用Parallel.Invoke并行调用方法
- en: '`Parallel.Invoke` allows us to execute tasks in (you guessed it) parallel.
    Sometimes, you need to perform operations simultaneously and, in so doing, speed
    up the processing. You can, therefore, expect that the total time taken to process
    the tasks is equal to the longest running process. Using `Parallel.Invoke` is
    quite easy.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`允许我们并行执行任务。有时，您需要同时执行操作，并通过这样做加快处理速度。因此，您可以期望处理任务所需的总时间等于运行时间最长的进程。使用`Parallel.Invoke`非常容易。'
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you've added the `using System.Threading.Tasks;` statement to
    the top of your `Demo` class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已经在`Demo`类的顶部添加了`using System.Threading.Tasks;`语句。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Start off by creating two methods in the `Demo` class called `ParallelInvoke()`
    and `PerformSomeTask()` that take an integer of seconds to sleep as the parameter:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`Demo`类中创建两个方法，分别称为`ParallelInvoke()`和`PerformSomeTask()`，并将秒数作为参数传递：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code to the `ParallelInvoke()` method. This code will call
    `Paralell.Invoke` to run the `PerformSomeTask()` method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ParallelInvoke()`方法中。这段代码将调用`Paralell.Invoke`来运行`PerformSomeTask()`方法：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `PerformSomeTask()` method, make the thread sleep for the amount of
    seconds passed to the method as the parameter (converting the seconds to milliseconds
    by multiplying it by `1000`):'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PerformSomeTask()`方法中，使线程睡眠传递给方法的秒数（通过将其乘以`1000`将秒转换为毫秒）：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you''ve added all the code, your `Demo` class should look like this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了所有的代码后，你的`Demo`类应该是这样的：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the console application, instantiate a new instance of the `Demo` class
    and call the `ParallelInvoke()` method:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，实例化`Demo`类的一个新实例，并调用`ParallelInvoke()`方法：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the console application and look at the output produced in the console
    window:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，并查看控制台窗口中产生的输出：
- en: '![](img/B06434_09_12.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_12.png)'
- en: How it works...
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Because we are running all these threads in parallel, we can assume that the
    longest process will denote the total duration of all the tasks. This means that
    the total duration of the process will be 5 seconds because the longest task will
    take 5 seconds to complete (we set `thread 3` to sleep for a maximum of 5 seconds).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在并行运行所有这些线程，我们可以假设最长的进程将表示所有任务的总持续时间。这意味着进程的总持续时间将是5秒，因为最长的任务将花费5秒完成（我们将`线程3`设置为最多睡眠5秒）。
- en: As we can see, the time difference between the start and the end of `Parallel.Invoke`
    is exactly 5 seconds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，`Parallel.Invoke`的开始和结束之间的时间差确实是5秒。
- en: Using a parallel foreach loop
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行foreach循环
- en: A while ago, during a work retreat (yes, the company I work for is really that
    cool), Graham Rook, who is one of my colleagues, showed me a parallel `foreach`
    loop. It certainly speeds up processing a great deal. But here's the rub. It makes
    no sense to use a parallel `foreach` loop if you're dealing with small amounts
    of data or little tasks. The parallel `foreach` loop excels when there is bulk
    processing to do or huge amounts of data to process.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 不久前，在一次工作撤退期间（是的，我工作的公司真的很酷），我的同事之一格雷厄姆·鲁克向我展示了一个并行`foreach`循环。它确实大大加快了处理速度。但问题是，如果你处理的数据量很小或者任务很少，使用并行`foreach`循环就没有意义。并行`foreach`循环在需要进行大量处理或处理大量数据时表现出色。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start off by looking at where the parallel `foreach` loop does not perform
    better than the standard `foreach` loop. For this, we will create a small list
    of 500 items and just iterate over the list, writing the items to the console
    window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先看看并行`foreach`循环在哪些情况下不比标准的`foreach`循环表现更好。为此，我们将创建一个包含500个项目的小列表，只需迭代列表，将项目写入控制台窗口。
- en: For the second example, which illustrates the power of the parallel `foreach`
    loop, we will use the same list and create a file for each item in the list. The
    power and benefit of the parallel `foreach` loop will be evident in the second
    example. You will need to add the `using System.Diagnostics;` and `using System.IO;`
    namespaces to run this recipe.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个例子，它展示了并行`foreach`循环的强大之处，我们将使用相同的列表，并为列表中的每个项目创建一个文件。并行`foreach`循环的强大和好处将在第二个例子中显而易见。您需要添加`using
    System.Diagnostics;`和`using System.IO;`命名空间来运行这个示例。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Start off by creating two methods in the `Demo` class. Call one method `ReadCollectionForEach()`
    and pass it a parameter of `List<string>`. Create a second method called `ReadCollectionParallelForEach()`
    that also accepts a parameter of `List<string>`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在`Demo`类中创建两个方法。一个方法称为`ReadCollectionForEach()`，并传递一个`List<string>`参数。创建第二个方法称为`ReadCollectionParallelForEach()`，它也接受一个`List<string>`参数：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the `ReadCollectionForEach()` method, add a standard `foreach` loop that
    will iterate over the collection of strings passed to it and write the value it
    finds to the console window. Then, clear the console window. Use a timer to keep
    track of the total seconds elapsed during the `foreach` loop:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReadCollectionForEach()`方法中，添加一个标准的`foreach`循环，它将迭代传递给它的字符串集合，并将它找到的值写入控制台窗口。然后清除控制台窗口。使用计时器来跟踪`foreach`循环期间经过的总秒数：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the second method, called `ReadCollectionParallelForEach()`, do the same.
    However, instead of using a standard `foreach` loop, add a `Parallel.ForEach`
    loop. You will notice that the `Parallel.ForEach` loop looks slightly different.
    The signature of `Parallel.ForEach` requires that you pass it an enumerable data
    source (`List<string> intCollection`) and define an action, which is the delegate
    that is invoked for every iteration (`integer`):'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个名为`ReadCollectionParallelForEach()`的方法中也是如此。但是，不要使用标准的`foreach`循环，而是添加一个`Parallel.ForEach`循环。您会注意到`Parallel.ForEach`循环看起来略有不同。`Parallel.ForEach`的签名要求您传递一个可枚举的数据源（`List<string>
    intCollection`）并定义一个操作，这是为每次迭代调用的委托（`integer`）：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'When you have added all the required code, your `Demo` class should look like
    this:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您添加了所有必需的代码后，您的`Demo`类应该如下所示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the console application, create the `List<string>` collection and pass it
    to the two methods created in the `Demo` class. You will notice that we are only
    creating a collection of 500 items. After the code is completed, return the time
    elapsed in seconds and output it to the console window:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建`List<string>`集合并将其传递给`Demo`类中创建的两个方法。您会注意到我们只创建了一个包含500个项目的集合。代码完成后，返回经过的时间（以秒为单位）并将其输出到控制台窗口：
- en: '[PRE29]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Run your application. From the output displayed, you will see the difference
    in performance. The `Parallel.ForEach` loop actually took longer to complete than
    the `foreach` loop:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序。从显示的输出中，您将看到性能上的差异。`Parallel.ForEach`循环实际上花费的时间比`foreach`循环长：
- en: '![](img/B06434_09_13.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_13.png)'
- en: 'Let''s use a different example now. We will create a process-intensive task
    and measure the performance gain that the `Parallel.ForEach` loop will give us.
    Create two methods called `CreateWriteFilesForEach()` and `CreateWriteFilesParallelForEach()`
    that both take the `List<string>` collection as the parameter:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用一个不同的例子。我们将创建一个处理密集型任务，并测量`Parallel.ForEach`循环将为我们带来的性能增益。创建两个名为`CreateWriteFilesForEach()`和`CreateWriteFilesParallelForEach()`的方法，两者都以`List<string>`集合作为参数：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Add the following code to the `CreateWriteFilesForEach()` method. This code
    starts the timer and executes the standard `foreach` loop on the `List<string>`
    object. It then writes the elapsed time out to the console window:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`CreateWriteFilesForEach()`方法中。此代码启动计时器并在`List<string>`对象上执行标准的`foreach`循环。然后将经过的时间写入控制台窗口：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Inside the `foreach` loop, add the code to check whether a file exists with
    the specific name created by appending the `integer` value to the filename portion
    of the `filePath` variable. Create the file (ensuring that you use the `Dispose`
    method so as not to lock the file when trying to write to it) and write some text
    to the newly created file:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foreach`循环内，添加代码来检查是否存在具有将`integer`值附加到`filePath`变量的文件名部分创建的特定名称的文件。创建文件（确保使用`Dispose`方法以避免在尝试写入文件时锁定文件）并向新创建的文件写入一些文本：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, add this code to the `CreateWriteFilesParallelForEach()` method, which
    basically performs the same function as the `CreateWriteFilesForEach()` method,
    but uses a `Parallel.ForEach` loop to create and write files:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将这段代码添加到`CreateWriteFilesParallelForEach()`方法中，该方法基本上执行与`CreateWriteFilesForEach()`方法相同的功能，但使用`Parallel.ForEach`循环来创建和写入文件：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the slightly modified file-creation code inside the `Parallel.ForEach`
    loop:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Parallel.ForEach`循环内添加稍作修改的文件创建代码：
- en: '[PRE34]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you are done, your code needs to look like this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，您的代码应该如下所示：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Head over to the console application, modify the `List<string>` object slightly,
    and increase the count from `500` to `1000`. Then, call the file methods created
    in the `Demo` class:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到控制台应用程序，稍微修改`List<string>`对象，并将计数从`500`增加到`1000`。然后，调用在`Demo`类中创建的文件方法：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Finally, when you are ready, make sure that you have the `C:tempoutput` directory
    and that there aren''t any other files in that directory. Run your application
    and review the output in the console window. This time round, we can see that
    the `Parallel.ForEach` loop has made a huge difference. The performance gain is
    massive and heralds a 47.42 percent performance increase over the standard `foreach`
    loop:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当您准备好时，请确保您有`C:tempoutput`目录，并且该目录中没有其他文件。运行您的应用程序并查看控制台窗口中的输出。这一次，我们可以看到`Parallel.ForEach`循环产生了巨大的差异。性能增益是巨大的，并且比标准的`foreach`循环提高了47.42％的性能：
- en: '![](img/B06434_09_14.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_14.png)'
- en: How it works...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: From the examples used in this recipe, it is clear that use of the parallel
    `foreach` loop should be considered carefully. If you are dealing with relatively
    low volumes of data or non-process intensive transactions, the parallel `foreach`
    loop will not benefit your application's performance much. In some instances,
    the standard `foreach` loop could be much faster than the parallel `foreach` loop.
    If, however, you find your application running into performance issues when processing
    large amounts of data or running processor-intensive tasks, give the parallel
    `foreach` loop a try. It just might surprise you.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从本教程中使用的示例中，很明显使用并行`foreach`循环应该仔细考虑。如果您处理的数据量相对较小或者事务不是处理密集型的，那么并行`foreach`循环不会对应用程序的性能产生太大的好处。在某些情况下，标准的`foreach`循环可能比并行`foreach`循环快得多。但是，如果您发现您的应用程序在处理大量数据或运行处理器密集型任务时遇到性能问题，请尝试使用并行`foreach`循环。它可能会让您感到惊讶。
- en: Cancelling a parallel foreach loop
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行foreach循环
- en: When dealing with parallel `foreach` loops, the obvious question is how one
    would terminate the loop prematurely based on a certain condition, such as a timeout.
    As it turns out, the parallel `foreach` loop is quite easy to terminate prematurely.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理并行`foreach`循环时，一个明显的问题是如何根据某些条件（例如超时）提前终止循环。事实证明，并行`foreach`循环相当容易提前终止。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a method that takes a collection of items and loops through this
    collection in a parallel `foreach` loop. It will also be aware of a timeout value
    that, if exceeded, will terminate the loop and exit the method.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个方法，该方法接受一个项目集合，并在并行`foreach`循环中循环遍历该集合。它还将意识到超时值，如果超过了，将终止循环并退出方法。
- en: How to do it...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start off by creating a new method called `CancelParallelForEach()` in the
    `Demo` class, which takes two parameters. One is a collection of `List<string>`,
    while the other is an integer specifying a timeout value. When the timeout value
    is exceeded, the `Parallel.ForEach` loop must terminate:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Demo`类中创建一个名为`CancelParallelForEach()`的新方法，它接受两个参数。一个是`List<string>`的集合，另一个是指定超时值的整数。当超过超时值时，`Parallel.ForEach`循环必须终止：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Inside the `CancelParallelForEach()` method, add a timer to keep track of the
    elapsed time. This will signal the loop that the timeout threshold has been exceeded
    and that the loop needs to exit. Create a `Parallel.ForEach` method defining a
    state. In each iteration, check the elapsed time against the timeout, and if the
    time is exceeded, break out of the loop:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CancelParallelForEach()`方法内，添加一个计时器来跟踪经过的时间。这将向循环发出信号，超过了超时阈值，循环需要退出。创建一个定义状态的`Parallel.ForEach`方法。在每次迭代中，检查经过的时间是否超过了超时时间，如果超过了，就跳出循环：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the console application, create the `List<string>` object and add `1000`
    items to it. Call the `CancelParallelForEach()` method with a timeout of only
    `5` seconds:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建`List<string>`对象，并向其中添加`1000`个项目。使用超时值为`5`秒调用`CancelParallelForEach()`方法：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Run your console application and review the output results:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并查看输出结果：
- en: '![](img/B06434_09_15.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_15.png)'
- en: How it works...
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: You can see from the console window output that, as soon as the elapsed time
    exceeded the timeout value, the parallel loop was notified to cease the execution
    of iterations beyond the current iteration at the system's earliest convenience.
    Having this kind of control over the `Parallel.ForEach` loop allows developers
    to avoid runaway loops, and gives the user control to cancel a loop operation
    by clicking on a button or automatically having the application terminate when
    the timeout value has been reached.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从控制台窗口输出中看到，一旦经过的时间超过了超时值，就会通知并行循环在系统尽快的时机停止执行当前迭代之后的迭代。对`Parallel.ForEach`循环有这种控制，使开发人员能够避免无限循环，并允许用户通过单击按钮或在超时值达到时自动终止应用程序来取消循环操作。
- en: Catching errors in parallel foreach loops
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获并行foreach循环中的错误
- en: With parallel `foreach` loops, developers can wrap the loop in a `try...catch`
    statement. Care needs to be taken, however, because the `Parallel.ForEach` will
    throw an `AggregatedException`, which has the exceptions it encounters over several
    threads rolled into one.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行`foreach`循环时，开发人员可以将循环包装在`try...catch`语句中。但是需要注意，因为`Parallel.ForEach`会抛出`AggregatedException`，其中包含它在多个线程上遇到的异常。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a `List<string>` object that contains a collection of machine
    IP addresses. The `Parallel.ForEach` loop will check the IP addresses to see whether
    the machines on the other end of the given IPs are alive. It does this by pinging
    the IP address. The method that performs the `Parallel.ForEach` loop will also
    be given the minimum required alive machines as an integer value. If the minimum
    number of machines alive is not met, an exception is thrown.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含一组机器IP地址的`List<string>`对象。`Parallel.ForEach`循环将检查IP地址，看看给定IP的另一端的机器是否在线。它通过对IP地址进行ping来实现这一点。执行`Parallel.ForEach`循环的方法还将获得所需最小在线机器数量作为整数值。如果未达到所需的最小在线机器数量，就会抛出异常。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `Demo` class, add a method called `CheckClientMachinesOnline()`, which
    takes as parameters a `List<string>` collection of IP addresses and an integer
    that specifies the minimum number of machines required to be online. Add a second
    method called `MachineReturnedPing()`, which will receive an IP address to ping.
    For our purpose, we will just return `false` to mimic a dead machine (the ping
    to the IP address timed out):'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中，添加一个名为`CheckClientMachinesOnline()`的方法，它以`List<string>` IP地址集合和指定要在线的最小机器数量的整数作为参数。添加第二个名为`MachineReturnedPing()`的方法，它将接收一个要ping的IP地址。对于我们的目的，我们将返回`false`来模拟一个死机器（对IP地址的ping超时）：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Inside the `CheckClientMachinesOnline()` method, add the `Parallel.ForEach`
    loop and create the `ParallelOptions` variable that will specify the degree of
    parallelism. Wrap all this code inside a `try...catch` statement and catch an `AggregateException`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CheckClientMachinesOnline()`方法内部，添加`Parallel.ForEach`循环，并创建指定并行度的`ParallelOptions`变量。将所有这些代码包装在`try...catch`语句中，并捕获`AggregateException`：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `Parallel.ForEach` loop, write the code to check whether the machine
    is online by calling the `MachineReturnedPing()` method. In our example, this
    method will always return `false`. You will notice that we are keeping track of
    the offline machine count via the `Interlocked.Increment` method. This is just
    a way of incrementing a variable across the threads of the `Parallel.ForEach`
    loop:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Parallel.ForEach`循环内，编写代码来检查机器是否在线，调用`MachineReturnedPing()`方法。在我们的示例中，这个方法总是返回`false`。您会注意到，我们通过`Interlocked.Increment`方法跟踪离线机器的数量。这只是一种在`Parallel.ForEach`循环的线程之间递增变量的方法：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you have added all the code correctly, your `Demo` class will look like
    this:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经正确添加了所有的代码，你的`Demo`类将如下所示：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In the console application, create the `List<string>` object to store a collection
    of dummy IP addresses. Instantiate your `Demo` class and call the `CheckClientMachinesOnline()`
    method, passing the collection of IP addresses and the minimum number of machines
    required to be online to it:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建`List<string>`对象来存储一组虚拟IP地址。实例化您的`Demo`类，并调用`CheckClientMachinesOnline()`方法，将IP地址集合和所需在线机器的最小数量传递给它：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run your application and review the output in the console window:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序并在控制台窗口中查看输出：
- en: '![](img/B06434_09_16.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_16.png)'
- en: Just a point to note. If you have Just My Code enabled, in some cases Visual
    Studio will break on the line that throws the exception. It might also say that
    the exception is not handled by the user code. You can just press *F5* to continue.
    To prevent this from happening, uncheck Enable Just My Code under Tools, Options,
    Debugging, and General.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 只需注意一点。如果启用了Just My Code，在某些情况下，Visual Studio会在引发异常的行上中断。它还可能会说异常未被用户代码处理。您只需按下*F5*继续。要防止这种情况发生，请取消选中Tools，Options，Debugging和General下的Enable
    Just My Code。
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: From the console window output, you can see that the minimum number of machines
    required to be online was not achieved. The application then threw an exception
    and caught it from the `Parallel.ForEach` loop. Being able to handle exceptions
    in parallel loops such as this one is essential for maintaining the stability
    of your application by being able to handle exceptions as they occur.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台窗口输出可以看到，未达到所需在线机器的最小数量。应用程序随后抛出了一个异常，并从`Parallel.ForEach`循环中捕获了它。能够处理这种并行循环中的异常对于通过处理异常来维持应用程序的稳定性至关重要。
- en: I encourage you to play around a little with the `Parallel.ForEach` loop and
    drill into some of the inner methods of the `AggregareException` class to really
    understand it better.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您尝试一下`Parallel.ForEach`循环，并深入研究`AggregareException`类的一些内部方法，以更好地理解它。
- en: Debugging multiple threads
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多个线程
- en: Debugging multiple threads in Visual Studio is tricky, especially since these
    threads are all running at the same time. Luckily, we have a few tools available
    to us as developers to use to get a better understanding of what is happening
    in our multithreaded applications.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试多个线程是棘手的，特别是因为这些线程都在同时运行。幸运的是，作为开发人员，我们有一些可用的工具可以帮助我们更好地了解多线程应用程序中发生的情况。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 做好准备
- en: While debugging multithreaded applications, you can access various windows by
    navigating to Debug | Windows in Visual Studio.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试多线程应用程序时，您可以通过转到Visual Studio中的Debug | Windows来访问各种窗口。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Start debugging your multithreaded application after adding a break point somewhere
    in the code. You can access various debugging windows by going to Debug | Windows
    in Visual Studio:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中的某个地方添加断点后，开始调试您的多线程应用程序。您可以通过转到Visual Studio中的Debug | Windows来访问各种调试窗口：
- en: '![](img/B06434_09_17.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_17.png)'
- en: The first window available to you is the Threads window. Access it by going
    to Debug | Windows in Visual Studio or type *Ctrl* + *D*, *T*. In here, you can
    right-click on a thread to watch and flag it. If you have given your threads names,
    you will see those names appear in the Name column. To give your thread a name,
    modify the `LockThreadExample()` method created in an earlier recipe.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以访问的第一个窗口是线程窗口。通过转到Visual Studio中的Debug | Windows或键入*Ctrl* + *D*，*T*来访问。在这里，您可以右键单击线程以进行监视和标记。如果您已经为线程命名，您将在名称列中看到这些名称。要为线程命名，请修改之前创建的`LockThreadExample()`方法。
- en: '[PRE45]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You will also be able to see the currently active thread in the debugger. It
    will be marked with a yellow arrow. Then, there is the managed ID, which is the
    same ID you will have used to create the unique thread name earlier on.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将能够在调试器中看到当前活动的线程。它将用黄色箭头标记。然后是托管ID，这是您之前用来创建唯一线程名称的相同ID。
- en: The Location column displays the current method that the thread is in. The Threads
    window allows you to view the stack of the thread by double-clicking on the Location
    field. You can also freeze and thaw threads. Freezing stops a thread from executing,
    while thawing allows the frozen thread to continue as normal.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 位置列显示线程当前所在的方法。通过双击位置字段，线程窗口允许您查看线程的堆栈。您还可以冻结和解冻线程。冻结会停止线程执行，而解冻允许冻结的线程继续正常运行。
- en: '![](img/B06434_09_18-2.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_18-2.png)'
- en: 'The Tasks window can be accessed by going to Debug | Windows or by holding
    down *Ctrl* + *Shift* + *D*, *K*. To see this in action, place a break point in
    your `LockThreadExample()` method on the line that reads `Task.WaitAll(thread1,
    thread2, thread3);`. Debug your application again and look at the Status column
    for each thread created. The status of the task shows the status at that moment,
    and we can see that the three threads are Active, Blocked, and Scheduled:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到Debug | Windows或按住*Ctrl* + *Shift* + *D*，*K*来访问Tasks窗口。要查看它的运行情况，请在您的`LockThreadExample()`方法中的一行上放置一个断点，该行读取`Task.WaitAll(thread1,
    thread2, thread3);`。再次调试应用程序，并查看每个线程创建的状态列。任务的状态显示了那一刻的状态，我们可以看到三个线程是Active、Blocked和Scheduled：
- en: '![](img/B06434_09_19.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_19.png)'
- en: 'The Parallel Stacks window can be accessed by going to Debug | Windows in Visual
    Studio or by holding down *Ctrl* + *D* + *S* key. Here, you can see a graphical
    view of the tasks and threads. You can switch between the Threads and Tasks view
    by making a selection in the drop-down list in the upper-left corner of the Parallel
    Stacks window:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到Visual Studio中的Debug | Windows或按住*Ctrl* + *D* + *S*键来访问并行堆栈窗口。在这里，您可以看到任务和线程的图形视图。您可以通过在并行堆栈窗口左上角的下拉列表中进行选择来在线程和任务视图之间切换：
- en: '![](img/B06434_09_20.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_20.png)'
- en: 'Changing the selection to Tasks will show you the current tasks in the debug
    session:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择更改为Tasks将显示调试会话中的当前任务：
- en: '![](img/B06434_09_21.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B06434_09_21.png)'
- en: The next window, undoubtedly my favorite, is the Parallel Watch window. It is
    in fact identical to the standard Watch window in Visual Studio, but this watches
    values across all threads in your application. You can type any valid C# expression
    into Parallel Watch and see the values as they are at that moment in the debug
    session. Try it out by adding several break points and adding expressions into
    the Parallel Watch.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个窗口，毫无疑问是我最喜欢的，就是并行监视窗口。实际上，它与Visual Studio中的标准监视窗口完全相同，但它可以监视应用程序中所有线程的值。您可以在并行监视中输入任何有效的C#表达式，并在调试会话中查看那一刻的值。通过添加几个断点并在并行监视中添加表达式来尝试一下。
- en: How it works...
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Being able to use the debugging tools for multithreaded applications effectively
    in Visual Studio makes it much easier to understand the structure of your application
    and helps you identify possible bugs, bottlenecks, and areas of concern.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 能够有效地在Visual Studio中使用多线程应用程序的调试工具，可以更轻松地理解应用程序的结构，并帮助您识别可能的错误、瓶颈和关注的领域。
- en: I encourage you to learn more about these various debugging windows available
    to you.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你更多地了解可用于调试的各种窗口。
