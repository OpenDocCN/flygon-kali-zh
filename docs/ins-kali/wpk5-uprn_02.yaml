- en: Working with Modules and Code Splitting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块和代码拆分
- en: This chapter will explore modules and code splitting in Webpack 5\. Modules
    are a way of structuring content so that code is sorted in sections by function.
    Code splitting is the method Webpack uses to build these modules automatically;
    it will parcel off code from your project into modules that best suit the functionality
    and structure of the completed project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨Webpack 5中的模块和代码拆分。模块是一种按功能将代码分组的方式。代码拆分是Webpack用来自动构建这些模块的方法；它将项目中的代码分割成最适合完成项目的功能和结构的模块。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Explaining modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释模块
- en: Understanding code splitting
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码拆分
- en: Prefetching and preloading modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预取和预加载模块
- en: Best practices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践
- en: Explaining modules
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释模块
- en: Webpack works with elements called modules. It uses these modules to build a
    dependency graph.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack使用称为模块的元素。它使用这些模块来构建依赖图。
- en: Modules are sections of code that deal with a related function; structuring
    your project according to a modular build will improve functionality. For instance,
    only code related to pertinent actions will need to be run, when compared to the
    need to run whole sections of unrelated code when the project is not built with
    modules.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是处理相关功能的代码部分；根据模块化构建项目将提高功能。例如，与未使用模块构建的项目相比，只有与相关操作相关的代码需要运行。
- en: With that being said, the next thing to understand is the specific function
    of modules, which will be discussed in the following section.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，下一件要理解的事情是模块的具体功能，这将在接下来的部分中讨论。
- en: The function of modules
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块的功能
- en: A module is a set of pieces of code: for example, code of a similar language
    has a common function—that is to say, it is part of the same function or operation within
    an application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是一组代码片段：例如，相似语言的代码具有共同的功能——也就是说，它是应用程序中相同功能或操作的一部分。
- en: 'Often, modules in Webpack 5 are grouped according to the scripting language
    used, as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Webpack 5中的模块根据使用的脚本语言进行分组，如下所示：
- en: '![](img/d145de8d-82c2-403f-a485-52765c3d1801.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d145de8d-82c2-403f-a485-52765c3d1801.jpg)'
- en: The preceding diagram should help illustrate what most people see when exploring
    the contents of a Webpack build.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表应该有助于说明大多数人在探索Webpack构建内容时看到的内容。
- en: An application is then divided into modules and assets. As we explained in [Chapter
    1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml), *Introduction to Webpack 5*, an
    asset is essentially images and videos that are not considered scripted by a developer.
    The directory structure is then subdivided into these modules, usually in a directory
    of their own.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将应用程序分成模块和资产。正如我们在[第1章](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml)中所解释的那样，资产基本上是开发人员不认为是脚本的图像和视频。然后，目录结构通常被细分为这些模块，通常在它们自己的目录中。
- en: Dividing an application into modules will naturally make the process of debugging
    easier. This will also aid us in verification and testing in general.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序分成模块将自然使调试过程更容易。这也将有助于我们进行验证和测试。
- en: Building applications this way ensures that a boundary is made between well-written
    code and more-dubiously written code. Naturally, this helps with directory navigation,
    as each module has a defined purpose.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式构建应用程序可以确保在良好编写的代码和更加可疑的代码之间建立边界。当然，这有助于目录导航，因为每个模块都有一个明确定义的目的。
- en: Many platforms use modules and it is a term that you will no doubt be used to
    if you work in web development in general. However, each platform differs slightly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多平台使用模块，这是一个您在一般的Web开发中肯定会习惯的术语。然而，每个平台略有不同。
- en: 'Webpack 5 forms these modules according to how it expresses the dependencies
    of the module. Here are a few examples of how Webpack 5 expresses them:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5根据模块的依赖关系表达方式来形成这些模块。以下是Webpack 5表达它们的一些示例：
- en: Through a **2015 ECMAScript** `import` statement
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**2015 ECMAScript**的`import`语句
- en: Through a **CommonJS **`require()` statement
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**CommonJS **的`require()`语句
- en: Through an **asynchronous module definition **(**ASM**) `define` and `require`
    statement
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**异步模块定义 **(**ASM**)的`define`和`require`语句
- en: Through an imageURLin a stylesheet
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过样式表中的imageURL
- en: Through an `@import` statement in a stylesheet
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过样式表中的`@import`语句
- en: In summary, modular code makes things a lot easier and understanding how Webpack
    expresses dependencies will help you understand how you should compile your code.
    From here, the natural next step is to look at the supported module types and
    how loaders work with them.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，模块化的代码使事情变得更容易，了解Webpack如何表达依赖关系将帮助您了解应该如何编译代码。从这里开始，自然的下一步是查看支持的模块类型以及加载器如何与它们一起工作。
- en: Supported module languages and loaders
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持的模块语言和加载器
- en: To make sure Webpack 5 supports these modules, they must be written in a programming
    language that can be understood and processed. Webpack 5 does this by using something
    called loaders.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保Webpack 5支持这些模块，它们必须用可以理解和处理的编程语言编写。Webpack 5通过使用称为加载器的东西来实现这一点。
- en: Loaders make Webpack truly stand out over rival bundlers. In simple terms, a
    loader tells Webpack how to process code that is not JavaScript or other predefined
    code that Webpack automatically understands, such as JSON or HTML. Webpack 5 will
    then include this processed code as dependencies in your bundle.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器使Webpack在竞争对手捆绑器中真正脱颖而出。简单来说，加载器告诉Webpack如何处理不是JavaScript或其他Webpack自动理解的预定义代码（如JSON或HTML）的代码。Webpack
    5将会将这些处理过的代码作为依赖项包含在您的捆绑包中。
- en: 'Webpack 5 has a community of developers, referred to as the Webpack community,
    who have built these loaders. These loaders currently support a large number of
    languages and processors; some examples are as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5拥有一个开发者社区，称为Webpack社区，他们构建了这些加载器。这些加载器目前支持大量的语言和处理器；一些例子如下：
- en: '**TypeScript**'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TypeScript**'
- en: '**SASS**'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SASS**'
- en: '**LESS**'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LESS**'
- en: '**C++ **'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C++ **'
- en: '**Babel**'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Babel**'
- en: '**Bootstrap**'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Bootstrap**'
- en: For a full list of available loaders, see the *Further reading* section toward
    the end of this chapter.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有关可用加载器的完整列表，请参阅本章末尾的“进一步阅读”部分。
- en: Being part of the Webpack community means you can write your loaders! This is
    something worth considering as it may be the best way to meet the requirements
    of your project.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 成为Webpack社区的一部分意味着您可以编写自己的加载器！这是值得考虑的事情，因为这可能是满足项目要求的最佳方式。
- en: There are many more loaders available from the Webpack community. The use of
    loaders means Webpack 5 can be described as a dynamic platform that allows the
    customization of just about any technology stack. In this chapter, we will begin
    to use loaders proactively as part of some example use cases that you can practice
    coding yourself.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多更多的加载器可用于Webpack社区。使用加载器意味着Webpack 5可以被描述为一个动态平台，允许定制几乎任何技术堆栈。在本章中，我们将开始积极地使用加载器作为一些示例用例的一部分，您可以练习自己编码。
- en: During your development, you may come across the term **encapsulation**, especially
    when working with modules and loaders.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，您可能会遇到“封装”一词，特别是在处理模块和加载器时。
- en: To understand encapsulation, you first need to understand that software can
    sometimes be developed independently until a requirement for interplay presents
    itself. For software to work together within a project, a dependency must be created
    between the two technology stacks. This is what is meant by the term encapsulation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解封装，您首先需要了解软件有时可以独立开发，直到需要互动才会出现。为了使软件在项目中一起工作，必须在两个技术堆栈之间创建一个依赖关系。这就是“封装”一词的含义。
- en: Encapsulation is a simple topic to outline; however, the next area of modular
    coding concerns resolution. It is a wider subject and has, therefore, been detailed
    as part of its own subsection.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是一个简单的主题，但模块化编码的下一个领域是解析。这是一个更广泛的主题，因此已经作为自己的子部分进行了详细说明。
- en: The enabling of a new asset module type is an experimental feature shipped with
    v5\. The asset module type is similar to the `file-loader`, `url-loader`, or `raw-loader`
    (`experiments.asset` since alpha.19) data URLs and options related to that have
    been supported since beta.8.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 启用新的资产模块类型是v5的一个实验性功能。资产模块类型类似于“file-loader”、“url-loader”或“raw-loader”（自alpha.19以来的“experiments.asset”）数据URL和相关选项自beta.8以来得到支持。
- en: Module resolution
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块解析
- en: Module resolution takes place via the use of a resolver. A resolver assists
    you in locating a module by its absolute path—the path to a module that is universally
    used throughout a project.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 模块解析是通过解析器进行的。解析器帮助您通过其绝对路径找到一个模块——在整个项目中通用的模块路径。
- en: 'Note that a module can act as a dependency of another module, such as the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一个模块可以作为另一个模块的依赖项，例如以下情况：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Regardless of whether the dependency module is from another library (not the
    resolver itself) or the application itself, the resolver will help to find the
    module code required to include in the bundle. Webpack 5 can also use `enhance-resolve`
    to resolve paths while bundling.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 无论依赖模块是来自另一个库（而不是解析器本身）还是应用程序本身，解析器都将帮助找到所需的模块代码以包含在捆绑包中。Webpack 5也可以在捆绑时使用“enhance-resolve”来解析路径。
- en: 'The resolving rules for Webpack 5 mean that, using the `enhanced-resolve` method, Webpack 5 can
    resolve three kinds of file paths:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5的解析规则意味着，使用“enhanced-resolve”方法，Webpack 5可以解析三种文件路径：
- en: Absolute paths
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绝对路径
- en: Relative paths
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对路径
- en: Module paths
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块路径
- en: The following sections will detail the meaning of each file path and there will
    be an example for each. This will become important later as we begin to build
    on our project bundle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将详细说明每个文件路径的含义，并且每个部分都将有一个示例。随着我们开始构建项目捆绑包，这将变得更加重要。
- en: Absolute paths
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绝对路径
- en: 'For the uninitiated, an absolute path refers to the file path and the location
    of a file that is common to all files and assets that your project uses. This
    common location is sometimes called the `home` or `root` directory. Here is a
    command-line location by way of example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于初学者来说，绝对路径是指文件路径和项目使用的所有文件和资产的位置。这个共同的位置有时被称为“home”或“root”目录。以下是一个命令行位置的示例：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding line is an example of an absolute path. The term **absolute**
    is something every JavaScript developer should be familiar with. It relates to
    the location of an object file or directory in a path that is universal throughout
    the system.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前一行是绝对路径的一个示例。术语“绝对”是每个JavaScript开发人员都应该熟悉的内容。它涉及到系统中普遍存在的对象文件或目录的位置。
- en: If we already have the absolute path, as in the preceding line, no further resolution
    is required.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经有了绝对路径，就像前一行一样，就不需要进一步解析了。
- en: Relative paths
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相对路径
- en: 'A relative path refers to the location of an object file or directory to another
    location. In this case, it is the location of the `context` directory—the current
    and working location where development is carried out:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 相对路径是指一个对象文件或目录到另一个位置的位置。在这种情况下，它是“上下文”目录的位置——开发进行的当前工作位置：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, the directory of the resource file is considered the
    `context` directory. The resource file refers to the file that the `import()` statement,
    the `require()` statement, or the call to an external file occurs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，资源文件的目录被认为是“上下文”目录。资源文件是指“import()”语句、“require()”语句或对外部文件的调用发生的文件。
- en: In this case, the relative path is joined to the context directory path, which
    then produces an absolute path.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，相对路径与上下文目录路径相结合，然后产生绝对路径。
- en: Module paths
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块路径
- en: 'A module path is something that not all JavaScript developers may be used to.
    With Webpack, it refers to a location relative to a module. In the following code
    snippet, `module` would be co-opted for the name of any specific module name you
    wish to use—the name of an existing module in your project, for example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模块路径是并非所有JavaScript开发人员都习惯的东西。在Webpack中，它指的是相对于模块的位置。在下面的代码片段中，`module`将被用于你希望使用的任何特定模块名称的名称——例如你项目中现有模块的名称：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Webpack 5 searches all the directories for modules that are specified in the
    `resolve.module` directive. An alias can be created for each original module file
    path using the `resolve.alias` configuration. Using this method, Webpack 5 checks
    the file path and whether it points to a file or directory.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5搜索所有在`resolve.module`指令中指定的模块的目录。可以使用`resolve.alias`配置为每个原始模块文件路径创建别名。使用这种方法，Webpack
    5会检查文件路径以及它指向文件还是目录。
- en: Webpack 5 has an option called `resolve.extension`. If a path does not have
    a file extension, this resolver will indicate to Webpack which extensions can
    be used for resolution. These might include `.js`, `.jsx`, or similar extensions.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5有一个名为`resolve.extension`的选项。如果路径没有文件扩展名，这个解析器将指示Webpack可以用于解析的扩展名。这些可能包括`.js`、`.jsx`或类似的扩展名。
- en: In the event of a file path not pointing to a file but only to a directory,
    Webpack 5 searches the directory for a `package.json` file. Webpack 5 then uses
    the fields specified in the `resove.main` field's configuration to search for
    fields contained in `package.json` and, from this, determines the correct contextual
    file path to use.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件路径不指向文件而只指向目录，Webpack 5会搜索该目录中的`package.json`文件。然后Webpack 5使用`resove.main`字段配置中指定的字段来搜索`package.json`中包含的字段，并从中确定要使用的正确上下文文件路径。
- en: If there is no `package.json` file present in the directory, or if the main
    fields do not return a valid path, Webpack 5 simply searches for filenames specified
    in the `resolve.main` configuration.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录中没有`package.json`文件，或者主字段没有返回有效路径，Webpack 5会简单地搜索`resolve.main`配置中指定的文件名。
- en: File extensions are resolved similarly, but using the `resolve.extension` option.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 文件扩展名的解析方式类似，但使用`resolve.extension`选项。
- en: We have, so far, covered modules, path resolution, supported languages, and
    loaders. The next crucial thing to understand is code splitting—what it is and
    how Webpack utilizes it to form both its modules and general output.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了模块、路径解析、支持的语言和加载程序。下一个重要的理解是代码拆分——它是什么，以及Webpack如何利用它来形成它的模块和一般输出。
- en: Understanding code splitting
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码拆分
- en: Code splitting allows the user to **split code** into various bundles that can
    then be loaded on-demand or in parallel. The developers of Webpack consider this
    "*one of the most compelling features of Webpack*" ([Webpack.js.org](http://webpack.js.org)).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代码拆分允许用户将代码拆分成各种捆绑包，然后按需或并行加载。Webpack的开发人员认为这是Webpack的“最引人注目的功能之一”([Webpack.js.org](http://webpack.js.org))。
- en: Code splitting has two key advantages—the process can be used to achieve smaller
    bundles and to control the priority of resource loading. This can lead to an improvement
    in loading time.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代码拆分有两个关键优势——这个过程可以用来实现更小的捆绑包，并控制资源加载的优先级。这可以导致加载时间的改善。
- en: 'There are three general code-splitting approaches available in Webpack 5:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5中有三种通用的代码拆分方法：
- en: '**Entry points**: This manually splits code using an entry point configuration.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**入口点**：这是使用入口点配置手动拆分代码。'
- en: '**Prevent duplication**: This approach uses `SplitChunksPlugin` to run a process
    called **dedupe**, which splits code into groups of modules called **chunks**.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**防止重复**：这种方法使用`SplitChunksPlugin`来运行一个称为**dedupe**的过程，将代码拆分成称为**chunks**的模块组。'
- en: '**Dynamic imports**: This approach uses inline functions to make **calls**
    to split code within modules.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态导入**：这种方法使用内联函数在模块内部进行**调用**以拆分代码。'
- en: A chunk refers to a group of modules. This is a term used by Webpack and is
    not frequently encountered on other platforms.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个chunk指的是一组模块。这是Webpack使用的一个术语，在其他平台上并不经常遇到。
- en: dedupe is a Python library that uses machine learning to perform matching, **deduplication**,
    and entity resolution quickly. It helps remove duplicate entries from a spreadsheet
    of names and addresses.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: dedupe是一个使用机器学习快速执行匹配、**去重**和实体解析的Python库。它有助于从姓名和地址的电子表格中删除重复条目。
- en: With these three approaches outlined, we can now discuss each one in detail
    in the following sections. Let's begin with entry points.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这三种方法的概述，我们现在可以在接下来的章节中详细讨论每一种方法。让我们从入口点开始。
- en: Entry points
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入口点
- en: Using entry points is probably the easiest way of performing code splitting.
    It is a manual operation and is, therefore, not automated like other methods.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用入口点可能是执行代码拆分的最简单方法。这是一个手动操作，因此不像其他方法那样自动化。
- en: We will now look at the development of splitting one module from the main bundle. To
    do this, we will begin with some practical work. From there, we will go over the
    concepts of duplication and dynamic imports.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看一下从主捆绑包中拆分一个模块的开发。为此，我们将从一些实际工作开始。然后，我们将讨论重复和动态导入的概念。
- en: We will now return to the project we were working on in [Chapter 1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml),
    *Introduction to Webpack 5*. This time, we will utilize what we have learned so
    far in this chapter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将回到我们在[第1章](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml)中工作的项目，*Webpack 5简介*。这一次，我们将利用到目前为止在本章中学到的知识。
- en: First, create a directory to work in. In this case, we are using the directory
    name we used in the last chapter. It might be a good idea to follow this same
    convention and, that way, you will be able to follow the course of the project's
    development as you continue through this book.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个工作目录。在这种情况下，我们使用了上一章中使用的目录名称。遵循相同的约定可能是一个好主意，这样你就可以在继续阅读本书的过程中跟踪项目的发展。
- en: 'In the following example, we will do the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们将做以下操作：
- en: 'Organize a project folder structure to start a project that shows how entry
    points work. You should build this set of directories in your practice project
    directory. This is done in the same way as creating folders on your desktop. For
    the sake of this example, we will call this folder `webpack5-demo` (but you can
    choose any name you want):'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组织一个项目文件夹结构，以开始一个展示入口点如何工作的项目。您应该在练习项目目录中构建这组目录。这与在桌面上创建文件夹的方式相同。为了本示例，我们将称此文件夹为`webpack5-demo`（但您可以选择任何您喜欢的名称）：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Be sure to add the last line of text (in bold), if it is missing from the code
    you are using. This can be done on a command line; if that's what you decide to
    use, please refer to [Chapter 1](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml),
    *Introduction to Webpack 5*, for guidance. You may have noticed the inclusion
    of `another-module.js`. You might not find this a typical build but you will need
    to include this for our example.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您使用的代码缺少最后一行文本（用粗体标记），请确保添加。这可以在命令行上完成；如果您决定使用命令行，请参考[第1章](26d5b9c8-5d08-4cca-b0fb-63d0e715eba0.xhtml)，*Webpack
    5简介*，以获取指导。您可能已经注意到了`another-module.js`的包含。您可能不会认为这是一个典型的构建，但是您需要包含这个示例。
- en: Ultimately, you can name the project anything you like but, for the sake of
    following this practice project, you should use the same naming convention used
    up to now to prevent confusion.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您可以随意命名项目，但是为了遵循此实践项目，您应该使用到目前为止使用的相同命名约定以防混淆。
- en: To follow this project development, using your **integrated development environment**(**IDE**)
    or notepad, you should create each of the preceding files and folders. The `**/**` character
    indicates a folder. Note the `another-module.js` file; this rests in the `/node_modules`
    directory.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟踪此项目的开发，使用您的**集成开发环境**（**IDE**）或记事本，您应该创建前面提到的每个文件和文件夹。`**/**`字符表示一个文件夹。请注意`another-module.js`文件；它位于`/node_modules`目录中。
- en: We will now edit and compile a build, beginning with the `another-module.js`
    file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编辑并编译一个构建，从`another-module.js`文件开始。
- en: 'Open `another-module.js` in your IDE of choice or a notepad:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您选择的IDE或记事本中打开`another-module.js`：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The file essentially imports `lodash`, ensuring the module that is loaded is
    recorded in the console log, setting the Webpack build mode to development, and
    setting entry points that Webpack begins mapping the assets in the application
    for bundling through and sets an output bundle name and location.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件基本上导入了`lodash`，确保加载的模块记录在控制台日志中，将Webpack构建模式设置为开发模式，并设置Webpack开始映射应用程序中的资产进行捆绑的入口点，并设置输出捆绑名称和位置。
- en: 'Now, run a build with `npm` by entering the location of the context directory
    (the one you are developing in) in the command line and type the following:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过在命令行中输入上下文目录的位置（您正在开发的目录）并输入以下内容来使用`npm`运行构建：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is all you need to produce a bundle output or development application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要产生捆绑输出或开发应用程序的全部内容。
- en: 'Then, check for successful compilation. When a build is run in your command
    line, you should see the following message:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，检查是否成功编译。当在命令行中运行构建时，您应该看到以下消息：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Success! However, some potential problems might occur when using entry points
    that a developer should be conscious of:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！但是，在使用开发人员应该注意的入口点时，可能会出现一些潜在问题：
- en: If there are duplicated modules between entry chunks, they will be included
    in both bundles.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果入口块之间存在重复的模块，它们将包含在两个捆绑包中。
- en: For our example, as `lodash` is also imported as part of the `./src/index.js` file
    in the project directory, it will be duplicated in both bundles. This duplication
    can be removed by using `SplitChunksPlugin`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，由于`lodash`也作为`./src/index.js`文件的一部分导入到项目目录中，它将在两个捆绑包中重复。通过使用`SplitChunksPlugin`可以消除此重复。
- en: They can't be used to dynamically split code using the programming logic of
    the application.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不能用于根据应用程序的编程逻辑动态拆分代码。
- en: Now, we will cover preventing duplication.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将介绍如何防止重复。
- en: Preventing duplication with SplitChunksPlugin
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SplitChunksPlugin防止重复
- en: '`SplitChunksPlugin` allows the extraction of common dependencies into entry
    chunks, either existing or new. In the following walk-through, this method will
    be used to deduplicate the `lodash` dependency from the preceding example.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`SplitChunksPlugin`允许将常见依赖项提取到入口块中，无论是现有的还是新的。在以下步骤中，将使用此方法来从前面示例中去重`lodash`依赖项。'
- en: 'The following is a code snippet from the `webpack.config.js` file, found in
    the preceding example''s project directory. This example shows the configuration
    options needed to use the plugin:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从前面示例的项目目录中找到的`webpack.config.js`文件中的代码片段。此示例显示了使用该插件所需的配置选项：
- en: 'We will begin by ensuring that our configuration is coded to the same configuration
    as in the preceding example:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先确保我们的配置与前面示例中的配置相同：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using the `optimization.splitChunks` configuration, the duplicate dependency
    should now be removed from `index.bundle.js` and `another.bundle.js`. `lodash`
    has been separated into a separate chunk and the main bundle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`optimization.splitChunks`配置，重复的依赖项现在应该从`index.bundle.js`和`another.bundle.js`中删除。`lodash`已被分离到一个单独的块和主捆绑包中。
- en: 'Next, perform `npm run build`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，执行`npm run build`：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'There are other community-developed loaders and plugins that can be used to
    split code. Some of the more notable examples are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他由社区开发的加载器和插件可用于拆分代码。一些更值得注意的例子如下：
- en: '`bundle-loader`: Used to split code and lazy-load the resulting bundles'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundle-loader`：用于拆分代码和延迟加载生成的捆绑包'
- en: '`promise-loader`: Similar to `bundle-loader` but uses promises'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`promise-loader`：类似于`bundle-loader`，但使用promises'
- en: '`mini-css-extract-plugin`: Useful for splitting CSS from the main application'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mini-css-extract-plugin`：用于从主应用程序中拆分CSS'
- en: Now, with a firm understanding of how duplication can be prevented, we will
    move on to a more difficult topic—dynamic imports.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过对如何防止重复的理解牢固，我们将转向一个更困难的主题——动态导入。
- en: Dynamic imports
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态导入
- en: Dynamic imports are, essentially, on-demand imports on Webpack. If you have
    already bundled a lot of code but need to patch more to it, the dynamic import
    method will come to the rescue. This also includes dynamic code splitting, which,
    as it sounds, means splitting code and optimizing it after a bundle has been built.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 动态导入本质上是Webpack上的按需导入。如果您已经捆绑了大量代码，但需要对其进行补丁，动态导入方法将会派上用场。这还包括动态代码拆分，即在构建包后拆分代码并优化它。
- en: 'Webpack 5 supports two methods of doing this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Webpack 5支持两种方法来做到这一点：
- en: The first method uses the `import()` syntax, which conforms to the dynamic import
    proposal for ECMAScript.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法使用了`import()`语法，符合ECMAScript的动态导入提案。
- en: The second is the `webpack-specific` approach, which uses the `require.ensure`
    method (this is a legacy method).
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种是**特定于webpack**的方法，使用`require.ensure`方法（这是一种传统方法）。
- en: The following is an example of the first approach; the goal is to demonstrate
    a modern method of using dynamic imports, which will be more common on recent
    projects.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第一种方法的示例；目标是演示使用动态导入的现代方法，这在最近的项目中将更常见。
- en: The `import()` call is an internal call to promises. A **promise** refers to
    the information returned from a loader.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`调用是对承诺的内部调用。**承诺**指的是从加载程序返回的信息。'
- en: When using `import()` with older browsers, use a `polyfill` function—such as `es6-promise` or `promise-polyfill`—to
    **shim promise**. `shim-loader` is a loader that transforms code so that it works
    in the Webpack 5 environment; this works similarly to doing this manually with
    `imports-loader` and `exports-loader`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在与旧版浏览器一起使用`import()`时，使用`polyfill`函数，例如`es6-promise`或`promise-polyfill`，来**模拟承诺**。`shim-loader`是一个在Webpack
    5环境中转换代码以使其工作的加载程序；这与使用`imports-loader`和`exports-loader`手动执行类似。
- en: 'The next step is to remove any surplus entries in the configuration file, which
    includes the `optmization.splitChunks` reference, as it will not be needed in
    the following demonstration:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是删除配置文件中的任何多余条目，其中包括`optmization.splitChunks`的引用，因为在接下来的演示中将不需要它：
- en: 'Now, open the `webpack.config.js` file and make the following entries:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`webpack.config.js`文件并进行以下条目：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note the use of `chunkFilename`, which determines the name of non-entry chunk
    files.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`chunkFilename`的使用，它确定非入口块文件的名称。
- en: The preceding configuration was needed to prepare your project to use dynamic
    imports. Be sure to remove the text in bold as you may see this when working with
    the same code, as before.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的配置是为了准备您的项目使用动态导入。确保删除粗体文本，因为在处理相同代码时可能会看到这些。
- en: Jumping back into the project, we need to update it with instructions to remove
    unused files.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 回到项目中，我们需要更新它以删除未使用的文件的说明。
- en: You may have already set up your practice directory; however, it is recommended
    that you start with a fresh set of directories that doesn't contain any experimental
    code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经设置了练习目录；但是，建议您从不包含任何实验代码的新目录集开始。
- en: The following demonstration will use dynamic importing to separate a chunk,
    instead of the static importing of `lodash`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下演示将使用动态导入来分离一个块，而不是静态导入`lodash`。
- en: 'Open the `index.js` file and ensure the following entries are made:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.js`文件，确保进行以下条目：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When importing a `CommonJS` module, this import will not resolve the value of
    `module.exports`; instead, an artificial namespace object will be created. Therefore,
    we need a default when importing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入`CommonJS`模块时，此导入将不会解析`module.exports`的值；而是将创建一个人工命名空间对象。因此，在导入时我们需要一个默认值。
- en: The use of `webpackChunkName` in the comment will cause our separate bundle
    to be named `lodash.bundle.js`, instead of just `[your id here].bundle.js`. For
    more information on `webpackChunkName` and the other available options, see the
    `import()` documentation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释中使用`webpackChunkName`将导致我们的单独包被命名为`lodash.bundle.js`，而不仅仅是`[your id here].bundle.js`。有关`webpackChunkName`和其他可用选项的更多信息，请参阅`import()`文档。
- en: If Webpack is now run, `lodash` will separate into a new bundle.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在运行Webpack，`lodash`将分离成一个新的包。
- en: '`npm run build` can be run using your **command-line interface** (**CLI**).
    In your CLI utility, type the following:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用**命令行界面**（**CLI**）运行`npm run build`。在CLI实用程序中，键入以下内容：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When a build is run, you should see the following message:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 运行构建时，您应该看到以下消息：
- en: '[PRE13]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`import()` can be used with asynchronous functions as it returns a promise.
    This requires the use of a preprocessor, such as the `syntax-dynamic-import` Babel
    plugin.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`import()`可以与异步函数一起使用，因为它返回一个承诺。这需要使用预处理器，例如`syntax-dynamic-import` Babel插件。'
- en: 'Using `src/index.js`, make the following amendments to show how the code can
    be simplified:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`src/index.js`，进行以下修改以显示代码如何可以简化：
- en: '[PRE14]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding example uses the same file that we used in the *Dynamic imports*
    section. We have turned multi-line code into single lines, replaced a returning
    function with asynchronous code, expediting our coding practice. You will see
    that it is now much simpler than the earlier code—it uses the same file, `src/index.js`,
    and achieves the same thing.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了我们在*动态导入*部分中使用的相同文件。我们将多行代码转换为单行代码，用异步代码替换了返回函数，加快了我们的编码实践。您会发现它现在比以前的代码简单得多——它使用了相同的文件`src/index.js`，并实现了相同的功能。
- en: We often simplify code to help with loading times. Another key way of improving
    browsing speed is caching.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常简化代码以帮助加载时间。改善浏览速度的另一个关键方法是缓存。
- en: Caching
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存
- en: Before we finish this section on code splitting, we will go over caching. Caching
    is related to the previous processes and is no doubt something that will come
    up during programming. For the uninitiated, caching is the method of storing previously
    computed data to allow it to be served faster. It also relates to the following
    section on prefetching and preloading, methods that govern how memory is used.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成代码拆分的这一部分之前，我们将介绍缓存。缓存与之前的过程有关，毫无疑问，在编程过程中会遇到。对于初学者来说，缓存是存储先前计算的数据以便更快地提供的方法。它还与下一节关于预取和预加载有关，这些方法控制内存的使用方式。
- en: 'Learning about caching will ensure you know how to split code more effectively.
    In the following example, we will see how it''s done. In Webpack, caching is done
    by something called **filename hashing** (when a computer traces the location
    of a file recursively) and, specifically, the hashing of the output bundle:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 了解缓存将确保您知道如何更有效地拆分代码。在下一个示例中，我们将看到如何做到这一点。在Webpack中，缓存是通过**文件名哈希**（当计算机递归跟踪文件位置时）完成的，特别是输出包的哈希化：
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note the `output` key handler in the preceding code block; within the parentheses,
    you will see the output  `bundle.js` filename and below that is the inline element
    we refer to as the hash. You should substitute the bracketed terms with your preferences.
    This method produces an alternative output that is only updated when the content
    updates and serves as our cache resource.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面的代码块中的`output`键处理程序；在括号内，您将看到`bundle.js`文件名，下面是我们称之为哈希的内联元素。您应该用您的偏好替换括号内的术语。这种方法产生了一种替代输出，只有在内容更新时才会更新，并作为我们的缓存资源。
- en: Every filesystem access is cached so that multiple parallel or serial requests
    to the same file occur faster. In `watch` mode, only modified files are evicted
    from the cache. If `watch` mode is turned off, then the cache is purged before
    every compilation.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件系统访问都被缓存，以便同一文件的多个并行或串行请求更快。在`watch`模式下，只有修改的文件才会从缓存中删除。如果关闭`watch`模式，则在每次编译之前都会清除缓存。
- en: This leads us to our next section, which also relates to imports—prefetching
    and preloading.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引导我们进入下一节，这也与导入有关——预取和预加载。
- en: Prefetching and preloading modules
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预取和预加载模块
- en: 'Webpack 5 can output a **resource hint** when using inline directives and declaring
    imports. It will give the browser the following commands:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明导入时，Webpack 5可以输出一个**资源提示**。它会给浏览器以下命令：
- en: '`preload` (may be needed during the current navigation)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`preload`（可能在当前导航期间需要）'
- en: '`prefetch` (may be needed for future navigation)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prefetch`（可能在未来的导航中需要）'
- en: The terms "current" and "future" may be confusing, but they essentially refer
    to the fact that `prefetch` loads content before the user needs it, which, in
    a way, loads and queues content ahead of time. This is a simple definition—a full
    explanation will follow—but in general, you can see the advantages and disadvantages
    in terms of memory usage and efficiency of user experience.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: “当前”和“未来”这些术语可能会令人困惑，但它们基本上指的是`prefetch`在用户需要之前加载内容，以某种方式提前加载和排队内容。这是一个简单的定义——接下来会有一个完整的解释——但总的来说，您可以从内存使用和用户体验的效率方面看到优缺点。
- en: One thing to be aware of is that prefetching doesn't work for **Web Assembly** (**WASM**)
    yet in Webpack 5.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，在Webpack 5中，预取对**Web Assembly**（**WASM**）尚不起作用。
- en: This simple `prefetch` example can have a `HomePage` component that renders
    a `LoginButton` component, which, upon being clicked, loads a `LoginModal` component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的`prefetch`示例可以有一个`HomePage`组件，它渲染一个`LoginButton`组件，当被点击时加载一个`LoginModal`组件。
- en: 'The `LoginButton` file will need to be created; follow these instructions in `LoginButton.js`
    to do this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginButton`文件需要被创建；按照`LoginButton.js`中的说明进行操作：'
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code will result in the following code snippet being appended
    to the header of the page:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将导致以下代码片段被附加到页面的头部：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will instruct the browser, when idle, to prefetch the `**login-modal-chunk.js**`
    file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这将指示浏览器在空闲时预取`**login-modal-chunk.js**`文件。
- en: 'The `preload` directive has many differences when compared to `prefetch`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与`prefetch`相比，`preload`指令有很多不同之处：
- en: Chunks using the `preload` directive load in parallel to their parent chunk, whereas
    a prefetched chunk starts after the parent chunk finishes loading.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`preload`指令的块与其父块并行加载，而预取的块在父块加载完成后开始加载。
- en: Chunks must be instantly requested by the parent chunk when preloaded, whereas
    a prefetched chunk can be used at any time.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预加载时，块必须由父块立即请求，而预取的块可以随时使用。
- en: Chunks using the `preload` directive are instantly downloaded when called. A
    prefetched chunk is downloaded while the browser is idle.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`preload`指令的块在调用时立即下载。在浏览器空闲时下载预取的块。
- en: Simple `preload` directives can have components that always depend on libraries
    that should be in a separate chunk.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的`preload`指令可以有组件，它们总是依赖应该在单独块中的库。
- en: The choice of whether to use `preload` or `prefetch` depends largely on context;
    you will discover more on how that might apply to you as the tutorial progresses.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`preload`或`prefetch`的选择在很大程度上取决于上下文；随着教程的进行，您将发现这可能如何适用于您。
- en: You should use `prefetch` or `preload`, depending on how the preceding points
    best suit your development needs. This largely depends on the complexity of the
    project and, ultimately, is a judgment call made by the developers.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的要点，您应该根据您的开发需求选择使用`prefetch`或`preload`。这在很大程度上取决于项目的复杂性，最终是开发人员做出的判断。
- en: 'The following example suggests an imagined component, `ChartComponent`, in `ChartComponent.js`,which
    requires a library that we will call `ChartingLibrary`. It instantly imports the
    library on demand and displays `LoadingIndicator` when rendered:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例提出了一个想象的组件`ChartComponent`，在`ChartComponent.js`中需要一个我们称之为`ChartingLibrary`的库。它会在需要时立即导入库，并在渲染时显示`LoadingIndicator`：
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When `ChartComponent` is requested, `charting-library-chunk` is also requested
    through `<link rel="preload">`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求`ChartComponent`时，也会通过`<link rel="preload">`请求`charting-library-chunk`。
- en: Assuming `page-chunk` finishes loading faster, the page will be displayed with
    `LoadingIndicator` until `charting-library-chunk` finishes loading. This will
    give a loading time improvement since it only needs one round process instead
    of two. This is especially true in high-latency environments (where delays often
    occur in data processing networks).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`page-chunk`加载完成得更快，页面将显示为`LoadingIndicator`，直到`charting-library-chunk`加载完成。这将提高加载时间，因为它只需要一个循环处理而不是两个。这在高延迟环境中尤其如此（在这些环境中，数据处理网络经常发生延迟）。
- en: Using `webpackPreload` incorrectly can harm the performance, so be mindful when
    using it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`webpackPreload`不正确可能会损害性能，因此在使用时要注意。
- en: One feature added with version 5 that is useful and related to fetching is the
    top-level await, a feature that enables modules to act as big async functions.
    That means they will be processed as code asynchronously. With top-level await,
    **ECMAScript Modules** (**ESMs**) can await resources, causing other modules that
    import them to wait before they start evaluating the body.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 版本5中添加的一个功能是有用的，并与获取相关，即顶级等待，这是一个使模块可以作为大型异步函数的功能。这意味着它们将被异步处理。使用顶级等待，**ECMAScript模块**（**ESM**）可以等待资源，导致导入它们的其他模块在开始评估主体之前等待。
- en: You should now understand the purposes of `prefetch` and `preload` and how their
    usage affects performance if done incorrectly. A decision on their use will depend
    largely on how you wish your application to perform. The best approach is to make
    your decision on their use after conducting a formal bundle analysis, which we
    will discuss in the next section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该了解了`prefetch`和`preload`的目的，以及如果使用不正确会如何影响性能。关于它们的使用决定将在很大程度上取决于您希望应用程序的性能如何。最好的方法是在进行正式捆绑包分析后再决定它们的使用，我们将在下一节中讨论。
- en: Best practices
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: As with all programming, there are best practices that ensure the most optimum
    delivery. This is also an excellent way to conclude this chapter. If best practices
    are followed, a developer can protect their application from security breaches
    and hacking, poor performance, and difficulties when working collaboratively in
    a team, or when future development is needed by new developers, future-proofing
    the build. This latter reason speaks to the product owner or project manager more
    than a development team.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有编程一样，有最佳实践可以确保最佳交付。这也是结束本章的一个很好的方式。如果遵循最佳实践，开发人员可以保护他们的应用程序免受安全漏洞和黑客攻击、性能不佳以及在团队协作或未来开发需要新开发人员时出现困难，从而使构建具有未来性。这后一点更适用于产品所有者或项目经理，而不是开发团队。
- en: When it comes to Webpack, the foremost areas of salience here would be bundle
    analysis and code linting.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在Webpack方面，这里最重要的领域将是捆绑包分析和代码清理。
- en: Bundle analysis
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捆绑包分析
- en: 'Once you start splitting code, it can be useful to analyze the output and check
    where modules have ended up. It''s important to get the most out of bundling,
    so a formal procedure for bundle analysis can be considered as fundamental, as
    well as browser and security testing. The official analyze tool is recommended.
    There are also some other options:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦开始拆分代码，分析输出并检查模块的最终位置将是有用的。充分利用捆绑包非常重要，因此捆绑包分析的正式程序可以被视为基本的，以及浏览器和安全性测试。建议使用官方分析工具。还有一些其他选项：
- en: '`webpack-bundle-analyzer`: This is a plugin and CLI utility that represents
    bundle content as a convenient interactive **treemap**, where zooming options
    are available.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-bundle-analyzer`：这是一个插件和CLI实用程序，它将捆绑包内容表示为方便的交互式**树状图**，其中有缩放选项。'
- en: '`webpack-bundle-optimize-helper`: This tool will analyze your bundle and give
    suggestions to reduce your bundle size.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-bundle-optimize-helper`：这个工具将分析您的捆绑包，并提出减小捆绑包大小的建议。'
- en: '`webpack-visualizer`: This is used to visually analyze bundles to see which
    modules are taking up too much space and which might be duplicated.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-visualizer`：这用于可视化分析捆绑包，以查看哪些模块占用了太多空间，哪些可能是重复的。'
- en: '`webpack-chart`: This offers an interactive pie chart used for Webpack stats.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webpack-chart`：这提供了一个用于Webpack统计的交互式饼图。'
- en: Treemapping is a method used to display hierarchical data using nested figures,
    usually rectangles.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图是一种用于使用嵌套图形（通常是矩形）显示分层数据的方法。
- en: All the previously mentioned tools will help with optimization, which is the
    primary purpose of Webpack.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 所有先前提到的工具都将有助于优化，这是Webpack的主要目的。
- en: Code linting
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码清理
- en: Another way that the application can be improved is through the removal of unwanted
    code. When automated, this is often called tree shaking, which we will discuss
    in later chapters. When this is done manually, it is referred to as code linting.
    A definition is probably in order as it is a phrase that is not often encountered
    in programming.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种改进应用程序的方法是通过删除不需要的代码。当自动化时，这通常被称为树摇，我们将在后面的章节中讨论。当手动进行时，它被称为代码清理。由于这是一个在编程中不经常遇到的短语，可能需要给出一个定义。
- en: Code linting is the process of removing unwanted or surplus code, just like
    removing lint from a blazer. This could include unused coding artifacts, erroneous
    code, or anything else that's unwanted. Webpack uses an automated process to do
    this when integrating with task runners such as **Gulp**. This is discussed in
    the following chapter, [Chapter 6](c8eb858d-110e-459c-aaa9-c6b8f48aef50.xhtml), *Production,
    Integrations, and Federated Modules*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 代码清理是删除不需要或多余代码的过程，就像从一件西装上除去绒毛一样。这可能包括未使用的编码工件、错误的代码或其他任何不需要的东西。Webpack在与**Gulp**等任务运行器集成时使用自动化过程来执行此操作。这将在下一章[第6章](c8eb858d-110e-459c-aaa9-c6b8f48aef50.xhtml)中讨论，*生产、集成和联合模块*。
- en: If you follow these procedures, then there can be little doubt that your application
    will perform at its very best. Code splitting and modular programming are central
    to Webpack and a firm understanding is required to prevent you from getting lost
    as the complexity of bundling projects advances through this guide.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循这些步骤，那么毫无疑问，您的应用程序将发挥出最佳性能。代码拆分和模块化编程对于 Webpack 来说至关重要，需要牢固的理解，以防止在捆绑项目的复杂性不断提高时迷失方向。
- en: Summary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter has followed the demonstration of various code-splitting practices,
    including code chunks and dynamic imports. You will now have a sound base of knowledge
    to carry out code splitting and use modules. These are fundamental features of
    Webpack, so a solid grounding is necessary.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 本章已经介绍了各种代码拆分实践，包括代码块和动态导入。现在，您将拥有扎实的知识基础，可以进行代码拆分和使用模块。这些是 Webpack 的基本特性，因此需要扎实的基础知识。
- en: Code splitting and modules are a matter of structural necessity for Webpack
    applications. Code chunks and dynamic imports will be more important on specialist
    tasks that require heavy-duty programming.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 代码拆分和模块是 Webpack 应用程序结构上的必要性。对于需要大量编程的专业任务来说，代码块和动态导入将更加重要。
- en: You were taken through prefetching modules and bundle analysis—important procedures
    that are needed to clearly understand the following chapter, where we will look
    at the world of configuration, understanding its limitations and capabilities
    as well as where options play their part.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了预取模块和捆绑分析——这些是需要清楚理解下一章内容的重要步骤，我们将在下一章中探讨配置的世界，了解其限制和能力，以及选项在其中发挥作用。
- en: These concepts are important as configuration is central to Webpack development
    and a matter of day-to-day programming. Options become more important when it
    comes to production and you need your project to operate correctly.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 随着配置在 Webpack 开发中的中心地位和日常编程的重要性，这些概念变得更加重要。当涉及到生产环境并且需要项目正常运行时，选项变得更加重要。
- en: To test your skills, try the following quiz and see whether your understanding
    of the topics covered in this chapter is up to scratch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试您的技能，请尝试以下测验，看看您对本章涵盖的主题的理解是否达到标准。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'We will conclude this chapter with a set of questions to test your knowledge.
    The answers to these questions can be found in the back of this book, in the *Assessment*
    section:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一组问题来结束本章，以测试您的知识。这些问题的答案可以在本书的后面，*评估* 部分找到。
- en: What is the difference between code splitting and modular programming?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码拆分和模块化编程有何不同？
- en: What is a code chunk?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是代码块？
- en: How do dynamic imports differ from entry points?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动态导入与入口点有何不同？
- en: How are `preload` directives preferable to `prefetch` directives?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`preload` 指令与 `prefetch` 指令有何优势？'
- en: What is meant by code linting?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码清理是什么意思？
- en: What is meant by the term promise?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 术语“promise”是什么意思？
- en: How does `SplitChunksPlugin` prevent duplication?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SplitChunksPlugin` 如何防止重复？'
- en: What does the `webpack-bundle-optimize-helper` tool offer?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`webpack-bundle-optimize-helper` 工具提供了什么？'
- en: What does the `webpack-chart` plugin do?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`webpack-chart` 插件的作用是什么？'
- en: What is treemapping?
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是树状映射？
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For a full list of loaders, go to [https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的加载器列表，请转到 [https://github.com/webpack-contrib/awesome-webpack](https://github.com/webpack-contrib/awesome-webpack)。
