["```php\nvar example = 5;\nfunction test() {\n\u00a0\u00a0var testVariable = 10;\n\u00a0\u00a0console.log( example ); // Expect output: 5\n\u00a0\u00a0console.log( testVariable ); // Expect output: 10\n}\ntest();\nconsole.log( testVariable ); // Expect reference error\n```", "```php\nexample = 5; // Assign value\nconsole.log( example ); // Expect output: 5\nvar example; // Declare variable\n```", "```php\n// Top level scope\nfunction scopeExample() {\n\u00a0\u00a0// Scope block 1\n\u00a0\u00a0for ( let i = 0; i < 10; i++ ){ /* Scope block 2 */ }\n\u00a0\u00a0if ( true ) { /* Scope block 3 */ } else {  /* Scope block 4 */ }\n\u00a0\u00a0// Braces without keywords create scope blocks\n\u00a0\u00a0{ /* Scope block 5 */ } \n\u00a0\u00a0// Scope block 1\n}\n// Top level scope\n```", "```php\n// console.log( example ); // Would throw ReferenceError\nlet example;\nconsole.log( example ); // Expected output: undefined\nexample = 5;\nconsole.log( example ); // Expected output: 5\n```", "```php\nfunction fn1(){\n\u00a0console.log('Scope 1');\n\u00a0let scope = 5;\n\u00a0console.log(scope);\n\u00a0{\n\u00a0\u00a0\u00a0console.log('Scope 2');\n\u00a0\u00a0\u00a0let scope = 'different scope';\n\u00a0\u00a0\u00a0console.log(scope);\n\u00a0}\n\u00a0\u00a0{\n\u00a0\u00a0\u00a0console.log('Scope 3');\n\u00a0\u00a0\u00a0let scope = 'a third scope';\n\u00a0\u00a0\u00a0console.log(scope);\n\u00a0}\n}\nfn1();\n```", "```php\n// Referenced before declaration\nconsole.log( example ); // Expect output: undefined\nvar example = 'example';\n```", "```php\n// Declared and assigned\nvar example = { prop1: 'test' };\nconsole.log( 'example:', example );\n// Expect output: example: {prop1: \"test\"}\n// Value reassigned\nexample = 5;\nconsole.log( example ); // Expect output: 5\n```", "```php\n// Declared and initialized\nlet example = { prop1: 'test' };\nconsole.log( 'example:', example );\n// Expect output: example: {prop1: 'test\"}\n// Value reassigned\nexample = 5;\nconsole.log( example ); // Expect output: 5\n```", "```php\n// Referenced before declaration\nconsole.log( example );\n// Expect ReferenceError because example is not defined\nlet example = 'example';\n```", "```php\n// Referenced before declaration\nconsole.log( example );\n// Expect ReferenceError because example is not defined\nconst example = 'example';\n```", "```php\n// Declared and initialized\nconst example = { prop1: 'test' };\n// Variable reassigned\nexample = 5;\n// Expect TypeError error because variable was declared with const\n// Object property updated\nexample.prop1 = 5;\n// Expect no error because subproperty was modified\n```", "```php\nvar hoisted = 'this got hoisted';\ntry{\n console.log(notHoisted1);\n} catch(err){}\nlet notHoisted1 = 5;\ntry{\n console.log(notHoisted2);\n} catch(err){}\nconst notHoisted2 = [1,2,3];\ntry{\n notHoisted2 = 'new value';\n} catch(err){}\nnotHoisted2.push(5);\n```", "```php\n( arg1, arg2, ..., argn ) => { /* Do function stuff here */ }\n```", "```php\nconst fn1 = function( a, b ) { return a + b; };\nconst fn2 = ( a, b ) => { return a + b; };\nconsole.log( fn1( 3 ,5 ), fn2( 3, 5 ) );\n```", "```php\n// Single argument arrow function\narg1 => { /* Do function stuff here */ }\n// Non simple identifier function argument\n( arg1 = 10 ) => { /* Do function stuff here */ }\n```", "```php\n// No arguments passed into the function\n( ) => { /* Do function stuff here */ }\n```", "```php\n// Multiple line body arrow function\n( arg1, arg2 ) => { \n\u00a0\u00a0console.log( `This is arg1: ${arg1}` );\n\u00a0\u00a0console.log( `This is arg2: ${arg2}` );\n\u00a0\u00a0/* Many more lines of code can go here */\n}\n// Single line body arrow function\n( arg1, arg2 ) => console.log( `This is arg1: ${arg1}` )\n```", "```php\n// With return keyword - not necessary\n( num1, num2 ) => { return ( num1 + num2 ) }\n// If called with arguments num1 = 5 and num2 = 5, expected output is 10\n// Without return keyword or braces\n( num1, num2 ) => num1 + num2\n// If called with arguments num1 = 5 and num2 = 5, expected output is 10\n```", "```php\n// Arrow function with a single line body\n// Assume numArray is an array of numbers\n( numArray ) => numArray.filter( n => n > 5).map( n => n - 1 ).every( n => n < 10 )\n// Arrow function with a single line body broken into multiple lines\n// Assume numArray is an array of numbers\n( numArray ) => (\n\u00a0\u00a0numArray.filter( n => n > 5)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.map( n => n - 1 )\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0.every( n => n < 10 )\n) \n```", "```php\n// Arrow function with an object literal in the body\n( num1, num2 ) => ( { prop1: num1, prop2: num2 } ) // Returns an object\n```", "```php\nlet fn1 = ( a, b ) => { \u2026 };\nlet fn2 = ( a, b ) => a * b;\nlet fn3 = a => { \u2026 };\nlet fn4 = () => { \u2026 };\nlet fn5 = ( a ) => ( \u2026  );\n```", "```php`) instead of the usual single or double quotes. Template literals allow you to embed expressions in the string that are evaluated at runtime. Thus, we can easily create dynamic strings from variables and variable expressions. These expressions are denoted with the dollar sign and curly braces (`${ expression }`). The template literal syntax is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.22: Template literal basic syntax\n\nTemplate literals are escaped like other strings in JavaScript. To escape a template literal, simply use a backslash (`\\`) character. For example, the following equalities evaluate to true: ``\\`` === \"`\",`\\t` === \"\\t\"`, and ``\\n\\r` === \"\\n\\r\".`\n\nTemplate literals allow for multiline strings. Any newline characters that are inserted into the source are part of the template literal and will result in a line break in the output. In simpler terms, inside a template literal, we can press the **Enter** key on the keyboard and split it on to two lines. This newline character in the source code will be parsed as part of the template literal and will result in a newline in the output. To replicate this with normal strings, we would have to use the `\\n` character to generate a new line. With template literals, we can break the line in the template literal source and achieve the same expected output. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.23: Template literal multi-line syntax\n\n### Exercise 5: Converting to Template Literals\n\nTo convert standard string objects to template literals to demonstrate the power of template literal expressions, perform the following steps:\n\n1.  Create two variables, `a` and `b`, and save numbers into them.\n2.  Log the sum of `a` and `b` in the format `a + b` is equal to `<result>` using normal strings.\n3.  Log the sum of `a` and `b` in the format `a + b` is equal to `<result>` using a single template literal.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.24: Template literal and string comparison\n\n[https://bit.ly/2RD5jbC](https://bit.ly/2RD5jbC)\n\n**Outcome**\n\n![Figure 1.7: Logging the sum of the variable's output\n](image/Figure_1.7.jpg)\n\n###### Figure 1.7: Logging the sum of the variable's output\n\nYou have successfully converted standard string objects to template literals.\n\nTemplate literals allow for expression nesting, that is, new template literals can be put inside the expression of a template literal. Since the nested template literal is part of the expression, it will be parsed as a new template literal and will not interfere with the external template literal. In some cases, nesting a template literal is the easiest and most readable way to create a string. An example of template literal nesting is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.25: Template literal nesting\n\nA more advanced form of template literals are **tagged template literals**. Tagged template literals can be parsed with a special function called **tag functions**, and can return a manipulated string or any other value. The first input argument of a tag function is an array containing string values. The string values represent the parts of the input string, broken at each template expression. The remaining arguments are the values of the template expressions in the string. Tag functions are not called like normal functions. To call a tag function, we omit the parentheses and any whitespace around the template literal argument. This syntax is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.26: Tagged template literal example\n\nA special property named `raw` is available for the first argument of a tagged template. This property returns an array that contains the raw, unescaped, versions of each part of the split template literal. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.27: Tagged template raw property\n\nIn summary, template literals allow for the simplification of complicated string expressions. Template literals allow you to embed variables and complicated expressions into strings. Template literals can even be nested into the expression fields of other template literals. If a template literal is broken into multiple lines in the source code, the interpreter will interpret that as a new line in the string and insert one accordingly. Template literals also provide a new way to parse and manipulate strings with the tagged template function. These functions give you a way to perform complex string manipulation via a special function. The tagged template functions also give access to the raw strings as they were entered, ignoring any escape sequences.\n\n### Exercise 6: Template Literal Conversion\n\nYou are building a website for a real estate company. You must build a function that takes in an object with property information and returns a formatted string that states the property owner, where the property is located (`address`), and how much they are selling it for (`price`). Consider the following object as input:\n\n```", "```php\n\n###### Snippet 1.28: Object Input\n\nTo utilize a template literal to pretty-print an object, perform the following steps:\n\n1.  Create a function called `parseHouse` that takes in an object.\n2.  Return a template literal from the function. Using expressions, embed the owner, address, and price in the format `<Owner> is selling the property at <address> for <price>`.\n3.  Create a variable called `house` and save the following object into it: `{ address: \"123 Main St, San Francisco CA, USA\", floors: 2, price: 5000000, owner: \"John Doe\" }`\n4.  Call the `parseHouse` function and pass in the `house` variable.\n5.  Log the output.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.29: Template literal using expressions\n\n[https://bit.ly/2RklKKH](https://bit.ly/2RklKKH)\n\n**Outcome**\n\n![Figure 1.8: Template literal output\n](image/Figure_1.8.jpg)\n\n###### Figure 1.8: Template literal output\n\nYou have successfully utilized a template literal to pretty-print an object.\n\nIn this section, we covered template literals. Template literals upgrade strings by allowing us to nest expressions inside them that are parsed at runtime. Expressions are inserted with the following syntax: ``${ expression }``. We then showed you how to escape special characters in template literals and discussed how in-editor newline characters in template literals are parsed as newline characters in the output. Finally, we covered template literal tagging and tagging functions, which allow us to perform more complex template literal parsing and creation.\n\n## Enhanced Object Properties\n\nECMAScript 6 added several enhancements to object literals as part of the **ES6 syntactic sugar**. ES6 added three ways to simplify the creation of object literals. These simplifications include a more concise syntax for initializing object properties from variables, a more concise syntax for defining function methods, and computed object property names.\n\n#### Note\n\nSyntactic sugar is a syntax that is designed to make expressions easier to read\u00a0and express. It makes the syntax \"sweeter\" because code can be expressed concisely.\n\n### Object Properties\n\nThe shorthand for initializing object properties allows you to make more concise objects. In ES5, we needed to define the object properties with a key name and a\u00a0value, as shown in the following code:\n\n```", "```php\n\n###### Snippet 1.30: ES5 object properties\n\nNotice the repetition in the object literal returned by the function. We name the property in the object after variable name causing duplication (`<code>name: name</code>`). In ES6, we can shorthand each property and remove the repetition. In ES6, we can simply state the variable in the object literal declaration and it will create a property with a key that matches the variable name and a value that matches the variable value. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.31: ES6 object properties\n\nAs you can see, both the ES5 and ES6 examples output the exact same object. However, in a large object literal declaration, we can save a lot of space and repetition by using this new shorthand.\n\n### Function Declarations\n\nES6 also added a shorthand for declaring function methods inside objects. In ES5, we had to state the property name, then define it as a function. This is shown in the following example:\n\n```", "```php\n\n###### Snippet 1.32: ES5 function properties\n\nIn ES6, we can define a function but with much less work. As with the property declaration, we don't need a key and value pair to create the function. The function name becomes the key name. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.33: ES6 function properties\n\nNotice the difference in the function declaration. We omit the function keyword and the colon after the property key name. Once again, this saves us a bit of space and simplifies things a little.\n\n### Computed Properties\n\nES6 also added a new, efficient way to create property names from variables. This is through computed property notation. As we already know, in ES5, there is only one way to create a dynamic property whose name is specified by a variable; this is through bracket notation, that is, `: obj[ expression ] = 'value'` . In ES6, we can use this same type of notation during the object literal's declaration. This is shown in the following example:\n\n```", "```php\n\n###### Snippet 1.34: ES6 Computed property\n\nAs we can see from the preceding snippet, the property name of `varName` was computed to be `firstName`. When accessing the property, we simply reference it as `person.firstName`. When creating computed properties in object literals, the value that's computed in the brackets does not need to be a variable; it can be almost any expression, even a function. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.35: Computed property from function\n\nIn the example shown in the preceding snippet, we created two variables. The first contains the string `first` and the second contains a function that returns a string. We then created an object and used computed property notation to create dynamic object key names. The first key name is equal to `firstName`. When `person.firstName` is accessed, the value that was saved will be returned. The second key name is equal\u00a0to `lastName`. When `person.lastName` is accessed, the value that was saved will\u00a0be returned.\n\nIn summary, ES6 added three ways to simplify the declaration of object literals, that is, property notation, function notation, and computed properties. To simplify property creation in objects, when properties are created from variables, we can omit the key name and the colon. The name property that's created is set to the variable name and the value is set to the value of the variable. To add a function as a property to an object, we can omit the colon and function keyword. The name of the property that's created is set to the function name and the value of the property is the function itself. Finally, we can create property names from computed expressions during the declaration of the object literal. We simply replace the key name with the expression in brackets. These three simplifications can save us space\u00a0in our code and make object literal creation easier to read.\n\n### Exercise 7: Implementing Enhanced Object Properties\n\nYou are building a simple JavaScript math package to publish to **Node Package Manager (NPM)**. Your module will export an object that contains several constants and functions. Using ES6 syntax, create the export object with the following functions and values: the value of pi, the ratio to convert inches to feet, a function that sums two arguments, and a function that subtracts two arguments. Log the object after it has been created.\n\nTo create objects using ES6 enhanced object properties and demonstrate the simplified syntax, perform the following steps:\n\n1.  Create an object and save it into the `exportObject` variable.\n2.  Create a variable called `PI` that contains the value of pi (3.1415).\n3.  Create a variable called `INCHES_TO_FEET` and save the value of the inches to feet conversion ratio (0.083333).\n\n    Using ES6 enhanced property notation, add a property called `PI` from the variable PI. Add a property called `INCHES_TO_FEET` from the `INCHES_TO_FEET` variable, which contains the inches to feet conversion ratio.\n\n    Add a function property called `sum` that takes in two input arguments and returns the sum of the two input arguments.\n\n    Add a function property called `subtract` that takes in two input arguments and returns the subtraction of the two input arguments.\n\n4.  Log the object `exportObject`.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.36: Enhanced object properties\n\n[https://bit.ly/2RLdHWk](https://bit.ly/2RLdHWk)\n\n**Outcome**\n\n![Figure 1.9: Enhanced object properties output\n](image/Figure_1.9.jpg)\n\n###### Figure 1.9: Enhanced object properties output\n\nYou have successfully created objects using ES6 enhanced object properties.\n\nIn this section, we showed you enhanced object properties, a syntactic sugar to help condense object property creation into fewer characters. We covered the shorthand for initializing object properties from variables and functions, and we covered the advanced features of computed object properties, that is, a way to create an object property name from a computed value, inline, while defining the object.\n\n## Destructuring Assignment\n\n**Destructuring assignment** is syntax in JavaScript that allows you to unpack values from arrays or properties from objects, and save them into variables. It is a very handy feature because we can extract data directly from arrays and objects to save into variables, all on a single line of code. It is powerful because it enables us to extract multiple array elements or object properties in the same expression.\n\n### Array Destructuring\n\n**Array destructuring** allows us to extract multiple array elements and save them into variables. In ES5, we do this by defining each variable with its array value, one variable at a time. This makes the code lengthy and increases the time required to write it.\n\nIn ES6, to destructure an array, we simply create an array containing the variable to assign data into, and set it equal to the data array being destructured. The values in the array are unpacked and assigned to the variables in the left-hand side array from left to right, one variable per array value. An example of basic array destructuring is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.37: Basic array destructuring\n\nAs can be seen in this example, we have an array of names and we want to destructure it into two variables, `name1` and `name2`. We simply surround the variables `name1` and `name2` with brackets and set that expression equal to the data array names, and then JavaScript will destructure the `names` array, saving data into each of the variables.\n\nThe data is destructured from the input array into the variables from left to right, in the order of array items. The first index variable will always be assigned the first index array item. This leads to the question, what do we do if we have more array items than variables? If there are more array items than variables, then the remaining array items will be discarded and will not be destructured into variables. The destructuring is a one to one mapping in array order.\n\nWhat about if there are more variables than array items? If we attempt to destructure an array into an array that contains more variables than the total number of array elements in the data array, some of the variables will be set to undefined. The array is destructured from left to right. Accessing a non-existent element in a JavaScript array results in an undefined value to be returned. This undefined value is saved to the leftover variables in the variable array. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.38: Array destructuring with mismatched variable and array items\n\n#### Note\n\nWe must be careful when destructuring arrays to make sure that we don't unintentionally assume that a variable will contain a value. The value of the variable could be set to undefined if the array is not long enough.\n\nES6 array destructuring allows for skipping array elements. If we have an array of values and we only care about the first and third values, we can still destructure the array. To ignore a value, simply omit the variable identifier for that array index in the left-hand side of the expression. This syntax can be used to ignore a single item, multiple items, or even all the items in an array. Two examples of this are shown in the following snippet:\n\n```", "```php\n\n###### Snippet 1.39: Array destructuring with skipped values\n\nAnother very useful feature of array destructuring is the ability to set default values for variables that are created with destructuring. When we want to add a default value, we simply need to set the variable equal to the desired default value in the left-hand side of the destructuring expression. If what we are destructuring does not contain an index to assign to the variable, then the default value will be used instead. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.40: Array destructuring with skipped values\n\nFinally, array destructuring can be used to easily swap values of variables. If we wish to swap the value of two variables, we can simply destructure an array into the reversed array. We can create an array containing the variables we want to reverse and set it equal to the same array, but with the variable order changed. This will cause the references to be swapped. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.41: Array destructuring with skipped values\n\n### Exercise 8: Array Destructuring\n\nTo extract values from an array using array destructuring assignment, perform the following steps:\n\n1.  Create an array with three values, `1`, `2`, and `3`, and save it into a variable called\u00a0`data`.\n2.  Destructure the array created with a single expression.\n\n    Destructure the first array value into a variable called `a`. Skip the second value of the array.\n\n    Destructure the third value into a variable called `b`. Attempt to destructure a fourth value into a variable called `c` and provide a default value of `4`.\n\n3.  Log the value of all of the variables.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.42: Array destructuring\n\n[https://bit.ly/2D2Hm5g](https://bit.ly/2D2Hm5g)\n\n**Outcome**\n\n![Figure 1.10: Destructured variable's output\n](image/Figure_1.51.jpg)\n\n###### Figure 1.10: Destructured variable's output\n\nYou have successfully applied an array destructuring assignment to extract values from an array.\n\nIn summary, array destructuring allows us to quickly extract values from arrays and save them into variables. Variables are assigned to array values, item by item, from left to right. If the number of variables exceeds the number of array items, then the variables are set to undefined, or the default value if specified. We can skip an array index in the destructuring by leaving a hole in the variables array. Finally, we can use destructuring assignment to quickly swap the values of two or more variables in a single line of code.\n\n### Rest and Spread Operators\n\nES6 also introduces two new operators for arrays called **rest**and **spread**. The rest and spread operators are both denoted with three ellipses or periods before an identifier ( `...array1` ). The rest operator is used to represent an infinite number of arguments as an array. The spread operator is used to allow an iterable object to be expanded into multiple arguments. To identify which is being used, we must look at the item that the argument is being applied to. If the operator is applied to an iterable object (array, object, and so on), then it is the spread operator. If the operator is applied to function arguments, then it is the rest operator.\n\n#### Note\n\nIn JavaScript, something considered iterable if something (generally values or key/value pairs) can be stepped through one at a time. For example, an array is iterable because the items in the array can be stepped through one at a time. Objects are considered iterable because the key/value pairs can be stepped through one at a time.\n\nThe **rest operator** is used to represent an indefinite number of arguments as an array. When the last parameter of a function is prefixed with the three ellipses, it becomes an array. The array elements are supplied by the actual arguments that are passed into the function, excluding the arguments that already have been given a separate name in the formal declaration of the function. An example of rest destructuring is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.43: Array destructuring with skipped values\n\nSimilar to the **arguments object** of a JavaScript function, the rest operator contains a list of function arguments. However, the rest operator has three distinct differences from the arguments object. As we already know, the arguments object is an array-like object that contains each argument that's passed into the function. The differences are as follows. First, the rest operator contains only the input parameters that have not been given a separate formal declaration in the function expression.\n\nSecond, the arguments object is not an instance of an **Array** object. The rest parameter is an instance of an array, which means that array functions like `sort()`, `map()`, and `forEach()` can be applied to them directly.\n\nLastly, the arguments object has special functionality that the rest parameter does not have. For example, the caller property exists on the arguments object.\n\nThe rest parameter can be destructured similar to how we destructure an array. Instead of putting a single variable name inside before the ellipses, we can replace it with an array of variables we want to fill. The arguments passed into the function will be destructured as expected for an array. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.44: Destructured rest operator\n\nThe spread operator allows an iterable object such as an array or string to be expanded into multiple arguments (for function calls), array elements (for array literals), or key-value pairs (for object expressions). This essentially means that we can expand an array into arguments for creating another array, object, or calling a\u00a0function. An example of spread syntax is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.45: Spread operator\n\nIn the preceding example, we created a simple function that takes in three inputs and logs them to the console. We created an array with three values, then called the function using the `spread` operator to destructure the array of values into three input parameters for the function.\n\nThe rest operator can be used in destructuring objects and arrays. When destructuring an array, if we have more array elements than variables, we can use the rest operator to capture, or catch, all of the additional array elements during destructuring. When using the rest operator, it must be the last parameter in the array destructuring or function arguments list. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.46: Spread operator\n\nIn the preceding snippet, we destructured the first three array elements into three variables, `n1`, `n2`, and `n3`. We then captured the remaining array elements with the rest operator and destructured them into the variable that remained.\n\nIn summary, the rest and spread operators allow iterable entities to be expanded into many arguments. They are denoted with three ellipses before the identifier name. This allows us to capture arrays of arguments in functions or unused items when destructuring entities. When we use the rest and spread operators, they must be the last arguments that are passed into the expression they are being used in.\n\n### Object Destructuring\n\n**Object destructuring** is used in a very similar way to array destructuring. Object destructuring is used to extract data from an object and assign the values to new variables. In ES6, we can do this in a single JavaScript expression. To destructure an object, we surround the variables we want to destructure with curly braces (`{}`), and set that expression equal to the object we are destructuring. A basic example of object destructuring is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.47: Object destructuring\n\nIn the preceding example, we created an object with the keys `firstName` and `lastName`. We then destructured this object into the variables `firstName` and `lastName`. Notice that the names of the variables and the object parameters match. This is shown in the following example:\n\n#### Note\n\nWhen doing basic object destructuring, the name of the parameter in the object and the name of the variable we are assigning it to must match. If there is no matching parameter for a variable we are trying to destructure, then the variable will be set to undefined.\n\n```", "```php\n\n###### Snippet 1.48: Object destructuring with no defined key\n\nAs we saw, the `middleName` key does not exist in the object. When we try to destructure the key and save it into the variable, it is unable to find a value and the variable is set to undefined.\n\nWith advanced object destructuring syntax, we can save the key that's extracted into a variable with a different name. This is done by adding a colon and the new variable name after the key name in the destructuring notation. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.49: Object destructuring into new variable\n\nIn the preceding example, we could clearly see that we are destructuring the `firstname` key from the object and saving it into the new variable, called first. The\u00a0`lastName` key is being destructured normally and is saved into a variable called\u00a0`lastName`.\n\nMuch like with array destructuring, we can destructure an object and provide a default value. If a default value is provided and the key we are attempting to destructure does not exist in the object, then the variable will be set to the default value instead of undefined. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.50: Object destructuring with default values\n\nIn the preceding example, we set the default values for both of the variables we are trying to destructure from the object. The default value for `firstName` is specified, but the `firstName` key exists in the object. This means that the value stored in the `firstName` key is destructured and the default value is ignored. The `middleName` key does not exist in the object and we have specified a default value to use when destructuring. Instead of using the undefined value of the `firstName` key, the destructuring assignment sets the destructured variable to the default value of `Chris`.\n\nWhen we are providing a default value and assigning the key to a new variable name, we must put the default value assignment after the new variable name. This is shown in the following example:\n\n```", "```php\n\n###### Snippet 1.51: Object destructuring into new variables with default values\n\nThe `firstName` key exists. The value of `obj.firstName` is saved into the new variable named `first`. The `middleName` key does not exist. This means that the new variable middle is created and set to the default value of `Chris`.\n\n### Exercise 9: Object Destructuring\n\nTo extract data from an object by using object destructuring concepts, perform the following steps:\n\n1.  Create an object with the fields `f1`, `f2`, and `f3`. Set the values to `v1`, `v2`, and `v3`, respectively. Save the object into the `data` variable.\n2.  Destructure this object into variables with a single statement, as follows:\n\n    Destructure the `f1` property into a variable named `f1.` Destructure the `f2` property into a variable named `field2.` Destructure the property `f4` into a variable named `f4` and provide a default value of `v4`.\n\n3.  Log the variables that are created.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.52: Object destructuring\n\n[https://bit.ly/2SJUba9](https://bit.ly/2SJUba9)\n\n**Outcome**\n\n![Figure 1.11: Created variable's output\n](image/Figure_1.11.jpg)\n\n###### Figure 1.11: Created variable's output\n\nYou have successfully applied object destructuring concepts to extract data from an\u00a0object.\n\nJavaScript requires special syntax if we declare the variables before the object destructuring expression. We must surround the entire object destructuring expression with parentheses. This syntax is not required for array destructuring. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.53: Object destructuring into predefined variables\n\n#### Note\n\nMake sure that object destructuring done in this way is preceded by a semicolon on the same or previous line. This prevents the JavaScript interpreter from interpreting the parentheses as a function call.\n\nThe **rest operator** can also be used to destructure objects. Since object keys are iterable, we can use the rest operator to catch the remaining keys that were uncaught in the original destructuring expression. This is done similar to arrays. We destructure the keys that we want to capture, and then we can add the rest operator to a variable and catch the remaining key/value pairs that have not been destructured out of the object. This is shown in the following example:\n\n```", "```php\n\n###### Snippet 1.54: Object destructuring with the rest operator\n\nIn summary, object destructuring allows us to quickly extract values from objects and save them into variables. The key name must match the variable name in simple object destructuring, however we can use more advanced syntax to save the key's value into a new object. If a key is not defined in the object, then the variable will be set to `false`, that is, unless we provide it with a default value. We can save this into predefined variables, but we must surround the destructuring expression with parentheses. Finally, the rest operator can be used to capture the remaining key value pairs and save them in a new object.\n\nObject and array destructuring support nesting. Nesting destructuring can be a little confusing, but it is a powerful tool because it allows us to condense several lines of destructuring code into a single line.\n\n### Exercise 10: Nested Destructuring\n\nTo destructure values from an array that's nested inside an object using the concept of nested destructuring, perform the following steps:\n\n1.  Create an object with a property, `arr`, that is, set to an array containing the values `1`, `2`, and `3`. Save the object into the `data` variable.\n2.  Destructure the second value of the array into a variable by doing the\u00a0following:\n\n    Destructure the `arr` property from the object and save it into a new variable called `v2`, which is the array. Replace `v2` with array destructuring.\n\n    In the array destructuring, skip the first element. Save the second element into a variable called `v2`.\n\n3.  Log the variable.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.55: Nested array and object destructuring\n\n[https://bit.ly/2SJUba9](https://bit.ly/2SJUba9)\n\n**Outcome**\n\n![Figure 1.12: Nested destructuring output\n](image/Figure_1.12.jpg)\n\n###### Figure 1.12: Nested destructuring output\n\nYou have successfully destructured values from an array inside an object.\n\nIn summary, object and array destructuring was introduced into ES6 to cut down code and allow for the quick creation of variables from objects and arrays. Array destructuring is denoted by setting an array of variables equal to an array of items. Object destructuring is denoted by setting an object of variables equal to an object of key value pairs. Destructuring statements can be nested for even greater effect.\n\n### Exercise 11: Implementing Destructuring\n\nYou have registered for university courses and need to buy the texts required for the classes. You are building a program to scrape data from the book list and obtain the ISBN numbers for each text book that's required. Use object and array nested destructuring to obtain the ISBN value of the first text of the first book in the courses array. The courses array follows the following format:\n\n```", "```php\n\n###### Snippet 1.56: Course array format\n\nTo obtain data from complicated array and object nesting by using nested destructuring, perform the following steps:\n\n1.  Save the provided data structure into the `courseCatalogMetadata` variable.\n2.  Destructure the first array element into a variable called `course`:\n\n    ```", "```php\n\n3.  Replace the `course` variable with object destructuring to save the texts field into a variable called `textbooks`:\n\n    ```", "```php\n\n4.  Replace the `textbooks` variable with array destructuring to get the first element of the texts array and save it into the variable called `textbook`:\n\n    ```", "```php\n\n5.  Replace the `textbook` variable with object destructuring to get the `ISBN` field and save it into the `ISBN` variable:\n\n    ```", "```php\n\n6.  Log the value of the `ISBN`.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.57: Implementing destructuring into code\n\n[https://bit.ly/2TMlgtz](https://bit.ly/2TMlgtz)\n\n**Outcome**\n\n![Figure 1.13: Array destructuring output\n](image/Figure_1.13.jpg)\n\n###### Figure 1.13: Array destructuring output\n\nYou have successfully obtained data from arrays and objects using destructuring and nested destructuring.\n\nIn this section, we discussed destructuring assignment for arrays and objects. We demonstrated how array and object destructuring simplifies code and allows us to quickly extract values from objects and arrays. Destructuring assignment allows us to unpack values from objects and arrays, provide default values, and rename object properties as variables when destructuring. We also introduced two new operators\u2014 the rest and spread operators. The rest operator was used to represent an indefinite number of arguments as an array. The spread operator was used to break an iterable object into multiple arguments.\n\n## Classes and Modules\n\nClasses and Modules were added to ES6\\. Classes were introduced as a way to expand on prototype-based inheritance by adding some object oriented concepts. Modules were introduced as a way to organize multiple code files in JavaScript and expand on code reusability and scoping among files.\n\n### Classes\n\n**Classes** were added to ECMAScript 6 primarily as syntactic sugar to expand on the existing prototype-based inheritance structure. Class syntax does not introduce object oriented inheritance to JavaScript. Class inheritance in JavaScript do not work like classes in object oriented languages.\n\nIn JavaScript, a class can be defined with the keyword class. A class is created by calling the keyword class, followed by the class name and curly braces. Inside the curly braces, we define all of the functions and logic for the class. The syntax is as\u00a0follows:\n\n```", "```php\n\n###### Snippet 1.58: Class syntax\n\nA class can be created with the **optional function constructor**. The constructor, if not necessary for a JavaScript class, but there can only be one method with the name constructor in a class. The constructor is called when an instance of the class in initialized and can be used to set up all of the default internal values. An example of a class declaration is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.59: Basic class creation\n\nIn the example, we create a class called `House`. Our `House` class has a `constructor` method. When we instantiate the class, it calls the constructor. Our `constructor` method takes in three parameters, two of them with default values. The constructor saves these values to variables in the `this` scope.\n\nThe keyword this is mapped to each class instantiation. It is a global scope class object. It is used to scope all functions and variables globally inside a class. Every function that is added at the root of the class will be added to the `this` scope. All the variables that is added to the `this` scope will be accessible inside any function inside the class. Additionally, anything added to the `this` scope is accessible publicly outside of the class.\n\n### Exercise 12: Creating Your Own Class\n\nTo create a simple class and demonstrate internal class variables, perform the following steps:\n\n1.  Declare a class called `Vehicle`.\n2.  Add a constructor function to the class. Have the constructor take in two variables, `wheels` and `topSpeed`.\n3.  In the constructor, save the input variables to two variables in the `this` scope, that is, `this.wheels` and `this.topSpeed`.\n4.  Instantiate the class with `wheels = 3` and `topSpeed = 20` and save it into the `tricycle` variable.\n5.  Log the value for wheels and `topSpeed` from the class that was saved in `tricycle`.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.60: Creating a class\n\n[https://bit.ly/2FrpL8X](https://bit.ly/2FrpL8X)\n\n**Outcome**\n\n![Figure 1.14: Creating classes output\n](image/Figure_1.14.jpg)\n\n###### Figure 1.14: Creating classes output\n\nYou have successfully created a simple class with values.\n\nWe instantiated a new instance of a class with the new keyword. To create a new class, simply declare a variable and set it equal to the expression `new className()`. When we instantiate a new class, the parameters that are passed into the class call are passed into the constructor function, if one exists. An example of a class instantiation is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.61: Class instantiation\n\nIn this example, the class instantiation happens on the line with the new keyword. This line of code creates a new instance of the `House` class and saves it into the `myHouse` variable. When we instantiate the class, we are providing the parameters for `address`, `floors`, and `garage`. These value are passed into the constructor and then saved into the instantiated class object.\n\nTo add functions to a class, we declare them with the new ES6 object function declaration. As a quick reminder, when using the new ES6 object function declaration, we can omit the function keyword and object key name. When a function is added to an object, it is automatically attached to the `this` scope. Additionally, all functions that are added to the class have access to the `this` scope and will be able to call any function and access any variable attached to the `this` scope. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.62: Creating a class with functions\n\nAs we can see from this example, the two functions `getFloors` and `setFloors` were added with the new ES6 enhanced object property syntax for function declarations. Both functions have access to the `this` scope. They can get and set variables in that scope, as well as call functions that have been attached to the `this` scope.\n\nIn ES6, we can also create subclasses using the `extends` keyword. **Subclasses** inherit properties and methods from the parent class. A subclass is defined by following the class name with the keyword `extends` and the name of the parent class. An example of a subclass declaration is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.63: Extending a class\n\n### Classes \u2013 Subclasses\n\nIn this example, we will create a class called `House`, and then we will create a subclass called `Mansion` that extends the class `House`. When we create a subclass, we need to take note of the behavior of the constructor method. If we provide a constructor method, then we must call the `super()` function. `super` is a function that calls the constructor of the parent object. If we try to access the `this` scope without a call to call `super`, then we will get a runtime error and our code will crash. Any parameters that are required by the parent constructor can be passed in through the `super` method. If we do not specify a constructor for the subclass, the default constructor behavior will automatically call the super constructor. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.64: Extending a class with and without a constructor\n\nIn this example, we created a subclass that extended our `House` class. The `Mansion` subclass has a defined constructor, so we must call super before we can access the `this` scope. When we call `super`, we pass the address parameter to the parent constructor, which adds it to the `this` scope. The constructor for `Mansion` then continues execution and adds the floors variable to the `this` scope. As we can see from the output logging at the end of this example, the subclass's `this` scope also includes all variables and functions that were created in the parent class. If a variable or function is redefined in the subclass, it will overwrite the inherited value or function from the parent class.\n\nIn summary, classes allow us to expand on the prototype-based inheritance of JavaScript by introducing some object oriented concepts. Classes are defined with the keyword `class` and initialized with the keyword `new`. When a class is defined, a special scope called `this` is created for it. All items in the `this` scope are publicly accessible outside the class. We can add functions and variables to the `this` scope to give our class functionality. When a class is instantiated, the constructor is called. We can also extend classes to create subclasses with the `extends` keyword. If an extended class has a constructor, we must call the super function to call its parent-class constructor. Subclasses have access to the parent class methods and variables.\n\n### Modules\n\nAlmost every coding language has a concept of modules. **Modules** are features that allow the programmer to break code into smaller independent parts that can be imported and reused. Modules are critical for the design of programs and are used to prevent code duplication and reduce file size. Modules did not exist in vanilla JavaScript until ES6\\. Moreover, not all JavaScript interpreters support this feature.\n\nModules are a way to reference other code files from the current file. Code can be broken into multiple parts, called **modules**. Modules allow us to keep unrelated code separate so that we can have smaller and simpler files in our large JavaScript projects.\n\nModules also allow the contained code to be quickly and easily shared without any code duplication. Modules in ES6 introduced two new keywords, `export` and `import`. These keywords allow us to make certain classes and variables publicly available when a file is loaded.\n\n#### Note\n\nJavaScript modules do not have full support across all platforms. At the time of writing this book, not all JavaScript frameworks could support modules. Make sure that the platforms you are releasing your code on can support the code you have written.\n\n### Export Keyword\n\nModules use the `export` keyword to expose variables and functions contained in the\u00a0file. Everything inside an ES6 module is private by default. The only way to make anything public is to use the export keyword. Modules can export properties in two ways, via **named exports** or **default exports**. Named exports allow for multiple exports per module. Multiple exports may be useful if you are building a math module that exports many functions and constants. Default exports allow for just a single export\u00a0per model. A single export may be useful if you are building a module that contains a\u00a0single class.\n\nThere are two ways to expose the named contents of a module with the `export` keyword. We can export each item individually by preceding the variable or function declaration with the `export` keyword, or we can export an object containing the key value pairs that reference each variable and function we want exported. These two export methods are shown in the following example:\n\n```", "```php\n\n###### Snippet 1.65: Named Exports\n\nBoth of the modules outlined in the preceding example export three constant variables and one function. The first module, `math-module-1.js`, exports each item, one at a time. The second module, `math-module-2.js`, exports all of the exports at once via an object.\n\nTo export the contents of a module as a default export, we must use the **default** **keyword**. The `default` keyword comes after the `export` keyword. When we default export a module, we can also omit the identifier name of the class, function, or variable we are exporting. An example of this is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.66: Default exports\n\nIn the preceding example, we created two modules. One exports a class and the other exports a function. Notice how we include the `default` keyword after the `export` keyword, and how we omit the name of the class/function. When we export a default class, the `export` is not named. When we are importing default export modules, the name of the object we are importing is derived via the module's name. This will be shown in the next section, where we will talk about the `import` keyword.\n\n### Import Keyword\n\nThe `import` keyword allows you to import a JavaScript module. Importing a module allows you to pull any items from that module into the current code file. When we import a module, we start the expression with the `import` keyword. Then, we identify what parts of the module we are going to import. Then, we follow that with the `from` keyword, and finally we finish with the path to the module file. The `from` keyword and file path tell the interpreter where to find the module we are importing.\n\n#### Note\n\nES6 modules may not have full support from all browsers versions or versions of Node.js. You may have to make use of a transpiler such as Babel to run your code on certain platforms.\n\nThere are four ways we can use the `import` keyword, all of which are shown in the following code:\n\n```", "```php\n\n###### Snippet 1.67: Different ways to import a module\n\nIn the code shown in preceding snippet, we have created a simple module that exports a few constants and four import example files. In the first `import` example, we are importing a single value from the module exports and making it accessible in the variable API. In the second `import` example, we are importing multiple properties from the module. In the third example, we are importing properties and renaming them to new variable names. The properties can then be accessed from the new variables. In the fourth example, we are using a slightly different syntax. The asterisk signifies that we want to import all exported properties from the module. When we use the asterisk, we must also use the `as` keyword to give the imported object a\u00a0variable name.\n\nThe process of importing and using modules is better explained through the following snippet:\n\n```", "```php\n\n###### Snippet 1.68: Importing a module\n\nTo use an import in the browser, we must use the `script` tag. The module import can be done inline or via a source file. To import a module, we need to create a `script` tag and set the type property to `module`. If we are importing via a source file, we must set the `src` property to the file path. This is shown in the following syntax:\n\n```", "```php\n\n###### Snippet 1.69: Browser import inline\n\n#### Note\n\nThe script tag is an HTML tag that allows us to run JavaScript code in the browser.\n\nWe can also import modules inline. To do this, we must omit the `src` property and code the import directly in the body of the script tag. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.70: Browser import in script body\n\n#### Note\n\nWhen importing modules in browsers, browser versions that do not support ES6 modules will not run scripts with type=\"module\".\n\nIf the browser does not support ES6 modules, we can provide a fallback option with the `nomodule` attribute. Module compatible browsers will ignore script tags with the `nomodule` attribute so that we can use it to provide fallback support. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.71: Browser import with compatibility option\n\nIn the preceding example, if the browser supports modules, then the first script tag will be run and the second will not. If the browser does not support modules, then the first script tag will be ignored, and the second will be run.\n\nOne final consideration for modules: be careful that any modules you build do not have circular dependencies. Because of the load order of modules, circular dependencies in JavaScript can cause lots of logic errors when ES6 is transpiled to ES5\\. If there is a circular dependency in your modules, you should restructure your dependency tree so that all dependencies are linear. For example, consider the dependency chain: Module A depends on B, module B depends on C, and module C depends on A. This is a circular module chain because through the dependency chain, A depends on C, which depends on A. The code should be restructured so that the circular dependency chain is broken.\n\n### Exercise 13: Implementing Classes\n\nYou have been hired by a car sales company to design their sales website. You must create a vehicle class to store car information. The class must take in the car make, model, year, and color. The car should have a method to change the color. To test the class, create an instance that is a grey (color) 2005 (year) Subaru (make) Outback (model). Log the car's variables, change the car's color, and log the new color.\n\nTo build a functional class to demonstrate the capabilities of a class, perform the following steps:\n\n1.  Create a `car` class.\n\n    Add a constructor that takes in the `make`, `model`, `year`, and `color`. Save the `make`, `model`, `year`, and `color` in internal variables (`this` scope) in the constructor function.\n\n    Add a function called `setColor` that takes in a single parameter, color, and updates the internal variable `color` to the provided color.\n\n2.  Instantiate the class with the parameters `Subaru`, `Outback`, `2005`, and `Grey`. Save the class into the `Subaru` variable.\n3.  Log the internal variables, that is, `make`, `model`, `year`, and `color`, of the class stored in `Subaru.`\n4.  Change the color with the `setColor` of the class stored in `Subaru` class method. Set the color to `Red`.\n5.  Log the new color.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.72: Full class implementation\n\n[https://bit.ly/2FmaVRS](https://bit.ly/2FmaVRS)\n\n**Outcome**\n\n![Figure 1.15: Implementing classes output\n](image/Figure_1.15.jpg)\n\n###### Figure 1.15: Implementing classes output\n\nYou have successfully built a functional class.\n\nIn this section, we introduced JavaScript classes and ES6 modules. We discussed the prototype-based inheritance structure and demonstrated the basics of class creation and JavaScript class inheritance. When discussing modules, we first showed how to create a module and export the functions and variables stored within them. Then, we showed you how to load a module and import the data contained within. We ended this topic by discussing browser compatibility and providing HTML script tag options for supporting browsers that do not yet support ES6 modules.\n\n## Transpilation\n\n**Transpilation** is defined as source-to-source compilation. Tools have been written to do this and they are called transpilers. **Transpilers** take the source code and convert it into another language. Transpilers are important for two reasons. First, not every browser supports every new syntax in ES6, and second, many developers use programming languages based off of JavaScript, such as CoffeeScript or TypeScript.\n\n#### Note\n\nThe ES6 compatibility table can be found at [https://kangax.github.io/compat-table/es6/](https://kangax.github.io/compat-table/es6/).\n\nLooking at the ES6 browser compatibility table clearly shows us that there are some holes in support. A transpiler allows us to write our code in ES6 and translate it into vanilla ES5, which works in every browser. It is critical to ensure that our code works on as many web platforms as possible. Transpilers can be an invaluable tool for ensuring compatibility.\n\nTranspilers also allow us to develop web or server side applications in other programming languages. Languages such as TypeScript and CoffeeScript may not run natively in the browser; however, with a transpiler, we are able to build a full application in these languages and translate them into JavaScript for server or browser execution.\n\nOne of the most popular transpilers for JavaScript is **Babel**. Babel is a tool that was created to aid in the transpilation between different versions of JavaScript. Babel can be installed through the node package manager (npm). First, open your terminal and path to the folder containing your JavaScript project.\n\nIf there is no `package.json` file in this directory, we must create it. This can be done with the `npm init` command. The command-line interface will ask you for several entries so that you can fill out the defaults of the `package.json` file. You can enter the values or simply press the return key and accept the default values.\n\nTo install the Babel command-line interface, use the following command: `npm install --save-dev babel-cli`. After that has concluded, the `babel-cli` field will have been added to the `devDependencies` object in the `package.json` file:\n\n```", "```php\n\n###### Snippet 1.73: Adding the first dependency\n\nThis command only installed the base Babel with no plugins for transpiling between versions of JavaScript. To install the plugin to transpile to ECMAScript 2015, use the `npm install --save-dev babel-preset-es2015` command. Once the command finishes running, our `package.json` file will contain another dependency:\n\n```", "```php\n\n###### Snippet 1.74: Adding the second dependency\n\nThis installs the ES6 presets. To use these presets, we must tell Babel to configure itself with these presets. Create a file called `.babelrc`. Note the leading period in the name. The `.babelrc` file is Babel's configuration file. This is where we tell Babel what presets, plugins, and so on, we are going to use. Once created, add the following contents to the file:\n\n```", "```php\n\n###### Snippet 1.75: Installing the ES6 presets\n\n### Babel- Transpiling\n\nNow that Babel has been configured, we must create the code file to transpile. In the root folder of your project, create a file called `app.js`. In this file, paste the following ES6 code:\n\n```", "```php\n\n###### Snippet 1.76: Pasting the code\n\nNow that Babel has been configured and we have a file that we wish to transpile, we need to update our `package.json` file to add a transpile script for npm. Add the following lines to your `package.json` file:\n\n```", "```php\n\n###### Snippet 1.77: Update the package.json file\n\nThe scripts object allows us to run these commands from npm. We are going to name the npm script `transpile` and it will run the command chain `babel app.js --out-file app.transpiled.js --source-maps`. `App.js` is our input file. The `--out-file` command specifies the output file for compilation. `App.transpiled.js` is our output file. Lastly, `--source-maps` creates a source map file. This file tells the browser which line of transpiled code corresponds to which lines of the original source. This allows us to debug directly in the original source file, that is, `app.js`.\n\nNow that we have everything set up, we can run our transpile script by typing `npm run transpile` into the terminal window. This will transpile our code from `app.js` into `app.transpiled.js`, creating or updating the file as needed. Upon examination, we can see that the code in `app.transpiled.js` has been converted into ES5 format. You can run the code in both files and see that the output is the same.\n\nBabel has many plugins and presets for different modules and JavaScript releases. There are enough ways to set up and run Babel that we could write an entire book about it. This was just a small preview for converting ES6 code to ES5\\. For full documentation and information on Babel and the uses of each plugin, visit the documentation.\n\n#### Note\n\nTake a look at Babel's home page at [https://babeljs.io](https://babeljs.io).\n\nIn summary, transpilers allow you to do source to source compiling. This is very useful because it allows us to compile ES6 code to ES5 when we need to deploy on a platform that does not yet support ES6\\. The most popular and most powerful JavaScript transpiler is Babel. Babel can be set up on the command line to allow us to build entire projects in different versions of JavaScript.\n\n### Exercise 14: Transpiling ES6 Code\n\nYour office team has written your website code in ES6, but some devices that users are using do not support ES6\\. This means that you must either rewrite your entire code base in ES5 or use a transpiler to convert it to ES5\\. Take the ES6 code written in the *Upgrading Arrow Functions* section and transpile it into ES5 with Babel. Run the original and transpiled code and compare the output.\n\nTo demonstrate Babel's ability to transpile code from ES6 to ES5, perform the following steps:\n\nEnsure that Node.js\u00a0is already installed before you start.\n\n1.  Install Node.js if it is not already installed.\n2.  Set up a Node.js project with the command line command `npm init`.\n3.  Put the code from the *Upgrading Arrow Functions* section into the `app.js` file.\n4.  Install Babel and the Babel ES6 plugin with `npm install`.\n5.  Configure Babel by adding a `.babelrc` file with the es2015 preset.\n6.  Add a transpile script to `package.json` that calls Babel and transpiles from `app.js` to `app.transpiled.js`.\n7.  Run the transpile script.\n8.  Run the code in `app.transpiled.js`.\n\n**Code**\n\n##### package.json:\n\n```", "```php\n\n###### Snippet 1.78: Package.json config file\n\n[https://bit.ly/2FsjzgD](https://bit.ly/2FsjzgD)\n\n##### .babelrc:\n\n```", "```php\n\n###### Snippet 1.79: Babel config file\n\n[https://bit.ly/2RMYWSW](https://bit.ly/2RMYWSW)\n\n##### app.transpiled.js:\n\n```", "```php\n\n###### Snippet 1.80: Fully transpiled code\n\n[https://bit.ly/2TLhuR7](https://bit.ly/2TLhuR7)\n\n**Outcome**\n\n![Figure 1.16: Transpiled script output\n](image/Figure_1.16.jpg)\n\n###### Figure 1.16: Transpiled script output\n\nYou have successfully implemented Babel's ability to transpile code from ES6 to ES5.\n\nIn this section, we discussed the concept of transpilation. We introduced the transpiler Babel and walked through how to install Babel. We discussed the basic steps to set up Babel to transpile ES6 into ES5 compatible code and, in the activity, built a simple Node.js project with ES6 code to test Babel.\n\n## Iterators and Generators\n\nIn their simplest forms, **iterators** and **generators** are two ways to process a collection of data incrementally. They gain efficiency over loops by keeping track of the state of the collection instead of all of the items in the collection.\n\n### Iterators\n\nAn **iterator** is a way to traverse through data in a collection. To iterate over a data structure means to step through each of its elements in order. For example, the `for/in` loop is a method that's used to iterate over the keys in a JavaScript object. An object is an iterator when it knows how to access its items from a collection one at a time, while tracking position and finality. An iterator can be used to traverse custom complicated data structure or for traversing chunks of large data that may not be practical to load all at once.\n\nTo create an iterator, we must define a function that takes a collection in as the parameter and returns an object. The return object must have a function property called next. When next is called, the iterator steps to the next value in the collection and returns an object with the value and the done status of the iteration. An example iterator is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.81: Iterator declaration\n\nThis iterator takes in an array and returns an object with the single function property next. Internally, the iterator keeps track of the array and the index we are currently looking at. To use the iterator, we simply call the next function. Calling next will cause the iterator to return an object and increment the internal index by one. The object returned by the iterator must have, at a minimum, the properties value and done. Value will contain the value at the index we are currently viewing. `Done` will contain a Boolean. If the Boolean equals true, then we have finished the **traversion on** the input collection. If it is **falsy**, then we can keep calling the next function:\n\n```", "```php\n\n###### Snippet 1.82: Iterator use\n\n#### Note\n\nWhen an iterator's finality property is truthy, it should not return any new data. To demonstrate the use of `iterator.next()`, you can provide the example shown in the preceding snippet.\n\nIn summary, iterators provide us with a way to traverse potentially complex collections of data. An iterator tracks its current state and each time the next function is called, it provides an object with a value and a finality Boolean. When the iterator reaches the end of the collection, calls to `iterator.next()` will return a truthy finality parameter and no new values will be received.\n\n### Generators\n\n**A** **generator** provides an iterative way to build a collection of data. A generator can return values one at a time while pausing execution until the next value is requested. A generator keeps track of the internal state and each time it is requested, it returns a new number in the sequence.\n\nTo create a `generator`, we must define a function with an asterisk in front of the function name and the `yield` keyword in the body. For example, to create a\u00a0generator called `testGenerator`, we would initialize it as follows:\n\n```", "```php\n\nThe asterisk designates that this is a `generator function`. The `yield` keyword designates a break in the normal function flow until the generator function is called again. An example of a generator is shown in the following snippet:\n\n```", "```php\n\n###### Snippet 1.83: Generator creation\n\nThis `generator` function that we created in the preceding snippet, called `gen`, has an internal state variable called `i`. When the `generator` is created, it is automatically initialized with an internal next function. When the `next` function is called for the first time, the execution starts, the loop begins, and when the `yield` keyword is reached, the execution of the function is stopped until the next function is called again. When the `next` function is called, the program returns an object containing a value and `done`.\n\n### Exercise 15: Creating a Generator\n\nTo create a generator function that generates the values of the sequence of 2n to show how generators can build a set of sequential data, perform the following steps:\n\n1.  Create a `generator` called `gen`.\n\n    Place an asterisk before the identifier name.\n\n2.  Inside the generator body, do the following:\n\n    Create a variable called `i` and set the initial value to 1\\. Then, create an infinite while loop.\n\n    In the body of the while loop, `yield` `i` and set `i` to `i * 2.`\n\n3.  Initialize `gen` and save it into a variable called `generator`\n4.  Call your `generator` several times and log the output to see the values change.\n\n**Code**\n\n##### index.js:\n\n```", "```php\n\n###### Snippet 1.84: Simple generator\n\n[https://bit.ly/2VK7M3d](https://bit.ly/2VK7M3d)\n\n**Outcome**\n\n![Figure 1.17: Calling the generator output\n](image/Figure_1.17.jpg)\n\n###### Figure 1.17: Calling the generator output\n\nYou have successfully created a generator function.\n\nSimilar to iterators, the `done` value contains the completion status of the generator. If the `done` value is set to `true`, then the generator has finished execution and will no longer return new values. The value parameter contains the result of the expression contained on the line with the `yield` keyword. In this case, it will return the current value of `i`, before the increment. This is shown in the following code:\n\n```", "```php\n\n###### Snippet 1.85: Generator use\n\nGenerators pause execution when they reach the `yield` keyword. This means that loops will pause execution. Another powerful tool of a generator is the ability to pass in data via the next function and `yield` keyword. When a value is passed into the next function, the return value of the `yield` expression will be set to the value that's passed into next. An example of this is shown in the following code:\n\n```"]