- en: Chapter 7. Playing Sound with OpenSL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用OpenSL ES播放声音
- en: '*Multimedia is not only about graphics, it is also about sound and music. Applications
    in this domain are among the most popular in the Android market. Indeed, music
    has always been a strong engine for mobile device sales and music lovers are a
    target of choice. This is why an OS like Android could probably not go far without
    some musical talent! Open Sound Library for Embedded Systems, more frequently
    called OpenSL ES, is the pendant of OpenGL for sound. Although rather low-levewl,
    it is a first-class API for all sound-related tasks, either input or output.*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*多媒体不仅仅是关于图形，也涉及声音和音乐。这个领域的应用程序是Android市场中最受欢迎的。事实上，音乐一直是移动设备销售的强大引擎，音乐爱好者是首选目标。这就是为什么像Android这样的操作系统可能无法在没有一些音乐天赋的情况下走得太远！嵌入式系统的开放声音库，更常被称为OpenSL
    ES，是OpenGL的音频对应物。虽然相当低级，但它是所有与声音相关任务的一流API，无论是输入还是输出。*'
- en: 'When talking about sound on Android, we should distinguish Java from the native
    world. Indeed, both sides feature completely different APIs: **MediaPlayer**,
    **SoundPool**, **AudioTrack**, and **JetPlayer** on one hand, and **OpenSL ES**
    on the other hand:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论Android上的声音时，我们应该区分Java和本机世界。事实上，两边具有完全不同的API：**MediaPlayer**，**SoundPool**，**AudioTrack**和**JetPlayer**一方面，**OpenSL
    ES**另一方面：
- en: MediaPlayer is more high level and easy to use. It handles not only music but
    also video. It is the way to go when a simple file playback is sufficient.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MediaPlayer更高级且易于使用。它不仅处理音乐，还处理视频。当简单的文件播放足够时，这是一个不错的选择。
- en: SoundPool and AudioTrack are more low level and closer to low latency when playing
    sound. AudioTrack is the most flexible but also complex to use. It allows sound
    buffer modifications on the fly (by hand!).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SoundPool和AudioTrack更低级，更接近低延迟播放声音。AudioTrack是最灵活的，但也更复杂。它允许在飞行中（手动）修改声音缓冲区。
- en: JetPlayer is more dedicated to the playback of MIDI files. This API can be interesting
    for dynamic musing synthesis in a multimedia application or game (see the JetBoy
    example provided with Android SDK).
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JetPlayer更专注于播放MIDI文件。这个API对于多媒体应用程序或游戏中的动态音乐合成可能会很有趣（请参阅Android SDK提供的JetBoy示例）。
- en: OpenSL ES aims at offering a cross-platform API to manage audio on embedded
    systems; in other words, the OpenGL ES for audio. Like GLES, its specification
    is led by the Khronos group. On Android, OpenSL ES is in fact implemented on top
    of the AudioTrack API.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenSL ES旨在提供一个跨平台的API来管理嵌入式系统上的音频；换句话说，它是音频的OpenGL ES。与GLES一样，它的规范由Khronos组织领导。在Android上，OpenSL
    ES实际上是在AudioTrack API之上实现的。
- en: OpenSL ES was first released on Android 2.3 Gingerbread and was not available
    in previous releases (Android 2.2 and lower). While there is a profusion of APIs
    in Java, OpenSL ES is the only one provided on the native side and is exclusively
    available on it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES首次发布于Android 2.3 Gingerbread，并且在之前的版本（Android 2.2及更低版本）中不可用。虽然Java中有大量的API，但OpenSL
    ES是本机端提供的唯一API，并且仅在本机端可用。
- en: However, OpenSL ES is still immature. The OpenSL specification is still incompletely
    supported and several limitations shall be expected. In addition, the OpenSL specification
    is implemented in its version 1.0.1 on Android, although version 1.1 is already
    out. Thus, some breaking changes can be expected in the future since the OpenSL
    ES implementation is still evolving.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenSL ES仍然不够成熟。OpenSL规范仍然不完全支持，并且可能会有一些限制。此外，OpenSL规范在Android上的实现版本为1.0.1，尽管版本1.1已经发布。因此，由于OpenSL
    ES的实现仍在不断发展，未来可能会有一些重大变化。
- en: 3D Audio features are available through OpenSL ES only for devices whose system
    is compiled with the appropriate profile. Indeed, the current OpenSL ES specification
    provides three different profiles, Game, Music, and Phone for different types
    of devices. At the time this book is written, none of these profiles are supported.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 3D音频功能仅适用于系统编译有适当配置文件的设备。事实上，当前的OpenSL ES规范提供了三种不同的配置文件，游戏、音乐和电话，适用于不同类型的设备。在撰写本书时，这些配置文件都没有得到支持。
- en: However, OpenSL ES has qualities. First, it may be easier to integrate in the
    architecture of a native application, since it is itself written in C/C++. It
    does not have to carry a garbage collector on its back. Native code is not interpreted
    and can be optimized in-depth through assembly code. These are some of the many
    reasons to consider it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，OpenSL ES有其优点。首先，它可能更容易集成到本机应用程序的架构中，因为它本身是用C/C++编写的。它不必背负垃圾收集器。本机代码不是解释的，可以通过汇编代码进行深度优化。这些是考虑它的许多原因之一。
- en: 'This chapter is an introduction to the musical capabilities of OpenSL ES on
    the Android NDK. We are about to discover how to do the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于Android NDK上OpenSL ES音乐功能的介绍。我们将要发现如何做以下事情：
- en: Initialize OpenSL ES on Android
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android上初始化OpenSL ES
- en: Play background music
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放背景音乐
- en: Play sounds with a sound buffer queue
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用声音缓冲队列播放声音
- en: Record sounds and play them
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制声音并播放它们
- en: Audio and, more specifically, real-time audio is a highly technical subject.
    This chapter covers the basics to embed sound and music in your own applications.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 音频，更具体地说是实时音频，是一个高度技术性的主题。本章涵盖了在自己的应用程序中嵌入声音和音乐的基础知识。
- en: Initializing OpenSL ES
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化OpenSL ES
- en: OpenSL will not be very useful if we do not initialize it first. As usual, this
    step requires some boilerplate code. The verbosity of OpenSL does not improve
    the situation. Let's start this chapter by creating a new `SoundManager` to wrap
    OpenSL ES-related logic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不先初始化OpenSL，它将不会很有用。像往常一样，这一步需要一些样板代码。OpenSL的冗长并没有改善情况。让我们通过创建一个新的`SoundManager`来开始本章，以包装与OpenSL
    ES相关的逻辑。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part10`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以`DroidBlaster_Part10`的名称提供。
- en: Time for action – creating OpenSL ES engine and output
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建OpenSL ES引擎和输出
- en: 'Let''s create a new manager dedicated to sounds:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个专门用于声音的新管理器：
- en: Create a new file `jni/SoundManager.hpp`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新文件`jni/SoundManager.hpp`。
- en: 'First, include the OpenSL ES standard header `SLES/OpenSLES.h`. The two latter
    define objects and methods and are specifically created for Android. Then, create
    the `SoundManager` class to do the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，包括OpenSL ES标准头文件`SLES/OpenSLES.h`。后两者定义了对象和方法，专门为Android创建。然后，创建`SoundManager`类来执行以下操作：
- en: Initialize OpenSL ES with the `start()` method
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`start()`方法初始化OpenSL ES
- en: Stop the sound and release OpenSL ES with the `stop()` method
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`stop()`方法停止声音并释放OpenSL ES
- en: 'There are two main kinds of pseudo-object structures (that is, containing function
    pointers applied on the structure itself, such as a C++ object with this) in OpenSL
    ES:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES中有两种主要的伪对象结构（即，包含应用于结构本身的函数指针，例如C++对象）：
- en: '**Objects**: These are represented by `SLObjectItf`, which provides a few common
    methods to get allocated resources and object interfaces. This could be roughly
    compared to an object in Java.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**：这些由`SLObjectItf`表示，提供了一些常见的方法来获取分配的资源和对象接口。这可以粗略地与Java中的对象进行比较。'
- en: '**Interfaces**: These give access to object features. There can be several
    interfaces for an object. Depending on the host device, some interfaces may or
    may not be available. These are very roughly comparable to interfaces in Java.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**：这些接口提供对对象功能的访问。一个对象可以有多个接口。根据主机设备的不同，一些接口可能可用，而另一些可能不可用。这些可以非常粗略地与Java中的接口进行比较。'
- en: 'In `SoundManager`, declare two `SLObjectItf` instances, one for the OpenSL
    ES engine and an other for the speakers. Engines are available through a `SLEngineItf`
    interface:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SoundManager`中，声明两个`SLObjectItf`实例，一个用于OpenSL ES引擎，另一个用于扬声器。引擎可以通过`SLEngineItf`接口获得：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement `SoundManager` in `jni/SoundManager.cpp` with its constructor:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/SoundManager.cpp`中实现`SoundManager`及其构造函数：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Write the method `start()`, which is going to create an OpenSL Engine object
    and an `Output Mix` object. We need three variables per object to initialize:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`start()`方法，用于创建OpenSL引擎对象和`Output Mix`对象。我们需要每个对象三个变量来初始化：
- en: The number of interfaces to support for each object (`engineMixIIDCount` and
    `outputMixIIDCount`).
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象需要支持的接口数量（`engineMixIIDCount`和`outputMixIIDCount`）。
- en: An array of all the interfaces objects should support (`engineMixIIDs` and `outputMixIIDs`),
    for example `SL_IID_ENGINE` for the engine.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对象应该支持的接口数组（`engineMixIIDs`和`outputMixIIDs`），例如`SL_IID_ENGINE`用于引擎。
- en: An array of Boolean values to indicate whether the interface is required or
    optional for the program (`engineMixReqs` and `outputMixReqs`).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值数组，指示接口对程序是必需的还是可选的（`engineMixReqs`和`outputMixReqs`）。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Continue the method `start()`:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续`start()`方法：
- en: Initialize the OpenSL ES engine object (that is, the basic type `SLObjectItf`)
    with the `slCreateEngine()` method. When we create an OpenSL ES object, the specific
    interfaces we are going to use have to be indicated. Here, we request the `SL_IID_ENGINE`
    interface, which allows creating other OpenSL ES objects. The engine is the central
    object of the OpenSL ES API.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`slCreateEngine()`方法初始化OpenSL ES引擎对象（即基本类型`SLObjectItf`）。当我们创建一个OpenSL ES对象时，必须指定要使用的特定接口。在这里，我们请求`SL_IID_ENGINE`接口，它允许创建其他OpenSL
    ES对象。引擎是OpenSL ES API的中心对象。
- en: Then, invoke `Realize()` on the engine object. Any OpenSL ES object needs to
    be *realized* to allocate the required internal resources before use.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，在引擎对象上调用`Realize()`。任何OpenSL ES对象在使用之前都需要*realized*来分配所需的内部资源。
- en: Finally, retrieve `SLEngineItf`-specific interface.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，检索`SLEngineItf`特定接口。
- en: The engine interface gives us the possibility to instantiate an audio output
    mix with the `CreateOutputMix()` method. The audio output mix defined here delivers
    sound to the default speakers. It is autonomous (the played sound is sent automatically
    to the speaker), so there is no need to request any specific interface here.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引擎接口使我们能够使用`CreateOutputMix()`方法实例化音频输出混音。这里定义的音频输出混音将声音传送到默认扬声器。它是自主的（播放的声音会自动发送到扬声器），因此这里不需要请求任何特定的接口。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Write the `stop()` method to destroy what has been created in `start()`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`stop()`方法来销毁`start()`中创建的内容：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit `jni/DroidBlaster.hpp` and embed our new `SoundManager`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`jni/DroidBlaster.hpp`并嵌入我们的新`SoundManager`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create, start, and stop the sound service in `jni/DroidBlaster.cpp`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.cpp`中创建、启动和停止声音服务：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, link to `libOpenSLES.so` in the `jni/Android.mk` file:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/Android.mk`文件中链接到`libOpenSLES.so`：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*What just happened?*'
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: Run the application and check that no error is logged. We initialized the OpenSL
    ES library, which gives us access to efficient sound handling primitives directly
    from the native code. The current code does not perform anything apart from initialization.
    No sound comes out of the speakers yet.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序并检查是否记录了错误。我们初始化了OpenSL ES库，这使我们能够直接从本机代码中获得高效的声音处理基元。当前的代码除了初始化外并没有执行任何操作。扬声器中还没有发出声音。
- en: The entry point to OpenSL ES here is `SLEngineItf`, which is mainly an OpenSL
    ES object factory. It can create a channel to an output device (a speaker or anything
    else), as well as sound players or recorders (and even more!), as we will see
    later in this chapter.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的OpenSL ES入口点是`SLEngineItf`，主要是OpenSL ES对象工厂。它可以创建到输出设备（扬声器或其他设备）的通道，以及声音播放器或录音机（甚至更多！），我们将在本章后面看到。
- en: The `SLOutputMixItf` is the object representing the audio output. Generally,
    this will be the device speaker or headset. Although the OpenSL ES specification
    allows enumerating the available output (and also input) devices, NDK implementation
    is not mature enough to obtain or select a proper one (`SLAudioIODeviceCapabilitiesItf`,
    the official interface to obtain such information). So, when dealing with output
    and input device selection (only input device for recorders needs to be specified
    currently), it is preferable to stick to default values, `SL_DEFAULTDEVICEID_AUDIOINPUT`
    and `SL_DEFAULTDEVICEID_AUDIOOUTPUT` defined in `SLES/OpenSLES.h`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`SLOutputMixItf`是表示音频输出的对象。通常，这将是设备扬声器或耳机。尽管OpenSL ES规范允许枚举可用的输出（和输入）设备，但NDK实现还不够成熟，无法获取或选择合适的设备（`SLAudioIODeviceCapabilitiesItf`，官方接口用于获取此类信息）。因此，在处理输出和输入设备选择时（目前只需要为录音机指定输入设备），最好坚持使用默认值，即在`SLES/OpenSLES.h`中定义的`SL_DEFAULTDEVICEID_AUDIOINPUT`和`SL_DEFAULTDEVICEID_AUDIOOUTPUT`。'
- en: The current Android NDK implementation allows only one engine per application
    (this should not be an issue) and, at most, 32 created objects. Beware, however,
    that the creation of any object can fail, as this is dependent on the available
    system resources.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的Android NDK实现每个应用程序只允许一个引擎（这不应该是一个问题），最多可以创建32个对象。但要注意，任何对象的创建都可能失败，因为这取决于可用的系统资源。
- en: More on OpenSL ES philosophy
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于OpenSL ES哲学的更多信息
- en: 'OpenSL ES is different from its graphics compatriot GLES, partly because it
    does not have a long history to carry. It is constructed on (more or less) an
    object-oriented principle based on objects and interfaces. The following definitions
    come from the official specification:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES与其图形同行GLES不同，部分原因是它没有悠久的历史。它是基于对象和接口的面向对象原则构建的。以下定义来自官方规范：
- en: An **object** is an abstraction of a set of resources, assigned for a well-defined
    set of tasks, and the state of these resources. An object has a type determined
    on its creation. The object type determines the set of tasks that an object can
    perform. This can be considered similar to a class in C++.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象**是一组资源的抽象，分配给一组明确定义的任务，并且这些资源的状态。对象在创建时具有确定的类型。对象类型确定对象可以执行的任务集。这可以被认为类似于C++中的类。'
- en: An **interface** is an abstraction of a set of related features that a certain
    object provides. An interface includes a set of methods, which are functions of
    the interface. An interface also has a type, which determines the exact set of
    methods of the interface. We can define the interface itself as a combination
    of its type and the object to which it is related.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口**是某个对象提供的一组相关功能的抽象。接口包括一组方法，这些方法是接口的函数。接口还有一个类型，它确定接口的确切方法集。我们可以将接口本身定义为其类型和与其相关的对象的组合。'
- en: An **interface ID** identifies an interface type. This identifier is used within
    the source code to refer to the interface type.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口ID**标识接口类型。此标识符在源代码中用于引用接口类型。'
- en: 'An OpenSL ES object is set up in a few steps as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES对象的设置分为几个步骤如下：
- en: Instantiating it through a build method (which usually belongs to the engine).
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过构建方法（通常属于引擎）进行实例化。
- en: Realizing it to allocate the necessary resources.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现它以分配必要的资源。
- en: Retrieving object interfaces. A basic object only has a very limited set of
    operations (`Realize()`, `Resume()`, `Destroy()`, and so on). Interfaces give
    access to real object features and describes what operations can be performed
    on an object, for example, a `Play` interface to play or pause a sound.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检索对象接口。一个基本对象只有一组非常有限的操作（“Realize()”，“Resume()”，“Destroy()”等）。接口可以访问真实对象的功能，并描述可以在对象上执行哪些操作，例如，一个“Play”接口用于播放或暂停声音。
- en: 'Any interfaces can be requested but only the one supported by the object is
    going to be successfully retrieved. You cannot retrieve the record interface for
    an audio player because it returns (sometimes annoyingly!) `SL_RESULT_FEATURE_UNSUPPORTED`
    (error code 12). In technical terms, an OpenSL ES interface is a structure containing
    function pointers (initialized by the OpenSL ES implementation) with a self-parameter
    to simulate C++ objects and `this`, for example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 可以请求任何接口，但只有对象支持的接口才能成功检索。您不能为音频播放器检索录制接口，因为它会返回（有时令人恼火的！）`SL_RESULT_FEATURE_UNSUPPORTED`（错误代码12）。在技术术语中，OpenSL
    ES接口是一个包含函数指针的结构（由OpenSL ES实现初始化），具有用于模拟C++对象和`this`的self参数，例如：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `Realize()`, `Resume()`, and so on are object methods that can be applied
    on an `SLObjectItf` object. The approach is identical for interfaces.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，“Realize()”，“Resume()”等都是可以应用于“SLObjectItf”对象的对象方法。接口的方法是相同的。
- en: For more detailed information on what OpenSL ES can provide, refer to the specification
    on the Khronos website [http://www.khronos.org/opensles](http://www.khronos.org/opensles),
    as well as the OpenSL ES documentation in the Android NDK docs directory. Android
    implementation does not fully respect the specification, at least for now. So,
    do not be disappointed when discovering that only a limited subset of the specification
    (especially sample codes) works on Android.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有关OpenSL ES可以提供的更详细信息，请参阅Khronos网站上的规范[http://www.khronos.org/opensles](http://www.khronos.org/opensles)，以及Android
    NDK文档目录中的OpenSL ES文档。Android实现目前并未完全遵守规范。因此，当发现只有规范的有限子集（特别是示例代码）在Android上运行时，请不要感到失望。
- en: Playing music files
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐文件
- en: OpenSL ES is initialized, but the only thing coming out of speakers is silence!
    So what about finding a nice piece of **Background Music** (**BGM**) and playing
    it natively with Android NDK? OpenSL ES provides the necessary stuff to read music
    files such as MP3 files.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSL ES已经初始化，但从扬声器中发出的唯一声音是寂静！那么，如何在Android NDK中找到一段好听的**背景音乐**（**BGM**）并进行本地播放呢？OpenSL
    ES提供了读取音乐文件（如MP3文件）所需的必要内容。
- en: Note
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part11`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的项目在本书中以“DroidBlaster_Part11”命名。
- en: Time for action – playing background music
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-播放背景音乐
- en: 'Let''s open and play an MP3 music file with OpenSL ES:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用OpenSL ES打开并播放一个MP3音乐文件：
- en: 'MP3 files are opened by OpenSL using a POSIX file descriptor pointing to the
    chosen file. Improve `jni/ResourceManager.cpp` created in the previous chapters
    by defining a new structure `ResourceDescriptor` and appending a new method `descriptor()`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenSL使用指向所选文件的POSIX文件描述符打开MP3文件。通过定义一个新的结构`ResourceDescriptor`并追加一个新的方法`descriptor()`来改进在前几章中创建的`jni/ResourceManager.cpp`：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Implement `jni/ResourceManager.cpp`. Of course, makes use of the asset manager
    API to open the descriptor and fill a `ResourceDescriptor` structure:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/ResourceManager.cpp`。当然，使用资产管理器API来打开描述符并填充`ResourceDescriptor`结构：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Go back to `jni/SoundManager.hpp` and define two methods `playBGM()` and `stopBGM()`
    to play/stop a background MP3 file.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到`jni/SoundManager.hpp`并定义两个方法`playBGM()`和`stopBGM()`来播放/停止背景MP3文件。
- en: 'Declare an OpenSL ES object for the music player, along with the following
    interfaces:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个用于音乐播放器的OpenSL ES对象，以及以下接口：
- en: '`SLPlayItf` plays and stops music files'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLPlayItf`播放和停止音乐文件'
- en: '`SLSeekItf` controls position and looping'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLSeekItf`控制位置和循环'
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Start implementing `jni/SoundManager.cpp`.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始实现`jni/SoundManager.cpp`。
- en: Include `Resource.hpp` to get access to asset file descriptors.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 包括`Resource.hpp`以获取访问资产文件描述符。
- en: 'Initialize new members in the constructor and update `stop()` to stop the background
    music automatically (or some users are not going to be happy!):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中初始化新成员，并更新`stop()`以自动停止背景音乐（否则一些用户可能不会高兴！）：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Implement `playBGM()` to enrich the manager with playback features.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`playBGM()`以丰富管理器的播放功能。
- en: First, describe our audio setup through two main structures, `SLDataSource`
    and `SLDataSink`. The first describes the audio input channel and the second,
    the audio output channel.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过两个主要结构`SLDataSource`和`SLDataSink`描述我们的音频设置。第一个描述音频输入通道，第二个描述音频输出通道。
- en: Here, we configure the data source as a MIME source so that the file type gets
    detected automatically from the file descriptor. The file descriptor is, of course,
    opened with a call to `ResourceManager::descriptor()`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将数据源配置为MIME源，以便文件类型可以从文件描述符中自动检测。当然，文件描述符是通过调用`ResourceManager::descriptor()`打开的。
- en: 'The data sink (that is, the destination channel) is configured with the `OutputMix`
    object created in the first part of this chapter while initializing the OpenSL
    ES engine (and refers to the default audio output, that is, speakers or headset):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 数据接收端（即目标通道）使用在初始化OpenSL ES引擎时创建的`OutputMix`对象进行配置（并且指的是默认音频输出，即扬声器或耳机）：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, create the OpenSL ES audio player. As always, with OpenSL ES objects,
    instantiate it through the engine first and then realize it. Two interfaces, `SL_IID_PLAY`
    and `SL_IID_SEEK`, are imperatively required:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建OpenSL ES音频播放器。与OpenSL ES对象一样，首先通过引擎实例化它，然后实现它。两个接口`SL_IID_PLAY`和`SL_IID_SEEK`是必不可少的。
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, using the `play` and `seek` interfaces, switch the playback in loop
    mode (that is, the music keeps playing) from the track's beginning (that is, `0`
    milliseconds) until its end (`SL_TIME_UNKNOWN`), and then start playing (`SetPlayState()`
    with `SL_PLAYSTATE_PLAYING`).
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`play`和`seek`接口，将播放切换到循环模式（即音乐保持播放）从曲目的开始（即`0`毫秒）直到其结束（`SL_TIME_UNKNOWN`），然后开始播放（使用`SetPlayState()`和`SL_PLAYSTATE_PLAYING`）。
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Terminate with the last method `stopBGM()` to stop and destroy the player:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个方法`stopBGM()`用于停止和销毁播放器：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add a resource pointing to the music file in `jni/DroidBlaster.hpp`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中添加指向音乐文件的资源：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, in `jni/DroidBlaster.cpp`, start playing the music right after `SoundManager`
    is started:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/DroidBlaster.cpp`中，在`SoundManager`启动后立即开始播放音乐：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Copy an MP3 file into the `droidblaster`'s `assets` directory and name it `bgm.mp3`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个MP3文件复制到`droidblaster`的`assets`目录中，并将其命名为`bgm.mp3`。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The BGM file is provided with this book in the `DroidBlaster_Part11/assets`
    directory.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: BGM文件在`DroidBlaster_Part11/assets`目录中提供。
- en: '*What just happened?*'
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么?*'
- en: We discovered how to play a music clip from an MP3 file. Playback loops until
    the game is terminated. When using a MIME data source, the file type is auto-detected.
    Several formats are currently supported in Gingerbread, including Wave PCM, Wave
    alaw, Wave ulaw, MP3, Ogg Vorbis, and so on. The MIDI playback is currently not
    supported. Have a look at `$ANDROID_NDK/docs/opensles/index.html` for more information.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了如何从MP3文件中播放音乐片段。播放循环直到游戏终止。使用MIME数据源时，文件类型会被自动检测。目前在Gingerbread中支持多种格式，包括Wave
    PCM、Wave alaw、Wave ulaw、MP3、Ogg Vorbis等。目前不支持MIDI播放。请查看`$ANDROID_NDK/docs/opensles/index.html`获取更多信息。
- en: The way the sample code is presented here is typical of how OpenSL ES works.
    The OpenSL ES engine object, which is basically an object factory, creates an
    `AudioPlayer`. In its raw state, this object cannot do much. First, it needs to
    be realized to allocate the necessary resources. However, that is not enough.
    It needs to retrieve the right interfaces, like the `SL_IID_PLAY` interface to
    change the audio player state to playing/stopped. Then, the OpenSL API can be
    effectively used.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现的示例代码的方式是OpenSL ES的典型工作方式。OpenSL ES引擎对象，基本上是一个对象工厂，创建了一个`AudioPlayer`。在原始状态下，这个对象不能做太多事情。首先，它需要被实现以分配必要的资源。然而，这还不够。它需要检索正确的接口，比如`SL_IID_PLAY`接口，以改变音频播放器的状态为播放/停止。然后，OpenSL
    API可以被有效地使用。
- en: That is quite some work, taking into account result verification (as any call
    is susceptible to fail), which kind of clutters the code. Getting inside this
    API can take a little bit more time than usual, but once understood, these concepts
    become rather easy to deal with.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到结果验证（因为任何调用都有可能失败），这是相当多的工作，这在某种程度上使代码变得混乱。进入这个API可能需要比平常更多的时间，但一旦理解，这些概念就变得相当容易处理。
- en: You may be surprised to see that `startBGM()` and `stopBGM()` recreates and
    destroys the audio player respectively. The reason is that there is currently
    no way to change an MIME data source without completely recreating the OpenSL
    ES `AudioPlayer` object. So, although this technique is fine to play a long clip,
    it is not suitable to play a short sound dynamically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会惊讶地发现`startBGM()`和`stopBGM()`分别重新创建和销毁音频播放器。原因是目前没有办法在完全重新创建OpenSL ES `AudioPlayer`对象的情况下更改MIME数据源。因此，虽然这种技术适用于播放长片段，但不适合动态播放短声音。
- en: Playing sounds
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放声音
- en: The technique presented to play BGM from a MIME source is very practical but,
    sadly, not flexible enough. Recreating an `AudioPlayer` object is not necessary
    and accessing asset files each time is not good in terms of efficiency.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 从MIME源播放BGM的技术非常实用，但可悲的是，不够灵活。重新创建`AudioPlayer`对象是不必要的，每次访问资产文件也不利于效率。
- en: So, when it comes to playing sounds quickly in response to an event and generating
    them dynamically, we need to use a sound buffer queue. Each sound is preloaded
    or generated in a memory buffer, and placed into a queue when the playback is
    requested. No need to access a file at runtime!
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当需要快速响应事件并动态生成声音时，我们需要使用声音缓冲区队列。每个声音都预加载或在内存缓冲区中生成，并在请求播放时放入队列。无需在运行时访问文件！
- en: A sound buffer, in the current OpenSL ES Android implementation, can contain
    PCM data. **Pulse Code Modulation** (**PCM**) is a data format dedicated to the
    representation of digital sounds. It is the format used in CD and in some Wave
    files. A PCM can be Mono (the same sound on all speakers) or Stereo (different
    sounds for left and right speakers if available).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的OpenSL ES Android实现中，声音缓冲区可以包含PCM数据。**脉冲编码调制**（**PCM**）是一种专门用于表示数字声音的数据格式。它是CD和一些Wave文件中使用的格式。PCM可以是单声道（所有扬声器上的相同声音）或立体声（如果可用，则左右扬声器的不同声音）。
- en: 'PCM is not compressed and is not efficient in terms of storage (just compare
    a musical CD with a data CD full of MP3). However, this format is lossless and
    offers the best quality. Quality depends on the sampling rate: analog sounds are
    represented digitally as a series of measure (that is, `sample`) of the sound
    signal.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: PCM未经压缩，在存储方面效率不高（只需比较音乐CD和充满MP3的数据CD）。但是，该格式是无损的，并提供最佳质量。质量取决于采样率：模拟声音以一系列测量（即`sample`）的声音信号的形式数字化表示。
- en: 'A sound sample at 44100 Hz (that is 44100 measures per second) has better quality
    but also takes place more than a sound sampled at 16000 Hz. Also, each measure
    can be represented with a more or less fine degree of precision (the encoding).
    On current Android implementation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 44100 Hz的声音样本（即每秒44100个测量）具有更好的质量，但也比16000 Hz的声音占用更多空间。此外，每个测量可以以更或少精细的精度（编码）表示。在当前的Android实现中：
- en: Sounds can use 8000 Hz, 11025 Hz, 12000 Hz, 16000 Hz, 22050 Hz, 24000 Hz, 32000
    Hz, 44100 Hz, or 48000 Hz sampling,
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音可以使用8000 Hz、11025 Hz、12000 Hz、16000 Hz、22050 Hz、24000 Hz、32000 Hz、44100 Hz或48000
    Hz采样，
- en: Samples can be encoded on 8-bit unsigned or 16-bit signed (finer precision)
    in **little-endian** or **big-endian**.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本可以以8位无符号或16位有符号（更精细的精度）以**小端**或**大端**编码。
- en: In the following step-by-step tutorial, we will use a raw PCM file encoded over
    16-bit in little-endian.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的逐步教程中，我们将使用16位小端编码的原始PCM文件。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_Part12`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 本书提供的项目名称为`DroidBlaster_Part12`。
- en: Time for action – creating and playing a sound buffer queue
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间-创建和播放声音缓冲区
- en: 'Let''s use OpenSL ES to play an explosion sound stored in a memory buffer:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用OpenSL ES来播放存储在内存缓冲区中的爆炸声音：
- en: 'Update `jni/Resource.hpp` again to add a new method `getLength()`, which provides
    the size in bytes of an `asset` file:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次更新`jni/Resource.hpp`以添加一个新方法`getLength()`，它提供了`asset`文件的字节大小：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement this method in `jni/Resource.cpp`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Resource.cpp`中实现此方法：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Create `jni/Sound.hpp` to manage a sound buffer.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/Sound.hpp`来管理声音缓冲区。
- en: Define a method `load()` to load a PCM file and `unload()` to release it.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`load()`方法来加载PCM文件和`unload()`来释放它。
- en: 'Also, define the appropriate getters. Hold the raw sound data in a buffer along
    with its size. The sound is loaded from a `Resource`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 还要定义适当的获取器。将原始声音数据及其大小保存在缓冲区中。声音从`Resource`中加载：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Sound loading implementation done in `jni/Sound.cpp` is quite simple; it creates
    a buffer with the same size as the PCM file and loads all the raw file content
    in it:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/Sound.cpp`中完成声音加载实现非常简单；它创建一个与PCM文件大小相同的缓冲区，并将所有原始文件内容加载到其中：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Create `jni/SoundQueue.hpp` to encapsulate the creation of a player object
    and its queue. Create three methods to:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`jni/SoundQueue.hpp`来封装播放器对象及其队列的创建。创建三种方法：
- en: Initialize the `queue` when the application starts to allocate OpenSL resources
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序启动时初始化`queue`以分配OpenSL资源
- en: Finalize the `queue` to release OpenSL resources
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完成`queue`以释放OpenSL资源
- en: Play a sound buffer of a predefined length
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放预定义长度的声音缓冲区
- en: 'A sound queue can be manipulated through the `SLPlayItf` and `SLBufferQueueItf`
    interfaces:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 声音队列可以通过`SLPlayItf`和`SLBufferQueueItf`接口进行操作：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Implement `jni/SoundQueue.cpp`:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`jni/SoundQueue.cpp`：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Write `initialize()`, beginning with `SLDataSource` and `SLDataSink` to describe
    the input and output channel. Use a `SLDataFormat_PCM` data format (instead of
    `SLDataFormat_MIME`), which includes sampling, encoding, and endianness information.
    Sounds need to be mono (that is, only one sound channel for both left and right
    speakers when available). The queue is created with the Android-specific extension
    `SLDataLocator_AndroidSimpleBufferQueue()`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`initialize()`，从`SLDataSource`和`SLDataSink`开始描述输入和输出通道。使用`SLDataFormat_PCM`数据格式（而不是`SLDataFormat_MIME`），其中包括采样、编码和字节顺序信息。声音需要是单声道（即，左右扬声器都只有一个声音通道）。队列是使用Android特定扩展`SLDataLocator_AndroidSimpleBufferQueue()`创建的：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, create and realize the sound player. We are going to need its `SL_IID_PLAY`
    and `SL_IID_BUFFERQUEUE` interface, available thanks to the data locator configured
    in the previous step:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建和实现声音播放器。我们将需要其`SL_IID_PLAY`和`SL_IID_BUFFERQUEUE`接口，这些接口是由前一步中配置的数据定位器提供的：
- en: '[PRE26]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, start the queue by setting it in the playing state. This does not
    actually mean that a sound is played. The queue is empty so that would not be
    possible. However, if a sound gets enqueued, it is automatically played:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过将其设置为播放状态来启动队列。这实际上并不意味着播放声音。队列是空的，因此不可能播放声音。但是，如果一个声音被加入队列，它会自动播放：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OpenSL ES objects need to be released when we no longer need them:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们不再需要OpenSL ES对象时，需要释放它们：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, write `playSound()`, which first stops any sound being played and
    then enqueue the new sound buffer to be played. This is the simplest strategy
    to play a sound immediately:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写`playSound()`，首先停止正在播放的任何声音，然后将新的声音缓冲区排队以进行播放。这是立即播放声音的最简单策略：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Open `jni/SoundManager.hpp` and include the newly created headers.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`jni/SoundManager.hpp`并包含新创建的头文件。
- en: 'Create two new methods:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个新方法：
- en: '`registerSound()` to load and manage a new sound buffer'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`registerSound()`来加载和管理新的声音缓冲区'
- en: '`playSound()` to send a sound buffer to the sound play queue'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`playSound()`将声音缓冲区发送到声音播放队列'
- en: Define a `SoundQueue` array so that up to four sounds may be played simultaneously.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个`SoundQueue`数组，以便同时播放最多四个声音。
- en: 'Sound buffers are stored in a fixed-size C++ array:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 声音缓冲区存储在固定大小的C++数组中：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Update the constructor in `jni/SoundManager.cpp` and create a new destructor
    to release resources:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`jni/SoundManager.cpp`中的构造函数，并创建一个新的析构函数来释放资源：
- en: '[PRE31]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Update `start()` to initialize the `SoundQueue` instances. Then, load sound
    resources registered with `registerSound()`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`start()`以初始化`SoundQueue`实例。然后，加载使用`registerSound()`注册的声音资源：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finalize the `SoundQueue` instances when the application stops to release OpenSL
    ES resources. Also, release the sound buffers:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序停止时，完成`SoundQueue`实例以释放OpenSL ES资源。同时，释放声音缓冲区：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save and cache the sounds in `registerSound()`:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`registerSound()`中保存和缓存声音：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, write `playSound()`, which sends the buffer to play to a `SoundQueue`.
    Use a simple round-robin strategy to play several sounds simultaneously. Send
    each new sound to play next in the queue (which is more likely to be available).
    Obviously, this playing strategy is suboptimal for sounds of various lengths:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写`playSound()`，将缓冲区发送到`SoundQueue`进行播放。使用简单的轮询策略同时播放多个声音。将每个新声音发送到队列中以便下一个播放（这更有可能是可用的）。显然，这种播放策略对于不同长度的声音是不够理想的：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We will play a sound when the DroidBlaster ship collides with an asteroid. Since
    the collision is not yet managed (see [Chapter 10](ch10.html "Chapter 10. Intensive
    Computing with RenderScript"), *Intensive Computing with RenderScript* for collision
    handling with **Box2D**), we will simply play a sound when the ship is initialized.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当DroidBlaster飞船与小行星相撞时，我们将播放声音。由于碰撞尚未处理（请参阅[第10章](ch10.html "第10章。使用RenderScript进行密集计算")，“使用**Box2D**进行碰撞处理”的*使用RenderScript进行密集计算*），因此我们将在飞船初始化时简单地播放声音。
- en: 'To do so, in `jni/Ship.hpp`, retrieve a reference to `SoundManager` in the
    constructor and a collision sound buffer to play in `registerShip()`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，在`jni/Ship.hpp`中，在构造函数中检索对`SoundManager`的引用，并在`registerShip()`中检索要播放的碰撞声音缓冲区：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, in `jni/Ship.cpp`, after having stored all the necessary references,
    play the sound when the ship is initialized:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`jni/Ship.cpp`中，在存储了所有必要的引用之后，当飞船初始化时播放声音：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `jni/DroidBlaster.hpp`, define a reference to a file, which contains a collision
    sound:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`jni/DroidBlaster.hpp`中，定义一个包含碰撞声音的文件的引用：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, in `jni/DroidBlaster.cpp`, register the new sound and pass it to the
    `Ship` class:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`jni/DroidBlaster.cpp`中，注册新声音并将其传递给`Ship`类：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*What just happened?*'
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚刚发生了什么？*'
- en: 'We discovered how to preload sounds in a buffer and play them as needed. What
    differentiates the sound playing technique from the BGM one seen earlier is the
    use of a buffer queue. A buffer queue is exactly what its name reveals: a **First
    In, First Out** (**FIFO**) collection of sound buffers played one after the other.
    Buffers are enqueued for playback when all the previous buffers are played.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了如何预先加载声音到缓冲区并根据需要播放它们。与之前看到的BGM的声音播放技术的不同之处在于使用了缓冲区队列。缓冲区队列正如其名称所示：一种**先进先出**（**FIFO**）的声音缓冲区集合，依次播放。当所有先前的缓冲区都播放完毕时，缓冲区被排队播放。
- en: 'Buffers can be recycled. This technique is essential in combination with streaming
    files: two or more buffers are filled and sent to the queue. When the first buffer
    has finished playing, the second one starts while the first buffer is filled with
    new data. As soon as possible, the first buffer is enqueued before the queue gets
    empty. This process repeats forever until the playback is over. In addition, buffers
    are raw data and can thus be processed or filtered on the fly.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区可以被回收利用。这种技术在与流式文件结合使用时至关重要：填充两个或更多缓冲区并将其发送到队列。当第一个缓冲区播放完毕时，第二个开始播放，同时第一个缓冲区被填充新数据。尽快地，第一个缓冲区在队列变空之前被排队。这个过程一直重复，直到播放结束。此外，缓冲区是原始数据，因此可以在播放过程中进行处理或过滤。
- en: In the present tutorial, because `DroidBlaster` does not need to play more than
    one sound at once and no form of streaming is necessary, the buffer queue size
    is simply set to one buffer (step 7, `dataLocatorIn.numBuffers = 1;`). In addition,
    we want new sounds to pre-empt older ones, which explains why the queue is systematically
    cleared. Your OpenSL ES architecture should, of course, be adapted to your needs.
    If it becomes necessary to play several sounds simultaneously, several audio players
    (and therefore buffer queues) should be created.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，因为`DroidBlaster`不需要同时播放多个声音，也不需要任何形式的流式传输，缓冲区队列大小只需设置为一个缓冲区（步骤7，`dataLocatorIn.numBuffers
    = 1;`）。此外，我们希望新声音能够取代旧声音，这就解释了为什么队列被系统地清除。当然，您的OpenSL ES架构应该根据您的需求进行调整。如果需要同时播放多个声音，应该创建多个音频播放器（因此也需要缓冲区队列）。
- en: Sound buffers are stored in the PCM format, which does not self-describe its
    internal format. Sampling, encoding, and other format information needs to be
    selected in the application code. Although this is fine for most of them, a solution,
    if that is not flexible enough, can be to load a Wave file, which contains all
    the necessary header information.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 声音缓冲区以PCM格式存储，不会自我描述其内部格式。采样、编码和其他格式信息需要在应用程序代码中选择。虽然对大多数人来说这是可以的，但如果这不够灵活，一个解决方案可以是加载包含所有必要头信息的Wave文件。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A great open source tool to filter and sequence sounds is **Audacity**. It allows
    altering the sampling rate and modifying channels (Mono/Stereo). Audacity is able
    to export as well as import sound as raw PCM data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开源工具来过滤和排序声音是**Audacity**。它允许改变采样率和修改通道（单声道/立体声）。Audacity能够导出以及导入声音作为原始PCM数据。
- en: Using callbacks to detect sound queue events
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用回调检测声音队列事件
- en: 'It is possible to detect when a sound has finished playing using callbacks.
    A callback can be set up by calling the `RegisterCallback()` method on a queue
    (but other types of objects can also register callbacks). For example, the callback
    can receive this, that is, a `SoundManager` self-reference, to allow processing
    with any contextual information if needed. Although this is facultative, an event
    mask is set up to ensure that the callback is called only when the `SL_PLAYEVENT_HEADATEND`
    (player has finished playing the buffer) event is triggered. A few others play
    events are available in `OpenSLES.h`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用回调来检测声音何时播放完成。可以通过在队列上调用`RegisterCallback()`方法来设置回调（但其他类型的对象也可以注册回调）。例如，回调可以接收这个，也就是`SoundManager`的自引用，以允许根据需要处理任何上下文信息。虽然这是可选的，但设置了一个事件掩码，以确保只有在触发`SL_PLAYEVENT_HEADATEND`（播放器已完成播放缓冲区）事件时才调用回调。`OpenSLES.h`中还有一些其他播放事件可用：
- en: '[PRE40]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, when a buffer finishes playing, a message is logged. Operations such as,
    enqueuing a new buffer (to handle streaming for example) can be performed.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当一个缓冲区播放完成时，会记录一条消息。可以执行一些操作，比如，排队一个新的缓冲区（用于处理流式传输，例如）。
- en: Low latency on Android
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android上的低延迟
- en: Callbacks are like system interruptions or application events, their processing
    must be short and fast. If advanced processing is necessary, it should not be
    performed inside the callback but on another thread- native threads being perfect
    candidates.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 回调就像系统中断或应用程序事件一样，它们的处理必须简短快速。如果需要进行高级处理，不应该在回调中执行，而是在另一个线程中执行-本地线程是完美的候选者。
- en: Indeed, callbacks are emitted on a system thread, different than the one requesting
    OpenSL ES services (that is, the `NativeActivity` native thread in our case).
    Of course, with threads, arises the problem of thread-safety when accessing your
    own variables from the callback. Although protecting code with mutexes is tempting,
    they are not the best way to deal with real-time audio. Their effect on scheduling
    (**inversion of priority** issues for example) can cause glitches during playback.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，回调是在一个系统线程上发出的，与请求OpenSL ES服务的线程不同（也就是说，在我们的情况下是`NativeActivity`本地线程）。当然，使用线程时，访问回调中的自己的变量时会出现线程安全的问题。虽然用互斥锁保护代码很诱人，但它们并不是处理实时音频的最佳方式。它们对调度的影响（例如优先级倒置）可能会导致播放时出现故障。
- en: So, prefer using thread-safe techniques, like a lock-free queue to communicate
    with callbacks. Lock-free techniques can be implemented using GCC built-in atomic
    functions such as `__sync_fetch_and_add()` (which does not require any include
    file). For more information about atomic operations with the Android NDK, have
    a look at, `${ANDROID_NDK}/docs/ANDROID-ATOMICS.html`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好使用线程安全的技术，比如无锁队列与回调进行通信。无锁技术可以使用GCC内置的原子函数来实现，比如`__sync_fetch_and_add()`（不需要任何包含文件）。有关使用Android
    NDK进行原子操作的更多信息，请查看`${ANDROID_NDK}/docs/ANDROID-ATOMICS.html`。
- en: 'Although proper lock-free code is essential to achieve low-latency on Android,
    another important point to consider is that not all Android platforms and devices
    are suited for it! Indeed, low latency support came quite late in Android, starting
    from OS Version 4.1/4.2\. If you are in the need for low latency, you can check
    its support with the following piece of Java code:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在Android上实现低延迟需要适当的无锁代码，但另一个重要的考虑点是，并非所有Android平台和设备都适合它！确实，低延迟支持在Android中来得相当晚，从OS版本4.1/4.2开始。如果需要低延迟，可以使用以下Java代码检查其支持：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: However, beware! Many devices, even with the latest system versions, cannot
    achieve low latencies because of driver issues.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，要小心！许多设备，即使是最新的系统版本，也无法实现低延迟，因为驱动程序问题。
- en: 'Once you know that the target platform supports low-latency, take care of using
    the proper sampling rate and buffer size. Indeed, the Android audio system provides
    a "fast path", which does not apply any resampling, when using the optimal configuration.
    To do so, from API level 17 or higher, use `android.media.AudioManager.getProperty()`
    from the Java side:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道目标平台支持低延迟，就要注意使用适当的采样率和缓冲区大小。确实，当使用最佳配置时，Android音频系统提供了一个“快速路径”，不会应用任何重采样。为此，从API级别17或更高版本开始，从Java端使用`android.media.AudioManager.getProperty()`。
- en: '[PRE42]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: For more information on this subject, have a look at the *High Performance*
    *Audio* talk at [https://developers.google.com/events/io/sessions/325993827](https://developers.google.com/events/io/sessions/325993827).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请查看[https://developers.google.com/events/io/sessions/325993827](https://developers.google.com/events/io/sessions/325993827)上的*高性能*
    *音频*讲座。
- en: Recording sounds
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制声音
- en: Android devices are all about interactions. Interactions can come not only from
    touches and sensors, but also from audio input. Most Android devices provide a
    microphone to record sound and allow an application such as the Android desktop
    search to offer vocal features to record queries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Android设备都是关于互动的。互动不仅可以来自触摸和传感器，还可以来自音频输入。大多数Android设备都提供麦克风来录制声音，并允许应用程序（如Android桌面搜索）提供语音功能来记录查询。
- en: If the sound input is available, OpenSL ES gives native access to the sound
    recorder. It collaborates with a buffer queue to take data from the input device
    and fill an output sound buffer from it. The setup is pretty similar to what has
    been done with `AudioPlayer`, except that data source and data sink are permuted.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声音输入可用，OpenSL ES可以原生访问声音录制器。它与缓冲区队列合作，从输入设备获取数据，并从中填充输出声音缓冲区。设置与`AudioPlayer`所做的非常相似，只是数据源和数据目标被置换。
- en: Have a go hero – recording and playing a sound
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄来试试——录制和播放声音
- en: 'To discover how recording works, record a sound when an application starts
    and play it when it has finished recording. Turning `SoundManager` into a recorder
    can be done in four steps:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解录制的工作原理，请在应用程序启动时录制声音，并在录制完成后播放声音。将`SoundManager`转换为录音机可以分为四个步骤：
- en: Using status `startSoundRecorder()` to initialize the sound recorder. Invoke
    it right after `startSoundPlayer()`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用状态`startSoundRecorder()`来初始化声音录制器。在`startSoundPlayer()`之后立即调用它。
- en: With void `recordSound()`, start recording a sound buffer with device micro.
    Invoke this method at instances such as when the application is activated in `onActivate()`
    after the background music playback starts.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`void recordSound()`开始使用设备麦克风录制声音缓冲区。在`onActivate()`中应用程序激活后背景音乐播放开始时调用此方法。
- en: A new callback static `void callback_recorder(SLAndroidSimpleBufferQueueItf,
    void*)` to be notified of the record queue events. You have to register this callback
    so that it is triggered when a recorder event happens. Here, we are interested
    in buffer full events, that is, when the sound recording is finished.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的回调静态`void callback_recorder(SLAndroidSimpleBufferQueueItf, void*)`用于通知记录队列事件。您必须注册此回调，以便在发生录音机事件时触发它。在这里，我们对缓冲区满事件感兴趣，也就是声音录制完成时。
- en: '`void playRecordedSound()` to play a sound once recorded. Play it at instances
    such as when the sound has finished being recorded in `callback_recorder()`. This
    is not technically correct because of potential race conditions but is fine for
    an illustration.'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`void playRecordedSound()` 用于播放一次录制的声音。在`callback_recorder()`中声音录制完成时播放。这在技术上并不正确，因为可能存在竞争条件，但对于说明来说是可以的。'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting project is provided with this book under the name `DroidBlaster_PartRecorder`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的项目在本书中名为`DroidBlaster_PartRecorder`。
- en: 'Before going any further, recording requires a specific Android permission
    and, of course, an appropriate Android device (you would not like an application
    to record your secret conversations behind your back!). This authorization has
    to be requested in the Android manifest:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，录制需要特定的Android权限，当然还需要一个合适的Android设备（您不希望应用程序在您不知情的情况下录制您的秘密对话！）。这种授权必须在Android清单中请求：
- en: '[PRE43]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Creating and releasing the recorder
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和释放录音机
- en: 'Sounds are recorded with a recorder object created from the OpenSL ES engine,
    as usual. The recorder offers two interesting interfaces:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 声音通常是使用从OpenSL ES引擎创建的录音机对象录制的。录音机提供了两个有趣的接口：
- en: '`SLRecordItf`: This interface is used to start and stop recording. The identifier
    is `SL_IID_RECORD`.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLRecordItf`：此接口用于开始和停止录制。标识符是`SL_IID_RECORD`。'
- en: '`SLAndroidSImpleBufferQueueItf`: This manages a sound queue for the recorder.
    This is an Android extension provided by NDK because the current OpenSL ES 1.0.1
    specification does not support recording to a queue. The identifier is `SL_IID_ANDROIDSIMPLEBUFFERQUEUE`:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SLAndroidSImpleBufferQueueItf`：这个接口管理录音机的声音队列。这是NDK提供的Android扩展，因为当前的OpenSL
    ES 1.0.1规范不支持录制到队列。标识符是`SL_IID_ANDROIDSIMPLEBUFFERQUEUE`：'
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'To create the recorder, you will need to declare your audio source and sink,
    similar to the following one. The data source is not a sound but a default recorder
    device (such as a microphone). On the other hand, the data sink (that is, the
    output channel) is not a speaker but a sound buffer in the PCM format (with the
    requested sampling, encoding, and endianness). The Android extension `SLDataLocator_AndroidSimpleBufferQueue`
    must be used to work with a recorder since the standard OpenSL buffer queues will
    not:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建录音机，您需要声明音频源和音频目标，类似于以下内容。数据源不是声音，而是默认的录音设备（如麦克风）。另一方面，数据目标（即输出通道）不是扬声器，而是PCM格式的声音缓冲区（具有请求的采样、编码和字节顺序）。必须使用Android扩展`SLDataLocator_AndroidSimpleBufferQueue`来处理录音机，因为标准的OpenSL缓冲区队列不会：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When an application ends, do not forget to release the recorder object as all
    other OpenSL objects.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序结束时，不要忘记释放录音机对象，就像释放所有其他OpenSL对象一样。
- en: Recording a sound
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录制声音
- en: 'To record a sound, you need to create a sound buffer with an appropriate size
    according to the duration of your recording. You can adapt the `Sound` class to
    allow the creation of an empty buffer with a given size. The size depends on the
    sampling rate. For example, for a record of `2` seconds with a sampling rate of
    `44100` Hz and `16`-bit quality, the sound buffer size would look like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要录制声音，您需要根据录制的持续时间创建一个适当大小的声音缓冲区。您可以调整`Sound`类以允许创建具有给定大小的空缓冲区。大小取决于采样率。例如，对于采样率为`44100`
    Hz和`16`位质量的`2`秒记录，声音缓冲区大小如下：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In `recordSound()`, first stop the recorder, thanks to `SLRecordItf`, to ensure
    it is not already recording. Then, clear the queue to ensure your record buffer
    is used immediately. Finally, you can enqueue a new buffer and start recording:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在`recordSound()`中，首先停止录音机，然后清除队列以确保立即使用您的记录缓冲区。最后，您可以入队一个新的缓冲区并开始录制：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Tip
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is perfectly possible to enqueue new sound buffers so that any current recording
    is processed to its end. This allows creating a continuous chain of recording
    or, in other words, streaming the recording. The sound being enqueued will be
    processed only once the previous is filled.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将新的声音缓冲区入队，以便处理任何当前录制直到结束。这允许创建一个连续的录音链，或者换句话说，流式传输录音。只有在填充前一个缓冲区后，才会处理入队的声音。
- en: Recording a callback
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录音回调
- en: 'You eventually need to know when your sound buffer has finished recording.
    To do so, register a callback triggered when a recorder event happens (for example,
    a buffer has been filled). An event mask should be set to ensure that callback
    is called only when a buffer has been filled (`SL_RECORDEVENT_BUFFER_FULL`). A
    few others are available in `OpenSLES.h`, but not all are supported (`SL_RECORDEVENT_HEADATLIMIT`,
    and so on):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，您需要知道您的声音缓冲区何时录制完成。为此，注册一个回调，当录制事件发生时触发（例如，缓冲区已填满）。应设置事件掩码以确保仅在缓冲区填满时调用回调（`SL_RECORDEVENT_BUFFER_FULL`）。`OpenSLES.h`中还有其他一些事件，但并非所有都受支持（`SL_RECORDEVENT_HEADATLIMIT`等）：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Finally, when `callback_recorder()` is triggered, stop recording and play the
    recorded buffer with `playRecordedSound()`. The recorded buffer needs to be enqueued
    in the audio player's queue for playback, as we did in the previous section. You
    can use a specific `SoundQueue` to play the sound for simplicity purposes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当`callback_recorder()`被触发时，停止录制并使用`playRecordedSound()`播放录制的缓冲区。录制的缓冲区需要被加入音频播放器的队列中以进行播放，就像我们在上一节中所做的那样。您可以使用一个特定的`SoundQueue`来简化播放声音的目的。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In summary, we saw in this chapter how to initialize OpenSL ES on Android. The
    engine object is the main entry point to manage all OpenSL objects. Objects in
    OpenSL follow a specific lifecycle of creation, realization, and destruction.
    Then, we saw how to play background music from an encoded file and in-memory sounds
    with a sound buffer queue. Finally, we discovered how to record and then play
    a sound in a way that is thread-safe and non-blocking.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们在本章中看到了如何在Android上初始化OpenSL ES。引擎对象是管理所有OpenSL对象的主要入口点。OpenSL中的对象遵循特定的创建、实现和销毁生命周期。然后，我们看到了如何从编码文件和内存中的声音缓冲区队列中播放背景音乐。最后，我们发现了如何以线程安全和非阻塞的方式录制然后播放声音。
- en: Do you prefer OpenSL ES over Java APIs? If all you need is a nice high-level
    API, Java APIs may suit your requirements better. If you need finer playback or
    recording control, there is no significant difference between low-level Java APIs
    and OpenSL ES. In this case, the choice should be architectural. If your code
    is mainly Java, you should probably go with Java.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否更喜欢OpenSL ES而不是Java API？如果您只需要一个不错的高级API，Java API可能更适合您的需求。如果您需要更精细的播放或录制控制，低级Java
    API和OpenSL ES之间没有显著的区别。在这种情况下，选择应该是架构性的。如果您的代码主要是Java，您可能应该选择Java。
- en: If you need to reuse an existing sound-related library, optimize the performance,
    or perform intense computations, such as sound filtering on the fly, OpenSL ES
    is probably the right choice. OpenSL ES is also the way to go to low-latency,
    although Android is not quite there yet (fragmentations, device-specific issues,
    and so on). At the least, this verbose API is probably the one that is going to
    give the best performance. There is no garbage collector overhead and aggressive
    optimization is favored in the native code.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要重复使用现有的与声音相关的库，优化性能，或执行强烈的计算，比如实时进行声音过滤，OpenSL ES可能是正确的选择。OpenSL ES也是低延迟的选择，尽管Android目前还没有完全达到这一点（碎片化，设备特定问题等）。至少，这个冗长的API可能会提供最佳性能。在本地代码中没有垃圾收集器开销，并且积极的优化在其中得到了支持。
- en: 'Whatever choice you make, know that the Android NDK has a lot more to offer.
    After dealing with [Chapter 6](ch06.html "Chapter 6. Rendering Graphics with OpenGL
    ES"), *Rendering Graphics with OpenGL ES* and [Chapter 7](ch07.html "Chapter 7. Playing
    Sound with OpenSL ES"), *Playing Sound with OpenSL ES*, the next chapter will
    take care of handling input natively: keyboard, touches, and sensors.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您做出什么选择，都要知道Android NDK还有更多可以提供的。在处理完[第6章](ch06.html "第6章。使用OpenGL ES渲染图形")
    *使用OpenGL ES渲染图形*和[第7章](ch07.html "第7章。使用OpenSL ES播放声音") *使用OpenSL ES播放声音*之后，下一章将处理本地处理输入：键盘、触摸和传感器。
