- en: Understanding .NET Core Internals and Measuring Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解.NET Core内部和性能测量
- en: When developing application architecture, knowing the internals of how the .NET
    framework works plays a vital role in ensuring the quality of the application's
    performance. In this chapter, we will focus on the internals of .NET Core that
    can help us write quality code and architecture for any application. This chapter
    will cover some of the core concepts of .NET Core internals, including the compilation
    process, garbage collection, and **Framework Class Library **(**FCL**). We will
    complete this chapter by going through the *BenchmarkDotNet* tool, which is mostly
    used in measuring code performance, and is highly recommended for benchmarking
    code snippets within an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序架构时，了解.NET框架的内部工作原理对确保应用程序性能的质量起着至关重要的作用。在本章中，我们将重点关注.NET Core的内部机制，这可以帮助我们为任何应用程序编写高质量的代码和架构。本章将涵盖.NET
    Core内部的一些核心概念，包括编译过程、垃圾回收和Framework Class Library（FCL）。我们将通过使用BenchmarkDotNet工具来完成本章，该工具主要用于测量代码性能，并且强烈推荐用于在应用程序中对代码片段进行基准测试。
- en: 'In this chapter, you will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习以下主题：
- en: .NET Core internals
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core内部
- en: Utilizing multiple cores of the CPU for high performance
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用CPU的多个核心实现高性能
- en: How releasing builds increases performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发布构建如何提高性能
- en: Benchmarking .NET Core 2.0 applications
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对.NET Core 2.0应用程序进行基准测试
- en: .NET Core internals
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core内部
- en: '.NET Core contains two core components—the runtime CoreCLR and the base-class
    libraries CoreFX. In this section, we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core包含两个核心组件——运行时CoreCLR和基类库CoreFX。在本节中，我们将涵盖以下主题：
- en: CoreFX
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreFX
- en: CoreCLR
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreCLR
- en: Understanding MSIL, CLI, CTS, and CLS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解MSIL、CLI、CTS和CLS
- en: How CLR works
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CLR的工作原理
- en: From compilation to execution—under the hood
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从编译到执行——在幕后
- en: Garbage collection
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: .NET Native and JIT compilation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET本机和JIT编译
- en: CoreFX
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreFX
- en: CoreFX is the code name of .NET Core's set of libraries. It contains all the
    libraries that start with Microsoft.* or System.*and contains collections, I/O,
    string manipulation, reflection, security, and many more features.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: CoreFX是.NET Core一组库的代号。它包含所有以Microsoft.*或System.*开头的库，并包含集合、I/O、字符串操作、反射、安全性等许多功能。
- en: The CoreFX is runtime agnostic, and it can run on any platform regardless of
    what APIs it supports.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: CoreFX是与运行时无关的，可以在任何平台上运行，而不管它支持哪些API。
- en: To learn more about each assembly, you can refer to the .NET Core source browser
    at [https://source.dot.net](https://source.dot.net).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解每个程序集的更多信息，您可以参考.NET Core源浏览器[https://source.dot.net](https://source.dot.net)。
- en: CoreCLR
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CoreCLR
- en: CoreCLR provides the common language runtime environment for .NET Core applications,
    and manages the execution of the complete application life cycle. It performs
    various operations when the program is running. Operations such as memory allocation,
    garbage collection, exception handling, type safety, thread management, and security
    are part of CoreCLR.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: CoreCLR为.NET Core应用程序提供了公共语言运行时环境，并管理完整应用程序生命周期的执行。在程序运行时，它执行各种操作。CoreCLR的操作包括内存分配、垃圾回收、异常处理、类型安全、线程管理和安全性。
- en: .NET Core's runtime provides the same **Garbage Collection** (**GC**) as .NET
    Framework and a new **Just In Time** (**JIT**) compiler that is more optimized,
    codenamed *RyuJIT*. When .NET Core was first released, it was only supported for
    64-bit platforms, but with the release of .NET Core 2.0, it is now available for
    32-bit platforms as well. However, the 32-bit version is only supported by Windows
    operating systems.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的运行时提供与.NET Framework相同的垃圾回收（GC）和一个新的更优化的即时编译器（JIT），代号为RyuJIT。当.NET
    Core首次发布时，它仅支持64位平台，但随着.NET Core 2.0的发布，现在也可用于32位平台。但是，32位版本仅受Windows操作系统支持。
- en: Understanding MSIL, CLI, CTS, and CLS
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解MSIL、CLI、CTS和CLS
- en: When we build our project, the code is compiled into the **Intermediate Language**(**IL**),
    also known as **Microsoft Intermediate Language** (**MSIL**). MSIL is compliant
    with the **Common Language Infrastructure** (**CLI**), where CLI is the standard
    that provides a common type system and a language specification, respectively
    known as the **Common Type System** (**CTS**) and **Common Language Specification** (**CLS**).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建项目时，代码被编译为中间语言（IL），也称为Microsoft中间语言（MSIL）。MSIL符合公共语言基础设施（CLI），其中CLI是提供公共类型系统和语言规范的标准，分别称为公共类型系统（CTS）和公共语言规范（CLS）。
- en: The CTS provides a common type system and compiles the language-specific types
    into the compliant data types. It standardizes all the .NET languages' data types
    to a common data type for language interoperability. For example, if the code
    is written in C#, it will be converted to the specific CTS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CTS提供了一个公共类型系统，并将语言特定类型编译为符合规范的数据类型。它将所有.NET语言的数据类型标准化为语言互操作的公共数据类型。例如，如果代码是用C#编写的，它将被转换为特定的CTS。
- en: 'Suppose we have two variables, defined in the following code fragment using
    C#:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个变量，在以下使用C#定义的代码片段中：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'On compilation, the compiler generates the MSIL into an assembly that will
    be available through the CoreCLR to perform the JIT and convert it into the native
    machine code. Note that the `int` and `long` types are converted to the `int32`
    and `int64` respectively:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译时，编译器将MSIL生成为一个程序集，通过CoreCLR可执行JIT并将其转换为本机机器代码。请注意，`int`和`long`类型分别转换为`int32`和`int64`：
- en: '![](img/00026.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00026.jpeg)'
- en: It is not necessary for every language to comply completely with the CTS, and
    it can support the smaller footprint of the CTS, too. For example, when VB.NET
    was first released in .NET Framework, it only supported the signed integer data
    types, and there was no provision to use unsigned integers. With later versions
    of .NET Framework, and now with .NET Core 2.0, we can use all managed languages,
    such as C#, F#, and VB.NET, to develop applications and easily reference any project's
    assembly.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每种语言都必须完全符合CTS，并且它也可以支持CTS的较小印记。例如，当VB.NET首次发布在.NET Framework中时，它只支持有符号整数数据类型，并且没有使用无符号整数的规定。通过.NET
    Framework的后续版本，现在通过.NET Core 2.0，我们可以使用所有托管语言，如C#、F#和VB.NET，来开发应用程序，并轻松引用任何项目的程序集。
- en: How the CLR works
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CLR的工作原理
- en: 'The CLR is implemented as a set of in-process libraries that are loaded with
    the application, and runs inside the context of the application process. In the
    following diagram, we have two .NET Core applications running, named App1.exe
    and App2.exe*.* Each black box represents the application process address space,
    where the applications App1.exe and App2.exe are running their own CLR version
    side by side:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: CLR实现为一组在进程中加载的内部库，并在应用程序进程的上下文中运行。在下图中，我们有两个运行的.NET Core应用程序，名为App1.exe和App2.exe*.*每个黑色方框代表应用程序进程地址空间，其中应用程序App1.exe和App2.exe并行运行其自己的CLR版本：
- en: '![](img/00027.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.gif)'
- en: When packaging the .NET Core applications, we can either publish them as **framework-dependent
    deployments** (**FDDs**) or **self-contained deployment**s (**SCDs**). In FDDs,
    the published package does not contain the .NET Core runtime, and expects that
    the .NET Core is present on the target/hosting system. With SCDs, all the components,
    such as the .NET Core runtime and .NET Core libraries, are included in the published
    package, and the .NET Core installation on the target system is not required.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在打包.NET Core应用程序时，我们可以将其发布为**依赖框架部署**（**FDDs**）或**自包含部署**（**SCDs**）。在FDDs中，发布的包不包含.NET
    Core运行时，并期望目标/托管系统上存在.NET Core。对于SCDs，所有组件，如.NET Core运行时和.NET Core库，都包含在发布的包中，并且目标系统上不需要.NET
    Core安装。
- en: To learn more about FDDs or SCDs, please refer to [https://docs.microsoft.com/en-us/dotnet/core/deploying/](https://docs.microsoft.com/en-us/dotnet/core/deploying/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关FDDs或SCDs的更多信息，请参阅[https://docs.microsoft.com/en-us/dotnet/core/deploying/](https://docs.microsoft.com/en-us/dotnet/core/deploying/)。
- en: From compilation to execution – Under the hood
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编译到执行-底层
- en: 'The .NET Core compilation process is like the one used with the .NET Framework.
    When the project is built, the internal .NET CLI command is invoked by the MSBuild
    system, which builds the project and generates the assembly (`.dll`) or executable
    (`.exe`) file. This assembly contains the manifest that contains the assembly''s
    metadata, and includes the version number, culture, type-reference information,
    information about the referenced assemblies, and a list of other files in the
    assembly and their association. This assembly manifest is stored either in the
    MSIL code or in a standalone **portable executable** (**PE**) file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core编译过程类似于.NET Framework使用的过程。项目构建时，MSBuild系统调用内部.NET CLI命令，构建项目并生成程序集（`.dll`）或可执行文件（`.exe`）。该程序集包含包含程序集元数据的清单，包括版本号、文化、类型引用信息、有关引用程序集的信息以及程序集中其他文件及其关联的列表。该程序集清单存储在MSIL代码中或独立的**可移植可执行文件**（**PE**）中：
- en: '![](img/00028.gif)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.gif)'
- en: Now, when the executable is run, a new process is started and bootstraps the
    .NET Core runtime, which then initializes the execution environment, sets up the
    heap and thread pool, and loads the assembly into the process address space. Based
    on the program, it then executes the main entry point method (`Main`) and performs
    a JIT compilation. From here, the code starts executing and the objects start
    allocating memory on heap, where primitive types store on stack. For each method,
    the JIT compilation is done and the native machine code gets generated.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当可执行文件运行时，会启动一个新进程并引导.NET Core运行时，然后初始化执行环境，设置堆和线程池，并将程序集加载到进程地址空间中。根据程序，然后执行主入口方法（`Main`）并进行JIT编译。从这里开始，代码开始执行，对象开始在堆上分配内存，原始类型存储在堆栈上。对于每个方法，都会进行JIT编译，并生成本机机器代码。
- en: 'When JIT compilation is done, and before generating a native machine code,
    however, it also performs a few validations. These validations include the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当JIT编译完成，并在生成本机机器代码之前，它还执行一些验证。这些验证包括以下内容：
- en: Verifying, that the MSIL was generated during the build process
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证，在构建过程中生成了MSIL
- en: Verifying, whether any code was modified or new types added during the JIT compilation
    process
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证，在JIT编译过程中是否修改了任何代码或添加了新类型
- en: Verifying, that the optimized code for the target machine has been generated
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证，已生成了针对目标机器的优化代码
- en: Garbage collection
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾收集
- en: One of the most important features of CLR is the garbage collector. Since the
    .NET Core applications are managed applications, most of the garbage collection
    is done automatically by the CLR. The allocation of objects in the memory is efficiently
    done by the CLR. The CLR not only tunes the virtual memory resources from time
    to time, but it also reduces the fragmentation of underlying virtual memory to
    make it more efficient in terms of space.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: CLR最重要的功能之一是垃圾收集器。由于.NET Core应用程序是托管应用程序，大部分垃圾收集都是由CLR自动完成的。CLR有效地在内存中分配对象。CLR不仅会定期调整虚拟内存资源，还会减少底层虚拟内存的碎片，使其在空间方面更加高效。
- en: When the program is run, the objects start allocating memory on the heap and
    each object's address is stored on the stack. This process continues until the
    memory reaches its maximum limit. Then the GC comes into play and starts reclaiming
    memory by removing the unused managed objects and allocating new objects. This
    is all done automatically by the GC, but there is also a way to invoke the GC
    to perform garbage collection by calling the `GC.Collect` method
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序运行时，对象开始在堆上分配内存，并且每个对象的地址都存储在堆栈上。这个过程会一直持续，直到内存达到最大限制。然后GC开始起作用，通过移除未使用的托管对象并分配新对象来回收内存。这一切都是由GC自动完成的，但也可以通过调用`GC.Collect`方法来调用GC执行垃圾收集。
- en: 'Let''s take an example where we have a `Car` object called `c` in the `Main`
    method. When the function is executed, the `Car` object will be allocated by the
    CLR into the heap memory and the reference to that `c` object will be stored in
    the stack address pointing to the `Car` object on the heap. When the garbage collector
    runs, it reclaims the memory from the heap and removes the reference from the
    stack:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，我们在`Main`方法中有一个名为`c`的`Car`对象。当函数被执行时，CLR将`Car`对象分配到堆内存中，并且将指向堆上`Car`对象的引用存储在堆栈地址中。当垃圾收集器运行时，它会从堆中回收内存，并从堆栈中移除引用：
- en: '![](img/00029.gif)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00029.gif)'
- en: Some important points to note are that the garbage collection is done automatically
    by the GC on managed objects, and that if there are any unmanaged objects, such
    as database connections, I/O operations, and so on, they need to be garbage collected
    explicitly. Otherwise, GC works efficiently on managed objects and ensures that
    the application will not experience any decrease in performance when the GC is
    performed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一些重要点是，垃圾收集是由GC自动处理托管对象的，如果有任何非托管对象，比如数据库连接、I/O操作等，它们需要显式地进行垃圾收集。否则，GC会高效地处理托管对象，并确保应用程序在进行GC时不会出现性能下降。
- en: Generations in GC
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GC中的世代
- en: There are three kinds of generation in garbage collection known as Generation
    0, Generation 1, and Generation 2\. In this section, we will look at the concept
    of generations and how it affects the performance of the garbage collector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集中有三种世代，分别为第零代、第一代和第二代。在本节中，我们将看一下世代的概念以及它对垃圾收集器性能的影响。
- en: 'Let''s suppose we run an application that creates three objects named Object1,
    Object2, and Object3\. These objects will allocate the memory in Generation 0:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们运行一个创建了三个名为Object1、Object2和Object3的对象的应用程序。这些对象将在第零代中分配内存：
- en: '![](img/00030.gif)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00030.gif)'
- en: Now, when the garbage collector runs (this is an automatic process, unless you
    explicitly call the garbage collector from the code), it checks for the objects
    that are not needed by the application and have no reference in the program. It
    will simply remove those objects. For example, if the scope of Object1 is not
    referenced anywhere, the memory for this object will be reclaimed. However, the
    other two objects, Object1 and Object2, are still referenced in the program, and
    will be moved to Generation 1.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当垃圾收集器运行时（这是一个自动过程，除非你从代码中显式调用垃圾收集器），它会检查应用程序不需要的对象，并且在程序中没有引用。它将简单地移除这些对象。例如，如果Object1的范围在任何地方都没有被引用，那么这个对象的内存将被回收。然而，另外两个对象Object1和Object2仍然在程序中被引用，并且将被移动到第一代。
- en: 'Now, let''s suppose two more objects, called Object4 and Object5, are created.
    We will store them in the Generation 0 slot, as shown in the following diagram:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们创建了两个名为Object4和Object5的对象。我们将它们存储在第零代槽中，如下图所示：
- en: '![](img/00031.gif)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00031.gif)'
- en: 'When garbage collection runs the second time, it will find two objects called Object4
    and Object5 in Generation 0 and two objects called Object2 and Object3 in Generation
    1\. Garbage collector will first check the reference of those objects in Generation
    0 and, if they are not used by the application, they will be removed. The same
    goes for the Generation 1 objects. For example, if Object3 is still referenced,
    it will be moved to Generation 2 and Object2 will be removed from Generation 1,
    as shown in the following diagram:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当垃圾收集再次运行时，它将在第零代找到两个名为Object4和Object5的对象，并且在第一代找到两个名为Object2和Object3的对象。垃圾收集器将首先检查第零代中这些对象的引用，如果它们没有被应用程序使用，它们将被移除。对于第一代的对象也是一样。例如，如果Object3仍然被引用，它将被移动到第二代，而Object2将从第一代中被移除，如下图所示：
- en: '![](img/00032.gif)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00032.gif)'
- en: This concept of generations actually optimizes the performance of GC, and the
    objects stored in Generation 2 are more likely to be stored for a longer period.
    GC performs fewer visits and gains time instead of checking each object again
    and again. The same goes for Generation 1, which is also less likely to reclaim
    the space than Generation 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种世代的概念实际上优化了GC的性能，存储在第二代的对象更有可能被存储更长时间。GC执行更少的访问，而不是一遍又一遍地检查每个对象。第一代也是如此，它也不太可能回收空间，而不像第零代。
- en: .NET Native and JIT compilation
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET本机和JIT编译
- en: JIT compilation is done mostly at runtime, and it converts the MSIL code to
    the native machine code. This is when the code is run the first time, and it takes
    a little bit more time than its successive runs. In .NET Core today, we are developing
    applications for mobile and handheld devices that have limited resources in terms
    of CPU power and memory. Currently, the **Universal Windows Platform** (**UWP**)
    and the Xamarin platform run on .NET Core. With these platforms, .NET Core automatically
    generates that native assembly at compilation time or while generating the platform-specific
    packages. Though it does not require the JIT compilation process to be done at
    runtime, this eventually increases the performance of the application's boot-up
    time. This native compilation is done through a component known as .NET Native.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译主要在运行时进行，它将MSIL代码转换为本机机器代码。这是代码第一次运行时进行的，比其后的运行需要更多的时间。如今，在.NET Core中，我们正在为CPU资源和内存有限的移动设备和手持设备开发应用程序。目前，**Universal
    Windows Platform**（**UWP**）和Xamarin平台运行在.NET Core上。使用这些平台，.NET Core会在编译时或生成特定平台包时自动生成本机程序集。虽然这不需要在运行时进行JIT编译过程，但最终会增加应用程序的启动时间。这种本机编译是通过一个名为.NET
    Native的组件完成的。
- en: '.NET Native begins the compilation process after the language-specific compiler
    finishes up the compilation process that is done at build time. The .NET Native
    toolchain reads the MSIL generated from the language compiler and performs the
    following operations:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Native在语言特定编译器完成编译过程后开始编译过程。.NET Native工具链读取语言编译器生成的MSIL，并执行以下操作：
- en: It eliminates the metadata from the MSIL.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它从MSIL中消除了元数据。
- en: It replaces the code that relies on reflection and metadata with the static
    native code when comparing field values.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较字段值时，它用静态本机代码替换依赖反射和元数据的代码。
- en: It checks the code that is invoked by the application and includes only that
    in the final assembly.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查应用程序调用的代码，并只在最终程序集中包含那些代码。
- en: It replaces the full CLR with a refactored runtime that contains the garbage
    collector and no JIT compiler. The refactored runtime goes with the app and is
    contained in the assembly named `mrt100_app.dll`.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它用不带JIT编译器的重构运行时替换了完整的CLR。重构后的运行时与应用程序一起，并包含在名为`mrt100_app.dll`的程序集中。
- en: Utilizing multiple cores of the CPU for high performance
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用CPU的多个核心实现高性能
- en: These days, the nature of applications focuses more on connectivity, and there
    are cases where their operations take more time to execute. We also know that
    nowadays, all computers come with a multi-core processor, and using these cores
    effectively increases the performance of the application. Operations such as network/IO
    have latency issues, and the synchronous execution of the application program
    may often lead to a long waiting time. If the long-running tasks are executed
    in a separate thread or in an asynchronous manner, the resulting operation will
    take less time and increase responsiveness. Another benefit is performance that
    actually utilizes multiple cores of the processor and executes the task simultaneously.
    In the .NET world, we can achieve responsiveness and performance by splitting
    the tasks into multiple threads and using classic multithreading programming APIs,
    or a more simplified and advanced model known as the**task programming library** (**TPL**).
    The TPL is now supported in .NET Core 2.0, and we will soon explore how it can
    be used to execute tasks on multiple cores.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，应用程序的性质更加注重连接性，有时它们的操作需要更长的执行时间。我们也知道，现在所有的计算机都配备了多核处理器，有效地利用这些核心可以提高应用程序的性能。诸如网络/IO之类的操作存在延迟问题，应用程序的同步执行往往会导致长时间的等待。如果长时间运行的任务在单独的线程中或以异步方式执行，结果操作将花费更少的时间并提高响应性。另一个好处是性能，它实际上利用了处理器的多个核心并同时执行任务。在.NET世界中，我们可以通过将任务分割成多个线程并使用经典的多线程编程API，或者更简化和先进的模型，即**任务编程库**（**TPL**）来实现响应性和性能。TPL现在在.NET
    Core 2.0中得到支持，我们很快将探讨如何使用它在多个核心上执行任务。
- en: The TPL programming model is based on the task. A task is a unit of work—an
    object's representation of an ongoing operation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: TPL编程模型是基于任务的。任务是工作单元，是正在进行的操作的对象表示。
- en: 'A simple task can be created by writing the following lines of code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编写以下代码来创建一个简单的任务：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding code, the task can be initialized using a `Task` object, where
    `Execute` is the computational method that is executed when the `Start` method
    is called. The `Start` method tells the .NET Core that the task can start and
    returns immediately. It forks the program execution into two threads that run
    concurrently. The first thread is the actual application thread and the second
    one is the one that executes the `execute` method. We have used the `t.Wait` method
    to wait for the worker task to show the result on the console. Otherwise, once
    the program exits the block of code under the `Main` method, the application ends.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，任务可以使用`Task`对象进行初始化，其中`Execute`是在调用`Start`方法时执行的计算方法。`Start`方法告诉.NET
    Core任务可以开始并立即返回。它将程序执行分成两个同时运行的线程。第一个线程是实际的应用程序线程，第二个线程是执行`execute`方法的线程。我们使用了`t.Wait`方法来等待工作任务在控制台上显示结果。否则，一旦程序退出`Main`方法下的代码块，应用程序就会结束。
- en: 'The goal of parallel programming is to effectively use multiple cores. For
    example, we are running the preceding code in a single-core processor. These two
    threads will run and share the same processor. However, if the same program can
    run on a multi-core processor, it can run on multiple cores by utilizing each
    core separately, increasing the performance and achieving true parallelism:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程的目标是有效地利用多个核心。例如，我们在单核处理器上运行上述代码。这两个线程将运行并共享同一个处理器。然而，如果相同的程序可以在多核处理器上运行，它可以通过分别利用每个核心在多个核心上运行，从而提高性能并实现真正的并行性：
- en: '![](img/00033.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00033.jpeg)'
- en: Unlike TPL, the classic `Thread` object doesn't guarantee that your thread will
    be running on distinct cores of the CPU. With TPL, however, it guarantees that
    each thread will run on the distinct thread unless it reaches the number of tasks
    as per the CPU and shares the cores.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与TPL不同，经典的`Thread`对象不能保证您的线程将在CPU的不同核心上运行。然而，使用TPL，它保证每个线程将在不同的线程上运行，除非它达到了与CPU一样多的任务数量并共享核心。
- en: To learn more about what TPL provides, please refer to
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解TPL提供的更多信息，请参阅
- en: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl).'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl](https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/task-parallel-library-tpl)。'
- en: How releasing builds increases performance
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布构建如何提高性能
- en: 'Release and debug builds are two build modes provided in .NET applications.
    Debug mode is mostly used when we are in the process of writing code or troubleshooting
    errors, whereas release build mode is often used while packaging the application
    to deploy on production servers. When developing the deployment package, developers
    often miss updating the build mode to the release build, and then they face performance
    issues when the application is deployed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: .NET应用程序提供了发布和调试两种构建模式。调试模式在编写代码或解决错误时通常使用，而发布构建模式通常在打包应用程序以部署到生产服务器时使用。在开发部署包时，开发人员经常忘记将构建模式更新为发布构建，然后在部署应用程序时遇到性能问题：
- en: '![](img/00034.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00034.jpeg)'
- en: 'The following table shows some differences between the debug and release modes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了调试模式和发布模式之间的一些区别：
- en: '| Debug | Release |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 调试 | 发布 |'
- en: '| No optimization of code is done by the compiler | Code is optimized and minified
    in size when built using release mode |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 编译器不对代码进行优化 | 使用发布模式构建时，代码会被优化和缩小 |'
- en: '| Stack trace is captured and thrown at the time of exception | No stack trace
    is captured |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 在异常发生时捕获并抛出堆栈跟踪 | 不捕获堆栈跟踪 |'
- en: '| The debug symbols are stored | All code and debug symbols under #debug directives
    are removed |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 调试符号被存储 | 所有在#debug指令下的代码和调试符号都被移除 |'
- en: '| More memory is used by the source code at runtime | Less memory is used by
    the source code at runtime |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 源代码在运行时使用更多内存 | 源代码在运行时使用更少内存 |'
- en: Benchmarking .NET Core 2.0 applications
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对.NET Core 2.0应用程序进行基准测试
- en: Benchmarking applications is the process of evaluating and comparing artifacts
    with the agreed upon standards. To benchmark .NET Core 2.0 application code, we
    can use the `BenchmarkDotNet` tool, which provides a very simple API to evaluate
    the performance of code in your application. Usually, benchmarking at the micro-level,
    such as with classes and methods, is not an easy task, and requires quite an effort
    to measure the performance, whereas `BenchmarkDotNet` does all the low-level plumbing
    and the complex work associated with benchmark solutions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试应用程序是评估和比较与约定标准的工件的过程。要对.NET Core 2.0应用程序代码进行基准测试，我们可以使用`BenchmarkDotNet`工具，该工具提供了一个非常简单的API来评估应用程序中代码的性能。通常，在微观级别进行基准测试，例如使用类和方法，不是一件容易的事，需要相当大的努力来衡量性能，而`BenchmarkDotNet`则完成了所有与基准测试解决方案相关的低级管道和复杂工作。
- en: Exploring BenchmarkDotNet
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索`BenchmarkDotNet`
- en: In this section, we will explore `BenchmarkDotNet` and learn how effectively
    it can be used to measure application performance.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索`BenchmarkDotNet`并学习如何有效地使用它来衡量应用程序性能。
- en: 'It can simply be installed using a NuGet package manager console window or
    through the Project References section of your project. To install `BenchmarkDotNet`,
    execute the following command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简单地通过NuGet包管理器控制台窗口或通过项目引用部分来安装`BenchmarkDotNet`。要安装`BenchmarkDotNet`，执行以下命令：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding command adds a `BenchmarkDotNet` package from `NuGet.org`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令从`NuGet.org`添加了一个`BenchmarkDotNet`包。
- en: To test the `BenchmarkDotNet` tool, we will create a simple class that contains
    two methods to generate a Fibonacci series for a sequence of `10` numbers. The
    Fibonacci series can be implemented in multiple ways, which is why we are using
    it to measure which code snippet is faster and more performance efficient.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`BenchmarkDotNet`工具，我们将创建一个简单的类，其中包含两种方法来生成一个包含`10`个数字的斐波那契数列。斐波那契数列可以用多种方式实现，这就是为什么我们使用它来衡量哪个代码片段更快，更高效。
- en: 'Here is the first method that generates the Fibonacci sequence iteratively:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个以迭代方式生成斐波那契数列的方法：
- en: '[PRE3]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is another method that uses the recursive approach to generate the Fibonacci
    series:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一种使用递归方法生成斐波那契数列的方法：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that both of the main methods of the Fibonacci series contain a `Benchmark`
    attribute. This actually tells the `BenchmarkRunner` to measure methods that contain
    this attribute. Finally, we can call the `BenchmarkRunner` from the main entry
    point of the application that measures the performance and generates a report,
    as shown in the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，斐波那契数列的两个主要方法都包含`Benchmark`属性。这实际上告诉`BenchmarkRunner`要测量包含此属性的方法。最后，我们可以从应用程序的主入口点调用`BenchmarkRunner`，该入口点测量性能并生成报告，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once the benchmark is run, we will get the report as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行基准测试，我们将得到以下报告：
- en: '![](img/00035.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00035.jpeg)'
- en: 'As well as this, it also generates files in the root folder of an application
    that runs the `BenchmarkRunner`. Here is the .html file that contains the information
    about the version of `BenchmarkDotNet` and the OS, the processor, frequency, resolution,
    and timer details, the .NET version (in our case, .NET Core SDK 2.0.0), host,
    and so on:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还在运行`BenchmarkRunner`的应用程序的根文件夹中生成文件。这是包含有关`BenchmarkDotNet`版本和操作系统、处理器、频率、分辨率和计时器详细信息、.NET版本（在我们的情况下是.NET
    Core SDK 2.0.0）、主机等信息的.html文件：
- en: '![](img/00036.jpeg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00036.jpeg)'
- en: The table contains four columns. However, we can add more columns, which are
    optional by default. We can also add custom columns as well. The Method is the
    name of the method that contains the benchmark attribute, the Mean is the average
    time it takes for all the measurements to be taken (where us is microseconds), Error
    is the time taken to process errors, and StdDev is the standard deviation of the
    measurements.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表格包含四列。但是，我们可以添加更多列，默认情况下是可选的。我们也可以添加自定义列。Method是包含基准属性的方法的名称，Mean是所有测量所需的平均时间（us为微秒），Error是处理错误所需的时间，StdDev是测量的标准偏差。
- en: After comparing both the methods, the `FibonacciRecursive` method is more efficient
    as the Mean, Error, and StdDev values are smaller than the `Fibonacci` method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两种方法后，`FibonacciRecursive`方法更有效，因为平均值、错误和StdDev值都小于`Fibonacci`方法。
- en: Other than the HTML, two more files are created, a **Comma Separated Value**
    (**CSV**) file and a **Markdown Documentation** (**MD**) file which contains the
    same information.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了HTML之外，还创建了两个文件，一个**逗号分隔值**（CSV）文件和一个**Markdown文档**（MD）文件，其中包含相同的信息。
- en: How it works
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: Benchmark generates a project at runtime for each benchmark method and builds
    it in release mode. It tries multiple combinations to measure the method's performance
    by launching that method multiple times. Once the multiple cycles are run, the
    report is generated, containing files and information about Benchmark.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 基准为每个基准方法在运行时生成一个项目，并以发布模式构建它。它尝试多种组合来测量方法的性能，通过多次启动该方法。运行多个周期后，将生成报告，其中包含有关基准的文件和信息。
- en: Setting parameters
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置参数
- en: In the previous example, we tested the method with only one value. Practically,
    when testing an enterprise application, we want to test it with different values
    to estimate the method's performance.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们只测试了一个值的方法。实际上，在测试企业应用程序时，我们希望使用不同的值来估计方法的性能。
- en: '[PRE6]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running Benchmark, the following report is generated:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Benchmark后，将生成以下报告：
- en: '![](img/00037.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00037.jpeg)'
- en: Memory diagnostics using BenchmarkDotnet
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用BenchmarkDotnet进行内存诊断
- en: With `BenchmarkDotnet`, we can also diagnose any problems with the memory and
    measure the number of allocated bytes and garbage collection.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BenchmarkDotnet`，我们还可以诊断内存问题，并测量分配的字节数和垃圾回收。
- en: 'It can be implemented using a `MemoryDiagnoser` attribute at the class level.
    To start, let''s just add the `MemoryDiagnoser` attribute to the `TestBenchmark`
    class that we created in the last example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`MemoryDiagnoser`属性在类级别实现。首先，让我们在上一个示例中创建的`TestBenchmark`类中添加`MemoryDiagnoser`属性：
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Rerun the application. Now it will collect other memory allocation and garbage
    collection information and generate logs accordingly:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行应用程序。现在它将收集其他内存分配和垃圾回收信息，并相应地生成日志：
- en: '![](img/00038.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: In the preceding table, the Gen 0 and Gen 1 columns each contain the number
    of that particular generation per 1,000 operations. If the value is 1, then it
    means that the garbage collection was done after 1,000 operations. However, note
    that in the first row, the value is *0.1984*, which means that the garbage collection
    was done after *198.4* seconds, whereas for Gen 1 of that row, no garbage collection
    took place. Allocated represents the size of the memory that is allocated while
    invoking that method. It does not include the Stackalloc/heap native allocations.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上表中，Gen 0和Gen 1列分别包含每1,000次操作的特定代数的数量。如果值为1，则表示在1,000次操作后进行了垃圾回收。但是，请注意，在第一行中，值为*0.1984*，这意味着在*198.4*秒后进行了垃圾回收，而该行的Gen
    1中没有进行垃圾回收。Allocated表示在调用该方法时分配的内存大小。它不包括Stackalloc/堆本机分配。
- en: Adding configurations
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加配置
- en: 'Benchmark configuration can be defined by creating a custom class and inheriting
    it from the `ManualConfig` class. Here is an example of the `TestBenchmark` class
    that we created earlier containing some benchmark methods:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过创建自定义类并从`ManualConfig`类继承来定义基准配置。以下是我们之前创建的`TestBenchmark`类的示例，其中包含一些基准方法：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we defined the `Config` class that inherits the `ManualConfig`
    class provided in the benchmark framework. Rules can be defined inside the `Config`
    constructor. In the preceding example, there is a rule that stipulates that only
    those benchmark methods that contain `Recursive` should be executed. In our case,
    we have only one method, `FibonacciRecursive`, that will be executed and whose
    performance we will measure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们定义了`Config`类，该类继承了基准框架中提供的`ManualConfig`类。规则可以在`Config`构造函数内定义。在上面的示例中，有一个规则规定只有包含`Recursive`的基准方法才会被执行。在我们的情况下，只有一个方法`FibonacciRecursive`会被执行，并且我们将测量其性能。
- en: 'Another way of doing this is through the fluent API, where we can skip creating
    a `Config` class and implement the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是通过流畅的API，我们可以跳过创建`Config`类，并实现以下内容：
- en: '[PRE10]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To learn more about `BenchmarkDotNet`, refer to [http://benchmarkdotnet.org/Configs.htm](http://benchmarkdotnet.org/Configs.htm).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`BenchmarkDotNet`的更多信息，请参阅[http://benchmarkdotnet.org/Configs.htm](http://benchmarkdotnet.org/Configs.htm)。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the core concepts of .NET Core, including
    the compilation process, garbage collection, how to develop high-performant .NET
    Core applications by utilizing multiple cores of the CPU, and publishing an application
    using a release build. We have also explored the benchmarking tool, which is highly
    used for code optimization, and provides results specific to class objects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了.NET Core的核心概念，包括编译过程、垃圾回收、如何利用CPU的多个核心开发高性能的.NET Core应用程序，以及使用发布构建发布应用程序。我们还探讨了用于代码优化的基准工具，并提供了特定于类对象的结果。
- en: In the next chapter, we will learn about multithreading and concurrent programming
    in .NET Core.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习.NET Core中的多线程和并发编程。
