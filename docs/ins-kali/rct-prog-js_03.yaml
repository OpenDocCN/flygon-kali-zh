- en: Chapter 3. Reactive Programming – The Basic Theory
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。响应式编程-基本理论
- en: Reactive programming, including functional reactive programming as will be discussed
    later, is a programming paradigm that can be used in multiparadigm languages such
    as JavaScript, Python, Scala, and many more. It is primarily distinguished from
    imperative programming, in which a statement does something by what are called
    *side effects*, in literature, about functional and reactive programming. Please
    note, though, that side effects here are not what they are in common English,
    where all medications have some effects, which are the point of taking the medication,
    and some other effects are unwanted but are tolerated for the main benefit. For
    example, Benadryl is taken for the express purpose of reducing symptoms of airborne
    allergies, and the fact that Benadryl, in a way similar to some other allergy
    medicines, can also cause drowsiness is (or at least was; now it is also sold
    as a sleeping aid) a *side effect*. This is unwelcome but tolerated as the lesser
    of two evils by people, who would rather be somewhat tired and not bothered by
    allergies than be alert but bothered by frequent sneezing. Medication side effects
    are rarely the only thing that would ordinarily be considered *side effects* by
    a programmer. For them, *side effects* are the primary intended purpose and effect
    of a statement, often implemented through changes in the stored state for a program.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程，包括稍后将讨论的函数式响应式编程，是一种可以在多范式语言中使用的编程范式，例如JavaScript、Python、Scala等等。它主要与命令式编程有所不同，在命令式编程中，语句通过所谓的*副作用*来执行某些操作，在文献中，关于函数式和响应式编程。请注意，这里的副作用并不是普通英语中的副作用，其中所有药物都有一些效果，这些效果是服用药物的目的，而其他一些效果是不受欢迎的，但为了主要的益处而被容忍。例如，苯海拉明是为了减轻空气过敏症状而服用的，而事实上，苯海拉明在某种程度上与其他一些过敏药物类似，也会引起嗜睡（或者至少曾经是这样；现在它也作为睡眠辅助剂出售）是一种*副作用*。这是不受欢迎的，但被人们容忍，因为他们宁愿有些疲倦，而不受频繁打喷嚏的困扰。药物的副作用很少是程序员通常会考虑的*副作用*的唯一事情。对于他们来说，*副作用*是语句的主要预期目的和效果，通常通过对程序的存储状态进行更改来实现。
- en: 'Reactive programming has its roots in the observer pattern, as discussed in
    Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides''s classic book *Design
    Patterns: Elements of Reusable Object-Oriented Software* (the authors of this
    book are commonly called *GoF* or *Gang of Four*). In the observer pattern, there
    is an observable subject. It has a list of listeners, and notifies all of them
    when it has something to publish. This is somewhat simpler than the publisher/subscriber
    (PubSub) pattern, not having potentially intricate filtering of which messages
    reach which subscriber which is a normal feature to include.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程源于观察者模式，如Erich Gamma、Richard Helm、Ralph Johnson和John Vlissides的经典著作《设计模式：可复用面向对象软件的元素》中所讨论的（这本书的作者通常被称为*GoF*或*四人帮*）。在观察者模式中，有一个可观察的主题。它有一个监听器列表，并在有发布内容时通知它们所有。这比发布者/订阅者（PubSub）模式要简单一些，不需要潜在复杂的消息筛选，以确定哪些消息到达哪些订阅者，这是一个常见的特性。
- en: Reactive programming has developed a life of its own, a bit like the MVC pattern-turned-buzzword,
    but it is best taken in connection with the broader context explored in GoF. Reactive
    programming, including the ReactJS framework (which is explored in this title),
    is intended to avoid the shared mutable state and be idempotent. This means that,
    as with RESTful web services, you will get the same result from a function whether
    you call it once or a hundred times. Pete Hunt formerly of Facebook—perhaps the
    face of ReactJS as it now exists—has said that he would rather be predictable
    than right. If there is a bug in his code, Hunt would rather have the interface
    fail the same way every single time than go on elaborate hunts for heisenbugs.
    These are bugs that manifest only in some special and slippery edge cases, and
    are explored later in this book.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 响应式编程已经发展成了一种独立的生活，有点像MVC模式变成了流行语，但最好是与GoF中探讨的更广泛的背景联系在一起。响应式编程，包括ReactJS框架（在本书中进行了探讨），旨在避免共享可变状态并且是幂等的。这意味着，就像RESTful网络服务一样，无论您调用一次还是一百次，您都将从函数中获得相同的结果。Facebook的前员工皮特·亨特（现在是ReactJS的代表人物）曾说过，他宁愿是可预测的，而不是正确的。如果他的代码中有错误，亨特宁愿接口每次都以相同的方式失败，而不是进行对海森巴格的复杂搜索。这些错误只在一些特殊而棘手的边缘情况下表现出来，并且在本书的后面进行了探讨。
- en: ReactJS is called the *V* of *MVC*. That is, it is intended for user interface
    work and has little intentions of offering other standard features. But just as
    the painter Charles Cézanne said about the impressionist painter Claude Monet,
    "Monet is only an eye, but what an eye!" about MVC and ReactJS, we can say, "ReactJS
    is only a view, but what a view!"
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS被称为*MVC*的*V*。也就是说，它旨在用于用户界面工作，并且几乎没有提供其他标准功能的意图。但就像画家保罗·塞尚对印象派画家克劳德·莫奈所说的，“莫奈只是一只眼睛，但是多么美的眼睛！”关于MVC和ReactJS，我们可以说，“ReactJS只是一个视图，但是多么出色的视图！”
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Declarative programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式编程
- en: The war on heisenbugs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对抗海森巴格
- en: The Flux Architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux架构
- en: From pit of despair to the pit of success
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从绝望之坑到成功之坑
- en: A complete UI teardown and rebuild
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的UI拆解和重建
- en: JavaScript as a **Domain-specific Language** (**DSL**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript作为**领域特定语言**（**DSL**）
- en: Big-Coffee Notation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大咖啡符号
- en: ReactJS, the library explored in this book, was developed by Facebook and made
    open source in the not-too-distant past. It is shaped by some of Facebook's concerns
    about making a large-scale site that is safe to debug and work on, and also allowing
    a large number of programmers to work on different components without having to
    store brain-bending levels of complexity in their heads. The quotation "Simplicity
    is the lack of interleaving," which can be found in the videos at [http://facebook.github.io/react](http://facebook.github.io/react),
    is not about how much or how little stuff there is on an absolute scale, but about
    how many moving parts you need to juggle simultaneously to work on a system (See
    the section on *Big-Coffee Notation* for further reflections).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中探讨的库ReactJS是由Facebook开发的，并在不久之前开源。它受到Facebook关于创建一个安全易于调试的大型网站以及允许大量程序员在不必将复杂性存储在头脑中的情况下工作的一些关注的影响。引用语“简单是缺乏交错”，可以在[http://facebook.github.io/react](http://facebook.github.io/react)的视频中找到，它不是关于绝对尺度上有多少或多少东西，而是关于您需要同时操纵多少个移动部分来工作在一个系统上（有关*大咖啡符号*的更多反思，请参见相关部分）。
- en: Declarative programming
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明式编程
- en: Probably, the biggest theoretical advantage of the ReactJS framework is that
    the programming is declarative rather than imperative. In imperative programming,
    you specify what steps need to be done; declarative programming is the programming
    in which you specify what needs to be accomplished without telling how it needs
    to be done. It may be difficult at first to shift from an imperative paradigm
    to a declarative paradigm, but once the shift has been made, it is well worth
    the effort involved to get there.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS框架最大的理论优势可能是编程是声明式的，而不是命令式的。在命令式编程中，您指定需要执行哪些步骤；声明式编程是指您指定需要完成什么，而不告诉如何完成。从命令式范式转变到声明式范式可能一开始会很困难，但一旦完成转变，付出的努力就是值得的。
- en: Familiar examples of declarative paradigms, as opposed to imperative paradigms,
    include both SQL and HTML. An SQL query would be much more verbose if you had
    to specify how exactly to find records and filter them appropriately, let alone
    say how indices are to be used, and HTML would be much more verbose if, instead
    of having an IMG tag, you had to specify how to render an image. Many libraries,
    for instance, are more declarative than a rolling of your own solution from scratch.
    With a library, you are more likely to specify only what needs to be done and
    not—in addition to this—how to do it. ReactJS is not in any sense the only library
    or framework that is intended to provide a more declarative JavaScript, but this
    is one of its selling points, along with other better specifics that it offers
    to help teams work together and be productive. And again, ReactJS has emerged
    from some of Facebook's efforts in managing bugs and cognitive load while enabling
    developers to contribute a lot to a large-scale project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的声明式范例，与命令式范例相对，包括SQL和HTML。如果您必须指定如何查找记录并适当地过滤它们，更不用说如何使用索引，那么SQL查询将会更加冗长，而如果您必须指定如何渲染图像，HTML将会更加冗长。许多库比起从头开始自己解决问题更具有声明性。使用库，您更有可能只指定需要完成什么，而不是除此之外还要指定如何完成。ReactJS在任何意义上都不是旨在提供更具声明性JavaScript的唯一库或框架，但这是它的卖点之一，还有其他更好的具体功能，可以帮助团队合作并提高生产力。再次强调，ReactJS是从Facebook在管理错误和认知负荷方面的一些努力中出现的。
- en: The war on Heisenbugs
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Heisenbugs的战争
- en: In modern physics, Heisenberg's uncertainty principle loosely says that there
    is an absolute theoretical limit to how well a particle's position and velocity
    can be known. Regardless of how good a laboratory's measuring equipment gets,
    funny things will always happen when you try to pin things down too far.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代物理学中，海森堡的不确定性原理大致表明，有一个绝对的理论限制，即一个粒子的位置和速度可以被了解到多好。无论实验室的测量设备有多好，当您试图过于深入地固定事物时，总会发生一些有趣的事情。
- en: Heisenbugs, loosely speaking, are subtle, slippery bugs that can be very hard
    to pin down. They only manifest under very specific conditions and may even fail
    to manifest when one attempts to investigate them (note that this definition is
    slightly different from the jargon file's narrower and more specific definition
    at [http://www.catb.org/jargon/html/H/heisenbug.html](http://www.catb.org/jargon/html/H/heisenbug.html),
    which specifies that attempting to measure a heisenbug may suppress its manifestation).
    This motive—of declaring war on heisenbugs—stems from Facebook's own woes and
    experiences in working at scale and seeing heisenbugs keep popping up. One thing
    that Pete Hunt mentioned, in not a flattering light at all, was a point where
    Facebook's advertisement system was only understood by two engineers well enough
    who were comfortable with modifying it. This is an example of something to avoid.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 海森堡不确定性原理，口语上来说，是一种微妙的、难以捉摸的错误，很难固定下来。它们只在非常特定的条件下显现，甚至在尝试调查它们时可能甚至不会显现（请注意，这个定义与jargon文件在[http://www.catb.org/jargon/html/H/heisenbug.html](http://www.catb.org/jargon/html/H/heisenbug.html)中更狭窄和更具体的定义略有不同，该定义指出尝试测量heisenbug可能会抑制其显现）。对海森堡不确定性原理进行宣战的动机源于Facebook自己在规模化工作和看到heisenbug不断出现的困扰和经验。Pete
    Hunt提到的一件事，一点也不令人愉快，是Facebook广告系统只有两名工程师能够充分理解并且愿意修改。这是一个需要避免的例子。
- en: By contrast, looking at Pete Hunt's remark that he would "rather be predictable
    than right" is a statement that if a defectively designed lamp can catch fire
    and burn, his much, much rather have it catch fire and burn immediately, the same
    way, every single time, than at just the wrong point of the moon phase have something
    burn. In the first case, the lamp will fail testing while the manufacturer is
    testing, the problem will be noticed and addressed, and lamps will not be shipped
    out to the public until the defect has been property addressed. The opposite Heisenbug
    case is one where the lamp will spark and catch fire under just the wrong conditions,
    which means that a defect will not be caught until the laps have shipped and started
    burning customers' homes down. "Predictable" means "fail the same way, every time,
    if it's going to fail at all." "Right means "passes testing successfully, but
    we don't know whether they're safe to use [probably they aren't]." Now, he ultimately
    does, in fact, care about being right, but the choices that Facebook has made
    surrounding React stem from a realization that being predictable is a means to
    being right. It's not acceptable for a manufacturer to ship something that will
    always spark and catch fire when a consumer plugs it in. However, being predictable
    moves the problems to the front and the center, rather than being the occasional
    result of subtle, hard-to-pin-down interactions that will have unacceptable consequences
    in some rare circumstances. The choices in Flux and ReactJS are designed to make
    failures obvious and bring them to the surface, rather than them being manifested
    only in the nooks and crannies of a software labyrinth.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，看看Pete Hunt的评论，他宁愿“可预测也不愿意正确”是一个声明，如果一个设计有缺陷的灯可以着火烧毁，他更愿意它立即着火烧毁，以相同的方式，每一次，而不是在月相的错误时刻发生燃烧。在第一种情况下，灯会在制造商测试时失败，问题会被注意到并得到解决，直到缺陷得到适当解决之前，灯不会被运送到公众那里。相反的Heisenbug情况是灯只会在恰当的条件下发出火花并着火，这意味着缺陷直到灯被运送并开始烧毁客户的家才会被发现。
    “可预测”意味着“如果失败，每次都以相同的方式失败”。 “正确”意味着“成功通过测试，但我们不知道它们是否安全使用[可能它们不安全]”。现在，他最终确实关心正确，但Facebook在React周围做出的选择源于一种认识，即可预测是成为正确的手段。制造商不可以运送一些在消费者插上电源时总是会发出火花并着火的东西。然而，可预测将问题移到前台和中心，而不是偶尔出现在软件迷宫的隐蔽和难以捉摸的相互作用的结果。Flux和ReactJS中的选择旨在使失败显而易见，并将其显现出来，而不是仅在软件迷宫的角落和缝隙中显现。
- en: Facebook's war on the shared mutable state is illustrated in the experience
    that they had regarding a chat bug. The chat bug became an overarching concern
    for its users. One crucial moment of enlightenment for Facebook came when they
    announced a completely unrelated feature, and the first comment on this feature
    was a request to fix the chat; it got 898 likes. Also, they commented that this
    was one of the more polite requests. The problem was that the indicator for unread
    messages could have a phantom positive message count when there were no messages
    available. Things came to a point where people seemed not to care about what improvements
    or new features Facebook was adding, but just wanted them to fix the phantom message
    count. And they kept investigating and kept addressing edge cases, but the phantom
    message count kept on recurring.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook对共享可变状态的战争在他们对聊天bug的经验中得到了体现。聊天bug成为用户的一个主要关注点。Facebook的一个重要的醒悟时刻是当他们宣布一个完全无关的功能时，第一个评论是要求修复聊天；它获得了898个赞。此外，他们评论说这是一个比较礼貌的请求之一。问题在于未读消息的指示器在没有消息可用时可能会有一个幻影正消息计数。事情来到一个人们似乎不关心Facebook正在添加什么改进或新功能，而只是想让他们修复幻影消息计数的地步。他们继续调查并解决边缘情况，但幻影消息计数不断重现。
- en: The solution, besides ReactJS, was found in the flux pattern, or architecture,
    which is discussed in the next section. After a situation where not too many people
    felt comfortable making changes, all of a sudden, many more people felt comfortable
    making changes. These things simplified matters enough that new developers tended
    not to really need the ramp-up time and treatment that had previously been given.
    Furthermore, when there was a bug, the more experienced developers could guess
    with reasonable accuracy what part of the system was the culprit, and the newer
    developers, after working on a bug, tended to feel confident and have a general
    sense of how the system worked.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 除了ReactJS之外，解决方案还可以在下一节讨论的flux模式或架构中找到。在一种情况下，不太多的人感到舒服进行更改，突然之间，更多的人感到舒服进行更改。这些事情简化了事情，以至于新开发人员通常不需要真正需要之前给予的启动时间和处理。此外，当出现错误时，经验丰富的开发人员可以合理准确地猜测系统的哪个部分是罪魁祸首，而新手开发人员在处理错误后往往会感到自信，并对系统的工作原理有一般的了解。
- en: The Flux Architecture
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flux架构
- en: 'One of the ways in which Facebook, in relation to ReactJS, has declared war
    on heisenbugs is by declaring war on the mutable state. Flux is an architecture
    and a pattern, rather than a specific technology, and it can be used (or not used)
    with ReactJS. It is somewhat like MVC, equivalent to a loose competitor to that
    approach, but it is very different from a simple MVC variant and is designed to
    have a *pit of success* that provides unidirectional data flow like this: from
    the action to the dispatcher, then to the store, and finally to the view (but
    some people have said that these two are so different that a direct comparison
    between Flux and MVC, in terms of trying to identify what part of Flux corresponds
    to what conceptual hook in MVC, is not really that helpful). Actions are like
    events—they are fed into a top funnel. Dispatchers go through the funnels and
    can not only pass actions but also make sure that no additional actions are dispatched
    until the previous one has completely settled out. Stores have similarities and
    difference to models. They are like models in that they keep track of state. They
    are unlike models in that they have only getters, not setters, which stops the
    effect of any part of the program with access to a model being able to change
    anything in its setters. Stores can accept input, but in a very controlled way,
    and in general a store is not at the mercy of anything possessing a reference
    to it. A view is what displays the current output based on what is obtained from
    stores. Stores, compared to models in some respects, have getters but not setters.
    This helps foster a kind of data flow that is not at the mercy of anyone who has
    access to a setter. It is possible for events to be percolated as actions, but
    the dispatcher acts as a traffic cop and ensures that new actions are processed
    only after the stores are completely settled. This de-escalates the complexity
    considerably.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Facebook在与ReactJS相关的一种方式是宣布对heisenbugs宣战，这是通过对可变状态宣战来实现的。Flux是一种架构和模式，而不是一种特定的技术，它可以与ReactJS一起使用（或不使用）。它有点像MVC，相当于该方法的一个松散竞争对手，但它与简单的MVC变体非常不同，并且旨在具有提供单向数据流的“成功深渊”，就像这样：从动作到分发器，然后到存储，最后到视图（但有些人说这两者是如此不同，以至于在尝试确定Flux的哪个部分对应于MVC中的哪个概念挂钩方面，直接比较Flux和MVC并不是真的有帮助）。动作就像事件-它们被送入顶部漏斗。分发器通过漏斗并不仅可以传递动作，还可以确保在前一个动作完全解决之前不会再发出任何其他动作。存储与模型有相似之处，也有不同之处。它们像模型一样跟踪状态。它们不像模型，因为它们只有getter，没有setter，这可以阻止程序的任何部分能够更改setter中的任何内容。存储可以接受输入，但以一种非常受控的方式，通常存储不受任何拥有对其引用的东西的控制。视图根据从存储获取的内容显示当前输出。在某些方面，存储与模型相比具有getter但没有setter。这有助于培养一种不受setter访问者控制的数据流。事件可以作为动作传播，但分发器充当交通警察，并确保只有在存储完全解决后才处理新动作。这大大降低了复杂性。
- en: Flux simplified interactions so that Facebook developers no longer had subtle
    edge cases and bug that kept coming back—the chat bug was finally dead and has
    not come back.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Flux简化了交互，使得Facebook开发人员不再遇到微妙的边缘情况和不断出现的错误-聊天错误最终消失了，再也没有出现。
- en: From the pit of despair to the pit of success
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从绝望的深渊到成功的深渊
- en: Louis Brandy has warned about the perils of C++, which—at the risk of being
    controversial—has been called the biggest example of the *second system effect*
    ([http://tinyurl.com/reactjs-second-system](http://tinyurl.com/reactjs-second-system))
    since the OS/360 project. In a vague *XKCD*-style graphic, he states "Never trust
    a programmer who says he knows C++" ([http://tinyurl.com/reactjs-cpp-valley](http://tinyurl.com/reactjs-cpp-valley)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Louis Brandy警告了C++的危险，冒着引起争议的风险，他称之为*第二系统效应*的最大例子（[http://tinyurl.com/reactjs-second-system](http://tinyurl.com/reactjs-second-system)），自OS/360项目以来。在一个模糊的*XKCD*风格的图形中，他说“永远不要相信一个说他懂C++的程序员”（[http://tinyurl.com/reactjs-cpp-valley](http://tinyurl.com/reactjs-cpp-valley)）。
- en: 'The following graph shows the level of confidence of the C++ programmer:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了C++程序员的信心水平：
- en: '![From the pit of despair to the pit of success](img/B04108_03_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![从绝望的深渊到成功的深渊](img/B04108_03_1.jpg)'
- en: 'He continues:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 他继续说：
- en: '*"Programmers (especially those coming from C) can very quickly get up to speed
    in C++ and feel quite proficient. These programmers will tell you they know C++.
    They are lying. As a programmer continues in C++, he goes through this valley
    of frustration where he comes fully to terms with the complexity of the language.
    The good news is that it''s really easy to tell between C++ programmers pre- and
    post-valley (in an interview, in this case). Just mention that C++ is an extremely
    large and complex language, and the post-valley people will give you 127 different
    tiny frustrations they have with the language. The pre-valley people will say,
    "Yeah, I guess. I mean, it''s just C with classes."*'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“程序员（特别是那些来自C语言）可以很快地掌握C++并感到非常熟练。这些程序员会告诉你他们懂C++。他们在撒谎。当程序员继续学习C++时，他会经历这种挫折的低谷，他完全认识到了语言的复杂性。好消息是很容易区分C++程序员在低谷之前和之后的状态（在这种情况下是面试）。只要提到C++是一种非常庞大和复杂的语言，低谷后的人会告诉你他们对语言有127种不同的小挫折。低谷前的人会说，“是的，我猜。我的意思是，这只是带有类的C语言。”*'
- en: 'Eric Lippert tells us something that isn''t really relevant to only C++ programmers;
    it leads to something larger than C++:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Lippert告诉我们的内容并不仅适用于C++程序员；它导致了比C++更大的东西：
- en: '*I often think of C++ as my own personal Pit of Despair programming language.
    Unmanaged C++ makes it so easy to fall into traps. Think buffer overruns, memory
    leaks, double frees, mismatch between allocator and deallocator, using freed memory,
    umpteen dozen dozen ways to trash the stack or heap -- and those are just some
    of the memory issues. There are lots more "gotchas" in C++. C++ often throws you
    into the Pit of Despair and you have to climb your way up to the Hill of Quality.
    (Not to be confused with scaling the Cliffs of Insanity. That''s different.)*'
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我经常把C++看作是我自己的绝望之坑编程语言。不受管理的C++使人很容易陷入陷阱。想想缓冲区溢出、内存泄漏、双重释放、分配器和解分配器不匹配、使用已释放的内存、无数种方式来破坏堆栈或堆——这些只是一些内存问题。C++经常把你扔进绝望之坑，你必须爬上质量之山。（不要与攀登疯狂悬崖混淆。那是不同的。）*'
- en: '>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*Now as I''ve said before, the design of C# is not a subtractive process. It
    is not "C++ with the stupid parts taken out." But that said, it would be rather
    foolish of us not to look at what problems people have had with other languages
    and work to ensure that those exact same problems do not crop up for C# users.
    I would like C# to be a "Pit of Quality" language, a language whose rules encourage
    you to write correct code in the first place. You have to work quite hard to write
    a buffer overrun bug into a C# program, and that''s on purpose.*'
  id: totrans-35
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*现在正如我之前所说的，C#的设计不是一个减法过程。它不是“去掉愚蠢部分的C++”。但是，不看看其他语言的问题并努力确保这些问题不会出现在C#用户身上，那我们就太愚蠢了。我希望C#成为一种“质量之坑”语言，一种鼓励你一开始就编写正确代码的语言。你必须非常努力才能在C#程序中写出缓冲区溢出的错误，这是有意为之的。*'
- en: '>'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '>'
- en: '*I have never written a buffer overrun in C#. I have never written a bug where
    I accidentally shadowed a variable in another scope in C#. I have never used stack
    memory after the function returned in C#. I''ve done all those things multiple
    times in C++, and it''s not because I''m an idiot, it''s because C++ makes it
    easy to do all those things and C# makes it very hard. Making it easy to do good
    stuff is obviously goodness; thinking about how to make it hard to do bad is actually
    more important.*'
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*我从未在C#中编写过缓冲区溢出。我从未在C#中写过意外地在另一个作用域中隐藏变量的错误。我从未在C#中在函数返回后使用堆栈内存。我在C++中做了所有这些事情，这不是因为我是个白痴，而是因为C++使得做所有这些事情变得容易，而C#使得这变得非常困难。使得做好事情变得容易显然是好事；考虑如何使做坏事变得困难实际上更重要。*'
- en: Or, as it happened on a Python mailing list, someone with an obvious 133t hax0r
    spelling asked how to write a buffer overflow in Python, and one of the more senior
    list members answered, "We're sorry, but Python doesn't support that feature."
    The point of this meme is that someone asking about how to find a particular kind
    of vulnerability is answered by saying that Python had the basic type of defect
    designed out of the language. As has been pointed out for C#, strings are handled
    in a sane fashion where no naive use ever results in buffer override vulnerabilities.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，就像在Python邮件列表上发生的那样，一个明显的133t hax0r拼写的人问如何在Python中编写缓冲区溢出，而更资深的列表成员之一回答说：“很抱歉，但Python不支持该功能。”这个梗的重点是，有人询问如何找到特定类型的漏洞，却得到的答复是Python的语言设计中已经排除了基本类型的缺陷。正如对C#所指出的，字符串的处理方式是合理的，没有任何天真的使用会导致缓冲区覆盖漏洞。
- en: 'Eric Lippert is, and remains, a pivotal figure in C#, and his post eloquently
    clarifies how exactly one could intelligently disagree with Bjarne Stroustrup''s
    words:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Eric Lippert是C#中的一个关键人物，他的帖子清楚地阐明了如何明智地反对Bjarne Stroustrup的话：
- en: '*"The connection between the language in which we think/program and the problems
    and solutions we can imagine is very close. For that reason restricting language
    features with the intent of eliminating programmer errors is at best dangerous."*'
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“我们思考/编程的语言与我们能够想象的问题和解决方案之间的联系非常紧密。因此，出于消除程序员错误的目的限制语言特性至少是危险的。”*'
- en: 'People who disagree with Stroustrup today might not contest both of these sentences,
    but might contest only the second: the connection between the language and the
    solutions may indeed seem to be real, but have quite the opposite implication
    for language features and the pit of success. And something like this may be factored
    into decisions such as those in the book *JavaScript: The Good Parts* by *Douglas
    Crockford*. This or that detail might be challenged, but the core idea of using
    a cherry-picked subset of JavaScript and leaving some other parts alone completely
    stems from seeking and retrofitting the fact that a pit of success is almost a
    no-brainer once the possibility has been pointed out.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 今天不同意Stroustrup的人可能不会质疑这两个句子，但可能只会质疑第二个句子：语言与解决方案之间的联系似乎确实是真实的，但对于语言特性和成功之坑却具有相反的含义。像*
    Douglas Crockford *的书《JavaScript：好部分》中的决定可能会考虑到这样的因素。这样或那样的细节可能会受到质疑，但使用JavaScript的精选子集并完全忽略其他部分的核心思想源于寻求和改装成功之坑的事实几乎是理所当然的一旦可能性被指出。
- en: All of this leads up to a point made by Rico Mariani in—sort of—the opposite
    of the pit of despair. The pit of success, in stark contrast to a summit, a peak,
    or a journey across a desert to find victory through many trials and surprises.
    We want our customers to simply "fall into" winning practices using our platforms
    and frameworks. To the extent that we make it easy to fall into trouble we fail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都导致了Rico Mariani在某种程度上提出的一个观点，与绝望之坑的相反。成功之坑与峰顶、山峰或穿越沙漠寻找胜利的旅程形成鲜明对比。我们希望我们的客户简单地“陷入”使用我们的平台和框架的成功实践。在我们让人陷入麻烦变得容易的程度上，我们失败了。
- en: Complete UI teardown and rebuild
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成UI拆解和重建
- en: 'One of Dijkstra''s quotations that is a favorite with ReactJS developers such
    as Pete Hunt is: our intellectual powers are rather geared to master static relations
    and that our powers to visualize processes evolving in time are relatively poorly
    developed. For that reason, we should do (as wise programmers aware of our limitations)
    our utmost to shorten the conceptual gap between the static program and the dynamic
    process, to make the correspondence between the program (spread out in text space)
    and the process (spread out in time) as trivial as possible.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 迪杰斯特拉的一句话，深受ReactJS开发者如Pete Hunt的喜爱，是：我们的智力更适合掌握静态关系，而我们对于可视化时间演变过程的能力相对较差。因此，我们应该尽最大努力缩短静态程序和动态过程之间的概念差距，使程序（在文本空间中展开）和过程（在时间中展开）之间的对应尽可能简单。
- en: One way in which ReactJS plays to this strength conceptually, is by blowing
    everything away and re-rendering afresh so that the correspondence between the
    program and the process is simple. You do not keep track of the present state
    of the DOM and 300 jQuery changes that need to be kept in mind to transition accurately
    from one state to another. All you need to do is tell how it should look now.
    Now, in fact, ReactJS does not blow everything away under the hood; it has fairly
    sophisticated facilities that can make a lightning-fast pure JavaScript synthetic
    DOM (the same synthetic DOM that enables HTML5 features in Internet Explorer 8),
    and reconcile and make the fastest changes possible ("fast" in this context includes
    the impressive feat of managing 60-frames-per-second updates on a non-JIT iPhone
    5.) However, conceptually speaking, using ReactJS means simply treating everything
    as if it was being blown away and redrawn from scratch, and trusting ReactJS to
    bring together all the pixie dust it needs to make the minimum sufficient DOM
    changes. This is done to update the page as requested, probably without losing
    the existing input or inertial scrolling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS在概念上发挥了这种优势的一种方式是，将所有东西都清除并重新渲染，以便程序和过程之间的对应关系变得简单。您不需要跟踪DOM的当前状态和需要记住的300个jQuery更改，以便准确地从一个状态过渡到另一个状态。您只需要告诉它现在应该看起来如何。实际上，ReactJS并不会在底层将所有东西都清除；它有相当复杂的功能，可以创建一个闪电般快速的纯JavaScript合成DOM（这个合成DOM也使得在Internet
    Explorer 8中实现HTML5功能成为可能），并协调和进行尽可能快速的更改（在这种情况下，“快速”包括在非JIT iPhone 5上实现每秒60帧的更新的令人印象深刻的壮举）。然而，从概念上讲，使用ReactJS意味着简单地将所有东西都视为被清除并从头开始重新绘制，并信任ReactJS将汇集所有需要的魔法粉来进行最小限度的DOM更改。这是为了根据请求更新页面，可能不会丢失现有的输入或惯性滚动。
- en: ReactJS provides optimization hooks to offer more fine-grained control over
    what is rendered. These are well-documented, but they should rarely be needed.
    Remember Knuth's words, "Premature optimization is the root of all evil." I have
    myself not used this feature for optimization, although the Om bindings in ClojureScript
    for ReactJS are significantly faster because they need only check reference equality
    instead of deep equality as objects are immutable in ClojureScript, although I
    have made a secondary usage, to ask ReactJS to disclaim ownership of some part
    of the DOM so that it will play nicely with third-party functionality. See [Chapter
    11](ch11.html "Chapter 11. Demonstrating Functional Reactive Programming in JavaScript
    with a Live Example Part IV – Adding a Scratchpad and Putting It All Together"),
    *Demonstrating Functional Reactive Programming in JavaScript with a Live Example
    Part IV – Adding a Scratchpad and Putting It All Together* for an example of this
    in action. ReactJS is very performant by default, rather than only in how you
    customize its default behavior.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ReactJS提供了优化钩子，以提供对渲染内容的更精细控制。这些都有很好的文档说明，但实际上很少需要使用。记住Knuth的话，“过早优化是万恶之源。”我自己并没有使用这个优化功能，尽管ClojureScript中用于ReactJS的Om绑定要快得多，因为它们只需要检查引用相等性，而不需要深度相等性，因为在ClojureScript中对象是不可变的，尽管我做了一个次要的用法，要求ReactJS放弃对DOM的某些部分的所有权，以便它能够与第三方功能良好地配合。在[第11章](ch11.html
    "第11章。使用实例演示JavaScript中的函数响应式编程的一部分IV – 添加一个草稿并把它全部放在一起")中，*使用实例演示JavaScript中的函数响应式编程的一部分IV
    – 添加一个草稿并把它全部放在一起*，有一个这样的例子。ReactJS默认情况下非常高效，而不仅仅是在您定制其默认行为方面。
- en: JavaScript as a Domain-specific Language
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript作为一种特定领域的语言。
- en: One widespread practice in templating systems is to provide a DSL for templating.
    In the usual process, such as an underscore on the frontend ([http://underscorejs.org](http://underscorejs.org))
    or Django templating on the backend ([http://djangoproject.com](http://djangoproject.com)),
    there is a carefully chosen but deliberately underpowered templating language
    provided. In Django, for instance, the power is deliberately limited so that templating
    can be handed over to untrusted designers, and there is nothing the designers
    can do that will compromise anything that one would prefer not to be compromised.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 模板系统中的一种广泛实践是为模板提供DSL。在通常的过程中，比如在前端使用underscore（[http://underscorejs.org](http://underscorejs.org)）或在后端使用Django模板（[http://djangoproject.com](http://djangoproject.com)）时，都提供了一个精心选择但故意功能不足的模板语言。例如，在Django中，故意限制了功能，以便将模板交给不受信任的设计师，设计师无法做任何可能损害不希望被损害的任何内容的事情。
- en: This is perhaps an attractive feature, but it speaks of a limited templating
    language. If templating needs something more powerful, they are in a bind until
    any requirements they have are accommodated by nonstandard adjustments on the
    server side. One basic insight, associated with Gödel's incompleteness theorem
    and the halting problem, is that if you tie someone's hands tightly enough so
    that person, in principle, cannot do any damage, you have significantly limited
    what that person is able to do. The best results require at least a little trust.
    If you want people to be able to give their most useful contributions, they probably
    won't be able to do that with their hands bound.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这也许是一个吸引人的特点，但它表明了一种有限的模板语言。如果模板需要更强大的东西，它们将束手无策，直到它们的任何要求都能在服务器端进行非标准调整。与哥德尔的不完备定理和停机问题相关的一个基本观点是，如果你把某人的手绑得足够紧，以至于这个人原则上不能造成任何伤害，你就显著地限制了这个人能做的事情。最好的结果至少需要一点信任。如果你希望人们能够做出最有用的贡献，他们可能不会能够在双手被束缚的情况下做到这一点。
- en: In ReactJS, the DSL for templating is JavaScript, with all its power. Some people
    perhaps find it strange to have designers working on raw JavaScript; The ReactJS
    people seem to have a *give it five minutes* approach (see [http://tinyurl.com/reactjs-five-minutes](http://tinyurl.com/reactjs-five-minutes)),
    and say that designers are smarter than what they are sometimes given credit for
    and are very capable of writing very specific types of JavaScript code. But this
    also means that if you have a special case and your complex situation calls for
    you to do something that was ruled out in some particular—deliberately underpowered—templating
    languages, it is good news. With ReactJS, you have the full power of JavaScript
    for use as you handle templating. With ReactJS, you can also, if you want, use
    a very limited subset of the language used for templating, and Pete Hunt and others
    seem to believe that designers are sharp enough to be able to handle it. But the
    much better news is when you have a difficult need that requires some real power
    to be available. You have as much power as JavaScript offers, and this makes quite
    a difference.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在ReactJS中，模板的DSL是JavaScript，具有其全部功能。有些人也许会觉得让设计师直接使用原始JavaScript很奇怪；ReactJS的人似乎采取了*给它五分钟*的方法，并说设计师比他们有时被认为的更聪明，非常有能力编写非常特定类型的JavaScript代码。但这也意味着，如果你有一个特殊情况，你复杂的情况需要你做一些在某些特定的、故意不够强大的模板语言中被排除的事情，这是个好消息。在ReactJS中，你可以充分利用JavaScript的全部功能来处理模板。在ReactJS中，如果你愿意，你也可以使用一种非常有限的语言子集用于模板，Pete
    Hunt和其他人似乎相信设计师足够聪明，能够处理它。但更好的消息是，当你有一个需要真正强大的困难情况时。你拥有JavaScript提供的全部功能，这会产生很大的不同。
- en: The Big-Coffee Notation
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Big-Coffee Notation
- en: Steve Luscher, a ReactJS guru and enthusiast outside of Facebook who was subsequently
    hired by Facebook, has talked about the Big-Coffee Notation in a video on React.
    The basic insight is that instead of using only the big-O notation for runtime
    complexity (how long the runtime slows down as a function of the rough size of
    a problem, or occasionally other dimensions, such as memory usage), we should
    have a Big-Coffee Notation for what the demands scale for the poor developer,
    who has to keep things in their own poor, caffeinated brain.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Luscher是Facebook之外的ReactJS大师和爱好者，后来被Facebook聘用，他在一段关于React的视频中谈到了Big-Coffee
    Notation。基本观点是，我们不应该只使用大O符号来表示运行时复杂度（运行时随问题规模粗略增长的时间，或者偶尔其他维度，比如内存使用），而是应该有一个Big-Coffee
    Notation来表示对于可怜的开发者来说需求如何增长，他们必须将这些东西保存在自己可怜的、充满咖啡因的大脑中。
- en: 'Gerald Weinberg''s classic book *The Psychology of Computer Programming* works
    out a basic insight at admirable length. The core insight is that *programmers
    programming computers* is not just an activity that involves computers. It''s
    also an activity that involves people, and we would do well to treat it as such.
    Perhaps we should also know the limits of computers, but the human side of this
    is not, in any sense, trivial. Weinberg may have been the first to make this observation,
    or possibly someone else may have made it before him, but in either case, this
    observation has been the bedrock of serious software engineering literature ever
    since it was absorbed. It is a core insight, for instance, in Steve McConnell''s
    *Code Complete: A Practical Handbook of Software Construction*. We will not be
    exploring this idea in full, but it is well worth exploring, especially if you
    haven''t explored it before, and Big-Coffee Notation falls squarely in this court.
    The core idea is that along with tracking the big-O notation or complexity, we
    should also pay attention to how increasingly complex problems scale in terms
    of appropriate demands made by the developer. These demands are in terms of how
    many moving parts need to be kept in one''s head.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Gerald Weinberg的经典著作《计算机编程心理学》详细阐述了一个基本观点。核心观点是*程序员编程计算机*不仅仅是涉及计算机的活动，也是涉及人的活动，我们最好也将其视为这样的活动。也许我们也应该了解计算机的限制，但人类这一方面并不是微不足道的。魏恩伯格可能是第一个提出这一观察的人，或者可能在他之前有人提出过，但无论哪种情况，这一观察自被吸收以来一直是严肃软件工程文献的基石。例如，在Steve
    McConnell的《代码大全：软件构建实用手册》中，这是一个核心观点。我们不会对这个想法进行全面探讨，但它是值得探索的，特别是如果你以前没有探索过的话，Big-Coffee
    Notation正好属于这一领域。核心思想是，除了跟踪大O符号或复杂度，我们还应该关注开发者在适当需求方面如何扩展越来越复杂的问题。这些需求是指需要记住多少移动部分。
- en: In the big-O notation, depending somewhat on the context, there are various
    *runtime complexities* that provide an upper bound to how much the runtime escalates
    when it is given a progressively larger problem to solve. The *O(1)* runtime has
    a fixed upper limit for any use case. *O(log n)* is associated, for instance,
    with unitary operations on certain data structures. *O(n)* is also called **linear**,
    referring to a runtime in which there is a linear upper limit to how much time
    something will take to run. You are guaranteed to be at least as some constant
    multiplied by the number of items. *O(n log n)* may be the next major step up,
    and it is associated with certain sorting algorithms. *O(n ^ 2)* is called **quadratic**
    (all previously mentioned complexities are called subquadratic, which means faster
    than quadratic) and may be taken as a threshold complexity when things really
    do not scale to large volumes. *(O(n * (n – 1))* is also considered to be quadratic
    and is subsumed under *O(n ^ 2)*. After that, there are some slower polynomial
    times and exponentials, without closing the door to still slower escalations,
    such as factorials. The famous question of NP completeness is a question of whether
    certain NP-complete problems, which are known to be solvable in exponential time,
    can also always be solved in some polynomial time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在大O符号表示法中，根据上下文的不同，有各种*运行时复杂度*，它们为运行时间在解决越来越大的问题时提供了一个上限。*O(1)*运行时对于任何用例都有一个固定的上限。*O(log
    n)*与某些数据结构上的单元操作相关。*O(n)*也被称为**线性**，指的是运行时在运行时间上有一个线性的上限。你可以保证至少有一些常数乘以项目的数量。*O(n
    log n)*可能是下一个重要的步骤，它与某些排序算法相关。*O(n ^ 2)*被称为**二次**（所有先前提到的复杂度都被称为次二次，意思是比二次更快），当事情真的不能扩展到大量时，它可能被视为一个阈值复杂度。*(O(n
    * (n – 1))*也被认为是二次，并被包含在*O(n ^ 2)*之下。之后还有一些较慢的多项式时间和指数时间，而不排除还有更慢的升级，比如阶乘。NP完全性的著名问题是一个问题，即某些已知可以在指数时间内解决的NP完全问题是否总是可以在多项式时间内解决。
- en: Steve Luscher's presentation about the difference between an imperative UI and
    a declarative UI is that if someone is making a widget to display the number of
    unread items in their queue, an imperative UI makes one transition between two
    states, making the poor programmer keep track of ![The Big-Coffee Notation](img/B04108_03_02.jpg),
    meaning quadratic or ![The Big-Coffee Notation](img/B04108_03_04.jpg) complexity
    for the number of items in the poor programmer's brain compared to the number
    of states. If there are three states, there are six transitions. If you add a
    fourth state, there will be 12, or twice as many, transitions. Add a fifth state
    and you are looking at twenty transitions. The explanation from the programmer
    to understand the code is *quadratic*, meaning *steep*. However, if you give the
    UI code declaratively, as in ReactJS programming, you describe the code only once
    per possible rendered state. Three states means only three descriptions. Four
    states means only four descriptions. Five states means only five descriptions.
    It's only ![The Big-Coffee Notation](img/B04108_03_03.jpg), or linear. The escalating
    demands the poor programmer's caffeinated brain to keep a track of what goes on
    in the code, which is much less of an escalation to keep track of. Like a fast
    algorithm, it is much less taxing to run.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Steve Luscher关于命令式UI和声明式UI之间的区别的演示是，如果有人要制作一个小部件来显示他们队列中未读项目的数量，命令式UI在两个状态之间进行一次转换，使可怜的程序员需要跟踪![The
    Big-Coffee Notation](img/B04108_03_02.jpg)，这意味着相对于状态数量，程序员大脑中的项目数量呈二次或![The Big-Coffee
    Notation](img/B04108_03_04.jpg)复杂度。如果有三个状态，就有六个转换。如果添加第四个状态，将有12个，或者是两倍的转换。添加第五个状态，你将看到20个转换。程序员理解代码的解释是*二次*，意味着*陡峭*。然而，如果你以声明方式给出UI代码，比如在ReactJS编程中，你只需描述每种可能的渲染状态一次。三种状态只需要三种描述。四种状态只需要四种描述。五种状态只需要五种描述。这只是![The
    Big-Coffee Notation](img/B04108_03_03.jpg)，或者是线性的。对于可怜的程序员的咖啡因大脑来说，这种不断升级的需求来跟踪代码发生的事情要少得多。就像一个快速的算法一样，运行起来要少得多。
- en: 'I haven''t heard of Dijkstra''s *The Humble Programmer* being referenced by
    the ReactJS community, but intellectual humility is a virtue among programmers
    and has been recognized as such in software engineering literature for a long
    time. It is emphasized in classics such as *Code Complete: A Practical Handbook
    of Software Construction*, and programmers are divided, not among those who have
    big and little minds, but those who know that they have little minds and those
    who have little minds but are heedless of it. Excellence in programming partly
    stems from recognition of one''s own cognitive limits. Dijkstra writes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有听说过Dijkstra的《谦逊的程序员》被ReactJS社区引用过，但在程序员中，知识谦卑是一种美德，并且在软件工程文献中长期以来一直被认可。它在经典著作中得到强调，比如《代码大全：软件构建的实用手册》，程序员们并不是分为大脑和小脑，而是分为知道自己有小脑的人和有小脑但不自知的人。编程的卓越部分源于对自己认知限制的认识。Dijkstra写道：
- en: '*The competent programmer is fully aware of the strictly limited size of his
    own skull; therefore he approaches the programming task in full humility, and
    among other things he avoids clever tricks like the plague. In the case of a well-known
    conversational programming language I have been told from various sides that as
    soon as a programming community is equipped with a terminal for it, a specific
    phenomenon occurs that even has a well-established name: it is called "the one-liners".
    It takes one of two different forms: one programmer places a one-line program
    on the desk of another and either he proudly tells what it does and adds the question
    "Can you code this in less symbols?" —as if this were of any conceptual relevance!—
    or he just asks "Guess what it does!". From this observation we must conclude
    that this language as a tool is an open invitation for clever tricks; and while
    exactly this may be the explanation for some of its appeal, viz. to those who
    like to show how clever they are, I am sorry, but I must regard this as one of
    the most damning things that can be said about a programming language…*'
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “胜任的程序员充分意识到自己头脑的严格有限；因此，他以完全谦卑的态度对待编程任务，而且在其他方面，他像瘟疫一样避开了聪明的把戏。在一个众所周知的对话式编程语言的情况下，我从各个方面听说，一旦一个编程社区配备了它的终端，就会出现一个特定的现象，甚至已经有了一个成熟的名字：它被称为“一行代码”。它有两种不同的形式：一个程序员把一行程序放在另一个程序员的桌子上，要么他自豪地告诉它做什么，然后问“你能用更少的符号编码吗？”——好像这对概念有任何重要性一样！——要么他只是问“猜猜它是做什么的！”。从这个观察中，我们必须得出结论，这种语言作为一种工具是聪明把戏的一个开放邀请；虽然这可能是它吸引力的解释之一，即对那些喜欢展示自己有多聪明的人来说，但很抱歉，我必须把这看作是对编程语言说的最严厉的话之一……*
- en: 'This challenge, namely the confrontation with the programming task, has already
    taught us a few lessons, and the one I have chosen to stress in this talk is the
    following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战，也就是面对编程任务，已经教会了我们一些经验教训，我选择在这次讲话中强调的是：
- en: '*We shall do a much better programming job, provided that we approach the task
    with a full appreciation of its tremendous difficulty, provided that we stick
    to modest and elegant programming languages, provided that we respect the intrinsic
    limitations of the human mind and approach the task as *very humble programmers*.*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们将做得更好的编程工作，只要我们以充分的欣赏其巨大困难的态度来对待这项任务，只要我们坚持使用适度和优雅的编程语言，只要我们尊重人类思维的固有局限，并以非常谦卑的程序员的态度来对待这项任务。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We just took a whirlwind tour of some of the theory surrounding reactive programming
    with ReactJS. This includes declarative programming, one of the selling points
    of ReactJS that offers something easier to work with at the end than imperative
    programming. The war on heisenbugs, is an overriding concern surrounding decisions
    made by Facebook, including ReactJS. This takes place through Facebook's declared
    war on the shared mutable state. The Flux Architecture is used by Facebook with
    ReactJS to avoid some nasty classes of bugs. The pit of success and the pit of
    despair, which learns from others' pain, a pain that is concentrated in connection
    to the C++ programming language, and looks at what we should be aiming for.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚快速浏览了一些围绕使用ReactJS进行响应式编程的理论。这包括声明式编程，这是ReactJS的卖点之一，它提供了比命令式编程更容易处理的东西。Heisenbugs的战争是Facebook所做决定的一个主要关注点，包括ReactJS。这是通过Facebook宣布对共享可变状态的战争来实现的。Flux架构被Facebook与ReactJS一起使用，以避免一些恶心的bug类。成功的陷阱和绝望的陷阱，从他人的痛苦中学习，这种痛苦集中在与C++编程语言的联系上，并且看看我们应该追求什么。
- en: We covered complete UI teardowns and rebuilds, providing a simple alternative
    to keeping track of the state in how to update an interface. We also saw JavaScript
    as a DSL, looking at an intentional decision in designing ReactJS that is meant
    to give you as much power as you need. Then the Big-Coffee Notation was discussed
    in relation to a healthy recognition of one's own limits instead of them breaking
    their shins, which is preventable.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了完整的UI拆卸和重建，提供了一个简单的替代方案来跟踪状态以更新界面。我们还将JavaScript作为DSL，看作是设计ReactJS的一个有意的决定，旨在给你尽可能多的权力。然后讨论了大咖啡符号与健康认识自己的限制的关系，而不是让他们摔断腿，这是可以预防的。
- en: In our next chapter, we will continue by looking at a concrete case of a user
    interface built with ReactJS.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一章中，我们将继续通过查看使用ReactJS构建的用户界面的具体案例来进行讨论。
