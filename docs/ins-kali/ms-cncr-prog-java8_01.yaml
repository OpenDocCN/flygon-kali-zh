- en: Chapter 1. The First Step – Concurrency Design Principles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。第一步-并发设计原则
- en: 'Users of computer systems are always looking for better performance for their
    systems. They want to get higher quality videos, better video games, and faster
    network speed. Some years ago, processors gave better performance to users by
    increasing their speed. But now, processors don''t increase their speed. Instead
    of this, they add more cores so that the operating system can execute more than
    one task at a time. This is named **concurrency**. Concurrent programming includes
    all the tools and techniques to have multiple tasks or processes running at the
    same time in a computer, communicating and synchronizing between them without
    data loss or inconsistency. In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统的用户总是在寻求系统的更好性能。他们希望获得更高质量的视频、更好的视频游戏和更快的网络速度。几年前，处理器通过提高速度为用户提供了更好的性能。但现在，处理器不再提高速度。相反，它们增加了更多的核心，以便操作系统可以同时执行多个任务。这被称为并发。并发编程包括所有工具和技术，以便在计算机中同时运行多个任务或进程，它们之间进行通信和同步，而不会丢失数据或不一致。在本章中，我们将涵盖以下主题：
- en: Basic concurrency concepts
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本并发概念
- en: Possible problems in concurrent applications
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发应用中可能出现的问题
- en: A methodology to design concurrent algorithms
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计并发算法的方法论
- en: The Java concurrency API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java并发API
- en: The Java memory model
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java内存模型
- en: Concurrency design patterns
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发设计模式
- en: Tips and tricks to design concurrency algorithms
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计并发算法的技巧和窍门
- en: Basic concurrency concepts
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本并发概念
- en: First of all, let's present the basic concepts of concurrency. You must understand
    these concepts to follow the rest of the book.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们介绍并发的基本概念。你必须理解这些概念才能继续阅读本书的其余部分。
- en: Concurrency versus parallelism
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发与并行
- en: Concurrency and parallelism are very similar concepts. Different authors give
    different definitions to these concepts. The most accepted definition talks about
    concurrency when you have more than one task in a single processor with a single
    core and the operating system's task scheduler quickly switches from one task
    to another, so it seems that all the tasks run simultaneously. The same definition
    talks about parallelism when you have more than one task that run simultaneously
    at the same time, in a different computer, processor, or core inside a processor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 并发和并行是非常相似的概念。不同的作者对这些概念给出了不同的定义。最被接受的定义是，当你在单个处理器上有多个任务，并且操作系统的任务调度程序快速地从一个任务切换到另一个任务时，就会出现并发，因此似乎所有任务都在同时运行。同样的定义也提到，当你有多个任务在不同的计算机、处理器或处理器内的不同核心上同时运行时，就会出现并行。
- en: Another definition talks about concurrency when you have more than one task
    (different tasks) running simultaneously on your system. One more definition discusses
    parallelism when you have different instances of the same task running simultaneously
    over different parts of a dataset.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个定义提到，当你的系统上有多个任务（不同的任务）同时运行时，就会出现并发。另一个定义讨论了当你在数据集的不同部分上同时运行相同任务的不同实例时，就会出现并行。
- en: The last definition that we include talks about parallelism when you have more
    than one task that runs simultaneously in your system and talks about concurrency
    to explain the different techniques and mechanisms programmers have to synchronize
    with the tasks and their access to shared resources.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含的最后一个定义提到，当你的系统中有多个任务同时运行时，就会出现并行，并且提到并发来解释程序员们用来与任务同步和访问共享资源的不同技术和机制。
- en: As you can see, both concepts are very similar and this similarity has increased
    with the development of multicore processors.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这两个概念非常相似，并且随着多核处理器的发展，这种相似性已经增加。
- en: Synchronization
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: 'In concurrency, we can define **synchronization** as the coordination of two
    or more tasks to get the desired results. We have two kinds of synchronization:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发中，我们可以将同步定义为协调两个或多个任务以获得期望的结果。我们有两种同步方式：
- en: '**Control synchronization**: When, for example, one task depends on the end
    of another task, the second task can''t start before the first has finished'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制同步：例如，一个任务依赖于另一个任务的结束，第二个任务在第一个任务完成之前不能开始
- en: '**Data access synchronization**: When two or more tasks have access to a shared
    variable and only one of the tasks can access the variable at any given time'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据访问同步：当两个或更多任务访问共享变量，且在任何给定时间只有一个任务可以访问该变量
- en: A concept closely related to synchronization is **critical section**. A critical
    section is a piece of code that can be only executed by a task at any given time
    because of its access to a shared resource. **Mutual exclusion** is the mechanism
    used to guarantee this requirement and can be implemented by different ways.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步密切相关的一个概念是关键部分。关键部分是一段代码，因为其对共享资源的访问，只能由一个任务在任何给定时间执行。互斥是用来保证这一要求的机制，并且可以通过不同的方式实现。
- en: Keep in mind that synchronization helps you avoid some errors you can have with
    concurrent tasks (they will be described later in this chapter), but it introduces
    some overhead to your algorithm. You have to calculate very carefully the number
    of tasks, which can be performed independently without intercommunication in your
    parallel algorithm. It's the **granularity** of your concurrent algorithm. If
    you have a **coarse-grained granularity** (big tasks with low intercommunication),
    the overhead due to synchronization will be low. However, maybe you won't benefit
    all the cores of your system. If you have a **fine-grained granularity** (small
    tasks with high intercommunication), the overhead due to synchronization will
    be high and maybe the throughput of your algorithm won't be good.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，同步可以帮助你避免一些并发任务可能出现的错误（它们将在本章后面描述），但它会给你的算法引入一些开销。你必须非常仔细地计算可以在并行算法中独立执行而不需要相互通信的任务数量。这就是你并发算法的**粒度**。如果你有**粗粒度的粒度**（大任务低相互通信），同步的开销会很低。然而，也许你无法充分利用系统的所有核心。如果你有**细粒度的粒度**（高相互通信的小任务），同步的开销会很高，也许你的算法的吞吐量不会很好。
- en: 'There are different mechanisms to get synchronization in a concurrent system.
    The most popular mechanisms from a theoretical point of view are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发系统中有不同的机制来实现同步。从理论上讲，最流行的机制有：
- en: '**Semaphore**: A semaphore is a mechanism that can be used to control the access
    to one or more units of a resource. It has a variable that stores the number of
    resources that can be used and two atomic operations to manage the value of the
    variable. A **mutex** (short for **mutual exclusion**) is a special kind of semaphore
    that can take only two values (*resource is free* and *resource is busy*), and
    only the process that sets the mutex to *busy* can release it.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号量**：信号量是一种可以用来控制对一个或多个资源单元的访问的机制。它有一个变量来存储可以使用的资源数量，以及两个原子操作来管理变量的值。**互斥锁**（**mutual
    exclusion**的缩写）是一种特殊类型的信号量，它只能取两个值（*资源空闲*和*资源忙碌*），只有设置互斥锁为*忙碌*的进程才能释放它。'
- en: '**Monitor**: A monitor is a mechanism to get mutual exclusion over a shared
    resource. It has a mutex, a condition variable, and two operations to wait for
    the condition and to signal the condition. Once you signal the condition, only
    one of the tasks that are waiting for it continues with its execution.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**：监视器是一种获得共享资源的互斥的机制。它有一个互斥锁、一个条件变量和两个等待条件和信号条件的操作。一旦你发出条件，只有一个等待它的任务可以继续执行。'
- en: The last concept related to synchronization you're going to learn in this chapter
    is **thread safety**. A piece of code (or a method or an object) is **thread-safe**
    if all the users of shared data are protected by synchronization mechanisms, a
    nonblocking **compare-and-swap** (**CAS**) primitive or data is immutable, so
    you can use that code in a concurrent application without any problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 与同步相关的最后一个概念是**线程安全**。如果所有共享数据的用户都受到同步机制的保护，非阻塞的**比较和交换**（**CAS**）原语或数据是不可变的，那么一段代码（或一个方法或一个对象）就是**线程安全**的，这样你就可以在并发应用中使用该代码而不会出现任何问题。
- en: Immutable object
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不可变对象
- en: An **immutable object** is an object with a very special characteristic. You
    can't modify its visible state (the value of its attributes) after its initialization.
    If you want to modify an immutable object, you have to create a new one.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变对象**是一个具有非常特殊特性的对象。在初始化后，你不能修改它的可见状态（属性的值）。如果你想修改一个不可变对象，你必须创建一个新的对象。'
- en: Its main advantage is that it is thread-safe. You can use it in concurrent applications
    without any problem.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它的主要优点是它是线程安全的。你可以在并发应用中使用它而不会出现任何问题。
- en: An example of an immutable object is the `String` class in Java. When you assign
    a new value to a `String` object, you are creating a new string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变对象的一个例子是Java中的`String`类。当你给一个`String`对象赋一个新值时，你实际上是创建了一个新的字符串。
- en: Atomic operations and variables
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子操作和变量
- en: An **atomic operation** is a kind of operation that appears to occur instantaneously
    to the rest of the tasks of the program. In a concurrent application, you can
    implement an atomic operation with a critical section to the whole operation using
    a synchronization mechanism.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子操作**是一种看起来对程序的其他任务瞬间发生的操作。在并发应用中，你可以使用同步机制来实现一个原子操作的整个操作。'
- en: An **atomic variable** is a kind of variable with atomic operations to set and
    get its value. You can implement an atomic variable using a synchronization mechanism
    or in a lock-free manner using CAS, which doesn't need any synchronization.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**原子变量**是一种具有原子操作来设置和获取其值的变量。你可以使用同步机制来实现原子变量，或者使用不需要任何同步的CAS来以无锁的方式实现原子变量。'
- en: Shared memory versus message passing
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共享内存与消息传递
- en: Tasks can use two different methods to communicate with each other. The first
    one is **shared memory,** and normally it is used when the tasks are running in
    the same computer. The tasks use the same memory area where they write and read
    values. To avoid problems, the access to this shared memory has to be in a critical
    section protected by a synchronization mechanism.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 任务可以使用两种不同的方法来相互通信。第一种是**共享内存**，通常在任务在同一台计算机上运行时使用。任务使用相同的内存区域来写入和读取值。为了避免问题，对这个共享内存的访问必须在由同步机制保护的临界区域内。
- en: The other synchronization mechanism is **message passing** and normally is used
    when the tasks are running in different computers. When a task needs to communicate
    with another, it sends a message that follows a predefined protocol. This communication
    can be synchronous if the sender is blocked waiting for a response or asynchronous
    if the sender continues with their execution after sending the message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个同步机制是**消息传递**，通常在任务在不同计算机上运行时使用。当一个任务需要与另一个任务通信时，它发送遵循预定义协议的消息。这种通信可以是同步的，如果发送者被阻塞等待响应，或者是异步的，如果发送者在发送消息后继续执行。
- en: Possible problems in concurrent applications
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发应用程序中可能出现的问题
- en: Programming a concurrent application is not an easy job. If you incorrectly
    use the synchronization mechanisms, you can have different problems with the tasks
    in your application. In this section, we describe some of these problems.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 编写并发应用程序并不是一件容易的工作。如果您错误地使用同步机制，您的应用程序中的任务可能会出现不同的问题。在本节中，我们描述了其中一些问题。
- en: Data race
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据竞争
- en: You can have a **data race** (also named **race condition**) in your application
    when you have two or more tasks writing a shared variable outside a critical section—that's
    to say, without using any synchronization mechanisms.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，当有两个或更多任务在没有使用任何同步机制的情况下写入共享变量时，您可能会发生数据竞争（也称为竞争条件）。
- en: 'Under these circumstances, the final result of your application may depend
    on the order of execution of the tasks. Look at the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您的应用程序的最终结果可能取决于任务的执行顺序。看下面的例子：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Imagine that two different tasks execute the `modify()` method in the same `Account`
    object. Depending on the order of execution of the sentences in the tasks, the
    final result can vary. Suppose that the initial balance is 1000 and the two tasks
    call the `modify()` method with 1000 as a parameter. The final result should be
    3000, but if both tasks execute the first sentence at the same time and then the
    second sentence at the same time, the final result will be 2000\. As you can see,
    the `modify()` method is not atomic and the `Account` class is not thread-safe.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，两个不同的任务在同一个“Account”对象中执行“modify（）”方法。根据任务中句子的执行顺序，最终结果可能会有所不同。假设初始余额为1000，两个任务都使用1000作为参数调用“modify（）”方法。最终结果应该是3000，但是如果两个任务同时执行第一句，然后同时执行第二句，最终结果将是2000。正如您所看到的，“modify（）”方法不是原子的，“Account”类也不是线程安全的。
- en: Deadlock
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 死锁
- en: 'There is a **deadlock** in your concurrent application when there are two or
    more tasks waiting for a shared resource that must be free from the other, so
    none of them will get the resources they need and will be blocked indefinitely.
    It happens when four conditions happen simultaneously in the system. They are
    **Coffman''s conditions**, which are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的并发应用程序中存在**死锁**，当有两个或更多任务等待必须从其他任务中释放的共享资源时，因此它们都无法获得所需的资源并将被无限期地阻塞。它发生在系统中同时发生四个条件。它们是**Coffman的条件**，如下所示：
- en: '**Mutual exclusion**: The resources involved in the deadlock must be nonshareable.
    Only one task can use the resource at a time.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互斥排斥：死锁中涉及的资源必须是不可共享的。一次只有一个任务可以使用资源。
- en: '**Hold and wait condition**: A task has the mutual exclusion for a resource
    and it''s requesting the mutual exclusion for another resource. While it''s waiting,
    it doesn''t release any resources.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持有和等待条件：一个任务拥有一个资源的互斥，并且正在请求另一个资源的互斥。在等待时，它不会释放任何资源。
- en: '**No pre-emption**: The resources can only be released by the tasks that hold
    them.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可抢占：资源只能由持有它们的任务释放。
- en: '**Circular wait**: There is a circular waiting where Task 1 is waiting for
    a resource that is being held by Task 2, which is waiting for a resource being
    held by Task 3, and so on until we have Task *n* that is waiting for a resource
    being held by Task 1.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环等待：任务1正在等待任务2持有的资源，而任务2正在等待任务3持有的资源，依此类推，直到有任务n等待任务1持有的资源。
- en: 'There exist some mechanisms that you can use to avoid deadlocks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些机制可以用来避免死锁：
- en: '**Ignore them**: This is the most commonly used mechanism. You suppose that
    a deadlock will never occur on your system, and if it occurs, you can see the
    consequences of stopping your application and having to re-execute it.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略它们：这是最常用的机制。您假设在您的系统上永远不会发生死锁，如果发生了，您可以看到停止应用程序的后果，并不得不重新执行它。
- en: '**Detection**: The system has a special task that analyzes the state of the
    system to detect if a deadlock has occurred. If it detects a deadlock, it can
    take action to remedy the problem. For example, finishing one task or forcing
    the liberation of a resource.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测：系统有一个特殊的任务，分析系统的状态以检测是否发生了死锁。如果它检测到死锁，它可以采取行动来解决问题。例如，完成一个任务或强制释放资源。
- en: '**Prevention**: If you want to prevent deadlocks in your system, you have to
    prevent one or more of Coffman''s conditions.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预防：如果您想要在系统中预防死锁，您必须预防Coffman的一个或多个条件。
- en: '**Avoidance**: Deadlocks can be avoided if you have information about the resources
    that are used by a task before it begins its execution. When a task wants to start
    its execution, you can analyze the resources that are free in the system and the
    resources that the task needs to decide that it can start its execution or not.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免：如果您在任务开始执行之前了解使用的资源的信息，可以避免死锁。当任务想要开始执行时，您可以分析系统中空闲的资源以及任务需要的资源，以决定它是否可以开始执行。
- en: Livelock
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活锁
- en: A **livelock** occurs when you have two tasks in your systems that are always
    changing their states due to the actions of the other. Consequently, they are
    in a loop of state changes and unable to continue.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的系统中有两个任务始终由于对方的操作而改变其状态时，就会发生**活锁**。因此，它们处于状态更改循环中，无法继续。
- en: 'For example, you have two tasks—Task 1 and Task 2—and both need two resources:
    Resource 1 and Resource 2\. Suppose that Task 1 has a lock on Resource 1, and
    Task 2 has a lock on Resource 2\. As they are unable to gain access to the resource
    they need, they free their resources and begin the cycle again. This situation
    can continue indefinitely, so the tasks will never end their execution.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您有两个任务——任务1和任务2——都需要两个资源：资源1和资源2。假设任务1锁定了资源1，任务2锁定了资源2。由于它们无法获得所需的资源，它们释放资源并重新开始循环。这种情况可能无限期地持续下去，因此任务永远不会结束执行。
- en: Resource starvation
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源匮乏
- en: '**Resource starvation** occurs when you have a task in your system that never
    gets a resource that it needs to continue with its execution. When there is more
    than one task waiting for a resource and the resource is released, the system
    has to choose the next task that can use it. If your system has not got a good
    algorithm, it can have threads that are waiting for a long time for the resource.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**资源饥饿**发生在系统中有一个任务永远无法获得需要继续执行的资源时。当有多个任务等待资源并且资源被释放时，系统必须选择下一个可以使用它的任务。如果你的系统没有一个好的算法，可能会有线程长时间等待资源。'
- en: '**Fairness** is the solution to this problem. All the tasks that are waiting
    for a resource must have the resource in a given period of time. An option is
    to implement an algorithm that takes into account the time that a task has been
    waiting for a resource when it chooses the next task that will hold a resource.
    However, fair implementation of locks requires additional overhead, which may
    lower your program throughput.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**公平性**是解决这个问题的方法。所有等待资源的任务必须在一定时间内获得资源。一种选择是实现一个算法，考虑任务等待资源的时间，以选择下一个将持有资源的任务。然而，公平实现锁需要额外的开销，可能会降低程序的吞吐量。'
- en: Priority inversion
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先级反转
- en: '**Priority inversion** occurs when a low-priority task holds a resource that
    is needed by a high-priority task, so the low-priority task finishes its execution
    before the high-priority task.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**优先级反转**发生在低优先级任务持有高优先级任务需要的资源时，因此低优先级任务在高优先级任务之前完成执行。'
- en: A methodology to design concurrent algorithms
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计并发算法的方法论
- en: 'In this section, we''re going to propose a five-step methodology to get a concurrent
    version of a sequential algorithm. It''s based on the one presented by Intel in
    their *Threading Methodology: Principles and Practices* document.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将提出一个五步方法论，以获得顺序算法的并发版本。这是基于英特尔在其《线程方法论：原理与实践》文档中提出的方法。
- en: The starting point – a sequential version of the algorithm
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 起点 - 算法的顺序版本
- en: 'Our starting point to implement a concurrent algorithm will be a sequential
    version of it. Of course, we can design a concurrent algorithm from scratch, but
    I think that a sequential version of the algorithm will give us two advantages:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现并发算法的起点将是它的顺序版本。当然，我们可以从头开始设计一个并发算法，但我认为算法的顺序版本会给我们带来两个优势：
- en: We can use the sequential algorithm to test if our concurrent algorithm generates
    correct results. Both algorithms must generate the same output when they receive
    the same input, so we can detect some problems in the concurrent version, such
    as data races or similar conditions.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用顺序算法来测试我们的并发算法是否生成正确的结果。当它们接收相同的输入时，两个算法必须生成相同的输出，这样我们可以检测并发版本中的一些问题，比如数据竞争或类似的情况。
- en: We can measure the throughput of both algorithms to see if the use of concurrency
    gives us a real improvement in the response time or in the amount of data the
    algorithm can process in a time.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以测量两种算法的吞吐量，看看并发使用是否真的能在响应时间或算法在一定时间内处理的数据量方面给我们带来真正的改进。
- en: Step 1 – analysis
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一步 - 分析
- en: In this step, we are going to analyze the sequential version of the algorithm
    to look for the parts of its code that can be executed in a parallel way. We should
    pay special attention to those parts that are executed most of the time or that
    execute more code because, by implementing a concurrent version of those parts,
    we're going to get a greater performance improvement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一步中，我们将分析算法的顺序版本，寻找可以以并行方式执行的代码部分。我们应该特别注意那些大部分时间执行或执行更多代码的部分，因为通过实现这些部分的并发版本，我们将获得更大的性能改进。
- en: Good candidates for this process are loops where one step is independent of
    the other steps or portions of code that are independent of other parts of the
    code (for example, an algorithm to initialize an application that opens the connections
    with the database, loads the configuration files, initialize some objects. All
    the previous tasks are independent of each other).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程的好候选者是循环，其中一个步骤独立于其他步骤，或者代码的部分独立于代码的其他部分（例如，初始化应用程序的算法，打开与数据库的连接，加载配置文件，初始化一些对象。所有前面的任务彼此独立）。
- en: Step 2 – design
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二步 - 设计
- en: Once you know what parts of the code you are going to parallelize, you have
    to decide how to do that parallelization.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你知道要并行化的代码部分，你必须决定如何进行并行化。
- en: 'The changes in the code will affect two main parts of the application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的变化将影响应用程序的两个主要部分：
- en: The structure of the code
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码结构
- en: The organization of the data structures
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构的组织
- en: 'You can take two different approaches to accomplish this task:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取两种不同的方法来完成这个任务：
- en: '**Task decomposition**: You do task decomposition when you split the code in
    two or more independent tasks that can be executed at once. Maybe some of these
    tasks have to be executed in a given order or have to wait at the same point.
    You must use synchronization mechanisms to get this behavior.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**任务分解**：当你将代码分割成两个或更多独立的任务可以同时执行时，你进行任务分解。也许其中一些任务必须按照给定的顺序执行，或者必须在同一点等待。你必须使用同步机制来实现这种行为。'
- en: '**Data decomposition**: You do data decomposition when you have multiple instances
    of the same task that work with a subset of the dataset. This dataset will be
    a shared resource, so if the tasks need to modify the data you have to protect
    access to it by implementing a critical section.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分解**：当你有多个相同任务的实例，它们使用数据集的一个子集时，你进行数据分解。这个数据集将是一个共享资源，所以如果任务需要修改数据，你必须通过实现临界区来保护对它的访问。'
- en: Another important point to keep in mind is the granularity of your solution.
    The objective of implementing a parallel version of an algorithm is to achieve
    improved performance, so you should use all the available processors or cores.
    On the other hand, when you use a synchronization mechanism, you introduce some
    extra instructions that must be executed. If you split the algorithm into a lot
    of small tasks (fine-grained granularity), the extra code introduced by the synchronization
    can provoke performance degradation. If you split the algorithm into fewer tasks
    than cores (coarse-grained granularity), you are not taking advantage of all the
    resources. Also, you must take into account the work every thread must do, especially
    if you implement a fine-grained granularity. If you have a task longer than the
    rest, that task will determine the execution time of the application. You have
    to find the equilibrium between these two points.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的要点是要记住您解决方案的粒度。实现算法的并行版本的目标是实现改进的性能，因此您应该使用所有可用的处理器或核心。另一方面，当您使用同步机制时，您会引入一些必须执行的额外指令。如果您将算法分解为许多小任务（细粒度粒度），同步引入的额外代码可能导致性能下降。如果您将算法分解为少于核心数的任务（粗粒度粒度），则没有充分利用所有资源。此外，您必须考虑每个线程必须执行的工作，特别是如果您实现了细粒度粒度。如果您有一个比其他任务更长的任务，该任务将决定应用程序的执行时间。您必须在这两个点之间找到平衡。
- en: Step 3 – implementation
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3步 - 实现
- en: The next step is to implement the parallel algorithm using a programming language
    and, if it's necessary, a thread library. In the examples of this book, you are
    going to use Java to implement all the algorithms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用编程语言和（如果必要）线程库实现并行算法。在本书的示例中，您将使用Java来实现所有算法。
- en: Step 4 – testing
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第4步 - 测试
- en: After finishing the implementation, you have to test the parallel algorithm.
    If you have a sequential version of the algorithm, you can compare the results
    of both algorithms to verify that your parallel implementation is correct.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成实现后，您必须测试并行算法。如果您有算法的顺序版本，您可以比较两种算法的结果以验证您的并行实现是否正确。
- en: Testing and debugging a parallel implementation are difficult tasks because
    the order of execution of the different tasks of the application is not guaranteed.
    In [Chapter 11](part0063_split_000.html#1S2JE2-2fff3d3b99304faa8fa9b27f1b5053ba
    "Chapter 11. Testing and Monitoring Concurrent Applications"), *Testing and Monitoring
    Concurrent Applications*, you will learn tips, tricks, and tools to do these tasks
    efficiently.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 测试和调试并行实现是困难的任务，因为应用程序的不同任务的执行顺序不能保证。在[第11章](part0063_split_000.html#1S2JE2-2fff3d3b99304faa8fa9b27f1b5053ba
    "第11章。测试和监视并发应用程序")中，*测试和监视并发应用程序*，您将学习到有效执行这些任务的技巧和工具。
- en: Step 5 – tuning
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5步 - 调优
- en: The last step is to compare the throughput of the parallel and the sequential
    algorithms. If the results are not as expected, you must review the algorithm,
    looking for the cause of the bad performance of the parallel algorithm.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是比较并行和顺序算法的吞吐量。如果结果不如预期，您必须检查算法，寻找并行算法性能不佳的原因。
- en: You can also test different parameters of the algorithm (for example, granularity
    or number of tasks) to find the best configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以测试算法的不同参数（例如，粒度或任务数量）以找到最佳配置。
- en: 'There are different metrics to measure the possible performance improvement
    you can obtain parallelizing an algorithm. The three most popular metrics are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的指标来衡量并行化算法可能获得的性能改进。最流行的三个指标是：
- en: '**Speedup**: This is a metric for relative performance improvement between
    the parallel and the sequential versions of the algorithm:![Step 5 – tuning](img/00002.jpeg)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速比**：这是衡量并行和顺序算法版本之间相对性能改进的指标：![第5步 - 调优](img/00002.jpeg)'
- en: Here, *T* *[sequential]* is the execution time of the sequential version of
    the algorithm and *T* *[concurrent]* is the execution time of the parallel version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*T* *[顺序]* 是顺序算法版本的执行时间，*T* *[并发]* 是并行版本的执行时间。
- en: '**Amdahl''s law**: This is used to calculate the maximum expected improvement
    obtained with the parallelization of an algorithm:![Step 5 – tuning](img/00003.jpeg)'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阿姆达尔定律**：这用于计算通过算法并行化获得的最大预期改进：![第5步 - 调优](img/00003.jpeg)'
- en: Here, *P* is the percentage of code that can be parallelized and *N* is the
    number of cores of the computer where you're going to execute the algorithm.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*P*是可以并行化的代码的百分比，*N*是您将执行算法的计算机的核心数。
- en: 'For example, if you can parallelize 75% of the code and you have four cores,
    the maximum speedup will be given by the following formula:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您可以并行化75%的代码并且您有四个核心，最大加速比将由以下公式给出：
- en: '![Step 5 – tuning](img/00004.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![第5步 - 调优](img/00004.jpeg)'
- en: '**Gustafson-Barsis'' law**: Amdahl''s law has a limitation. It supposes that
    you have the same input dataset when you increase the number of cores, but normally,
    when you have more cores, you want to process more data. Gustafson law proposes
    that when you have more cores available, bigger problems can be solved in the
    same time using the following formula:![Step 5 – tuning](img/00005.jpeg)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**古斯塔夫森-巴西斯定律**：阿姆达尔定律有一个限制。它假设在增加核心数时，您拥有相同的输入数据集，但通常，当您拥有更多核心时，您希望处理更多数据。古斯塔夫森定律提出，当您有更多可用的核心时，可以使用以下公式在相同时间内解决更大的问题：![第5步
    - 调优](img/00005.jpeg)'
- en: Here, *N* is the number of cores and *P* is the percentage of parallelizable
    code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，*N*是核心数，*P*是可并行化代码的百分比。
- en: 'If we use the same example as before, the scaled speedup calculated by the
    Gustafson law is:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用与之前相同的示例，由古斯塔夫森定律计算得出的加速比为：
- en: '![Step 5 – tuning](img/00006.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![第5步 - 调优](img/00006.jpeg)'
- en: Conclusion
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结论
- en: In this section, you learned some important issues you have to take into account
    when you want to parallelize a sequential algorithm.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，您学习了在想要并行化顺序算法时必须考虑的一些重要问题。
- en: First of all, not every algorithm can be parallelized. For example, if you have
    to execute a loop where the result of an iteration depends on the result of the
    previous iteration, you can't parallelize that loop. Recurrent algorithms are
    another example of algorithms that can be parallelized for a similar reason.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，不是每个算法都可以并行化。例如，如果你必须执行一个循环，其中迭代的结果取决于前一次迭代的结果，那么你无法并行化该循环。递归算法是另一个例子，由于类似的原因可以并行化。
- en: Another important thing you have to keep in mind is that the sequential version
    of an algorithm with better performance can be a bad starting point to parallelize
    it. If you start parallelizing an algorithm and you find yourself in trouble because
    you don't easily find independent portions of the code, you have to look for other
    versions of the algorithm and verify that the version can be parallelized in an
    easier way.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，性能更好的顺序算法的顺序版本可能不是并行化的一个好的起点。如果你开始并行化一个算法，并且发现自己陷入困境，因为你不容易找到代码的独立部分，你必须寻找算法的其他版本，并验证该版本是否可以更容易地并行化。
- en: 'Finally, when you implement a concurrent application (from scratch or based
    on a sequential algorithm), you must take into account the following points:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当你实现一个并发应用程序（从头开始或基于顺序算法），你必须考虑以下几点：
- en: '**Efficiency**: The parallel algorithm must end in less time than the sequential
    algorithm. The first goal of parallelizing an algorithm is that its running time
    is less than the sequential one, or it can process more data in the same time.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：并行算法必须在比顺序算法更短的时间内结束。并行化算法的第一个目标是其运行时间比顺序算法短，或者它可以在相同的时间内处理更多的数据。'
- en: '**Simplicity**: When you implement an algorithm (parallel or not), you must
    keep it as simple as possible. It will be easier to implement, test, debug, and
    maintain, and it will have fewer errors.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：当你实现一个算法（并行或非并行）时，你必须尽量保持简单。这样更容易实现、测试、调试和维护，而且错误更少。'
- en: '**Portability**: Your parallel algorithm should be executed on different platforms
    with minimal changes. As in this book you will use Java, this point will be very
    easy. With Java, you can execute your programs in every operating system without
    any change (if you implement the program as you must).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：你的并行算法应该在不同的平台上执行，只需进行最小的更改。在本书中你将使用Java，这一点将非常容易。使用Java，你可以在每个操作系统上执行你的程序，而不需要任何更改（如果你按照必须的方式实现程序）。'
- en: '**Scalability**: What happens to your algorithm if you increase the number
    of cores? As mentioned before, you should use all the available cores, so your
    algorithm should be ready to take advantage of all available resources.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果增加核心的数量，你的算法会发生什么？如前所述，你应该使用所有可用的核心，因此你的算法应该准备利用所有可用的资源。'
- en: Java concurrency API
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java并发API
- en: The Java programming language has a very rich concurrency API. It contains classes
    to manage the basic elements of concurrency, such as `Thread`, `Lock`, and `Semaphore`,
    and classes that implement very high-level synchronization mechanisms, such as
    the **executor framework** or the new parallel `Stream` API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Java编程语言拥有非常丰富的并发API。它包含了管理并发的基本元素的类，如`Thread`、`Lock`和`Semaphore`，以及实现非常高级的同步机制的类，如**执行器框架**或新的并行`Stream`API。
- en: In this section, we will cover the basic classes that form the concurrency API.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍构成并发API的基本类。
- en: Basic concurrency classes
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的并发类
- en: 'The basic classes of the Java concurrency API are:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API的基本类包括：
- en: 'The `Thread` class: This class represents all the threads that execute a concurrent
    Java application'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread`类：这个类代表执行并发Java应用程序的所有线程'
- en: 'The `Runnable` interface: This is another way to create concurrent applications
    in Java'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Runnable`接口：这是在Java中创建并发应用程序的另一种方式'
- en: 'The `ThreadLocal` class: This is a class to store variables locally to a thread'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadLocal`类：这是一个用于在线程本地存储变量的类'
- en: 'The `ThreadFactory` interface: This is the base of the Factory design pattern
    that you can use to create customized threads'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadFactory`接口：这是你可以用来创建自定义线程的工厂设计模式的基础'
- en: Synchronization mechanisms
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步机制
- en: 'The Java concurrency API includes different synchronization mechanisms that
    allow you to:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括不同的同步机制，允许你：
- en: Define a critical section to access a shared resource
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义访问共享资源的临界区
- en: Synchronize different tasks in a common point
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个共同点同步不同的任务
- en: 'The following mechanisms are considered to be the most important synchronization
    mechanisms:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下机制被认为是最重要的同步机制：
- en: 'The `synchronized` keyword: The `synchronized` keyword allows you to define
    a critical section in a block of code or in an entire method.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`synchronized`关键字：`synchronized`关键字允许你在代码块或整个方法中定义临界区。'
- en: 'The `Lock` interface: `Lock` provides a more flexible synchronization operation
    than the `synchronized` keyword. There are different kinds of Locks: `ReentrantLock`,
    to implement a Lock that can be associated with a condition; `ReentrantReadWriteLock`,
    which separates read and write operations; and `StampedLock`, a new feature of
    Java 8 that includes three modes for controlling read/write access.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lock`接口：`Lock`提供了比`synchronized`关键字更灵活的同步操作。有不同种类的锁：`ReentrantLock`，用于实现可以与条件关联的锁；`ReentrantReadWriteLock`，用于分离读写操作；以及`StampedLock`，这是Java
    8的一个新特性，包括三种模式来控制读/写访问。'
- en: 'The `Semaphore` class: The class that implements the classical semaphore to
    implement synchronization. Java supports binary and general semaphores.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Semaphore`类：实现经典信号量以实现同步的类。Java支持二进制和一般信号量。'
- en: 'The `CountDownLatch` class: A class that allows a task to wait for the finalization
    of multiple operations.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CountDownLatch`类：允许任务等待多个操作的完成。'
- en: 'The `CyclicBarrier` class: A class that allows the synchronization of multiple
    threads in a common point.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CyclicBarrier`类：允许多个线程在一个共同点同步的类。'
- en: 'The `Phaser` class: A class that allows you to control the execution of tasks
    divided into phases. None of the tasks advance to the next phase until all of
    the tasks have finished the current phase.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Phaser`类：一个允许你控制分阶段执行任务的类。在所有任务完成当前阶段之前，没有一个任务会进入下一个阶段。'
- en: Executors
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行器
- en: 'The executor framework is a mechanism that allows you to separate thread creation
    and management for the implementation of concurrent tasks. You don''t have to
    worry about the creation and management of threads, only about creating tasks
    and sending them to the executor. The main classes involved in this framework
    are:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 执行器框架是一种允许你分离线程创建和管理以实现并发任务的机制。你不必担心线程的创建和管理，只需要创建任务并将它们发送到执行器。参与该框架的主要类有：
- en: 'The `Executor` and `ExecutorService` interface: They include methods common
    to all executors.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executor`和`ExecutorService`接口：它们包括所有执行器的常用方法。'
- en: '`ThreadPoolExecutor`: This is a class that allows you to get an executor with
    a pool of threads and optionally define a maximum number of parallel tasks'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadPoolExecutor`：这是一个允许你获取一个具有线程池的执行器，并可选择定义最大并行任务数的类'
- en: '`ScheduledThreadPoolExecutor`: This is a special kind of executor to allow
    you to execute tasks after a delay or periodically'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScheduledThreadPoolExecutor`：这是一种特殊类型的执行器，允许你在延迟后或定期执行任务'
- en: '`Executors`: This is a class that facilitates the creation of executors'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors`：这是一个简化执行器创建的类'
- en: 'The `Callable` interface: This is an alternative to the *Runnable* interface—a
    separate task that can return a value'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callable`接口：这是*Runnable*接口的一种替代方式，它是一个可以返回值的独立任务'
- en: 'The `Future` interface: This is an interface that includes the methods to obtain
    the value returned by a `Callable` interface and to control its status'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Future`接口：这是一个包括获取`Callable`接口返回值和控制其状态的方法的接口'
- en: The Fork/Join framework
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fork/Join框架
- en: 'The **Fork/Join framework** defines a special kind of executor specialized
    in the resolution of problems with the divide and conquer technique. It includes
    a mechanism to optimize the execution of the concurrent tasks that solve these
    kinds of problems. Fork/Join is specially tailored for fine-grained parallelism
    as it has a very low overhead in order to place the new tasks into the queue and
    take queued tasks for execution. The main classes and interfaces involved in this
    framework are:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**Fork/Join框架**定义了一种特殊类型的执行器，专门用于使用分而治之技术解决问题。它包括一种机制来优化解决这类问题的并发任务的执行。Fork/Join特别适用于细粒度的并行性，因为它在将新任务放入队列和执行排队任务方面的开销非常低。参与该框架的主要类和接口有：'
- en: '`ForkJoinPool`: This is a class that implements the executor that is going
    to run the tasks'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinPool`：这是一个实现将运行任务的执行器的类'
- en: '`ForkJoinTask`: This is a task that can be executed in the `ForkJoinPool` class'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinTask`：这是一个可以在`ForkJoinPool`类中执行的任务'
- en: '`ForkJoinWorkerThread`: This is a thread that is going to execute tasks in
    the `ForkJoinPool` class'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForkJoinWorkerThread`：这是一个将在`ForkJoinPool`类中执行任务的线程'
- en: Parallel streams
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行流
- en: '**Streams** and **Lambda expressions** are maybe the two most important new
    features of the Java 8 version. Streams have been added as a method in the `Collection`
    interface and other data sources and allow processing all elements of a data structure,
    generating new structures, filtering data and implementing algorithms using the
    map and reduce technique.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**流**和**Lambda表达式**可能是Java 8版本中最重要的两个新特性。流已经作为`Collection`接口和其他数据源的一个方法添加，允许处理数据结构的所有元素，生成新的结构，过滤数据，并使用映射和减少技术实现算法。'
- en: 'A special kind of stream is a parallel stream which realizes its operations
    in a parallel way. The most important elements involved in the use of parallel
    streams are:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的流是并行流，它以并行方式实现其操作。使用并行流涉及的最重要的元素有：
- en: 'The `Stream` interface: This is an interface that defines all the operations
    that you can perform on a stream.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`接口：这是一个定义你可以在流上执行的所有操作的接口。'
- en: '`Optional`: This is a container object that may or may not contain a non-null
    value.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Optional`：这是一个可能包含非空值的容器对象。'
- en: '`Collectors`: This is a class that implements reduction operations that can
    be used as part of a stream sequence of operations.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collectors`：这是一个实现减少操作的类，可以作为流操作序列的一部分使用。'
- en: 'Lambda expressions: Streams has been thought to work with Lambda expressions.
    Most stream methods accept a lambda expression as a parameter. This allows you
    to implement a more compact version of the operations.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式：流被设计为与Lambda表达式一起工作。大多数流方法接受Lambda表达式作为参数。这允许你实现更紧凑的操作版本。
- en: Concurrent data structures
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发数据结构
- en: Normal data structures of the Java API (`ArrayList`, `Hashtable`, and so on)
    are not ready to work in a concurrent application unless you use an external synchronization
    mechanism. If you use it, you will be adding a lot of extra computing time to
    your application. If you don't use it, it's probable that you will have race conditions
    in your application. If you modify them from several threads and a race condition
    occurs, you may experience various exceptions thrown (such as, `ConcurrentModificationException`
    and `ArrayIndexOutOfBoundsException`), there may be silent data loss or your program
    may even stuck in an endless loop.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Java API的普通数据结构（`ArrayList`，`Hashtable`等）在并发应用中不适合工作，除非你使用外部同步机制。如果你使用它，将会为你的应用程序增加大量的额外计算时间。如果你不使用它，你的应用程序可能会出现竞争条件。如果你从多个线程修改它们并发生竞争条件，可能会出现各种异常抛出（如`ConcurrentModificationException`和`ArrayIndexOutOfBoundsException`），可能会出现静默数据丢失，或者你的程序甚至可能会陷入无限循环。
- en: 'The Java concurrency API includes a lot of data structures that can be used
    in concurrent applications without risk. We can classify them in two groups:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括许多可以在并发应用中使用而不会有风险的数据结构。我们可以将它们分类为两组：
- en: '**Blocking data structures**: These include methods that block the calling
    task when, for example, the data structure is empty and you want to get a value.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻塞数据结构**：这些包括在数据结构为空并且您想要获取一个值时，阻止调用任务的方法。'
- en: '**Non-blocking data structures:** If the operation can be made immediately,
    it won''t block the calling tasks. Otherwise, it returns the `null` value or throws
    an exception.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非阻塞数据结构**：如果操作可以立即完成，它不会阻止调用任务。否则，它会返回`null`值或抛出异常。'
- en: 'These are some of the data structures:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些数据结构：
- en: '`ConcurrentLinkedDeque`: This is a non-blocking list'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedDeque`：这是一个非阻塞列表'
- en: '`ConcurrentLinkedQueue`: This is a non-blocking queue'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentLinkedQueue`：这是一个非阻塞队列'
- en: '`LinkedBlockingDeque`: This is a blocking list'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingDeque`：这是一个阻塞列表'
- en: '`LinkedBlockingQueue`: This is a blocking queue'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinkedBlockingQueue`：这是一个阻塞队列'
- en: '`PriorityBlockingQueue`: This is a blocking queue that orders its elements
    based on its priority'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PriorityBlockingQueue`：这是一个根据优先级排序其元素的阻塞队列'
- en: '`ConcurrentSkipListMap`: This is a non-blocking navigable map'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentSkipListMap`：这是一个非阻塞可导航映射'
- en: '`ConcurrentHashMap`: This is a non-blocking hash map'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`：这是一个非阻塞哈希映射'
- en: '`AtomicBoolean`, `AtomicInteger`, `AtomicLong`, and `AtomicReference`: These
    are atomic implementations of the basic Java data types'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AtomicBoolean`、`AtomicInteger`、`AtomicLong`和`AtomicReference`：这些是基本Java数据类型的原子实现'
- en: Concurrency design patterns
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发设计模式
- en: In software engineering, a **design pattern** is a solution to a common problem.
    This solution has been used many times, and it has proved to be an optimal solution
    to the problem. You can use them to avoid 'reinventing the wheel' every time you
    have to solve one of these problems. **Singleton** or **Factory** are the examples
    of common design patterns used in almost every application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中，**设计模式**是对一个常见问题的解决方案。这个解决方案已经被多次使用，并且已经被证明是解决问题的最佳方案。您可以使用它们来避免每次解决这些问题时都要“重新发明轮子”。**单例**或**工厂**是几乎每个应用程序中使用的常见设计模式的例子。
- en: Concurrency also has its own design patterns. In this section, we describe some
    of the most useful concurrency design patterns and their implementation in the
    Java language.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 并发性也有自己的设计模式。在本节中，我们描述了一些最有用的并发设计模式及其在Java语言中的实现。
- en: Signaling
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: This design pattern explains how to implement the situation where a task has
    to notify an event to another task. The easiest way to implement this pattern
    is with a semaphore or a mutex, using the `ReentrantLock` or `Semaphore` classes
    of the Java language or even the `wait()` and `notify()` methods included in the
    `Object` class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式解释了如何实现一个任务必须通知另一个任务的事件的情况。实现这个模式的最简单方法是使用Java语言的`ReentrantLock`或`Semaphore`类，甚至是`Object`类中包含的`wait()`和`notify()`方法。
- en: 'See the following example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE1]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Under these circumstances, the `section2()` method will always be executed after
    the `section1()` method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，`section2()`方法将始终在`section1()`方法之后执行。
- en: Rendezvous
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会合
- en: This design pattern is a generalization of the **Signaling** pattern. In this
    case, the first task waits for an event of the second task and the second task
    waits for an event of the first task. The solution is similar to that of Signaling,
    but in this case you must use two objects instead of one.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式是**信号**模式的一般化。在这种情况下，第一个任务等待第二个任务的事件，第二个任务等待第一个任务的事件。解决方案类似于信号，但在这种情况下，您必须使用两个对象而不是一个。
- en: 'See the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE2]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Under these circumstances, `section2_2()` always will be executed after `section1_1()`
    and `section1_2()` after `section2_1()`, take into account that, if you put the
    call to the `wait()` method before the call to the `notify()` method, you will
    have a deadlock.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，`section2_2()`总是在`section1_1()`之后执行，`section1_2()`在`section2_1()`之后执行，要注意的是，如果在调用`notify()`方法之前调用`wait()`方法，会导致死锁。
- en: Mutex
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 互斥
- en: A mutex is a mechanism that you can use to implement a critical section ensuring
    mutual exclusion. That is to say, only one task can execute the portion of code
    protected by the mutex at one time. In Java, you can implement a critical section
    using the `synchronized` keyword (that allows you to protect a portion of code
    or a full method), the `ReentrantLock` class, or the `Semaphore` class.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥是一种机制，您可以使用它来实现临界区，确保互斥。也就是说，一次只有一个任务可以执行由互斥保护的代码部分。在Java中，您可以使用`synchronized`关键字（允许您保护代码部分或整个方法）、`ReentrantLock`类或`Semaphore`类来实现临界区。
- en: 'Look at the following example:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE3]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Multiplex
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多路复用
- en: The **Multiplex design pattern** is a generalization of the mutex. In this case,
    a determined number of tasks can execute the critical section at once. It is useful,
    for example, when you have multiple copies of a resource. The easiest way to implement
    this design pattern in Java is using the `Semaphore` class initialized to the
    number of tasks that can execute the critical section at once.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**多路复用设计模式**是互斥的一般化。在这种情况下，确定数量的任务可以同时执行临界区。例如，当您有多个资源的副本时，这是有用的。在Java中实现这个设计模式的最简单方法是使用初始化为可以同时执行临界区的任务数量的`Semaphore`类。'
- en: 'Look at the following example:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE4]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Barrier
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏障
- en: This design pattern explains how to implement the situation where you need to
    synchronize some tasks at a common point. None of the tasks can continue with
    their execution until all the tasks have arrived at the synchronization point.
    The Java concurrency API provides the `CyclicBarrier` class, which is an implementation
    of this design pattern.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式解释了如何实现需要在一个共同点同步一些任务的情况。在所有任务到达同步点之前，没有一个任务可以继续执行。Java并发API提供了`CyclicBarrier`类，这是这个设计模式的一个实现。
- en: 'Look at the following example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 看下面的例子：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Double-checked locking
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双重检查锁定
- en: 'This design pattern provides a solution to the problem that occurs when you
    acquire a lock and then check for a condition. If the condition is false, you
    have had the overhead of acquiring the lock ideally. An example of this situation
    is the lazy initialization of objects. If you have a class implementing the `Singleton`
    design pattern, you may have some code like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式提供了解决在获取锁并检查条件时发生的问题的方法。如果条件为假，您理想情况下已经获得了锁的开销。这种情况的一个例子是对象的延迟初始化。如果您有一个实现`Singleton`设计模式的类，可能会有类似以下的代码：
- en: '[PRE6]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A possible solution can be to include the lock inside the conditions:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的解决方案是在条件中包含锁：
- en: '[PRE7]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This solution still has problems. If two tasks check the condition at once,
    you will create two objects. The best solution to this problem doesn''t use any
    explicit synchronization mechanism:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案仍然存在问题。如果两个任务同时检查条件，将创建两个对象。解决此问题的最佳方法不使用任何显式同步机制：
- en: '[PRE8]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Read-write lock
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读写锁
- en: 'When you protect access to a shared variable with a lock, only one task can
    access that variable, independently of the operation you are going to perform
    on it. Sometimes, you will have variables that you modify a few times but read
    many times. In this circumstance, a lock provides poor performance because all
    the read operations can be made concurrently without any problem. To solve this
    problem, there exists the read-write lock design pattern. This pattern defines
    a special kind of lock with two internal locks: one for read operations and the
    other for write operations. The behavior of this lock is as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用锁来保护对共享变量的访问时，只有一个任务可以访问该变量，无论您要对其执行什么操作。有时，您会有一些您多次修改但多次读取的变量。在这种情况下，锁提供了较差的性能，因为所有读取操作都可以并发进行而不会出现任何问题。为解决这个问题，存在读写锁设计模式。该模式定义了一种特殊类型的锁，具有两个内部锁：一个用于读操作，另一个用于写操作。该锁的行为如下：
- en: If one task is doing a read operation and another task wants to do another read
    operation, it can do it
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个任务正在执行读操作，另一个任务想要执行另一个读操作，它可以执行。
- en: If one task is doing a read operation and another task wants to do a write operation,
    it's blocked until all the readers finish
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个任务正在执行读操作，另一个任务想要执行写操作，它将被阻塞，直到所有读取操作完成。
- en: If one task is doing a write operation and another task wants to do an operation
    (read or write), it's blocked until the writer finishes
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果一个任务正在执行写操作，另一个任务想要执行操作（读或写），它将被阻塞，直到写操作完成。
- en: The Java concurrency API includes the class `ReentrantReadWriteLock` that implements
    this design pattern. If you want to implement this pattern from scratch, you have
    to be very careful with the priority between read-tasks and write-tasks. If too
    many read-tasks exist, write-tasks can be waiting too long.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括实现此设计模式的`ReentrantReadWriteLock`类。如果要从头开始实现此模式，必须非常小心读任务和写任务之间的优先级。如果存在太多的读任务，写任务可能会等待太久。
- en: Thread pool
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程池
- en: This design pattern tries to remove the overhead introduced by creating a thread
    for the task you want to execute. It's formed by a set of threads and a queue
    of tasks you want to execute. The set of threads usually has a fixed size. When
    a thread approaches the execution of a task, it doesn't finish its execution;
    it looks for another task in the queue. If there is another task, it executes
    it. If not, the thread waits until a task is inserted in the queue, but it's not
    destroyed.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式试图消除为要执行的任务创建线程引入的开销。它由一组线程和要执行的任务队列组成。线程组通常具有固定大小。当线程接近执行任务时，它不会完成执行；它会查找队列中的另一个任务。如果有另一个任务，它会执行它。如果没有，线程将等待，直到队列中插入任务，但不会被销毁。
- en: The Java concurrency API includes some classes that implement the `ExecutorService`
    interface, which internally uses a pool of threads.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括一些实现`ExecutorService`接口的类，它们在内部使用线程池。
- en: Thread local storage
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程本地存储
- en: This design pattern defines how to use global or static variables locally to
    tasks. When you have a static attribute in a class, all the objects of a class
    access the same occurrences of the attribute. If you use thread local storage,
    each thread accesses a different instance of the variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式定义了如何在任务中本地使用全局或静态变量。当类中有静态属性时，类的所有对象都访问属性的相同实例。如果使用线程本地存储，每个线程访问变量的不同实例。
- en: The Java concurrency API includes the `ThreadLocal` class to implement this
    design pattern.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Java并发API包括`ThreadLocal`类来实现此设计模式。
- en: The Java memory model
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java内存模型
- en: When you execute a concurrent application in a computer with several cores or
    processors, you can have a problem with memory caches. They are very useful to
    increment the performance of the application, but they can cause data inconsistency.
    When a task modifies the value of a variable, it's modified in the cache, but
    it's not modified in the main memory immediately. If another task reads the value
    of that variable before it's updated in the main memory, it will read the old
    value of the variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在具有多个核心或处理器的计算机上执行并发应用程序时，可能会遇到内存缓存的问题。它们非常有用，可以增加应用程序的性能，但可能会导致数据不一致。当一个任务修改变量的值时，它在缓存中被修改，但在主内存中并没有立即修改。如果另一个任务在变量更新到主内存之前读取该变量的值，它将读取变量的旧值。
- en: Other problems that may exist with concurrent applications are the optimizations
    introduced by the compilers and code optimizer. Sometimes, they reorder the instructions
    to get a better performance. In sequential applications, this doesn't cause any
    problems, but in concurrent applications it can provoke unexpected results.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 并发应用程序可能存在的其他问题是编译器和代码优化器引入的优化。有时，它们重新排列指令以获得更好的性能。在顺序应用程序中，这不会造成任何问题，但在并发应用程序中可能会导致意外结果。
- en: To solve problems such as this, programming languages introduced memory models.
    A memory model describes how individual tasks interact with each other through
    memory and when changes made by one task will be visible to another. It also defines
    what optimizations of code are allowed and under what circumstances.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这样的问题，编程语言引入了内存模型。内存模型描述了个别任务如何通过内存相互交互，以及一个任务所做的更改何时对另一个任务可见。它还定义了允许的代码优化以及在什么情况下允许。
- en: There are different memory models. Some of them are very strict (all of the
    tasks always have access to the same values) and others are less stringent (only
    some instructions update the values in the main memory). The memory model must
    be known by the compiler and optimizer developers, and it's transparent to the
    rest of the programmers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同的内存模型。其中一些非常严格（所有任务始终可以访问相同的值），而其他一些不那么严格（只有一些指令更新主内存中的值）。内存模型必须为编译器和优化器开发人员所知，并且对其他程序员是透明的。
- en: 'Java was the first programming language that defined its memory model. The
    original memory model defined in the JVM had some issues, and it was redefined
    in Java 5\. That memory model is the same in Java 8\. It''s defined in JSR 133\.
    Basically, the Java Memory Model defines the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Java是第一种定义自己内存模型的编程语言。JVM中最初定义的内存模型存在一些问题，并在Java 5中重新定义。该内存模型在Java 8中是相同的。它在JSR
    133中定义。基本上，Java内存模型定义如下：
- en: It defines the behavior of the volatile, synchronized, and final keywords.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了volatile、synchronized和final关键字的行为。
- en: It ensures that a properly synchronized concurrent program runs correctly on
    all architectures.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它确保一个正确同步的并发程序在所有架构上都能正确运行。
- en: It creates a partial ordering of the **volatile read**, **volatile write**,
    **lock**, and **unlock** instructions denominated as **happens-before**. Task
    synchronization helps us establish the happens-before relations too. If one action
    happens-before another, then the first is visible to and ordered before the second.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了**volatile read**，**volatile write**，**lock**和**unlock**指令的部分排序，称为**happens-before**。任务同步也帮助我们建立happens-before关系。如果一个动作happens-before另一个动作，那么第一个动作对第二个动作是可见的并且有序的。
- en: When a task acquires a monitor, the memory cache is invalidated.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务获取监视器时，内存缓存被作废。
- en: When a task releases a monitor, the cache data is flushed into the main memory.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任务释放监视器时，缓存数据被刷新到主内存中。
- en: It's transparent for Java programmers.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Java程序员来说是透明的。
- en: The main objective of the Java memory model is that the properly written concurrent
    application will behave correctly on every **Java Virtual Machine** (**JVM**)
    regardless of operating system, CPU architecture, and the number of CPUs and cores.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Java内存模型的主要目标是，正确编写的并发应用程序将在每个**Java虚拟机**（**JVM**）上都正确运行，而不受操作系统、CPU架构和CPU核心数量的影响。
- en: Tips and tricks to design concurrent algorithms
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计并发算法的技巧和窍门
- en: In this section, we have compiled some tips and tricks you have to keep in mind
    to design good concurrent applications.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们总结了一些设计良好的并发应用程序时必须牢记的技巧和窍门。
- en: Identify the correct independent tasks
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定正确的独立任务
- en: You can only execute concurrent tasks that are independent of each other. If
    you have two or more tasks with an order dependency between them, maybe you have
    no interest in trying to execute them concurrently and including a synchronization
    mechanism to guarantee the execution order. The tasks will execute in a sequential
    way, and you will have to overcome the synchronization mechanism. A different
    situation is when you have a task with some prerequisites, but these prerequisites
    are independent of each other. In this case, you can execute the prerequisites
    concurrently and then use a synchronization class to control the execution of
    the task after completion of all the prerequisites.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能执行彼此独立的并发任务。如果您有两个或更多具有顺序依赖性的任务，也许您对尝试并发执行它们并包括同步机制以保证执行顺序没有兴趣。任务将以顺序方式执行，并且您将不得不克服同步机制。另一种情况是当您有一个具有一些先决条件的任务，但这些先决条件彼此独立。在这种情况下，您可以并发执行先决条件，然后使用同步类来控制在所有先决条件完成后执行任务。
- en: Another situation where you can't use concurrency is when you have a loop, and
    all the steps use data generated in the step before or there is some status information
    that goes from one step to the next step.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个不能使用并发的情况是当您有一个循环，并且所有步骤使用前一步生成的数据，或者有一些状态信息从一步到下一步。
- en: Implement concurrency at the highest possible level
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在尽可能高的级别实现并发
- en: 'Rich threading APIs, as the Java concurrency API, offer you different classes
    to implement concurrency in your applications. In the case of Java, you can control
    the creation and synchronization of threads using the `Thread` or `Lock` classes,
    but it also offers you high-level concurrency objects, such as executors or the
    Fork/Join framework that allows you to execute concurrent tasks. This high-level
    mechanism offers you the following benefits:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 丰富的线程API，如Java并发API，为您提供了不同的类来在应用程序中实现并发。在Java的情况下，您可以使用`Thread`或`Lock`类来控制线程的创建和同步，但它还为您提供了高级并发对象，如执行器或Fork/Join框架，允许您执行并发任务。这种高级机制为您带来以下好处：
- en: You don't have to worry about the creation and management of threads. You only
    create tasks and send them for execution. The Java concurrency API controls the
    creation and management of threads for you.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不必担心线程的创建和管理。您只需创建任务并将它们发送执行。Java并发API控制线程的创建和管理。
- en: They are optimized to give better performance than using threads directly. For
    example, they use a pool of threads to reuse them and avoid thread creation for
    every task. You can implement these mechanisms from scratch, but it will take
    you a lot of time, and it will be a complex task.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们被优化以比直接使用线程提供更好的性能。例如，它们使用线程池来重用线程并避免为每个任务创建线程。您可以从头开始实现这些机制，但这将花费您很多时间，而且这将是一个复杂的任务。
- en: They include advanced features that make the API more powerful. For example,
    with executors in Java, you can execute tasks that return a result in the form
    of a `Future` object. Again, you can implement these mechanisms from scratch,
    but it's not advisable.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包括使API更加强大的高级功能。例如，在Java中，您可以使用执行器执行返回`Future`对象形式的结果的任务。同样，您可以从头开始实现这些机制，但这是不建议的。
- en: Your application will be migrated easier from one operating system to another,
    and it will be more scalable.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序将更容易从一个操作系统迁移到另一个操作系统，并且它将更具可伸缩性。
- en: Your application might become faster in the future Java versions. Java developers
    constantly improve the internals, and JVM optimizations will be likely more tailored
    for JDK APIs.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序可能会在未来的Java版本中变得更快。Java开发人员不断改进内部，JVM优化可能更适合JDK API。
- en: In summary, for performance and development time reasons, analyze the high-level
    mechanisms your thread API offers you before implementing your concurrent algorithm.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，出于性能和开发时间的原因，在实现并发算法之前，分析线程API提供的高级机制。
- en: Take scalability into account
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑可伸缩性
- en: One of the main objectives when you implement a concurrent algorithm is to take
    advantage of all the resources of your computer, especially the number of processors
    or cores. But this number may change over time. Hardware is constantly evolving
    and its cost becomes lower each year.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 实现并发算法的主要目标之一是充分利用计算机的所有资源，特别是处理器或核心的数量。但是这个数量可能随时间而变化。硬件不断发展，每年成本都在降低。
- en: When you design a concurrent algorithm using data decomposition, don't presuppose
    the number of cores or processors that your application will execute on. Get the
    information about the system dynamically (for example, in Java you can get it
    with the method `Runtime.getRuntime().availableProcessors()`) and make your algorithm
    use that information to calculate the number of tasks it's going to execute. This
    process will have an overhead over the execution time of your algorithm, but your
    algorithm will be more scalable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用数据分解设计并发算法时，不要假设应用程序将在多少核心或处理器上执行。动态获取系统信息（例如，在Java中，您可以使用`Runtime.getRuntime().availableProcessors()`方法获取），并使您的算法使用该信息来计算它将要执行的任务数量。这个过程会增加算法的执行时间，但您的算法将更具可伸缩性。
- en: If you design a concurrent algorithm using task decomposition, the situation
    can be more difficult. You depend on the number of independent tasks you have
    in the algorithm and forcing a bigger number of tasks will increment the overhead
    introduced by synchronization mechanisms, and the global performance of the application
    can be even worse. Analyze in detail the algorithm to determine whether you can
    have a dynamic number of tasks or not.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用任务分解设计并发算法，情况可能会更加困难。您取决于算法中独立任务的数量，强制增加任务数量将增加同步机制引入的开销，并且应用程序的全局性能甚至可能更差。详细分析算法，以确定是否可以具有动态任务数量。
- en: Use thread-safe APIs
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用线程安全的API
- en: 'If you need to use a Java library in a concurrent application, read its documentation
    first to know if it''s thread-safe or not. If it''s thread-safe, you can use it
    in your application without any problem. If it''s not, you have the following
    two options:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在并发应用程序中使用Java库，请先阅读其文档，了解它是否是线程安全的。如果它是线程安全的，您可以在应用程序中使用它而不会出现任何问题。如果不是，您有以下两个选择：
- en: If a thread-safe alternative exists, you should use it
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在线程安全的替代方案，您应该使用它
- en: If a thread-safe alternative doesn't exist, you should add the necessary synchronization
    to avoid all possible problematic situations, especially data race conditions
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不存在线程安全的替代方案，您应该添加必要的同步以避免所有可能的问题情况，特别是数据竞争条件
- en: For example, if you need a List in a concurrent application, you should not
    use the `ArrayList` class if you are going to update it from several threads because
    it's not thread-safe. In this case, you can use a thread-safe class such as `ConcurrentLinkedDeque,CopyOnWriteArrayList`,
    or `LinkedBlockingDeque`. If the class you want to use is not thread-safe, first
    you must look for a thread-safe alternative. Probably, it will be more optimized
    to work with concurrency that any alternative that you can implement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您需要在并发应用程序中使用List，如果您将从多个线程更新它，就不应该使用`ArrayList`类，因为它不是线程安全的。在这种情况下，您可以使用`ConcurrentLinkedDeque,
    CopyOnWriteArrayList`或`LinkedBlockingDeque`等线程安全类。如果您想要使用的类不是线程安全的，首先必须寻找线程安全的替代方案。可能，与您可以实现的任何替代方案相比，使用并发更加优化。
- en: Never assume an execution order
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永远不要假设执行顺序
- en: The execution of tasks in a concurrent application when you don't use any synchronization
    mechanism is nondeterministic. The order in which the tasks are executed and the
    time each task is in execution before the processor moves on to another task is
    determined by the scheduler of the operating system. It doesn't care if you observe
    that the execution order is the same in a number of executions. The next one could
    be different.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在不使用任何同步机制的并发应用程序中执行任务是不确定的。任务的执行顺序以及处理器在执行每个任务之前的时间由操作系统的调度程序确定。它不在乎您是否观察到执行顺序在多次执行中是相同的。下一次可能会有所不同。
- en: The result of this assumption used to be a data race problem. The final result
    of your algorithm depends on the execution order of the tasks. Sometimes, the
    result can be right, but at other times it can be wrong. It can be very difficult
    to detect the cause of data race conditions, so you must be careful not to forget
    all the necessary synchronization elements.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种假设的结果过去常常是数据竞争问题。您的算法的最终结果取决于任务的执行顺序。有时，结果可能是正确的，但其他时候可能是错误的。很难检测数据竞争条件的原因，因此您必须小心不要忘记所有必要的同步元素。
