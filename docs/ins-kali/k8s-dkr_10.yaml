- en: '*Chapter 7*: Integrating Authentication into Your Cluster'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：将身份验证集成到您的集群中'
- en: Once a cluster has been built, users will need to interact with it securely.
    For most enterprises, this means authenticating individual users and making sure
    they can only access what they need in order to do their jobs. With Kubernetes,
    this can be challenging because a cluster is a collection of APIs, not an application
    with a frontend that can prompt for authentication.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦集群建立完成，用户将需要安全地与之交互。对于大多数企业来说，这意味着对个别用户进行身份验证，并确保他们只能访问他们工作所需的内容。在Kubernetes中，这可能是具有挑战性的，因为集群是一组API，而不是具有可以提示进行身份验证的前端的应用程序。
- en: In this chapter, you'll learn how to integrate enterprise authentication into
    your cluster using the OpenID Connect protocol and Kubernetes impersonation. We'll
    also cover several anti-patterns and explain why you should avoid using them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用OpenID Connect协议和Kubernetes模拟将企业身份验证集成到您的集群中。我们还将涵盖几种反模式，并解释为什么您应该避免使用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding how Kubernetes knows who you are
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Kubernetes如何知道你是谁
- en: Understanding OpenID Connect
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解OpenID Connect
- en: What are the other options?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他选项是什么？
- en: Configuring KinD for OpenID Connect
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置KinD以进行OpenID Connect
- en: How cloud Kubernetes knows who you are
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云Kubernetes如何知道你是谁
- en: Configuring your cluster for impersonation
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的集群以进行模拟
- en: Configuring impersonation without OpenUnison
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在没有OpenUnison的情况下配置模拟
- en: Let's get started!
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the exercises in this chapter, you will require the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您将需要以下内容：
- en: An Ubuntu 18.04 server with 8 GB of RAM
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个拥有8GB RAM的Ubuntu 18.04服务器
- en: A KinD cluster running with the configuration from [*Chapter 5*](B15514_05_Final_ASB_ePub.xhtml#_idTextAnchor150),
    *Deploying a Cluster Using KinD*
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[*第5章*](B15514_05_Final_ASB_ePub.xhtml#_idTextAnchor150)中的配置运行的KinD集群，*使用KinD部署集群*
- en: 'You can access the code for this chapter at the following GitHub repository:
    [https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter7](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter7).'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下GitHub存储库中访问本章的代码：[https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter7](https://github.com/PacktPublishing/Kubernetes-and-Docker-The-Complete-Guide/tree/master/chapter7)。
- en: Understanding how Kubernetes knows who you are
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Kubernetes如何知道你是谁
- en: There Is No Spoon
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 没有勺子
- en: – The Matrix, 1999
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '- 《黑客帝国》，1999'
- en: In the 1999 sci-fi film *The Matrix*, Neo talks to a child about the Matrix
    as he waits to see the Oracle. The child explains to him that the trick to manipulating
    the Matrix is to realize that *"There is no spoon"*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在1999年的科幻电影《黑客帝国》中，尼奥在等待见奥拉克时与一个孩子谈论矩阵。孩子向他解释，操纵矩阵的诀窍是意识到“没有勺子”。
- en: This is a great way to look at users in Kubernetes because they don't exist.
    With the exception of service accounts, which we'll talk about later, there are
    no objects in Kubernetes called "User" or "Group". Every API interaction must
    include enough information to tell the API server who the user is and what groups
    the user is a member of. This assertion can take different forms, depending on
    how you plan to integrate authentication into your cluster.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这是查看Kubernetes中的用户的绝佳方式，因为他们并不存在。除了我们稍后将讨论的服务账户之外，在Kubernetes中没有称为“用户”或“组”的对象。每个API交互必须包含足够的信息，以告诉API服务器用户是谁以及用户是哪些组的成员。这种断言可以采用不同的形式，具体取决于您计划如何将身份验证集成到您的集群中。
- en: In this section, we will get into the details of the different ways Kubernetes
    can associate a user with a cluster.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将详细介绍Kubernetes可以将用户与集群关联的不同方式。
- en: External users
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部用户
- en: 'Users who are accessing the Kubernetes API from outside the cluster will usually
    do so using one of a two authentication methods:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从集群外部访问Kubernetes API的用户通常会使用两种认证方法之一：
- en: '**Certificate**: You can assert who you are using a client certificate that
    has information about you, such as your username and groups. The certificate is
    used as part of the TLS negotiation process.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 证书：您可以使用包含有关您的信息的客户端证书来断言您的身份，例如您的用户名和组。该证书用作TLS协商过程的一部分。
- en: '**Bearer token**: Embedded in each request, a bearer token can either be a
    self-contained token that contains all the information needed to verify itself
    or a token that can be exchanged by a webhook in the API server for that information.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bearer token：嵌入在每个请求中，Bearer token可以是一个自包含的令牌，其中包含验证自身所需的所有信息，或者可以由API服务器中的webhook交换该信息的令牌。
- en: You can also use service accounts to access the API server outside the cluster,
    though it's strongly discouraged. We'll cover the risks and concerns around using
    service accounts in the *What are the other options?* section.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用服务账户来访问集群外的API服务器，尽管这是强烈不建议的。我们将在“还有哪些选项？”部分讨论使用服务账户的风险和关注点。
- en: Groups in Kubernetes
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes中的组
- en: 'Different users can be assigned the same permissions without creating **RoleBinding
    objects** for each user individually via groups. Kubernetes includes two types
    of groups:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的用户可以被分配相同的权限，而无需为每个用户单独创建RoleBinding对象，通过组来实现。Kubernetes包括两种类型的组：
- en: '**System assigned**: These groups start with the **system:** prefix and are
    assigned by the API server. An example group is **system:authenticated**, which
    is assigned to all authenticated users. Other examples of system assigned groups
    are the **system:serviceaccounts:namespace** group, where **Namespace** is the
    name of the namespace that contains all the service accounts for the namespace
    named in the group.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统分配的：这些组以system:前缀开头，并由API服务器分配。一个例子是system:authenticated，它被分配给所有经过认证的用户。系统分配的其他示例包括system:serviceaccounts:namespace组，其中Namespace是包含命名组中命名的命名空间的名称。
- en: '**User asserted groups**: These groups are asserted by the authentication system
    either in the token provided to the API server or via the authentication webhook.
    There are no standards or requirements for how these groups are named. Just as
    with users, groups don''t exist as objects in the API server. Groups are asserted
    at authentication time by external users and tracked locally for system generated
    groups. When asserting a user''s groups, the primary difference between a user''s
    unique ID and groups is that the unique ID is expected to be unique, whereas groups
    are not.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户断言的组：这些组是由认证系统在提供给API服务器的令牌中断言的，或者通过认证webhook进行断言的。对于这些组的命名没有标准或要求。就像用户一样，组在API服务器中并不存在为对象。组是由外部用户在认证时断言的，并且对于系统生成的组在本地进行跟踪。在断言用户的组时，用户唯一ID和组之间的主要区别在于唯一ID预期是唯一的，而组不是。
- en: You may be authorized for access by groups, but all access is still tracked
    and audited based on your user's unique ID.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能被授权访问组，但所有访问仍然基于您的用户唯一ID进行跟踪和审计。
- en: Service accounts
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务账户
- en: 'Service accounts are objects that exist in the API server to track which pods
    can access the various APIs. Service account tokens are called **JSON Web Tokens**,
    or **JWTs**. Depending on how the token was generated, there are two ways to obtain
    a service account:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户是存在于API服务器中的对象，用于跟踪哪些pod可以访问各种API。服务账户令牌称为JSON Web Tokens，或JWTs。根据令牌生成的方式，有两种获取服务账户的方式：
- en: The first is from a secret that was generated by Kubernetes when the service
    account was created.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种是来自Kubernetes在创建服务账户时生成的一个密钥。
- en: The second is via the **TokenRequest** API, which is used to inject a secret
    into pods via a mount point or used externally from the cluster. All service accounts
    are used by injecting the token as a header in the request into the API server.
    The API server recognizes it as a service account and validates it internally.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法是通过**TokenRequest** API，该API用于通过挂载点将秘钥注入到Pod中，或者从集群外部使用。所有服务账户都是通过在请求中将令牌作为标头注入到API服务器中来使用的。API服务器将其识别为服务账户并在内部进行验证。
- en: Unlike users, service accounts can **NOT** be assigned to arbitrary groups.
    Service accounts are members of pre-built groups, but you can't create a group
    of specific service accounts for assigning roles.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户不同，服务账户**不能**分配给任意组。服务账户是预先构建的组的成员，但您不能创建特定服务账户的组以分配角色。
- en: Now that we explored the fundamentals of how Kubernetes identifies users, we'll
    explore how this framework fits into the **OpenID Connect** (**OIDC**) protocol.
    OIDC provides the security most enterprises require and is standards-based, but
    Kubernetes doesn't use it in a way that is typical of many web applications. Understanding
    these differences and why Kubernetes needs them is an important step in integrating
    a cluster into an enterprise security environment.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了Kubernetes如何识别用户的基本原理，我们将探讨这个框架如何适用于**OpenID Connect**（**OIDC**）协议。OIDC提供了大多数企业需要的安全性，并且符合标准，但Kubernetes并不像许多网络应用程序那样使用它。了解这些差异以及Kubernetes为何需要它们是将集群整合到企业安全环境中的重要步骤。
- en: Understanding OpenID Connect
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解OpenID Connect
- en: OpenID Connect is a standard identity federation protocol. It's built on the
    OAuth2 specification and has some very powerful features that make it the preferred
    choice for interacting with Kubernetes clusters.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect是一种标准的身份联合协议。它建立在OAuth2规范之上，并具有一些非常强大的功能，使其成为与Kubernetes集群交互的首选选择。
- en: 'The main benefits of OpenID Connect are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect的主要优势如下：
- en: '**Short-lived tokens**: If a token is leaked, such as via a log message or
    breach, you want the token to expire as quickly as possible. With OIDC, you''re
    able to specify tokens that can live for 1-2 minutes, which means the token will
    likely be expired by the time an attacker attempts to use it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短期令牌**：如果令牌泄露，比如通过日志消息或违规行为，您希望令牌尽快过期。使用OIDC，您可以指定令牌的生存时间为1-2分钟，这意味着令牌在攻击者尝试使用时很可能已经过期。'
- en: '**User and group memberships**: When we start talking about authorizations,
    we''ll see quickly that it''s important to manage access by groups instead of
    managing access by referencing users directly. OIDC tokens can embed both the
    user''s identifier and their groups, leading to easier access management.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户和组成员资格**：当我们开始讨论授权时，我们很快就会发现按组管理访问权限比直接引用用户进行访问权限管理更为重要。OIDC令牌可以嵌入用户的标识符和他们的组，从而更容易进行访问管理。'
- en: '**Refresh tokens scoped to timeout policies**: With short-lived tokens, you
    need to be able to refresh them as needed. The time a refresh token is valid for
    can be scoped to your enterprise''s web application idle timeout policy, keeping
    your cluster in compliance with other web-based applications.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌受到超时策略的限制：使用短期令牌时，您需要能够根据需要刷新它们。刷新令牌的有效时间可以根据企业的网络应用程序空闲超时策略进行限定，从而使您的集群符合其他基于网络的应用程序的规定。
- en: '**No plugins required for kubectl**: The **kubectl** binary supports OpenID
    Connect natively, so there''s no need for any additional plugins. This is especially
    useful if you need to access your cluster from a jump box or VM because you''re
    unable to install the **Command-Line Interface** (**CLI**) tools directly onto
    your workstation.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**kubectl**不需要插件：**kubectl**二进制文件原生支持OpenID Connect，因此不需要任何额外的插件。如果您需要从跳板机或虚拟机访问集群，但无法直接在工作站上安装**命令行界面**（**CLI**）工具，这将非常有用。'
- en: '**More multi-factor authentication options**: Many of the strongest multi-factor
    authentication options require a web browser. Examples include FIDO U2F and WebAuth,
    which use hardware tokens.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更多多因素身份验证选项**：许多最强大的多因素身份验证选项需要使用Web浏览器。例如，使用硬件令牌的FIDO U2F和WebAuth。'
- en: OIDC is a peer reviewed standard that has been in use for several years and
    is quickly becoming the preferred standard for identity federation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC是一个经过同行评审的标准，已经使用了几年，并迅速成为身份联合的首选标准。
- en: Important Note
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Identity federation is the term used to describe the assertion of identity data
    and authentication without sharing the user's confidential secret or password.
    A classic example of identity federation is logging into your employee website
    and being able to access your benefits provider without having to log in again.
    Your employee website doesn't share your password with your benefits provider.
    Instead, your employee website *asserts* that you logged in at a certain date
    and time and provides some information about you. This way, your account is *federated*
    across two silos (your employee website and benefits portal), without your benefits
    portal knowing your employee website password.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 身份联合是用来描述断言身份数据和认证的术语，而不共享用户的机密密码。身份联合的经典示例是登录到员工网站并能够访问您的福利提供者，而无需再次登录。您的员工网站不会与福利提供者共享您的密码。相反，您的员工网站*断言*您在特定日期和时间登录，并提供一些关于您的信息。这样，您的帐户就可以在两个独立的系统（您的员工网站和福利门户）之间*联合*，而无需让您的福利门户知道您的员工网站密码。
- en: The OpenID Connect protocol
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenID Connect协议
- en: As you can see, there are multiple components to OIDC. To fully understand how
    OIDC works, let's begin the OpenID connect protocol.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，OIDC有多个组件。为了充分理解OIDC的工作原理，让我们开始OpenID连接协议。
- en: 'The two aspects of the OIDC protocol we will be focusing on are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注OIDC协议的两个方面：
- en: Using tokens with **kubectl** and the API server
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**kubectl**和API服务器的令牌
- en: Refreshing tokens to keep your tokens up to date
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新令牌以保持令牌的最新状态
- en: We won't focus too much on obtaining tokens. While the protocol to get a token
    does follow a standard, the login process does not. How you obtain tokens from
    an identity provider will vary, based on how you choose to implement the OIDC
    **Identity Provider** (**IdP**).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会过多关注获取令牌。虽然获取令牌的协议遵循标准，但登录过程并不是。根据您选择实现OIDC**身份提供者**（**IdP**）的方式，从身份提供者获取令牌的方式会有所不同。
- en: 'There are three tokens that are generated from an OIDC login process:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: OIDC登录过程生成了三个令牌：
- en: '**access_token**: This token is used to make authenticated requests to web
    services your identity provider may provide, such as obtaining user information.
    It is **NOT** used by Kubernetes and can be discarded.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**access_token**：此令牌用于向身份提供者提供的Web服务进行经过身份验证的请求，例如获取用户信息。它**不**被Kubernetes使用，可以丢弃。'
- en: '**id_token**: This token is a JWT that encapsulates your identity, including
    your unique identifier (sub), groups, and expiration information about you that
    the API server can use to authorize your access. The JWT is signed by your identity
    provider''s certificate and can be verified by Kubernetes simply by checking the
    JWT''s signature. This is the token you pass to Kubernetes for each request to
    authenticate yourself.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id_token**：这是一个JWT令牌，包含您的身份信息，包括您的唯一标识（sub）、组和关于您的到期信息，API服务器可以使用它来授权您的访问。JWT由您的身份提供者的证书签名，并且可以通过Kubernetes简单地检查JWT的签名来验证。这是您传递给Kubernetes以进行身份验证的令牌。'
- en: '**refresh_token**: **kubectl** knows how to refresh your **id_token** for you
    automatically once it expires. To do this, it makes a call to your IdP''s token
    endpoint using **refresh_token** to obtain a new **id_token**. A **refresh_token**
    can only be used once and is opaque, meaning that you, as the holder of the token,
    have no visibility into its format and it really doesn''t matter to you. It either
    works, or it doesn''t *refresh_token never goes to Kubernetes (or any other application).
    It is only used in communications with the IdP.*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh_token**：**kubectl**知道如何在令牌过期后自动为您刷新**id_token**。为此，它使用**refresh_token**调用您的IdP的令牌端点以获取新的**id_token**。**refresh_token**只能使用一次，是不透明的，这意味着作为令牌持有者的您无法看到其格式，对您来说并不重要。它要么有效，要么无效。*refresh_token永远不会传递到Kubernetes（或任何其他应用程序）。它只在与IdP的通信中使用。*'
- en: 'Once you have your tokens, you can use them to authenticate with the API server.
    The easiest way to use your tokens is to add them to the **kubectl** configuration
    using command-line parameters:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了您的令牌，您可以使用它们来与API服务器进行身份验证。使用您的令牌的最简单方法是将它们添加到**kubectl**配置中，使用命令行参数：
- en: kubectl config set-credentials username --auth-provider=oidc --auth-provider-arg=idp-issuer-url=https://host/uri
    --auth-provider-arg=client-id=kubernetes --auth-provider-arg=refresh-token=$REFRESH_TOKEN
    --auth-provider-arg=id-token=$ID_TOKEN
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl config set-credentials username --auth-provider=oidc --auth-provider-arg=idp-issuer-url=https://host/uri
    --auth-provider-arg=client-id=kubernetes --auth-provider-arg=refresh-token=$REFRESH_TOKEN
    --auth-provider-arg=id-token=$ID_TOKEN
- en: '**config set-credentials** has a few options that need to be provided. We have
    already explained **id-token** and **refresh_token**, but there are two additional
    options:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**config set-credentials**有一些需要提供的选项。我们已经解释了**id-token**和**refresh_token**，但还有两个额外的选项：'
- en: '**idp-issuer-url**: This is the same URL we will use to configure the API server
    and points to the base URL used for the IdP''s discovery URL.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**idp-issuer-url**：这与我们将用于配置API服务器的URL相同，并指向用于IdP发现URL的基本URL。'
- en: '**client-id**: This is used by your IdP to identify your configuration. This
    is unique to a Kubernetes deployment and is not considered secret information.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端ID**：这是由您的IdP用于识别您的配置。这是Kubernetes部署中的唯一标识，不被视为机密信息。'
- en: The OpenID Connect protocol has an optional element, known as a **client_secret**,
    that is shared between an OIDC client and the IdP. It is used to "authenticate"
    the client prior to making any requests, such as refreshing a token. While it's
    supported by Kubernetes as an option, its recommended to not use it and instead
    configure your IdP to use a public endpoint (which doesn't use a secret at all).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect协议有一个可选元素，称为**client_secret**，它在OIDC客户端和IdP之间共享。它用于在进行任何请求之前“验证”客户端，例如刷新令牌。虽然Kubernetes支持它作为一个选项，但建议不使用它，而是配置您的IdP使用公共端点（根本不使用密钥）。
- en: The client secret has no practical value since you'd need to share it with every
    potential user and since it's a password, your enterprise's compliance framework
    will likely require that it is rotated regularly, causing support headaches. Overall,
    it's just not worth any potential downsides in terms of security.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端密钥没有实际价值，因为您需要与每个潜在用户共享它，并且由于它是一个密码，您企业的合规框架可能要求定期轮换，这会导致支持方面的麻烦。总的来说，它不值得在安全方面承担任何潜在的不利影响。
- en: Important Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Kubernetes requires that your identity provider supports the discovery URL endpoint,
    which is a URL that provides some JSON to tell you where you can get keys to verify
    JWTs and the various endpoints available. Take any issuer URL and add **/.well-known/openid-configuration**
    to see this information.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes要求您的身份提供者支持发现URL端点，这是一个URL，提供一些JSON告诉您可以在哪里获取用于验证JWT的密钥和各种可用的端点。取任何发行者URL并添加**/.well-known/openid-configuration**以查看此信息。
- en: Following OIDC and the API's interaction
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遵循OIDC和API的交互
- en: 'Once **kubectl** has been configured, all of your API interactions will follow
    the following sequence:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦**kubectl**被配置，所有API交互将遵循以下顺序：
- en: '![Figure 7.1 – Kubernetes/kubectl OpenID Connect sequence diagram'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.1 - Kubernetes/kubectl OpenID Connect序列图'
- en: '](image/Fig_7.1_B15514.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.1_B15514.jpg)'
- en: Figure 7.1 – Kubernetes/kubectl OpenID Connect sequence diagram
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - Kubernetes/kubectl OpenID Connect序列图
- en: 'The preceding diagram is from Kubernetes'' authentication page at [https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens).
    Authenticating a request involves doing the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表来自Kubernetes的认证页面，网址为[https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens)。认证请求涉及以下操作：
- en: '**Log in to your Identity Provider (IdP)**: This will be different for each
    IdP. This could involve providing a username and password to a form in a web browser,
    a multi-factor token, or a certificate. This will be implementation-specific to
    every implementation.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**登录到您的身份提供者（IdP）**：对于每个IdP都会有所不同。这可能涉及在Web浏览器中向表单提供用户名和密码，多因素令牌或证书。这将针对每个实现具体实现。'
- en: '**Provide tokens to the user**: Once authenticated, the user needs a way to
    generate the tokens needed by **kubectl** to access the Kubernetes APIs. This
    can take the form of an application that makes it easy for the user to copy and
    paste them into the configuration file, or can be a new file to download.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**向用户提供令牌**：一旦经过身份验证，用户需要一种方式来生成**kubectl**访问Kubernetes API所需的令牌。这可以是一个应用程序，使用户可以轻松地将它们复制并粘贴到配置文件中，或者可以是一个新的可下载文件。'
- en: This step is where **id_token** and **refresh_token** are added to the **kubectl**
    configuration. If the tokens were presented to the user in the browser, they can
    be manually added to the configuration. If a new configuration is provided so
    that it can be downloaded, it can be. There are also **kubectl** plugins that
    will launch a web browser to start the authentication process and, once completed,
    generate your configuration for you.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这一步是将**id_token**和**refresh_token**添加到**kubectl**配置中。如果令牌在浏览器中呈现给用户，它们可以手动添加到配置中。如果提供了新的配置以便下载，也可以这样做。还有**kubectl**插件，将启动一个Web浏览器来开始认证过程，并在完成后为您生成配置。
- en: '**Inject id_token**: Once the **kubectl** command has been called, each API
    call includes an addition header, called the **Authorization** header, that includes
    **id_token**.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注入id_token**：一旦调用了**kubectl**命令，每个API调用都包括一个额外的标头，称为**Authorization**标头，其中包括**id_token**。'
- en: '**JWT signature validation**: Once the API server receives **id_token** from
    the API call, it validates the signature against the public key provided by the
    identity provider. The API server will also validate whether the issuer matches
    the issuer for the API server configuration, and also that the recipient matches
    the client ID from the API server configuration.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JWT签名验证：一旦API服务器从API调用接收到id_token，它将使用身份提供者提供的公钥验证签名。API服务器还将验证发行者是否与API服务器配置的发行者匹配，以及接收者是否与API服务器配置的客户端ID匹配。
- en: '**Check the JWT''s expiration**: Tokens are only good for a limited amount
    of time. The API server ensures that the token hasn''t expired.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查JWT的过期时间：令牌只在有限的时间内有效。API服务器确保令牌尚未过期。
- en: '**Authorization check**: Now that the user has been authenticated, the API
    server will determine whether the user identified by the provided **id_token**
    is able to perform the requested action by matching the user''s identifier and
    asserted groups to internal policies.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权检查：现在用户已经通过身份验证，API服务器将确定由提供的id_token标识的用户是否能够执行所请求的操作，方法是将用户的标识符和断言的组与内部策略进行匹配。
- en: '**Execute the API**: All checks are complete and the API server executes the
    request, generating a response that will be sent back to **kubectl**.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行API：所有检查都已完成，API服务器执行请求，生成一个将发送回kubectl的响应。
- en: '**Format the response for the user**: Once the API call is complete (or a series
    of API calls), the JSON is formatted for the user by **kubectl**.'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户的响应格式：一旦API调用完成（或一系列API调用），JSON将由kubectl为用户格式化。
- en: Important Note
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In general terms, authentication is the process of validating you are you. Most
    of us encounter this when we put our username and password into a website. We're
    proving who we are. In the enterprise world, authorization then becomes the decision
    of whether we're allowed to do something. First, we authenticate and then we authorize.
    The standards built around API security don't assume authentication and go straight
    to authorization based on some sort of token. It's not assumed that the caller
    has to be identified. For instance, when you use a physical key to open a door,
    the door doesn't know who you are, only that you have the right key. This terminology
    can become very confusing, so don't feel bad if you get a bit lost. You're in
    good company!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，身份验证是验证您的过程。当我们在网站上输入用户名和密码时，大多数人都会遇到这种情况。我们在证明我们是谁。在企业世界中，授权随后成为我们是否被允许做某事的决定。首先，我们进行身份验证，然后进行授权。围绕API安全构建的标准并不假设身份验证，而是直接基于某种令牌进行授权。不假设调用者必须被识别。例如，当您使用物理钥匙打开门时，门不知道您是谁，只知道您有正确的钥匙。这些术语可能会变得非常令人困惑，所以如果您有点迷茫，不要感到难过。您并不孤单！
- en: '**id_token** is self-contained; everything the API server needs to know about
    you is in that token. The API server verifies **id_token** using the certificate
    provided by the identity provider and verifies that the token hasn''t expired.
    As long as that all lines up, the API server will move on to authorizing your
    request based on its own RBAC configuration. We''ll cover the details of that
    process later. Finally, assuming you''re authorized, the API server provides a
    response.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: id_token是自包含的；API服务器需要了解有关您的所有信息都包含在该令牌中。API服务器使用身份提供者提供的证书验证id_token，并验证令牌是否已过期。只要一切都符合，API服务器将根据其自身的RBAC配置继续授权您的请求。我们将在稍后介绍该过程的详细信息。最后，假设您已获得授权，API服务器将提供响应。
- en: 'Notice that Kubernetes never sees your password or any other secret information
    that you, and only you, know. The only thing that''s shared is **id_token**, and
    that''s ephemeral. This leads to several important points:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Kubernetes从不会看到您的密码或任何其他只有您知道的秘密信息。唯一共享的是**id_token**，而且它是短暂的。这导致了几个重要的观点：
- en: Since Kubernetes never sees your password or other credentials, it can't compromise
    them. This can save you a tremendous amount of time working with your security
    team, because all the tasks related to securing passwords can be skipped!
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于Kubernetes从不会看到您的密码或其他凭据，它无法 compromise 它们。这可以节省您与安全团队合作的大量时间，因为所有与保护密码相关的任务都可以跳过！
- en: '**id_token** is self-contained, which means that if it''s compromised, there
    is nothing you can do, short of re-keying your identity provider, to stop it from
    being abused. This is why it''s so important for your **id_token** to have a short
    lifespan. At 1-2 minutes, the likelihood that an attacker will be able to obtain
    an **id_token**, realize what it is, and abuse it, is very low.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**id_token**是自包含的，这意味着如果它被 compromise，除非重新生成您的身份提供者密钥，否则无法阻止它被滥用。这就是为什么您的**id_token**的寿命如此重要。在1-2分钟内，攻击者能够获取**id_token**，意识到它是什么，并滥用它的可能性非常低。'
- en: If, while performing its calls, **kubectl** finds that **id_token** has expired,
    it will attempt to refresh it by calling the IdP's token endpoint using **refresh_token**.
    If the user's session is still valid, the IdP will generate a new **id_token**
    and **refresh_token**, which **kubectl** will store for you in the **kubectl**
    configuration. This happens automatically with no user intervention. Additionally,
    a **refresh_token** has a one-time use, so if someone tries to use a previously
    used **refresh_token**, your IdP will fail the refresh process.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行其调用时，**kubectl**发现**id_token**已过期，它将尝试通过调用IdP的令牌端点使用**refresh_token**来刷新它。如果用户的会话仍然有效，IdP将生成新的**id_token**和**refresh_token**，**kubectl**将为您存储在kubectl配置中。这将自动发生，无需用户干预。此外，**refresh_token**只能使用一次，因此如果有人尝试使用先前使用过的**refresh_token**，您的IdP将失败刷新过程。
- en: Important Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It's bound to happen. Someone may need to be locked out immediately. It may
    be that they're being walked out or that their session has been compromised. This
    is dependent on your IdP, so when choosing an IdP, make sure it supports some
    form of session revocation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可避免的。有人可能需要立即被锁定。可能是因为他们被走出去了，或者他们的会话已经被 compromise。这取决于您的IdP，因此在选择IdP时，请确保它支持某种形式的会话撤销。
- en: Finally, if **refresh_token** has expired or the session has been revoked, the
    API server will return a **401 Unauthorized** message to indicate that it will
    no longer support the token.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果**refresh_token**已过期或会话已被撤销，API服务器将返回**401 Unauthorized**消息，表示它将不再支持该令牌。
- en: We've spent a considerable amount of time examining the OIDC protocol. Now,
    let's take an in-depth look at **id_token**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了大量时间研究OIDC协议。现在，让我们深入了解**id_token**。
- en: id_token
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: id_token
- en: 'An **id_token** is a JSON web token that is base64-encoded and is digitally
    signed. The JSON contains a series of attributes, known as claims, in OIDC. There
    are some standard claims in i**d_token**, but for the most part, the claims you
    will be most concerned with are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**id_token**是一个经过base64编码和数字签名的JSON web token。JSON包含一系列属性，称为claims，在OIDC中。**id_token**中有一些标准的claims，但大部分时间您最关心的claims如下：'
- en: '**iss**: The issuer, which **MUST** line up with the issuer in your kubectl
    configuration'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iss**：发行者，必须与kubectl配置中的发行者一致'
- en: '**aud**: Your client ID'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**aud**：您的客户端ID'
- en: '**sub**: Your unique identifier'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sub**：您的唯一标识符'
- en: '**groups**: Not a standard claim, but should be populated with groups specifically
    related to your Kubernetes deployment'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**groups**：不是标准声明，但应填充与您的Kubernetes部署相关的组'
- en: Important Note
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Many deployments attempt to identify you by your email address. This is an anti-pattern
    as your email address is generally based on your name, and names change. The sub
    claim is supposed to be a unique identifier that is immutable and will never change.
    This way, it doesn't matter if your email changes because your name changes. This
    can make it harder to debug *"who is cd25d24d-74b8-4cc4-8b8c-116bf4abbd26?"* but
    will provide a cleaner and easier to maintain cluster.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多部署尝试通过您的电子邮件地址来识别您。这是一种反模式，因为您的电子邮件地址通常基于您的姓名，而姓名会发生变化。sub声明应该是一个不可变的唯一标识符，永远不会改变。这样，即使您的电子邮件地址发生变化，也不重要，因为您的姓名发生了变化。这可能会使调试“cd25d24d-74b8-4cc4-8b8c-116bf4abbd26是谁？”变得更加困难，但会提供一个更清晰、更易于维护的集群。
- en: 'There are several other claims that indicate when an **id_token** should no
    longer be accepted. These claims are all measured in seconds from epoch (January
    1, 1970) UTC time:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些声明，指示**id_token**何时不再被接受。这些声明都是以秒为单位从纪元时间（1970年1月1日）的UTC时间计算的：
- en: '**exp**: When **id_token** expires'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**exp**：**id_token**过期时间'
- en: '**iat**: When **id_token** was created'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iat**：**id_token**创建时间'
- en: '**nbf**: The absolute earliest an **id_token** should be allowed'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nbf**：**id_token**允许的绝对最早时间'
- en: Why doesn't a token just have a single expiration time?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么令牌不只有一个过期时间？
- en: It's unlikely that the clock on the system that created **id_token** has the
    exact same time as the system that is evaluating it. There's often a skew and
    depending on how the clock is set, it may be a few minutes. Having a not-before
    in addition to an expiration gives some room for standard time deviation.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建**id_token**的系统上的时钟不太可能与评估它的系统上的时钟完全相同。通常会有一些偏差，取决于时钟的设置，可能会有几分钟。除了过期时间之外，还有一个不早于时间，可以为标准时间偏差提供一些余地。
- en: There are other claims in an **id_token** that don't really matter but are there
    for additional context. Examples include your name, contact information, organization,
    and so on.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**id_token**中还有其他一些声明，虽然并不重要，但是为了提供额外的上下文。例如，您的姓名、联系信息、组织等。'
- en: While the primary use for tokens is to interact with the Kubernetes API server,
    they are not limited to only API interaction. In addition to going to the API
    server, webhook calls may also receive your **id_token**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管令牌的主要用途是与Kubernetes API服务器进行交互，但它们不仅限于API交互。除了访问API服务器，webhook调用也可能接收您的**id_token**。
- en: You may have deployed OPA as a validating webhook on a cluster. When someone
    submits a pod creation request, the webhook will receive the user's **id_token**,
    which can be used for other decisions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经在集群上部署了OPA作为验证webhook。当有人提交pod创建请求时，webhook将接收用户的**id_token**，这可以用于其他决策。
- en: One example is that you want to ensure that the PVCs are mapped to specific
    PVs based on the submitter's organization. The organization is included in **id_token**
    , which is passed to Kubernetes, and then onto OPA webhook. Since the token has
    been passed to the webhook, the information can then be used in your OPA policies.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是，您希望确保PVC基于提交者的组织映射到特定的PV。组织包含在**id_token**中，传递给Kubernetes，然后传递到OPA webhook。由于令牌已传递到webhook，因此信息可以在您的OPA策略中使用。
- en: Other authentication options
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他身份验证选项
- en: In this section, we focused on OIDC and presented reasons why it's the best
    mechanism for authentication. It is certainly not the only option, and we will
    cover the other options in this section and when they're appropriate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们专注于OIDC，并提出了它是身份验证的最佳机制的原因。当然，这并不是唯一的选择，我们将在本节中涵盖其他选项以及它们的适用性。
- en: Certificates
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 证书
- en: This is generally everyone's first experience authenticating to a Kubernetes
    cluster.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是每个人第一次对Kubernetes集群进行身份验证的经历。
- en: Once a Kubernetes installation is complete, a pre-built kubectl **config** file
    that contains a certificate and private key is created and ready to be use. This
    file should only be used in "break glass in case of emergency" scenarios, where
    all other forms of authentication are not available. It should be controlled by
    your organization's standards for privileged access. When this configuration file
    is used, it doesn't identify the user and can easily be abused since it doesn't
    allow for an easy audit trail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Kubernetes安装完成，将创建一个预先构建的kubectl **config**文件，其中包含证书和私钥，并准备好使用。此文件应仅在“紧急情况下打破玻璃”情况下使用，在其他形式的身份验证不可用时。它应受到组织对特权访问的标准控制。当使用此配置文件时，它不会识别用户，并且很容易被滥用，因为它不允许轻松的审计跟踪。
- en: While this is a standard use case for certificate authentication, it's not the
    only use case for certificate authentication. Certificate authentication, when
    done correctly, is one of the strongest recognized credentials in the industry.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是证书认证的标准用例，但并不是证书认证的唯一用例。当正确使用时，证书认证是行业中公认的最强凭据之一。
- en: Certificate authentication is used by the US Federal Government for its most
    important tasks. At a high level, certificate authentication involves using a
    client key and certificate to negotiate your HTTPS connection to the API server.
    The API server can get the certificate you used to establish the connection and
    validate it against a **Certificate Authority** (**CA**) certificate. Once verified,
    it maps attributes from the certificate to a user and groups the API server can
    recognize.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 美国联邦政府在其最重要的任务中使用证书认证。在高层次上，证书认证涉及使用客户端密钥和证书来协商与API服务器的HTTPS连接。API服务器可以获取您用于建立连接的证书，并根据**证书颁发机构**（**CA**）证书对其进行验证。验证后，它将证书中的属性映射到API服务器可以识别的用户和组。
- en: To get the security benefits of certificate authentication, the private key
    needs to be generated on isolated hardware, usually in the form of a smartcard,
    and never leave that hardware. A certificate signing request is generated and
    submitted to a CA that signs the public key, thus creating a certificate that
    is then installed on the dedicated hardware. At no point does the CA get the private
    key, so even if the CA were compromised, you couldn't gain the user's private
    key. If a certificate needs to be revoked, it's added to a revocation list that
    can either be pulled from an LDAP directory, a file, or can be checked using the
    OCSP protocol.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得证书认证的安全性好处，私钥需要在隔离的硬件上生成，通常以智能卡的形式，并且永远不离开该硬件。生成证书签名请求并提交给签署公钥的CA，从而创建一个安装在专用硬件上的证书。在任何时候，CA都不会获得私钥，因此即使CA被
    compromise，也无法获得用户的私钥。如果需要撤销证书，它将被添加到一个吊销列表中，可以从LDAP目录、文件中提取，或者可以使用OCSP协议进行检查。
- en: This may look like an attractive option, so why shouldn't you use certificates
    with Kubernetes?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一个吸引人的选择，那么为什么不应该在Kubernetes中使用证书呢？
- en: Smartcard integration uses a standard called PKCS11, which neither **kubectl**
    or the API server support.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 智能卡集成使用一个名为PKCS11的标准，**kubectl**或API服务器都不支持。
- en: The API server has no way of checking certificate revocation lists or using
    OCSP, so once a certificate has been minted, there's no way to revoke it so that
    the API server can use it.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API服务器无法检查证书吊销列表或使用OCSP，因此一旦证书被颁发，就无法撤销，以便API服务器可以使用它。
- en: Additionally, the process to correctly generate a key pair is rarely used. It
    requires a complex interface to be built that is difficult for users to use combine
    with command-line tools that need to be run. To get around this, the certificate
    and key pair are generated for you and you download it or it's emailed to you,
    negating the security of the process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正确生成密钥对的过程很少使用。它需要构建一个复杂的接口，用户很难使用，结合需要运行的命令行工具。为了解决这个问题，证书和密钥对是为您生成的，您可以下载它或者通过电子邮件发送给您，从而抵消了该过程的安全性。
- en: The other reason you shouldn't use certificate authentication for users is that
    it's difficult to leverage groups. While you can embed groups into the subject
    of the certificate, you can't revoke a certificate. So, if a user's role changes,
    you can give them a new certificate but you can't keep them from using the old
    one.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您不应该为用户使用证书身份验证的另一个原因是很难利用组。虽然您可以将组嵌入到证书的主题中，但无法撤销证书。因此，如果用户的角色发生变化，您可以给他们一个新的证书，但无法阻止他们使用旧的证书。
- en: As stated in the introduction to this section, using a certificate to authenticate
    in "break glass in case of emergencies" situations is a good use of certificate
    authentication. It may be the only way to get into a cluster if all other authentication
    methods are experiencing issues.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的介绍中提到，使用证书在“紧急情况下打破玻璃”的情况下进行身份验证是证书身份验证的一个很好的用途。如果所有其他身份验证方法都出现问题，这可能是进入集群的唯一方法。
- en: Service accounts
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务帐户
- en: 'Service accounts appear to provide an easy access method. Creating them is
    easy. The following command creates a service account object and a secret to go
    with it that stores the service account''s token:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 服务帐户似乎提供了一种简单的访问方法。创建它们很容易。以下命令创建了一个服务帐户对象和一个与之配套的密钥，用于存储服务帐户的令牌：
- en: kubectl create sa mysa -n default
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl create sa mysa -n default
- en: 'Next, the following command will retrieve the service account''s token in JSON
    format and return only the value of the token. This token can then be used to
    access the API server:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，以下命令将以JSON格式检索服务帐户的令牌，并仅返回令牌的值。然后可以使用此令牌访问API服务器：
- en: kubectl get secret $(kubectl get sa mysa -n default -o json | jq -r '.secrets[0].name')
    -o json | jq -r '.data.token' | base64 -d
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get secret $(kubectl get sa mysa -n default -o json | jq -r '.secrets[0].name')
    -o json | jq -r '.data.token' | base64 -d
- en: 'To show an example of this, let''s call the API endpoint directly, without
    providing any credentials:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点，让我们直接调用API端点，而不提供任何凭据：
- en: curl -v --insecure https://0.0.0.0:32768/api
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: curl -v --insecure https://0.0.0.0:32768/api
- en: 'You will receive the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您将收到以下内容：
- en: .
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: .
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: .
- en: '{'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"kind": "Status",'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '“kind”: “状态”，'
- en: '"apiVersion": "v1",'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '“apiVersion”: “v1”，'
- en: '"metadata": {'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: “metadata”:{
- en: '},'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"status": "Failure",'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '“status”: “失败”,'
- en: '"message": "forbidden: User \"system:anonymous\" cannot get path \"/api\"",'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '“message”: “禁止：用户“system:anonymous”无法获取路径“/api””,'
- en: '"reason": "Forbidden",'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: “原因”:“禁止”，
- en: '"details": {'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: “details”:{
- en: '},'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '},'
- en: '"code": 403'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '“code”: 403'
- en: '* Connection #0 to host 0.0.0.0 left intact'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接到主机0.0.0.0的连接已保持不变'
- en: By default, most Kubernetes distributions do not allow anonymous access to the
    API server, so we receive a *403 error* because we didn't specify a user.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大多数Kubernetes发行版不允许匿名访问API服务器，因此我们收到了*403错误*，因为我们没有指定用户。
- en: 'Now, let''s add our service account to an API request:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将我们的服务帐户添加到API请求中：
- en: export KUBE_AZ=$(kubectl get secret $(kubectl get sa mysa -n default -o json
    | jq -r '.secrets[0].name') -o json | jq -r '.data.token' | base64 -d)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: export KUBE_AZ=$(kubectl get secret $(kubectl get sa mysa -n default -o json
    | jq -r '.secrets[0].name') -o json | jq -r '.data.token' | base64 -d)
- en: 'curl  -H "Authorization: Bearer $KUBE_AZ" --insecure https://0.0.0.0:32768/api'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 'curl -H“Authorization: Bearer $KUBE_AZ” --insecure https://0.0.0.0:32768/api'
- en: '{'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"kind": "APIVersions",'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '“kind”: “APIVersions”，'
- en: '"versions": ['
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: “versions”:[
- en: '"v1"'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: “v1”
- en: '],'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '],'
- en: '"serverAddressByClientCIDRs": ['
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: “serverAddressByClientCIDRs”:[
- en: '{'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"clientCIDR": "0.0.0.0/0",'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '“clientCIDR”: “0.0.0.0/0”，'
- en: '"serverAddress": "172.17.0.3:6443"'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '“serverAddress”: “172.17.0.3:6443”'
- en: '}'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ']'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: '}'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'Success! This was an easy process, so you may be wondering, *"Why do I need
    worry about all the complicated OIDC mess?"* This solution''s simplicity brings
    multiple security issues:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！这是一个简单的过程，所以您可能会想，“为什么我需要担心所有复杂的OIDC混乱呢？”这个解决方案的简单性带来了多个安全问题：
- en: '**Secure transmission of the token**: Service accounts are self-contained and
    need nothing to unlock them or verify ownership, so if a token is taken in transit,
    you have no way of stopping its use. You could set up a system where a user logs
    in to download a file with the token in it, but you now have a much less secure
    version of OIDC.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**令牌的安全传输**：服务账户是自包含的，不需要任何内容来解锁它们或验证所有权，因此如果令牌在传输中被获取，您无法阻止其使用。您可以建立一个系统，让用户登录以下载其中包含令牌的文件，但现在您拥有的是一个功能较弱的OIDC版本。'
- en: '**No expiration**: When you decode a service account token, there is nothing
    that tell you when the token expires. That''s because the token never expires.
    You can revoke a token by deleting the service account and recreating it, but
    that means you need a system in place to do that. Again, you''ve built a less
    capable version of OIDC.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无过期时间**：当您解码服务账户令牌时，没有任何告诉您令牌何时过期的信息。这是因为令牌永远不会过期。您可以通过删除服务账户并重新创建来撤销令牌，但这意味着您需要一个系统来执行此操作。再次，您构建了一个功能较弱的OIDC版本。'
- en: '**Auditing**: The service account can easily be handed out by the owner once
    the key has been retrieved. If there are multiple users using a single key, it
    becomes very difficult to audit use of the account.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：一旦所有者检索到密钥，服务账户就可以轻松地被分发。如果有多个用户使用单个密钥，很难审计账户的使用情况。'
- en: In addition to these issues, you can't put a service account into arbitrary
    groups. This means that RBAC bindings have to either be direct to the service
    account or use one of the pre-built groups that service accounts are a member
    of. We'll explore why this is an issue when we talk about authorization, so just
    keep it in mind for now.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些问题，您无法将服务账户放入任意组中。这意味着RBAC绑定要么直接绑定到服务账户，要么使用服务账户是成员的预建组之一。当我们谈论授权时，我们将探讨为什么这是一个问题，所以现在只需记住这一点。
- en: Finally, service accounts were never designed to be used outside of the cluster.
    It's like using a hammer to drive in a screw. With enough muscle and aggravation,
    you will drive it in, but it won't be pretty and no one will be happy with the
    result.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，服务账户从未设计用于在集群外部使用。这就像使用锤子来打螺丝。通过足够的力量和激怒，您可以将其打入，但这不会很漂亮，也不会有人对结果感到满意。
- en: TokenRequest API
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TokenRequest API
- en: At the time of writing, the **TokenRequest** API is still a **beta** feature.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，**TokenRequest** API仍然是一个**beta**功能。
- en: The **TokenRequest** API lets you request a short-lived service account for
    a specific scope. While it provides slightly better security since it will expire
    and has a limited scope, it's still bound to a service account, which means no
    groups, and there's still the issue of securely getting the token to the user
    and auditing its use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**TokenRequest** API允许您请求特定范围的短期服务账户。虽然它提供了稍微更好的安全性，因为它将会过期并且范围有限，但它仍然绑定到服务账户，这意味着没有组，并且仍然存在安全地将令牌传递给用户并审计其使用的问题。'
- en: Tokens generated by the **TokenRequest** API are built for other systems to
    talk to your cluster; they are not meant to be used by users.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由**TokenRequest** API生成的令牌是为其他系统与您的集群通信而构建的；它们不是用于用户使用的。
- en: Custom authentication webhooks
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义认证webhook
- en: If you already have an identity platform that doesn't use an existing standard,
    a custom authentication webhook will let you integrate it without having to customize
    the API server. This feature is commonly used by cloud providers who host managed
    Kubernetes instances.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经有一个不使用现有标准的身份平台，那么自定义身份验证webhook将允许你集成它，而无需定制API服务器。这个功能通常被托管托管Kubernetes实例的云提供商所使用。
- en: You can define an authentication webhook that the API server will call with
    a token to validate it and get information about the user. Unless you manage a
    public cloud with a custom IAM token system that you are building a Kubernetes
    distribution for, don't do this. Writing your own authentication is like writing
    your own encryption – just don't do it. Every custom authentication system we've
    seen for Kubernetes boils down to either a pale imitation of OIDC or "pass the
    password". Much like the analogy of driving a screw in with a hammer, you could
    do it, but it will be very painful. This is mostly because instead of driving
    the screw through a board, you're more likely to drive it into your own foot.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个身份验证webhook，API服务器将使用令牌调用它来验证并获取有关用户的信息。除非你管理一个具有自定义IAM令牌系统的公共云，你正在构建一个用于Kubernetes分发的，不要这样做。编写自己的身份验证就像编写自己的加密
    - 不要这样做。我们看到的每个自定义身份验证系统最终都归结为OIDC的苍白模仿或“传递密码”。就像用锤子拧螺丝的类比一样，你可以这样做，但这将非常痛苦。这主要是因为你更有可能把螺丝钉拧进自己的脚而不是木板。
- en: Keystone
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Keystone
- en: Those familiar with OpenStack will recognize the name Keystone as an identity
    provider. If you are not familiar with Keystone, it is the default identity provider
    used in an OpenStack deployment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉OpenStack的人会认识Keystone这个身份提供者的名字。如果你不熟悉Keystone，它是OpenStack部署中使用的默认身份提供者。
- en: 'Keystone hosts the API that handles authentication and token generation. OpenStack
    stores users in Keystone''s database. While using Keystone is more often associated
    with OpenStack, Kubernetes can also be configured to use Keystone for username
    and password authentication, with some limitations:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Keystone托管处理身份验证和令牌生成的API。OpenStack将用户存储在Keystone的数据库中。虽然使用Keystone更常与OpenStack相关联，但Kubernetes也可以配置为使用Keystone进行用户名和密码身份验证，但有一些限制：
- en: The main limitation of using Keystone as an IdP for Kubernetes is that it only
    works with Keystone's LDAP implementation. While you could use this method, you
    should consider that only username and password are supported, so you're creating
    an identity provider with a non-standard protocol to authenticate to an LDAP server,
    which pretty much any OIDC IdP can do out of the box.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Keystone作为Kubernetes的IdP的主要限制是它只能与Keystone的LDAP实现一起使用。虽然你可以使用这种方法，但你应该考虑只支持用户名和密码，因此你正在创建一个使用非标准协议进行身份验证的身份提供者，而任何OIDC
    IdP都可以直接执行此操作。
- en: You can't leverage SAML or OIDC with Keystone, even though Keystone supports
    both protocols for OpenStack, which limits how users can authenticate, thus cutting
    you off from multiple multi-factor options.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能利用Keystone使用SAML或OIDC，尽管Keystone支持OpenStack的这两种协议，这限制了用户的身份验证方式，因此使你无法使用多种多因素选项。
- en: Few, if any, applications know how to use the Keystone protocol outside of OpenStack.
    Your cluster will have multiple applications that make up your platform, and those
    applications won't know how to integrate with Keystone.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很少有应用程序知道如何在OpenStack之外使用Keystone协议。你的集群将有多个应用程序组成你的平台，而这些应用程序不知道如何与Keystone集成。
- en: Using Keystone is certainly an appealing idea, especially if you're deploying
    on OpenStack, but ultimately, it's very limiting and you will likely put in just
    as much working getting Keystone integrated as just using OIDC.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Keystone当然是一个吸引人的想法，特别是如果您正在部署OpenStack，但最终，它非常有限，您可能需要花费与使用OIDC一样多的工作来集成Keystone。
- en: The next section will take the details we've explored here and apply them to
    integrating authentication into a cluster. As you move through the implementation,
    you'll see how **kubectl**, the API server, and your identity provider interact
    to provide secure access to the cluster. We'll tie these features back to common
    enterprise requirements to illustrate why the details for understanding the OpenID
    Connect protocol are important.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将把我们在这里探讨的细节应用到集成身份验证的集群中。当您在实施过程中，您将看到**kubectl**、API服务器和您的身份提供者是如何相互作用以提供对集群的安全访问的。我们将把这些特性与常见的企业需求联系起来，以说明理解OpenID
    Connect协议的细节为什么重要。
- en: Configuring KinD for OpenID Connect
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置KinD以进行OpenID Connect
- en: 'For our example deployment, we will use a scenario from our customer, FooWidgets.Foowidgets
    has a Kubernetes cluster that they would like integrated using OIDC. The proposed
    solution needs to address the following requirements:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例部署，我们将使用我们客户FooWidgets的一个场景。FooWidgets有一个Kubernetes集群，他们希望使用OIDC进行集成。提出的解决方案需要满足以下要求：
- en: Kubernetes must use our central authentication system, Active Directory Federation
    Services.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes必须使用我们的中央身份验证系统Active Directory联合身份验证服务。
- en: We need to be able map Active Directory groups into our RBAC **RoleBinding**
    objects.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够将Active Directory组映射到我们的RBAC **RoleBinding**对象。
- en: Users need access to the Kubernetes Dashboard.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要访问Kubernetes仪表板。
- en: Users need to be able to use the CLI.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要能够使用CLI。
- en: All enterprise compliance requirements must be met.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须满足所有企业合规性要求。
- en: Let's explore each of these in detail and explain how we can address the customer's
    requirements.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨每一个，并解释我们如何满足客户的需求。
- en: Addressing the requirements
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 满足需求
- en: Our enterprise's requirements require multiple moving parts, both inside and
    outside our cluster. We'll examine each of these components and how they relate
    to building an authenticated cluster.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们企业的需求需要多个内部和外部的组件。我们将检查每个组件以及它们与构建经过身份验证的集群的关系。
- en: Use Active Directory Federation Services
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Active Directory联合身份验证服务
- en: Most enterprises today use Active Directory from Microsoft™ to store information
    about users and their credentials. Depending on the size of your enterprise, it's
    not unusual to have multiple domain or forests where users live. If your IdP is
    well integrated into a Microsoft's Kerberos environment, it may know how to navigate
    these various systems. Most non-Microsoft applications are not, including most
    identity providers. **Active Directory Federation Services** (**ADFS**) is Microsoft's
    IdP that supports both SAML2 and OpenID Connect, and it knows how to navigate
    the domains and forest of an enterprise implementation. It's common in many large
    enterprises.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，大多数企业都使用微软™的Active Directory来存储有关用户及其凭据的信息。根据您企业的规模，拥有多个用户所在的域或森林并不罕见。如果您的IdP与微软的Kerberos环境很好地集成在一起，它可能知道如何浏览这些不同的系统。大多数非微软应用程序不是这样的，包括大多数身份提供者。**Active
    Directory联合身份验证服务**（**ADFS**）是微软的IdP，支持SAML2和OpenID Connect，并且知道如何浏览企业实施的域和森林。在许多大型企业中很常见。
- en: The next decision with ADFS is whether to use SAML2 or OpenID Connect. At the
    time of writing, SAML2 is much easier to implement and most enterprise environments
    with ADFS prefer to use SAML2\. Another benefit of SAML2 is that it doesn't require
    a connection between our cluster and the ADFS servers; all of the important information
    is transferred through the user's browser. This cuts down on potential firewall
    rules that need to be implemented in order to get our cluster up and running.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 与ADFS相关的下一个决定是是否使用SAML2还是OpenID Connect。在撰写本文时，SAML2更容易实现，并且大多数使用ADFS的企业环境更喜欢使用SAML2。SAML2的另一个好处是它不需要我们的集群与ADFS服务器之间建立连接；所有重要信息都通过用户的浏览器传输。这减少了需要实施的潜在防火墙规则，以便让我们的集群正常运行。
- en: Important Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Don't worry – you don't need ADFS ready to go to run this exercise. We have
    a handy SAML testing identity provider we'll use. You won't need to install anything
    to use SAML2 with your KinD cluster.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心-你不需要ADFS准备好就可以运行这个练习。我们有一个方便的SAML测试身份提供者，我们将使用它。您不需要安装任何东西来在您的KinD集群中使用SAML2。
- en: Mapping Active Directory Groups to RBAC RoleBindings
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Active Directory组映射到RBAC RoleBindings
- en: This will become important when we start talking about authorization. What's
    important to point out here is that ADFS has the capability to put a user's group
    memberships in the SAML assertion, which our cluster can then consume.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始讨论授权时，这将变得重要。这里要指出的重要一点是，ADFS有能力将用户的组成员资格放入SAML断言中，然后我们的集群可以消耗它。
- en: Kubernetes Dashboard access
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes仪表板访问
- en: The dashboard is a powerful way to quickly access information about your cluster
    and make quick updates. When deployed correctly, the dashboard does not create
    any security issues. The proper way to deploy the dashboard is with no privileges,
    instead relying on the user's own credentials. We'll do this with a reverse proxy
    that injects the user's OIDC token on each request, which the dashboard will then
    use when it makes calls to the API server. Using this method, we'll be able to
    constrain access to our dashboard the same way we would with any other web application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是一种快速访问集群信息并进行快速更新的强大方式。正确部署时，仪表板不会创建任何安全问题。部署仪表板的正确方式是不赋予任何特权，而是依赖用户自己的凭据。我们将通过一个反向代理来实现这一点，该代理会在每个请求中注入用户的OIDC令牌，仪表板在调用API服务器时将使用该令牌。使用这种方法，我们将能够以与任何其他Web应用程序相同的方式限制对我们仪表板的访问。
- en: There are a few reasons why using the **kubectl** built-in proxy and port-forward
    aren't a great strategy for accessing the dashboard. Many enterprises will not
    install CLI utilities locally, forcing you to use a jump box to access privileged
    systems such as Kubernetes, meaning port forwarding won't work. Even if you can
    run **kubectl** locally, opening a port on loopback (127.0.0.1) means anything
    on your system can use it, not just you from your browser. While browsers have
    controls in place to keep you from accessing ports on loopback using a malicious
    script, that won't stop anything else on your workstation. Finally, it's just
    not a great user experience.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因说明为什么使用kubectl内置代理和端口转发不是访问仪表板的好策略。许多企业不会在本地安装CLI实用程序，迫使您使用跳板机来访问诸如Kubernetes之类的特权系统，这意味着端口转发不起作用。即使您可以在本地运行kubectl，打开回环（127.0.0.1）上的端口意味着您的系统上的任何东西都可以使用它，而不仅仅是您从浏览器中。虽然浏览器有控件可以阻止您使用恶意脚本访问回环上的端口，但这不会阻止您的工作站上的其他任何东西。最后，这只是一个不太好的用户体验。
- en: We'll dig into the details of how and why this works in [*Chapter 9*](B15514_09_Final_ASB_ePub.xhtml#_idTextAnchor246)*,
    Deploying a Secured Kubernetes Dashboard.*
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨这是如何以及为什么工作的细节，详情请参阅[*第9章*](B15514_09_Final_ASB_ePub.xhtml#_idTextAnchor246)*，部署安全的Kubernetes仪表板*。
- en: Kubernetes CLI access
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes CLI访问
- en: Most developers want to be able to access **kubectl** and other tools that rely
    on the **kubectl** configuration. For instance, the Visual Studio Code Kubernetes
    plugin doesn't require any special configuration. It just uses the **kubectl**
    built-in configuration. Most enterprises tightly constrain what binaries you're
    able to install, so we want to minimize any additional tools and plugins we want
    to install.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员希望能够访问**kubectl**和其他依赖**kubectl**配置的工具。例如，Visual Studio Code Kubernetes插件不需要任何特殊配置。它只使用**kubectl**内置配置。大多数企业严格限制您能够安装的二进制文件，因此我们希望尽量减少我们想要安装的任何额外工具和插件。
- en: Enterprise compliance requirements
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 企业合规要求
- en: Being cloud-native doesn't mean you can ignore your enterprise's compliance
    requirements. Most enterprises have requirements such as having 20-minute idle
    timeouts, may require multi-factor authentication for privileged access, and so
    on. Any solution we put in place has to make it through the control spreadsheets
    needed to go live. Also, this goes without saying, but everything needs to be
    encrypted (and I do mean everything).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 成为云原生并不意味着您可以忽视企业的合规要求。大多数企业都有要求，例如20分钟的空闲超时，可能需要特权访问的多因素身份验证等。我们提出的任何解决方案都必须通过控制电子表格才能上线。另外，毋庸置疑，但一切都需要加密（我是指一切）。
- en: Pulling it all together
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'To fulfill these requirements, we''re going to use OpenUnison. It has prebuilt
    configurations to work with Kubernetes, the dashboard, the CLI, and SAML2 identity
    providers such as ADFS. It''s also pretty quick to deploy, so we don''t need to
    concentrate on provider-specific implementation details and instead focus on Kubernetes''
    configuration options. Our architecture will look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足这些要求，我们将使用OpenUnison。它具有预构建的配置，可与Kubernetes、仪表板、CLI和SAML2身份提供者（如ADFS）一起使用。部署速度也相当快，因此我们不需要专注于特定提供程序的实现细节，而是专注于Kubernetes的配置选项。我们的架构将如下所示：
- en: '![Figure 7.2 – Authentication architecture'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 认证架构'
- en: '](image/Fig_7.2_B15514.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.2_B15514.jpg)'
- en: Figure 7.2 – Authentication architecture
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 认证架构
- en: 'For our implementation, we''re going to use two hostnames:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实现，我们将使用两个主机名：
- en: '**k8s.apps.X-X-X-X.nip.io**: Access to the OpenUnison portal, where we''ll
    initiate our login and get our tokens'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**k8s.apps.X-X-X-X.nip.io**：访问OpenUnison门户，我们将在那里启动登录并获取我们的令牌'
- en: '**k8sdb.apps.X-X-X-X.nip.io**: Access to the Kubernetes dashboard'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**k8sdb.apps.X-X-X-X.nip.io**：访问Kubernetes仪表板'
- en: Important Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As a quick refresher, **nip.io** is a public DNS service that will return an
    IP address from the one embedded in your hostname. This is really useful in a
    lab environment where setting up DNS can be painful. In our examples, X-X-X-X
    is the IP of your Docker host.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个快速提醒，**nip.io**是一个公共DNS服务，将返回嵌入在您主机名中的IP地址。在实验环境中，设置DNS可能很麻烦，这真的很有用。在我们的示例中，X-X-X-X是您的Docker主机的IP。
- en: When a user attempts to access **https://k8s.apps.X-X-X-X.nip.io/**, they'll
    be redirected to ADFS, which will collect their username and password (and maybe
    even a multi-factor authentication token). ADFS will generate an assertion that
    will be digitally signed and contain our user's unique ID, as well as their group
    assignments. This assertion is similar to **id_token**, which we examined earlier,
    but instead of being JSON, it's XML. The assertion is sent to the user's browser
    in a special web page that contains a form that will automatically submit the
    assertion back to OpenUnison. At that point, OpenUnison will create user objects
    in the OpenUnison namespace to store the user's information and create OIDC sessions.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试访问https://k8s.apps.X-X-X-X.nip.io/时，他们将被重定向到ADFS，ADFS将收集他们的用户名和密码（甚至可能是多因素身份验证令牌）。
    ADFS将生成一个断言，该断言将被数字签名并包含我们用户的唯一ID，以及他们的组分配。这个断言类似于我们之前检查的id_token，但它不是JSON，而是XML。这个断言被发送到用户的浏览器中的一个特殊网页中，该网页包含一个表单，该表单将自动将断言提交回OpenUnison。在那时，OpenUnison将在OpenUnison命名空间中创建用户对象以存储用户信息并创建OIDC会话。
- en: Earlier, we described how Kubernetes doesn't have user objects. Kubernetes lets
    you extend the base API with **Custom Resource Definitions** (**CRDs**). OpenUnison
    defines a User CRD to help with high availability and to avoid needing a database
    to store state in. These user objects can't be used for RBAC.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 早些时候，我们描述了Kubernetes没有用户对象。Kubernetes允许您使用自定义资源定义（CRD）扩展基本API。OpenUnison定义了一个用户CRD，以帮助实现高可用性，并避免需要在数据库中存储状态。这些用户对象不能用于RBAC。
- en: Once the user is logged into OpenUnison, they can get their **kubectl** configuration
    to use the CLI or use the Kubernetes dashboard, [https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/](https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/),
    to access the cluster from their browser. Once the user is ready, they can log
    out of OpenUnison, which will end their session and invalidate their **refresh_token**,
    making it impossible for them to use **kubectl** or the dashboard until after
    they log in again. If they walk away from their desk for lunch without logging
    out, when they return, their **refresh_token** will have expired, so they'll no
    longer be able to interact with Kubernetes without logging back in.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录到OpenUnison，他们可以获取他们的kubectl配置，以使用CLI或使用Kubernetes仪表板来从浏览器访问集群。一旦用户准备好，他们可以注销OpenUnison，这将结束他们的会话并使他们的refresh_token失效，从而使他们无法再次使用kubectl或仪表板，直到他们再次登录。如果他们离开桌子吃午饭而没有注销，当他们回来时，他们的refresh_token将会过期，因此他们将无法再与Kubernetes交互而不重新登录。
- en: Now that we have walked through how users will log in and interact with Kubernetes,
    we'll deploy OpenUnison and integrate it into the cluster for authentication.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了用户如何登录并与Kubernetes交互，我们将部署OpenUnison并将其集成到集群中进行身份验证。
- en: Deploying OIDC
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署OIDC
- en: We have included two installation scripts to automate the deployment steps.
    These scripts, **install-oidc-step1.sh** and **install-oidc-step2.sh**, are located
    in this book's GitHub repository, in the **chapter7** directory.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经包含了两个安装脚本来自动化部署步骤。这些脚本install-oidc-step1.sh和install-oidc-step2.sh位于本书的GitHub存储库中的chapter7目录中。
- en: This section will explain all of the manual steps that the script automates.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释脚本自动化的所有手动步骤。
- en: Important Note
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'If you install OIDC using the scripts, you **must** follow this process for
    a successful deployment:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用脚本安装OIDC，您必须遵循这个过程才能成功部署：
- en: 'Step 1: Run the **./install-oidc-step1.sh** script.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤1：运行./install-oidc-step1.sh脚本。
- en: 'Step 2: Register for an SAML2 test lab by following the procedure in the *Registering
    for a SAML2 test lab* section.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 第2步：按照*注册SAML2测试实验室*部分的步骤注册SAML2测试实验室。
- en: 'Step3: Run the **./install-oidc-step2.sh** script to complete the OIDC deployment.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步：运行**./install-oidc-step2.sh**脚本完成OIDC部署。
- en: 'Deploying OIDC to a Kubernetes cluster using OpenUnison is a five-step process:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenUnison在Kubernetes集群中部署OIDC是一个五步过程：
- en: Deploy the dashboard.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署仪表板。
- en: Deploy the OpenUnison operator.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署OpenUnison运算符。
- en: Create a secret.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个秘密。
- en: Create a **values.yaml** file.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**values.yaml**文件。
- en: Deploy the chart.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署图表。
- en: Let's perform these steps one by one.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地执行这些步骤。
- en: Deploying OpenUnison
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部署OpenUnison
- en: 'The dashboard is a popular feature for many users. It provides a quick view
    into resources without us needing to use the kubectl CLI. Over the years, it has
    received some bad press for being insecure, but when deployed correctly, it is
    very secure. Most of the stories you may have read or heard about come from a
    dashboard deployment that was not set up correctly. We will cover this topic in
    [*Chapter 9*](B15514_09_Final_ASB_ePub.xhtml#_idTextAnchor246)*, Securing the
    Kubernetes Dashboard*:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是许多用户喜欢的功能。它提供了资源的快速视图，而无需使用kubectl CLI。多年来，它因不安全而受到一些负面评价，但是当正确部署时，它是非常安全的。您可能读过或听过的大多数故事都来自未正确设置的仪表板部署。我们将在[*第9章*](B15514_09_Final_ASB_ePub.xhtml#_idTextAnchor246)*，保护Kubernetes仪表板*中涵盖这个主题：
- en: 'First, we''ll deploy the dashboard from https://github.com/kubernetes/dashboard:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从https://github.com/kubernetes/dashboard部署仪表板：
- en: '**kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml**'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0/aio/deploy/recommended.yaml**'
- en: '**namespace/kubernetes-dashboard created**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**namespace/kubernetes-dashboard created**'
- en: '**serviceaccount/kubernetes-dashboard created**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**serviceaccount/kubernetes-dashboard created**'
- en: '**service/kubernetes-dashboard created**'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**service/kubernetes-dashboard created**'
- en: '**secret/kubernetes-dashboard-certs created**'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**secret/kubernetes-dashboard-certs created**'
- en: '**secret/kubernetes-dashboard-csrf created**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**secret/kubernetes-dashboard-csrf created**'
- en: '**secret/kubernetes-dashboard-key-holder created**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**secret/kubernetes-dashboard-key-holder created**'
- en: '**configmap/kubernetes-dashboard-settings created**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**configmap/kubernetes-dashboard-settings created**'
- en: '**role.rbac.authorization.k8s.io/kubernetes-dashboard created**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**role.rbac.authorization.k8s.io/kubernetes-dashboard created**'
- en: '**clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created**'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '**clusterrole.rbac.authorization.k8s.io/kubernetes-dashboard created**'
- en: '**rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**rolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created**'
- en: '**clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**clusterrolebinding.rbac.authorization.k8s.io/kubernetes-dashboard created**'
- en: '**deployment.apps/kubernetes-dashboard created**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**deployment.apps/kubernetes-dashboard created**'
- en: '**service/dashboard-metrics-scraper created**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**service/dashboard-metrics-scraper created**'
- en: '**deployment.apps/dashboard-metrics-scraper created**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**deployment.apps/dashboard-metrics-scraper created**'
- en: 'Next, we need to add the repository that contains OpenUnison to our Helm list.
    To add the Tremolo chart repository, use the **Helm repo add** command:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将包含OpenUnison的存储库添加到我们的Helm列表中。要添加Tremolo图表存储库，请使用**Helm repo add**命令：
- en: Helm repo add tremolo https://nexus.tremolo.io/repository/Helm/
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Helm repo add tremolo https://nexus.tremolo.io/repository/Helm/
- en: '**https://nexus.tremolo.io/repository/Helm/"tremolo" has been added to your
    repositories**'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '**https://nexus.tremolo.io/repository/Helm/"tremolo"已添加到您的存储库**'
- en: Important Note
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Helm is a package manager for Kubernetes. Helm provides a tool that will deploy
    a "Chart" to your cluster and help you manage the state of the deployment. We're
    using Helm v3, which does not require you to deploy any components, such as Tiller,
    to your cluster to work.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Helm是Kubernetes的包管理器。Helm提供了一个工具，可以将“Chart”部署到您的集群，并帮助您管理部署的状态。我们正在使用Helm v3，它不需要您在集群中部署任何组件，如Tiller，才能工作。
- en: 'Once added, you need to update the repository using the **Helm repo update**
    command:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加后，您需要使用**Helm repo update**命令更新存储库：
- en: '**helm repo update**'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**helm repo update**'
- en: '**Hang tight while we grab the latest from your chart repositories...**'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从图表存储库中获取最新信息时，请稍等片刻...
- en: '**...Successfully got an update from the "tremolo" chart repository**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '...成功从“tremolo”图表存储库获取更新'
- en: '**Update Complete. Happy Helming!**'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 更新完成。祝您使用Helm愉快！
- en: You are now ready to deploy the OpenUnison operator using the Helm chart.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用Helm图表部署OpenUnison运算符。
- en: 'First, we want to deploy OpenUnison in a new namespace called **openunison**.
    We need to create the namespace before deploying the Helm chart:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们希望在一个名为**openunison**的新命名空间中部署OpenUnison。在部署Helm图表之前，我们需要创建命名空间：
- en: '**kubectl create ns openunison**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create ns openunison**'
- en: '**namespace/openunison created**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**namespace/openunison created**'
- en: 'With the namespace created, you can deploy the chart into the namespace using
    Helm. To install a chart using Helm, use **Helm install <name> <chart> <options>**:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了创建的命名空间，您可以使用Helm将图表部署到命名空间中。要使用Helm安装图表，请使用**Helm install <name> <chart>
    <options>**：
- en: '**helm install openunison tremolo/openunison-operator --namespace openunison**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**helm install openunison tremolo/openunison-operator --namespace openunison**'
- en: '**NAME: openunison**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**NAME: openunison**'
- en: '**LAST DEPLOYED: Fri Apr 17 15:04:50 2020**'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '**LAST DEPLOYED: Fri Apr 17 15:04:50 2020**'
- en: '**NAMESPACE: openunison**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**NAMESPACE: openunison**'
- en: '**STATUS: deployed**'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '**STATUS: deployed**'
- en: '**REVISION: 1**'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**REVISION: 1**'
- en: '**TEST SUITE: None**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**TEST SUITE: None**'
- en: The operator will take a few minutes to finish deploying.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符将需要几分钟来完成部署。
- en: Important Note
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An operator is a concept that was pioneered by CoreOS with the goal of encapsulating
    many of the tasks an administrator may perform that can be automated. Operators
    are implemented by watching for changes to a specific CRD and acting accordingly.
    The OpenUnison operator looks for objects of the OpenUnison type and will create
    any objects that are needed. A secret is created with a PKCS12 file; Deployment,
    Service and Ingress objects are all created too. As you make changes to an OpenUnison
    object, the operator makes updates to the Kubernetes object as needed. For instance,
    if you change the image in the OpenUnison object, the operator updates the Deployment,
    which triggers Kubernetes to rollout new pods. For SAML, the operator also watches
    metadata so that if it changes, the updated certificates are imported.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是由CoreOS首创的一个概念，旨在封装管理员可能执行的许多可以自动化的任务。运算符通过观察特定CRD的更改并相应地采取行动来实现。OpenUnison运算符寻找OpenUnison类型的对象，并将创建所需的任何对象。一个包含PKCS12文件的密钥被创建；还创建了Deployment、Service和Ingress对象。当您对OpenUnison对象进行更改时，运算符会根据需要更新Kubernetes对象。例如，如果您更改了OpenUnison对象中的图像，运算符会更新Deployment，从而触发Kubernetes滚动部署新的pod。对于SAML，运算符还会监视元数据，以便在更改时导入更新的证书。
- en: 'Once the operator has been deployed, we need to create a secret that will store
    passwords used internally by OpenUnison. Make sure to use your own values for
    the keys in this secret (remember to base64 encode them):'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运算符部署完成，我们需要创建一个存储OpenUnison内部使用的密码的密钥。确保在此密钥中使用您自己的键的值（记得对它们进行base64编码）：
- en: '**kubectl create -f - <<EOF**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f - <<EOF**'
- en: '**apiVersion: v1**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**apiVersion: v1**'
- en: '**type: Opaque**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**type: Opaque**'
- en: '**metadata:**'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**metadata:**'
- en: '**   name: orchestra-secrets-source**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**name: orchestra-secrets-source**'
- en: '**   namespace: openunison**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**namespace: openunison**'
- en: '**data:**'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '**data:**'
- en: '**   K8S_DB_SECRET: cGFzc3dvcmQK**'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '**K8S_DB_SECRET: cGFzc3dvcmQK**'
- en: '**   unisonKeystorePassword: cGFzc3dvcmQK**'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**unisonKeystorePassword: cGFzc3dvcmQK**'
- en: '**kind: Secret**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**kind: Secret**'
- en: '**EOF**'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '**EOF**'
- en: '**secret/orchestra-secrets-source created**'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**secret/orchestra-secrets-source created**'
- en: Important Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: From here on out, we'll assume you're using Tremolo Security's testing identity
    provider. This tool will let you customize the user's login information without
    having to stand up a directory and identity provider. Register by going to https://portal.apps.tremolo.io/and
    clicking on **Register**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将假设您正在使用Tremolo Security的测试身份提供者。该工具将允许您自定义用户的登录信息，而无需搭建目录和身份提供者。注册，请访问https://portal.apps.tremolo.io/并单击**注册**。
- en: To provide the accounts for the OIDC environment, we will use a SAML2 testing
    lab, so be sure to register before moving on.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供OIDC环境的帐户，我们将使用SAML2测试实验室，因此请确保在继续之前注册。
- en: First, we need to need to log into the testing identity provider by going to
    [https://portal.apps.tremolo.io/](https://portal.apps.tremolo.io/) and clicking
    on the **SAML2 Test Lab** badge:![Figure 7.3 – SAML2 Test Lab badge
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过访问[https://portal.apps.tremolo.io/](https://portal.apps.tremolo.io/)并单击**SAML2测试实验室**徽章来登录测试身份提供者：![图7.3
    – SAML2测试实验徽章
- en: '](image/Fig_7.3_B15514.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.3_B15514.jpg)'
- en: Figure 7.3 – SAML2 Test Lab badge
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – SAML2测试实验徽章
- en: Once you've clicked on the badge, you'll be presented with a screen that shows
    your test IdP metadata URL:![Figure 7.4 – Testing identity provider's page, highlighting
    the SAML2 metadata URL
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击徽章后，将显示一个屏幕，显示您的测试IdP元数据URL：![图7.4 – 测试身份提供者页面，突出显示SAML2元数据URL
- en: '](image/Fig_7.4_B15514.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.4_B15514.jpg)'
- en: Figure 7.4 – Testing identity provider's page, highlighting the SAML2 metadata
    URL
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 测试身份提供者页面，突出显示SAML2元数据URL
- en: Copy this value and store it in a safe place.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 复制此值并将其存储在安全的地方。
- en: 'Now, we need to create a **values.yaml** file that will be used to supply configuration
    information when we deploy OpenUnison. This book''s GitHub repository contains
    a base file in the **chapter7** directory:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个**values.yaml**文件，用于在部署OpenUnison时提供配置信息。本书的GitHub存储库中包含**chapter7**目录中的基本文件：
- en: 'network:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'openunison_host: "k8sou.apps.XX-XX-XX-XX.nip.io"'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: openunison_host："k8sou.apps.XX-XX-XX-XX.nip.io"
- en: 'dashboard_host: "k8sdb.apps.XX-XX-XX-XX.nip.io"'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: dashboard_host："k8sdb.apps.XX-XX-XX-XX.nip.io"
- en: 'api_server_host: ""'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: api_server_host：""
- en: 'session_inactivity_timeout_seconds: 900'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: session_inactivity_timeout_seconds：900
- en: 'k8s_url: https://0.0.0.0:6443'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: k8s_url：https://0.0.0.0:6443
- en: 'cert_template:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: cert_template：
- en: 'ou: "Kubernetes"'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ou："Kubernetes"
- en: 'o: "MyOrg"'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: o："MyOrg"
- en: 'l: "My Cluster"'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: l："我的集群"
- en: 'st: "State of Cluster"'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: st："集群状态"
- en: 'c: "MyCountry"'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: c："MyCountry"
- en: 'image: "docker.io/tremolosecurity/openunison-k8s-login-saml2:latest"'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像："docker.io/tremolosecurity/openunison-k8s-login-saml2:latest"
- en: 'myvd_config_path: "WEB-INF/myvd.conf"'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: myvd_config_path："WEB-INF/myvd.conf"
- en: 'k8s_cluster_name: kubernetes'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: k8s_cluster_name：kubernetes
- en: 'enable_impersonation: false'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: enable_impersonation：false
- en: 'dashboard:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板：
- en: 'namespace: "kubernetes-dashboard"'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间："kubernetes-dashboard"
- en: 'cert_name: "kubernetes-dashboard-certs"'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: cert_name："kubernetes-dashboard-certs"
- en: 'label: "k8s-app=kubernetes-dashboard"'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 标签："k8s-app=kubernetes-dashboard"
- en: 'service_name: kubernetes-dashboard'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: service_name：kubernetes-dashboard
- en: 'certs:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 证书：
- en: 'use_k8s_cm: false'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: use_k8s_cm：false
- en: 'trusted_certs: []'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: trusted_certs：[]
- en: 'monitoring:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 监控：
- en: 'prometheus_service_account: system:serviceaccount:monitoring:prometheus-k8s'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: prometheus_service_account：system:serviceaccount:monitoring:prometheus-k8s
- en: 'saml:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: saml：
- en: 'idp_url: https://portal.apps.tremolo.io/idp-test/metadata/dfbe4040-cd32-470e-a9b6-809c840'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: idp_url：https://portal.apps.tremolo.io/idp-test/metadata/dfbe4040-cd32-470e-a9b6-809c840
- en: 'metadata_xml_b64: ""'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: metadata_xml_b64：""
- en: 'You need to change the following values for your deployment:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要更改部署的以下值：
- en: '**Network: openunison_host:** This value should use the IP address of your
    cluster, which is the IP address of your Docker host; for example, **k8sou.apps.192-168-2=131.nip.io**.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络：openunison_host：**此值应使用集群的IP地址，即Docker主机的IP地址；例如，**k8sou.apps.192-168-2=131.nip.io**。'
- en: '**Network: dashboard_host**: This value should use the IP address of your cluster,
    which is the IP address of your Docker host; for example, **k8sdb.apps.192-168-2-131.nip.io**.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络：dashboard_host**：此值应使用集群的IP地址，即Docker主机的IP地址；例如，**k8sdb.apps.192-168-2-131.nip.io**。'
- en: '**saml: idp url**: This value should be the SAML2 metadata URL that you retrieved
    from the SAML2 lab page in the previous step.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**saml：idp url**：此值应该是您从上一步中的SAML2实验室页面检索到的SAML2元数据URL。'
- en: After you've edited or created the file using your own entries, save the file
    and move on to deploying your OIDC provider.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用您自己的条目编辑或创建文件后，保存文件并继续部署您的OIDC提供者。
- en: 'To deploy OpenUnison using your **values.yaml** file, execute a **Helm install**
    command that uses the **-f** option to specify the **values.yaml** file:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用您的**values.yaml**文件部署OpenUnison，执行一个使用**-f**选项指定**values.yaml**文件的**Helm
    install**命令：
- en: '**helm install orchestra tremolo/openunison-k8s-login-saml2 --namespace openunison
    -f ./values.yaml**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**helm install orchestra tremolo/openunison-k8s-login-saml2 --namespace openunison
    -f ./values.yaml**'
- en: '**NAME: orchestra**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称：管弦乐队**'
- en: '**LAST DEPLOYED: Fri Apr 17 16:02:00 2020**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**上次部署：2020年4月17日星期五16:02:00**'
- en: '**NAMESPACE: openunison**'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间：openunison**'
- en: '**STATUS: deployed**'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态：已部署**'
- en: '**REVISION: 1**'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**修订版本：1**'
- en: '**TEST SUITE: None**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试套件：无**'
- en: 'In a few minutes, OpenUnison will be up and running. Check the deployment status
    by getting the pods in the **openunison** namespace:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，OpenUnison将启动并运行。通过获取**openunison**命名空间中的pod来检查部署状态：
- en: '**kubectl get pods -n openunison**'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl get pods -n openunison**'
- en: '**NAME                                    READY   STATUS    RESTARTS   AGE**'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称                                    准备就绪    状态    重启次数    年龄**'
- en: '**openunison-operator-858d496-zzvvt       1/1    Running   0          5d6h**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**openunison-operator-858d496-zzvvt       1/1    运行中   0          5d6h**'
- en: '**openunison-orchestra-57489869d4-88d2v   1/1     Running   0          85s**'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**openunison-orchestra-57489869d4-88d2v   1/1     运行中   0          85s**'
- en: 'There is one more step you need to follow to complete the OIDC deployment:
    you need to update the SAML2 lab with the relying party for your deployment.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要执行一步才能完成OIDC部署：您需要更新SAML2实验室的依赖方以完成部署。
- en: 'Now that OpenUnison is running, we need to get the SAML2 metadata from OpenUnison
    using the host in **network.openunison_host** in our **values.yaml** file and
    the **/auth/forms/saml2_rp_metadata.jsp** path:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在OpenUnison正在运行，我们需要使用**values.yaml**文件中的**network.openunison_host**主机和**/auth/forms/saml2_rp_metadata.jsp**路径从OpenUnison获取SAML2元数据：
- en: '**curl --insecure https://k8sou.apps.192-168-2-131.nip.io/auth/forms/saml2_rp_metadata.jsp**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**curl --insecure https://k8sou.apps.192-168-2-131.nip.io/auth/forms/saml2_rp_metadata.jsp**'
- en: '**<?xml version="1.0" encoding="UTF-8"?><md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    ID="fc334f48076b7b13c3fcc83d1d116ac2decd7d665" entityID="https://k8sou.apps.192-168-2-131.nip.io/auth/SAML2Auth">**'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**<?xml version="1.0" encoding="UTF-8"?><md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    ID="fc334f48076b7b13c3fcc83d1d116ac2decd7d665" entityID="https://k8sou.apps.192-168-2-131.nip.io/auth/SAML2Auth">**'
- en: '**.**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: '**.**'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: '**.**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**.**'
- en: Copy the output, paste it into the testing identity provider where it says **Meta
    Data**, and click **Update Relying Party**:![Figure 7.5 – Testing the identity
    provider with the relying party metadata
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制输出，粘贴到测试身份提供者的“元数据”处，然后点击“更新依赖方”：![图7.5-使用依赖方元数据测试身份提供者
- en: '](image/Fig_7.5_B15514.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.5_B15514.jpg)'
- en: Figure 7.5 – Testing the identity provider with the relying party metadata
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5-使用依赖方元数据测试身份提供者
- en: Finally, we need to add some attributes to our test user. Add the attributes
    shown in the following screenshot:![Figure 7.6 – Identity provider test user configuration
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为我们的测试用户添加一些属性。添加以下截图中显示的属性：![图7.6-身份提供者测试用户配置
- en: '](image/Fig_7.6_B15514.jpg)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.6_B15514.jpg)'
- en: Figure 7.6 – Identity provider test user configuration
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6-身份提供者测试用户配置
- en: Next, click **Update Test User Data** to save your attributes. With that, you're
    ready to log in.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击**更新测试用户数据**以保存您的属性。有了这个，你就可以登录了。
- en: You can log into the OIDC provider using any machine on your network by using
    the assigned nip.io address. Since we will test access using the dashboard, you
    can use any machine with a browser. Navigate your browser to **network.openunison_host**
    in your **values.yaml** file. Enter your testing identity provider credentials,
    if needed, and then click **Finish Login** at the bottom of the screen. You should
    now be logged into OpenUnison:![Figure 7.7 – OpenUnison home screen
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用分配的nip.io地址在网络上的任何计算机上登录OIDC提供程序。由于我们将使用仪表板进行访问测试，您可以使用任何带有浏览器的计算机。在**values.yaml**文件中将您的浏览器导航到**network.openunison_host**。如果需要，输入您的测试身份提供者凭据，然后在屏幕底部点击**完成登录**。您现在应该已经登录到OpenUnison：![图7.7
    - OpenUnison主屏幕
- en: '](image/Fig_7.7_B15514.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.7_B15514.jpg)'
- en: Figure 7.7 – OpenUnison home screen
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 - OpenUnison主屏幕
- en: 'Let''s test the OIDC provider by clicking on the **Kubernetes Dashboard** link.
    Don''t panic when you look at the initial dashboard screen – you''ll see something
    like the following:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过点击**Kubernetes仪表板**链接来测试OIDC提供程序。当您查看初始仪表板屏幕时不要惊慌 - 您会看到类似以下内容：
- en: '![](image/Fig_7.8_B15514.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Fig_7.8_B15514.jpg)'
- en: Figure 7.8 – Kubernetes Dashboard before SSO integration has been completed
    with the API server
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 - 在API服务器完成SSO集成之前的Kubernetes仪表板
- en: That looks like a lot of errors! We're in the dashboard, but nothing seems to
    be authorized.That's because the API server doesn't trust the tokens that have
    been generated by OpenUnison yet. The next step is to tell Kubernetes to trust
    OpenUnison as its OpenID Connect Identity Provider.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来像是很多错误！我们在仪表板上，但似乎没有被授权。这是因为API服务器尚不信任OpenUnison生成的令牌。下一步是告诉Kubernetes信任OpenUnison作为其OpenID
    Connect身份提供者。
- en: Configuring the Kubernetes API to use OIDC
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Kubernetes API使用OIDC
- en: At this point, you have deployed OpenUnison as an OIDC provider and it's working,
    but your Kubernetes cluster has not been configured to use it as a provider yet.
    To configure the API server to use an OIDC provider, you need to add the OIDC
    options to the API server and provide the OIDC certificate so that the API will
    trust the OIDC provider.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您已经部署了OpenUnison作为OIDC提供程序，并且它正在工作，但是您的Kubernetes集群尚未配置为使用它作为提供程序。要配置API服务器使用OIDC提供程序，您需要向API服务器添加OIDC选项，并提供OIDC证书，以便API信任OIDC提供程序。
- en: Since we are using KinD, we can add the required options using a few **kubectl**
    and **docker** commands.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用KinD，我们可以使用一些**kubectl**和**docker**命令添加所需的选项。
- en: 'To provide the OIDC certificate to the API server, we need to retrieve the
    certificate and copy it over to the KinD master server. We can do this using two
    commands on the Docker host:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要向API服务器提供OIDC证书，我们需要检索证书并将其复制到KinD主服务器上。我们可以在Docker主机上使用两个命令来完成这个任务：
- en: 'The first command extracts OpenUnison''s TLS certificate from its secret. This
    is the same secret referenced by OpenUnison''s Ingress object. We use the **jq**
    utility to extract the data from the secret and then base64 decode it:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一个命令从其密钥中提取OpenUnison的TLS证书。这是OpenUnison的Ingress对象引用的相同密钥。我们使用**jq**实用程序从密钥中提取数据，然后对其进行base64解码：
- en: '**kubectl get secret ou-tls-certificate -n openunison -o json | jq -r ''.data["tls.crt"]''
    | base64 -d > ou-ca.pem**'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl get secret ou-tls-certificate -n openunison -o json | jq -r ''.data["tls.crt"]''
    | base64 -d > ou-ca.pem**'
- en: 'The second command will copy the certificate to the master server into the
    **/etc/Kubernetes/pki** directory:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个命令将把证书复制到主服务器的**/etc/Kubernetes/pki**目录中：
- en: '**docker cp ou-ca.pem cluster01-control-plane:/etc/kubernetes/pki/ou-ca.pem**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker cp ou-ca.pem cluster01-control-plane:/etc/kubernetes/pki/ou-ca.pem**'
- en: 'As we mentioned earlier, to integrate the API server with OIDC, we need to
    have the OIDC values for the API options. To list the options we will use, describe
    the **api-server-config** ConfigMap in the **openunison** namespace:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，要将 API 服务器与 OIDC 集成，我们需要为 API 选项准备 OIDC 值。要列出我们将使用的选项，请在 **openunison**
    命名空间中描述 **api-server-config** ConfigMap：
- en: '**kubectl describe configmap api-server-config -n openunison**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl describe configmap api-server-config -n openunison**'
- en: '**Name:         api-server-config**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称:         api-server-config**'
- en: '**Namespace:    openunison**'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间:    openunison**'
- en: '**Labels:       <none>**'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**标签:       <无>**'
- en: '**Annotations:  <none>**'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**注释:  <无>**'
- en: '**Data**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据**'
- en: '**====**'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '**====**'
- en: '**oidc-api-server-flags:**'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**oidc-api-server-flags:**'
- en: '**----**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**----**'
- en: '**--oidc-issuer-url=https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp**'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**--oidc-issuer-url=https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp**'
- en: '**--oidc-client-id=kubernetes**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**--oidc-client-id=kubernetes**'
- en: '**--oidc-username-claim=sub**'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: --oidc-username-claim=sub
- en: '**--oidc-groups-claim=groups**'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '**--oidc-groups-claim=groups**'
- en: '**--oidc-ca-file=/etc/kubernetes/pki/ou-ca.pem**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**--oidc-ca-file=/etc/kubernetes/pki/ou-ca.pem**'
- en: 'Next, edit the API server configuration. OpenID Connect is configured by changing
    flags on the API server. This is why managed Kubernetes generally doesn''t offer
    OpenID Connect as an option, but we''ll cover that later in this chapter. Every
    distribution handles these changes differently, so check with your vendor''s documentation.
    For KinD, shell into the control plane and update the manifest file:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，编辑 API 服务器配置。通过更改 API 服务器上的标志来配置 OpenID Connect。这就是为什么托管的 Kubernetes 通常不提供
    OpenID Connect 作为选项，但我们将在本章后面介绍。每个发行版处理这些更改的方式都不同，因此请查阅您供应商的文档。对于 KinD，请进入控制平面并更新清单文件：
- en: '**docker exec -it cluster-auth-control-plane bash**'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**docker exec -it cluster-auth-control-plane bash**'
- en: '**apt-get update**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**apt-get update**'
- en: '**apt-get install vim**'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**apt-get install vim**'
- en: '**vi /etc/kubernetes/manifests/kube-apiserver.yaml**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**vi /etc/kubernetes/manifests/kube-apiserver.yaml**'
- en: 'Look for two options under **command** called **--oidc-client** and **–oidc-issuer-url**.
    Replace those two with the output from the preceding command that produced the
    API server flags. Make sure to add spacing and a dash (**-**) in front. It should
    look something like this when you''re done:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **command** 下查找两个选项，分别为 **--oidc-client** 和 **–oidc-issuer-url**。用前面命令产生的
    API 服务器标志的输出替换这两个选项。确保在前面加上空格和破折号（**-**）。完成后应该看起来像这样：
- en: '- --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '- --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname'
- en: '- --oidc-issuer-url=https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '- --oidc-issuer-url=https://k8sou.apps.192-168-2-131.nip.io/auth/idp/k8sIdp'
- en: '- --oidc-client-id=kubernetes'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '- --oidc-client-id=kubernetes'
- en: '- --oidc-username-claim=sub'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '- --oidc-username-claim=sub'
- en: '- --oidc-groups-claim=groups'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '- --oidc-groups-claim=groups'
- en: '- --oidc-ca-file=/etc/kubernetes/pki/ou-ca.pem'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '- --oidc-ca-file=/etc/kubernetes/pki/ou-ca.pem'
- en: '- --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '- --proxy-client-cert-file=/etc/kubernetes/pki/front-proxy-client.crt'
- en: 'Exit vim and the Docker environment (*ctl+d*) and then take a look at the **api-server**
    pod:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出 vim 和 Docker 环境（*ctl+d*），然后查看 **api-server** pod：
- en: kubectl get pod kube-apiserver-cluster-auth-control-plane -n kube-system
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get pod kube-apiserver-cluster-auth-control-plane -n kube-system
- en: NAME                      READY   STATUS    RESTARTS  AGE kube-apiserver-cluster-auth-control-plane   1/1  Running
    0 73s
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 名称                      准备   状态    重启  年龄 kube-apiserver-cluster-auth-control-plane   1/1  运行中
    0 73秒
- en: Notice that it's only **73s** old. That's because KinD saw that there was a
    change in the manifest and restarted the API server.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它只有 **73 秒**。这是因为 KinD 看到清单有变化，所以重新启动了 API 服务器。
- en: Important Note
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The API server pod is known as a "static pod". This pod can't be changed directly;
    its configuration has to be changed from the manifest on disk. This gives you
    a process that's managed by the API server as a container, but without giving
    you a situation where you need to edit pod manifests in EtcD directly if something
    goes wrong.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器pod被称为“静态pod”。这个pod不能直接更改；它的配置必须从磁盘上的清单中更改。这为您提供了一个由API服务器作为容器管理的过程，但如果出现问题，您不需要直接在EtcD中编辑pod清单。
- en: Verifying OIDC integration
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证OIDC集成
- en: 'Once OpenUnison and the API server have been integrated, we need to test that
    the connection is working:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦OpenUnison和API服务器集成完成，我们需要测试连接是否正常：
- en: To test the integration, log back into OpenUnison and click on the **Kubernetes
    Dashboard** link again.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试集成，请重新登录OpenUnison，然后再次单击**Kubernetes仪表板**链接。
- en: Click on the bell in the upper right and you'll see a different error:![](image/Fig_7.9_B15514.jpg)
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击右上角的铃铛，您会看到一个不同的错误：![](image/Fig_7.9_B15514.jpg)
- en: Figure 7.9 – SSO enabled but the user is not authorized to access any resources
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9 - 启用SSO，但用户未被授权访问任何资源
- en: 'SSO between OpenUnison and you''ll see that Kubernetes is working! However,
    the new error, **service is forbidden: User https://...**, is an authorization
    error, **not** an authentication error. The API server knows who we are, but isn''t
    letting us access the APIs.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 'OpenUnison和您之间的SSO，您会发现Kubernetes正在工作！但是，新错误**service is forbidden: User https://...**是一个授权错误，**而不是**身份验证错误。API服务器知道我们是谁，但不允许我们访问API。'
- en: 'We''ll dive into the details of RBAC and authorizations in the next chapter,
    but for now, create this RBAC binding:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在下一章详细介绍RBAC和授权，但现在，请创建此RBAC绑定：
- en: '**kubectl create -f - <<EOF**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**kubectl create -f - <<EOF**'
- en: '**apiVersion: rbac.authorization.k8s.io/v1**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: api版本：rbac.authorization.k8s.io/v1
- en: '**kind: ClusterRoleBinding**'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 类型：ClusterRoleBinding
- en: '**metadata:**'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: '**   name: ou-cluster-admins**'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '   名称：ou-cluster-admins'
- en: '**subjects:**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 主题：
- en: '**- kind: Group**'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '- 类型：组'
- en: '**   name: k8s-cluster-admins**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '   名称：k8s-cluster-admins'
- en: '**   apiGroup: rbac.authorization.k8s.io**'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '   api组：rbac.authorization.k8s.io'
- en: '**roleRef:**'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 角色引用：
- en: '**   kind: ClusterRole**'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '   类型：ClusterRole'
- en: '**   name: cluster-admin**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '   名称：cluster-admin'
- en: '**   apiGroup: rbac.authorization.k8s.io**'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '   api组：rbac.authorization.k8s.io'
- en: '**EOF**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: EOF
- en: '**clusterrolebinding.rbac.authorization.k8s.io/ou-cluster-admins created**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: clusterrolebinding.rbac.authorization.k8s.io/ou-cluster-admins已创建
- en: Finally, go back to the dashboard and you'll see that you have full access to
    your cluster and all that of error messages are gone.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，返回仪表板，您会发现您对集群拥有完全访问权限，所有错误消息都已消失。
- en: The API server and OpenUnison are now connected. Additionally, an RBAC policy
    has been created to enable our test user to manage the cluster as an administrator.
    Access was verified by logging into the Kubernetes dashboard, but most interactions
    will take place using the **kubectl** command. The next step is to verify we're
    able to access the cluster using **kubectl**.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: API服务器和OpenUnison现在已连接。此外，已创建了一个RBAC策略，以使我们的测试用户能够作为管理员管理集群。通过登录Kubernetes仪表板验证了访问权限，但大多数交互将使用**kubectl**命令进行。下一步是验证我们能够使用**kubectl**访问集群。
- en: Using your tokens with kubectl
  id: totrans-442
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用您的令牌与kubectl
- en: Important Note
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: This section assumes you have a machine on your network that has a browser and
    **kubectl** running.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 本节假定您的网络中有一台计算机，上面有一个浏览器和正在运行的**kubectl**。
- en: 'Using the Dashboard has its use cases, but you will likely interact with the
    API server using **kubectl**, rather than the dashboard, for the majority of your
    day. In this section, we will explain how to retrieve your JWT and how to add
    it to your Kubernetes config file:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仪表板有其用例，但您可能会在大部分时间内使用**kubectl**与API服务器进行交互，而不是使用仪表板。在本节中，我们将解释如何检索您的JWT以及如何将其添加到Kubernetes配置文件中：
- en: You can retrieve you token from the OpenUnison dashboard. Navigate to the OpenUnison
    home page and click on the key that says **Kubernetes Tokens**. You'll see a screen
    that looks as follows:![Figure 7.10 – OpenUnison kubectl configuration tool
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以从OpenUnison仪表板中检索令牌。转到OpenUnison主页，单击标有**Kubernetes Tokens**的密钥。您将看到以下屏幕：![图7.10
    – OpenUnison kubectl配置工具
- en: '](image/Fig_7.10_B15514.jpg)'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.10_B15514.jpg)'
- en: Figure 7.10 – OpenUnison kubectl configuration tool
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – OpenUnison kubectl配置工具
- en: OpenUnison provides a command line that you can copy and paste into your host
    session that adds all the required information to your config.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: OpenUnison提供了一个命令行，您可以将其复制并粘贴到主机会话中，以将所有必需的信息添加到您的配置中。
- en: First, click on the double documents button next to the **kubectl** command
    to copy your **kubectl** command into your buffer. Leave the web browser open
    in the background.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击**kubectl**命令旁边的双文档按钮，将**kubectl**命令复制到缓冲区中。将网页浏览器保持在后台打开。
- en: 'You may want to back up your original config file before pasting the **kubectl**
    command from OpenUnison:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从OpenUnison粘贴**kubectl**命令之前，您可能希望备份原始配置文件：
- en: cp .kube/config .kube/config.bak
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: cp .kube/config .kube/config.bak
- en: export KUBECONFIG=/tmp/k
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: export KUBECONFIG=/tmp/k
- en: kubectl get nodes
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes
- en: '**W0423 15:46:46.924515    3399 loader.go:223] Config not found: /tmp/k error:
    no configuration has been provided, try setting KUBERNETES_MASTER environment
    variable**'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '**W0423 15:46:46.924515    3399 loader.go:223] Config not found: /tmp/k error:
    no configuration has been provided, try setting KUBERNETES_MASTER environment
    variable**'
- en: 'Then, go to your host console and paste the command into the console (the following
    output has been shortened, but your paste will start with the same output):'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，转到主机控制台，并将命令粘贴到控制台中（以下输出已经被缩短，但您的粘贴将以相同的输出开头）：
- en: export TMP_CERT=$(mktemp) && echo -e "-----BEGIN CER. . .
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: export TMP_CERT=$(mktemp) && echo -e "-----BEGIN CER. . .
- en: '**Cluster "kubernetes" set.**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 已设置集群"kubernetes"。
- en: '**Context "kubernetes" modified.**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文"kubernetes"已修改。
- en: '**User "mlbiamext" set.**'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户"mlbiamext"已设置。**'
- en: '**Switched to context "kubernetes".**'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 已切换到上下文"kubernetes"。
- en: 'Now, verify that you can view the cluster nodes using **kubectl get nodes**:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，验证您是否可以使用**kubectl get nodes**查看集群节点：
- en: kubectl get nodes
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes
- en: '**NAME                         STATUS   ROLES    AGE   VERSION**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称                         状态   角色    年龄   版本**'
- en: '**cluster-auth-control-plane   Ready    master   47m   v1.17.0**'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '**cluster-auth-control-plane   就绪    主节点   47分钟   v1.17.0**'
- en: '**cluster-auth-worker          Ready    <none>   46m   v1.17.0**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**cluster-auth-worker          就绪    <none>   46分钟   v1.17.0**'
- en: 'You are now using your login credentials instead of the master certificate!
    As you work, the session will refresh. Log out of OpenUnison and watch the list
    of nodes. Within a minute or two, your token will expire and no longer work:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在使用登录凭据而不是主证书！在您工作时，会话将会刷新。注销OpenUnison并观察节点列表。一两分钟内，您的令牌将过期并且不再起作用：
- en: '**$ kubectl get nodes**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ kubectl get nodes**'
- en: '**Unable to connect to the server: failed to refresh token: oauth2: cannot
    fetch token: 401 Unauthorized**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法连接到服务器：无法刷新令牌：oauth2：无法获取令牌：401未经授权**'
- en: 'Congratulations! You''ve now set up your cluster so that it does the following:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已设置好您的集群，使其可以执行以下操作：
- en: Authenticate using SAML2 using your enterprise's existing authentication system.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SAML2进行身份验证，使用您企业现有的身份验证系统。
- en: Use groups from your centralized authentication system to authorize access to
    Kubernetes (we'll get into the details of how in the next chapter).
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用来自集中式身份验证系统的组来授权对Kubernetes的访问（我们将在下一章中详细介绍）。
- en: Give access to your users to both the CLI and the dashboard using the centralized
    credentials.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集中式凭据为用户提供对CLI和仪表板的访问权限。
- en: Maintain your enterprise's compliance requirements by having short-lived tokens
    that provide a way to time out.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过提供一种超时的方式，维护企业的合规性要求，以提供短暂的令牌。
- en: Everything uses TLS from the user's browser, to the Ingress Controller, to OpenUnison,
    the dashboard, and finally the API server.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从用户的浏览器到Ingress Controller，再到OpenUnison、仪表板，最后到API服务器，所有内容都使用TLS。
- en: Next, you'll learn how to integrate centralized authentication into your managed
    clusters.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何将集中身份验证集成到托管的集群中。
- en: Introducing impersonation to integrate authentication with cloud-managed clusters
  id: totrans-477
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入冒充以将身份验证与云托管集群集成
- en: 'It''s very popular to use managed Kubernetes services from cloud vendors such
    as Google, Amazon, Microsoft, and DigitalOcean (among many others). When it comes
    to these services, its generally very quick to get up and running, and they all
    share a common thread: they don''t support OpenID Connect.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自谷歌、亚马逊、微软和DigitalOcean等云供应商的托管Kubernetes服务非常受欢迎（还有许多其他供应商）。在使用这些服务时，通常非常快速启动，并且它们都有一个共同的特点：它们不支持OpenID
    Connect。
- en: 'Earlier in this chapter, we talked about how Kubernetes supports custom authentication
    solutions through webhooks and that you should never, ever, use this approach
    unless you are a public cloud provider or some other host of Kubernetes systems.
    It turns out that pretty much every cloud vendor has its own approach to using
    these webhooks that uses their own identity and access management implementations.
    In that case, why not just use what the vendor provides? There are several reasons
    why you may not want to use a cloud vendor''s IAM system:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面，我们谈到了Kubernetes通过webhook支持自定义身份验证解决方案，并且除非您是公共云提供商或其他Kubernetes系统的主机，否则绝对不要使用这种方法。事实证明，几乎每个云供应商都有自己的方法来使用这些webhook，使用他们自己的身份和访问管理实现。在这种情况下，为什么不使用供应商提供的呢？有几个原因您可能不想使用云供应商的IAM系统：
- en: '**Technical**: You may want to support features not offered by the cloud vendor,
    such as the dashboard, in a secure fashion.'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术**：您可能希望以安全的方式支持云供应商未提供的功能，比如仪表板。'
- en: '**Organizational**: Tightly coupling access to managed Kubernetes with that
    cloud''s IAM puts an additional burden on the cloud team, which means that they
    may not want to manage access to your clusters.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**：将对托管的Kubernetes的访问与云的IAM紧密耦合会给云团队增加额外负担，这意味着他们可能不想管理对您的集群的访问。'
- en: '**User Experience**: Your developers and admins may have to work across multiple
    clouds. Providing a consistent login experience makes it easier on them and requires
    learning fewer tools.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户体验**：您的开发人员和管理员可能需要跨多个云进行工作。提供一致的登录体验可以让他们更容易，并且需要学习更少的工具。'
- en: '**Security and Compliance**: The cloud implementation may not offer choices
    that line up with your enterprise''s security requirements, such as short-lived
    tokens and idle timeouts.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和合规性**：云实施可能不提供符合企业安全要求的选择，比如短暂的令牌和空闲超时。'
- en: All that being said, there may be reasons to use the cloud vendor's implementation.
    You'll need to balance out the requirements, though. If you want to continue to
    use centralized authentication and authorization with hosted Kubernetes, you'll
    need to learn how to work with Impersonation.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，可能有理由使用云供应商的实现。但您需要权衡需求。如果您想继续在托管的Kubernetes中使用集中身份验证和授权，您需要学习如何使用冒充。
- en: What is Impersonation?
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是冒充？
- en: 'Kubernetes Impersonation is a way of telling the API server who you are without
    knowing your credentials or forcing the API server to trust an OpenID Connect
    IdP. When you use **kubectl**, instead of the API server receiving your **id_token**
    directly, it will receive a service account or identifying certificate that will
    be authorized to impersonate users, as well as a set of headers that tell the
    API server who the proxy is acting on behalf of:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes模拟登录是一种告诉API服务器您是谁的方式，而不知道您的凭据或强制API服务器信任OpenID Connect IdP。当您使用**kubectl**时，API服务器不会直接接收您的**id_token**，而是会接收一个服务账户或标识证书，该证书将被授权模拟用户，以及一组标头，告诉API服务器代理是代表谁在操作：
- en: '![Figure 7.11 – Diagram of how a user interacts with the API server when using
    Impersonation'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.11 – 用户在使用模拟登录时与API服务器交互的示意图'
- en: '](image/Fig_7.11_B15514.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.11_B15514.jpg)'
- en: Figure 7.11 – Diagram of how a user interacts with the API server when using
    Impersonation
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 用户在使用模拟登录时与API服务器交互的示意图
- en: 'The reverse proxy is responsible for determining how to map from **id_token**,
    which the user provides (or any other token, for that matter), to the **Impersonate-User**
    and **Impersonate-Group** HTTP headers. The dashboard should never be deployed
    with a privileged identity, which the ability to impersonate falls under. To allow
    Impersonation with the 2.0 dashboard, use a similar model, but instead of going
    to the API server, you go to the dashboard:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 反向代理负责确定如何从用户提供的**id_token**（或者其他任何令牌）映射到**模拟用户**和**模拟组**HTTP标头。仪表板永远不应该部署具有特权身份，模拟登录的能力属于特权。要允许2.0仪表板进行模拟登录，使用类似的模型，但是不是直接到API服务器，而是到仪表板：
- en: '![Figure 7.12 – Kubernetes Dashboard with Impersonation'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.12 – 使用模拟登录的Kubernetes仪表板'
- en: '](image/Fig_7.12_B15514.jpg)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Fig_7.12_B15514.jpg)'
- en: Figure 7.12 – Kubernetes Dashboard with Impersonation
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 带有模拟登录的Kubernetes仪表板
- en: The user interacts with the reverse proxy just like any web application. The
    reverse proxy uses its own service account and adds the impersonation headers.
    The dashboard passes this information through to the API server on all requests.
    The dashboard never has its own identity.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 用户与反向代理的交互就像任何Web应用程序一样。反向代理使用自己的服务账户并添加模拟登录标头。仪表板通过所有请求将此信息传递给API服务器。仪表板从不具有自己的身份。
- en: Security considerations
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全考虑
- en: 'The service account has a certain superpower: it can be used to impersonate
    **anyone** (depending on your RBAC definitions). If you''re running your reverse
    proxy from inside the cluster, a service account is OK, especially if combined
    with the **TokenRequest** API to keep the token short-lived. Earlier in the chapter,
    we talked about **ServiceAccount** objects having no expiration. That''s important
    here because if you''re hosting your reverse proxy off cluster, then if it were
    compromised, someone could use that service account to access the API service
    as anyone. Make sure you''re rotating that service account often. If you''re running
    the proxy off cluster, it''s probably best to use a shorter-lived certificate
    instead of a service account.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户具有某种超级权限：它可以被用来模拟**任何人**（取决于您的RBAC定义）。如果您从集群内部运行反向代理，那么服务账户是可以的，特别是如果与**TokenRequest**
    API结合使用以保持令牌的短暂性。在本章的前面，我们谈到**ServiceAccount**对象没有过期时间。这里很重要，因为如果您将反向代理托管在集群外部，那么如果它被
    compromise，某人可以使用该服务账户以任何人的身份访问API服务。确保您经常更换该服务账户。如果您在集群外运行代理，最好使用较短寿命的证书而不是服务账户。
- en: When running the proxy on a cluster, you want to make sure it's locked down.
    It should run in its own namespace at a minimum. Not **kube-system** either. You
    want to minimize who has access. Using multi-factor authentication to get to that
    namespace is always a good idea, as are network policies that control what pods
    can reach out to the reverse proxy.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群上运行代理时，您希望确保它被锁定。至少应该在自己的命名空间中运行。也不是**kube-system**。您希望最小化谁有访问权限。使用多因素身份验证进入该命名空间总是一个好主意，以及控制哪些Pod可以访问反向代理的网络策略。
- en: Based on the concepts we've just learned about regarding impersonation, the
    next step is to update our cluster's configuration to use impersonation instead
    of using OpenID Connect directly. You don't need a cloud-managed cluster to work
    with impersonation.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们刚刚学到的有关模拟的概念，下一步是更新我们集群的配置，以使用模拟而不是直接使用OpenID Connect。您不需要云托管的集群来使用模拟。
- en: Configuring your cluster for impersonation
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模拟配置您的集群
- en: 'Let''s deploy an impersonating proxy for our cluster. Assuming you''re reusing
    your existing cluster, we first need to delete our orchestra Helm deployment (this
    will not delete the operator; we want to keep the OpenUnison operator). So, let''s
    begin:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的集群部署一个模拟代理。假设您正在重用现有的集群，我们首先需要删除我们的orchestra Helm部署（这不会删除操作员；我们要保留OpenUnison操作员）。所以，让我们开始：
- en: 'Run the following command to delete our **orchestra** Helm deployment:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令以删除我们的**orchestra** Helm部署：
- en: '**$ helm delete orchestra --namespace openunison**'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ helm delete orchestra --namespace openunison**'
- en: '**release "orchestra" uninstalled**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**释放"orchestra"已卸载**'
- en: The only pod running in the **openunison** namespace is our operator. Notice
    that all the Secrets, Ingress, Deployments, Services, and other objects that were
    created by the operator when the orchestra Helm chart was deployed are all gone.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '**openunison**命名空间中唯一运行的Pod是我们的操作员。请注意，当orchestra Helm图表部署时，操作员创建的所有Secrets、Ingress、Deployments、Services和其他对象都已消失。'
- en: 'Next, redeploy OpenUnison, but this time, update our Helm chart to use impersonation.
    Edit the **values.yaml** file and add the two bold lines shown in the following
    example file:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重新部署OpenUnison，但这次更新我们的Helm图表以使用模拟。编辑**values.yaml**文件，并添加以下示例文件中显示的两行粗体线：
- en: 'network:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 网络：
- en: 'openunison_host: "k8sou.apps.192-168-2-131.nip.io"'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: openunison_host："k8sou.apps.192-168-2-131.nip.io"
- en: 'dashboard_host: "k8sdb.apps.192-168-2-131.nip.io"'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: dashboard_host："k8sdb.apps.192-168-2-131.nip.io"
- en: '**  api_server_host: "k8sapi.apps.192-168-2-131.nip.io"**'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '** api_server_host："k8sapi.apps.192-168-2-131.nip.io"**'
- en: 'session_inactivity_timeout_seconds: 900'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 会话不活动超时秒数：900
- en: 'k8s_url: https://192.168.2.131:32776'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: k8s_url：https://192.168.2.131:32776
- en: 'cert_template:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: cert_template：
- en: 'ou: "Kubernetes"'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: ou："Kubernetes"
- en: 'o: "MyOrg"'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: o："我的组织"
- en: 'l: "My Cluster"'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: l："我的集群"
- en: 'st: "State of Cluster"'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: st："集群状态"
- en: 'c: "MyCountry"'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: c："我的国家"
- en: 'image: "docker.io/tremolosecurity/openunison-k8s-login-saml2:latest"'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: image："docker.io/tremolosecurity/openunison-k8s-login-saml2:latest"
- en: 'myvd_config_path: "WEB-INF/myvd.conf"'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: myvd_config_path："WEB-INF/myvd.conf"
- en: 'k8s_cluster_name: kubernetes'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: k8s_cluster_name：kubernetes
- en: '**enable_impersonation: true**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**enable_impersonation：true**'
- en: 'dashboard:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板：
- en: 'namespace: "kubernetes-dashboard"'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间："kubernetes-dashboard"
- en: 'cert_name: "kubernetes-dashboard-certs"'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: cert_name："kubernetes-dashboard-certs"
- en: 'label: "k8s-app=kubernetes-dashboard"'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 标签："k8s-app=kubernetes-dashboard"
- en: 'service_name: kubernetes-dashboard'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: service_name："kubernetes-dashboard"
- en: 'certs:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 证书：
- en: 'use_k8s_cm: false'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: use_k8s_cm：false
- en: 'trusted_certs: []'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: trusted_certs：[]
- en: 'monitoring:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 监控：
- en: 'prometheus_service_account: system:serviceaccount:monitoring:prometheus-k8s'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: prometheus_service_account：system:serviceaccount:monitoring:prometheus-k8s
- en: 'saml:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: saml：
- en: 'idp_url: https://portal.apps.tremolo.io/idp-test/metadata/dfbe4040-cd32-470e-a9b6-809c8f857c40'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: idp_url：https://portal.apps.tremolo.io/idp-test/metadata/dfbe4040-cd32-470e-a9b6-809c8f857c40
- en: 'metadata_xml_b64: ""'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: metadata_xml_b64：""
- en: 'We have made two changes here:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做了两个更改：
- en: Added a host for the API server proxy
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为API服务器代理添加一个主机
- en: Enabled impersonation
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用模拟
- en: These changes enable OpenUnison's impersonation features and generate an additional
    RBAC binding to enable impersonation on OpenUnison's service account.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改启用了OpenUnison的冒充功能，并生成了一个额外的RBAC绑定，以在OpenUnison的服务帐户上启用冒充。
- en: 'Run the Helm chart with the new **values.yaml** file:'
  id: totrans-539
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的**values.yaml**文件运行Helm图表：
- en: '**helm install orchestra tremolo/openunison-k8s-login-saml2 –namespace openunison
    -f ./values.yaml**'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '**helm install orchestra tremolo/openunison-k8s-login-saml2 –namespace openunison
    -f ./values.yaml**'
- en: '**NAME: orchestra**'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称：orchestra**'
- en: '**LAST DEPLOYED: Thu Apr 23 20:55:16 2020**'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**上次部署：2020年4月23日星期四20:55:16**'
- en: '**NAMESPACE: openunison**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名空间：openunison**'
- en: '**STATUS: deployed**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态：已部署**'
- en: '**REVISION: 1**'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '**修订版：1**'
- en: '**TEST SUITE: None**'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试套件：无**'
- en: 'Just like with our OpenID Connect integration with Kubernetes, finish the integration
    with the testing identity provider. First, get the metadata:'
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们与Kubernetes的OpenID Connect集成一样，完成与测试身份提供者的集成。首先，获取元数据：
- en: '**$ curl --insecure https://k8sou.apps.192-168-2-131.nip.io/auth/forms/saml2_rp_metadata.jsp**'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ curl --insecure https://k8sou.apps.192-168-2-131.nip.io/auth/forms/saml2_rp_metadata.jsp**'
- en: '**<?xml version="1.0" encoding="UTF-8"?><md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    ID="f4a4bacd63709fe486c30ec536c0f552a506d0023" entityID="https://k8sou.apps.192-168-2-131.nip.io/auth/SAML2Auth">**'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '**<?xml version="1.0" encoding="UTF-8"?><md:EntityDescriptor xmlns:md="urn:oasis:names:tc:SAML:2.0:metadata"
    ID="f4a4bacd63709fe486c30ec536c0f552a506d0023" entityID="https://k8sou.apps.192-168-2-131.nip.io/auth/SAML2Auth">**'
- en: '**   <md:SPSSODescriptor WantAssertionsSigned="true" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:**'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '**<md:SPSSODescriptor WantAssertionsSigned="true" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:**'
- en: '**protocol">**'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '**协议">**'
- en: '**.**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**。**'
- en: '**.**'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**。**'
- en: '**.**'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '**。**'
- en: Next, log into [https://portal.apps.tremolo.io/](https://portal.apps.tremolo.io/),
    choose the testing identity provider, and copy and paste the resulting metadata
    into the testing identity provider where it says **Meta Data**.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，登录到[https://portal.apps.tremolo.io/](https://portal.apps.tremolo.io/)，选择测试身份提供者，并将生成的元数据复制并粘贴到测试身份提供者的**元数据**位置。
- en: Finally, to update the change, click **Update Relying Party**.
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击**更新Relying Party**以更新更改。
- en: The new OpenUnison deployment is configured as a reverse proxy for the API server
    and has been re-integrated with our SAML2 identity provider. There are no cluster
    parameters to set because impersonation doesn't need any cluster-side configuration.
    The next step is to test the integration.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 新的OpenUnison部署配置为API服务器的反向代理，并已重新集成到我们的SAML2身份提供者。没有需要设置的集群参数，因为冒充不需要任何集群端配置。下一步是测试集成。
- en: Testing impersonation
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试冒充
- en: 'Now, let''s test our impersonation setup. Follow these steps:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们测试我们的冒充设置。按照以下步骤进行：
- en: In a browser, enter the URL for your OpenUnison deployment. This is the same
    URL you used for your initial OIDC deployment.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中输入您的OpenUnison部署的URL。这是您用于初始OIDC部署的相同URL。
- en: Log into OpenUnison and then click on the dashboard. You should recall that
    the first time you opened the dashboard on the your initial OpenUnison deployment,
    you received a lot of errors until you created the new RBAC role, which granted
    access to the cluster.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到OpenUnison，然后单击仪表板。您应该记得，第一次打开初始OpenUnison部署的仪表板时，直到创建了新的RBAC角色，才能访问集群，您会收到很多错误。
- en: After you've enabled impersonation and opened the dashboard, you shouldn't see
    any error messages, even though you were prompted for new certificate warnings
    and didn't tell the API server to trust the new certificates you're using with
    the dashboard.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 启用冒充并打开仪表板后，即使提示了新证书警告并且没有告诉API服务器信任您在仪表板上使用的新证书，您也不应该看到任何错误消息。
- en: Click on the little circular icon in the upper right-hand corner to see who
    you're logged in as.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击右上角的小圆形图标，查看您登录的身份。
- en: Next, go back to the main OpenUnison dashboard and click on the **Kubernetes
    Tokens** badge.
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，返回到主OpenUnison仪表板，然后单击**Kubernetes Tokens**徽章。
- en: Notice that the **--server** flag being passed to kubectl no longer has an IP.
    Instead, it has the hostname from **network.api_server_host** in the **values.yaml**
    file. This is impersonation. Instead of interacting directly with the API server,
    you're now interacting with OpenUnison's reverse proxy.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，传递给kubectl的**--server**标志不再具有IP。相反，它具有**values.yaml**文件中**network.api_server_host**的主机名。这就是模拟。现在，您不再直接与API服务器交互，而是与OpenUnison的反向代理进行交互。
- en: 'Finally, let''s copy and paste our **kubectl** command into a shell:'
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将**kubectl**命令复制并粘贴到shell中：
- en: export TMP_CERT=$(mktemp) && echo -e "-----BEGIN CERTIFI...
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: export TMP_CERT=$(mktemp) && echo -e "-----BEGIN CERTIFI...
- en: '**Cluster "kubernetes" set.**'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '**集群"kubernetes"设置。**'
- en: '**Context "kubernetes" created.**'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文"kubernetes"已创建。**'
- en: '**User "mlbiamext" set.**'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户"mlbiamext"设置。**'
- en: '**Switched to context "kubernetes".**'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '**切换到上下文"kubernetes"。**'
- en: 'To verify you have access, list the cluster nodes:'
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要验证您是否有访问权限，请列出集群节点：
- en: kubectl get nodes
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes
- en: '**NAME                         STATUS   ROLES    AGE    VERSION**'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '**名称                         状态   角色    年龄    版本**'
- en: '**cluster-auth-control-plane   Ready    master   6h6m   v1.17.0**'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '**cluster-auth-control-plane   Ready    master   6h6m   v1.17.0**'
- en: '**cluster-auth-worker          Ready    <none>   6h6m   v1.17.0**'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**cluster-auth-worker          Ready    <none>   6h6m   v1.17.0**'
- en: 'Just like when you integrated the original deployment of OpenID Connect, once
    you''ve logged out of the OpenUnison page, within a minute or two, the tokens
    will expire and you won''t be able to refresh them:'
  id: totrans-577
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像当您集成原始的OpenID Connect部署时一样，一旦您登出OpenUnison页面，一两分钟内，令牌将过期，您将无法刷新它们：
- en: kubectl get nodes
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: kubectl get nodes
- en: '**Unable to connect to the server: failed to refresh token: oauth2: cannot
    fetch token: 401 Unauthorized**'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法连接到服务器：刷新令牌失败：oauth2：无法获取令牌：401未经授权**'
- en: You've now validated that your cluster is working correctly with impersonation.
    Instead of authenticating directly to the API server, the impersonating reverse
    proxy (OpenUnison) is forwarding all requests to the API server with the correct
    impersonation headers. You're still meeting your enterprise's needs by providing
    both a login and logout process and integrating your Active Directory groups.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经验证了您的集群是否正确地使用模拟工作。现在，模拟反向代理（OpenUnison）将所有请求转发到具有正确模拟标头的API服务器，而不是直接进行身份验证。通过提供登录和注销过程以及集成您的Active
    Directory组，您仍然满足企业的需求。
- en: Configuring Impersonation without OpenUnison
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在没有OpenUnison的情况下配置模拟
- en: The OpenUnison operator automated a couple of key steps to get impersonation
    working. There are other projects designed specifically for Kubernetes, such as
    JetStack's OIDC Proxy ([https://github.com/jetstack/kube-oidc-proxy](https://github.com/jetstack/kube-oidc-proxy)),
    that are designed to make using impersonation easier. You can use any reverse
    proxy that can generate the correct headers. There are two critical items to understand
    when doing this on your own.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: OpenUnison运算符自动化了一些关键步骤，使得模拟工作起来更加容易。还有其他专门为Kubernetes设计的项目，比如JetStack的OIDC代理（[https://github.com/jetstack/kube-oidc-proxy](https://github.com/jetstack/kube-oidc-proxy)），旨在使模拟更加容易。您可以使用任何能够生成正确标头的反向代理。在自己进行此操作时，有两个关键要理解的项目。
- en: Impersonation RBAC policies
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟RBAC策略
- en: 'RBAC will be covered in the next chapter, but for now, the correct policy to
    authorize a service account for impersonation is as follows:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC将在下一章中介绍，但目前，授权服务帐户进行模拟的正确策略如下：
- en: 'apiVersion: rbac.authorization.k8s.io/v1'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: apiVersion：rbac.authorization.k8s.io/v1
- en: 'kind: ClusterRole'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 种类：ClusterRole
- en: 'metadata:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据：
- en: 'name: impersonator'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 名称：模拟器
- en: 'rules:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 规则：
- en: '- apiGroups:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '- apiGroups：'
- en: '- ""'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '- ""'
- en: 'resources:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 资源：
- en: '- users'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '- 用户'
- en: '- groups'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '- 组'
- en: 'verbs:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 动词：
- en: '- impersonate'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '- 模拟'
- en: To constrain what accounts can be impersonated, add **resourceNames** to your
    rule.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制可以模拟的帐户，将**resourceNames**添加到您的规则中。
- en: Default groups
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认组
- en: When impersonating a user, Kubernetes does not add the default group, **system:authenticated**,
    to the list of impersonated groups. When using a reverse proxy that doesn't specifically
    know to add the header for this group, configure the proxy to add it manually.
    Otherwise, simple acts such as calling the **/api** endpoint will fail as this
    will be unauthorized for anyone except cluster administrators.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟用户时，Kubernetes不会将默认组**system:authenticated**添加到模拟组列表中。当使用不知道如何为该组添加标头的反向代理时，需要手动配置代理以添加它。否则，简单的操作，如调用**/api**端点，将对除集群管理员之外的任何人都是未经授权的。
- en: Summary
  id: totrans-600
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter detailed how Kubernetes identifies users and what groups their
    members are in. We detailed how the API server interacts with identities and explored
    several options for authentication. Finally, we detailed the OpenID Connect protocol
    and how it's applied to Kubernetes.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 本章详细介绍了Kubernetes如何识别用户以及他们的成员所在的组。我们详细介绍了API服务器如何与身份交互，并探讨了几种身份验证选项。最后，我们详细介绍了OpenID
    Connect协议以及它如何应用于Kubernetes。
- en: Learning how Kubernetes authenticates users and the details of the OpenID Connect
    protocol are an important part of building security into a cluster. Understanding
    the details and how they apply to common enterprise requirements will help you
    decide the best way to authenticate to clusters, and also provide justification
    regarding why the anti-patterns we explored should be avoided.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 学习Kubernetes如何认证用户以及OpenID Connect协议的细节是构建集群安全性的重要部分。了解细节以及它们如何适用于常见的企业需求将帮助您决定最佳的集群身份验证方式，并提供关于为什么应该避免我们探讨的反模式的理由。
- en: In the next chapter, we'll apply our authentication process to authorizing access
    to Kubernetes resources. Knowing who someone is isn't enough to secure your clusters.
    You also need to control what they have access to.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将将我们的身份验证流程应用于授权访问Kubernetes资源。知道某人是谁并不足以保护您的集群。您还需要控制他们可以访问什么。
- en: Questions
  id: totrans-604
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: OpenID Connect is a standard protocol with extensive peer review and usage.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenID Connect是一个标准协议，经过广泛的同行评审和使用。
- en: A. True
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: Which token does Kubernetes use to authorize your access to an API?
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes使用哪个令牌来授权您访问API？
- en: A. **access_token**
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: A. **access_token**
- en: B. **id_token**
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: B. **id_token**
- en: C. **refresh_token**
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: C. **refresh_token**
- en: D. **certificate_token**
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: D. **certificate_token**
- en: In which situation is certificate authentication a good idea?
  id: totrans-613
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在哪种情况下，证书身份验证是一个好主意？
- en: A. Day-to-day usage by administrators and developers
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: A. 管理员和开发人员的日常使用
- en: B. Access from external CI/CD pipelines and other services
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: B. 来自外部CI/CD流水线和其他服务的访问
- en: C. Break glass in case of emergency when all other authentication solutions
    are unavailable
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: C. 紧急情况下打破玻璃，当所有其他身份验证解决方案不可用时
- en: How should you identify users accessing your cluster?
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该如何识别访问您的集群的用户？
- en: A. Email address
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: A. 电子邮件地址
- en: B. Unix login ID
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: B. Unix登录ID
- en: C. Windows login ID
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: C. Windows登录ID
- en: D. An immutable ID not based on a user's name
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: D. 不基于用户名称的不可变ID
- en: Where are OpenID Connect configuration options set in Kubernetes?
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Kubernetes中，OpenID Connect配置选项设置在哪里？
- en: A. Depends on the distribution
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: A. 取决于发行版
- en: B. In a ConfigMap object
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: B. 在ConfigMap对象中
- en: C. In a Secret
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: C. 在一个Secret中
- en: D. Set as flags on the Kubernetes API server executable
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: D. 设置为Kubernetes API服务器可执行文件的标志
- en: When using impersonation with your cluster, the groups your user brings are
    the only ones needed.
  id: totrans-627
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用模拟与您的集群时，您的用户带来的组是唯一需要的组。
- en: A. True
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
- en: The dashboard should have its own privileged identity to work properly.
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仪表板应该有自己的特权身份才能正常工作。
- en: A. True
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: A. 正确
- en: B. False
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: B. 错误
