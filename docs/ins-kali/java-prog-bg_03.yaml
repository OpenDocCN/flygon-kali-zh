- en: Branching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支
- en: Programs that perform the same action every time they run are all well and good,
    but the most interesting computer programs do something a little different each
    time they run, whether it's because they have differing input or even because
    a user is actively interacting with them. With this, let's kick-start this chapter
    by understanding conditional statements, then we will further explore how Java
    handles complicated conditional statements, modify the control flow of our program,
    and study loops functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行时执行相同操作的程序都很好，但最有趣的计算机程序每次运行时都会做一些不同的事情，这可能是因为它们具有不同的输入，甚至是因为用户正在积极地与它们交互。有了这个，让我们通过理解条件语句来启动本章，然后我们将进一步探讨Java如何处理复杂的条件语句，修改程序的控制流，并研究循环功能。
- en: 'Specifically, we''ll cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，本章将涵盖以下主题：
- en: Understanding `if` statements
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`if`语句
- en: Complex conditionals
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的条件语句
- en: The `switch`, `case`, and `break` statements
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`、`case`和`break`语句'
- en: The `while` and `do...while` loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`和`do...while`循环'
- en: The `for` loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: Understanding if statements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解if语句
- en: 'Today, we''re going to explore the very basic `if` and `else` conditional statements.
    To understand this further, refer to the following bullet list:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们将探讨非常基本的`if`和`else`条件语句。要进一步理解这一点，请参考以下项目列表：
- en: 'Let''s create a new Java project in NetBeans. I''m going to call mine `ConditionalStatements`,
    and I will allow NetBeans to create the `main` class for me; refer to the following
    screenshot:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在NetBeans中创建一个新的Java项目。我将把我的项目命名为`ConditionalStatements`，并允许NetBeans为我创建`main`类；参考以下截图：
- en: '![](img/fed44d7e-dcac-4bcd-af4b-85b68c4bf7ce.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fed44d7e-dcac-4bcd-af4b-85b68c4bf7ce.jpg)'
- en: To keep things clean, we can get rid of all our comments; now we're good to
    go. To allow us to write more interesting programs, we're going to quickly learn
    how to do some basic user input in Java. At this point in time, you don't have
    the knowledge base to fully grasp the intricacies of what we're about to do, but
    you may have a basic understanding of what's going on and you can certainly repeat
    the process on your own in future.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持清晰，我们可以摆脱所有的注释；现在我们可以开始了。为了让我们编写更有趣的程序，我们将快速学习如何在Java中进行一些基本的用户输入。在这个时候，你还没有足够的知识基础来完全理解我们即将要做的复杂性，但是你可能对正在发生的事情有基本的理解，并且将来肯定可以自己重复这个过程。
- en: 'While writing to this **InputStream**/**Console** window is kind of a simple
    fire-and-forget process, reading input in Java can be a little more complicated:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个**InputStream**/**Console**窗口中写入是一种简单的一次性过程，但是在Java中读取输入可能会更加复杂：
- en: '![](img/7ee0bc80-e7a7-467d-be90-0f391752e393.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee0bc80-e7a7-467d-be90-0f391752e393.jpg)'
- en: 'User input is put into a buffer that our program accesses when it''s prompted
    to; therefore, we need to declare a variable that will allow us to access this
    buffer when we need to get some new user input. For this, we''re going to use
    the `Scanner` class. Let''s call our new instance `reader`. NetBeans yells at
    us because `Scanner` lives in the `java.util` package, which we need to access
    explicitly. We can always import the `java.util` package:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入被放入一个缓冲区，我们的程序在提示时访问它；因此，我们需要声明一个变量，允许我们在需要获取新用户输入时访问这个缓冲区。为此，我们将使用`Scanner`类。让我们称我们的新实例为`reader`。NetBeans对我们大喊大叫，因为`Scanner`位于`java.util`包中，我们需要显式访问它。我们可以随时导入`java.util`包：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here''s the part where you kind of have to take a leap of faith and jump a
    little bit ahead of what you''re really ready to completely and totally understand.
    We need to assign a value to this `reader` variable of the `Scanner` type so that
    it links with the InputStream window, where our user will be entering their input.
    To do this, we''re going to set its value to the value of a brand new `Scanner()`
    object, but this Scanner object is going to be created with a type argument, that
    is, `(System.in)`, which happens to be the link to the InputStream our users will
    be using:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是你需要有点信心并超前一点，超出你现在真正准备完全理解的范围。我们需要为`reader`变量分配一个值，这个值是`Scanner`类型的，这样它就可以连接到InputStream窗口，用户将在其中输入。为此，我们将把它的值设置为一个全新的`Scanner()`对象的值，但是这个Scanner对象将使用一个类型参数，即`(System.in)`，这恰好是我们的用户将要使用的InputStream的链接：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the output of the preceding code:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/e06f5667-f6bc-4689-a1ad-e0d229864520.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e06f5667-f6bc-4689-a1ad-e0d229864520.jpg)'
- en: Like I said, this is some heavy hitting stuff and you certainly shouldn't expect
    to understand how this works at a lower level right now. For now, know that `reader`
    is connected with our InputStream window, and our `Scanner` object has the `next()`
    function that allows us to access the input that the user has just entered into
    the stream. Like most functions, this function simply returns this input, so we're
    going to have to create a string to store this input.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我说的，这是一些重要的内容，你肯定不应该期望现在就完全理解它是如何工作的。现在，知道`reader`与我们的InputStream窗口连接，我们的`Scanner`对象具有`next()`函数，允许我们访问用户刚刚输入到流中的输入。就像大多数函数一样，这个函数只是返回这个输入，所以我们需要创建一个字符串来存储这个输入。
- en: 'Once we''ve done this, we can use our `System.out.println()` function to print
    the `input` value back to the console:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以使用`System.out.println()`函数将`input`值打印回控制台：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we run our program, nothing appears to happen, but in actuality, our console
    here is waiting for some user input. Now, when we type our input into this console
    and hit *Enter* key, it will echo right back at us:![](img/2fa36d7d-6ad2-47af-a345-6939a71bfe6d.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们运行程序时，似乎没有任何事情发生，但实际上，我们的控制台在这里等待用户输入。现在，当我们在控制台中输入我们的输入并按下*Enter*键时，它将立即回显给我们：![](img/2fa36d7d-6ad2-47af-a345-6939a71bfe6d.jpg)
- en: 'We can make this a little nicer to use by having our program prompt the user
    for the input rather than simply waiting quietly:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过让程序提示用户输入而不是静静地等待来使其更加友好：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Conditional statements
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'At the beginning of this chapter, I promised you''d learn about conditional
    statements, and we''re about to do that now. But first, let''s make a quick modification
    to the user input portion of our program. Rather than acquiring a string, it''s
    going to be a lot easier if we learn conditional statements working with a user-provided
    integer value. So let''s change the value or the type of our `input` variable
    to an `int` datatype; the `reader.next()` function returns a string, but there''s
    a similar function called `nextInt()` that will return an integer:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我承诺过你会学习条件语句，我们现在就要做到这一点。但首先，让我们对我们程序的用户输入部分进行一个小修改。与其获取一个字符串，如果我们学习使用用户提供的整数值来工作，那将会更容易得多。因此，让我们将我们的`input`变量的值或类型更改为`int`数据类型；`reader.next()`函数返回一个字符串，但有一个类似的函数叫做`nextInt()`，它将返回一个整数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We're certainly not going to bother putting any error-handling mechanism in
    our very simple program.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们肯定不会在我们非常简单的程序中加入任何错误处理机制。
- en: Know that if we accidentally provide this Java program with anything besides
    an integer, the program will crash.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要知道，如果我们不小心向这个Java程序提供除整数以外的任何东西，程序将崩溃。
- en: So what are conditional statements exactly? Well, conditional statements allow
    us to send our program down different paths, executing different lines of code
    depending on whether or not something is true or not. In this chapter, we'll use
    conditional statements to print different responses to our user depending on the
    value of the input they give us. Specifically, we'll let them know whether the
    value they've given us is less than, greater than, or equal to the number 10\.
    To start this process off, let's set up our output cases.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 那么条件语句到底是什么？条件语句允许我们根据某些事情是真还是假，将我们的程序引导到不同的路径上，执行不同的代码行。在本章中，我们将使用条件语句根据用户给我们的输入值来打印不同的响应。具体来说，我们将告诉他们他们给我们的值是小于、大于还是等于数字10。为了开始这个过程，让我们设置我们的输出情况。
- en: If our user provides us with input that is greater than 10, we print out `MORE`.
    If the user provides us with input that happens to be less than 10, we print out
    `LESS`. Of course, if we run this program right now, it will simply print out
    `MORE` or `LESS`, both the lines. What we need to do is use conditional statements
    to make sure that only one of these two lines executes in any program run, and
    that the proper line executes of course. You may have noticed that the default
    project NetBeans created for us divides our code into segments that have curly
    brackets around them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的用户提供的输入大于10，我们打印出`MORE`。如果用户提供的输入恰好小于10，我们打印出`LESS`。当然，如果我们现在运行这个程序，它将简单地打印出`MORE`或`LESS`，两行都会打印。我们需要使用条件语句来确保这两行中只有一行在任何程序运行中执行，并且当然执行正确的行。您可能已经注意到，NetBeans为我们创建的默认项目将我们的代码分成了用大括号括起来的段。
- en: We can further divide our code into segments using brackets of our own. Convention
    dictates that once we've created a new set of brackets, a new segment of code,
    we need to then add a tab before everything between the brackets to make our program
    more readable.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自己的括号进一步将我们的代码分成段。惯例规定，一旦我们创建了一组新的括号，一个新的代码段，我们需要在括号之间的所有内容之前添加一个制表符，以使我们的程序更易读。
- en: Using if statements
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用if语句
- en: 'Once we''ve sectioned off our two `system.out.println` statements, we''re now
    ready to provide cases that must be true if these statements are to run. To do
    this, we preface our new sections with the Java `if` statement, where `if` is
    a Java keyword and it''s followed by two parentheses between which we put the
    statement to be evaluated. If Java determines that the statement we write between
    the parentheses is true, the code in the following brackets will execute. If Java
    determines that the statement is false, the code in the brackets will be completely
    skipped. Essentially, we''re going to give this `if` statement two pieces of input.
    We''re going to give it the variable `input`, which if you remember contains the
    integer value that we got from the user, and we''re going to give it the explicit
    value `10`, which is what we''re comparing it to. Java understands the greater
    than (`>`) and the less than (`<`) comparison operators. So, if we make this `if`
    statement `if(input > 10)`, then the `System.out.println` command (as seen in
    the following screenshot) will only run if the user has provided a value that''s
    greater than 10:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将我们的两个`system.out.println`语句分开，我们现在可以提供必须为真的情况，如果这些语句要运行的话。为此，我们用Java的`if`语句作为前缀，其中`if`是一个Java关键字，后面跟着两个括号，我们在括号之间放置要评估的语句。如果Java确定我们在括号之间写的语句为真，则以下括号中的代码将执行。如果Java确定该语句为假，则括号中的代码将被完全跳过。基本上，我们将给这个`if`语句两个输入。我们将给它变量`input`，如果你还记得，它包含我们从用户那里得到的整数值，我们将给它显式值`10`，这是我们要比较的值。Java理解大于（`>`）和小于（`<`）比较运算符。因此，如果我们使这个`if`语句`if(input
    > 10)`，那么`System.out.println`命令（如下面的屏幕截图中所示）只有在用户提供大于10的值时才会运行：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we need to provide an `if` statement to make sure that our program doesn't
    always print out `LESS` anyway.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一个`if`语句，以确保我们的程序不会总是打印出`LESS`。
- en: 'We could use the less than operator to ask our program to print out `LESS`
    whenever the user provides input that is less than 10\. This would be good in
    almost all cases, but if our user provides the input value 10, our program would
    print out nothing. To fix this, we can use the less than or equal to operator
    to ensure that our program always responds to the user input:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用小于运算符，要求我们的程序在用户提供小于10的输入时打印出`LESS`。在几乎所有情况下，这都是很好的，但如果我们的用户提供的输入值是10，我们的程序将什么也不打印。为了解决这个问题，我们可以使用小于或等于运算符来确保我们的程序始终对用户输入做出响应：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, let's quickly run our program to make sure that it works.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们快速运行我们的程序，确保它能正常工作。
- en: 'There''s a prompt for input in the InputStream window. Let''s start by giving
    it a value that is greater than 10 and pressing the *Enter* key. We get the `MORE`
    response and not the `LESS` response; this is what we expected:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在InputStream窗口中有一个输入提示。让我们首先给它一个大于10的值，然后按*Enter*键。我们得到了`MORE`的响应，而不是`LESS`的响应；这是我们预期的结果：
- en: '![](img/a1c5ebc2-852f-4f95-8a4f-b36932e7fcbc.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a1c5ebc2-852f-4f95-8a4f-b36932e7fcbc.jpg)'
- en: Our program doesn't loop, so we're going to have to run it again to test the
    `LESS` output, and this time let's give it the value `10`, which should trigger
    our less than or equal to operator. Tada!
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的程序不循环，所以我们需要再次运行它来测试`LESS`输出，这次让我们给它一个值`10`，这应该触发我们的小于或等于运算符。大功告成！
- en: '![](img/9d01689c-e4d7-48ee-bf12-29c9be84c256.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9d01689c-e4d7-48ee-bf12-29c9be84c256.jpg)'
- en: Using else statements
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用else语句
- en: 'It turns out that there''s a slightly easier way to write the preceding program.
    When we write a conditional statement or rather a pair of conditional statements
    in which we''re always going to execute one of the two code blocks, it''s probably
    a good time to make use of the `else` keyword. The `else` keyword must follow
    a bracketed `if` block, then it''s followed by brackets of its own. The `else`
    statement will evaluate to true and execute the code between its brackets only
    if the code between the previous `if` brackets was not executed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事实证明，有一种稍微更容易的方法来编写前面的程序。当我们编写一个条件语句或者说一对条件语句，其中我们总是要执行两个代码块中的一个时，现在可能是使用`else`关键字的好时机。`else`关键字必须跟在带括号的`if`块后面，然后跟着它自己的括号。`else`语句将在前一个`if`括号之间的代码未执行时评估为true，并执行其括号之间的代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run this program, we will get the same results as we did before with
    one less bit of logic code to write:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个程序，我们将得到与之前相同的结果，只是少写了一点逻辑代码：
- en: '![](img/19ce9e8f-2b8f-406a-b701-34809cabf6c7.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19ce9e8f-2b8f-406a-b701-34809cabf6c7.jpg)'
- en: 'Let''s end this topic with a brief run-through of what other operators we can
    use in our `if` statements, then we''ll take a look at what to do if we need to
    compare items that are not primitives. In addition to the greater than and less
    than operators, we can also make use of the equality operator (`==`), which is
    true if the items on both the sides have the same value. Make sure when you use
    the equality operator, do not accidently use the assignment operator (`=`) instead:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以简要介绍我们的`if`语句中可以使用的其他运算符结束这个话题，然后我们将看看如果需要比较非原始类型的项目该怎么办。除了大于和小于运算符之外，我们还可以使用相等运算符（`==`），如果两侧的项目具有相同的值，则为true。当使用相等运算符时，请确保不要意外使用赋值运算符（`=`）：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In some instances, your program won''t compile, but at other times it will
    compile and you''ll get very weird results. If you''d like to use the opposite
    of the equality operator, you can use not equals (`!=`), which returns true if
    the two items do not have the same value:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您的程序不会编译，但在其他情况下，它将编译，并且您将得到非常奇怪的结果。如果您想使用相等运算符的相反操作，可以使用不等于（`!=`），如果两个项目的值不相同，则返回true：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It's important that we do not attempt to use these equality operators when comparing
    instances of a class. We should only use them when we're working with primitives.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当比较类的实例时，我们不应尝试使用这些相等运算符。我们只应在处理原始类型时使用它们。
- en: 'To show this, let''s modify our program so that we could take `String` as user
    input. We''ll see whether `String` is equivalent to the secret password code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明这一点，让我们修改我们的程序，以便我们可以将`String`作为用户输入。我们将看看`String`是否等同于秘密密码代码：
- en: '![](img/60cd30ee-5d55-4ffa-a99a-2b40396097bc.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/60cd30ee-5d55-4ffa-a99a-2b40396097bc.png)'
- en: 'If it is, it will print out `YES`; if not, it will print out `NO`. Now, NetBeans
    gives us a warning (as shown in the preceding screenshot); in fact, if we attempt
    to compare strings with some different operators, NetBeans would let us know that
    our program is probably not even going to compile. That''s because Java does not
    expect us to compare instances of a class with these operators. Instead, classes
    should expose functions that allow us to compare them logically. Almost every
    object in Java has a few functions for this purpose. One of the most common ones
    is the `equals()` function that takes an object of the same type and lets us know
    whether they''re equivalent. This function returns what''s called a **Boolean
    type**, which is a primitive type of its own that can have a value of either true
    or false. Our `if` statement understands how to evaluate this Boolean type:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是，它将打印出`YES`；如果不是，它将打印出`NO`。现在，NetBeans给了我们一个警告（如前面的截图所示）；实际上，如果我们尝试使用一些不同的运算符来比较字符串，NetBeans会让我们知道我们的程序可能甚至无法编译。这是因为Java不希望我们使用这些运算符来比较类的实例。相反，类应该公开允许我们逻辑比较它们的函数。几乎每个Java对象都有一些用于此目的的函数。其中最常见的之一是`equals()`函数，它接受相同类型的对象，并让我们知道它们是否等价。这个函数返回一个称为**布尔类型**的东西，它是自己的原始类型，可以具有true或false的值。我们的`if`语句知道如何评估这个布尔类型：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run our program quickly and start by inputting a bad string, then let''s
    input `password` to see our program work:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行我们的程序，首先输入一个错误的字符串，然后输入`password`来看看我们的程序是否工作：
- en: '![](img/e9cf84c3-0f85-40e3-8ba6-3b0c5fb8eaa0.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9cf84c3-0f85-40e3-8ba6-3b0c5fb8eaa0.jpg)'
- en: That's the basics of `if-else` statements. I would encourage you now to play
    with some of the comparison operators that we looked at and try nesting `if...else`
    statements within each other.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`if-else`语句的基础。我现在鼓励你尝试一些我们看过的比较运算符，并尝试在彼此之间嵌套`if...else`语句。
- en: As a very last note, you may sometimes see `if` statements without their following
    brackets. This is a valid syntax and is basically the equivalent of putting the
    entire statement on one line.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点，有时您可能会看到没有后续括号的`if`语句。这是有效的语法，基本上相当于将整个语句放在一行上。
- en: Complex conditionals
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂条件
- en: To begin with, let's write a very simple Java program. We'll start by importing
    `java.util` so that we can get some user input via a `Scanner` object, and we'll
    link this `Scanner` object with the `System.in` input string so we can use it
    in the console window.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们编写一个非常简单的Java程序。我们将首先导入`java.util`，以便我们可以通过`Scanner`对象获得一些用户输入，并将这个`Scanner`对象与`System.in`输入字符串链接起来，这样我们就可以在控制台窗口中使用它。
- en: 'Once we''ve done this, we''re going to need to get some input from the user
    and store it, so let''s create a new string and assign its value to whatever the
    user gives us. To keep things interesting, let''s give ourselves two more String
    variables to work with. We''ll call them `sOne` and `sTwo`; we''ll assign the
    value of our first string variable to `abc` and the value of our second string
    variable to just `z`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们需要从用户那里获取一些输入并存储它，因此让我们创建一个新的字符串并将其值分配给用户给我们的任何值。为了保持事情有趣，让我们给自己再增加两个String变量来使用。我们将它们称为`sOne`和`sTwo`；我们将第一个字符串变量的值分配为`abc`，第二个字符串变量的值分配为`z`：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because this topic is about conditional statements, we''re probably going to
    need one of those, so let''s create an `if...else` block. This is where we''ll
    evaluate our conditional statement. We''ll set ourselves up some output so we
    can see what''s going on. If our conditional statement evaluates to true and we
    enter the following portion of the block, we''ll simply print out `TRUE`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个话题是关于条件语句，我们可能需要其中之一，所以让我们创建一个`if...else`块。这是我们将评估我们条件语句的地方。我们将设置一些输出，这样我们就可以看到发生了什么。如果我们的条件语句评估为true并且我们进入块的以下部分，我们将简单地打印出`TRUE`：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the conditional statement evaluates to false and we skip the previous `if`
    portion of the block and instead enter the `else` portion, we''ll print out `FALSE`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件语句评估为false并且我们跳过块的前一个`if`部分，而是进入`else`部分，我们将打印出`FALSE`：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The contains function
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含函数
- en: 'Now it''s probably time to write our conditional statement. Let me introduce
    you to a new string function called the `contains` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能是时候编写我们的条件语句了。让我向您介绍一个名为`contains`函数的新字符串函数：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `contains` function takes as input a sequence of characters of which a string
    qualifies. As output, it gives us a Boolean value, which means it will either
    output `TRUE` or `FALSE`. So our `if` statement should understand the result of
    this function and evaluate to the same. To test our program, let's start by simply
    going through the following process.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`contains`函数接受一个字符序列作为输入，其中包含一个字符串的资格。作为输出，它给我们一个布尔值，这意味着它将输出`TRUE`或`FALSE`。因此，我们的`if`语句应该理解这个函数的结果并评估为相同。为了测试我们的程序，让我们首先简单地通过以下过程。'
- en: 'We''ll provide our `contains` function with the value stored in the `sOne`
    string which is `abc`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的`contains`函数提供存储在`sOne`字符串中的值，即`abc`：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, if we run our program and provide it with `abcdefg` which contains within
    it the `abc` string, we get the `TRUE` result. This is because `input.contains`
    evaluates to true and we enter the `if` portion of our `if...else` block:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们运行我们的程序并为其提供`abcdefg`，其中包含`abc`字符串，我们将得到`TRUE`的结果。这是因为`input.contains`评估为true，我们进入了我们的`if...else`块的`if`部分：
- en: '![](img/886ca0f1-ddab-4e6d-be46-ecb2e2c31df5.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/886ca0f1-ddab-4e6d-be46-ecb2e2c31df5.jpg)'
- en: 'If we were to run and provide some gibberish that does not contain the `abc`
    string, we could instead enter the `else` statement of the block and return `FALSE`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行并提供一些不包含`abc`字符串的胡言乱语，我们可以进入块的`else`语句并返回`FALSE`：
- en: '![](img/01e77543-5023-400f-9057-cf280175bef0.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01e77543-5023-400f-9057-cf280175bef0.jpg)'
- en: Nothing too crazy there. But, let's say we want to make our program a little
    more complicated. Let's look at this in the next section.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有太疯狂的地方。但是，假设我们想让我们的程序变得更加复杂。让我们在下一节中看看这个。
- en: Complex conditional statements
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复杂的条件语句
- en: 'What if we want to check and see whether our input string contains both the
    strings, namely `sOne` and `sTwo`? There''s a couple of ways to do this, and we''ll
    take a look at some others. But probably, the simplest way for our purposes is
    to use a **complex** conditional on the `if(input.contains(sOne))` line. Java
    allows us to evaluate multiple true or false statements, or Boolean objects, at
    once using the `&&` or the `|` conditional operator. The `&&` operator gives us
    a true result when all conditionals compared with the `&&` operator have evaluated
    to true. The `|` operator gives us a true result when any of the conditionals
    compared with the `|` operator evaluate to true. In our case, we want to know
    whether our input string contains both the contents of `sOne` and `sTwo`, so we''re
    going to use the `&&` operator. This operator works by simply providing two conditional
    statements on either side of it. So, we''re going to run our `input.contains`
    function on both `sOne` and `sTwo`. If both these functions on either side of
    the `&&` operator, which is expressed as (`if(input.contains (sOne) && input.contains
    (sTwo))`, evaluate to true, our conditional statement will be true as well:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要检查并查看我们的输入字符串是否同时包含`sOne`和`sTwo`两个字符串呢？有几种方法可以做到这一点，我们将看看一些其他方法。但是，对于我们的目的来说，可能最简单的方法是在`if(input.contains(sOne))`行上使用**复杂**条件。Java允许我们使用`&&`或`|`条件运算符一次评估多个true或false语句，或布尔对象。当与`&&`运算符比较的所有条件都评估为true时，`&&`运算符给我们一个true结果。当与`|`运算符比较的任何条件评估为true时，`|`运算符给我们一个true结果。在我们的情况下，我们想知道我们的输入字符串是否同时包含`sOne`和`sTwo`的内容，所以我们将使用`&&`运算符。这个运算符通过简单地在它的两侧提供两个条件语句来工作。因此，我们将在`sOne`和`sTwo`上运行我们的`input.contains`函数。如果`&&`运算符的两侧的这些函数都评估为true，即(`if(input.contains(sOne)
    && input.contains(sTwo))`，我们的条件语句也将为true：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let''s run our program. The `abcz` string should evaluate to true in both cases,
    and when we press *Enter* key, we see that this is in fact the case:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行我们的程序。`abcz`字符串在两种情况下都应该评估为true，当我们按下*Enter*键时，我们看到实际情况确实如此：
- en: '![](img/a7f9e3c4-ec4b-47c7-945a-83f2a8cbdeff.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a7f9e3c4-ec4b-47c7-945a-83f2a8cbdeff.jpg)'
- en: 'If we were to provide only the valid string `z`, we would get a false result
    because our `&&` operator would evaluate false and true, which evaluates to false.
    If we were to use the `|` operator, this would be the string:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只提供有效的字符串`z`，我们会得到一个false的结果，因为我们的`&&`运算符会评估为false和true，这评估为false。如果我们使用`|`运算符，这将是字符串：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following is the output of the preceding code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/434b956d-d20a-4387-acbb-76dfbc0aa772.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/434b956d-d20a-4387-acbb-76dfbc0aa772.jpg)'
- en: This would in fact give us a true result because we only need one of these functions
    to return true now. Boolean logic can get pretty crazy pretty quick. For example,
    we can put the `&& false` statement at the end of our Boolean condition, namely
    `if(input.contains(sOne) || input.contains(sTwo) && false)`. The `true` and `false`
    code terms in Java are keywords; in fact, they're explicit values, just like a
    number or a single character would be. The `true` keyword evaluates to true and
    the `false` keyword evaluates to false.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上会给我们一个真正的结果，因为现在我们只需要其中一个函数返回true。布尔逻辑可能会变得非常疯狂。例如，我们可以将`&& false`语句放在我们的布尔条件的末尾，即`if(input.contains(sOne)
    || input.contains(sTwo) && false)`。在Java中，`true`和`false`代码术语是关键字；实际上，它们是显式值，就像数字或单个字符一样。`true`关键字评估为true，`false`关键字评估为false。
- en: 'Any single conditional statement that ends with `false` will always evaluate
    as a whole to false:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何以`false`结尾的单个条件语句将始终作为整体评估为false：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Curiously though, if we return to our previous original statement and run the
    following program providing it with the most valid possible input, we''re going
    to get the true result:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果我们返回到我们之前的原始语句，并运行以下程序，提供它最有效的可能输入，我们将得到真正的结果：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Following is the output of the preceding code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/07c8a447-62db-4e98-b65e-34a9c778ef5d.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/07c8a447-62db-4e98-b65e-34a9c778ef5d.png)'
- en: That's interesting because if Java had chosen to evaluate the `if(input.contains(sOne)
    || input.contains(sTwo))` statement first and then the `&& false` statement, we
    would have gotten a false result; instead, Java seems to have chosen to evaluate
    the `(input.contains(sTwo) && false)` statement first and then the `||` statement,
    that is, `(input.contains(sOne) ||)`. This can make things confusing pretty quick.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，如果Java首先评估`if(input.contains(sOne) || input.contains(sTwo))`语句，然后是`&& false`语句，我们将得到一个false的结果；相反，Java似乎选择首先评估`(input.contains(sTwo)
    && false)`语句，然后是`||`语句，即`(input.contains(sOne) ||)`。这可能会让事情变得非常混乱。
- en: 'Fortunately, just like in algebra, we can ask Java to do operations in a specific
    order. We do this by surrounding the blocks of our code with parentheses. Blocks
    of code within parentheses will evaluate before Java leaves the parentheses to
    evaluate against something else:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，就像在代数中一样，我们可以要求Java按特定顺序执行操作。我们通过用括号括起我们的代码块来做到这一点。括号内的代码块将在Java离开括号以评估其他内容之前进行评估：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'So, after we''ve surrounded our `||` statement with parentheses, we''ll compute
    the `||` statement and then end that result with `false`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们用括号括起`||`语句之后，我们将计算`||`语句，然后以`false`结束该结果：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We will now see that our preceding program always evaluates to false here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将看到我们前面的程序总是在这里评估为false：
- en: '![](img/e7c6a449-89cb-44ed-8d2e-a56f6144f07d.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7c6a449-89cb-44ed-8d2e-a56f6144f07d.png)'
- en: So complex conditionals can get pretty complicated pretty quick. If we come
    across something like this `if` statement in code, especially if it's code that
    we haven't written, it can take us a good while to figure out exactly what's going
    on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的条件可能会变得非常复杂。如果我们在代码中遇到这样的`if`语句，特别是如果这是我们没有编写的代码，可能需要花费很长时间才能弄清楚到底发生了什么。
- en: The boolean variable
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布尔变量
- en: 'To help us with what we discussed in the preceding section, we have the `boolean`
    variable:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们理解前面部分讨论的内容，我们有布尔变量：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the preceding line of code, `boolean` is a primitive type in Java, and a
    variable of the `boolean` type can have only one of the two values: it can be
    either `true` or `false`. We can set the value of our Boolean variables to be
    any conditional statement. So, if we wanted to simplify how our code looks in
    the actual `if` statement, we could go ahead and store these Boolean values:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一行代码中，`boolean`是Java中的一个原始类型，`boolean`类型的变量只能有两个值之一：它可以是`true`或`false`。我们可以将我们的布尔变量的值设置为任何条件语句。因此，如果我们想要简化实际`if`语句中的代码外观，我们可以继续存储这些布尔值：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We need to do this before we actually evaluate the `if` statement, keeping
    everything much more compact and readable:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际评估`if`语句之前，我们需要这样做，使一切更加紧凑和可读：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember that the name of the game is keeping our code as simple and readable
    as possible. A really long conditional might feel great to write, but oftentimes,
    there's a more elegant solution.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，游戏的名字是尽可能保持我们的代码简单和可读。一个非常长的条件语句可能写起来感觉很棒，但通常有更加优雅的解决方案。
- en: That's the nuts and bolts of complex conditionals in Java.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Java中复杂条件的实质。
- en: Switch, case, and break
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Switch，case和break
- en: In this section, we're going to take a look at the `switch` statement, which
    is another way that we can modify the control flow of our program.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下`switch`语句，这是我们可以修改程序控制流的另一种方式。
- en: 'To begin, let''s create a new project in NetBeans. At my end at least, I''m
    going to get rid of all these comments. To demonstrate the power of the `switch`
    statement, we''re going to start by writing a program using only `if` blocks,
    then we''ll convert the program to one that uses `switch` statements. The following
    are the steps for the program that uses only `if` blocks:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在NetBeans中创建一个新项目。至少在我的端上，我要摆脱所有这些注释。为了展示`switch`语句的强大，我们将首先编写一个仅使用`if`块的程序，然后将程序转换为使用`switch`语句的程序。以下是仅使用`if`块的程序的步骤：
- en: 'To begin, let''s simply declare a variable `x`, (`int x =1;`), and here is
    our goal: If the value of `x` is `1`, `2`, or `3`, we''d like to print out the
    responses `RED`, `BLUE`, or `GREEN`, respectively. If `x` is not one of those
    numbers, we''ll just print out a default response.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们简单地声明一个变量`x`（`int x =1;`），这是我们的目标：如果`x`的值是`1`、`2`或`3`，我们想要分别打印出响应`RED`、`BLUE`或`GREEN`。如果`x`不是这些数字之一，我们将只打印出默认响应。
- en: 'Doing this with `if` blocks is pretty straightforward, if not a little tedious:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`if`块做这件事情相当简单，尽管有点乏味：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, we''ll pretty much just copy and paste this block of code and modify
    it for the blue and green cases:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们基本上只需复制并粘贴这段代码，并为蓝色和绿色情况进行修改：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For our default case, we simply want to check that `x` is not equal to `1`,
    `x` is not equal to `2`, and `x` is not equal to `3`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的默认情况，我们只想检查`x`不等于`1`，`x`不等于`2`，`x`不等于`3`：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s give our program a very quick run-through:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速运行一下我们的程序：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following is the screenshot of the expected results:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期结果的屏幕截图：
- en: '![](img/7e3988b1-d934-4ed0-967b-bce9492aaba4.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7e3988b1-d934-4ed0-967b-bce9492aaba4.jpg)'
- en: This is a simplified version of something we might logically find ourselves
    doing in the course of writing a bigger program. While we put together this at
    a pretty decent clip, it's easy to see how this problem would become extremely
    unwieldy if we were dealing with many possible cases of `x`. And, it's also pretty
    difficult for someone to read and figure out what's going on here. The solution,
    as you've probably guessed, is to use a `switch` statement to control our program's
    flow instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在编写更大程序的过程中可能会做的事情的简化版本。虽然我们以相当快的速度组织了这个程序，但很容易看出，如果我们要处理许多可能的`x`情况，这个问题将变得非常难以控制。而且，对于某人来阅读和弄清楚这里发生了什么，也是相当困难的。解决方案，你可能已经猜到了，是使用`switch`语句来控制程序的流程。
- en: Program using switch, case, and break
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用switch、case和break的程序
- en: 'When we want to execute different lines or blocks of code depending on the
    value of an individual variable, the `switch` statement is extremely effective.
    Now let''s rewrite our series of `if` blocks using a `switch` statement instead.
    The syntax is explained in the following steps:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要根据一个变量的值执行不同的行或代码块时，`switch`语句非常有效。现在让我们使用`switch`语句来重写我们的一系列`if`块。语法在以下步骤中解释：
- en: 'We first declare that we''re going to use a `switch` statement, `switch` being
    a reserved keyword in Java. Then, we provide the name of the variable that we''d
    like the `switch` statement to act on, in this case `x` because we''re going to
    execute different blocks of code depending on the value of `x`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先声明我们将使用`switch`语句，`switch`是Java中的一个保留关键字。然后，我们提供我们希望`switch`语句作用的变量的名称，在这种情况下是`x`，因为我们将根据`x`的值执行不同的代码块：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, just like using an `if` or `else` statement, we're going to create a new
    segment of code using two brackets.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像使用`if`或`else`语句一样，我们将使用两个括号创建一个新的代码段。
- en: Now, instead of creating a series of unwieldy `if` blocks, we create separate
    blocks in our `switch` statements using the `case` keyword. After each `case`
    keyword, we give a prescribed value, and the following code will execute if the
    value of `x` matches with the value of the `case` keyword.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们不再创建一系列难以控制的`if`块，而是使用`case`关键字在我们的`switch`语句中创建单独的代码块。在每个`case`关键字之后，我们给出一个规定的值，如果`x`的值与`case`关键字的值匹配，接下来的代码将执行。
- en: So, just like when we were doing our `if` blocks, if the value of `x` is `1`,
    we'd like to print out `RED`. Writing separate cases for each of the possible
    values now becomes much cleaner and easier to read.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，就像我们在做`if`块时一样，如果`x`的值是`1`，我们想要打印出`RED`。现在为每种可能的值编写单独的情况变得更加清晰和易于阅读。
- en: The `switch` statements also have a special case, the `default` case, which
    we pretty much always put at the end of a `switch` statement.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`switch`语句还有一个特殊情况，即`default`情况，我们几乎总是将其放在`switch`语句的末尾。'
- en: 'This case will only execute if none of the other cases have executed, and it
    means that we don''t have to write that complicated Boolean logic for our last
    `if` block:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在其他情况都没有执行时，这种情况才会执行，这意味着我们不必为我们最后的`if`块编写复杂的布尔逻辑：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If we run the preceding program, we''re actually going to see every possible
    output execute. That''s because we''ve forgotten to do something very important:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的程序，实际上会看到每种可能的输出都会执行。这是因为我们忘记了做一件非常重要的事情：
- en: '![](img/9e4403de-f278-4069-aa68-c503c2128703.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9e4403de-f278-4069-aa68-c503c2128703.jpg)'
- en: The `switch` statements allow us to create complicated logic trees because once
    a case starts executing, it will continue to execute even through the next cases
    in the queue. Because we're writing a very simple program where we only want a
    single case to execute, we need to explicitly end the execution once we enter
    a case and finish the code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句允许我们创建复杂的逻辑树，因为一旦一个`case`开始执行，它将继续执行，即使通过了队列中的下一个`case`。因为我们正在编写一个非常简单的程序，我们只希望执行一个`case`，所以我们需要在进入一个`case`并完成代码后明确结束执行。'
- en: 'We can do that with the `break` keyword, which exists on a line of code all
    by itself and simply steps us up and out of the case that we''re in:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`break`关键字来做到这一点，它存在于一行代码中，并且简单地将我们从当前的`case`中跳出来：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now if we run our program, we''ll see the expected results:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的程序，我们将看到预期的结果：
- en: '![](img/6836df9b-f730-468b-a41d-38a45cb27b2f.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6836df9b-f730-468b-a41d-38a45cb27b2f.jpg)'
- en: 'In addition to falling through from one case to another, we can increase the
    complexity and the power of our switch statements by adding multiple cases to
    a single line. Because the cases freely fall through to each other, doing something
    like `case 1: case 5: case;` means that the following block of code will execute
    if we provide one of these numbers: `1`, `5`, or `7`. So there''s the quick and
    easy way of `switch` statements:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '除了从一个情况自由地转到另一个情况，我们还可以通过在一行中添加多个情况来增加我们的switch语句的复杂性和功能。因为情况自由地相互转到，做一些像`case
    1: case 5: case;`这样的事情意味着如果我们提供这些数字之一：`1`，`5`或`7`，接下来的代码块将执行。所以这是`switch`语句的快速简单方法：'
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the output of the preceding code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/b1feaa12-6894-4d4d-acff-58e1fc2bb4f2.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1feaa12-6894-4d4d-acff-58e1fc2bb4f2.jpg)'
- en: Switch statements essentially compare the variable or explicit value we're switching
    and the cases using the equality (`==`) operator. If elements cannot be compared
    with the equality operator, the switch statement will not work properly.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Switch语句基本上是使用等号（`==`）运算符比较我们正在切换的变量或显式值和情况。如果元素不能使用等号运算符进行比较，switch语句将无法正常工作。
- en: As of Java SE v7, you can compare strings with the equality operator so you
    can use them in `switch` statements. This was not always the case, and it's still
    a good idea to avoid using strings with the equality operator in your `switch`
    statements. This is because it destroys the backwards compatibility of the code
    you're writing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从Java SE v7开始，您可以使用等号运算符比较字符串，因此可以在`switch`语句中使用它们。这并不总是这样，而且最好避免在`switch`语句中使用等号运算符与字符串。这是因为它破坏了您正在编写的代码的向后兼容性。
- en: While and do...while loops
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: While和do...while循环
- en: 'Welcome to the introductory lesson on loops. At the end of this section, we''ll
    have command over Java''s `while` and `do...while` loops. I''m pretty excited
    about this because loops allow us to execute a block of Java code over and over
    again as many times as we see fit. This is a pretty cool step in our learning
    process because the ability to perform small tasks many times in rapid succession
    is one of the things that makes computers better at certain tasks than humans
    are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到循环的入门课程。在本节结束时，我们将掌握Java的`while`和`do...while`循环。我对此感到非常兴奋，因为循环允许我们执行一块Java代码多次，正如我们所希望的那样。这是我们学习过程中非常酷的一步，因为能够连续多次执行小任务是使计算机在某些任务上比人类更优越的原因之一：
- en: To begin this topic, let's create a new NetBeans project, enter the `main` method,
    and simply declare an integer and give it a value. We can choose any positive
    value. We're going to ask our program to print out the phrase `Hello World` a
    number of times equal to the value of our integer.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始这个话题，让我们创建一个新的NetBeans项目，输入`main`方法，然后简单地声明一个整数并给它一个值。我们可以选择任何正值。我们将要求我们的程序打印出短语`Hello
    World`的次数等于我们整数的值。
- en: 'To do this, we''ll employ a `while` loop. The `while` loop syntax looks a lot
    like we''re writing an `if` statement. We begin with the reserved `while` keyword
    and follow it by two parentheses; inside these, we''re eventually going to place
    a conditional statement. Just like it was an `if` statement, the following block
    of code will only execute if our program reaches our `while` loop and evaluates
    its conditional statement to true:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为此，我们将使用`while`循环。`while`循环的语法看起来很像我们在写一个`if`语句。我们从保留的`while`关键字开始，然后跟着两个括号；在这些括号里，我们最终会放置一个条件语句。就像它是一个`if`语句一样，只有当我们的程序到达我们的`while`循环并且评估其条件语句为真时，接下来的代码块才会执行：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: What separates `while` loops from `if` statements, however, is that when the
    end of the `while` loop's block of code is reached, our program will basically
    jump back and execute this line of code again, evaluating the conditional statement
    and reentering the while loop's block of code if the conditional statement is
    still true.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将`while`循环与`if`语句分开的是，当到达`while`循环的代码块的末尾时，我们的程序基本上会跳回并再次执行这行代码，评估条件语句并且如果条件语句仍然为真，则重新进入`while`循环的代码块。
- en: Let's start off by setting up the logic for our `while` loop. We have the number
    of times we would like our loop to execute stored in the value of the integer
    i, but we're going to need a way to communicate this to our loop. Well, any loop
    that is not going to run infinite times is going to need to make some control
    flow changes within the content of the loop. In our case, let's change the state
    of our program each time the loop runs by decreasing the value of i so that when
    i reaches 0, we would have ran the loop five times.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从设置`while`循环的逻辑开始。我们希望循环执行的次数存储在整数i的值中，但我们需要一种方法将这个值传达给我们的循环。嗯，任何不会无限运行的循环都需要在循环内容中进行一些控制流的改变。在我们的情况下，让我们每次循环运行时改变程序的状态，通过减少i的值，这样当i达到0时，我们将循环运行了五次。
- en: 'If that''s the case, it means that we only want our loop to execute when the
    value of `i` is greater than `0`. Let''s pause and quickly take a look at this
    line of code. Here `i = i -1` is a perfectly valid statement, but there''s a shortcut
    we can use that''s a little faster and easier to read. We can use `i--` to decrement
    the value of an integer variable by one. Once we''ve set this up, the only thing
    left to do is place the functional code inside of our loop; that''s simply a `println`
    statement that says `Hello world`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是这种情况，这意味着我们只希望我们的循环在`i`的值大于`0`时执行。让我们暂停一下，快速看一下这行代码。这里`i = i -1`是一个完全有效的语句，但我们可以使用一个更快更容易阅读的快捷方式。我们可以使用`i--`来将整数变量的值减少一。一旦我们设置好这个，唯一剩下的事情就是将功能代码放在我们的循环内；那就是一个简单的`println`语句，说`Hello
    world`：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, let''s run our program and see what happens:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们运行我们的程序，看看会发生什么：
- en: '![](img/b53deb54-febf-49fd-b361-d2f8ac16958b.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b53deb54-febf-49fd-b361-d2f8ac16958b.jpg)'
- en: There we go, five `Hello world` instances printed to our console window, just
    as we intended.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，五个`Hello world`实例打印到我们的控制台窗口中，就像我们打算的那样。
- en: While loops
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: While循环
- en: 'Often, we allow small programs, such as the ones we''re writing here, to end
    when there''s simply no more code for them to execute. However, while we''re working
    with loops, we''re probably going to make the mistake of accidentally creating
    an infinite `while` loop and running a program that has no end:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们允许小程序，比如我们在这里编写的程序，在没有更多代码可执行时结束。但是，在使用循环时，我们可能会错误地创建一个无限的“while”循环并运行一个没有结束的程序：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When this happens, we''ll need to turn our program off manually. In NetBeans,
    there''s a handy little feature called Stop at the left-hand side of the output
    window:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，我们需要手动关闭我们的程序。在NetBeans中，输出窗口的左侧有一个称为“停止”的方便小功能：
- en: '![](img/c7d6f44b-a371-4bc4-becf-8a58f2ef672d.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7d6f44b-a371-4bc4-becf-8a58f2ef672d.jpg)'
- en: 'If we''re running a program through a Command Prompt, *Ctrl* + *C* is the common
    command to cancel the execution of a program. Now that we have a grasp of the
    basic `while` loop syntax, let''s try something a little more complicated and
    much more dynamic:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过命令提示符运行程序，“Ctrl”+“C”是取消执行程序的常用命令。现在我们已经掌握了基本的“while”循环语法，让我们尝试一些更复杂和更动态的东西：
- en: 'The program I have in mind is going to need some user input, so let''s import
    `java.util` and set up a new `Scanner` object:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我心目中的程序将需要一些用户输入，因此让我们导入“java.util”并设置一个新的“Scanner”对象：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rather than gathering user input right away though, we''re going to collect
    new user input every time our `while` loop successfully executes:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不过，我们不会立即收集用户输入，而是每次我们的“while”循环成功执行时收集新的用户输入：
- en: '[PRE37]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each time we gather this input, we''re going to need somewhere to store it,
    so let''s create a new string whose purpose will be to store the value of the
    newly acquired input:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们收集这个输入，我们都需要一个地方来存储它，所以让我们创建一个新的字符串，其目的是存储新获取的输入的值：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This `input` variable's value will change a number of times throughout the execution
    of our program because at the beginning of every `while` loop, we'll be assigning
    it a new value. If we were to simply execute this program, it wouldn't be very
    interesting for us, the user, because the old values of our input string would
    constantly be lost when we assign it a new value.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个“input”变量的值将在程序执行过程中多次更改，因为在每个“while”循环的开始，我们将为它分配一个新值。如果我们简单地执行这个程序，对我们用户来说将不会很有趣，因为当我们为它分配一个新值时，输入字符串的旧值将不断丢失。
- en: 'So, let''s create another string whose purpose is to store all the concatenated
    values that we''ve gotten from the user. Then, at the end of our program, we''ll
    print out the value of this string so that the user can see we''ve been storing
    their input:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，让我们创建另一个字符串，其目的是存储我们从用户那里得到的所有连接值。然后，在我们的程序结束时，我们将打印出这个字符串的值，以便用户可以看到我们一直在存储他们的输入：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Add the value of the input to the all string on the line illustrated here:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里所示的行上将输入的值添加到所有字符串中：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'There''s a couple of things we can do. We can add strings with the addition
    operator just fine. So the `all = all + input` statement, with `all` and `input`
    being strings, and the plus sign are perfectly valid. However, when we add something
    to itself and work with a primitive or a type that can act like a primitive as
    a string can, we can also use the `+=` operator, which performs the same function.
    Also, we cannot forget to reimplement the decrement of the integer value `i` so
    that our program doesn''t run infinitely:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些事情。我们可以使用加法运算符很好地添加字符串。因此，“all = all + input”语句，其中“all”和“input”是字符串，加号是完全有效的。但是，当我们将某物添加到它自身并使用原始类型或可以像字符串一样起作用的类型时，我们还可以使用“+=”运算符，它执行相同的功能。此外，我们不能忘记重新实现整数值“i”的递减，以便我们的程序不会无限运行：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, if we run this program and provide five strings of input, we get the output
    as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个程序并提供五个输入字符串，我们将得到如下屏幕截图所示的输出：
- en: '![](img/7c471b2c-2671-4516-a0f3-1eac27ec5548.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c471b2c-2671-4516-a0f3-1eac27ec5548.jpg)'
- en: We'll see them all spit back out at us as expected, which is pretty cool, but
    I've got bigger plans for this program.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到它们如预期般全部输出，这很酷，但我对这个程序有更大的计划。
- en: Actually, if we'd only wanted to write the program we have right here, a `for`
    loop, which we'll learn later, might have been completely appropriate. But for
    what we're about to do, `while` and `do...while` loops are pretty necessary. What
    I'd like to do is get rid of our counting variable in this program. Instead, we're
    going to allow the user to tell us when to stop executing our program.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们只想编写我们在这里拥有的程序，稍后我们将学习的“for”循环可能完全合适。但是对于我们即将要做的事情，“while”和“do...while”循环是非常必要的。我想做的是在这个程序中摆脱我们的计数变量。相反，我们将允许用户告诉我们何时停止执行我们的程序。
- en: 'When the user sets the value of the input to the `STOP` string, in all capital
    letters, we''ll quit executing our `while` loop and print out all the strings
    they''ve given us so far. So, we only want this `while` loop to run while the
    value of the input is not the `STOP` value. You''ll notice that we''ll get a precompiled
    error as shown in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将输入的值设置为“STOP”字符串时，以所有大写字母，我们将退出执行我们的“while”循环并打印出他们迄今为止给我们的所有字符串。因此，我们只希望这个“while”循环在输入的值不是“STOP”值时运行。您会注意到，我们将得到一个预编译错误，如下屏幕截图所示：
- en: '![](img/d2271039-64d5-4e5d-8032-3d104f32c4d8.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2271039-64d5-4e5d-8032-3d104f32c4d8.png)'
- en: We'll get a full-on compiler error if we do attempt to run our program. That's
    because our program knows that when we attempt to execute this conditional statement
    for the first time, the value of the input will not have been set. Even though
    the nonexistent value of the input is not equivalent to `STOP`, it's a very bad
    form. In the case of a string here, which is not a primitive, it is not possible
    for our computer to access any of its methods before it's given any value at all.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行程序，我们将会得到一个完整的编译器错误。这是因为我们的程序知道，当我们尝试执行这个条件语句的时候，输入的值还没有被设置。即使输入的不存在的值不等于`STOP`，这也是非常糟糕的形式。在这里的字符串情况下，它不是一个原始的值，我们的计算机在给它任何值之前是不可能访问它的任何方法的。
- en: One inelegant solution here would be to give the input a start value, like we
    did with `all`, but there's a better way. Once our loop has executed for the first
    time, we know that the input will have a proper value given by the user, which
    may or may not be `STOP`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个不太优雅的解决方案是给输入一个起始值，就像我们在`all`中所做的那样，但有一个更好的方法。一旦我们的循环执行了一次，我们知道输入将会有一个由用户给出的正确值，这个值可能是`STOP`，也可能不是。
- en: The do...while loops
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: do...while循环
- en: 'What if instead of checking our conditional at the beginning of our loop, we
    check it at the end? This is in fact an option. The `do...while` loops operate
    just like `while` loops, but the first time they run, they won''t check to see
    whether a conditional is true; they''ll simply run through and check their conditional
    statement at the end. We do need to put a semicolon at the end of a conditional
    statement on the back of the `do...while` loop. I just mentioned this because
    I always forget it. Now, if we run our program, we can give any number of strings
    and then type in the `STOP` string to see everything we''ve typed so far and printed
    out to the screen:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是在循环的开始检查条件，而是在循环的结束检查条件呢？这实际上是一个选项。`do...while`循环的操作方式与`while`循环相同，但第一次运行时，它们不会检查条件是否为真；它们只会运行并在最后检查它们的条件语句。我们需要在`do...while`循环的后面的条件语句的末尾加上一个分号。我提到这个是因为我总是忘记。现在，如果我们运行我们的程序，我们可以输入任意数量的字符串，然后输入`STOP`字符串，以查看到目前为止我们输入的所有内容并打印到屏幕上：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The following is the output of the preceding code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![](img/020caa84-f084-411a-b257-0a1e9854a695.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/020caa84-f084-411a-b257-0a1e9854a695.jpg)'
- en: As a last little note, with just about anything followed by its own code block,
    you'll see a syntax like this, where you will have a keyword and may be a conditional
    statement and then brackets on the following lines; alternatively, you might see
    the brackets start on the same line as the keyword and the conditional statement.
    Both the methods are completely valid, and in fact, the brackets starting on the
    same line as the keyword is probably quickly becoming more common.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点说明，几乎任何后面跟着自己代码块的东西，你会看到这样的语法，你会有一个关键字，可能是一个条件语句，然后是后面的括号；或者，你可能会看到括号从与关键字和条件语句相同的行开始。这两种方法都是完全有效的，事实上，括号从与关键字相同的行开始可能很快就变得更加普遍。
- en: I encourage you to play around with the program we've written. Try executing
    loops that you think will push the boundaries of how much information a string
    can hold, or play around with loops that present an enormous amount of information
    to the screen. This is stuff that computers do that we simply couldn't with pencil
    and paper, so it's pretty neat.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你玩弄一下我们写的程序。尝试执行你认为会推动字符串所能容纳的信息量边界的循环，或者玩弄一下向屏幕呈现大量信息的循环。这是计算机做的事情，我们简单地无法用铅笔和纸做到，所以这很酷。
- en: For loops
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: for循环
- en: In this section, we're going to take a quick look at `for` loops. We use `for`
    loops to solve a common problem in Java in a very semantically elegant manner.
    These loops are appropriate when we need to iterate a variable to count how many
    times we've looped.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将快速看一下`for`循环。我们使用`for`循环以非常语义优雅的方式解决Java中的一个常见问题。当我们需要迭代一个变量来计算我们循环了多少次时，这些循环是合适的。
- en: 'To start off, I''ve written a very basic program using a `while` loop; it prints
    the values `1` through `100` to the window on our screen. Once you''ve hashed
    out in your mind how this `while` loop is working, we''ll write the same loop
    with a `for` loop so that we could see how the `for` loop is more elegant in this
    particular instance. Let''s comment out our `while` loop so that we can still
    see it as shown in the following screenshot without having it execute any of its
    code and begin writing our `for` loop instead :'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我写了一个非常基本的程序，使用了一个`while`循环；它将值`1`到`100`打印到我们屏幕上的窗口。一旦你在脑海中理清了这个`while`循环是如何工作的，我们将使用`for`循环编写相同的循环，这样我们就可以看到在这种特定情况下`for`循环更加优雅。让我们注释掉我们的`while`循环，这样我们仍然可以在下面的截图中看到它，而不执行任何代码，并开始编写我们的`for`循环：
- en: '![](img/d4996023-cabc-4c0c-8152-afe66ac3487a.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d4996023-cabc-4c0c-8152-afe66ac3487a.jpg)'
- en: The basic syntax of a `for` loop looks very similar to that of a `while` loop.
    We have the reserved keyword, two parentheses in which we'll put some information
    that the loop needs, and the code block that we're going to loop through. Unlike
    a `while` loop, which just takes a conditional statement between these parentheses,
    we're going to provide our `for` loop with a bunch of information. Because the
    `for` loop is designed to handle a specific case, once we give it all this information,
    it will know exactly what to do with it. This alleviates the need for us to handle
    code outside of the loop and manually increment or decrement it inside of the
    loop. It keeps the functional bit of our code, our `println` statement, and in
    more complicated programs, the more complicated information that may be inside
    the `for` loop, more isolated.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环的基本语法看起来非常类似于`while`循环。我们有保留关键字，在两个括号中我们将放一些循环需要的信息，以及我们将要循环的代码块。与`while`循环不同的是，`while`循环只在这些括号之间提供一个条件语句，而我们将为`for`循环提供大量信息。因为`for`循环设计用于处理特定情况，一旦我们提供了所有这些信息，它就会准确知道如何处理。这减轻了我们处理循环外的代码和在循环内手动递增或递减的需要。它使我们的代码的功能部分，即`println`语句，以及在更复杂的程序中可能在`for`循环内的更复杂的信息，更加独立。'
- en: 'Our typical `for` loop takes three pieces of input. These are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们典型的`for`循环需要三个输入。它们如下：
- en: First, we need to declare the variable that we're going to be incrementing or
    decrementing to count the number of times we've looped. In this case, we'll use
    an integer `i` and give it a initial value of `1`. We follow this initial statement
    with a semicolon. This is not a function call; it's special syntax for the `for`
    loop.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要声明我们将要递增或递减以计算我们循环的次数的变量。在这种情况下，我们将使用一个整数`i`，并给它一个初始值`1`。我们在这个初始语句后面加上一个分号。这不是一个函数调用；这是`for`循环的特殊语法。
- en: The second piece of information the special syntax requires is the conditional
    statement that we need to evaluate each time we're going to restart the loop.
    If this conditional statement is ever not true, then our `for` loop ends and we
    continue resuming our code after the `for` loop block. In this case, our conditional
    statement will be the same as it was for the `while` loop. We want our last iteration
    of the `for` loop to be when `i` is equal to `100`, that is, when we print out
    `100`. Once `i` is no longer less than or equal to 100, it's time to exit our
    `for` loop.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特殊语法需要的第二个信息是我们需要评估每次重新开始循环时的条件语句。如果这个条件语句不成立，那么我们的`for`循环就结束了，我们继续在`for`循环块之后恢复我们的代码。在这种情况下，我们的条件语句将与`while`循环的条件语句相同。我们希望我们的`for`循环的最后一次迭代是当`i`等于`100`时，也就是当我们打印出`100`时。一旦`i`不再小于或等于100，就是退出我们的`for`循环的时候了。
- en: 'Just as the first piece of information we specially gave the `for` loop saved
    us from having to handle a variable outside the scope of our loop, the last piece
    of information we will give the `for` loop takes the place of us having to manually
    increment or decrement our counter inside the scope of the loop. This is the special
    modification code, and whatever we provide the `for` loop here will run at the
    end of every loop. In this case, we''d just like to increment the value of `i`
    at the end of each looping through. I think you''ll agree that this program is
    much cleaner than our `while` loop:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像我们特别给`for`循环的第一个信息使我们不必处理循环范围之外的变量一样，我们将给`for`循环的最后一个信息取代我们在循环范围内手动递增或递减计数器。这是特殊的修改代码，无论我们在这里为`for`循环提供什么，都将在每次循环结束时运行。在这种情况下，我们只想在每次循环结束时递增`i`的值。我想你会同意，这个程序比我们的`while`循环要干净得多：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s just check that it performs the same task of printing the value
    of `1` to `100` to our screen, as shown in the following screenshot:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一下它是否执行了相同的任务，即将值从`1`打印到`100`到我们的屏幕上，如下面的截图所示：
- en: '![](img/1cb8b21e-035c-4dfc-8e7b-4a57d4888cf2.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1cb8b21e-035c-4dfc-8e7b-4a57d4888cf2.jpg)'
- en: If this statement were to execute at the very beginning of our `for` loop, `0`
    would have been correct, but this executes at the end.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个语句在我们的`for`循环的最开始执行，`0`就是正确的，但是这个语句在最后执行。
- en: When we're working with large numbers and increments in Java or any programming
    language really, we call errors, like what we just ran into, **off-by-one error**
    (**OBOE**) errors. OBOE are those kinds of little logic mistakes that even experienced
    programmers can run into if they don't pay attention or just look the wrong way
    for an instance. Learning to recognize the symptoms of OBOE, for example, one
    more line outputted than expected, will allow us to track them down and find them
    much more efficiently.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Java或任何编程语言中处理大数字和增量时，我们会遇到错误，就像我们刚刚遇到的那样，**一错再错**（**OBOE**）错误。OBOE是那种即使有经验的程序员也会遇到的小逻辑错误，如果他们不注意或者只是看错了一瞬间。学会识别OBOE的症状，例如，输出的行数比预期的多一行，将使我们能够更有效地追踪并找到它们。
- en: Summary
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we basically saw how to work with conditional `if...else` statements
    running through the complex conditionals using functions such as `contains`, `complex`,
    and `boolean`. We went through the intricacies of `switch`, `case`, and `break`
    with the help of programs; also, we dived deep into how to use the loop functionality
    using the `while`, `do...while`, and `for` loops.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们基本上看到了如何使用条件`if...else`语句来运行复杂的条件，使用诸如`contains`、`complex`和`boolean`等函数。我们通过程序详细讨论了`switch`、`case`和`break`的复杂性；此外，我们深入探讨了如何使用`while`、`do...while`和`for`循环的循环功能。
- en: In the next chapter, we'll look at something called a **data structure**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下所谓的**数据结构**。
