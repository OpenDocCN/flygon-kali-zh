["```java\npublic static void sort(int[] arr) {\n\u00a0\u00a0int n = arr.length;\n\u00a0\u00a0buildHeap(arr, n);\n\u00a0\u00a0while (n > 1) {\n\u00a0\u00a0\u00a0\u00a0swap(arr, 0, n - 1);\n\u00a0\u00a0\u00a0\u00a0n--;\n\u00a0\u00a0\u00a0\u00a0heapify(arr, n, 0);\n\u00a0\u00a0}\n}\nprivate static void buildHeap(int[] arr, int n) {\n\u00a0\u00a0for (int i = arr.length / 2; i >= 0; i--) {\n\u00a0\u00a0\u00a0\u00a0heapify(arr, n, i);\n\u00a0\u00a0}\n}\nprivate static void heapify(int[] arr, int n, int i) {\n\u00a0\u00a0int left = i * 2 + 1;\n\u00a0\u00a0int right = i * 2 + 2;\n\u00a0\u00a0int greater;\n\u00a0\u00a0if (left < n && arr[left] > arr[i]) {\n\u00a0\u00a0\u00a0\u00a0greater = left;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0greater = i;\n\u00a0\u00a0}\n\u00a0\u00a0if (right < n && arr[right] > arr[greater]) {\n\u00a0\u00a0\u00a0\u00a0greater = right;\n\u00a0\u00a0}\n\u00a0\u00a0if (greater != i) {\n\u00a0\u00a0\u00a0\u00a0swap(arr, i, greater);\n\u00a0\u00a0\u00a0\u00a0heapify(arr, n, greater);\n\u00a0\u00a0}\n}\nprivate static void swap(int[] arr, int x, int y) {\n\u00a0\u00a0int temp = arr[x];\n\u00a0\u00a0arr[x] = arr[y];\n\u00a0\u00a0arr[y] = temp;\n}\n```", "```java\npublic static void sort(int[] arr) {\n\u00a0\u00a0if (arr.length > 1) {\n\u00a0\u00a0\u00a0\u00a0int[] left = leftHalf(arr);\n\u00a0\u00a0\u00a0\u00a0int[] right = rightHalf(arr);\n\u00a0\u00a0\u00a0\u00a0sort(left);\n\u00a0\u00a0\u00a0\u00a0sort(right);\n\u00a0\u00a0\u00a0\u00a0merge(arr, left, right);\n\u00a0\u00a0}\n}\nprivate static int[] leftHalf(int[]arr) {\n\u00a0\u00a0int size = arr.length / 2;\n\u00a0\u00a0int[] left = new int[size];\n\u00a0\u00a0System.arraycopy(arr, 0, left, 0, size);\n\u00a0\u00a0return left;\n}\nprivate static int[] rightHalf(int[] arr) {\n\u00a0\u00a0int size1 = arr.length / 2;\n\u00a0\u00a0int size2 = arr.length - size1;\n\u00a0\u00a0int[] right = new int[size2];\n\u00a0\u00a0for (int i = 0; i < size2; i++) {\n\u00a0\u00a0\u00a0\u00a0right[i] = arr[i + size1];\n\u00a0\u00a0}\n\u00a0\u00a0return right;\n}\n```", "```java\nprivate static void merge(int[] result, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int[] left, int[] right) {\n\u00a0\u00a0int t1 = 0;\n\u00a0\u00a0int t2 = 0;\n\u00a0\u00a0for (int i = 0; i < result.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (t2 >= right.length\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|| (t1 < left.length && left[t1] <= right[t2])) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i] = left[t1];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t1++;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result[i] = right[t2];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0t2++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nsort(array, left, right)\n\u00a0\u00a0\u00a0\u00a0if left < right\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m = partition(array, left, right)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sort(array, left, m-1)\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sort(array, m+1, right)\n\u00a0\u00a0\u00a0\u00a0end\nend\npartition(array, left, right)\n\u00a0\u00a0\u00a0\u00a0pivot = array[right]\n\u00a0\u00a0\u00a0\u00a0m = left\n\u00a0\u00a0\u00a0\u00a0for i = m to right-1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if array[i] <= pivot\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0swap array[i] with array[m]\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0m=m+1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0end \n\u00a0\u00a0\u00a0\u00a0end\n\u00a0\u00a0\u00a0\u00a0swap array[m] with array[right]\n\u00a0\u00a0\u00a0\u00a0return m\nend\n```", "```java\npublic static void sort(int[] arr, int left, int right) {\n\u00a0\u00a0if (left < right) {\n\u00a0\u00a0\u00a0\u00a0int m = partition(arr, left, right);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0\u00a0\u00a0sort(arr, left, m - 1);\n\u00a0\u00a0\u00a0\u00a0sort(arr, m + 1, right);\n\u00a0\u00a0}\n}\nprivate static int partition(int[] arr, int left, int right) {\n\u00a0\u00a0int pivot = arr[right];\n\u00a0\u00a0int m = left;\n\u00a0\u00a0for (int i = m; i < right; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[i] <= pivot) {\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0swap(arr, i, m++);\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0swap(arr, right, m);\n\u00a0\u00a0return m;\n}\n```", "```java\nsort(array)\n\u00a0\u00a0create N buckets each of which can hold a range of elements\n\u00a0\u00a0for all the buckets\n\u00a0\u00a0\u00a0\u00a0initialize each bucket with 0 values\n\u00a0\u00a0for all the buckets\n\u00a0\u00a0\u00a0\u00a0put elements into buckets matching the range\n\u00a0\u00a0for all the buckets \n\u00a0\u00a0\u00a0\u00a0sort elements in each bucket\n\u00a0\u00a0\u00a0\u00a0gather elements from each bucket\nend \n```", "```java\n/* Scatter-Sort-Gather approach */\npublic static void sort(int[] arr) {\n\u00a0\u00a0// get the hash codes \n\u00a0\u00a0int[] hashes = hash(arr);\n\u00a0\u00a0// create and initialize buckets\n\u00a0\u00a0List<Integer>[] buckets = new List[hashes[1]];\n\u00a0\u00a0for (int i = 0; i < hashes[1]; i++) {\n\u00a0\u00a0\u00a0\u00a0buckets[i] = new ArrayList();\n\u00a0\u00a0}\n\u00a0\u00a0// scatter elements into buckets\n\u00a0\u00a0for (int e : arr) {\n\u00a0\u00a0\u00a0\u00a0buckets[hash(e, hashes)].add(e);\n\u00a0\u00a0}\n\u00a0\u00a0// sort each bucket\n\u00a0\u00a0for (List<Integer> bucket : buckets) {\n\u00a0\u00a0\u00a0\u00a0Collections.sort(bucket);\n\u00a0\u00a0}\n\u00a0\u00a0// gather elements from the buckets\n\u00a0\u00a0int p = 0;\n\u00a0\u00a0for (List<Integer> bucket : buckets) {\n\u00a0\u00a0\u00a0\u00a0for (int j : bucket) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[p++] = j;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\nsort(array)\n\u00a0\u00a0create N buckets each of which can track a\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0counter of a single element\n\u00a0\u00a0for all the buckets\n\u00a0\u00a0\u00a0\u00a0initialize each bucket with 0 values\n\u00a0\u00a0for all the buckets\n\u00a0\u00a0\u00a0\u00a0put elements into buckets matching a single \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0element per bucket\n\u00a0\u00a0for all the buckets \n\u00a0\u00a0\u00a0\u00a0gather elements from each bucket\nend \n```", "```java\n/* Scatter-Gather approach */\npublic static void sort(int[] arr) {\n\u00a0\u00a0// get the maximum value of the given array\n\u00a0\u00a0int max = arr[0];\n\u00a0\u00a0for (int i = 1; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[i] > max) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = arr[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// create max buckets\n\u00a0\u00a0int[] bucket = new int[max + 1];\n\u00a0\u00a0// the bucket[] is automatically initialized with 0s, \n\u00a0\u00a0// therefore this step is redundant\n\u00a0\u00a0for (int i = 0; i < bucket.length; i++) {\n\u00a0\u00a0\u00a0\u00a0bucket[i] = 0;\n\u00a0\u00a0}\n\u00a0\u00a0// scatter elements in buckets\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0bucket[arr[i]]++;\n\u00a0\u00a0}\n\u00a0\u00a0// gather elements from the buckets\n\u00a0\u00a0int p = 0;\n\u00a0\u00a0for (int i = 0; i < bucket.length; i++) {\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < bucket[i]; j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0arr[p++] = i;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic static void sort(int[] arr, int radix) {\n\u00a0\u00a0int min = arr[0];\n\u00a0\u00a0int max = arr[0];\n\u00a0\u00a0for (int i = 1; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[i] < min) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0min = arr[i];\n\u00a0\u00a0\u00a0\u00a0} else if (arr[i] > max) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0max = arr[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0int exp = 1;\n\u00a0\u00a0while ((max - min) / exp >= 1) {\n\u00a0\u00a0\u00a0\u00a0countSortByDigit(arr, radix, exp, min);\n\u00a0\u00a0\u00a0\u00a0exp *= radix;\n\u00a0\u00a0}\n}\nprivate static void countSortByDigit(\n\u00a0\u00a0\u00a0\u00a0int[] arr, int radix, int exp, int min) {\n\u00a0\u00a0int[] buckets = new int[radix];\n\u00a0\u00a0for (int i = 0; i < radix; i++) {\n\u00a0\u00a0\u00a0\u00a0buckets[i] = 0;\n\u00a0\u00a0}\n\u00a0\u00a0int bucket;\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0bucket = (int) (((arr[i] - min) / exp) % radix);\n\u00a0\u00a0\u00a0\u00a0buckets[bucket]++;\n\u00a0\u00a0}\n\u00a0\u00a0for (int i = 1; i < radix; i++) {\n\u00a0\u00a0\u00a0\u00a0buckets[i] += buckets[i - 1];\n\u00a0\u00a0}\n\u00a0\u00a0int[] out = new int[arr.length];\n\u00a0\u00a0for (int i = arr.length - 1; i >= 0; i--) {\n\u00a0\u00a0\u00a0\u00a0bucket = (int) (((arr[i] - min) / exp) % radix);\n\u00a0\u00a0\u00a0\u00a0out[--buckets[bucket]] = arr[i];\n\u00a0\u00a0}\n\u00a0\u00a0System.arraycopy(out, 0, arr, 0, arr.length);\n}\n```", "```java\nsearch 17 in {1, 4, 5, 7, 10, 16, 17, 18, 20,\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a023, 24, 25, 26, 30, 31, 33}\n\u00a0\u00a0\u00a0\u00a0compare 17 to 18 -> 17 < 18\n\u00a0\u00a0\u00a0\u00a0search 17 in {1, 4, 5, 7, 10, 16, 17, 18}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compare 17 to 7 -> 17 > 7\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0search 17 in {7, 10, 16, 17}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compare 17 to 16 -> 17 > 16\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0search 17 in {16, 17}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0compare 17 to 17\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return\n```", "```java\npublic static int runIterative(int[] arr, int p) {\n\u00a0\u00a0// the search space is the whole array\n\u00a0\u00a0int left = 0;\n\u00a0\u00a0int right = arr.length - 1;\n\u00a0\u00a0// while the search space has at least one element\n\u00a0\u00a0while (left <= right) {\n\u00a0\u00a0\u00a0\u00a0// half the search space\n\u00a0\u00a0\u00a0\u00a0int mid = (left + right) / 2;\n\u00a0\u00a0\u00a0\u00a0// if domain overflow can happen then use:\n\u00a0\u00a0\u00a0\u00a0// int mid = left + (right - left) / 2;\n\u00a0\u00a0\u00a0\u00a0// int mid = right - (right - left) / 2;\n\u00a0\u00a0\u00a0\u00a0// we found the searched element \n\u00a0\u00a0\u00a0\u00a0if (p == arr[mid]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return mid;\n\u00a0\u00a0\u00a0\u00a0} // discard all elements in the right of the \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// search space including 'mid'\n\u00a0\u00a0\u00a0\u00a0else if (p < arr[mid]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = mid - 1;\n\u00a0\u00a0\u00a0\u00a0} // discard all elements in the left of the \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// search space including 'mid'\n\u00a0\u00a0\u00a0\u00a0else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = mid + 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// by convention, -1 means element not found into the array\n\u00a0\u00a0return -1;\n}\n```", "```java\npublic static void merge(int[] p, int[] q) {\n\u00a0\u00a0int pLast = p.length - q.length;\n\u00a0\u00a0int qLast = q.length;\n\u00a0\u00a0if (pLast < 0) {\n\u00a0\u00a0\u00a0\u00a0throw new IllegalArgumentException(\"p cannot fit q\");\n\u00a0\u00a0}\n\u00a0\u00a0int pIdx = pLast - 1;\n\u00a0\u00a0int qIdx = qLast - 1;\n\u00a0\u00a0int mIdx = pLast + qLast - 1;\n\u00a0\u00a0// merge p and q\n\u00a0\u00a0// start from the last element in p and q\n\u00a0\u00a0while (qIdx >= 0) {\n\u00a0\u00a0\u00a0\u00a0if (pIdx >= 0 && p[pIdx] > q[qIdx]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p[mIdx] = p[pIdx];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0pIdx--;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0p[mIdx] = q[qIdx];\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0qIdx--;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0mIdx--;\n\u00a0\u00a0}\n}\n```", "```java\nString[] words = {\n\u00a0\u00a0\"calipers\", \"caret\", \"slat\", \"cater\", \"thickset\",\u00a0\u00a0 \n\u00a0\u00a0\"spiracle\", \"trace\", \"last\", \"salt\", \"bowel\", \"crate\", \n\u00a0\u00a0\"loop\", \"polo\", \"thickest\", \"below\", \"thickets\", \n\u00a0\u00a0\"pool\", \"elbow\", \"replicas\"\n};\n```", "```java\n// helper method for sorting the chars of a word\nprivate static String sortWordChars(String word) {\n\u00a0\u00a0char[] wordToChar = word.toCharArray();\n\u00a0\u00a0Arrays.sort(wordToChar);\n\u00a0\u00a0return String.valueOf(wordToChar);\n}\n```", "```java\npublic class Anagrams implements Comparator<String> {\n\u00a0\u00a0@Override\n\u00a0\u00a0public int compare(String sl, String s2) {\n\u00a0\u00a0\u00a0\u00a0return sortStringChars(sl).compareTo(sortStringChars(s2));\n\u00a0\u00a0}\n}\n```", "```java\nArrays.sort(words, new Anagrams());\n```", "```java\n/* Group anagrams via hashing (O(nm log m) */\npublic void printAnagrams(String words[]) {\n\u00a0\u00a0Map<String, List<String>> result = new HashMap<>();\n\u00a0\u00a0for (int i = 0; i < words.length; i++) {\n\u00a0\u00a0\u00a0\u00a0// sort the chars of each string\n\u00a0\u00a0\u00a0\u00a0String word = words[i];\n\u00a0\u00a0\u00a0\u00a0String sortedWord = sortWordChars(word);\n\u00a0\u00a0\u00a0\u00a0if (result.containsKey(sortedWord)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.get(sortedWord).add(word);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// start a new group of anagrams\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0List<String> anagrams = new ArrayList<>();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0anagrams.add(word);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.put(sortedWord, anagrams);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// print the result\n\u00a0\u00a0System.out.println(result.values());\n}\n```", "```java\n/* Group anagrams via hashing (O(nm)) */\npublic void printAnagramsOptimized(String[] words) {\n\u00a0\u00a0Map<String, List<String>> result = new HashMap<>();\n\u00a0\u00a0for (int i = 0; i < words.length; i++) {\n\u00a0\u00a0\u00a0\u00a0String word = words[i];\n\u00a0\u00a0\u00a0\u00a0char[] wordToChar = new char[RANGE_a_z];\n\u00a0\u00a0\u00a0\u00a0// count up the number of occurrences (frequency) \n\u00a0\u00a0\u00a0\u00a0// of each letter in 'word'\n\u00a0\u00a0\u00a0\u00a0for (int j = 0; j < word.length(); j++) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0wordToChar[word.charAt(j) - 'a']++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0String computedWord = String.valueOf(wordToChar);\n\u00a0\u00a0\u00a0\u00a0if (result.containsKey(computedWord)) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.get(computedWord).add(word);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0List<String> anagrams = new ArrayList<>();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0anagrams.add(word);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0result.put(computedWord, anagrams);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0System.out.println(result.values());\n}\n```", "```java\npublic class SizelessList {\n\u00a0\u00a0private final int[] arr;\n\u00a0\u00a0public SizelessList(int[] arr) {\n\u00a0\u00a0\u00a0\u00a0this.arr = arr.clone();\n\u00a0\u00a0}\n\u00a0\u00a0public int peekAt(int index) {\n\u00a0\u00a0\u00a0\u00a0if (index >= arr.length) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0return arr[index];\n\u00a0\u00a0}\n}\n```", "```java\npublic static int search(SizelessList sl, int element) {\n\u00a0\u00a0int index = 1;\n\u00a0\u00a0while (sl.peekAt(index) != -1\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& sl.peekAt(index) < element) {\n\u00a0\u00a0\u00a0\u00a0index *= 2;\n\u00a0\u00a0}\n\u00a0\u00a0return binarySearch(sl, element, index / 2, index);\n}\nprivate static int binarySearch(SizelessList sl, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int element, int left, int right) {\n\u00a0\u00a0int mid;\n\u00a0\u00a0while (left <= right) {\n\u00a0\u00a0\u00a0\u00a0mid = (left + right) / 2;\n\u00a0\u00a0\u00a0\u00a0int middle = sl.peekAt(mid);\n\u00a0\u00a0\u00a0\u00a0if (middle > element || middle == -1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = mid - 1;\n\u00a0\u00a0\u00a0\u00a0} else if (middle < element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = mid + 1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return mid;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```", "```java\n// Divide the given linked list in two equal sub-lists.\n// If the length of the given linked list is odd, \n// the extra node will go in the first sub-list\nprivate Node[] divide(Node sourceNode) {\n\u00a0\u00a0// length is less than 2\n\u00a0\u00a0if (sourceNode == null || sourceNode.next == null) {\n\u00a0\u00a0\u00a0\u00a0return new Node[]{sourceNode, null};\n\u00a0\u00a0}\n\u00a0\u00a0Node fastRunner = sourceNode.next;\n\u00a0\u00a0Node slowRunner = sourceNode;\n\u00a0\u00a0// advance 'firstRunner' two nodes, \n\u00a0\u00a0// and advance 'secondRunner' one node\n\u00a0\u00a0while (fastRunner != null) {\n\u00a0\u00a0\u00a0\u00a0fastRunner = fastRunner.next;\n\u00a0\u00a0\u00a0\u00a0if (fastRunner != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0slowRunner = slowRunner.next;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0fastRunner = fastRunner.next;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// 'secondRunner' is just before the middle point \n\u00a0\u00a0// in the list, so split it in two at that point\n\u00a0\u00a0Node[] headsOfSublists = new Node[]{\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sourceNode, slowRunner.next};\n\u00a0\u00a0slowRunner.next = null;\n\u00a0\u00a0return headsOfSublists;\n}\n```", "```java\n// sort the given linked list via the Merge Sort algorithm\npublic void sort() {\n\u00a0\u00a0head = sort(head);\n}\nprivate Node sort(Node head) {\n\u00a0\u00a0if (head == null || head.next == null) {\n\u00a0\u00a0\u00a0\u00a0return head;\n\u00a0\u00a0}\n\u00a0\u00a0// split head into two sublists\n\u00a0\u00a0Node[] headsOfSublists = divide(head);\n\u00a0\u00a0Node head1 = headsOfSublists[0];\u00a0\u00a0\n\u00a0\u00a0Node head2 = headsOfSublists[1];\n\u00a0\u00a0// recursively sort the sublists\n\u00a0\u00a0head1 = sort(head1);\n\u00a0\u00a0head2 = sort(head2);\n\u00a0\u00a0// merge the two sorted lists together\n\u00a0\u00a0return merge(head1, head2);\n}\n// takes two lists sorted in increasing order, and merge \n// their nodes together (which is returned)\nprivate Node merge(Node head1, Node head2) {\n\u00a0\u00a0if (head1 == null) {\n\u00a0\u00a0\u00a0\u00a0return head2;\n\u00a0\u00a0} else if (head2 == null) {\n\u00a0\u00a0\u00a0\u00a0return head1;\n\u00a0\u00a0}\n\u00a0\u00a0Node merged;\n\u00a0\u00a0// pick either 'head1' or 'head2'\n\u00a0\u00a0if (head1.data <= head2.data) {\n\u00a0\u00a0\u00a0\u00a0merged = head1;\n\u00a0\u00a0\u00a0\u00a0merged.next = merge(head1.next, head2);\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0merged = head2;\n\u00a0\u00a0\u00a0\u00a0merged.next = merge(head1, head2.next);\n\u00a0\u00a0}\n\u00a0\u00a0return merged;\n}\n```", "```java\npublic static int search(String[] stringsArr, String str) {\n\u00a0\u00a0return search(stringsArr, str, 0, stringsArr.length - 1);\n}\nprivate static int search(String[] stringsArr, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0String str, int left, int right) {\n\u00a0\u00a0if (left > right) {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0int mid = (left + right) / 2;\n\u00a0\u00a0// since mid is empty we try to find the \n\u00a0\u00a0// closest non-empty string to mid\n\u00a0\u00a0if (stringsArr[mid].isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0int leftMid = mid - 1;\n\u00a0\u00a0\u00a0\u00a0int rightMid = mid + 1;\n\u00a0\u00a0\u00a0\u00a0while (true) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (leftMid < left && rightMid > right) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (rightMid <= right \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& !stringsArr[rightMid].isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = rightMid;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else if (leftMid >= left \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0&& !stringsArr[leftMid].isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0mid = leftMid;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0break;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0rightMid++;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0leftMid--;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0if (str.equals(stringsArr[mid])) {\n\u00a0\u00a0\u00a0\u00a0// the searched string was found\n\u00a0\u00a0\u00a0\u00a0return mid;\n\u00a0\u00a0} else if (stringsArr[mid].compareTo(str) < 0) {\n\u00a0\u00a0\u00a0\u00a0// search to the right\n\u00a0\u00a0\u00a0\u00a0return search(stringsArr, str, mid + 1, right);\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0// search to the left\n\u00a0\u00a0\u00a0\u00a0return search(stringsArr, str, left, mid - 1);\n\u00a0\u00a0}\n}\n```", "```java\npublic static void sort(Queue<Integer> queue) {\n\u00a0\u00a0if (queue == null || queue.size() < 2) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// this is the extra queue\n\u00a0\u00a0Queue<Integer> extraQueue = new ArrayDeque();\n\u00a0\u00a0int count = 0;\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// count the processed elements\n\u00a0\u00a0boolean sorted = false;\u00a0\u00a0 // flag when sorting is done\n\u00a0\u00a0int queueSize = queue.size();\u00a0\u00a0 // size of the given queue\n\u00a0\u00a0int lastElement = queue.peek(); // we start from the front\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// of the given queue\n\u00a0\u00a0while (!sorted) {\n\u00a0\u00a0\u00a0\u00a0// Step 1\n\u00a0\u00a0\u00a0\u00a0if (lastElement <= queue.peek()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastElement = queue.poll();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0extraQueue.add(lastElement);\n\u00a0\u00a0\u00a0\u00a0} else { // Step 2\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(queue.poll());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// still have elements to process\n\u00a0\u00a0\u00a0\u00a0count++;\n\u00a0\u00a0\u00a0\u00a0if (count != queueSize) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0continue;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Step 4\n\u00a0\u00a0\u00a0\u00a0if (extraQueue.size() == queueSize) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0sorted = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// Step 3\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0while (extraQueue.size() > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(extraQueue.poll());\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0lastElement = queue.peek();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0count = 0;\n\u00a0\u00a0}\n}\n```", "```java\npublic static void sort(Queue<Integer> queue) {\n\u00a0\u00a0// traverse the unsorted part of the queue\n\u00a0\u00a0for (int i = 1; i <= queue.size(); i++) {\n\u00a0\u00a0\u00a0\u00a0moveMinToRear(queue, queue.size() - i);\n\u00a0\u00a0}\n}\n// find (in the unsorted part) the minimum\n// element and move this element to the rear of the queue\nprivate static void moveMinToRear(Queue<Integer> queue, \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int sortIndex) {\n\u00a0\u00a0int minElement = Integer.MAX_VALUE;\n\u00a0\u00a0boolean flag = false;\n\u00a0\u00a0int queueSize = queue.size();\n\u00a0\u00a0for (int i = 0; i < queueSize; i++) {\n\u00a0\u00a0\u00a0\u00a0int currentElement = queue.peek();\n\u00a0\u00a0\u00a0\u00a0// dequeue\n\u00a0\u00a0\u00a0\u00a0queue.poll();\n\u00a0\u00a0\u00a0\u00a0// avoid traversing the sorted part of the queue\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (currentElement <= minElement && i <= sortIndex) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// if we found earlier a minimum then \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we put it back into the queue since\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// we just found a new minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (flag) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(minElement);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0flag = true;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0minElement = currentElement;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// enqueue the current element which is not the minimum\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0queue.add(currentElement);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0// enqueue the minimum element\n\u00a0\u00a0queue.add(minElement);\n}\n```", "```java\npublic static void sort(Stack<Integer> stack) {\n\u00a0\u00a0Stack<Integer> auxStack = new Stack<>();\n\u00a0\u00a0// Step 1 (a, b and c)\n\u00a0\u00a0while (!stack.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0int t = stack.pop();\n\u00a0\u00a0\u00a0\u00a0while (!auxStack.isEmpty() && auxStack.peek() > t) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.push(auxStack.pop());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0auxStack.push(t);\n\u00a0\u00a0}\n\u00a0\u00a0// Step 2\n\u00a0\u00a0while (!auxStack.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0stack.push(auxStack.pop());\n\u00a0\u00a0}\n}\n```", "```java\npublic static void sort(Stack<Integer> stack) {\n\u00a0\u00a0// stack is empty (base case)\n\u00a0\u00a0if (stack.isEmpty()) {\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// remove the top element\n\u00a0\u00a0int top = stack.pop();\n\u00a0\u00a0// apply recursion for the remaining elements in the stack\n\u00a0\u00a0sort(stack);\n\u00a0\u00a0// insert the popped element back in the sorted stack\n\u00a0\u00a0sortedInsert(stack, top);\n}\nprivate static void sortedInsert(\n Stack<Integer> stack, int element) {\n\u00a0\u00a0// the stack is empty or the element \n\u00a0\u00a0// is greater than all elements in the stack (base case)\n\u00a0\u00a0if (stack.isEmpty() || element > stack.peek()) {\n\u00a0\u00a0\u00a0\u00a0stack.push(element);\n\u00a0\u00a0\u00a0\u00a0return;\n\u00a0\u00a0}\n\u00a0\u00a0// the element is smaller than the top element, \n\u00a0\u00a0// so remove the top element\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0int top = stack.pop();\n\u00a0\u00a0// apply recursion for the remaining elements in the stack\n\u00a0\u00a0sortedInsert(stack, element);\n\u00a0\u00a0// insert the popped element back in the stack\n\u00a0\u00a0stack.push(top);\n}\n```", "```java\npublic static boolean search(int[][] matrix, int element) {\n\u00a0\u00a0int rows = matrix.length;\u00a0\u00a0\u00a0\u00a0// number of rows\n\u00a0\u00a0int cols = matrix[0].length; // number of columns\n\u00a0\u00a0// search space is an array as [0, (rows * cols) - 1]\n\u00a0\u00a0int left = 0;\n\u00a0\u00a0int right = (rows * cols) - 1;\n\u00a0\u00a0// start binary search\n\u00a0\u00a0while (left <= right) {\n\u00a0\u00a0\u00a0\u00a0int mid = (left + right) / 2;\n\u00a0\u00a0\u00a0\u00a0int midElement = matrix[mid / cols][mid % cols];\n\u00a0\u00a0\u00a0\u00a0if (element == midElement) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0} else if (element < midElement) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = mid - 1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = mid + 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static boolean search(int[][] matrix, int element) {\n\u00a0\u00a0int row = 0;\n\u00a0\u00a0int col = matrix[0].length - 1;\n\u00a0\u00a0while (row < matrix.length && col >= 0) {\n\u00a0\u00a0\u00a0\u00a0if (matrix[row][col] == element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return true;\n\u00a0\u00a0\u00a0\u00a0} else if (matrix[row][col] > element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0col--;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0row++;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return false;\n}\n```", "```java\npublic static int firstOneIndex(int[] arr) {\n\u00a0\u00a0if (arr == null) {\n\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0}\n\u00a0\u00a0int left = 0;\n\u00a0\u00a0int right = arr.length - 1;\n\u00a0\u00a0while (left <= right) {\n\u00a0\u00a0\u00a0\u00a0int middle = 1 + (right - left) / 2;\n\u00a0\u00a0\u00a0\u00a0if (arr[middle] == 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0left = middle + 1;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0right = middle - 1;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (arr[left] == 1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return left;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return -1;\n}\n```", "```java\npublic static int maxDiff(int arr[]) {\n\u00a0\u00a0int len = arr.length;\n\u00a0\u00a0int maxDiff = arr[1] - arr[0];\n\u00a0\u00a0int marker = arr[0];\n\u00a0\u00a0for (int i = 1; i < len; i++) {\n\u00a0\u00a0\u00a0\u00a0if (arr[i] - marker > maxDiff) { \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0maxDiff = arr[i] - marker;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (arr[i] < marker) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0marker = arr[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0return maxDiff;\n}\n```", "```java\npublic class Stream {\n\u00a0\u00a0private Node root = null;\n\u00a0\u00a0private class Node {\n\u00a0\u00a0\u00a0\u00a0private final int element;\n\u00a0\u00a0\u00a0\u00a0private int leftTreeSize;\n\u00a0\u00a0\u00a0\u00a0private Node left;\n\u00a0\u00a0\u00a0\u00a0private Node right;\n\u00a0\u00a0\u00a0\u00a0private Node(int element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.element = element;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.left = null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0this.right = null;\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0 \n\u00a0\u00a0}\n\u00a0\u00a0/* add a new node into the tree */\n\u00a0\u00a0public void generate(int element) {\n\u00a0\u00a0\u00a0\u00a0if (root == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0root = new Node(element);\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0insert(root, element);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0private void insert(Node node, int element) {\n\u00a0\u00a0\u00a0\u00a0if (element <= node.element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.left != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0insert(node.left, element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.left = new Node(element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.leftTreeSize++;\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.right != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0insert(node.right, element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0node.right = new Node(element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n\u00a0\u00a0/* return rank of 'element' */\n\u00a0\u00a0public int getRank(int element) {\n\u00a0\u00a0\u00a0\u00a0return getRank(root, element);\n\u00a0\u00a0}\n\u00a0\u00a0private int getRank(Node node, int element) {\n\u00a0\u00a0\u00a0\u00a0if (element == node.element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node.leftTreeSize;\n\u00a0\u00a0\u00a0\u00a0} else if (element < node.element) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (node.left == null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return getRank(node.left, element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0int rightTreeRank = node.right == null \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0? -1 : getRank(node.right, element);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (rightTreeRank == -1) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return -1;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return node.leftTreeSize + 1 + rightTreeRank;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```", "```java\npublic static void sort(int[] arr) {\n\u00a0\u00a0for (int i = 1; i < arr.length; i += 2) {\n\u00a0\u00a0\u00a0\u00a0int maxFoundIndex = maxElementIndex(arr, i - 1, i, i + 1);\n\u00a0\u00a0\u00a0\u00a0if (i != maxFoundIndex) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0swap(arr, i, maxFoundIndex);\n\u00a0\u00a0\u00a0\u00a0}\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0}\n}\nprivate static int maxElementIndex(int[] arr, \n int left, int middle, int right) {\n\u00a0\u00a0int arrLength = arr.length;\n\u00a0\u00a0int leftElement = left >= 0 && left < arrLength\n\u00a0\u00a0\u00a0\u00a0? arr[left] : Integer.MIN_VALUE;\n\u00a0\u00a0int middleElement = middle >= 0 && middle < arrLength\n\u00a0\u00a0\u00a0\u00a0? arr[middle] : Integer.MIN_VALUE;\n\u00a0\u00a0int rightElement = right >= 0 && right < arrLength\n\u00a0\u00a0\u00a0\u00a0? arr[right] : Integer.MIN_VALUE;\n\u00a0\u00a0int maxElement = Math.max(leftElement,\n\u00a0\u00a0\u00a0\u00a0Math.max(middleElement, rightElement));\n\u00a0\u00a0if (leftElement == maxElement) {\n\u00a0\u00a0\u00a0\u00a0return left;\n\u00a0\u00a0} else if (middleElement == maxElement) {\n\u00a0\u00a0\u00a0\u00a0return middle;\n\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0return right;\n\u00a0\u00a0}\n}\n```", "```java\npublic static void leftSmaller(int arr[]) {\n\u00a0\u00a0Stack<Integer> stack = new Stack<>();\n\u00a0\u00a0// While the top element of the stack is greater than \n\u00a0\u00a0// equal to arr[i] remove it from the stack\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0for (int i = 0; i < arr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0while (!stack.empty() && stack.peek() >= arr[i]) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stack.pop();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// if stack is empty there is no left smaller element\n\u00a0\u00a0\u00a0\u00a0if (stack.empty()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(\"_, \");\n\u00a0\u00a0\u00a0\u00a0} else {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the top of the stack is the left smaller element\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0System.out.print(stack.peek() + \", \");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// push arr[i] into the stack\n\u00a0\u00a0\u00a0\u00a0stack.push(arr[i]);\n\u00a0\u00a0}\n}\n```", "```java\nint[] firstArr = {4, 1, 8, 1, 3, 8, 6, 7, 4, 9, 8, 2, 5, 3};\nint[] secondArr = {7, 4, 8, 11, 2};\n```", "```java\npublic static void custom(int[] firstArr, int[] secondArr) {\n\u00a0\u00a0// store the frequency of each element of first array\n\u00a0\u00a0// using a TreeMap stores the data sorted\n\u00a0\u00a0Map<Integer, Integer> frequencyMap = new TreeMap<>();\n\u00a0\u00a0for (int i = 0; i < firstArr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0frequencyMap.putIfAbsent(firstArr[i], 0);\n\u00a0\u00a0\u00a0\u00a0frequencyMap.put(firstArr[i],\u00a0\u00a0 \n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frequencyMap.get(firstArr[i]) + 1);\n\u00a0\u00a0}\n\u00a0\u00a0// overwrite elements of first array\n\u00a0\u00a0int index = 0;\n\u00a0\u00a0for (int i = 0; i < secondArr.length; i++) {\n\u00a0\u00a0\u00a0\u00a0// if the current element is present in the 'frequencyMap'\n\u00a0\u00a0\u00a0\u00a0// then set it n times (n is the frequency of \n\u00a0\u00a0\u00a0\u00a0// that element in the first array)\n\u00a0\u00a0\u00a0\u00a0int n = frequencyMap.getOrDefault(secondArr[i], 0);\n\u00a0\u00a0\u00a0\u00a0while (n-- > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0firstArr[index++] = secondArr[i];\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0// remove the element from map\n\u00a0\u00a0\u00a0\u00a0frequencyMap.remove(secondArr[i]);\n\u00a0\u00a0}\n\u00a0\u00a0// copy the remaining elements (the elements that are\n\u00a0\u00a0// present in the first array but not present \n\u00a0\u00a0// in the second array)\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0for (Map.Entry<Integer, Integer> entry :\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0frequencyMap.entrySet()) {\n\u00a0\u00a0\u00a0\u00a0int count = entry.getValue();\n\u00a0\u00a0\u00a0\u00a0while (count-- > 0) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0firstArr[index++] = entry.getKey();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}\n}\n```"]