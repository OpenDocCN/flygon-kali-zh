- en: Prepare Angular App for Production Release
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产发布准备 Angular 应用
- en: If you don't ship it, it never happened. In the previous chapter, you created
    a local weather application that can retrieve current weather data. You have created
    some amount of value; however, if you don't put your app on the web, you end up
    creating zero value. Delivering something is difficult, delivering something to
    production is even more difficult. You want to follow a strategy that results
    in a reliable, high quality, and flexible release.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不发布它，它就从未发生过。在上一章中，您创建了一个可以检索当前天气数据的本地天气应用程序。您已经创造了一定的价值；然而，如果您不将应用程序放在 web
    上，最终将创造零价值。交付某物是困难的，将某物交付到生产环境中更加困难。您希望遵循一种能够产生可靠、高质量和灵活的发布的策略。
- en: The app we created in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml), *Create
    a Local Weather Web Application*, is fragile. We need to be able to deliver the
    frontend app separately from the backend app, which is a very important decoupling
    to retain the flexibility of being able to push separate app and server updates.
    In addition, decoupling will ensure that as the various tools and technologies
    in your application stack inevitably fall out of support or favor, you will be
    able to replace your frontend or backend without a full rewrite of your system.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第 9 章](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)中创建的应用，*创建一个本地天气 Web 应用程序*，是脆弱的。我们需要能够将前端应用程序与后端应用程序分开交付，这是保持能够推送独立的应用程序和服务器更新的灵活性的非常重要的解耦。此外，解耦将确保随着应用程序堆栈中的各种工具和技术不可避免地退出支持或受欢迎程度，您将能够替换前端或后端，而无需对系统进行全面重写。
- en: 'In this chapter, you will learn to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学会以下内容：
- en: Guard against null data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防范空数据
- en: Containerize the app using Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 将应用容器化
- en: Deploy the app on the web using Zeit Now
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Zeit Now 在 web 上部署应用
- en: 'Required software is as listed:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 所需软件如下：
- en: Docker Community Edition Version 17.12
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 社区版版本 17.12
- en: Zeit Now Account
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zeit Now 账户
- en: Null guarding in Angular
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Angular 中进行空值保护
- en: 'In JavaScript, the `undefined` and `null` values are a persistent issue that
    must be proactively dealt with every step of the way. There are multiple ways
    to guard against `null` values in Angular:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`undefined` 和 `null` 值是一个持久性问题，必须在每一步积极地处理。在 Angular 中，有多种方法可以防范
    `null` 值：
- en: Property Initialization
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 属性初始化
- en: Safe Navigation Operator `?.`
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安全导航操作符 `?.`
- en: Null Guarding with `*ngIf`
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `*ngIf` 进行空值保护
- en: Property initialization
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性初始化
- en: 'In statically-typed languages such as Java, it is drilled into you that proper
    variable initialization/instantiation is the key to error free operation. So let''s
    try that in `CurrentWeatherComponent` by initializing current with default values:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在诸如 Java 这样的静态类型语言中，正确的变量初始化/实例化是无错误操作的关键。因此，让我们在 `CurrentWeatherComponent`
    中尝试使用默认值初始化当前值：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The outcome of these changes will reduce console errors from 12 to 3, at which
    point you will only be seeing API call related errors. However, the app itself
    will not be in a presentable state, as you can see below:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改的结果将把控制台错误从 12 个减少到 3 个，此时您只会看到与 API 调用相关的错误。然而，应用本身将不会处于可呈现的状态，如下所示：
- en: '![](Images/1f84089f-b267-456c-880f-f229a904a8e2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/1f84089f-b267-456c-880f-f229a904a8e2.png)'
- en: Results of Property Initialization
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 属性初始化的结果
- en: To make this view presentable to user, we will have to code for default values
    on every property on the template. So by fixing the null guarding issue by initialization,
    we created a default value handling issue. Both the initialization and the default
    value handling are *O(n)* scale tasks for developers. At its best, this strategy
    will be annoying to implement and at its worst, highly ineffective and error prone,
    requiring, at minimum, *O(2n)* effort per property.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个视图对用户呈现，我们将不得不为模板上的每个属性编写默认值的代码。因此，通过初始化来解决空值保护问题，我们创建了一个默认值处理问题。对于开发人员来说，初始化和默认值处理都是*O(n)*规模的任务。在最好的情况下，这种策略将很烦人，并且在最坏的情况下，效果非常不佳且容易出错，每个属性至少需要*O(2n)*的工作量。
- en: Safe navigation operator
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全导航运算符
- en: 'Angular implements the safe navigation operation `?.` to prevent unintended
    traversals of undefined objects. So, instead of writing initialization code and
    having to deal with template values, let''s just update the template:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Angular实现了安全导航操作`?.`来防止对未定义对象的意外遍历。因此，我们不必编写初始化代码并处理模板值，只需更新模板即可：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This time, we didn''t have to make up defaults, and we let Angular deal with
    displaying undefined bindings. You will note that just like the initialization
    fix, the errors have been reduced from 12 to 3\. The app itself is in a somewhat
    better shape. There''s no more confusing data being displayed; however, it still
    is not in a presentable state, as shown below:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们不必制定默认值，让Angular处理显示未定义的绑定。您会注意到，就像初始化修复一样，错误已经从12个减少到3个。应用程序本身的状态略微好转。不再显示混乱的数据；但是，它仍然不处于一个可呈现的状态，如下所示：
- en: '![](Images/cf719932-a5c2-4a64-ba10-861ad126010e.png)Results of Safe Navigation
    Operator'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/cf719932-a5c2-4a64-ba10-861ad126010e.png)安全导航运算符的结果'
- en: You can probably imagine ways where the safe navigation operator can come in
    handy, in far more complicated scenarios. However, when deployed at scale, this
    type of coding still requires, at minimum, *O(n)* level of effort to implement.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能可以想象安全导航运算符在更复杂的情况下会有用。然而，当在规模上部署时，这种类型的编码仍然需要至少*O(n)*级别的工作量来实现。
- en: Null guarding with *ngIf
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用*ngIf进行空值保护
- en: The idea strategy will be to use `*ngIf`, which is a structural directive, meaning
    Angular will stop traversing DOM tree elements beyond a falsy statement.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的策略是使用`*ngIf`，这是一个结构指令，意味着Angular将停止遍历DOM树元素，超出一个假语句。
- en: 'In the `CurrentWeather` component, we can easily check to see whether the `current`
    variable is null or undefined before attempting to render the template:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CurrentWeather`组件中，我们可以在尝试渲染模板之前轻松检查`current`变量是否为null或未定义：
- en: 'Update the topmost `div` element with `*ngIf` to check whether `current` is
    an object, as shown:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新顶层的`div`元素，使用`*ngIf`来检查`current`是否是一个对象，如下所示：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now observe the console log and that no errors are being reported. You always
    ensure that your Angular application reports zero console errors. If you're still
    seeing errors in the console log, ensure that you have correctly reverted the
    `OpenWeather` URL to its correct state or kill and restart your `npm start` process.
    I highly recommend that you resolve any console errors before moving on. Once
    you've fixed all errors, ensure that you commit your code again.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在观察控制台日志，没有错误被报告。您始终要确保您的Angular应用程序报告零控制台错误。如果您仍然在控制台日志中看到错误，请确保您已正确恢复`OpenWeather`
    URL到其正确状态，或者终止并重新启动您的`npm start`进程。我强烈建议您在继续之前解决任何控制台错误。一旦您解决了所有错误，请确保再次提交您的代码。
- en: Commit your code.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交你的代码。
- en: Containerizing the app using Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker容器化应用程序
- en: 'Docker [docker.io](http://docker.io) is an *open platform* for developing,
    shipping, and running applications. Docker combines a *lightweight* container
    virtualization platform with workflows and tooling that help manage and deploy
    applications. The most obvious difference between **Virtual Machines** (**VMs**)
    and Docker containers are that VMs usually are dozens of gigabytes in size and
    require gigabytes of memory, whereas containers are megabytes in disk and memory
    size requirements. Furthermore, the Docker platform abstracts away host **operating
    system** (**OS**) level configuration settings, so every piece of configuration
    that is needed to successfully run an application is encoded within the human-readable
    Dockerfile format, as demonstrated here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker [docker.io](http://docker.io)是一个用于开发、部署和运行应用程序的*开放平台*。Docker将*轻量级*的容器虚拟化平台与工作流程和工具结合起来，帮助管理和部署应用程序。**虚拟机**（**VMs**）和Docker容器之间最明显的区别是，VMs通常有数十GB的大小，并且需要GB级的内存，而容器的磁盘和内存大小要求只有MB级。此外，Docker平台抽象了主机**操作系统**（**OS**）级别的配置设置，因此成功运行应用程序所需的每一部分配置都被编码在可读的Dockerfile格式中，就像这里所演示的一样。
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding file describes a new container that inherits from a container
    named `duluca/minimal-node-web-server`, changes the working directory to `/usr/src/app`,
    and then copies the contents of `dist` folder from your development environment
    into the container's `public` folder. In this case, the parent image is configured
    with an Express.js server to act as a web server to serve the content inside the
    `public` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的文件描述了一个新的容器，它继承自一个名为`duluca/minimal-node-web-server`的容器，将工作目录更改为`/usr/src/app`，然后将开发环境中`dist`文件夹的内容复制到容器的`public`文件夹中。在这种情况下，父级镜像配置了一个Express.js服务器，用作Web服务器，以提供`public`文件夹中的内容。
- en: 'Refer to the following diagram for a visual representation of what''s happening:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考以下图表，以直观地了解发生了什么：
- en: '![](Images/e85a11d3-ea47-4e80-804d-ae9267b23407.jpg)Context of a Docker Image'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/e85a11d3-ea47-4e80-804d-ae9267b23407.jpg)Docker镜像的上下文'
- en: At the base layer is our host OS, such as Windows or macOS that runs the Docker
    runtime, which will be installed in the next section. The Docker runtime is capable
    of running self-contained Docker images, which is defined by the aforementioned
    `Dockerfile`. `duluca/minimal-node-web-server` is based off of the lightweight
    Linux operating system Alpine. Alpine is a completely pared down version of Linux
    that doesn't come with any GUI, drivers or even most CLI tools you may expect
    from a Linux system. As a result, the OS is around only ~5 MB in size. The base
    package then installs Node.js, which itself is around ~10 MB in size and my custom
    Node.js-based Express.js web server, resulting in a tiny ~15 MB image. The Express
    server is configured to serve the contents of the `/usr/src/app` folder. In the
    preceding `Dockerfile`, we merely copy the contents of the `/dist` folder in our
    development environment and place it into the `/usr/src/app` folder. We will later
    build and execute this image, which will run our Express web server containing
    the output of our `dist` folder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 基础层是我们的主机操作系统，例如运行Docker运行时的Windows或macOS，这将在下一节中安装。Docker运行时能够运行自包含的Docker镜像，这是由上述的`Dockerfile`定义的。`duluca/minimal-node-web-server`基于轻量级的Linux操作系统Alpine。Alpine是Linux的一个完全精简版本，不带有任何图形界面、驱动程序，甚至大多数你可能期望从Linux系统中得到的CLI工具。因此，该操作系统的大小只有约5MB。基础软件包然后安装了Node.js，Node.js本身的大小约为10MB，以及我的自定义基于Node.js的Express.js
    Web服务器，结果是一个微小的约15MB的镜像。Express服务器被配置为提供`/usr/src/app`文件夹中的内容。在前述的`Dockerfile`中，我们只是将开发环境中`/dist`文件夹的内容复制并放置到`/usr/src/app`文件夹中。我们稍后将构建并执行这个镜像，这将运行我们的Express
    Web服务器，其中包含我们`dist`文件夹的输出。
- en: The beauty of Docker is that you can navigate to [https://hub.docker.com](https://hub.docker.com),
    search for `duluca/minimal-node-web-server`, read its `Dockerfile`, and trace
    its origins all the way back to the original base image that is the foundation
    of the web server. I encourage you to vet every Docker image you use in this manner
    to understand what exactly it brings to the table for your needs. You may find
    it either overkill or has features you never knew about that can make your life
    a lot easier. Note that the parent images require a specific version of `duluca/minimal-node-web-server` at `8.11.1`.
    This is quite intentional, and as the reader, you should choose the latest available
    version of a Docker image you find. However, if you don't specify a version number,
    you will always get the latest version of the image. As more versions of an image
    is published, you may pull a future version that may break your application. For
    this reason, always specify a version number for images you're depending on.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的美妙之处在于你可以转到[https://hub.docker.com](https://hub.docker.com)，搜索`duluca/minimal-node-web-server`，阅读它的`Dockerfile`，并追溯到它的起源，一直回溯到web服务器的原始基础镜像。我鼓励你以这种方式审查你使用的每个Docker镜像，以了解它对你的需求到底带来了什么。你可能会发现它要么过于复杂，要么有你以前不知道的功能，可以让你的生活变得更加轻松。请注意，父镜像需要特定版本的`duluca/minimal-node-web-server`，为`8.11.1`。这是非常有意义的，作为读者，你应该选择你找到的Docker镜像的最新可用版本。但是，如果你不指定版本号，你将始终获得镜像的最新版本。随着镜像的发布更多版本，你可能会拉取一个未来版本，可能会破坏你的应用程序。因此，对于你依赖的镜像，始终指定版本号。
- en: 'One such case is the HTTPS redirection support that is baked into `duluca/minimal-node-web-server`.
    You can spend countless hours trying to set up a nginx proxy to do the same thing,
    when all you need to do is add the following line to your Dockerfile:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的例子是内置到`duluca/minimal-node-web-server`中的HTTPS重定向支持。你可以花费无数个小时来尝试设置一个nginx代理来做同样的事情，当你只需要在你的Dockerfile中添加以下一行：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Just like npm packages, Docker can bring great convenience and value, but you
    must take care to understand the tools you are working with.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 就像npm包一样，Docker可以带来很大的便利和价值，但你必须小心地理解你正在使用的工具。
- en: In [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS,* we mention the use of a lower footprint docker image
    based on Nginx. If you're comfortable configuring `nginx`, you can use `duluca/minimal-nginx-web-server`
    as your base image.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第16章](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml)，*在AWS上构建高可用云基础设施*，我们提到了基于Nginx的低占用docker镜像的使用。如果你熟悉配置`nginx`，你可以使用`duluca/minimal-nginx-web-server`作为你的基础镜像。
- en: Installing Docker
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Docker
- en: In order to be able to build and run containers, you must first install the
    Docker execution environment on your computer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够构建和运行容器，你必须首先在你的计算机上安装Docker执行环境。
- en: Windows support of Docker can be challenging. You must have a PC with a CPU
    that supports virtualization extensions, which is not a guarantee on laptops.
    You must also have a Pro version of Windows with Hyper-V enabled. On the flip
    side, Windows Server 2016 has native support for Docker, which is an unprecedented
    amount of support shown by Microsoft toward the industry initiative to adopt Docker
    and containerization.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Windows对Docker的支持可能会有挑战。你必须拥有一台支持虚拟化扩展的CPU的PC，这在笔记本电脑上并不是一定会有的。你还必须拥有启用了Hyper-V的Windows专业版。另一方面，Windows
    Server 2016原生支持Docker，这是微软向行业采用Docker和容器化倡议所表现出的前所未有的支持。
- en: 'Install Docker by executing the following command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令安装Docker：
- en: 'For Windows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For macOS:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Execute `docker -v` to verify the installation.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker -v`来验证安装。
- en: Setting up Docker scripts
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker脚本
- en: 'Now, let''s configure some Docker scripts that you can use to automated the
    building, testing, and publishing of your container. I have developed a set of
    scripts called **npm Scripts for Docker** that work on Windows 10 and macOS. You
    can get the latest version of these scripts at [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置一些Docker脚本，您可以使用这些脚本来自动构建、测试和发布您的容器。我开发了一组名为**npm Scripts for Docker**的脚本，适用于Windows
    10和macOS。您可以在[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)获取这些脚本的最新版本：
- en: Sign up for a Docker Hub account on [https://hub.docker.com/](https://hub.docker.com/)
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://hub.docker.com/](https://hub.docker.com/)上注册Docker Hub帐户
- en: Create a public (free) repository for your application
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的应用程序创建一个公共（免费）存储库
- en: Unfortunately, at the time of publication, Zeit doesn't support private Docker
    Hub repositories, so your only alternative is to publish your container publicly.
    If your image must remain private, I encourage you to set up an AWS ECS environment
    as described in [Chapter 16](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml), *Highly-Available
    Cloud Infrastructure on AWS*. You can keep tabs on the issue by visiting Zeit
    Now's documentation at [zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在发布时，Zeit不支持私有Docker Hub存储库，因此您的唯一选择是公开发布您的容器。如果您的图像必须保持私有，我建议您按照[第16章](7ccc1261-21e7-44b9-aaf8-0079360288e7.xhtml)中描述的在AWS
    ECS环境中设置的方法进行操作，*在AWS上构建高可用云基础设施*。您可以通过访问Zeit Now的文档[zeit.co/docs/deployment-types/docker](https://zeit.co/docs/deployment-types/docker)来了解问题的最新情况。
- en: 'Update `package.json` to add a new config property with the following configuration
    properties:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`package.json`以添加一个新的配置属性，具有以下配置属性：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The namespace will be your DockerHub username. You will be defining what your
    repository is called during creation. An example image repository variable should
    look like `duluca/localcast-weather`. The image name is for easy identification
    of your container, while using Docker commands such as `docker ps`. I will call
    mine just `localcast-weather`. The port will define which port should be used
    to expose your application from inside the container. Since we use `5000` for
    development, pick a different one, like `8080`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间将是您的DockerHub用户名。您将在创建过程中定义您的存储库的名称。示例图像存储库变量应如`duluca/localcast-weather`。图像名称用于轻松识别您的容器，同时使用Docker命令，如`docker
    ps`。我将只称之为`localcast-weather`。端口将定义应从容器内部使用哪个端口来公开应用程序。由于我们在开发中使用`5000`，请选择一个不同的端口，如`8080`。
- en: Add Docker scripts to `package.json` by copy-pasting the scripts from [bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker).
    Here's an annotated version of the scripts that explains each function.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从[bit.ly/npmScriptsForDocker](http://bit.ly/npmScriptsForDocker)复制粘贴脚本将Docker脚本添加到`package.json`。以下是脚本的注释版本，解释了每个功能。
- en: 'Note that with npm scripts, the `pre` and `post` keywords are used to execute
    helper scripts, respectively, before or after the execution of a given script
    and scripts are intentionally broken into smaller pieces to make it easier to
    read and maintain them:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用npm脚本时，`pre`和`post`关键字分别用于在执行给定脚本之前或之后执行辅助脚本，并且脚本被故意分成较小的部分，以使其更易于阅读和维护：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`npm run docker:build` will build your Angular application in `pre`, then build
    the Docker image using the `docker image build` command and tag the image with
    a version number in post:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:build`将在`pre`中构建您的Angular应用程序，然后使用`docker image build`命令构建Docker镜像，并在`post`中为图像打上版本号：'
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`npm run docker:tag` will tag an already built Docker image using the version
    number from the `version` property in `package.json` and the `latest` tag:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`npm run docker:tag`将使用`package.json`中`version`属性的版本号和`latest`标签标记已构建的Docker镜像：'
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`npm run docker:run` will remove any existing, prior version of an image and
    run the already built image using the `docker run` command. Note that the `imagePort`
    property is used as the external port of the Docker image, which is mapped to
    the internal port of the image that the Node.js server listens to, port `3000`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:run`将删除任何现有的旧版本镜像，并使用`docker run`命令运行已构建的镜像。请注意，`imagePort`属性用作Docker镜像的外部端口，该端口映射到Node.js服务器监听的镜像的内部端口，即端口`3000`：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`npm run docker:publish` will publish a built image to the configured repository,
    in this case, Docker Hub, using the `docker image push` command. First, the versioned
    image is published, followed by one tagged with `latest` in post:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:publish`将使用`docker image push`命令将构建的镜像发布到配置的存储库，此处为Docker
    Hub。首先发布带版本号的镜像，然后发布一个带有`latest`标签的镜像：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`npm run docker:clean` will remove a previously built version of the image
    from your system, using the `docker rm -f` command:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:clean`将使用`docker rm -f`命令从系统中删除先前构建的镜像的版本：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`npm run docker:taillogs` will display the internal console logs of a running
    Docker instance using the `docker log -f` command, a very useful tool when debugging
    your Docker instance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:taillogs`将使用`docker log -f`命令显示正在运行的Docker实例的内部控制台日志，这是调试Docker实例时非常有用的工具：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`npm run docker:open:win` or `npm run docker:open:mac` will wait for 2 seconds
    and then launch the browser with the correct URL to your application using the
    `imagePort` property:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:open:win`或`npm run docker:open:mac`将等待2秒，然后使用`imagePort`属性启动浏览器，打开应用程序的正确URL：
- en: '[PRE15]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`npm run docker:debug` will build your image and run an instance of it in `pre`,
    open the browser, and then start displaying the internal logs of the container.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`npm run docker:debug`将构建您的镜像并在`pre`中运行一个实例，打开浏览器，然后开始显示容器的内部日志。
- en: 'Install two development dependencies that are needed to ensure cross-platform
    functionality of the scripts:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装两个开发依赖项，以确保脚本的跨平台功能性：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Customize the pre-build script to execute unit and e2e tests before building
    the image:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自定义预构建脚本以在构建镜像之前执行单元测试和e2e测试：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Note that `npm run build` is provided the `--prod` argument, which achieves
    two things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`npm run build`提供了`--prod`参数，可以实现两个目标：
- en: 1\. Development time payload of ~2.5 MB is optimized down to ~73kb or less
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 将开发时的大约2.5 MB有效载荷优化为大约73kb或更少
- en: 2\. The configuration items defined in `src/environments/environment.prod.ts`
    is used at runtime
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 在运行时使用`src/environments/environment.prod.ts`中定义的配置项
- en: 'Update `src/environments/environment.prod.ts` to look like using your own `appId`
    from `OpenWeather`:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`src/environments/environment.prod.ts`，以便使用您自己的`OpenWeather`的`appId`：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We are modifying how `npm test` is executed, so the tests are run only once
    and the tool stops executing. The `--watch=false` option is provided to achieve
    this behavior, as opposed to the development-friendly default continuous execution
    behavior. In addition `npm run build` is provided with `--output-path dist` to
    ensure that `index.html` is published at the root of the folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在修改`npm test`的执行方式，以便测试只运行一次，工具停止执行。提供`--watch=false`选项以实现此行为，与默认的持续执行行为相反，这是开发友好的。此外，为了确保`index.html`发布在文件夹的根目录，为`npm
    run build`提供了`--output-path dist`。
- en: Create a new file named `Dockerfile` with no file-extensions
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dockerfile`的新文件，没有文件扩展名
- en: 'Implement the `Dockerfile`, as shown:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`Dockerfile`，如下所示：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Be sure to inspect the contents of your `dist` folder. Ensure that `index.html`
    is at the root of `dist`. Otherwise ensure that your `Dockerfile` copies the folder
    that has `index.html` at its root.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保检查`dist`文件夹的内容。确保`index.html`位于`dist`的根目录。否则，请确保您的`Dockerfile`复制了具有`index.html`的文件夹，使其位于其根目录。
- en: Execute `npm run predocker:build` to ensure that your application changes have
    been successful
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run predocker:build`以确保您的应用程序更改已成功
- en: Execute `npm run docker:build` to ensure that your image builds successfully
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`npm run docker:build`以确保您的镜像构建成功
- en: 'While you can run any of the provided scripts individually, you really only
    need to remember two of them going forward:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以单独运行提供的任何脚本，但在以后，您实际上只需要记住其中的两个：
- en: '**npm run docker:debug **will test, build, tag, run, tail and launch your containerize
    app in a new browser window for testing'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:debug**将在新的浏览器窗口中测试、构建、标记、运行、跟踪和启动您的容器化应用程序进行测试'
- en: '**npm run docker:publish **will publish the image you just built and test to
    the online Docker repository'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm run docker:publish**将发布您刚刚构建和测试的镜像到在线Docker仓库'
- en: 'Execute `docker:debug` in your terminal:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`docker:debug`：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will note that the scripts display errors in the Terminal window. These
    are not necessarily indicators of a failure. The scripts are not polished, so
    they attempt both Windows and macOS compatible scripts parallelly, and during
    a first build, the clean command fails, because there's nothing to clean. By the
    time you read this, I may have published better scripts; if not, you're more than
    welcome to submit a pull request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到脚本在终端窗口中显示错误。这些并不一定是失败的指标。脚本并不完善，因此它们会同时尝试Windows和macOS兼容的脚本，并且在第一次构建时，清理命令会失败，因为没有需要清理的内容。在您阅读此文时，我可能已经发布了更好的脚本；如果没有，您可以随时提交拉取请求。
- en: 'A successful `docker:debug` run should result in a new in-focus browser window
    with your application and the server logs being tailed in the terminal, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 成功的`docker:debug`运行应该会在一个新的焦点浏览器窗口中显示您的应用程序和服务器日志在终端中被跟踪，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You should always run `docker ps` to check whether your image is running, when
    it was last updated, or if it is clashing with the existing images claiming the
    same port.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该始终运行`docker ps`来检查您的镜像是否正在运行，上次更新时间，或者它是否与声称使用相同端口的现有镜像发生冲突。
- en: 'Execute `docker:publish` in your terminal:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中执行`docker:publish`：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You should observe a successful run in the Terminal window like this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在终端窗口中观察到成功运行，如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Over time, your local Docker cache may grow to a significant size, that is,
    on my laptop, roughly 40 GB over two years. You can use the `docker image prune`
    and `docker container prune` commands to reduce the size of your cache. For more
    detailed information, refer to the documentation at [https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，您的本地Docker缓存可能会增长到相当大的规模，在我的笔记本电脑上，大约两年时间增长了大约40GB。您可以使用`docker image
    prune`和`docker container prune`命令来减小缓存的大小。有关更详细的信息，请参阅[https://docs.docker.com/config/pruning](https://docs.docker.com/config/pruning)上的文档。
- en: Let's look into an easier way to interact with Docker next.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一种更简单的与Docker交互的方式。
- en: Docker extension in VS Code
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code中的Docker扩展
- en: 'Another way to interact with Docker images and containers is through VS Code.
    If you have installed the `PeterJausovec.vscode-docker` Docker extension, as suggested
    in [Chapter 9](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)*, Create a Local Weather
    Web Application*, you will see an expandable title named DOCKER in the Explorer
    pane of VS Code, as pointed out with an arrow in the following screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通过VS Code还可以与Docker镜像和容器进行交互。如果您已经安装了`PeterJausovec.vscode-docker` Docker扩展，就像[第9章](7c897af2-bc94-4c2f-a5ad-8ae0b4bc0508.xhtml)*创建本地天气Web应用程序*中建议的那样，您将在VS
    Code的资源管理器窗格中看到一个名为DOCKER的可展开标题，如下截图中的箭头所示：
- en: '![](Images/40d5e5e1-2f87-4b8e-af8a-fccc3466b3c1.png)Docker extension in VS
    Code'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/40d5e5e1-2f87-4b8e-af8a-fccc3466b3c1.png)VS Code中的Docker扩展'
- en: 'Let''s go through some of the functionality provided by the extension:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下扩展提供的一些功能：
- en: '**Images** contains a list of all the container snapshots that exist on your
    system'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**图像**包含系统上存在的所有容器快照的列表'
- en: Right-clicking on a Docker image brings up a context menu to run various operations
    on it, like run, push and tag
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 Docker 图像会弹出一个上下文菜单，以在其上运行各种操作，如运行、推送和标记
- en: '**Containers** list all executable Docker containers that exist on your system,
    which you start, stop or attach to'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**容器**列出了系统上存在的所有可执行 Docker 容器，您可以启动、停止或附加到它们'
- en: '**Registries** display the registries that you''re configured to connect to,
    like DockerHub or AWS Elastic Container Registry'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**注册表**显示您配置连接的注册表，如DockerHub或AWS Elastic Container Registry'
- en: While the extension makes it easier to interact with Docker, **npm Scripts for
    Docker** automate a lot of the chores related to building, tagging and testing
    and image. They are cross-platform and will work equally well in a continuous
    integration environment.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然该扩展使与 Docker 交互变得更加容易，**用于 Docker 的 npm 脚本**自动化了与构建、标记和测试图像相关的许多琐事。它们是跨平台的，并且在持续集成环境中同样有效。
- en: You may find it confusing to interact with npm scripts in general through the
    CLI. Let's look at VS Code's npm script support next.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 CLI 与 npm 脚本进行交互可能会让您感到困惑。让我们接下来看一下 VS Code 的 npm 脚本支持。
- en: NPM Scripts in VS Code
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VS Code 中的 NPM 脚本
- en: 'VS Code provides support for npm scripts out of the box. In order to enable
    npm script explorer, open VS Code settings and ensure that the `"npm.enableScriptExplorer":
    true` property is present. Once you do, you will see an expandable title named NPM
    SCRIPTS in the Explorer pane, as pointed out with an arrow here:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'VS Code 提供了对 npm 脚本的支持。为了启用 npm 脚本资源管理器，打开 VS Code 设置并确保存在`"npm.enableScriptExplorer":
    true`属性。一旦您这样做，您将在资源管理器窗格中看到一个可展开的标题名为 NPM SCRIPTS，如此处所指出的箭头：'
- en: '![](Images/86f456ab-00f5-4eed-aff6-74117f03454c.png)NPM Scripts in VS Code'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![](Images/86f456ab-00f5-4eed-aff6-74117f03454c.png)VS Code 中的 NPM 脚本'
- en: You can click on any script to launch the line that contains the script in `package.json`
    or right-click and select Run to execute the script.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以单击任何脚本以启动包含脚本的行`package.json`，或右键单击并选择运行以执行脚本。
- en: Deploying containerized app
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署容器化应用
- en: If delivering something to production is difficult from a coding perspective,
    it is extremely difficult to do it right from an infrastructure perspective. In
    the later chapters, I will cover how to provision a world-class AWS **Elastic
    Container Service** (**ECS**) infrastructure for your applications, but that won't
    help if you need to quickly demonstrate an idea. Enter, Zeit Now.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从编码角度交付产品很困难，那么从基础架构角度做正确就更加困难。在后面的章节中，我将介绍如何为您的应用程序配置世界级的 AWS **弹性容器服务**（**ECS**）基础架构，但如果您需要快速展示一个想法，这是没有帮助的。这时，就需要
    Zeit Now。
- en: Zeit Now
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zeit Now
- en: Zeit Now, [https://zeit.co/now](https://zeit.co/now), is a multi-cloud service
    that enables real-time global deployments of applications directly from the CLI.
    Now works with applications that either correctly implement `package.json` or
    a `Dockerfile`. Even though we have done both, we will prefer to deploy our Docker
    image, because a lot more magic is applied behind the scenes to make a `package.json`
    deployment work, whereas your Docker image can be deployed anywhere, including
    AWS ECS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Zeit Now，[https://zeit.co/now](https://zeit.co/now)，是一个多云服务，可以直接从 CLI 实现应用程序的实时全球部署。Now
    适用于正确实现`package.json`或`Dockerfile`的应用程序。尽管我们两者都做了，但我们更喜欢部署我们的 Docker 图像，因为在幕后会应用更多的魔法来使`package.json`部署工作，而您的
    Docker 图像可以部署到任何地方，包括 AWS ECS。
- en: Configuring the Now CLI tool
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Now CLI 工具
- en: 'Now, let''s configure Zeit Now to work on your repository:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们配置 Zeit Now 来在您的存储库上工作：
- en: Install Zeit Now by executing `npm i -g now`
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `npm i -g now` 安装 Zeit Now
- en: Ensure correct installation by executing `now -v`
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行 `now -v` 确保正确安装
- en: Create a new folder under `local-weather-app` called `now`
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local-weather-app`下创建一个名为`now`的新文件夹
- en: Create a new `Dockerfile` under the new `now` folder
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的`now`文件夹下创建一个新的`Dockerfile`
- en: 'Implement the file to pull from the image you just published:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现从您刚刚发布的图像中提取文件：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, execute the `now` command in your terminal and follow the instructions
    to the finish configuration:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在终端中执行`now`命令，并按照说明完成配置：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Deploying
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署中
- en: 'Deploying on Zeit Now is very easy:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Zeit Now上部署非常容易：
- en: 'Change your working directory to `now` and execute the command:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的工作目录更改为`now`，并执行命令：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the Terminal window, the tool will report its progress and the URL from
    which you can access your now published app:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，该工具将报告其进度和您可以访问您现在发布的应用程序的URL：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Navigate to the URL listed on the second line and verify the publication of
    your app.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到第二行列出的URL，并验证您的应用程序的发布。
- en: Note that if you've made a configuration error along the way, your browser may
    display an error saying This page is trying to load unsafe scripts, allow and
    reload to see your app.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您在过程中出现配置错误，您的浏览器可能会显示一个错误，指出“此页面正在尝试加载不安全的脚本，请允许并重新加载以查看您的应用程序”。
- en: You can explore Zeit Now's paid features, which allow for advanced features
    such as automated scaling for your application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以探索Zeit Now的付费功能，这些功能允许您的应用程序进行高级功能，例如自动扩展。
- en: Congratulations, you are app is live on the internet!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，您的应用程序已经在互联网上上线！
- en: Summary
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to best avoid Angular console errors by guarding
    against null data. You configured your system to work with Docker and successfully
    containerized your web application with its own dedicated web server. You configured
    your project with npm scripts for Docker that can be leveraged by any team member.
    Finally, you have successfully delivered a web application in the cloud.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何通过防范空数据来最好地避免Angular控制台错误。您配置了系统以便与Docker一起工作，并成功地为您的Web应用程序容器化了自己的专用Web服务器。您为Docker配置了npm脚本，可以被任何团队成员利用。最后，您成功地在云中交付了一个Web应用程序。
- en: Now you know what takes to build a production-ready Angular application that
    is reliable, resilient, and containerized to allow for a flexible deployment strategy.
    In the next chapter, we will improve the apps feature set and make it look great
    using Angular Material.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何构建一个可靠、有弹性并且容器化的、以便灵活部署的生产就绪的Angular应用程序。在下一章中，我们将改进应用程序的功能集，并使用Angular
    Material使其看起来更加出色。
