- en: A React Bootstrap Personal Contacts Manager
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个React Bootstrap个人联系人管理器
- en: In this chapter, we are going to learn how to build a personal contacts manager
    using React, which is a library for building **user interfaces** (**UIs**) out
    of small components. By learning React, you will gain the ability to use one of
    the most popular libraries currently in use, as well as begin to understand how
    and when to use the power of binding to simplify your code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用React构建个人联系人管理器，它是一个用于构建**用户界面**（**UI**）的小组件库。通过学习React，您将获得使用当前最流行的库之一的能力，并开始了解何时以及如何使用绑定的力量来简化您的代码。
- en: Exploring React will help us to understand how to write a modern application
    for the client side and also study its requirements.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 探索React将帮助我们了解如何为客户端编写现代应用程序，并研究其要求。
- en: 'To help us to develop the application, the following topics will be covered
    in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们开发应用程序，本章将涵盖以下主题：
- en: Creating a mock layout to check our layouts
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模拟布局来检查我们的布局
- en: Creating our React application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建我们的React应用程序
- en: Analyzing and formatting code with `tslint`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`tslint`分析和格式化代码
- en: Adding Bootstrap support
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加Bootstrap支持
- en: Using tsx components in React
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React中使用tsx组件
- en: The `App` component in React
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React中的`App`组件
- en: Displaying our personal details UI
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示我们的个人详细信息UI
- en: Using binding to simplify our updates
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用绑定简化我们的更新
- en: Creating validators and applying them as validation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建验证器并将它们应用为验证
- en: Applying validation in a React component
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在React组件中应用验证
- en: Creating and sending data to an IndexedDB database
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建并将数据发送到IndexedDB数据库
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As we are using an IndexedDB database to store data, a modern web browser such
    as Chrome (version 11 or later) or Firefox (version 4 or later) will be required.
    The finished project can be downloaded from [https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03).
    After downloading the project, you will have to install the package requirements
    using `npm install`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用IndexedDB数据库来存储数据，将需要一个现代的网络浏览器，如Chrome（11版或更高版本）或Firefox（4版或更高版本）。完成的项目可以从[https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03](https://github.com/PacktPublishing/Advanced-TypeScript-3-Programming-Projects/tree/master/chapter03)下载。下载项目后，您将需要使用`npm
    install`安装软件包要求。
- en: Understanding the project overview
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解项目概述
- en: 'We are going to build a personal contacts manager database using React. The
    data is stored locally on the client using the standard IndexedDB database. When
    we have finished, our application will look like the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用React构建一个个人联系人管理器数据库。数据存储在客户端上，使用标准的IndexedDB数据库。完成后，我们的应用程序将如下所示：
- en: '![](assets/d5353a60-f978-4180-bf0b-a86ad7ce205c.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d5353a60-f978-4180-bf0b-a86ad7ce205c.png)'
- en: You should be able to complete the steps in this chapter, working alongside
    the code in the GitHub repository, in approximately two hours.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该能够在本章中完成这些步骤，与GitHub存储库中的代码一起工作，大约需要两个小时。
- en: Getting started with the components
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用组件
- en: 'This chapter relies on Node.js, which is available at [https://nodejs.org/](https://nodejs.org/).
    As we progress through the chapter, we will install the following components:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于Node.js，可在[https://nodejs.org/](https://nodejs.org/)上获得。随着我们在本章中的进展，我们将安装以下组件：
- en: '`@types/bootstrap` (4.1.2 or later)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/bootstrap`（4.1.2或更高版本）'
- en: '`@types/reactstrap` (6.4.3 or later)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@types/reactstrap`（6.4.3或更高版本）'
- en: '`bootstrap` (4.1.3 or later)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bootstrap`（4.1.3或更高版本）'
- en: '`react` (16.6.3 or later)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react`（16.6.3或更高版本）'
- en: '`react-dom` (16.6.3 or later)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-dom`（16.6.3或更高版本）'
- en: '`react-script-ts` (3.1.0 or later)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-script-ts`（3.1.0或更高版本）'
- en: '`reactstrap` (6.5.0 or later)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reactstrap`（6.5.0或更高版本）'
- en: '`create-react-app` (2.1.2 or later)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create-react-app`（2.1.2或更高版本）'
- en: Creating a React Bootstrap project with TypeScript support
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个带有TypeScript支持的React Bootstrap项目
- en: 'As we discussed in [Chapter 2](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml),
    *Creating a Markdown Editor with TypeScript,* it is a good idea to start off by
    gathering the requirements of the application that we are going to write. Here are
    the requirements for this chapter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](3593e33f-7490-47b6-b129-ab5e08aef1b0.xhtml)中讨论的*使用TypeScript创建Markdown编辑器*，最好的方法是首先收集我们将要编写的应用程序的需求。以下是本章的要求：
- en: The user will be able to create new details of a person or edit them
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够创建一个人的新详细信息或编辑它们
- en: These details will be saved to a client-side database
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些详细信息将保存到客户端数据库
- en: The user will be able to load the list of all people
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够加载所有人的列表
- en: The user will be able to delete the personal details of a person
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将能够删除一个人的个人详细信息
- en: The personal details will consist of the first and last names, the address (made
    up of two address lines, the town, the county, and the zip code), the phone number,
    and the date of birth
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人详细信息将包括名字和姓氏、地址（由两个地址行、城镇、县和邮政编码组成）、电话号码和出生日期。
- en: The personal details will be saved to the database
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 个人详细信息将保存到数据库中
- en: The first name will be at least one character and the last name will be at least
    two characters
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名字至少为一个字符，姓氏至少为两个字符
- en: Address line 1, town, and county will be at least five characters
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址行1、城镇和县至少为五个字符
- en: The zip code will conform to the American standard for most zip codes
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮政编码将符合大多数邮政编码的美国标准
- en: The phone number will conform to the standard American phone format
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码将符合标准的美国电话格式
- en: The user can clear details with the click of a button
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可以通过点击按钮清除详细信息
- en: Creating our mock layout
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的模拟布局
- en: Once we have our requirements, it is normally a good idea to draw up some rough
    drafts of what we think the layout of our application should be. What we want
    to do is to create a layout that shows we are using a web browser layout in a
    sketch format. The reason we want it to look as though it is sketched is because
    of the way we interact with our clients. We want them to get an idea about the
    rough layout of our application without getting caught up in details such as exactly
    how wide a particular button is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了我们的要求，通常最好草拟一些我们认为应用程序布局应该是什么样的草图。我们想做的是创建一个布局，显示我们正在使用网页浏览器布局的草图格式。我们希望它看起来像是草绘的，因为我们与客户互动的方式。我们希望他们能够了解我们应用程序的大致布局，而不会陷入诸如特定按钮有多宽等细节中。
- en: 'What is particularly useful is the ability to use a tool such as [https://ninjamock.com](https://ninjamock.com)/
    to create a wireframe sketch of our interface. These sketches can be shared online
    with clients or other team members who can directly add comments. The following
    sketch diagram demonstrates what we want our interface to look like when we are
    finished:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 特别有用的是使用诸如[https://ninjamock.com](https://ninjamock.com)这样的工具来创建我们界面的线框草图。这些草图可以在线与客户或其他团队成员共享，并直接添加评论。以下草图示意了我们完成后希望我们的界面看起来的样子：
- en: '![](assets/22334fc2-a57c-47ec-88b6-7ea1a5f928cc.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/22334fc2-a57c-47ec-88b6-7ea1a5f928cc.png)'
- en: Creating our application
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的应用程序
- en: 'Before we can begin writing our code, we need to install React. While it is
    possible to create the infrastructure we need for React manually, most people
    use the `create-react-app` command to create a React application. We aren''t going
    to do this any differently, so we are also going to use the `create-react-app` command. React
    does not use TypeScript by default so we are going to add a little bit extra to
    the command we use to create our application to give us all the TypeScript capacity
    that we need. We use `create-react-app`, giving it the name of our application
    and an extra `scripts-version` parameter that hooks in TypeScript for us:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们需要安装React。虽然可以手动创建我们需要的React基础设施，但大多数人使用`create-react-app`命令来创建React应用程序。我们不会做任何不同的事情，所以我们也将使用`create-react-app`命令。React默认不使用TypeScript，因此我们将在用于创建应用程序的命令中添加一些额外的内容，以为我们提供所有需要的TypeScript功能。我们使用`create-react-app`，给它我们应用程序的名称和一个额外的`scripts-version`参数，为我们挂接TypeScript：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you have installed Node.js packages before, you may think that there is a
    mistake in the preceding command and that we should be using `npm` to install
    `create-react-app`. However, we are using `npx` in place of `npm` because `npx`
    is an enhanced version of the **Node Package Manager** (**NPM**). With `npx`,
    we missed out the need to run `npm install create-react-app` to install the `create-react-app`
    package before manually running `create-react-app` to start the process. The use
    of `npx` does help to speed up our development workflow.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前安装过Node.js包，您可能会认为在前面的命令中有一个错误，并且我们应该使用`npm`来安装`create-react-app`。但是，我们使用`npx`代替`npm`，因为`npx`是**Node
    Package Manager**（**NPM**）的增强版本。使用`npx`，我们省去了运行`npm install create-react-app`来安装`create-react-app`包，然后手动运行`create-react-app`来启动进程的步骤。使用`npx`确实有助于加快我们的开发工作流程。
- en: 'Once our application has been created, we open the `Chapter03` directory and
    run the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完我们的应用程序后，我们打开`Chapter03`目录并运行以下命令：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Assuming that we have a default browser set, it should be opened to `http://localhost:3000`,
    which is the default web page for this application. This will serve up a standard
    web page that just happens to contain a default React sample. What we are going
    to do now is edit the `public/index.html` file and set a title for it. We are
    going to set our title to `Advanced TypeScript - Personal Contacts Manager`. While
    the contents of this file appear to be sparse, they contain everything that we
    need on our HTML side, namely, a `div` element called `root`. This is the hook that
    our React code will hang off, as we will discuss later. We can live edit our application
    so that any changes we make will be compiled and served back to the browser automatically:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经设置了默认浏览器，它应该打开到`http://localhost:3000`，这是该应用程序的默认网页。这将提供一个包含默认React示例的标准网页。现在我们要做的是编辑`public/index.html`文件并为其设置一个标题。我们将把我们的标题设置为`Advanced
    TypeScript - Personal Contacts Manager`。虽然这个文件的内容看起来很少，但它包含了我们在HTML方面所需要的一切，即一个名为`root`的`div`元素。这是我们的React代码将依附的挂钩，我们稍后会讨论。我们可以实时编辑我们的应用程序，以便我们所做的任何更改都将被编译并自动返回到浏览器：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Formatting our code using tslint
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用tslint格式化我们的代码
- en: 'Once we have created our application, we are using something called `tslint`,
    which analyzes our code by looking for potential problems. Note that support for
    this was automatically added when we created our application. The `tslint` version
    that runs applies a very aggressive set of rules against which we check our code.
    I have gone with the full set of `tslint` rules in my code base; however, if you
    want to relax the rules a bit, you just need to change the `tslint.json` file
    to something like the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了我们的应用程序，我们使用了一个叫做`tslint`的东西，它通过查找潜在问题来分析我们的代码。请注意，当我们创建我们的应用程序时，对此的支持已经自动添加。运行的`tslint`版本应用了一套非常激进的规则，我们检查我们的代码是否符合这些规则。我在我的代码库中使用了完整的`tslint`规则集；但是，如果您想放松规则，只需将`tslint.json`文件更改为以下内容：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Adding Bootstrap support
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Bootstrap支持
- en: 'One of the things we need to do with our application is bring in support for
    Bootstrap. This is not something that is provided *out of the box* with React,
    so we need to add this capacity using other packages:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要做的一件事是引入对Bootstrap的支持。这不是React默认提供的功能，因此我们需要使用其他包添加这个功能：
- en: 'Install Bootstrap as follows:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Bootstrap如下：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With this in place, we are now free to use a React-ready Bootstrap component.
    We are going to use the `reactstrap` package because this package targets Bootstrap
    4 in a React-friendly fashion:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以自由地使用一个React-ready的Bootstrap组件。我们将使用`reactstrap`包，因为这个包以React友好的方式针对Bootstrap
    4：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`reactstrap` is not a TypeScript component, so we need to install the `DefinitelyTyped`
    definition for this and for Bootstrap:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`reactstrap`不是一个TypeScript组件，所以我们需要安装这个和Bootstrap的`DefinitelyTyped`定义：'
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this in place, we can now add the Bootstrap CSS files. To do this, we
    are going to update the `index.tsx` file by adding a reference to our locally
    installed Bootstrap CSS file, by adding the following `import` to the very top
    of the file:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以添加Bootstrap CSS文件。为了做到这一点，我们将通过在`index.tsx`文件中添加对我们本地安装的Bootstrap
    CSS文件的引用，添加以下`import`到文件的顶部：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we are using the local Bootstrap file for convenience. As we discussed
    in [Chapter 1](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml), *Advanced TypeScript
    Features,* we want to change this to use a CDN source for the production version
    of this application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用本地的Bootstrap文件是为了方便。正如我们在[第1章](56be9c18-a050-4794-bbd6-c51cd62f8f35.xhtml)中讨论的*高级TypeScript特性*，我们希望将其更改为在生产版本中使用CDN源。
- en: 'To tidy up, remove the following line from `src/index.tsx` and then remove
    the matching `.css` file from the disk:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了整理一下，从`src/index.tsx`中删除以下行，然后从磁盘中删除匹配的`.css`文件：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: React using tsx components
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React使用tsx组件
- en: One question that you might have right now is why does the index file have a
    different extension? That is, why is it `.tsx` and not `.ts`? To answer these
    questions, we have to change our mental image of the extension slightly and talk
    about why React uses `.jsx` files and not `.js` (the `.tsx` version is the TypeScript
    equivalent of `.jsx`).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能会问一个问题，为什么索引文件有不同的扩展名？也就是说，为什么是`.tsx`而不是`.ts`？要回答这些问题，我们必须稍微改变我们对扩展的心智形象，并谈谈为什么React使用`.jsx`文件而不是`.js`（`.tsx`版本是`.jsx`的TypeScript等价物）。
- en: These JSX files are extensions of JavaScript that get transpiled to JavaScript.
    If you were to try and run them *as is* in JavaScript, then you would get runtime
    errors if they contained any of these extensions. In traditional React, there
    is a transpilation phase that takes the JSX file and converts it to JavaScript
    by expanding out the code to standard JavaScript. Effectively, this is a form
    of the compilation phase that we get from TypeScript anyway. With TypeScript React,
    we get the same end result where the TSX file ultimately ends up as a JavaScript
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些JSX文件是JavaScript的扩展，会被转译成JavaScript。如果你试图在JavaScript中直接运行它们，那么如果它们包含任何这些扩展，你将会得到运行时错误。在传统的React中，有一个转译阶段，它会将JSX文件转换为JavaScript，通过将代码扩展为标准的JavaScript。实际上，这是一种我们从TypeScript中得到的编译阶段。使用TypeScript
    React，我们得到了相同的结果，TSX文件最终会成为JavaScript文件。
- en: 'So, the question now is why do we actually need these extensions? To answer
    this, we are going to analyze the `index.tsx` file. This is what the file looks
    like with our Bootstrap CSS file added:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，现在的问题是为什么我们实际上需要这些扩展？为了回答这个问题，我们将分析`index.tsx`文件。这是我们添加了Bootstrap CSS文件后文件的样子：
- en: '[PRE9]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `import` statements should be familiar to us by now and `registerServiceWorker`
    is the behavior that is added to the code to provide a faster production application
    by serving assets from a cache, rather than reloading them time and time again.
    One of the key tenets of React is that it should be as fast as possible and that's
    where `ReactDOM.render` comes in. If we read this piece of code, things should
    become clear. What it is doing is looking for the element marked as root in the
    HTML page we serve up—we saw this in the `index.html` file. The reason we use
    the `as HTMLElement` syntax here is that we want to let TypeScript know what type
    this is (this parameter either has to derive from an element or be null—yes, that
    does mean that underlying this is a union type).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句现在应该对我们来说很熟悉，`registerServiceWorker`是添加到代码中的行为，通过从缓存中提供资产，而不是一次又一次地重新加载它们，来提供更快的生产应用程序。React的一个关键原则是它应该尽可能快，这就是`ReactDOM.render`的作用所在。如果我们阅读这段代码，事情应该变得清晰。它正在寻找在我们提供的HTML页面中标记为根的元素——我们在`index.html`文件中看到了这一点。我们在这里使用`as
    HTMLElement`语法的原因是我们想让TypeScript知道这是什么类型（这个参数要么派生自一个元素，要么为空——是的，这意味着底层是一个联合类型）。'
- en: Now, the reason we need a special extension is because of the piece of code
    that says `<App />`. What we are doing here is inlining a piece of XML code into
    our statement. In this particular instance, we are telling our `render` method
    to render out a component called `App`, that has been defined in the `App.tsx` file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个特殊的扩展的原因是因为代码中有一个说`<App />`的部分。我们在这里所做的是将一段XML代码嵌入到我们的语句中。在这个特定的例子中，我们告诉我们的`render`方法渲染一个名为`App`的组件，这个组件在`App.tsx`文件中被定义。
- en: How React uses a virtual DOM to be more responsive
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React如何使用虚拟DOM来提高响应性
- en: I glossed over why the `render` method is used, so now is the time to address
    React's secret weapon, that is, the virtual **Document Object Model** (**DOM**).
    If you've been developing web applications for a while, you are probably aware
    of the DOM.  If you have never encountered this, the DOM is an entity that describes
    exactly what a web page will look like. Web browsers rely very heavily on the
    DOM, and, as it has grown organically over the years, it can be pretty unwieldy.
    There is only so much that browser manufacturers can do to try and speed up the
    DOM. If they want to be able to serve up old web pages, then they have to support
    the full DOM.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我略过了为什么使用`render`方法，现在是时候解释一下React的秘密武器，也就是虚拟**文档对象模型**（**DOM**）。如果你已经开发了一段时间的Web应用程序，你可能已经了解了DOM。如果你从未遇到过这个，DOM是一个描述网页将会是什么样子的实体。Web浏览器非常依赖DOM，并且随着多年的发展，它可能变得相当笨重。浏览器制造商只能尽力加快DOM的速度。如果他们想要能够提供旧的网页，那么他们必须支持完整的DOM。
- en: The virtual DOM is a light weight copy of the standard DOM. The reason it is
    lighter in weight is that it misses out a major feature of the standard DOM; that
    is, it doesn't have to render out to the screen. When React runs the `render`
    method, it traverses each `.tsx` (or `.jsx` in JavaScript) file and executes the
    rendering code there. It then compares this rendered code to a copy of the last
    render that was run to work out exactly what has changed. Only those changed elements
    are updated on the screen. This comparison stage is the reason we have to use
    a virtual DOM. It's much faster to tell what elements need updating using this
    approach, and only those elements that get changed need to be updated.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟DOM是标准DOM的轻量级副本。它之所以轻量级是因为它缺少标准DOM的一个重要特性；也就是说，它不必呈现到屏幕上。当React运行`render`方法时，它遍历每个`.tsx`（或JavaScript中的`.jsx`）文件并在那里执行渲染代码。然后将此渲染代码与上次运行的渲染的副本进行比较，以确定确切发生了什么变化。只有那些发生变化的元素才会在屏幕上更新。这个比较阶段是我们必须使用虚拟DOM的原因。使用这种方法更快地告诉哪些元素需要更新，只有那些发生变化的元素才需要更新。
- en: Our React App component
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的React App组件
- en: 'We have already touched on the use of components in React. By default, we will
    always have an `App` component. This is the component that will be rendered to
    the root element in our HTML. Our components derive from `React.Component`, so
    the start of our `App` component looks like the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到了React中组件的使用。默认情况下，我们将始终有一个`App`组件。这是将呈现到我们HTML根元素的组件。我们的组件源自`React.Component`，因此我们的`App`组件的开头看起来像下面这样：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Of course, our component requires a well-known method to trigger the rendering
    of the component. It will not come as much of a surprise to learn that the method
    is called `render`. As we are using Bootstrap to display our UI, we want to be
    rendering out a component that relates to our `Container` div. To do this, we
    are going to use a `Container` component from `reactstrap` (and introduce the
    core component that we are going to use to display our interface):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的组件需要一个常用的方法来触发组件的渲染。毫不奇怪，这个方法被称为`render`。由于我们正在使用Bootstrap来显示我们的UI，我们希望呈现一个与我们的`Container`
    div相关的组件。为此，我们将使用`reactstrap`中的`Container`组件（并引入我们将用于显示界面的核心组件）：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Displaying the personal details interface
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示个人详细信息界面
- en: 'We are going to create a class called `PersonalDetails`. This class is going
    to render out the core of our interface inside the `render` method. Again, we
    are using `reactstrap` to lay out the various parts of the interface. Before we
    break down the intricacies of what our `render` method does, let''s take a look
    at what this all looks like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为`PersonalDetails`的类。这个类将在`render`方法中呈现出我们界面的核心。同样，我们使用`reactstrap`来布置界面的各个部分。在我们分解`render`方法的复杂性之前，让我们先看看这一切是什么样子：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see, there''s a lot going on in this method; however, the vast majority
    of it is repeated code used to replicate the row and column Bootstrap elements.
    If we take a look at the layout for the `postcode` and `phoneNumber` elements,
    for instance, we can see that we are laying out two rows with two explicit columns
    in each. In Bootstrap terms, one of these `Col` elements is a large size of three
    and the other one is a large size of four (we will leave it to Bootstrap to factor
    in the empty column that remains):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这个方法中有很多事情要做；然而，其中绝大部分是重复的代码，用于复制行和列的Bootstrap元素。例如，如果我们看一下`postcode`和`phoneNumber`元素的布局，我们会发现我们正在布置两行，每行有两个显式的列。在Bootstrap术语中，其中一个`Col`元素是三个大尺寸，另一个是四个大尺寸（我们将留给Bootstrap来考虑剩下的空列）：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Looking at the label and input elements, we can see that there are two unfamiliar
    elements. Surely, the correct key in a label is `for` and we should use `class`
    to refer to a CSS class in our input? The reason we have replacement keys here
    is that `for` and `class` are JavaScript keywords. As React allows us to mix the
    code and markup language inside a render, React has to use different keywords.
    This means that we use `htmlFor` to replace `for` and `className` to replace `class`.
    Going back to when we talked about the virtual DOM, this gives us a major hint
    that these HTML elements are copies that serve a similar purpose, rather than
    the elements themselves.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 看着标签和输入元素，我们可以看到有两个不熟悉的元素。当然，在标签中正确的键是`for`，我们应该在输入中使用`class`来引用CSS类？我们在这里使用替代键的原因是`for`和`class`是JavaScript关键字。由于React允许我们在渲染中混合代码和标记语言，React必须使用不同的关键字。这意味着我们使用`htmlFor`来替换`for`，使用`className`来替换`class`。回到我们谈论虚拟DOM时，这给了我们一个重要的提示，即这些HTML元素是用于类似目的的副本，而不是元素本身。
- en: Simplify updating values with binding
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用绑定简化更新值
- en: One feature of many modern frameworks is the use of binding to remove the need
    to manually update inputs or trigger events. The idea behind using a binding is
    that the framework establishes a connection between a UI element and the code,
    such as a property, watches for changes to the underlying values, and then triggers
    updates when it detects a change. When done correctly, this removes a lot of drudgery
    from writing our code and, more importantly, helps to reduce errors.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代框架的一个特性是使用绑定来消除手动更新输入或触发事件的需要。使用绑定的想法是，框架在UI元素和代码之间建立连接，例如属性，监视基础值的变化，然后在检测到变化时触发更新。正确使用时，这可以减少我们编写代码的繁琐工作，更重要的是有助于减少错误。
- en: Supplying state to bind against
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提供要绑定的状态
- en: 'The idea behind binding with React is that we have a state that we need to
    bind to. In the case of creating data that we want to display on the screen, our
    state can be as simple as an interface describing the properties that we want
    to use. For a single contact, this translates to our state looking like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React进行绑定的想法是我们有一个需要绑定的状态。对于创建要在屏幕上显示的数据，我们的状态可以简单地是描述我们要使用的属性的接口。对于单个联系人，这将转化为我们的状态看起来像这样：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Note that we have created a union type called `StringOrNull` as a convenience.
    We will place this in a file called `Types.tsx` so that it looks like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们创建了一个名为`StringOrNull`的联合类型作为一种便利。我们将把它放在一个名为`Types.tsx`的文件中，使其看起来像这样：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'What we want to do now is tell our component what state it is going to use.
    The first thing to do is update our class definition so that it looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要做的是告诉我们的组件它将使用什么状态。首先要做的是更新我们的类定义，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This follows the convention where the properties are passed into our class from
    the parent and the state comes from our local component. This separation of properties
    and state is important to us because it provides us with a way for the parent
    to communicate with the component (and for the component to communicate back with
    the parent), while still being able to manage the data and behaviors that our
    component wants as the state.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了一个惯例，即属性从父级传递到我们的类中，而状态来自我们的本地组件。这种属性和状态的分离对我们很重要，因为它为父组件与子组件之间的通信提供了一种方式（以及子组件与父组件之间的回传），同时仍然能够管理组件作为状态所需的数据和行为。
- en: Here, our properties are defined in an interface called `IProps`. Now that we
    have told React what the *shape* of our state is going to be internally, React
    and TypeScript use this to create a `ReadOnly<IPersonState>` property. Therefore,
    it is important to ensure that we are using the right state. If we use the wrong
    type for our state, TypeScript will inform us of this.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的属性在一个名为`IProps`的接口中定义。现在我们已经告诉React我们的状态的*形状*将会是什么，React和TypeScript会用这个信息创建一个`ReadOnly<IPersonState>`属性。因此，确保我们使用正确的状态是很重要的。如果我们对状态使用了错误的类型，TypeScript会通知我们这一点。
- en: Note that there is a caveat to that preceding statement. If we have two interfaces
    of exactly the same shape, then TypeScript treats them as equivalent to each other.
    So, even though TypeScript is expecting `IState`, if we supply something called
    `IMyOtherState` that has exactly the same properties, then TypeScript will happily
    let us use that in its place. The question, of course, is why would we want to
    duplicate the interface in the first place? I cannot think of many cases where
    we would want to do that, so the idea of using the right state is accurate for
    almost all the cases we are ever likely to encounter.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的陈述有一个警告。如果我们有两个完全相同形状的接口，那么TypeScript会将它们视为等价的。因此，即使TypeScript期望`IState`，如果我们提供了一个名为`IMyOtherState`的东西，它具有完全相同的属性，那么TypeScript也会乐意让我们使用它。当然，问题是，为什么我们要首先复制接口呢？我想不出很多情况下我们会这样做，所以使用正确的状态的想法几乎适用于我们可能遇到的所有情况。
- en: 'Our `app.tsx` file is going to create a default for the state and pass this
    to our component as its property. The default state is the one that will be applied
    when the user presses clear to clear the currently edited entry, or New Person
    to start adding a new person. Our `IProps` interface looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`app.tsx`文件将会为状态创建一个默认值，并将其作为属性传递给我们的组件。默认状态是当用户按下清除按钮清除当前编辑的条目，或者按下新建人员按钮开始添加新人员时将会应用的状态。我们的`IProps`接口看起来是这样的：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Something that may seem slightly confusing at first is a potential contradiction
    between my earlier statement the idea that the properties and state are different—with
    state being something that is local to the component and yet we are passing state
    down as part of the properties. I deliberately use state as part of the name to
    reinforce the fact that this represents the state. The values that we are passing
    in can be called anything at all. They do not have to represent any state; they
    could simply be functions that the component calls to trigger some response in
    the parent. Our component will receive this property and it will be its responsibility
    to convert any part that it needs into state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能会有些令人困惑的是，我之前的陈述和属性和状态是不同的这个想法之间存在潜在的矛盾——状态是组件本地的东西，但我们将状态作为属性的一部分传递下去。我故意在名称中使用状态的一部分来强调这一点。我们传递的值可以是任何东西。它们不必代表任何状态；它们可以只是组件调用以触发父级响应的函数。我们的组件将接收这个属性，并且它将负责将其需要的任何部分转换为状态。
- en: 'With this in place, we are ready to change our `App.tsx` file to create our
    default state and to pass this into our `PersonalDetails` component. As we can
    see in the following code, the property from the `IProps` interface becomes a
    parameter in the `<PersonalDetails ..` line. The more items we add to our properties
    interface, the more parameters we will have to add to this line:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就可以准备改变我们的`App.tsx`文件，创建我们的默认状态，并将其传递给我们的`PersonalDetails`组件。正如我们在下面的代码中所看到的，`IProps`接口中的属性成为了`<PersonalDetails
    ..`行中的一个参数。我们向我们的属性接口添加更多的项目，我们就需要在这一行中添加更多的参数：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Date handling with JavaScript can be off-putting when we want to hook the date
    into a date picker component. The date picker expects to receive the date in the
    format of YYYY-MM-DD. So, we use the `new Date().toISOString().substring(0,10)` syntax
    to get today's date, which includes a time component, and only retrieve the YYYY-MM-DD
    portion from this. Even though the date picker expects the date to be in this
    format, it does not say that this is the format that will be displayed on the
    screen. The format on your screen should respect the local settings of the user.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要将日期挂接到日期选择器组件时，使用JavaScript处理日期可能会让人望而却步。日期选择器期望以YYYY-MM-DD的格式接收日期。因此，我们使用`new
    Date().toISOString().substring(0,10)`语法来获取今天的日期，其中包括一个时间组件，并且只从中检索YYYY-MM-DD部分。尽管日期选择器期望日期以这种格式呈现，但它并没有规定这是屏幕上显示的格式。屏幕上的格式应该遵守用户的本地设置。
- en: What was interesting about the changes we made to support passing in properties
    is that we have already seen binding in action here. Inside the `render` method,
    where we set `Default={this.defaultPerson}`, we are using binding. With the use
    of `{ }` here, we are telling React that we want to bind to something, whether
    it's to a property or an event. We will encounter binding a lot in React.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们对支持传递属性所做的更改已经在这里看到了绑定的作用。在`render`方法中，我们设置`Default={this.defaultPerson}`时，我们正在使用绑定。在这里使用`{}`，我们告诉React我们想要绑定到某些东西，无论是属性还是事件。我们在React中会经常遇到绑定。
- en: 'Now we are going to add a constructor to `PersonalDetails.tsx` to support the
    property that is being passed in from `App.tsx`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在`PersonalDetails.tsx`中添加一个构造函数，以支持从`App.tsx`传入的属性：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We are doing two things here. First, we are setting up a default state to go
    back to if we need to, which we received from our parent; second, we are setting
    up the state for this page. We didn't have to create a state property in our code
    as this is provided for us by `React.Component`. This is the final part of learning
    how we have tied our property from the parent to the state.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做两件事。首先，我们正在设置一个默认状态，以便在需要时返回到我们从父级那里收到的状态；其次，我们正在为此页面设置状态。我们不必在我们的代码中创建一个状态属性，因为这是由`React.Component`为我们提供的。这是学习如何将我们的属性从父级绑定到状态的最后一部分。
- en: Changes to state will not be reflected back in the parent props. If we wanted
    to explicitly set a value back in the parent component, this would require us
    to trigger a change to `props.DefaultState`. I advise against doing this directly
    if you can possibly avoid it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对状态的更改不会反映在父级props中。如果我们想要明确地将一个值设置回父组件，这将要求我们触发对`props.DefaultState`的更改。如果可能的话，我建议不要直接这样做。
- en: 'Right. Let''s set up our first name and last name elements to work with the
    binding from our state. The idea here is that if we update the state of the first
    or last names in our code, this will automatically be updated in our UI. So, let''s
    change the entries as required:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们设置我们的名字和姓氏元素，使其与我们状态的绑定一起工作。这里的想法是，如果我们在代码中更新名字或姓氏的状态，这将自动在我们的UI中更新。因此，让我们根据需要更改条目：
- en: '[PRE20]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we run our application, we have entries that are bound to the underlying
    state. There is, however, an issue with this code. If we try to type into either
    textbox, we will see that nothing happens. The actual text entry is rejected.
    That does not mean we have done anything wrong, rather we only have part of the
    overall picture here. What we need to understand is that React provides us with
    a read-only version of the state. If we want our UI to update our state, we have
    to explicitly opt into this by reacting to changes and then setting the state
    as appropriate. First, we are going to write an event handler to handle setting
    the state when the text changes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行我们的应用程序，我们会发现条目已绑定到底层状态。然而，这段代码存在一个问题。如果我们尝试在任一文本框中输入，我们会发现没有任何反应。实际的文本输入被拒绝了。这并不意味着我们做错了什么，而是我们只是在这里看到了整体图片的一部分。我们需要理解的是，React为我们提供了一个只读版本的状态。如果我们希望我们的UI更新我们的状态，我们必须通过对变化做出反应，然后适当地设置状态来明确地选择这一点。首先，我们将编写一个事件处理程序来处理文本更改时的状态设置：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With this in place, we can now update our input to trigger this update using
    the `onChange` attribute. Again, we are going to use binding to match the `onChange`
    event to the code that is triggered as a result:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个设置，我们现在可以使用`onChange`属性更新我们的输入以触发此更新。同样，我们将使用绑定将`onChange`事件与作为结果触发的代码匹配：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'From this code, we can clearly see that `this.state` provides us with access
    to the underlying state that we set up in our component and that we need to change
    it using `this.setState`. The syntax of `this.setState` should look familiar as
    it matches the key to the value, which we have encountered many times before in
    TypeScript. At this stage, we can now update the rest of our entry components
    to support this two-way binding. First, we expand our `updateBinding` code as
    follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们可以清楚地看到`this.state`为我们提供了对我们在组件中设置的底层状态的访问，并且我们需要使用`this.setState`来更改它。`this.setState`的语法应该看起来很熟悉，因为它与我们在TypeScript中多次遇到的键值匹配。在这个阶段，我们现在可以更新我们的其余输入组件以支持这种双向绑定。首先，我们将扩展我们的`updateBinding`代码如下：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We aren't going to code dump all of the changes that we need to make to our
    actual inputs. We just need to update each input to match the value to the appropriate
    state element, and then add the same `onChange` handler in each case.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不打算将我们需要对实际输入进行的所有更改都进行代码转储。我们只需要更新每个输入以将值与相应的状态元素匹配，并在每种情况下添加相同的`onChange`处理程序。
- en: As `Address2` can be null, we are using the `!` operator on our binding so that
    it looks slightly different: `value={this.state.Address2!}`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Address2`可能为空，我们在绑定上使用`!`运算符，使其看起来略有不同：`value={this.state.Address2!}`。
- en: Validating user inputs and the use of validators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入和验证器的使用
- en: At this stage, we really should think about validating inputs from the user.
    We are going to introduce two types of validation in our code. The first is the
    minimum length validation. In other words, we are going to ensure that some of
    the entries have to have a minimum number of entries before they can be considered
    to be valid. The second type of validation uses something called a regular expression
    to validate it. What this means is that it takes the input and compares it against
    a set of rules to see whether there is a match; the expressions can look a little
    bit odd if you are new to regular expressions, so we will break them down to see
    exactly what rules we are applying.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们真的应该考虑验证用户的输入。我们将在我们的代码中引入两种类型的验证。第一种是最小长度验证。换句话说，我们将确保一些条目在被视为有效之前必须具有最少数量的条目。第二种验证类型使用称为正则表达式的东西来验证它。这意味着它接受输入并将其与一组规则进行比较，以查看是否有匹配；如果您对正则表达式不熟悉，这些表达式可能看起来有点奇怪，因此我们将对它们进行分解，以确切了解我们正在应用的规则。
- en: 'We are going to break our validation down into three parts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的验证分解为三个部分：
- en: The classes that provide the checking features, such as applying a regular expression.
    We will call these validators.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供检查功能的类，比如应用正则表达式。我们将称这些为验证器。
- en: The classes that apply the validation items to the different parts of the state.
    We will call these classes validations.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将验证项目应用到状态的不同部分的类。我们将称这些类为验证。
- en: The component that will call the validation items and update the UI with the
    details of a failed validation. This will be a new component called `FormValidation.tsx`.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将调用验证项目并使用失败验证的详细信息更新UI的组件。这将是一个名为`FormValidation.tsx`的新组件。
- en: 'We will start by creating an interface called `IValidator`. This interface
    is going to accept a generic parameter so that we can apply it to pretty much
    anything that we want. As a validation will tell us whether the input is valid,
    it will have a single method called `IsValid` that accepts the relevant input
    and then returns a `boolean` value:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`IValidator`的接口。这个接口将接受一个通用参数，以便我们可以将它应用到几乎任何我们想要的东西上。由于验证将告诉我们输入是否有效，它将有一个名为`IsValid`的单一方法，该方法接受相关输入，然后返回一个`boolean`值：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first validator that we are going to write checks to see whether a string
    has a minimum number of characters, which we will set through the constructor.
    We will also guard against situations where the user fails to supply an input,
    by returning `false` from `IsValid` when the input is null:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要编写的第一个验证器是检查字符串是否具有最小数量的字符，我们将通过构造函数设置。我们还将防范用户未提供输入的情况，通过在输入为null时从`IsValid`返回`false`：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The other validator that we are going to create is slightly more complicated.
    This validator accepts a string, which it uses to create something called a regular
    expression. A regular expression is effectively a mini language that provides
    a set of rules to test our input string against. In this case, the rules that
    form our regular expression are passed into our constructor. The constructor will
    then instantiate an instance of the JavaScript regular expression engine (`RegExp`).
    In a similar way to the minimum length validation, we ensure that we return `false`
    if there is no input. If we have an input, then we return the result of our regular
    expression test:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的另一个验证器稍微复杂一些。这个验证器接受一个字符串，用它来创建一个叫做正则表达式的东西。正则表达式实际上是一种提供一组规则来测试我们的输入字符串的迷你语言。在这种情况下，构成我们正则表达式的规则被传递到我们的构造函数中。构造函数将实例化JavaScript正则表达式引擎（`RegExp`）的一个实例。与最小长度验证类似，我们确保如果没有输入则返回`false`。如果有输入，我们返回我们正则表达式测试的结果：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have our validators, we are going to examine how we are going to
    apply them. It probably will not come as a surprise that the first thing that
    we are going to do is define an interface that forms the *contract* of what we
    want our validation to do. Our `Validate` method is going to accept the `IPersonState`
    state from our component, validate items from this, and then return an array of
    validation failures:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了验证器，我们将研究如何应用它们。也许不会让人感到意外的是，我们要做的第一件事是定义一个接口，形成我们希望验证做的*合同*。我们的`Validate`方法将接受来自我们组件的`IPersonState`状态，验证其中的项目，然后返回一个验证失败的数组。
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'I have decided to break the validation down into the following three areas:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我决定将验证分解为以下三个领域：
- en: Validating the address
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证地址
- en: Validating the name
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证姓名
- en: Validating the phone number
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证电话号码
- en: Validating the address
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证地址
- en: 'Our address validation is going to use the `MinLengthValidator` and `RegularExpressionValidator`
    validators:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的地址验证将使用`MinLengthValidator`和`RegularExpressionValidator`验证器：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The minimum length validation is simple enough, but the regular expression can
    be intimidating if you have never seen this type of syntax before. Before we look
    at our validation code, we will break down what the regular expression is doing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最小长度验证足够简单，但如果你以前从未见过这种类型的语法，正则表达式可能会让人望而生畏。在查看我们的验证代码之前，我们将分解正则表达式的工作。
- en: The first character, `^`, tells us that our validation is going to start at
    the very beginning of the string. If we left this character out, it would mean
    that our match could occur anywhere in the text. The use of `[0-9]` tells the
    regular expression engine that we want to match against a number. Strictly speaking,
    as US zip codes start with five numbers, we need to tell the validator that we
    want to match against five numbers, which we do by telling the engine how many
    we want: `[0-9]{5}`. If we only wanted to match against major area codes such
    as 10023, we could almost end our expression here. Zip codes, however, have an
    optional four-digit portion as well that is separated from the main part by a
    hyphen. Therefore, we have to tell the regular expression engine that we have
    an optional part that we want to apply.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字符`^`告诉我们验证将从字符串的开头开始。如果我们省略这个字符，那么意味着我们的匹配可以出现在文本的任何地方。使用`[0-9]`告诉正则表达式引擎我们要匹配一个数字。严格来说，由于美国邮政编码以五个数字开头，我们需要告诉验证器我们要匹配五个数字，我们通过告诉引擎我们需要多少个来做到这一点：`[0-9]{5}`。如果我们只想匹配主要区号，比如10023，我们几乎可以在这里结束我们的表达式。然而，邮政编码还有一个可选的四位数字部分，它与主要部分由一个连字符分隔。因此，我们必须告诉正则表达式引擎我们有一个可选的部分要应用。
- en: We know that the format of the optional part of the zip code is a hyphen with
    four digits. This means that the next part of the regular expression has to consider
    the test as being one test. This means that we cannot test for a hyphen and then
    separately test for the numbers; we either have the -1234 format or we don't have
    anything. This tells us that we want to group the items we want to test together.
    The way that we group things together in a regular expression is to put the expression
    inside brackets. So, if we apply the same logic that we had before, we would probably
    think that this part of the validation was `(-[0-9]{4})`. As a first pass, that
    is pretty close to what we want. The rule, here, is to treat this as a group where
    the first character must be a hyphen and then there must be four numbers. There
    are two things that we need to sort out with this part of the expression. The
    first thing is that this test is not optional at the moment. In other words, the
    input 10012-1234 is valid, while 10012 is no longer valid. The second problem
    is that we have created something called a capture group in our expression, which
    we do not need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '我们知道邮政编码可选部分的格式是一个连字符和四位数字。这意味着正则表达式的下一部分必须将测试视为一个测试。这意味着我们不能测试连字符，然后分别测试数字；我们要么有-1234格式，要么什么都没有。这告诉我们我们想要将要测试的项目分组。在正则表达式中将事物分组的方法是将表达式放在括号内。因此，如果我们应用之前的逻辑，我们可能会认为验证的这部分是
    `(-[0-9]{4})`。首次尝试，这与我们想要的非常接近。这里的规则是将其视为一个组，其中第一个字符必须是连字符，然后必须有四个数字。这个表达式的一部分有两件事情需要解决。第一件事是目前这个测试是不可选的。换句话说，输入10012-1234是有效的，而10012不再有效。第二个问题是我们在表达式中创建了一个捕获组，而我们并不需要。 '
- en: A capture group is a numbered group that represents the number of the match.
    This can be useful if we want to match the same text in a number of places in
    a document; however, as we only want one match, it is something we can avoid.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获组是一个编号组，代表匹配的次数。如果我们想在文档的多个地方匹配相同的文本，这可能很有用；然而，由于我们只想要一个匹配，这是可以避免的。
- en: We will fix both issues with the optional part of the validation now. The first
    thing we are going to do is remove the capture group. This is done by using an
    `?:` operator that tells the engine that this group is a non-capture group. The
    next thing we are going to take care of is applying a `?` operator that says that
    we want this match to happen zero times or one time only. In other words, we have
    made this an optional test. At this point, we can successfully test both 10012
    and 10012-1234, but we do have one more thing that we need to take care of. We
    need to make sure that the input only matches this input. In other words, we don't
    want to allow any stray characters at the end; otherwise, the user would be able
    to type in 10012-12345 and the engine would think that we had a valid input. What
    we need to do is add the `$` operator at the end of the expression, which states
    that the expression is expecting the end of the line at that point. At this point,
    our regular expression is `^[0-9]{5}(?:-[0-9]{4})?$`, which matches the validation
    that we are expecting to apply to the zip code.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解决验证的可选部分的两个问题。我们要做的第一件事是删除捕获组。这是通过使用 `?:` 运算符来完成的，告诉引擎这个组是一个非捕获组。接下来我们要处理的是应用
    `?` 运算符，表示我们希望此匹配发生零次或一次。换句话说，我们已经将其设置为可选测试。此时，我们可以成功测试10012和10012-1234，但我们还有一件事需要处理。我们需要确保输入只匹配此输入。换句话说，我们不希望在结尾允许任何杂乱的字符；否则，用户可以输入10012-12345，引擎会认为我们有一个有效的输入。我们需要做的是在表达式的结尾添加
    `$` 运算符，表示表达式在那一点处期望行的结束。此时，我们的正则表达式是 `^[0-9]{5}(?:-[0-9]{4})?$`，它匹配我们期望应用于邮政编码的验证。
- en: I have chosen to explicitly specify that a number is represented as `[0-9]`
    because it is a clear indicator for someone new to regular expressions that this
    represents a number between 0 and 9\. There is an equivalent shorthand that can
    be used to represent a single digit, and that is to use `\d` in its place. With
    this, we can rewrite this rule to `^\d{5}(?:-\d{4})?$`. The use of `\d` in this
    represents a single **American Standard Code for Information Interchange** (**ASCII**)
    digit.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择明确指定数字表示为 `[0-9]`，因为这对于新接触正则表达式的人来说是一个清晰的指示，表示0到9之间的数字。有一个等效的速记可以用来表示单个数字，那就是使用
    `\d` 代替。有了这个，我们可以将这个规则重写为 `^\d{5}(?:-\d{4})?$`。在这里使用 `\d` 代表一个**美国信息交换标准代码**（**ASCII**）数字。
- en: 'Going back to our address validation, the actual validation itself is extremely
    straightforward because we took the time to write validators that did the hard
    work for us. All we need to do is apply the minimum length validator against the
    first line of the address, the town, and the county, and the regular expression
    validator is applied to the zip code. Each failing validation item is added to
    the list of errors:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的地址验证，实际验证本身非常简单，因为我们花时间编写了为我们做了艰苦工作的验证器。我们所需要做的就是对地址的第一行、城镇和县区应用最小长度验证器，对邮政编码应用正则表达式验证器。每个失败的验证项目都会添加到错误列表中：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Validating the name
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证姓名
- en: 'The name validation is the simplest piece of validation we are going to write.
    This validation assumes that we have a minimum of one letter for the first name
    and two letters for the last name:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 姓名验证是我们将要编写的最简单的验证部分。此验证假定我们的名字至少有一个字母，姓氏至少有两个字母：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Validating the phone number
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证电话号码
- en: 'The phone number validation is going to be broken down into two parts. First,
    we validate that there is an entry for the phone number. Then, we validate to
    ensure that it is in the correct format using a regular expression. Before we
    analyze the regular expression, let''s see what this validation class looks like:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码验证将分为两部分。首先，我们验证电话号码是否有输入。然后，我们验证以正确格式输入，使用正则表达式。在分析正则表达式之前，让我们看看这个验证类是什么样子的：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The regular expression initially looks more complicated than the zip code validation;
    however, once we break it down, we will see that it has lots of familiar elements.
    It uses `^` to capture from the start of the line, `$` to capture right to the
    end, and `?:` to create non-capture groups. We also see that we have set number
    matches such as `[0-9]{3}` to represent three numbers. If we break this down section
    by section, we will see that this really is a straightforward piece of validation.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，正则表达式看起来比邮政编码验证更复杂；然而，一旦我们将其分解，我们会发现它有很多熟悉的元素。它使用`^`从行的开头捕获，使用`$`捕获到行的末尾，并使用`?:`创建非捕获组。我们还看到我们设置了数字匹配，比如`[0-9]{3}`表示三个数字。如果我们逐段分解，我们会发现这确实是一个简单的验证部分。
- en: The first part of our phone number either takes the format of (555) or 555 optionally
    followed by a hyphen, period, or space. At first glance, `(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?` is the most intimidating part of the expression. As we know, the first part
    either has to be something such as (555) or 555; that means that we have either
    *this expression* or *this expression* test. We have already seen that `(` and
    `)` mean something special to the regular expression engine so we must have some
    mechanism available to us to say that we are looking at the actual brackets rather
    than the expression that the brackets represent. That is what the `\\` part means
    in the expression.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的电话号码的第一部分要么采用(555)或555的格式，后面可能跟着一个连字符、句号或空格。乍一看，`(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?`是表达式中最令人生畏的部分。正如我们所知，第一部分要么是(555)这样的东西，要么是555；这意味着我们要么测试*这个表达式*，要么测试*这个表达式*。我们已经看到`(`和`)`对正则表达式引擎来说意味着特殊的东西，所以我们必须有一些机制可用来表明我们正在看实际的括号，而不是括号代表的表达式。这就是表达式中`\\`的意思。
- en: The use of `\` in a regular expression escapes the next character so that it
    is treated literally, rather than as an expression that forms a rule that will
    be matched. Additionally, as TypeScript already treats `\` as an escape character,
    we have to escape the escape character as well so that the expression engine sees
    the correct value.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中使用`\`来转义下一个字符，使其被当作字面量处理，而不是作为一个规则形成表达式来匹配。另外，由于TypeScript已经将`\`视为转义字符，我们必须对转义字符进行转义，以便表达式引擎看到正确的值。
- en: When we want a regular expression to say a value must be this or that, we group
    the expression and then use `|` to break it apart. Looking at our expression there,
    we see that we are looking for the (*nnn*) part first and, if that is not matched,
    we look at the *nnn* part instead.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要一个正则表达式表示一个值必须是这样或那样时，我们将表达式分组，然后使用`|`来分隔它。看看我们的表达式，我们首先看到我们首先寻找(*nnn*)部分，如果没有匹配，我们会转而寻找*nnn*部分。
- en: We also said that this value could be followed by a hyphen, period, or space.
    We use `[-. ]` to match a single character from that list. To make this test optional,
    we put `?` at the end.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还说这个值可以后面跟着一个连字符、句号或空格。我们使用`[-. ]`来匹配列表中的单个字符。为了使这个测试是可选的，我们在末尾加上`?`。
- en: With this knowledge, we see that the next part of the regular expression, `(?:[0-9]{3})[-.
    ]?`, is looking for three numbers optionally followed by a hyphen, period, or
    space. The final part, `(?:[0-9]{4})`, states that the number must end in four
    digits. We now know that we can match numbers such as (555) 123-4567, 123.456.7890,
    and (555) 543 9876.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个知识，我们看到正则表达式的下一部分，`(?:[0-9]{3})[-. ]?`，正在寻找三个数字，后面可能跟着一个连字符、句号或空格。最后一部分，`(?:[0-9]{4})`，表示数字必须以四位数字结尾。我们现在知道我们可以匹配像(555)
    123-4567，123.456.7890和(555) 543 9876这样的数字。
- en: For our purpose, simple zip code and phone number validations such as these
    work perfectly. In larger-scale applications, we do not want to rely on these
    as validation. These only test the data that looks to be in a particular format;
    they don't actually check to see whether they belong to real addresses or phones.
    If we reached a stage with our application where we actually wanted to verify
    that these existed, we would have to hook up to the services that did these checks.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，像这样的简单邮政编码和电话号码验证非常完美。在大型应用程序中，我们不希望依赖这些验证。这些只是测试看起来是否符合特定格式的数据；它们实际上并不检查它们是否属于真实地址或电话。如果我们的应用程序达到了一个阶段，我们实际上想要验证这些是否存在，我们将不得不连接到执行这些检查的服务。
- en: Applying validation in a React component
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React组件中应用验证
- en: In our mock layout, we identified that we wanted our validation to appear below
    the `Save` and `Clear` buttons. While we could do this inside our main component,
    we are going to separate our validation out into a separate validation component.
    The component will receive the current state of our main component, apply the
    validation whenever the state changes, and return whether we can save our data.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的模拟布局中，我们确定我们希望我们的验证出现在`保存`和`清除`按钮下方。虽然我们可以在主组件内部完成这个操作，但我们将把我们的验证分离到一个单独的验证组件中。该组件将接收我们主组件的当前状态，在状态改变时应用验证，并返回我们是否可以保存我们的数据。
- en: 'In a similar way to how we created our `PersonalDetails` component, we are
    going to create properties to pass into our component:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建`PersonalDetails`组件的方式类似，我们将创建属性传递到我们的组件中：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We are going to create a component in `FormValidation.tsx`, that will apply
    the different `IValidation` classes that we have just created. The constructor
    simply adds the different validators into an array that we will shortly iterate
    over and apply the validation for:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`FormValidation.tsx`中创建一个组件，它将应用我们刚刚创建的不同的`IValidation`类。构造函数只是将不同的验证器添加到一个数组中，我们很快将对其进行迭代并应用验证：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In the `Validate` method, we apply each piece of validation inside `forEach`
    before we call the `CanSave` method from our properties.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Validate`方法中，我们在调用我们的属性的`CanSave`方法之前，对每个验证部分都进行验证。
- en: 'Before we add our `render` method, we are going to revisit `PersonalDetails`
    and add our `FormValidation` component:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加`render`方法之前，我们将重新访问`PersonalDetails`并添加我们的`FormValidation`组件：
- en: '[PRE34]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `userCanSave` method looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`userCanSave`方法看起来像这样：'
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: So, whenever the validation is updated, our `Validate` method calls back to
    `userCanSave`, which has been passed in as a property.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当验证更新时，我们的`Validate`方法回调`userCanSave`，这已经作为属性传递进来。
- en: 'The last thing we need to do to get our validation running is to call the `Validate`
    method from the `render` method. We do this because the render cycle is called
    whenever the state of the parent changes. When we have a list of validation failures,
    we need to add them into our DOM as elements that we want to render back to the
    interface. A simple way to do this is to create a map of all of the failures and
    provide an iterator as a function that will loop over each failure and write it
    back as a row to the interface:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行验证的最后一件事是从`render`方法中调用`Validate`方法。我们这样做是因为每当父级的状态改变时，渲染周期都会被调用。当我们有一系列验证失败时，我们需要将它们添加到我们的DOM中作为我们想要渲染回接口的元素。一个简单的方法是创建所有失败的映射，并提供一个迭代器作为一个函数，它将循环遍历每个失败并将其写回作为一个行到接口：
- en: '[PRE36]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: At this point, whenever we change the state inside the application, our validation
    will automatically be triggered and any failures will be written in the browser
    as a `label` tag.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，每当我们在应用程序内部改变状态时，我们的验证将自动触发，并且任何失败都将被写入浏览器作为`label`标签。
- en: Creating and sending data to the IndexedDB database
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并发送数据到IndexedDB数据库
- en: It would make for a very poor experience when using the application if we could
    not save details for use the next time we came back to it. Fortunately, newer
    web browsers provide support for something called IndexedDB, which is a web browser-based
    database. Using this as our data store means that the details will be available
    when we reopen the page.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能保存细节以便下次回到应用程序时使用，那将会是非常糟糕的体验。幸运的是，较新的Web浏览器提供了对一种称为IndexedDB的东西的支持，这是一个基于Web浏览器的数据库。使用这个作为我们的数据存储意味着当我们重新打开页面时，这些细节将可用。
- en: While we are working with the database, we have two distinct areas that we need
    to bear in mind. We require code to build the database table and we require code
    to save the records in a database. Before we start writing the database table,
    we are going to add the ability to describe what our database looks like, which
    will be used to build the database.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用数据库时，我们需要牢记两个不同的领域。我们需要代码来构建数据库表，我们需要代码来保存数据库中的记录。在我们开始编写数据库表之前，我们将添加描述我们的数据库外观的能力，这将用于构建数据库。
- en: 'Next, we will create a fluent interface to add the information that `ITable`
    exposes:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个流畅的接口来添加`ITable`公开的信息：
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The idea behind fluent interfaces is that they allow us to chain methods together
    so that they can be read in an easier fashion. They encourage the idea of keeping
    method operations together, making it easier to read what is happening to an instance
    because the operations are all grouped together. This interface is fluent because
    the methods return `ITableBuilder`. The implementations of these methods use `return
    this;` to allow the chaining of operations together.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 流畅接口的理念是它们允许我们将方法链接在一起，以便更容易地阅读。它们鼓励将方法操作放在一起，使得更容易阅读实例发生了什么，因为操作都是分组在一起的。这个接口是流畅的，因为这些方法返回`ITableBuilder`。这些方法的实现使用`return
    this;`来允许将操作链接在一起。
- en: With fluent interfaces, not all methods need to be fluent. If you create a non-fluent
    method on an interface, that becomes the end of the call chain. This is sometimes
    used for classes that need to set some properties and then build an instance of
    a class that has those properties.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流畅的接口，不是所有的方法都需要是流畅的。如果你在接口上创建一个非流畅的方法，那就成为了调用链的终点。这有时用于需要设置一些属性然后构建具有这些属性的类的实例的类。
- en: 'The other side of building the table is the ability to get the values from
    the builder. As we want to keep our fluent interface purely dealing with adding
    the details, we are going to write a separate interface to retrieve these values
    and build our IndexedDB database:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 构建表的另一方面是从构建器获取值的能力。由于我们希望保持我们的流畅接口纯粹处理添加细节，我们将编写一个单独的接口来检索这些值并构建我们的IndexedDB数据库：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'While both of these interfaces serve different purposes and will be used by
    classes in different ways, they both refer to the same underlying code. When we
    write the class that exposes these interfaces, we are going to implement both
    the interfaces in the same class. The reason for doing this is so that we can
    segregate how they behave depending on which interface our calling code sees.
    Our table building class definition looks as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两个接口有不同的目的，并且将以不同的方式被类使用，但它们都指向相同的基础代码。当我们编写公开这些接口的类时，我们将在同一个类中实现这两个接口。这样做的原因是我们可以根据调用代码看到的接口来分隔它们的行为。我们的表构建类定义如下：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Of course, if we tried to build this right now, it would fail because we haven''t
    implemented either of our interfaces. The code for the `ITableBuilder` portion
    of this class looks like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们现在尝试构建这个，它会失败，因为我们还没有实现我们的任何一个接口。这个类的`ITableBuilder`部分的代码如下：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'For the most part, this is simple code. We have defined a number of member
    variables to hold the details, and each method is responsible for populating a
    single value. Where the code does get interesting is in the `return` statement.
    By returning this, we have the ability to chain each method together. Before we
    add our `ITable` support, let''s explore how we use this fluent interface by creating
    a class to add the personal details table definition:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这是简单的代码。我们已经定义了一些成员变量来保存细节，每个方法负责填充一个单一的值。代码变得有趣的地方在于`return`语句。通过返回`this`，我们有能力将每个方法链接在一起。在我们添加`ITable`支持之前，让我们通过创建一个类来添加个人详细信息表定义来探索如何使用这个流畅的接口：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: What this code does is create a table builder that sets the database name to
    `packt-advanced-typescript-ch3` and adds the `People` table to it, setting the
    primary field as `PersonId` and creating an index in this named `personId`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是创建一个将数据库名称设置为`packt-advanced-typescript-ch3`并向其中添加`People`表的表格构建器，将主字段设置为`PersonId`并在其中创建一个名为`personId`的索引。
- en: 'Now that we have seen the fluent interface in action, we need to complete the
    `TableBuilder` class by adding the missing `ITable` methods:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了流畅接口的运行方式，我们需要通过添加缺失的`ITable`方法来完成`TableBuilder`类：
- en: '[PRE42]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Build` method is the most interesting one in this part of the code. This
    is where we physically create the table using the methods from the underlying
    IndexedDB database. `IDBDatabase` is the connection to the actual IndexedDB database,
    which we are going to retrieve when we start writing the core database functionality.
    We use this to create the object store that we will use to store our people records.
    Setting `keyPath` allows us to give the object store a field that we want to search
    in, so it will match the name of a field. When we add indexes, we can tell the
    object store what fields we want to be able to search in.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Build`方法是代码中最有趣的部分。这是我们使用底层IndexedDB数据库的方法来物理创建表格的地方。`IDBDatabase`是实际IndexedDB数据库的连接，我们将在开始编写核心数据库功能时检索到它。我们使用它来创建我们将用来存储人员记录的对象存储。设置`keyPath`允许我们给对象存储一个我们想要搜索的字段，因此它将匹配字段的名称。当我们添加索引时，我们可以告诉对象存储我们想要能够搜索的字段。'
- en: Adding active record support to our state
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的状态添加活动记录支持
- en: 'Before we look at our actual database code, we need to introduce one last piece
    of the puzzle—the object that we are going to store. While we have been working
    with state, we have been using `IPersonState` to represent the state of a person
    and, as far as the `PersonalDetails` component goes, that is sufficient. While
    working with the database, we want to expand this state. We are going to introduce
    a new `IsActive` parameter that will determine whether a person is shown on the
    screen. We don''t need to change the implementation of `IPersonState` to add this
    capability; we are going to use an intersection type to handle this instead. The
    first thing we have to do is add a class that has this active flag and then create
    our intersection type:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们的实际数据库代码之前，我们需要介绍最后一部分拼图——我们将要存储的对象。虽然我们一直在处理状态，但我们一直在使用`IPersonState`来表示一个人的状态，并且就`PersonalDetails`组件而言，这已经足够了。在处理数据库时，我们希望扩展这个状态。我们将引入一个新的`IsActive`参数，用于确定一个人是否显示在屏幕上。我们不需要更改`IPersonState`的实现来添加这个功能；我们将使用交集类型来处理这个问题。我们首先要做的是添加一个具有这个活动标志的类，然后创建我们的交集类型：
- en: '[PRE43]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Working with the database
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数据库
- en: 'Now that we have the ability to build the table and a representation of the
    state that we want to save into the table, we can turn our attention to connecting
    to the database and actually manipulating data in it. The first thing that we
    are going to do is define our class as a generic type that can work with any type
    that extends the `RecordState` class we just implemented:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们有了构建表格和保存到表格中的状态表示的能力，我们可以把注意力转向连接数据库并实际操作其中的数据。我们要做的第一件事是将我们的类定义为一个通用类型，可以与我们刚刚实现的`RecordState`类扩展的任何类型一起工作：
- en: '[PRE44]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The reason we need to specify the type that we accept in this class is that
    most of the methods in it are going to either accept instances of that type as
    a parameter or return instances of that type to be worked with in the calling
    code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这个类中指定我们接受的类型的原因是，其中大多数方法要么接受该类型的实例作为参数，要么返回该类型的实例供调用代码使用。
- en: As IndexedDB has become the standard client-side database, it has become something
    that can be directly accessed from the window object. TypeScript provides strong
    interfaces to support the database, so it is exposed as an `IDBFactory` type.
    This is important to us because it gives us access to operations such as opening
    the database. Effectively, this is the route that our code has to begin at to
    start manipulating data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 随着IndexedDB成为标准的客户端数据库，它已经成为可以直接从window对象访问的内容。TypeScript提供了强大的接口来支持数据库，因此它被公开为`IDBFactory`类型。这对我们很重要，因为它使我们能够访问打开数据库等操作。实际上，这是我们的代码开始操作数据的起点。
- en: Whenever we want to open the database, we give it a name and version. If the
    database name does not exist, or we are attempting to open a newer version, then
    our application code needs to upgrade the database. This is where the `TableBuilder`
    code comes into play. As we have specified that `TableBuilder` implements an `ITable`
    interface to provide the ability to read values and build the underlying database
    table, we are going to use that (the table instance is passed into the constructor,
    as we will see shortly).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们想要打开数据库时，我们都会给它一个名称和版本。如果数据库名称不存在，或者我们试图打开一个更新版本，那么我们的应用程序代码需要升级数据库。这就是`TableBuilder`代码发挥作用的地方。由于我们已经指定`TableBuilder`实现了`ITable`接口以提供读取值和构建底层数据库表的能力，我们将使用它（表实例将在不久后传递到构造函数中）。
- en: Working with IndexedDB can seem slightly strange at first because it emphasizes
    the use of event handlers a lot. For instance, when we attempt to open the database,
    if the code decides that an upgrade is needed, it triggers the `upgradeneeded`
    event, which we handle using `onupgradeneeded`. This use of events allows our
    code to behave asynchronously because the execution continues without waiting
    for the operation to complete. Then, when the event handler is triggered, it takes
    over the processing. We will be seeing a lot of this when we add our data methods
    to this class.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，使用IndexedDB可能会有些奇怪，因为它强调了大量使用事件处理程序。例如，当我们尝试打开数据库时，如果代码决定需要升级，它会触发`upgradeneeded`事件，我们使用`onupgradeneeded`来处理。这种事件的使用允许我们的代码异步地执行，因为执行会继续而不必等待操作完成。然后，当事件处理程序被触发时，它接管处理。当我们向这个类添加数据方法时，我们将会看到很多这样的情况。
- en: 'With this information in mind, we can write our `OpenDatabase` method to open
    the database with the value from the `Version` method. The first time we hit this
    code, we are going to need to write the database table. Even though this is a
    new table, it is treated as an upgrade so the `upgradeneeded` event is triggered.
    Again, we can see the benefit of having the ability to build the database in the
    `PersonalDetailsTableBuilder` class because we keep our database code free from
    knowing how to build the table. By doing this, we can reuse this class for writing
    other types to the database if we need to. When the database opens, the `onsuccess`
    handler will be triggered, and we will set an instance-level `database` member
    that we can use later on:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些信息，我们可以编写我们的`OpenDatabase`方法来使用`Version`方法的值打开数据库。第一次我们执行这段代码时，我们需要写入数据库表。即使这是一个新表，它也被视为升级，因此会触发`upgradeneeded`事件。再次，我们可以看到在`PersonalDetailsTableBuilder`类中具有构建数据库的能力的好处，因为我们的数据库代码不需要知道如何构建表。通过这样做，如果需要，我们可以重用这个类来将其他类型写入数据库。当数据库打开时，将触发`onsuccess`处理程序，我们将设置一个实例级别的`database`成员，以便以后使用：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now that we have the ability to build and open the table that is in place,
    we are going to write a constructor that accepts the `ITable` instance, which
    we will use to build the table:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了构建和打开表的能力，我们将编写一个接受`ITable`实例的构造函数，我们将用它来构建表：
- en: '[PRE46]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We have one last helper method to write for this class before we start writing
    the code that works with the data. In order to write data to the database, we
    have to create a transaction and retrieve an instance of the object store from
    it. Effectively, the object store represents a single table in our database. Essentially,
    we require an object store if we want to read or write data. As this is so common,
    we create a `GetObjectStore` method that returns the object store. For convenience,
    we are going to allow our transaction to treat every operation as read or write,
    which we specify when we call the transaction:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写处理数据的代码之前，我们还需要为这个类编写最后一个辅助方法。为了将数据写入数据库，我们必须创建一个事务并从中检索对象存储的实例。实际上，对象存储代表数据库中的一个表。基本上，如果我们想要读取或写入数据，我们需要一个对象存储。由于这是如此常见，我们创建了一个`GetObjectStore`方法来返回对象存储。为了方便起见，我们将允许我们的事务将每个操作都视为读取或写入，这是我们在调用事务时指定的：
- en: '[PRE47]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As we go through the code, you will see that I have chosen to name the methods
    `Create`, `Read`, `Update`, and `Delete`. It is fairly common to name the first
    two methods `Load` and `Save`; however, I chose these method names deliberately,
    because when working with data in databases, we often use the term *CRUD operation*,
    where **CRUD** refers to **Create**, **Read**, **Update**, and **Delete**. By
    adopting this naming convention, I hope that this solidifies this connection for
    you.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们阅读代码时，您会看到我选择将方法命名为`Create`、`Read`、`Update`和`Delete`。通常将前两个方法命名为`Load`和`Save`是相当常见的；然而，我故意选择了这些方法名，因为在与数据库中的数据工作时，我们经常使用*CRUD操作*这个术语，其中**CRUD**指的是**Create**、**Read**、**Update**和**Delete**。通过采用这种命名约定，我希望这能够巩固这种联系。
- en: 'The first (and simplest) method that we are going to add will allow us to save
    a record to the database. The `Create` method takes in an individual record, gets
    the object store, and adds the record to the database:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要添加的第一个（也是最简单的）方法将允许我们将记录保存到数据库中。`Create`方法接受一个单独的记录，获取对象存储，并将记录添加到数据库中：
- en: '[PRE48]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'When I was originally writing the code for this chapter, I wrote the `Read`
    and `Write` methods to use callback methods. The idea behind the callback method
    was simply to accept a function that our methods could *call back to* when the
    `success` event handlers were triggered. When we look at a lot of IndexedDB samples,
    we can see that they tend to adopt this type of convention. Before we look at
    the finalized version, let''s take a look at what the `Read` method originally
    looked like:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初编写本章的代码时，我编写了`Read`和`Write`方法来使用回调方法。回调方法背后的想法很简单，就是接受一个函数，我们的方法可以在`success`事件处理程序触发时*回调*到它。当我们看很多IndexedDB示例时，我们可以看到它们倾向于采用这种类型的约定。在我们看最终版本之前，让我们看一下`Read`方法最初的样子：
- en: '[PRE49]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The method opens by getting the object store and using it to open something
    called a cursor. A cursor provides us with the ability to read a record and move
    onto the next one; so, when the cursor is opened, the success event is triggered,
    which means that we enter the `onsuccess` event handler. As this happens asynchronously,
    the `Read` method completes, so we will rely on the callback to transfer the actual
    values back to the class that called it. The rather strange-looking `callback:
    (value: T[]) => void` is the actual callback that we will use to return the array
    of `T` items back to the calling code.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '该方法通过获取对象存储并使用它来打开一个称为游标的东西来打开。游标为我们提供了读取记录并移动到下一个记录的能力；因此，当游标被打开时，成功事件被触发，这意味着我们进入了`onsuccess`事件处理程序。由于这是异步发生的，`Read`方法完成，因此我们将依赖回调将实际值传回调用它的类。看起来相当奇怪的`callback:
    (value: T[]) => void`是我们将用来将`T`项数组返回给调用代码的实际回调。'
- en: Inside the `success` event handler, we get the result from the event, which
    will be a cursor. Assuming that the cursor is not null, we get the result from
    the cursor and add the record to our array if the state of our record is active;
    this is why we apply the generic constraint to our class—so that we can access
    the `IsActive` property. We then call `continue` on the cursor, which moves on
    to the next record. The `continue` method results in `success` being fired again,
    which means that we re-enter the `onsuccess` handler, resulting in the same code
    happening for the next record. When there are no more records, the cursor will
    be null so the code will call back to the calling code with the array of items.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在“success”事件处理程序内部，我们从事件中获取结果，这将是一个光标。假设光标不为空，我们从光标中获取结果，并且如果我们的记录状态是活动的，我们将记录添加到我们的数组中；这就是为什么我们对我们的类应用了通用约束——这样我们就可以访问“IsActive”属性。然后我们在光标上调用“continue”，它会移动到下一条记录。调用“continue”方法会再次触发“success”，这意味着我们重新进入“onsuccess”处理程序，导致下一条记录发生相同的代码。当没有更多记录时，光标将为空，因此代码将使用项目数组回调到调用代码。
- en: 'I mentioned that this was the initial implementation of this code. While callbacks
    are useful, they don''t really take advantage of the power that TypeScript gives
    us. What this misses is the ability to use promises in our code base. As we are
    relying on a promise, we are going to gather all of the records together before
    we return them to the calling code. This means that we will have some minor structural
    differences to the logic inside our `success` handler:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到这是这段代码的初始实现。虽然回调很有用，但它们并没有真正充分利用TypeScript给我们带来的力量。这意味着我们将在返回给调用代码之前将所有记录聚集在一起。这意味着我们的“success”处理程序内部的逻辑将有一些细微的结构差异：
- en: '[PRE50]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As this is returning a promise, we drop the callback from the method signature
    and return a promise of an array of `T`. One of the things we have to be aware
    of is that the scope of the array we are going to use to store the results in
    has to be outside the `success` event handler; otherwise, we would reallocate
    it every time we hit `onsuccess`. What is interesting about this code is how similar
    it is to the callback version. All we have done is change the return type while
    dropping the callback from the method signature. The response part of our promise
    acts in place of the callback.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是返回一个承诺，我们从方法签名中删除回调，并返回一个“T”数组的承诺。我们必须注意的一件事是，我们将用于存储结果的数组的范围必须在“success”事件处理程序之外；否则，每次我们命中“onsuccess”时都会重新分配它。这段代码有趣的地方在于它与回调版本有多么相似。我们所做的只是改变返回类型，同时从方法签名中删除回调。我们承诺的响应部分充当回调的位置。
- en: In general, if our code accepts a callback, we can convert it to a promise by
    returning a promise with the callback moved from the method signature into the
    promise itself.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果我们的代码接受回调，我们可以通过返回一个将回调从方法签名中移动到承诺本身的承诺来将其转换为承诺。
- en: 'The logic for our cursor is the same as we rely on the cursor check to see
    whether we have a value, and, if we do, we push it onto our array. When there
    are no more records, we call the response on our promise so that the calling code
    can work with it in the `then` part of the promise. To illustrate this, let''s
    examine the `loadPeople` code in `PersonalDetails`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的光标逻辑与我们依赖光标检查的逻辑相同，以查看我们是否有一个值，如果有，我们就将其推送到我们的数组上。当没有更多记录时，我们调用承诺上的响应，以便调用代码可以在承诺的“then”部分中处理它。为了说明这一点，让我们来看看“PersonalDetails”中的“loadPeople”代码：
- en: '[PRE51]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Read` method is the most complicated part of our CRUD operation. The next
    method that we are going to write is the `Update` method. When the record has
    been updated, we want to reload the records in our list so that changes to the
    first or last names are updated on the screen. The object store operation that
    updates our record is `put`. If it completes successfully, it raises the success
    event, which leads our code to call the `resolve` property on our promise. As
    we are returning a `Promise<void>` type, we have the ability to use the `async`/`await`
    syntax when calling this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: “Read”方法是我们的CRUD操作中最复杂的部分。我们接下来要编写的方法是“Update”方法。当记录已更新时，我们希望重新加载列表中的记录，以便屏幕上的名字更改得到更新。更新我们的记录的对象存储操作是“put”。如果成功完成，它会触发成功事件，这会导致我们的代码调用承诺上的“resolve”属性。由于我们返回的是“Promise<void>”类型，因此在调用时可以使用“async”/“await”语法：
- en: '[PRE52]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Our final database method is the `Delete` method. The syntax of the `Delete`
    method is very similar to that of the `Update` method—the only real difference
    is that it just takes the index, which tells it what row to `delete` in the database:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的最终数据库方法是“Delete”方法。“Delete”方法的语法与“Update”方法非常相似——唯一的真正区别是它只接受索引，告诉它在数据库中要“删除”哪一行：
- en: '[PRE53]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Accessing the database from PersonalDetails
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从PersonalDetails访问数据库
- en: 'We can now add database support to our `PersonalDetails` class. The first thing
    we are going to do is update the member variables and constructor to bring in
    the database support and store the list of people we want to display:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的“PersonalDetails”类添加数据库支持。我们要做的第一件事是更新成员变量和构造函数，引入数据库支持并存储我们想要显示的人员列表：
- en: 'First, we add the members:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们添加成员：
- en: '[PRE54]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Next, we update the constructor to hook up to the database and create `TableBuilder`
    using `PersonalDetailsTableBuilder`:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们更新构造函数，连接到数据库并使用“PersonalDetailsTableBuilder”创建“TableBuilder”：
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'One thing that we still have to do is add the ability to show people into our
    `render` method. In a similar way to displaying the validation failures using
    `map`, we are going to apply `map` to the `people` array:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要做的一件事是在我们的“render”方法中添加显示人员的能力。类似于使用“map”显示验证失败的方式，我们将“map”应用于“people”数组：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is then rendered out with the following:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后用以下方式呈现出来：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The Load button is one of a number of places that the `loadPeople` method is
    called from in this class. We will see it in use when we update and then delete
    the records.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: “Load”按钮是在这个类中从“loadPeople”方法调用的许多地方之一。当我们更新然后删除记录时，我们将看到它的使用。
- en: When working with database code, it is common to encounter situations where
    the deletion of a record should not physically delete the record from the database.
    We might not want to physically delete it because another record points to that
    one, and so deleting it will break the other record. Alternatively, we might have
    to keep it in place for auditing purposes. In those cases, it is common to do
    something called a soft delete (a hard delete being the one where the record is
    deleted from the database). With a soft delete, there is a flag on a record that
    indicates whether the record is active. While `IPersonState` does not provide
    this flag, the `PersonRecord` type does because it is an intersection of `IPersonState`
    and `RecordState`. Our `delete` method is going to change `IsActive` to `false`
    and update the database with that value. The code that loads the people already
    understands that it is retrieving records where `IsActive` is `true`, so these
    deleted records will disappear as soon as the list is reloaded. This means that,
    while we wrote a Delete method in our database code, we aren't actually going
    to be using it. It's there as a handy reference and you might want to change the
    code to do a hard delete but this isn't necessary for our purpose.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数据库代码时，通常会遇到情况，其中删除记录不应从数据库中物理删除。我们可能不希望物理删除它，因为另一条记录指向该记录，因此删除它将破坏其他记录。或者，我们可能需要出于审计目的保留它。在这些情况下，通常会执行一种称为软删除的操作（硬删除是从数据库中删除记录的操作）。使用软删除，记录上会有一个指示记录是否活动的标志。虽然`IPersonState`没有提供此标志，但`PersonRecord`类型有，因为它是`IPersonState`和`RecordState`的交集。我们的`delete`方法将把`IsActive`更改为`false`并使用该值更新数据库。加载人员的代码已经理解，它正在检索`IsActive`为`true`的记录，因此这些已删除的记录将在重新加载列表时消失。这意味着，虽然我们在数据库代码中编写了一个删除方法，但我们实际上不会使用它。它作为一个方便的参考，您可能希望更改代码以执行硬删除，但这对我们的目的并不是必要的。
- en: 'The Delete button is going to trigger the delete operation. As there can be
    a number of items in this list, and we cannot assume that the user is going to
    select a person before deleting them, we need to find that person from the list
    of people before we attempt to delete them. Looking back at the code to render
    out the people, we can see that the ID of the person is passed across to the event
    handler. Before we write our event handler, we are going to write the method that
    asynchronously deletes the person from the database. The first thing we are going
    to do in this method is find the person using the `find` array method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 删除按钮将触发删除操作。由于此列表中可能有多个项目，并且我们不能假设用户在删除之前会选择一个人，因此我们需要在尝试删除之前从人员列表中找到该人。回顾渲染人员的代码，我们可以看到人员的ID被传递到事件处理程序。在编写事件处理程序之前，我们将编写一个异步从数据库中删除人员的方法。在此方法中，我们要做的第一件事是使用`find`数组方法找到该人：
- en: '[PRE58]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Assuming that we find the person from the array, we need to get the person
    into a state where we can set `IsActive` to `false`. We start off by creating
    a new instance of `RecordState`, as follows:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们从数组中找到了这个人，我们需要将这个人置于一个状态，以便我们可以将`IsActive`设置为`false`。我们首先创建一个`RecordState`的新实例，如下所示：
- en: '[PRE59]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We have an intersection type, `PersonRecord`, made up of the intersection of
    the person and record states. We are going to spread `foundPerson` and `personState`
    to give us our `PersonRecord` type. With this in place, we are going to call our
    `Update` database method. What we want to do, when our update has completed, is
    reload the list of people and clear the item currently in the editor—just in case
    it''s the one that we have just deleted; we don''t want the user to be able to
    reinstate the record simply because they save it again with `IsActive` set to
    `true`. We are going to use the fact that we can use `await` on code written as
    a promise to wait until the record has been updated before we carry on with the
    processing:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个交集类型，`PersonRecord`，由人和记录状态的交集组成。我们将展开`foundPerson`和`personState`以获得我们的`PersonRecord`类型。有了这个，我们将调用我们的`Update`数据库方法。当更新完成后，我们想要重新加载人员列表并清除编辑器中当前的项目——以防它是我们刚刚删除的项目；我们不希望用户能够简单地再次保存并将`IsActive`设置为`true`来恢复记录。我们将利用我们可以在写成`promise`的代码上使用`await`来等待记录更新完成后再继续处理：
- en: '[PRE60]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `clear` method simply changes the state back to our default state. That''s
    the whole reason we passed it into this component, so that we can easily clear
    the values back to their default state:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`clear`方法只是将状态更改回我们的默认状态。这是我们将其传递到此组件的整个原因，这样我们就可以轻松地将值清除回其默认状态：'
- en: '[PRE61]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Using our `delete` event handler, the full code for this is as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的`delete`事件处理程序，完整的代码如下：
- en: '[PRE62]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The last database operations we need to hook up to are triggered from the Save
    button. What happens with the save depends on whether we have previously saved
    the record, which can be identified by whether `PersonId` is empty. Before we
    attempt to save the record, we have to determine whether it can be saved. This
    comes down to checking whether the validation says we can save or not. If there
    are outstanding validation failures, we are going to alert the users that they
    cannot save the record:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接的最后一个数据库操作是从保存按钮触发的。保存的操作取决于我们之前是否保存了记录，这可以通过`PersonId`是否为空来确定。在尝试保存记录之前，我们必须确定它是否可以保存。这取决于检查验证是否允许我们保存。如果存在未解决的验证失败，我们将通知用户他们无法保存记录：
- en: '[PRE63]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Similarly to how we used the deletion technique, we are going to create our
    `PersonRecord` type by bringing the state together with `RecordState`. This time,
    we set `IsActive` to `true` so that it is picked up as a live record:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们使用删除技术的方式，我们将通过将状态与`RecordState`结合来创建我们的`PersonRecord`类型。这次，我们将`IsActive`设置为`true`，以便它被视为活动记录。
- en: '[PRE64]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'When we insert our record, we need to assign it a unique value for `PersonId`.
    For simplicity, we are just going to use it with the current date and time. When
    we add the person to the database, we reload the list of people and clear the
    current record from the editor so that the user cannot insert a duplicate just
    by clicking on Save again:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们插入记录时，我们需要为`PersonId`分配一个唯一值。为简单起见，我们将使用当前日期和时间。当我们将人员添加到数据库时，我们重新加载人员列表，并从编辑器中清除当前记录，以便用户不能通过再次点击“保存”来插入重复记录：
- en: '[PRE65]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The code to update the person leverages the features of a promise so that the
    list of people is updated immediately after it has finished saving. We do not
    need to clear the current record in this case because if the user clicks on Save
    again, there is no possibility that we are going to create a new record—but we
    will simply update the current one:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 更新人员的代码利用了promise的特性，以便在保存完成后立即更新人员列表。在这种情况下，我们不需要清除当前记录，因为如果用户再次点击“保存”，我们不可能创建一个新记录，而只是更新当前记录：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The completed method for saving is as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 保存的完成方法如下：
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'There is one last method that we need to cover. What you may have noticed is
    that we have no way of selecting and displaying a user in the textboxes when we
    click on the Edit button. Logic dictates that pressing the button should trigger
    an event that passes `PersonId` to an event handler, which we can use to find
    the relevant person from the list; we have already seen this type of behavior
    when using the Delete button, so we have a good idea of what the selection portion
    of the code will look like. Once we have the person, we call `setState` to update
    the state, which will update the display through the power of binding:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要涵盖一个最后的方法。您可能已经注意到，当我们点击“编辑”按钮时，我们没有办法选择并在文本框中显示用户。逻辑推断，按下按钮应该触发一个事件，将`PersonId`传递给事件处理程序，我们可以使用它从列表中找到相关的人；当使用删除按钮时，我们已经看到了这种行为类型，因此我们对代码的选择部分有了一个很好的想法。一旦我们有了这个人，我们调用`setState`来更新状态，这将通过绑定的力量更新显示：
- en: '[PRE68]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We now have all the code we need to build our contact manager with React. We
    have satisfied the requirements that we set out at the start of the chapter and
    our display looks close enough to our mock layout.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了构建React联系人管理器所需的所有代码。我们满足了本章开头设定的要求，并且我们的显示看起来与我们的模拟布局非常接近。
- en: Enhancements
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增强
- en: The `Create` method has a potential problem in that it assumes that it succeeds
    immediately. It does not handle the `success` event for the operation. Additionally,
    there is a further issue in that `add` operations have a `complete` event because
    the `success` event may fire before the record has been successfully written to
    the disk, and, if the transaction fails, the `complete` event is not raised. You
    can convert the `Create` method so that it uses a promise and resumes processing
    when the `success` event is raised. Then, update the insert portion of the component
    to reload once this has been completed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Create`方法存在一个潜在问题，即它假设立即成功。它没有处理操作的`success`事件。此外，还有一个进一步的问题，即`add`操作具有`complete`事件，因为`success`事件可能在记录成功写入磁盘之前触发，如果事务失败，则不会引发`complete`事件。您可以将`Create`方法转换为使用promise，并在引发`success`事件时恢复处理。然后，更新组件的插入部分，以便在完成后重新加载。'
- en: The deletion resets the state even if the user wasn't editing the record that
    was deleted. So, enhance the delete code to only reset the state if the record
    being edited is the same as the one that was deleted.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 删除会重置状态，即使用户没有编辑被删除的记录。因此，增强删除代码，只有在被编辑的记录与被删除的记录相同时才重置状态。
- en: Summary
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced us to the popular React framework and discussed how
    we can use it with TypeScript to build a modern client side application to add
    contact information. We started by defining the requirements and creating a mock
    layout of our application before we created the basic implementation using `create-react-app`
    with the `react-scripts-ts` script version. To leverage Bootstrap 4 in a React-friendly
    way, we added in the `reactstrap` package.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了流行的React框架，并讨论了如何使用TypeScript来构建现代客户端应用程序以添加联系信息。我们首先定义了需求，并在创建基本实现之前，创建了我们应用程序的模拟布局，使用`create-react-app`和`react-scripts-ts`脚本版本。为了以React友好的方式利用Bootstrap
    4，我们添加了`reactstrap`包。
- en: After discussing how React uses the special JSX and TSX formats to control the
    way it renders, we moved on to customizing the `App` component and adding our
    own custom TSX components. With these components, we looked at passing properties
    and setting up state, which we then used to create two-way bindings. With the
    bindings, we discussed how to validate user inputs by creating reusable validators
    that were then applied to validation classes. As part of the validation, we added
    two regular expressions, which we analyzed to understand how they were constructed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了React如何使用特殊的JSX和TSX格式来控制渲染方式之后，我们开始定制`App`组件，并添加了自定义的TSX组件。通过这些组件，我们学习了如何传递属性和设置状态，然后使用它们创建双向绑定。通过这些绑定，我们讨论了如何通过创建可重用的验证器来验证用户输入，然后将其应用于验证类。作为验证的一部分，我们添加了两个正则表达式，并对其进行了分析以了解其构造方式。
- en: Finally, we examined how to save personal information in the IndexedDB database.
    The first part of this was to understand how to build the database and tables
    using table builders, which was complemented by looking at how to work with the
    database. We looked at how to convert a callback-based method to use the promises
    API to provide asynchronous support as well as the difference between soft and
    hard deletes of data.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们研究了如何将个人信息保存在IndexedDB数据库中。这一部分首先是了解如何使用表构建器构建数据库和表，然后是如何操作数据库。我们学习了如何将基于回调的方法转换为使用promises
    API以提供异步支持，以及软删除和硬删除数据之间的区别。
- en: In the next chapter, we are going to move on to using Angular with MongoDB,
    Express, and Node.js, which are collectively known as the MEAN stack, to build
    a photo gallery application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续使用Angular与MongoDB、Express和Node.js，它们合称为MEAN堆栈，来构建一个照片库应用程序。
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What gives React the ability to mix visual elements with code inside the `render`
    method?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么赋予了React在`render`方法中混合视觉元素和代码的能力？
- en: Why does React use `className` and `htmlFor`?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么React使用`className`和`htmlFor`？
- en: We saw that phone numbers can be validated using the regular expression `^(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-.
    ]?(?:[0-9]{3})[-. ]?(?:[0-9]{4})$`. We also discussed that there was an alternative
    way of representing a single digit. How could we convert this expression to give
    exactly the same result with the alternative representation?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看到电话号码可以使用正则表达式`^(?:\\((?:[0-9]{3})\\)|(?:[0-9]{3}))[-. ]?(?:[0-9]{3})[-.
    ]?(?:[0-9]{4})$`进行验证。我们还讨论了表示单个数字的另一种方式。我们如何将这个表达式转换为使用另一种表示方式得到完全相同的结果？
- en: Why do we create validators separately from validation code?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们要将验证器与验证代码分开创建？
- en: What is the difference between a soft delete and a hard delete?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 软删除和硬删除之间有什么区别？
- en: Further reading
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: React is a big topic. In order to find out more about the ideas behind it, I
    recommend *React and React Native* –* Second Edition *([https://www.packtpub.com/application-development/react-and-react-native-second-edition](https://www.packtpub.com/application-development/react-and-react-native-second-edition)).
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React是一个大的话题。为了更多地了解其中的思想，我推荐*React and React Native* –* Second Edition *（[https://www.packtpub.com/application-development/react-and-react-native-second-edition](https://www.packtpub.com/application-development/react-and-react-native-second-edition)）。
- en: For more information on using React with TypeScript, I recommend *Learn React
    with TypeScript 3* by Carl Rippon ([https://www.packtpub.com/web-development/learn-react-typescript-3](https://www.packtpub.com/web-development/learn-react-typescript-3)).
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关在React中使用TypeScript的更多信息，我推荐Carl Rippon的*Learn React with TypeScript 3*（[https://www.packtpub.com/web-development/learn-react-typescript-3](https://www.packtpub.com/web-development/learn-react-typescript-3)）。
- en: Packt also publishes the excellent book *JavaScript Regular Expressions* by
    Loiane Groner and Gabriel Manricks ([https://www.packtpub.com/web-development/javascript-regular-expressions](https://www.packtpub.com/web-development/javascript-regular-expressions)), if
    you want to take your regular expression knowledge to the next level.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Packt还出版了Loiane Groner和Gabriel Manricks的优秀书籍*JavaScript Regular Expressions*（[https://www.packtpub.com/web-development/javascript-regular-expressions](https://www.packtpub.com/web-development/javascript-regular-expressions)），如果你想提升你的正则表达式知识。
