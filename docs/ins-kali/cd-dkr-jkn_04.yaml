- en: Continuous Integration Pipeline
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成管道
- en: We already know how to configure Jenkins. In this chapter, you will see how
    to use it effectively, focusing on the feature that lays at the heart of Jenkins,
    pipelines. By building a complete Continuous Integration process from scratch,
    we will describe all aspects of modern team-oriented code development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道如何配置Jenkins。在本章中，您将看到如何有效地使用它，重点放在Jenkins核心的功能上，即管道。通过从头开始构建完整的持续集成过程，我们将描述现代团队导向的代码开发的所有方面。
- en: 'This chapter covers the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下要点：
- en: Explaining the idea of pipelining
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释管道的概念
- en: Introducing the Jenkins pipeline syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Jenkins管道语法
- en: Creating a Continuous Integration pipeline
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建持续集成管道
- en: Explaining the idea of Jenkinsfile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Jenkinsfile的概念
- en: Creating code quality checks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建代码质量检查
- en: Adding pipeline triggers and notifications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加管道触发器和通知
- en: Explaining development workflows and branching strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释开发工作流程和分支策略
- en: Introducing Jenkins Multibranch
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Jenkins多分支
- en: Introducing pipelines
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍管道
- en: 'A pipeline is a sequence of automated operations that usually represents a
    part of software delivery and the quality assurance process. It can be simply
    seen as a chain of scripts providing the following additional benefits:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一系列自动化操作，通常代表软件交付和质量保证过程的一部分。它可以简单地被看作是一系列脚本，提供以下额外的好处：
- en: '**Operation grouping**: Operations are grouped together into stages (also known
    as **gates** or **quality gates**) that introduce a structure into the process
    and clearly defines the rule: if one stage fails, no further stages are executed'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作分组**：操作被分组到阶段中（也称为**门**或**质量门**），引入了结构到过程中，并清晰地定义了规则：如果一个阶段失败，就不会执行更多的阶段'
- en: '**Visibility**: All aspects of the process are visualized, which help in quick
    failure analysis and promotes team collaboration'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见性**：过程的所有方面都被可视化，这有助于快速分析失败，并促进团队协作'
- en: '**Feedback**: Team members learn about any problems as soon as they occur,
    so they can react quickly'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反馈**：团队成员一旦发现问题，就可以迅速做出反应'
- en: The concept of pipelining is similar for most Continuous Integration tools,
    however, the naming can differ. In this book, we stick to the Jenkins terminology.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的概念对于大多数持续集成工具来说是相似的，但命名可能有所不同。在本书中，我们遵循Jenkins的术语。
- en: Pipeline structure
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道结构
- en: 'A Jenkins pipeline consists of two kinds of elements: stages and steps. The
    following figure shows how they are used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins管道由两种元素组成：阶段和步骤。以下图显示了它们的使用方式：
- en: '![](assets/f0485dcf-1ed8-4ab0-bb5a-7cea1f89a09f.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f0485dcf-1ed8-4ab0-bb5a-7cea1f89a09f.png)'
- en: 'The following are the basic pipeline elements:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基本的管道元素：
- en: '**Step**: A single operation (tells Jenkins what to do, for example, checkout
    code from repository, execute a script)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：单个操作（告诉Jenkins要做什么，例如，从存储库检出代码，执行脚本）'
- en: '**Stage**: A logical separation of steps (groups conceptually distinct sequences
    of steps, for example, **Build, Test,** and **Deploy**) used to visualize the
    Jenkins pipeline progress'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段**：步骤的逻辑分离（概念上区分不同的步骤序列，例如**构建，测试**和**部署**），用于可视化Jenkins管道的进展'
- en: Technically, it's possible to create parallel steps; however, it's better to
    treat it as an exception when really needed for optimization purposes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，可以创建并行步骤；然而，最好将其视为真正需要优化目的时的例外。
- en: Multi-stage Hello World
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多阶段Hello World
- en: 'As an example, let''s extend the `Hello World` pipeline to contain two stages:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们扩展`Hello World`管道，包含两个阶段：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The pipeline has no special requirements in terms of environment (any slave
    agent), and it executes three steps inside two stages. When we click on Build
    Now, we should see the visual representation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 管道在环境方面没有特殊要求（任何从属代理），并在两个阶段内执行三个步骤。当我们点击“立即构建”时，我们应该看到可视化表示：
- en: '![](assets/e654212a-9407-4e1a-9543-e54ee2b15bdf.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e654212a-9407-4e1a-9543-e54ee2b15bdf.png)'
- en: The pipeline succeeded, and we can see the step execution details by clicking
    on the console. If any of the steps failed, the processing would stop and no further
    steps would run. Actually, the entire reason for a pipeline is to prevent all
    further steps from execution and visualize the point of failure.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 管道成功了，我们可以通过单击控制台查看步骤执行详细信息。如果任何步骤失败，处理将停止，不会运行更多的步骤。实际上，管道的整个目的是阻止所有进一步的步骤执行并可视化失败点。
- en: Pipeline syntax
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道语法
- en: We have discussed the pipeline elements and already used a few of the pipeline
    steps, for example, `echo`. What other operations can we use inside the pipeline
    definition?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了管道元素，并已经使用了一些管道步骤，例如`echo`。在管道定义内部，我们还可以使用哪些其他操作？
- en: In this book, we use the declarative syntax that is recommended for all new
    projects. The different options are Groovy-based DSL and (prior to Jenkins 2)
    XML (created via the web interface).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们使用了为所有新项目推荐的声明性语法。不同的选项是基于Groovy的DSL和（在Jenkins 2之前）XML（通过Web界面创建）。
- en: The declarative syntax was designed to make it as simple as possible to understand
    the pipeline, even by the people who do not write code on a daily basis. This
    is why the syntax is limited only to the most important keywords.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性语法旨在使人们尽可能简单地理解管道，即使是那些不经常编写代码的人。这就是为什么语法仅限于最重要的关键字。
- en: 'Let''s prepare an experiment and, before we describe all the details, read
    the following pipeline definition and try to guess what it does:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们准备一个实验，在我们描述所有细节之前，阅读以下管道定义并尝试猜测它的作用：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hopefully, the pipeline didn''t scare you. It is quite complex. Actually, it
    is so complex that it contains all possible Jenkins instructions. To answer the
    experiment puzzle, let''s see what the pipeline does instruction by instruction:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 希望管道没有吓到你。它相当复杂。实际上，它是如此复杂，以至于它包含了所有可能的Jenkins指令。为了回答实验谜题，让我们逐条看看管道的执行指令：
- en: Use any available agent.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何可用的代理。
- en: Execute automatically every minute.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每分钟自动执行。
- en: Stop if the execution takes more than 5 minutes.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果执行时间超过5分钟，请停止。
- en: Ask for the Boolean input parameter before starting.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在开始之前要求布尔输入参数。
- en: Set `Rafal` as the environment variable NAME.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Rafal`设置为环境变量NAME。
- en: 'Only in the case of the `true` input parameter:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在`true`输入参数的情况下：
- en: Print `Hello from Rafal`
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`来自Rafal的问候`
- en: Print `Testing the chrome browser`
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`测试chrome浏览器`
- en: Print `Testing the firefox browser`
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印`测试firefox浏览器`
- en: Print `I will always say Hello again!` no matter if there are any errors during
    the execution.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论执行过程中是否出现任何错误，都打印`我总是会说再见！`
- en: Let's describe the most important Jenkins keywords. A declarative pipeline is
    always specified inside the `pipeline` block and contains sections, directives,
    and steps. We will walk through each of them.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述最重要的Jenkins关键字。声明性管道总是在`pipeline`块内指定，并包含部分、指令和步骤。我们将逐个讨论它们。
- en: The complete pipeline syntax description can be found on the official Jenkins
    page at [https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的管道语法描述可以在官方Jenkins页面上找到[https://jenkins.io/doc/book/pipeline/syntax/](https://jenkins.io/doc/book/pipeline/syntax/)。
- en: Sections
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分
- en: 'Sections define the pipeline structure and usually contain one or more directives
    or steps. They are defined with the following keywords:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 部分定义了流水线的结构，通常包含一个或多个指令或步骤。它们使用以下关键字进行定义：
- en: '**Stages**: This defines a series of one or more stage directives'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段**：这定义了一系列一个或多个阶段指令'
- en: '**Steps**: This defines a series of one or more step instructions'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**步骤**：这定义了一系列一个或多个步骤指令'
- en: '**Post**: This defines a series of one or more step instructions that are run
    at the end of the pipeline build; marked with a condition (for example, always,
    success, or failure), usually used to send notifications after the pipeline build
    (we will cover this in detail in the *Triggers and notifications* section.)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后置**：这定义了在流水线构建结束时运行的一个或多个步骤指令序列；标有条件（例如always，success或failure），通常用于在流水线构建后发送通知（我们将在*触发器和通知*部分详细介绍）。'
- en: Directives
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指令
- en: 'Directives express the configuration of a pipeline or its parts:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 指令表达了流水线或其部分的配置：
- en: '**Agent**: This specifies where the execution takes place and can define the
    `label` to match the equally labeled agents or `docker` to specify a container
    that is dynamically provisioned to provide an environment for the pipeline execution'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理**：这指定执行的位置，并可以定义`label`以匹配同样标记的代理，或者使用`docker`来指定动态提供环境以执行流水线的容器'
- en: '**Triggers**: This defines automated ways to trigger the pipeline and can use
    `cron` to set the time-based scheduling or `pollScm` to check the repository for
    changes (we will cover this in detail in the *Triggers and notifications* section)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：这定义了触发流水线的自动方式，可以使用`cron`来设置基于时间的调度，或者使用`pollScm`来检查仓库的更改（我们将在*触发器和通知*部分详细介绍）
- en: '**Options**: This specifies pipeline-specific options, for example, `timeout` (maximum
    time of pipeline run) or `retry` (number of times the pipeline should be rerun
    after failure)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选项**：这指定了特定于流水线的选项，例如`timeout`（流水线运行的最长时间）或`retry`（流水线在失败后应重新运行的次数）'
- en: '**Environment**: This defines a set of key values used as environment variables
    during the build'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境**：这定义了在构建过程中用作环境变量的一组键值'
- en: '**Parameters**: This defines a list of user-input parameters'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这定义了用户输入参数的列表'
- en: '**Stage**: This allows for logical grouping of steps'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阶段**：这允许对步骤进行逻辑分组'
- en: '**When**: This determines whether the stage should be executed depending on
    the given condition'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**当**：这确定阶段是否应根据给定条件执行'
- en: Steps
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步骤
- en: Steps are the most fundamental part of the pipeline. They define the operations
    that are executed, so they actually tell Jenkins **what to do**.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤是流水线最基本的部分。它们定义了要执行的操作，因此它们实际上告诉Jenkins**要做什么**。
- en: '**sh**: This executes the shell command; actually, it''s possible to define
    almost any operation using `sh`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**sh**：这执行shell命令；实际上，几乎可以使用`sh`来定义任何操作'
- en: '**custom**: Jenkins offers a lot of operations that can be used as steps (for
    example, `echo`); many of them are simply wrappers over the `sh` command used
    for convenience; plugins can also define their own operations'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：Jenkins提供了许多可用作步骤的操作（例如`echo`）；其中许多只是用于方便的`sh`命令的包装器；插件也可以定义自己的操作'
- en: '**script**: This executes a block of the Groovy-based code that can be used
    for some non-trivial scenarios, where flow control is needed'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本**：这执行基于Groovy的代码块，可用于一些需要流程控制的非常规情况'
- en: The complete specification of the available steps can be found at: [https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可用步骤的完整规范可以在以下网址找到：[https://jenkins.io/doc/pipeline/steps/](https://jenkins.io/doc/pipeline/steps/)。
- en: Notice that the pipeline syntax is very generic and technically, can be used
    for almost any automation process. This is why the pipeline should be treated
    as a method of structurization and visualization. The most common use case is,
    however, implementing the Continuous Integration server that we will look at in
    the following section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，流水线语法非常通用，从技术上讲，几乎可以用于任何自动化流程。这就是为什么应该将流水线视为一种结构化和可视化的方法。然而，最常见的用例是实现我们将在下一节中看到的持续集成服务器。
- en: Commit pipeline
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交流水线
- en: The most basic Continuous Integration process is called a commit pipeline. This
    classic phase, as its name says, starts with a commit (or push in Git) to the
    main repository and results in a report about the build success or failure. Since
    it runs after each change in the code, the build should take no more than 5 minutes
    and should consume a reasonable amount of resources. The commit phase is always
    the starting point of the Continuous Delivery process, and it provides the most
    important feedback cycle in the development process, constant information if the
    code is in a healthy state.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的持续集成流程称为提交流水线。这个经典阶段，顾名思义，从主存储库提交（或在Git中推送）开始，并导致构建成功或失败的报告。由于它在代码每次更改后运行，构建时间不应超过5分钟，并且应消耗合理数量的资源。提交阶段始终是持续交付流程的起点，并且在开发过程中提供了最重要的反馈循环，不断提供代码是否处于健康状态的信息。
- en: 'The commit phase works as follows. A developer checks in the code to the repository,
    the Continuous Integration server detects the change, and the build starts. The
    most fundamental commit pipeline contains three stages:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提交阶段的工作如下。开发人员将代码提交到存储库，持续集成服务器检测到更改，构建开始。最基本的提交流水线包含三个阶段：
- en: '**Checkout**: This stage downloads the source code from the repository'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检出**：此阶段从存储库下载源代码'
- en: '**Compile**: This stage compiles the source code'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译**：此阶段编译源代码'
- en: '**Unit test**: This stage runs a suite of unit tests'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：此阶段运行一套单元测试'
- en: Let's create a sample project and see how to implement the commit pipeline.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个示例项目，看看如何实现提交流水线。
- en: This is an example of a pipeline for the project that uses technologies such
    as Git, Java, Gradle, and Spring Boot. Nevertheless, the same principles apply
    to any other technology.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用Git、Java、Gradle和Spring Boot等技术的项目的流水线示例。然而，相同的原则适用于任何其他技术。
- en: Checkout
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检出
- en: Checking out code from the repository is always the first operation in any pipeline.
    In order to see this, we need to have a repository. Then, we will be able to create
    a pipeline.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从存储库检出代码始终是任何流水线中的第一个操作。为了看到这一点，我们需要有一个存储库。然后，我们将能够创建一个流水线。
- en: Creating a GitHub repository
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建GitHub存储库
- en: 'Creating a repository on the GitHub server takes just a few steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub服务器上创建存储库只需几个步骤：
- en: Go to the [https://github.com/](https://github.com/) page.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[https://github.com/](https://github.com/)页面。
- en: Create an account if you don't have one yet.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果还没有帐户，请创建一个。
- en: Click on New repository.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新存储库”。
- en: Give it a name, `calculator`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它一个名字，“calculator”。
- en: Tick Initialize this repository with a README.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选中“使用README初始化此存储库”。
- en: Click on Create repository.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建存储库”。
- en: Now, you should see the address of the repository, for example, `https://github.com/leszko/calculator.git`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该看到存储库的地址，例如`https://github.com/leszko/calculator.git`。
- en: Creating a checkout stage
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个检出阶段
- en: 'We can create a new pipeline called `calculator` and, as **Pipeline script**,
    put the code with a stage called Checkout:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个名为“calculator”的新流水线，并将代码放在一个名为Checkout的阶段的**流水线脚本**中：
- en: '[PRE2]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The pipeline can be executed on any of the agents, and its only step does nothing
    more than downloading code from the repository. We can click on Build Now and
    see if it was executed successfully.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线可以在任何代理上执行，它的唯一步骤只是从存储库下载代码。我们可以点击“立即构建”并查看是否成功执行。
- en: Note that the Git toolkit needs to be installed on the node where the build
    is executed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Git工具包需要安装在执行构建的节点上。
- en: When we have the checkout, we're ready for the second stage.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成检出时，我们准备进行第二阶段。
- en: Compile
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译
- en: 'In order to compile a project, we need to:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编译一个项目，我们需要：
- en: Create a project with the source code.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有源代码的项目。
- en: Push it to the repository.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其推送到存储库。
- en: Add the Compile stage to the pipeline.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将编译阶段添加到流水线。
- en: Creating a Java Spring Boot project
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Java Spring Boot项目
- en: Let's create a very simple Java project using the Spring Boot framework built
    by Gradle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用Gradle构建的Spring Boot框架创建一个非常简单的Java项目。
- en: Spring Boot is a Java framework that simplifies building enterprise applications.
    Gradle is a build automation system that is based on the concepts of Apache Maven.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot是一个简化构建企业应用程序的Java框架。Gradle是一个基于Apache Maven概念的构建自动化系统。
- en: 'The simplest way to create a Spring Boot project is to perform the following
    steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 创建Spring Boot项目的最简单方法是执行以下步骤：
- en: Go to the [http://start.spring.io/](http://start.spring.io/) page.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到[http://start.spring.io/](http://start.spring.io/)页面。
- en: Select Gradle project instead of Maven project (you can also leave Maven if
    you prefer it to Gradle).
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Gradle项目而不是Maven项目（如果您更喜欢Maven，也可以保留Maven）。
- en: Fill Group and Artifact (for example, `com.leszko` and `calculator`).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写组和Artifact（例如，`com.leszko`和`calculator`）。
- en: Add Web to Dependencies.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Web添加到依赖项。
- en: Click on Generate Project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击生成项目。
- en: The generated skeleton project should be downloaded (the `calculator.zip` file).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应下载生成的骨架项目（`calculator.zip`文件）。
- en: 'The following screenshot presents the [http://start.spring.io/](http://start.spring.io/)
    page:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了[http://start.spring.io/](http://start.spring.io/)页面：
- en: '![](assets/f7679438-1eed-48ca-be76-8fc68853701d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f7679438-1eed-48ca-be76-8fc68853701d.png)'
- en: Pushing code to GitHub
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码推送到GitHub
- en: 'We will use the Git tool to perform the `commit` and `push` operations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Git工具执行`commit`和`push`操作：
- en: In order to run the `git` command, you need to have the Git toolkit installed
    (it can be downloaded from [https://git-scm.com/downloads](https://git-scm.com/downloads)).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行`git`命令，您需要安装Git工具包（可以从[https://git-scm.com/downloads](https://git-scm.com/downloads)下载）。
- en: 'Let''s first clone the repository to the filesystem:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先将存储库克隆到文件系统：
- en: '[PRE3]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Extract the project downloaded from [http://start.spring.io/](http://start.spring.io/)
    into the directory created by Git.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 将从[http://start.spring.io/](http://start.spring.io/)下载的项目解压到Git创建的目录中。
- en: If you prefer, you can import the project into IntelliJ, Eclipse, or your favorite
    IDE tool.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以将项目导入到IntelliJ、Eclipse或您喜欢的IDE工具中。
- en: 'As a result, the `calculator` directory should have the following files:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，`calculator`目录应该有以下文件：
- en: '[PRE4]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In order to perform the Gradle operations locally, you need to have Java JDK
    installed (in Ubuntu, you can do it by executing `sudo apt-get install -y default-jdk`).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地执行Gradle操作，您需要安装Java JDK（在Ubuntu中，您可以通过执行`sudo apt-get install -y default-jdk`来完成）。
- en: 'We can compile the project locally using the following code:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在本地编译项目：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the case of Maven, you can run `./mvnw compile`. Both Gradle and Maven compile
    the Java classes located in the `src` directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven的情况下，您可以运行`./mvnw compile`。Gradle和Maven都编译`src`目录中的Java类。
- en: You can find all possible Gradle instructions (for the Java project) at [https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.gradle.org/current/userguide/java_plugin.html](https://docs.gradle.org/current/userguide/java_plugin.html)找到所有可能的Gradle指令（用于Java项目）。
- en: 'Now, we can `commit` and `push` to the GitHub repository:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其`commit`和`push`到GitHub存储库中：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After running the `git push` command, you will be prompted to enter the GitHub
    credentials (username and password).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`git push`命令后，您将被提示输入GitHub凭据（用户名和密码）。
- en: The code is already in the GitHub repository. If you want to check it, you can
    go to the GitHub page and see the files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 代码已经在GitHub存储库中。如果您想检查它，可以转到GitHub页面并查看文件。
- en: Creating a compile stage
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个编译阶段
- en: 'We can add a `Compile` stage to the pipeline using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在管道中添加一个`编译`阶段：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we used exactly the same command locally and in the Jenkins pipeline,
    which is a very good sign because the local development process is consistent
    with the Continuous Integration environment. After running the build, you should
    see two green boxes. You can also check that the project was compiled correctly
    in the console log.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在本地和Jenkins管道中使用了完全相同的命令，这是一个非常好的迹象，因为本地开发过程与持续集成环境保持一致。运行构建后，您应该看到两个绿色的框。您还可以在控制台日志中检查项目是否已正确编译。
- en: Unit test
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'It''s time to add the last stage that is Unit test, which checks if our code
    does what we expect it to do. We have to:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候添加最后一个阶段了，即单元测试，检查我们的代码是否符合预期。我们必须：
- en: Add the source code for the calculator logic
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加计算器逻辑的源代码
- en: Write unit test for the code
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为代码编写单元测试
- en: Add a stage to execute the unit test
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个阶段来执行单元测试
- en: Creating business logic
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建业务逻辑
- en: 'The first version of the calculator will be able to add two numbers. Let''s
    add the business logic as a class in the `src/main/java/com/leszko/calculator/Calculator.java` file:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 计算器的第一个版本将能够添加两个数字。让我们将业务逻辑作为一个类添加到`src/main/java/com/leszko/calculator/Calculator.java`文件中：
- en: '[PRE8]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To execute the business logic, we also need to add the web service controller
    in a separate file `src/main/java/com/leszko/calculator/CalculatorController.java`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行业务逻辑，我们还需要在单独的文件`src/main/java/com/leszko/calculator/CalculatorController.java`中添加网络服务控制器：
- en: '[PRE9]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This class exposes the business logic as a web service. We can run the application
    and see how it works:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将业务逻辑公开为一个网络服务。我们可以运行应用程序并查看它的工作方式：
- en: '[PRE10]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It should start our web service and we can check that it works by navigating
    to the browser and opening the page `http://localhost:8080/sum?a=1&b=2`. This
    should sum two numbers ( `1` and `2`) and show `3` in the browser.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该启动我们的网络服务，我们可以通过浏览器导航到页面`http://localhost:8080/sum?a=1&b=2`来检查它是否工作。这应该对两个数字（`1`和`2`）求和，并在浏览器中显示`3`。
- en: Writing a unit test
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: We already have the working application. How can we ensure that the logic works
    as expected? We have tried it once, but in order to know constantly, we need a
    unit test. In our case, it will be trivial, maybe even unnecessary; however, in
    real projects, unit tests can save from bugs and system failures.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了可工作的应用程序。我们如何确保逻辑按预期工作？我们已经尝试过一次，但为了不断了解，我们需要进行单元测试。在我们的情况下，这可能是微不足道的，甚至是不必要的；然而，在实际项目中，单元测试可以避免错误和系统故障。
- en: 'Let''s create a unit test in the file `src/test/java/com/leszko/calculator/CalculatorTest.java`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在文件`src/test/java/com/leszko/calculator/CalculatorTest.java`中创建一个单元测试：
- en: '[PRE11]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can run the test locally using the `./gradlew test` command. Then, let''s
    `commit` the code and `push` it to the repository:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`./gradlew test`命令在本地运行测试。然后，让我们`commit`代码并将其`push`到存储库中：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating a unit test stage
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个单元测试阶段
- en: 'Now, we can add a `Unit test` stage to the pipeline:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在管道中添加一个`单元测试`阶段：
- en: '[PRE13]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the case of Maven, we would have to use `./mvnw test`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Maven的情况下，我们需要使用`./mvnw test`。
- en: 'When we build the pipeline again, we should see three boxes, which means that
    we''ve completed the Continuous Integration pipeline:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次构建流水线时，我们应该看到三个框，这意味着我们已经完成了持续集成流水线：
- en: '![](assets/ee925c80-529f-4732-8a8e-57c41190cf79.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ee925c80-529f-4732-8a8e-57c41190cf79.png)'
- en: Jenkinsfile
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkinsfile
- en: All the time, so far, we created the pipeline code directly in Jenkins. This
    is, however, not the only option. We can also put the pipeline definition inside
    a file called `Jenkinsfile` and `commit` it to the repository together with the
    source code. This method is even more consistent because the way your pipeline
    looks is strictly related to the project itself.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直直接在Jenkins中创建流水线代码。然而，这并不是唯一的选择。我们还可以将流水线定义放在一个名为`Jenkinsfile`的文件中，并将其与源代码一起`commit`到存储库中。这种方法更加一致，因为流水线的外观与项目本身密切相关。
- en: For example, if you don't need the code compilation because your programming
    language is interpreted (and not compiled), then you won't have the `Compile`
    stage. The tools you use also differ depending on the environment. We used Gradle/Maven
    because we've built the Java project; however, in the case of a project written
    in Python, you could use PyBuilder. It leads to the idea that the pipelines should
    be created by the same people who write the code, developers. Also, the pipeline
    definition should be put together with the code, in the repository.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您不需要代码编译，因为您的编程语言是解释性的（而不是编译的），那么您将不会有`Compile`阶段。您使用的工具也取决于环境。我们使用Gradle/Maven，因为我们构建了Java项目；然而，对于用Python编写的项目，您可以使用PyBuilder。这导致了一个想法，即流水线应该由编写代码的同一人员，即开发人员创建。此外，流水线定义应与代码一起放在存储库中。
- en: 'This approach brings immediate benefits, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法带来了即时的好处，如下所示：
- en: In case of Jenkins' failure, the pipeline definition is not lost (because it's
    stored in the code repository, not in Jenkins)
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins失败的情况下，流水线定义不会丢失（因为它存储在代码存储库中，而不是在Jenkins中）
- en: The history of the pipeline changes is stored
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线更改的历史记录被存储
- en: Pipeline changes go through the standard code development process (for example,
    they are subjected to code reviews)
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流水线更改经过标准的代码开发过程（例如，它们要经过代码审查）
- en: Access to the pipeline changes is restricted exactly in the same way as the
    access to the source code
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对流水线更改的访问受到与对源代码访问完全相同的限制
- en: Creating Jenkinsfile
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Jenkinsfile
- en: We can create the `Jenkinsfile` and push it to our GitHub repository. Its content
    is almost the same as the commit pipeline we wrote. The only difference is that
    the checkout stage becomes redundant because Jenkins has to checkout the code
    (together with `Jenkinsfile`) first and then read the pipeline structure (from
    `Jenkinsfile`). This is why Jenkins needs to know the repository address before
    it reads `Jenkinsfile`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`Jenkinsfile`并将其推送到我们的GitHub存储库。它的内容几乎与我们编写的提交流水线相同。唯一的区别是，检出阶段变得多余，因为Jenkins必须首先检出代码（与`Jenkinsfile`一起），然后读取流水线结构（从`Jenkinsfile`）。这就是为什么Jenkins在读取`Jenkinsfile`之前需要知道存储库地址。
- en: 'Let''s create a file called `Jenkinsfile` in the root directory of our project:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目的根目录中创建一个名为`Jenkinsfile`的文件：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can now `commit` the added files and `push` to the GitHub repository:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以`commit`添加的文件并`push`到GitHub存储库：
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Running pipeline from Jenkinsfile
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Jenkinsfile运行流水线
- en: 'When `Jenkinsfile` is in the repository, then all we have to do is to open
    the pipeline configuration and in the `Pipeline` section:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当`Jenkinsfile`在存储库中时，我们所要做的就是打开流水线配置，在`Pipeline`部分：
- en: Change Definition from `Pipeline script` to `Pipeline script from SCM`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将定义从`Pipeline script`更改为`Pipeline script from SCM`
- en: Select Git in SCM
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在SCM中选择Git
- en: Put `https://github.com/leszko/calculator.git` in Repository URL
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`https://github.com/leszko/calculator.git`放入存储库URL
- en: '![](assets/2abce73b-7789-4457-9252-7eff8f912dbf.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/2abce73b-7789-4457-9252-7eff8f912dbf.png)
- en: After saving, the build will always run from the current version of Jenkinsfile
    into the repository.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 保存后，构建将始终从Jenkinsfile的当前版本运行到存储库中。
- en: We have successfully created the first complete commit pipeline. It can be treated
    as a minimum viable product, and actually, in many cases, it's sufficient as the
    Continuous Integration process. In the next sections, we will see what improvements
    can be done to make the commit pipeline even better.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已成功创建了第一个完整的提交流水线。它可以被视为最小可行产品，并且实际上，在许多情况下，它作为持续集成流程是足够的。在接下来的章节中，我们将看到如何改进提交流水线以使其更好。
- en: Code quality stages
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码质量阶段
- en: We can extend the classic three steps of Continuous Integration with additional
    steps. The most widely used are code coverage and static analysis. Let's look
    at each of them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过额外的步骤扩展经典的持续集成三个步骤。最常用的是代码覆盖和静态分析。让我们分别看看它们。
- en: Code coverage
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖
- en: 'Think about the following scenario: you have a well-configured Continuous Integration
    process; however, nobody in your project writes unit tests. It passes all the
    builds, but it doesn''t mean that the code is working as expected. What to do
    then? How to ensure that the code is tested?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下情景：您有一个良好配置的持续集成流程；然而，项目中没有人编写单元测试。它通过了所有构建，但这并不意味着代码按预期工作。那么该怎么办？如何确保代码已经测试过了？
- en: The solution is to add the code coverage tool that runs all tests and verifies
    which parts of the code have been executed. Then, it creates a report showing
    not-tested sections. Moreover, we can make the build fail when there is too much
    untested code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是添加代码覆盖工具，运行所有测试并验证代码的哪些部分已执行。然后，它创建一个报告显示未经测试的部分。此外，当未经测试的代码太多时，我们可以使构建失败。
- en: There are a lot of tools available to perform the test coverage analysis; for
    Java, the most popular are JaCoCo, Clover, and Cobertura.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可用于执行测试覆盖分析；对于Java来说，最流行的是JaCoCo、Clover和Cobertura。
- en: 'Let''s use JaCoCo and show how the coverage check works in practice. In order
    to do this, we need to perform the following steps:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用JaCoCo并展示覆盖检查在实践中是如何工作的。为了做到这一点，我们需要执行以下步骤：
- en: Add JaCoCo to the Gradle configuration.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将JaCoCo添加到Gradle配置中。
- en: Add the code coverage stage to the pipeline.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将代码覆盖阶段添加到流水线中。
- en: Optionally, publish JaCoCo reports in Jenkins.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在Jenkins中发布JaCoCo报告。
- en: Adding JaCoCo to Gradle
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JaCoCo添加到Gradle
- en: 'In order to run JaCoCo from Gradle, we need to add the `jacoco` plugin to the
    `build.gradle` file by adding the following line in the plugin section:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从Gradle运行JaCoCo，我们需要通过在插件部分添加以下行将`jacoco`插件添加到`build.gradle`文件中：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, if we would like to make the Gradle fail in case of too low code coverage,
    we can add the following configuration to the `build.gradle` file as well:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们希望在代码覆盖率过低的情况下使Gradle失败，我们还可以将以下配置添加到`build.gradle`文件中：
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This configuration sets the minimum code coverage to 20%. We can run it with
    the following command:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置将最小代码覆盖率设置为20%。我们可以使用以下命令运行它：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The command checks if the code coverage is at least 20%. You can play with
    the minimum value to see the level at which the build fails. We can also generate
    a test coverage report using the following command:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令检查代码覆盖率是否至少为20%。您可以尝试不同的最小值来查看构建失败的级别。我们还可以使用以下命令生成测试覆盖报告：
- en: '[PRE19]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can also have a look at the full coverage report in the `build/reports/jacoco/test/html/index.html` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在`build/reports/jacoco/test/html/index.html`文件中查看完整的覆盖报告：
- en: '![](assets/f40840a3-e0e7-47f2-810c-53cd492ae0f6.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: ！[](assets/f40840a3-e0e7-47f2-810c-53cd492ae0f6.png)
- en: Adding a code coverage stage
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加代码覆盖阶段
- en: 'Adding a code coverage stage to the pipeline is as simple as the previous stages:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码覆盖率阶段添加到流水线中与之前的阶段一样简单：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After adding this stage, if anyone commits code that is not well-covered with
    tests, the build will fail.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了这个阶段后，如果有人提交了未经充分测试的代码，构建将失败。
- en: Publishing the code coverage report
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布代码覆盖率报告
- en: When the coverage is low and the pipeline fails, it would be useful to look
    at the code coverage report and find what parts are not yet covered with tests.
    We could run Gradle locally and generate the coverage report; however, it is more
    convenient if Jenkins shows the report for us.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当覆盖率低且流水线失败时，查看代码覆盖率报告并找出尚未通过测试的部分将非常有用。我们可以在本地运行Gradle并生成覆盖率报告；然而，如果Jenkins为我们显示报告会更方便。
- en: 'In order to publish the code coverage report in Jenkins, we need the following
    stage definition:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Jenkins中发布代码覆盖率报告，我们需要以下阶段定义：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This stage copies the generated JaCoCo report to the Jenkins output. When we
    run the build again, we should see a link to the code coverage reports (in the
    menu on the left side, below "Build Now").
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此阶段将生成的JaCoCo报告复制到Jenkins输出。当我们再次运行构建时，我们应该会看到代码覆盖率报告的链接（在左侧菜单下方的“立即构建”下）。
- en: To perform the `publishHTML` step, you need to have the **HTML Publisher** plugin
    installed in Jenkins. You can read more about the plugin at [https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports](https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`publishHTML`步骤，您需要在Jenkins中安装**HTML Publisher**插件。您可以在[https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports](https://jenkins.io/doc/pipeline/steps/htmlpublisher/#publishhtml-publish-html-reports)了解有关该插件的更多信息。
- en: We have created the code coverage stage, which shows the code that is not tested
    and therefore vulnerable to bugs. Let's see what else can be done in order to
    improve the code quality.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了代码覆盖率阶段，显示了未经测试且因此容易出现错误的代码。让我们看看还可以做些什么来提高代码质量。
- en: If you need code coverage that is more strict, you can check the concept of
    mutation testing and add the PIT framework stage to the pipeline. Read more at [http://pitest.org/](http://pitest.org/).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更严格的代码覆盖率，可以检查变异测试的概念，并将PIT框架阶段添加到流水线中。在[http://pitest.org/](http://pitest.org/)了解更多信息。
- en: Static code analysis
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态代码分析
- en: Your code may work perfectly fine, however, what about the quality of the code
    itself? How do we ensure it is maintainable and written in a good style?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码可能运行得很好，但是代码本身的质量如何呢？我们如何确保它是可维护的并且以良好的风格编写的？
- en: Static code analysis is an automatic process of checking the code without actually
    executing it. In most cases, it implies checking a number of rules on the source
    code. These rules may apply to a wide range of aspects; for example, all public
    classes need to have a Javadoc comment; the maximum length of a line is 120 characters,
    or if a class defines the `equals()` method, it has to define the `hashCode()`
    method as well.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析是一种自动检查代码而不实际执行的过程。在大多数情况下，它意味着对源代码检查一系列规则。这些规则可能适用于各种方面；例如，所有公共类都需要有Javadoc注释；一行的最大长度是120个字符，或者如果一个类定义了`equals()`方法，它也必须定义`hashCode()`方法。
- en: 'The most popular tools to perform the static analysis on the Java code are
    Checkstyle, FindBugs, and PMD. Let''s look at an example and add the static code
    analysis stage using Checkstyle. We will do this in three steps:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对Java代码进行静态分析的最流行工具是Checkstyle、FindBugs和PMD。让我们看一个例子，并使用Checkstyle添加静态代码分析阶段。我们将分三步完成这个过程：
- en: Add the Checkstyle configuration.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Checkstyle配置。
- en: Add the Checkstyle stage.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加Checkstyle阶段。
- en: Optionally, publish the Checkstyle report in Jenkins.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可选地，在Jenkins中发布Checkstyle报告。
- en: Adding the Checkstyle configuration
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加Checkstyle配置
- en: 'In order to add the Checkstyle configuration, we need to define the rules against
    which the code is checked. We can do this by specifying the `config/checkstyle/checkstyle.xml` file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加Checkstyle配置，我们需要定义代码检查的规则。我们可以通过指定`config/checkstyle/checkstyle.xml`文件来做到这一点：
- en: '[PRE22]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The configuration contains only one rule: Checking if public classes, interfaces,
    and enums are documented with Javadoc. If they are not, the build fails.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 配置只包含一个规则：检查公共类、接口和枚举是否用Javadoc记录。如果没有，构建将失败。
- en: The complete Checkstyle description can be found at [http://checkstyle.sourceforge.net/config.html](http://checkstyle.sourceforge.net/config.html).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的Checkstyle描述可以在[http://checkstyle.sourceforge.net/config.html](http://checkstyle.sourceforge.net/config.html)找到。
- en: 'We also need to add the `checkstyle` plugin to the `build.gradle` file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将“checkstyle”插件添加到“build.gradle”文件中：
- en: '[PRE23]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, we can run the `checkstyle` with the following code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以运行以下代码来运行`checkstyle`：
- en: '[PRE24]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the case of our project, it should result in a failure because none of our
    public classes (`Calculator.java`, `CalculatorApplication.java`, `CalculatorTest.java`, `CalculatorApplicationTests.java`) has
    a Javadoc comment. We need to fix it by adding the documentation, for example,
    in case of the `src/main/java/com/leszko/calculator/CalculatorApplication.java` file:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，这应该会导致失败，因为我们的公共类（`Calculator.java`，`CalculatorApplication.java`，`CalculatorTest.java`，`CalculatorApplicationTests.java`）都没有Javadoc注释。我们需要通过添加文档来修复它，例如，在`src/main/java/com/leszko/calculator/CalculatorApplication.java`文件中：
- en: '[PRE25]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, the build should be successful.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，构建应该成功。
- en: Adding a static code analysis stage
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态代码分析阶段
- en: 'We can add a `Static code analysis` stage to the pipeline:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在流水线中添加一个“静态代码分析”阶段：
- en: '[PRE26]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, if anyone commits a file with a public class without Javadoc, the build
    will fail.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果有人提交了一个没有Javadoc的公共类文件，构建将失败。
- en: Publishing static code analysis reports
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布静态代码分析报告
- en: 'Very similar to JaCoCo, we can add the Checkstyle report to Jenkins:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 与JaCoCo非常相似，我们可以将Checkstyle报告添加到Jenkins中：
- en: '[PRE27]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It generates a link to the Checkstyle report.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它会生成一个指向Checkstyle报告的链接。
- en: We have added the static code analysis stage that can help in finding bugs and
    in standardizing the code style inside the team or organization.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了静态代码分析阶段，可以帮助找到错误并在团队或组织内标准化代码风格。
- en: SonarQube
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SonarQube
- en: SonarQube is the most widespread source code quality management tool. It supports
    multiple programming languages and can be treated as an alternative to the code
    coverage and static code analysis steps we looked at. Actually, it is a separate
    server that aggregates different code analysis frameworks, such as Checkstyle,
    FindBugs, and JaCoCo. It has its own dashboards and integrates well with Jenkins.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: SonarQube是最广泛使用的源代码质量管理工具。它支持多种编程语言，并且可以作为我们查看的代码覆盖率和静态代码分析步骤的替代品。实际上，它是一个单独的服务器，汇总了不同的代码分析框架，如Checkstyle、FindBugs和JaCoCo。它有自己的仪表板，并且与Jenkins集成良好。
- en: Instead of adding code quality steps to the pipeline, we can install SonarQube,
    add plugins there, and add a "sonar" stage to the pipeline. The advantage of this
    solution is that SonarQube provides a user-friendly web interface to configure
    rules and show code vulnerabilities.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与将代码质量步骤添加到流水线不同，我们可以安装SonarQube，在那里添加插件，并在流水线中添加一个“sonar”阶段。这种解决方案的优势在于，SonarQube提供了一个用户友好的Web界面来配置规则并显示代码漏洞。
- en: You can read more about SonarQube on its official page [https://www.sonarqube.org/](https://www.sonarqube.org/).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在其官方页面[https://www.sonarqube.org/](https://www.sonarqube.org/)上阅读有关SonarQube的更多信息。
- en: Triggers and notifications
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器和通知
- en: So far, we have always built the pipeline manually by clicking on the Build
    Now button. It works but is not very convenient. All team members would have to
    remember that after committing to the repository, they need to open Jenkins and
    start the build. The same works with pipeline monitoring; so far, we manually
    opened Jenkins and checked the build status. In this section, we will see how
    to improve the process so that the pipeline would start automatically and, when
    completed, notify the team members about its status.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直通过点击“立即构建”按钮手动构建流水线。这样做虽然有效，但不太方便。所有团队成员都需要记住，在提交到存储库后，他们需要打开Jenkins并开始构建。流水线监控也是一样；到目前为止，我们手动打开Jenkins并检查构建状态。在本节中，我们将看到如何改进流程，使得流水线可以自动启动，并在完成后通知团队成员其状态。
- en: Triggers
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发器
- en: 'An automatic action to start the build is called the pipeline trigger. In Jenkins,
    there are many options to choose from; however, they all boil down to three types:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 自动启动构建的操作称为流水线触发器。在Jenkins中，有许多选择，但它们都归结为三种类型：
- en: External
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部
- en: Polling SCM (Source Control Management)
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轮询SCM（源代码管理）
- en: Scheduled build
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时构建
- en: Let's take a look at each of them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每一个。
- en: External
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部
- en: External triggers are natural to understand. They mean that Jenkins starts the
    build after it's called by the notifier, which can be the other pipeline build,
    the SCM system (for example, GitHub), or any remote script.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 外部触发器很容易理解。它意味着Jenkins在被通知者调用后开始构建，通知者可以是其他流水线构建、SCM系统（例如GitHub）或任何远程脚本。
- en: 'The following figure presents the communication:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了通信：
- en: '![](assets/51bf1a24-ebcd-48de-b743-4bea791ba412.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/51bf1a24-ebcd-48de-b743-4bea791ba412.png)'
- en: GitHub triggers Jenkins after a push to the repository and the build is started.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub在推送到存储库后触发Jenkins并开始构建。
- en: 'To configure the system this way, we need the following setup steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式配置系统，我们需要以下设置步骤：
- en: Install the GitHub plugin in Jenkins.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Jenkins中安装GitHub插件。
- en: Generate a secret key for Jenkins.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Jenkins生成一个秘钥。
- en: Set the GitHub web hook and specify the Jenkins address and key.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置GitHub Web钩子并指定Jenkins地址和秘钥。
- en: In the case of the most popular SCM providers, dedicated Jenkins plugins are
    always provided.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最流行的SCM提供商，通常都会提供专门的Jenkins插件。
- en: There is also a more generic way to trigger Jenkins via the REST call to the
    endpoint `<jenkins_url>/job/<job_name>/build?token=<token>`. For security reasons,
    it requires setting `token` in Jenkins and then using it in the remote script.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种更通用的方式可以通过对端点`<jenkins_url>/job/<job_name>/build?token=<token>`进行REST调用来触发Jenkins。出于安全原因，它需要在Jenkins中设置`token`，然后在远程脚本中使用。
- en: Jenkins must be accessible from the SCM server. In other words, if we use the
    public GitHub to trigger Jenkins, then our Jenkins server must be public as well.
    This also applies to the generic solution; the `<jenkins_url>` address must be
    accessible.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins必须可以从SCM服务器访问。换句话说，如果我们使用公共GitHub来触发Jenkins，那么我们的Jenkins服务器也必须是公共的。这也适用于通用解决方案；`<jenkins_url>`地址必须是可访问的。
- en: Polling SCM
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 轮询SCM
- en: 'Polling SCM trigger is a little less intuitive. The following figure presents
    the communication:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 轮询SCM触发器有点不太直观。下图展示了通信：
- en: '![](assets/ea1d08c6-7d01-477e-9d0f-3639f4aabc12.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ea1d08c6-7d01-477e-9d0f-3639f4aabc12.png)'
- en: 'Jenkins periodically calls GitHub and checks if there was any push to the repository.
    Then, it starts the build. It may sound counter-intuitive, however, there are
    at least two good cases for using this method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins定期调用GitHub并检查存储库是否有任何推送。然后，它开始构建。这可能听起来有些反直觉，但是至少有两种情况可以使用这种方法：
- en: Jenkins is inside the firewalled network (which GitHub does not have access
    to)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins位于防火墙网络内（GitHub无法访问）
- en: Commits are frequent and the build takes a long time, so executing a build after
    every commit would cause an overload
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交频繁，构建时间长，因此在每次提交后执行构建会导致过载
- en: 'The configuration of **poll SCM** is also somehow simpler because the way to
    connect from Jenkins to GitHub is already set up (Jenkins checks out the code
    from GitHub, so it needs to have access). In the case of our calculator project,
    we can set up an automatic trigger by adding the `triggers` declaration (just
    after `agent`) to the pipeline:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**轮询SCM**的配置也更简单，因为从Jenkins到GitHub的连接方式已经设置好了（Jenkins从GitHub检出代码，因此需要访问权限）。对于我们的计算器项目，我们可以通过在流水线中添加`triggers`声明（在`agent`之后）来设置自动触发：'
- en: '[PRE28]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After running the pipeline manually for the first time, the automatic trigger
    is set. Then, it checks GitHub every minute, and for new commits, it starts a
    build. To test that it works as expected, you can commit and push anything to
    the GitHub repository and see that the build starts.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次手动运行流水线后，自动触发被设置。然后，它每分钟检查GitHub，对于新的提交，它会开始构建。为了测试它是否按预期工作，您可以提交并推送任何内容到GitHub存储库，然后查看构建是否开始。
- en: We used the mysterious `* * * * *` as an argument to `pollSCM`. It specifies
    how often Jenkins should check for new source changes and is expressed in the
    cron-style string format.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用神秘的`* * * * *`作为`pollSCM`的参数。它指定Jenkins应该多久检查新的源更改，并以cron样式字符串格式表示。
- en: The cron string format is described (together with the cron tool) at [https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron).
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: cron字符串格式在[https://en.wikipedia.org/wiki/Cron](https://en.wikipedia.org/wiki/Cron)中描述（与cron工具一起）。
- en: Scheduled build
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计划构建
- en: Scheduled trigger means that Jenkins runs the build periodically, no matter
    if there was any commit to the repository or not.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 计划触发意味着Jenkins定期运行构建，无论存储库是否有任何提交。
- en: 'As the following figure presents, there is no communication with any system
    needed:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示，不需要与任何系统进行通信：
- en: '![](assets/a7ecf582-38bd-4402-98f3-b28700ff392a.png)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7ecf582-38bd-4402-98f3-b28700ff392a.png)'
- en: The implementation of Scheduled build is exactly the same as polling SCM. The
    only difference is that the keyword `cron` is used instead of `pollSCM`. This
    trigger method is rarely used for the commit pipeline but applies well to nightly
    builds (for example, complex integration testing executed at nights).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 计划构建的实现与轮询SCM完全相同。唯一的区别是使用`cron`关键字而不是`pollSCM`。这种触发方法很少用于提交流水线，但适用于夜间构建（例如，在夜间执行的复杂集成测试）。
- en: Notifications
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知
- en: Jenkins provides a lot of ways to announce its build status. What's more, as
    with everything in Jenkins, new notification types can be added using plugins.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins提供了很多宣布其构建状态的方式。而且，与Jenkins中的所有内容一样，可以使用插件添加新的通知类型。
- en: Let's walk through the most popular types so that you can choose the one that
    fits your needs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一介绍最流行的类型，以便您选择适合您需求的类型。
- en: Email
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件
- en: The most classic way to notify about the Jenkins build status is to send emails.
    The advantage of this solution is that everybody has a mailbox; everybody knows
    how to use the mailbox; and everybody is used to receiving information by the
    mailbox. The drawback is that usually there are simply too many emails and the
    ones from Jenkins quickly become filtered out and never read.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 通知Jenkins构建状态的最经典方式是发送电子邮件。这种解决方案的优势是每个人都有邮箱；每个人都知道如何使用邮箱；每个人都习惯通过邮箱接收信息。缺点是通常有太多的电子邮件，而来自Jenkins的电子邮件很快就会被过滤掉，从未被阅读。
- en: 'The configuration of the email notification is very simple; it''s enough to:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件通知的配置非常简单；只需：
- en: Have the SMTP server configured
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已配置SMTP服务器
- en: Set its details in Jenkins (in Manage Jenkins | Configure System)
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jenkins中设置其详细信息（在管理Jenkins | 配置系统中）
- en: Use `mail to` instruction in the pipeline
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在流水线中使用`mail to`指令
- en: 'The pipeline configuration can be as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线配置可以如下：
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that all notifications are usually called in the `post` section of the
    pipeline, which is executed after all steps, no matter whether the build succeeded
    or failed.  We used the `always` keyword; however, there are different options:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有通知通常在流水线的`post`部分中调用，该部分在所有步骤之后执行，无论构建是否成功或失败。我们使用了`always`关键字；然而，还有不同的选项：
- en: '**always:** Execute regardless of the completion status'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**始终：**无论完成状态如何都执行'
- en: '**changed:** Execute only if the pipeline changed its status'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改：**仅在流水线更改其状态时执行'
- en: '**failure:** Execute only if the pipeline has the **failed** status'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败：**仅在流水线处于**失败**状态时执行'
- en: '**success:** Execute only if the pipeline has the **success** status'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功：**仅在流水线处于**成功**状态时执行'
- en: '**unstable:** Execute only if the pipeline has the **unstable** status (usually
    caused by test failures or code violations)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不稳定：**仅在流水线处于**不稳定**状态时执行（通常是由测试失败或代码违规引起的）'
- en: Group chat
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 群聊
- en: 'If group chat (for example, Slack or HipChat) is the first method of communication
    in your team, then it''s worth considering adding the automatic build notifications
    there. No matter which tool you use, the procedure to configure it is always the
    same:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果群聊（例如Slack或HipChat）是团队中的第一种沟通方式，那么考虑在那里添加自动构建通知是值得的。无论使用哪种工具，配置的过程始终是相同的：
- en: Find and install plugin for your group chat tool (for example, the **Slack Notification**
    plugin).
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找并安装群聊工具的插件（例如**Slack通知**插件）。
- en: Configure the plugin (server URL, channel, authorization token, and so on).
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置插件（服务器URL、频道、授权令牌等）。
- en: Add the sending instruction to the pipeline.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将发送指令添加到流水线中。
- en: 'Let''s see a sample pipeline configuration for Slack to send notifications
    after the build fails:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个Slack的样本流水线配置，在构建失败后发送通知：
- en: '[PRE30]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Team space
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队空间
- en: Together with the agile culture came the idea that it's better to have everything
    happening in the team space. Instead of writing emails, meet together; instead
    of online messaging, come and talk; instead of task-tracking tool, have a whiteboard.
    The same idea came to Continuous Delivery and Jenkins. Currently, it's very common
    to install big screens (also called **build radiators**) in the team space. Then,
    when you come to the office, the first thing you see is the current status of
    the pipeline. Build radiators are considered one of the most effective notification
    strategies. They ensure that everyone is aware of failing builds and, as a side-effect
    benefit, they boost team spirit and favor in-person communication.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 随着敏捷文化的出现，人们认为最好让所有事情都发生在团队空间里。与其写电子邮件，不如一起见面；与其在线聊天，不如当面交谈；与其使用任务跟踪工具，不如使用白板。这个想法也适用于持续交付和Jenkins。目前，在团队空间安装大屏幕（也称为**构建辐射器**）非常普遍。因此，当你来到办公室时，你看到的第一件事就是流水线的当前状态。构建辐射器被认为是最有效的通知策略之一。它们确保每个人都知道构建失败，并且作为副作用，它们提升了团队精神并促进了面对面的沟通。
- en: Since developers are creative beings, they invented a lot of other ideas that
    play the same role as the radiators. Some teams hang large speakers that beep
    when the pipeline failed. Some others have toys that blink when the build is done.
    One of my favorites is Pipeline State UFO, which is provided as an open source
    project on GitHub. On its page, you can find the description of how to print and
    configure a UFO that hangs under the ceiling and signals the pipeline state. You
    can find more at [https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 由于开发人员是有创造力的存在，他们发明了许多其他与“辐射器”起着相同作用的想法。一些团队挂大型扬声器，当管道失败时会发出哔哔声。其他一些团队有玩具，在构建完成时会闪烁。我最喜欢的之一是Pipeline
    State UFO，它是GitHub上的开源项目。在其页面上，您可以找到如何打印和配置挂在天花板下并信号管道状态的UFO的描述。您可以在[https://github.com/Dynatrace/ufo](https://github.com/Dynatrace/ufo)找到更多信息。
- en: Since Jenkins is extensible by plugins, its community wrote a lot of different
    ways to inform about the build statuses. Among them, you can find RSS feeds, SMS
    notifications, mobile applications, desktop notifiers, and much more.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Jenkins可以通过插件进行扩展，其社区编写了许多不同的方式来通知构建状态。其中，您可以找到RSS订阅、短信通知、移动应用程序、桌面通知器等。
- en: Team development strategies
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 团队开发策略
- en: We have already described everything about how the Continuous Integration pipeline
    should look. However, when exactly should it be run? Of course, it is triggered
    after the commit to the repository but after the commit to which branch? Only
    to the trunk or to every branch? Or maybe it should run before, not after committing
    so that the repository would always be healthy? Or, how about the crazy idea to
    have no branches at all?
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经描述了持续集成管道应该是什么样子的一切。但是，它应该在什么时候运行？当然，它是在提交到存储库后触发的，但是提交到哪个分支？只提交到主干还是每个分支都提交？或者它应该在提交之前而不是之后运行，以便存储库始终保持健康？或者，怎么样采用没有分支的疯狂想法？
- en: There is no single best answer to these questions. Actually, the way you use
    the Continuous Integration process depends on your team development workflow.
    So, before we go any further, let's describe what the possible workflows are.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些问题并没有单一的最佳答案。实际上，您使用持续集成过程的方式取决于团队的开发工作流程。因此，在我们继续之前，让我们描述一下可能的工作流程是什么。
- en: Development workflows
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发工作流程
- en: A development workflow is the way your team puts the code into the repository.
    It depends, of course, on many factors such as the source control management tool,
    the project specifics, or the team size.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 开发工作流程是您的团队将代码放入存储库的方式。当然，这取决于许多因素，如源代码控制管理工具、项目特定性或团队规模。
- en: 'As a result, each team develops the code in a slightly different manner. We
    can, however, classify them into three types: trunk-based workflow, branching
    workflow, and forking workflow.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个团队以稍微不同的方式开发代码。但是，我们可以将它们分类为三种类型：基于主干的工作流程、分支工作流程和分叉工作流程。
- en: All workflows are described in detail with examples at [https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 所有工作流程都在[https://www.atlassian.com/git/tutorials/comparing-workflows](https://www.atlassian.com/git/tutorials/comparing-workflows)上详细描述，并附有示例。
- en: Trunk-based workflow
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主干的工作流程
- en: 'Trunk-based workflow is the simplest possible strategy. Its overview is presented
    in the following figure:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的工作流程是最简单的策略。其概述如下图所示：
- en: '![](assets/dfd60182-ccde-4fba-aec5-e01d4fb677af.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/dfd60182-ccde-4fba-aec5-e01d4fb677af.png)'
- en: There is one central repository with a single entry for all changes to the project,
    which is called the trunk or master. Every member of the team clones the central
    repository to have their own local copies. The changes are committed directly
    to the central repository.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个中央存储库，所有对项目的更改都有一个单一入口，称为主干或主要。团队的每个成员都克隆中央存储库，以拥有自己的本地副本。更改直接提交到中央存储库。
- en: Branching workflow
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支工作流
- en: 'Branching workflow, as its name suggests, means that the code is kept in many
    different branches. The idea is presented in the following figure:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 分支工作流，顾名思义，意味着代码被保存在许多不同的分支中。这个想法如下图所示：
- en: '![](assets/18d4bcff-09cf-42c4-8e90-b88268349bee.png)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/18d4bcff-09cf-42c4-8e90-b88268349bee.png)'
- en: When developers start to work on a new feature, they create a dedicated branch
    from the trunk and commit all feature-related changes there. This makes it easy
    for multiple developers to work on a feature without breaking the main codebase.
    This is why, in the case of branching workflow, there is no problem in keeping
    the master healthy. When the feature is completed, a developer rebases the feature
    branch from master and creates a pull request that contains all feature-related
    code changes. It opens the code review discussions and makes space to check if
    the changes don't disturb the master. When the code is accepted by other developers
    and automatic system checks, then it is merged into the main codebase. Then, the
    build is run again on master but should almost never fail since it didn't fail
    on the branch.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 当开发人员开始开发新功能时，他们从主干创建一个专用分支，并在那里提交所有与功能相关的更改。这使得多个开发人员可以轻松地在不破坏主代码库的情况下开发功能。这就是为什么在分支工作流的情况下，保持主干健康是没有问题的。当功能完成时，开发人员会从主干重新设置功能分支，并创建一个包含所有与功能相关代码更改的拉取请求。这会打开代码审查讨论，并留出空间来检查更改是否不会影响主干。当代码被其他开发人员和自动系统检查接受后，它就会合并到主代码库中。然后，在主干上再次运行构建，但几乎不应该失败，因为它在分支上没有失败。
- en: Forking workflow
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分叉工作流
- en: 'Forking workflow is very popular among the open source community. Its idea
    is presented in the following figure:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉工作流在开源社区中非常受欢迎。其思想如下图所示：
- en: '![](assets/83ff827e-d29b-4e4e-8449-cb5d979dc6a2.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/83ff827e-d29b-4e4e-8449-cb5d979dc6a2.png)'
- en: Each developer has his own server-side repository. They may or may not be the
    official repository, but technically, each repository is exactly the same.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发人员都有自己的服务器端存储库。它们可能是官方存储库，也可能不是，但从技术上讲，每个存储库都是完全相同的。
- en: Forking means literally creating a new repository from the other repository.
    Developers push to their own repositories and when they want to integrate the
    code, they create a pull request to the other repository.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 分叉字面上意味着从其他存储库创建一个新存储库。开发人员将代码推送到自己的存储库，当他们想要集成代码时，他们会创建一个拉取请求到其他存储库。
- en: The main advantage of the forking workflow is that the integration is not necessarily
    via a central repository. It also helps with the ownership because it allows accepting
    pull requests from others without giving them write access.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 分支工作流的主要优势在于集成不一定通过中央存储库。它还有助于所有权，因为它允许接受他人的拉取请求，而不给予他们写入权限。
- en: In the case of requirement-oriented commercial projects, the team usually works
    on one product and therefore has a central repository, so this model boils down
    to the branching workflow with the good ownership assignment, for example, only
    project leads can merge pull requests into the central repository.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向需求的商业项目中，团队通常只开发一个产品，因此有一个中央存储库，因此这个模型归结为分支工作流，具有良好的所有权分配，例如，只有项目负责人可以将拉取请求合并到中央存储库中。
- en: Adopting Continuous Integration
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 采用持续集成
- en: We described different development workflows, but how do they influence the
    Continuous Integration configuration?
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了不同的开发工作流程，但它们如何影响持续集成配置呢？
- en: Branching strategies
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分支策略
- en: 'Each development workflow implies a different Continuous Integration approach:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 每种开发工作流程都意味着不同的持续集成方法：
- en: '**Trunk-based workflow**: implies constantly struggling against the broken
    pipeline. If everyone commits to the main codebase, then the pipeline often fails.
    In this case, the old Continuous Integration rule says, "*If the build is broken,
    then the development team stops whatever they are doing and fixes the problem
    immediately*."'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于主干的工作流程**：意味着不断与破损的管道作斗争。如果每个人都提交到主代码库，那么管道经常会失败。在这种情况下，旧的持续集成规则是：“如果构建失败，开发团队立即停止正在做的事情并立即解决问题”。'
- en: '**Branching workflow**: solves the broken trunk issue but introduces another
    one: if everyone develops in their own branches, then where is the integration?
    A feature usually takes weeks or months to develop, and for all this time, the
    branch is not integrated into the main code, therefore it cannot be really called
    "continuous" integration; not to mention that there is a constant need for merging
    and resolving conflicts.'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支工作流程**：解决了破损主干的问题，但引入了另一个问题：如果每个人都在自己的分支上开发，那么集成在哪里？一个功能通常需要几周甚至几个月的时间来开发，而在这段时间内，分支没有集成到主代码中，因此不能真正称为“持续”集成；更不用说不断需要合并和解决冲突。'
- en: '**Forking workflow**: implies managing the Continuous Integration process by
    every repository owner, which isn''t usually a problem. It shares, however, the
    same issues as the branching workflow.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分叉工作流程**：意味着每个存储库所有者管理持续集成过程，这通常不是问题。然而，它与分支工作流程存在相同的问题。'
- en: There is no silver bullet, and different organizations choose different strategies.
    The solution that is the closest to perfection is using the technique of the branching
    workflow and the philosophy of the trunk-based workflow. In other words, we can
    create very small branches and integrate them frequently into master. This seems
    to take the best of both, however, requires either having tiny features or using
    feature toggles. Since the concept of feature toggles fits very well into Continuous
    Integration and Continuous Delivery, let's take a moment to explore it.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 没有银弹，不同的组织选择不同的策略。最接近完美的解决方案是使用分支工作流程的技术和基于主干工作流程的哲学。换句话说，我们可以创建非常小的分支，并经常将它们集成到主分支中。这似乎兼具两者的优点，但要求要么有微小的功能，要么使用功能切换。由于功能切换的概念非常适合持续集成和持续交付，让我们花点时间来探讨一下。
- en: Feature toggles
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能切换
- en: Feature toggle is a technique that is an alternative to maintaining multiple
    source code branches such that the feature can be tested before it is completed
    and ready for release. It is used to disable the feature for users but enable
    it for developers while testing. Feature toggles are essentially variables used
    in conditional statements.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 功能切换是一种替代维护多个源代码分支的技术，以便在功能完成并准备发布之前进行测试。它用于禁用用户的功能，但在测试时为开发人员启用。功能切换本质上是在条件语句中使用的变量。
- en: 'The simplest implementation of feature toggles are flags and the `if` statements.
    A development using feature toggles, as opposed to feature branching development,
    looks as follows:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 功能切换的最简单实现是标志和if语句。使用功能切换进行开发，而不是使用功能分支开发，看起来如下：
- en: A new feature has to be implemented.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 必须实现一个新功能。
- en: Create a new flag or a configuration property `feature_toggle` (instead of the `feature` branch).
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的标志或配置属性“feature_toggle”（而不是“feature”分支）。
- en: 'Every feature-related code is added inside the `if` statement (instead of committing
    to the `feature` branch), for example:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个与功能相关的代码都添加到“if”语句中（而不是提交到“feature”分支），例如：
- en: '[PRE31]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'During the feature development:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在功能开发期间：
- en: Coding is done in master with `feature_toggle = true` (instead of coding in
    the feature branch)
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`feature_toggle = true`在主分支上进行编码（而不是在功能分支上进行编码）
- en: Release is done from master with `feature_toggle = false`
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从主分支进行发布，使用`feature_toggle = false`
- en: When the feature development is completed, all `if` statements are removed and
    `feature_toggle` is removed from the configuration (instead of merging `feature`
    to master and removing the `feature` branch).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当功能开发完成时，所有“if”语句都被移除，并且从配置中移除了“feature_toggle”（而不是将“feature”合并到主分支并删除“feature”分支）。
- en: The benefit of feature toggle is that all development is done in the `trunk`,
    which enables the real Continuous Integration and mitigates problems with merging
    code.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 功能切换的好处在于所有开发都是在“主干”上进行的，这样可以实现真正的持续集成，并减轻合并代码的问题。
- en: Jenkins Multibranch
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins多分支
- en: If you decide to use branches in any form, the long feature branches or the
    recommended short-lived branches, then it is convenient to know that the code
    is healthy before merging it into master. This approach results in always keeping
    the main codebase green and, luckily, there is an easy way to do it with Jenkins.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定以任何形式使用分支，长期功能分支或推荐的短期分支，那么在将其合并到主分支之前知道代码是否健康是很方便的。这种方法可以确保主代码库始终保持绿色，幸运的是，使用Jenkins可以很容易地实现这一点。
- en: 'In order to use Multibranch in our calculator project, let''s proceed with
    the following steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的计算器项目中使用多分支，让我们按照以下步骤进行：
- en: Open the main Jenkins page.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开主Jenkins页面。
- en: Click on New Item.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“新建项目”。
- en: Enter `calculator-branches` as the item name, select Multibranch Pipeline, and
    click on OK.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入“calculator-branches”作为项目名称，选择多分支管道，然后点击“确定”。
- en: In the Branch Sources section, click on Add source, and select Git.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分支来源部分，点击“添加来源”，然后选择Git。
- en: Enter the repository address into Project Repository.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将存储库地址输入到项目存储库中。
- en: '![](assets/612d9172-f32d-4de6-93b8-d050718945ea.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/612d9172-f32d-4de6-93b8-d050718945ea.png)'
- en: Tick Periodically if not otherwise run and set 1 minute as Interval.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有其他运行，则设置1分钟为间隔，然后勾选“定期运行”。
- en: Click on Save.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“保存”。
- en: Every minute, this configuration checks if there were any branches added (or
    removed) and creates (or deletes) the dedicated pipeline defined by Jenkinsfile.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 每分钟，此配置会检查是否有任何分支被添加（或删除），并创建（或删除）由Jenkinsfile定义的专用管道。
- en: 'We can create a new branch and see how it works. Let''s create a new branch
    called `feature` and `push` it into the repository:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个新的分支并看看它是如何工作的。让我们创建一个名为“feature”的新分支并将其“push”到存储库中：
- en: '[PRE32]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After a moment, you should see a new branch pipeline automatically created
    and run:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一会儿之后，您应该会看到一个新的分支管道被自动创建并运行：
- en: '![](assets/1d029385-1907-49ca-8a47-6869c12edbfd.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1d029385-1907-49ca-8a47-6869c12edbfd.png)'
- en: Now, before merging the feature branch to master, we can check if it's green.
    This approach should never break the master build.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在将功能分支合并到主分支之前，我们可以检查它是否是绿色的。这种方法不应该破坏主构建。
- en: In the case of GitHub, there is an even better approach, using the `GitHub Organization
    Folder` plugin. It automatically creates pipelines with branches and pull requests
    for all projects.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitHub的情况下，有一种更好的方法，使用“GitHub组织文件夹”插件。它会自动为所有项目创建具有分支和拉取请求的管道。
- en: A very similar approach is to build a pipeline per pull request instead of a
    pipeline per branch, which gives the same result; the main codebase is always
    healthy.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常类似的方法是为每个拉取请求构建一个管道，而不是为每个分支构建一个管道，这会产生相同的结果；主代码库始终保持健康。
- en: Non-technical requirements
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非技术要求
- en: Last but not least, Continuous Integration is not all about the technology.
    On the contrary, technology comes second. James Shore in his article *Continuous
    Integration on a Dollar a Day* described how to set up the Continuous Integration
    process without any additional software. All he used was a rubber chicken and
    a bell. The idea is to make the team work in one room and set up a separate computer
    with an empty chair. Put the rubber chicken and the bell in front of that computer.
    Now, when you plan to check in the code, take the rubber chicken, check in the
    code, go to the empty computer, checkout the fresh code, run all tests there,
    and if everything passes, put back the rubber chicken and ring the bell so that
    everyone knows that something has been added to the repository.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，持续集成并不全是关于技术。相反，技术排在第二位。詹姆斯·肖尔在他的文章《每日一美元的持续集成》中描述了如何在没有任何额外软件的情况下设置持续集成过程。他所使用的只是一个橡皮鸡和一个铃铛。这个想法是让团队在一个房间里工作，并在一个空椅子上设置一台独立的计算机。把橡皮鸡和铃铛放在那台计算机前。现在，当你计划签入代码时，拿起橡皮鸡，签入代码，去空的计算机，检出最新的代码，在那里运行所有的测试，如果一切顺利，放回橡皮鸡并敲响铃铛，这样每个人都知道有东西被添加到了代码库。
- en: '*Continuous Integration on a Dollar a Day* by *James Shore* can be found at: [http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html](http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html).'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 《每日一美元的持续集成》是由詹姆斯·肖尔（James Shore）撰写的，可以在以下网址找到：[http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html](http://www.jamesshore.com/Blog/Continuous-Integration-on-a-Dollar-a-Day.html)。
- en: 'The idea is a little oversimplified, and automated tools are useful; however,
    the main message is that without each team member''s engagement, even the best
    tools won''t help. Jez Humble in his great book, *Continuous Delivery*, mentions
    the prerequisites for Continuous Integration that can be rephrased with the following
    points:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法有点过于简化，自动化工具很有用；然而，主要信息是，没有每个团队成员的参与，即使是最好的工具也无济于事。杰兹·汉布尔（Jez Humble）在他的著作《持续交付》中提到了持续集成的先决条件，可以用以下几点重新表述：
- en: '**Check in regularly**: Quoting *Mike Roberts,* <q>"Continuously is more often
    than you think"</q>, the minimum is once a day.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期签入**：引用*迈克·罗伯茨*的话，“连续性比你想象的更频繁”，最少每天一次。'
- en: '**Create comprehensive unit tests**: It''s not only about the high test coverage,
    it''s possible to have no assertions and still keep 100% coverage.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建全面的单元测试**：不仅仅是高测试覆盖率，可能没有断言但仍保持100%的覆盖率。'
- en: '**Keep the process quick**: Continuous Integration must take a short time,
    preferably under 5 minutes. 10 minutes is already a lot.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持流程迅速**：持续集成必须需要很短的时间，最好在5分钟以内。10分钟已经很长了。'
- en: '**Monitor the builds**: It can be a shared responsibility or you can adapt
    the **build master** role that rotates weekly.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控构建**：这可以是一个共同的责任，或者你可以适应每周轮换的**构建主管**角色。'
- en: Exercises
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'You''ve learned a lot about how to configure the Continuous Integration process.
    Since *practice makes man perfect*, we recommend doing the following exercises:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了如何配置持续集成过程。由于“熟能生巧”，我们建议进行以下练习：
- en: 'Create a Python program that multiplies two numbers passed as the command-line
    parameters. Add unit tests and publish the project on GitHub:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Python程序，用作命令行参数传递的两个数字相乘。添加单元测试并将项目发布到GitHub上：
- en: Create two files `calculator.py` and `test_calculator.py`
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建两个文件`calculator.py`和`test_calculator.py`
- en: You can use the `unittest` library at [https://docs.python.org/library/unittest.html](https://docs.python.org/library/unittest.html)
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.python.org/library/unittest.html](https://docs.python.org/library/unittest.html)使用`unittest`库。
- en: Run the program and the unit test
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行程序和单元测试
- en: 'Build the Continuous Integration pipeline for the Python calculator project:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Python计算器项目构建持续集成流水线：
- en: Use Jenkinsfile for specifying the pipeline
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jenkinsfile指定管道
- en: Configure the trigger so that the pipeline runs automatically in case of any
    commit to the repository
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置触发器，以便在存储库有任何提交时自动运行管道
- en: The pipeline doesn't need the `Compile` step since Python is an interpretable
    language
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道不需要“编译”步骤，因为Python是一种可解释语言
- en: Run the pipeline and observe the results
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行管道并观察结果
- en: Try to commit the code that breaks each stage of the pipeline and observe how
    it is visualized in Jenkins
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试提交破坏管道每个阶段的代码，并观察它在Jenkins中的可视化效果
- en: Summary
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we covered all aspects of the Continuous Integration pipeline,
    which is always the first step for Continuous Delivery. The key takeaway from
    the chapter:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了持续集成管道的所有方面，这总是持续交付的第一步。本章的关键要点：
- en: Pipeline provides a general mechanism for organizing any automation processes;
    however, the most common use cases are Continuous Integration and Continuous Delivery
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道提供了组织任何自动化流程的一般机制；然而，最常见的用例是持续集成和持续交付
- en: Jenkins accepts different ways of defining pipelines but the recommended one
    is the declarative syntax
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins接受不同的管道定义方式，但推荐的是声明性语法
- en: Commit pipeline is the most basic Continuous Integration process and, as its
    name suggests, it should be run after every commit to the repository
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交管道是最基本的持续集成过程，正如其名称所示，它应该在每次提交到存储库后运行
- en: The pipeline definition should be stored in the repository as a Jenkinsfile
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管道定义应存储在存储库中作为Jenkinsfile
- en: Commit pipeline can be extended with the code quality stages
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交管道可以通过代码质量阶段进行扩展
- en: No matter the project build tool, Jenkins commands should always be consistent
    with the local development commands
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论项目构建工具如何，Jenkins命令应始终与本地开发命令保持一致
- en: Jenkins offers a wide range of triggers and notifications
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins提供了广泛的触发器和通知
- en: The development workflow should be carefully chosen inside the team or organization
    because it affects the Continuous Integration process and defines the way the
    code is developed
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队或组织内部应谨慎选择开发工作流程，因为它会影响持续集成过程，并定义代码开发的方式
- en: In the next chapter, we will focus on the next phase of the Continuous Delivery
    process, automated acceptance testing. It can be considered as the most important
    and, in many cases, the most difficult step to implement. We will explore the
    idea of acceptance testing and a sample implementation using Docker.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于持续交付过程的下一个阶段，自动接受测试。它可以被认为是最重要的，而且在许多情况下，是最难实现的步骤。我们将探讨接受测试的概念，并使用Docker进行示例实现。
