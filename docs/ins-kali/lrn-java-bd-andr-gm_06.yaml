- en: Chapter 6. OOP – Using Other People's Hard Work
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 面向对象编程 - 使用他人的辛勤工作
- en: OOP stands for **object-oriented programming**. In this chapter, you don't need
    to even try and remember everything. Why do I say this? Surely, that's what learning
    is. The more important thing is to grasp the concepts and begin to understand
    the *why* of OOP rather than memorize rules, syntax, and jargon.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程代表**面向对象的编程**。在本章中，你甚至不需要试图记住一切。为什么我这么说？当然，这就是学习。更重要的是掌握这些概念，并开始理解面向对象编程的*为什么*，而不是记住规则、语法和行话。
- en: The more important thing is to actually start to use some of the concepts, even
    though you might have to keep referring back and your code might not properly
    adhere to every OOP principal that we discuss. Neither does the code in this book.
    The code in this chapter is here to help you explore and grasp the concepts of
    OOP.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是实际开始使用一些概念，即使你可能不得不不断地参考，你的代码可能不完全符合我们讨论的每一个面向对象编程原则。这本书中的代码也是如此。本章的代码是为了帮助你探索和理解面向对象编程的概念。
- en: If you try to memorize this chapter, you will have to make a lot of room in
    your brain, and you will probably forget something really important in its place
    such as going to work or thanking the author for telling you not to try and memorize
    this stuff.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图记住本章，你将不得不在你的大脑中腾出很多空间，你可能会忘记一些非常重要的事情，比如去工作或感谢作者告诉你不要试图记住这些东西。
- en: A good goal will be to try and almost get it. Then we will start to recognize
    examples of OOP in action so that our understanding becomes more rounded. You
    can then often refer back to this chapter for a refresher.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的目标是尽量接近它。然后我们将开始认识到面向对象编程在实际中的应用，这样我们的理解就会更全面。然后你可以经常回顾本章来温习。
- en: So what is all this OOP stuff we will learn about? Actually, we have already
    learned loads about OOP. Until now, we have been using classes such as `Button`,
    `Random`, and `Activity`, overriding methods of classes (mainly `onCreate`) and
    using an **interface** as well; remember implementing `onClickListener` a few
    times in the first five chapters?
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们将学到的所有这些面向对象的东西是什么？实际上，我们已经学到了很多关于面向对象的知识。到目前为止，我们已经使用了诸如`Button`、`Random`和`Activity`之类的类，重写了类的方法（主要是`onCreate`），还使用了**接口**；还记得在前五章中几次实现`onClickListener`吗？
- en: This chapter just helps to make sense of OOP and expands our understanding,
    and finally, we will make our own classes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章只是帮助理解面向对象编程并扩展我们的理解，最后，我们将制作我们自己的类。
- en: Then we will be in a good position in the next two chapters to make two cool
    retro arcade games using lots of other people's hard work. This chapter will be
    mainly theory, but with a few practical console examples using LogCat so that
    we can see OOP in action.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在接下来的两章中，我们将处于一个很好的位置，制作两个很酷的复古街机游戏，利用了很多其他人的辛勤工作。本章主要是理论，但也有一些使用LogCat的实际控制台示例，这样我们就可以看到面向对象编程在实际中的应用。
- en: 'In this chapter, we will do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Look at what OOP is.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看面向对象编程是什么。
- en: Write our first class.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个类。
- en: Look at what encapsulation is and how we achieve it as well as look more deeply
    at variables and the different types. We will also take a short break to throw
    out the garbage.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看封装是什么，我们如何实现它，以及更深入地了解变量和不同类型。我们还将短暂休息一下，清理一下垃圾。
- en: Learn about inheritance and how we can extend and even improve upon a class
    before we use it.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习继承以及我们如何在使用之前扩展甚至改进一个类。
- en: Take a look at polymorphism, which is a way of being more than one thing at
    a time and is really useful in programming.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看多态性，这是一种在编程中同时成为多种东西的方式，非常有用。
- en: What is OOP?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是面向对象编程？
- en: OOP is a way of programming that involves breaking our requirements down into
    chunks that are more manageable than the whole.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种将我们的需求分解为比整体更易管理的块的编程方式。
- en: Each chunk is self-contained yet potentially reusable by other programs while
    working together as a whole with the other chunks.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 每个块都是独立的，但也可能被其他程序重复使用，同时与其他块一起作为一个整体工作。
- en: These chunks are what we have been referring to as objects. When we plan an
    object, we do so with a class. A class can be thought of as the blueprint of an
    object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这些块就是我们所说的对象。当我们计划一个对象时，我们会使用一个类。一个类可以被看作是一个对象的蓝图。
- en: 'We implement an object of a class. This is called an **instance** of a class.
    Think about a house blueprint. You can''t live in it, but you can build a house
    from it, which means you build an instance of it. However, OOP is more than this.
    It is also a methodology that defines best practices such as the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个类的对象。这被称为类的**实例**。想象一下一幢房子的蓝图。你不能住在里面，但你可以根据它建造一座房子，这意味着你建造了它的一个实例。然而，面向对象编程不仅仅是这样。它还是一种定义最佳实践的方法，比如以下内容：
- en: '**Encapsulation**: This means keeping the internal workings of your code safe
    from interference from the programs that use it, and allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still accessed in the same way.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：这意味着将代码的内部工作与使用它的程序的干扰隔离开来，并且只允许访问你选择的变量和方法。这意味着只要暴露的部分仍然以相同的方式被访问，你的代码就可以随时更新、扩展或改进，而不会影响使用它的程序。'
- en: '**Inheritance**: Just like it sounds, inheritance means we can harness all
    the features and benefits of other people''s hard work, including encapsulation
    and polymorphism, while refining their code specifically for our situation. Actually,
    we have done this already every time we used the `extends` keyword.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：就像它听起来的那样，继承意味着我们可以利用其他人的辛勤工作的所有特性和好处，包括封装和多态性，同时针对我们的情况对他们的代码进行特定的改进。实际上，每当我们使用`extends`关键字时，我们都已经这样做了。'
- en: '**Polymorphism**: This allows us to write code that is less dependent on the
    types we are trying to manipulate, making our code clearer and more efficient.
    Some examples later in the chapter will make this clear.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态性**：这使我们能够编写对我们试图操作的类型不太依赖的代码，使我们的代码更清晰、更高效。本章后面的一些例子将使这一点更加清晰。'
- en: Tip
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When we talk about using other people's hard work, we are not talking about
    a magical way to abuse copyright and get away with it. Some code is plain and
    simple, someone else's property. What we are taking about is the vast array of
    free-to-use code, particularly in the context of this book, in the Java and Android
    APIs. If you want some code that does a certain thing, it has probably been done
    before. We just have to find it, then use it or modify it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论使用其他人的辛勤工作时，我们并不是在谈论一种滥用版权并逍遥法外的神奇方式。有些代码是简单明了的，是别人的财产。我们所说的是在Java和Android
    API的背景下，我们可以使用的大量免费代码。如果您需要执行某个特定操作的代码，它可能已经存在。我们只需要找到它，然后使用或修改它。
- en: Java was designed from the start with all of this in mind, so we are fairly
    significantly constrained to using OOP. However, this is a good thing because
    we learn how to use the best practices.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Java从一开始就考虑到了所有这些，因此我们在很大程度上受到使用面向对象编程的限制。然而，这是一件好事，因为我们学会了如何使用最佳实践。
- en: Why do it like this?
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要这样做？
- en: When written properly, all this OOP allows you to add new features without worrying
    as much about how they interact with existing features. When you do have to change
    a class, its self-contained nature means less, or perhaps zero, consequences for
    other parts of the program. This is the encapsulation part.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确编写时，所有这些面向对象编程允许您添加新功能，而无需过多担心它们与现有功能的交互。当您必须更改一个类时，它的自包含性意味着对程序的其他部分的影响较小，或者可能为零。这就是封装的部分。
- en: You can use other people's code without knowing or perhaps even caring how it
    works. Think about the Android lifecycle, buttons, threads, and so on. The `Button`
    class is quite complicated, with nearly 50 methods—do we really want to write
    all that just for a button?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用其他人的代码，而不知道甚至不关心它是如何工作的。想想Android生命周期、按钮、线程等。`Button`类非常复杂，有近50个方法——我们真的想为一个按钮写这么多代码吗？
- en: OOP allows you to write apps for highly complex situations without breaking
    a sweat. You can create multiple similar yet different versions of a class without
    starting the class from scratch using inheritance, and you can still use the methods
    intended for the original type of object with your new object because of polymorphism.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程允许您在不费吹灰之力的情况下为高度复杂的情况编写应用程序。您可以使用继承创建类的多个相似但不同版本，而无需从头开始编写类，并且由于多态性，您仍然可以使用原始对象类型的方法来处理新对象。
- en: Makes sense, really! Let's write some classes and then make some objects out
    of them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很有道理！让我们写一些类，然后用它们制作一些对象。
- en: Our first class and first object
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个类和第一个对象
- en: So what exactly is a class? A class is a bunch of code that can contain methods,
    variables, loops, and all other types of Java syntax. A class is part of a package
    and most packages will normally have multiple classes. Usually, but not always,
    each new class will be defined in its own `.java` code file with the same name
    as the class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 那么究竟什么是类？类是一堆代码，可以包含方法、变量、循环和所有其他类型的Java语法。类是包的一部分，大多数包通常会有多个类。通常情况下，每个新类都会在自己的`.java`代码文件中定义，文件名与类名相同。
- en: Once we have written a class, we can use it to make as many objects from it
    as we need. Remember, the class is the blueprint, and we make objects based on
    the blueprint. The house isn't the blueprint just as the object isn't the class;
    it is an object made from the class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们编写了一个类，我们可以使用它来创建我们需要的任意多个对象。记住，类是蓝图，我们根据蓝图制作对象。房子不是蓝图，就像对象不是类；它是从类制作的对象。
- en: 'Here is the code for a class. We call it a class implementation:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类的代码。我们称之为类实现：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: There is also a method called `shootEnemy`. The method has no parameters and
    a `void return` type, but class methods can be of any shape or size that we discussed
    in [Chapter 5](ch05.xhtml "Chapter 5. Gaming and Java Essentials"), *Gaming and
    Java Essentials*.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为`shootEnemy`的方法。该方法没有参数和`void`返回类型，但类方法可以是我们在[第5章](ch05.xhtml "第5章。游戏和Java基础")中讨论的任何形状或大小，*游戏和Java基础*。
- en: When we declare variables in a class, they are known as **fields**. When the
    class is instantiated into a real object, the fields become variables of the object
    itself, so we call them **instance** variables. Whichever fancy name they are
    referred to by, they are just variables of the class. However, the difference
    between fields and variables declared in methods (called the **local** variables)
    becomes more important as we progress. We will look at all types of variables
    again in the *Variables revisited* section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在类中声明变量时，它们被称为**字段**。当类被实例化为一个真正的对象时，这些字段成为对象本身的变量，因此我们称它们为**实例**变量。无论它们被称为什么花哨的名字，它们只是类的变量。然而，随着我们的进展，字段和方法中声明的变量（称为**局部**变量）之间的区别变得更加重要。我们将在*变量重访*部分再次查看所有类型的变量。
- en: 'Remember, this is just a class, not an object. It is a blueprint for a soldier,
    not an actual `soldier` object. This is how we make an object of the `Soldier`
    type from our `Soldier` class:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这只是一个类，不是一个对象。这是一个士兵的蓝图，而不是一个实际的`士兵`对象。这是我们如何从我们的`士兵`类中创建一个`士兵`类型的对象：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the first part of the code, `Soldier mySoldier` declares a new reference
    type variable of type `Soldier`, called `mySoldier`, and in the last part of the
    code, `new Soldier()` creates an actual `Soldier` object. Of course, the assignment
    operator, `=`, in the middle of the two parts assigns the result of the second
    part to that of the first. Just like regular variables, we could also have performed
    the preceding steps like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的第一部分中，`Soldier mySoldier`声明了一个名为`mySoldier`的`Soldier`类型的新引用类型变量，而在代码的最后部分，`new
    Soldier()`创建了一个实际的`Soldier`对象。当然，赋值运算符`=`,将第二部分的结果赋给了第一部分的结果。就像常规变量一样，我们也可以像这样执行前面的步骤：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how we would assign and use the variables:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何分配和使用变量的方式：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: As a rough guide, a class's methods are what it can *do* and its instance variables
    are what it *knows* about itself.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 粗略地说，类的方法是它可以*做*的事情，它的实例变量是它*知道*的关于自己的事情。
- en: 'We can also go ahead by making another `Soldier` object and accessing its methods
    and variables:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以继续制作另一个`Soldier`对象并访问其方法和变量：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It is important to realize that `mySoldier2` is a totally separate object with
    totally separate instance variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到`mySoldier2`是一个完全独立的对象，具有完全独立的实例变量。
- en: Also notice that everything is done on the object itself. We must create objects
    of classes in order to make them useful.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，一切都是在对象本身上完成的。我们必须创建类的对象才能使它们有用。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As always, there are exceptions to this rule, but they are in the minority,
    and we will look at the exceptions later in the chapter. In fact, we have already
    seen an exception way back in [Chapter 3](ch03.xhtml "Chapter 3. Speaking Java
    – Your First Game"), *Speaking Java – Your First Game*. Think of `Toast`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总是有例外情况，但它们是少数，我们将在本章后面再看到这些例外情况。事实上，我们在[第3章](ch03.xhtml "第3章。说Java-你的第一个游戏")中已经看到了一个例外情况，*说Java-你的第一个游戏*。想想`Toast`。
- en: Let's explore basic classes a little more deeply.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地探索基本类。
- en: Basic classes
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本类
- en: What happens when we want an army of `Soldier` objects? We will instantiate
    multiple objects. We will also demonstrate the use of the dot operator on variables
    and methods, and show that different objects have different instance variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要一个`Soldier`对象的军队时会发生什么？我们将实例化多个对象。我们还将演示对变量和方法使用点运算符，并展示不同的对象具有不同的实例变量。
- en: 'You can get the working project for this example in the code download. It is
    in the `chapter6` folder and is called simply `BasicClasses`. Or read on to create
    your own working example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在代码下载中获取此示例的工作项目。它位于`chapter6`文件夹中，简称为`BasicClasses`。或者继续阅读以创建您自己的工作示例：
- en: Create a project with a blank activity, just as we did in [Chapter 2](ch02.xhtml
    "Chapter 2. Getting Started with Android"), *Getting Started with Android*. Clean
    up the code by deleting the unnecessary parts, but this isn't essential. Call
    the application `BasicClasses`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有空白活动的项目，就像我们在[第2章](ch02.xhtml "第2章。开始使用Android")中所做的那样，*开始使用Android*。通过删除不必要的部分来清理代码，但这并非必要。将应用程序命名为`BasicClasses`。
- en: Now we create a new class called `Soldier`. Right-click on the `com.packtpub.basicclasses`
    folder in the Project Explorer window. Click on **New**, then on **Java Class**.
    In the **Name** field, type `Soldier` and click on **OK**. The new class is created
    for us, with a code template ready to put our implementation within, just like
    what is shown in the following screenshot:![Basic classes](img/8859OS_06_01.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们创建一个名为`Soldier`的新类。在项目资源管理器窗口中，右键单击`com.packtpub.basicclasses`文件夹。单击**新建**，然后单击**Java类**。在**名称**字段中，键入`Soldier`，然后单击**确定**。新类已为我们创建，其中包含一个代码模板，准备放入我们的实现，就像以下截图中所示：![Basic
    classes](img/8859OS_06_01.jpg)
- en: 'Notice that Android Studio has put the class in the same package as the rest
    of our app. Now we can write its implementation. Write the following class implementation
    code within the opening and closing curly braces of the `Soldier` class:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，Android Studio已将该类放在与我们应用程序的其余部分相同的包中。现在我们可以编写其实现。在`Soldier`类的开头和结尾大括号内编写以下类实现代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have a class, a blueprint for our future objects of the `Soldier`
    type, we can start to build our army. In the editor window, click on the tab of
    **MainActivity.java**. We will write this code, as so often, within the `onCreate`
    method just after the call to `setContentView`:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了一个类，一个`Soldier`类型的未来对象的蓝图，我们可以开始建立我们的军队。在编辑窗口中，单击**MainActivity.java**选项卡。我们将像往常一样在`onCreate`方法中编写此代码，就在调用`setContentView`之后：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This is a really good time to start taking advantage of the autocomplete feature
    in Android Studio. Notice that after you have declared and created a new object,
    all you have to do is begin typing the object's name and all the autocomplete
    options will present themselves.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始充分利用Android Studio中的自动完成功能了。注意，在声明和创建新对象之后，您只需开始输入对象的名称，所有自动完成选项都会呈现出来。
- en: 'Now that we have our extremely varied and somewhat unlikely army, we can use
    it and also verify the identity of each object. Type the following code below
    the code in the previous step:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了极其多样化且有些不太可能的军队，我们可以使用它，并验证每个对象的身份。在上一步中的代码下面输入以下代码：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can run our app on an emulator. Remember, all the output will be in the
    **LogCat** console window.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在模拟器上运行我们的应用程序。请记住，所有输出都将显示在**LogCat**控制台窗口中。
- en: This is how the preceding pieces of code work. In step 2, Android Studio created
    a template for our new `Soldier` class. In step 3, we implemented our class in
    quite the same way that we have before—two variables, an `int` and a `string`,
    called `health` and `soldierType`, respectively.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是前面的代码是如何工作的。在第2步中，Android Studio为我们的新`Soldier`类创建了一个模板。在第3步中，我们以与以前相同的方式实现了我们的类——两个变量，一个`int`和一个`string`，分别称为`health`和`soldierType`。
- en: 'We also have a method in our class called `shootEnemy`. Let''s look at it again
    and examine what is going on:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类中还有一个名为`shootEnemy`的方法。让我们再次看一下并检查发生了什么：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the body of the method, we print the `soldierType` string to the console
    first, and then the arbitrary `" is shooting"` string. What's neat here is that
    the `soldierType` string will be different depending on which object we call the
    `shootEnemy` method on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法的主体中，我们首先将`soldierType`字符串打印到控制台，然后是任意的`" is shooting"`字符串。这里很棒的是，根据我们调用`shootEnemy`方法的对象不同，`soldierType`字符串也会不同。
- en: In step 4, we declared, created, and assigned three new objects of type `Soldier`.
    They where `rambo`, `vassily`, and `wellington`. In step 5, we initialized each
    with a different value for `health` as well as `soldierType`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们声明、创建和分配了三个新的`Soldier`类型对象。它们是`rambo`、`vassily`和`wellington`。在第5步中，我们为每个对象初始化了不同的`health`和`soldierType`值。
- en: 'Here is the output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that each time we access the `health` variable of each `Soldier` object,
    it is printed to the value we assigned it, demonstrating that although the three
    objects are of the same type, they are completely separate individual objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每次访问每个`Soldier`对象的`health`变量时，它都会打印出我们分配给它的值，这表明尽管这三个对象是相同类型的，它们是完全独立的个体对象。
- en: Perhaps more interesting are the three calls to `shootEnemy`. One call by each
    of our `Soldier` objects' `shootEnemy` method is made, and we print the `soldierType`
    variable to the console. The method has the appropriate value for each individual
    object, further demonstrating that we have three distinct objects, albeit created
    from the same `Soldier` class.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更有趣的是对`shootEnemy`的三次调用。我们的每个`Soldier`对象的`shootEnemy`方法都被调用了一次，并且我们将`soldierType`变量打印到控制台。该方法对每个单独的对象都具有适当的值，进一步证明我们有三个不同的对象，尽管它们是从同一个`Soldier`类创建的。
- en: More things we can do with our first class
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们可以用我们的第一类做更多的事情
- en: 'We can treat a class much like other variables. Assuming we have already implemented
    our `Soldier` class, we can make an array of `Soldier` objects like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像对待其他变量一样对待类。假设我们已经实现了我们的`Soldier`类，我们可以这样创建一个`Soldier`对象的数组：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we can use an object from an array using the same style of array notation
    as we did for regular variables, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以使用与常规变量相同的数组表示法从数组中使用对象，就像这样：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also use a class as an argument in a method call. Here is a hypothetical
    call to a `healSoldier` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在方法调用中使用类作为参数。以下是对`healSoldier`方法的假设调用：
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Of course, the preceding example might raise questions like should the `healSoldier`
    method be a method of a class?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，前面的例子可能会引发问题，比如`healSoldier`方法应该是一个类的方法吗？
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It could be or not (as shown in the previous example). It would depend upon
    what is the best solution for the situation. We will look at more OOP, and then
    the best solution for lots of similar conundrums should present themselves more
    easily.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能是或不是（如前面的例子所示）。这将取决于对于情况来说什么是最好的解决方案。我们将更多地了解面向对象编程，然后许多类似的难题的最佳解决方案应该更容易地呈现出来。
- en: 'As you might have come to expect by now, we can use an object as the return
    value of a method. Here is what the hypothetical `healSoldier` method might look
    like:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你现在可能已经预料到的，我们可以使用对象作为方法的返回值。以下是假设的`healSoldier`方法可能看起来像的样子：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: All of this information will likely raise a few questions. OOP is like that,
    so to try and consolidate all this class stuff with what we already know, let's
    take another look at variables and encapsulation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息可能会引发一些问题。面向对象编程就是这样，因此为了尝试将所有这些类的内容与我们已经知道的内容整合起来，让我们再次看看变量和封装。
- en: Encapsulation
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: So far, what we have really seen is what amounts to a kind of code-organizing
    convention, although we did discuss the wider goals of all this OOP stuff. Now
    we will take things further and begin to see how we actually manage to achieve
    encapsulation with OOP.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们真正看到的是一种代码组织约定，尽管我们确实讨论了所有这些面向对象编程的更广泛目标。现在我们将进一步探讨，并开始看到我们如何实际通过面向对象编程实现封装。
- en: Tip
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Definition of encapsulation**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**封装的定义**'
- en: As we have learned encapsulation means keeping the internal workings of your
    code safe from interference from the programs that use it, allowing only the variables
    and methods you choose to be accessed. This means your code can always be updated,
    extended, or improved without affecting the programs that use it, as long as the
    exposed parts are still made available in the same way. It also allows the code
    that uses your encapsulated code to be much simpler and easier to maintain because
    much of the complexity of the task is encapsulated in your code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，封装意味着保护代码的内部工作方式，使其不受使用它的程序的干扰，只允许访问你选择的变量和方法。这意味着你的代码始终可以更新、扩展或改进，而不会影响使用它的程序，只要暴露的部分仍然以相同的方式提供。它还使使用你封装的代码的代码变得更简单、更容易维护，因为任务的大部分复杂性都封装在你的代码中。
- en: But didn't I say that we don't have to know what is going on inside? So you
    might question what we have seen so far. If we are constantly setting the instance
    variables like this `rambo.health = 100;`, isn't it possible that eventually things
    could start to go wrong, perhaps like the following line of code?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我不是说我们不必知道内部发生了什么吗？所以你可能会质疑到目前为止我们所看到的。如果我们不断地设置实例变量，比如`rambo.health = 100;`，难道不可能最终出现问题，比如以下代码行吗？
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Encapsulation protects your class from being used in a way that it wasn''t
    meant to be. By strictly controlling the way that your code is used, it can only
    ever do what you want it to do, with values you can control. It can''t be forced
    into errors or crashes. Also, you are then free to make changes to the way your
    code works internally, without breaking any programs that are using an older version
    of the code or the rest of your program:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 封装保护了你的类，使其不会被以不符合预期的方式使用。通过严格控制代码的使用方式，它只能做你想让它做的事情，并且你可以控制值。它不会被迫出现错误或崩溃。此外，你可以自由地更改代码的内部工作方式，而不会破坏使用旧版本代码的任何程序或你的程序的其余部分：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We can encapsulate our classes to avoid this, and here is how.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以封装我们的类以避免这种情况，以下是方法。
- en: Controlling the use of classes with access modifiers
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制类的使用
- en: 'The designer of the class controls what can be seen and manipulated by any
    program that uses their class. We can add an **access modifier** before the `class`
    keyword, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类的设计者控制着任何使用他们的类的程序所能看到和操作的内容。我们可以在`class`关键字之前添加一个**访问修饰符**，就像这样：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'There are two class access modifiers. Let''s briefly look at each in turn:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类访问修饰符。让我们依次简要看一下每一个：
- en: '`public`: This is straightforward. A class declared as `public` can be seen
    by all other classes.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：这很简单。声明为`public`的类可以被所有其他类看到。'
- en: '`default`: A class has default access when no access modifier is specified.
    This will make it public but only to classes in the same package, and inaccessible
    to all others.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：当没有指定访问修饰符时，类具有默认访问权限。这将使其对同一包中的类公开，对所有其他类不可访问。'
- en: Now we can make a start with this encapsulation thing. However, even at a glance,
    the access modifiers described are not very fine-grained. We seem to be limited
    to complete lockdown to anything outside the package or a complete free-for-all.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始使用封装了。然而，即使乍一看，所描述的访问修饰符也不是非常精细。我们似乎只能完全封锁包之外的任何东西，或者完全自由。
- en: Actually, the benefits here are easily taken advantage of. The idea would be
    to design a package that fulfills a set of tasks. Then all the complex inner workings
    of the package, the stuff that shouldn't be messed with by anybody but our package,
    should have default access (only accessible to classes within the package). We
    can then provide a careful selection of public classes that can be used by others
    (or other distinct parts of our program).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这里的好处很容易利用。想法是设计一个完成一系列任务的包。然后包的所有复杂内部工作，那些不应该被包之外的任何人干扰的东西，应该具有默认访问权限（只能被包内的类访问）。然后我们可以提供一组精心挑选的公共类，供其他人（或程序的其他不同部分）使用。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: For the size and complexity of the games in this book, multiple packages are
    almost certainly overkill.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书中游戏的规模和复杂性来说，几乎可以肯定地说，多个包是过度的。
- en: Class access in a nutshell
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类访问权限的要点
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能包含一个或多个包，每个包只包含默认或默认和公共类。
- en: In addition to class-level privacy controls, Java gives us very fine-grained
    controls, but to use these controls, we have to look at variables in more detail.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了类级别的隐私控制，Java还给了我们非常精细的控制，但要使用这些控制，我们必须更详细地查看变量。
- en: Controlling the use of variables with access modifiers
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问修饰符控制变量的使用
- en: 'To build on class visibility controls, we have variable access modifiers. Here
    is a variable with the private access modifier being declared:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加强类的可见性控制，我们有变量访问修饰符。这里有一个使用private访问修饰符声明的变量：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note also that all of our discussion of variable access modifiers applies to
    object variables too. For example, here is an instance of our `Soldier` class
    being declared, created, and assigned. As you can see, the access specified in
    this case is public:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们对变量访问修饰符的讨论也适用于对象变量。例如，这里声明、创建和分配了我们的`Soldier`类的一个实例。正如你所看到的，这种情况下指定的访问权限是public：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Before you apply a modifier to a variable, you must first consider the class
    visibility. If class `a` is not visible to class `b`, say because class `a` has
    default access and class `b` is in another package, then it doesn't make any difference
    what access modifiers you use on the variables in class `a`; class `b` still can't
    see it.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在将修饰符应用于变量之前，您必须首先考虑类的可见性。如果类`a`对类`b`不可见，比如因为类`a`具有默认访问权限，而类`b`在另一个包中，那么在类`a`的变量上使用任何访问修饰符都没有任何影响；类`b`仍然看不到它。
- en: Thus, it makes sense to show a class to another class when necessary, but you
    should only expose the variables that are needed—not everything.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将一个类显示给另一个类是有意义的，但你应该只暴露需要的变量，而不是所有的变量。
- en: We have a bit more to cover on access modifiers, and then we will look at a
    few examples to help clarify things. For now, here is an explanation of the different
    variable access modifiers. They are more numerous and fine-grained than the class
    access modifiers. Most of the explanations are straightforward, and the ones that
    might raise questions will become clearer when we look at an example.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有更多关于访问修饰符的内容要讲，然后我们将看一些示例来帮助澄清事情。现在，这里是不同的变量访问修饰符的解释。它们比类访问修饰符更多，更精细。大多数解释都很直接，而可能引起问题的解释在我们看一个例子时会变得更清晰。
- en: 'The depth and complexity of access modification is not so much in the range
    of modifiers, but by using them in smart ways, we can combine them to achieve
    the worthy goals of encapsulation. Here are the variable access modifiers:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修改的深度和复杂性并不在于修饰符的范围，而是通过巧妙地使用它们，我们可以将它们结合起来实现封装的值得目标。以下是变量访问修饰符：
- en: '`public`: You guessed it! Any class or method from any package can see this
    variable. Use `public` only when you are sure that this is what you want.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`：你猜对了！来自任何包的任何类或方法都可以看到这个变量。只有当你确定这就是你想要的时候才使用`public`。'
- en: '`protected`: This is the next least restrictive modifier after `public`. `protected`
    Variables set as protected can be seen by any class and any method as long as
    they are in the same package.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`protected`：这是在`public`之后的下一个最不限制的修饰符。设置为protected的变量可以被同一包中的任何类和任何方法看到。'
- en: '`default`: This doesn''t sound as restrictive as `protected`, but it is more
    so. A variable has default access when no access is specified. The fact that `default`
    is restrictive perhaps implies that we should be thinking on the side of hiding
    our variables rather than exposing them. At this point, we need to introduce a
    new concept. Do you remember that we briefly discussed inheritance, and how we
    can quickly take on the attributes of a class and yet refine it using the `extends`
    keyword? Just for the record, default access variables are not visible to subclasses.
    This means that when we extend a class like we did with `Activity`, we cannot
    see its default variables. We will look at inheritance in more detail later in
    the chapter.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：这听起来不像`protected`那么限制，但实际上更加限制。当没有指定访问权限时，变量具有默认访问权限。`default`更加限制可能意味着我们应该考虑隐藏变量而不是暴露它们。在这一点上，我们需要介绍一个新概念。你还记得我们简要讨论过继承吗，以及我们如何可以快速地继承一个类的属性，然后使用`extends`关键字对其进行改进吗？只是为了记录，default访问权限的变量对子类不可见。这意味着当我们像我们在`Activity`中所做的那样扩展一个类时，我们无法看到它的默认变量。我们将在本章后面更详细地讨论继承。'
- en: '`private`: These variables can only be seen within the class they are declared.
    Like default access, they cannot be seen by subclasses (inherited classes).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`：这些变量只能在它们声明的类内部看到。与默认访问一样，它们不能被子类（继承类）看到。'
- en: Variable access in a nutshell
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量访问简而言之
- en: A well-designed app will probably consist of one or more packages, each containing
    only default or default and public classes. Within these classes, variables will
    have carefully chosen and most likely varied access modifiers.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的应用程序可能由一个或多个包组成，每个包只包含默认或默认和公共类。在这些类中，变量将具有精心选择的访问修饰符，很可能是不同的。
- en: There's one more twist in all this access modification stuff before we get practical
    with it.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始实际操作之前，这些访问修改的东西还有一个小小的转折。
- en: Methods have access modifiers too
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也有访问修饰符
- en: It makes sense that methods are the things that our classes can do. We will
    want to control what users of our class can and can't do. The general idea here
    is that some methods will do things internally only and are therefore not needed
    by users of the class, and some methods will be fundamental to how users use your
    class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是我们的类可以做的事情。我们将要控制我们的类的用户可以做什么，不能做什么。这里的一般想法是，一些方法只会在内部执行，因此不需要类的用户，而一些方法将是用户使用类的基本方法。
- en: The access modifiers for methods are the same as those for the class variables.
    This makes things easy to remember but suggests again that successful encapsulation
    is a matter of design rather than any specific set of rules.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的访问修饰符与类变量的访问修饰符相同。这使得事情容易记住，但再次表明成功的封装是一种设计问题，而不是任何特定的规则。
- en: 'As an example, the method in the following code snippet, provided in a public
    class, can be used by any other class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段中提供的公共类中的方法可以被任何其他类使用：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, the following method can only be used internally by the class that
    created it:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下方法只能被创建它的类内部使用：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The next method has default visibility with no access specified. It can be
    used only by other classes in the same package. If we extend the class containing
    this default access method, the class will not have access to this method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个方法具有默认可见性，没有指定访问权限。它只能被同一包中的其他类使用。如果我们扩展包含此默认访问方法的类，该类将无法访问此方法：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here is a last example before we move on. It contains a `protected` method,
    only visible to the package, but usable by our classes that extend it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，这是最后一个例子。它包含一个`protected`方法，只对包可见，但可以被扩展它的类使用：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Method access in a nutshell
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法访问简而言之
- en: Method access should be chosen to best enforce the principles we have already
    discussed. It should provide the users of your class with just the access they
    need, and preferably nothing more. Thereby, we achieve our encapsulation goals
    such as keeping the internal workings of your code safe from interference from
    the programs that use it, for all the reasons we have discussed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 应该选择方法访问权限以最好地执行我们已经讨论过的原则。它应该为您的类的用户提供所需的访问权限，最好是没有更多。因此，我们实现了封装目标，例如使代码的内部工作免受使用它的程序的干扰，出于我们已经讨论过的所有原因。
- en: Accessing private variables with the getter and setter methods
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用getter和setter方法访问私有变量
- en: So if it is best practice to hide our variables away as private, how do we allow
    access to them without spoiling our encapsulation? What if an object of the `Hospital`
    class wanted access to the `health` member variable from an object of type `Soldier`
    so that it could increase it? The `health` variable should be private, right?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将变量尽可能隐藏为私有是最佳实践，那么如何在不破坏封装的情况下允许访问它们呢？如果`Hospital`类的对象想要访问`Soldier`类型对象的`health`成员变量以增加它，`health`变量应该是私有的，对吗？
- en: In order to be able to make as many member variables as possible private and
    yet allow some kind of limited access to some of them, we use **getters** and
    **setters**. Getters and setters are methods that just get and set variable values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够尽可能将成员变量设为私有，同时允许对其中一些进行有限访问，我们使用**getter**和**setter**。Getter和setter是只获取和设置变量值的方法。
- en: This is not some special or new Java thing we have to learn. It is just a convention
    for the use of what we already know. Let's take a look at getters and setters
    using the example of our `Soldier` and `Hospital` classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是我们必须学习的一些特殊或新的Java东西。这只是对我们已经知道的东西的使用约定。让我们以我们的`Soldier`和`Hospital`类为例，看看使用getter和setter。
- en: 'In this example, each of our two classes are created in their own file but
    the same package. First of all, here is our hypothetical `Hospital` class:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的两个类分别在自己的文件中创建，但在同一个包中。首先，这是我们假设的`Hospital`类：
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Our implementation of the `Hospital` class has just one method, `healSoldier`.
    It receives a reference to a `Soldier` object as a parameter, so this method will
    work on whichever `Soldier` object is passed in: `vassily`, `wellington`, `rambo`,
    or whoever.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Hospital`类的实现只有一个方法`healSoldier`。它接收一个`Soldier`对象的引用作为参数，因此这个方法将在传入的任何`Soldier`对象上工作：`vassily`，`wellington`，`rambo`，或其他人。
- en: It also has a `health` variable. It uses this variable to temporarily hold and
    increase the soldier's health. In the same line, it initializes the `health` variable
    to the `Soldier` object's current health. The `Soldier` object's `health` is private,
    so the public getter method is used instead.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个`health`变量。它使用这个变量来临时保存并增加士兵的健康。在同一行中，它将`health`变量初始化为`Soldier`对象的当前健康状况。`Soldier`对象的`health`是私有的，因此使用公共的getter方法。
- en: Then `health` is increased by 10 and the `setHealth` setter method loads the
    new `health` value back to the `Soldier` object.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`health`增加了10，`setHealth`设置器方法将新的`health`值加载回`Soldier`对象。
- en: The key here is that although a `Hospital` object can change a `Soldier` object's
    health, it does so within the bounds of the getter and setter methods. The getter
    and setter methods can be written to control and check for potentially erroneous
    or harmful values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于，尽管`Hospital`对象可以改变`Soldier`对象的健康状况，但它是在getter和setter方法的范围内进行的。getter和setter方法可以被编写来控制和检查潜在的错误或有害的值。
- en: 'Next comes our hypothetical `Soldier` class, with the simplest implementation
    possible of it''s getter and setter methods:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是我们假设的`Soldier`类，具有最简单的getter和setter方法的实现：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We have one instance variable called `health` and it is private. Private means
    it can only be changed by methods of the `Soldier` class. We then have a public
    `getHealth` method, which unsurprisingly returns the value held in the private
    `health` variable of the `int` type. As this method is public, anyone with access
    to the `Soldier` class can use it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`health`的实例变量，它是私有的。私有意味着它只能被`Soldier`类的方法更改。然后我们有一个公共的`getHealth`方法，不出所料地返回`int`类型的私有`health`变量中保存的值。由于这个方法是公共的，任何有权访问`Soldier`类的人都可以使用它。
- en: Next, the `setHealth` method is implemented. Again it is public, but this time,
    it takes `int` as a parameter and assigns whatever value is passed to the private
    `health` variable. In a more life-like example, we would write some more code
    here to ensure that the value passed is within the bounds we expect.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，实现了`setHealth`方法。同样它是公共的，但这次它以`int`作为参数，并将传递的任何值分配给私有的`health`变量。在一个更贴近生活的例子中，我们会在这里编写更多的代码来确保传递的值在我们期望的范围内。
- en: 'Now we will declare, create, and assign to make an object of each of our two
    new classes and see how our getters and setters work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将声明、创建并分配我们两个新类的对象，并看看我们的getter和setter是如何工作的：
- en: '[PRE29]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We see that we can call our public `setHealth` and `getHealth` methods directly
    on our object of type `Soldier`. Not only that, we can also call the `healSoldier`
    method of the `Hospital` object, passing in a reference to the `Soldier` object,
    which can use the public getters and setters to manipulate the private `health`
    variable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们可以直接在我们的`Soldier`类型的对象上调用我们的公共`setHealth`和`getHealth`方法。不仅如此，我们还可以调用`Hospital`对象的`healSoldier`方法，传递一个对`Soldier`对象的引用，后者可以使用公共的getter和setter来操作私有的`health`变量。
- en: We see that the private `health` variable is simply accessible, yet totally
    within the control of the designer of the `Soldier` class.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到私有的`health`变量是可以被简单访问的，但完全受`Soldier`类的设计者控制。
- en: If you want to play around with this example, there is a working app in the
    code bundle in the `Chapter6` folder, called `Getters And Setters`. I have added
    a few lines of code to print to the console. We deliberately covered this the
    way we did to keep the key parts of the code as clear as possible. We will soon
    build some real working examples that explore class, variable, and method access.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下这个例子，在`Chapter6`文件夹的代码包中有一个可用的应用程序，名为`Getters And Setters`。我添加了几行代码来打印到控制台。我们故意以这种方式来覆盖它，以尽可能清晰地保留代码的关键部分。我们很快将构建一些真正的工作示例，探索类、变量和方法的访问。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Getters and setters are sometimes referred to by their more correct names, **Accessors**
    and **Mutators**. We will stick to getters and setters. Just thought you might
    like to know.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: Getter和setter有时被称为它们更正确的名称，**访问器**和**修改器**。我们将坚持使用getter和setter。只是想让你知道。
- en: 'Yet again, our example and the explanation are probably raising more questions.
    That''s good! Previously, I said that:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们的例子和解释可能引起更多的问题。这很好！之前，我说过：
- en: There are two access modifiers for a class, default and public
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类有两种访问修饰符，默认和公共
- en: Objects of classes are a type of reference variable
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的对象是一种引用变量的类型
- en: Variables (including objects) have even more access possibilities
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（包括对象）有更多的访问可能性
- en: We need to look more closely at reference and primitive variables as well as
    local and instance variables. We will do so in a moment in the *Variables revisited*
    section. In that section, we will consolidate our information further to get a
    tighter grip on this OOP stuff. First let's remind ourselves of a bit about encapsulation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更仔细地查看引用和原始变量，以及局部和实例变量。我们将在“变量重访”部分进行。在该部分，我们将进一步整合我们的信息，以更紧密地掌握这个面向对象的编程知识。首先让我们回顾一下封装的一些内容。
- en: Using encapsulation features (such as access control) is like signing a really
    important deal about how to use and access a class, its methods, and its variables.
    The contract is not just an agreement about the present but an implied guarantee
    for the future. We will see that as we proceed through this chapter, there are
    more ways that we refine and strengthen this contract.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用封装特性（如访问控制）就像签署一项关于如何使用和访问类、它的方法和变量的非常重要的协议。这个合同不仅仅是关于现在的协议，还隐含着对未来的保证。随着我们在本章的进展，我们将看到更多的方式来完善和加强这个合同。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is perfectly possible to rewrite every example in this book without thinking
    or caring about encapsulation. In fact, the projects in this book outside of this
    chapter are quite lax about encapsulation.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 完全可以在不考虑封装的情况下重写本书中的每个示例。事实上，本章之外的本书中的项目对封装非常宽松。
- en: Use encapsulation where it is needed or, of course, if you are being paid to
    use it by an employer. Often encapsulation is overkill on small learning projects,
    such as the games in this book, except when the topic you are learning is encapsulation
    itself.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要的时候使用封装，或者当然，如果你被雇主付费使用它。通常封装在小型学习项目中是多余的，比如本书中的游戏，除非你学习的主题本身就是封装。
- en: We are learning this Java OOP stuff under the assumption that you will one day
    want to write much more complex apps, whether on Android or some other platform
    that uses OOP.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习这个Java OOP的知识是基于这样一个假设，即有一天你会想要在Android或其他使用OOP的平台上编写更复杂的应用程序。
- en: Setting up our objects with constructors
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构造函数设置我们的对象。
- en: 'With all of these private variables and their getters and setters, does it
    mean that we need a getter and a setter for every private variable? What about
    a class with lots of variables that need initializing at the start? Think about
    this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些私有变量及其getter和setter，这是否意味着我们需要为每个私有变量都需要一个getter和setter？那么对于一个需要在开始时初始化许多变量的类呢？想想这个：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We could go on like this. Some of these variables might need getters and setters,
    but what if we just want to set things up when the object is first created to
    make the object function correctly? Do we need two methods (a getter and a setter)
    for each?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续这样下去。其中一些变量可能需要getter和setter，但如果我们只想在对象首次创建时设置好一切，以使对象正确运行，我们需要两个方法（一个getter和一个setter）吗？
- en: 'For this, we have a special method called a constructor. Here, we create an
    object of type `Soldier` and assign it to an object called `mySoldier`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们有一个特殊的方法称为构造函数。在这里，我们创建了一个名为`mySoldier`的对象，并将其分配给`Soldier`类型的对象：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There''s nothing new here, but look at the last part of that line of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么新鲜事，但看一下代码行的最后部分：
- en: '[PRE32]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This looks suspiciously like a method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来非常像一个方法。
- en: We have called a special method called a constructor that has been supplied
    automatically for us by the compiler.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了一个特殊的方法，称为构造函数，它已经被编译器自动为我们提供。
- en: 'However (and this is getting to the point now), like a method, we can override
    it, which means we can do really useful things to set up our new object *before*
    it is used and any of its methods are placed on the stack:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而（这就是现在的重点），就像方法一样，我们可以重写它，这意味着我们可以在使用新对象之前做一些非常有用的事情，并且在堆栈上放置任何方法之前：
- en: '[PRE33]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is a constructor. It has a lot of syntactical similarities to a method.
    It can only be run with the use of the `new` keyword. It is created for us automatically
    by the compiler unless we create our own like in the previous code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构造函数。它在语法上与方法有很多相似之处。它只能通过使用`new`关键字来运行。除非我们像在先前的代码中那样创建自己的构造函数，否则它会被编译器自动创建。
- en: 'Constructors have the following properties:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数具有以下属性：
- en: They have no return type
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们没有返回类型
- en: They have the same name as the class
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们与类名相同
- en: They can have parameters
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以有参数
- en: They can be overloaded
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可以被重载
- en: We will play with constructors in the next demo.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一个演示中使用构造函数。
- en: Variables revisited
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量重温
- en: You probably remember, back in the math game project, that we kept changing
    where we declared our variables. First, we declared some in `onCreate`, then we
    moved them to just below the class declaration, and then we were making them member
    or instance variables.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得，在数学游戏项目中，我们不断更改变量的声明位置。首先，我们在`onCreate`中声明了一些变量，然后我们将它们移动到类声明的下方，然后我们将它们变成成员或实例变量。
- en: Because we didn't specify the access, they were of default access and visible
    to the whole class, and as everything took place in the one class, we could access
    them everywhere. For example, we could update our TextView type objects from `onClick`,
    but why couldn't we do that when they were declared in `onCreate`? Further explanation
    about when and how we can access different variables is probably going to be useful.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有指定访问权限，它们是默认访问权限，并且对整个类可见，由于所有操作都发生在一个类中，我们可以随处访问它们。例如，我们可以从`onClick`更新我们的TextView类型对象，但是为什么我们不能在`onCreate`中声明它们时就这样做呢？关于何时以及如何访问不同变量的进一步解释可能会很有用。
- en: The stack and the heap
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 堆栈和堆
- en: The VM inside every Android device takes care of memory allocation to our games.
    In addition, it stores different types of variables in different places.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android设备内部的虚拟机负责为我们的游戏分配内存。此外，它将不同类型的变量存储在不同的位置。
- en: Variables that we declare and initialize in methods are stored on the area of
    memory known as the `stack`. We can stick to our warehouse analogy when talking
    about the stack—almost. We already know how we can manipulate the stack.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法中声明和初始化的变量存储在称为`堆栈`的内存区域中。在谈论堆栈时，我们可以沿用我们的仓库类比——几乎是。我们已经知道我们可以如何操作堆栈。
- en: Let's talk about the heap and what is stored there. All reference type objects,
    which include objects (of classes) and arrays, are stored in the heap. Think of
    the heap as a separate area of the same warehouse. The heap has lots of floor
    space for odd-shaped objects, racks for smaller objects, lots of long rows with
    smaller sized cube-shaped holes for arrays, and so on. This is where our objects
    are stored. The problem is that we have no direct access to the heap.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈堆以及存储在其中的内容。所有引用类型对象，包括对象（类）和数组，都存储在堆中。将堆视为同一仓库的另一个区域。堆有大量的地板空间用于奇形怪状的对象，用于较小对象的货架，用于数组的大量长排和较小尺寸的立方体孔，等等。这是我们的对象存储的地方。问题是我们无法直接访问堆。
- en: Let's look again at what exactly a reference variable is. It is a variable that
    we refer to and use via a reference. A reference can be loosely (but usefully)
    defined as an address or location. The reference (address or location) of the
    object is on the stack. When we use the dot operator, we are asking Dalvik to
    perform a task at a specific location as stored in the reference.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看引用变量到底是什么。它是一个我们引用并通过引用使用的变量。引用可以宽泛地（但有用地）定义为一个地址或位置。对象的引用（地址或位置）在堆栈上。当我们使用点运算符时，我们要求Dalvik在引用中存储的特定位置执行任务。
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Reference variables are just that—a reference. They are a way to access and
    manipulate the object (variables or methods), but they are not the actual variable.
    An analogy might be that primitives are right there (on the stack) but references
    are an address, and we say what to do at the address. In this analogy, all addresses
    are on the heap.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 引用变量就是这样——一个引用。它们是访问和操作对象（变量或方法）的一种方式，但它们不是实际的变量。类比可能是，基本类型就在那里（在堆栈上），但引用是一个地址，我们说在地址上该做什么。在这个类比中，所有地址都在堆上。
- en: Why would we ever want a system like this? Just give me my objects on the stack
    already!
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么要有这样的系统？直接把对象放在堆栈上就行了！
- en: A quick break to throw out the trash
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 快速休息一下，扔掉垃圾
- en: Remember way back in the first chapter when I said Java was easier to learn
    than some languages because it helps us manage the memory? Well, this whole stack
    and heap thing does that for us.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得在第一章时我说Java比一些语言更容易学习，因为它帮助我们管理内存吗？嗯，这整个堆栈和堆的东西就是为我们做的。
- en: As we know, the VM keeps track of all our objects for us and stores them in
    the heap—a special area of our warehouse. Periodically, the VM will scan the stack,
    or the regular racks of our warehouse, and match references to objects. If it
    finds any objects without a matching reference, it destroys them. In Java terminology,
    it performs garbage collection. Think of a very discriminating refuse vehicle
    driving through the middle of our heap, scanning objects to match to references.
    No reference? You're garbage now! After all, if an object has no reference variable,
    we can't possibly do anything with it anyway. This system of garbage collection
    helps our games run more efficiently by freeing unused memory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，VM会为我们跟踪所有的对象，并将它们存储在堆中——我们仓库的一个特殊区域。定期，VM会扫描堆栈，或者我们仓库的常规货架，并将对象与引用进行匹配。如果它发现任何没有匹配引用的对象，它会销毁它们。在Java术语中，它执行垃圾回收。想象一辆非常歧视性的垃圾车驶过我们堆的中心，扫描对象以匹配引用。没有引用？你现在是垃圾！毕竟，如果一个对象没有引用变量，我们无法对其进行任何操作。这种垃圾回收系统通过释放未使用的内存帮助我们的游戏更有效地运行。
- en: So variables declared in a method are local, on the stack, and only visible
    within the method they were declared. A member variable is on the heap and can
    be referenced from any place where there is a reference to it, provided the access
    specification allows the referencing.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在方法中声明的变量是局部的，在堆栈上，并且只能在声明它们的方法内部可见。成员变量在堆上，并且可以在有引用的任何地方引用它，前提是访问规范允许引用。
- en: Now we can take a closer look at the variable scope—what can be seen from where.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更仔细地看一下变量范围——从哪里可以看到什么。
- en: There are more twists and turns to be learned with regard to variables. In the
    next demo, we will explore all we have learned so far in this chapter and some
    new ideas too.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 关于变量还有更多的技巧和转折需要学习。在下一个演示中，我们将探索本章迄今为止学到的所有内容以及一些新的想法。
- en: 'We will look at the following topics:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究以下主题：
- en: Static variables that are consistent (the same) across every instance of a class
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态变量在类的每个实例中都是一致的（相同的）
- en: Static methods of a class where you can use the methods of a class without an
    object of that class type
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的静态方法，可以在没有该类类型对象的情况下使用类的方法
- en: We will demonstrate the scope of class and local variables, and where they can
    and can't be seen by different parts of the program
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将演示类和局部变量的范围，以及它们在程序的不同部分中可以和不能被看到的地方
- en: We will look at the `this` keyword, which allows us to write code that refers
    to variables that belong to a specific instance of a class, but without keeping
    track of which instance we are currently using
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将研究`this`关键字，它允许我们编写引用属于特定类实例的变量的代码，但不需要跟踪我们当前使用的实例是哪个
- en: The following is the demo.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示。
- en: Access, scope, this, static, and constructors demo
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问、范围、this、静态和构造函数演示
- en: 'We have looked at the intricate way by which access to variables and their
    scope is controlled, and it would probably serve us well to look at an example
    of them in action. These will not be very practical real-world examples of variable
    use, but more of a demonstration to help understand access modifiers for classes,
    methods, and variables, alongside the different types of variables such as reference
    (or primitive) and local (or instance). Then we will cover the new concepts of
    static and final variables and the `this` keyword. The completed project is in
    the `Chapter6` folder of the code download. It is called `AccessScopeThisAndStatic`.
    We will now perform the following steps to implement it:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了控制变量访问和范围的复杂方式，现在可能会对我们有所帮助，看一个实际应用的例子。这些不会是非常实际的真实世界变量使用示例，而更多是为了帮助理解类、方法和变量的访问修饰符，以及引用（或原始）和局部（或实例）等不同类型的变量的演示。然后我们将介绍静态和最终变量以及`this`关键字的新概念。完成的项目在代码下载的`Chapter6`文件夹中。它被称为`AccessScopeThisAndStatic`。我们现在将执行以下步骤来实现它：
- en: Create a new blank activity project and call it `AccessScopeThisAndStatic`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空白活动项目，并将其命名为`AccessScopeThisAndStatic`。
- en: Create a new class by right-clicking on the existing `MainActivity` class in
    the Project Explorer and navigating to **New** | **Class**. Name the new class
    `AlienShip`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在项目资源管理器中右键单击现有的`MainActivity`类并导航到**新建** | **类**来创建一个新类。将新类命名为`AlienShip`。
- en: 'Now we declare our new class and some member variables. Note that `numShips`
    is private and static. We will soon see how this variable is the same across all
    instances of the class. The `shieldStrength` variable is `private` and `shipName`
    is `public`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们声明我们的新类和一些成员变量。请注意，`numShips`是私有的和静态的。我们很快就会看到这个变量在类的所有实例中是相同的。`shieldStrength`变量是`private`的，`shipName`是`public`的：
- en: '[PRE34]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next is the constructor. We can see that the constructor is public, has no
    return type, and has the same name as the class, as per the rules. In it, we increment
    the private static `numShips` variable. Remember that this will happen each time
    we create a new object of the `AlienShip` type. The constructor also sets a value
    for the `shieldStrength` private variable using the private `setShieldStrength`
    method:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是构造函数。我们可以看到构造函数是公共的，没有返回类型，并且与类名相同，符合规则。在其中，我们递增了私有静态`numShips`变量。请记住，每次创建`AlienShip`类型的新对象时都会发生这种情况。构造函数还使用私有的`setShieldStrength`方法为`shieldStrength`私有变量设置一个值：
- en: '[PRE35]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Here is the public static getter method that classes outside `AlienShip` can
    use to find out how many `AlienShip` objects are there. We will also see the unusual
    way in which we use static methods:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是公共静态getter方法，外部`AlienShip`类可以使用它来找出有多少`AlienShip`对象。我们还将看到我们使用静态方法的不寻常方式：
- en: '[PRE36]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The following code shows our private `setShieldStrength` method. We could have
    just set `shieldStrength` directly from within the class, but this code shows
    how we can distinguish between the `shieldStrength` local variable/parameter and
    the `shieldStrength` member variable using the `this` keyword:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码显示了我们的私有`setShieldStrength`方法。我们本可以直接从类内部设置`shieldStrength`，但这段代码展示了我们如何使用`this`关键字区分`shieldStrength`局部变量/参数和`shieldStrength`成员变量：
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This next method is the getter, so other classes can read but not alter the
    shield strength of each `AlienShip` object:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的方法是getter，所以其他类可以读取但不能改变每个`AlienShip`对象的护盾强度：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we have a public method that can be called every time an `AlienShip` object
    is hit. It just prints to the console and then checks whether that particular
    object''s `shieldStrength` is zero. If it is zero, it calls the `destroyShip`
    method, which we look at next:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个公共方法，每次击中`AlienShip`对象时都可以调用它。它只是打印到控制台，然后检查该特定对象的`shieldStrength`是否为零。如果为零，它调用`destroyShip`方法，接下来我们将看到：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we will look at the `destroyShip` method for our `AlienShip` class.
    We print a message that indicates which ship has been destroyed, based on its
    `shipName`, as well as increment the `numShips` static variable so that we can
    keep track of the number of objects of the `AlienShip` type we have:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将看一下我们的`AlienShip`类的`destroyShip`方法。我们打印一条消息，指示哪艘飞船已被摧毁，基于它的`shipName`，并递增`numShips`静态变量，以便我们可以跟踪`AlienShip`类型的对象数量：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we switch over to our `MainActivity` class and write some code that uses
    our new `AlienShip` class. All of the code goes in the `onCreate` method after
    the call to `setContentView`. First, we create two new `AlienShip` objects called
    `girlShip` and `boyShip`:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们切换到我们的`MainActivity`类，并编写一些使用我们的新`AlienShip`类的代码。所有的代码都放在`setContentView`调用之后的`onCreate`方法中。首先，我们创建两个名为`girlShip`和`boyShip`的新的`AlienShip`对象：
- en: '[PRE41]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Look how we get the value in `numShips`. We use the `getNumShips` method as
    we might expect. However, look closely at the syntax. We are using the class name
    and not an object. We can also access static variables with methods that are not
    static. We did it this way to see a static method in action:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看我们如何获取`numShips`中的值。我们使用`getNumShips`方法，正如我们所期望的那样。然而，仔细看语法。我们使用的是类名而不是对象。我们还可以使用非静态的方法访问静态变量。我们这样做是为了看到静态方法的运行情况：
- en: '[PRE42]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now we assign names to our public `shipName` string variables:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们给我们的公共`shipName`字符串变量分配名称：
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If we attempt to assign a value directly to a private variable, it won''t work.
    Therefore, we use the public `getShieldStrength` getter method to print the value
    of `shieldStrength`, which was assigned to the constructor:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试直接为私有变量分配一个值，它不起作用。因此，我们使用公共的`getShieldStrength` getter方法来打印`shieldStrength`的值，这个值是分配给构造函数的：
- en: '[PRE44]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, we get to blow some stuff up by playing with the `hitDetected` method
    and occasionally checking the shield strength of our two objects:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过玩`hitDetected`方法和偶尔检查我们两个对象的护盾强度来炸毁一些东西：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When we think we have destroyed a ship, we again use our static `getNumShips`
    method to check whether our static variable `numShips` was changed by the `destroyShip`
    method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们认为我们已经摧毁了一艘飞船时，我们再次使用我们的静态`getNumShips`方法来检查我们的静态变量`numShips`是否被`destroyShip`方法改变了：
- en: '[PRE46]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Run the demo and look at the console output.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行演示并查看控制台输出。
- en: 'Here is the output of the preceding blocks of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码块的输出：
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the previous example, we saw that we can distinguish between local and member
    variables of the same name using the `this` keyword. We can also use the `this`
    keyword to write code that refers to the current object being acted upon.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到我们可以使用`this`关键字区分相同名称的局部变量和成员变量。我们还可以使用`this`关键字编写引用当前对象的代码。
- en: We saw that a static variable, in this case `numShips`, is consistent across
    all instances. Moreover, by incrementing it in the constructor and decrementing
    it in our `destroyShip` method, we can keep track of the number of `AlienShip`
    objects we created.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到静态变量，在这种情况下是`numShips`，在所有实例中是一致的。此外，通过在构造函数中递增它，并在我们的`destroyShip`方法中递减它，我们可以跟踪我们创建的`AlienShip`对象的数量。
- en: We also saw that we can use static methods by writing the class name with the
    dot operator instead of an object.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到我们可以通过写类名和点运算符而不是对象来使用静态方法。
- en: Finally, we demonstrated how we could hide and expose certain methods and variables
    using an access specifier.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们演示了如何使用访问修饰符隐藏和暴露某些方法和变量。
- en: Let's take a look at a quick review of the stack and the heap before we move
    on to something new.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行新的内容之前，让我们快速回顾一下栈和堆。
- en: A quick summary on stack and heap
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于栈和堆的快速总结
- en: 'Let''s look at what we learned about the stack and the heap:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于堆和栈的知识：
- en: You don't delete objects but the VM sends the garbage collector when it thinks
    it is appropriate. This is usually done when there is no active reference to the
    object.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不会删除对象，但是虚拟机在认为合适时会发送垃圾收集器。通常是在对象没有活动引用时执行。
- en: Local variables and methods are on the stack, and local variables are local
    to the specific method within which they were declared.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量和方法在栈上，局部变量是在声明它们的特定方法中局部的。
- en: Instance or class variables are on the heap (with their objects) but the reference
    to the object (address) is a local variable on the stack.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例或类变量在堆上（与它们的对象一起），但对对象的引用（地址）是栈上的局部变量。
- en: We control what goes inside the stack. We can use the objects on the heap but
    only by referencing them.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们控制栈内的内容。我们可以使用堆上的对象，但只能通过引用它们。
- en: The heap is maintained by the garbage collector.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆由垃圾收集器维护。
- en: An object is garbage collected when there is no longer a valid reference to
    it. Therefore, when a reference variable, local or instance, is removed from the
    stack, then its related object becomes viable for garbage collection, and when
    the virtual machine decides the time is right (usually very promptly), it will
    free the RAM memory to avoid running out.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当不再有有效引用指向对象时，对象将被垃圾回收。因此，当引用变量（局部或实例）从堆栈中移除时，与之相关的对象就可以进行垃圾回收，当虚拟机决定时机合适时（通常非常迅速），它将释放RAM内存以避免耗尽。
- en: If we try to reference an object that doesn't exist, we will get a **null pointer
    exception** and the game will crash.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们尝试引用一个不存在的对象，我们将得到一个**空指针异常**，游戏将崩溃。
- en: Inheritance
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: We have seen how we can use other people's hard work by instantiating/creating
    objects from the classes of an API such as that of Android, but this whole OOP
    thing goes even further than that.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了我们可以通过实例化/创建来自Android等API的类的对象来使用其他人的辛勤工作，但是这整个面向对象的东西甚至比这更深入。
- en: What if there is a class that has loads of useful functionality in it but not
    quite what we want? We can inherit from the class and then further refine or add
    to how it works and what it does.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个类中有大量有用的功能，但不完全符合我们的要求，我们可以从该类继承，然后进一步完善或添加其工作方式和功能。
- en: 'You might be surprised to hear that we have done this already. In fact, we
    have done this with every single game and demo we looked at. When we use the `extends`
    keyword, we are inheriting, for example, in this line of code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶地听到我们已经这样做了。事实上，我们在每个游戏和演示中都这样做了。当我们使用`extends`关键字时，我们正在继承，例如，在这行代码中：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Here, we are inheriting the `Activity` class along with all its functionality,
    or more specifically, all of the functionality that the class designers want us
    to have access to. Here are some of the things we can do to classes we have extended.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们继承了`Activity`类以及其所有功能，或者更具体地说，类设计者希望我们能够访问的所有功能。以下是我们可以对我们扩展的类做的一些事情。
- en: 'We can override a method and still rely in part on the overridden method in
    the class we inherit from. For example, we overrode the `onCreate` method every
    time we extended the `Activity` class, but we also called the default implementation
    provided by the class designers when we did this:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写一个方法，但仍然部分依赖于我们继承的类中被重写的方法。例如，每次我们扩展`Activity`类时，我们都重写了`onCreate`方法，但我们也调用了类设计者提供的默认实现时：
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next chapter, we will also be overriding some more methods of the `Activity`
    class. Specifically, we'll override the methods that handle the lifecycle.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们还将重写`Activity`类的一些方法。具体来说，我们将重写处理生命周期的方法。
- en: If we or the designer of a class wants to force us to inherit before we use
    their class, they can declare a class as **abstract**. Then we cannot make an
    object from it. Therefore, we must extend it first and make an object from the
    subclass. We will do this in our inheritance example and discuss it further when
    we look at polymorphism.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们或类的设计者希望我们在使用他们的类之前强制继承，他们可以将一个类声明为**抽象**。然后我们就不能从中创建对象。因此，我们必须首先扩展它，然后从子类中创建对象。我们将在我们的继承示例中这样做，并在我们讨论多态性时进一步讨论它。
- en: We can also declare a method abstract, and that method must be overridden in
    any class that extends the class with the abstract method. We will do this as
    well in our inheritance example.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明一个方法为抽象方法，必须在扩展具有抽象方法的类的任何类中重写该方法。我们也将在我们的继承示例中这样做。
- en: In our game projects, we will not be designing any classes that we will be extending.
    We have no need of that in the context of learning about building simple games.
    However, we will be extending classes designed by others in every future game.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏项目中，我们不会设计任何需要扩展的类。在学习构建简单游戏的情况下，我们不需要那样。然而，在未来的每个游戏中，我们都将扩展他人设计的类。
- en: We discuss inheritance mainly so that we understand what is going on around
    us and as the first step towards being able to eventually design useful classes
    that we or others can extend. With this in mind, let's make some simple classes
    and see how we can extend them, just to play around with the syntax as a first
    step, and also to be able to say we have done it. When we look at the last major
    topic of this chapter, polymorphism, we will also dig a little deeper into inheritance.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要讨论继承，以便了解我们周围发生的事情，并作为最终能够设计有用的类的第一步，我们或其他人可以扩展。考虑到这一点，让我们创建一些简单的类，并看看我们如何扩展它们，只是为了玩弄一下语法作为第一步，也为了能够说我们已经这样做了。当我们看这一章的最后一个主要主题，多态性时，我们还将更深入地探讨继承。
- en: An example of inheritance
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承的例子
- en: 'We have looked at the way we can create hierarchies of classes to model the
    system that fits our game or software project, so let''s try out some simple code
    that uses inheritance. The completed project is in the `Chapter6` folder of the
    code download. It is called `InheritanceExample`. We will now perform the following
    steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了我们可以创建类的层次结构来模拟适合我们的游戏或软件项目的系统的方式，所以让我们尝试一些使用继承的简单代码。完成的项目在代码下载的`Chapter6`文件夹中。它被称为`InheritanceExample`。我们现在将执行以下步骤：
- en: Create three new classes in the usual way. Call one `AlienShip`, another `Fighter`,
    and the last one `Bomber`.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以通常的方式创建三个新类。一个叫做`AlienShip`，另一个叫做`Fighter`，最后一个叫做`Bomber`。
- en: 'Here is the code for the `AlienShip` class. It is very similar to our previous
    `AlienShip` class demo. The differences are that the constructor now takes an
    `int` parameter, which it uses to set the shield strength. The constructor also
    outputs a message to the console so that we can see when it is being used. The
    `AlienShip` class also has a new method, `fireWeapon`, that is declared `abstract`.
    This guarantees that any class that subclasses `AlienShip` must implement their
    own version of `fireWeapon`. Notice that the class has the `abstract` keyword
    as part of its declaration. We have to do this because one of its methods also
    uses the keyword `abstract`. We will explain the `abstract` method when discussing
    this demo and the `abstract` class when we talk about polymorphism:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`AlienShip`类的代码。它与我们之前的`AlienShip`类演示非常相似。不同之处在于构造函数现在接受一个`int`参数，它用于设置护盾强度。构造函数还向控制台输出消息，以便我们可以看到它何时被使用。`AlienShip`类还有一个新方法`fireWeapon`，它被声明为`abstract`。这保证了任何继承`AlienShip`的类必须实现自己的`fireWeapon`版本。注意，该类在其声明中有`abstract`关键字。我们必须这样做是因为它的方法之一也使用了`abstract`关键字。当我们讨论这个演示和多态时，我们将解释`abstract`方法和`abstract`类：
- en: '[PRE50]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we will implement the `Bomber` class. Notice the call to `super(100)`.
    This calls the constructor of the superclass with the value for `shieldStrength`.
    We could do further specific `Bomber` initialization in this constructor, but
    for now, we just print the location so that we can see when the `Bomber` constructor
    is being executed. We also implement a `Bomber` class-specific version of the
    abstract `fireWeapon` method because we must do so:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现`Bomber`类。注意调用`super(100)`。这将使用`shieldStrength`的值调用超类的构造函数。我们可以在这个构造函数中进一步初始化`Bomber`，但现在我们只是打印位置，以便我们可以看到`Bomber`构造函数何时被执行。我们还实现了一个`Bomber`类特定版本的抽象`fireWeapon`方法，因为我们必须这样做：
- en: '[PRE51]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we will implement the `Fighter` class. Notice the call to `super(400)`.
    This calls the constructor of the superclass with the value of `shieldStrength`.
    We could do further `Fighter` class-specific initialization in this constructor,
    but for now, we just print the location so that we can see when the `Fighter`
    constructor is being executed. We also implement a `Fighter` specific version
    of the abstract `fireWeapon` method because we must do so:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将实现`Fighter`类。注意调用`super(400)`。这将使用`shieldStrength`的值调用超类的构造函数。我们可以在这个构造函数中进一步初始化`Fighter`类，但现在我们只是打印位置，以便我们可以看到`Fighter`构造函数何时被执行。我们还实现了一个`Fighter`特定版本的抽象`fireWeapon`方法，因为我们必须这样做：
- en: '[PRE52]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Here is our code in the `onCreate` method of `MainActivity`. As usual, we enter
    this code after the call to `setContentView`. This is the code that uses our three
    new classes. It looks quite ordinary, but there''s nothing new; it is the output
    that is interesting:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们在`MainActivity`的`onCreate`方法中的代码。像往常一样，在调用`setContentView`之后输入此代码。这是使用我们的三个新类的代码。它看起来很普通，但没有什么新鲜的；有趣的是输出：
- en: '[PRE53]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here is the output of the preceding snippets of code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段的输出如下：
- en: '[PRE54]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can see how the constructor of the subclass can call the constructor of the
    superclass. We can also clearly see that the individual implementations of the
    `fireWeapon` method work exactly as expected.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到子类的构造函数如何调用超类的构造函数。我们还可以清楚地看到`fireWeapon`方法的各个实现确实按预期工作。
- en: As if OOP where not useful enough already! We can now model real-world objects
    and design them to interact with each other. We have also seen how we can make
    OOP even more useful by subclassing/extending/inheriting from other classes. The
    terminology we might like to learn here is that the class that is extended from
    is the **superclass** and the class that inherits from the superclass is the **subclass**.
    We can also call them parent and child classes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 好像面向对象编程还不够有用！我们现在可以模拟现实世界的对象并设计它们相互交互。我们还看到了如何通过子类化/扩展/继承其他类使面向对象编程变得更加有用。我们可能想要学习的术语是被扩展的类是**超类**，继承超类的类是**子类**。我们也可以称它们为父类和子类。
- en: Tip
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'As usual, we might find ourselves asking this question about inheritance: Why?
    We can write common code once, in the parent class, and we can update that common
    code. All the classes that inherit from it are also updated. Furthermore, a subclass
    only inherits public instance variables and methods. When designed properly, this
    further enhances the goals of encapsulation.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们可能会问自己关于继承的问题：为什么？我们可以在父类中编写一次通用代码，并且可以更新该通用代码。所有继承自它的类也会被更新。此外，子类只继承公共实例变量和方法。当设计得当时，这进一步增强了封装的目标。
- en: Polymorphism
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism roughly means different forms. But what does it mean to us?
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 多态大致意味着不同的形式。但对我们来说意味着什么？
- en: In the simplest words possible, any subclass can be used as a part of the code
    that uses the superclass.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 用尽可能简单的话来说，任何子类都可以作为使用超类的代码的一部分。
- en: For example, if we have an array of animals, we could put any object that is
    of a type that is a subclass of `Animal` in the `Animal` array, perhaps cats and
    dogs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个动物数组，我们可以将任何属于`Animal`子类的对象放入`Animal`数组中，比如猫和狗。
- en: 'This means that we can write code that is simpler and easier to understand
    and modify:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以编写更简单、更易于理解和修改的代码：
- en: '[PRE55]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can also write code for the superclass and rely on the fact that no matter
    how many times it is subclassed, within certain parameters, the code will still
    work. Let''s continue our previous example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为超类编写代码，并依赖于这样一个事实，即无论它被子类化多少次，在一定的参数范围内，代码仍然可以工作。让我们继续我们之前的例子：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You can also write methods with polymorphic return types and arguments:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以编写具有多态返回类型和参数的方法：
- en: '[PRE57]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: So you can even write code *today* and make another subclass in a week, month,
    or year, and the very same methods and data structures will still work.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使今天编写代码，一周、一个月或一年后制作另一个子类，相同的方法和数据结构仍将起作用。
- en: Further, we can enforce on our subclasses a set of rules as to what they can
    and cannot do, and also how they should do it. Thus, good design in one stage
    can influence our subclasses at other stages.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以对我们的子类强制执行一组规则，规定它们可以做什么，不能做什么，以及它们应该如何做。因此，一个阶段的良好设计可以影响其他阶段的子类。
- en: If you do suddenly find yourself with a flappy-bird-sized phenomenon, and you
    have a lot of OOP in your code, right from the start, it will be much easier to
    bring in hired help to move the project forward and still maintain control of
    the project.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你突然发现自己有一个像小鸟一样大小的现象，并且你的代码中有很多面向对象编程，那么从一开始就很容易引入雇佣帮助来推动项目的进展，并且仍然保持对项目的控制。
- en: What if you have an idea for a game with lots of features but you want to get
    a simple version of the game out as soon as possible? Smart, object-oriented design
    would certainly be the solution. It could enable you to write the working bare
    bones of a game and then gradually extend it.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个想法，想要一个有很多功能的游戏，但你想尽快推出一个简化版本的游戏，那么聪明的面向对象设计肯定是解决方案。它可以让你编写游戏的基本框架，然后逐渐扩展它。
- en: 'Moving on, let''s look at another OOP concept: abstract classes. We can now
    get to the bottom of what was going on with that `AlienShip` code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看另一个面向对象编程的概念：抽象类。我们现在可以弄清楚`AlienShip`代码中发生了什么：
- en: '[PRE58]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Abstract classes
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类
- en: An abstract class is a class that cannot be instantiated, or cannot be made
    into an object. We mentioned that `AlienShip` was abstract in the previous example.
    So is it a blueprint that will never be used then? But that's like paying an architect
    to design your home and then never building it! I kind of got the idea of an abstract
    method but this is just silly!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是一个不能被实例化的类，或者不能被制作成对象。我们在前面的例子中提到`AlienShip`是抽象的。那么它是一个永远不会被使用的蓝图吗？但这就像支付一个建筑师设计你的房子，然后永远不建造它！我有点明白抽象方法的概念，但这太愚蠢了！
- en: 'It might seem like this at first. We make a class abstract by declaring it
    with the `abstract` keyword, like this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始可能会觉得是这样的。我们通过使用`abstract`关键字来声明一个类为抽象类，就像这样：
- en: '[PRE59]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: But why?
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但是为什么呢？
- en: Sometimes, we want a class that can be used as a polymorphic type but we need
    to ensure that it can never be used as an object. For example, `Animal` doesn't
    really make sense on its own.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望一个类可以被用作多态类型，但我们需要确保它永远不能被用作对象。例如，`Animal`本身并没有太多意义。
- en: We don't talk about animals; we talk about types of animals. We don't say, "Ooh,
    look at that lovely, fluffy, white animal", or "Yesterday, we went to the pet
    shop and got an animal and an animal bed." It's just too abstract.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不谈论动物；我们谈论动物的类型。我们不会说，“哦，看那只可爱的、蓬松的、白色的动物”，或者“昨天，我们去宠物店买了一只动物和一个动物床。”这太抽象了。
- en: So an abstract class is like a template to be used by any class that extends
    it (inherits from it).
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，抽象类就像一个模板，可以被任何继承它的类使用。
- en: We might want a `Worker` class and extend to make classes such as `Miner`, `Steelworker`,
    `OfficeWorker`, and of course `Programmer`. But what exactly does a plain `Worker`
    class do? Why would we ever want to instantiate one?
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要一个`Worker`类，并扩展为类似`Miner`、`Steelworker`、`OfficeWorker`和当然`Programmer`的类。但是一个普通的`Worker`类到底是做什么的呢？我们为什么要实例化一个？
- en: The answer is that we wouldn't want to instantiate it, but we might want to
    use it as a polymorphic type so that we can pass multiple worker subclasses between
    methods and have data structures that can hold all types of workers.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是我们不想实例化它，但我们可能想要将它用作多态类型，这样我们可以在方法之间传递多个工作子类，并且可以拥有可以容纳所有类型工作者的数据结构。
- en: We call this type of class an abstract class, and when a class has even one
    abstract method, like `AlienShip` did, it must be declared abstract itself. As
    we saw, all abstract methods must be overridden by any class that extends the
    abstract class. This means that the abstract class can provide some of the common
    functionality that would be available in all its subclasses. For example, the
    `Worker` class might have the `height`, `weight`, and `age` member variables.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这种类型的类为抽象类，当一个类有一个抽象方法时，就像`AlienShip`一样，它必须被声明为抽象类。正如我们所看到的，所有抽象方法必须被任何扩展抽象类的类重写。这意味着抽象类可以提供一些在其所有子类中都可用的常见功能。例如，`Worker`类可能有`height`、`weight`和`age`成员变量。
- en: It might have the `getPayCheck` method, which is the same in all the subclasses,
    and the `doWork` method, which is abstract and must be overridden because all
    the different types of worker do work very differently.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能有`getPayCheck`方法，在所有子类中都是相同的，还有`doWork`方法，它是抽象的，必须被重写，因为所有不同类型的工作者工作方式都非常不同。
- en: This leads us neatly on to another area of polymorphism that deserves an honorable
    mention because we have been using it in every game so far.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们顺利地进入了另一个值得一提的多态性领域，因为我们迄今为止一直在使用它。
- en: Interfaces
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: An interface is like a class. Phew! Nothing complicated here then. However,
    it's like a class that is always abstract and with only abstract methods.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接口就像一个类。呼！那么这里没有什么复杂的。然而，它就像一个始终是抽象的类，只有抽象方法。
- en: We can think of an interface as an entirely abstract class with all its methods
    abstract too. Okay, so you can just about wrap your head round an abstract class
    because it can at least pass on some functionality in its methods that are not
    abstract and serve as a polymorphic type.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以把接口看作是一个完全抽象的类，它的所有方法也都是抽象的。好吧，你可能刚刚能理解抽象类，因为它至少可以传递一些功能，而它的方法不是抽象的，可以作为多态类型。
- en: But seriously, this interface seems a bit pointless. Bear with me.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 但说真的，这个接口似乎有点无聊。请耐心等待。
- en: 'To define an interface, we type the following code:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个接口，我们输入以下代码：
- en: '[PRE60]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The methods of an interface have no body because they are abstract, but they
    can still have return types and parameters, or not.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接口的方法没有主体，因为它们是抽象的，但它们仍然可以有返回类型和参数，也可以没有。
- en: 'To use an interface, we use the `implements` keyword after the class declaration.
    Yes, we already did this for `onClickListener` a few times:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用一个接口，我们在类声明后使用`implements`关键字。是的，我们已经为`onClickListener`做了几次。
- en: '[PRE61]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This enables us to use polymorphism with multiple different objects that are
    from completely unrelated inheritance hierarchies. As long as it implements an
    interface, the whole thing can be passed along as if it is that thing, which it
    is. We can even have a class implement multiple different interfaces at the same
    time. Just add a comma between each interface and list them after the `implements`
    keyword. Just be sure to implement all the necessary methods.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用多个来自完全不相关的继承层次结构的对象进行多态。只要它实现了一个接口，整个东西就可以像那个东西一样传递。我们甚至可以让一个类同时实现多个不同的接口。只需在每个接口之间添加逗号，并在`implements`关键字后列出它们。只需确保实现所有必要的方法。
- en: Let's go back to the `onClickListener` interface. Any thing might like to know
    when it is being clicked on; a Button, a TextView, and so on. We don't want different
    `onClick` methods for every type.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到`onClickListener`接口。任何东西可能都想知道它何时被点击；按钮、文本视图等。我们不希望为每种类型都有不同的`onClick`方法。
- en: Tip
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When using Android, for games or for more regular GUI-based apps (a bit like
    ours so far), 9 times out of 10, you will be implementing interfaces rather than
    writing your own. However, knowing what is happening is quite important, not so
    much from a point of view of technical awareness, as we have just seen that the
    interface specifies a contract and the compiler enforces it, but more as a matter
    of sanity in knowing what is actually happening when you use the `implements`
    keyword and write a method (or methods) with a name that you didn't choose.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Android时，无论是用于游戏还是更常规的基于GUI的应用程序（有点像我们迄今为止的应用程序），你将十有八九实现接口而不是编写自己的接口。然而，知道发生了什么是非常重要的，不是从技术意识的角度来看，因为我们刚刚看到接口指定了一个合同，编译器强制执行它，而更多的是为了理智地知道当你使用`implements`关键字并编写一个你没有选择的名称的方法（或方法）时实际发生了什么。
- en: More about OOP and classes
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于OOP和类
- en: It is possible to write a whole book on OOP, and many authors have already done
    so, but the best way to learn OOP is probably to practice it; practice it *before*
    we have learned all of the theory. Anyway, before we get on with some more practical
    examples, here is one more slightly theoretical OOP example that will leave us
    scratching our heads later if not mentioned.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有人写一本关于OOP的整本书，许多作者已经这样做了，但学习OOP的最佳方法可能是练习它；在我们学习所有理论之前就练习它。不管怎样，在我们继续一些更实际的例子之前，这里有一个稍微理论化的OOP例子，如果不提到的话，以后我们会对此感到困惑。
- en: Inner classes
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部类
- en: When we looked at our basic classes demo app, we declared and implemented the
    class in a separate file to our `MainActivity` class. That file had the same name
    as the class.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的基本类演示应用程序时，我们在一个单独的文件中声明和实现了类，而不是在我们的`MainActivity`类中。该文件与类同名。
- en: We can also declare and implement a class within a class. The only question
    remaining, of course, is why would we do this? When we implement an inner class,
    the inner class can access the member variables of the enclosing class and the
    enclosing class can access the members of the inner class. We will see this in
    action in the next two chapters.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在一个类中声明和实现一个类。当然，唯一剩下的问题是为什么我们要这样做？当我们实现一个内部类时，内部类可以访问外部类的成员变量，外部类也可以访问内部类的成员。我们将在接下来的两章中看到这一点。
- en: If you are not modeling deep or real-world systems, then inner classes are often
    the way to go. In fact, all the classes we will write ourselves in the rest of
    this book will be extended inner classes. This means that we will extend a type
    to make our own class within our `Activity` class. This makes our code nice and
    simple.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不是在建模深层或现实世界的系统，那么内部类通常是一种方法。事实上，在本书的其余部分，我们将编写的所有类都将是扩展的内部类。这意味着我们将扩展一种类型来创建我们自己的类在我们的`Activity`类中。这使我们的代码简单明了。
- en: Self-test questions
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自测问题
- en: 'Q1) Find out what is wrong with this class declaration:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Q1) 找出这个类声明有什么问题：
- en: '[PRE62]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Q2) What is encapsulation?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Q2) 封装是什么？
- en: Q3) I don't get it all, and actually, I have more questions now than I had at
    the start of the chapter. What should I do?
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Q3) 我并没有完全理解，实际上，我现在比章节开始时还有更多问题。我该怎么办？
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we covered more theory than in any other chapter. If you haven't
    memorized everything, then you have succeeded completely. If you just understand
    that OOP is about writing reusable, extendable, and efficient code through encapsulation,
    inheritance, and polymorphism, then you have the potential to be a Java master.
    Simply put, OOP enables us to use other people's hard work even when those people
    were not aware of exactly what we would be doing at the time they did the work.
    All you have to do is keep practicing, so let's make a retro game in the next
    chapter.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖的理论比其他任何一章都多。如果你没有记住一切，那么你已经完全成功了。如果你只是理解OOP是通过封装、继承和多态编写可重用、可扩展和高效的代码，那么你有成为Java大师的潜力。简而言之，OOP使我们能够在那些人当时并不知道我们将要做什么的时候使用其他人的辛勤工作。你所要做的就是不断练习，所以让我们在下一章制作一个复古游戏。
