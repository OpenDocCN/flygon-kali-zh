- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Understanding the Different Domains in Software Solutions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解软件解决方案中的不同领域
- en: This chapter is dedicated to a modern software development technique called
    **domain-driven design** (**DDD**), which was first proposed by Eric Evans. While
    DDD has existed for more than 15 years, it has achieved great success in the last
    few years because of its ability to cope with two important problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍了一种称为**领域驱动设计**（**DDD**）的现代软件开发技术，这是由Eric Evans首次提出的。虽然DDD已经存在了15年以上，但由于其解决了两个重要问题的能力，它在过去几年取得了巨大成功。
- en: The first problem is modeling complex systems. No single expert has in-depth
    knowledge of the whole domain; this knowledge is instead split among several people.
    As we will see, DDD copes with this problem by splitting the whole CI/CD cycle
    into independent parts, assigned to different teams. This way each team can focus
    on a specific domain of knowledge by interacting only with the experts of that
    domain.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是对复杂系统进行建模。没有一个专家对整个领域有深入的了解；相反，这种知识分散在几个人之间。正如我们将看到的，DDD通过将整个CI/CD周期分成独立的部分分配给不同的团队来解决这个问题。这样，每个团队可以专注于特定的知识领域，只与该领域的专家进行互动。
- en: The second problem DDD copes with well is big projects with several development
    teams. There are many reasons why a project is split among several teams, the
    most common being the team's size and all of its members having different skills
    and/or different locations. In fact, experience has proven that teams of more
    than 6-8 people are not efficacious and, clearly, different skills and locations
    prevent tight interaction from occurring. Team splitting prevents tight interaction
    from happening for all the people involved in the project.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: DDD很好地解决了第二个问题，即涉及多个开发团队的大型项目。项目被分成几个团队有很多原因，最常见的原因是团队的规模以及所有成员具有不同的技能和/或不同的地点。事实上，经验已经证明，超过6-8人的团队并不高效，而不同的技能和地点阻止了紧密的互动。团队分裂阻止了所有参与项目的人之间的紧密互动。
- en: In turn, the importance of the two aforementioned problems has grown in the
    last few years. Software systems have always taken up a lot of space inside every
    organization, and they became more and more complex and geographically distributed.
    At the same time, the need for frequent updates increased so that these complex
    software systems could be adapted to the needs of a quickly changing market.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来，上述两个问题的重要性在过去几年中不断增加。软件系统一直占据着每个组织内大量的空间，并且变得越来越复杂和地理分布。与此同时，对频繁更新的需求增加，以便这些复杂的软件系统能够适应快速变化的市场需求。
- en: These problems led to the conception of more sophisticated CI/CD cycles and
    the adoption of complex distributed architectures that may leverage reliability,
    high throughput, quick updates, and the capability to evolve legacy subsystems
    gradually. Yes—we are speaking of the microservices and container-based architectures
    we analyzed in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题导致了更复杂的CI/CD周期的构想和复杂分布式架构的采用，这些架构可以利用可靠性、高吞吐量、快速更新以及逐渐演变传统子系统的能力。是的——我们谈论的是微服务和基于容器的架构，我们在*第5章*、*将微服务架构应用于企业应用程序*中进行了分析。
- en: In this scenario, it's common to implement complex software systems with associated
    fast CI/CD cycles that always require more people to evolve and maintain them.
    In turn, this created a need for technologies that were adequate for high-complexity
    domains and for the cooperation of several loosely coupled development teams.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，常见的做法是实现与快速CI/CD周期相关的复杂软件系统，这些系统始终需要���多的人来进行演进和维护。反过来，这就产生了对适用于高复杂性领域以及对几个松散耦合的开发团队进行合作的技术的需求。
- en: 'In this chapter, we will analyze the basic principles, advantages, and common
    patterns related to DDD, as well as how to use them in our solutions. More specifically,
    we will cover the following topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析与DDD相关的基本原则、优势和常见模式，以及如何在我们的解决方案中使用它们。更具体地，我们将涵盖以下主题：
- en: What are software domains?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是软件领域？
- en: Understanding domain-driven design
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解领域驱动设计
- en: Using SOLID principles to map your domains
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SOLID原则来映射您的领域
- en: Use case—understanding the domains of the use case
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用例——理解用例的领域
- en: Let's get started.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires Visual Studio 2019 free Community Edition or better with
    all the database tools installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要安装了所有数据库工具的Visual Studio 2019免费社区版或更高版本。
- en: All the code snippets in this chapter can be found in the GitHub repository
    associated with this book, [https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码片段都可以在与本书相关的GitHub存储库中找到，[https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5](https://github.com/PacktPublishing/Software-Architecture-with-C-9-and-.NET-5)。
- en: What are software domains?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是软件领域？
- en: As we discussed in *Chapter 2*, *Non-Functional Requirements*, and *Chapter
    3*, *Documenting Requirements with Azure DevOps*, the transfer of knowledge from
    domain experts to the development team plays a fundamental role in software design.
    Developers try to communicate with experts and describe their solutions in a language
    that domain experts and stakeholders can understand. However, often, the same
    word has a different meaning in various parts of an organization, and what appear
    to be the same conceptual entities have completely different shapes in different
    contexts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第2章*、*非功能性需求*和*第3章*、*使用Azure DevOps记录需求*中讨论的，从领域专家到开发团队的知识传递在软件设计中起着基础性作用。开发人员试图与专家沟通，并用领域专家和利益相关者能够理解的语言描述他们的解决方案。然而，通常情况下，同一个词在组织的不同部分有不同的含义，在不同的上下文中，看似相同的概念实体在不同的情境中完全不同。
- en: For instance, in our WWTravelClub use case, the order-payment and packages-handling
    subsystems use completely different models for customers. Order-payment characterizes
    a customer by their payment methods and currency, bank accounts, and credit cards,
    while packages-handling is more concerned with the locations and packages that
    have been visited and/or purchased in the past, the user's preferences, and their
    geographical location. Moreover, while order-payment refers to various concepts
    with a language that we may roughly define as a **bank language**, packages-handling
    uses a language that is typical of travel agencies/operators.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的WWTravelClub用例中，订单支付和包裹处理子系统使用完全不同的客户模型。订单支付通过支付方式和货币、银行账户和信用卡来描述客户，而包裹处理更关注过去访问和/或购买的位置和包裹、用户的偏好以及其地理位置。此外，订单支付涉及各种概念，使用的语言可以粗略地定义为**银行语言**，而包裹处理使用的语言则是旅行社/运营商的典型语言。
- en: 'The classical way to cope with these discrepancies is to use a unique abstract
    entity called **customer**, which projects into two different views—the order-payment
    view and the package-handling view. Each projection operation takes some operations
    and some properties from the **customer** abstract entity and changes their names.
    Since domain experts only give us the projected views, our main task as system
    designers is to create a conceptual model that can explain all the views. The
    following diagram shows how different views are handled:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应对这些差异的经典方式是使用一个称为**客户**的唯一抽象实体，它投影到两个不同的视图——订单-支付视图和包裹处理视图。每个投影操作都从**客户**抽象实体中获取一些操作和一些属性，并更改它们的名称。由于领域专家只给我们提供了投影视图，作为系统设计师的主要任务是创建一个能够解释所有视图的概念模型。下图显示了如何处理不同的视图：
- en: '![](img/B16756_12_01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_01.png)'
- en: 'Figure 12.1: Creating a unique model'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：创建一个唯一模型
- en: The main advantage of the classic approach is that we have a unique and coherent
    representation of the data of the domain. If this conceptual model is built successfully,
    all the operations will have a formal definition and purpose and the whole abstraction
    will be a rationalization of the way the whole organization should work, possibly
    highlighting and correcting errors and simplifying some procedures.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 经典方法的主要优势在于我们对领域数据有一个独特和一致的表示。如果成功构建了这个概念模型，所有操作都将有一个正式的定义和目的，整个抽象将是整个组织应该工作的合理化，可能会突出和纠正错误，并简化一些程序。
- en: However, what are the downsides of this approach?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有什么不足之处呢？
- en: The sharp adoption of a new monolithic data model may cause an acceptable impact
    in a small organization, when the software is destined for a small part of the
    overall organization, or when the software automatizes a small enough percentage
    of the data flow. However, if the software becomes the backbone of a complex geographically
    distributed organization, sharp changes become unacceptable and unfeasible. Complex
    structured companies require a gradual transition from the old organization to
    the new organization. In turn, a gradual transition is possible only if old data
    models can coexist with new data models, and if each of the various components
    of the organization is allowed to change at its own speed, that is, if each component
    of the organization can evolve independently of the others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个小组织来说，快速采用新的单体数据模型可能会产生可接受的影响，当软件面向整个组织的一小部分，或者当软件自动化了数据流的足够小的百分比时。然而，如果软件成为复杂的地理分布式组织的支柱，急剧的变化变得不可接受和不可行。复杂结构的公司需要从旧组织逐渐过渡到新组织。反过来，只有在旧数据模型可以与新数据模型共存，并且组织的各个组成部分都被允许以自己的速度变化时，逐渐过渡才是可能的，也就是说，组织的每个组成部分都可以独立于其他部分发展。
- en: 'Moreover, as the complexity of the software system grows, several other issues
    appear, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着软件系统复杂性的增加，还会出现其他一些问题，例如：
- en: '**Coherency issues**: Arriving at a uniquely coherent view of data becomes
    more difficult since we can''t retain the complexity when we break these tasks
    into smaller, loosely coupled tasks.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性问题**：当我们将这些任务分解为更小、松散耦合的任务时，要达到数据的统一一致视图变得更加困难，因为我们无法保留复杂性。'
- en: '**Difficulties updating**: As complexity grows, there is a need for frequent
    system changes, but it is quite difficult to update and maintain a unique global
    model. Moreover, bugs/errors that are introduced by changes in small subparts
    of the system may propagate to the whole organization through the uniquely shared
    model.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新困难**：随着复杂性的增长，系统需要频繁变更，但更新和维护一个唯一的全局模型是相当困难的。此外，由于系统中某些小部分的变更引入的错误可能通过唯一共享的模型传播到整个组织。'
- en: '**Team organization issues**: System modeling must be split among several teams,
    and only loosely-coupled tasks can be given to separate teams; if two tasks are
    strongly coupled, they need to be given to the same team.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队组织问题**：系统建模必须分配给几个团队，并且只能给予分离的松散耦合任务；如果两个任务紧密耦合，它们需要分配给同一个团队。'
- en: '**Parallelism issues**: The need to move to a microservice-based architecture
    makes the bottleneck of a unique database more unacceptable.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行问题**：需要转向基于微服务的架构，这使得唯一数据库的瓶颈变得更加不可接受。'
- en: '**Language issues**: As the system grows, we need to communicate with more
    domain experts, each speaking a different language and each with a different view
    of that data model. Thus, we need to translate our unique model''s properties
    and operations to/from more languages to be able to communicate with them.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语言问题**：随着系统的增长，我们需要与更多的领域专家进行沟通，每个人说着不同的语言，对数据模型有不同的看法。因此，我们需要将我们唯一模型的属性和操作从更多的语言翻译成/翻译出来，以便与他们进行沟通。'
- en: As the system grows, it becomes more inefficient to deal with records with hundreds/thousands
    of fields. Such inefficiencies originate in database engines that inefficiently
    handle big records with several fields (memory fragmentation, problems with too
    many related indices, and so on). However, the main inefficiencies take place
    in **object-relational mappings** (**ORMs**) and business layers that are forced
    to handle these big records in their update operations. In fact, while query operations
    usually require just a few fields that have been retrieved from the storage engine,
    updates and business processing involve the whole entity.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 随着系统的增长，处理具有数百/数千个字段的记录变得更加低效。这种低效性源于数据库引擎对具有多个字段的大记录的低效处理（内存碎片化，与太多相关索引的问题等）。然而，主要的低效性发生在**对象关系映射**（**ORMs**）和业务层，它们被迫在其更新操作中处理这些大记录。事实上，虽然查询操作通常只需要从存储引擎中检索出的少数字段，但更新和业务处理涉及整个实体。
- en: As the traffic in the data storage subsystem grows, we need read and update/write
    parallelism in all the data operations. As we discussed in *Chapter 9*, *How to
    Choose Your Data Storage in the Cloud*, while read parallelism is easily achieved
    with data replication, write parallelism requires sharding, and it is difficult
    to shard a uniquely monolithic and tightly connected data model.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着数据存储子系统中的流量增长，我们需要在所有数据操作中实现读取和更新/写入并行性。正如我们在*第9章*中讨论的*如何在云中选择数据存储*，读取并行性可以通过数据复制轻松实现，而写入并行性则需要分片，对于一个独特的单片和紧密连接的数据模型来说，分片是困难的。
- en: These issues are the reason for DDD's success in the last few years because
    they were characterized by more complex software systems that became the backbones
    of entire organizations. DDD's basic principles will be discussed in detail in
    the next section.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题是DDD在过去几年取得成功的原因，因为它们被更复杂的软件系统所特征，这些系统成为整个组织的支柱。DDD的基本原则将在下一节中详细讨论。
- en: Understanding domain-driven design
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解领域驱动设计
- en: DDD is about the construction of a unique domain model that keeps all the views
    as separate models. Thus, the whole application domain is split into smaller domains,
    each with a separate model. These separate domains are called **Bounded Contexts**.
    Each domain is characterized by the language spoken by the experts and used to
    name all the domain concepts and operations. Thus, each domain defines a common
    language used by both the expert and the development team called a **Ubiquitous
    Language**. Translations are not needed anymore, and if the development team uses
    interfaces as bases for its code, the domain expert is able to understand and
    validate them since all the operations and properties are expressed in the same
    language that's used by the expert.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: DDD是关于构建一个独特的领域模型，将所有视图保持为单独的模型。因此，整个应用程序领域被分割成更小的领域，每个领域都有一个单独的模型。这些单独的领域被称为**有界上下文**。每个领域都以专家所使用的语言为特征，并用于命名所有领域概念和操作。因此，每个领域定义了一个专家和开发团队都使用的通用语言，称为**普遍语言**。不再需要翻译，如果开发团队使用接口作为代码的基础，领域专家能够理解和验证它们，因为所有操作和属性都用专家使用的相同语言表达。
- en: 'Here, we''re getting rid of a cumbersome unique abstract model, but now we
    have several separated models that we need to relate somehow. DDD proposes that
    it will handle all of these separated models, that is, all the Bounded Contexts,
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们摆脱了繁琐的唯一抽象模型，但现在我们有几个分离的模型，我们需要以某种方式进行关联。DDD建议将处理所有这些分离的模型，即所有有界上下文，如下所示：
- en: We need to add Bounded Context boundaries whenever the meanings of the language
    terms change. For instance, in the WWTravelClub use case, order-payment and packages-handling
    belong to different Bounded Contexts because they give a different meaning to
    the word **customer**.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当语言术语的含义发生变化时，我们需要添加有界上下文边界。例如，在WWTravelClub的用例中，订单支付和套餐处理属于不同的有界上下文，因为它们赋予了**客户**这个词不同的含义。
- en: We need to explicitly represent relations among bounded contexts. Different
    development teams may work on different Bounded Contexts, but each team must have
    a clear picture of the relationship between the Bounded Context it is working
    on and all the other models. For this reason, such relationships are represented
    in a unique document that's shared with every team.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要明确表示有界上下文之间的关系。不同的开发团队可能在不同的有界上下文上工作，但每个团队必须清楚地了解其所在的有界上下文与所有其他模型之间的关系。因此，这些关系在一个共享给每个团队的唯一文档中表示。
- en: We need to keep all the Bounded Contexts aligned with CI. Meetings are organized
    and simplified system prototypes are built in order to verify that all the Bounded
    Contexts are evolving coherently, that is, that all the Bounded Contexts can be
    integrated into the desired application behavior.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要保持所有有界上下文与CI保持一致。会议被组织起来，简化的系统原型被构建，以验证所有有界上下文是否一致地发展，即所有有界上下文是否能够集成到所需的应用程序行为中。
- en: 'The following diagram shows how the WWTravelClub example that we discussed
    in the previous section changes with the adoption of DDD:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了我们在前一节中讨论的WWTravelClub示例在采用DDD后的变化：
- en: '![](img/B16756_12_02.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_02.png)'
- en: 'Figure 12.2: Relations among DDD Bounded Contexts'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：DDD有界上下文之间的关系
- en: There is a relationship between the customer entities of each Bounded Context,
    while the Purchase entity of the packages-handling Bounded Context is related
    to the payments. Identifying entities that map to each other in the various Bounded
    Contexts is the first step of formally defining the interfaces that represent
    all the possible communications among the contexts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有界上下文的客户实体之间存在关系，而套餐处理有界上下文的购买实体与支付相关。确定在各个有界上下文中映射到彼此的实体是正式定义代表上下文之间所有可能通信的接口的第一步。
- en: For instance, from the preceding diagram, we know that payments are done after
    purchases, and so we can deduce that the order-payment Bounded Context must have
    an operation to create a payment for a specific customer. In this domain, new
    customers are created if they don't already exist. The payment creation operation
    is triggered immediately after purchase. Since several more operations are triggered
    after an item is purchased, we can implement all the communication related to
    a purchase event with the Publisher/Subscriber pattern we explained in *Chapter
    11*, *Design Patterns and .NET 5 Implementation*. These are known as **domain
    events** in DDD. Using events to implement communications between Bounded Contexts
    is very common since it helps keep Bounded Contexts loosely coupled.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从前面的图表中，我们知道购买后会进行付款，因此我们可以推断订单-付款有界上下文必须有一个为特定客户创建付款的操作。在此领域中，如果新客户不存在，则会创建新客户。购买后立即触发付款创建操作。由于购买商品后会触发多个操作，我们可以使用我们在*第11章*，*设计模式和.NET
    5实现*中解释的发布者/订阅者模式来实现与购买事件相关的所有通信。这在DDD中被称为**领域事件**。使用事件来实现有界上下文之间的通信非常常见，因为它有助于保持有界上下文之间的松耦合。
- en: Once an instance of either an event or an operation that's been defined in the
    Bounded Context's interface crosses the context boundary, it is immediately translated
    into the Ubiquitous Language of the receiving context. It is important that this
    translation is performed before the input data starts interacting with the other
    domain entities to avoid the Ubiquitous Language of the other domain becoming
    contaminated by extra context terms.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在有界上下文界面中定义的事件或操作的实例跨越上下文边界，它立即被转换为接收上下文的普遍语言。在输入数据开始与其他领域实体交互之前执行此转换非常重要，以避免其他领域的普遍语言被额外的上下文术语污染。
- en: Each Bounded Context implementation must contain a Data Model Layer completely
    expressed in terms of the Bounded Context Ubiquitous Language (class and interface
    names and property and method names), with no contamination from other Bounded
    Contexts' Ubiquitous Languages, and without contamination from programming technical
    stuff. This is necessary to ensure good communication with domain experts and
    to ensure that domain rules are translated correctly into code so that they can
    be easily validated by domain experts.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个有界上下文实现必须包含一个完全以有界上下文普遍语言（类和接口名称以及属性和方法名称）表达的数据模型层，不受其他有界上下文普遍语言的污染，也不受编程技术内容的污染。这对于确保与领域专家的良好沟通以及确保领域规则被正确地转换为代码以便领域专家轻松验证是必要的。
- en: When there is a strong mismatch between the communication language and the target
    Ubiquitous Language, an anti-corruption layer is added to the receiving Bounded
    Context boundary. The only purpose of this anti-corruption layer is to perform
    a language translation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当通信语言与目标普遍语言之间存在严重不匹配时，会在接收有界上下文边界添加一个反腐层。这个反腐层的唯一目的是执行语言翻译。
- en: 'The document that contains a representation of all the Bounded Contexts, along
    with the Bounded Contexts'' mutual relationships and interface definitions, is
    called a **Context Mapping**. The relationships among contexts contain organizational
    constraints that specify the kind of cooperation that''s required among the team
    that works on the different Bounded Contexts. Such relationships don''t constrain
    the Bounded Context interfaces but do affect the way they may evolve during the
    software CI/CD cycle. They represent patterns of team cooperation. The most common
    patterns are as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有有界上下文的表示，以及有界上下文的相互关系和接口定义的文档称为**上下文映射**。上下文之间的关系包含组织约束，指定了在不同有界上下文上工作的团队之间所需的合作方式。这些关系不限制有界上下文的接口，但会影响它们在软件CI/CD周期中可能发展的方式。它们代表了团队合作的模式。最常见的模式如下：
- en: '**Partner**: This is the original pattern suggested by Eric Evans. The idea
    is that the two teams have a mutual dependency on each other for delivery. In
    other terms, they decide together and, if needed, change the Bounded Context''s
    mutual communication specifications during the software CI/CD cycle.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合作伙伴**：这是Eric Evans建议的最初模式。其想法是两个团队在交付方面相互依赖。换句话说，他们共同决定，并在软件CI/CD周期中如有需要，更改有界上下文的相互通信规范。'
- en: '**Customer/supplier development teams**: In this case, one team acts as a customer
    and another acts as a supplier. Both teams define the interface of the customer
    side of the Bounded Context and some automated acceptance tests to validate it.
    After that, the supplier can work independently. This pattern works when the customer''s
    Bounded Context is the only active part that invokes the interface methods that
    are exposed by the other Bounded Context. This is adequate for the interaction
    between the order-payment and the packages-handling contexts, where order-payment
    acts as a supplier since its functions are subordinate to the needs of packages-handling.
    When this pattern can be applied, it decouples the two Bounded Contexts completely.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户/供应商开发团队**：在这种情况下，一个团队充当客户，另一个充当供应商。两个团队定义了有界上下文客户端的接口以及一些自动化验收测试来验证它。之后，供应商可以独立工作。当客户的有界上下文是唯一激活的部分，调用其他有界上下文公开的接口方法时，此模式适用。这对于订单-付款和包裹处理上下文之间的交互是足够的，其中订单-付款充当供应商，因为其功能从属于包裹处理的需求。当可以应用此模式时，它完全解耦了两个有界上下文。'
- en: '**Conformist**: This is similar to the customer/supplier, but in this case,
    the customer side accepts an interface that''s been imposed by the supplier side
    with no negotiation stage. This pattern offers no advantages to the other patterns,
    but sometimes we are forced into the situation depicted by the pattern since either
    the supplier''s Bounded Context is implemented in a preexisting product that can''t
    be configured/modified too much, or because it is a legacy subsystem that we don''t
    want to modify.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顺从者**：这类似于客户/供应商，但在这种情况下，客户方接受了供应方强加的接口，没有谈判阶段。这种模式对其他模式没有优势，但有时我们被迫处于模式所描述的情况，因为供应方的有界上下文是在无法进行太多配置/修改的现有产品中实现的，或者因为它是我们不想修改的遗留子系统。'
- en: It is worth pointing out that the separation in Bounded Contexts is only efficacious
    if the resulting Bounded Contexts are loosely coupled; otherwise, the reduction
    of complexity that's obtained by breaking a whole system into subparts would be
    overwhelmed by the complexity of the coordination and communication processes.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，如果结果的有界上下文松散耦合，那么有界上下文的分离才是有效的；否则，通过将整个系统分解为子部分而获得的复杂性减少将被协调和通信过程的复杂性所淹没。
- en: However, if Bounded Contexts are defined with the language criterion, that is,
    Bounded Context boundaries are added whenever the **Ubiquitous Language** changes,
    this should actually be the case. In fact, different languages may arise as a
    result of a loose interaction between organization subparts since the more each
    subpart has tight interactions inside of it and loose interactions with other
    subparts, the more each subpart ends up defining and using its own internal language,
    which differs from the language used by the other subparts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果有界上下文是根据语言标准来定义的，也就是说，每当**普遍语言**发生变化时，就会添加有界上下文边界，那么实际情况应该是这样。事实上，不同的语言可能会由于组织子部分之间的松散交互而产生，因为每个子部分内部的紧密交互越多，与其他子部分的松散交互越多，每个子部分最终就会定义和使用自己的内部语言，这与其他子部分使用的语言不同。
- en: 'Moreover, all human organizations can grow by evolving into loosely coupled
    subparts for the same reason complex software systems may be implemented as the
    cooperation of loosely coupled submodules: this is the only way humans are able
    to cope with complexity. From this, we can conclude that complex organizations/artificial
    systems can always be decomposed into loosely coupled subparts. We just need to
    understand *how*.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有人类组织都可以通过演变成松散耦合的子部分来增长，原因是复杂软件系统可以作为松散耦合的子模块的合作来实现：这是人类应对复杂性的唯一方式。由此，我们可以得出结论，复杂的组织/人工系统总是可以分解成松散耦合的子部分。我们只需要了解*如何*。
- en: Beyond the basic principles we've mentioned so far, DDD provides a few basic
    primitives to describe each Bounded Context, as well as some implementation patterns.
    While Bounded Context primitives are an integral part of DDD, these patterns are
    useful heuristics we can use in our implementation, so their usage in some or
    all Bounded Contexts is not obligatory once we opt for DDD adoption.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们迄今提到的基本原则之外，DDD还提供了一些基本原语来描述每个有界上下文，以及一些实现模式。虽然有界上下文原语是DDD的一个组成部分，但这些模式是我们在实现中可以使用的有用启发式方法，因此一旦我们选择DDD采用，它们在一些或所有有界上下文中的使用并不是强制性的。
- en: In the next section, we will describe primitives and patterns.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述原始和模式。
- en: Entities and value objects
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和值对象
- en: DDD entities represent domain objects that have a well-defined identity, as
    well as all the operations that are defined on them. They don't differ too much
    from the entities of other, more classical approaches. Also, DDD entities are
    the starting point of the storage layer design.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: DDD实体代表具有明确定义身份的领域对象，以及定义在它们上面的所有操作。它们与其他更经典的方法中的实体��没有太大的区别。此外，DDD实体是存储层设计的起点。
- en: The main difference is that DDD stresses their object-oriented nature, while
    other approaches use them mainly as **records** whose properties can be written/updated
    without too many constraints. DDD, on the other hand, forces strong SOLID principles
    on them to ensure that only certain information is encapsulated inside of them
    and that only certain information is accessible from outside of them, to stipulate
    which operations are allowed on them, and to set which business-level validation
    criteria apply to them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于DDD强调它们的面向对象性质，而其他方法主要将它们用作**记录**，其属性可以在不受太多约束的情况下被编写/更新。另一方面，DDD强制将强大的SOLID原则应用于它们，以确保只有特定信息封装在其中，并且只有特定信息可以从外部访问，以规定允许对其进行哪些操作，并设置哪些业务级别的验证标准适用于它们。
- en: In other words, DDD entities are richer than the entities of record-based approaches.
    In other approaches, operations that manipulate entities are defined outside of
    them in classes that represent business and/or domain operations. In DDD, these
    operations are moved to the entity definitions as their class methods. The reason
    for this is that they offer better modularity and keep related chunks of software
    in the same place so that they can be maintained and tested easily.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，DDD实体比基于记录的方法中的实体更丰富。在其他方法中，操作操纵实体的操作是在代表业务和/或领域操作的类之外定义的。在DDD中，这些操作被移动到实体定义中作为它们的类方法。原因是它们提供更好的模块化，并将相关的软件块放在同一个地方，以便可以轻松地进行维护和测试。
- en: 'For the same reason, business validation rules are moved inside of DDD entities.
    DDD entity validation rules are business-level rules, so they must not be confused
    with database integrity rules or with user-input validation rules. They contribute
    to the way entities represent domain objects by encoding the constraints the represented
    objects must obey. In .NET (Core), business validation can be carried out with
    one of the following techniques:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，业务验证规则被移至DDD实体内部。DDD实体验证规则是业务级别的规则，因此不应与数据库完整性规则或用户输入验证规则混淆。它们通过编码所代表的对象必须遵守的约束，有助于实体表示领域对象的方式。在.NET（Core）中，可以使用以下技术进行业务验证：
- en: Calling the validation methods in all the class methods that modify the entity
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在修改实体的所有类方法中调用验证方法
- en: Hooking the validation methods to all the property setters
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将验证方法挂钩到所有属性设置器
- en: Decorating the class and/or its properties with custom validation attributes
    and then invoking the `TryValidateObject` static method of the `System.ComponentModel.DataAnnotations.Validator`
    class on the entity each time it is modified
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义验证属性装饰类和/或其属性，然后在每次修改实体时调用`System.ComponentModel.DataAnnotations.Validator`类的`TryValidateObject`静态方法
- en: Once detected, validation errors must be handled somehow; that is, the current
    operation must be aborted and the error must be reported to an appropriate error
    handler. The simplest way to handle validation errors is by throwing an exception.
    This way, both purposes are easily achieved and we can choose where to intercept
    and handle them. Unfortunately, as we discussed in the *Performance issues that
    need to be considered while programming in C#* section of *Chapter 2*, *Non-Functional
    Requirements*, exceptions imply big performance penalties, so, often, different
    options are considered. Handling errors in the normal flow of control would break
    modularity by spreading the code that's needed to handle the error all over the
    stack of methods that caused the error, with a never-ending set of conditions
    all over that code. Therefore, more sophisticated options are needed.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检测到验证错误，必须以某种方式处理；也就是说，当前操作必须中止，并且错误必须报告给适当的错误处理程序。处理验证错误的最简单方法是抛出异常。通过这种方式，可以轻松实现两个目的，并且可以选择在何处拦截和处理它们。不幸的是，正如我们在*第2章*
    *非功能需求*的*C#编程中需要考虑的性能问题*部分中讨论的那样，异常会带来很大的性能损失，因此通常会考虑不同的选项。在控制流的正常处理中处理错误会通过在引起错误的方法堆栈中传播所需的处理错误的代码来破坏模块化，代码中到处都是永无止境的条件。因此，需要更复杂的选项。
- en: A good alternative to exceptions is to notify errors to an error handler that
    is defined in the dependency injection engine. Being scoped, the same service
    instance is returned while each request is being processed so that the handler
    that controls the execution of the whole call stack can inspect possible errors
    when the flow of control returns to it and can handle them appropriately. Unfortunately,
    this sophisticated technique can't abort the operation's execution immediately
    or return it to the controlling handler. This is why exceptions are recommended
    for this scenario, notwithstanding their performance issues.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的替代方案是将错误通知到依赖注入引擎中定义的错误处理程序，而不是使用异常。由于作用域限定，当每个请求被处理时，相同的服务实例被返回，以便控制整个调用堆栈的处理程序在控制流返回时检查可能的错误，并适当地处理它们。不幸的是，这种复杂的技术无法立即中止操作的执行或将其返回给控制处理程序。这就是为什么在这种情况下建议使用异常，尽管它们存在性能问题。
- en: Business-level validation must not be confused with input validation, which
    will be discussed in more detail in *Chapter 15*, *Presenting ASP.NET Core MVC*,
    since the two types of validation have different and complementary purposes. While
    business-level validation rules encode domain rules, input validation enforces
    the format of every single input (string length, correct email and URL formats,
    and so on), ensures that all the necessary input has been provided, enforces the
    execution of the chosen user-machine interaction protocols, and provides fast
    and immediate feedback that drives the user to interact with the system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 业务级别验证不应与输入验证混淆，输入验证将在*第15章* *介绍ASP.NET Core MVC*中更详细地讨论，因为这两种验证类型具有不同且互补的目的。虽然业务级别验证规则编码领域规则，但输入验证强制执行每个输入的格式（字符串长度，正确的电子邮件和URL格式等），确保提供了所有必要的输入，强制执行所选择的用户-机器交互协议，并提供快速和即时的反馈，以驱使用户与系统进行交互。
- en: 'Since DDD entities must have a well-defined identity, they must have properties
    that act as primary keys. It is common to override the `Object.Equals` method
    of all the DDD entities in such a way that two objects are considered equal whenever
    they have the same primary keys. This is easily achieved by letting all the entities
    inherit from an abstract `Entity` class, as shown in the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DDD实体必须具有明确定义的标识，它们必须具有充当主键的属性。通常会以这样一种方式重写所有DDD实体的`Object.Equals`方法，即当两个对象具有相同的主键时，它们被视为相等。这很容易通过让所有实体继承自一个抽象的`Entity`类来实现，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is worth pointing out that, once we've redefined the `Object.Equals` method
    in the `Entity` class, we can also override the `==` and `!=` operators.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，一旦我们在`Entity`类中重新定义了`Object.Equals`方法，我们还可以重写`==`和`!=`运算符。
- en: The `IsTransient` predicate returns `true` whenever the entity has been recently
    created and hasn't been recorded in the permanent storage, so its primary key
    is still undefined.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsTransient`谓词在实体最近创建并且尚未记录在永久存储中时返回`true`，因此其主键仍未定义。'
- en: In .NET, it is good practice that, whenever you override the `Object.Equals`
    method of a class, you also override its `Object.GetHashCode` method so that class
    instances can be efficiently stored in data structures such as dictionaries and
    sets. That's why the `Entity` class overrides it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET中，一个良好的做法是，每当重写类的`Object.Equals`方法时，也要重写其`Object.GetHashCode`方法，以便类实例可以有效地存储在诸如字典和集合之类的数据结构中。这就是为什么`Entity`类对其进行了重写。
- en: It is also worth implementing an `IEntity<K>` interface that defines all the
    properties/methods of `Entity<K>`. This interface is useful whenever we need to
    hide data classes behind interfaces.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得实现一个定义`Entity<K>`的所有属性/方法的`IEntity<K>`接口。每当我们需要在接口后面隐藏数据类时，这个接口就很有用。
- en: Value objects, on the other hand, represent complex types that can't be encoded
    with numbers or strings. Therefore, they have no identity and no principal keys.
    They have no operations defined on them and are immutable; that is, once they've
    been created, all their fields can be read but cannot be modified. For this reason,
    they are usually encoded with classes whose properties have protected/private
    setters. Two value objects are considered equal when all their independent properties
    are equal (some properties are not independent since they just show data that's
    been encoded by other properties in a different way, as is the case for the ticks
    of `DateTime` and its representation of the date and time fields).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，值对象代表无法用数字或字符串编码的复杂类型。因此，它们没有身份和主键。它们没有在其上定义的操作，并且是不可变的；也就是说，一旦它们被创建，所有字段都可以被读取，但不能被修改。因此，它们通常被编码为具有受保护/私有设置器的类。当所有独立属性都相等时，两个值对象被认为是相等的（有些属性不是独立的，因为它们只显示以不同方式由其他属性编码的数据，就像`DateTime`的刻度和其日期和时间字段的表示方式一样）。
- en: 'Value types are easily implemented with C# 9 `record` types, since all `record`
    types automatically override the `Equals` method so that it performs a property
    by property comparison. Moreover, `record` types behave like `structs`, in that
    a new instance is created at each assignment. However, record types are also immutable;
    that is, once initialized, the only way to change their values is to create a
    new instance. Here is an example of how to modify a `record`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有`record`类型都会自动重写`Equals`方法，因此很容易使用C# 9的`record`类型来实现值类型，以便进行逐属性比较。此外，`record`类型的行为类似于`structs`，在每次赋值时都会创建一个新实例。但是，`record`类型也是不可变的；也就是说，一旦初始化，改变它们的值的唯一方法是创建一个新实例。以下是如何修改`record`的示例：
- en: '[PRE1]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is an example of how to define a `record`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何定义`record`的示例：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `init` keyword is what makes `record` types properties immutable, since
    it means they can be only initialized.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`关键字使`record`类型的属性不可变，因为它意味着它们只能被初始化。'
- en: Typical value objects include costs represented as a number and a currency symbol,
    locations represented as longitude and latitude, addresses, and contact information.
    When the interface of the storage engine is Entity Framework, which we analyzed
    in *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*, and *Chapter
    9*, *How to Choose Your Data Storage in the Cloud*, value objects are connected
    with the entity that uses them through the `OwnsMany` and `OwnsOne` relationships.
    In fact, such relationships also accept classes with no principal keys defined
    on them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的值对象包括以数字和货币符号表示的成本，以经度和纬度表示的位置，地址和联系信息。当存储引擎的接口是Entity Framework时，我们在第8章《使用C#与数据交互-Entity
    Framework Core》和第9章《如何选择云中的数据存储》中进行了分析，值对象通过`OwnsMany`和`OwnsOne`关系与使用它们的实体相连。事实上，这样的关系也接受没有主键定义的类。
- en: When the storage engine is a NoSQL database, value objects are stored inside
    the record of the entities that use them. On the other hand, in the case of relational
    databases, they can either be implemented with separated tables whose principal
    keys are handled automatically by Entity Framework and are hidden from the developer
    (no property is declared as a principal key) or, in the case of `OwnsOne`, they
    are flattened and added to the table associated with the entity that uses them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当存储引擎是NoSQL数据库时，值对象存储在使用它们的实体的记录中。另一方面，在关系数据库的情况下，它们可以通过分离的表来实现，其主键由Entity Framework自动处理并对开发人员隐藏（没有属性被声明为主键），或者在`OwnsOne`的情况下，它们被展开并添加到使用它们的实体相关的表中。
- en: Using SOLID principles to map your domains
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SOLID原则来映射您的领域
- en: 'In the following subsections, we will describe some of the patterns that are
    commonly used with DDD. Some of them can be adopted in all projects, while others
    can only be used for certain Bounded Contexts. The general idea is that the business
    layer is split into two layers:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将描述一些常用的DDD模式。其中一些可以在所有项目中采用，而另一些只能用于特定的Bounded Contexts。总体思想是业务层分为两层：
- en: Application layer
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用层
- en: Domain layer
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层
- en: Here, the domain layer is an abstraction of the data layer based on the Ubiquitous
    Language. It is where DDD entities and value objects are defined together with
    abstractions of the operations to retrieve and save them. These operations are
    defined in interfaces that are implemented in the underlying data layer (Entity
    Framework in our case).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，领域层是基于普遍语言对数据层的抽象。这是定义DDD实体和值对象以及检索和保存它们的操作的地方。这些操作在接口中定义，并在底层数据层（在我们的案例中是Entity
    Framework）中实现。
- en: The application layer, instead, defines operations that use the domain layer
    interfaces, to get DDD entities and value objects, and that manipulate them to
    implement the application business logic.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层定义了使用领域层接口的操作，以获取DDD实体和值对象，并对它们进行操作以实现应用程序业务逻辑。
- en: As we will see later on in this chapter, it is common to implement the domain
    layer with just interfaces that are implemented in the data layer. Thus, the data
    layer must have a reference to the domain layer since it must implement its interfaces,
    while the application layer is where each domain layer interface is connected
    with its implementation through a record of the application layer dependency injection
    engine. More specifically, the only data layer objects referenced by the application
    layer are these interface implementations that are referenced only in the dependency
    injection engine.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面看到的那样，通常只使用领域层中的接口来实现领域层。因此，数据层必须引用领域层，因为它必须实现其接口，而应用层是通过应用层依赖注入引擎的记录将每个领域层接口与其实现连接起来的地方。更具体地说，应用层引用的唯一数据层对象是仅在依赖注入引擎中引用的这些接口实现。
- en: 'Each application layer operation requires the interfaces it needs from the
    dependency engine, uses them to get DDD entities and value objects, manipulates
    them, and possibly saves them through the same interfaces. Here is a diagram that
    shows the relations among the three layers discussed in this section:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用层操作都需要从依赖引擎中获取所需的接口，使用它们获取DDD实体和值对象，对它们进行操作，并可能通过相同的接口保存它们。下面是一个显示本节讨论的三个层之间关系的图表：
- en: '![](img/B16756_12_03.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_03.png)'
- en: 'Figure 12.3: Relations among layers'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3：层之间的关系
- en: Thus, the domain layer contains the representation of the domain objects, the
    methods to use on them, validation constraints, and its relationship with various
    entities. To increase modularity and decoupling, communication among entities
    is usually encoded with events, that is, with a Publisher/Subscriber pattern.
    This means entity updates can trigger events that have been hooked to business
    operations, and these events act on other entities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，领域层包含领域对象的表示、在其上使用的方法、验证约束以及与各种实体的关系。为了增加模块化和解耦，实体之间的通信通常使用事件进行编码，即发布者/订阅者模式。这意味着实体更新可以触发已连接到业务操作的事件，并且这些事件会对其他实体进行操作。
- en: This layered architecture allows us to change the whole data layer without affecting
    the domain layer, which only depends on the domain specifications and language
    and doesn't depend on the technical details of how the data is handled.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分层架构使我们能够更改整个数据层而不影响领域层，后者仅依赖于领域规范和语言，不依赖于数据处理的技术细节。
- en: The application layer contains the definitions of all the operations that may
    potentially affect several entities and the definitions of all the queries that
    are needed by the applications. Both business operations and queries use the interfaces
    defined in the domain layer to interact with the data layer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层包含可能影响多个实体的所有操作的定义，以及应用程序所需的所有查询的定义。业务操作和查询都使用领域层中定义的接口与数据层交互。
- en: However, while business operations manipulate and exchange entities with these
    interfaces, queries send query specifications and receive generic **Data Transfer
    Objects** (**DTOs**) from them. In fact, the purpose of queries is just to show
    data to the user, not to act on them; accordingly, query operations don't need
    whole entities with all their methods, properties, and validation rules, but just
    property tuples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，虽然业务操作通过这些接口操作和交换实体，查询则向它们发送查询规范，并从它们接收通用的**数据传输对象**（**DTOs**）。事实上，查询的目的只是向用户显示数据，而不是对其进行操作；因此，查询操作不需要整个实体及其所有方法、属性和验证规则，而只需要属性元组。
- en: Business operations are invoked either by other layers (typically the presentation
    layer) or by communication operations. Business operations may also be hooked
    to events that are triggered when some entities are modified by other operations.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 业务操作可以由其他层（通常是表示层）或通信操作调用。业务操作也可以连接到由其他操作修改实体时触发的事件。
- en: Summing up, the application layer operates on the interfaces defined in the
    domain layer instead of interacting directly with their data layer implementations,
    which means that the application layer is decoupled from the data layer. More
    specifically, data layer objects are only mentioned in the dependency injection
    engine definitions. All the other application layer components refer to the interfaces
    that are defined in the domain layers, and the dependency injection engine injects
    the appropriate implementations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，应用层在领域层中定义的接口上操作，而不是直接与数据层实现交互，这意味着应用层与数据层解耦。更具体地说，数据层对象仅在依赖注入引擎定义中提到。所有其他应用层组件都引用领域层中定义的接口，依赖注入引擎注入适当的实现。
- en: 'The application layer communicates with other application components through
    one or more of the following patterns:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层通过以下一种或多种模式与其他应用组件通信：
- en: It exposes business operations and queries on a communication endpoint, such
    as an HTTP Web API (see *Chapter 14*, *Applying Service-Oriented Architectures
    with .NET Core*). In this case, the presentation layer may connect to this endpoint
    or to other endpoints that, in turn, take information from this and other endpoints.
    Application components that collect information from several endpoints and expose
    them in a unique endpoint are called gateways. They may be either custom or general
    purpose, such as Ocelot.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在通信端点上公开业务操作和查询，比如HTTP Web API（参见*第14章*，*使用.NET Core应用服务导向架构*）。在这种情况下，表示层可以连接到这个端点，或者连接到其他端点，这些端点反过来从这个和其他端点获取信息。从几个端点收集信息并在一个唯一端点中公开它们的应用组件称为网关。它们可以是自定义的，也可以是通用的，比如Ocelot。
- en: It is referenced as a library by an application that directly implements the
    presentation layer, such as an ASP.NET Core MVC Web application.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被应用程序作为库引用，直接实现表示层，比如ASP.NET Core MVC Web应用程序。
- en: It doesn't expose all the information through endpoints and communicates some
    of the data it processes/creates to other application components that, in turn,
    expose endpoints. Such communication is often implemented with the Publisher/Subscriber
    pattern to increase modularity.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不通过端点公开所有信息，并将其处理/创建的一些数据传递给其他应用程序组件，这些组件反过来公开端点。这种通信通常使用发布者/订阅者模式来增加模块化。
- en: Before we describe these patterns, we need to understand the concept of aggregates.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述这些模式之前，我们需要了解聚合的概念。
- en: Aggregates
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 聚合
- en: So far, we have talked about entities as the **units** that are processed by
    a DDD-based business layer. However, several entities can be manipulated and made
    into single entities. An example of this is a purchase order and all of its items.
    In fact, it makes absolutely no sense to process a single order-item independently
    of the order it belongs to. This happens because order-items are actually subparts
    of an order, not independent entities.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经谈到了实体作为基于DDD的业务层处理的**单元**。然而，可以操作并组成单个实体的多个实体。一个例子是采购订单及其所有项目。事实上，独立处理单个订单项而不考虑其所属的订单是毫无意义的。这是因为订单项实际上是订单的子部分，而不是独立的实体。
- en: There is no transaction that may affect a single order-item without it affecting
    the order that the item is in. Imagine that two different people in the same company
    are trying to increase the total quantity of cement, but one increases the quantity
    of type-1 cement (item 1) while the other increases the quantity of type-2 cement
    (item 2). If each item is processed as an independent entity, both quantities
    will be increased, which could cause an incoherent purchase order since the total
    quantity of cement would be increased twice.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何交易可能会影响单个订单项而不影响该项所在的订单。想象一下，同一家公司的两个不同的人试图增加水泥的总数量，但一个人增加了1型水泥（项目1）的数量，而另一个人增加了2型水泥（项目2）的数量。如果每个项目都被处理为独立实体，那么两个数量都将增加，这可能导致不一致的采购订单，因为水泥的总数量将增加两次。
- en: On the other hand, if the whole order, along with all its order-items, is loaded
    and saved with every single transaction by both people, one of the two will overwrite
    the changes of the other one, so whoever makes the final change will have their
    requirements set. In a web application, it isn't possible to lock the purchase
    order for the whole time the user sees and modifies it, so an optimistic concurrency
    policy is used. If the data layer is based on **Entity Framework** (**EF**) Core
    we can use the EF concurrency check attribute. If we decorate a property with
    the `[ConcurrencyCheck]` attribute, when EF saves changes, the transaction is
    aborted and a concurrency exception is generated whenever the value in the database
    of the property decorated with `[ConcurrencyCheck]` differs from the one retrieved
    when the entity was read.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果整个订单及其所有订单项都在每个交易中加载和保存，那么两者中的一个将覆盖另一个的更改，因此最终进行更改的人将满足其要求。在Web应用程序中，不可能锁定用户查看和修改订单的整个时间，因此使用乐观并发策略。如果数据层基于**Entity
    Framework**（**EF**）Core，我们可以使用EF并发检查属性。如果我们使用`[ConcurrencyCheck]`属性修饰属性，当EF保存更改时，如果数据库中的属性值与检索实体时的值不同时，事务将中止并生成并发异常。
- en: 'For instance, it is enough to add a version number decorated with `[ConcurrencyCheck]`
    to each purchase order and to do the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，只需为每个采购订单添加一个带有`[ConcurrencyCheck]`修饰的版本号，并执行以下操作：
- en: Read the order without opening any transaction, and update it.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不打开任何交易的情况下阅读订单，并更新它。
- en: Before saving the updated purchase order, we increment the counter.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在保存更新后的采购订单之前，我们会递增计数器。
- en: When we save all changes, if someone else incremented this counter before we
    were able to save our changes, a concurrency exception is generated and the operation
    is aborted.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们保存所有更改时，如果其他人在我们能够保存更改之前递增了此计数器，则会生成并发异常并中止操作。
- en: Repeat from *step 1* until no concurrency exception occurs.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复从*步骤1*开始，直到不再发生并发异常。
- en: It is also possible to use an automatically generated `TimeStamp` instead of
    a counter. However, as we will see shortly, we need counters to implement the
    **Command Query Responsibility Segregation** (**CQRS**) pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用自动生成的`TimeStamp`代替计数器。然而，正如我们将很快看到的，我们需要计数器来实现**命令查询责任分离**（**CQRS**）模式。
- en: A purchase order, along with all its subparts (its order-items), is called an
    **aggregate**, while the order entity is called the root of the aggregate. Aggregates
    always have roots since they are hierarchies of entities connected by **subpart**
    relations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 采购订单及其所有子部分（订单项）称为**聚合**，而订单实体称为聚合的根。聚合始终具有根，因为它们是由**子部分**关系连接的实体的层次结构。
- en: Since each aggregate represents a single complex entity, all the operations
    on it must be exposed by a unique interface. Therefore, the aggregate root usually
    represents the whole aggregate, and all the operations on the aggregate are defined
    as methods of the root entity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个聚合表示单个复杂实体，因此必须通过唯一接口公开对其进行的所有操作。因此，聚合根通常表示整个聚合，聚合上的所有操作都被定义为根实体的方法。
- en: When the aggregate pattern is used, the units of information that are transferred
    between the business layer and the data layer are called aggregates, queries,
    and query results. Thus, aggregates replace single entities.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用聚合模式时，业务层和数据层之间传输的信息单元称为聚合、查询和查询结果。因此，聚合取代了单个实体。
- en: What about the WWTravelClub location and packages entities we looked at in *Chapter
    8*, *Interacting with Data in C# – Entity Framework Core*, and *Chapter 9*, *How
    to Choose Your Data Storage in the Cloud*? Are packages part of the unique aggregates
    that are rooted in their associated locations? No! In fact, locations are rarely
    updated, and changes that are made to a package have no influence on its location
    or on the other packages associated with the same location.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们在第8章《使用C#与数据交互-Entity Framework Core》和第9章《如何选择云中的数据存储》中看到的WWTravelClub位置和套餐实体呢？套餐是否是根植于其关联位置的唯一聚合的一部分？不是！实际上，位置很少更新，对套餐所做的更改对其位置或与同一位置关联的其他套餐都没有影响。
- en: The repository and Unit of Work patterns
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仓库和工作单元模式
- en: 'The repository pattern is an entity-centric approach to the definition of the
    domain layer interfaces: each aggregate has its own repository interface that
    defines how to retrieve and save it, and that defines all queries that involve
    entities in the aggregate. The data layer implementation of each repository interface
    is called a repository.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式是领域层接口定义的以实体为中心的方法：每个聚合都有自己的仓库接口，定义了如何检索和保存它，并定义了涉及聚合中实体的所有查询。每个仓库接口的数据层实现称为仓库。
- en: 'With the repository pattern, each operation has an easy-to-find place where
    it must be defined: the interface of the aggregate the operation works on, or,
    in case of a query, the aggregate that contains the root entity of the query.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仓库模式，每个操作都有一个易于找到的位置来定义：操作所在的聚合的接口，或者在查询的情况下，包含查询根实体的聚合。
- en: Often, application layer operations that span several aggregates and that, accordingly,
    use several different repository interfaces must be executed in a unique transaction.
    The **Unit of Work** pattern is a solution that maintains the independence of
    the domain layer from the underlying data layer. It states that each repository
    interface must also contain a reference to a Unit of Work interface that represents
    the identity of the current transaction. This means that several repositories
    with the same Unit of Work reference belong to the same transaction.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，跨多个聚合的应用层操作，因此使用多个不同的仓库接口，必须在唯一事务中执行。**工作单元**模式是保持领域层独立于底层数据层的解决方案。它规定每个仓库接口还必须包含对表示当前事务标识的工作单元接口的引用。这意味着具有相同工作单元引用的多个仓库属于同一事务。
- en: 'Both the repository and the unit of work patterns can be implemented by defining
    some seed interfaces:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库模式和工作单元模式都可以通过定义一些种子接口来实现：
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All repository interfaces inherit from `IRepository<T>` and bind `T` to the
    aggregate root they are associated with, while Unit of Work simply implements
    `IUnitOfWork`. When using Entity Framework, `IUnitOfWork` is usually implemented
    with `DBContext`, which means that `SaveEntitiesAsync()` can perform other operations
    and then call the `DBContext` `SaveChangeAsync` method so that all the pending
    changes are saved in a single transaction. If a wider transaction that starts
    when some data is retrieved from the storage engine is needed, it must be started
    and committed/aborted by the application layer handler, which takes care of the
    whole operation with the help of the `IUnitOfWork` `StartAsync`, `CommitAsync`,
    and `RollbackAsync` methods. `IRepository<T>` inherits from an empty `IRepository`
    interface to help automatic repository discovery. The GitHub repository associated
    with this book contains a `RepositoryExtensions` class whose `AddAllRepositories`
    `IServiceCollection` extension method automatically discovers all the repository
    implementations contained in an assembly and adds them to the dependency injection
    engine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仓库接口都继承自`IRepository<T>`，并将`T`绑定到它们关联的聚合根，而工作单元只是实现`IUnitOfWork`。在使用Entity
    Framework时，`IUnitOfWork`通常与`DBContext`一起实现，这意味着`SaveEntitiesAsync()`可以执行其他操作，然后调用`DBContext`的`SaveChangeAsync`方法，以便将所有未决更改保存在单个事务中。如果需要启动从存储引擎检索数据时开始的更广泛的事务，则必须由应用程序层处理程序启动并提交/中止，该处理程序借助`IUnitOfWork`的`StartAsync`、`CommitAsync`和`RollbackAsync`方法来处理整个操作。`IRepository<T>`继承自一个空的`IRepository`接口，以帮助自动发现仓库。与本书相关联的GitHub仓库包含一个`RepositoryExtensions`类，其`AddAllRepositories`
    `IServiceCollection`扩展方法会自动发现包含在程序集中的所有仓库实现，并将它们添加到依赖注入引擎中。
- en: 'Here''s a diagram of the application layer/domain layer/data layer architecture
    based on the repository and Unit of Work patterns:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于仓库和工作单元模式的应用层/领域层/数据层架构的图表：
- en: '![](img/B16756_12_04.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_04.png)'
- en: 'Figure 12.4: Layer responsibilities and mutual references'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4：层责任和相互引用
- en: The main advantage of avoiding direct references to repository implementations
    is that the various modules can be tested easily if we mock these interfaces.
    The domain events mentioned in the domain layer are the events that implement
    the communication between different Bounded Contexts mentioned in the *Understanding
    domain-driven design* section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 避免直接引用仓库实现的主要优势是，如果我们模拟这些接口，各个模块可以很容易地进行测试。领域层中提到的领域事件是实现*理解领域驱动设计*部分中提到的不同边界上下文之间通信的事件。
- en: DDD entities and Entity Framework Core
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 领域驱动设计实体和Entity Framework Core
- en: DDD requires entities to be defined in a way that is different from the way
    we defined entities in *Chapter 8*, *Interacting with Data in C# – Entity Framework
    Core*. In fact, Entity Framework entities are record-like lists of public properties
    with almost no methods, while DDD entities should have methods that encode domain
    logic, more sophisticated validation logic, and read-only properties. While further
    validation logic and methods can be added without breaking Entity Framework's
    operations, adding read-only properties that must not be mapped to database properties
    can create problems that must be handled adequately. Preventing properties from
    being mapped to the database is quite easy—all we need to do is decorate them
    with the `NotMapped` attribute.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: DDD要求以一种与我们在*第8章* *在C#中与数据交互-Entity Framework Core*中定义实体的方式不同的方式定义实体。实际上，Entity
    Framework实体是类似记录的公共属性列表，几乎没有方法，而DDD实体应该具有编码领域逻辑、更复杂的验证逻辑和只读属性的方法。虽然可以在不破坏Entity
    Framework操作的情况下添加进一步的验证逻辑和方法，但添加不能映射到数据库属性的只读属性可能会产生必须适当处理的问题。防止属性映射到数据库非常容易——我们只需要用`NotMapped`属性装饰它们。
- en: 'The issues that read-only properties have are a little bit more complex and
    can be solved in three fundamental ways:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性存在的问题有点复杂，可以通过三种基本方式解决：
- en: '**Map EF entities to different classes**. Define the DDD entities as different
    classes and copy data to/from them when entities are returned/passed to repository
    methods. This is the easiest solution, but it requires that you write some code
    so that you can convert the entities between the two formats. DDD entities are
    defined in the domain layer, while the EF entities continue being defined in the
    data layer. This is the cleaner solution, but it causes a non-trivial overhead
    in both code writing and maintenance. I recommend it when you have complex aggregates
    with several complex methods.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将EF实体映射到不同的类**。将DDD实体定义为不同的类，并在实体返回/传递给存储库方法时复制数据。这是最简单的解决方案，但它需要编写一些代码，以便可以在两种格式之间转换实体。DDD实体在领域层中定义，而EF实体继续在数据层中定义。这是更干净的解决方案，但它会在编写和维护代码方面产生非常大的开销。我建议在有多个复杂聚合和多个复杂方法时使用它。'
- en: '**Map table fields to private properties**. Let Entity Framework Core map fields
    to private class fields so that you can decide how to expose them to properties
    by writing custom getters and/or setters. It is sufficient to give either the
    `_<property name>` name or the `_<property name in camel case>` name to these
    private fields, and Entity Framework will use them instead of their associated
    properties. In this case, DDD entities defined in the domain layer are used also
    as data layer entities. The main disadvantage of this approach is that we can''t
    use data annotations to configure each property because DDD entities can''t depend
    on how the underlying data layer is implemented. Therefore, we must configure
    all database mapping in the `OnModelCreating` `DbContext` method. This is the
    simpler solution but it generates code that is not readable and is difficult to
    maintain, so I don''t advise adopting it at all.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将表字段映射到私有属性**。让Entity Framework Core将字段映射到私有类字段，以便您可以决定如何通过编写自定义getter和/或setter将它们暴露为属性。只需给这些私有字段命名为`_<属性名称>`或`_<属性名称的驼峰命名法>`，Entity
    Framework就会使用它们而不是它们关联的属性。在这种情况下，在领域层中定义的DDD实体也用作数据层实体。这种方法的主要缺点是我们不能使用数据注释来配置每个属性，因为DDD实体不能依赖底层数据层的实现方式。因此，我们必须在`OnModelCreating`
    `DbContext`方法中配置所有数据库映射。这是更简单的解决方案，但它会生成不可读且难以维护的代码，因此我不建议完全采用它。'
- en: '**Define DDD as interfaces**. Hide each Entity Framework class with all its
    public properties behind an interface that, when needed, only exposes property
    getters. The interface is defined in the domain layer, while the entity continues
    being defined in the data layer. In this case, the repository must expose a `Create`
    method that returns an implementation of the interface; otherwise, the higher
    layers won''t be able to create new instances that can be added to the storage
    engine since interfaces can''t be created with `new`. This is the solution I prefer
    when there are several simple entities.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定义DDD接口**。使用接口隐藏每个Entity Framework类及其所有公共属性，当需要时，只暴露属性的getter。接口在领域层中定义，而实体继续在数据层中定义。在这种情况下，存储库必须暴露一个`Create`方法，该方法返回接口的实现；否则，更高层将无法创建可以添加到存储引擎的新实例，因为接口不能使用`new`创建。当存在多个简单实体时，这是我更喜欢的解决方案。'
- en: 'For instance, suppose that we would like to define a DDD interface called `IDestination`
    for the `Destination` class defined in the *Defining DB entities* subsection of
    *Chapter 8*, *Interacting with Data in C# – Entity Framework Core*, and suppose
    we would like to expose the `Id`, `Name`, and `Country` properties as read-only
    since once a destination is created it can''t be modified anymore. Here, it is
    sufficient to let `Destination` implement `IDestination` and to define `Id`, `Name`,
    and `Country` as read-only in `IDestination`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想要为*第8章* *在C#中与数据交互-Entity Framework Core*的*定义DB实体*子部分中定义的`Destination`类定义一个名为`IDestination`的DDD接口，并且假设我们想要将`Id`、`Name`和`Country`属性暴露为只读，因为一旦创建了目的地，就不能再修改了。在这里，让`Destination`实现`IDestination`并在`IDestination`中将`Id`、`Name`和`Country`定义为只读就足够了：
- en: '[PRE4]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we've discussed the basic patterns of DDD and how to adapt Entity Framework
    for the needs of DDD, we can discuss more advanced DDD patterns. In the next section,
    we will introduce the CQRS pattern.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了DDD的基本模式以及如何调整Entity Framework以满足DDD的需求，我们可以讨论更高级的DDD模式。在下一节中，我们将介绍CQRS模式。
- en: Command Query Responsibility Segregation (CQRS) pattern
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令查询职责分离（CQRS）模式
- en: 'In its general form, the usage of this pattern is quite easy: use different
    structures to store and query data. Here, the requirements regarding how to store
    and update data differ from the requirements of queries. In the case of DDD, the
    unit of storage is the **aggregate**, so additions, deletions, and updates involve
    aggregates, while queries usually involve more or less complicated transformations
    of properties that have been taken from several aggregates.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在其一般形式中，使用此模式非常简单：使用不同的结构存储和查询数据。在这里，关于如何存储和更新数据的要求与查询的要求不同。在DDD的情况下，存储单元是**聚合**，因此添加、删除和更新涉及聚合，而查询通常涉及从多个聚合中获取的属性的更多或更少复杂的转换。
- en: Moreover, usually, we don't perform business operations on query results. We
    just use them to compute other data (averages, sums, and so on). Therefore, while
    updates require entities with full object-oriented semantics (methods, validation
    rules, encapsulated information, and so on), query results just need sets of property/value
    pairs, so **Data Transfer Objects** (**DTOs**) with only public properties and
    no methods work well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通常情况下，我们不会对查询结果执行业务操作。我们只是用它们来计算其他数据（平均值、总和等）。因此，虽然更新需要具有完整面向对象语义（方法、验证规则、封装信息等）的实体，但查询结果只需要一组属性/值对，因此只具有公共属性而没有方法的**数据传输对象**（**DTOs**）可以很好地工作。
- en: 'In its common form, the pattern can be depicted as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在其常见形式中，该模式可以描述如下：
- en: '![](img/B16756_12_05.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_05.png)'
- en: 'Figure 12.5: Commands and queries processing'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5：命令和查询处理
- en: 'The main takeaway from this is that the extraction of query results don''t
    need to pass through the construction of entities and aggregates, but the fields
    shown in the query must be extracted from the storage engine and projected into
    ad hoc DTOs. If queries are implemented with LINQ, we need to use the `Select`
    clause to project the necessary properties into DTOs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从中可以得出的主要观点是，提取查询结果不需要经过实体和聚合的构造，而是必须从存储引擎中提取查询中显示的字段，并投影到特定的DTO中。如果使用LINQ实现查询，我们需要使用`Select`子句将必要的属性投影到DTO中：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, in more complex situations, CQRS may be implemented in a stronger form.
    Namely, we can use different Bounded Contexts to store preprocessed query results.
    This approach is common when queries involve data stored in different Bounded
    Contexts that are handled by different distributed microservices.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在更复杂的情况下，CQRS可以以更强大的形式实现。换句话说，我们可以使用不同的有界上下文存储预处理的查询结果。当查询涉及存储在不同有界上下文中的数据，并由不同的分布式微服务处理时，这种方法很常见。
- en: 'In fact, the other option would be an aggregator microservice that queries
    all the necessary microservices in order to assemble each query result. However,
    recursive calls to other microservices to build an answer may result in unacceptable
    response times. Moreover, factoring out some preprocessing ensures better usage
    of the available resources. This pattern is implemented as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，另一个选择是使用聚合器微服务查询所有必要的微服务，以组装每个查询结果。然而，对其他微服务进行递归调用以构建答案可能会导致无法接受的响应时间。此外，分解一些预处理可以更好地利用可用资源。该模式的实现如下：
- en: Query handling is delegated to specialized microservices.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查询处理被委托给专门的微服务。
- en: Each query-handling microservice uses a database table for each query it must
    handle. There, it stores all fields to be returned by the query. This means that
    queries are not computed at each request, but pre-computed and stored in specific
    database tables. Clearly, queries with child collections need additional tables,
    one for each child collection.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个查询处理微服务为其必须处理的每个查询使用一个数据库表。在那里，它存储查询返回的所有字段。这意味着查询不会在每个请求时计算，而是预先计算并存储在特定的数据库表中。显然，具有子集合的查询需要额外的表，每个子集合一个。
- en: All microservices that process updates forward all changes to the interested
    query-handling microservices. Records are versioned so the query-handling microservices
    that receive the changes can apply them in the right order to their query-handling
    tables. In fact, since communication is asynchronous to improve performance, changes
    are not ensured to be received in the same order they were sent.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有处理更新的微服务都将所有更改转发给感兴趣的查询处理微服务。记录被版本化，因此接收更改的查询处理微服务可以按正确顺序将其应用于其查询处理表。实际上，由于通信是异步的以提高性能，无法保证更改会按照发送的顺序接收。
- en: Changes received by each query-handling microservice are cached while they wait
    for the changes to be applied. Whenever a change has a version number that immediately
    follows the last change applied, it is applied to the right query-handling table.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个查询处理微服务接收的更改在等待应用更改时被缓存。每当一个更改具有紧随最后应用的更改的版本号时，它就会被应用到正确的查询处理表中。
- en: The usage of this stronger form of the CQRS pattern transforms usual local database
    transactions into complex time-consuming distributed transactions since a failure
    in a single query preprocessor microservice should invalidate the whole transaction.
    As we explained in *Chapter 5*, *Applying a Microservice Architecture to Your
    Enterprise Application*, implementing distributed transactions is usually unacceptable
    for performance reasons, and sometimes is not supported at all, so the common
    solution is to renounce the idea of a database that is immediately consistent
    overall, and to accept that the overall database will eventually be consistent
    after each update. Transient failures can be solved with the retry policies that
    we analyzed in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, while permanent failures are handled by performing corrective actions
    on the already committed local transactions instead of pretending to implement
    an overall globally distributed transaction.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种更强大形式的CQRS模式将通常的本地数据库事务转换为复杂耗时的分布式事务，因为单个查询预处理微服务的失败应该使整个事务无效。正如我们在*第5章*中解释的，将分布式事务通常不可接受，因为性能原因，有时根本不支持，因此常见的解决方案是放弃立即一致的整体数据库的想法，并接受每次更新后整体数据库最终一致。瞬态故障可以通过我们在*第5章*中分析的重试策略来解决，而永久故障则通过对已提交的本地事务执行纠正操作来处理，而不是假装实现整体全局分布式事务。
- en: As we discussed in *Chapter 5*, *Applying a Microservice Architecture to Your
    Enterprise Application*, communication between microservices is often implemented
    with the Publisher/Subscriber pattern to improve microservice separation.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*第5章*中讨论的，微服务之间的通信通常使用发布者/订阅者模式来实现，以改善微服务的分离。
- en: 'At this point, you may be asking the following question:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您可能会问以下问题：
- en: '"*Why do we need to keep the original data once we have all the preprocessed
    query results? We will never use it to answer queries!*"'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: “*一旦我们拥有了所有预处理的查询结果，为什么我们还需要保留原始数据呢？我们永远不会用它来回答查询！*”
- en: 'Some of the answers to this question are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个问题的一些答案如下：
- en: They are the source of truth that we may need to recover from failures.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是我们可能需要从失败中恢复的真相来源。
- en: We need them to compute new preprocessed results when we add new queries.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要它们来在添加新查询时计算新的预处理结果。
- en: We need them to process new updates. In fact, processing updates usually requires
    that some of the data is retrieved from the database, possibly shown to the user,
    and then modified. For instance, to modify an item in an existing purchase order,
    we need the whole order so that we can show it to the user and compute the changes
    so that we can forward it to other microservices. Moreover, whenever we modify
    or add data to the storage engine, we must verify the coherence of the overall
    database (unique key constraints, foreign key constraints, and so on).
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要它们来处理新的更新。实际上，处理更新通常需要从数据库中检索一些数据，可能向用户显示，然后进行修改。例如，要修改现有采购订单中的项目，我们需要整个订单，以便我们可以向用户显示它并计算更改，以便我们可以将其转发给其他微服务。此外，每当我们修改或向存储引擎添加数据时，我们必须验证整体数据库的一致性（唯一键约束，外键约束等）。
- en: In the next section, we will describe a common pattern that's used for handling
    operations that span several aggregates and several Bounded Contexts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将描述用于处理跨多个聚合和多个有界上下文的操作的常见模式。
- en: Command handlers and domain events
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令处理程序和领域事件
- en: 'To keep aggregates separated, usually, interactions with other aggregates and
    other Bounded Contexts are done through events. It is good practice to store all
    the events when they are created during the processing of each aggregate, instead
    of executing them immediately, in order to prevent event execution from interfering
    with the ongoing aggregate processing. This is easily achieved by adding the following
    code to the abstract `Entity` class defined in the *Entities and value objects*
    subsection of this chapter, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了保持聚合分离，与其他聚合和其他有界上下文的交互是通过事件完成的。在处理每个聚合期间创建事件时，最好将所有事件存储起来，而不是立即执行它们，以防止事件执行干扰正在进行的聚合处理。这可以通过将以下代码添加到本章*实体和值对象*子部分中定义的抽象`Entity`类中轻松实现，如下所示：
- en: '[PRE6]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `IEventNotification` is an empty interface that's used to mark classes
    as events.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`IEventNotification`是一个空接口，用于将类标记为事件。
- en: Event processing is usually performed immediately before changes are stored
    in the storage engine. Accordingly, a good place to perform event processing is
    immediately before the command handler calls the `SaveEntitiesAsync()` method
    of each `IUnitOfWork` implementation (see the *The repository and Unit of Work
    patterns* subsection). Similarly, if event handlers can create other events, they
    must process them after they finish processing all their aggregates.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理通常是在更改存储在存储引擎中之前立即执行的。因此，执行事件处理的好地方是在命令处理程序调用每个`IUnitOfWork`实现的`SaveEntitiesAsync()`方法之前（请参阅*存储库和工作单元模式*子部分）。同样，如果事件处理程序可以创建其他事件，它们必须在完成处理所有聚合后处理它们。
- en: 'Subscriptions to an event, `T`, can be provided as an implementation of the
    `IEventHandler<T>` interface:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对事件`T`的订阅可以作为`IEventHandler<T>`接口的实现提供：
- en: '[PRE7]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Analogously, business operations can be described by the `command` object,
    which contains all the input data of the operation, while the code that implements
    the actual operation can be provided through the implementation of an `ICommandHandler<T>`
    interface:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，业务操作可以由`command`对象描述，该对象包含操作的所有输入数据，而实现实际操作的代码可以通过实现`ICommandHandler<T>`接口提供：
- en: '[PRE8]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, `ICommand` is an empty interface that's used to mark classes as commands.
    `ICommandHandler<T>` and `IEventHandler<T>` are examples of the command pattern
    we described in *Chapter 11*, *Design Patterns and .NET 5 Implementation*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`ICommand`是一个空接口，用于将类标记为命令。`ICommandHandler<T>`和`IEventHandler<T>`是我们在*第11章*《设计模式和.NET
    5实现》中描述的命令模式的例子。
- en: Each `ICommandHandler<T>` can be registered in the dependency injection engine
    so that classes that need to execute a command, `T`, can use `ICommandHandler<T>`
    in their constructor. This way, we decouple the abstract definition of a command
    (the `command` class) from the way it is executed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`ICommandHandler<T>`都可以在依赖注入引擎中注册，以便需要执行命令`T`的类可以在其构造函数中使用`ICommandHandler<T>`。这样，我们将命令的抽象定义（`command`类）与其执行方式解耦。
- en: 'The same construction can''t be applied to events, `T`, and their `IEventHandler<T>`
    because when an event is triggered, we need to retrieve several instances of `IEventHandler<T>`
    and not just one. We need to do this since each event may have several subscriptions.
    However, a few lines of code can easily solve this difficulty. First, we need
    to define a class that hosts all the handlers for a given event type:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的构造不能应用于事件`T`及其`IEventHandler<T>`，因为当事件被触发时，我们需要检索多个`IEventHandler<T>`实例，而不仅仅是一个。我们需要这样做，因为每个事件可能有多个订阅。然而，几行代码可以轻松解决这个困难。首先，我们需要定义一个类，用于承载给定事件类型的所有处理程序：
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The idea is that each class that needs to trigger event `T` requires `EventTrigger<T>`
    and then passes the event to be triggered to its `Trigger` method, which, in turn,
    invokes all the handlers.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是，每个需要触发事件`T`的类都需要`EventTrigger<T>`，然后将要触发的事件传递给它的`Trigger`方法，该方法依次调用所有处理程序。
- en: 'Then, we need to register `EventTrigger<T>` in the dependency injection engine.
    A good idea is to define the dependency injection extensions that we can invoke
    to declare each event, as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要在依赖注入引擎中注册`EventTrigger<T>`。一个好主意是定义依赖注入扩展，我们可以调用它来声明每个事件，如下所示：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `AddEventHandler` extension must automatically produce a dependency injection
    definition for `EventTrigger<T>` and must process all the handlers that are declared
    with `AddEventHandler` for each type, `T`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`AddEventHandler`扩展必须自动为`EventTrigger<T>`生成一个依赖注入定义，并且必须处理使用`AddEventHandler`声明的每种类型`T`的所有处理程序。
- en: 'The following extension class does this for us:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下扩展类为我们执行此操作：
- en: '[PRE11]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `H` type passed to `AddEventHandler` is recorded in the dependency injection
    engine, and the first time `AddEventHandler` is called, `EventTrigger<>` is also
    added to the dependency injection engine. Then, when an `EventTrigger<T>` instance
    is required by the dependency injection engine, all `IEventHandler<T>` types added
    to the dependency injection engine are created, collected, and passed to the `EventTrigger(IEnumerable<IEventHandler<T>>
    handlers)` constructor.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`AddEventHandler`的`H`类型被记录在依赖注入引擎中，第一次调用`AddEventHandler`时，`EventTrigger<>`也被添加到依赖注入引擎中。然后，当依赖注入引擎需要`EventTrigger<T>`实例时，所有添加到依赖注入引擎中的`IEventHandler<T>`类型都会被创建、收集，并传递给`EventTrigger(IEnumerable<IEventHandler<T>>
    handlers)`构造函数。
- en: When the program starts up, all the `ICommandHandler<T>` and `IEventHandler<T>`
    implementations can be retrieved with reflection and registered automatically.
    To help with automatic discovery, they inherit from `ICommandHandler` and `IEventHandler`,
    which are both empty interfaces. The `EventDIExtensions` class, which is available
    in this book's GitHub repository, contains methods for the automatic discovery
    and registration of command handlers and event handlers. The GitHub repository
    also contains an `IEventMediator` interface and its `EventMediator` implementation,
    whose `TriggerEvents(IEnumerable<IEventNotification> events)` method retrieves
    all the handlers associated with the events it receives in its argument from the
    dependency injection engine and executes them. It is sufficient to have `IEventMediator`
    injected into a class so that it can trigger events. `EventDIExtensions` also
    contains an extension method that discovers all the queries that implement the
    empty `IQuery` interface and adds them to the dependency injection engine.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序启动时，所有`ICommandHandler<T>`和`IEventHandler<T>`的实现都可以通过反射自动检索和注册。为了帮助自动发现，它们继承自`ICommandHandler`和`IEventHandler`，这两个都是空接口。`EventDIExtensions`类，该类在本书的GitHub存储库中可用，包含了用于自动发现和注册命令处理程序和事件处理程序的方法。GitHub存储库还包含了`IEventMediator`接口及其`EventMediator`实现，其`TriggerEvents(IEnumerable<IEventNotification>
    events)`方法从依赖注入引擎中检索与其参数中接收到的事件相关的所有处理程序，并执行它们。只需将`IEventMediator`注入到一个类中，就可以触发事件。`EventDIExtensions`还包含一个扩展方法，用于发现实现空`IQuery`接口的所有查询，并将它们添加到依赖注入引擎中。
- en: A more sophisticated implementation is given by the `MediatR` NuGet package.
    The next subsection is dedicated to an extreme implementation of the CQRS pattern.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediatR` NuGet包提供了更复杂的实现。下一小节将专门介绍CQRS模式的极端实现。'
- en: Event sourcing
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源
- en: 'Event sourcing is an extreme implementation of the stronger form of CQRS. It
    is useful when the original Bounded Context database isn''t used at all to retrieve
    information but just as a **source of truth**, that is, for recovering from failures
    and for software maintenance. In this case, instead of updating data, we simply
    add events that describe the operation that was performed: deleted `record Id
    15`, changed the name to `John in Id 21`, and so on. These events are immediately
    sent to all the dependent Bounded Contexts, and in the case of failures and/or
    the addition of new queries, all we have to do is to reprocess some of them. Event
    reprocessing can''t cause problems if events are idempotent, that is, if processing
    the same event several times has the same effect of processing it once.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是更强的CQRS的极端实现。当原始有界上下文数据库根本不用于检索信息，而仅用作**真相的来源**时，即用于从故障中恢复和进行软件维护时，它是有用的。在这种情况下，我们不是更新数据，而是简单地添加描述已执行操作的事件：删除`记录Id
    15`，将名称更改为`Id 21中的John`等。这些事件立即发送到所有依赖的有界上下文，而在故障和/或添加新查询的情况下，我们只需重新处理其中的一些事件。如果事件是幂等的，即多次处理相同的事件与处理一次具有相同的效果，那么事件重新处理不会引起问题。
- en: As discussed in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, idempotency is a standard requirement for microservices that communicate
    through events.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在*第5章* *将微服务架构应用于企业应用程序*中讨论的那样，幂等性是通过事件通信的微服务的标准要求。
- en: While all of the techniques we've described up until now can be used in every
    type of project if minor modifications are made, event sourcing requires a deep
    analysis to be performed before it can be adopted since, in several cases, it
    may create bigger problems than the ones it can solve. To get an idea of the problems
    it may cause when it's misused, imagine that we apply it to purchase orders that
    have been modified and validated by several users before being approved. Since
    purchase orders need to be retrieved before they're updated/validated, the purchase
    order's Bounded Context isn't used just as a source of truth, so event sourcing
    should not be applied to it. If this isn't the case, then we can apply event sourcing
    to it, in which case our code would be forced to rebuild the whole order from
    the recorded events each time the order is updated.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们到目前为止描述的所有技术都可以在每种类型的项目中使用，只要进行一些小的修改，但事件溯源需要进行深入分析才能被采用，因为在几种情况下，它可能会带来比它能解决的问题更大的问题。要了解它被滥用时可能引起的问题，可以想象我们将其应用于已被多个用户修改和验证后才被批准的采购订单。由于需要在更新/验证之前检索采购订单，采购订单的有界上下文不仅仅用作真相的来源，因此不应将事件溯源应用于它。如果不是这种情况，那么我们可以将事件溯源应用于它，在这种情况下，我们的代码将被迫每次更新订单时从记录的事件中重建整个订单。
- en: An example of its usage is the revenue logging system we described at the end
    of *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise Application*.
    Single revenues are recorded with event sourcing and then sent to the microservice
    we described in *Chapter 5*, *Applying a Microservice Architecture to Your Enterprise
    Application*, which, in turn, uses them to preprocess future queries, that is,
    to compute daily revenues.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*第5章* *将微服务架构应用于企业应用程序*的结尾描述了其使用示例是收入记录系统。单个收入使用事件溯源记录，然后发送到我们在*第5章* *将微服务架构应用于企业应用程序*中描述的微服���，该微服务又用于预处理未来的查询，即计算每日收入。
- en: In the next section, we will learn how DDD can be applied to define the Bounded
    Contexts of this book's WWTravelClub use case. A complete example of how to implement
    a Bounded Context that uses most of the patterns and code described in this book
    can be found in the *Use case – implementing a web app in ASP.NET Core MVC* section
    of *Chapter 15*, *Presenting ASP.NET Core MVC*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何应用DDD来定义本书WWTravelClub用例的有界上下文。本书中描述的大部分模式和代码的有界上下文的完整示例可以在*第15章*
    *介绍ASP.NET Core MVC*的*用例-在ASP.NET Core MVC中实现Web应用程序*部分找到。
- en: Use case – understanding the domains of the use case
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用例-理解用例的领域
- en: 'From the requirements listed in the *Case study – introducing World Wild Travel
    Club* section of *Chapter 1*, *Understanding the Importance of Software Architecture*,
    and for the analysis in the *Use case – storing data* section of *Chapter 9*,
    *How to Choose Your Data Storage in the Cloud*, we know that the WWTravelClub
    system is composed of the following parts:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 根据*第1章* *理解软件架构的重要性*中列出的要求以及*第9章* *如何在云中选择数据存储*中的*用例-存储数据*部分的分析，我们知道WWTravelClub系统由以下部分组成：
- en: Information about the available destinations and packages. We implemented the
    first prototype of this subsystem's data layer in *Chapter 9*, *How to Choose
    Your Data Storage in the Cloud*.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关可用目的地和套餐的信息。我们在*第9章* *如何在云中选择数据存储*中实现了该子系统数据层的第一个原型。
- en: Reservation/purchase orders subsystem.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预订/购买订单子系统。
- en: Communication with the experts/reviews subsystem.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与专家/评论子系统的通信。
- en: Payment subsystem. We briefly analyzed the features of this subsystem and its
    relationship with the reservation purchase subsystem at the beginning of the *Understanding
    domain-driven design* section of this chapter.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支付子系统。我们在本章的*理解领域驱动设计*部分开始时简要分析了该子系统的特性以及与预订购买子系统的关系。
- en: User accounts subsystem.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户帐户子系统。
- en: Statistics reporting subsystem.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 统计报告子系统。
- en: 'Do the preceding subsystems represent different **Bounded Contexts**? Can some
    subsystems be split into different Bounded Contexts? The answers to these questions
    are given by the languages that are spoken in each subsystem:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述子系统代表不同的**有界上下文**吗？一些子系统可以分成不同的有界上下文吗？这些问题的答案取决于每个子系统使用的语言。
- en: The language that's spoken in subsystem 1 is the language of **travel agencies**.
    There is no concept of a customer; just of locations, packages, and their features.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统1中使用的语言是**旅行社**的语言。没有客户的概念，只有位置、套餐及其特点。
- en: The language that's spoken in subsystem 2 is common to all service purchases,
    such as the available resources, reservations, and purchase orders. This is a
    separate Bounded Context.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统2中使用的语言适用于所有服务购买，如可用资源、预订和购买订单。这是一个独立的有界上下文。
- en: 'The language that''s spoken in subsystem 3 has a lot in common with subsystem
    1''s language. However, there are also typical **social media** concepts, such
    as ratings, chats, post sharing, media sharing, and so on. This subsystem can
    be split into two parts: a social media subsystem that has a new bounded context
    and an available information subsystem that is part of the Bounded Context of
    subsystem 1.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统3中使用的语言与子系统1的语言有很多共同之处。然而，也有典型的**社交媒体**概念，如评分、聊天、帖子分享、媒体分享等。该子系统可以分为两部分：一个具有新有界上下文的社交媒体子系统和一个属于子系统1有界上下文的可用信息子系统。
- en: As we pointed out in the *Understanding domain-driven design* section, in subsystem
    4, we speak the language of **banking**. This subsystem communicates with the
    reservation purchase subsystem and executes tasks that are needed to carry out
    a purchase. From these observations, we can see that it is a different Bounded
    Context and has a customer/supplier relationship with the purchase/reservation
    system.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在*理解领域驱动设计*部分中指出的，子系统4中我们使用**银行**的语言。该子系统与预订购买子系统通信，并执行执行购买所需的任务。从这些观察中，我们可以看到它是一个不同的有界上下文，并且与购买/预订系统有客户/供应商关系。
- en: Subsystem 5 is definitely a separate Bounded Context (as in almost all web applications).
    It has a relationship with all the Bounded Contexts that either have a concept
    of a user or a concept of a customer because the concept of user accounts always
    maps to these concepts. But how? Simple—the currently logged-in user is assumed
    to be the social media user of the social media Bounded Context, the customer
    of the reservation/purchase Bounded Context, and the payer of the payment Bounded
    Context.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子系统5绝对是一个独立的有界上下文（几乎所有Web应用程序都是如此）。它与所有具有用户概念或客户概念的有界上下文都有关系，因为用户账户的概念总是映射到这些概念。但是如何呢？简单——当前登录的用户被假定为社交媒体有界上下文的社交媒体用户，预订/购买有界上下文的客户，以及支付有界上下文的付款人。
- en: The query-only subsystem, that is, 6, speaks the language of analytics and statistics
    and differs a lot from the languages that are spoken in the other subsystems.
    However, it has a connection with almost all the Bounded Contexts since it takes
    all its input from them. The preceding constraints force us to adopt CQRS in its
    strong form, thereby considering it a query-only separated Bounded Context. We
    implemented a part of it in *Chapter 5*, *Applying a Microservice Architecture
    to Your Enterprise Application*, by using a microservice that conforms to a strong
    form of CQRS.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅查询子系统，即6，使用分析和统计的语言，与其他子系统使用的语言有很大不同。然而，它与几乎所有有界上下文都有连接，因为它的所有输入都来自它们。前面的约束迫使我们采用CQRS的强形式，因此将其视为一个仅查询的独立有界上下文。我们在*第5章*
    *将微服务架构应用于企业应用程序*中实现了部分内容，使用了符合CQRS强形式的微服务。
- en: In conclusion, each of the listed subsystems defines a different Bounded Context,
    but part of the communication with the experts/reviews subsystem must be included
    in the information about available destinations and packages Bounded Context.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，列出的每个子系统都定义了一个不同的有界上下文，但必须将与专家/评论子系统的通信部分包含在可用目的地和套餐有界上下文的信息中。
- en: As the analysis continues and a prototype is implemented, some Bounded Contexts
    may split and some others may be added, but it is fundamental to immediately start
    modeling the system and to immediately start analyzing the relations among the
    Bounded Contexts with the partial information we have since this will drive further
    investigations and will help us define the communication protocols and Ubiquitous
    Languages that are needed so that we can interact with the domain experts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 随着分析的继续和原型的实施，一些有界上下文可能会分裂，而其他一些可能会被添加，但是立即开始对系统进行建模，并立即开始分析有界上下文之间的关系是至关重要的，因为这将推动进一步的调查，并帮助我们定义所需的通信协议和普遍语言，以便我们可以与领域专家进行交互。
- en: 'The following is a basic first sketch of the domain map:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是领域地图的基本初步草图：
- en: '![](img/B16756_12_06.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B16756_12_06.png)'
- en: 'Figure 12.6: WWTravelClub domain map'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：WWTravelClub领域地图
- en: For simplicity, we've omitted the **Statistics reporting** Bounded Context.
    Here, we're assuming that the **User accounts** and **Social** Bounded Contexts
    have a **conformist** relationship with all the other Bounded Contexts that communicate
    with them because they are implemented with already existing software, so all
    the other components must adapt to them.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为简单起见，我们省略了**统计报告**有界上下文。在这里，我们假设**用户账户**和**社交**有界上下文与所有与它们通信的其他有界上下文具有**顺从**关系，因为它们是使用已经存在的软件实现的，所以所有其他组件必须适应它们。
- en: As we mentioned previously, the relationship between **Reservation** and **Payments**
    is **customer/supplier** because **Payments** provides services that are used
    to execute the tasks of **Reservation**. All the other relationships are classified
    as **Partners**. The various concepts of customer/user that most Bounded Contexts
    have are coordinated by the **User accounts** authorization token, which indirectly
    takes care of mapping these concepts between all the Bounded Contexts.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，**预订**和**支付**之间的关系是**客户/供应商**，因为**支付**提供用于执行**预订**任务的服务。所有其他关系都被归类为**合作伙伴**。大多数有界上下文具有的各种客户/用户概念由**用户账户**授权令牌协调，间接地负责在所有有界上下文之间映射这些概念。
- en: The **Packages/locations** subsystem not only communicates the packages information
    that's needed to carry out a reservation/purchase—it also takes care of informing
    pending purchase orders of possible price changes. Finally, we can see that social
    interactions are started from an existing review or location, thereby creating
    communication with the **Packages/locations** Bounded Context.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**Packages/locations**子系统不仅传达了执行预订/购买所需的包裹信息，还负责通知待处理的购买订单可能的价格变化。最后，我们可以看到社交互动是从现有的评论或位置开始的，从而与**Packages/locations**
    Bounded Context进行通信。'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the main reasons for the adoption of DDD and why
    and how it meets the needs of the market. We described how to identify domains
    and how to coordinate the teams that work on different domains of the same application
    with domain maps. Then, we analyzed the way DDD represents data with entities,
    value objects, and aggregates, providing advice and code snippets so that we can
    implement them in practice.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了采用DDD的主要原因，以及它为什么以及如何满足市场需求。我们描述了如何识别领域以及如何协调在同一应用程序的不同领域上工作的团队与领域映射。然后，我们分析了DDD如何用实体、值对象和聚合表示数据，并提供建议和代码片段，以便我们可以在实践中实现它们。
- en: We also covered some typical patterns that are used with DDD, that is, the repository
    and Unit of Work patterns, domain event patterns, CQRS, and event sourcing. Then,
    we learned how to implement them in practice. We also showed you how to implement
    domain events and the command pattern with decoupled handling so that we can add
    code snippets to real-world projects.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了一些与DDD一起使用的典型模式，即仓库和工作单元模式、领域事件模式、CQRS和事件溯源。然后，我们学习了如何在实践中实现它们。我们还向您展示了如何实现领域事件和命令模式，以及解耦处理，以便我们可以将代码片段添加到实际项目中。
- en: Finally, we used the principles of DDD in practice to define domains and to
    create the first sketch of a domain map for this book's WWTravelClub use case.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在实践中使用DDD原则来定义领域，并为本书的WWTravelClub用例创建了第一个领域映射的草图。
- en: In the next chapter, you will learn how to maximize code reuse in your projects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何在项目中最大程度地重用代码。
- en: Questions
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What provides the main hints so that we can discover domain boundaries?
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是什么提供了主要提示，以便我们可以发现领域边界？
- en: What is the main tool that's used for coordinating the development of a separate
    Bounded Context?
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于协调单独Bounded Context开发的主要工具是什么？
- en: Is it true that each entry that composes an aggregate communicates with the
    remainder of the system with its own methods?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个组成聚合的条目是否都通过自己的方法与系统的其余部分进行通信？
- en: Why is there a single aggregate root?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么只有一个聚合根？
- en: How many repositories can manage an aggregate?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有多少个仓库可以管理一个聚合？
- en: How does a repository interact with the application layer?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仓库如何与应用层交互？
- en: Why is the Unit of Work pattern needed?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么需要工作单元模式？
- en: What are the reasons for the light form of CQRS? What about the reasons for
    its strongest form?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 轻量级CQRS的原因是什么？最强形式的原因呢？
- en: What is the main tool that allows us to couple commands/domain events with their
    handlers?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许我们将命令/领域事件与其处理程序耦合的主要工具是什么？
- en: Is it true that event sourcing can be used to implement any Bounded Context?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件溯源是否可以用于实现任何Bounded Context？
- en: Further reading
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'More resources on DDD can be found here: [https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关DDD的更多资源可以在这里找到：[https://domainlanguage.com/ddd/](https://domainlanguage.com/ddd/)
- en: 'A detailed discussion of CQRS design principles can be found here: [http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关CQRS设计原则的详细讨论可以在这里找到：[http://udidahan.com/2009/12/09/clarified-cqrs/](http://udidahan.com/2009/12/09/clarified-cqrs/)
- en: 'More information on MediatR can be found on MediatR''s GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关MediatR的更多信息可以在MediatR的GitHub仓库中找到：[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
- en: 'A good description of event sourcing, along with an example of it, can be seen
    in the following blog post by Martin Fowler: [https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·福勒在以下博客文章中对事件溯源进行了很好的描述，并提供了一个示例：[https://martinfowler.com/eaaDev/EventSourcing.html](https://martinfowler.com/eaaDev/EventSourcing.html)
