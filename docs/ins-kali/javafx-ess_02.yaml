- en: Chapter 2. JavaFX 8 Essentials and Creating a Custom UI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。JavaFX 8基础知识和创建自定义UI
- en: Getting to know the essentials of JavaFX will definitely help you to easily
    build complicated and complex UI solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 了解JavaFX的基本知识肯定会帮助您轻松构建复杂的UI解决方案。
- en: In this chapter, you will get a brief introduction about JavaFX 8 architecture,
    so you get an idea of how JavaFX architecture components and engines interconnect
    together with your JavaFX application efficiently and render its graphics smoothly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将简要介绍JavaFX 8架构，以便了解JavaFX架构组件和引擎如何有效地相互连接，并使其图形平滑地渲染。
- en: You will learn how to render graphics on the JavaFX scene and, for that, we
    will create a basic application using a scene, some controls, and styling.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将学习如何在JavaFX场景上呈现图形，并为此创建一个使用场景、一些控件和样式的基本应用程序。
- en: We will touch upon the fundamentals of Java SE 8 features (such as **Lambda**
    and **functional interfaces**) to help increase code readability, quality, and
    productivity.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涉及Java SE 8功能的基础知识（如**Lambda**和**函数接口**），以帮助提高代码的可读性、质量和生产力。
- en: Once we have our first structured JavaFX 8 application, wouldn't it be nice
    if you could change the UI of your application without altering its functionality?
    You will learn about theming by having a glance at the fundamentals of JavaFX
    CSS styling.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了第一个结构良好的JavaFX 8应用程序，如果您可以在不改变其功能的情况下更改应用程序的UI，那不是很好吗？您将通过查看JavaFX CSS样式的基础知识来了解主题。
- en: Finally, you will find out how to use Scene Builder to create and define UI
    screens graphically and save them as a JavaFX FXML-formatted file. And you will
    get hands-on experience of creating *custom controls*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将了解如何使用Scene Builder以图形方式创建和定义UI屏幕，并将其保存为JavaFX FXML格式的文件。您还将亲身体验创建*自定义控件*。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding JavaFX architecture components
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解JavaFX架构组件
- en: Using JavaFX components to set up the UI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JavaFX组件设置UI
- en: Using Java SE 8, Lambda expressions, and other features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java SE 8，Lambda表达式和其他功能
- en: Theming your application to target different platforms
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同平台定制应用程序的主题
- en: Customizing the application UI with CSS
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CSS自定义应用程序UI
- en: Using the Scene Builder tool to create the UI visually
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Scene Builder工具以可视化方式创建UI
- en: Building a custom UI with FXML
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FXML构建自定义UI
- en: Quick review of the JavaFX 8 architecture
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaFX 8架构的快速回顾
- en: To better understand how the framework's components and engines interact together
    to run your JavaFX application, this section gives a high-level description of
    the JavaFX architecture and ecosystem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解框架的组件和引擎如何相互交互以运行您的JavaFX应用程序，本节对JavaFX架构和生态系统进行了高层次描述。
- en: The following figure illustrates the JavaFX platform's architectural components.
    It displays each component and how each of them interconnects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示了JavaFX平台的架构组件。它显示了每个组件以及它们如何相互连接。
- en: The engine that is responsible for running your JavaFX application code lies
    below the JavaFX public APIs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 负责运行JavaFX应用程序代码的引擎位于JavaFX公共API的下方。
- en: This engine is composed of subcomponents. These include **Prism**, a JavaFX
    high-performance graphics engine; the Glass toolkit, a small and efficient windowing
    system; a media engine; and a web engine.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此引擎由子组件组成。这些包括**Prism**，一个JavaFX高性能图形引擎；Glass工具包，一个小巧高效的窗口系统；媒体引擎；和Web引擎。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While these components are not exposed through public APIs, we will describe
    them so you have a better idea of what makes JavaFX applications run successfully
    in an efficient way.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些组件没有通过公共API公开，但我们将对它们进行描述，以便您更好地了解是什么使JavaFX应用以高效的方式成功运行。
- en: '![Quick review of the JavaFX 8 architecture](img/B03998_02_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![JavaFX 8架构的快速回顾](img/B03998_02_01.jpg)'
- en: JavaFX architecture diagram
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX架构图
- en: For more information and a description of the JavaFX architecture and ecosystem,
    visit [http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaFX架构和生态系统的更多信息，请访问[http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm](http://docs.oracle.com/javase/8/javafx/get-started-tutorial/jfx-architecture.htm)。
- en: Scene graphs
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景图
- en: Every application has a starting root point to construct a UI hierarchy, and
    the starting point for JavaFX applications is the *scene graph*. In the preceding
    screenshot, it is shown as part of the top layer in blue. It is the root tree
    of nodes that represents all of the visual elements of the application's user
    interface. It also tracks and handles any user input and can be rendered, as it
    is itself a UI node.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有一个起始根点来构建UI层次结构，而JavaFX应用程序的起始点是*场景图*。在前面的屏幕截图中，它显示为蓝色的顶层的一部分。它是表示应用程序用户界面的所有视觉元素的根节点树。它还跟踪和处理任何用户输入，并且可以被渲染，因为它本身是一个UI节点。
- en: '*Node* is any single element in the scene graph tree. Each node has these properties
    by default – an ID for identification, a list of style classes for changing its
    visual properties, and a bounding volume to fit correctly on the scene with other
    components and inside its parent layout container node, with the exception of
    the root node of a scene graph.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node*是场景图树中的任何单个元素。每个节点默认具有这些属性 - 用于标识的ID，用于更改其视觉属性的样式类列表，以及用于正确适应场景并放置在其父布局容器节点内的边界体积，除了场景图的根节点。'
- en: 'Each node in a scene graph tree has a single parent but could have zero or
    more children; however, the scene root has no parent (is null). Moreover, JavaFX
    has a mechanism to ensure a node could have only a single parent; it can also
    have the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 场景图树中的每个节点都有一个父节点，但可以有零个或多个子节点；但是，场景根节点没有父节点（为空）。此外，JavaFX具有一种机制，以确保节点只能有一个父节点；它还可以具有以下内容：
- en: Visual effects, such as blurs and shadows
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视觉效果，如模糊和阴影
- en: Controlling components transparency via opacity
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过不透明度控制组件的透明度
- en: CPU-accelerated 2D transforms, transitions, and rotations
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU加速的2D变换、过渡和旋转
- en: 3D transforms such as transitions, scaling, and rotations
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D变换，如过渡、缩放和旋转
- en: Event handlers (such as mouse events, key events, or other input methods such
    as touch events)
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理程序（如鼠标事件、键盘事件或其他输入方法，如触摸事件）
- en: An application-specific state
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序特定状态
- en: 'The following figure shows the relationship between the stage, scene, UI nodes,
    and graphical tree:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了舞台、场景、UI节点和图形树之间的关系：
- en: '![Scene graphs](img/B03998_02_02.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![场景图](img/B03998_02_02.jpg)'
- en: JavaFX UI tree hierarchy relationship
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX UI树层次关系
- en: The graphics primitives also are an integral part of the JavaFX scene graph,
    such as lines, rectangles, and text in addition to images, media, UI controls,
    and layout containers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图形原语也是JavaFX场景图的一个组成部分，如线条、矩形和文本，以及图像、媒体、UI控件和布局容器。
- en: When it comes to delivering complex and rich UIs for customers, scene graphs
    simplify this task. Also, you can use the `javafx.animation` APIs to quickly and
    easily animate various graphics in the scene graph.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及为客户提供复杂和丰富的UI时，场景图简化了这项任务。此外，您可以使用`javafx.animation` API快速轻松地为场景图中的各种图形添加动画。
- en: 'In addition to these features, the `javafx.scene` API allows the creation and
    specification of several content types as the following:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些功能外，`javafx.scene` API还允许创建和指定几种内容类型，如下所示：
- en: '**Nodes**: Any node element represented as UI controls, charts, groups, containers,
    embedded web browser, shapes (2-D and 3-D), images, media, and text'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节点**：表示为UI控件、图表、组、容器、嵌入式Web浏览器、形状（2D和3D）、图像、媒体和文本的任何节点元素'
- en: '**Effects**: These are simple objects that, when applied to a UI node, change
    its appearance on the scene graph node, such as blurs, shadows, and color adjustment'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效果**：这些是简单的对象，当应用于UI节点时，会改变其在场景图节点上的外观，如模糊、阴影和颜色调整'
- en: '**State**: Any application-specific state such as transforms (positioning and
    orientation of nodes) and visual effects'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态**：任何特定于应用程序的状态，如变换（节点的位置和方向）和视觉效果'
- en: Java public APIs for JavaFX features
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaFX功能的Java公共API
- en: This is your Swiss-knife toolkit provided as a complete set of Java public APIs
    that support rich client application development.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是作为一套完整的Java公共API的瑞士军刀工具包，支持丰富的客户端应用程序开发。
- en: These APIs provide you with unprecedented flexibility to construct your rich
    client UI applications by combining the best capabilities of the Java SE platform
    with comprehensive, immersive media functionality into an intuitive and comprehensive
    one-stop development environment at hand.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API为您提供了前所未有的灵活性，通过将Java SE平台的最佳功能与全面的沉浸式媒体功能相结合，构建直观而全面的一站式开发环境，用于构建丰富的客户端UI应用程序。
- en: 'These Java APIs for JavaFX allow you to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些JavaFX的Java API允许您执行以下操作：
- en: Use the powerful features of Java SE, from generics, annotations, and multithreading,
    to new Lambda Expressions (introduced in Java SE 8).
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用Java SE的强大功能，从泛型、注解和多线程到新的Lambda表达式（Java SE 8中引入）。
- en: Provides an easier way for web developers to use JavaFX from other JVM-based
    dynamic languages, such as *JavaScript*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为Web开发人员提供了一种更简单的方式，可以从其他基于JVM的动态语言（如*JavaScript*）中使用JavaFX。
- en: Writing large and complex JavaFX applications by integrating other system languages,
    such as *Groovy*.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过集成其他系统语言（如*Groovy*）编写大型复杂的JavaFX应用程序。
- en: Binding your UI controls to your controller attributes for automatic notifications
    and updates to be reflected from your model to bound UI nodes. Binding includes
    support for high-performance lazy binding, binding expressions, bound sequence
    expressions, and partial bind reevaluation. We will see this in action and more
    in [Chapter 3](ch03.html "Chapter 3. Developing a JavaFX Desktop and Web Application"),
    *Developing a JavaFX Desktop and Web Application*.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将UI控件绑定到控制器属性，以便从模型到绑定的UI节点自动通知和更新。绑定包括对高性能延迟绑定、绑定表达式、绑定序列表达式和部分绑定重新评估的支持。我们将在[第3章](ch03.html
    "第3章。开发JavaFX桌面和Web应用程序")中看到这一点以及更多内容，*开发JavaFX桌面和Web应用程序*。
- en: Introducing observable lists and maps, which allow applications to wire UIs
    to data models to observe the changes in those data models and update the corresponding
    UI control accordingly by extending the Java collections library.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入可观察列表和映射，允许应用程序将UI连接到数据模型，观察这些数据模型的变化，并相应地更新相应的UI控件，通过扩展Java集合库。
- en: Graphics System
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形系统
- en: The JavaFX Graphics System, shown in Purple in the preceding figure, supports
    both 2D and 3D scene graphs to run smoothly on the JavaFX scene graph layer. As
    it is the implementation detail beneath this layer, it provides the rendering
    software stack when running on a system that doesn't have sufficient graphics
    hardware to support hardware-accelerated rendering.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX图形系统，如前图中的紫色所示，支持在JavaFX场景图层上平稳运行的2D和3D场景图。作为该层下面的实现细节，它在运行在没有足够图形硬件支持硬件加速渲染的系统时，提供了渲染软件堆栈。
- en: 'The JavaFX platform has two graphics-accelerated pipelines that implement:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX平台有两个实现图形加速管道：
- en: '**Prism**: This is the engine that processes all render jobs. It can run on
    both hardware and software renderers, including 3D. Rasterization and rendering
    of JavaFX scenes are taken care of by this engine. Based on the device being used,
    the following multiple render paths are possible:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prism**：这是处理所有渲染作业的引擎。它可以在硬件和软件渲染器上运行，包括3D。JavaFX场景的光栅化和渲染由此引擎处理。根据使用的设备，可能存在以下多个渲染路径：'
- en: DirectX 9 on Windows XP and Vista, and DirectX 11 on Windows 7
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DirectX 9在Windows XP和Vista上，DirectX 11在Windows 7上
- en: OpenGL on Linux, Mac, and Embedded
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenGL在Linux、Mac和嵌入式系统上
- en: Software rendering when hardware acceleration is not possible
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法进行硬件加速时进行软件渲染。
- en: '**Quantum Toolkit**: This is responsible for linking the Prism engine and Glass
    Windowing Toolkit together to make them available to the JavaFX layer above them
    in the stack. This is in addition to managing any threading rules related to rendering
    versus event handling.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Quantum Toolkit**：这负责将Prism引擎和玻璃窗口工具包连接起来，使它们在堆栈中的JavaFX层中可用。这是除了管理与渲染与事件处理相关的任何线程规则。'
- en: Glass Windowing Toolkit
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玻璃窗口工具包
- en: The Glass Windowing Toolkit, shown in red in the middle portion of the preceding
    figure, serves as the platform-dependent layer that connects the JavaFX platform
    to the native operating system.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图中间部分所示，玻璃窗口工具包作为连接JavaFX平台与本机操作系统的平台相关层。
- en: As its main responsibility is to provide native operating services, such as
    managing the timers, windows, and surfaces, its position in the rendering stack
    is the lowest.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其主要责任是提供本机操作服务，例如管理定时器、窗口和表面，因此它在渲染堆栈中的位置最低。
- en: JavaFX threads
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaFX线程
- en: 'Normally, the system runs two or more of the following threads at any given
    time:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，系统在任何给定时间运行两个或更多以下线程：
- en: '**JavaFX application thread**: This is the main and primary thread used by
    the JavaFX application to run.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JavaFX应用程序线程**：这是JavaFX应用程序使用的主要线程。'
- en: '**Prism render thread**: This handles rendering separately from the event dispatcher.
    It renders frame N while frame N +1 is being prepared to process next. Its big
    advantage is the ability to perform concurrent processing, especially on modern
    systems that have multiple processors.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Prism渲染线程**：这将渲染与事件分发器分开处理。它在准备处理下一个N + 1帧时渲染N帧。它的最大优势是能够执行并发处理，特别是在具有多个处理器的现代系统上。'
- en: '**Media thread**: This runs in the background and synchronizes the latest frames
    through the scene graph by using the JavaFX application thread.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**媒体线程**：这在后台运行，并通过JavaFX应用程序线程通过场景图同步最新帧。'
- en: '**Pulse**: This enables you to have a way to handle events asynchronously.
    It helps you manage synchronization between the JavaFX scene graph elements state
    and an event of the scene graph with the Prism engine. When it is fired, the state
    of the elements on the scene graph is synchronized to the rendering layer.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pulse**：这使您能够以异步方式处理事件。它帮助您管理JavaFX场景图元素状态与Prism引擎场景图元素事件之间的同步。当它被触发时，场景图上元素的状态将与渲染层同步。'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any Layout nodes and CSS are also tied to pulse events.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何布局节点和CSS也与脉冲事件相关联。
- en: The *Glass Windowing Toolkit* executes all pulse events using high-resolution
    native timers to make the execution.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 玻璃窗口工具包使用高分辨率本机定时器执行所有脉冲事件。
- en: Media and images
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 媒体和图像
- en: The JavaFX `javafx.scene.media` APIs provide media functionality. JavaFX supports
    both visual and audio media. For audio files, it supports `MP3`, `AIFF`, and `WAV`
    files and `FLV` video files.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX `javafx.scene.media` API提供媒体功能。JavaFX支持视觉和音频媒体。对于音频文件，它支持`MP3`、`AIFF`和`WAV`文件以及`FLV`视频文件。
- en: You can access your media functionalities through three main separate components
    provided by JavaFX media – the `Media` object represents a media file, `MediaPlayer`
    plays a media file, and `MediaView` is a node that displays the media into your
    scene graph.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过JavaFX媒体提供的三个主要独立组件访问媒体功能-`Media`对象表示媒体文件，`MediaPlayer`播放媒体文件，`MediaView`是一个将媒体显示到您的场景图中的节点。
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Media Engine component, shown in orange in the preceding figure, has been
    designed carefully with stability and performance in mind to provide a consistent
    behavior across all supported platforms.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体引擎组件，如上图中橙色所示，经过精心设计，以稳定性和性能为考量，以在所有支持的平台上提供一致的行为。
- en: Web component
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web组件
- en: The web engine component, shown in green in the preceding figure, is one of
    the most important JavaFX UI controls and is built based on the WebKit engine,
    which is an open source web browser engine that supports HTML5, JavaScript, CSS,
    DOM rendering, and SVG graphics. It provides a web viewer and full browsing functionality
    through its API. We will dive deep into this in [Chapter 3](ch03.html "Chapter 3. Developing
    a JavaFX Desktop and Web Application"), *Developing a JavaFX Desktop and Web Application*,
    when developing web applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如上图中绿色所示，Web引擎组件是最重要的JavaFX UI控件之一，它基于WebKit引擎构建，这是一个支持HTML5、JavaScript、CSS、DOM渲染和SVG图形的开源Web浏览器引擎。它通过其API提供Web查看器和完整的浏览功能。在[第3章](ch03.html
    "第3章。开发JavaFX桌面和Web应用程序")中，*开发JavaFX桌面和Web应用程序*，我们将深入研究这一点，当开发Web应用程序时。
- en: 'It allows you to add and implement the following features in your Java applications:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许您在Java应用程序中添加和实现以下功能：
- en: Render any HTML content from a local or remote URL
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从本地或远程URL渲染任何HTML内容
- en: Provide Back and Forward navigation, and support history
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供后退和前进导航，并支持历史
- en: Reload the content for any updates
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新加载任何更新的内容
- en: Animate and apply CSS effects to the web component
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对Web组件进行动画处理和应用CSS效果
- en: Provide rich editing control for HTML content
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为HTML内容提供丰富的编辑控件
- en: Can execute JavaScript commands and handle web control events
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以执行JavaScript命令并处理Web控件事件
- en: Layout components
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局组件
- en: When building a rich and complex UI, we need a way to allow for flexible and
    dynamic arrangements of the UI controls within the JavaFX application. This is
    the best place to use Layout containers or panes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建丰富和复杂的UI时，我们需要一种方式来允许在JavaFX应用程序中的UI控件内进行灵活和动态的排列。这是使用布局容器或窗格的最佳位置。
- en: 'The Layout API includes the following container classes that automate common
    layout UI patterns:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 布局API包括以下容器类，它们自动化常见的布局UI模式：
- en: '**BorderPane**: This lays out its content nodes in the top, bottom, right,
    left, or center region'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BorderPane**：这将其内容节点布局在顶部、底部、右侧、左侧或中心区域'
- en: '**HBox**: This arranges its content nodes horizontally in a single row'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HBox**：这将其内容节点水平排列在一行中'
- en: '**VBox**: This arranges its content nodes vertically in a single column'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VBox**：这将其内容节点垂直排列在单列中'
- en: '**StackPane**: This places its content nodes in a back-to-front single stack
    at the center of the pane'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StackPane**：这将其内容节点放置在面板中心的前后单一堆栈中'
- en: '**GridPane**: This enable the creation of a flexible grid of rows and columns
    in which to lay out content nodes'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GridPane**：这使得可以创建一个灵活的行和列网格，用于布置内容节点'
- en: '**FlowPane**: This arranges its content nodes in either a horizontal or vertical
    flow, wrapping at the specified width (for horizontal) or height (for vertical)
    boundaries'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FlowPane：这将其内容节点以水平或垂直流的方式排列，在指定的宽度（水平）或高度（垂直）边界处换行
- en: '**TilePane**: This places its content nodes in uniformly sized layout cells
    or tiles'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TilePane**：这将其内容节点放置在统一大小的布局单元或瓷砖中'
- en: '**AnchorPane**: This enables the creation of anchor nodes to the top, bottom,
    left-hand side, or center of the layout, and we can freely position its child
    nodes'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AnchorPane**：这使得可以将锚节点创建到布局的顶部、底部、左侧或中心，并且可以自由定位其子节点'
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Different containers can be nested within a JavaFX application; to achieve the
    desired layout structure, we will see this in action next when developing our
    Custom UI.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX应用程序中可以嵌套不同的容器；为了实现所需的布局结构，我们将在下一步中看到这一点，当开发我们的自定义UI时。
- en: JavaFX controls
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaFX控件
- en: JavaFX controls are the building blocks of your UI layout, and they reside in
    the `javafx.scene.control` package as a set of JavaFX APIs. They are built by
    using nodes in the scene graph. They can be themed and skinned by JavaFX CSS.
    They are portable *across different platforms*. They take full advantage of the
    visually rich features of the JavaFX platform.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX控件是UI布局的构建块，它们位于`javafx.scene.control`包中作为一组JavaFX API。它们是通过场景图中的节点构建的。它们可以通过JavaFX
    CSS进行主题和皮肤设置。它们可以在*不同平台*上进行移植。它们充分利用了JavaFX平台丰富的视觉特性。
- en: 'This figure shows some of the UI controls that are currently supported and
    there are more not shown here as well:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图显示了目前支持的一些UI控件，还有更多未显示的：
- en: '![JavaFX controls](img/B03998_02_03.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![JavaFX控件](img/B03998_02_03.jpg)'
- en: JavaFX UI controls sample
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX UI控件示例
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more detailed information about all the available JavaFX UI controls, see
    the official tutorial at [http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336](http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336)
    and the API documentation for the `javafx.scene.control` package.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有关所有可用的JavaFX UI控件的更详细信息，请参阅[http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336](http://docs.oracle.com/javase/8/javafx/user-interface-tutorial/ui_controls.htm#JFXUI336)的官方教程和`javafx.scene.control`包的API文档。
- en: Java SE 8 features
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java SE 8特性
- en: We will scratch the surface of Java SE 8 to understand two of the most important
    features – lambda or lambda expressions and functional interfaces, which make
    the lambdas available to us, to help write better, concise, and low-boilerplate
    JavaFX 8 code. However, keep in mind that we will not address every lambda detail
    in this book, as this is not a Java SE 8 book.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入了解Java SE 8的两个最重要的特性 - lambda或lambda表达式和功能接口，这使得lambda可用于我们，以帮助编写更好、更简洁、更低样板的JavaFX
    8代码。但是，请记住，本书不会涉及每一个lambda细节，因为这不是一本Java SE 8的书。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To get a better idea of Java''s lambda roadmap, visit the following official
    tutorial: [http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要更好地了解Java的lambda路线图，请访问以下官方教程：[http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html](http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)。
- en: Lambda expressions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: The primary goal of project **lambda** in the Java language is to address the
    lack of functional programming and provide a way to do functional programming
    easily by creating anonymous (unnamed) functions in a similar manner to creating
    anonymous objects instead of methods in Java.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Java语言项目**lambda**的主要目标是解决函数式编程的缺乏，并通过以类似于在Java中创建匿名对象而不是方法的方式轻松创建匿名（无名称）函数来提供一种轻松进行函数式编程的方法。
- en: 'As you saw in the example from [Chapter 1](ch01.html "Chapter 1. Getting Started
    with JavaFX 8"), *Getting Started with JavaFX 8*, we talked about the usual approach
    for defining a handler for the pressed event on a JavaFX button by using an anonymous
    inner class:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第1章](ch01.html "第1章。开始使用JavaFX 8")的示例中所看到的，*开始使用JavaFX 8*，我们讨论了在JavaFX按钮的按下事件上定义处理程序的常规方法，使用匿名内部类：
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This code is very verbose as compared to just wiring up a single line of code
    that sets the `text` attribute of the message text field in a button action. Wouldn't
    it be nice to be able to rewrite this block of code containing your logic without
    the need of so much boilerplate code?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 与在按钮动作中设置消息文本字段的`text`属性的单行代码相比，这段代码非常冗长。能否重写这个包含逻辑的代码块而不需要那么多样板代码？
- en: 'Java SE 8 solves this with a Lambda expressions as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Java SE 8通过Lambda表达式解决了这个问题：
- en: '[PRE1]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Beyond making your code more concise and easy to read, lambda expressions make
    your code perform better as well.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使您的代码更简洁和易于阅读外，Lambda表达式还使您的代码执行性能更好。
- en: Syntax
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 语法
- en: 'There are two ways to write lambda expressions, and the general form is as
    shown in the following figure:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种编写Lambda表达式的方式，一般形式如下图所示：
- en: '![Syntax](img/B03998_02_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![语法](img/B03998_02_04.jpg)'
- en: Lambda expression general form – creating a new thread as an example
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式的一般形式 - 以创建新线程为例
- en: 'These two ways are as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方式如下：
- en: '`(param1, param2, ...) -> expression;`'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(param1, param2, ...) -> expression;`'
- en: '`(param1, param2, ...) -> { /* code statements */ };`'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(param1, param2, ...) -> { /* code statements */ };`'
- en: The first form, the expression form, is used when we assign only one line of
    code or just a simple expression. While the second one, the block form, is a body
    of single or multiple lines of code, with a return statement, so we need to wrap
    them with curly braces.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种形式，表达式形式，用于当我们只分配一行代码或只是一个简单表达式时。而第二种形式，块形式，是单行或多行代码的主体，带有返回语句，因此我们需要用大括号包裹它们。
- en: 'The following three statements are equivalent:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下三个语句是等价的：
- en: '`btn.setOnAction((ActionEvent event) -> {message.setText("Hello World!");});`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn.setOnAction((ActionEvent event) -> {message.setText("Hello World!");});`'
- en: '`btn.setOnAction( (event) -> message.setText("Hello World!"));`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn.setOnAction( (event) -> message.setText("Hello World!"));`'
- en: '`btn.setOnAction(event -> message.setText("Hello World!"));`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`btn.setOnAction(event -> message.setText("Hello World!"));`'
- en: Tip
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'To dive deeper into the new lambda expressions and their related features alongside
    the Java SE 8 features, I encourage you to try this articles series – Java SE
    8 new features tour: [http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html](http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解新的lambda表达式及其相关特性以及Java SE 8特性，我鼓励您尝试这个系列文章 - Java SE 8新特性之旅：[http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html](http://tamanmohamed.blogspot.com/2014/06/java-se-8-new-features-tour-big-change.html)
- en: Functional interfaces
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数接口
- en: A lambda expression is fantastic, isn't it?, but you may be wondering what its
    exact type is, so it can be assigned to variables and passed to methods.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式很棒，不是吗？但是您可能想知道它的确切类型，以便将其分配给变量并传递给方法。
- en: The answer is in the power of functional interfaces. How? Functional interfaces,
    cleverly created by Java language designers/architects as closures, use the concept
    of **Single Abstract Method** (**SAM**), providing an interface with just one
    abstract method, and the `@FunctionalInterface` annotation. The single abstract
    method pattern is an integral part of Java SE 8's lambda expressions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 答案在于函数接口的强大。如何？函数接口是由Java语言设计师/架构师巧妙地创建为闭包，使用**单一抽象方法**（**SAM**）的概念，提供了一个只有一个抽象方法的接口，并使用`@FunctionalInterface`注解。单一抽象方法模式是Java
    SE 8的lambda表达式的一个重要部分。
- en: 'Let''s clear things up with an example to illustrate the concept of both functional
    interfaces and lambda expressions. I have created a functional interface called
    `Calculator.java` containing a single abstract method, `calculate()`. Once it
    is created, you can declare and assign variables to lambda expressions. The following
    is the functional interface:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来澄清函数接口和lambda表达式的概念。我创建了一个名为`Calculator.java`的函数接口，其中包含一个抽象方法`calculate()`。创建后，您可以声明并为lambda表达式分配变量。以下是函数接口：
- en: '[PRE2]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now we are ready to create variables and assign them lambda expressions. The
    following code creates and assigns lambda expressions to our functional interface
    variables:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备创建变量并为它们分配lambda表达式。以下代码创建并为我们的函数接口变量分配lambda表达式：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of the code should be as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出应该如下所示：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Theming
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主题
- en: When working with designers and UX/UI specialists, you will hear about skinning
    the application or changing its appearance. Both terms are often interchangeable,
    and both of them reflect the basic concept of *theming*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计师和UX/UI专家合作时，您会听到关于为应用程序设置皮肤或更改其外观的说法。这两个术语通常可以互换使用，它们都反映了*主题*的基本概念。
- en: The idea of theming is to change the entire application style by changing its
    control appearance and without altering its underlying functionality.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 主题的理念是通过改变控件的外观而不改变其基本功能来改变整个应用程序的样式。
- en: In JavaFX, you have the ability to create, modify, or use existing themes to
    skin your applications, scene, or even just a UI control.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaFX中，您可以创建、修改或使用现有的主题来为应用程序、场景甚至只是UI控件设置皮肤。
- en: CSS
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS
- en: JavaFX **Cascading Style Sheets** (**CSS**) can be applied to any node in the
    JavaFX scene graph; they are applied to the nodes asynchronously. Styles can also
    be easily assigned to the scene at runtime, allowing an application's appearance
    to change dynamically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX **级联样式表**（**CSS**）可以应用于JavaFX场景图中的任何节点；它们是异步应用于节点的。样式也可以在运行时轻松地分配给场景，从而允许应用程序的外观动态变化。
- en: It is based on the W3C CSS version 2.1 specifications, and is currently compatible
    with some additions from the current work on version 3\. The JavaFX CSS support
    and extensions have been designed to allow JavaFX CSS style sheets to be parsed
    cleanly by any compliant CSS parser. This enables the mixing of CSS styles for
    JavaFX and for other purposes (such as for HTML pages) into a single style sheet.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 它基于W3C CSS版本2.1规范，并且目前与版本3的当前工作中的一些附加功能兼容。JavaFX CSS支持和扩展已经被设计为允许任何兼容的CSS解析器干净地解析JavaFX
    CSS样式表。这使得可以将JavaFX和其他目的（如HTML页面）的CSS样式混合到单个样式表中。
- en: All JavaFX property names are prefixed with an extension of `-fx-`, including
    those that might looks compatible with standard HTML CSS, because some JavaFX
    values have slightly different semantics from standard ones.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有JavaFX属性名称都以`-fx-`为前缀，包括那些可能看起来与标准HTML CSS兼容的属性，因为一些JavaFX值与标准值的语义略有不同。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more about JavaFX CSS, see the Skinning JavaFX Applications with CSS document
    and the reference guide at [http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关JavaFX CSS的更多信息，请参阅使用CSS文档对JavaFX应用程序进行皮肤设置和[http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html](http://docs.oracle.com/javase/8/javafx/api/javafx/scene/doc-files/cssref.html)的参考指南。
- en: Applying CSS theme
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用CSS主题
- en: 'Here is a custom simple JavaFX CSS rule, `ButtonStyle.css`, that is to be used
    in our theming process to theme a button:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自定义的简单JavaFX CSS规则，`ButtonStyle.css`，它将用于我们的主题过程来为按钮设置主题：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have two ways to apply CSS style sheets to change the look-and-feel theming
    of our JavaFX applications:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种方法可以应用CSS样式表来改变我们的JavaFX应用程序的外观和主题：
- en: 'Using a JavaFX Application (`javafx.application.Application`) class static
    method `setUserAgentStylesheet(String URL)` method, which styles all the application
    hierarchy, including every scene and all child nodes in a JavaFX application.
    It is used as follows:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JavaFX应用程序（`javafx.application.Application`）类的静态方法`setUserAgentStylesheet(String
    URL)`方法，可以为JavaFX应用程序中的所有场景和所有子节点设置样式。使用方法如下：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now you can use JavaFX 8''s two style sheets that currently come preshipped,
    Caspian and Modena, and we can switch between them using the same method as shown
    here:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以使用JavaFX 8当前预装的两个样式表，Caspian和Modena，我们可以使用与此处相同的方法在它们之间切换：
- en: '[PRE7]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Tip
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are invoking `setUserAgentStylesheet(null)` by passing a null value,
    the default look and feel will be loaded (in this case, Modena) whereas, if you
    are using JavaFX 2.x Caspian, the default one will be loaded.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过传递空值来调用`setUserAgentStylesheet(null)`，则将加载默认的外观和感觉（在这种情况下为Modena），而如果您使用JavaFX
    2.x Caspian，则将加载默认的外观和感觉。
- en: 'Using scene''s `getStylesheets().add(String URL)` method will style the individual
    scene and its child node automatically as follows:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用场景的`getStylesheets().add(String URL)`方法将自动为个别场景及其子节点设置样式，如下所示：
- en: '[PRE8]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Basically, the default theme (Modena) will be loaded, as `Application.setUserAgentStylesheet(null)`
    is called. It then sets the scene's additional styling by invoking the `getStylesheets().add()`
    method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，将加载默认主题（Modena），因为调用了`Application.setUserAgentStylesheet(null)`。然后通过调用`getStylesheets().add()`方法设置场景的额外样式。
- en: Styles are first applied to the parent and then to its children. A node is styled
    after it is added to the scene graph, regardless of whether it's shown or not.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先应用样式到父级，然后应用到其子级。节点在添加到场景图后进行样式设置，无论它是否显示。
- en: The JavaFX CSS implementation applies the following order of precedence – a
    style from a user agent style sheet has lower priority than a value set from code,
    which has lower priority than a Scene or Parent style sheet.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX CSS实现应用以下优先顺序 - 用户代理样式表的样式优先级低于从代码设置的值，后者优先级低于场景或父级样式表。
- en: Inline styles have the highest precedence. Style sheets from a Parent instance
    are considered to be more specific than styles from Scene style sheets.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 内联样式具有最高优先级。来自父级实例的样式表被认为比场景样式表的样式更具体。
- en: Scene Builder
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Scene Builder
- en: For most complex and sophisticated UI requirements, wouldn't it be easier for
    designers to use a tool to design their UI with a WYSIWYG interface, without writing
    any code, and then load the result (`FXML` file) into their JavaFX application
    logic?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数复杂和复杂的UI需求，设计师使用工具在WYSIWYG界面中设计他们的UI，而无需编写任何代码，然后将结果（`FXML`文件）加载到他们的JavaFX应用程序逻辑中会更容易吗？
- en: Therefore, you need JavaFX Scene Builder; it is a visual layout tool that allows
    you to easily lay out your UI controls so that you can quickly prototype your
    application with effects and animations. Scene Builder (version 2.0 upwards) is
    the compatible version for JavaFX 8.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您需要JavaFX Scene Builder；它是一个可视化布局工具，可以让您轻松地布置UI控件，以便您可以快速地使用效果和动画原型化您的应用程序。Scene
    Builder（2.0及以上版本）是JavaFX 8的兼容版本。
- en: At any time during the creation of your project, you can preview your work to
    check its real appearance before deploying it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目创建过程中的任何时候，您都可以预览您的工作，以检查其真实外观，然后再部署它。
- en: It is open source and therefore it integrates with most IDEs, but more tightly
    with the NetBeans IDE. It is also a cross-platform, self-contained application
    that runs on most platforms.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 它是开源的，因此与大多数IDE集成，但与NetBeans IDE更紧密。它还是一个跨平台的、独立的应用程序，可以在大多数平台上运行。
- en: In addition to supporting CSS, it allows you to easily apply custom theming
    to your prototype.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持CSS，它还允许您轻松地将自定义主题应用于您的原型。
- en: Downloading and launching
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载和启动
- en: At the beginning of 2015, Oracle release JavaFX Scene Builder tool version 2.0,
    and announced that it will no longer be providing builds of the JavaFX Scene Builder
    tool (in compiled form).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 2015年初，Oracle发布了JavaFX Scene Builder工具2.0版本，并宣布将不再提供JavaFX Scene Builder工具的构建（已编译形式）。
- en: A company called **Gluon** ([http://gluonhq.com](http://gluonhq.com)) understands
    that tools can make or break a coding experience. So they have decided to begin
    providing builds, based on a fork they will maintain in a publicly accessible
    repository.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一家名为**Gluon**（[http://gluonhq.com](http://gluonhq.com)）的公司意识到工具可以改善或破坏编码体验。因此，他们决定开始提供基于他们将在公开可访问的存储库中维护的分支的构建。
- en: Gluon provides IDE plugins, as well as improved builds of the JavaFX Scene Builder
    tool based on the latest sources from OpenJFX, with additional improvements based
    on community involvement and a desire to better support third party projects such
    as **ControlsFX** ([http://www.controlsfx.org/](http://www.controlsfx.org/)),
    **FXyz** ([https://github.com/FXyz/FXyz](https://github.com/FXyz/FXyz)), and **DataFX**
    ([http://www.datafx.io/](http://www.datafx.io/)).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Gluon提供IDE插件，以及基于OpenJFX最新源代码的JavaFX Scene Builder工具的改进版本，还有基于社区参与和更好地支持第三方项目（如**ControlsFX**
    ([http://www.controlsfx.org/](http://www.controlsfx.org/))、**FXyz** ([https://github.com/FXyz/FXyz](https://github.com/FXyz/FXyz))和**DataFX**
    ([http://www.datafx.io/](http://www.datafx.io/))）的额外改进。
- en: To get started let's download the tool from the following URL [http://gluonhq.com/products/downloads/](http://gluonhq.com/products/downloads/).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下URL下载工具开始[http://gluonhq.com/products/downloads/](http://gluonhq.com/products/downloads/)。
- en: 'After downloading version 8.0 and installing it, launch it and the Scene Builder
    tool should open as in the following screenshot:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 下载版本8.0并安装后，启动它，Scene Builder工具应该如下截图所示打开：
- en: '![Downloading and launching](img/B03998_02_05.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![下载和启动](img/B03998_02_05.jpg)'
- en: The JavaFX 8 Scene Builder tool.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: JavaFX 8 Scene Builder工具。
- en: FXML
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FXML
- en: While adding components and building your beautiful UI layout, Scene Builder
    under the hood generates a FXML - and XML-based markup file for you automatically,
    which will be used later to be bind your UI to your Java application logic.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加组件和构建美丽的UI布局时，Scene Builder在幕后自动生成一个FXML - 基于XML的标记文件，以便稍后将其绑定到Java应用程序逻辑的UI。
- en: One of the main advantages FXML provide is separation of concerns, as it decouples
    UI layer (*view*) from logic (*Controller*); this means you can alter UI at anytime
    without changing underlying logic. Since the FXML file is not compiled, it can
    be dynamically loaded at runtime without any required compilation. This means
    it helps you with rapid prototyping.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: FXML提供的主要优势之一是关注点的分离，因为它将UI层（*视图*）与逻辑（*控制器*）解耦；这意味着您可以随时更改UI而不更改底层逻辑。由于FXML文件未经编译，因此可以在运行时动态加载，无需任何编译。这意味着它可以帮助您进行快速原型设计。
- en: Loading FXML into JavaFX applications
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将FXML加载到JavaFX应用程序中
- en: 'It is very easy task to add your UI design after generating it from the Scene
    Builder tool. Shown here is code to load an FXML file in a `start()` method:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从Scene Builder工具中导出结果后，很容易将UI设计添加到其中。这里展示了在`start()`方法中加载FXML文件的代码：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, I am using the static method load on the `javafx.fxml.FXMLLoaderclass`,
    The `load()` method will load (`deserialize`) the FXML file that was created by
    the Scene Builder tool.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我在`javafx.fxml.FXMLLoaderclass`上使用了`load()`静态方法，`load()`方法将加载（反序列化）由Scene
    Builder工具创建的FXML文件。
- en: Developing a custom UI
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发自定义UI
- en: For the final part of this chapter, we are going to develop a custom UI component
    based on JavaFX 8 built-in controls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将基于JavaFX 8内置控件开发自定义UI组件。
- en: We will develop this custom UI with concepts discussed before that are based
    on FXML; the primary advantage is the separation of concerns to customize the
    component later on without altering its functionality and any other logic bound
    to it.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前讨论过的基于FXML的概念来开发这个自定义UI；其主要优势是关注点的分离，以便稍后定制组件而不改变其功能和与其绑定的任何其他逻辑。
- en: The Login dialog custom UI
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录对话框自定义UI
- en: 'We will use most of the previously covered tools and techniques to develop
    our custom UI: the Login Dialog, which is a necessary component in every Enterprise
    application. Our UI component will be as shown in the following screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用大部分之前介绍的工具和技术来开发我们的自定义UI：登录对话框，这是每个企业应用程序中必不可少的组件。我们的UI组件将如下图所示：
- en: '![The Login dialog custom UI](img/B03998_02_06.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![登录对话框自定义UI](img/B03998_02_06.jpg)'
- en: Login custom UI component
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 登录自定义UI组件
- en: Structure of the Login dialog custom UI
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录对话框自定义UI的结构
- en: 'The most common structure and stages in custom component development based
    on FXML markup are these:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 基于FXML标记的自定义组件开发中最常见的结构和阶段如下：
- en: Develop the UI inside the Scene Builder tool; then export the result to the
    FXML-based file
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Scene Builder工具中开发UI；然后将结果导出为基于FXML的文件
- en: Extract the controller skeleton from the Scene builder
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Scene Builder中提取控制器骨架
- en: Create a controller that binds the UI (view) to its logic and extends either
    a control or a layout
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将UI（视图）绑定到其逻辑并扩展控件或布局的控制器
- en: Load the FXML file inside the Controller constructor
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Controller构造函数中加载FXML文件
- en: Create an initialization method that makes sure that all FXML controls are initialized
    and loaded successfully
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个初始化方法，确保所有FXML控件都被成功初始化和加载
- en: Expose public attributes to get and set control data and action methods that
    need our implementation logic
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开公共属性以获取和设置控件数据和需要我们实现逻辑的动作方法
- en: Develop a separate CSS file
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发一个单独的CSS文件
- en: Use the custom component inside your application
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中使用自定义组件
- en: Coding the Login dialog custom UI
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写登录对话框自定义UI
- en: 'Let''s code and develop our custom UI, the Login Dialog:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写和开发我们的自定义UI，登录对话框：
- en: Open the Scene Builder tool and create the UI. Its properties are as shown in
    the following figure:![Coding the Login dialog custom UI](img/B03998_02_07.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Scene Builder工具并创建UI。其属性如下图所示：![编写登录对话框自定义UI](img/B03998_02_07.jpg)
- en: The login dialog layout hierarchy will be as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_08.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录对话框布局层次结构如下所示：![编写登录对话框自定义UI](img/B03998_02_08.jpg)
- en: 'It consists of a Pane layout as the top and root layout node. Then, `GridPane(1,4)`
    is used to lay out the controls in a grid of one column and four rows using these:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它由一个Pane布局作为顶部和根布局节点组成。然后，使用`GridPane(1,4)`来以一列和四行的网格布局放置控件，包括：
- en: The **first** row contains the `HBox` layout control at location (`0,0`) to
    lay out the controls horizontally. It consists of the `ImageView` control to show
    the logo and Label for the title.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第一**行包含`HBox`布局控件，位置为(`0,0`)，用于水平放置控件。它包括用于显示标志的`ImageView`控件和用于标题的Label。'
- en: The **second** row lays out the username `TextField` for the username attribute,
    at location (`0,1`).
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第二**行放置了用于用户名属性的`TextField`，位置为(`0,1`)。'
- en: The **third** row lays out the password `PasswordField` for password attribute,
    at location (`0,2`).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三**行放置了用于密码属性的`PasswordField`，位置为(`0,2`)。'
- en: The **last** row, at location (`0,3`), has a root layout control `HBox`, and
    it lays out another HBox that contains the `CheckBox` and `Label` (for showing
    errors and other messages) controls aligned to the center-left. We then have two
    button controls, **Reset** and **Login**, which are aligned to the center-right.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最后**一行，位置为(`0,3`)，有一个根布局控件`HBox`，它放置了另一个`HBox`，其中包含居中左对齐的`CheckBox`和`Label`（用于显示错误和其他消息）。然后有两个按钮控件，**重置**和**登录**，它们位于中心右侧。'
- en: 'In the Code tab, add a proper **fx:id** name to all of the controls in the
    dialog, and a name to `onAction` for buttons and checkbox events as in the following
    screenshot:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码选项卡中，为对话框中的所有控件添加适当的**fx:id**名称，并为按钮和复选框事件添加`onAction`名称，如下图所示：
- en: '![Coding the Login dialog custom UI](img/B03998_02_09.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![编写登录对话框自定义UI](img/B03998_02_09.jpg)'
- en: Login button properties
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 登录按钮属性
- en: From the Scene Builder **Preview** menu, choose **Show preview in windows**.
    Your layout will pop up. If everything is okay and you are satisfied with the
    resulting design, from the menu bar, click on **File**, then **Save**, and enter
    the file name as `LoginUI.fxml`. Congratulations! You have created your first
    JavaFX UI layout.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Scene Builder的**预览**菜单中，选择**在窗口中显示预览**。您的布局将弹出。如果一切正常，并且您对结果设计满意，从菜单栏中单击**文件**，然后单击**保存**，并输入文件名为`LoginUI.fxml`。恭喜！您已经创建了您的第一个JavaFX
    UI布局。
- en: Now we will open NetBeans to set up a JavaFX FXML project, so launch NetBeans,
    and from the **File** menu, choose **New Project**.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将打开NetBeans来设置一个JavaFX FXML项目，因此启动NetBeans，并从**文件**菜单中选择**新建项目**。
- en: In the **JavaFX** category, choose **JavaFX FXML Application**. Click on **Next**.
    Then name the project **LoginControl**, change **FXML name** to `LoginUI`, and
    click on **Finish**.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**JavaFX**类别中，选择**JavaFX FXML应用程序**。单击**下一步**。然后将项目命名为**LoginControl**，将**FXML名称**更改为`LoginUI`，然后单击**完成**。
- en: Tip
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Make sure that the JavaFX platform is Java SE 8.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 确保JavaFX平台是Java SE 8。
- en: NetBeans will create a project structure as shown here:![Coding the Login dialog
    custom UI](img/B03998_02_10.jpg)
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NetBeans将创建如下的项目结构：![编码登录对话框自定义UI](img/B03998_02_10.jpg)
- en: Login Control NetBeans project structure.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 登录控制NetBeans项目结构。
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure to *clean and build* your project before running it, to avoid any
    problems you may face, especially when running your application and possibility
    loading the `*.fxml` file during runtime may return `null`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行项目之前，请确保*清理和构建*您的项目，以避免可能出现的任何问题，特别是在运行应用程序和可能在运行时加载`*.fxml`文件时可能返回`null`。
- en: Go to the Scene Builder tool and, from **View**, select **Show sample controller
    skeleton**. The window shown in the following screenshot will open, which we will
    copy to replace `LoginUIController.java` (this which extends the `Pane` class
    content code with the copied content in NetBeans) and then fix the missing imports.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到Scene Builder工具，并从**视图**中选择**显示示例控制器骨架**。将打开如下截图所示的窗口，我们将复制以替换`LoginUIController.java`（这将扩展`Pane`类内容代码与NetBeans中复制的内容）然后修复缺少的导入。
- en: Replace the previously generated and saved `LoginUI.fxml` file from Scene Builder
    with one already created by NetBeans.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用NetBeans已经创建的一个替换之前生成并保存的`LoginUI.fxml`文件。
- en: Right-click on the `LoginController.java` file, choose **Refactor**, then **Rename**,
    and rename it to `Main.java`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`LoginController.java`文件，选择**重构**，然后选择**重命名**，将其重命名为`Main.java`。
- en: 'Finally, add the following code in the `start(Stage stage)` method of `Main.java
    class` as shown here. We are creating a new instance of the login component as
    a root node of our scene and adding it to the stage:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Main.java类`的`start(Stage stage)`方法中添加以下代码，如下所示。我们正在创建登录组件的新实例作为我们场景的根节点，并将其添加到舞台上：
- en: '[PRE10]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![Coding the Login dialog custom UI](img/B03998_02_11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![编码登录对话框自定义UI](img/B03998_02_11.jpg)'
- en: 'In the `LoginUIController.java` class, right-click under the class name and
    choose **Insert Code**; then choose **Constructor** and finally add the following
    code inside the constructor:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LoginUIController.java`类中，在类名下右键单击选择**插入代码**；然后选择**构造函数**，最后在构造函数中添加以下代码：
- en: '[PRE11]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code loads our `LoginUI.fxml` document and returns it as the Pane layout
    with its hierarchy. It then binds it to the current controller instance as the
    Controller and root node at the same time. Note that the controller extends Pane
    as the root element definition in `LoginUI.fxml`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码加载我们的`LoginUI.fxml`文档，并将其作为Pane布局与其层次结构返回。然后将其绑定到当前控制器实例作为控制器和根节点。请注意，控制器扩展了Pane作为`LoginUI.fxml`中根元素定义。
- en: From NetBeans, choose **Clean and Build** and then right-click on the project
    and choose **Run**. The same screen we saw earlier should appear.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从NetBeans中选择**清理和构建**，然后右键单击项目选择**运行**。应该出现与之前看到的相同的屏幕。
- en: While the program is running, enter any credentials and click on the **Login**
    button; an error message will appear in red as shown in the following screenshot:![Coding
    the Login dialog custom UI](img/B03998_02_12.jpg)
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序运行时，输入任何凭据并单击**登录**按钮；如下截图所示，将出现红色的错误消息：![编码登录对话框自定义UI](img/B03998_02_12.jpg)
- en: Login Control invalid login.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 登录控制无效登录。
- en: 'If the right credentials (user: *tamanm*, pass: *Tamanm*) are entered, the
    green message appears with "*Valid Credentials*", as shown in the following figure.'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果输入正确的凭据（用户：*tamanm*，密码：*Tamanm*），则将显示绿色消息“*有效凭据*”，如下图所示。
- en: If the **Reset** button is clicked, then all controls return to the default
    values.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果单击**重置**按钮，则所有控件都将返回默认值。
- en: Congratulations! You have successfully created and implemented a UI custom control.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已成功创建并实现了一个UI自定义控件。
- en: '![Coding the Login dialog custom UI](img/B03998_02_13.jpg)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![编码登录对话框自定义UI](img/B03998_02_13.jpg)'
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered a lot of ground – getting started with a brief
    introduction about JavaFX 8 architecture components that act as the foundation
    layer to run your JavaFX application smoothly and efficiently. Then followed we
    explored how to render graphics on the scene with a brief explanation about the
    most common layouts and UI controls.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了很多内容-简要介绍了JavaFX 8架构组件，这些组件作为基础层来顺利高效地运行JavaFX应用程序。然后我们探讨了如何在场景上呈现图形，并简要解释了最常见的布局和UI控件。
- en: You were introduced to new features in Java SE 8 such as lambda expressions
    and functional interfaces, which was supported by examples showing the power of
    each.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解了Java SE 8中的新功能，例如lambda表达式和函数接口，这些功能得到了示例的支持，展示了每个功能的强大之处。
- en: You learned how to style your application with custom CSS files by using the
    `setUserAgentStylesheet(String URL)` and `getStylesheets().add(String URL)` methods.
    Next, you took a short look at the Scene Builder and how to load FXML into a scene.
    Finally, you learned about custom UI components in JavaFX and how to create them.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 您学会了如何使用`setUserAgentStylesheet(String URL)`和`getStylesheets().add(String URL)`方法来使用自定义CSS文件样式化您的应用程序。接下来，您简要了解了Scene
    Builder以及如何将FXML加载到场景中。最后，您学习了JavaFX中的自定义UI组件以及如何创建它们。
- en: In the next chapter, you will learn how to create a desktop application that
    consists of multiple scenes and then how to package it. Additionally, we will
    learn how to interact with the Web and develop web applications using JavaFX 8.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何创建由多个场景组成的桌面应用程序，然后如何打包它。此外，我们还将学习如何与Web进行交互，并使用JavaFX 8开发Web应用程序。
