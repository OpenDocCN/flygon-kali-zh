- en: '8: Containerizing an app'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8: 容器化应用程序'
- en: Docker is all about taking applications and running them in containers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的全部内容都是关于将应用程序放入容器中运行。
- en: The process of taking an application and configuring it to run as a container
    is called “containerizing”. Sometimes we call it “Dockerizing”.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序配置为容器运行的过程称为“容器化”。有时我们称之为“Docker化”。
- en: In this chapter we’ll walk through the process of containerizing a simple Linux
    web application. If you don’t have a Linux Docker environment to follow along
    with, you can use *Play With Docker* for free. Just point your web browser to
    https://play-with-docker.com and spin up some Linux Docker nodes. It’s my favourite
    way to spin up Docker and do testing!
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍将一个简单的Linux Web应用程序容器化的过程。如果您没有Linux Docker环境可以跟随操作，可以免费使用*Play With
    Docker*。只需将您的网络浏览器指向https://play-with-docker.com并启动一些Linux Docker节点。这是我启动Docker并进行测试的最喜欢的方式！
- en: 'We’ll split this chapter into the usual three parts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这一章分为通常的三个部分：
- en: The TLDR
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简而言之
- en: The deep dive
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨
- en: The commands
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令
- en: Let’s containerize an app!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将应用程序容器化！
- en: Containerizing an app - The TLDR
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化应用程序-简而言之
- en: Containers are all about apps! In particular, they’re about making apps simple
    to **build**, **ship**, and **run**.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器都是关于应用程序！特别是，它们是关于使应用程序简单**构建**、**交付**和**运行**。
- en: 'The process of containerizing an app looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应用程序的过程如下：
- en: Start with your application code.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的应用程序代码开始。
- en: Create a *Dockerfile* that describes your app, its dependencies, and how to
    run it.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个描述您的应用程序、其依赖关系以及如何运行它的*Dockerfile*。
- en: Feed this *Dockerfile* into the `docker image build` command.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此*Dockerfile*输入`docker image build`命令。
- en: Sit back while Docker builds your application into a Docker image.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 坐下来，让Docker将您的应用程序构建成一个Docker镜像。
- en: Once your app is containerized (made into a Docker image), you’re ready to ship
    it and run it as a container.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的应用程序被容器化（制作成Docker镜像），您就可以准备将其交付并作为容器运行。
- en: Figure 8.1 shows the process in picture form.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1以图片形式展示了这个过程。
- en: '![Figure 8.1 - Basic flow of containerizing an app](images/figure8-1.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1-容器化应用程序的基本流程](images/figure8-1.png)'
- en: Figure 8.1 - Basic flow of containerizing an app
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1-容器化应用程序的基本流程
- en: Containerizing an app - The deep dive
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化应用程序-深入探讨
- en: 'We’ll break up this Deep Dive section of the chapter as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把本章的深入探讨部分分为以下几个部分：
- en: Containerize a single-container app
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化单容器应用程序
- en: Moving to Production with multi-stage builds
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多阶段构建进行生产
- en: A few best practices
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些最佳实践
- en: Containerize a single-container app
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 容器化单容器应用程序
- en: The rest of this chapter will walk you through the process of containerizing
    a simple single-container Node.js web app. The process is the same for Windows,
    and future editions of the book will include a Windows example.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将引导您完成容器化一个简单的单容器Node.js Web应用程序的过程。这个过程对于Windows是一样的，未来版本的书籍将包括一个Windows示例。
- en: 'We’ll complete the following high-level steps:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将完成以下高层次的步骤：
- en: Get the app code
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取应用程序代码
- en: Inspect the Dockerfile
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查Dockerfile
- en: Containerize the app
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化应用程序
- en: Run the app
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: Test the app
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: Look a bit closer
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仔细观察一下
- en: Move to production with **Multi-stage Builds**
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**多阶段构建**进行生产
- en: A few best practices
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些最佳实践
- en: Although we’ll be working with a single-container app in this chapter, we’ll
    move on to a multi-container app in the next chapter on Docker Compose. After
    that, we’ll move on to an even more complicated app in the chapter on Docker Stacks.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在本章中我们将使用单容器应用程序，但在下一章关于Docker Compose中，我们将转向多容器应用程序。之后，我们将在关于Docker Stacks的章节中转向更复杂的应用程序。
- en: Getting the application code
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 获取应用程序代码
- en: 'The application used in this example can be cloned form GitHub:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例中使用的应用程序可以从GitHub克隆：
- en: https://github.com/nigelpoulton/psweb.git
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: https://github.com/nigelpoulton/psweb.git
- en: Clone the sample app from GitHub.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从GitHub克隆示例应用程序。
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`The clone operation creates a new directory called `psweb`. Change directory
    into `psweb` and list its contents.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`克隆操作会创建一个名为`psweb`的新目录。切换到`psweb`目录并列出其内容。'
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`This directory contains all of the application source code, as well as subdirectories
    for views and unit tests. Feel free to look at the files - the app is extremely
    simple. We won’t be using the unit tests in this chapter.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: “这个目录包含了所有的应用程序源代码，以及用于视图和单元测试的子目录。随意查看这些文件 - 应用程序非常简单。在本章中，我们不会使用单元测试。
- en: Now that we have the app code, let’s look at its Dockerfile.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了应用程序代码，让我们来看看它的Dockerfile。
- en: Inspecting the Dockerfile
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 检查Dockerfile
- en: Notice that the repo has a file called **Dockerfile**. This is the file that
    describes the application and tells Docker how to build it into an image.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储库有一个名为**Dockerfile**的文件。这个文件描述了应用程序，并告诉Docker如何将其构建成一个镜像。
- en: The directory containing the application is referred to as the *build context*.
    It’s a common practice to keep your Dockerfile in the root directory of the *build
    context*. It’s also important that **Dockerfile** starts with a capital “**D**”
    and is all one word. “dockerfile” and “Docker file” are not valid.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 包含应用程序的目录被称为*构建上下文*。将Dockerfile放在*构建上下文*的根目录是一种常见做法。同时，**Dockerfile**以大写的“**D**”开头，并且是一个单词。
    “dockerfile”和“Docker file”都是无效的。
- en: Let’s look at the contents of the Dockerfile.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看Dockerfile的内容。
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`The Dockerfile has two main purposes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile有两个主要目的：'
- en: To describe the application
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述应用程序
- en: To tell Docker how to containerize the application (create an image with the
    app inside)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 告诉Docker如何将应用程序容器化（创建一个包含应用程序的镜像）
- en: Do not underestimate the impact of the Dockerfile as a from of documentation!
    It has the ability to help bridge the gap between development and operations!
    It also has the power to speed up on-boarding of new developers etc. This is because
    the file accurately describes the application and its dependencies in an easy-to-read
    format. As such, it should be treated as code, and checked into a source control
    system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 不要低估Dockerfile作为文档的影响！它有助于弥合开发和运维之间的差距！它还有助于加快新开发人员等的入职速度。这是因为该文件准确描述了应用程序及其依赖关系，格式易于阅读。因此，它应被视为代码，并检入源代码控制系统。
- en: 'At a high-level, the example Dockerfile says: Start with the `alpine` image,
    add “nigelpoulton@hotmail.com” as the maintainer, install Node.js and NPM, copy
    in the application code, set the working directory, install dependencies, document
    the app’s network port, and set `app.js` as the default application to run.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，示例Dockerfile表示：从`alpine`镜像开始，将“nigelpoulton@hotmail.com”添加为维护者，安装Node.js和NPM，复制应用程序代码，设置工作目录，安装依赖项，记录应用程序的网络端口，并将`app.js`设置为默认要运行的应用程序。
- en: Let’s look at it in a bit more detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下。
- en: All Dockerfiles start with the `FROM` instruction. This will be the base layer
    of the image, and the rest of the app will be added on top as additional layers.
    This particular application is a Linux app, so it’s important that the FROM instruction
    refers to a Linux-based image. If you are containerizing a Windows application,
    you will need to specify the appropriate Windows base image - such as `microsoft/aspnetcore-build`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有Dockerfile都以`FROM`指令开头。这将是镜像的基础层，应用程序的其余部分将作为附加层添加在顶部。这个特定的应用程序是一个Linux应用程序，所以很重要的是`FROM`指令引用一个基于Linux的镜像。如果您要容器化一个Windows应用程序，您需要指定适当的Windows基础镜像
    - 比如`microsoft/aspnetcore-build`。
- en: At this point, the image looks like Figure 8.2 .
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，镜像看起来像图8.2。
- en: '![Figure 8.2](images/figure8-2.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2](images/figure8-2.png)'
- en: Figure 8.2
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2
- en: Next, the Dockerfile creates a LABEL that specifies “nigelpoulton@hotmail.com”
    as the maintainer of the image. Labels are simple key-value pairs and are an excellent
    way of adding custom metadata to an image. It’s considered a best practice to
    list a maintainer of an image so that other potential users have a point of contact
    when working with it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Dockerfile 创建了一个LABEL，指定“nigelpoulton@hotmail.com”作为镜像的维护者。标签是简单的键值对，是向镜像添加自定义元数据的绝佳方式。将镜像的维护者列出来被认为是最佳实践，这样其他潜在的用户在使用时有一个联系点。
- en: '**Note:** I will not be maintaining this image. I’m including the label to
    show you how to use labels as well as showing you a best practice.'
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：** 我将不会维护这个镜像。我包含这个标签是为了向您展示如何使用标签，同时向您展示最佳实践。'
- en: The `RUN apk add --update nodejs nodejs-npm` instruction uses the Alpine `apk`
    package manager to install `nodejs` and `nodejs-npm` into the image. The RUN instruction
    installs these packages as a new image layer on top of the `alpine` base image
    created by the `FROM alpine` instruction. The image now looks like Figure 8.3.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN apk add --update nodejs nodejs-npm` 指令使用 Alpine `apk` 包管理器将 `nodejs` 和
    `nodejs-npm` 安装到镜像中。RUN 指令将这些软件包安装为新的镜像层，放在由 `FROM alpine` 指令创建的 `alpine` 基础镜像之上。镜像现在看起来像图8.3。'
- en: '![Figure 8.3](images/Figure8-3.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3](images/Figure8-3.png)'
- en: Figure 8.3
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3
- en: The `COPY . /src` instruction copies in the app files from the *build context*.
    It copies these files into the image as a new layer. The image now has three layers
    as shown in Figure 8.4.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY . /src` 指令从*构建上下文*中复制应用程序文件。它将这些文件作为新层复制到镜像中。镜像现在有三个层，如图8.4所示。'
- en: '![Figure 8.4](images/figure8-4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4](images/figure8-4.png)'
- en: Figure 8.4
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4
- en: Next, the Dockerfile uses the `WORKDIR` instruction to set the working directory
    for the rest of the instructions in the file. This directory is relative to the
    image, and the info is added as metadata to the image config and not as a new
    layer.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，Dockerfile 使用 `WORKDIR` 指令为文件中的其余指令设置工作目录。此目录是相对于镜像的，并且该信息被添加为镜像配置的元数据，而不是作为新层。
- en: Then the `RUN npm install` instruction uses `npm` to install application dependencies
    listed in the `package.json` file in the build context. It runs within the context
    of the `WORKDIR` set in the previous instruction, and installs the dependencies
    as a new layer in the image. The image now has four layers as shown in Figure
    8.5.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`RUN npm install` 指令使用 `npm` 在构建上下文中列出的 `package.json` 文件中安装应用程序依赖项。它在前一条指令中设置的
    `WORKDIR` 上下文中运行，并将依赖项安装为镜像中的新层。镜像现在有四个层，如图8.5所示。
- en: '![Figure 8.5](images/figure8-5.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5](images/figure8-5.png)'
- en: Figure 8.5
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5
- en: The application exposes a web service on TCP port 8080, so the Dockerfile documents
    this with the `EXPOSE 8080` instruction. This is added as image metadata and not
    an image layer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序在TCP端口8080上公开了一个Web服务，因此Dockerfile 使用 `EXPOSE 8080` 指令记录了这一点。这被添加为镜像元数据，而不是镜像层。
- en: Finally, the `ENTRYPOINT` instruction is used to set the main application that
    the image (container) should run. This is also added as metadata and not an image
    layer.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`ENTRYPOINT` 指令用于设置镜像（容器）应该运行的主要应用程序。这也被添加为元数据，而不是镜像层。
- en: Containerize the app/build the image
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 容器化应用/构建镜像
- en: Now that we understand how it works, let’s build it!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了它是如何工作的，让我们来构建它吧！
- en: The following command will build a new image called `web:latest`. The period
    (`.`) at the end of the command tells Docker to use the shell’s current working
    directory as the *build context*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将构建一个名为 `web:latest` 的新镜像。命令末尾的句点 (`.`) 告诉 Docker 使用当前 shell 的工作目录作为*构建上下文*。
- en: Be sure to include the period (.) at the end of the command, and be sure to
    run the command from the `psweb` directory that contains the Dockerfile and application
    code.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在命令的末尾包括句点（.），并确保从包含Dockerfile和应用程序代码的`psweb`目录运行命令。
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Check that the image exists in your Docker host’s local repository.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`检查镜像是否存在于您的Docker主机的本地存储库中。'
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Congratulations, the app is containerized!'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`恭喜，应用已经容器化！'
- en: You can use the `docker image inspect web:latest` command to verify the configuration
    of the image. It will list all of the settings that were configured from the Dockerfile.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker image inspect web:latest`命令来验证镜像的配置。它将列出从Dockerfile配置的所有设置。
- en: Pushing images
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 推送镜像
- en: Once you’ve created an image, it’s a good idea to store it in an image registry
    to keep it safe and make it available to others. Docker Hub is the most common
    public image registry, and it’s the default push location for `docker image push`
    commands.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一个镜像后，将其存储在镜像注册表中是一个好主意，以确保其安全并使其对他人可用。Docker Hub是最常见的公共镜像注册表，也是`docker image
    push`命令的默认推送位置。
- en: In order to push an image to Docker Hub, you need to login with your Docker
    ID. You also need tag the image appropriately.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将镜像推送到Docker Hub，您需要使用您的Docker ID登录。您还需要适当地标记镜像。
- en: Let’s log in to Docker Hub and push the newly created image.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们登录Docker Hub并推送新创建的镜像。
- en: In the following example’s you will need to substitute my Docker ID with your
    own. So any time you see “nigelpoulton”, swap it out for your Docker ID.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，您需要用您自己的Docker ID替换我的Docker ID。因此，每当您看到“nigelpoulton”时，请将其替换为您的Docker
    ID。
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`Before you can push an image, you need to tag it in a special way. This is
    because Docker needs all of the following information when pushing an image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`在您可以推送镜像之前，您需要以特殊方式标记它。这是因为Docker在推送镜像时需要以下所有信息：'
- en: '`Registry`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`注册表`'
- en: '`Repository`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`存储库`'
- en: '`Tag`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`标签`'
- en: Docker is opinionated, so you don’t need to specify values for `Registry` and
    `Tag`. If you don’t specify values, Docker will assume `Registry=docker.io` and
    `Tag=latest`. However, Docker does not have a default value for the Repository
    value, it gets this from the “REPOSITORY” value of the image it is pushing. This
    might be confusing, so let’s take a closer look at the one from our example.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Docker有自己的观点，因此您不需要为`Registry`和`Tag`指定值。如果您不指定值，Docker将假定`Registry=docker.io`和`Tag=latest`。但是，Docker没有默认值用于存储库值，它从正在推送的镜像的“REPOSITORY”值中获取。这可能会让人感到困惑，因此让我们仔细看一下我们示例中的值。
- en: The previous `docker image ls` output shows our image with `web` as the repository
    name. This means a `docker image push` will try and push the image to `docker.io/web:latest`.
    However, I don’t have access to the `web` repository, all of my images have to
    sit within the `nigelpoulton` second-level namespace. This means we need to re-tag
    the image to include my Docker ID.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的`docker image ls`输出显示我们的镜像的存储库名称为`web`。这意味着`docker image push`将尝试将镜像推送到`docker.io/web:latest`。但是，我无法访问`web`存储库，我的所有镜像都必须位于`nigelpoulton`的二级命名空间中。这意味着我们需要重新标记镜像以包含我的Docker
    ID。
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`The format of the command is `docker image tag <current-tag> <new-tag>` and
    it adds an additional tag, it does not overwrite the original.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`命令的格式是`docker image tag <current-tag> <new-tag>`，它会添加一个额外的标签，而不是覆盖原始标签。'
- en: Another image listing shows the image now has two tags, one of which includes
    my Docker ID.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个镜像列表显示，该镜像现在有两个标签，其中一个包含我的Docker ID。
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`Now we can push it to Docker Hub.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`现在我们可以将其推送到Docker Hub。'
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Figure 8.6 shows how Docker determined the push location.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`图8.6显示了Docker如何确定推送位置。'
- en: '![Figure 8.6](images/figure8-6.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6](images/figure8-6.png)'
- en: Figure 8.6
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6
- en: You will not be able to push images to repos in my Docker Hub namespace, you
    will have to use your own.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您将无法将镜像推送到我的Docker Hub命名空间中的存储库，您将需要使用您自己的存储库。
- en: All of the examples in the rest of the chapter will use the shorter of the two
    tags (`web:latest`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章其余部分的所有示例都将使用两个标签中较短的一个（`web:latest`）。
- en: Run the app
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: The application that we’ve containerized is a simple web server that listens
    on TCP port 8080\. You can verify this in the `app.js` file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们容器化的应用程序是一个简单的Web服务器，监听TCP端口8080。您可以在`app.js`文件中验证这一点。
- en: The following command will start a new container called `c1` based on the `web:latest`
    image we just created. It maps port `80` on the Docker host, to port `8080` inside
    the container. This means that you will be able to point a web browser at the
    DNS name or IP address of the Docker host and access the app.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将基于我们刚刚创建的`web:latest`镜像启动一个名为`c1`的新容器。它将Docker主机上的端口`80`映射到容器内部的端口`8080`。这意味着您将能够将网络浏览器指向Docker主机的DNS名称或IP地址，并访问该应用程序。
- en: '**Note:** If your host is already running a service on port 80, you can specify
    a different port as part of the `docker container run` command. For example, to
    map the app to port 5000 on the Docker host, use the `-p 5000:8080` flag.'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意：**如果您的主机已经在端口80上运行服务，您可以在`docker container run`命令中指定不同的端口。例如，要将应用程序映射到Docker主机上的端口5000，请使用`-p
    5000:8080`标志。'
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`The `-d` flag runs the container in the background, and the `-p 80:8080` flag
    maps port 80 on the host to port 8080 inside the running container.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`-d`标志在后台运行容器，`-p 80:8080`标志将主机上的端口80映射到运行容器内部的端口8080。'
- en: Check that the container is running and verify the port mapping.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器是否正在运行并验证端口映射。
- en: '[PRE10]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`The output above is snipped for readability, but shows that the app container
    is running. Note that port 80 is mapped, on all host interfaces (`0.0.0.0:80`),
    to port 8080 in the container.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出被剪辑以提高可读性，但显示应用程序容器正在运行。请注意，端口80被映射到容器中的端口8080，映射到所有主机接口（`0.0.0.0:80`）。
- en: Test the app
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: Open a web browser and point it to the DNS name or IP address of the host that
    the container is running on. You will see the web page shown in Figure .
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个网络浏览器，并将其指向容器正在运行的主机的DNS名称或IP地址。您将看到图中显示的网页。
- en: '![Figure 8.7](images/figure8-7.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7](images/figure8-7.png)'
- en: Figure 8.7
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7
- en: 'If the test does not work, try the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试不起作用，请尝试以下操作：
- en: Make sure that the container is up and running with the `docker container ls`
    command. The container name is `c1` and you should see the port mapping as `0.0.0.0:80->8080/tcp`.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保容器正在运行并且使用`docker container ls`命令。容器名称为`c1`，您应该看到端口映射为`0.0.0.0:80->8080/tcp`。
- en: Check that the firewall and other network security settings are not blocking
    traffic to port 80 on the Docker host.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查防火墙和其他网络安全设置是否阻止Docker主机上的80端口的流量。
- en: Congratulations, the application is containerized and running!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，应用程序已经容器化并正在运行！
- en: Looking a bit closer
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更仔细地观察
- en: Now that the application is containerized, let’s take a closer look at how some
    of the machinery works.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序已经容器化，让我们更仔细地看看一些机制是如何工作的。
- en: Comment lines in a Dockerfile start with the `#` character.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile中的注释行以`#`字符开头。
- en: All non-comment lines are **Instructions**. Instructions take the format `INSTRUCTION
    argument`. Instruction names are not case sensitive, but it is normal practice
    to write them in UPPERCASE. This makes reading the Dockerfile easier.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有非注释行都是**指令**。指令采用`INSTRUCTION argument`的格式。指令名称不区分大小写，但通常习惯将它们写成大写。这样可以更容易地阅读Dockerfile。
- en: The `docker image build` command parses the Dockerfile one-line-at-a-time starting
    from the top.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker image build`命令逐行解析Dockerfile，从顶部开始。'
- en: Some instructions create new layers, whereas others just add metadata to the
    image.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指令创建新的层，而其他一些只是向镜像添加元数据。
- en: Examples of instructions that create new layers are `FROM`, `RUN`, and `COPY`.
    Examples of instructions that create metadata include `EXPOSE`, `WORKDIR`, `ENV`,
    and `ENTRYPOINT`. The basic premise is this - if an instruction is adding *content*
    such as files and programs to the image, it will create a new layer. If it is
    adding instructions on how to build the image and run the application, it will
    create metadata.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新层的指令示例包括`FROM`、`RUN`和`COPY`。创建元数据的指令示例包括`EXPOSE`、`WORKDIR`、`ENV`和`ENTRYPOINT`。基本原则是
    - 如果一条指令正在向镜像添加*内容*，比如文件和程序，它将创建一个新的层。如果它正在添加有关如何构建镜像和运行应用程序的指令，它将创建元数据。
- en: You can view the instructions that were used to build the image with the `docker
    image history command`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker image history`命令查看用于构建镜像的指令。
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Two things from the output above are worth noting.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上面输出中的两点值得注意。
- en: First. Each line corresponds to an instruction in the Dockerfile (starting from
    the bottom and working up). The `CREATED BY` column even lists the exact Dockerfile
    instruction that was executed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先。每行对应Dockerfile中的一条指令（从底部开始向上工作）。`CREATED BY`列甚至列出了执行的确切Dockerfile指令。
- en: Second. Only 4 of the lines displayed in the output create new layers (the ones
    with non-zero values in the `SIZE` column). These correspond to the `FROM`, `RUN`,
    and `COPY` instructions in the Dockerfile. Although the other instructions might
    look like they create layers, they actually create metadata instead of layers.
    The reason that the `docker image history` output makes it looks like all instructions
    create layers is an artefact of the way Docker builds and image layering used
    to work.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 其次。在输出中显示的行中，只有4行创建了新的层（`SIZE`列中的非零值）。这些对应于Dockerfile中的`FROM`、`RUN`和`COPY`指令。尽管其他指令看起来像是创建了层，但实际上它们创建的是元数据而不是层。`docker
    image history`输出使所有指令看起来都创建了层的原因是Docker构建和镜像分层的方式的产物。
- en: Use the `docker image inspect` command to confirm that only 4 layers were created.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker image inspect`命令确认只创建了4个层。
- en: '[PRE12]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`It is considered a good practice to use images from official repositories
    with the `FROM` instruction. This is because they tend to follow best practices
    and be relatively free from known vulnerabilities. It is also a good idea to start
    from (`FROM`) small images as this reduces potential vulnerabilities.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`FROM`指令从官方仓库中使用镜像被认为是一个良好的做法。这是因为它们往往遵循最佳实践，并且相对免受已知漏洞的影响。从小型镜像（`FROM`）开始也是一个好主意，因为这样可以减少潜在的漏洞。
- en: 'You can view the output of the `docker image build` command to see the general
    process for building an image. As the following snippet shows, the basic process
    is: `spin up a temporary container` > `run the Dockerfile instruction inside of
    that container` > `save the results as a new image layer` > `remove the temporary
    container`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看`docker image build`命令的输出，以了解构建镜像的一般过程。如下摘录所示，基本过程是：`启动临时容器` > `在该容器内运行Dockerfile指令`
    > `将结果保存为新的镜像层` > `删除临时容器`。
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`#### Moving to production with **Multi-stage Builds**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用**多阶段构建**进行生产部署'
- en: When it comes to Docker images, big is bad!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker镜像中，大尺寸是不好的！
- en: Big means slow. Big means hard to work with. And big means a more potential
    vulnerabilities and possibly a bigger attack surface!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大尺寸意味着慢。大尺寸意味着难以处理。大尺寸意味着更多的潜在漏洞，可能意味着更大的攻击面！
- en: For these reasons, Docker images should be small. The aim of the game is to
    only ship production images containing the stuff **needed** to run your app in
    production.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker镜像应该尽量保持小尺寸。游戏的目标是只在生产镜像中包含**必要**的内容来运行您的应用程序。
- en: The problem is… keeping images small *was* hard work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是...保持镜像尺寸小曾经是一项艰苦的工作。
- en: For example, the way you write your Dockerfiles has a huge impact on the size
    of your images. A common example is that every `RUN` instruction adds a new layer.
    As a result, it’s usually considered a best practice to include multiple commands
    as part of a single RUN instruction - all glued together with double-ampersands
    (&&) and backslash (`\`) line-breaks. While this isn’t rocket science, it requires
    time and discipline.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您编写Dockerfile的方式对映像的大小有很大影响。一个常见的例子是每个`RUN`指令都会添加一个新的层。因此，通常被认为是最佳实践的是将多个命令作为单个RUN指令的一部分
    - 所有这些命令都用双和号（&&）和反斜杠（`\`）换行符粘合在一起。虽然这并不是什么高深的学问，但它需要时间和纪律。
- en: Another issue is that we don’t clean up after ourselves. We’ll RUN a command
    against an image that pulls some build-time tools, and we’ll leave all those tools
    in the image when we ship it to production. Not ideal!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是我们没有清理干净。我们将针对一个映像运行一个命令，拉取一些构建时工具，并在将其发送到生产环境时将所有这些工具留在映像中。这并不理想！
- en: There were ways around this - most notably the *builder pattern*. But most of
    these required discipline and added complexity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有解决方法 - 最明显的是*构建者模式*。但其中大多数都需要纪律和增加复杂性。
- en: The builder pattern required you to have at least two Dockerfiles - one for
    development and one for production. You’d write your Dockerfile.dev to start from
    a large base image, pull in any additional build tools required, and build your
    app. You’d then build an image from the Dockerfile.dev and create a container
    from it. You’d then use your Dockerfile.prod to build a new image from a smaller
    base image, and copy over just the application stuff from the container you just
    created from the build image. And everything needed to be glued together with
    a script.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式要求您至少有两个Dockerfile - 一个用于开发，一个用于生产。您将编写Dockerfile.dev以从大型基础映像开始，拉入所需的任何其他构建工具，并构建您的应用程序。然后，您将从Dockerfile.dev构建一个映像，并从中创建一个容器。然后，您将使用Dockerfile.prod从较小的基础映像构建一个新的映像，并从刚刚从构建映像创建的容器中复制应用程序内容。所有内容都需要用脚本粘合在一起。
- en: This approach was doable, but at the expense of complexity.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法是可行的，但代价是复杂性。
- en: Multi-stage builds to the rescue!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建来拯救！
- en: Multi-stage builds are all about optimizing builds without adding complexity.
    And they deliver on the promise!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建的目标是优化构建而不增加复杂性。它们实现了承诺！
- en: Here’s the high-level…
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个高层次的…
- en: With multi-stage builds, we have a single Dockerfile containing multiple FROM
    instructions. Each FROM instruction is a new **build stage** that can easily COPY
    artefacts from previous **stages**.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多阶段构建，我们有一个包含多个FROM指令的单个Dockerfile。每个FROM指令都是一个新的**构建阶段**，可以轻松地从以前的**阶段**复制构件。
- en: Let’s look at an example!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子！
- en: This example app is available at https://github.com/nigelpoulton/atsea-sample-shop-app.git
    and the Dockerfile is in the `app` directory. It’s a Linux-based application so,
    will only work on a Linux Docker host.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序可在https://github.com/nigelpoulton/atsea-sample-shop-app.git上找到，Dockerfile位于`app`目录中。这是一个基于Linux的应用程序，因此只能在Linux
    Docker主机上运行。
- en: The repo is a fork of `dockersamples/atsea-sample-shop-app` and I’ve forked
    it in case the upstream repo is removed or deleted.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该存储库是`dockersamples/atsea-sample-shop-app`的一个分支，我已经分叉了它，以防上游存储库被删除或删除。
- en: 'The Dockerfile is shown below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile如下所示：
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`The first thing to note is that the Dockerfile has three `FROM` instructions.
    Each of these constitutes a distinct **build stage**. Internally they’re numbered
    form the top starting at 0\. However, we’ve also given each stage a friendly name.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “首先要注意的是Dockerfile有三个`FROM`指令。每个都构成一个独立的**构建阶段**。在内部，它们从顶部开始编号为0。但是，我们还给每个阶段起了一个友好的名字。
- en: Stage 0 is called `storefront`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第0阶段称为“店面”
- en: Stage 1 is called `appserver`
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1阶段称为“应用服务器”
- en: Stage 2 is called `production`
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2阶段称为“生产”
- en: The `storefront` stage pulls the `node:latest` image which is over 600MB in
    size. It sets the working directory, copies in some app code, and uses two RUN
    instructions to perform some `npm` magic. This adds three layers and considerable
    size. The result is an even bigger image containing lots of build stuff and not
    very much app code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`storefront`阶段拉取了大小超过600MB的`node:latest`镜像。它设置了工作目录，复制了一些应用代码，并使用了两个RUN指令来执行一些`npm`魔法。这增加了三层和相当大的大小。结果是一个更大的镜像，其中包含了大量的构建工具和非常少的应用代码。'
- en: The `appserver` stage pulls the `maven:latest` image which is over 700MB in
    size. It adds four layers of content via two COPY instructions and two RUN instructions.
    This produces another very large image with lots of build tools and very little
    actual production code.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`appserver`阶段拉取了大小超过700MB的`maven:latest`镜像。它通过两个COPY指令和两个RUN指令添加了四层内容。这产生了另一个非常大的镜像，其中包含了大量的构建工具和非常少的实际生产代码。'
- en: The `production` stage starts by pulling the `java:8-jdk-alpine` image. This
    image is approximately 150MB - considerably smaller than the node and maven images
    used by the previous build stages. It adds a user, sets the working directory,
    and copies in some app code from the image produced by the `storefront` stage.
    After that, it sets a different working directory and copies in the application
    code form the image produced by the `appserver` stage. Finally, it sets the main
    application for the image to run when it’s started as a container.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 生产阶段从拉取`java:8-jdk-alpine`镜像开始。这个镜像大约150MB，比之前构建阶段使用的node和maven镜像要小得多。它添加了一个用户，设置了工作目录，并从`storefront`阶段生成的镜像中复制了一些应用代码。之后，它设置了一个不同的工作目录，并从`appserver`阶段生成的镜像中复制了应用程序代码。最后，它设置了启动容器时要运行的主应用程序镜像。
- en: An important thing to note, is that `COPY --from` instructions are used to **only
    copy production-related application code** from the images built by the previous
    stages. They do not copy across build artefacts that are not needed for production.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一件重要的事情是，`COPY --from`指令用于**仅从前几个阶段构建的镜像中复制与生产相关的应用代码**。它们不会复制不需要用于生产的构建产物。
- en: It’s also important to note that we only need a single Dockerfile, and no extra
    arguments are needed for the `docker image build` command!
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，我们只需要一个Dockerfile，并且`docker image build`命令不需要额外的参数！
- en: Speaking of which… let’s build it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这个……让我们来构建它。
- en: Clone the repo.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆存储库。
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Change directory into the `app` folder of the cloned repo and verify that
    the Dockerfile exists.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到克隆存储库的`app`文件夹，并验证Dockerfile是否存在。
- en: '[PRE16]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Perform the build (this may take several minutes to complete).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 进行构建（这可能需要几分钟才能完成）。
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`> **Note:** The `multi:stage` tag used in the example above is arbitrary.
    You can tag your images according to your own requirements and standards - there
    is no requirement to tag multi-stage builds the way we did in this example.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '> **注意：**上面示例中使用的`multi:stage`标签是任意的。您可以根据自己的要求和标准为镜像打标签 - 没有必要像我们在这个示例中那样为多阶段构建打标签。'
- en: Run a `docker image ls` to see the list of images pulled and created by the
    build operation.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker image ls`以查看构建操作拉取和创建的镜像列表。
- en: '[PRE18]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`The top line in the output above shows the `node:latest` image pulled by the
    `storefront` stage. The image below is the image produced by that stage (created
    by adding the code and running the npm install and build operations). Both are
    very large images with lots of build tools included.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上面输出的第一行显示了`storefront`阶段拉取的`node:latest`镜像。下面的镜像是该阶段生成的镜像（通过添加代码并运行npm install和构建操作创建）。两者都是非常大的镜像，包含了大量的构建工具。
- en: The 3rd and 4th lines are the images pulled and produced by the `appserver`
    stage. These are both large and contain lots of builds tools.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和第四行是由`appserver`阶段拉取和生成的镜像。这两个镜像都很大，包含了很多构建工具。
- en: The last line is the `multi:stage` image built by the final build stage in the
    Dockerfile (stage2/production). You can see that this is significantly smaller
    than the images pulled and produced by the previous stages. This is because it’s
    based off the much smaller `java:8-jdk-alpine` image and has only added the production-related
    app files from the previous stages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行是由 Dockerfile 中最终构建阶段（stage2/production）构建的`multi:stage`镜像。你可以看到，这个镜像比之前阶段拉取和生成的镜像要小得多。这是因为它是基于更小的`java:8-jdk-alpine`镜像，并且只添加了前几个阶段的与生产相关的应用文件。
- en: The net result is a small production image created by a single Dockerfile, a
    normal `docker image build` command, and zero additional scripting!
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是通过一个普通的`docker image build`命令和零额外脚本创建的小型生产镜像！
- en: Multi-stage builds were new with Docker 17.05 and are an excellent feature for
    building small production-worthy images.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段构建是 Docker 17.05 中的新功能，非常适合构建小型的生产级镜像。
- en: A few best practices
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 一些最佳实践。
- en: Let’s list a few best practices before closing out the chapter. This list is
    not intended to be exhaustive.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，让我们列举一些最佳实践。这个列表并不打算是详尽无遗的。
- en: Leverage the build cache
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 利用构建缓存
- en: The build process used by Docker has the concept of a cache. The best way to
    see the impact of the cache is to build a new image on a clean Docker host, then
    repeat the same build immediately after. The first build will pull images and
    take time building layers. The second build will complete almost instantaneously.
    This is because artefacts form the first build, such as layers, are cached and
    leveraged by later builds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用的构建过程有一个缓存的概念。看到缓存的影响最好的方法是在一个干净的 Docker 主机上构建一个新的镜像，然后立即重复相同的构建。第一次构建将拉取镜像并花费时间构建层。第二次构建将几乎立即完成。这是因为第一次构建的产物，比如层，被缓存并被后续构建所利用。
- en: As we know, the `docker image build` process iterates through a Dockerfile one-line-at-a-time
    starting from the top. For each instruction, Docker looks to see if it already
    has an image layer for that instruction in its cache. If it does, this is a *cache
    hit* and it uses that layer. If it doesn’t, this is a *cache miss* and it builds
    a new layer from the instruction. Getting *cache hits* can hugely speed up the
    build process.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，`docker image build` 过程是逐行迭代 Dockerfile，从顶部开始。对于每个指令，Docker 会查看它的缓存中是否已经有了该指令的镜像层。如果有，这就是*缓存命中*，它会使用该层。如果没有，这就是*缓存未命中*，它会根据该指令构建一个新的层。获得*缓存命中*可以极大地加快构建过程。
- en: Let’s look a little closer.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再仔细看一下。
- en: 'We’ll use this example Dockerfile to provide a quick walk-through:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个示例 Dockerfile 进行快速演示：
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`The first instruction tells Docker to use the `alpine:latest` image as its
    *base image*. If this image already exists on the host, the build will move on
    to the next instruction. If the image does not exist, it is pulled from Docker
    Hub (docker.io).'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`第一条指令告诉 Docker 使用`alpine:latest`镜像作为其*基础镜像*。如果该镜像已经存在于主机上，构建将继续进行到下一条指令。如果该镜像不存在，它将从
    Docker Hub（docker.io）上拉取。'
- en: The next instruction (`RUN apk...`) runs a command against the image. At this
    point, Docker checks its build cache for a layer that was built from the same
    base image, as well as using the same instruction it is currently being asked
    to execute. In this case, it’s looking for a layer that was built directly on
    top of `alpine:latest` by executing the `RUN apk add --update nodejs nodejs-npm`
    instruction.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令（`RUN apk...`）针对镜像运行一个命令。此时，Docker会检查构建缓存，查找是否有一个层是从相同的基础镜像构建的，并且使用了当前要执行的相同指令。在这种情况下，它正在寻找一个直接在`alpine:latest`之上构建的层，通过执行`RUN
    apk add --update nodejs nodejs-npm`指令。
- en: If it finds a layer, it skips the instruction, links to that existing layer,
    and continues the build with the cache in tact. If it does **not** find a layer,
    it invalidates the cache and builds the layer. This operation of invalidating
    the cache invalidates it for the remainder of the build. This means all subsequent
    Dockerfile instructions are completed in full without attempting to reference
    the build cache.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它找到了一个层，它会跳过该指令，链接到该现有层，并继续使用缓存进行构建。如果它**没有**找到一个层，它会使缓存失效并构建该层。使缓存失效的操作会使其在剩余的构建过程中失效。这意味着所有后续的Dockerfile指令都将完全完成，而不会尝试引用构建缓存。
- en: Let’s assume that Docker already had a layer for this instruction in the cache
    (a cache hit). And let’s assume the ID of that layer was `AAA`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Docker已经在缓存中为此指令创建了一个层（缓存命中）。假设该层的ID是`AAA`。
- en: The next instruction copies some code into the image (`COPY . /src`). Because
    the previous instruction resulted in a cache hit, Docker now checks to see if
    it has a cached layer that was built from the `AAA` layer with the `COPY . /src`
    command. If it does, it links to the layer and proceeds to the next instruction.
    If it does not, it builds the layer and invalidates the cache for the rest of
    the build.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条指令将一些代码复制到镜像中（`COPY . /src`）。由于前一条指令导致了缓存命中，Docker现在会检查是否有一个缓存的层是从`AAA`层使用`COPY
    . /src`命令构建的。如果有，它会链接到该层并继续执行下一条指令。如果没有，它会构建该层并使得剩余的构建过程缓存失效。
- en: Let’s assume that Docker already has a layer for this instruction in the cache
    (a cache hit). And let’s assume the ID of that layer is `BBB`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Docker已经在缓存中为此指令创建了一个层（缓存命中）。假设该层的ID是`BBB`。
- en: This process continues for the rest of the Dockerfile.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程将继续进行，直到 Dockerfile 的其余部分。
- en: It’s important to understand a few things.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解一些事情。
- en: Firstly, as soon as any instruction results in a cache-miss (no layer was found
    for that instruction), the cache is no longer used for the rest of the entire
    build. This has an important impact on how you write your Dockerfiles. Try and
    build them in a way that places any instructions that are likely to change towards
    the end of the file. This means that a cache-miss will not occur until later stages
    of the build - allowing the build to benefit as much as possible from the cache.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一旦任何指令导致缓存未命中（没有找到该指令的层），缓存将不再用于整个构建的剩余部分。这对您如何编写Dockerfile有重要影响。尝试以一种方式构建它们，将可能更改的任何指令放在文件末尾。这意味着直到构建的后期阶段才会发生缓存未命中，从而使构建尽可能多地受益于缓存。
- en: You can force the build process to ignore the entire cache by passing the `--no-cache=true`
    flag to the `docker image build` command.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过向`docker image build`命令传递`--no-cache=true`标志来强制构建过程忽略整个缓存。
- en: It is also important to understand that the `COPY` and `ADD` instructions include
    steps to ensure that the content being copied into the image has not changed since
    the last build. For example, it’s possible that the `COPY . /src` instruction
    in the Dockerfile has not changed since the previous, **but…** the contents of
    the directory being copied into the image **have** changed!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 还重要的是要理解`COPY`和`ADD`指令包括确保复制到镜像中的内容自上次构建以来没有更改的步骤。例如，Dockerfile中的`COPY . /src`指令可能自上次构建以来没有更改，**但是...**被复制到镜像中的目录的内容**已经**发生了变化！
- en: To protect against this, Docker performs a checksum against each file being
    copied, and compares that to a checksum of the same file in the cached layer.
    If the checksums do not match, the cache is invalidated and a new layer is built.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，Docker对每个被复制的文件执行校验和，并将其与缓存层中相同文件的校验和进行比较。如果校验和不匹配，则缓存将被作废，并构建一个新的层。
- en: Squash the image
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 压缩镜像
- en: Squashing an image isn’t really a best practice as it has pros and cons.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩镜像并不是一个最佳实践，因为它有利有弊。
- en: At a high level, Docker follows the normal process to build an image, but then
    adds an additional step that squashes everything into a single layer.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在高层次上，Docker遵循构建镜像的正常流程，但然后添加了一个额外的步骤，将所有内容压缩成一个单一层。
- en: Squashing can be good in situations where images are starting to have a lot
    of layers and this isn’t ideal. And example might be when creating a new base
    image that you want to build other images from in the future - this is much better
    as a single-layer image.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像开始具有大量层并且这并不理想的情况下，压缩可能是有益的。例如，当创建一个新的基础镜像，您希望将来从中构建其他镜像时 - 这作为单层镜像要好得多。
- en: On the negative side, squashed images do not share image layers. This can result
    in storage inefficiencies and larger push and pull operations.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 消极的一面是，压缩的镜像不共享镜像层。这可能导致存储效率低下和更大的推送和拉取操作。
- en: Add the `--squash` flag to the `docker image build` command if you want to create
    a squashed image.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建压缩的镜像，请在`docker image build`命令中添加`--squash`标志。
- en: Figure 8.8 shows some of the inefficiencies that come with squashed images.
    Both images are exactly the same except for the fact that one is squashed and
    the other is not. The squashed image shares layers with other images on the host
    (saving disk space) but the squashed image does not. The squashed image will also
    need to send every byte to Docker Hub on a `docker image push` command, whereas
    the non-squashed image only needs to send unique layers.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8显示了压缩镜像带来的一些效率低下。两个镜像除了一个是压缩的，另一个不是，其他都完全相同。压缩的镜像与主机上的其他镜像共享层（节省磁盘空间），但压缩的镜像不共享。压缩的镜像还需要在`docker
    image push`命令中发送每个字节到Docker Hub，而非压缩的镜像只需要发送唯一的层。
- en: '![Figure 8.8 - Squashed images vs non-squashed images](images/figure8-8.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 - 压缩镜像与非压缩镜像](images/figure8-8.png)'
- en: Figure 8.8 - Squashed images vs non-squashed images
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 压缩镜像与非压缩镜像
- en: Use no-install-recommends
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不安装推荐软件
- en: If you are building Linux images, and using the apt package manager, you should
    use the `no-install-recommends` flag with the `apt-get install` command. This
    makes sure that `apt` only installs main dependencies (packages in the `Depends`
    field) and not recommended or suggested packages. This can greatly reduce the
    number of unwanted packages that are downloaded into your images.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建Linux镜像，并使用apt软件包管理器，您应该在`apt-get install`命令中使用`no-install-recommends`标志。这可以确保`apt`只安装主要依赖项（`Depends`字段中的软件包），而不是推荐或建议的软件包。这可以大大减少下载到镜像中的不需要的软件包的数量。
- en: Do not install from MSI packages (Windows)
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 不要从MSI软件包（Windows）安装
- en: If you are building Windows images, you should try not to use the MSI package
    manager. It is not space efficient and results in substantially larger images
    than are required.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建Windows映像，应尽量避免使用MSI软件包管理器。它不够节省空间，导致映像比所需的要大得多。
- en: Containerizing an app - The commands
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器化应用程序 - 命令
- en: '`docker image build` is the command that reads a Dockerfile and containerizes
    an application. The `-t` flag tags the image, and the `-f` flag lets you specify
    the name and location of the Dockerfile. With the `-f` flag, it is possible to
    use a Dockerfile with an arbitrary name and in an arbitrary location. The *build
    context* is where your application files exist, and this can be a directory on
    your local Docker host or a remote Git repo.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker image build`是一个读取Dockerfile并将应用程序容器化的命令。`-t`标志为映像打标签，`-f`标志允许您指定Dockerfile的名称和位置。使用`-f`标志，可以使用任意名称和位置的Dockerfile。*构建上下文*是您的应用程序文件所在的位置，可以是本地Docker主机上的目录，也可以是远程Git存储库。'
- en: The `FROM` instruction in a Dockerfile specifies the base image for the new
    image you will build. It is usually the first instruction in a Dockerfile.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中的`FROM`指令指定了要构建的新映像的基础映像。通常是Dockerfile中的第一条指令。
- en: The `RUN` instruction in a Dockerfile allows you to run commands inside the
    image which create new layers. Each `RUN` instruction creates a single new layer.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中的`RUN`指令允许您在映像内部运行命令，从而创建新的层。每个`RUN`指令都会创建一个新的层。
- en: The `COPY` instruction in a Dockerfile adds files into the image as a new layer.
    It is common to use the `COPY` instruction to copy your application code into
    an image.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中的`COPY`指令将文件添加到映像中作为一个新层。通常使用`COPY`指令将应用程序代码复制到映像中。
- en: The `EXPOSE` instruction in a Dockerfile documents the network port that the
    application uses.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中的`EXPOSE`指令记录了应用程序使用的网络端口。
- en: The `ENTRYPOINT` instruction in a Dockerfile sets the default application to
    run when the image is started as a container.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile中的`ENTRYPOINT`指令设置了在将映像启动为容器时要运行的默认应用程序。
- en: Other Dockerfile instructions include `LABEL`, `ENV`, `ONBUILD`, `HEALTHCHECK`,
    `CMD` and more…
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他Dockerfile指令包括`LABEL`、`ENV`、`ONBUILD`、`HEALTHCHECK`、`CMD`等等…
- en: Chapter summary
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 章节总结
- en: In this chapter we learned how to containerize (Dockerize) an application.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将应用程序容器化（Docker化）。
- en: We pulled some application code from a remote Git repo. The repo included the
    application code, as well as a Dockerfile containing instructions on how to build
    the application into an image. We learned the basics of the how Dockerfiles work,
    and fed one into a `docker image build` command to create a new image.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从远程Git存储库中提取了一些应用程序代码。存储库包括应用程序代码以及一个包含如何将应用程序构建成映像的Dockerfile。我们学习了Dockerfile的基础知识，并将其输入到`docker
    image build`命令中以创建一个新的映像。
- en: Once the image was created, we started a container form it and tested it worked
    with a web browser.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建映像后，我们启动了一个容器并使用Web浏览器测试了它的工作情况。
- en: After that, we saw how multi-stage builds give us a simple way to build and
    ship smaller images to our production environments.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们了解了多阶段构建如何为我们提供了一种简单的方式来构建和部署更小的映像到生产环境。
- en: We also learned that the Dockerfile is a great tool for documenting an app.
    As such, it can speed-up the on-boarding of new developers and bridge the divide
    between developers and operations staff! With this in mind, treat it like code
    and check it in and out of a source control system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还了解到Dockerfile是一个很好的工具，可以用来记录应用程序。因此，它可以加快新开发人员的入职速度，并弥合开发人员和运维人员之间的鸿沟！考虑到这一点，将其视为代码，并将其检入和检出源代码控制系统。
- en: 'Although the example cited was a Linux-based example, the process for containerizing
    Windows apps is the same: Start with your app code, create a Dockerfile describing
    the app, build the image with `docker image build`. Job done![PRE20]`'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管引用的例子是一个基于Linux的例子，但容器化Windows应用程序的过程是相同的：从您的应用程序代码开始，创建描述应用程序的Dockerfile，使用`docker
    image build`构建镜像。工作完成！
