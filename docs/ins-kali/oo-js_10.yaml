- en: Chapter 10. The Browser Environment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。浏览器环境
- en: 'You know that JavaScript programs need a host environment. Most of what you
    learned so far in this book was related to core ECMAScript/JavaScript and can
    be used in many different host environments. Now, let''s shift the focus to the
    browser as this is the most popular and natural host environment for JavaScript
    programs. In this chapter, you will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您知道JavaScript程序需要一个宿主环境。到目前为止，您在本书中学到的大部分内容都与核心ECMAScript/JavaScript有关，并且可以在许多不同的宿主环境中使用。现在，让我们把重点转移到浏览器上，因为这是JavaScript程序最受欢迎和自然的宿主环境。在本章中，您将学习以下主题：
- en: The **Browser Object Model** (**BOM**)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浏览器对象模型**（**BOM**）'
- en: The **Document Object Model** (**DOM**)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档对象模型**（**DOM**）'
- en: Browser events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器事件
- en: The `XMLHttpRequest` object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest`对象'
- en: Including JavaScript in an HTML page
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在HTML页面中包含JavaScript
- en: 'To include JavaScript in an HTML page, you will need to use the `<script>`
    tag as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要在HTML页面中包含JavaScript，您需要使用以下`<script>`标签：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, the first `<script>` tag includes an external file, `somefile.js`,
    which contains JavaScript code. The second `<script>` tag includes the JavaScript
    code directly in the HTML code of the page. The browser executes the JavaScript
    code in the sequence it finds it on the page and all the code in all tags share
    the same global namespace. This means that when you define a variable in `somefile.js`,
    it also exists in the second `<script>` block.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，第一个`<script>`标签包含一个外部文件`somefile.js`，其中包含JavaScript代码。第二个`<script>`标签直接在页面的HTML代码中包含JavaScript代码。浏览器按照在页面上找到的顺序执行JavaScript代码，并且所有标签中的代码共享相同的全局命名空间。这意味着当您在`somefile.js`中定义一个变量时，它也存在于第二个`<script>`块中。
- en: BOM and DOM - an overview
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BOM和DOM - 概述
- en: 'The JavaScript code in a page has access to a number of objects. These objects
    can be divided into the following types:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 页面中的JavaScript代码可以访问多个对象。这些对象可以分为以下类型：
- en: '**Core ECMAScript objects**: This consists of all the objects mentioned in
    the previous chapters'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心ECMAScript对象**：这包括前几章中提到的所有对象'
- en: '**DOM**: This consists of objects that have to do with the currently loaded
    page, which is also called the document'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DOM**：这包括与当前加载的页面有关的对象，也称为文档'
- en: '**BOM**: This consists of objects that deal with everything outside the page-the
    browser window and the desktop screen'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**BOM**：这包括处理页面外的一切内容-浏览器窗口和桌面屏幕'
- en: DOM stands for Document Object Model and BOM for Browser Object Model.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: DOM代表文档对象模型，BOM代表浏览器对象模型。
- en: The DOM is a standard governed by the **World Wide Web Consortium** (**W3C**)
    and has different versions, called levels, such as DOM Level 1, DOM Level 2, and
    so on. Browsers in use today have different degrees of compliance with the standard,
    but in general, they almost all completely implement DOM Level 1\. The DOM was
    standardized post factum after the browser vendors had each implemented their
    own ways to access the document. The legacy part from before the W3C took over
    is still around and is referred to as DOM 0, although, no real DOM Level 0 standard
    exists. Some parts of DOM 0 have become de facto standards as all major browsers
    support them; some of these were added to the DOM Level 1 standard. The rest of
    DOM 0 that didn't find its way to DOM 1 is too browser specific and won't be discussed
    here.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DOM是由**万维网联盟**（**W3C**）制定的标准，有不同的版本，称为DOM Level 1、DOM Level 2等。今天使用的浏览器对标准的遵从程度不同，但总的来说，它们几乎都完全实现了DOM
    Level 1。在浏览器供应商各自实现了访问文档的方式之后，DOM被标准化后事实上成为了标准。W3C接管之前的遗留部分仍然存在，并被称为DOM 0，尽管实际上并不存在真正的DOM
    Level 0标准。DOM 0的一些部分已成为事实上的标准，因为所有主要浏览器都支持它们；其中一些已添加到DOM Level 1标准中。未能在DOM 1中找到其位置的DOM
    0的其余部分太过特定于浏览器，这里不会讨论。
- en: Historically, BOM was not a part of any standard. Similar to DOM 0, it has a
    subset of objects that is supported by all major browsers, and another subset
    that is browser-specific. The HTML5 standard codifies common behavior among browsers,
    and it includes common BOM objects. Additionally, mobile devices come with their
    specific objects (and HTML5 aims to standardize those as well), which traditionally
    were not necessary for desktop computers, but make sense in a mobile world, for
    example, geolocation, camera access, vibration, touch events, telephony, and SMS.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，BOM不是任何标准的一部分。与DOM 0类似，它具有所有主要浏览器支持的对象的子集，以及特定于浏览器的另一个子集。HTML5标准对浏览器之间的共同行为进行了编码，并包括了常见的BOM对象。此外，移动设备配备了它们特定的对象（HTML5也旨在标准化这些对象），这在传统上对于台式电脑来说并不是必需的，但在移动世界中是有意义的，例如地理位置、相机访问、振动、触摸事件、电话和短信。
- en: 'This chapter discusses only cross-browser subsets of BOM and DOM Level 1, unless
    noted otherwise in the text. Even these safe subsets constitute a large topic,
    and a full reference is beyond the scope of this book. You can also consult the
    following references:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅讨论BOM和DOM Level 1的跨浏览器子集，除非在文本中另有说明。即使这些安全子集构成了一个很大的主题，但完整的参考资料超出了本书的范围。您还可以参考以下参考资料：
- en: Mozilla DOM reference ([http://developer.mozilla.org/en/docs/Gecko_DOM_Reference](http://developer.mozilla.org/en/docs/Gecko_DOM_Reference))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla DOM参考（[http://developer.mozilla.org/en/docs/Gecko_DOM_Reference](http://developer.mozilla.org/en/docs/Gecko_DOM_Reference)）
- en: Mozilla's HTML5 wiki ([https://developer.mozilla.org/en-US/docs/HTML/HTML5](https://developer.mozilla.org/en-US/docs/HTML/HTML5))
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mozilla的HTML5维基（[https://developer.mozilla.org/en-US/docs/HTML/HTML5](https://developer.mozilla.org/en-US/docs/HTML/HTML5)）
- en: Microsoft's documentation for Internet Explorer ([http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx](http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx))
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软的Internet Explorer文档（[http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx](http://msdn2.microsoft.com/en-us/library/ms533050(vs.85).aspx)）
- en: W3C's DOM specifications ([http://www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR))
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: W3C的DOM规范（[http://www.w3.org/DOM/DOMTR](http://www.w3.org/DOM/DOMTR)）
- en: BOM
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BOM
- en: The BOM is a collection of objects that give you access to the browser and the
    computer screen. These objects are accessible through the global object `window`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: BOM是一组对象，它们让你可以访问浏览器和计算机屏幕。这些对象可以通过全局对象`window`访问。
- en: The window object revisited
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: window对象重访
- en: 'As you already know, in JavaScript, there''s a global object provided by the
    host environment. In the browser environment, this global object is accessible
    using `window`. All global variables are also accessible as properties of the
    `window` object. For example, take a look at the following code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，在JavaScript中，宿主环境提供了一个全局对象。在浏览器环境中，可以使用`window`访问此全局对象。所有全局变量也可以作为`window`对象的属性访问。例如，看一下以下代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Additionally, all the core JavaScript functions, discussed in [Chapter 2](ch02.html
    "Chapter 2. Primitive Data Types, Arrays, Loops, and Conditions"), *Primitive
    Data Types, Arrays, Loops, and Conditions*, are methods of the global object.
    Consider the following piece of code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，所有核心JavaScript函数，如[第2章](ch02.html "第2章。基本数据类型、数组、循环和条件")中讨论的*基本数据类型、数组、循环和条件*，都是全局对象的方法。考虑以下代码片段：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In addition to being a reference to the global object, the `window` object also
    serves a second purpose-providing information about the browser environment. There's
    a `window` object for every frame, iframe, pop up, or browser tab.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了作为全局对象的引用外，`window`对象还有第二个目的-提供有关浏览器环境的信息。每个框架、iframe、弹出窗口或浏览器选项卡都有一个`window`对象。
- en: Let's see some of the browser-related properties of the `window` object. Again,
    these can vary from one browser to another, so let's only consider the properties
    that are implemented consistently and reliably across all major browsers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`window`对象的一些与浏览器相关的属性。同样，这些属性在不同浏览器中可能会有所不同，因此让我们只考虑在所有主要浏览器中一致可靠实现的属性。
- en: Using window.navigator property
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用window.navigator属性
- en: 'The `navigator` is an object that has some information about the browser and
    its capabilities. One property is `navigator.userAgent`, which is a long string
    of browser identification. In Firefox, you''ll get the following output:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`navigator`是一个对象，其中包含有关浏览器及其功能的一些信息。一个属性是`navigator.userAgent`，它是浏览器标识的长字符串。在Firefox中，您将获得以下输出：'
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `userAgent` string in Microsoft Internet Explorer is something as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在Microsoft Internet Explorer中，`userAgent`字符串如下所示：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As the browsers have different capabilities, developers are using the `userAgent`
    string to identify the browser and provide different versions of the code. For
    example, the following code snippet searches for the presence of the `MSIE` string
    to identify Internet Explorer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浏览器具有不同的功能，开发人员使用`userAgent`字符串来识别浏览器并提供代码的不同版本。例如，以下代码片段搜索`MSIE`字符串的存在以识别Internet
    Explorer：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It''s better not to rely on the `userAgent` string, but to use feature sniffing
    (also called capability detection) instead. The reason for this is that it''s
    hard to keep track of all browsers and their different versions. It''s much easier
    to simply check if the feature you intend to use is indeed available in the user''s
    browser. For example, take a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要依赖`userAgent`字符串，而是使用特性嗅探（也称为能力检测）。原因是很难跟踪所有浏览器及其不同的版本。简单检查您打算在用户的浏览器中使用的功能是否确实可用。例如，看一下以下代码片段：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Another reason to avoid `userAgent` sniffing is that some browsers allow users
    to modify the string and pretend they are using a different browser.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`userAgent`嗅探的另一个原因是，一些浏览器允许用户修改字符串并假装他们正在使用不同的浏览器。
- en: Your console is a cheat sheet
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 您的控制台是一个速查表
- en: 'The console lets you inspect what''s in an object and this includes all the
    BOM and DOM properties. Just type the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台允许您检查对象中的内容，包括所有BOM和DOM属性。只需键入以下代码：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then click on the result. The result is a list of properties and their values,
    as shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后单击结果。结果是属性及其值的列表，如下截图所示：
- en: '![Your console is a cheat sheet](graphics/image_10_001-e1482822786978.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![您的控制台是一个速查表](graphics/image_10_001-e1482822786978.jpg)'
- en: Using window.location property
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用window.location属性
- en: The `location` property points to an object that contains information about
    the URL of the currently loaded page. For example, `location.href` is the full
    URL and `location.hostname` is only the domain. With a simple loop, you can see
    the full list of properties of the `location` object.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`属性指向一个包含有关当前加载页面的URL信息的对象。例如，`location.href`是完整的URL，`location.hostname`只是域名。通过简单的循环，您可以查看`location`对象的完整属性列表。'
- en: 'Imagine you''re on a page with the following URL:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在具有以下URL的页面上：
- en: '[http://search.phpied.com:8080/search?q=java&what=script#results](http://search.phpied.com:8080/search?q=java&what=script#results).'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://search.phpied.com:8080/search?q=java&what=script#results](http://search.phpied.com:8080/search?q=java&what=script#results)。'
- en: 'Consider the following code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: There are also three methods that `location` property provides, namely `reload()`,
    `assign()`, and `replace()`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`location`属性还提供了三种方法，即`reload()`、`assign()`和`replace()`。'
- en: 'It''s interesting how many different ways exist for you to navigate to another
    page. The following are a few ways:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多不同的方法可以让您导航到另一个页面。以下是一些方法：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `replace()` method is almost the same as `assign()`. The difference is
    that it doesn''t create an entry in the browser''s history list as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`replace()`方法与`assign()`几乎相同。不同之处在于它不会在浏览器的历史记录中创建条目，如下所示：'
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To reload a page, you can use the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要重新加载页面，您可以使用以下代码：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Alternatively, you can use `location.href` to point it to itself, as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`location.href`将其指向自身，如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or, simply use the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，只需使用以下代码：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using window.history property
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用window.history属性
- en: 'The `window.history` property allows limited access to the previously visited
    pages in the same browser session. For example, you can see how many pages the
    user has visited before coming to your page, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.history` 属性允许有限访问同一浏览器会话中先前访问的页面。例如，您可以查看用户在访问您的页面之前访问了多少页面，如下所示：'
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You cannot see the actual URLs though. For privacy reasons, this doesn''t work.
    See the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但是你无法看到实际的URL。出于隐私原因，这是行不通的。看下面的代码：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can, however, navigate back and forth through the user''s session as if
    the user had clicked on the back/forward browser buttons, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可以像用户点击后退/前进浏览器按钮一样在用户会话中前后导航，如下所示：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also skip pages back and forth with `history.go()`. This is the same
    as calling `history.back()`. The code for `history.go()` is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `history.go()` 来前后跳转页面。这与调用 `history.back()` 相同。`history.go()` 的代码如下：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To go two pages back, use the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要后退两页，请使用以下代码：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Reload the current page using the following code:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码重新加载当前页面：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'More recent browsers also support HTML5 history API, which lets you change
    the URL without reloading the page. This is perfect for dynamic pages because
    they can allow users to bookmark a specific URL, which represents the state of
    the application, and when they come back, or share with their friends, the page
    can restore the application state based on the URL. To get a sense of the history
    API, go to any page and write the following lines of code in the console:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 更近期的浏览器还支持 HTML5 历史 API，它允许您在不重新加载页面的情况下更改 URL。这对于动态页面非常理想，因为它们可以允许用户收藏特定的 URL，该
    URL 代表应用程序的状态，当他们回来时，或与朋友分享时，页面可以根据 URL 恢复应用程序状态。要了解历史 API 的情况，请转到任何页面并在控制台中编写以下代码行：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice how the URL changes, but the page is the same. Now, experiment with back
    and forward buttons in the browser and inspect the `history.state` object again.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意URL的变化，但页面是相同的。现在，在浏览器中尝试使用后退和前进按钮，并再次检查 `history.state` 对象。
- en: using window.frames property
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `window.frames` 属性
- en: 'The `window.frames` property is a collection of all of the frames in the current
    page. It doesn''t distinguish between frames and iframes (inline frames). Regardless
    of whether there are frames on the page or not, `window.frames` always exists
    and points to `window`, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.frames` 属性是当前页面中所有框架的集合。它不区分框架和 iframe（内联框架）。无论页面上是否有框架，`window.frames`
    都始终存在并指向 `window`，如下所示：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s consider an example where you have a page with one iframe, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个页面有一个 iframe 的例子，如下所示：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In order to tell if there are any frames on the page, you can check the `length`
    property. In case of one iframe, you''ll see the following output:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为了判断页面上是否有任何框架，您可以检查 `length` 属性。在一个 iframe 的情况下，您将看到以下输出：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Each frame contains another page, which has its own global `window` object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 每个框架包含另一个页面，该页面有自己的全局 `window` 对象。
- en: 'To get access to the iframe''s `window`, you can execute any of the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 iframe 的 `window`，可以执行以下任何一个：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'From the parent page, you can access properties of the child frame as well.
    For example, you can reload the frame as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 从父页面，您也可以访问子框架的属性。例如，您可以按如下方式重新加载框架：
- en: '[PRE25]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'From inside the child, you can access the parent as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从子页面内部，您可以按如下方式访问父页面：
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Using a property called `top`, you can access the top-most page-the one that
    contains all the other frames-from within any frame, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名为 `top` 的属性，您可以从任何框架内访问顶部页面-包含所有其他框架的页面，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, `self` is the same as `window`, as you can see in the following
    code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`self` 与 `window` 是相同的，如下面的代码片段所示：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If a frame has a `name` attribute, you cannot only access the frame by name,
    but also by index, as shown in the following piece of code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个框架有一个 `name` 属性，你不仅可以通过名称访问框架，还可以通过索引访问，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Or, alternatively, you can use the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下代码：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using window.screen property
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `window.screen` 属性
- en: 'The `screen` property provides information about the environment outside the
    browser. For example, the `screen.colorDepth` property contains the color bit
    depth (the color quality) of the monitor. This is mostly used for statistical
    purposes. Take a look at the following line of code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`screen` 属性提供有关浏览器外部环境的信息。例如，`screen.colorDepth` 属性包含显示器的颜色位深度（颜色质量）。这主要用于统计目的。看一下以下代码行：'
- en: '[PRE31]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can also check the available screen real estate (the resolution), as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以检查可用的屏幕房地产（分辨率），如下所示：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The difference between `height` and `availHeight` is that `height` is the whole
    screen, while `availHeight` subtracts any operating system menus, such as the
    Windows task bar. The same is the case for `width` and `availWidth`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`height` 和 `availHeight` 之间的区别在于 `height` 是整个屏幕，而 `availHeight` 减去了任何操作系统菜单，例如
    Windows 任务栏。`width` 和 `availWidth` 也是如此。'
- en: 'Somewhat related is the property mentioned in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与下面的代码相关的属性有：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It tells you the difference (ratio) between physical pixels and device pixels
    in the retina displays in mobile devices, for example, value 2 in iPhone.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 它告诉您在移动设备的视网膜显示器中物理像素和设备像素之间的差异（比率），例如，iPhone 中的值为 2。
- en: window.open()/close() method
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`window.open()/close()` 方法'
- en: Having explored some of the most common cross-browser properties of the `window`
    object, let's move to some of the methods. One such method is `open()`, which
    allows you to open new browser windows (pop ups). Various browser policies and
    user settings may prevent you from opening a pop up (due to abuse of the technique
    for marketing purposes), but generally, you should be able to open a new window
    if it was initiated by the user. Otherwise, if you try to open a pop up as the
    page loads, it will most likely be blocked, because the user didn't initiate it
    explicitly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索了`window`对象的一些最常见的跨浏览器属性之后，让我们转向一些方法。其中一种方法是`open()`，它允许你打开新的浏览器窗口（弹出窗口）。各种浏览器策略和用户设置可能会阻止你打开弹出窗口（因为滥用该技术进行营销目的），但通常情况下，如果是用户发起的，你应该能够打开一个新窗口。否则，如果你尝试在页面加载时打开弹出窗口，很可能会被阻止，因为用户没有明确发起它。
- en: 'The `window.open()` method accepts the following parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.open()`方法接受以下参数：'
- en: URL to load in the new window
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在新窗口中加载的URL
- en: Name of the new window that can be used as the value of a form's `target` attribute
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新窗口的名称，可以作为表单`target`属性的值
- en: 'Comma-separated list of features, which is as follows:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以逗号分隔的功能列表，如下所示：
- en: '`resizable`: Should the user be able to resize the new window'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resizable`：用户是否可以调整新窗口的大小'
- en: '`width`, `height`: Width and height of the pop up'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`、`height`：弹出窗口的宽度和高度'
- en: '`status`: Should the status bar be visible'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`status`：状态栏是否可见'
- en: 'The `window.open()` method returns a reference to the `window` object of the
    newly created browser instance. The following is an example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.open()`方法返回对新创建的浏览器实例的`window`对象的引用。以下是一个例子：'
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `win` variable points to the `window` object of the pop up. You can check
    if `win` has a falsy value, which means that the pop up was blocked.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`win`变量指向弹出窗口的`window`对象。你可以检查`win`是否为假值，这意味着弹出窗口被阻止了。'
- en: The `win.close()` method closes the new window.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`win.close()`方法关闭新窗口。'
- en: It's best to stay away from opening new windows for accessibility and usability
    reasons. If you don't like sites popping up windows to you, why do it to your
    users? There are legitimate purposes, such as providing help information while
    filling out a form, but often, the same can be achieved with alternative solutions,
    such as using a floating `<div>` inside the page.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 出于可访问性和可用性原因，最好不要打开新窗口。如果你不喜欢网站给你弹出窗口，为什么要对你的用户这样做呢？有合法的目的，比如在填写表单时提供帮助信息，但通常可以用替代方案实现，比如在页面内使用浮动的`<div>`。
- en: window.moveTo() and window.resizeTo() methods
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: window.moveTo()和window.resizeTo()方法
- en: 'Continuing with the shady practices from the past, the following are more methods
    to irritate your users, provided their browser and personal settings allow you
    to do so:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 继续过去的不良做法，以下是更多方法来激怒你的用户，前提是他们的浏览器和个人设置允许你这样做：
- en: '`window.moveTo(100, 100)`: This moves the browser window to screen location
    `x = 100` and `y = 100`, which is counted from the top-left corner'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.moveTo(100, 100)`：这将浏览器窗口移动到屏幕位置`x = 100`和`y = 100`，从左上角计算'
- en: '`window.moveBy(10, -10)`: This moves the window 10 pixels to the right and
    10 pixels up from its current location'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.moveBy(10, -10)`：这将窗口从当前位置向右移动10像素，向上移动10像素'
- en: '`window.resizeTo(x, y)` and `window.resizeBy(x, y)`: These accept the same
    parameters as the move methods, but they resize the window as opposed to moving
    it'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window.resizeTo(x, y)`和`window.resizeBy(x, y)`：这些方法接受与移动方法相同的参数，但它们调整窗口的大小而不是移动它'
- en: Again, try to solve the problem you're facing without resorting to these methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试解决你面临的问题，而不要求助于这些方法。
- en: window.alert(), window.prompt(), and window.confirm() methods
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: window.alert()、window.prompt()和window.confirm()方法
- en: In [Chapter 2](ch02.html "Chapter 2. Primitive Data Types, Arrays, Loops, and
    Conditions"), *Primitive Data Types, Arrays, Loops, and Conditions*, we talked
    about the `alert()` function. Now you know that global functions are accessible
    as methods of the global object, so `alert('Watch` `out!')` and `window.alert('Watch`
    `out!')` are exactly the same.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。基本数据类型、数组、循环和条件")中，*基本数据类型、数组、循环和条件*，我们讨论了`alert()`函数。现在你知道全局函数可以作为全局对象的方法访问，所以`alert('小心')`和`window.alert('小心')`是完全相同的。
- en: 'The `alert()` function is not an ECMAScript function but a BOM method. In addition
    to it, two other BOM methods allow you to interact with the user through system
    messages. The following are the methods:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`alert()`函数不是ECMAScript函数，而是BOM方法。除此之外，还有两个BOM方法允许你通过系统消息与用户交互。以下是这些方法：'
- en: '`confirm()`: This gives the user two options, **OK** and **Cancel**'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`confirm()`：这给用户两个选项，**确定**和**取消**'
- en: '`prompt()`: This collects textual input'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prompt()`：这收集文本输入'
- en: 'This is how it works:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理如下：
- en: '[PRE35]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'It presents you with a window similar to the following screenshot (the exact
    look depends on the browser and the operating system):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它会显示一个类似于以下截图的窗口（确切的外观取决于浏览器和操作系统）：
- en: '![window.alert(), window.prompt(), and window.confirm() methods](graphics/image_10_002.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![window.alert(), window.prompt(), and window.confirm() methods](graphics/image_10_002.jpg)'
- en: 'You''ll notice the following things:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到以下几点：
- en: Nothing gets written to the console until you close this message, which means
    that any JavaScript code execution freezes, waiting for the user's answer
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在关闭此消息之前，不会有任何内容写入控制台，这意味着任何JavaScript代码执行都会被冻结，等待用户的答复
- en: Clicking on **OK** returns `true`, clicking on **Cancel** or closing the message
    using the **X** icon, or the **ESC** key, returns `false`
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击**确定**返回`true`，点击**取消**或使用**X**图标关闭消息，或按下**ESC**键，返回`false`。
- en: 'This is handy to confirm user actions, as shown in the following piece of code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于确认用户操作非常方便，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Make sure you provide an alternative way to confirm user actions for people
    who have disabled JavaScript, or for search engine spiders.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为禁用JavaScript的用户或搜索引擎蜘蛛提供确认用户操作的替代方法。
- en: 'The `window.prompt()` method presents the user with a dialog to enter text,
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.prompt()`方法向用户显示一个对话框，让其输入文本，如下所示：'
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This results in the following dialog box (Chrome, MacOS):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下对话框（Chrome，MacOS）：
- en: '![window.alert(), window.prompt(), and window.confirm() methods](graphics/image_10_003-e1482823176627.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![window.alert(), window.prompt(), and window.confirm() methods](graphics/image_10_003-e1482823176627.jpg)'
- en: 'The value of `answer` is one of the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`answer`的值是以下之一：'
- en: '`null`: This happens if you click on **Cancel**, the **X** icon, or press **ESC**
    key'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`：如果你点击**Cancel**，**X**图标，或按**ESC**键，就会发生这种情况。'
- en: '`""` (empty string): This happens if you click on OK or press Enter without
    typing anything'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）：如果你点击**OK**或按下没有输入任何内容的**Enter**'
- en: 'A text string: This is if you type something and then click on **OK** or press
    **Enter**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本字符串：如果你输入一些内容然后点击**OK**或按**Enter**
- en: The function also takes a string as a second parameter and displays it as a
    default value prefilled into the input field.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数还接受一个字符串作为第二个参数，并将其显示为预填充到输入字段中的默认值。
- en: Using window.setTimeout() and window.setInterval() methods
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用window.setTimeout()和window.setInterval()方法
- en: The `setTimeout()`and `setInterval()` methods allow scheduling the execution
    of a piece of code. The `setTimeout()` method attempts to execute the given code
    once, after a specified number of milliseconds. The `setInterval()` method attempts
    to execute it repeatedly after a specified number of milliseconds has passed.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout()`和`setInterval()`方法允许安排执行一段代码。`setTimeout()`方法尝试在指定的毫秒数后执行给定的代码一次。`setInterval()`方法尝试在指定的毫秒数后重复执行它。'
- en: 'This shows an alert after approximately 2 seconds (2000 milliseconds). Consider
    the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在大约2秒后（2000毫秒）显示一个警报。考虑以下代码：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you can see, the function returned an integer (in this case, `4`) representing
    the ID of the timeout. You can use this ID to cancel the timeout using `clearTimeout()`.
    In the following example, if you''re quick enough, and clear the timeout before
    2 seconds have passed, the alert will never be shown, as you can see in the following
    code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该函数返回了一个整数（在这种情况下是`4`），表示超时的ID。你可以使用这个ID来使用`clearTimeout()`取消超时。在以下示例中，如果你足够快，并在2秒钟之前清除超时，警报将永远不会显示，就像你在以下代码中看到的那样：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s change `boo()`to something less intrusive, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`boo()`改为更不具侵入性的东西，如下所示：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, using `setInterval()`, you can schedule `boo()` to execute every 2 seconds,
    until you cancel the scheduled execution with `clearInterval()`. Consider the
    following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用`setInterval()`，你可以安排`boo()`每2秒执行一次，直到你用`clearInterval()`取消安排的执行。考虑以下代码：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that both functions accept a pointer to a callback function as a first
    parameter. They can also accept a string, which is evaluated with `eval();` however,
    as you know, `eval()` is evil, so it should be avoided. Moreover, what if you
    want to pass arguments to the function? In such cases, you can just wrap the function
    call inside another function.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这两个函数都接受一个回调函数的指针作为第一个参数。它们也可以接受一个字符串，该字符串将使用`eval()`进行评估；然而，正如你所知，`eval()`是邪恶的，所以应该避免使用。此外，如果你想向函数传递参数怎么办？在这种情况下，你可以将函数调用包装在另一个函数中。
- en: 'The following code is valid, but not recommended:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是有效的，但不建议使用：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This alternative is preferred:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个替代方案更受欢迎：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Be aware that scheduling a function in some amount of milliseconds is not a
    guarantee that it will execute exactly at that time. One reason is that most browsers
    don't have millisecond resolution time. If you schedule something in 3 milliseconds,
    it will execute after a minimum of 15 in older IEs and sooner in more modern browsers,
    but most likely, not in 1 millisecond. The other reason is that the browsers maintain
    a queue of what you request them to do. 100 milliseconds timeout means add to
    the queue after 100 milliseconds. However, if the queue is delayed by something
    slow happening, your function will have to wait and execute after, say, 120 milliseconds.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，安排一个函数在一定的毫秒数后执行并不保证它会准确地在那个时间执行。一个原因是大多数浏览器没有毫秒分辨率的时间。如果你安排在3毫秒后执行某事，在较旧的IE中至少要等待15毫秒，而在更现代的浏览器中会更快，但很可能不会在1毫秒内执行。另一个原因是浏览器维护一个你要求它们执行的队列。100毫秒的超时意味着在100毫秒后添加到队列中。然而，如果队列被某些慢的事情延迟了，你的函数将不得不等待并在之后执行，比如说在120毫秒后。
- en: 'More recent browsers implement the `requestAnimationFrame()` function. It''s
    preferable to the timeout functions because you''re asking the browser to call
    your function whenever it has available resources, not after a predefined time
    in milliseconds. Try executing the following code snippet in your console:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 更近期的浏览器实现了`requestAnimationFrame()`函数。它比超时函数更可取，因为你要求浏览器在有可用资源时调用你的函数，而不是在预定义的毫秒时间之后。尝试在控制台中执行以下代码片段：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: window.document property
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: window.document属性
- en: The `window.document` property is a BOM object that refers to the currently
    loaded document (page). Its methods and properties fall into the DOM category
    of objects. Take a deep breath (and maybe first look at the BOM exercises at the
    end of the chapter) and let's dive into the DOM.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`window.document`属性是一个BOM对象，指的是当前加载的文档（页面）。它的方法和属性属于DOM对象的范畴。深呼吸一下（也许先看一下本章末尾的BOM练习），然后让我们深入了解DOM。'
- en: DOM
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DOM
- en: The DOM represents an XML or an HTML document as a tree of nodes. Using DOM
    methods and properties, you can access any element on the page, modify or remove
    elements, or add new ones. The DOM is a language-independent API and can be implemented
    not only in JavaScript, but also in any other language. For example, you can generate
    pages on the server-side with PHP's DOM implementation ([http://php.net/dom](http://php.net/dom)).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: DOM将XML或HTML文档表示为节点树。使用DOM方法和属性，你可以访问页面上的任何元素，修改或删除元素，或添加新元素。DOM是一种与语言无关的API，不仅可以在JavaScript中实现，还可以在任何其他语言中实现。例如，你可以使用PHP的DOM实现（[http://php.net/dom](http://php.net/dom)）在服务器端生成页面。
- en: 'Take a look at this example HTML page:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下这个示例HTML页面：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Consider the second paragraph `(<p><em>second</em> paragraph</p>`). You will
    see that it''s a `<p>` tag, and it''s contained in the `<body>` tag. If you think
    in terms of family relationships, you can say that `<body>` is the parent of `<p>`
    and `<p>` is the child. The first and the third paragraphs would also be children
    of the `<body>` tag, and at the same time, siblings of the second paragraph. The
    `<em>` tag is a child of the second `<p>`, so `<p>` is its parent. The parent-child
    relationships can be represented graphically in an ancestry tree, called the DOM
    tree:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑第二段（<p><em>第二</em>段</p>）。您会看到它是一个<p>标签，并且包含在<body>标签中。如果您从家庭关系的角度思考，您可以说<body>是<p>的父级，<p>是子级。第一和第三段也将是<body>标签的子级，并且与第二段同时是兄弟姐妹。<em>标签是第二个<p>的子级，因此<p>是其父级。父子关系可以在一个称为DOM树的祖先树中以图形方式表示：
- en: '![DOM](graphics/image_10_004.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![DOM](graphics/image_10_004.jpg)'
- en: The previous screenshot shows what you'll see in the WebKit console's **Elements**
    tab after you expand each node.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的屏幕截图显示了在WebKit控制台的**元素**选项卡中展开每个节点后会看到的内容。
- en: You can see how all of the tags are shown as expandable nodes on the tree. Although
    not shown, there exists the so-called text nodes, for example, the text inside
    the `<em>` tag (the word second) is a text node. Whitespace is also considered
    a text node. Comments inside the HTML code are also nodes in the tree, the `<!-
    and that's about it ->` comment in the HTML source is a comment node in the tree.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到所有标签都显示为树上可展开的节点。尽管没有显示，但存在所谓的文本节点，例如`<em>`标签内的文本（单词second）是一个文本节点。空格也被视为文本节点。HTML代码中的注释也是树中的节点，HTML源代码中的`<!-
    and that's about it ->`注释是树中的注释节点。
- en: 'Every node in the DOM tree is an object and the **Properties** section on the
    right lists all of the properties and methods you can use to work with these objects,
    following the inheritance chain of how this object was created:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: DOM树中的每个节点都是一个对象，右侧的**属性**部分列出了您可以使用的所有属性和方法，遵循了创建此对象的继承链：
- en: '![DOM](graphics/image_10_005.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![DOM](graphics/image_10_005.jpg)'
- en: You can also see the constructor function that was used behind the scenes to
    create each of these objects. Although, this is not too practical for day-to-day
    tasks, it may be interesting to know that, for example, `<p>` is created by the
    `HTMLParagraphElement()` constructor, the object that represents the `head` tag
    is created by `HTMLHeadElement()`, and so on. You cannot create objects using
    these constructors directly, though.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到在幕后使用的构造函数来创建这些对象。尽管这对日常任务来说并不太实用，但知道例如`<p>`是由`HTMLParagraphElement()`构造函数创建的，表示`head`标签的对象是由`HTMLHeadElement()`创建的等等可能会很有趣。但是，您不能直接使用这些构造函数创建对象。
- en: Core DOM and HTML DOM
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心DOM和HTML DOM
- en: 'One last diversion before moving on to more practical examples. As you now
    know, the DOM represents both XML documents and HTML documents. In fact, HTML
    documents are XML documents, but a little more specific. Therefore, as part of
    DOM Level 1, there is a Core DOM specification that is applicable to all XML documents,
    and there is also an HTML DOM specification, which extends and builds upon the
    core DOM. Of course, the HTML DOM doesn''t apply to all XML documents, but only
    to HTML documents. Let''s see some examples of Core DOM and HTML DOM constructors:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续更实际的示例之前，最后再偏离一下。正如您现在所知，DOM代表XML文档和HTML文档。实际上，HTML文档是XML文档，但更具体。因此，作为DOM
    Level 1的一部分，有一个适用于所有XML文档的核心DOM规范，还有一个HTML DOM规范，它扩展并构建在核心DOM之上。当然，HTML DOM并不适用于所有XML文档，而只适用于HTML文档。让我们看一些核心DOM和HTML
    DOM构造函数的示例：
- en: '| **Constructor** | **Inherits from** | **Core or HTML** | **Comment** |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| **构造函数** | **继承自** | **核心或HTML** | **注释** |'
- en: '| --- | --- | --- | --- |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `Node` |  | Core | Any node on the tree |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `Node` |  | 核心 | 树上的任何节点 |'
- en: '| `Document` | `Node` | Core | The document object, the main entry point to
    any XML document |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `Document` | `Node` | 核心 | 文档对象，任何XML文档的主要入口点 |'
- en: '| `HTMLDocument` | `Document` | HTML | This is window.document or simply document,
    the HTML-specific version of the previous object, which you''ll use extensively
    |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLDocument` | `Document` | HTML | 这是window.document或简单地document，前一个对象的HTML特定版本，您将广泛使用它
    |'
- en: '| `Element` | `Node` | Core | Every tag in the source is represented by an
    element. That''s why you say-the `P` element meaning the `<p></p>` tag |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `Element` | `Node` | 核心 | 源代码中的每个标签都由一个元素表示。这就是为什么您说-`P`元素表示`<p></p>`标签 |'
- en: '| `HTMLElement` | `Element` | HTML | General-purpose constructor, all constructors
    for HTML elements inherit from it |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLElement` | `Element` | HTML | 通用构造函数，所有HTML元素的构造函数都继承自它 |'
- en: '| `HTMLBodyElement` | `HTMLElement` | HTML | Element representing the `<body>`
    tag |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLBodyElement` | `HTMLElement` | HTML | 表示`<body>`标签的元素 |'
- en: '| `HTMLLinkElement` | `HTMLElement` | HTML | An A element: an `<a href="..."></a>`
    tag |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLLinkElement` | `HTMLElement` | HTML | A元素：`<a href="..."></a>`标签 |'
- en: '| And other such constructors | `HTMLElement` | HTML | All the rest of the
    HTML elements |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 和其他构造函数 | `HTMLElement` | HTML | 所有其他HTML元素 |'
- en: '| `CharacterData` | `Node` | Core | General-purpose constructor for dealing
    with texts |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `CharacterData` | `Node` | 核心 | 用于处理文本的通用构造函数 |'
- en: '| `Text` | `CharacterData` | Core | Text node inside a tag; in `<em>`second`</em>`,
    you have the element node `EM` and the text node with value second |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `Text` | `CharacterData` | 核心 | 标签内的文本节点；在`<em>`second`</em>`中，您有元素节点`EM`和值为second的文本节点
    |'
- en: '| `Comment` | `CharacterData` | Core | `<!-- any comment -->` |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `Comment` | `CharacterData` | 核心 | `<!-- 任何注释 -->` |'
- en: '| `Attr` | `Node` | Core | Represents an attribute of a tag; in `<p id="closer">`,
    the `id` attribute is a DOM object created by the `Attr()` constructor |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `Attr` | `Node` | 核心 | 表示标签的属性；在`<p id="closer">`中，`id`属性是由`Attr()`构造函数创建的DOM对象
    |'
- en: '| `NodeList` |  | Core | A list of nodes, an array-like object that has a `length`
    property |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `NodeList` |  | 核心 | 节点列表，具有`length`属性的类似数组的对象 |'
- en: '| `NamedNodeMap` |  | Core | Same as `NodeList`, but the nodes can be accessed
    by name, not only by numeric index. |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `NamedNodeMap` |  | 核心 | 与 `NodeList` 相同，但节点可以通过名称访问，而不仅仅是通过数字索引。'
- en: '| `HTMLCollection` |  | HTML | Similar to `NamedNodeMap` but specific for HTML.
    |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `HTMLCollection` |  | HTML | 类似于 `NamedNodeMap`，但专门用于 HTML。'
- en: These are, by no means, all of the Core DOM and HTML DOM objects. For the full
    list, consult [http://www.w3.org/TR/DOM-Level-1/](http://www.w3.org/TR/DOM-Level-1/).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绝不是所有核心 DOM 和 HTML DOM 对象。 要获取完整列表，请参阅 [http://www.w3.org/TR/DOM-Level-1/](http://www.w3.org/TR/DOM-Level-1/)。
- en: 'Now that this bit of the DOM theory is behind you, let''s focus on the practical
    side of working with the DOM. In the following sections, you''ll learn how to
    do the following topics:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 既然 DOM 理论的这一部分已经过去了，让我们专注于处理 DOM 的实际方面。 在接下来的几节中，您将学习以下主题：
- en: Access DOM nodes
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 DOM 节点
- en: Modify nodes
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改节点
- en: Create new nodes
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新节点
- en: Remove nodes
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除节点
- en: Accessing DOM nodes
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 DOM 节点
- en: Before you can validate the user input in a form on a page or swap an image,
    you need to get access to the element you want to inspect or modify. Luckily,
    there are many ways to get to any element, either by navigating around traversing
    the DOM tree or by using a shortcut.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以验证页面上表单中的用户输入或交换图像之前，您需要访问要检查或修改的元素。 幸运的是，有许多方法可以访问任何元素，无论是通过导航遍历 DOM 树还是使用快捷方式。
- en: It's best if you start experimenting with all of the new objects and methods.
    The examples you'll see use the same simple document that you saw at the beginning
    of the DOM section, and which you can access at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    Open your console, and let's get started.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最好是您开始尝试所有新对象和方法。 您将看到的示例使用了与 DOM 部分开头看到的相同简单文档，您可以在 [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)
    上访问。 打开控制台，让我们开始吧。
- en: The document node
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文档节点
- en: 'The `document` node gives you access to the current document. To explore this
    object, you can use your console as a cheat sheet. Type `console.dir`(document)
    and click on the result:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`document` 节点使您可以访问当前文档。 要探索此对象，您可以使用控制台作为备忘单。 输入 `console.dir`(document) 并单击结果：'
- en: '![The document node](graphics/image_10_006.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![文档节点](graphics/image_10_006.jpg)'
- en: 'Alternatively, you can browse all of the properties and methods of the `document`
    object DOM properties in the **Elements** panel:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在**元素**面板中浏览 `document` 对象 DOM 属性的所有属性和方法：
- en: '![The document node](graphics/image_10_007.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![文档节点](graphics/image_10_007.jpg)'
- en: 'All nodes, including the document node, text nodes, element nodes, and attribute
    nodes have `nodeType`, `nodeName` and `nodeValue` properties:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点，包括文档节点、文本节点、元素节点和属性节点都有 `nodeType`、`nodeName` 和 `nodeValue` 属性：
- en: '[PRE46]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: There are 12 node types, represented by integers. As you can see, the document
    node type is `9`. The most commonly used are `1` (element), `2` (attribute), and
    `3` (text).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有 12 种节点类型，用整数表示。 如您所见，文档节点类型是 `9`。 最常用的是 `1`（元素）、`2`（属性）和 `3`（文本）。
- en: 'Nodes also have names. For HTML tags, the node name is the tag name (`tagName`
    property). For text nodes, it''s `#text`, and for document nodes, the name is
    as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也有名称。 对于 HTML 标签，节点名称是标签名称（`tagName` 属性）。 对于文本节点，它是 `#text`，对于文档节点，名称如下：
- en: '[PRE47]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Nodes can also have node values. For example, for text nodes, the value is
    the actual text. The document node doesn''t have a value, which can be seen as
    follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 节点也可以有节点值。 例如，对于文本节点，值是实际文本。 文档节点没有值，可以如下所示：
- en: '[PRE48]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: documentElement
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: documentElement
- en: Now, let's move around the tree. XML documents always have one root node that
    wraps the rest of the document. For HTML documents, the root is the `<html>` tag.
    To access the root, you will use the `documentElement` property of the `document`
    object.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在树中移动。 XML 文档始终有一个根节点，用于包装文档的其余部分。 对于 HTML 文档，根是 `<html>` 标签。 要访问根，您将使用
    `document` 对象的 `documentElement` 属性。
- en: '[PRE49]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '`nodeType` is `1` (an element node) which can be seen as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodeType` 是 `1`（元素节点），可以如下所示：'
- en: '[PRE50]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'For element nodes, both `nodeName` and `tagName` properties contain the name
    of the tag, as seen in the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于元素节点，`nodeName` 和 `tagName` 属性都包含标签的名称，如下所示：
- en: '[PRE51]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Child nodes
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子节点
- en: 'In order to tell if a node has any children, you will use `hasChildNodes()`,
    as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定节点是否有任何子节点，您将使用 `hasChildNodes()`，如下所示：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The HTML element has three children, the `head` and the `body` elements and
    the whitespace between them (whitespace is counted in most, but not all browsers).
    You can access them using the `childNodes` array-like collection, as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 元素有三个子节点，`head` 和 `body` 元素以及它们之间的空格（在大多数浏览器中计算空格）。 您可以使用 `childNodes`
    类似数组的集合来访问它们，如下所示：
- en: '[PRE53]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Any child has access to its parent through the `parentNode` property, as seen
    in the following code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 任何子节点都可以通过 `parentNode` 属性访问其父节点，如下所示：
- en: '[PRE54]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s assign a reference to body to a variable, as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将 body 的引用分配给一个变量，如下所示：
- en: '[PRE55]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: How many children does the `body` element have? Consider the following piece
    of code
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '`body` 元素有多少子节点？ 考虑以下代码片段'
- en: '[PRE56]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As a refresher, here, again, is the body of the document:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 作为复习，这里是文档的主体：
- en: '[PRE57]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How come body has `9` children? Well, three paragraphs plus one comment makes
    four nodes. The whitespace between these four nodes makes three more text nodes.
    This makes a total of seven so far. The whitespace between `<body>` and the first
    `<p>` is the eighth node. The whitespace between the comment and the closing `</body>`
    is another text node. This makes a total of nine child nodes. Just type `bd.childNodes`
    in the console to inspect them all.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么 `body` 有 `9` 个子节点？ 好吧，三个段落加上一个注释共四个节点。 这四个节点之间的空格产生了另外三个文本节点。 到目前为止总共有七个。
    `<body>` 和第一个 `<p>` 之间的空格是第八个节点。 注释和闭合 `</body>` 之间的空格是另一个文本节点。 这样总共有九个子节点。 只需在控制台中键入
    `bd.childNodes` 来检查它们。
- en: Attributes
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性
- en: 'As the first child of the body is a whitespace, the second child (index 1)
    is the first paragraph. Refer to the following piece of code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于body的第一个子节点是空格，因此第二个子节点（索引1）是第一个段落。请参考以下代码片段：
- en: '[PRE58]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You can check whether an element has attributes using `hasAttributes()`, as
    follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`hasAttributes()`来检查元素是否具有属性，如下所示：
- en: '[PRE59]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'How many attributes? In this example, one is the `class` attribute, which can
    be seen as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有多少属性？在这个例子中，一个是`class`属性，可以如下所示：
- en: '[PRE60]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can access the attributes by index and name. You can also get the value
    using the `getAttribute()` method, which is as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按索引和名称访问属性。您还可以使用`getAttribute()`方法获取值，如下所示：
- en: '[PRE61]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Accessing the content inside a tag
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问标签内的内容
- en: 'Let''s take a look at the first paragraph:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看第一段：
- en: '[PRE62]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'You can get the text contained in the paragraph using the `textContent` property.
    It doesn''t exist in older IEs, but another property called `innerText` returns
    the same value, as seen in the following output:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`textContent`属性获取段落中包含的文本。它在旧版IE中不存在，但另一个名为`innerText`的属性返回相同的值，如下输出所示：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'There is also the `innerHTML` property. It''s a relatively new addition to
    the DOM standard, despite the fact that it previously existed in all major browsers.
    It returns (or sets) HTML code contained in a node. You can see how this is a
    little inconsistent as DOM treats the document as a tree of nodes, not as a string
    of tags. However, `innerHTML` is so convenient to use that you''ll see it everywhere.
    Refer to the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`innerHTML`属性。尽管它以前存在于所有主要浏览器中，但它是DOM标准的一个相对较新的添加。它返回（或设置）节点中包含的HTML代码。您可以看到这有点不一致，因为DOM将文档视为节点树，而不是标签字符串。然而，`innerHTML`非常方便使用，您会在各处看到它。请参考以下代码：
- en: '[PRE64]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The first paragraph contains only text, so `innerHTML` is the same as `textContent`
    (or `innerText` in IE). However, the second paragraph does contain an `em` node,
    so you can see the difference as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段只包含文本，所以`innerHTML`与`textContent`（或IE中的`innerText`）相同。然而，第二段包含一个`em`节点，因此您可以如下所示看到差异：
- en: '[PRE65]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Another way to get the text contained in the first paragraph is by using the
    `nodeValue` method of the text node contained inside the `p` node, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种获取第一段中包含的文本的方法是使用`p`节点内包含的文本节点的`nodeValue`方法，如下所示：
- en: '[PRE66]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: DOM access shortcuts
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DOM访问快捷方式
- en: Using `childNodes`, `parentNode`, `nodeName`, `nodeValue`, and `attributes`,
    you can navigate up and down the tree and do anything with the document. However,
    the fact that whitespace is a text node makes this a fragile way of working with
    the DOM. If the page changes, your script may no longer work correctly. Also,
    if you want to get to a node deeper in the tree, it could take a bit of code before
    you get there. That's why you have shortcut methods, namely, `getElementsByTagName()`,
    `getElementsByName()`, and `getElementById()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`childNodes`、`parentNode`、`nodeName`、`nodeValue`和`attributes`，您可以在树中上下导航并对文档进行任何操作。然而，空格是文本节点的事实使得这种处理DOM的方式很脆弱。如果页面发生变化，您的脚本可能不再正确工作。此外，如果要深入树中的节点，可能需要一些代码才能到达那里。这就是为什么有快捷方式方法，即`getElementsByTagName()`、`getElementsByName()`和`getElementById()`。
- en: 'The `getElementsByTagName()` method takes a tag name (the name of an element
    node) and returns an HTML collection (array-like object) of nodes with the matching
    tag name. For example, the following example asks-give me a count of all paragraphs,
    which is given as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`getElementsByTagName()`方法接受一个标签名称（元素节点的名称）并返回一个匹配标签名称的节点的HTML集合（类似数组的对象）。例如，以下示例要求给出所有段落的计数，如下所示：'
- en: '[PRE67]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can access an item in the list using the brackets notation, or the `item()`method,
    and passing the index (0 for the first element). Using `item()` is discouraged,
    as array brackets are more consistent and also shorter to type. Refer to the following
    piece of code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用括号表示法或`item()`方法访问列表中的项目，并传递索引（第一个元素为0）。使用`item()`是不鼓励的，因为数组括号更一致，而且输入更短。请参考以下代码片段：
- en: '[PRE68]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Getting the contents of the first `p` can be done as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 获取第一个`p`的内容可以如下所示：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Accessing the last `p` can be done as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 访问最后一个`p`可以如下所示：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To access the attributes of an element, you can use the `attributes` collection
    or `getAttribute()`, as shown previously. However, a shorter way is to use the
    attribute name as a property of the element you''re working with. So, to get the
    value of the `id` attribute, you will just use `id` as a property, which is as
    follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问元素的属性，您可以使用`attributes`集合或`getAttribute()`，如前所示。但是，更简洁的方法是将属性名称作为要处理的元素的属性。因此，要获取`id`属性的值，您只需将`id`作为属性使用，如下所示：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Getting the `class` attribute of the first paragraph won''t work though. It''s
    an exception because it just happens so that class is a reserved word in ECMAScript.
    You can use `className` instead, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，无法获取第一段的`class`属性。这是一个例外，因为在ECMAScript中class是一个保留字。您可以使用`className`代替，如下所示：
- en: '[PRE72]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Using `getElementsByTagName()`, you can get all of the elements on the page,
    as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getElementsByTagName()`，您可以获取页面上的所有元素，如下所示：
- en: '[PRE73]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In earlier versions of IE before IE7, `*` is not acceptable as a tag name. To
    get all elements, you can use IE's proprietary `document.all` collection, although,
    selecting every element is rarely needed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在IE7之前的早期版本中，`*`作为标签名称是不可接受的。要获取所有元素，可以使用IE的专有`document.all`集合，尽管很少需要选择每个元素。
- en: 'The other shortcut mentioned is `getElementById()`. This is probably the most
    common way of accessing an element. You just assign IDs to the elements you plan
    to play with and they''ll be easy to access later on, as seen in the following
    code:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个提到的快捷方式是`getElementById()`。这可能是访问元素的最常见方法。您只需为要处理的元素分配ID，以后访问它们会很容易，如下代码所示：
- en: '[PRE74]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Additional shortcut methods in more recent browsers include the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 更近期浏览器中的其他快捷方式方法包括以下内容：
- en: '`getElementByClassName()`:This method finds elements using their class attribute'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getElementByClassName()`:此方法使用其class属性查找元素'
- en: '`querySelector()`: This method finds an element using a CSS selector string'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelector()`:该方法使用CSS选择器字符串查找元素'
- en: '`querySelectorAll()`: This method is the same as the previous one but returns
    all matching elements, not just the first'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`querySelectorAll()`:该方法与前一个方法相同，但返回所有匹配的元素，而不仅仅是第一个'
- en: Siblings, body, first, and last child
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 兄弟节点、body、第一个和最后一个子节点
- en: 'The `nextSibling` and `previousSibling` are two other convenient properties
    to navigate the DOM tree once you have a reference to one element. Consider the
    following code:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了对一个元素的引用，`nextSibling`和`previousSibling`是另外两个方便的属性，用于导航DOM树。考虑以下代码：
- en: '[PRE75]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `body` element is used so often that it has its own shortcut, which is
    as follows:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`body`元素经常使用，因此它有自己的快捷方式，如下所示：'
- en: '[PRE76]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `firstChild` and `lastChild` properties are also convenient. The `firstChild`
    property is the same as `childNodes[0]` and `lastChild` is the same as `childNodes[childNodes.length
    - 1]` properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstChild`和`lastChild`属性也很方便。`firstChild`属性与`childNodes[0]`相同，`lastChild`与`childNodes[childNodes.length
    - 1]`属性相同：'
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The following screenshot shows the family relationships between the body and
    the three paragraphs in it. For simplicity, all the whitespace text nodes are
    removed from the screenshot:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了body和其中三个段落之间的家族关系。为简单起见，屏幕截图中删除了所有空白文本节点：
- en: '![Siblings, body, first, and last child](graphics/image_10_008.jpg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![兄弟节点、body、第一个和最后一个子节点](graphics/image_10_008.jpg)'
- en: Walk the DOM
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 遍历DOM
- en: 'To wrap up, here''s a function that takes any node and walks through the DOM
    tree recursively, starting from the given node, as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，以下是一个函数，它接受任何节点并从给定节点开始递归地遍历DOM树，如下所示：
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You can test the function as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下方式测试该函数：
- en: '[PRE79]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Modifying DOM nodes
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改DOM节点
- en: 'Now that you know a whole lot of methods to access any node of the DOM tree
    and its properties, let''s see how you can modify these nodes:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了访问DOM树及其属性的许多方法，让我们看看如何修改这些节点：
- en: 'Let''s assign a pointer to the last paragraph to the variable `my`, as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将指针分配给最后一个段落，变量名为`my`，如下所示：
- en: '[PRE80]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, changing the text of the paragraph can be as easy as changing the `innerHTML`
    value, which is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，更改段落的文本可以像更改`innerHTML`值一样简单，如下所示：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'As `innerHTML` accepts a string of HTML source code, you can also create a
    new `em` node in the DOM tree as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`innerHTML`接受HTML源代码的字符串，因此您也可以按照以下方式在DOM树中创建新的`em`节点：
- en: '[PRE82]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The new `em` node becomes a part of the tree. Lets take a look at the following
    code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`em`节点成为树的一部分。让我们看一下以下代码：
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Another way to change text is to get the actual text node and change its `nodeValue`,
    as shown in the following piece of code:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 改变文本的另一种方法是获取实际的文本节点并更改其`nodeValue`，如下所示：
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Modifying styles
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改样式
- en: 'Often you don''t change the content of a node, but its presentation. The elements
    have a `style` property, which in turn has a property mapped to each CSS property.
    For example, changing the style of the paragraph to add a red border, as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 通常您不会更改节点的内容，而是更改其呈现方式。元素具有`style`属性，该属性又具有映射到每个CSS属性的属性。例如，更改段落的样式以添加红色边框，如下所示：
- en: '[PRE85]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'CSS properties often have dashes, but dashes are not acceptable in JavaScript
    identifiers. In such cases, you skip the dash and uppercase the next letter. So,
    `padding-top` becomes `paddingTop`, `margin-left` becomes `marginLeft`, and so
    on. Take a look at the following code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: CSS属性通常带有破折号，但是在JavaScript标识符中破折号是不可接受的。在这种情况下，您跳过破折号并将下一个字母大写。因此，`padding-top`变成了`paddingTop`，`margin-left`变成了`marginLeft`，等等。看一下以下代码：
- en: '[PRE86]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You also have access to the `cssText` property of `style`, which lets you work
    with styles as strings, as you can see in the following code snippet:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以访问`style`的`cssText`属性，它允许您将样式作为字符串进行处理，如下所示：
- en: '[PRE87]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Moreover, modifying styles is a string manipulation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，修改样式是一种字符串操作：
- en: '[PRE88]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Fun with forms
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单乐趣
- en: 'As mentioned earlier, JavaScript is great for client-side input validation
    and can save a few round-trip to the server. Let''s practice form manipulations
    and play a little bit with a form located on a popular page, [www.google.com](http://www.google.com):'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，JavaScript非常适合客户端输入验证，并且可以节省几次往返服务器。让我们练习表单操作，并在一个流行页面上玩一下，[www.google.com](http://www.google.com)上的表单：
- en: '![Fun with forms](graphics/image_10_009.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![玩转表单](graphics/image_10_009.jpg)'
- en: 'Finding the first text input using the `querySelector()` method and a CSS selector
    string is as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`querySelector()`方法和CSS选择器字符串查找第一个文本输入的方法如下：
- en: '[PRE89]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Accessing the search box. Consider the following code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 访问搜索框。考虑以下代码：
- en: '[PRE90]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Changing the search query by setting the text contained in the `value` attribute
    is done as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`value`属性中包含的文本来更改搜索查询的结果如下所示：
- en: '[PRE91]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, let''s have some fun and change the word **Lucky** with **Tricky** in
    the button:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩得开心，将按钮中的**Lucky**更改为**Tricky**：
- en: '[PRE92]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '![Fun with forms](graphics/image_10_010.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![玩转表单](graphics/image_10_010.jpg)'
- en: 'Now, let''s implement the tricky part and make that button show and hide for
    one second. You can do this with a simple function. Let''s call it `toggle()`.
    Every time you call the function, it checks the value of the CSS property `visibility`,
    and sets it to visible if it''s hidden and vice versa using the following code
    snippet:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现一些技巧，并使该按钮在一秒钟内显示和隐藏。您可以使用一个简单的函数来实现这一点。让我们称之为`toggle()`。每次调用该函数时，它都会检查CSS属性`visibility`的值，并使用以下代码片段将其设置为可见（如果它是隐藏的）或相反：
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Instead of calling the function manually, let''s set an interval and call it
    every second:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 不要手动调用该函数，让我们设置一个间隔，每秒调用一次：
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The result? The button starts blinking, making it trickier to click. When you''re
    tired of chasing it, just remove the timeout interval by writing the following
    line of code:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 结果？按钮开始闪烁，使得点击变得更加困难。当您厌倦追逐它时，只需编写以下代码来删除超时间隔：
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Creating new nodes
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新节点
- en: To create new nodes, you can use the `createElement()` and `createTextNode()`
    methods. Once you have the new nodes, you can add them to the DOM tree using `appendChild()`,
    `insertBefore()`, or `replaceChild()`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新节点，可以使用`createElement()`和`createTextNode()`方法。一旦有了新节点，可以使用`appendChild()`、`insertBefore()`或`replaceChild()`将它们添加到DOM树中。
- en: Reload [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)
    and let's play.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载[http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)，让我们来玩一下。
- en: 'Create a new `p` element and set its `innerHTML`, as shown in the following
    code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`p`元素并设置其`innerHTML`，如下所示：
- en: '[PRE96]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'The new element automatically gets all the default properties, such as `style`,
    which you can modify as follows:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素自动获得所有默认属性，比如`style`，你可以按照以下方式修改它：
- en: '[PRE97]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Using `appendChild()`, you can add the new node to the DOM tree. Calling this
    method on the `document.body` node means creating one more child node right after
    the last child, as follows:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`appendChild()`，你可以将新节点添加到DOM树中。在`document.body`节点上调用此方法意味着在最后一个子节点之后创建一个更多的子节点，如下所示：
- en: '[PRE98]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Here''s an illustration of how the page looks like after the new node is appended:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在新节点附加后页面的示例：
- en: '![Creating new nodes](graphics/image_10_011.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![创建新节点](graphics/image_10_011.jpg)'
- en: DOM-only method
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅使用DOM方法
- en: 'The `innerHTML` property gets things done a little more quickly than using
    pure DOM. In pure DOM, you will need to perform the following steps:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`innerHTML`属性比纯DOM更快地完成了一些工作。在纯DOM中，你需要执行以下步骤：'
- en: Create a new text node containing yet another text.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含另一个文本的新文本节点。
- en: Create a new paragraph node.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的段落节点。
- en: Append the text node as a child to the paragraph.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文本节点作为段落的子节点添加。
- en: Append the paragraph as a child to the body.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将段落作为子节点添加到body。
- en: 'This way, you can create any number of text nodes and elements and nest them,
    however you like. Let''s say, you want to add the following HTML to the end of
    the body:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以创建任意数量的文本节点和元素，并将它们嵌套，就像你喜欢的那样。假设你想要将以下HTML添加到body的末尾：
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Presenting the preceding code as a hierarchy would be something like the following
    code snippet:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码呈现为层次结构，会像以下代码片段一样：
- en: '[PRE100]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The code that accomplishes this is as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的代码如下：
- en: '[PRE101]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Using cloneNode() method
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用cloneNode()方法
- en: Another way to create nodes is by copying or cloning existing ones. The `cloneNode()`
    method does this and accepts a Boolean parameter (`true` = deep copy with all
    the children, `false` = shallow copy, only this node). Let's test the method.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种创建节点的方法是通过复制或克隆现有节点。`cloneNode()`方法可以做到这一点，并接受一个布尔参数（`true` = 深拷贝，包括所有子节点，`false`
    = 浅拷贝，只有这个节点）。让我们测试一下这个方法。
- en: 'Getting a reference to the element you want to clone can be done as follows:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 获取要克隆的元素的引用可以通过以下方式完成：
- en: '[PRE102]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Now, `el` refers to the second paragraph on the page that looks like the following
    code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`el`指的是页面上第二个段落，如下所示的代码：
- en: '[PRE103]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let''s create a shallow clone of `el` and append it to the `body` as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`el`的浅克隆，并将其附加到`body`中，如下所示：
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You won''t see a difference on the page because the shallow copy only copied
    the `P` node without any children. This means that the text inside the paragraph,
    which is a text node child, was not cloned. The preceding line will be equivalent
    to the following code line:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你在页面上看不到任何区别，因为浅拷贝只复制了`P`节点而没有任何子节点。这意味着段落内的文本节点子节点没有被克隆。前面的行等同于以下代码行：
- en: '[PRE105]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'However, if you create a deep copy, the whole DOM subtree starting from `P`
    is copied, and this includes text nodes and the `EM` element. This line copies
    (visually too) the second paragraph to the end of the document. Consider the following
    line of code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你创建一个深拷贝，从`P`开始的整个DOM子树都会被复制，包括文本节点和`EM`元素。这一行将第二段复制（在视觉上也是）到文档的末尾。考虑以下代码行：
- en: '[PRE106]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'You can also copy only the `EM` if you want, as shown in the following lines
    of code:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你也可以只复制`EM`，就像以下代码行所示：
- en: '[PRE107]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Or, you can copy only the text node with value `second`, as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以只复制值为`second`的文本节点，如下所示：
- en: '[PRE108]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Using insertBefore() method
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用insertBefore()方法
- en: 'Using `appendChild()`, you can only add new children at the end of the selected
    element. For more control over the exact location, there is `insertBefore()`.
    This is the same as `appendChild()`, but accepts an extra parameter specifying
    where (before which element) to insert the new node. For example, the following
    code inserts a text node at the end of the `body` element:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`appendChild()`，你只能在所选元素的末尾添加新的子节点。要更精确地控制位置，可以使用`insertBefore()`。这与`appendChild()`相同，但接受一个额外的参数，指定在哪里（在哪个元素之前）插入新节点。例如，以下代码在`body`元素的末尾插入一个文本节点：
- en: '[PRE109]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Moreover, this creates another text node and adds it as the first child of
    the `body` element:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这将创建另一个文本节点，并将其添加为`body`元素的第一个子节点：
- en: '[PRE110]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Removing nodes
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除节点
- en: 'To remove nodes from the DOM tree, you can use the `removeChild()` method.
    Again, let''s start fresh with the same page with the body:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要从DOM树中移除节点，可以使用`removeChild()`方法。同样，让我们从具有相同body的同一页开始：
- en: '[PRE111]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Here''s how you can remove the second paragraph:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何移除第二段的方法：
- en: '[PRE112]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The method returns the removed node if you want to use it later. You can still
    use all the DOM methods even though the element is no longer in the tree. Lets
    take a look on the following code:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以后使用，该方法会返回已移除的节点。即使元素不再在树中，你仍然可以使用所有DOM方法。让我们看一下以下代码：
- en: '[PRE113]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: There's also the `replaceChild()`method that removes a node and puts another
    one in its place.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`replaceChild()`方法，它删除一个节点并将另一个节点放在它的位置。
- en: 'After removing the node, the tree looks as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 移除节点后，树的结构如下：
- en: '[PRE114]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Now, the second paragraph is the one with the ID `"closer"`, which is as follows:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，第二段是ID为“closer”的段落，如下所示：
- en: '[PRE115]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Let''s replace this paragraph with the one in the `removed` variable. Consider
    the following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`removed`变量中的段落替换这个段落。考虑以下代码：
- en: '[PRE116]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Just like `removeChild()`, `replaceChild()` returns a reference to the node
    that is now out of the tree:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`removeChild()`一样，`replaceChild()`返回一个对现在已经不在树中的节点的引用：
- en: '[PRE117]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, the body looks like the following piece of code:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，body看起来像下面的代码：
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'A quick way to wipe out all of the content of a subtree is to set `innerHTML`
    to a blank string. This removes all the children of the `body` element:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 清除子树的所有内容的快速方法是将`innerHTML`设置为空字符串。这将删除`body`元素的所有子元素：
- en: '[PRE119]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Testing is done as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 测试如下进行：
- en: '[PRE120]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Removing with `innerHTML` is fast and easy. The DOM-only way will be to go
    over all of the child nodes and remove each one individually. Here''s a little
    function that removes all nodes from a given start node:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`innerHTML`进行删除快速而简单。仅使用DOM的方法将是遍历所有子节点并逐个删除每个节点。以下是一个从给定起始节点删除所有节点的小函数：
- en: '[PRE121]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'If you want to delete all the children from the `body` element and leave the
    page with an empty `<body></body>`, use the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除`body`元素的所有子元素，并使页面保留一个空的`<body></body>`，请使用以下代码：
- en: '[PRE122]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: HTML - only DOM objects
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅适用于HTML的DOM对象
- en: As you already know, the DOM applies to both XML and HTML documents. What you've
    learned earlier about traversing the tree and then adding, removing, or modifying
    nodes, applies to any XML document. There are, however, some HTML-only objects
    and properties.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，DOM适用于XML和HTML文档。您之前学到的关于遍历树，然后添加、删除或修改节点的内容，适用于任何XML文档。然而，有一些仅适用于HTML的对象和属性。
- en: The `document.body` is one such HTML-only object. It's so common to have a `<body>`
    tag in HTML documents, and it's accessed so often, that it makes sense to have
    an object that's shorter and friendlier than the equivalent `document.getElementsByTagName('body')[0]`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.body`是这样一个仅适用于HTML的对象。在HTML文档中有一个`<body>`标签是如此常见，而且经常被访问，因此有一个比等效的`document.getElementsByTagName(''body'')[0]`更短更友好的对象是有意义的。'
- en: The `document.body` element is one example of a `legacy` object inherited from
    the prehistoric DOM Level 0 and moved to the HTML extension of the DOM specification.
    There are other objects similar to `document.body` element. For some of them,
    there is no core DOM equivalent, for others, there is an equivalent; however,
    the DOM 0 original was anyway ported for simplicity and legacy purposes. Let's
    see some of those objects.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.body`元素是从史前DOM Level 0继承并移至DOM规范的HTML扩展的`legacy`对象的一个示例。还有其他类似`document.body`元素的对象。对于其中一些对象，没有核心DOM等效物，对于其他对象，有一个等效物；然而，DOM
    0原始版本无论如何都被简化和保留了遗留目的。让我们看看其中一些对象。'
- en: Primitive ways to access the document
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问文档的原始方法
- en: 'to the elements of an HTML document. This was done mainly through a number
    of collections, which are as follows: Unlike the DOM, which gives you access to
    any element, and even comments and whitespace, initially, JavaScript had only
    limited access to the elements of an HTML document. This was done mainly through
    a number of collections, which are as follows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 对HTML文档的元素进行访问。这主要是通过一些集合来完成的，这些集合如下：与DOM不同，DOM可以访问任何元素，甚至是注释和空格，最初，JavaScript只能有限地访问HTML文档的元素。这主要是通过一些集合来完成的，这些集合如下：
- en: '`document.images`: This is a collection of all of the images on the page. The
    Core DOM equivalent is `document.getElementsByTagName(''img'')`.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.images`：这是页面上所有图像的集合。核心DOM等效物是`document.getElementsByTagName(''img'')`。'
- en: '`document.applets`: This is the same as `document.getElementsByTagName(''applet'')`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.applets`：这与`document.getElementsByTagName(''applet'')`相同。'
- en: '`document.links`: The document.links collection contains a list of all `<a
    href="..."></a>` tags on the page, meaning the `<a>` tags that have an `href`
    attribute.'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.links`：`document.links`集合包含页面上所有`<a href="..."></a>`标签的列表，即具有`href`属性的`<a>`标签。'
- en: '`document.anchors`: The document.anchors collection contains all links with
    a name attribute (`<a name="..."></a>`).'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.anchors`：`document.anchors`集合包含所有具有`name`属性的链接（`<a name="..."></a>`）。'
- en: '`document.forms`: One of the most widely used collections is `document.forms`,
    which contains a list of `<form>` elements.'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.forms`：最常用的集合之一是`document.forms`，其中包含`<form>`元素的列表。'
- en: 'Let''s play with a page that contains a form and an input ([http://www.phpied.com/files/jsoop/ch7-form.html](http://www.phpied.com/files/jsoop/ch7-form.html)).
    The following line of code gives you access to the first form on the page:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们玩一个包含表单和输入的页面（[http://www.phpied.com/files/jsoop/ch7-form.html](http://www.phpied.com/files/jsoop/ch7-form.html)）。以下代码行让您访问页面上的第一个表单：
- en: '[PRE123]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'It''s the same as the following line of code:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 它与以下代码行相同：
- en: '[PRE124]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The `document.forms` collection contains collections of input fields and buttons,
    accessible through the `elements` property. Here''s how to access the first input
    of the first form on the page:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.forms`集合包含通过`elements`属性访问的输入字段和按钮的集合。以下是如何访问页面上第一个表单的第一个输入：'
- en: '[PRE125]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Once you have access to an element, you can access its attributes as object
    properties. The first field of the first form in the test page is as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您访问了一个元素，就可以将其属性作为对象属性进行访问。测试页面中第一个表单的第一个字段如下：
- en: '[PRE126]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'You can change the text in the field (the value of the `value` attribute) using
    the following code:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下代码更改字段中的文本（`value`属性的值）：
- en: '[PRE127]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'If you want to disable the field dynamically, use the following code:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要动态禁用字段，请使用以下代码：
- en: '[PRE128]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'When forms or `form` elements have a `name` attribute, you can access them
    by name too, as shown in the following code:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 当表单或`form`元素具有`name`属性时，您也可以按名称访问它们，如下所示：
- en: '[PRE129]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Using document.write() method
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`document.write()`方法
- en: 'The `document.write()` method allows you to insert HTML into the page while
    the page is being loaded. You can have something like the following code:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.write()`方法允许您在页面加载时将HTML插入页面。您可以有以下代码：'
- en: '[PRE130]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'This is the same as if you had the date directly in the source of the HTML
    document, as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这与您直接在HTML文档的源代码中使用日期是一样的，如下所示：
- en: '[PRE131]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that you can only use `document.write()` method while the page is being
    loaded. If you try it after page load, it will replace the content of the whole
    page.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只能在页面加载时使用`document.write()`方法。如果尝试在页面加载后使用它，它将替换整个页面的内容。
- en: It's rare that you would need `document.write()` method, and if you think you
    do, try an alternative approach. The ways to modify the contents of the page provided
    by DOM Level 1 are preferred and are much more flexible.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 很少情况下你会需要`document.write()`方法，如果你认为需要，尝试另一种方法。首选使用DOM Level 1提供的修改页面内容的方式，更加灵活。
- en: Cookies, title, referrer, and domain
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cookies、标题、引荐者和域
- en: The four additional properties of `document` you'll see in this section are
    also ported from DOM Level 0 to the HTML extension of DOM Level 1\. Unlike the
    previous ones, for these properties, there are no core DOM equivalents.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本节中看到的`document`的四个附加属性也是从DOM Level 0移植到DOM Level 1的HTML扩展中。与之前的不同，对于这些属性，没有核心DOM等价物。
- en: 'The `document.cookie` is a property that contains a string. This string is
    the content of the cookies exchanged between the server and the client. When the
    server sends a page to the browser, it may include the `Set-Cookie` HTTP header.
    When the client sends a request to the server, it sends the cookie information
    back with the `Cookie` header. Using `document.cookie`, you can alter the cookies
    the browser sends to the server. For example, visiting `cnn.com` and typing `document.cookie`
    in the console gives you the following output:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.cookie`是一个包含字符串的属性。这个字符串是服务器和客户端之间交换的cookie的内容。当服务器向浏览器发送页面时，它可能包含`Set-Cookie`
    HTTP头。当客户端向服务器发送请求时，它会在`Cookie`头中将cookie信息发送回去。使用`document.cookie`，你可以改变浏览器发送到服务器的cookie。例如，访问`cnn.com`并在控制台中输入`document.cookie`会得到以下输出：'
- en: '[PRE132]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The `document.title` property allows you to change the title of the page displayed
    in the browser window. For example, see the following code:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.title`属性允许你更改浏览器窗口中显示的页面标题。例如，看下面的代码：'
- en: '[PRE133]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Note that this doesn't change the value of the `<title>` element, but only the
    display in the browser window, so it's not equivalent to `document.querySelector('title')`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不会改变`<title>`元素的值，而只是在浏览器窗口中显示，因此它不等同于`document.querySelector('title')`。
- en: 'The `document.referrer` property tells you the URL of the previously visited
    page. This is the same value the browser sends in the `Referer` HTTP header when
    requesting the page. (Note that `Referer` is misspelled in the HTTP headers, but
    is correct in JavaScript''s `document.referrer`). If you''ve visited the CNN page
    by searching on Yahoo first, you can see something like the following:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.referrer`属性告诉你先前访问的页面的URL。这是浏览器在请求页面时发送的`Referer` HTTP头的相同值。（注意，在HTTP头中`Referer`拼写错误，但在JavaScript的`document.referrer`中是正确的）。如果你先在Yahoo上搜索后访问CNN页面，你可以看到类似以下的内容：'
- en: '[PRE134]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The `document.domain` property gives you access to the domain name of the currently
    loaded page. This is commonly used when you need to perform so-called domain relaxation.
    Imagine your page is `www.yahoo.com`, and inside it, you have an iframe hosted
    on `music.yahoo.com` subdomain. These are two separate domains, so the browser's
    security restrictions won't allow the page and the iframe to communicate. To resolve
    this, you can set `document.domain` property on both pages to `yahoo.com` and
    they'll be able to talk to each other.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`document.domain`属性允许你访问当前加载页面的域名。当你需要执行所谓的域放宽时，这通常会被使用。想象一下你的页面是`www.yahoo.com`，在其中，你有一个托管在`music.yahoo.com`子域上的iframe。这是两个独立的域，所以浏览器的安全限制不允许页面和iframe进行通信。为了解决这个问题，你可以在两个页面上都设置`document.domain`属性为`yahoo.com`，它们就可以互相通信了。'
- en: 'Note that you can only set the domain to a less specific one, for example,
    you can change `www.yahoo.com` to `yahoo.com`, but you cannot change `yahoo.com`
    to `www.yahoo.com`, or any other non-yahoo domain. Consider the following code:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你只能将域设置为更少特定的域，例如，你可以将`www.yahoo.com`更改为`yahoo.com`，但你不能将`yahoo.com`更改为`www.yahoo.com`，或者任何其他非雅虎域。考虑以下代码：
- en: '[PRE135]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Previously, in this chapter, you saw the `window.location` object. Well, the
    same functionality is also available as `document.location` object:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了`window.location`对象。同样的功能也可以通过`document.location`对象实现：
- en: '[PRE136]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Events
  id: totrans-459
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件
- en: 'Imagine you are listening to a radio program and they announce, "Big event!
    Huge! Aliens have landed on Earth!" You might think, "Yeah, whatever"; some other
    listeners might think "They come in peace"; and some might think, "We''re all
    gonna die!". Similarly, the browser broadcasts events, and your code can be notified
    should it decide to tune in and listen to the events as they happen. Some example
    events are as follows:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你正在听收音机节目，他们宣布说：“大事件！巨大的！外星人已经降落在地球上！”你可能会想：“是啊，随便”;其他一些听众可能会想“他们是和平的”;还有一些人可能会想：“我们都会死！”同样，浏览器会广播事件，如果你决定调整并监听事件发生，你的代码可以被通知。一些示例事件如下：
- en: The user clicks a button
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户点击按钮
- en: The user types a character in a form field
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户在表单字段中输入字符
- en: The page finishes loading
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面加载完成
- en: You can attach a JavaScript function called event listener or event handler
    to a specific event and the browser will invoke your function as soon as the event
    occurs. Let's see how this is done.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将一个名为事件监听器或事件处理程序的JavaScript函数附加到特定事件上，浏览器将在事件发生时立即调用你的函数。让我们看看如何做到这一点。
- en: Inline HTML attributes
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联HTML属性
- en: 'Adding specific attributes to a tag is the laziest but the least maintainable
    way; take the following line of code as an example:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 向标签添加特定属性是最懒惰但最不可维护的方式；以以下代码为例：
- en: '[PRE137]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: In this case, when the user clicks on `<div>`, the click event fires and the
    string of JavaScript code contained in the `onclick` attribute is executed. There's
    no explicit function that listens to the click event; however, behind the scenes,
    a function is still created, and it contains the code you specified as a value
    of the `onclick` attribute.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当用户点击`<div>`时，点击事件触发，`onclick`属性中包含的JavaScript代码字符串将被执行。虽然没有明确的函数监听点击事件；然而，在幕后，仍然创建了一个函数，它包含你在`onclick`属性的值中指定的代码。
- en: Element Properties
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素属性
- en: 'Another way to have some code executed when a click event fires is to assign
    a function to the `onclick` property of a DOM node element. For example, take
    a look at the following piece of code:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击事件触发时，另一种执行一些代码的方法是将函数分配给DOM节点元素的`onclick`属性。例如，看一下以下代码片段：
- en: '[PRE138]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This way is better because it helps you keep your `<div>` tag clean of any JavaScript
    code. Always keep in mind that HTML is for content, JavaScript for behavior, and
    CSS for formatting, and you should keep these three separate as much as possible.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式更好，因为它有助于保持`<div>`标签不含任何JavaScript代码。请始终记住，HTML用于内容，JavaScript用于行为，CSS用于格式化，您应尽可能将这三者分开。
- en: This method has the drawback that you can attach only one function to the event,
    as if the radio program has only one listener. It's true that you can have a lot
    happening inside the same function, but this is not always convenient, as if all
    the radio listeners are in the same room.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是您只能将一个函数附加到事件，就像广播节目只有一个听众一样。确实，您可以在同一个函数中做很多事情，但这并不总是方便的，就像所有广播听众都在同一个房间里一样。
- en: DOM event listeners
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DOM事件监听器
- en: The best way to work with browser events is to use the event listener approach
    outlined in DOM Level 2, where you can have many functions listening to an event.
    When an event fires, all the functions are executed. All of the listeners don't
    need to know about each other and can work independently. They can tune in and
    out at any time, without affecting the other listeners.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 与浏览器事件一起工作的最佳方法是使用DOM Level 2中概述的事件监听器方法，其中可以有多个函数监听事件。当事件触发时，所有函数都会被执行。所有监听器不需要相互了解，并且可以独立工作。它们可以随时调整，而不会影响其他监听器。
- en: 'Let''s use the same simple markup from the previous section, which is available
    for you to play with at [http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html).
    It has this piece of markup, which is as follows:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用上一节中相同的简单标记，你可以在[http://www.phpied.com/files/jsoop/ch7.html](http://www.phpied.com/files/jsoop/ch7.html)上玩耍。它有以下标记：
- en: '[PRE139]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Your JavaScript code can assign listeners to the click event using the `addEventListener()`
    method. Let''s attach two listeners as follows:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 您的JavaScript代码可以使用`addEventListener()`方法为点击事件分配监听器。让我们按如下方式附加两个监听器：
- en: '[PRE140]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: As you can see, `addEventListeners`
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`addEventListeners`
- en: Capturing and bubbling
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获和冒泡
- en: In the calls to `addEventListener()`, there was a third parameter-`false`. Let's
    see what it is for.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`addEventListener()`时，有一个第三个参数-`false`。让我们看看它是什么。
- en: 'Let''s say you have a link inside an unordered list, which is as follows:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在无序列表中有一个链接，如下所示：
- en: '[PRE141]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'When you click on the link, you''re actually also clicking on the list item,
    `<li>`, the `<ul>` list, the `<body>` tag, and eventually, the document as a whole.
    This is called event propagation. A click on a link can also be seen as a click
    on the document. The process of propagating an event can be implemented in the
    two following ways:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击链接时，实际上也点击了列表项`<li>`，`<ul>`列表，`<body>`标签，最终是整个文档。这称为事件传播。单击链接也可以看作是单击文档。传播事件的过程可以通过以下两种方式实现：
- en: '**Event capturing**: This click happens in the document first, then it propagates
    down to the body, the list, the list item, and finally, to the link'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件捕获**：此点击首先发生在文档中，然后向下传播到body，列表，列表项，最后到链接'
- en: '**Event bubbling**: This click happens on the link and then bubbles up to the
    document'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件冒泡**：此点击发生在链接上，然后冒泡到文档'
- en: 'DOM level 2 events specification suggests that the events propagate in three
    phases, namely, capturing, at target, and bubbling. This means that the event
    propagates from the document to the link (target) and then bubbles back up to
    the document. The event objects have an `eventPhase` property, which reflects
    the current phase:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: DOM Level 2事件规范建议事件在三个阶段传播，即捕获，目标，冒泡。这意味着事件从文档传播到链接（目标），然后再冒泡回文档。事件对象具有一个`eventPhase`属性，反映当前阶段：
- en: '![Capturing and bubbling](graphics/image_10_012.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![捕获和冒泡](graphics/image_10_012.jpg)'
- en: Historically, IE and Netscape (working on their own and without a standard to
    follow) implemented the exact opposites. IE implemented only bubbling and Netscape
    only capturing. Today, long after the DOM specification, modern browsers implement
    all three phases.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，IE和Netscape（各自独立工作，没有遵循的标准）实现了完全相反的方法。IE只实现了冒泡，而Netscape只实现了捕获。今天，在DOM规范很久之后，现代浏览器实现了所有三个阶段。
- en: 'The practical implications related to the event propagation are as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件传播相关的实际影响如下：
- en: The third parameter to `addEventListener()` specifies whether or not capturing
    should be used. In order to have your code more portable across browsers, it's
    better to always set this parameter to `false` and use bubbling only.
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addEventListener()`的第三个参数指定是否使用捕获。为了使您的代码在各种浏览器中更具可移植性，最好始终将此参数设置为`false`并仅使用冒泡。'
- en: You can stop the propagation of the event in your listeners so that it stops
    bubbling up and never reaches the document. To do this, you can call the `stopPropagation()`
    method of the event object; there is an example in the next section.
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在监听器中停止事件传播，使其停止冒泡并永远不会到达文档。为此，您可以调用事件对象的`stopPropagation()`方法；下一节中有一个示例。
- en: You can also use event delegation. If you have ten buttons inside `<div>`, you
    can always attach ten event listeners, one for each button. However, a smarter
    thing to do is to attach only one listener to the wrapping `<div>` and once the
    event happens, check which button was the target of the click.
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用事件委托。如果在`<div>`内有十个按钮，您可以始终附加十个事件监听器，每个按钮一个。但是，更明智的做法是仅将一个监听器附加到包装的`<div>`上，一旦事件发生，检查哪个按钮是点击的目标。
- en: As a side note, there is a way to use event capturing in old IEs too (using
    `setCapture()` and `releaseCapture()` methods) but only for mouse events. Capturing
    any other events (keystroke events for example) is not supported.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在旧版IE中也有一种方法可以使用事件捕获（使用`setCapture()`和`releaseCapture()`方法），但仅适用于鼠标事件。不支持捕获任何其他事件（例如按键事件）。
- en: Stop propagation
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止传播
- en: 'Let''s see an example of how you can stop the event from bubbling up. Going
    back to the test document, there is this piece of code:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，说明如何阻止事件冒泡。回到测试文档，有这段代码：
- en: '[PRE142]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Let''s define a function that handles clicks on the paragraph, as follows:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个处理段落点击的函数，如下所示：
- en: '[PRE143]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Now, let''s attach this function as a listener to the click event:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将此函数作为点击事件的侦听器附加：
- en: '[PRE144]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Let''s also attach listeners to the click event on the body, the document,
    and the browser window:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们还将侦听器附加到body、document和浏览器窗口的点击事件：
- en: '[PRE145]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Note that the DOM specifications don't say anything about events on the window.
    And why would they, as DOM deals with the document and not the browser. So browsers
    implement window events inconsistently.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，DOM规范对窗口上的事件没有任何说明。为什么会这样呢？因为DOM处理的是文档，而不是浏览器。因此，浏览器对窗口事件的实现是不一致的。
- en: 'Now, if you click on the paragraph, you''ll see four alerts saying:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您点击段落，您将看到四个警报，内容如下：
- en: clicked paragraph
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击段落
- en: clicked body
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击body
- en: clicked doc
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击文档
- en: clicked window
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击窗口
- en: This illustrates how the same single click event propagates (bubbles up) from
    the target all the way up to the window.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这说明了同一个单击事件是如何从目标一直冒泡到窗口的。
- en: 'The opposite of `addEventLister()` is `removeEventListener()`, and it accepts
    exactly the same parameters. Let''s remove the listener attached to the paragraph
    by writing the following line of code:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEventLister()`的相反操作是`removeEventListener()`，它接受完全相同的参数。让我们通过编写以下代码来删除附加到段落的侦听器：'
- en: '[PRE146]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If you try now, you'll see alerts only for the click event on the body, document,
    and window, but not on the paragraph.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试，您将只会在body、document和window的点击事件上看到警报，而不会在段落上看到。
- en: 'Now, let''s stop the propagation of the event. The function you add as a listener
    receives the event object as a parameter, and you can call the `stopPropagation()`
    method of that event object as follows:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们停止事件的传播。您作为侦听器添加的函数将接收事件对象作为参数，并且您可以调用该事件对象的`stopPropagation()`方法，如下所示：
- en: '[PRE147]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Adding the modified listener is done as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 添加修改后的侦听器如下所示：
- en: '[PRE148]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Now, when you click on the paragraph, you will see only one alert because the
    event doesn't bubble up to the body, the document, or the window.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您点击段落时，您将只会看到一个警报，因为事件不会冒泡到body、document或window。
- en: 'Note that when you remove a listener, you have to pass a pointer to the same
    function you previously attached. Otherwise, doing the following does not work
    because the second argument is a new function, not the same you passed when adding
    the event listener, even if the body is exactly the same. Consider the following
    code:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当您删除侦听器时，您必须传递指向先前附加的相同函数的指针。否则，以下操作不起作用，因为第二个参数是一个新函数，而不是您在添加事件侦听器时传递的相同函数，即使body完全相同也是如此。请考虑以下代码：
- en: '[PRE149]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Prevent default behavior
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阻止默认行为
- en: Some browser events have a predefined behavior. For example, clicking a link
    causes the browser to navigate to another page. You can attach listeners to clicks
    on a link, and you can also disable the default behavior by calling the `preventDefault()`
    method on the event object.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一些浏览器事件具有预定义的行为。例如，单击链接会导致浏览器导航到另一个页面。您可以附加侦听器以监听链接的点击，并且还可以通过在事件对象上调用`preventDefault()`方法来禁用默认行为。
- en: 'Let''s see how you can annoy your visitors by asking "Are you sure you want
    to follow this link?" every time they click a link? If the user clicks on **Cancel**
    (causing `confirm()` to return `false`), the `preventDefault()` method is called,
    which is shown as follows:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何通过每次点击链接时询问“您确定要跟随此链接吗？”来打扰您的访问者？如果用户点击“取消”（导致`confirm()`返回`false`），则调用`preventDefault()`方法，如下所示：
- en: '[PRE150]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that not all events allow you to prevent the default behavior. Most do,
    but if you want to be sure, you can check the `cancellable` property of the event
    object.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非所有事件都允许您阻止默认行为。大多数事件都可以，但如果您想确保，可以检查事件对象的`cancellable`属性。
- en: Cross-browser event listeners
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨浏览器事件侦听器
- en: As you already know, most modern browsers almost fully implement the DOM Level
    1 specification. However, the events were not standardized until DOM 2\. As a
    result, there are quite a few differences in how IE, before version 9, implements
    this functionality compared to modern browsers.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的那样，大多数现代浏览器几乎完全实现了DOM Level 1规范。但是，直到DOM 2标准化之前，事件才得到标准化。因此，IE在版本9之前实现此功能与现代浏览器相比存在相当多的差异。
- en: 'Check out an example that causes `nodeName` of a clicked element (the target
    element) to be written to the console:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 查看一个示例，导致被点击元素（目标元素）的`nodeName`被写入控制台：
- en: '[PRE151]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Now, let''s take a look at how IE is different:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看IE有何不同：
- en: In IE, there's no `addEventListener()` method; although, since IE Version 5,
    there is an equivalent `attachEvent()` method. For earlier versions, your only
    choice is accessing the property directly, such as `onclick`.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IE中，没有`addEventListener()`方法；尽管自IE 5版本以来，有一个等效的`attachEvent()`方法。对于早期版本，您唯一的选择是直接访问属性，例如`onclick`。
- en: The `click` event becomes `onclick` when using `attachEvent()`.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`attachEvent()`时，`click`事件变为`onclick`。
- en: If you listen to events the old fashioned way (for example, by setting a function
    value to the `onclick` property), when the callback function is invoked, it doesn't
    get an event object passed as a parameter. However, regardless of how you attach
    the listener in IE, there is always a global object `window.event` that points
    to the latest event.
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您以老式方式监听事件（例如，通过将函数值设置为`onclick`属性），当调用回调函数时，它不会作为参数传递事件对象。但是，无论您如何在IE中附加侦听器，始终存在一个指向最新事件的全局对象`window.event`。
- en: In IE, the event object doesn't get a target attribute telling you the element
    on which the event fired, but it does have an equivalent property called `srcElement`.
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在IE中，事件对象没有目标属性，告诉您事件触发的元素，但它确实有一个称为`srcElement`的等效属性。
- en: As mentioned earlier, event capturing doesn't apply to all events, so only bubbling
    should be used.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，事件捕获不适用于所有事件，因此只应使用冒泡。
- en: There's no `stopPropagation()` method, but you can set the IE-only `cancelBubble`
    property to `true`.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`stopPropagation()`方法，但是你可以将IE专用的`cancelBubble`属性设置为`true`。
- en: There's no `preventDefault()` method, but you can set the IE-only `returnValue`
    property to `false`.
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有`preventDefault()`方法，但是你可以将IE专用的`returnValue`属性设置为`false`。
- en: To stop listening to an event, instead of `removeEventListener()` in IE, you'll
    need `detachEvent()`.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要停止监听事件，而不是在IE中使用`removeEventListener()`，您将需要`detachEvent()`。
- en: 'So, here''s the revised version of the previous code that works across browsers:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是先前代码的修订版本，可在各种浏览器中使用：
- en: '[PRE152]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Types of events
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件类型
- en: 'Now you know how to handle cross-browser events. However, all of the preceding
    examples used only click events. What other events are happening out there? As
    you can probably guess, different browsers provide different events. There is
    a subset of cross-browser events, and some browser-specific ones. For a full list
    of events, you should consult the browser''s documentation, but here''s a selection
    of cross-browser events:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何处理跨浏览器事件了。但是，所有先前的示例只使用了点击事件。其他事件正在发生吗？您可能已经猜到，不同的浏览器提供不同的事件。有一组跨浏览器事件和一些特定于浏览器的事件。要获取事件的完整列表，您应该查阅浏览器的文档，但是这里是一些跨浏览器事件的选择：
- en: Mouse events
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鼠标事件
- en: '`mouseup`, `mousedown`, `click` (the sequence is mousedown-up-click), `dblclick`'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseup`，`mousedown`，`click`（顺序为mousedown-up-click），`dblclick`'
- en: '`mouseover` (mouse is over an element), `mouseout` (mouse was over an element
    but left it), `mousemove`'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mouseover`（鼠标悬停在元素上），`mouseout`（鼠标悬停在元素上但离开了它），`mousemove`'
- en: Keyboard events
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘事件
- en: '`keydown`, `keypress`, `keyup` (occur in this sequence)'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keydown`，`keypress`，`keyup`（按此顺序发生）'
- en: Loading/window events
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载/窗口事件
- en: '`load` (an image or a page and all of its components are done loading), `unload`
    (user leaves the page), `beforeunload` (the script can provide the user with an
    option to stop the unload)'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`load`（加载图像或页面及其所有组件完成加载），`unload`（用户离开页面），`beforeunload`（脚本可以为用户提供停止卸载的选项）'
- en: '`abort` (user stops loading the page or an image in IE), `error` (a JavaScript
    error, also when an image cannot be loaded in IE)'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abort`（用户停止在IE中加载页面或图像），`error`（JavaScript错误，也是在IE中无法加载图像时）'
- en: '`resize` (the browser window is resized), `scroll` (the page is scrolled),
    `contextmenu` (the right-click menu appears)'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resize`（浏览器窗口被调整大小），`scroll`（页面被滚动），`contextmenu`（右键菜单出现）'
- en: Form events
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单事件
- en: '`focus` (enter a form field), `blur` (leave the form field)'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`focus`（进入表单字段），`blur`（离开表单字段）'
- en: '`change` (leave a field after the value has changed), `select` (select text
    in a text field)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`change`（在值更改后离开字段），`select`（在文本字段中选择文本）'
- en: '`reset` (wipe out all user input), `submit` (send the form)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reset`（清除所有用户输入），`submit`（发送表单）'
- en: Additionally, modern browsers provide drag events (`dragstart`, `dragend`, `drop`,
    and among others) and touch devices provide `touchstart`, `touchmove`, and `touchend`.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现代浏览器提供拖动事件（`dragstart`，`dragend`，`drop`等），触摸设备提供`touchstart`，`touchmove`和`touchend`。
- en: This concludes the discussion of events. Refer to the exercise section at the
    end of this chapter for a little challenge of creating your own event utility
    to handle cross-browser events.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了事件的讨论。请参考本章末尾的练习部分，挑战自己创建自己的事件实用程序来处理跨浏览器事件。
- en: XMLHttpRequest
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XMLHttpRequest
- en: '`XMLHttpRequest()` is an object (a constructor function) that allows you to
    send HTTP requests from JavaScript. Historically, XHR (`XMLHttpRequest`) was introduced
    in IE and was implemented as an ActiveX object. Starting with IE7, it''s a native
    browser object, the same way as it''s in the other browsers. The common implementation
    of this object across browsers gave birth to the so-called Ajax applications,
    where it''s no longer necessary to refresh the whole page every time you need
    new content. With JavaScript, you can make an HTTP request to the server, get
    the response, and update only a part of the page. This way, you can build much
    more responsive and desktop-like web pages.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`XMLHttpRequest()`是一个允许您从JavaScript发送HTTP请求的对象（构造函数）。从历史上看，XHR（`XMLHttpRequest`）是在IE中引入的，并且被实现为ActiveX对象。从IE7开始，它是一个本机浏览器对象，就像其他浏览器中一样。跨浏览器对此对象的常见实现产生了所谓的Ajax应用程序，不再需要每次需要新内容时刷新整个页面。使用JavaScript，您可以向服务器发出HTTP请求，获取响应，并仅更新页面的一部分。这样，您可以构建更具响应性和类似桌面的网页。'
- en: '**Ajax** stands for **Asynchronous JavaScript and XML**:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**Ajax**代表**异步JavaScript和XML**：'
- en: Asynchronous because, after sending an HTTP request, your code doesn't need
    to wait for the response; however, it can do other stuff and be notified, through
    an event, when the response arrives.
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步是因为在发送HTTP请求后，您的代码不需要等待响应；但是，它可以做其他事情，并在响应到达时通过事件通知。
- en: JavaScript because it's obvious that XHR objects are created with JavaScript.
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript，因为很明显XHR对象是用JavaScript创建的。
- en: XML because initially developers were making HTTP requests for XML documents
    and were using the data contained in them to update the page. This is no longer
    a common practice, though, as you can request data in plain text, in the much
    more convenient JSON format, or simply as HTML ready to be inserted into the page.
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XML，因为最初开发人员正在为XML文档发出HTTP请求，并且正在使用其中包含的数据来更新页面。尽管这不再是常见做法，因为您可以请求以纯文本、更方便的JSON格式或简单地作为准备插入页面的HTML的数据。
- en: 'There are two steps to using the `XMLHttpRequest` object, which are as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`XMLHttpRequest`对象有两个步骤，如下所示：
- en: '**Send the request**: This includes creating an `XMLHttpRequest` object and
    attaching an event listener'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发送请求**：这包括创建一个`XMLHttpRequest`对象并附加事件监听器'
- en: '**Process the response**: This happens when your event listener gets notified
    that the response has arrived, and your code gets busy doing something amazing
    with the response'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理响应**：当您的事件监听器得到通知响应已经到达，并且您的代码忙于处理响应时'
- en: Sending the request
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送请求
- en: 'In order to create an object, you will simply use the following code (let''s
    deal with browser inconsistencies in just a bit):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个对象，你只需使用以下代码（让我们稍后再处理浏览器的不一致性）：
- en: '[PRE153]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The next thing is to attach an event listener to the `readystatechange` event
    fired by the object:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来要做的是将事件监听器附加到对象触发的`readystatechange`事件上：
- en: '[PRE154]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Then, you will need to call the `open()` method, as follows:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要调用`open()`方法，如下所示：
- en: '[PRE155]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The first parameter specifies the type of HTTP request, such as `GET`, `POST`,
    `HEAD`, and so on. `GET` and `POST` are the most common ones. Use `GET` when you
    don't need to send much data with the request and your request doesn't modify
    (write) data on the server, otherwise, use `POST`. The second parameter is the
    URL you are requesting. In this example, it's the text file `somefile.txt` located
    in the same directory as the page. The last parameter is a Boolean specifying
    whether the request is asynchronous (`true`, always prefer this) or not (`false`,
    blocks all the JavaScript execution and waits until the response arrives).
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数指定HTTP请求的类型，例如`GET`，`POST`，`HEAD`等。`GET`和`POST`是最常见的。当您不需要发送太多数据的请求并且您的请求不会修改（写入）服务器上的数据时，请使用`GET`，否则请使用`POST`。第二个参数是您正在请求的URL。在这个例子中，它是位于与页面相同目录中的文本文件`somefile.txt`。最后一个参数是一个布尔值，指定请求是异步的（`true`，始终首选）还是同步的（`false`，阻止所有JavaScript执行并等待直到响应到达）。
- en: 'The last step is to fire off the request, which is done as follows:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是发出请求，步骤如下：
- en: '[PRE156]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The `send()` method accepts any data you want to send with the request. For
    `GET` requests, this is an empty string because the data is in the URL. For `POST`
    request, it's a query string in the `key=value&key2=value2` form.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`send()`方法接受您想要发送的请求数据。对于`GET`请求，这是一个空字符串，因为数据在URL中。对于`POST`请求，它是一个查询字符串，形式为`key=value&key2=value2`。'
- en: At this point, the request is sent and your code and the user can move on to
    other tasks. The callback function, `myCallback`, will be invoked when the response
    comes back from the server.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，请求已发送，您的代码和用户可以继续其他任务。当响应从服务器返回时，回调函数`myCallback`将被调用。
- en: Processing the response
  id: totrans-580
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理响应
- en: A listener is attached to the `readystatechange` event. So, what exactly is
    the ready state and how does it change?
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器附加到`readystatechange`事件。那么，准确来说ready状态是什么，它是如何改变的呢？
- en: 'There is a property of the XHR object called `readyState`. Every time it changes,
    the `readystatechange` event fires. The possible values of the `readyState` property
    are as follows:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: XHR对象有一个叫做`readyState`的属性。每次它改变时，`readystatechange`事件就会触发。`readyState`属性的可能值如下：
- en: 0-uninitialized
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0-未初始化
- en: 1-loading
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1-加载
- en: 2-loaded
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2-已加载
- en: 3-interactive
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3-交互
- en: 4-complete
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4-完成
- en: When `readyState` gets the value of `4`, it means the response is back and ready
    to be processed. In `myCallback`, after you make sure `readyState` is `4`, the
    other thing to check is the status code of the HTTP request. You might have requested
    a non-existing URL, for example, and got a `404` (File not found) status code.
    The interesting code is the `200` (`OK`) code, so `myCallback` should check for
    this value. The status code is available in the `status` property of the XHR object.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 当`readyState`得到值`4`时，意味着响应已经返回并准备好被处理。在`myCallback`中，确保`readyState`是`4`后，要检查的另一件事是HTTP请求的状态码。例如，您可能已经请求了一个不存在的URL，并得到了`404`（文件未找到）的状态码。有趣的代码是`200`（`OK`）代码，所以`myCallback`应该检查这个值。状态码在XHR对象的`status`属性中可用。
- en: 'Once `xhr.readyState` is `4` and `xhr.status` is `200`, you can access the
    contents of the requested URL using the `xhr.responseText` property. Let''s see
    how `myCallback` can be implemented to simply `alert()` the contents of the requested
    URL:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`xhr.readyState`是`4`且`xhr.status`是`200`，您就可以使用`xhr.responseText`属性访问所请求的URL的内容。让我们看看如何实现`myCallback`来简单地`alert()`所请求的URL的内容：
- en: '[PRE157]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Once you've received the new content you requested, you can add it to the page,
    use it for some calculations, or for any other purpose you find suitable.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您收到了您请求的新内容，您可以将其添加到页面上，用于一些计算，或者用于您认为合适的任何其他目的。
- en: Overall, this two-step process (send request and process response) is the core
    of the whole XHR/Ajax functionality. Now that you know the basics, you can move
    on to building the next Gmail. Oh yes, let's take a look at some minor browser
    inconsistencies.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个两步过程（发送请求和处理响应）是整个XHR/Ajax功能的核心。现在您已经了解了基础知识，可以继续构建下一个Gmail。哦是的，让我们看看一些次要的浏览器不一致性。
- en: Creating XMLHttpRequest objects in IE prior to Version 7
  id: totrans-593
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在IE 7之前创建XMLHttpRequest对象
- en: 'In Internet Explorer, prior to version 7, the `XMLHttpRequest` object was an
    ActiveX object, so creating an XHR instance is a little different. It goes as
    follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在Internet Explorer 7之前的版本中，`XMLHttpRequest`对象是一个ActiveX对象，因此创建XHR实例有点不同。步骤如下：
- en: '[PRE158]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '`MSXML2.XMLHTTP.3.0` is the identifier of the object you want to create. There
    are several versions of the `XMLHttpRequest` object, and if your page visitor
    doesn''t have the latest one installed, you can try two older ones before you
    give up.'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSXML2.XMLHTTP.3.0`是您想要创建的对象的标识符。`XMLHttpRequest`对象有几个版本，如果您的页面访问者没有安装最新版本，您可以在放弃之前尝试两个旧版本。'
- en: 'For a fully-cross-browser solution, you should first test to see if the user''s
    browser supports `XMLHttpRequest` as a native object, and if not, try the IE way.
    Therefore, the whole process of creating an XHR instance could be like the following:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 为了一个完全跨浏览器的解决方案，您应该首先测试用户的浏览器是否支持`XMLHttpRequest`作为一个原生对象，如果不支持，尝试IE的方式。因此，创建XHR实例的整个过程可能如下所示：
- en: '[PRE159]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: What is this doing? The `ids` array contains a list of ActiveX program IDs to
    try. The `xhr` variable points to the new XHR object. The code first checks to
    see if `XMLHttpRequest` exists. If so, this means that the browser supports `XMLHttpRequest()`
    natively, so the browser is relatively modern. If it is not, the code loops through
    ids trying to create an object. The `catch(e)` block quietly ignores failures
    and the loop continues. As soon as an `xhr` object is created, you break out of
    the loop.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在做什么？`ids`数组包含要尝试的ActiveX程序ID列表。`xhr`变量指向新的XHR对象。代码首先检查`XMLHttpRequest`是否存在。如果存在，这意味着浏览器原生支持`XMLHttpRequest()`，因此浏览器相对较新。如果不存在，代码会循环尝试创建对象。`catch(e)`块会静默忽略失败，循环继续。一旦创建了`xhr`对象，就会跳出循环。
- en: As you can see, this is quite a bit of code, so it's best to abstract it into
    a function. Actually, one of the exercises at the end of the chapter prompts you
    to create your own Ajax utility.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这是相当多的代码，最好将其抽象成一个函数。实际上，在本章末尾的练习中，有一个练习要求您创建自己的Ajax实用程序。
- en: A is for Asynchronous
  id: totrans-601
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A代表异步
- en: Now you know how to create an XHR object, give it a URL and handle the response
    to the request. What happens when you send two requests asynchronously? What if
    the response to the second request comes before the first?
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建XHR对象，给它一个URL并处理请求的响应。当您异步发送两个请求时会发生什么？如果第二个请求的响应在第一个请求之前到达会怎么样？
- en: 'In the preceding example, the XHR object was global and `myCallback` was relying
    on the presence of this global object in order to access its `readyState`, `status`,
    and `responseText` properties. Another way, which prevents you from relying on
    global variables, is to wrap the callback in a closure. Let''s see how:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，XHR对象是全局的，`myCallback`依赖于全局对象的存在来访问其`readyState`、`status`和`responseText`属性。另一种方法，可以避免依赖全局变量，就是将回调函数封装在闭包中。让我们看看：
- en: '[PRE160]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: In this case, `myCallback()` receives the XHR object as a parameter and will
    not go looking for it in the global space. This also means that at the time the
    response is received, the original `xhr` might be reused for a second request.
    The closure keeps pointing to the original object.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`myCallback()`将XHR对象作为参数接收，并不会在全局空间中寻找它。这也意味着在接收响应时，原始的`xhr`可能会被重用来进行第二次请求。闭包保持指向原始对象。
- en: X is for XML
  id: totrans-606
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X代表XML
- en: Although these days JSON (discussed in the next chapter) is preferred over XML
    as a data transfer format, XML is still an option. In addition to the `responseText`
    property, the XHR objects also have another property called `responseXML`. When
    you send an HTTP request for an XML document, `responseXML` points to an XML DOM
    document object. To work with this document, you can use all of the core DOM methods
    discussed previously in this chapter, such as `getElementsByTagName()`, `getElementById()`,
    and so on.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如今JSON（在下一章中讨论）作为数据传输格式优先于XML，但XML仍然是一个选项。除了`responseText`属性之外，XHR对象还有另一个属性叫做`responseXML`。当您发送一个XML文档的HTTP请求时，`responseXML`指向一个XML
    DOM文档对象。要处理此文档，您可以使用本章前面讨论过的所有核心DOM方法，比如`getElementsByTagName()`、`getElementById()`等。
- en: An example
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个例子
- en: Let's wrap up the different XHR topics with an example. You can visit the page
    located at [http://www.phpied.com/files/jsoop/xhr.html](http://www.phpied.com/files/jsoop/xhr.html)
    to work on the example yourself.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子总结不同的XHR主题。您可以访问位于[http://www.phpied.com/files/jsoop/xhr.html](http://www.phpied.com/files/jsoop/xhr.html)的页面来自己操作示例。
- en: 'The main page, `xhr.html`, is a simple static page that contains nothing but
    three `<div>` tags, which are as follows:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 主页`xhr.html`是一个简单的静态页面，里面只包含三个`<div>`标签，如下所示：
- en: '[PRE161]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Using the console, you can write code that requests three files and loads their
    respective contents into each `<div>`.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用控制台，您可以编写代码请求三个文件，并将它们各自的内容加载到每个`<div>`中。
- en: 'The three files to load are as follows:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载的三个文件如下：
- en: '`content.txt`: This is a simple text file containing the text `I am a text
    file`'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.txt`：这是一个包含文本`I am a text file`的简单文本文件'
- en: '`content.html`: This is a file containing HTML code `I am <strong>formatted</strong>
    <em>HTML</em>`'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.html`：这是一个包含HTML代码的文件`I am <strong>formatted</strong> <em>HTML</em>`'
- en: '`content.xml`: This is an XML file containing the following code:'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content.xml`：这是一个包含以下代码的XML文件：'
- en: '[PRE162]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: All of the files are stored in the same directory as `xhr.html`.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 所有文件都存储在与`xhr.html`相同的目录中。
- en: Note
  id: totrans-619
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注
- en: For security reasons, you can only use the original `XMLHttpRequest` to request
    files that are on the same domain. However, modern browsers support XHR2, which
    lets you make cross-domain requests, provided that the appropriate Access-Control-Allow-Origin
    HTTP header is in place.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，您只能使用原始的`XMLHttpRequest`来请求与同一域上的文件。然而，现代浏览器支持XHR2，允许您进行跨域请求，前提是适当的Access-Control-Allow-Origin
    HTTP头已经就位。
- en: 'First, let''s create a function to abstract the request/response part:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个函数来抽象请求/响应部分：
- en: '[PRE163]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This function accepts a URL to request and a callback function to call once
    the response arrives. Let''s call the function three times, once for each file,
    as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个要请求的URL和一个一旦响应到达就要调用的回调函数。让我们调用该函数三次，每次请求一个文件，如下所示：
- en: '[PRE164]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The callback functions are defined inline. The first two are identical. They
    just replace the HTML of the corresponding `<div>` with the contents of the requested
    file. The third one is a little different as it deals with the XML document. First,
    you will access the XML DOM object as `o.responseXML`. Then, using `getElementsByTagName()`,
    you will get a list of all the `<root>` tags (there is only one). The `firstChild`
    of `<root>` is a text node and `nodeValue` is the text contained in it (`I''m
    XML data)`. Then, just replace the HTML of `<div id="xml">` with the new content.
    The result is shown in the following screenshot:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 回调函数是内联定义的。前两个是相同的。它们只是用请求文件的内容替换相应`<div>`的HTML。第三个有点不同，因为它涉及XML文档。首先，您将访问XML
    DOM对象作为`o.responseXML`。然后，使用`getElementsByTagName()`，您将得到所有`<root>`标签的列表（只有一个）。`<root>`的`firstChild`是一个文本节点，`nodeValue`是其中包含的文本（`I'm
    XML data`）。然后，只需用新内容替换`<div id="xml">`的HTML。结果如下截图所示：
- en: '![An example](graphics/image_10_013.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![一个例子](graphics/image_10_013.jpg)'
- en: When working with the XML document, you can also use `o.responseXML.documentElement`
    to get to the `<root>` element instead of `o.responseXML.getElementsByTagName('root')[0]`.
    Remember that `documentElement` gives you the root node of an XML document. The
    root in HTML documents is always the `<html>` tag.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理XML文档时，您还可以使用`o.responseXML.documentElement`来获取`<root>`元素，而不是`o.responseXML.getElementsByTagName('root')[0]`。请记住，`documentElement`给您提供了XML文档的根节点。HTML文档中的根节点始终是`<html>`标签。
- en: Exercises
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: In the previous chapters, the solutions to the exercises could be found in the
    text of the chapter. This time, some of the exercises require you to do some more
    reading, or experimentation, outside this book.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的章节中，练习的解决方案可以在章节的文本中找到。这一次，一些练习需要您进行更多阅读或实验，超出本书的范围。
- en: 'BOM: As a BOM exercise, try coding something wrong, obtrusive, user-unfriendly,
    and all in all, very Web 1.0, the shaking browser window. Try implementing code
    that opens a 200 x 200 pop up window and then resizes it slowly and gradually
    to 400 x 400\. Next, move the window around as if there''s an earthquake. All
    you''ll need is one of the move`*()` functions, one or more calls to `setInterval()`,
    and maybe one to `setTimeout()`/`clearInterval()` to stop the whole thing. Or,
    here''s an easier one-print the current date/time in `document.title` and update
    it every second, like a clock.'
  id: totrans-630
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: BOM：作为BOM练习，尝试编写一些错误的、侵入性的、用户不友好的，总的来说，非常Web 1.0的代码，使浏览器窗口摇晃。尝试实现打开一个200 x 200的弹出窗口，然后慢慢地将其调整大小到400
    x 400。接下来，移动窗口，就像发生地震一样。您只需要一个`move*()`函数，一个或多个`setInterval()`调用，也许还有一个`setTimeout()`/`clearInterval()`来停止整个过程。或者，这里有一个更简单的方法-在`document.title`中打印当前日期/时间，并每秒更新一次，就像时钟一样。
- en: 'DOM:'
  id: totrans-631
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DOM：
- en: Implement `walkDOM()` differently. Also, make it accept a callback function
    instead of hard coding `console.log()`.
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以不同的方式实现`walkDOM()`。还使其接受回调函数，而不是硬编码`console.log()`。
- en: Removing content with `innerHTML` is easy (`document.body.innerHTML = ''`),
    but not always best. The problem will be when there are event listeners attached
    to the removed elements; they won't be removed in IE, causing the browser to leak
    memory because it stores references to something that doesn't exist. Implement
    a general-purpose function that deletes DOM nodes, but removes any event listeners
    first. You can loop through the attributes of a node and check if the value is
    a function. If it is, it's most likely an attribute like `onclick`. You need to
    set it to `null` before removing the element from the tree.
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`innerHTML`删除内容很容易（`document.body.innerHTML = ''`），但并非总是最佳选择。问题将出现在已附加到已删除元素的事件侦听器上；它们在IE中不会被移除，导致浏览器泄漏内存，因为它存储对不存在的东西的引用。实现一个通用函数，删除DOM节点，但首先删除任何事件侦听器。您可以循环遍历节点的属性，并检查值是否为函数。如果是，它很可能是像`onclick`这样的属性。在删除元素之前，您需要将其设置为`null`。
- en: 'Create a function called `include()` that includes external scripts on demand.
    This means you need to create a new `<script>` tag dynamically, set its `src`
    attribute, and append to the document''s `<head>`. Test it by using the following
    code:'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`include()`的函数，根据需要包含外部脚本。这意味着您需要动态创建一个新的`<script>`标签，设置其`src`属性，并将其附加到文档的`<head>`中。通过使用以下代码进行测试：
- en: '[PRE165]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Events:'
  id: totrans-636
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 事件：
- en: 'Create an event utility (object) called `myevent`, which has the following
    methods working cross-browser:'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`myevent`的事件实用程序（对象），它具有以下跨浏览器工作的方法：
- en: The `addListener``(element`, `event_name`, `callback)`, where `element` can
    also be an array of elements
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addListener``(element`, `event_name`, `callback)`，其中`element`也可以是元素的数组'
- en: '`removeListener``(element`, `event_name`, `callback)`'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeListener``(element`, `event_name`, `callback)`'
- en: '`getEvent(event)` just to check for a `window.event` for older versions of
    IE'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEvent(event)`只是为了检查旧版本IE的`window.event`'
- en: getTarget(event)
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: getTarget(event)
- en: stopPropagation(event)
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stopPropagation(event)
- en: preventDefault(event)
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: preventDefault(event)
- en: 'Usage example is as follows:'
  id: totrans-644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用示例如下：
- en: '[PRE166]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The result of the example code should be that all of the links in the document
    lead nowhere, but only alert the `href` attribute.
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例代码的结果应该是文档中的所有链接都不起作用，只会弹出`href`属性。
- en: Create an absolutely positioned `<div>`, say at `x = 100px`, `y = 100px`. Write
    the code to be able to move div around the page using the arrow keys or the *J*
    (left), *K* (right), *M* (down), and *I* (up) keys. Reuse your own event utility
    from 3.1.
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个绝对定位的`<div>`，比如在`x = 100px`，`y = 100px`的位置。编写代码，使得能够使用箭头键或*J*（左）、*K*（右）、*M*（下）和*I*（上）键在页面上移动div。重用您自己的事件实用程序从3.1。
- en: 'XMLHttpRequest:'
  id: totrans-648
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XMLHttpRequest：
- en: 'Create your own XHR utility (object) called `ajax`. For example, take a look
    at the following code:'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您自己的XHR实用程序（对象）称为`ajax`。例如，看一下以下代码：
- en: '[PRE167]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Summary
  id: totrans-651
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'You learned quite a bit in this chapter. You learned the following cross-browser
    BOM objects:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学到了很多东西。您学到了以下跨浏览器BOM对象：
- en: Properties of the global `window` object, such as `navigator`, `location`, `history`,
    `frames`, `screen`
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局`window`对象的属性，如`navigator`、`location`、`history`、`frames`、`screen`
- en: Methods such as `setInterval()` and `setTimeout()`; `alert()`, `confirm()` and
    `prompt()`; `moveTo/By()` and `resizeTo/By()`
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法，如`setInterval()`和`setTimeout()`；`alert()`、`confirm()`和`prompt()`；`moveTo/By()`和`resizeTo/By()`
- en: 'Then, you learned about the DOM, an API to represent an HTML or XML document
    as a tree structure, where each tag or text is a node on the tree. You also learned
    how to perform the following actions:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您学习了DOM，这是一个用于表示HTML或XML文档的API，它将其表示为树结构，其中每个标签或文本都是树上的一个节点。您还学习了如何执行以下操作：
- en: 'Accessing nodes:'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问节点：
- en: Using parent/child relationship properties, such as `parentNode`, `childNodes`,
    `firstChild`, `lastChild`, `nextSibling`, and `previousSibling`
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用父/子关系属性，如`parentNode`、`childNodes`、`firstChild`、`lastChild`、`nextSibling`和`previousSibling`
- en: Using `getElementsById()`, `getElementsByTagName()`, `getElementsByName()`,
    and `querySelectorAll()`
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`getElementsById()`、`getElementsByTagName()`、`getElementsByName()`和`querySelectorAll()`
- en: 'Modifying nodes:'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改节点：
- en: Using `innerHTML` or `innerText/textContent`
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`innerHTML`或`innerText/textContent`
- en: Using `nodeValue` or `setAttribute()`, or just using attributes as object properties
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`nodeValue`或`setAttribute()`，或者只是将属性作为对象属性使用
- en: Removing nodes with `removeChild()` or `replaceChild()`
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`removeChild()`或`replaceChild()`删除节点
- en: Adding new ones with `appendChild()`, `cloneNode()`, and `insertBefore()`
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`appendChild()`、`cloneNode()`和`insertBefore()`添加新节点
- en: 'You also learned the following DOM 0 (pre-standardization) properties, ported
    to DOM Level 1:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了以下DOM 0（预标准化）属性，迁移到DOM Level 1：
- en: Collections, such as `document.forms`, `images`, `links`, `anchors`, `applets`.
    Using these are discouraged as DOM1 has the much more flexible `getElementsByTagName()`
    method.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合，如`document.forms`、`images`、`links`、`anchors`、`applets`。不建议使用这些，因为DOM1具有更灵活的`getElementsByTagName()`方法。
- en: The `document.body` element, which gives you convenient access to `<body>`.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.body`元素，它方便地让您访问`<body>`。'
- en: The `document.title`, `cookie`, `referrer`, and `domain`.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document.title`、`cookie`、`referrer`和`domain`。'
- en: Next, you learned how the browser broadcasts events that you can listen to.
    It's not straightforward to do this in a cross-browser manner, but it's possible.
    Events bubble up, so you can use event delegation to listen to events more globally.
    You can also stop the propagation of events and interfere with the default browser
    behavior.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您学习了浏览器如何广播事件，您可以监听这些事件。以跨浏览器的方式执行此操作并不直接，但是是可能的。事件会冒泡，因此您可以使用事件委托来更全局地监听事件。您还可以阻止事件的传播并干预默认的浏览器行为。
- en: 'Finally, you learned about the `XMLHttpRequest` object that allows you to build
    responsive web pages that do the following tasks:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您学习了`XMLHttpRequest`对象，它允许您构建响应式网页，执行以下任务：
- en: Make HTTP requests to the server to get pieces of data
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向服务器发出HTTP请求以获取数据片段
- en: Process the response to update portions of the page
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理响应以更新页面的部分
