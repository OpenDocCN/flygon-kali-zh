- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: The Building Blocks of Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程的构建模块
- en: Any programming language starts off looking like ancient Greek to the unaccustomed
    eye, and C# is no exception. The good news is beneath the initial mystery, all
    programming languages are made up of the same essential building blocks. Variables,
    methods, and classes (or objects) make up the DNA of conventional programming;
    understanding these simple concepts opens up an entire world of diverse and complex
    applications. After all, there are only four different DNA nucleobases in every
    person on earth; yet, here we are, every one of us a unique organism.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言对于不熟悉的人来说都像古希腊语一样难以理解，C#也不例外。好消息是，在最初的神秘之下，所有编程语言都由相同的基本构建模块组成。变量、方法和类（或对象）构成了传统编程的DNA；理解这些简单的概念将打开一个多样和复杂应用的全新世界。毕竟，地球上每个人的DNA中只有四种不同的核碱基；然而，我们每个人都是独特的生物。
- en: If you are new to programming, there's going to be a lot of information coming
    at you in this chapter, and this could mark the first lines of code that you've
    ever written. The point is not to overload your brain with facts and figures;
    it's to give you a holistic look at the building blocks of programming using examples
    from everyday life.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是编程新手，在本章中会有大量的信息涌向你，这可能标志着你写下的第一行代码。重点不是用事实和数字来过载你的大脑，而是通过日常生活中的例子给你一个编程构建模块的整体观。
- en: 'This chapter is all about the high-level view of the bits and pieces that make
    up a program. Getting the hang of how things work before getting into the code
    directly will not only help you new coders find your feet, but it will also solidify
    the topics with easy-to-remember references. Ramblings aside, we''ll focus on
    the following topics throughout this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章主要讨论构成程序的各个部分的高层视图。在直接进入代码之前，了解事物如何运作不仅能帮助新手程序员找到自己的位置，还能通过易于记忆的参考加强对主题的理解。撇开闲话，本章将重点讨论以下主题：
- en: Defining variables
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义变量
- en: Understanding methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法
- en: Introducing classes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入类
- en: Working with comments
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用注释
- en: Putting the building blocks together
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构建模块组合在一起
- en: Defining variables
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义变量
- en: 'Let''s start with a simple question: what is a variable? Depending on your
    point of view, there are a few different ways of answering that question:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的问题开始：什么是变量？根据你的观点，有几种不同的回答方式：
- en: '**Conceptually**, a variable is the most basic unit of programming, as an atom
    is to the physical world (excepting string theory). Everything starts with variables,
    and programs can''t exist without them.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，变量是编程的最基本单元，就像原子是物理世界一样（除了弦理论）。一切都始于变量，没有它们程序就无法存在。'
- en: '**Technically**, a variable is a tiny section of your computer''s memory that
    holds an assigned value. Every variable keeps track of where its information is
    stored (this is called a memory address), its value, and its type (for instance,
    numbers, words, or lists).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，变量是计算机内存的一个小部分，它保存了一个分配的值。每个变量都会跟踪它的信息存储位置（这称为内存地址）、它的值和它的类型（比如数字、单词或列表）。'
- en: '**Practically**, a variable is a container. You can create new ones at will,
    fill them with stuff, move them around, change what they''re holding, and reference
    them as needed. They can even be empty and still be useful.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，变量就是一个容器。你可以随意创建新的变量，填充它们，移动它们，改变它们的内容，并根据需要引用它们。它们甚至可以是空的，但仍然有用。'
- en: You can find an in-depth explanation of variables in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在微软C#文档中找到关于变量的深入解释[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/variables)。
- en: A practical real-life example of a variable is a mailbox—remember those?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的一个实际生活例子是邮箱——还记得吗？
- en: '![](img/B17573_02_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_01.png)'
- en: 'Figure 2.1: Snapshot of a row of colorful mailboxes'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：一排色彩斑斓的邮箱快照
- en: 'They can hold letters, bills, a picture from your aunt Mabel—anything. The
    point is that what''s in a mailbox can vary: they can have names, hold information
    (physical mail), and their contents can even be changed if you have the right
    security clearance. Similarly, variables can hold different kinds of information.
    Variables in C# can hold strings (text), integers (numbers), and even Booleans
    (binary values that represent either true or false).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以装信件、账单、姨妈梅贝尔的照片——任何东西。重点是邮箱里的东西可能会有所不同：它们可以有名称，装信息（实体邮件），如果你有适当的安全许可，它们的内容甚至可以被更改。同样，变量可以容纳不同类型的信息。C#中的变量可以容纳字符串（文本）、整数（数字），甚至布尔值（代表真或假的二进制值）。
- en: Names are important
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称很重要
- en: 'Referring to *Figure 2.1*, if I asked you to go over and open the mailbox,
    the first thing you''d probably ask is: which one? If I said the Smith family
    mailbox, or the sunflower mailbox, or even the droopy mailbox on the far right,
    then you''d have the necessary context to open the mailbox I was referencing.
    Similarly, when you are creating variables, you have to give them unique names
    that you can reference later. We''ll get into the specifics of proper formatting
    and descriptive naming in *Chapter 3*,*Diving into Variables, Types, and Methods*.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 参考*图2.1*，如果我让你过去打开邮箱，你可能会问的第一件事是：哪一个？如果我说史密斯家的邮箱，或者向日葵邮箱，甚至是最右边的垂头丧气的邮箱，那么你就有了打开我所指的邮箱所需的上下文。同样，当你创建变量时，你必须给它们一个你以后可以引用的唯一名称。我们将在*第3章*，*深入变量、类型和方法*中详细讨论适当的格式和描述性命名。
- en: Variables act as placeholders
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量充当占位符
- en: 'When you create and name a variable, you are creating a placeholder for the
    value that you want to store. Let''s take the following simple math equation as
    an example:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建并命名一个变量时，你就创建了一个存储数值的占位符。让我们以以下简单的数学方程为例：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Okay, no mystery here, but what if we wanted the number `9` to be its variable?
    Consider the following code block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，这里没有什么神秘的，但如果我们想让数字`9`成为它的变量呢？考虑以下代码块：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now we can use the variable name, `MyVariable`, as a substitute for `9` anywhere
    we need it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用变量名`MyVariable`来替代我们需要的`9`：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If you're wondering whether variables have other rules or regulations, they
    do. We'll get to those in the next chapter, so sit tight.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道变量是否有其他规则或规定，答案是肯定的。我们将在下一章中介绍这些内容，所以请耐心等待。
- en: Even though this example isn't real C# code, it illustrates the power of variables
    and their use as placeholder references. In the next section you'll start creating
    variables of your own, so keep going!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个例子不是真正的C#代码，但它说明了变量的威力以及它们作为占位符引用的用途。在下一节中，你将开始创建自己的变量，所以继续前进吧！
- en: 'Alright, enough theory—let''s create a real variable in the `LearningCurve`
    script we created in *Chapter 1*, *Getting to Know Your Environment*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，理论够了，让我们在我们在*第1章*，*了解你的环境*中创建的`LearningCurve`脚本中创建一个真正的变量：
- en: Double-click on `LearningCurve.cs` from the Unity project window to open it
    in Visual Studio.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Unity项目窗口中双击`LearningCurve.cs`，在Visual Studio中打开它。
- en: 'Add a space between lines 6 and 7 and add the following line of code to declare
    a new variable:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第6行和第7行之间添加一个空格，并添加以下代码行来声明一个新变量：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Inside the `Start` method, add two debug logs to print out the following calculations:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`方法中，添加两个调试日志，打印出以下计算结果：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's break down the code we just added. First, we created a new variable called
    `CurrentAge` and assigned it a value of `30`. Then, we added two debug logs to
    print out the result of `30 + 1` and `CurrentAge + 1` to show how variables are
    storage for values. They can be used the exact same way as the values themselves.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解刚刚添加的代码。首先，我们创建了一个名为`CurrentAge`的新变量，并将其赋值为`30`。然后，我们添加了两个调试日志，打印出`30 +
    1`和`CurrentAge + 1`的结果，以展示变量是值的存储器。它们可以与值本身完全相同地使用。
- en: 'It''s also important to note that `public` variables appear in the Unity Inspector,
    while `private` ones don''t. Don''t worry about the syntax right now—just make
    sure your script is the same as the script that is shown in the following screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，`public`变量会出现在Unity检视面板中，而`private`变量不会。现在不用担心语法，只需确保你的脚本与下面截图中显示的脚本相同：
- en: '![](img/B17573_02_02.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_02.png)'
- en: 'Figure 2.2: LearningCurve script open in Visual Studio'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在Visual Studio中打开的LearningCurve脚本
- en: To finish, save the file using **Editor** | **File** | **Save**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用**编辑器** | **文件** | **保存**保存文件。
- en: 'For scripts to run in Unity, they have to be attached to *GameObjects* in the
    scene. The sample scene in *Hero Born* has a camera and directional light by default,
    which provides the lighting for the scene, so let''s attach `LearningCurve` to
    the camera to keep things simple:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Unity中运行脚本，它们必须附加到场景中的*游戏对象*上。*英雄诞生*中的示例场景默认包含摄像机和定向光，这为场景提供了照明，所以让我们将`LearningCurve`附加到摄像机上，以保持简单：
- en: Drag and drop `LearningCurve.cs` onto the **Main Camera**.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`LearningCurve.cs`拖放到**主摄像机**上。
- en: Select the **Main Camera** so that it appears in the **Inspector** panel, and
    verify that the `LearningCurve.cs` (Script) component is attached properly.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**主摄像机**，使其出现在**检视器**面板中，并验证`LearningCurve.cs`（脚本）组件是否正确附加。
- en: Click play and watch for the output in the **Console** panel:![](img/B17573_02_03.png)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击播放并观察**控制台**面板中的输出：![](img/B17573_02_03.png)
- en: 'Figure 2.3: Unity Editor window with callouts for dragging and dropping scripts'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：Unity编辑器窗口，带有拖放脚本的标注
- en: 'The `Debug.Log()` statements printed out the result of the simple math equations
    we put in between the parentheses. As you can see in the following **Console**
    screenshot, the equation that used our variable, `CurrentAge`, worked the same
    as if it were a real number:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`Debug.Log()`语句打印出了我们放在括号中的简单数学方程的结果。正如你在下面的**控制台**截图中所看到的，使用我们的变量`CurrentAge`的方程的工作方式与它是一个实际数字一样：'
- en: '![](img/B17573_02_04.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_04.png)'
- en: 'Figure 2.4: Unity console with debug output from the attached script'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4：Unity控制台显示了附加脚本的调试输出
- en: We'll get into how Unity converts C# scripts into components at the end of this
    chapter, but first, let's work on changing the value of one of our variables.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章末讨论Unity如何将C#脚本转换为组件，但首先让我们来改变其中一个变量的值。
- en: 'Since `CurrentAge` was declared as a variable on line 7 as shown in *Figure
    2.2*, the value it stores can be changed. The updated value will then trickle
    down to wherever the variable is used in code; let''s see this in action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`CurrentAge`在第7行被声明为一个变量，如*图2.2*所示，它存储的值可以被改变。更新后的值将传递到代码中使用变量的任何地方；让我们看看这个过程：
- en: Stop the game by clicking the **Pause** button if the scene is still running
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果场景仍在运行，请点击**暂停**按钮停止游戏
- en: Change **Current Age** to `18` in the **Inspector** panel and play the scene
    again, looking at the new output in the **Console** panel:![](img/B17573_02_05.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检视器**面板中将**Current Age**更改为`18`，然后再次播放场景，观察**控制台**面板中的新输出：![](img/B17573_02_05.png)
- en: 'Figure 2.5: Unity console with debug logs and the LearningCurve script attached
    to Main Camera'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5：Unity控制台显示了调试日志和附加到主摄像机的LearningCurve脚本
- en: The first output will still be `31` because we didn't change anything in the
    script, but the second output is now `19` because we changed the value of `CurrentAge`
    in the Inspector.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个输出仍然是`31`，因为我们在脚本中没有改变任何东西，但第二个输出现在是`19`，因为我们在检视面板中改变了`CurrentAge`的值。
- en: The goal here wasn't to go over variable syntax but to show how variables act
    as containers that can be created once and referenced elsewhere. We'll go into
    more detail in *Chapter 3*, *Diving into Variables, Types, and Methods*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目标不是讨论变量语法，而是展示变量如何作为容器，可以创建一次并在其他地方引用。我们将在*第3章*，*深入变量、类型和方法*中详细讨论。
- en: 'Now that we know how to create variables in C# and assign them values, we''re
    ready to dive into the next important programming building block: methods!'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何在C#中创建变量并赋值，我们准备好深入下一个重要的编程构建块：方法！
- en: Understanding methods
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法
- en: On their own, variables can't do much more than keep track of their assigned
    values. While this is vital, they are not very useful on their own in terms of
    creating meaningful applications. So, how do we go about creating actions and
    driving behavior in our code? The short answer is by using methods.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 单独的变量不能做更多的事情，只能跟踪其分配的值。虽然这很重要，但它们单独来说在创建有意义的应用程序方面并不是非常有用。那么，我们如何创建动作并在代码中驱动行为呢？简短的答案是使用方法。
- en: Before we get to what methods are and how to use them, we should clarify a small
    point of terminology. In the world of programming, you'll commonly see the terms
    *method* and *function* used interchangeably, especially in regards to Unity.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论方法是什么以及如何使用它们之前，我们应该澄清一个术语的小细节。在编程世界中，你经常会看到术语*方法*和*函数*被交替使用，特别是在Unity方面。
- en: Since C# is an object-oriented language (this is something that we'll cover
    in *Chapter 5*, *Working with Classes, Structs, and OOP*), we'll be using the
    term *method* for the rest of the book to conform to standard C# guidelines.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#是一种面向对象的语言（这是我们将在*第5章* *使用类、结构和面向对象编程*中介绍的内容），我们将在本书的其余部分使用术语*方法*，以符合标准的C#指南。
- en: When you come across the word function in the Scripting Reference or any other
    documentation, think method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在脚本参考或其他文档中遇到函数这个词时，想到方法。
- en: Methods drive actions
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法驱动行为
- en: 'Similarly to variables, defining programming methods can be tediously long-winded
    or dangerously brief; here''s another three-pronged approach to consider:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与变量类似，定义编程方法可能会非常冗长或非常简短；这里有另外一个三方面的方法来考虑：
- en: '**Conceptually**, methods are how work gets done in an application.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，方法是应用程序中完成工作的方式。'
- en: '**Technically**, a method is a block of code containing executable statements
    that run when the method is called by name. Methods can take in arguments (also
    called parameters), which can be used inside the method''s scope.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，方法是一个包含可执行语句的代码块，当通过名称调用方法时运行。方法可以接受参数（也称为参数），这些参数可以在方法的范围内使用。'
- en: '**Practically**, a method is a container for a set of instructions that run
    every time it''s executed. These containers can also take in variables as inputs,
    which can only be referenced inside the method itself.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，方法是一组指令的容器，每次执行时都会运行。这些容器还可以接受变量作为输入，这些变量只能在方法内部引用。'
- en: Taken all together, methods are the bones of any program—they connect everything
    and almost everything is built off of their structure.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，方法是任何程序的骨架——它们连接一切，几乎所有的东西都是基于它们的结构构建的。
- en: You can find an in-depth guide to methods in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Microsoft C#文档中找到有关方法的深入指南，网址为[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/methods)。
- en: Methods are placeholders too
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法也是占位符
- en: 'Let''s take an oversimplified example of adding two numbers together to drive
    the concept home. When writing a script, you''re essentially laying down lines
    of code for the computer to execute in sequential order. The first time you need
    to add two numbers together, you could just add them like in the following code
    block:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个过于简化的例子来加深概念。在编写脚本时，你实际上是按顺序放置代码行，让计算机执行。第一次需要将两个数字相加时，你可以像下面的代码块中那样直接相加：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: But then you conclude that these numbers need to be added together somewhere
    else.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 但是然后你得出结论，这些数字需要在其他地方相加。
- en: 'Instead of copying and pasting the same line of code, which results in sloppy
    or "spaghetti" code and should be avoided at all costs, you can create a named
    method that will take care of this action:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与其复制和粘贴相同的代码行，导致杂乱或“意大利面”代码并且应该尽量避免，你可以创建一个命名的方法来处理这个动作：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now `AddNumbers` is holding a place in memory, just like a variable; however,
    instead of a value, it holds a block of instructions. Using the name of the method
    (or calling it) anywhere in a script puts the stored instructions at your fingertips
    without having to repeat any code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`AddNumbers`就像一个变量一样占据着内存中的位置；但是，它不是一个值，而是一系列指令。在脚本中的任何地方使用方法的名称（或调用它）都可以让你立即使用存储的指令，而无需重复任何代码。
- en: If you find yourself writing the same lines of code over and over, you're likely
    missing a chance to simplify or condense repeated actions into common methods.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己一遍又一遍地写相同的代码行，你很可能错过了简化或将重复操作合并为常见方法的机会。
- en: This produces what programmers jokingly call spaghetti code because it can get
    messy. You'll also hear programmers refer to a solution called the **Don't Repeat
    Yourself** (**DRY**) principle, which is a mantra you should keep in mind.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生程序员开玩笑称之为意大利面代码的东西，因为它可能会变得混乱。你也会听到程序员提到一个叫做**不要重复自己**（**DRY**）原则的解决方案，这是一个你应该牢记的口头禅。
- en: As before, once we've seen a new concept in pseudocode, it's best if we implement
    it ourselves, which is what we'll do in the next section to drive it home.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，一旦我们在伪代码中看到了一个新概念，最好是自己实现一下，这就是我们将在下一节中做的事情。
- en: 'Let''s open up `LearningCurve` again and see how a method works in C#. Just
    like with the variables example, you''ll want to copy the code into your script
    exactly as it appears in the following screenshot. I''ve deleted the previous
    example code to make things neater, but you can, of course, keep it in your script
    for reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次打开`LearningCurve`，看看C#中的方法是如何工作的。就像变量示例一样，你会想要将代码粘贴到你的脚本中，就像下面的截图中显示的那样。我已经删除了以前的示例代码，以使事情更整洁，但你当然可以将其保留在脚本中以供参考：
- en: Open up `LearningCurve` in Visual Studio.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`LearningCurve`。
- en: 'Add a new variable to line 8:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第8行添加一个新变量：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Add a new method to line 16 that adds `CurrentAge` and `AddedAge` together
    and prints out the result:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第16行添加一个新的方法，将`CurrentAge`和`AddedAge`相加并打印出结果：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Call the new method inside `Start` with the following line:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Start`中调用新方法，使用以下行：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Double-check that your code looks like the following screenshot before you
    run the script in Unity:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中运行脚本之前，请确保您的代码看起来像以下截图：
- en: '![](img/B17573_02_06.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_06.png)'
- en: 'Figure 2.6: LearningCurve with new ComputeAge method'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6：具有新的ComputeAge方法的LearningCurve
- en: Save the file, and then go back and hit play in Unity to see the new **Console**
    output.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，然后返回Unity并点击播放，看看新的**控制台**输出。
- en: 'You defined your first method on lines 16 to 19 and called it on line 13\.
    Now, wherever `ComputeAge()` is called, the two variables will be added together
    and printed to the console, even if their values change. Remember, you set `CurrentAge`
    to `18` in the Unity Inspector, and the Inspector value will always override the
    value in a C# script:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您在第16到19行定义了您的第一个方法，并在第13行调用了它。现在，无论何时调用`ComputeAge()`，这两个变量都将被相加并打印到控制台上，即使它们的值发生变化。请记住，您在Unity检视器中将`CurrentAge`设置为`18`，检视器的值将始终覆盖C#脚本中的值：
- en: '![](img/B17573_02_07.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_07.png)'
- en: 'Figure 2.7: Console output from changing the variable value in the Inspector'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7：更改检视器中变量值的控制台输出
- en: Go ahead and try out different variable values in the **Inspector** panel to
    see this in action! More details on the actual code syntax of what you just wrote
    are coming up in the next chapter.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 继续尝试在**检视器**面板中尝试不同的变量值，看看它是如何运作的！关于您刚刚编写的实际代码语法的更多细节将在下一章中介绍。
- en: With a bird's-eye view of methods under our belts, we're ready to tackle the
    biggest topic in the programming landscape—classes!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们掌握了方法的整体概念之后，我们准备好着手处理编程领域中最大的主题——类！
- en: Introducing classes
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍类
- en: 'We''ve seen how variables store information and how methods perform actions,
    but our programming toolkit is still somewhat limited. We need a way of creating
    a sort of super container, containing variables and methods that can be referenced
    from within the container itself. Enter classes:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到变量存储信息，方法执行操作，但是我们的编程工具包仍然有些有限。我们需要一种创建一种超级容器的方法，其中包含可以从容器内部引用的变量和方法。输入类：
- en: '**Conceptually**, a class holds related information, actions, and behaviors
    inside a single container. They can even communicate with each other.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概念上**，类在单个容器内保存相关信息、操作和行为。它们甚至可以相互通信。'
- en: '**Technically**, classes are data structures. They can contain variables, methods,
    and other programmatic information, all of which can be referenced when an object
    of the class is created.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术上**，类是数据结构。它们可以包含变量、方法和其他编程信息，当类的对象被创建时，所有这些信息都可以被引用。'
- en: '**Practically**, a class is a blueprint. It sets out the rules and regulations
    for any object (called an instance) created using the class blueprint.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实际上**，类是一个蓝图。它为使用类蓝图创建的任何对象（称为实例）制定了规则和法规。'
- en: You've probably realized that classes surround us not only in Unity but in the
    real world as well. Next, we'll take a look at the most common Unity class and
    how classes function in the wild.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经意识到类不仅在Unity中存在，而且在现实世界中也存在。接下来，我们将看一下最常见的Unity类以及类在实际中的功能。
- en: You can find an in-depth guide to classes in the Microsoft C# documentation
    at [https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Microsoft C#文档中找到有关类的深入指南[https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes](https://docs.microsoft.com/en-us/dotnet/csharp/fundamentals/types/classes)。
- en: A common Unity class
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个常见的Unity类
- en: 'Before you wonder what a class looks like in C#, you should know that you''ve
    been working with a class this whole chapter. By default, every script created
    in Unity is a class, which you can see from the `class` keyword on line 5:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在您想知道C#中的类是什么样子之前，您应该知道您在整个本章中一直在使用一个类。默认情况下，Unity中创建的每个脚本都是一个类，您可以从第5行的`class`关键字中看到：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MonoBehaviour` just means that this class can be attached to a GameObject
    in the Unity scene.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoBehaviour`只是意味着这个类可以附加到Unity场景中的GameObject上。'
- en: Classes can exist on their own, which we'll see when we create standalone classes
    in *Chapter 5*, *Working with Classes, Structs, and OOP*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以独立存在，当我们在*第5章*中创建独立类时，我们将看到这一点。
- en: The terms script and class are sometimes used interchangeably in Unity resources.
    For consistency, I'll be referring to C# files as scripts if they're attached
    to GameObjects and as classes if they are standalone.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在Unity资源中，脚本和类这两个术语是可以互换使用的。为了保持一致，我将在脚本附加到GameObject时将C#文件称为脚本，并在它们是独立的类时称为类。
- en: Classes are blueprints
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类是蓝图
- en: For our last example, let's think about a local post office. It's a separate,
    self-contained environment that has properties, such as a physical address (a
    variable), and the ability to execute actions, such as sending out your mail (methods).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的最后一个例子，让我们想想一个当地的邮局。它是一个独立的、自包含的环境，具有属性，比如物理地址（一个变量），以及执行动作的能力，比如寄出您的邮件（方法）。
- en: 'This makes a post office a great example of a potential class that we can outline
    in the following block of pseudocode:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得邮局成为一个潜在类的绝佳例子，我们可以在以下伪代码块中概述：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The main takeaway here is that when information and behaviors follow a predefined
    blueprint, complex actions and inter-class communication become possible. For
    instance, if we had another class that wanted to send a letter through our `PostOffice`
    class, it wouldn''t have to wonder where to go to fire this action. It could simply
    call the `SendMail` function from the `PostOffice` class, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要要点是，当信息和行为遵循预定义的蓝图时，复杂的操作和类间通信变得可能。例如，如果我们有另一个类想要通过我们的`PostOffice`类发送一封信，它不必想知道去哪里执行此操作。它可以简单地从`PostOffice`类中调用`SendMail`函数，如下所示：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, you could use it to look up the address of the post office so
    you know where to post your letters:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用它查找邮局的地址，这样您就知道在哪里寄信：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you're wondering about the use of periods (called dot notation) between words,
    we'll be diving into that in the next section—hold tight.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对单词之间使用句点（称为点表示法）有疑问，我们将在下一节中详细介绍。
- en: Communication among classes
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类之间的通信
- en: Up until now, we've described classes and, by extension, Unity components as
    separate standalone entities; in reality, they are deeply intertwined. You'd be
    hard-pressed to create any kind of meaningful software application without invoking
    some kind of interaction or communication between classes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经将类和Unity组件描述为独立的实体；实际上，它们是紧密相连的。要创建任何有意义的软件应用程序，都需要在类之间进行某种形式的交互或通信。
- en: 'If you remember the post office example from earlier, the example code made
    use of periods (or dots) to reference classes, variables, and methods. If you
    think of classes as directories of information, then dot notation is the indexing
    tool:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得之前的邮局例子，示例代码使用句点（或点）来引用类、变量和方法。如果你把类想象成信息目录，那么点表示法就是索引工具：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Any variables, methods, or other data types within a class can be accessed with
    dot notation. This applies to nested, or subclass, information as well, but we'll
    tackle all those subjects when we get to *Chapter 5*, *Working with Classes, Structs,
    and OOP*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的任何变量、方法或其他数据类型都可以用点表示法访问。这也适用于嵌套或子类信息，但我们将在*第5章*“使用类、结构和面向对象编程”中讨论所有这些主题。
- en: 'Dot notation is also what drives communication between classes. Whenever a
    class needs information about another class or wants to execute one of its methods,
    dot notation is used:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点表示法也是驱动类之间通信的工具。每当一个类需要另一个类的信息或想要执行它的方法时，都会使用点表示法：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Dot notation is sometimes referred to as the `.` operator, so don't be thrown
    off if you see it mentioned this way in documentation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点表示法有时被称为`.`运算符，所以如果在文档中看到这种提法，不要感到困惑。
- en: If dot notation doesn't quite click with you yet, don't worry, it will. It's
    the bloodstream of the entire programming body, carrying information and context
    wherever it's needed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点表示法还没有完全理解，不要担心，它会的。它是整个编程体系的血脉，将信息和上下文传递到需要的地方。
- en: Now that you know a little more about classes, let's talk about the tool you'll
    use the most in your programming career—comments!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对类有了更多了解，让我们谈谈你在编程生涯中最常用的工具——注释！
- en: Working with comments
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理注释
- en: You might have noticed that `LearningCurve` has an odd line of text (**10**
    in *Figure 2.6*) starting with two forward slashes, which were created by default
    with the script.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到`LearningCurve`有一行奇怪的文本（*图2.6*中的**10**），以两个斜杠开头，这是脚本默认创建的。
- en: These are code comments! In C#, there are a few ways that you can use to create
    comments, and Visual Studio (and other code editing applications) will often make
    it even easier with built-in shortcuts.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是代码注释！在C#中，有几种方法可以用来创建注释，而Visual Studio（和其他代码编辑应用程序）通常会通过内置快捷方式使其更加容易。
- en: Some professionals wouldn't call commenting an essential building block of programming,
    but I'll have to respectfully disagree. Correctly commenting out your code with
    meaningful information is one of the most fundamental habits a new programmer
    can develop.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一些专业人士可能不认为注释是编程的基本构建块，但我不得不尊重地不同意。正确地用有意义的信息注释你的代码是新程序员可以养成的最基本的习惯之一。
- en: Single-line comments
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单行注释
- en: 'The following single-line comment is like the one we''ve included in `LearningCurve`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下单行注释与我们在`LearningCurve`中包含的注释类似：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Visual Studio doesn't compile lines starting with two forward slashes (without
    empty space) as code, so you can use them as much as needed to explain your code
    to others or your future self.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio不会将以两个斜杠开头（没有空格）的行编译为代码，因此你可以根据需要使用它们来向他人或未来的自己解释你的代码。
- en: Multi-line comments
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行注释
- en: 'Since it''s in the name, you''d be right to assume that single-line comments
    only apply to one line of code. If you want multi-line comments, you''ll need
    to use a forward slash and an asterisk, (`/*` and `*/` as opening and closing
    characters respectively) around the comment text:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 由于名称中有，你可以合理地假设单行注释只适用于一行代码。如果你想要多行注释，你需要在注释文本周围使用斜杠和星号（分别作为开头和结尾字符）：`/*`和`*/`。
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: You can also comment and uncomment blocks of code by highlighting them and using
    the `Cmd` + `/`shortcut on macOS and `Ctrl` + `K` + `C` on Windows.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过在macOS上使用`Cmd` + `/`快捷键和在Windows上使用`Ctrl` + `K` + `C`来对代码块进行注释和取消注释。
- en: Visual Studio also provides a handy auto-generated commenting feature; type
    in three forward slashes on the line preceding any line of code (variables, methods,
    classes, and more) and a summary comment block will appear.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio还提供了一个方便的自动生成注释功能；在任何代码行（变量、方法、类等）的前一行输入三个斜杠，将出现一个摘要注释块。
- en: Seeing example comments is good, but putting them in your code is always better.
    It's never too early to start commenting!
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 看到示例注释是好的，但在你的代码中加入它们总是更好的。现在开始注释永远不会太早！
- en: Adding comments
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加注释
- en: 'Open up `LearningCurve` and add in three backslashes above the `ComputeAge()`
    method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LearningCurve`，在`ComputeAge()`方法上方添加三个反斜杠：
- en: '![](img/B17573_02_08.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_08.png)'
- en: 'Figure 2.8: Triple-line comment automatically generated for a method'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8：为方法自动生成的三行注释
- en: You should see a three-line comment with a description of the method generated
    by Visual Studio from the method's name, sandwiched between two `<summary>` tags.
    You can, of course, change the text, or add new lines by hitting `Enter` just
    as you would in a text document; just make sure not to touch the `<summary>` tags
    or Visual Studio won't recognize the comments correctly.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到一个三行注释，其中包含由Visual Studio从方法名称生成的方法描述，夹在两个`<summary>`标签之间。当然，你可以通过按`Enter`键添加新行来更改文本，但一定不要触碰`<summary>`标签，否则Visual
    Studio将无法正确识别注释。
- en: 'The useful part about these detailed comments is clear when you want to know
    something about a method you''ve written. If you''ve used a triple forward slash
    comment, all you need to do is hover over the method name anywhere it''s called
    within a class or script, and Visual Studio will pop your summary:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些详细注释的有用之处在于，当您想了解自己编写的方法时，它就会变得清晰。如果您使用了三个斜杠的注释，只需将鼠标悬停在类或脚本中调用方法的任何位置，Visual
    Studio就会弹出您的摘要：
- en: '![](img/B17573_02_09.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_09.png)'
- en: 'Figure 2.9: Visual Studio pop-up info box with the comment summary'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9：带有注释摘要的Visual Studio弹出信息框
- en: Your basic programming toolkit is now complete (well, the theory drawer, at
    least). However, we still need to understand how everything we've learned in this
    chapter applies in the Unity game engine, which is what we'll be focusing on in
    the next section!
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您的基本编程工具包现在已经完成（至少是理论抽屉）。然而，我们仍然需要了解本章中所学内容在Unity游戏引擎中的应用，这将是我们下一节的重点！
- en: Putting the building blocks together
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合基本组件
- en: With the building blocks squared away, it's time to do a little Unity-specific
    housekeeping before wrapping up this chapter. Specifically, we need to know more
    about how Unity handles C# scripts attached to game objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完基本组件之后，现在是时候在结束本章之前进行一些Unity特定的整理工作了。具体来说，我们需要更多地了解Unity如何处理附加到游戏对象的C#脚本。
- en: For this example, we'll keep using our `LearningCurve` script and Main Camera
    GameObject.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将继续使用我们的`LearningCurve`脚本和Main Camera游戏对象。
- en: Scripts become components
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本变成组件
- en: All GameObject components are scripts, whether they're written by you or the
    good people at Unity. The only difference is that Unity-specific components such
    as `Transform`, and their respective scripts just aren't supposed to be edited
    by users.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的游戏对象组件都是脚本，无论是你自己编写的还是Unity团队编写的。唯一的区别是Unity特定的组件，比如`Transform`，以及它们各自的脚本，不应该被用户编辑。
- en: The moment a script that you have created is dropped onto a GameObject, it becomes
    another component of that object, which is why it appears in the **Inspector**
    panel. To Unity, it walks, talks, and acts like any other component, complete
    with public variables underneath the component that can be changed at any time.
    Even though we aren't supposed to edit the components provided by Unity, we can
    still access their properties and methods, making them powerful development tools.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建的脚本被放置到游戏对象上，它就会成为该对象的另一个组件，这就是为什么它会出现在**检视面板**中。对于Unity来说，它像任何其他组件一样行走、交谈和行动，包括组件下面的公共变量，可以随时更改。尽管我们不应该编辑Unity提供的组件，但我们仍然可以访问它们的属性和方法，使它们成为强大的开发工具。
- en: Unity also makes some automatic readability adjustments when a script becomes
    a component. You might have noticed in *Figures 2.3* and *2.5* that when we added
    `LearningCurve` to Main Camera, Unity displayed it as `Learning Curve`, with `CurrentAge`
    changing to `Current Age`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当脚本成为组件时，Unity还会进行一些自动的可读性调整。您可能已经注意到在*图2.3*和*2.5*中，当我们将`LearningCurve`添加到Main
    Camera时，Unity将其显示为`Learning Curve`，`CurrentAge`变为`Current Age`。
- en: 'We looked at how to update a variable in the **Inspector** panel in the *Variables
    act as placeholders* section, but it''s important to touch on how this works in
    more detail. There are three situations in which you can modify a property value:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在*变量作为占位符*部分，我们看了如何在**检视面板**中更新变量，但重点是要了解这是如何工作的。有三种情况可以修改属性值：
- en: In **Play Mode** in the Unity Editor window
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity编辑器窗口中的**播放模式**
- en: In **Development Mode** in the Unity Editor window
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Unity编辑器窗口中的**开发模式**
- en: In the Visual Studio code editor
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Visual Studio代码编辑器中
- en: Changes made in Play Mode take effect in real time, which is great for testing
    and fine-tuning gameplay. However, it's important to note that any changes made
    while in Play Mode will be lost when you stop the game and return to Development
    Mode.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式下进行的更改会实时生效，这对于测试和微调游戏性非常有用。然而，需要注意的是，在播放模式下进行的任何更改在停止游戏并返回开发模式时都将丢失。
- en: When you're in Development Mode, any changes that you make to the variables
    will be saved by Unity. This means that if you were to quit Unity and then restart
    it, the changes would be retained.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当您处于开发模式时，您对变量所做的任何更改都将被Unity保存。这意味着，如果您退出Unity然后重新启动它，更改将被保留。
- en: The changes that you make to values in the **Inspector** panel while in Play
    Mode do not modify your script, but they will override any values you had assigned
    in your script when in Development Mode.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式下，您在**检视面板**中对值所做的更改不会修改您的脚本，但它们会覆盖您在开发模式下分配的任何值。
- en: 'Any changes made in Play Mode will always reset automatically when you stop
    Play Mode. If you need to undo any changes made in the **Inspector** panel, you
    can reset the script to its default (sometimes called initial) values. Click on
    the three vertical dots icon to the right of any component, and then select **Reset**,
    as shown in the following screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放模式下进行的任何更改都会在停止播放模式时自动重置。如果您需要撤消在**检视面板**中所做的任何更改，可以将脚本重置为其默认（有时称为初始）值。单击任何组件右侧的三个垂直点图标，然后选择**重置**，如下面的屏幕截图所示：
- en: '![](img/B17573_02_10.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_02_10.png)'
- en: 'Figure 2.10: Script reset option in the Inspector'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10：检视面板中的脚本重置选项
- en: This should give you some peace of mind—if your variables get out of hand, there's
    always the hard reset.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该让您放心——如果您的变量失控，总是可以进行硬重置。
- en: A helping hand from MonoBehaviour
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MonoBehaviour的帮助
- en: Since C# scripts are classes, how does Unity know to make some scripts components
    and not others? The short answer is that `LearningCurve` (and any script created
    in Unity) inherits from `MonoBehaviour` (a default class provided by Unity). This
    tells Unity that the C# class can be transformed into a component.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C#脚本是类，Unity如何知道要将某些脚本转换为组件而不是其他脚本呢？简短的答案是`LearningCurve`（以及Unity创建的任何脚本）继承自`MonoBehaviour`（Unity提供的默认类）。这告诉Unity，这个C#类可以被转换为组件。
- en: The topic of class inheritance is a bit advanced for this point of your programming
    journey; think of it as the `MonoBehaviour` class lending a few of its variables
    and methods to `LearningCurve`. *Chapter 5*, *Working with Classes, Struct, and
    OOP*, will cover class inheritance in practical detail.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承的主题对于您的编程之旅来说有点高级；把`MonoBehaviour`类想象成向`LearningCurve`借用一些变量和方法。*第5章*，*使用类、结构和面向对象编程*，将详细介绍类继承。
- en: The `Start()` and `Update()` methods that we've used belong to `MonoBehaviour`,
    which Unity runs automatically on any script attached to a GameObject. The `Start()`
    method runs once when the scene starts playing, while the `Update()` method runs
    once per frame (depending on the frame rate of your machine).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的`Start()`和`Update()`方法属于`MonoBehaviour`，Unity会自动在附加到GameObject的任何脚本上运行它们。`Start()`方法在场景开始播放时运行一次，而`Update()`方法在每帧运行一次（取决于您的机器的帧率）。
- en: Now that your familiarity with Unity's documentation has gotten a nice bump,
    I've put together a short optional challenge for you to tackle!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对Unity的文档熟悉度有了很大提升，我为您准备了一个简短的可选挑战！
- en: Hero's trial – MonoBehaviour in the Scripting API
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 英雄的试炼-脚本API中的MonoBehaviour
- en: 'Now it''s time for you to get comfortable using the Unity documentation on
    your own, and what better way than to look up some of the common `MonoBehaviour`
    methods:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候让您自己熟悉使用Unity文档了，还有什么比查找一些常见的`MonoBehaviour`方法更好的方法呢：
- en: Try searching for the `Start()` and `Update()` methods in the Scripting API
    to gain a better understanding of what they do in Unity, and when
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在脚本API中搜索`Start()`和`Update()`方法，以更好地了解它们在Unity中的作用，以及何时
- en: If you're feeling brave, go the extra step and have a look at the `MonoBehaviour`
    class in the manual for a more detailed explanation
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您感到勇敢，可以进一步查看手册中的`MonoBehaviour`类，以获得更详细的解释
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've come a long way in a few short pages, but understanding the overarching
    theory of fundamental concepts such as variables, methods, and classes will give
    you a strong foundation to build on. Bear in mind that these building blocks have
    very real counterparts in the real world. Variables hold values like mailboxes
    hold letters; methods store instructions like recipes, to be followed for a predefined
    result; and classes are blueprints just like real blueprints. You can't build
    a house without a well-thought-out design to follow if you expect it to stay standing.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在短短的几页中走了很长的路，但是理解变量、方法和类等基本概念的总体理论将为您打下坚实的基础。请记住，这些构建块在现实世界中有非常真实的对应物。变量保存值，就像邮箱保存信件一样；方法存储指令，就像食谱一样，用于预定义的结果；类就像真实的蓝图一样。如果您希望房子能够屹立不倒，就不能没有经过深思熟虑的设计来遵循。
- en: The rest of this book will take you on a deep dive into C# syntax from scratch,
    starting with more detail in the next chapter on how to create variables, manage
    value types, and work with simple and complex methods.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将带您深入学习C#语法，从头开始，从下一章开始更详细地介绍如何创建变量、管理值类型以及使用简单和复杂的方法。
- en: Pop quiz – C# building blocks
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小测验-C#构建块
- en: What is the main purpose of a variable?
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量的主要目的是什么？
- en: What role do methods play in scripts?
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法在脚本中扮演什么角色？
- en: How does a script become a component?
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本如何成为组件？
- en: What is the purpose of dot notation?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点符号的目的是什么？
- en: JOIN us on Discord!
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C#专家和Harrison Ferrone一起阅读本书。提出问题，为其他读者提供解决方案，通过*问我任何事*会话与作者交谈，以及更多。
- en: Join Now!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code_9781801813945.png)'
