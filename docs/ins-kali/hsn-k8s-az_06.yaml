- en: 4\. Building scalable applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4\. 构建可扩展的应用程序
- en: When running an application, the ability to scale and upgrade your application
    is critical. **Scaling** is required to handle additional loads with your application,
    while upgrading is required to keep your application up to date and to be able
    to introduce new functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行应用程序时，扩展和升级应用程序的能力至关重要。**扩展**是处理应用程序的额外负载所必需的，而升级是保持应用程序最新并能够引入新功能所必需的。
- en: Scaling on demand is one of the key benefits of using cloud-native applications.
    It also helps optimize resources for your application. If the front-end component
    encounters heavy loads, you can scale the front end alone, while keeping the same
    number of back-end instances. You can increase or reduce the number/size of **Virtual
    Machines** (**VM**) required depending on your workload and peak demand hours.
    This chapter will cover both the scale dimensions in detail.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 按需扩展是使用基于云的应用程序的关键好处之一。它还有助于优化应用程序的资源。如果前端组件遇到重负载，您可以单独扩展前端，同时保持相同数量的后端实例。您可以根据工作负载和高峰需求小时增加或减少所需的**虚拟机**（**VM**）的数量/大小。本章将详细介绍两种扩展维度。
- en: In this chapter, we will show you how to scale the sample guestbook application
    that we introduced in *Chapter 3,* *Application deployment on AKS*. We will first
    scale this application using manual commands, and afterward we'll autoscale it
    using the **Horizontal Pod Autoscaler (HPA)**. The goal is to make you comfortable
    with `kubectl`, which is an important tool for managing applications running on
    top of the **Azure Kubernetes** **Service** (**AKS**). After scaling the application
    itself, we will also scale the cluster. We'll first scale the cluster manually,
    and then use the cluster autoscaler to automatically scale the cluster. In addition,
    in this chapter, you will get a brief introduction to how you can upgrade applications
    running on top of AKS.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您展示如何扩展我们在*第3章* *在AKS上部署应用程序*中介绍的示例留言簿应用程序。我们将首先使用手动命令扩展此应用程序，然后我们将使用**水平Pod自动缩放器（HPA）**对其进行自动缩放。我们的目标是让您熟悉`kubectl`，这是管理在**Azure
    Kubernetes** **Service**（**AKS**）上运行的应用程序的重要工具。在扩展应用程序本身之后，我们还将扩展集群。我们将首先手动扩展集群，然后使用集群自动缩放器自动扩展集群。此外，在本章中，您将简要介绍如何升级在AKS上运行的应用程序。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Scaling your application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的应用程序
- en: Scaling your cluster
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展您的集群
- en: Upgrading your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级您的应用程序
- en: We will start this chapter by discussing the different dimensions when it comes
    to scaling applications on top of AKS.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论在AKS上扩展应用程序时涉及的不同维度开始本章。
- en: Note
  id: totrans-9
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the previous chapter, we cloned the example files in Cloud Shell. If you
    didn''t do this back then, we recommend doing that now:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在Cloud Shell中克隆了示例文件。如果您当时没有这样做，我们建议现在这样做：
- en: '`git clone` [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure---Second-Edition/tree/SecondEdition](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure---Second-Edition/tree/SecondEdition)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`git clone` [https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure---Second-Edition/tree/SecondEdition](https://github.com/PacktPublishing/Hands-On-Kubernetes-on-Azure---Second-Edition/tree/SecondEdition)'
- en: 'For this chapter, navigate to the `Chapter04` directory:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，请导航到`Chapter04`目录：
- en: '`cd Chapter04`'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd Chapter04`'
- en: Scaling your application
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展您的应用程序
- en: There are two scale dimensions for applications running on top of AKS. The first
    scale dimension is the number of Pods a deployment has, while the second scale
    dimension in AKS is the number of nodes in the cluster.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在AKS上运行的应用程序有两个扩展维度。第一个扩展维度是部署的Pod的数量，而AKS中的第二个扩展维度是集群中节点的数量。
- en: By adding additional Pods to a deployment, also known as scaling out, you add
    additional compute power to the deployed application. You can either scale out
    your applications manually or have Kubernetes take care of this automatically
    via the HPA. The HPA will watch metrics such as CPU to determine whether Pods
    need to be added to your deployment.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向部署添加额外的Pod，也称为扩展，您为部署的应用程序增加了额外的计算能力。您可以手动扩展应用程序，也可以让Kubernetes通过HPA自动处理这一点。HPA将监视诸如CPU之类的指标，以确定是否需要向部署添加Pod。
- en: The second scale dimension in AKS is the number of nodes in the cluster. The
    number of nodes in a cluster defines how much CPU and memory are available for
    all the applications running on that cluster. You can scale your cluster either
    manually by changing the number of nodes, or you can use the cluster autoscaler
    to automatically scale out your cluster. The cluster autoscaler will watch the
    cluster for Pods that cannot be scheduled due to resource constraints. If Pods
    cannot be scheduled, it will add nodes to the cluster to ensure that your applications
    can run.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: AKS中的第二个扩展维度是集群中的节点数。集群中的节点数定义了集群上所有应用程序可用的CPU和内存量。您可以通过手动更改节点数来扩展集群，也可以使用集群自动缩放器自动扩展集群。集群自动缩放器将监视无法由于资源约束而无法调度的Pod。如果无法调度Pod，它将向集群添加节点，以确保您的应用程序可以运行。
- en: Both scale dimensions will be covered in this chapter. In this section, you
    will learn how you can scale your application. First, you will scale your application
    manually, and then later, you will scale your application automatically.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖两个扩展维度。在本节中，您将学习如何扩展您的应用程序。首先，您将手动扩展您的应用程序，然后，您将自动扩展您的应用程序。
- en: Implementing scaling of your application
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施应用程序的扩展
- en: 'To demonstrate manual scaling, let''s use the guestbook example that we used
    in the previous chapter. Follow these steps to learn how to implement manual scaling:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示手动扩展，让我们使用在上一章中使用的guestbook示例。按照以下步骤学习如何实施手动扩展：
- en: 'Install the guestbook by running the `kubectl create` command in the Azure
    command line:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在Azure命令行中运行`kubectl create`命令来安装guestbook：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: After you have entered the preceding command, you should see something similar,
    as shown in *Figure 4.1*, in your command-line output:![When you execute the command,
    your command-line output will list the services and deployments are created.](image/Figure_4.1.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入上述命令后，您应该在命令行输出中看到类似的内容，如*图4.1*所示：![当您执行该命令时，您的命令行输出将列出已创建的服务和部署。](image/Figure_4.1.jpg)
- en: 'Figure 4.1: Launching the guestbook application'
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：启动guestbook应用程序
- en: 'Right now, none of the services are publicly accessible. We can verify this
    by running the following command:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，没有任何服务是公开可访问的。我们可以通过运行以下命令来验证这一点：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*Figure 4.2* shows that none of the services have an external IP:![The output
    screen will display the External-IP column as <none>. This indicates that none
    of the services have a public IP.](image/Figure_4.2.jpg)'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图4.2*显示没有任何服务具有外部IP：![输出屏幕将显示External-IP列为<none>。这表示没有任何服务具有公共IP。](image/Figure_4.2.jpg)'
- en: 'Figure 4.2: Output displaying none of the services having a public IP'
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2：显示没有任何服务具有公共IP的输出
- en: 'To test out our application, we will expose it publicly. For this, we will
    introduce a new command that will allow you to edit the service in Kubernetes
    without having to change the file on your file system. To start the edit, execute
    the following command:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试我们的应用程序，我们将公开它。为此，我们将介绍一个新的命令，允许您在Kubernetes中编辑服务，而无需更改文件系统上的文件。要开始编辑，请执行以下命令：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will open a `vi` environment. Navigate to the line that now says `type:`
    `ClusterIP` (line 27) and change that to `type: LoadBalancer`, as shown in *Figure
    4.3*. To make that change, hit the *I* button, type your changes, hit the *Esc*
    button, type `:wq!`, and then hit *Enter* to save the changes:![Output displays
    that line 27 is replaced by Type: LoadBalancer.](image/Figure_4.3.jpg)'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将打开一个`vi`环境。导航到现在显示为`type:` `ClusterIP`（第27行），并将其更改为`type: LoadBalancer`，如*图4.3*所示。要进行更改，请按*I*按钮，输入更改，按*Esc*按钮，输入`:wq!`，然后按*Enter*保存更改：![输出显示第27行被Type:
    LoadBalancer替换。](image/Figure_4.3.jpg)'
- en: 'Figure 4.3: Changing this line to type: LoadBalancer'
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图4.3：将此行更改为type: LoadBalancer'
- en: 'Once the changes are saved, you can watch the service object until the public
    IP becomes available. To do this, type the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，您可以观察服务对象，直到公共IP可用。要做到这一点，请输入以下内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It will take a couple of minutes to show you the updated IP. Once you see the
    correct public IP, you can exit the `watch` command by hitting *Ctrl* + *C* (*command
    + C* on Mac):![Using the kubectl get svc -w command, the external-ip of the frontend
    Service will change from <pending> to an actual external IP address.](image/Figure_4.4.jpg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新IP地址可能需要几分钟时间。一旦看到正确的公共IP，您可以通过按*Ctrl* + *C*（Mac上为*command + C*）退出`watch`命令：![使用kubectl
    get svc -w命令，前端服务的外部IP将从<pending>更改为实际的外部IP地址。](image/Figure_4.4.jpg)
- en: 'Figure 4.4: Output showing the front-end service getting a public IP'
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：显示前端服务获得公共IP
- en: 'Type the IP address from the preceding output into your browser navigation
    bar as follows: `http://<EXTERNAL-IP>/`. The result of this is shown in *Figure
    4.5*:![Enter the External-IP obtained from the preceding command to your browser
    navigation bar. A white screen withthe word Guestbook in bold is displayed.](image/Figure_4.5.jpg)'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器导航栏中输入前面命令获取的IP地址，如下所示：`http://<EXTERNAL-IP>/`。其结果如*图4.5*所示：![在浏览器导航栏中输入前面命令获取的外部IP。显示一个带有粗体字Guestbook的白屏。](image/Figure_4.5.jpg)
- en: 'Figure 4.5: Browse to the guestbook application'
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：浏览访客留言应用程序
- en: The familiar guestbook sample should be visible. This shows that you have successfully
    publicly accessed the guestbook.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉的访客留言示例应该是可见的。这表明您已成功地公开访问了访客留言。
- en: Now that you have the guestbook application deployed, you can start scaling
    the different components of the application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经部署了访客留言应用程序，可以开始扩展应用程序的不同组件。
- en: Scaling the guestbook front-end component
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展访客留言前端组件
- en: 'Kubernetes gives us the ability to scale each component of an application dynamically.
    In this section, we will show you how to scale the front end of the guestbook
    application. This will cause Kubernetes to add additional Pods to the deployment:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes使我们能够动态地扩展应用程序的每个组件。在本节中，我们将向您展示如何扩展访客留言应用程序的前端。这将导致Kubernetes向部署添加额外的Pods：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can set the number of replicas you want, and Kubernetes takes care of the
    rest. You can even scale it down to zero (one of the tricks used to reload the
    configuration when the application doesn''t support the dynamic reload of configuration).
    To verify that the overall scaling worked correctly, you can use the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以设置要使用的副本数，Kubernetes会处理其余的工作。您甚至可以将其缩减为零（用于重新加载配置的技巧之一，当应用程序不支持动态重新加载配置时）。要验证整体扩展是否正确工作，您可以使用以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This should give you an output as shown in *Figure 4.6*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给您一个如*图4.6*所示的输出：
- en: '![Upon executing the kubectl get pods command, you will see sixPods are now
    running for the frontend.](image/Figure_4.6.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: 执行kubectl get pods命令后，您将看到前端现在运行了六个Pods。
- en: 'Figure 4.6: Different Pods running in the guestbook application after scaling
    out'
  id: totrans-48
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：扩展后访客留言应用程序中运行的不同Pods
- en: 'As you can see, the front-end service scaled to six Pods. Kubernetes also spread
    these Pods across multiple nodes in the cluster. You can see the nodes that this
    is running on with the following command:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，前端服务扩展到了六个Pod。Kubernetes还将这些Pod分布在集群中的多个节点上。您可以使用以下命令查看此服务运行在哪些节点上：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will generate an output as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成以下输出：
- en: '![Executing the kubectl get pods -o wide command displays the nodes on which
    the Pods are running.](image/Figure_4.7.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get pods -o wide命令会显示Pod所在的节点。](image/Figure_4.7.jpg)'
- en: 'Figure 4.7: Showing which nodes the Pods are running on'
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：显示Pod运行在哪些节点上。
- en: In this section, you have seen how easy it is to scale Pods with Kubernetes.
    This capability provides a very powerful tool for you to not only dynamically
    adjust your application components, but also provide resilient applications with
    failover capabilities enabled by running multiple instances of components at the
    same time. However, you won't always want to manually scale your application.
    In the next section, you will learn how you can automatically scale your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经看到了使用Kubernetes扩展Pod有多么容易。这种能力为您提供了一个非常强大的工具，不仅可以动态调整应用程序组件，还可以通过同时运行多个组件实例来提供具有故障转移能力的弹性应用程序。然而，您并不总是希望手动扩展您的应用程序。在下一节中，您将学习如何自动扩展您的应用程序。
- en: Using the HPA
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用HPA
- en: Scaling manually is useful when you're working on your cluster. In most cases,
    however, you will want some sort of autoscaling to happen on your application.
    In Kubernetes, you can configure autoscaling of your deployment using an object
    called the **Horizontal Pod Autoscaler** (**HPA**).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在您工作在集群上时，手动扩展是有用的。然而，在大多数情况下，您希望应用程序发生某种自动缩放。在Kubernetes中，您可以使用名为**水平Pod自动缩放器**（**HPA**）的对象来配置部署的自动缩放。
- en: The HPA monitors Kubernetes metrics at regular intervals and, based on rules
    you define, autoscales your deployment. For example, you can configure the HPA
    to add additional Pods to your deployment once the CPU utilization of your application
    is above 50%.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: HPA定期监视Kubernetes指标，并根据您定义的规则自动缩放您的部署。例如，您可以配置HPA在应用程序的CPU利用率超过50%时向部署添加额外的Pod。
- en: 'In this section, you will configure the HPA to scale the front end of the application
    automatically:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将配置HPA自动扩展应用程序的前端部分：
- en: 'To start the configuration, let''s first manually scale down our deployment
    to 1 instance:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始配置，让我们首先手动将我们的部署缩减到1个实例：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next up, we''ll create an HPA. Open up the code editor in Cloud Shell by typing
    `code hpa.yaml` and enter the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个HPA。通过输入`code hpa.yaml`在Cloud Shell中打开代码编辑器，并输入以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s investigate what is configured in this file:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个文件中配置了什么：
- en: '**Line 2:** Here, we define that we need `HorizontalPodAutoscaler`.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第2行**：在这里，我们定义了需要`HorizontalPodAutoscaler`。'
- en: '**Lines 6-9**: These lines define the deployment that we want to autoscale.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第6-9行**：这些行定义了我们要自动缩放的部署。'
- en: '**Lines 10-11**: Here, we configure the minimum and maximum Pods in our deployment.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第10-11行**：在这里，我们配置了部署中的最小和最大Pod数。'
- en: '**Lines 12-16**: Here, we define the metric that Kubernetes will be monitoring,
    in order to do the scaling.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第12-16行**：在这里，我们定义了Kubernetes将要监视的指标，以便进行扩展。'
- en: 'Save this file, and create the HPA using the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存此文件，并使用以下命令创建HPA：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create our autoscaler. You can see your autoscaler with the following
    command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的自动缩放器。您可以使用以下命令查看您的自动缩放器：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will initially output something as shown in *Figure 4.8*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将最初输出如*图4.8*所示的内容：
- en: '![Executing kubectl get hpa shows the horizontal pod autoscaler that was created.
    The target shows as <unknown>, indicating the hpa isn''t fully ready yet.](image/Figure_4.8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get hpa显示已创建的水平Pod自动缩放器。目标显示为<unknown>，表示HPA尚未完全准备好。](image/Figure_4.8.jpg)'
- en: 'Figure 4.8: The target unknown shows that the HPA isn''t ready yet'
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：未知的目标显示HPA尚未准备好
- en: 'It takes a couple of seconds for the HPA to read the metrics. Wait for the
    return from the HPA to look something similar to the output shown in *Figure 4.9*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: HPA需要几秒钟来读取指标。等待HPA返回的结果看起来类似于*图4.9*中显示的输出：
- en: '![Executing kubectl get hpa --watch shows the value of targets change from
    <unknown> to an actual value of 10% in this screenshot.](image/Figure_4.9.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get hpa --watch显示目标值从<unknown>更改为此截图中的实际值10%。](image/Figure_4.9.jpg)'
- en: 'Figure 4.9: Once the target shows a percentage, the HPA is ready'
  id: totrans-77
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.9：一旦目标显示百分比，HPA就准备好了
- en: 'We''ll now go ahead and do two things: first, we will watch our Pods to see
    whether new Pods are created. Then, we will create a new shell, and create some
    load for our system. Let''s start with the first task – watching our Pods:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续做两件事：首先，我们将观察我们的Pods，看看是否创建了新的Pods。然后，我们将创建一个新的shell，并为我们的系统创建一些负载。让我们从第一个任务开始——观察我们的Pods：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will continuously monitor the Pods that get created or terminated.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将持续监视创建或终止的Pod。
- en: 'Let''s now create some load in a new shell. In Cloud Shell, hit the button
    to open a new shell:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在一个新的shell中创建一些负载。在Cloud Shell中，点击按钮打开一个新的shell：
- en: '![Click the icon on the toolbar that has a plus sign on its edge. This button
    opens a new Cloud Shell.](image/Figure_4.10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![单击工具栏上带有加号标志的图标。此按钮将打开一个新的Cloud Shell。](image/Figure_4.10.jpg)'
- en: 'Figure 4.10: Use this button to open a new Cloud Shell'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.10：使用此按钮打开一个新的Cloud Shell
- en: This will open a new tab in your browser with a new session in Cloud Shell.
    We will generate some load for our application from this tab.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在浏览器中打开一个新的选项卡，其中包含Cloud Shell中的新会话。我们将从这个选项卡为我们的应用程序生成一些负载。
- en: 'Next, we will use a program called `hey` to generate this load. `hey` is a
    tiny program that sends loads to a web application. We can install and run `hey`
    using the following commands:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将使用一个名为`hey`的程序来生成这个负载。`hey`是一个发送负载到Web应用程序的小程序。我们可以使用以下命令安装和运行`hey`：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `hey` program will now try to create up to 20 million connections to our
    front end. This will generate CPU loads on our system, which will trigger the
    HPA to start scaling our deployment. It will take a couple of minutes for this
    to trigger a scale action, but at a certain point, you should see multiple Pods
    being created to handle the additional load as shown in *Figure 4.11*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`hey`程序现在将尝试创建多达2000万个连接到我们的前端。这将在我们的系统上生成CPU负载，这将触发HPA开始扩展我们的部署。这将需要几分钟才能触发扩展操作，但在某个时刻，您应该看到创建多个Pod来处理额外的负载，如*图4.11*所示：'
- en: '![Executing kubectl get pods -w will show new pods of the frontend being created.
    You will see new pods change their status fromPending to ContainerCreating to
    Running.](image/Figure_4.11.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get pods -w将显示正在创建的前端新Pod。您将看到新的Pod从Pending状态更改为ContainerCreating状态再到Running状态。](image/Figure_4.11.jpg)'
- en: 'Figure 4.11: New Pods get started by the HPA'
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.11：HPA启动新的Pod
- en: At this point, you can go ahead and kill the `hey` program by hitting *Ctrl*
    + *C* (*command* + *C* on Mac).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可以继续通过按*Ctrl* + *C*（Mac上的*command* + *C*）来终止`hey`程序。
- en: 'Let''s have a closer look at what our HPA did by running the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过运行以下命令来更仔细地查看我们的HPA所做的事情：
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can see a few interesting points in the `describe` operation, as shown in
    *Figure 4.12*:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在“描述”操作中看到一些有趣的点，如*图4.12*所示：
- en: '![Executing the kubectl describe hpa command will generate a detailed view
    of the HPA. You will see the resource load, a message saying TooManyReplicas,
    and the HPA will scale from 1 to 4, to 8, to 10.](image/Figure_4.12.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl describe hpa命令将生成HPA的详细视图。您将看到资源负载，一个显示TooManyReplicas的消息，HPA将从1扩展到4，然后到8，最后到10。](image/Figure_4.12.jpg)'
- en: 'Figure 4.12: Detailed view of the HPA'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.12：HPA的详细视图
- en: 'The annotations in *Figure 4.12* are explained as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '*图4.12*中的注释解释如下：'
- en: '**1**: This shows you the current CPU utilization (132%) versus the desired
    (25%). The current CPU utilization will likely be different in your situation.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**1**：这向您显示当前的CPU利用率（132%）与期望值（25%）的对比。当前的CPU利用率在您的情况下可能会有所不同。'
- en: '**2**: This shows you that the current desired replica count is higher than
    the actual maximum we had configured. This ensures that a single deployment doesn''t
    consume all resources in the cluster.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**2**：这向您显示当前期望的副本数高于我们配置的实际最大值。这确保了单个部署不会消耗集群中的所有资源。'
- en: '**3**: This shows you the scaling actions that the HPA took. It first scaled
    to 4, then to 8, and then to 10 Pods in the deployment.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**3**：这向您显示了HPA所采取的扩展操作。它首先将部署扩展到4个，然后扩展到8个，然后扩展到10个Pod。'
- en: 'If you wait for a couple of minutes, the HPA should start to scale down. You
    can track this scale-down operation using the following command:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您等待几分钟，HPA应该开始缩减。您可以使用以下命令跟踪此缩减操作：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will track the HPA and show you the gradual scaling down of the deployment,
    as displayed in *Figure 4.13*:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这将跟踪HPA并向您显示部署的逐渐缩减，如*图4.13*所示：
- en: '![When you execute the kubectl get hpa -w command, you will see that the number
    of replicas gradually goes down.](image/Figure_4.13.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![当您执行kubectl get hpa -w命令时，您将看到副本数量逐渐减少。](image/Figure_4.13.jpg)'
- en: 'Figure 4.13: Watching the HPA scale down'
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.13：观察HPA的缩减
- en: 'Before we move on to the next section, let''s clean up the resources we created
    in this section:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们清理一下在本节中创建的资源：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this section, we first manually and then automatically scaled our application.
    However, the cluster resources were static; we ran this on a two-node cluster.
    In many cases, you might also run out of resources on the cluster itself. In the
    next section, we will deal with that issue, and explain how you can scale your
    AKS cluster yourself.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先手动，然后自动扩展了我们的应用程序。但是，集群资源是静态的；我们在一个两节点的集群上运行了这个。在许多情况下，您可能也会在集群本身耗尽资源。在下一节中，我们将处理这个问题，并解释如何自己扩展您的AKS集群。
- en: Scaling your cluster
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展您的集群
- en: In the previous section, we dealt with scaling the application running on top
    of a cluster. In this section, we'll explain how you can scale the actual cluster
    you are running. We will first discuss how you can manually scale your cluster.
    We'll start with scaling down our cluster to one node. Then, we'll configure the
    cluster autoscaler. The cluster autoscaler will monitor our cluster and will scale
    out when there are Pods that cannot be scheduled on our cluster.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们处理了在集群顶部运行的应用程序的扩展。在本节中，我们将解释如何扩展您正在运行的实际集群。我们将首先讨论如何手动扩展您的集群。我们将从将我们的集群缩减到一个节点开始。然后，我们将配置集群自动缩放器。集群自动缩放器将监视我们的集群，并在无法在我们的集群上安排的Pod时进行扩展。
- en: Manually scaling your cluster
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 手动扩展您的集群
- en: You can manually scale your AKS cluster by setting a static number of nodes
    for the cluster. The scaling of your cluster can be done either via the Azure
    portal or via the command line.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过为集群设置静态节点数来手动扩展您的AKS集群。您可以通过Azure门户或命令行来扩展您的集群。
- en: In this section, we'll show you how you can manually scale your cluster by scaling
    the cluster down to one node. This will cause Azure to remove one of the nodes
    from your cluster. First, the workload on the node that is about to be removed
    will be rescheduled onto the other node. Once the workload is safely rescheduled,
    the node will be removed from your cluster, and then the VM will be deleted from
    Azure.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何通过将集群缩减到一个节点来手动扩展您的集群。这将导致Azure从您的集群中移除一个节点。首先，即将被移除的节点上的工作负载将被重新调度到其他节点上。一旦工作负载安全地重新调度，节点将从您的集群中移除，然后VM将从Azure中删除。
- en: 'To scale your cluster, follow these steps:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展您的集群，请按照以下步骤操作：
- en: Open the Azure portal and go to your cluster. Once there, go to **Node pools**
    and click on the number below **Node count**, as shown in *Figure 4.14*:![Upon
    opening your cluster on the Azure portal, go to the Node pools tab in the navigation
    pane located on the leftside of the screen. Click on the tab. You will see the
    details of the node. Click on the number 2 onthe Node count tab to change the
    number of nodes.](image/Figure_4.14.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Azure门户并转到您的集群。一旦到达那里，转到**节点池**并点击**节点计数**下面的数字，如*图4.14*所示：![在Azure门户上打开您的集群后，转到左侧屏幕上的导航窗格中的节点池选项卡。点击该选项卡。您将看到节点的详细信息。点击节点计数选项卡上的数字2以更改节点数。](image/Figure_4.14.jpg)
- en: 'Figure 4.14: Manually scaling the cluster'
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.14：手动扩展集群
- en: This will open a pop-up that will give the option to scale your cluster. For
    our example, we will scale down our cluster to one node, as shown in *Figure 4.15*:![When
    you click on the Node count tab, a pop-up window will appear that will give you
    a choice to scale your cluster. Scale it down to one node.](image/Figure_4.15.jpg)
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个弹出窗口，其中将提供扩展集群的选项。在我们的示例中，我们将将集群缩减到一个节点，如*图4.15*所示：![当您点击节点计数选项卡时，将弹出一个窗口，让您选择扩展您的集群。将其缩减到一个节点。](image/Figure_4.15.jpg)
- en: 'Figure 4.15: Pop-up confirming the new cluster size'
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.15：确认新集群大小的弹出窗口
- en: Hit the **Apply** button at the bottom of the screen to save these settings.
    This will cause Azure to remove a node from your cluster. This process will take
    about 5 minutes to complete. You can follow the progress by clicking on the notification
    icon at the top of the Azure portal as follows:![The process of scaling down of
    nodes takes some time. To see the progress, click on the bell icon in the toolbar
    to open the notifications.](image/Figure_4.16.jpg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕底部的**应用**按钮以保存这些设置。这将导致Azure从您的集群中移除一个节点。这个过程大约需要5分钟才能完成。您可以通过点击Azure门户顶部的通知图标来跟踪进度，如下所示：![节点缩减的过程需要一些时间。要查看进度，请点击工具栏中的铃铛图标以打开通知。](image/Figure_4.16.jpg)
- en: 'Figure 4.16: Cluster scaling can be followed using the notifications in the
    Azure portal'
  id: totrans-119
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.16：可以通过Azure门户中的通知来跟踪集群的扩展
- en: 'Once this scale-down operation has completed, we will relaunch our guestbook
    application on this small cluster:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这个缩减操作完成，我们将在这个小集群上重新启动我们的guestbook应用程序：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, we will scale out the guestbook so that it can no longer
    run on our small cluster. We will then configure the cluster autoscaler to scale
    out our cluster.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将扩展guestbook，以便它不再在我们的小集群上运行。然后，我们将配置集群自动缩放器来扩展我们的集群。
- en: Scaling your cluster using the cluster autoscaler
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用集群自动缩放器扩展您的集群
- en: In this section, we will explore the cluster autoscaler. The cluster autoscaler
    will monitor the deployments in your cluster and scale your cluster to meet your
    application requirements. The cluster autoscaler watches the number of Pods in
    your cluster that cannot be scheduled due to insufficient resources. We will first
    force our deployment to have Pods that cannot be scheduled, and then we will configure
    the cluster autoscaler to automatically scale our cluster.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨集群自动缩放器。集群自动缩放器将监视集群中的部署，并根据您的应用程序需求来扩展您的集群。集群自动缩放器会监视集群中由于资源不足而无法被调度的Pod的数量。我们将首先强制我们的部署有无法被调度的Pod，然后我们将配置集群自动缩放器自动扩展我们的集群。
- en: 'To force our cluster to be out of resources, we will—manually—scale up the
    `redis-slave` deployment. To do this, use the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制我们的集群资源不足，我们将手动扩展`redis-slave`部署。要做到这一点，请使用以下命令：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can verify that this command was successful by looking at the Pods in our
    cluster:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看我们集群中的Pod来验证此命令是否成功：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This should show you something similar to an output generated in *Figure 4.17*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示类似于*图4.17*中生成的输出：
- en: '![Executing kubectl get pods will show four pods in thePending state. This
    means they cannot be scheduled on a node.](image/Figure_4.17.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get pods将显示四个处于挂起状态的Pod。这意味着它们无法被调度到节点上。](image/Figure_4.17.jpg)'
- en: 'Figure 4.17: Four out of five Pods are pending, meaning they cannot be scheduled'
  id: totrans-131
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.17：五个Pod中有四个处于挂起状态，意味着它们无法被调度
- en: As you can see, we now have four Pods in a `Pending` state. The `Pending` state
    in Kubernetes means that that Pod cannot be scheduled onto a node. In our case,
    this is due to the cluster being out of resources.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有四个处于“挂起”状态的Pod。在Kubernetes中，“挂起”状态意味着该Pod无法被调度到节点上。在我们的情况下，这是由于集群资源不足造成的。
- en: 'We will now configure the cluster autoscaler to automatically scale our cluster.
    As in the manual scaling in the previous section, there are two ways you can configure
    the cluster autoscaler. You can configure it either via the Azure portal—similar
    to how we did the manual scaling—or you can configure it using the **command-line
    interface (CLI)**. In this example, we will use the CLI to enable the cluster
    autoscaler. The following command will configure the cluster autoscaler for our
    cluster:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将配置集群自动缩放器自动扩展我们的集群。与上一节中的手动扩展一样，您可以通过两种方式配置集群自动缩放器。您可以通过Azure门户配置它，类似于我们进行手动扩展的方式，或者您可以使用**命令行界面（CLI）**进行配置。在本例中，我们将使用CLI来启用集群自动缩放器。以下命令将为我们的集群配置集群自动缩放器：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command configures the cluster autoscaler on the nodepool we have in our
    cluster. It configures it to have a minimum of one node and a maximum of three
    nodes. This will take a couple of minutes to configure.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在我们集群中的节点池上配置了集群自动缩放器。它将其配置为最少一个节点和最多三个节点。这将花费几分钟来配置。
- en: 'Once the cluster autoscaler is configured, you can see it in action by using
    the following command to watch the number of nodes in your cluster:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了集群自动缩放器后，您可以使用以下命令来观察集群中节点的数量：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It will take about 5 minutes for the new node to show up and become `Ready`
    in the cluster. Once the new node is `Ready`, you can stop watching the nodes
    by hitting *Ctrl* + *C* (*command* + *C* on Mac). You should see an output similar
    to the one in *Figure 4.18*:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点出现并在集群中变为“Ready”大约需要5分钟。一旦新节点处于“Ready”状态，您可以通过按下*Ctrl* + *C*（Mac上的*command*
    + *C*）来停止观察节点。您应该看到类似于*图4.18*中的输出：
- en: '![The kubectl get nodes -w command shows the new node being added to the cluster
    and the status changing from NotReady to Ready.](image/Figure_4.18.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![kubectl get nodes -w命令显示新节点被添加到集群，并且状态从NotReady变为Ready。](image/Figure_4.18.jpg)'
- en: 'Figure 4.18: The new node joins the cluster'
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.18：新节点加入集群
- en: 'The new node should ensure that our cluster has sufficient resources to schedule
    the scaled-out `redis-slave` deployment. To verify this, run the following command
    to check the status of the Pods:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 新节点应该确保我们的集群有足够的资源来调度扩展的`redis-slave`部署。要验证这一点，请运行以下命令来检查Pod的状态：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This should show you all the Pods in a `Running` state as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示所有处于`Running`状态的Pod，如下所示：
- en: '![Executing the kubectl get pods command displays the status of all the Pods
    as Running.](image/Figure_4.19.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl get pods命令显示所有Pod的状态为Running。](image/Figure_4.19.jpg)'
- en: 'Figure 4.19: All Pods are now in a Running state'
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.19：所有Pod现在都处于Running状态
- en: 'We will now clean up the resources we created, disable the cluster autoscaler,
    and ensure that our cluster has two nodes for the next examples. To do this, use
    the following commands:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将清理我们创建的资源，禁用集群自动缩放器，并确保我们的集群在接下来的示例中有两个节点。要做到这一点，请使用以下命令：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The last command from the previous example will show you an error if the cluster
    already has two nodes. You can safely ignore this error.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个示例中的最后一个命令将在集群已经有两个节点的情况下显示错误。您可以安全地忽略此错误。
- en: In this section, we first manually scaled down our cluster, and then we used
    the cluster autoscaler to scale out our cluster. We first used the Azure portal
    to scale out the cluster manually, and then we also used the Azure CLI to configure
    the cluster autoscaler. In the next section, we will look into how we can upgrade
    applications running on AKS.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先手动缩减了我们的集群，然后我们使用了集群自动缩放器来扩展我们的集群。我们首先使用Azure门户手动扩展了集群，然后我们还使用了Azure
    CLI来配置集群自动缩放器。在下一节中，我们将探讨如何升级在AKS上运行的应用程序。
- en: Upgrading your application
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 升级您的应用程序
- en: Using deployments in Kubernetes makes upgrading an application a straightforward
    operation. As with any upgrade, you should have good failbacks in case something
    goes wrong. Most of the issues you will run into will happen during upgrades.
    Cloud-native applications are supposed to make dealing with this relatively easy,
    which is possible if you have a very strong development team that embraces DevOps
    principles.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中使用部署使升级应用程序成为一个简单的操作。与任何升级一样，如果出现问题，您应该有良好的回退。您将遇到的大多数问题将发生在升级过程中。云原生应用程序应该使处理这些问题相对容易，如果您有一个非常强大的开发团队，他们拥抱DevOps原则是可能的。
- en: The State of DevOps report ([https://services.google.com/fh/files/misc/state-of-devops-2019.pdf](https://services.google.com/fh/files/misc/state-of-devops-2019.pdf))
    has reported for multiple years that companies that have high software deployment
    frequency rates have higher availability and stability in their applications as
    well. This might seem counterintuitive, as doing software deployments heightens
    the risk of issues. However, by deploying more frequently and deploying using
    automated DevOps practices, you can limit the impact of software deployment.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps报告（[https://services.google.com/fh/files/misc/state-of-devops-2019.pdf](https://services.google.com/fh/files/misc/state-of-devops-2019.pdf)）已经多年报告说，具有高软件部署频率的公司在其应用程序中具有更高的可用性和稳定性。这可能看起来违反直觉，因为进行软件部署会增加问题的风险。然而，通过更频繁地部署并使用自动化的DevOps实践进行部署，您可以限制软件部署的影响。
- en: 'There are multiple ways we can make updates in a Kubernetes cluster. In this
    section, we will explore the following ways to update Kubernetes resources:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes集群中，我们可以进行多种方式的更新。在本节中，我们将探讨以下更新Kubernetes资源的方式：
- en: Upgrading by changing YAML files
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更改YAML文件进行升级
- en: Upgrading using `kubectl edit`
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl edit`进行升级
- en: Upgrading using `kubectl patch`
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`kubectl patch`进行升级
- en: Upgrading using Helm
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm进行升级
- en: The methods we will describe in the following section work great if you have
    stateless applications. If you have a state stored anywhere, make sure to back
    up that state before you try anything.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中描述的方法非常适用于无状态应用程序。如果您在任何地方存储了状态，请确保在尝试任何操作之前备份该状态。
- en: 'Let''s start this section by doing the first type of upgrade: changing YAML
    files.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过进行第一种类型的升级来开始本节：更改YAML文件。
- en: Upgrading by changing YAML files
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过更改YAML文件进行升级
- en: In order to upgrade a Kubernetes service or deployment, we can update the actual
    YAML definition file and apply that to the currently deployed application. Typically,
    we use `kubectl create` to create resources. Similarly, we can use `kubectl apply`
    to make changes to the resources.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了升级Kubernetes服务或部署，我们可以更新实际的YAML定义文件，并将其应用到当前部署的应用程序中。通常，我们使用`kubectl create`来创建资源。同样，我们可以使用`kubectl
    apply`来对资源进行更改。
- en: 'The deployment detects the changes (if any) and matches the `Running` state
    to the desired state. Let''s see how this is done:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 部署检测更改（如果有）并将`Running`状态与期望状态匹配。让我们看看这是如何完成的：
- en: 'We start with our guestbook application to demonstrate this example:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从我们的留言簿应用程序开始，以演示这个例子：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After a few minutes, all the Pods should be running. Let''s perform our first
    upgrade by changing the service from `ClusterIP` to `LoadBalancer`, as we did
    earlier in the chapter. However, now we will edit our YAML file rather than using
    `kubectl edit`. Edit the YAML file using this:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几分钟后，所有的Pod应该都在运行。让我们通过将服务从`ClusterIP`更改为`LoadBalancer`来执行我们的第一个升级，就像我们在本章前面所做的那样。然而，现在我们将编辑我们的YAML文件，而不是使用`kubectl
    edit`。使用以下命令编辑YAML文件：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Uncomment line 108 in this file to set the type as `LoadBalancer` and save
    the file. as shown in *Figure 4.20*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 取消注释此文件中的第108行，将类型设置为`LoadBalancer`并保存文件。如*图4.20*所示：
- en: '![The screen displays the edited YAML file. It now displays the Type as LoadBalancer
    on line 108.](image/Figure_4.20.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕显示了编辑后的YAML文件。现在在第108行显示了类型为LoadBalancer。](image/Figure_4.20.jpg)'
- en: 'Figure 4.20: Changing this line in the guestbook-all-in-one YAML file'
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.20：更改guestbook-all-in-one YAML文件中的这一行
- en: 'Apply the change as shown in the following code:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下代码进行更改：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can now get the public IP of the service using the following command:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令获取服务的公共IP：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Give it a few minutes, and you should be shown the IP as displayed in *Figure
    4.21*:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 等几分钟，您应该会看到IP，就像*图4.21*中显示的那样：
- en: '![When you execute the kubectl get svc command, you will see that only the
    frontend service has an External IP.](image/Figure_4.21.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![当您执行kubectl get svc命令时，您会看到只有前端服务有外部IP。](image/Figure_4.21.jpg)'
- en: 'Figure 4.21: Output displaying a public IP'
  id: totrans-177
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.21：显示公共IP的输出
- en: 'We will now make another change. We''ll downgrade the front-end image line
    on line 133 from `image: gcr.io/google-samples/gb-frontend:v4` to the following:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在我们将进行另一个更改。我们将把第133行的前端图像从`image: gcr.io/google-samples/gb-frontend:v4`降级为以下内容：'
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This change can be made by opening the guestbook application in the editor
    by using this familiar command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个熟悉的命令在编辑器中打开留言簿应用程序，可以进行此更改：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the following command to perform the update and watch the Pods change:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令执行更新并观察Pod更改：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will generate the following output:![Executing the kubectl apply -f guestbook-all-in-one.yaml&&kubectl
    get pods -w command generates an output displaying the change in Pods. You will
    see podsbeing created from a new ReplicaSet.](image/Figure_4.22.jpg)
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将生成以下输出：![执行kubectl apply -f guestbook-all-in-one.yaml && kubectl get pods
    -w命令会生成一个显示Pod更改的输出。您将看到从新的ReplicaSet创建的Pod。](image/Figure_4.22.jpg)
- en: 'Figure 4.22: Pods from a new ReplicaSet are created'
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.22：从新的ReplicaSet创建的Pod
- en: What you can see here is that the old version of the Pods (based on the old
    ReplicaSet) gets terminated, while the new version gets created.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以看到旧版本的Pod（基于旧的ReplicaSet）被终止，而新版本被创建。
- en: Running `kubectl get events | grep ReplicaSet` will show the rolling update
    strategy that the deployment uses to update the front-end images as follows:![The
    output will highlight all the ReplicaSet-related events.](image/Figure_4.23.jpg)
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`kubectl get events | grep ReplicaSet`将显示部署使用的滚动更新策略，以更新前端图像如下：![输出将突出显示所有与ReplicaSet相关的事件。](image/Figure_4.23.jpg)
- en: 'Figure 4.23: Monitoring Kubernetes events and filtering to only see ReplicaSet-related
    events'
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.23：监视Kubernetes事件并筛选只看到与ReplicaSet相关的事件
- en: Note
  id: totrans-189
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding example, we are making use of a pipe—shown by the `|` sign—and
    the `grep` command. A pipe in Linux is used to send the output of one command
    to the input of another command. In our case, we are sending the output of `kubectl
    get events` to the `grep` command. `grep` is a command in Linux that is used to
    filter text. In our case, we are using the `grep` command to only show us lines
    that contain the word ReplicaSet.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，我们使用了管道—由`|`符号表示—和`grep`命令。在Linux中，管道用于将一个命令的输出发送到另一个命令的输入。在我们的情况下，我们将`kubectl
    get events`的输出发送到`grep`命令。`grep`是Linux中用于过滤文本的命令。在我们的情况下，我们使用`grep`命令只显示包含单词ReplicaSet的行。
- en: 'You can see here that the new ReplicaSet gets scaled up, while the old one
    gets scaled down. You will also see two ReplicaSets for the front end, the new
    one replacing the other one Pod at a time:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到新的ReplicaSet被扩展，而旧的ReplicaSet被缩减。您还将看到前端有两个ReplicaSets，新的ReplicaSet逐个替换另一个Pod：
- en: '[PRE30]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This will display an output as shown in *Figure 4.24*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如*图4.24*所示的输出：
- en: '![Using the kubectl get replicaset command, you can see two different ReplicaSets.](image/Figure_4.24.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: 使用kubectl get replicaset命令，您可以看到两个不同的ReplicaSets。
- en: 'Figure 4.24: Two different ReplicaSets'
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.24：两个不同的ReplicaSets
- en: 'Kubernetes will also keep a history of your rollout. You can see the rollout
    history using this command:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes还将保留您的部署历史。您可以使用此命令查看部署历史：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This will generate an output as shown in *Figure 4.25*:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成如*图4.25*所示的输出：
- en: '![The output screen displays the history of the application. It shows the number
    of revisions, the change, and the cause for the change.](image/Figure_4.25.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: 图4.25：输出屏幕显示了应用程序的历史。它显示了修订次数、更改和更改的原因。
- en: 'Figure 4.25: Deployment history of the application'
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.25：应用程序的部署历史
- en: 'Since Kubernetes keeps a history of our rollout, this also enables rollback.
    Let''s do a rollback of our deployment:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于Kubernetes保留了我们部署的历史记录，这也使得回滚成为可能。让我们对部署进行回滚：
- en: '[PRE32]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This will trigger a rollback. This means that the new ReplicaSet will be scaled
    down to zero instances, and the old one will be scaled up to three instances again.
    We can verify this using the following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这将触发回滚。这意味着新的ReplicaSet将被缩减为零个实例，而旧的ReplicaSet将再次扩展为三个实例。我们可以使用以下命令来验证这一点：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The resultant output is as shown in *Figure 4.26*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的输出如*图4.26*所示：
- en: '![Executing the kubectl get rscommand shows two frontend ReplicaSets. One has
    0 pods and the other has 3 pods.](image/Figure_4.26.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: 图4.26：执行kubectl get rs命令显示两个前端ReplicaSets。一个没有pod，另一个有3个pod。
- en: 'Figure 4.26: The old ReplicaSet now has three Pods, and the new one is scaled
    down to zero'
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.26：旧的ReplicaSet现在有三个Pod，而新的ReplicaSet被缩减为零
- en: This shows us, as expected, that the old ReplicaSet is scaled back to three
    instances and the new one is scaled down to zero instances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了，正如预期的那样，旧的ReplicaSet被缩减为三个实例，新的ReplicaSet被缩减为零个实例。
- en: 'Finally, let''s clean up again by running the `kubectl delete` command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们再次通过运行`kubectl delete`命令进行清理：
- en: '[PRE34]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Congratulations! You have completed the upgrade of an application and a rollback
    to a previous version.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已完成了应用程序的升级和回滚到先前版本。
- en: In this example, you have used `kubectl apply` to make changes to your application.
    You can similarly also use `kubectl edit` to make changes, which will be explored
    in the next section.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，您已使用`kubectl apply`对应用程序进行更改。您也可以类似地使用`kubectl edit`进行更改，这将在下一节中探讨。
- en: Upgrading an application using kubectl edit
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用kubectl edit升级应用程序
- en: We can make changes to our application running on top of Kubernetes by using
    `kubectl edit`. You used this previously in this chapter. When running `kubectl
    edit`, the `vi` editor will be opened for you, which will allow you to make changes
    directly against the object in Kubernetes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`kubectl edit`对运行在Kubernetes之上的应用程序进行更改。您在本章中先前使用过这个。运行`kubectl edit`时，`vi`编辑器将为您打开，这将允许您直接对Kubernetes中的对象进行更改。
- en: 'Let''s redeploy our guestbook application without a public load balancer and
    use `kubectl` to create the load balancer:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新部署我们的guestbook应用程序，而不使用公共负载均衡器，并使用`kubectl`创建负载均衡器：
- en: 'You will start by deploying the guestbook application:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将开始部署guestbook应用程序：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To start the edit, execute the following command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始编辑，请执行以下命令：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will open a `vi` environment. Navigate to the line that now says `type:`
    `ClusterIP` (line 27) and change that to `type: LoadBalancer`, as shown in *Figure
    4.27*. To make that change, hit the *I* button, type your changes, hit the *Esc*
    button, type `:wq!`, and then hit *Enter* to save the changes:![Output shows that
    line 27 is replaced by Type: LoadBalancer.](image/Figure_4.3.jpg)'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这将打开一个`vi`环境。导航到现在显示为`type:` `ClusterIP`（第27行），并将其更改为`type: LoadBalancer`，如*图4.27*所示。要进行更改，请按*I*按钮，输入更改内容，按*Esc*按钮，输入`:wq!`，然后按*Enter*保存更改：![输出显示第27行被Type:
    LoadBalancer替换。](image/Figure_4.3.jpg)'
- en: 'Figure 4.27: Changing this line to type: LoadBalancer'
  id: totrans-221
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.27：将此行更改为类型：LoadBalancer
- en: 'Once the changes are saved, you can watch the service object until the public
    IP becomes available. To do this, type the following:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，您可以观察服务对象，直到公共IP可用。要做到这一点，请输入以下内容：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It will take a couple of minutes to show you the updated IP. Once you see the
    right public IP, you can exit the `watch` command by hitting *Ctrl* + *C* (*command*
    + *C* on Mac)
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将花费几分钟时间来显示更新后的IP。一旦看到正确的公共IP，您可以通过按*Ctrl* + *C*（Mac上为*command* + *C*）退出`watch`命令
- en: This is an example of using `kubectl edit` to make changes to a Kubernetes object.
    This command will open up a text editor to interactively make changes. This means
    that you need to interact with the text editor to make the changes. This will
    not work in an automated environment. To make automated changes, you can use the
    `kubectl patch` command.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`kubectl edit`对Kubernetes对象进行更改的示例。此命令将打开一个文本编辑器，以交互方式进行更改。这意味着您需要与文本编辑器交互以进行更改。这在自动化环境中不起作用。要进行自动化更改，您可以使用`kubectl
    patch`命令。
- en: Upgrading an application using kubectl patch
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用kubectl patch升级应用程序
- en: In the previous example, you used a text editor to make the changes to Kubernetes.
    In this example, you will use the `kubectl patch` command to make changes to resources
    on Kubernetes. The `patch` command is particularly useful in automated systems,
    such as in a script or in a continuous integration/continuous deployment system.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的示例中，您使用文本编辑器对Kubernetes进行更改。在这个示例中，您将使用`kubectl patch`命令对Kubernetes上的资源进行更改。`patch`命令在自动化系统中特别有用，例如在脚本中或在持续集成/持续部署系统中。
- en: 'There are two main ways in which to use `kubectl patch`, either by creating
    a file containing your changes (called a patch file) or by providing the changes
    inline. We''ll explore both approaches. First, in this example, we''ll change
    the image of the front end from `v4` to `v3` using a patch file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要方式可以使用`kubectl patch`，一种是创建一个包含更改的文件（称为补丁文件），另一种是提供内联更改。我们将探讨这两种方法。首先，在这个例子中，我们将使用补丁文件将前端的图像从`v4`更改为`v3`：
- en: 'Start this example by creating a file called `frontend-image-patch.yaml`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过创建一个名为`frontend-image-patch.yaml`的文件来开始这个例子：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Use the following text as a patch in that file:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该文件中使用以下文本作为补丁：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This patch file uses the same YAML layout as typical YAML files. The main thing
    about a patch file is that it only has to contain the changes and doesn't have
    to be capable of deploying the whole resource.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此补丁文件使用与典型YAML文件相同的YAML布局。补丁文件的主要特点是它只需要包含更改，而不必能够部署整个资源。
- en: 'To apply the patch, use the following command:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要应用补丁，请使用以下命令：
- en: '[PRE40]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This command does two things: first, it reads the `frontend-image-patch.yaml`
    file, and then it passes that to the `patch` command to execute the change.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令执行两件事：首先，它读取`frontend-image-patch.yaml`文件，然后将其传递给`patch`命令以执行更改。
- en: 'You can verify the changes by describing the front-end deployment and looking
    for the `Image` section:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过描述前端部署并查找`Image`部分来验证更改：
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This will display an output as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如下输出：
- en: '![After the Patch command is executed, you can use the kubectl describe deployment
    frontend command to verify the changes. You should see the path of the new image.](image/Figure_4.28.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![执行Patch命令后，您可以使用kubectl describe deployment frontend命令来验证更改。您应该看到新图像的路径。](image/Figure_4.28.jpg)'
- en: 'Figure 4.28: After the patch, we are running the old image'
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.28：补丁后，我们正在运行旧图像
- en: This was an example of using the `patch` command using a patch file. You can
    also apply a patch directly on the command line without creating a YAML file.
    In this case, you would describe the change in JSON rather than in YAML.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用`patch`命令使用补丁文件的一个例子。您还可以在命令行上直接应用补丁，而不创建YAML文件。在这种情况下，您将以JSON而不是YAML描述更改。
- en: 'Let''s run through an example in which we will revert the image change back
    to `v4`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来说明，我们将图像更改恢复到`v4`：
- en: 'Run the following command to patch the image back to `v4`:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令将图像补丁回到`v4`：
- en: '[PRE42]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can verify this change by describing the deployment and looking for the
    `Image` section:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过描述部署并查找`Image`部分来验证此更改：
- en: '[PRE43]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This will display an output as shown in *Figure 4.29*:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示如图4.29所示的输出：
- en: '![After applying another patch command, you will see the new version of the
    image.](image/Figure_4.29.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![应用另一个补丁命令后，您将看到图像的新版本。](image/Figure_4.29.jpg)'
- en: 'Figure 4.29: After another patch, we are running the new version again'
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.29：应用另一个补丁后，我们再次运行新版本
- en: 'Before we move on to the next example, let''s remove the guestbook application
    from our cluster:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一个例子之前，让我们从集群中删除guestbook应用程序：
- en: '[PRE44]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: So far, you have explored three ways of upgrading Kubernetes applications. First,
    you made changes to the actual YAML file and applied them using `kubectl apply`.
    Afterward, you used `kubectl edit` and `kubectl patch` to make more changes. In
    the final section of this chapter, we will use Helm to upgrade our application.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经探索了升级Kubernetes应用程序的三种方式。首先，您对实际的YAML文件进行了更改，并使用`kubectl apply`应用了这些更改。之后，您使用了`kubectl
    edit`和`kubectl patch`进行了更多更改。在本章的最后一节中，我们将使用Helm来升级我们的应用程序。
- en: Upgrading applications using Helm
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Helm升级应用程序
- en: 'This section will explain how to perform upgrades using Helm operators:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何使用Helm操作符执行升级：
- en: 'Run the following command:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will force an update of the image of the `WordPress` container. Let''s first
    check the version of the current image:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将强制更新`WordPress`容器的图像。让我们首先检查当前图像的版本：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In our case, the image version is `10.3.21-debian-10-r0` as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，图像版本为`10.3.21-debian-10-r0`如下：
- en: '![The output displays the 10.3.21-debian-10-r0 as the current version of the
    StatefulSet.](image/Figure_4.30.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![输出显示10.3.21-debian-10-r0作为StatefulSet的当前版本。](image/Figure_4.30.jpg)'
- en: 'Figure 4.30: Getting the current image of the StatefulSet'
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.30：获取StatefulSet的当前图像
- en: Let's look at the tags from [https://hub.docker.com/r/bitnami/mariadb/tags](https://hub.docker.com/r/bitnami/mariadb/tags)
    and select another tag. In our case, we will select the `10.3.22-debian-10-r9`
    tag to update our StatefulSet.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下来自[https://hub.docker.com/r/bitnami/mariadb/tags](https://hub.docker.com/r/bitnami/mariadb/tags)的标签，并选择另一个标签。在我们的情况下，我们将选择`10.3.22-debian-10-r9`标签来更新我们的StatefulSet。
- en: 'However, in order to update the MariaDB container image, we need to get the
    root password for the server and the password for the database. We can get these
    passwords in the following way:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了更新MariaDB容器图像，我们需要获取服务器的root密码和数据库的密码。我们可以通过以下方式获取这些密码：
- en: '[PRE47]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This will generate an output as shown in *Figure 4.31*:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个如*图4.31*所示的输出：
- en: '![The output will display a base64-encoded version of the password and the
    root password of the MariaDB which we need to update the container image.](image/Figure_4.31.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![输出将显示MariaDB的密码和root密码的base64编码版本，我们需要更新容器图像。](image/Figure_4.31.jpg)'
- en: 'Figure 4.31: The encrypted secrets that MariaDB uses'
  id: totrans-268
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.31：MariaDB使用的加密密码
- en: 'In order to get the decoded password, use the following command:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取解码后的密码，请使用以下命令：
- en: '[PRE48]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will show us the decoded root password and the decoded database password.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向我们显示解码后的root密码和解码后的数据库密码。
- en: 'We can update the image tag with Helm and then watch the Pods change using
    the following command:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用Helm更新图像标签，然后使用以下命令观察Pod的更改：
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This will update the image of our MariaDB and make a new Pod start. Running
    `describe` on the new Pod and grepping for `Image` will show us the new image
    version:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这将更新我们的MariaDB的图像并启动一个新的Pod。在新的Pod上运行`describe`并使用`grep`查找`Image`将向我们显示新的图像版本：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will generate an output as shown in *Figure 4.32*:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个如*图4.32*所示的输出：
- en: '![A new version of the image will be displayed upon executing the kubectl describe
    pod wp-mariadb-0 | grep Image command.](image/Figure_4.32.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![执行kubectl describe pod wp-mariadb-0 | grep Image命令将显示图像的新版本。](image/Figure_4.32.jpg)'
- en: 'Figure 4.32: Showing the new image'
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.32：显示新图像
- en: 'Finally, clean up by running the following command:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过运行以下命令进行清理：
- en: '[PRE51]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Thus, we have upgraded our application using Helm. As you have seen in this
    example, upgrading using Helm can be done by using the `--set` operator. This
    makes performing upgrades and multiple deployments using Helm so efficient.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经使用Helm升级了我们的应用程序。正如您在本例中所看到的，使用Helm进行升级可以通过使用`--set`运算符来完成。这使得使用Helm进行升级和多次部署变得非常高效。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This was a chapter with tons of information. Our goal was to show you how to
    scale deployments with Kubernetes. We did this by showing you how to create multiple
    instances of your application.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个充满大量信息的章节。我们的目标是向您展示如何使用Kubernetes扩展部署。我们通过向您展示如何创建应用程序的多个实例来实现这一点。
- en: We started the chapter by looking at how to define the use of a load balancer
    and leverage the deployment scale feature in Kubernetes to achieve scalability.
    With this type of scalability, we also achieve failover by using a load balancer
    and multiple instances of the software for stateless applications. We also looked
    into using the HPA to automatically scale our deployment based on load.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始这一章是通过研究如何定义负载均衡器的使用，并利用Kubernetes中的部署规模功能来实现可伸缩性。通过这种类型的可伸缩性，我们还可以通过使用负载均衡器和多个无状态应用程序实例来实现故障转移。我们还研究了如何使用HPA根据负载自动扩展我们的部署。
- en: After that, we also looked into how we can scale the cluster itself. First,
    we manually scaled our cluster, and afterward we used a cluster autoscaler to
    scale our cluster based on application demand.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们还研究了如何扩展集群本身。首先，我们手动扩展了我们的集群，然后我们使用了集群自动缩放器根据应用程序需求来扩展我们的集群。
- en: We finished the chapter by looking into different ways to upgrade a deployed
    application. First, we explored manually updating YAML files. Then, we delved
    into two additional `kubectl` commands (`edit` and `patch`) that can be used to
    make changes. Finally, we showed how Helm can be used to perform these upgrades.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过研究不同的方法来升级已部署的应用程序来完成了这一章。首先，我们探讨了手动更新YAML文件。然后，我们深入研究了两个额外的`kubectl`命令（`edit`和`patch`），可以用来进行更改。最后，我们展示了如何使用Helm来执行这些升级。
- en: In the next chapter, we will look at common failures you can see while deploying
    applications to AKS and how to fix them.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到在部署应用程序到AKS时可能遇到的常见故障以及如何修复它们。
