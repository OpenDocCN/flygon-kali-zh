- en: Vanilla Land - Looking at the Modern Web
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Vanilla Land - 看现代Web
- en: The landscape of the JavaScript language has changed quite a bit since the release
    of the ECMAScript 2015 standard. There are now many new features that make JavaScript
    a first-class language for all types of development. It has become much easier
    to use the language, and we can even see some syntactic sugar in it now.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 自ECMAScript 2015标准发布以来，JavaScript语言的格局发生了很大变化。现在有许多新功能使JavaScript成为各种开发的一流语言。使用该语言变得更容易，我们现在甚至可以看到一些语法糖。
- en: From the ECMAScript 2015 standard and beyond, we have received classes, modules,
    more ways of declaring variables, variations of scope, and much more. All of these
    features and more are going to be explained throughout the rest of this chapter.
    This is an excellent chapter to read in full if you are new to the language or
    you may just want to check out the features that may be unfamiliar. We will also
    take a look at some older sections of the web with DOM queries and how we can
    utilize them to replace extraneous libraries that we may be currently using, such
    as jQuery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 从ECMAScript 2015标准及以后，我们已经获得了类、模块、更多声明变量的方式、作用域的变化等。所有这些特性等等将在本章的其余部分进行解释。如果您对该语言还不熟悉，或者只是想了解一下可能不熟悉的特性，这是一章值得阅读的好章节。我们还将看一下一些旧的Web部分，如DOM查询，以及我们如何利用它们来替换我们可能当前正在使用的多余库，如jQuery。
- en: 'In this chapter, the following topics will be covered:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将涵盖以下主题：
- en: A dive into modern JavaScript
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入现代JavaScript
- en: Understanding classes and modules
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类和模块
- en: Working with the DOM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与DOM一起工作
- en: Understanding the Fetch API
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Fetch API
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are prerequisites for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的先决条件如下：
- en: An editor such as VS Code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如VS Code之类的编辑器
- en: A system that is set up to use Node.js
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个使用Node.js的系统
- en: A browser, preferably Chrome
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个浏览器，最好是Chrome
- en: A general understanding of JavaScript and its scope
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对JavaScript及其作用域的一般理解
- en: The relevant code can be found at [https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相关代码可以在[https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-High-Performance-Web-Development-with-JavaScript/tree/master/Chapter03)找到。
- en: A dive into modern JavaScript
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入现代JavaScript
- en: As stated in the introduction, the language has changed for the better in a
    lot of ways. We now have proper scoping, better handling for `async` operations,
    more collection types, and even metaprogramming features such as reflection and
    proxies. All of these features lead to a more involved language, but they also
    lead to more effective problem-solving. We will be looking at a few of the best
    items to come out of the new standards and what they can be used for in our code.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，语言在许多方面都有所改进。我们现在有了适当的作用域，更好地处理`async`操作，更多的集合类型，甚至元编程特性，如反射和代理。所有这些特性都导致了更复杂的语言，但也导致了更有效的问题解决。我们将看一下新标准中出现的一些最佳项，以及它们在我们的代码中可以用来做什么。
- en: 'One thing to also note moving forward is that any JavaScript code that is shown
    can be run in the following ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的是，未来显示的任何JavaScript代码都可以通过以下方式运行：
- en: Adding it to the developer's console by hitting *F12* on the keyboard
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按下键盘上的*F12*将其添加到开发者控制台
- en: Utilizing snippets in the developer's console that can be seen on the Sources
    tab, and in the left panel an option should be called Snippets
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用开发者控制台中可以在“Sources”选项卡中看到的片段，在左侧面板中应该有一个名为“Snippets”的选项
- en: Writing a base level `index.html` that has a script element added to it
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个基本的`index.html`，其中添加了一个脚本元素
- en: Let/const and block scoping
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Let/const和块作用域
- en: 'Before ECMAScript 2015, we only had the use of the `var` keyword for defining
    variables. The lifetime of a `var` keyword was from the function declaration to
    the end of it. This could lead to quite a few problems. The following code showcases
    one of the issues that we could run into with the `var` keyword:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 2015之前，我们只能使用`var`关键字来定义变量。`var`关键字的生命周期从函数声明到函数结束。这可能会导致很多问题。以下代码展示了我们可能在`var`关键字中遇到的问题之一：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What would the console print out? In most languages, we would guess that this
    is an error or that it would print `null`. However, JavaScript''s `var` keyword
    is function scoped, so the variable `i` will be `10`. This has led to many bugs
    popping up by accidentally forgetting to declare it a variable, or even the dreaded
    `switch` statement errors (these still happen with `let` and `const`). An example
    of a `switch` statement error is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台会打印出什么？在大多数语言中，我们可能会猜想这是一个错误，或者会打印`null`。然而，JavaScript的`var`关键字是函数作用域的，所以变量`i`将是`10`。这导致了许多错误的出现，因为意外地忘记声明变量，甚至可怕的`switch`语句错误（这些错误仍然会发生在`let`和`const`中）。`switch`语句错误的一个例子如下：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding `switch` statement, we would expect `y` to be `null`, but
    because the `var` keyword is not block-scoped, it will be the letter `z`. We always
    had to stay on top of variables and make sure that we were not using something
    that was declared outside our scope and changing it, or we were making sure that
    we were redeclaring variables to stop leaks from happening.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的`switch`语句中，我们期望`y`是`null`，但因为`var`关键字不是块作用域的，它将是字母`z`。我们总是必须掌握变量并确保我们没有使用在我们范围之外声明的东西并改变它，或者我们确保我们重新声明变量以阻止泄漏发生。
- en: 'With both `let` and `const`, we got block scoping. This means that the curly
    braces tell us how long our variables should live for. An example of this is seen
    here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`let`和`const`，我们得到了块作用域。这意味着花括号告诉我们变量应该存在多久。这里有一个例子：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we look at the printouts for the variable `x`, we can see that we have first
    declared it as `10` outside of the function. Inside the function, we have created
    a new scope with the curly braces and redeclared `x` as `20`. Inside the block,
    the code will print out `inner scope 20`. But, outside of the block inside of
    `fun2`, we print out `x` and it is `10`. The `let` keyword follows this block
    scope. Had we declared the variable as `var`, it would have stayed as `20` when
    we printed it out the second time. Finally, we add `10` to the outer `x` and we
    should see that `x` is `20`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看变量`x`的打印输出时，我们可以看到我们首先在函数外部将其声明为`10`。在函数内部，我们使用大括号创建了一个新的作用域，并将`x`重新声明为`20`。在块内部，代码将打印出`inner
    scope 20`。但是，在`fun2`内部的块之外，我们打印出`x`，它是`10`。`let`关键字遵循此块作用域。如果我们将变量声明为`var`，则第二次打印时它将保持为`20`。最后，我们将`10`添加到外部的`x`，我们应该看到`x`是`20`。
- en: In addition to getting block scoping, the `const` keyword gave us some immutability.
    If the types that we are working with are value types, we will not be able to
    mutate that value. If we have a reference type, the values inside the reference
    can be changed, but we cannot change the reference itself. This leads to some
    nice capabilities.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了获得块作用域之外，`const`关键字还赋予了我们一些不可变性。如果我们正在使用的类型是值类型，我们将无法改变该值。如果我们有一个引用类型，引用内部的值可以被改变，但是我们不能改变引用本身。这带来了一些很好的功能。
- en: A great style of coding is to use `const` as much as possible and only use `let`
    when we need to mutate something at the base level, such as loops. Since an object,
    array, or a function can have its values mutated, we can set them to `const`.
    The only downside that this has is that they cannot be nulled out, but it still
    adds quite a bit of safety on top of possible performance gains that the compiler
    can utilize knowing a value is immutable.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的编码风格是尽可能多地使用`const`，只有在需要在基本级别上改变某些东西时才使用`let`，比如循环。由于对象、数组或函数的值可以被改变，我们可以将它们设置为`const`。唯一的缺点是它们不能被置空，但它仍然在可能的性能增益之上增加了相当多的安全性，编译器可以利用知道一个值是不可变的。
- en: Arrow functions
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'Another notable change to the language was the addition of arrow functions.
    With this, we have now gotten access to change `this` without having to resort
    to various hacks on the language. An example of this can be seen as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语言的另一个显著变化是添加了箭头函数。有了这个，我们现在可以在不使用语言上的各种技巧的情况下改变`this`。可以看到以下示例：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We are creating a constructor function for a new object. We have two inner functions,
    one being a basic function call and the other being an arrow function. When we
    print this out, we notice that the basic function prints the window's scope. When
    we print the inner arrow function's scope, we get the scope of our parent.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在为一个新对象创建一个构造函数。我们有两个内部函数，一个是基本函数调用，另一个是箭头函数。当我们打印这个时，我们注意到基本函数打印出了窗口的作用域。当我们打印内部箭头函数的作用域时，我们得到了父级的作用域。
- en: We could solve this in a few ways for the basic inner function. First, we could
    declare a variable in the parent and utilize that for the inner function. Also,
    when we run the function, we could use call or `apply` to actually run the function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式来解决基本内部函数的问题。首先，我们可以在父级中声明一个变量，并在内部函数中使用它。此外，当我们运行函数时，我们可以使用call或`apply`来实际运行函数。
- en: However, neither of these is a good idea, especially when we now have arrow
    functions. A key point to remember is that the arrow function takes the scope
    of the parent, so whatever `this` points to for the parent, we are now going to
    do the same inside the arrow function. Now, we can always change that by utilizing
    `apply` on an arrow function, but it is best to only utilize `apply` and such
    for partial application reasons and not to call functions by changing its `this`
    keyword.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种方法都不是一个好主意，特别是当我们现在有箭头函数时。要记住的一个关键点是箭头函数获取父级的作用域，所以无论`this`指向父级的什么，我们现在都将在箭头函数内部执行相同的操作。现在，我们可以通过在箭头函数上使用`apply`来始终更改它，但最好只使用`apply`等来进行部分应用，而不是通过更改其`this`关键字来调用函数。
- en: Collection types
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合类型
- en: 'An array and an object have been the two main types that JavaScript developers
    have used for quite some time. But, we now have two other collection types that
    help us do some things that we used to use these other types for. These are set
    and map. A set is an unordered collection of unique items. What this means is
    that if we try to put something in the set that is already there, we will notice
    that we only have a single item. We can easily simulate a set with an array like
    so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和对象一直是JavaScript开发人员使用的两种主要类型。但是，现在我们有了另外两种集合类型，可以帮助我们做一些我们过去使用这些其他类型的事情。这些是set和map。set是一个无序的唯一项集合。这意味着如果我们试图将已经存在的东西放入set中，我们会注意到我们只有一个单一项。我们可以很容易地用数组模拟一个set，如下所示：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since we now have the set system, we can just use that API. We also get access
    to the `for of` loop since the set is an iterable item (we can also use the next
    syntax if we get the iterator attached to the set). Sets also have an advantage
    of faster read access over arrays when we get into large datasets. The following
    example illustrates this point:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在有了set系统，我们可以直接使用该API。我们还可以访问`for of`循环，因为set是一个可迭代项（如果我们获取附加到set的迭代器，我们也可以使用下一个语法）。与数组相比，当我们处理大型数据集时，set在读取访问速度上也具有优势。以下示例说明了这一点：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the set takes a bit longer to create, when it comes to looking for items
    or even grabbing them, the set will perform nearly 100 times faster than an array.
    This is mostly due to the way the array has to look items up. Since an array is
    purely linear, it has to go through each element to check, whereas the set is
    a simple constant time check.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管创建set需要一些时间，但是当查找项目或甚至获取它们时，set的性能几乎比数组快100倍。这主要是由于数组查找项目的方式。由于数组是纯线性的，它必须遍历每个元素进行检查，而set是一个简单的常量时间检查。
- en: A set can be implemented in different ways depending on the engine. A set in
    the V8 engine is built utilizing hash dictionaries for the lookup. We will not
    go over the internals of this, but essentially, the lookup time is considered
    constant, or *O(1)*, for computer science folk, whereas the array lookup time
    is linear, or *O(n)*.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以根据引擎的不同方式实现。V8 引擎中的集合是利用哈希字典进行查找构建的。我们不会详细介绍这些内部情况，但基本上，查找时间被认为是常数，或者对于计算机科学家来说是*O(1)*，而数组查找时间是线性的，或者*O(n)*。
- en: 'On top of the set, we also have maps. We can look at these and see them as
    just objects, but they have a couple of nice properties:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 除了集合，我们还有地图。我们可以将它们视为普通对象，但它们有一些很好的属性：
- en: First, we can use any value as the key, even an object. This can be great for
    adding other data that we do not want to tie directly to the object (private values
    come to mind).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们可以使用任何值作为键，甚至是对象。这对于添加我们不想直接绑定到对象的其他数据非常有用（私有值浮现在脑海中）。
- en: In addition to this, maps are also iterable, so we can utilize the `for of`
    loop just like a set.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除此之外，地图也是可迭代的，因此我们可以像集合一样利用`for of`循环。
- en: Finally, a map can give us performance benefits over a plain old object in the
    cases of large datasets and when the keys are the same types and so are the values.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，地图可以在大型数据集和键和值类型相同的情况下为我们带来性能优势。
- en: 'The following example highlights many of the areas where maps are generally
    better than plain objects and where objects used to be used:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例突出了地图通常比普通对象更好的许多领域，以及曾经使用对象的领域：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On top of these two items, we also have weak versions of them. The weak versions
    have one major limitation: the values have to be objects. This makes sense once
    we understand what `WeakSet` and `WeakMap` do. They *weakly* store the reference
    to the items. This means that while the items they have stored are around, we
    can perform the methods that these interfaces give us. Once the garbage collector
    decides to collect them, the references will be removed from the weak versions.
    We may be wondering, why would we use these?'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个项目，我们还有它们的弱版本。弱版本有一个主要限制：值必须是对象。一旦我们了解了`WeakSet`和`WeakMap`的作用，这就说得通了。它们*弱地*存储对项目的引用。这意味着当它们存储的项目存在时，我们可以执行这些接口给我们的方法。一旦垃圾收集器决定收集它们，引用将从弱版本中删除。我们可能会想，为什么要使用这些？
- en: 'For a `WeakMap`, there are a few use cases:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`WeakMap`，有一些用例：
- en: First, if we do not have private variables, we can utilize `WeakMap` to store
    values on the object without actually attaching the property to them. Now, when
    the object is eventually garbage collected, so is this private reference.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果我们没有私有变量，我们可以利用`WeakMap`在对象上存储值，而实际上不将属性附加到它们上。现在，当对象最终被垃圾收集时，这个私有引用也会被回收。
- en: We can also utilize weak maps to attach properties or data to the DOM without
    actually having to add attributes to the DOM. We get all of the benefits of data
    attributes without cluttering up the DOM.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以利用弱映射将属性或数据附加到 DOM，而实际上不必向 DOM 添加属性。我们可以获得数据属性的所有好处，而不会使 DOM 混乱。
- en: Finally, if we wanted to store reference data off to the side, but have it disappear
    when the data does, this is another use case.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们想要将引用数据存储到一边，但在数据消失时使其消失，这是另一个用例。
- en: 'All in all, `WeakMap` is used when we want to tie some sort of data to that
    object without having a tight coupling. We will be able to see this as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，当我们想要将某种数据与对象绑定而不需要紧密耦合时，我们会使用`WeakMap`。我们将能够看到这一点，如下所示：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: First, we create a `WeakMap` to store the data we want against the DOM elements
    that we are creating. Next, we grab our unordered list and add a list element
    to each iteration. We then tie the number that we are on to the DOM element through
    the `WeakMap`. That way, the `onclick` handler can get the item and get back the
    data we stored against it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`WeakMap`来存储我们想要针对创建的 DOM 元素的数据。接下来，我们获取我们的无序列表，并在每次迭代中添加一个列表元素。然后，我们通过`WeakMap`将我们所在的数字与
    DOM 元素联系起来。这样，`onclick`处理程序就可以获取该项并取回我们存储在其中的数据。
- en: With this, we can click on any of the elements and get the data back. This is
    cool since we used to add data attributes to the HTML elements directly in the
    DOM. Now we can just use `WeakMap`. But, we also get one more benefit that has
    been talked about. If we run the `removeHalf` function in the command line and
    garbage collect, we can take a look at how many items are in the `WeakMap`. If
    we do this and we check how many elements are in the `WeakMap`, we will notice
    the number of elements it has stored can range from 25,000 to the full 50,000
    elements we started with. This is for the reason stated above; once a reference
    has been garbage collected, the `WeakMap` will no longer store it. It has a weak
    reference.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们可以点击任何元素并取回数据。这很酷，因为我们过去直接在 DOM 中向 HTML 元素添加数据属性。现在我们可以使用`WeakMap`。但是，我们还有一个更多的好处，这已经被讨论过。如果我们在命令行中运行`removeHalf`函数并进行垃圾收集，我们可以看一下`WeakMap`中有多少项。如果我们这样做，并检查`WeakMap`中有多少元素，我们会注意到它存储的元素数量可以从
    25,000 到我们开始的完整 50,000 个元素。这是由于上面所述的原因；一旦引用被垃圾收集，`WeakMap`将不再存储它。它具有弱引用。
- en: The amount to be collected by the garbage collector is going to be up to the
    system that we are running. On some systems, the garbage collector may decide
    to not collect anything from the list. This all depends on how the V8 garbage
    collection has been set up for Chrome or Node.js.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器要收集的数量将取决于我们正在运行的系统。在某些系统上，垃圾收集器可能决定不从列表中收集任何内容。这完全取决于 Chrome 或 Node.js
    中的 V8 垃圾收集是如何设置的。
- en: We can easily see this if we replace `WeakMap` with a regular one. Let's go
    ahead and make this minor change. With this change, observe the same preceding
    steps. We will notice that the map still has all 50,000 items inside it. This
    is what we mean when we say something either has a strong reference or a weak
    reference. A weak reference will allow the item to be cleaned up by the garbage
    collector, whereas a strong reference will not. *WeakMaps* are great for these
    types of linking in terms of data to another data source. If we want the item
    decoration or the link to be cleaned up when the primary object is cleaned, a
    `WeakMap` is a go-to item.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用普通的`WeakMap`替换它，我们很容易看到这一点。让我们继续进行这个小改变。通过这个改变，观察同样的步骤。我们会注意到地图仍然有50,000个项目。这就是我们所说的，当我们说某物有强引用或弱引用时的意思。弱引用将允许垃圾收集器清理项目，而强引用则不会。*WeakMaps*非常适合这种数据与另一个数据源的链接。如果我们希望在主对象被清理时清理项目装饰或链接，`WeakMap`是一个不错的选择。
- en: A `WeakSet` has a more limited use case. One great use case is for checking
    for infinite loops in object properties or graphs. If we store all of the visited
    nodes in a `WeakSet`, we are able to check whether we have the items, but we also
    don't have to clear the set once we are done with the check. This means, once
    the data gets collected, so will all of the references that were stored in the
    `WeakSet`. Overall, a `WeakSet` should be used when we need to tag an object or
    a reference. This means that if we need to see whether we have it or whether it
    has been visited, a `WeakSet` is a likely candidate for this job.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakSet`有一个更有限的用例。一个很好的用例是检查对象属性或图中的无限循环。如果我们将所有访问过的节点存储在`WeakSet`中，我们就能够检查我们是否有这些项目，但我们也不必在检查完成后清除集合。这意味着一旦数据被收集，存储在`WeakSet`中的所有引用也将被收集。总的来说，当我们需要标记一个对象或引用时，应该使用`WeakSet`。这意味着如果我们需要查看我们是否拥有它或它是否被访问过，`WeakSet`很可能是这项工作的合适选择。'
- en: 'We can utilize the deep copy example from the previous chapter. With it, we
    still run into one more use case that we did not think of. What happens if an
    item points to another item in the object and that same item decides to point
    back at the original item? This can be seen in the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用上一章的深拷贝示例。通过它，我们还遇到了一个我们没有考虑到的用例。如果一个项目指向对象中的另一个项目，并且同一个项目决定再次指向原始项目，会发生什么？这可以在以下代码中看到：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With each of these items pointing at one another, we would run into circular
    reference issues. A way to get around this is with a `WeakSet`. We could hold
    all the visited nodes, and if we come to a node that is already visited, we just
    return from the function. This can be seen in the modified version of the code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个项目都指向彼此，我们将遇到循环引用的问题。解决这个问题的方法是使用`WeakSet`。我们可以保存所有访问过的节点，如果我们遇到一个已经访问过的节点，我们就从函数中返回。这可以在代码的修改版本中看到：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, we have added a new `_held` variable that will hold all of our
    references. Then, the `runUpdate` function has been modified to make sure that
    when an item is not a primitive type or a function, we check whether we already
    have it in our `held` list. If we do, then we skip the item, otherwise, we will
    just keep going. Finally, we replace the `_held` variable with a new `WeakSet`
    since the `clear` method is no longer available on *WeakSets*.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已经添加了一个新的`_held`变量，它将保存我们所有的引用。然后，`runUpdate`函数已经被修改，以确保当一个项目不是原始类型或函数时，我们检查我们的`held`列表中是否已经有它。如果有，我们就跳过这个项目，否则我们将继续进行。最后，我们用一个新的`WeakSet`替换了`_held`变量，因为在*WeakSets*上`clear`方法不再可用。
- en: This does not keep the circular reference, which may be a problem, but it does
    solve our issue of the system going into an infinite loop because of objects referencing
    one another. Other than this use case, and maybe some more advanced ideas, there
    are not many other needs for a `WeakSet`. The main thing is if we need to track
    the existence of something. If we need to do this, the `WeakSet` is the perfect
    use case for us.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不会保留循环引用，这可能是一个问题，但它解决了因对象相互引用而导致系统陷入无限循环的问题。除了这种用例，也许还有一些更高级的想法，`WeakSet`并没有太多其他的需求。主要的是，如果我们需要跟踪某物的存在。如果我们需要这样做，`WeakSet`就是我们的完美用例。
- en: Most developers will not find a need for *WeakSets* or *WeakMaps*. These will
    likely be utilized by library authors. However, the conventions mentioned previously
    may come up in some cases so it is nice to know the reason for these items and
    why they are there. If we do not have a reason to use something, then we should
    most likely not use it, this is definitely the case with these two items since
    they have really specific use cases and one of the major use cases for *WeakMaps*
    is being delivered to us in the ECMAScript standard (private variables).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员不会发现需要*WeakSets*或*WeakMaps*。这些可能会被库作者使用。然而，之前提到的约定在某些情况下可能会出现，因此了解这些项目的原因和存在的意义是很好的。如果我们没有使用某物的理由，那么我们很可能不应该使用它，这在这两个项目中绝对是这样，因为它们有非常具体的用例，而*WeakMaps*的主要用例之一是在ECMAScript标准中提供给我们的（私有变量）。
- en: Reflection and proxies
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 反射和代理
- en: One of the last major pieces of the ECMAScript standard we are going to touch
    on is two metaprogramming objects. Metaprogramming is the technique of having
    code that generates code. This could be for things such as compilers or parsers.
    It could also be for self-changing code. It can even be for runtime evaluation
    of another language (interpreting) and doing something with this. While this is
    probably the main feature that reflection and proxies give us, it also gives us
    the ability to listen to events on an object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要讨论的ECMAScript标准的最后一个重要部分是两个元编程对象。元编程是指生成代码的技术。这可能是用于编译器或解析器等工具。它也可以用于自我改变的代码。甚至可以用于运行时评估另一种语言（解释）并对其进行操作。虽然这可能是反射和代理给我们的主要功能，但它也使我们能够监听对象上的事件。
- en: 'In the previous chapter, we talked about listening to events and we created
    a `CustomEvent` to listen for events on our object. Well, we can change that code
    and utilize proxies for that behavior. The following is some basic code to handle
    basic events on an object:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们谈到了监听事件，并创建了一个`CustomEvent`来监听对象上的事件。好吧，我们可以改变那段代码，并利用代理来实现该行为。以下是处理对象上基本事件的一些基本代码：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: What we have done is add some basic logging for the `get` and `set` methods
    on this object. We have extended the functionality of this object by also making
    the `set` method only take string values. With this, we have created an object
    that can be listened to and we can respond to those events.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是为这个对象的`get`和`set`方法添加了一些基本的日志记录。我们通过使`set`方法只接受字符串值，扩展了这个对象的功能。有了这个，我们创建了一个可以被监听的对象，并且我们可以对这些事件做出响应。
- en: Proxies are currently slower than adding a `CustomEvent` to the system. As stated
    previously, even though proxies were in the ECMAScript 2015 standard, their adoption
    has been slow, so browsers need some more time to optimize them. Also, it should
    be noted that we would not want to run the logging directly here. We would, instead,
    opt for the system to queue messages and utilize something called `requestIdleCallback`
    to run our logging code once the browser notices downtime in our application.
    This is still an experimental technology but should be added to all browsers soon.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 代理目前比向系统添加`CustomEvent`要慢。正如前面所述，尽管代理在ECMAScript 2015标准中，但它们的采用速度很慢，因此浏览器需要更多时间来优化它们。另外，应该注意的是，我们不希望直接在这里运行日志记录。相反，我们选择让系统排队消息，并利用称为`requestIdleCallback`的东西，在浏览器注意到我们应用程序的空闲时间时运行我们的日志记录代码。这仍然是一项实验性技术，但应该很快添加到所有浏览器中。
- en: Another interesting property of proxies is revocable methods. This is a proxy
    that we can eventually say is revoked and this will throw a `TypeError` when we
    try to use it after this method call. This can be very useful for anyone trying
    to implement the RAII pattern with objects. Instead of trying to `null` out the
    reference, we can revoke the proxy and we will no longer be able to utilize it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的另一个有趣特性是可撤销方法。这是一个代理，我们最终可以说是被撤销的，当我们尝试在此方法调用后使用它时，会抛出`TypeError`。这对于任何试图使用对象实现RAII模式的人来说非常有用。我们可以撤销代理，而不再能够利用它，而不是试图将引用“null”掉。
- en: This pattern of RAII will differ slightly from the null reference. Once we revoke
    a proxy, all references will no longer be able to use it. This may become an issue,
    but it would also give us the added benefit of failing fast, which is always a
    great property to have in code development. This means that when we are in development,
    it will throw a `TypeError` instead of just passing a null value. In this case,
    only try-catch blocks would allow this code to keep going instead of just simple
    null checks. Failing fast is a great way to protect ourselves in development and
    to catch bugs earlier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这种RAII模式与空引用略有不同。一旦我们撤销了代理，所有引用将不再能够使用它。这可能会成为一个问题，但它也会给我们带来失败快速的额外好处，这在代码开发中总是一个很好的特性。这意味着当我们在开发中时，它会抛出`TypeError`，而不仅仅是传递一个空值。在这种情况下，只有try-catch块才能让这段代码继续运行，而不仅仅是简单的空检查。失败快速是保护我们自己在开发中并更早捕获错误的好方法。
- en: 'An example of this is shown here with a modified version of the preceding code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个示例，修改了前面代码的版本：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, instead of just throwing *TypeErrors* on the set, we also will throw a
    `TypeError` once we revoke the proxy. This can be of great use to us when we decide
    to write code that will protect itself. We also no longer need to write a bunch
    of guard clauses in our code when we are utilizing objects. If we utilize proxies
    and revocables instead, we are able to guard our sets.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不仅在设置时抛出*TypeErrors*，一旦我们撤销代理，我们也会抛出`TypeError`。当我们决定编写能够保护自己的代码时，这对我们非常有用。当我们使用对象时，我们也不再需要在代码中编写一堆守卫子句。如果我们使用代理和可撤销代替，我们可以保护我们的设置。
- en: We did not go into the terminology of the proxy system. Technically, the methods
    we add in the handler for the proxies are called traps, similar to operating system
    traps, but we can really just think of them as simple events. Sometimes, the terminology
    can add a bit of confusion to things and is usually not needed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有深入讨论代理系统的术语。从技术上讲，我们在代理处理程序中添加的方法称为陷阱，类似于操作系统陷阱，但我们实际上可以将它们简单地视为简单的事件。有时，术语可能会给事情增加一些混乱，通常是不需要的。
- en: 'Besides proxies, the Reflect API is a bunch of static methods that mirror the
    proxy handlers. We can utilize them in place of some familiar systems such as
    the `Function.prototype.apply` method. We can instead utilize the `Reflect.apply`
    method, which can be a bit clearer when writing our code. This looks like the
    following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理，反射API是一堆静态方法，它们反映了代理处理程序。我们可以在某些熟悉的系统的位置使用它们，比如`Function.prototype.apply`方法。我们可以使用`Reflect.apply`方法，这在编写我们的代码时可能会更清晰一些。如下所示：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As we can see, we set a value on our object the first time and it was successful.
    But, the second property was first defined and it was set to non-writable (the
    default when we use `defineProperty` ), and so we were not able to set a value
    on it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们第一次在对象上设置了一个值，并且成功了。但是，第二个属性首先被定义，并且被设置为不可写（当我们使用`defineProperty`时的默认值），因此我们无法在其上设置一个值。
- en: With both of these APIs, we can write some nice functionality for accessing
    objects and even making mutations as safe as possible. We can utilize the RAII
    pattern very easily with these two APIs and we can even do some cool metaprogramming
    along with it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个API，我们可以为访问对象编写一些不错的功能，甚至使变异尽可能安全。我们可以很容易地利用这两个API来使用RAII模式，甚至可以进行一些很酷的元编程。
- en: Other notable changes
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他值得注意的变化
- en: There are plenty of changes that have come with the advancement of the ECMAScript
    standard and we could devote an entire chapter to all of those changes, but we
    will lay out a few more here that can be seen in code written in this book and
    most likely seen elsewhere.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 ECMAScript 标准的进步，出现了许多变化，我们可以专门讨论所有这些变化，但我们将在这里列出一些在本书中编写的代码中以及其他地方可能看到的变化。
- en: Spread operator
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展开运算符
- en: 'The spread operator allows us to pull apart arrays, iterable collections such
    as sets or maps, and even objects in the latest standard. This gives us a nicer
    syntax for performing some common operations such as the ones here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符允许我们拆开数组，可迭代集合（如集合或映射），甚至是最新标准中的对象。这为我们提供了更美观的语法，用于执行一些常见操作，例如以下操作：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What used to be `for` loops and other versions of iteration is now a simple
    one-line piece of code. Also, the first item is nice since it shows the reader
    of this code that we are utilizing the function as a variable argument function.
    Instead of needing documentation to lay this out, we can see this with the code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的 `for` 循环和其他迭代版本现在变成了简单的一行代码。此外，第一个项目很好，因为它向代码的读者显示我们正在将函数用作变量参数函数。我们可以通过代码看到这一点，而不需要文档来说明这一点。
- en: When dealing with arguments, if we are going to mutate them at all in the function,
    create a copy and then mutate. Certain de-optimizations happen if we decide to
    mutate the arguments directly.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 处理参数时，如果我们在函数中要对其进行任何改变，先创建一个副本，然后再进行改变。如果我们决定直接改变参数，会发生某些非优化。
- en: Destructuring
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解构
- en: 'Destructuring is the process of taking an array or an object and passing the
    items to the variable we are assigning to in an easier fashion. This can be seen
    with the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 解构是将数组或对象的项目以更简单的方式传递给我们分配给的变量的过程。可以在以下代码中看到：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both of these examples showcase some cool properties. First, we can pick and
    choose the items that we want from the object. We can also reassign the value
    to something else if we want to, on the left-hand side. On top of this, we can
    even do nested objects and destructuring.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例展示了一些很酷的特性。首先，我们可以从对象中挑选我们想要的项目。我们还可以在左侧重新分配值为其他值。除此之外，我们甚至可以进行嵌套对象和解构。
- en: For the array, we are able to pick and choose all of the items, some of the
    items, or even use the `rest` syntax by putting the rest of the array in a variable.
    In the preceding example, `a` will hold `1`, `b` will hold `3`, and `c` will be
    an array with `4` and `5` inside it. We skipped 2 by making that space empty.
    In other languages, we would use something like `_` to showcase this, but we can
    just skip it here. Again, all of this is just syntactic sugar that enables tighter
    and cleaner code to be written.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组，我们可以选择所有项目、部分项目，甚至通过将数组的其余部分放入变量来使用 `rest` 语法。在前面的示例中，`a` 将保存 `1`，`b` 将保存
    `3`，`c` 将是一个包含 `4` 和 `5` 的数组。我们通过使该空间为空来跳过了 2。在其他语言中，我们会使用 `_` 来展示这一点，但在这里我们可以直接跳过它。同样，所有这些只是语法糖，使得能够编写更紧凑和更清晰的代码。
- en: Power operator
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幂运算符
- en: There is not much to say here other than the fact that we no longer need to
    utilize the `Math.pow()` function; we now have the power operator or `**`, leading
    to cleaner code and nicer-looking mathematical equations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么可说的，除了我们不再需要使用 `Math.pow()` 函数；我们现在有了幂运算符或 `**`，从而使代码更清晰，数学方程更美观。
- en: Parameter defaults
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数默认值
- en: 'These allow us to put in default values if we do not have something for that
    position when calling a function. This may appear as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些允许我们在调用函数时为某个位置放入默认值。可以如下所示：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: One thing to note with parameter defaults is that once we start to utilize defaults
    in the chain of arguments, we can't stop using defaults. In the preceding example,
    if we gave argument 2 a default, we would have to give argument 3 a default, even
    if we just pass undefined or `null` to it. Again, this helps with the clarity
    of code and making sure that we no longer have to create default cases where we
    are looking at the arguments of the array.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一点是，一旦我们开始在参数链中使用默认值，就不能停止使用默认值。在前面的示例中，如果我们给参数 2 设置了默认值，那么我们必须给参数 3 设置默认值，即使我们只是将
    undefined 或 `null` 传递给它。同样，这有助于代码的清晰度，并确保我们不再需要在查看数组的参数时创建默认情况。
- en: A lot of code still utilizes the arguments section of a function. There are
    even other properties of a function that we can get at such as the caller. If
    we are in strict mode, a lot of this behavior will break. Strict mode is a way
    to not allow access to certain behaviors in the JavaScript engine. A good description
    of this can be found at [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode).
    In addition to this, we should no longer be using the arguments section of the
    function since we have plenty of helpful alternatives with the new standard.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 很多代码仍然利用函数的参数部分。甚至还有函数的其他属性可以获取，比如调用者。如果我们处于严格模式，很多这种行为都会被破坏。严格模式是一种不允许访问 JavaScript
    引擎中某些行为的方式。关于这一点的良好描述可以在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)找到。除此之外，由于新标准提供了许多有用的替代方案，我们不应再使用函数的参数部分。
- en: String templates
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串模板
- en: 'String templates allow us to pass in arbitrary code that will evaluate to a
    string or an object that has a `toString` function. This allows us, yet again,
    to write cleaner code instead of having to create a bunch of concatenated strings.
    It also allows us to write multiline strings without having to create escape sequences.
    This can be seen as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串模板允许我们传入将求值为字符串或具有 `toString` 函数的对象的任意代码。这再次使我们能够编写更清晰的代码，而不必创建大量连接的字符串。它还允许我们编写多行字符串，而无需创建转义序列。可以如下所示：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Just remember that even though we can do something, doing something may not
    be the best idea. Specifically, we may be able to pass arbitrary expressions that
    will evaluate to something, but we should try to keep them as clean and simple
    as possible to make the code more readable.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，即使我们可以做某事，做某事可能不是最好的主意。具体来说，我们可能能够传递将求值为某个值的任意表达式，但我们应该尽量保持它们简洁清晰，以使代码更易读。
- en: Typed arrays
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型化数组
- en: We will be discussing these at length in future chapters, but typed arrays are
    ways of representing arbitrary bytes in the system. This allows us to work with
    lower-level functionality, such as encoders and decoders, or even working on the
    byte streams of a `fetch` call directly instead of having to work with converting
    blobs to numbers or strings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在未来的章节中对此进行详细讨论，但类型化数组是表示系统中任意字节的一种方式。这使我们能够使用更低级的功能，例如编码器和解码器，甚至直接处理`fetch`调用的字节流，而无需将blob转换为数字或字符串。
- en: 'These usually start out with an `ArrayBuffer` and then we create a view over
    it. This can look like the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常以`ArrayBuffer`开始，然后我们在其上创建一个视图。这可能看起来像下面这样：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, we first create an array buffer. Think of this as a low-level
    instance. It just holds raw bytes. We then have to create a view over it. A lot
    of the time, we will be utilizing `Uint8Array` as we need to work with the arbitrary
    bytes, but we can utilize views all the way up to `BigInt`. These are usually
    utilized in low-level systems such as in 3D canvas code, WebAssembly, or raw streams
    from the server.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们首先创建一个数组缓冲区。可以将其视为低级实例。它只保存原始字节。然后我们必须在其上创建一个视图。大部分时间，我们将使用`Uint8Array`，因为我们需要处理任意字节，但我们可以一直使用视图到`BigInt`。这些通常用于低级系统，例如3D画布代码、WebAssembly或来自服务器的原始流。
- en: BigInt
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigInt
- en: '`BigInt` is an arbitrarily long integer. Numbers in JavaScript are stored as
    64-bit, floating-point doubles. This means that even if we only have a normal
    integer, we still only get 53 bits of precision. We can only store numbers inside
    variables up to the number 9 quadrillion. Anything bigger than this will usually
    cause the system to go into undefined behavior. To make up for this, we can now
    utilize the `BigInt` feature in JavaScript. This looks like the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt`是一个任意长的整数。JavaScript中的数字以64位浮点数双精度存储。这意味着即使我们只有一个普通整数，我们仍然只能获得53位的精度。我们只能在变量中存储数字，最大到9000万亿。比这更大的数字通常会导致系统进入未定义的行为。为了弥补这一点，我们现在可以在JavaScript中利用`BigInt`特性。这看起来像下面这样：'
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will notice that *BigInts* are appended with an `n`. We also need to coerce
    regular numbers to *BigInts* if we want to utilize them in regular operations.
    Now that we have big integers, we can work with very large numbers, which can
    be of great use in 3D, financial, and scientific applications.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会注意到*BigInts*后面会附加一个`n`。如果我们想要在常规操作中使用它们，我们还需要将常规数字强制转换为*BigInts*。现在我们有了大整数，我们可以处理非常大的数字，这在3D、金融和科学应用中非常有用。
- en: Do not try to coerce *BigInts* back to regular numbers. There is some undefined
    behavior here and we may lose precision if we try to do this. The best approach
    is that if we need to use *BigInts*, stay in *BigInts*.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不要试图将*BigInts*强制转换回常规数字。这里存在一些未定义的行为，如果我们尝试这样做，可能会失去精度。最好的方法是，如果我们需要使用*BigInts*，就保持在*BigInts*中。
- en: Internationalization
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化
- en: 'Finally, we come to internationalization. Before, we would need to internationalize
    such things as dates, number formats, and even currencies. We would use special
    lookups or converters that would do this for us. With the newer versions of ECMAScript,
    we have gained support for getting these new formats with the built-in `Intl`
    object. Some of the use cases can be seen as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们来到国际化。以前，我们需要国际化诸如日期、数字格式甚至货币等内容。我们会使用特殊的查找或转换器来为我们执行这些操作。通过ECMAScript的更新版本，我们已经获得了使用内置`Intl`对象获取这些新格式的支持。一些用例可以如下所示：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this, we can now internationalize our system depending on where someone
    may be located or what language they choose at the start of our application.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们现在可以根据某人的所在地或他们在我们应用程序开始时选择的语言来国际化我们的系统。
- en: This will only perform conversions of the numbers to the stylings for that country
    code; it will not try to convert the actual values since options such as currency
    change within the course of the day. If we need to perform such conversions, we
    will need to use an API. On top of this, if we want to translate something, we
    will still need to have separate lookups for what we need to put in text since
    there is no direct translation between languages.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会将数字转换为该国家代码的样式；它不会尝试转换实际值，因为货币等选项在一天之内会发生变化。如果我们需要执行这样的转换，我们将需要使用API。除此之外，如果我们想要翻译某些内容，我们仍然需要有单独的查找，以确定我们需要在文本中放置什么，因为不同语言之间没有直接的翻译。
- en: With these awesome features added in the ECMAScript standard, let's now move
    onto a way to encapsulate functions and data that go together. To do this, we
    will use classes and modules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有了ECMAScript标准中添加的这些令人惊叹的功能，现在让我们转向一种封装函数和数据的方式。为此，我们将使用类和模块。
- en: Understanding classes and modules
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和模块
- en: With the new ECMAScript standard, we got the new class syntax for having a form
    of **object-oriented programming** (**OOP**) and, later, we also got modules,
    a way of importing and exporting user-defined collections of functions and objects.
    Both of these systems have enabled us to remove certain hacks that we built into
    the system, and also remove certain libraries that were close to essential for
    modularizing our code bases.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新的ECMAScript标准，我们得到了新的类语法，用于实现**面向对象编程**（**OOP**），后来，我们还得到了模块，一种导入和导出用户定义的函数和对象集合的方式。这两种系统使我们能够消除系统中内置的某些黑客技巧，并且也能够移除一些几乎是必不可少的库，用于模块化我们的代码库。
- en: First, we need to understand what type of language JavaScript is. JavaScript
    is a multi-paradigm language. This means that we can utilize many of the ideas
    that are out there for different programming styles and incorporate them into
    our code base. One style of programming that we have touched on in previous chapters
    is the functional style of programming.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解JavaScript是什么类型的语言。JavaScript是一种多范式语言。这意味着我们可以利用许多不同编程风格的思想，并将它们合并到我们的代码库中。我们在之前的章节中提到的一种编程风格是函数式编程。
- en: In pure functional programming, we have pure functions, or functions that perform
    an action and have no side effects (do something outside what the function is
    supposed to do). When we write in this way, we can create generalized functions
    and put them together to create a chain of simple ideas that can work on complex
    ideas. We also treat functions as first-class citizens in the language. This means
    that functions can be assigned to variables and passed to other functions. We
    can also compose these functions, as we have seen in previous chapters. This is
    one way to think about a problem.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在纯函数式编程中，我们有纯函数，或者执行操作并且没有副作用（在函数应该执行的外部执行其他操作）的函数。当我们以这种方式编写时，我们可以创建通用函数，并将它们组合在一起，以创建可以处理复杂思想的一系列简单思想。我们还将函数视为语言中的一等公民。这意味着函数可以分配给变量并传递给其他函数。我们还可以组合这些函数，正如我们在之前的章节中所看到的。这是解决问题的一种方式。
- en: Another popular style of programming is object-oriented programming. This style
    states that a program can be described with a hierarchy of classes and objects
    that can be built and used together to create this complex idea. This idea can
    be seen in most of the popular languages that are out there. We build base classes
    that have some general functionality or some definitions that specific versions
    of them need to incorporate. We inherit from this base class and add our own specific
    functionality and then we create these objects. Once we put all of these objects
    together, we can work on the complex idea that we need to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种流行的编程风格是面向对象编程。这种风格表明程序可以用类和对象的层次结构来描述，并且可以构建和一起使用这些类和对象来创建这个复杂的思想。这个想法可以在大多数流行的语言中看到。我们构建具有一些通用功能或某些特定版本需要合并的定义的基类。我们从这个基类继承并添加我们自己的特定功能，然后我们创建这些对象。一旦我们把所有这些对象放在一起，我们就可以处理我们需要的复杂思想。
- en: With JavaScript, we get both of these ideas, but the OOP design in JavaScript
    is a bit different. We have what is known as prototypal inheritance. What this
    means is that there is really no idea of these abstract ideas called *classes*.
    All we have in JavaScript are objects. We inherit an object's prototype that has
    methods and data on it that all objects with the same prototype share, but they
    are all instantiated instances.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript，我们可以得到这两种思想，但是JavaScript中的面向对象设计有点不同。我们拥有所谓的原型继承。这意味着在JavaScript中并没有所谓的抽象概念*类*。在JavaScript中，我们只有对象。我们继承一个对象的原型，该原型具有方法和数据，所有具有相同原型的对象共享，但它们都是实例化的实例。
- en: 'When we talk about class syntax in JavaScript, we are talking about syntactic
    sugar for constructor functions and methods/data that we are adding to their prototype.
    Another way to think about this type of inheritance is to note that there are
    not abstract ideas in JavaScript, only concrete objects. If this seems a bit esoteric
    or confusing, the following code should clarify what these statements mean:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在JavaScript中谈论类语法时，我们指的是构造函数和我们添加到它们的原型的方法/数据的语法糖。另一种思考这种类型的继承的方式是注意到在JavaScript中没有抽象概念，只有具体对象。如果这看起来有点神秘或令人困惑，下面的代码应该澄清这些陈述的含义：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have shown a few things with this example. First, this is the older way of
    creating constructor functions. A constructor function is a function that sets
    up the scope and all of the functions that are directly available to an object
    when it gets instantiated. In this case, we have made `a`, `b`, and `c` as instance
    variables on an `Item` constructor. Second, we have added something to the item's
    prototype. When we declare something on the prototype of a constructor function,
    we are making that available to all instances of that constructor function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们展示了一些东西。首先，这是创建构造函数的旧方法。构造函数是设置作用域和在实例化时直接可用于对象的所有函数的函数。在这种情况下，我们已经将`a`、`b`和`c`作为`Item`构造函数的实例变量。其次，我们已经向项目的原型添加了一些内容。当我们在构造函数的原型上声明某些内容时，我们使所有该构造函数的实例都可以使用它。
- en: From here, we declare two items that are based on the `Item` constructor. This
    means that they will both get separate instances of the `a`, `b`, and `c` variables,
    but they will share the function `d`. We can see this in action with the next
    two statements. This showcases that if we add something directly to the `this`
    scope of a constructor function, it will create a brand-new instance of that item,
    but if we put something on the prototype, the items will all share it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们声明了两个基于`Item`构造函数的项目。这意味着它们将分别获得`a`、`b`和`c`变量的单独实例，但它们将共享函数`d`。我们可以在接下来的两个语句中看到这一点。这展示了如果我们直接添加一些内容到构造函数的`this`作用域中，它将创建该项目的全新实例，但如果我们将一些内容放在原型上，所有项目都将共享它。
- en: Finally, we can see that `item3` is a new `Item`, but we got to the constructor
    function in a roundabout way. Some browsers support the `__proto__` property on
    items, but this function should be available in all browsers. We grab the prototype
    and we notice that there is a constructor function. This is the same exact function
    that we declared at the top, so we are able to utilize it to make a new item.
    We can see that it is also on the same prototype as the other items and that the
    constructor function on the prototype is the exact same thing as the `item` variable
    that we declared.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以看到`item3`是一个新的`Item`，但我们通过迂回的方式到达了构造函数。一些浏览器支持项目上的`__proto__`属性，但这个函数应该在所有浏览器中都可用。我们获取原型并注意到有一个构造函数。这正是我们在顶部声明的完全相同的函数，因此我们能够利用它来创建一个新的项目。我们可以看到它也在与其他项目相同的原型上，并且原型上的构造函数与我们声明的`item`变量完全相同。
- en: 'What all of this should showcase is the fact that JavaScript is purely made
    of objects. There are no abstract types such as true classes in other languages.
    If we utilize the new syntax, it is best to understand that all we are doing is
    utilizing syntactic sugar to do what we used to be able to do with the prototype.
    That said, the next example will showcase the exact same behavior, but one will
    be old-school prototype-based, and the other will utilize the new class syntax:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都应该展示的是JavaScript纯粹由对象构成。没有其他语言中真正的类等抽象类型。如果我们利用新的语法，最好理解我们所做的只是利用语法糖来做我们以前可以用原型做的事情。也就是说，下一个例子将展示完全相同的行为，但一个是老式的基于原型的，另一个是利用新的类语法：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As we can see with this example, we get some cleaner syntax while creating the
    same object as what we had before with the prototype version. The constructor
    function is the same thing as when we declared the `Item` as a function. We could
    pass in any parameters and do the setup in here. One interesting thing with classes
    is that we are able to create instance variables inside the class, just like when
    we declared them on `this` in the prototype example. We can also see that the
    declaration of `d` is put on the prototype. We will explore more aspects of the
    class syntax below, but take some time and play with both pieces of code. Understanding
    how JavaScript is prototype-based helps immensely when we are trying to write
    highly performant code.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个例子，我们可以看到在创建与原型版本之前相同的对象时，我们获得了一些更清晰的语法。构造函数与我们声明`Item`为函数时是一样的。我们可以传入任何参数并在这里进行设置。类中的一个有趣之处是我们能够在类内部创建实例变量，就像我们在原型示例中在`this`上声明它们一样。我们还可以看到`d`的声明放在了原型上。我们将在下面探索类语法的更多方面，但花些时间并玩弄这两段代码。当我们试图编写高性能代码时，理解JavaScript是基于原型的将会极大地帮助。
- en: The public variables being inside the class is rather new (Chrome 72). If we
    do not have access to a newer browser, we will have to utilize Babel to transpile
    our code back down to a version that the browser will understand. We will also
    be taking a look at another feature that is only in Chrome and is experimental,
    but it should come to all browsers within the year.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的公共变量是相当新的（Chrome 72）。如果我们无法访问更新的浏览器，我们将不得不使用Babel将我们的代码转译回浏览器能理解的版本。我们还将看看另一个只在Chrome中且是实验性的功能，但它应该在一年内传递到所有浏览器。
- en: Other notable features
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他值得注意的功能
- en: JavaScript classes give us a bunch of nice features that make the code we write
    clean and concise, while also performing at or near the same speed as if we wrote
    directly to the prototype. One nice feature is the inclusion of static member
    variables and static member functions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript类为我们提供了许多很好的功能，使我们编写的代码清晰简洁，同时性能几乎与直接编写原型相同。一个很好的功能是包括静态成员变量和静态成员函数。
- en: 'While there is not much of a difference, it does allow us to write functions
    that cannot be accessed by the member functions (they can still be accessed, but
    it is a lot harder) and it can provide a good tool for grouping utility functions
    to that specific class. An example of static functions and variables is shown
    here:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有太大的区别，但它确实允许我们编写无法被成员函数访问的函数（它们仍然可以被访问，但要困难得多），并且它可以为将实用函数分组到特定类中提供一个很好的工具。这里展示了静态函数和变量的一个例子：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The two static definitions were added to the `newItem` class and then we showcase
    what is available. With the function `e` and the static variable `f`, we can see
    that they are not included on the objects we create from `newItem`, but we have
    access to them when we access `newItem` directly. On top of this, we can see that
    the `this` that is inside the static function points to the class. Static members
    and variables are great for creating utility functions or even for creating the
    singleton pattern in JavaScript.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 两个静态定义被添加到`newItem`类中，然后我们展示了可用的内容。通过函数`e`和静态变量`f`，我们可以看到它们不包括在我们从`newItem`创建的对象中，但当我们直接访问`newItem`时，我们可以访问它们。除此之外，我们可以看到静态函数内部的`this`指向类。静态成员和变量非常适合创建实用函数，甚至用于在JavaScript中创建单例模式。
- en: 'If we want to create the same experience in the old style, it would look like
    the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要以旧式风格创建相同的体验，它看起来会像下面这样：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, we have to put these definitions after the first definition of
    `Item`. This means that we have to be relatively careful in trying to group all
    of our code for the definition of our classes in the old style, whereas the class
    syntax allows us to put it all in a group.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们必须在`Item`的第一个定义之后放置这些定义。这意味着我们必须相对小心地尝试将我们的类定义的所有代码分组在旧式风格中，而类语法允许我们将其全部放在一个组中。
- en: 'On top of static variables and functions, we have the shorthand for writing
    the getters and setters for a variable in a class. This can be seen as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了静态变量和函数之外，我们还有一种为类中的变量编写getter和setter的简写方式。可以如下所示：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this getter and setter, we are able to do various things inside these functions
    when someone or something tries to access this variable. In the same vein that
    we set up a proxy to event on a change, we can do something similar with the getter
    and setter. We can also set up logging inside here. This syntax is quite nice
    when we want to access something as just a property name instead of writing our
    something like `getG` and `setG`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个getter和setter，当有人或某物尝试访问这个变量时，我们能够在这些函数内部做各种事情。就像我们设置了一个代理来监听变化一样，我们也可以在getter和setter中做类似的事情。我们还可以在这里设置日志记录。当我们想要访问某些东西时，这种语法非常好，只需使用属性名，而不是像`getG`和`setG`这样写。
- en: 'Finally, there are the new private variables that have come in Chrome 76\.
    While this is still in the candidate recommendation phase, it is still going to
    be discussed since it will most likely come into play. A lot of the time, we want
    to expose as much information as possible. However, there are times when we want
    to utilize internal variables to hold state or just not generally be accessed
    outside of our object. In this vein, the JavaScript community has come up with
    the `_` solution. Anything that has an `_` is considered a private variable. But,
    a user can still get access to these variables and manipulate them. Even worse
    than this, a malicious user could find a vulnerability in these private variables
    and be able to manipulate the system in their favor. One technique of creating
    private variables in the old system is something that looked like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有Chrome 76中出现的新私有变量。虽然这仍处于候选推荐阶段，但仍然会被讨论，因为它很可能会发挥作用。很多时候，我们希望尽可能多地公开信息。然而，有时我们希望利用内部变量来保存状态，或者一般情况下不被访问。在这方面，JavaScript社区提出了`_`解决方案。任何带有`_`的东西都被视为私有变量。但是，用户仍然可以访问这些变量并对其进行操作。更糟糕的是，恶意用户可能会发现这些私有变量中的漏洞，并能够操纵系统。在旧系统中创建私有变量的一种技术是以下形式：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With this, no one has access to the `priv` variable except for the implementer.
    This gives us a public-facing system, without access to that private variable.
    However, there is still a catch with this system: if we create another `Public`
    object, we will still be affecting the same `priv` variable. There are other ways
    to make sure that we get new variables as we create new objects, but these are
    all workarounds to the system we are trying to make. Instead, we can now utilize
    the following syntax:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，除了实现者之外，没有人可以访问`priv`变量。这为我们提供了一个面向公众的系统，而不会访问私有变量。然而，这个系统仍然有一个问题：如果我们创建另一个`Public`对象，我们仍然会影响相同的`priv`变量。还有其他方法可以确保我们在创建新对象时获得新变量，但这些都是我们试图制定的系统的变通方法。相反，我们现在可以利用以下语法：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: What that pound sign does is say that this is a private variable. If we try
    to get access to it from any one of our instances, it will come back undefined.
    This works great with the getter and setter interface as we will be able to control
    access to variables and even modify them if need be.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 井号的作用是表示这是一个私有变量。如果我们尝试从任何一个实例中访问它，它将返回未定义。这与getter和setter接口非常配合，因为我们将能够控制对变量的访问，甚至在需要时修改它们。
- en: 'One final look into classes is the `extend` and `super` keywords. With `extend`,
    we are able to do just that with classes. Let''s take our `newItem` class and
    extend its functionality. This could look like the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再来看一下类的`extend`和`super`关键字。通过`extend`，我们可以对类进行扩展。让我们以`newItem`类为例，扩展其功能。这可能看起来像这样：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We have a few interesting behaviors happening in this example. First, if we
    run `Object.getPrototypeOf` on our extended object, we will see that the prototype
    is what we would expect, `extendedNewItem`. Now, if we get the prototype of that,
    we will see that it is `newItem`. We have created a prototype chain just like
    many of the built-in objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中发生了一些有趣的行为。首先，如果我们在扩展对象上运行`Object.getPrototypeOf`，我们会看到原型是我们所期望的`extendedNewItem`。现在，如果我们获取它的原型，我们会看到它是`newItem`。我们创建了一个原型链，就像许多内置对象一样。
- en: Second, we have the capability of getting to our parent's methods from inside
    our class with the use of `super`. This is essentially a reference to our parent's
    prototype. We cannot chain these if we want to keep going through all of the prototypes.
    We would have to utilize something like `Object.getPrototypeOf`. We can also see,
    by inspecting our extended object, that we got all of the member variables that
    were held in our parent's system.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们可以使用`super`从类内部访问父类的方法。这本质上是对我们父类的原型的引用。如果我们想要继续遍历所有的原型，我们不能链式调用它们。我们必须利用诸如`Object.getPrototypeOf`之类的东西。我们还可以通过检查我们的扩展对象来看到，我们得到了我们父类系统中保存的所有成员变量。
- en: This gives us the ability to compose our classes together and create base classes
    or abstract classes that give us some defined behavior and then we can create
    extended classes that give us specific behavior that we want. We will see more
    code later on that utilizes classes and many of the concepts that we have gone
    over here, but remember that classes are just syntactical sugar for the prototype
    system and a good understanding of that will go a long way into understanding
    how JavaScript works as a language.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够组合我们的类并创建基类或抽象类，这些类给我们一些定义好的行为，然后我们可以创建扩展类，给我们想要的特定行为。我们将在后面看到更多使用类和我们在这里讨论过的许多概念的代码，但请记住，类只是原型系统的语法糖，对此的良好理解将有助于理解JavaScript作为一种语言的工作原理。
- en: There are many great things about that class interface with the JavaScript ecosystem
    and there appear to be some other great ideas potentially coming in the future,
    such as decorators. It is always a good idea to keep an eye on the **Mozilla Developer
    Network** (**MDN**) page to see what is new and what is possibly coming out in
    the future. We will now take a look at modules and how they work in our system
    of writing clean and fast code.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JavaScript生态系统中的类接口有很多好东西，而且似乎还有一些其他很棒的想法可能会在未来出现，比如装饰器。随时关注**Mozilla开发者网络**（**MDN**）页面，了解新的内容和可能在未来出现的内容总是一个好主意。现在我们将看一下模块以及它们在我们编写清晰快速代码的系统中是如何工作的。
- en: A good rule of thumb is to not extend any class more than one, maybe two levels
    deep. If we go any further, we can start to create a maintenance nightmare, on
    top of potential objects getting heavy with information that they don't need.
    Thinking ahead will always be the best bet when we are creating our systems, and
    trying to minimize the impact of our classes is one way of reducing memory use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的经验法则是不要扩展任何类超过一到两个级别。如果我们再继续下去，我们可能会开始创建一个维护的噩梦，除了潜在的对象变得过于沉重，包含了它们不需要的信息。提前考虑将始终是我们创建系统时的最佳选择，尽量减少我们类的影响是减少内存使用的一种方式。
- en: Modules
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块
- en: Before ECMAScript 2015, we had no concept of loading in code other than utilizing
    the script tag. We came up with many module concepts and libraries, such as **RequireJS** or
    **AMD**, but none of them were built into the language. With the advent of modules,
    we now had a way of creating highly modular code that could easily be packaged
    up and imported into other sections of our code. We also got scope lock on our
    systems where we used to have to utilize IIFEs to get this behavior.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 2015之前，我们没有加载代码的概念，除了使用脚本标签。我们提出了许多模块概念和库，比如**RequireJS**或**AMD**，但没有一个是内置到语言中的。随着模块的出现，我们现在有了一种创建高度模块化代码的方式，可以轻松地打包并导入到我们代码的其他部分。我们还在我们以前必须使用IIFE来获得这种行为的系统中获得了作用域锁。
- en: 'First, before we can start to work with modules, we will need a static server
    to host all of our content. Even if we get Chrome to allow access to the local
    filesystem, the module system will get upset since it will not serve them as text/JavaScript.
    To get around this, we can install the node package, `node-static`. We are going
    to add this package to a static directory. We can run the following command: `npm
    install node-static`. Once this is finished downloading into the `static` directory,
    we can grab the `app.js` file from the `Chapter03` folder in our repository and
    run `node app.js`. This will start up the static server, along with serving them
    from the `files` directory inside our `static` directory. We can then place any
    files that we want to serve in there and be able to get at them from our code.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在我们开始使用模块之前，我们需要一个静态服务器来托管我们所有的内容。即使我们让Chrome允许访问本地文件系统，模块系统也会因为无法将它们作为文本/JavaScript提供而感到不安。为了解决这个问题，我们可以安装node包`node-static`。我们将把这个包添加到一个静态目录中。我们可以运行以下命令：`npm
    install node-static`。一旦这个包下载完成到`static`目录中，我们可以从我们的存储库中的`Chapter03`文件夹中获取`app.js`文件并运行`node
    app.js`。这将启动静态服务器，并从`static`目录中的`files`目录中提供服务。然后我们可以把任何想要提供的文件放在那里，并且能够从我们的代码中获取到它们。
- en: 'Now, we can write a basic module along the lines of the following and save
    it as `lib.js`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个基本的模块，如下所示，并将其保存为`lib.js`：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can then import this module from an HTML file as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以从HTML文件中导入这个模块，如下所示：
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With even this basic example, we can get an idea of how modules work in the
    browser. First, the type of script needs to be a module. This tells the browser
    that we are going to load in modules and that we are going to treat this body
    of code as if it were a module. This gives us several benefits. First, we are
    automatically put into strict mode when we are utilizing modules. Second, we are
    automatically scoped with modules. This means that the `lib` that we just imported
    is not available as a global. If we loaded in content as text/JavaScript and put
    variables on the global path, then we would automatically have them; that is why
    we usually have to utilize an IIFE. Finally, we get a nice syntax in which to
    load our JavaScript files. We could still utilize the old way of loading in a
    bunch of scripts, but we can also just import the ones that are module-based.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是这个基本的例子，我们也可以了解模块在浏览器中是如何工作的。首先，脚本的类型需要是一个模块。这告诉浏览器我们要加载模块，并且我们要把这段代码作为模块来处理。这给了我们几个好处。首先，当我们使用模块时，我们会自动进入严格模式。其次，我们在模块中自动获得了作用域。这意味着我们刚刚导入的`lib`不会作为全局变量可用。如果我们将内容加载为文本/JavaScript并将变量放在全局路径上，那么我们将自动拥有它们；这就是为什么我们通常必须使用IIFE。最后，我们得到了一个很好的语法来加载我们的JavaScript文件。我们仍然可以使用旧的方式加载一堆脚本，但我们也可以只导入基于模块的脚本。
- en: 'Next, we can see that the module itself uses the `export` and `default` keywords.
    The `export` means that we want this item to be available outside of this scope
    or file. We can now get to this item outside of our current file. The default
    means that if we load in the module without defining what we want, we will get
    this item automatically. This can be seen in the following example:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到模块本身使用了`export`和`default`关键字。`export`表示我们希望这个项在这个作用域或文件之外可用。现在我们可以在当前文件之外访问到这个项。`default`表示如果我们加载模块而没有定义我们想要的内容，我们将自动获得这个项。这可以在以下示例中看到：
- en: '[PRE30]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'First, we defined an object called `exports`. This is the object that we want
    to add as an exported item. Second, we added this item to an `export` declaration
    and we also renamed it. This is one nice thing about modules. On either the export
    or the import side, we can rename the items that we want to export. Now, in our
    HTML file, we would have a declaration such as the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了一个名为`exports`的对象。这是我们要添加为导出项的对象。其次，我们将此项添加到一个`export`声明中，并且还重命名了它。这是模块的一个好处。在导出或导入的一侧，我们都可以重命名我们想要导出的项。现在，在我们的HTML文件中，我们会有如下声明：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If we did not have the brackets around the declaration, we would be trying to
    bring in the default export. Since we have the curly brackets, it is going to
    look for an item called `Item` inside `lib.js`. If it finds it, then it will bring
    in the code that is associated with that.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在声明周围没有括号，我们将尝试引入默认导出。由于我们有花括号，它将在`lib.js`中查找名为`Item`的项目。如果找到，它将引入与之关联的代码。
- en: 'Now, just as we renamed the exports from the export list, we can rename the
    import. Let''s go ahead and change that to the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，就像我们从导出列表中重命名导出一样，我们可以重命名导入。让我们继续将其更改为以下内容：
- en: '[PRE32]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can now utilize the item as we normally would, but as the variable `_item`
    instead of `Item`. This is great for name collisions. There are only so many variable
    names that we can come up with so, instead of changing the variables inside the
    separate libraries, we can just change them when they are loaded in.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像往常一样利用该项，但是作为变量`_item`而不是`Item`。这对于名称冲突非常有用。我们只能想出那么多变量名，所以，我们可以在加载它们时改变它们，而不是在单独的库中更改变量。
- en: 'A good styling convention is to declare all of our imports at the top. However,
    there are use cases where we may need to dynamically load our modules due to some
    type of user interaction or some other event. If this occurs, we can utilize dynamic
    imports to do this. These appear as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的样式约定是在顶部声明所有导入。然而，有一些用例可能需要动态加载模块，因为某种类型的用户交互或其他事件。如果发生这种情况，我们可以利用动态导入来实现这一点。这些看起来如下：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have added a button that, when clicked, we try to load the module into our
    system. This is not the best way to cache the module in our system and most browsers
    will also do some caching for us, but this way is fairly straightforward and showcases
    the dynamic import system. The import function is based on promises, so we try
    to grab it and, if we succeed, we add it to an imported object. We then call the
    default method. We can get to any of the items that the module exports for us,
    but this is one of the easiest to get to.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个按钮，当点击时，我们尝试将模块加载到我们的系统中。这不是在我们的系统中缓存模块的最佳方式，大多数浏览器也会为我们做一些缓存，但这种方式相当简单，展示了动态导入系统。导入函数基于承诺，因此我们尝试抓取它，如果成功，我们将其添加到导入的对象中。然后调用默认方法。我们可以访问模块为我们导出的任何项目，但这是最容易访问的项目之一。
- en: Seeing how JavaScript has evolved has been amazing. All of these new features
    give us capabilities that we used to have to rely on from third parties. The same
    can be said regarding the changes to the DOM. We will now look at these changes.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 看到JavaScript的发展是令人惊讶的。所有这些新功能给了我们以前必须依赖第三方的能力。关于DOM的变化也是如此。我们现在将看看这些变化。
- en: Working with the DOM
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用DOM
- en: 'The **Document Object Model** (**DOM**) has not always been the easiest technology
    to work with. We had old archaic APIs and, most of the time, they never lined
    up between browsers. But, within the last couple of years, we have gotten some
    nice APIs to do the following: grab elements with ease, build in-memory hierarchies
    for fast attachment, and templates with DOM shadowing. All of these have led to
    a rich environment for making changes to the underlying nodes and creating a number
    of rich frontends without the need for libraries such as jQuery. In the following
    sections, we will see how working with these new APIs has helped us.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 文档对象模型（DOM）并不总是最容易使用的技术。我们有古老的过时API，大多数时候，它们在不同浏览器之间无法对齐。但是，在过去的几年里，我们已经得到了一些很好的API来做以下事情：轻松获取元素，构建内存层次结构以进行快速附加，并使用DOM阴影进行模板。所有这些都导致了一个丰富的环境，可以对底层节点进行更改，并创建许多丰富的前端，而无需使用jQuery等库。在接下来的几节中，我们将看到如何使用这些新API有所帮助。
- en: Query selector
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询选择器
- en: 'Before we had this API (or we were trying to be as cross-browser as we could),
    we relied on systems such as `getElementById` or `getElementsByClassName`. Each
    of these provided a way in which we could get DOM elements, as in the following
    example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有这个API之前（或者我们试图尽可能跨浏览器），我们依赖于诸如`getElementById`或`getElementsByClassName`之类的系统。每个都提供了一种我们可以获取DOM元素的方式，如下例所示：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One difference between this older API and the new `querySelector` and `querySelectorAll`
    is that the old API implements a collection of DOM nodes as an `HTMLCollection`
    and the newer API implements them as a `NodeList`. While this may not seem like
    a major difference, the `NodeList` API does give us a `forEach` already built
    into the system. Otherwise, we would have to change both of these collections
    to a regular array of DOM nodes. The preceding example, implemented in the new
    API, appears as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个旧API和新的`querySelector`和`querySelectorAll`之间的一个区别是，旧API将DOM节点集合实现为`HTMLCollection`，而新API将它们实现为`NodeList`。虽然这可能看起来不是一个重大的区别，但`NodeList`API确实给了我们一个已经内置到系统中的`forEach`。否则，我们将不得不将这两个集合都更改为常规的DOM节点数组。在新API中实现的前面的示例如下：
- en: '[PRE35]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This becomes much nicer when we want to start adding other features to our selection
    process.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要开始向我们的选择过程添加其他功能时，这变得更加美好。
- en: Let's say that we now have a few inputs and that we want to grab all inputs
    that are of the text type. How would this look inside the old API? We could attach
    a class to all of them if need be, but this would pollute our use of classes and
    is probably not the best way of handling this information.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在有一些输入，并且我们想获取所有文本类型的输入。在旧API中会是什么样子？如果需要，我们可以给它们都附加一个类，但这会污染我们对类的使用，可能不是处理这些信息的最佳方式。
- en: 'The other way that we could get this data would be to utilize one of the old
    API methods and then check whether those elements have the input attribute set
    to `text`. This could look like the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用旧API方法之一来获取这些数据，然后检查这些元素是否将输入属性设置为`text`。这可能看起来像下面这样：
- en: '[PRE36]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But we now have a certain level of verbosity that is not needed. Instead, we
    could grab them by utilizing CSS selectors, utilizing the Selector API as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在我们有了一定程度的冗长，这是不需要的。相反，我们可以通过使用CSS选择器来获取它们，使用选择器API如下：
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This means we should be able to get to any DOM node utilizing the CSS syntax,
    just like jQuery does. We can even start from another element so that we do not
    have to parse the entire DOM, like so:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该能够利用CSS语法访问任何DOM节点，就像jQuery一样。我们甚至可以从另一个元素开始，这样我们就不必解析整个DOM，就像这样：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The other nice thing about the Selectors API is that it will throw an error
    if we do not utilize a correct CSS selector. This gives us the added benefit of
    the system running checks for us. While the new Selector API has been around,
    it has not been utilized much because of Internet Explorer needing to be included
    in the supported web browsers. It is highly suggested to start to utilize the
    new Selector API as it is less verbose and we are able to do a lot more with it
    than our old system.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器API的另一个好处是，如果我们不使用正确的CSS选择器，它将抛出错误。这为我们提供了系统为我们运行检查的额外好处。虽然新的选择器API已经存在，但由于需要包括Internet
    Explorer在支持的Web浏览器中，它并没有被广泛使用。强烈建议开始使用新的选择器API，因为它不那么冗长，我们能够做的事情比旧系统多得多。
- en: jQuery is a library that gives us a nicer API to utilize than the base system
    had. Most of the changes that jQuery supported have now become obsolete, with
    many of the new web APIs that we have been talking about taking over. For most
    new applications, they will no longer need to utilize jQuery.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery是一个库，它为我们提供了比基本系统更好的API。jQuery支持的大多数更改现在已经过时，许多我们已经谈论过的新的web API正在接管。对于大多数新应用程序，它们将不再需要使用jQuery。
- en: Document fragments
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文档片段
- en: We have seen these in previous chapters, but it is nice to touch upon them.
    Document fragments are reusable containers that we can create a DOM hierarchy
    in and attach all of those nodes at once. This leads to faster draw times and
    less repainting when utilized.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在之前的章节中已经看到了这些，但是触及它们是很好的。文档片段是可重用的容器，我们可以在其中创建DOM层次结构，并一次性附加所有这些节点。这导致更快的绘制时间和更少的重绘。
- en: 'The following example showcases two ways of attaching a series of list elements
    utilizing straight-to-DOM addition and fragment addition:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了两种使用直接DOM添加和片段添加的方式附加一系列列表元素：
- en: '[PRE39]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While the time between these two is tiny, the number of repaints that take place
    is not. In our first example, the document is going to repaint each time we add
    an element directly to it, whereas our second example is only going to repaint
    the DOM once. This is the nice thing about document fragments; it makes adding
    to the DOM simple, while also only utilizing minimal repaints.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这两者之间的时间很短，但发生的重绘次数并非如此。在我们的第一个示例中，每次直接向文档添加元素时，文档都会重绘，而我们的第二个示例只会重绘一次DOM。这就是文档片段的好处；它使向DOM添加变得简单，同时只使用最少的重绘。
- en: Shadow DOM
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shadow DOM
- en: The shadow DOM is usually paired with templates and web components, but it can
    also be utilized by itself. The shadow DOM allows us to encapsulate our markup
    and styles for a specific section of our application. This is great if we want
    to have a certain styling for a piece of our page, but we do not want that to
    propagate to the rest of the page.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影DOM通常与模板和Web组件配对使用，但也可以单独使用。阴影DOM允许我们封装我们应用程序的特定部分的标记和样式。如果我们想要页面的某个部分具有特定的样式，但不希望其传播到页面的其他部分，这是很好的。
- en: 'We can easily utilize the shadow DOM by utilizing its API, shown as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用其API轻松地使用阴影DOM，如下所示：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: First, we attach a shadow DOM to an element, in this case, our `shadowHolder`
    element. There is a mode option that allows us to say whether we can access the
    content through JavaScript outside of the shadow context, but it has been found
    that we can easily circumvent this, so it is recommended just to keep it open.
    Next, we create a few elements, one being a number of styling attributes. We then
    attach these to a document fragment and finally to the shadow root.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将阴影DOM附加到一个元素上，这里是我们的`shadowHolder`元素。有一个模式选项，它允许我们说是否可以在阴影上下文之外通过JavaScript访问内容，但已经发现我们可以轻松地规避这一点，因此建议保持它开放。接下来，我们创建一些元素，其中一个是一些样式属性。然后，我们将这些附加到一个文档片段，最后附加到阴影根。
- en: With all of that out of the way, we can take a look and notice that our shadow
    DOM gets affected by the styling attributes that were put inside with it instead
    of the ones that were put at the top of our main document. What happens if we
    put a style at the top of our document that our shadow styling does not have?
    It still does not get affected. With this, we are now able to create components
    that can be styled separately without the use of classes. This brings us to one
    of our final topics of the DOM.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定所有这些之后，我们可以看到并注意到我们的阴影DOM受到了放在其中的样式属性的影响，而不是放在我们主文档顶部的样式属性。如果我们在文档顶部放置一个我们的阴影样式没有的样式会发生什么？它仍然不会受到影响。有了这个，我们现在能够创建可以单独样式化的组件，而无需使用类。这将我们带到DOM的最后一个主题之一。
- en: Web components
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web组件
- en: The Web Component API allows us to create custom elements that have defined
    behaviors utilizing only the browser APIs. This is different to a framework such
    as Bootstrap or even Vue as we are able to utilize all of the technologies that
    are present in our browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Web组件API允许我们创建具有定义行为的自定义元素，仅利用浏览器API。这与诸如Bootstrap甚至Vue之类的框架不同，因为我们能够利用浏览器中存在的所有技术。
- en: Chrome and Firefox have all of these APIs supported. Safari has most of them,
    and if this is a browser that we want to support, we will only be able to utilize
    some of the APIs. Edge does not have support for the Web Component APIs, but with
    it moving to a chromium base, we will see another browser able to utilize this
    technology.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome和Firefox都支持所有这些API。Safari支持其中大部分，如果这是我们想要支持的浏览器，我们只能利用其中的一些API。Edge不支持Web组件API，但随着它转向Chromium基础，我们将看到另一个能够利用这项技术的浏览器。
- en: 'Let''s create a basic `tooltip` element. First, we need to extend the base
    `HTMLElement` in our class. We will then need to attach some properties to allow
    us to place the element and to give us the text that we need to use. Finally,
    we will need to register this component with our system to make sure it recognizes
    our custom element. The following code creates this custom element (modified from
    [https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的`tooltip`元素。首先，我们需要在我们的类中扩展基本的`HTMLElement`。然后，我们需要附加一些属性，以允许我们放置元素并给我们需要使用的文本。最后，我们需要注册这个组件到我们的系统中，以确保它识别我们的自定义元素。以下代码创建了这个自定义元素（修改自[https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements)）：
- en: '[PRE41]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: First, we have a list of attributes that we are going to use to style and position
    our `tooltip`. They are called `x`, `y`, `type`, `text`, and `show`, respectively.
    Next, we create a map for some emoji-based text so that we can utilize icons without
    bringing in a full-fledged library for this. We then set up our reusable object
    inside a shadow container. We also put the shadow root on the object so we have
    easy access to it. The `update` method will fire on the first creation of our
    element and on any subsequent changes to our attributes. We can see this in the
    last three functions. `connectedCallback` will fire once we have been attached
    to the DOM. `attributeChangedCallback` will alert us to any attribute changes
    that have occurred. This is very similar to the Proxy API. The last piece lets
    our object know which attributes we specifically care about, in this case, `x`,
    `y`, `type`, `text`, and `show`. Finally, we register our custom component with
    the `customElements.define` method, giving it a name and the class that we want
    to run when one of these objects is created.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有一个属性列表，我们将使用它们来样式化和定位我们的`tooltip`。它们分别称为`x`、`y`、`type`、`text`和`show`。接下来，我们创建了一个基于表情符号的文本映射，这样我们就可以利用图标而不需要引入一个完整的库。然后我们在一个阴影容器内设置了可重用的对象。我们还将阴影根放在对象上，这样我们就可以轻松访问它。`update`方法将在我们的元素第一次创建时触发，并在属性的任何后续更改时触发。我们可以在最后三个函数中看到这一点。`connectedCallback`将在我们被附加到DOM时触发。`attributeChangedCallback`将提醒我们发生了任何属性更改。这与代理API非常相似。最后一部分让我们的对象知道我们特别关心哪些属性，这种情况下是`x`、`y`、`type`、`text`和`show`。最后，我们使用`customElements.define`方法注册我们的自定义组件，给它一个名称和我们想要在创建这些对象时运行的类。
- en: 'Now, if we create our `tooltip`, we can utilize these different properties
    to make a reusable system for `tooltip` or even alerts. The following code demonstrates
    this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们创建我们的`tooltip`，我们可以利用这些不同的属性来制作一个可重用的`tooltip`系统，甚至是警报。以下代码演示了这一点：
- en: '[PRE42]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We should see a floating box with a checkmark and the text Here is our tooltip.
    We can make this `tooltip` a little bit easier to read by utilizing the templating
    system that also comes with the Web Component API.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到一个浮动框，上面有一个复选标记和文本“这是我们的提示”。通过利用Web组件API中的模板系统，我们可以使这个`tooltip`更容易阅读。
- en: Templates
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板
- en: 'Now, we have a nice reusable `tooltip` element, but we also have quite a bit
    of code along with our style tag that is made up entirely of a templated string.
    What would be best is if we could have this semantic markup put somewhere else
    and have the execution logic in our web component as it is now. This is where
    templates come into play. The `<template>` element will not be displayed on the
    page, but we can still grab it quite easily by giving it an ID. So, one way of
    refactoring our current code would be to do the following:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个不错的可重用的`tooltip`元素，但是我们的样式标签中也有相当多的代码，它完全由模板化的字符串组成。最好的办法是，如果我们可以把这个语义标记放在别的地方，并把执行逻辑放在我们的Web组件中，就像现在一样。这就是模板发挥作用的地方。`<template>`元素不会显示在页面上，但我们仍然可以通过给它一个ID来很容易地获取它。因此，重构我们当前的代码的一种方式是这样的：
- en: '[PRE43]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And our JavaScript class constructor should now look like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript类构造函数现在应该是这样的：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: That is much easier to read and much easier to reason about. We now grab our
    template and get its content. We create a `shadow` object and append our template.
    We need to make sure to clone our template nodes otherwise we will share the same
    reference between all of the elements that we decide to create! One thing you
    will notice is that we cannot now control the text through an attribute. While
    it was interesting to see this behavior, we really want to leave that information
    up to the creator of our `tooltip`. We can do this through the `<slot>` element.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更容易阅读，更容易理解。现在我们获取我们的模板并获取它的内容。我们创建一个`shadow`对象并附加我们的模板。我们需要确保克隆我们的模板节点，否则我们将在我们决定创建的所有元素之间共享相同的引用！你会注意到的一件事是，我们现在无法通过属性来控制文本。虽然看到这种行为很有趣，但我们真的希望把这些信息留给我们的`tooltip`的创建者。我们可以通过`<slot>`元素来实现这一点。
- en: 'A slot gives us an area where we can put HTML in place of that location. We
    can utilize this to allow users of the `tooltip` to put in the markup they want
    for that slot. We could give them a template that looks like the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 插槽给了我们一个区域，我们可以在那个位置放置HTML。我们可以利用这一点，让`tooltip`的用户放入他们想要的标记。我们可以给他们一个看起来像下面这样的模板：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And our implementation may appear as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的实现可能如下所示：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As we can see, the use of the shadow DOM, along with web components and the
    template system in our browser, allows us to create rich elements without the
    need for external libraries such as Bootstrap or Foundation.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，阴影DOM的使用，以及浏览器中的Web组件和模板系统，使我们能够创建丰富的元素，而无需外部库，如Bootstrap或Foundation。
- en: We may still need these libraries to provide some base-level styling, but we
    should not need them to the extent we used to. The best-case scenario is that
    we can write all of our own components with styling and not need to utilize external
    libraries. But, seeing as how these systems are relatively new, if we are not
    able to control what our users use, we may be stuck polyfilling.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能仍然需要这些库来提供一些基本的样式，但我们不应该像过去那样需要它们。最理想的情况是，我们可以编写所有自己的组件和样式，而不需要利用外部库。但是，由于这些系统相对较新，如果我们无法控制用户的使用，我们可能会陷入填充的困境。
- en: Understanding the Fetch API
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Fetch API
- en: 'Before the Fetch API, we had to utilize the `XMLHttpRequest` system. To create
    a request for server data, we had to write something like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fetch API之前，我们必须利用`XMLHttpRequest`系统。要创建一个服务器数据请求，我们必须编写类似以下的内容：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, you will notice that the object type is called `XMLHttpRequest`. The
    reason is due to who invented it and the reason behind it. Microsoft had originally
    developed the technique for the Outlook web access product. Originally, they were
    transferring XML documents back and forth, and so they named the object for what
    it was built for. Once other browser vendors, mainly Mozilla, adopted it, they
    decided to keep the name even though its purpose had shifted from just sending
    XML documents to sending any type of response from a server to a client.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会注意到对象类型被称为`XMLHttpRequest`。原因是由于谁发明了它以及背后的原因。微软最初开发了这种技术，用于Outlook Web
    Access产品。最初，他们来回传输XML文档，因此他们为其构建的对象命名。一旦其他浏览器供应商，主要是Mozilla，采用了它，他们决定保留名称，即使其目的已经从仅发送XML文档转变为从服务器发送到客户端的任何类型的响应。
- en: Second, we add an event listener to the object. Since this is a plain object
    and not promise-based, we add a listener the old fashioned way with the `addEventListener`
    method. This means we would also clean up the event listener once it has been
    utilized. Next, we open the request, passing in the method we want to send on
    and where we want to send it to. We can then set up a bunch of request headers
    (here specifically, we stipulate that we want application/JSON data and we set
    the `responseType` to `json` so that it will be converted properly by the browser).
    Finally, we send the request.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们向对象添加了一个事件监听器。由于这是一个普通对象而不是基于promise的，我们以`addEventListener`方法的老式方式添加监听器。这意味着一旦它被使用，我们也会清理事件监听器。接下来，我们打开请求，传入我们想要发送的方法和发送的位置。然后我们可以设置一堆请求头（在这里特别指定我们想要的应用程序/JSON数据，并将`responseType`设置为`json`，以便浏览器正确转换）。最后，我们发送请求。
- en: 'Once we achieve a response, our event will fire and we can retrieve the response
    from the event''s target. Once we get into posting data, it can get even more
    cumbersome. This was the reason for things such as jQuery''s `$.ajax` and such
    methods. It made working with the `XMLHttpRequest` object a lot easier. So what
    does this response look like in terms of the Fetch API? This exact same request
    can be seen as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获得响应，我们的事件将触发，我们可以从事件的目标中检索响应。一旦我们开始发布数据，情况可能会变得更加繁琐。这就是jQuery的`$.ajax`和类似方法的原因。它使得与`XMLHttpRequest`对象一起工作变得更加容易。那么从Fetch
    API的角度来看，这种响应是什么样子的呢？这个完全相同的请求可以如下所示：
- en: '[PRE48]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We can see that this is quite a bit easier to read and comprehend. First, we
    set up the URL that we want to hit. If we do not pass the action to the `fetch`
    call, it will automatically assume that we are creating a `GET` request. Next,
    we get the response and make sure that we get it in `json`. The responses will
    always come back as a *promise* (more about that in a bit) and so we want to convert
    it to the format that we want, in this case, `json`. From here, we get the final
    object that we are able to set to the `innerHTML` of our content. As we can see
    from this basic example of the two objects, the Fetch API has almost the exact
    same capabilities that we have with `XMLHttpRequest`, but it is in an easier-to-understand
    format and we can easily work with the API.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这样阅读和理解起来要容易得多。首先，我们设置我们要访问的URL。如果我们在`fetch`调用中不传递操作，它将自动假定我们正在创建一个`GET`请求。接下来，我们获取响应，并确保以`json`格式获取它。响应将始终作为*promise*返回（稍后会详细介绍），因此我们希望将其转换为我们想要的格式，即`json`。从这里，我们得到了最终的对象，我们可以将其设置为我们内容的`innerHTML`。从这两个基本对象的示例中，我们可以看到Fetch
    API几乎具有与`XMLHttpRequest`相同的功能，但它的格式更容易理解，我们可以轻松地使用API。
- en: Promises
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Promises
- en: 'As we saw with the previous `fetch` example, we utilized something called a
    promise. A simple way to think of a promise is a value that we are going to want
    in the future, and what is returned to us is a contract that states *I will hand
    it to you later*. Promises were based on the concept of callbacks. If we look
    at an example of a callback that we could have wrapped around `XMLHttpRequest`,
    we can see how it functions as a promise:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的`fetch`示例中看到的，我们利用了一个叫做promise的东西。简单地说，promise就是一个我们将来会需要的值，而返回给我们的是一个合同，声明了“我会在以后把它交给你”。Promise是基于回调的概念。如果我们看一个可能包装在`XMLHttpRequest`周围的回调的例子，我们可以看到它是如何作为一个promise运行的：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this, we get almost the same functionality that we have with a promise
    but utilizing callbacks or functions that we want to run when something happens.
    The problem with a callback system is something known as callback hell. This is
    the idea that highly asynchronous code will always have callbacks and this means
    that if we want to utilize it, we will have a wonderful tree view of callbacks.
    This would look like the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们几乎可以得到与promise相同的功能，但是利用回调或我们想要在发生某事时运行的函数。回调系统的问题是被称为回调地狱。这是高度异步代码总是有回调的想法，这意味着如果我们想要利用它，我们将会有一个美妙的回调树视图。这看起来像下面这样：
- en: '[PRE50]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This fake version of `fetch` would be if the API for `fetch` were not promise-based.
    First, we would pass in our URL. We would also need to provide a callback for
    when our response comes back in. We would then need to pass that response to the
    `json` method that would also need a callback to turn the response data into `json`.
    Finally, we would have the result and would put it into our DOM.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个虚构的`fetch`版本是如果`fetch`的API不是基于promise的。首先，我们会传入我们的URL。我们还需要为响应返回时提供一个回调。然后，我们需要将该响应传递给`json`方法，该方法还需要一个回调来将响应数据转换为`json`。最后，我们会得到结果并将其放入我们的DOM。
- en: As we can see, callbacks can lead to quite a few problems. Instead, we have
    the promise. A promise takes a single argument when it is created, a function
    that has two parameters—resolve and reject. With these, we can either give a success
    back to our caller through the `resolve` function, or we can error out with the
    `reject` function. This, in turn, will allow us to chain these promises together
    through `then` calls and the `catch` call, as we can see in our `fetch` example.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，回调可能会导致很多问题。相反，我们有了promise。promise在创建时需要一个参数，即一个具有两个参数（resolve和reject）的函数。有了这些，我们可以通过`resolve`函数向调用者返回成功，或者通过`reject`函数报错。这将允许我们通过`then`调用和`catch`调用将这些promise链接在一起，就像我们在`fetch`示例中看到的那样。
- en: 'However, these can also lead to another problem. We can get a giant chain of
    promises that looks a bit better than callbacks, but not by much. We then get
    the `async`/`await` system. Instead of constantly chaining promises with `then`,
    we can use `await` to utilize the response. We can then turn our `fetch` call
    into something that looks like the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也可能导致另一个问题。我们可能会得到一长串promise，看起来比回调好一些，但并不明显。然后我们有了`async`/`await`系统。我们可以使用`await`来利用响应，而不是不断地用`then`链接promise。然后我们可以将我们的`fetch`调用转换成以下形式：
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `async` descriptor before the function tells us that this is an `async`
    function. We cannot utilize `await` if we do not have this. Next, instead of chaining
    `then` functions together, we can just `await` the function. The result is what
    would have been wrapped in our `resolve` function. Now, we have something that
    reads quite well.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 函数前的`async`描述符告诉我们这是一个`async`函数。如果没有这个描述符，我们就无法使用`await`。接下来，我们可以直接使用`await`函数，而不是将`then`函数链接在一起。结果就是原本会被包装在我们的`resolve`函数中的内容。现在，我们有了一个非常易读的东西。
- en: We do need to be careful with the `async`/`await` system. It does actually wait,
    so if we put this on the main thread or do not have this wrapped in something,
    it can block the main thread, causing us to lock up. Also, if we have a bunch
    of tasks that we want to run at the same time, instead of awaiting them one at
    a time (making our code sequential), we can utilize `Promise.all()`. This allows
    us to put a bunch of promises together and allows them all to run asynchronously.
    Once they all return, we can continue execution.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心`async`/`await`系统。它确实会等待，所以如果我们将其放在主线程上，或者没有将其包装在其他东西中，它可能会阻塞主线程，导致我们无法继续执行。此外，如果我们有一堆任务需要同时运行，我们可以利用`Promise.all()`，而不是一个接一个地等待它们（使我们的代码变成顺序执行）。这允许我们将一堆promise放在一起，并允许它们异步运行。一旦它们都返回，我们就可以继续执行。
- en: One nice thing about the `async`/`await` system is that it can actually be faster
    than using generic promises. Many browsers have added optimizations around these
    specific keywords and so we should try to use them at every opportunity we have.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`/`await`系统的一个好处是它实际上可能比使用通用promise更快。许多浏览器已经围绕这些特定的关键字添加了优化，因此我们应该尽可能地利用它们。'
- en: It has been stated before, but browser vendors are constantly making improvements
    to their implementations of the ECMAScript standard. This means that new technologies
    will be slow at first, but once they are in widespread use or they are agreed
    upon by all vendors, they will start to optimize and usually make them faster
    than their counterparts. When possible, utilize the newer technologies that browser
    vendors are giving us!
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 之前已经提到过，但浏览器供应商不断改进他们对ECMAScript标准的实现。这意味着新技术一开始会比较慢，但一旦被广泛使用或得到所有供应商的认可，它们就会开始优化，并通常比其对应的技术更快。在可能的情况下，利用浏览器供应商提供给我们的新技术！
- en: Back to fetch
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到fetch
- en: So now that we have seen what a `fetch` request looks like, we should take a
    look at grabbing the underlying readable stream. The `fetch` system has been adding
    quite a few features, two of these being piping and streaming. This can be seen
    in a lot of recent web APIs and it can be observed that browser vendors have taken
    notice of how Node.js has gone about utilizing streams.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`fetch`请求的样子，我们应该看一下如何获取底层的可读流。`fetch`系统已经添加了很多功能，其中两个是管道和流。这可以在许多最近的Web
    API中看到，可以观察到浏览器供应商已经注意到了Node.js如何利用流。
- en: Streams, as stated in a previous chapter, are a way of handling chunks of data
    at a time. It also makes sure that we do not have to grab the entire payload at
    once, and instead, we can slowly build up the payload. This means that if we have
    to transform the data, we can do it on the fly as the blocks of data are coming
    in. It also means that we can work on data types that are not common, such as
    JSON and plain text.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所述，流是一种一次处理数据块的方式。它还确保我们不必一次性获取整个有效负载，而是可以逐步构建有效负载。这意味着如果我们需要转换数据，我们可以在数据块到达时即时进行转换。这也意味着我们可以处理不常见的数据类型，比如JSON和纯文本。
- en: 'We will write a basic example of a `TransformStream` that takes our input and
    does a simple ROT13 encoding to it (ROT13 is a very basic encoder that takes the
    thirteenth letter after the one that we get). We will be going into streams in
    much more detail later (these will be the Node.js version, but the concepts are
    relatively similar). The example looks something like the following:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个基本示例，演示`TransformStream`如何对输入进行简单的ROT13编码（ROT13是一种非常基本的编码器，它将我们得到的第13个字母替换原来的字母）。稍后我们将更详细地介绍流（这些将是Node.js版本，但概念相对类似）。示例大致如下：
- en: '[PRE52]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Let's break this example down into the actual `TransformStream` and then the
    code that utilizes it. First, we create a class that is going to house our rotation
    code. We then need a method called `transform` that takes two parameters, the
    chunk, and the controller. The chunk is the data that we are going to get.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个例子分解成实际的`TransformStream`，然后是利用它的代码。首先，我们创建一个类，用于容纳我们的旋转代码。然后，我们需要一个叫做`transform`的方法，它接受两个参数，块和控制器。块是我们将要获取的数据。
- en: Remember that this is not going to get the data all at once so if we needed
    to build objects or the like, we would need to create a possible holding location
    for previous data if the current chunk doesn't give us everything we want. In
    our case, we are simply running a rotation scheme on the underlying bytes so we
    don't need to have a temporary holder.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不会一次性获取所有数据，因此如果我们需要构建对象或类似的东西，我们需要为前面的数据创建一个可能的临时存储位置，如果当前块没有给我们想要的所有内容。在我们的情况下，我们只是在底层字节上运行一个旋转方案，因此我们不需要有一个临时持有者。
- en: Next, the controller is the underlying system for both flow control and for
    stating that the data is either ready to be read from (a Readable or Transform
    stream) or written to (a Writable stream). We next await some data and put it
    in a temporary variable. We then run a simple map expression over each of the
    bytes and rotate them 13 to the right and then mod them by 26.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，控制器是流控制和声明数据是否准备从中读取（一个可读或转换流）或写入（一个可写流）的基础系统。接下来，我们等待一些数据并将其放入一个临时变量中。然后，我们对每个字节运行一个简单的映射表达式，将它们向右旋转13次，然后对26取模。
- en: ASCII convention has all the uppercase characters starting at 65\. This is the
    reason for some of the math involved here as we are trying to get the number between
    0 and 26 first, do the operations, and then move it back into the normal ASCII
    range.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ASCII约定将所有大写字符从65开始。这就是这里涉及一些数学的原因，因为我们试图首先得到0到26之间的数字，进行操作，然后将其移回正常的ASCII范围内。
- en: Once we have rotated our input, we enqueue it on the controller. This means
    that the data is ready to be read from another stream. Next, we can look at the
    series of promises that occur. First, we get our data. We then grab the underlying
    `ReadableStream` from the `fetch` request by grabbing the body of it. We then
    utilize a method called `pipeThrough`. The piping mechanism automatically handles
    flow control for us so it makes our lives easier when working with streams.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们旋转了输入，我们就会将其排队在控制器上。这意味着数据已准备好从另一个流中读取。接下来，我们可以看一系列发生的承诺。首先，我们获取我们的数据。然后，我们通过获取其主体从`fetch`请求中获取底层的`ReadableStream`。然后，我们利用一个叫做`pipeThrough`的方法。管道机制会自动为我们处理流量控制，因此在处理流时会让我们的生活变得更加轻松。
- en: Flow control is vital to making streams work. It essentially tells other streams
    if we are backed up, don't send us any more data, or that we are good to keep
    receiving data. If we did not have this mechanism, we would constantly be having
    to keep our streams in check, which can be a real pain when we just want to focus
    on the logic that we want to incorporate.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 流控制对于使流工作至关重要。它基本上告诉其他流，如果我们被堵住了，就不要再发送数据，或者我们可以继续接收数据。如果没有这种机制，我们将不断地不得不控制我们的流，当我们只想专注于我们想要合并的逻辑时，这可能会是一个真正的痛苦。
- en: We pipe the data into a new `TransformStream` that takes our rotation logic.
    This will now pipe all of the data from the response into our transforming code
    and make sure that it comes out transformed. We then wrap our `ReadableStream`
    in a new `Response` so we can work with it just like any other `Response` object
    from a `fetch` request. We then grab the data as normal text and put it in our
    DOM.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数据传输到一个新的`TransformStream`中，该流采用我们的旋转逻辑。现在，这将把响应中的所有数据传输到我们的转换代码中，并确保它经过转换后输出。然后，我们将我们的`ReadableStream`包装在一个新的`Response`中，这样我们就可以像处理`fetch`请求的任何其他`Response`对象一样处理它。然后，我们像处理普通文本一样获取数据并将其放入我们的DOM中。
- en: As we can see, this example showcases that we can do a lot of cool things with
    the streaming system. While the DOM API is still in flux, these concepts are similar
    to the streaming interface in Node.js. It also showcases how we could possibly
    write decoders for more complicated binary types that may come over the wire such
    as the smile format.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，这个例子展示了我们可以通过流系统做很多很酷的事情。虽然DOM API仍在变化中，但这些概念与Node.js中的流接口类似。它还展示了我们如何可能为更复杂的二进制类型编写解码器，这些类型可能通过网络传输，比如smile格式。
- en: Stopping fetch requests
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止fetch请求
- en: 'One action that we may want to do when making requests is to stop them. This
    could be for a multitude of reasons, such as:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行请求时，我们可能想要执行的一个操作是停止它们。这可能是出于多种原因，比如：
- en: First, if we make a request in the background and we let a user update parameters
    for a `POST` request, we may want to stop the current request and let them make
    the new one.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，如果我们在后台进行请求，并且让用户更新`POST`请求的参数，我们可能希望停止当前请求，并让他们发出新的请求。
- en: Second, a request could be taking too long and we want to make sure that we
    stop the request instead of hanging the application or getting it into an unknown
    state.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，一个请求可能花费太长时间，我们希望确保停止请求，而不是挂起应用程序或使其进入未知状态。
- en: Finally, we may have a caching mechanism that is set up and, once we are done
    caching a large amount of data, we want to use that. If this happens, we want
    to stop any pending requests and have it switch over to that source.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可能有一个设置好的缓存机制，一旦我们完成缓存大量数据，我们希望使用它。如果发生这种情况，我们希望停止任何待处理的请求，并将其切换到该来源。
- en: 'Any of these reasons are great for stopping a request and now we have an API
    that can do this. The `AbortController` system allows us to stop these requests.
    What happens is that `AbortController` has a `signal` property. We attach this
    `signal` to the `fetch` request and when we call the `abort` method, it tells
    the `fetch` request that we do not want it to keep going with the request. It
    is very simple and intuitive. The following is an example:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些原因都是停止请求的好理由，现在我们有一个可以做到这一点的API。`AbortController`系统允许我们停止这些请求。发生的情况是`AbortController`有一个`signal`属性。我们将这个`signal`附加到`fetch`请求上，当我们调用`abort`方法时，它告诉`fetch`请求我们不希望它继续进行请求。这非常简单和直观。以下是一个例子：
- en: '[PRE53]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As we can see, we have set up an `AbortController` system and grabbed its `signal`
    property. We then set up a button that, when clicked, will run the `abort` method.
    Next, we see the typical `fetch` request, but inside the options, we pass the
    `signal`. Now, when we click the button, we will see that the request stops with
    a DOM error. We also see a bit of error handling in terms of `async`/`await`.
    `aysnc`/`await` can utilize basic `try-catch` statements to get to an error, just
    another way that the `async`/`await` API makes the code more readable than both
    the callback and the promise-based versions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，我们已经建立了一个`AbortController`系统并获取了它的`signal`属性。然后我们设置了一个按钮，当点击时，将运行`abort`方法。接下来，我们看到了典型的`fetch`请求，但在选项中，我们传递了`signal`。现在，当我们点击按钮时，我们会看到请求因DOM错误而停止。我们还看到了一些关于`async`/`await`的错误处理。`async`/`await`可以利用基本的`try-catch`语句来捕获错误，这只是`async`/`await`API使代码比回调和基于promise的版本更可读的另一种方式。
- en: This is another API that is experimental and will most likely have changes in
    the future. But, we did have this same type of idea in `XMLHttpRequest` and it
    makes sense that the Fetch API will be getting it also. Just note that the MDN
    website is the best place to get up-to-date information on what browsers support
    and more documentation on any of the experimental APIs that we have discussed
    and will discuss in future chapters.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个实验性的API，将来很可能会有变化。但是，我们在`XMLHttpRequest`中也有了相同类型的想法，因此Fetch API也会得到它是有道理的。请注意，MDN网站是获取有关浏览器支持和任何我们已经讨论过并将在未来章节讨论的实验性API的最新信息的最佳地方。
- en: The `fetch` and promise system is a great way to get data from the server and
    to showcase the new way of handling asynchronous traffic. While we used to have
    to utilize callbacks and some nasty-looking objects, we now have a nice streamlined
    API that is quite easy to use. Even though parts of the API are in flux, just
    note that these systems are most likely going to be in place one way or another.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`fetch`和promise系统是从服务器获取数据并展示处理异步流量的新方式。虽然我们过去必须利用回调和一些看起来很糟糕的对象，但现在我们有了一个非常容易使用的简洁的API。尽管API的部分正在变化，但请注意，这些系统很可能会以某种方式存在。'
- en: Summary
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have seen how much of the browser environment has changed
    over the past 5 years. With new APIs that have enhanced the way we code, through
    to the DOM APIs that have allowed us to write rich UIs with built-in controls,
    we are now able to become as vanilla as possible with our applications. This includes
    the use of fetching external data, along with the new asynchronous APIs such as
    promises and the `async`/`await` system.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了过去5年来浏览器环境发生了多少变化。通过新的API增强了我们编写代码的方式，通过DOM API使我们能够编写具有内置控件的丰富UI，我们现在能够尽可能地使用原生应用。这包括获取外部数据的使用，以及新的异步API，如promises和`async`/`await`系统。
- en: In the next chapter, we will be looking at a library that focuses on outputting
    vanilla JavaScript and giving us a no runtime application environment. We will
    also be incorporating most of the modern APIs into the rest of the book when we
    talk about nodes and workers. Play around with these systems and get comfortable
    with them because we are just getting started.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到一个专注于输出原生JavaScript并为我们提供无运行时应用环境的库。当我们讨论节点和工作线程时，我们还将把大部分现代API整合到本书的其余部分中。玩弄这些系统，并熟悉它们，因为我们才刚刚开始。
