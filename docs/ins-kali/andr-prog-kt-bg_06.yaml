- en: Chapter 6. The Android Lifecycle
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。Android生命周期
- en: In this chapter, we will familiarize ourselves with the lifecycle of an Android
    app. The idea that a computer program has a lifecycle might sound strange at first,
    but it will soon make sense.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将熟悉Android应用程序的生命周期。计算机程序有生命周期这个想法一开始可能听起来很奇怪，但很快就会有意义。
- en: The lifecycle is the way that all Android apps interact with the Android OS.
    In the same way that the lifecycle of humans enables them to interact with the
    world around them, we have no choice but to interact with the Android lifecycle
    and we must be prepared to handle numerous unpredictable events if we want our
    apps to survive.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期是所有Android应用程序与Android操作系统交互的方式。就像人类的生命周期使他们能够与周围的世界互动一样，我们别无选择，只能与Android生命周期互动，并且必须准备处理许多不可预测的事件，如果我们希望我们的应用程序能够生存下来。
- en: We will explore the phases of the lifecycle that an app goes through, from creation
    to destruction, and how this helps us know *where* to put our Kotlin code, depending
    on what we are trying to achieve.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨应用程序从创建到销毁经历的生命周期阶段，以及这如何帮助我们知道*何时*根据我们想要实现的目标放置我们的Kotlin代码。
- en: 'In this chapter, we will explore the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The life and times of an Android app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序的生活和时代
- en: The process of overriding and the `override` keyword
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖过程和`override`关键字
- en: The phases of the Android lifecycle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android生命周期的阶段
- en: What exactly we need to know and do to code our apps
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们究竟需要了解和做些什么来编写我们的应用程序
- en: A lifecycle demonstration app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生命周期演示应用程序
- en: How Android code is structured, and preparation for going deeper into Kotlin
    coding in the next chapter
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android代码的结构，以及为下一章深入学习Kotlin编码做准备
- en: Let's start learning about the Android lifecycle.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习Android生命周期。
- en: The life and times of an Android app
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android应用程序的生活和时代
- en: We have talked a bit about the structure of our code; we know that we can write
    classes, and within those classes we have functions, and these functions contain
    our code, which gets things done. We also know that when we want the code within
    a function to run (that is, be **executed**), we **call** that function by using
    its name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈到了我们代码的结构；我们知道我们可以编写类，在这些类中我们有函数，这些函数包含我们的代码，完成任务。我们也知道当我们想要函数中的代码运行（也就是说，被**执行**）时，我们通过使用它的名称**调用**该函数。
- en: Additionally, in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI Designer"),
    *Kotlin, XML, and the UI Designer*, we learned that Android itself calls the `onCreate`
    function just before the app is ready to start. We saw this when we output to
    the logcat window and used the `Toast` class to send a pop-up message to the user.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在[第2章](ch02.html "第2章。Kotlin、XML和UI设计师")中，*Kotlin、XML和UI设计师*，我们了解到Android在应用程序准备启动之前调用`onCreate`函数。当我们输出到logcat窗口并使用`Toast`类向用户发送弹出消息时，我们就看到了这一点。
- en: In this chapter, we will examine what happens throughout the lifecycle of every
    app that we write; that is, when it starts, ends, and the stages in between. What
    we will see is that Android interacts with our app on numerous occasions each
    time that it is run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究我们编写的每个应用程序的生命周期中发生的事情；也就是说，当它启动、结束和中间阶段。我们将看到的是，每次运行时，Android都会与我们的应用程序进行多次交互。
- en: How Android interacts with our apps
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android如何与我们的应用程序交互
- en: Android interacts with our apps by calling functions that are contained within
    the `Activity` class. Even if the function is not visible within our Kotlin code,
    it is still being called by Android at the appropriate time. If this doesn't appear
    to make any sense, then read on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android通过调用包含在`Activity`类中的函数与我们的应用程序交互。即使该函数在我们的Kotlin代码中不可见，它仍然会在适当的时间被Android调用。如果这看起来毫无意义，那么请继续阅读。
- en: 'Have you ever wondered why the `onCreate` function has the unusual `override`
    keyword just before it? Consider the following line of code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾经想过为什么`onCreate`函数之前有一个不寻常的`override`关键字？考虑以下代码行：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When we override a function such as `onCreate`, we are saying to Android that
    when you call `onCreate`, please use our overridden version because we have some
    code in it that we want to execute.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写`onCreate`等函数时，我们是在告诉Android当你调用`onCreate`时，请使用我们重写的版本，因为我们在其中有一些代码需要执行。
- en: 'Furthermore, you might remember the unusual-looking first line of code in the
    `onCreate` function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可能会记得`onCreate`函数中不寻常的第一行代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is telling Android to call the original version of `onCreate` before proceeding
    with our overridden version.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Android在继续使用我们重写的版本之前调用`onCreate`的原始版本。
- en: There are also many other functions that we can optionally override, and they
    allow us to add our code at appropriate times within the lifecycle of our Android
    app. In the same way that `onCreate` is called just before the app is shown to
    the user, there are also other functions that are called at other times. We haven't
    seen them or overridden them yet, but they are there, they are called, and their
    code executes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他函数，我们可以选择性地重写它们，它们允许我们在Android应用程序的生命周期内的适当时间添加我们的代码。就像`onCreate`在应用程序显示给用户之前被调用一样，还有其他在其他时间被调用的函数。我们还没有看到它们或重写它们，但它们存在，它们被调用，它们的代码被执行。
- en: The reason we need to know and understand the functions of *our* app that Android
    calls whenever it wants is because these functions control the very life and death
    of our code. For instance, what if our app allows the user to type an important
    reminder, then, halfway through typing the reminder, their phone rings, our app
    disappears, and the data (that is, the user's important reminder) is gone?
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解和理解Android在需要时调用的*我们*应用程序的函数，因为这些函数控制着我们代码的生死。例如，如果我们的应用程序允许用户输入重要提醒，然后在输入提醒的一半时，他们的手机响了，我们的应用程序消失了，数据（也就是用户的重要提醒）就消失了？
- en: It is vital and, thankfully, quite straightforward to learn when, why, and which
    functions Android will call as part of the lifecycle of our app. We can then understand
    where we need to override functions to add our own code, and where to add the
    real functionality (code) that defines our app.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 了解我们的应用程序的生命周期何时、为什么以及哪些功能Android将调用是至关重要的，而且幸运的是，这是相当简单的。然后我们可以理解我们需要重写哪些功能来添加我们自己的代码，以及在哪里添加定义我们应用程序的真正功能（代码）。
- en: Let's examine the Android lifecycle. We can then move on to the ins and outs
    of Kotlin and gain an understanding of exactly where to put the code that we write.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来研究一下Android的生命周期。然后我们可以深入了解Kotlin的方方面面，明确我们编写的代码应该放在哪里。
- en: A simplified explanation of the Android lifecycle
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android生命周期的简化解释
- en: If you have ever used an Android device, you have probably noticed that it works
    quite differently to many other operating systems. For example, you can be using
    an app on your device, perhaps checking what people are doing on Facebook.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过Android设备，你可能已经注意到它的工作方式与许多其他操作系统有很大不同。例如，你可以在设备上使用一个应用程序，也许在查看Facebook上的人们在做什么。
- en: Then, you get an email notification and you tap the notification to read it.
    Halfway through reading the email, you might get a Twitter notification and, because
    you are waiting on important news from someone you follow, you interrupt your
    email reading and change apps to Twitter with a touch.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你收到一封电子邮件通知，你点击通知来阅读它。在阅读邮件的过程中，你可能会收到Twitter通知，因为你正在等待某个关注者的重要消息，所以你中断了邮件阅读并触摸屏幕切换到Twitter。
- en: After reading the tweet, you fancy a game of *Angry Birds*; however, halfway
    through the first fling, you suddenly remember the Facebook post. So, you quit
    *Angry Birds* and tap on the Facebook icon.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完推特后，你想玩《愤怒的小鸟》；然而，在第一次射击的一半时，你突然想起了Facebook的帖子。所以，你退出《愤怒的小鸟》并点击Facebook图标。
- en: You will likely resume Facebook at the exact same point that you left it. Afterward,
    you could then go back to reading the email, decide to reply to the tweet, or
    start an entirely new app.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在恢复Facebook时恰好回到离开它的地方。之后，你可以回到阅读邮件，决定回复推特，或者开始一个全新的应用程序。
- en: All this toing and froing takes quite a lot of management on the part of the
    operating system, and is independent from the individual apps themselves.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些来回需要操作系统进行相当多的管理，并且独立于各个应用程序本身。
- en: The difference between, for example, a Windows PC and Android in the context
    of what we have just discussed is notable. With Android, although the user decides
    which app they are using, the OS decides when to close down (or destroy) an application
    and our user's data (such as the hypothetical note) along with it. We need to
    consider this when coding our apps; just because we might write code to do something
    interesting with our user's input doesn't mean that Android will let the code
    execute.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，就我们刚刚讨论的内容而言，Windows PC和Android之间的区别是显著的。在Android中，尽管用户决定使用哪个应用程序，但操作系统决定何时关闭（或销毁）应用程序以及我们用户的数据（例如假设的笔记）。我们在编写应用程序时需要考虑这一点；仅仅因为我们可能编写代码来处理用户的输入并不意味着Android会允许代码执行。
- en: The lifecycle phases demystified
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期阶段的神秘
- en: The Android system has a number of distinct phasesthat any given app can be
    in. Depending upon the phase, the Android system decides how the app is viewed
    by the user, or whether it is viewed at all.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android系统有许多不同的阶段，任何给定的应用程序都可能处于其中之一。根据阶段，Android系统决定用户如何查看应用程序，或者是否根本不查看。
- en: Android has these phases so that it can decide which app is in current use,
    and can then allocate the correct amount of resources, such as memory and processing
    power, to the app.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Android有这些阶段，以便它可以决定哪个应用程序正在使用，并且可以为应用程序分配正确数量的资源，例如内存和处理能力。
- en: In addition, as the user interacts with the device (for example, touches the
    screen), Android must give the details of that interaction to the correct app.
    For instance, a drag-and-release movement in *Angry Birds* means take a shot,
    but in a messaging app, it might mean delete a text message.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当用户与设备进行交互（例如触摸屏幕）时，Android必须将该交互的详细信息传递给正确的应用程序。例如，在《愤怒的小鸟》中进行拖动和释放动作意味着射击，但在消息应用中可能意味着删除短信。
- en: We have already raised the issue of when the user quits our app to answer a
    phone call; will they lose their progress, data, or important note?
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提出了当用户退出我们的应用程序来接听电话时会丢失他们的进度、数据或重要笔记的问题。
- en: 'Android has a system that, when simplified a little for the purposes of explanation,
    means that every app on an Android device is in one of the following phases:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Android有一个系统，简化一下以便解释，意味着Android设备上的每个应用程序都处于以下阶段之一：
- en: Being created
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正在创建
- en: Starting
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始
- en: Resuming
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 恢复
- en: Running
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行
- en: Pausing
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停
- en: Stopping
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止
- en: Being destroyed
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被销毁
- en: This list of phases will hopefully appear logical. As an example, the user presses
    the Facebook app icon and the app is **being created**; then, it is **started**.
    This is all straightforward so far, but the next phase in the list is **resuming**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段列表希望看起来是合乎逻辑的。例如，用户按下Facebook应用程序图标，应用程序正在创建；然后，它被启动。到目前为止，一切都很简单，但列表中的下一个阶段是恢复。
- en: This is not as illogical as it might first appear. If, for a moment, we can
    just accept that the app resumes after it starts, then all will become clear as
    we continue.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像一开始看起来那么不合逻辑。如果我们能暂时接受应用程序在启动后恢复，那么随着我们的继续，一切都会变得清晰起来。
- en: After **resuming,** the app is **running**. This is when the Facebook app has
    control of the screen and has the greater share of system memory and processing
    power, and is receiving the details of the user's input.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在恢复之后，应用程序正在运行。这时，Facebook应用程序控制着屏幕，并且拥有更多的系统内存和处理能力，并且正在接收用户输入的详细信息。
- en: Now, what about our example where we switch from the Facebook app to the email
    app?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们切换从Facebook应用到邮件应用的例子呢？
- en: As we tap to go to read our email, the Facebook app will have entered the **paused**
    phase, followed by the **stopping** phase, and the email app will enter the **being**
    **created** phase, followed by **resuming**, and then **running**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击去阅读我们的电子邮件时，Facebook应用程序将进入**暂停**阶段，然后是**停止**阶段，而电子邮件应用程序将进入**被创建**阶段，然后是**恢复**，然后是**运行**。
- en: If we decide to revisit Facebook, as in the previous scenario, the Facebook
    app will probably skip **being created** and go straight to **resume** and then
    be **running** again (most likely at the exact same place that we left it).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定重新访问Facebook，就像在前面的情景中一样，Facebook应用程序可能会跳过**被创建**直接进入**恢复**，然后再次**运行**（很可能在我们离开它的确切位置）。
- en: Note that at any time, Android can decide to **stop** and then **destroy** an
    app, in which case, when we run the app again, it will need to be **created**
    at the first phase all over again.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，随时，Android都可以决定**停止**然后**销毁**一个应用程序，在这种情况下，当我们再次运行应用程序时，它将需要在第一个阶段**被创建**。
- en: So, had the Facebook app been inactive long enough, or perhaps *Angry Birds*
    had needed so many system resources that Android had **destroyed** the Facebook
    app, then our experience of finding the exact post that we were previously reading
    might have been different. The point is that it is within the control of the app
    and how it interacts with the lifecycle to determine the user's experience.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Facebook应用程序长时间不活动，或者*愤怒的小鸟*需要太多系统资源，以至于Android**销毁**了Facebook应用程序，那么我们之前阅读的确切帖子的体验可能会有所不同。关键是应用程序及其与生命周期的交互控制了用户的体验。
- en: 'If all this is starting to get confusing, then you will be pleased to know
    that the only reason to mention these phases is due to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些开始变得令人困惑，那么你会高兴地知道提到这些阶段的唯一原因是因为以下原因：
- en: You know they exist
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你知道它们存在
- en: We will occasionally need to interact with them
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们偶尔需要与它们交互
- en: We will take things step by step when we do
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们做的时候，我们将一步一步地进行
- en: How we handle the lifecycle phases
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们如何处理生命周期阶段
- en: When we are programming an app, how do we interact with this complexity? The
    good news is that the Android code that was autogenerated when we created our
    first project does most of it for us.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写应用程序时，我们如何与这种复杂性进行交互？好消息是，当我们创建第一个项目时自动生成的Android代码大部分都是为我们做的。
- en: As we have discussed, we just don't see the functions that handle this interaction,
    but we do have the opportunity to override them and add our own code to that phase
    ifwe need to.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所讨论的，我们并不只是看到处理这种交互的函数，但我们有机会覆盖它们并在需要时向该阶段添加我们自己的代码。
- en: This means that we can get on with learning Kotlin and making Android apps until
    we come to one of the occasional instances where we need to do something in one
    of the phases.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以继续学习Kotlin并制作Android应用程序，直到我们遇到偶尔需要在其中一个阶段做一些事情的情况。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If our app has more than one activity, they will each have their own lifecycle.
    This doesn't have to complicate things and, overall, it will make things easier
    for us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用程序有多个活动，它们将各自拥有自己的生命周期。这并不一定会使事情复杂化，总的来说，这将使事情对我们更容易。
- en: The following list offers a quick explanation of the functions provided by Android
    to manage the lifecycle phases. To clarify our discussion of lifecycle functions,
    they are listed next to their corresponding phases that we have been discussing.
    However, as you will see, the function names make it clear on their own where
    they fit in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了Android提供的用于管理生命周期阶段的函数的快速解释。为了澄清我们对生命周期函数的讨论，它们被列在我们一直在讨论的相应阶段旁边。然而，正如你将看到的，函数名称本身清楚地表明了它们在哪里适用。
- en: 'In the list, there is also a brief explanation or suggestion for why we might
    use each function to interact during each phase. We will meet most of these functions
    as we progress through the book; we have, of course, already seen `onCreate`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表中，还有对为什么我们可能在每个阶段使用每个函数进行交互的简要解释或建议。随着我们在书中的进展，我们将遇到大部分这些函数；当然，我们已经见过`onCreate`：
- en: '`onCreate`: This function is executed when the Activity is *being created*.
    Here, we get everything ready for the app, including the UI (such as calling `setContentView`),
    graphics, and sound.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate`：当Activity*被创建*时，将执行此函数。在这里，我们为应用程序准备好一切，包括UI（例如调用`setContentView`）、图形和声音。'
- en: '`onStart`: This function is executed when the app is in the *starting* phase.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart`：当应用程序处于*启动*阶段时，将执行此函数。'
- en: '`onResume`: This function runs after `onStart`, but can also be entered (most
    logically) after our Activity is resuming after being previously paused. We might
    reload the previously saved user data (such as an important note) from when the
    app had been interrupted, perhaps by a phone call or the user running another
    app.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume`：此函数在`onStart`之后运行，但也可以在Activity在先前暂停后恢复时（最合乎逻辑的）进入。我们可能会从应用程序被中断时重新加载先前保存的用户数据（例如重要的笔记），例如通过电话呼叫或用户运行另一个应用程序。'
- en: '`onPause`: This occurs when our app is *pausing*. Here, we might save unsaved
    data (such as the note) that could be reloaded in `onResume`. Activities always
    transition into a paused state when another UI element is displayed on top of
    the current Activity (for example, a pop-up dialog) or when the Activity is about
    to stopped (for example, when the user navigates to a different Activity).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause`：当我们的应用程序*暂停*时会发生这种情况。在这里，我们可能会保存未保存的数据（例如笔记），这些数据可以在`onResume`中重新加载。当另一个UI元素显示在当前Activity的顶部（例如弹出对话框）或Activity即将停止时（例如用户导航到不同的Activity）时，Activity总是转换到暂停状态。'
- en: '`onStop`: This relates to the *stopping* phase. This is where we might undo
    everything we did in `onCreate`, such as releasing system resources or writing
    information to a database. If we reach here, the Activity is probably going to
    get destroyed sometime soon.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop`：这与*停止*阶段有关。这是我们可能会撤消`onCreate`中所做的一切的地方，例如释放系统资源或将信息写入数据库。如果我们到达这里，Activity很可能很快就会被销毁。'
- en: '`onDestroy`: This is when our Activity is finally being *destroyed*. There
    is no turning back at this phase. This is our last chance to dismantle our app
    in an orderly manner. If the Activity reaches this stage, it will need to go through
    the lifecycle phases from the beginning the next time the app is used.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy`：这是当我们的Activity最终被*销毁*时发生的。在这个阶段没有回头路。这是我们有序拆除应用程序的最后机会。如果Activity达到这个阶段，它将需要在下次使用应用程序时从头开始经历生命周期阶段。'
- en: 'The following diagram shows the likely flows of execution between the functions:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了函数之间执行的可能流程：
- en: '![How we handle the lifecycle phases](img/B12806_06_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![我们如何处理生命周期阶段](img/B12806_06_03.jpg)'
- en: 'All the function descriptions and their related phases should appear straightforward.
    The only real question is: what about the running phase? As you will see when
    we write our code in the other functions and phases, the `onCreate`, `onStart`,
    and `onResume` functions will prepare the app, which then persists, forming the
    running phase. Then, the `onPause`, `onStop`, and `onDestroy` functions will occur
    afterward.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数的描述及其相关阶段应该很直接。唯一真正的问题是：关于运行阶段呢？正如当我们在其他函数和阶段中编写代码时所看到的，`onCreate`、`onStart`和`onResume`函数将准备应用程序，然后保持运行阶段。然后，`onPause`、`onStop`和`onDestroy`函数将在此之后发生。
- en: Now we can look at these lifecycle functions in action with a mini-app. We will
    do so by overriding them all and adding a `Log` message and a `Toast` message
    to each. This will visually demonstrate the phases that our app passes through.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过一个迷你应用程序来观察这些生命周期函数的实际运行情况。我们将通过重写它们并为每个函数添加一个`Log`消息和一个`Toast`消息来实现这一点。这将直观地演示我们的应用程序经历的各个阶段。
- en: The lifecycle demo app
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生命周期演示应用程序
- en: In this section, we will do a quick experiment that will help to familiarize
    us with the lifecycle functions that our app uses and give us a chance to play
    around with a bit more Kotlin code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将进行一个快速实验，以帮助我们熟悉应用程序使用的生命周期函数，并让我们有机会玩弄更多的Kotlin代码。
- en: 'Follow these steps to start a new project and then we can add some code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤开始一个新项目，然后我们可以添加一些代码：
- en: Start a new project and choose the **Basic Activity** project template; this
    is because during this project, we will also look at the functions that control
    the app menu and the **Empty Activity** option doesn't generate a menu.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，并选择**Basic Activity**项目模板；这是因为在这个项目中，我们还将研究控制应用程序菜单的函数，而**Empty Activity**选项不会生成菜单。
- en: Call it **Lifecycle Demo**. The code is in the download bundle in the `Chapter06/Lifecycle
    Demo` folder, should you wish to refer to it or copy and paste it.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其命名为**Lifecycle Demo**。代码在下载包的`Chapter06/Lifecycle Demo`文件夹中，如果您希望参考或复制粘贴它。
- en: Keep the other settings as they have been in all our example apps so far.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持其他设置与我们所有示例应用程序中的设置相同。
- en: Wait for Android Studio to generate the project files and then open the `MainActivity.kt`
    file in the code editor (if it is not opened for you by default) by left-clicking
    on the **MainActivity** tab above the editor.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待Android Studio生成项目文件，然后通过在编辑器上方的**MainActivity**标签上单击左键来打开代码编辑器中的`MainActivity.kt`文件（如果默认情况下没有为您打开）。
- en: We will only need the `MainActivity.kt` file for this demonstration as we will
    not be building a UI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们只需要`MainActivity.kt`文件，因为我们不会构建用户界面。
- en: Coding the lifecycle demo app
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写生命周期演示应用程序
- en: 'In the `MainActivity.kt` file, find the `onCreate` function and add two lines
    of code just before the closing curly brace (`}`), which marks the end of the
    `onCreate` function:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.kt`文件中，找到`onCreate`函数，并在闭合大括号（`}`）之前添加两行代码，标志着`onCreate`函数的结束：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Remember that you will need to use the *Alt* + *Enter* keyboard combination
    twice to import the classes needed for `Toast` and `Log`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您需要使用*Alt* + *Enter*键盘组合两次来导入`Toast`和`Log`所需的类。
- en: 'After the closing curly brace (`}`) of the `onCreate` function, leave one clear
    line and add the following five lifecycle functions and their contained code.
    Note that it doesn''t matter in what order we add our overridden functions; Android
    will call them in the correct order, regardless of the order in which we type
    them:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate`函数的闭合大括号（`}`）之后，留出一行空白，并添加以下五个生命周期函数及其包含的代码。请注意，我们添加重写的函数的顺序并不重要；无论我们以何种顺序输入它们，Android都会按正确的顺序调用它们：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, let's talk about the code itself. Notice that the function names all
    correspond to the lifecycle functions and their related phases, which we discussed
    earlier in this chapter. Notice that all the function declarations are preceded
    by the `override` keyword. Also, see that the first line of code inside each function
    is `super.on...`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们谈谈代码本身。请注意，函数名称都对应于我们在本章早些时候讨论过的生命周期函数及其相关阶段。请注意，所有函数声明之前都有`override`关键字。另外，请注意每个函数内的第一行代码是`super.on...`。
- en: 'The following explains exactly what is going on:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下详细解释了正在发生的事情：
- en: Android calls our functions at the various times that we have already discussed.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android在我们已经讨论过的各个时间调用我们的函数。
- en: The `override` keyword shows that these functions replace or override the original
    version of the function that is provided as part of the Android API. Note that
    we don't see these replaced functions, but they are there, and if we didn't override
    them, these original versions will be called by Android instead of ours.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`override`关键字表明这些函数替换或重写了作为Android API的一部分提供的函数的原始版本。请注意，我们看不到这些被替换的函数，但它们存在，如果我们不重写它们，Android将调用这些原始版本而不是我们自己的版本。'
- en: The `super.on...` code, which is the first line of code within each of the overridden
    functions, then calls these original versions. So, we don't simply override these
    original functions in order to add our own code; we also call them, and their
    code is executed too.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super.on...`代码是每个重写函数内的第一行代码，然后调用这些原始版本。因此，我们不仅仅是重写这些原始函数以添加我们自己的代码；我们还调用它们，它们的代码也会被执行。'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For the eager reader, the `super` keyword is for super-class. We will explore
    function overriding and super-classes more as we progress through this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于急切的读者，`super`关键字是用于超类。随着我们在本书中的进展，我们将更多地探讨函数重写和超类。
- en: Finally, the code that you added will make each of the functions output one
    `Toast` message and one `Log` message. However, the messages that are output vary,
    as can be seen with the text that is in between the double speech marks (`""`).
    The messages that are output will make it clear which function produced them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您添加的代码将使每个函数输出一条`Toast`消息和一条`Log`消息。然而，输出的消息会有所不同，可以通过双引号（`""`）之间的文本看出。输出的消息将清楚地表明是哪个函数产生了它们。
- en: Running the lifecycle demo app
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行生命周期演示应用程序
- en: 'Now that we have looked at the code, we can play with our app and learn about
    the lifecycle from what happens:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了代码，我们可以玩玩我们的应用程序，并从发生的事情中了解生命周期：
- en: Run the app on either a device or an emulator.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: 'Watch the screen of the emulator and you will see the following appear one
    after the other as `Toast` messages: **In onCreate**, **In onStart**, and **In
    onResume**.'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察模拟器的屏幕，您将看到以下内容依次出现为`Toast`消息：**在onCreate**，**在onStart**和**在onResume**。
- en: 'Notice the following messages in the logcat window; if there are too many messages,
    remember that you can filter them by setting the **Log level** dropdown to **Info**:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意logcat窗口中的以下消息；如果有太多消息，请记住可以通过将**日志级别**下拉菜单设置为**信息**来过滤它们：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now tap the back button on the emulator or the device. Notice that you get
    the following three `Toast` messages in this exact order: **In onPause**, **In
    onStop**, and **In onDestroy**. Verify that we have matching output in the logcat
    window.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在模拟器或设备上点击返回按钮。注意，您会按照以下确切顺序收到以下三条`Toast`消息：**在onPause**，**在onStop**和**在onDestroy**。验证我们在logcat窗口中是否有匹配的输出。
- en: Next, run a different app. Perhaps run the Hello World app from [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Android and Kotlin"), *Getting Started with Android
    and Kotlin* (but any app will do), by tapping its icon on the emulator or device
    screen.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，运行另一个应用程序。也许可以运行[第1章](ch01.html "第1章。使用Android和Kotlin入门")中的Hello World应用程序，*使用Android和Kotlin入门*（但任何应用程序都可以），通过在模拟器或设备屏幕上点击其图标来运行。
- en: Now try opening the task manager on the emulator.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试在模拟器上打开任务管理器。
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can refer to [Chapter 3](ch03.html "Chapter 3. Exploring Android Studio
    and the Project Structure"), *Exploring Android Studio and the Project Structure*,
    and the Using the emulator as a real device section for how to do this on the
    emulator if you are unsure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定如何在模拟器上执行此操作，可以参考[第3章](ch03.html "第3章。探索Android Studio和项目结构")中的内容，*探索Android
    Studio和项目结构*，以及在模拟器上使用真实设备部分。
- en: You should now see all the recently run apps on the device.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在您应该能够在设备上看到最近运行的所有应用程序。
- en: Tap on the lifecycle demo app and notice that the usual three starting messages
    are shown; this is because our app was previously destroyed.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生命周期演示应用程序，注意通常的三条启动消息会显示；这是因为我们的应用程序以前被销毁。
- en: Now tap the task manager button again and switch to the Hello Worldapp. Notice
    that this time, only the **In onPause** and **In onStop** messages are shown.
    Verify that we have matching output in the logcat window; this should tell us
    that the app has **not** been destroyed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在再次点击任务管理器按钮，切换到Hello World应用程序。注意，这一次只显示**在onPause**和**在onStop**消息。验证我们在logcat窗口中是否有匹配的输出；这应该告诉我们应用程序**没有**被销毁。
- en: Now, again using the task manager button, switch to the lifecycle demo app.
    You will see that only the **In onStart** and **In onResume** messages are shown,
    indicating that `onCreate` was not required to get the app running again. This
    is as expected because the app was not previously destroyed, but merely stopped.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次使用任务管理器按钮，切换到生命周期演示应用程序。您会看到只显示**在onStart**和**在onResume**消息，表明不需要`onCreate`就可以再次运行应用程序。这是预期的，因为应用程序以前并没有被销毁，而只是停止了。
- en: Next, let's talk about what we saw when we ran the app.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们谈谈我们运行应用程序时看到的情况。
- en: Examining the lifecycle demo app output
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查生命周期演示应用程序的输出
- en: When we started the lifecycle demo app for the first time, we saw that the `onCreate`,
    `onStart`, and `onResume` functions were called. Then, when we closed the app
    using the back button, the `onPause`, `onStop`, and `onDestroy` functions were
    called.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次启动生命周期演示应用程序时，我们看到调用了`onCreate`，`onStart`和`onResume`函数。然后，当我们使用返回按钮关闭应用程序时，调用了`onPause`，`onStop`和`onDestroy`函数。
- en: Furthermore, we know from our code that the original versions of all these functions
    are also called because we are calling them ourselves with the `super.on...` code,
    which is the first thing we do in each of our overridden functions.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们从我们的代码中知道，所有这些函数的原始版本也被调用，因为我们在每个重写的函数中首先使用`super.on...`代码调用它们。
- en: The quirk in our app's behavior came when we used the task manager to switch
    between apps and, when switching away from the lifecycle demo app, it was not
    destroyed and, subsequently, when switching back, it was not necessary to run
    `onCreate`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序行为的怪癖出现在我们使用任务管理器在应用程序之间切换时，当从生命周期演示应用程序切换时，它并没有被销毁，因此当再次切换回来时，不需要运行`onCreate`。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Where''s my Toast?**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**我的Toast在哪里？**'
- en: The opening three and closing three `Toast` messages are queued by the operating
    system and the functions have already completed by the time they are shown. You
    can verify this by running the experiments again and see that all three starting
    and closing log messages are output before the second `Toast` message is even
    shown. However, the `Toast` messages do reinforce our knowledge about the order,
    if not the timing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 开头的三条和结尾的三条`Toast`消息由操作系统排队，并且函数在它们显示时已经完成。您可以通过再次运行实验来验证这一点，并看到所有三条启动和关闭日志消息在第二条`Toast`消息甚至显示之前就已经输出。然而，`Toast`消息确实加强了我们对顺序的了解，尽管不是时间上的了解。
- en: It is entirely possible (but not that likely) that you got slightly different
    results when you followed the preceding steps. What is for sure is that when our
    apps are run on thousands of different devices by millions of different users
    who have different preferences for interacting with their devices, Android will
    be calling the lifecycle functions at unpredictable times.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按照前面的步骤进行操作时，可能会得到略有不同的结果。可以肯定的是，当我们的应用在成千上万台不同的设备上由数百万不同的用户运行时，这些用户对与其设备交互的偏好也不同，Android将在不可预测的时间调用生命周期函数。
- en: For example, what happens when the user exits the app by pressing the home button?
    If we open two apps one after the other, and then use the back button to switch
    to the earlier app, will that destroy or just stop the app? What happens when
    the user has a dozen apps in their task manager and the operating system needs
    to destroy some apps that were previously only stopped; will our app be one of
    the victims?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当用户通过按下主页按钮退出应用程序时会发生什么？如果我们依次打开两个应用程序，然后使用返回按钮切换到先前的应用程序，那会销毁还是只是停止应用程序？当用户在其任务管理器中有数十个应用程序，并且操作系统需要销毁一些先前仅停止的应用程序时，我们的应用程序会成为受害者吗？
- en: You can, of course, test out all the preceding scenarios on the emulator. But
    the results will only be true for the one time you test it. It is not guaranteed
    that the same behavior will be exhibited every time, and certainly not on every
    different Android device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以在模拟器上测试所有前面的场景。但结果只对您测试的一次有效。不能保证每次都会表现出相同的行为，当然也不会在每个不同的Android设备上表现出相同的行为。
- en: 'At last, there is some good news; the solution to all of this complexity is
    to follow a few simple rules:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一些好消息；解决所有这些复杂性的方法是遵循一些简单的规则：
- en: Set up your app so that it is ready to run in the `onCreate` function.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置您的应用程序，以便在`onCreate`函数中准备运行。
- en: Load your user's data in the `onResume` function.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onResume`函数中加载用户的数据。
- en: Save your user's data in the `onPause` function.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onPause`函数中保存用户的数据。
- en: Tidy up your app and make it a good Android citizen in the `onDestroy` function.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`onDestroy`函数中整理您的应用程序，并使其成为一个良好的Android公民。
- en: Watch out for a couple of occasions in this book where we might like to use
    `onStart` and `onStop`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本书中，有几个场合我们可能想要使用`onStart`和`onStop`，要注意一下。
- en: If we follow the preceding rules, we will see that, over the course of the book,
    we can simply stop worrying about the lifecycle and let Android handle it.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们遵循前面的规则，我们会发现，在本书的过程中，我们可以简单地不再担心生命周期，让Android来处理它。
- en: There are a few more functions that we can override as well; so, let's take
    a look at them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他函数我们也可以重写；所以，让我们来看看它们。
- en: Some other overridden functions
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些其他重写的函数
- en: You may have noticed that there are two other autogenerated functions in the
    code of all our projects using the Basic Activity template. They are `onCreateOptionsMenu`
    and `onOptionsItemSelected`. Many Android apps have a pop-up menu, so Android
    Studio generates one by default when using the Basic Activity template, including
    the outline of the code to make it work.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，在使用基本活动模板的所有项目代码中，还有另外两个自动生成的函数。它们是`onCreateOptionsMenu`和`onOptionsItemSelected`。许多Android应用程序都有弹出菜单，因此在使用基本活动模板时，Android
    Studio会默认生成一个，包括使其工作的代码概述。
- en: 'You can see the XML that describes the menu in `res/menu/menu_main.xml` from
    the project explorer. The key lines of XML code are as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在项目资源管理器中的`res/menu/menu_main.xml`中查看描述菜单的XML。XML代码的关键行如下：
- en: '[PRE5]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This describes a menu **item** with the **Settings** text. If you run any of
    our apps built with the Basic Activity template, you will see the button as shown
    in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这描述了一个带有**设置**文本的菜单**项**。如果您运行使用基本活动模板构建的任何应用程序，您将会看到如下截图中所示的按钮：
- en: '![Some other overridden functions](img/B12806_06_01.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![一些其他重写的函数](img/B12806_06_01.jpg)'
- en: 'If you tap the button, you can see it in action as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击按钮，您可以看到它的操作如下：
- en: '![Some other overridden functions](img/B12806_06_02.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![一些其他重写的函数](img/B12806_06_02.jpg)'
- en: So, how do the `onCreateOptionsMenu` and `onOptionsItemSelected` functions produce
    these results?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，`onCreateOptionsMenu`和`onOptionsItemSelected`函数是如何产生这些结果的呢？
- en: 'The `onCreateOptionsMenu` function loads the menu from the `menu_main.xml`
    file with this line of code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`onCreateOptionsMenu`函数使用以下代码行从`menu_main.xml`文件加载菜单：'
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is called by the default version of the `onCreate` function, which is why
    we don't see it happen.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它是由`onCreate`函数的默认版本调用的，这就是为什么我们没有看到它发生。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will use the pop-up menu in [Chapter 17](ch17.html "Chapter 17. Data Persistence
    and Sharing"), *Data Persistence and Sharing*, to switch between the different
    screens of our app.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第17章](ch17.html "第17章。数据持久性和共享")中使用弹出菜单，*数据持久性和共享*，在我们的应用程序的不同屏幕之间进行切换。
- en: The `onOptionsItemSelected` function is called when the user taps on the menu
    button. This function handles what will happen when an item is selected. Now,
    nothing happens; it just returns `true`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击菜单按钮时，将调用`onOptionsItemSelected`函数。该函数处理当项目被选中时会发生什么。现在，什么都不会发生；它只是返回`true`。
- en: Feel free to add `Toast` and `Log` messages to these functions to test out the
    order and timing I have just described.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 随意向这些函数添加`Toast`和`Log`消息，以测试我刚刚描述的顺序和时间。
- en: Now that we have seen how the Android lifecycle works and have been introduced
    to a number of overridable functions to interact with this lifecycle, we had better
    learn the fundamentals of Kotlin so that we can write some more useful code to
    go in these functions and write our own functions too.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Android生命周期的工作原理，并且已经介绍了一些可重写的函数来与这个生命周期进行交互，我们最好学习一下Kotlin的基础知识，这样我们就可以编写一些更有用的代码放入这些函数中，并且编写我们自己的函数。
- en: The structure of Kotlin code – revisited
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin代码的结构-重新访问
- en: We have already seen that each time we create a new Android project, we also
    create a new **package**; this is a kind of container for the code that we write.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，每次创建新的Android项目时，我们也会创建一个新的**包**；这是我们编写的代码的一种容器。
- en: 'We have also learned about and played around with **classes**. We have imported
    and taken direct advantage of classes from the Android API, such as `Log` and
    `Toast`. We have also used the `AppCompatActivity` class but in a different manner
    to that of `Log` and `Toast`. You might recall that the first line of code in
    all our projects so far, after the `import` statements, used the `:` notation
    to inherit from a class:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了并玩耍了**类**。我们已经从Android API中导入并直接利用了类，比如`Log`和`Toast`。我们还使用了`AppCompatActivity`类，但方式与`Log`和`Toast`不同。你可能还记得，到目前为止我们所有项目的第一行代码，在`import`语句之后，使用了`:`符号来继承一个类：
- en: '[PRE7]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we inherit from a class, as opposed to just importing it, we are making
    it our own. In fact, if you take another look at the line of code, you can see
    that we are making a new class, with a new name, `MainActivity`, but basing it
    on the `AppCompatActivity` class from the Android API.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们继承一个类时，与仅仅导入它不同，我们正在使它成为我们自己的。事实上，如果你再看一下代码行，你会看到我们正在创建一个新的类，用一个新的名字`MainActivity`，但是基于Android
    API中的`AppCompatActivity`类。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`AppCompatActivity` is a modified version of `Activity`. It gives extra features
    for older versions of Android that would otherwise not be present. Everything
    we have discussed about `Activity`, such as the lifecycle, is equally true for
    `AppCompatActivity`. If the name ends in `...Activity`, it doesn''t matter because
    everything we have discussed and will discuss is equally true. I will usually
    just refer to this class simply as `Activity`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppCompatActivity`是`Activity`的修改版本。它为较旧版本的Android提供了额外的功能，否则这些功能将不存在。关于`Activity`的所有讨论，比如生命周期，同样适用于`AppCompatActivity`。如果名称以`...Activity`结尾，也没关系，因为我们讨论过的和将要讨论的一切同样适用。我通常会简单地将这个类称为`Activity`。'
- en: 'We can summarize our use of classes as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以总结我们对类的使用如下：
- en: We can import classes to use them
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以导入类来使用它们
- en: We can inherit from classes to use them and to extend their functionality
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以继承类来使用它们并扩展它们的功能
- en: We can eventually make our own classes (and will do so soon)
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们最终可以制作自己的类（并且很快会这样做）
- en: Our own classes, and those that are written by others, are the building blocks
    of our code, and the functions within the classes wrap the functional code – that
    is, the code that does the work.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的类，以及其他人编写的类，都是我们代码的构建模块，类中的函数包装了功能代码 - 也就是执行工作的代码。
- en: We can write functions within the classes that we extend as we did with `topClick`
    and `bottomClick` in [Chapter 2](ch02.html "Chapter 2. Kotlin, XML, and the UI
    Designer"), *Kotlin, XML, and the UI Designer*. Furthermore, we overrode functions
    that are already part of classes written by others, such as `onCreate` and `onPause`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在扩展的类中编写函数，就像我们在[第2章](ch02.html "第2章。Kotlin，XML和UI设计师")中所做的`topClick`和`bottomClick`一样，*Kotlin，XML和UI设计师*。此外，我们重写了其他人编写的类中已经存在的函数，比如`onCreate`和`onPause`。
- en: The only code, however, that we put in these functions was a few calls using
    `Toast` and `Log`. Now we are ready to take some more steps with Kotlin.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这些函数中放入的唯一代码是使用`Toast`和`Log`进行了几次调用。现在我们准备用Kotlin迈出更多的步伐。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned that it is not only us that can call our code;
    the operating system can also call the code contained within the functions that
    we have overridden. By adding the appropriate code to the various overridden lifecycle
    functions, we can be sure that the right code will be executed at the right time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了不仅我们可以调用我们的代码；操作系统也可以调用我们重写的函数中包含的代码。通过向各种重写的生命周期函数添加适当的代码，我们可以确保在正确的时间执行正确的代码。
- en: What we need to do now is to learn how to write some more Kotlin code. In the
    next chapter, we will start to focus on Kotlin and, because we have such a good
    grounding already in Android, we will have no problem practicing and using everything
    we learn.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的是学习如何编写更多的Kotlin代码。在下一章中，我们将开始专注于Kotlin，并且因为我们已经在Android上有了很好的基础，所以练习和使用我们学到的一切都不会有问题。
