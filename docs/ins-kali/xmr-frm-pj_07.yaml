- en: Building a Real-Time Chat Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建实时聊天应用程序
- en: In this chapter, we will build a chat app with real-time communication. In the
    app, you will be able to send and receive messages and photos to and from other
    users, which will appear without the page needing to be refreshed. We will look
    at how we can use SignalR to implement a real-time connection with the server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个具有实时通信的聊天应用程序。在该应用程序中，您将能够向其他用户发送和接收消息和照片，而无需刷新页面即可看到消息。我们将看看如何使用SignalR实现与服务器的实时连接。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How to use SignalR in a Xamarin.Forms app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Xamarin.Forms应用程序中使用SignalR
- en: How to use template selectors for a ListView
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何为ListView使用模板选择器
- en: How to use CSS-styling in a Xamarin.Forms app
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在Xamarin.Forms应用程序中使用CSS样式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before you can build the app for this project, you need to build the backend
    that we detailed in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)*, Setting
    up a Backend for a Chat App Using Azure Services*. You will also need to have
    Visual Studio for Mac or PC installed, as well as the Xamarin components. See [Chapter
    1](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml), *Introduction to Xamarin*, for
    more details on how to set up your environment. The source code for this chapter
    is available in the GitHub repository, which is available at [https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建此项目的应用程序之前，您需要构建我们在[第6章](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)*，使用Azure服务为聊天应用程序设置后端*中详细说明的后端。您还需要安装Visual
    Studio for Mac或PC，以及Xamarin组件。有关如何设置环境的更多详细信息，请参阅[第1章](80b2455c-7174-4e4b-b2eb-916d03b9d3f6.xhtml)，*Xamarin简介*。本章的源代码可在GitHub存储库中找到，网址为[https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7](https://github.com/PacktPublishing/Xamarin.Forms-Projects/tree/master/Chapter-6-and-7)。
- en: Project overview
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: When building a chat app, it is really important to have real-time communication
    because the user expects messages to arrive more or less immediately. To achieve
    this, we will use SignalR, which is a library for real-time communication. SignalR
    will use WebSockets if they are available and, if not, it will have several fallback
    options it can use instead. In the app, a user will be able to send text and photos
    from the photo library on the device.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建聊天应用程序时，实时通信非常重要，因为用户期望消息能够几乎立即到达。为了实现这一点，我们将使用SignalR，这是一个用于实时通信的库。SignalR将使用WebSockets（如果可用），如果不可用，它将有几种备用选项可以使用。在该应用程序中，用户将能够从设备的照片库发送文本和照片。
- en: The build time for this project is about 180 minutes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的构建时间约为180分钟。
- en: Getting started
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: We can use either Visual Studio 2017 on a PC or Visual Studio for Mac to do
    this project. To build an iOS app using Visual Studio for PC, you have to have
    a Mac connected. If you don't have a access to a Mac at all, you can choose to
    just build the Android part of the app.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用PC上的Visual Studio 2017或Mac上的Visual Studio来完成此项目。要使用Visual Studio在PC上构建iOS应用程序，您必须连接Mac。如果根本没有Mac，您可以选择仅构建应用程序的Android部分。
- en: Building the chat app
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建聊天应用程序
- en: 'It''s time to start building the app. We recommend that you use the same method
    as in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting up a Backend
    for a Chat App Using Azure Services*, because this will make code sharing easier.
    In that solution, create a Mobile App (Xamarin.Forms) with the name `Chat`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始构建应用程序了。我们建议您使用与[第6章](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)相同的方法，*使用Azure服务为聊天应用程序设置后端*，因为这将使代码共享更容易。在该解决方案中，创建一个名为`Chat`的移动应用程序（Xamarin.Forms）：
- en: '![](img/36568c5f-b137-44c0-bc52-0e4248b43864.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![](img/36568c5f-b137-44c0-bc52-0e4248b43864.png)'
- en: 'Select the Blank template and use .NET Standard as the Code Sharing Strategy. Select iOS
    and Android as the platforms. After we have created the project, we will update
    all NuGet packages to the latest versions because the project templates are not
    updated as often as the packages that are used inside the templates:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 选择空白模板，并将.NET Standard作为代码共享策略。选择iOS和Android作为平台。创建项目后，我们将更新所有NuGet包到最新版本，因为项目模板的更新频率不如模板内部使用的包频繁：
- en: '![](img/0e6b50ff-8208-4344-b14e-bd0666082aca.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e6b50ff-8208-4344-b14e-bd0666082aca.png)'
- en: Creating the chat service
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建聊天服务
- en: 'The first thing we will do is create a chat service that will be used by both
    the iOS and Android applications. To make the code more testable and to make it
    easier to replace the chat service if we want to use another provider in the future,
    we will follow these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个聊天服务，该服务将被iOS和Android应用程序共同使用。为了使代码更易于测试，并且在将来想要使用其他提供程序替换聊天服务更容易，我们将按照以下步骤进行：
- en: In the `Chat` project, add a reference to the `Chat.Messages` project.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中，添加对`Chat.Messages`项目的引用。
- en: Create a new folder in the `Chat` project called `Services`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中创建一个名为`Services`的新文件夹。
- en: Create a new interface called `IChatService` in the `Services` folder.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中创建一个名为`IChatService`的新接口。
- en: Create a `bool` property called `IsConnected`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`IsConnected`的`bool`属性。
- en: Create a method called `SendMessage`that takes `Message` as an argument and returns `Task`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`SendMessage`的方法，该方法以`Message`作为参数并返回`Task`。
- en: Create a method called `CreateConnection` that returns `Task`. The method will
    create and start a connection to the SignalR service.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CreateConnection`的方法，返回`Task`。该方法将创建并启动与SignalR服务的连接。
- en: 'Create a method called `Dispose` that returns` Task`. The method will be used
    when the app goes to sleep to ensure that the connection to the SignalR service
    is properly closed:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Dispose`的方法，返回`Task`。当应用程序进入休眠状态时，将使用该方法来确保与SignalR服务的连接被正确关闭：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The interface will also contain an event, but before we add the event to the
    interface, we will create an `EventArgs` class that the event will use. We will
    do this as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口还将包含一个事件，但在将事件添加到接口之前，我们将创建一个`EventArgs`类，该事件将使用。我们将按照以下步骤进行：
- en: In the `Chat` project, create a new folder called `Events`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中，创建一个名为`Events`的新文件夹。
- en: Create a new class called `NewMessageEventArgs` in the `Events` folder.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Events`文件夹中创建一个名为`NewMessageEventArgs`的新类。
- en: Add `EventArgs` as a base class.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`EventArgs`添加为基类。
- en: Create a property called `Message` of the `Message` type with a public getter
    and a private setter.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Message`的`Message`类型的属性，具有公共getter和私有setter。
- en: Create an empty constructor.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的构造函数。
- en: Create a constructor with `Message` as a parameter.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个带有`Message`参数的构造函数。
- en: Set the parameter of the constructor to the `Message` property.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数的参数设置为`Message`属性。
- en: 'The following code is the result of these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是这些步骤的结果：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we have created a new `EventArgs` class, we can use it and add an
    event to the interface. We will name the event `NewMessage`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了一个新的`EventArgs`类，我们可以使用它并在接口中添加一个事件。我们将事件命名为`NewMessage`：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first thing we will do in the service is to make a call to the `GetSignalRInfo`
    service that we created in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting
    up a Backend for a Chat App Using Azure Services*, to obtain information about
    how to connect to the SignalR service. To serialize that information, we will
    create a new class:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务中，我们将首先调用`GetSignalRInfo`服务，该服务是我们在[第6章](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)中创建的，*使用Azure服务为聊天应用程序设置后端*，以获取有关如何连接到SignalR服务的信息。为了序列化该信息，我们将创建一个新类：
- en: In the `Chat` project, create a new folder called `Models`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中，创建一个名为`Models`的新文件夹。
- en: Create a new class called `ConnectionInfo`.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ConnectionInfo`的新类。
- en: Add a string property called `Url` for the `string`.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`string`添加一个名为`Url`的字符串属性。
- en: 'Add a string property called `AccessToken` for the `string`:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`string`添加一个名为`AccessToken`的字符串属性：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have the interface and a model to obtain the connection information,
    it is time to create an implementation of the `IChatService` interface. To use
    SignalR, we need to add a package for NuGet that will give us the necessary classes.
    Follow these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了接口和一个用于获取连接信息的模型，是时候创建`IChatService`接口的实现了。要使用SignalR，我们需要添加一个NuGet包，它将为我们提供必要的类。请按照以下步骤操作：
- en: In the `Chat` project, install the NuGet package, `Microsoft.AspNetCore.SignalR.Client`.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中，安装NuGet包`Microsoft.AspNetCore.SignalR.Client`。
- en: In the `Services` folder, create a new class called `ChatService`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Services`文件夹中，创建一个名为`ChatService`的新类。
- en: Add and implement the `IChatService` interface to the `ChatService`.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IChatService`接口添加并实现到`ChatService`中。
- en: Add a private field for `HttpClient` called `httpClient`.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`HttpClient`添加一个名为`httpClient`的私有字段。
- en: Add a private field for `HubConnection` called `hub`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`HubConnection`添加一个名为`hub`的私有字段。
- en: 'Add a private field for `SemaphoreSlim` called `semaphoreSlim` and create a
    new instance with an initial and maximum count of one in the constructor:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`SemaphoreSlim`添加一个名为`semaphoreSlim`的私有字段，并在构造函数中使用初始计数和最大计数为1创建一个新实例：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We will start with the `CreateConnection`, which will call the `GetSignalRInfo`
    function. We will then use the information to connect to the SignalR service and
    start listening for messages. To do this, carry out the following steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`CreateConnection`开始，它将调用`GetSignalRInfo`函数。然后我们将使用这些信息连接到SignalR服务并开始监听消息。为此，请执行以下步骤：
- en: Add a call to the `WaitAsync` method of `SemaphoreSlim` to make sure that only
    one thread can use the method at any one time.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`SemaphoreSlim`的`WaitAsync`方法，以确保一次只有一个线程可以使用该方法。
- en: Check weather `httpClient` is `null`. If it is, create a new instance. We will
    reuse the instance of the `httpClient` because this is better from a performance
    perspective.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`httpClient`是否为`null`。如果是，创建一个新实例。我们将重用`httpClient`的实例，因为从性能的角度来看这样做更好。
- en: 'Make a call to `GetSignalRInfo` and serialize the result to a `ConnectionInfo`
    object:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`GetSignalRInfo`并将结果序列化为`ConnectionInfo`对象：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we have the information about how to connect to the SignalR service, we
    can use the `HubConnectionBuilder` to create a connection. We can then start listening
    for messages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有关于如何连接到SignalR服务的信息时，我们可以使用`HubConnectionBuilder`来创建一个连接。然后我们可以开始监听消息：
- en: Create a new `HubConnectionBuilder`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`HubConnectionBuilder`。
- en: Use the `WithUrl` method to specify the URL to the SignalR service as the first
    argument. The second argument is an `Action` of the `HttpConnectionObject` type.
    This means that you will get an object of the `HttpConnectionObject` type as a
    parameter.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`WithUrl`方法指定SignalR服务的URL作为第一个参数。第二个参数是`HttpConnectionObject`类型的`Action`。这意味着您将获得一个`HttpConnectionObject`类型的对象作为参数。
- en: In the action, set `AccessTokenProvider` to a `Func` that returns the value
    of the `AccessToken` property on the `ConnectionInfo` object.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在操作中，将`AccessTokenProvider`设置为一个返回`ConnectionInfo`对象上`AccessToken`属性值的`Func`。
- en: Use the `Build` method of the `HubConnectionBuilder` to create a connection
    object.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`HubConnectionBuilder`的`Build`方法创建一个连接对象。
- en: Add an `Action` that will run when new messages arrive using the `On<object>`
    method on the `HubConnection` object. The action will be specified as the second
    argument. For the first argument, we will specify the name of the target (we specified
    the target in [Chapter 6](a652292c-994d-4788-ad47-7a8deba3230c.xhtml), *Setting
    up a Backend for a Chat App Using Azure Services*, when we sent the message),
    which is `newMessage`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`HubConnection`对象上的`On<object>`方法添加一个在新消息到达时运行的`Action`。将该操作指定为第二个参数。对于第一个参数，我们将指定目标的名称（在[第6章](a652292c-994d-4788-ad47-7a8deba3230c.xhtml)中指定了目标，*使用Azure服务为聊天应用程序设置后端*，当我们发送消息时），即`newMessage`。
- en: In the `Action`, convert the incoming message to a string using the `ToString`
    method and deserialize it to a `Message` object so we can read its `TypeInfo`
    property. To do this, use the `JsonConvert` class and the `DeserializeObject<Message>`
    method.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Action`中，使用`ToString`方法将传入的消息转换为字符串，并将其反序列化为`Message`对象，以便读取其`TypeInfo`属性。为此，使用`JsonConvert`类和`DeserializeObject<Message>`方法。
- en: The reason we have to deserialize the object twice is that we only get the value
    of properties in the `Message` class the first time. When we know which subclass
    of `Message` we received, we can use this to deserialize that information for
    that class. We are casting it to `Message` so we can pass it to the `NewMessageEventArgs` object.
    In this case, we will not lose the properties of the subclass. To access the properties,
    we just cast the class back to the subclass.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须两次反序列化对象的原因是，第一次我们只能得到`Message`类中属性的值。当我们知道我们收到的`Message`的哪个子类时，我们可以使用这个来为该类反序列化信息。我们将其转换为`Message`，以便将其传递给`NewMessageEventArgs`对象。在这种情况下，我们不会丢失子类的属性。要访问属性，我们只需将类转换回子类。
- en: When we know what type the message is, we can use this to deserialize the object
    to the actual type. Use the `DeserializeObject` method of `JsonConvert` and pass
    the JSON string and the `TypeInfo` to it and then cast it to `Message`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们知道消息的类型时，我们可以使用这个来将对象反序列化为实际类型。使用`JsonConvert`的`DeserializeObject`方法，并将JSON字符串和`TypeInfo`传递给它，然后将其转换为`Message`。
- en: Invoke the `NewMessage` event and pass the current instance of the `ChatService` and
    a new `NewMessageEventArgs` object to it. Pass the `Message` object to the constructor
    of `NewMessageEventArgs`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`NewMessage`事件，并将`ChatService`的当前实例和一个新的`NewMessageEventArgs`对象传递给它。将`Message`对象传递给`NewMessageEventArgs`的构造函数。
- en: Once we have a connection object and we have configured what will happen when
    a message arrives, we will start to listen to messages with the `StartAsync` method
    of the `HubConnection`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了连接对象，并且配置了消息到达时会发生什么，我们将开始使用`HubConnection`的`StartAsync`方法来监听消息。
- en: Set the `IsConnected` property to `true`.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsConnected`属性设置为`true`。
- en: 'Use the `Release` method of `SemaphoreSlim` to let other threads go to the
    `CreateConnection` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SemaphoreSlim`的`Release`方法让其他线程进入`CreateConnection`方法：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next method to implement is the `SendMessage` method. This will send a
    message to an Azure function, which will add the message to the SignalR service:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的下一个方法是`SendMessage`方法。这将向Azure函数发送消息，该函数将将消息添加到SignalR服务：
- en: Use the `Serialize` method on the `JsonConvert` class to serialize the `Message`
    object to JSON.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`JsonConvert`类的`Serialize`方法将`Message`对象序列化为JSON。
- en: Create a `StringContent` object and pass the JSON string as the first argument,
    `Encoding.UTF8` as the second argument, and the content-type `application/json`
    as the last argument to the constructor.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`StringContent`对象，并将JSON字符串作为第一个参数，`Encoding.UTF8`作为第二个参数，内容类型`application/json`作为最后一个参数传递给构造函数。
- en: 'Use the `PostAsync` method on the `HttpClient` object with the URL as the first
    argument and the `StringContent` object as the second argument to post the message
    to the function:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`HttpClient`对象的`PostAsync`方法，将URL作为第一个参数，`StringContent`对象作为第二个参数，将消息发布到函数：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last method to implement is the `Dispose` method. This will close the connection
    when the app is entering the background state, for example when a user hits the
    home button or switches app:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的最后一个方法是`Dispose`方法。这将在应用程序进入后台状态时关闭连接，例如当用户按下主页按钮或切换应用程序时：
- en: Use the `WaitAsync` method to ensure that there is no thread that is trying
    to create a connection or to dispose of a connection when we are running the method.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`WaitAsync`方法确保在运行该方法时没有线程尝试创建连接或释放连接。
- en: Add an `if` statement to ensure that the hub field isn't `null`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`if`语句，以确保`hub`字段不为`null`。
- en: If it is not null, call the `StopAsync` method and the `DisposeAsync` method
    of the `HubConnection`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不为空，调用`HubConnection`的`StopAsync`方法和`DisposeAsync`方法。
- en: Set the `httpClient` field to `null`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`httpClient`字段设置为`null`。
- en: Set `IsConnected` to `false`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`IsConnected`设置为`false`。
- en: 'Release `SemaphoreSlim`with the `Release` method:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Release`方法释放`SemaphoreSlim`：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Initializing the app
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化应用程序
- en: We are now ready to write the initialization code for the app. We will set up
    **Inversion-of-Control** (**IoC**) and carry out the necessary configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备为应用程序编写初始化代码。我们将设置**控制反转**（**IoC**）并进行必要的配置。
- en: Creating a resolver
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个解析器
- en: 'We will create a helper class that will ease the process of resolving object
    graphs through Autofac. This will help us to create types based on a configured
    IoC container. In this project, we will use `Autofac` as the IoC library:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个辅助类，以便通过Autofac轻松解析对象图的过程。这将帮助我们基于配置的IoC容器创建类型。在这个项目中，我们将使用`Autofac`作为IoC库：
- en: Install the `NuGet` package, `Autofac`, in the `Chat` project.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中安装`NuGet`包`Autofac`。
- en: Create a new class called `Resolver` in the `Chat` project.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中创建一个名为`Resolver`的新类。
- en: Add a `private static` field called `container` of the `IContainer` type (from
    `Autofac`).
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`container`的`IContainer`类型（来自`Autofac`）的`private static`字段。
- en: Add a public static method called `Initialize` with `IContainer` as a parameter.
    Set the value of the parameter to the container field.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Initialize`的公共静态方法，带有`IContainer`作为参数。将参数的值设置为容器字段。
- en: 'Add a generic static public method called `Resolve`, which will return an instance
    that is based on the argument type with the `Resolve` method of `IContainer`:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Resolve`的通用静态公共方法，它将返回一个基于参数类型的实例，使用`IContainer`的`Resolve`方法：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Creating a Bootstrapper
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个Bootstrapper
- en: 'Here, we will create a `Bootstrapper` class that we will use to set up the
    common configurations that we need in the startup phase of the app. Usually, there
    is one part of the Bootstrapper for each target platform and one that is shared
    for all platforms. In this project, we only need the shared part:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将创建一个`Bootstrapper`类，用于在应用程序启动阶段设置我们需要的常见配置。通常，Bootstrapper的每个目标平台都有一个部分，所有平台都有一个共享部分。在这个项目中，我们只需要共享部分：
- en: Create a new class called `Bootstrapper` in the`Chat`project.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中创建一个名为`Bootstrapper`的新类。
- en: Add a new public static method called `Init`.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Init`的新的公共静态方法。
- en: Create a new `ContainerBuilder` and register the types to the `container`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`ContainerBuilder`并将类型注册到`container`。
- en: Create a `Container` using the `Build` method of the `ContainerBuilder`. Create
    a variable called `container` that should contain the instance of the `Container`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ContainerBuilder`的`Build`方法创建一个`Container`。创建一个名为`container`的变量，它应该包含`Container`的实例。
- en: 'Use the `Initialize` method on the `Resolver` and pass the `container` variable
    as an argument, as shown in the following code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Resolver`上使用`Initialize`方法，并将`container`变量作为参数传递，如下所示：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Call the `Init` method of the `Bootstrapper` in the constructor in the `App.xaml.cs` file
    after the call to `InitializeComponents`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`App.xaml.cs`文件中，在调用`InitializeComponents`之后，在构造函数中调用`Bootstrapper`的`Init`方法：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating a base ViewModel
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本ViewModel
- en: 'We now have a service that is responsible for handling the communication with
    the backend. It''s time to create a view model. First, however, we will create
    a base view model, where we can put the code that will be shared between all view
    models of the app:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个负责处理与后端通信的服务。是时候创建一个视图模型了。但首先，我们将创建一个基本视图模型，其中可以放置在应用程序的所有视图模型之间共享的代码：
- en: Create a new folder called `ViewModels`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModels`的新文件夹。
- en: Create a new class called `ViewModel`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ViewModel`的新类。
- en: Make the new class public and abstract.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类设置为public和abstract。
- en: Add a static field called `Navigation` of the `INavigation` type. This will
    be used to store a reference to the navigation services provided by Xamarin.Forms.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Navigation`的`INavigation`类型的静态字段。这将用于存储Xamarin.Forms提供的导航服务的引用。
- en: Add a static field called `User` of the `string` type. The field will be used
    when connecting to the chat service so that messages you send will be displayed
    with your name attached.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`User`的`string`类型的静态字段。该字段将在连接到聊天服务时使用，以便您发送的消息将显示您的名称。
- en: Add and implement the `INotifiedPropertyChanged` interface. This is necessary
    because we want to use data bindings.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加并实现`INotifiedPropertyChanged`接口。这是必要的，因为我们想要使用数据绑定。
- en: 'Add a `Set` method that will make it easier for us to raise the `PropertyChanged` event
    from the `INotifiedPropertyChanged` interface. The method will check if the value
    has changed. If it has, it will raise the event:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Set`方法，这样我们就可以更容易地从`INotifiedPropertyChanged`接口中触发`PropertyChanged`事件。该方法将检查值是否已更改。如果已更改，它将触发事件：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Creating the Mainview
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MainView
- en: Now that we have our `ViewModel` base class set up and all of the code for receiving
    and sending messages, it's time to create the two views. These will act as the
    user interface of the app.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了`ViewModel`基类，并且已经编写了接收和发送消息的所有代码，是时候创建两个视图了。这些将充当应用程序的用户界面。
- en: We are going to start by creating the main view. This is the view that will
    be displayed when the user starts the app. We will add an entry control (an input
    textbox) so that the user can enter a username and add a command to navigate to
    the chat view.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从创建主视图开始。这是用户启动应用程序时将显示的视图。我们将添加一个输入控件（输入文本框），以便用户可以输入用户名，并添加一个命令以导航到聊天视图。
- en: 'The main view will be composed of the following:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 主视图将由以下内容组成：
- en: A `ViewModel` file called `MainViewModel.cs`
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`MainViewModel.cs`的ViewModel文件
- en: An XAML file called `MainView.xaml`, which contains the layout
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`MainView.xaml`的XAML文件，其中包含布局
- en: A code-behind file called `MainView.xaml.cs`, which will carry out the data-binding
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`MainView.xaml.cs`的代码后台文件，将执行数据绑定
- en: Let's start by creating the `ViewModel` for the `MainView`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为`MainView`创建`ViewModel`开始。
- en: Creating MainViewModel
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MainViewModel
- en: 'The `MainViewModel` that we are about to create will hold a username that the
    user will enter in the UI. It will also contain a `Command` property called `Start`
    that will be bound to a `Button` that the user will click after entering their
    username:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建的`MainViewModel`将保存用户将在UI中输入的用户名。它还将包含一个名为`Start`的`Command`属性，该属性将绑定到用户在输入用户名后单击的`Button`：
- en: In the `ViewModel` folder, create a class called `MainViewModel.cs`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewModel`文件夹中，创建一个名为`MainViewModel.cs`的类。
- en: Inherit the class from `ViewModel`.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ViewModel`继承该类。
- en: Make the class `public`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为`public`。
- en: Add a property called `Username` of the `string` type.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Username`的`string`类型的属性。
- en: Add a property called `Start` of the `ICommand` type and implement it as shown
    as the following. The `Start` command will assign the `Username` from the `Username`
    property and assign it to the static `User` property in the base `ViewModel`.
    It then creates a new instance of `ChatView` by using the `Resolver` and pushing
    it onto the navigation stack.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Start`的`ICommand`类型的属性，并按照以下方式实现它。`Start`命令将从`Username`属性中分配`Username`并将其分配给基本`ViewModel`中的静态`User`属性。然后，它使用`Resolver`创建`ChatView`的新实例，并将其推送到导航堆栈上。
- en: '`MainViewModel` should now look as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel`现在应该如下所示：'
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that we have the `MainViewModel`, we need a view that goes with it. It's
    time to create the `MainView`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`MainViewModel`，我们需要一个与之配套的视图。是时候创建`MainView`了。
- en: Creating the MainView
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MainView
- en: The `MainView` will display a user interface that allows the user to enter a
    name before starting the chat. This section will be about creating the `MainView`
    XAML file and the code behind that view.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainView`将显示一个用户界面，允许用户在开始聊天之前输入名称。本节将介绍创建`MainView`的XAML文件和该视图的代码。'
- en: We will start by removing the template-generated `MainPage` and replacing it
    with an MVVM-friendly `MainView`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先删除模板生成的`MainPage`，并将其替换为MVVM友好的`MainView`。
- en: Replacing the MainPage
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换MainPage
- en: 'When we created the app, the template generated a page called `MainPage`. Since
    we are using MVVM as a pattern, we need to remove this page and replace it with
    a view called `MainView` instead:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建应用程序时，模板生成了一个名为`MainPage`的页面。由于我们使用MVVM作为模式，我们需要删除此页面，并将其替换为一个名为`MainView`的视图：
- en: In the root of the `Chat` project, delete the page called `MainPage`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目的根目录中，删除名为`MainPage`的页面。
- en: Create a new folder called `Views`.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Views`的新文件夹。
- en: Add a new XAML page called `MainView` in the `Views` folder.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Views文件夹中添加一个名为`MainView`的新XAML页面。
- en: Editing the XAML
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑XAML
- en: 'It''s now time to add some content to the newly created `MainView.xaml` file.
    The icons that are mentioned next can be found in the same folder that they should
    be added to if you go to the project on GitHub. The GitHub URL can be found at
    the beginning of this chapter. There is a lot going on here, so make sure to check
    what you write against the code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向新创建的 `MainView.xaml` 文件添加一些内容了。下面提到的图标可以在与其应该添加到的同一文件夹中找到，如果你去GitHub上的项目，就可以找到。GitHub的URL可以在本章的开头找到。这里有很多内容，所以确保检查你写的代码：
- en: Add the `chat.png` icon to the `Drawable` folder that is inside the `Resources`
    folder in the Android project.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `chat.png` 图标添加到 Android 项目中 `Resources` 文件夹内的 `Drawable` 文件夹中。
- en: Add the `chat@2x.png` icon to the `Resources` folder in the iOS project.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `chat@2x.png` 图标添加到 iOS 项目中的 `Resources` 文件夹中。
- en: Open the `MainView.xaml` file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml` 文件。
- en: Add a `Title` property in the `ContentPage` node. This will be the title displayed
    in the navigation bar of the app.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ContentPage` 节点中添加一个 `Title` 属性。这将是应用程序导航栏中显示的标题。
- en: Add a `Grid` and define two rows in it. The first one should have a height of
    `"*"` and the second one of `"2*"`. This will partition the space in two rows,
    of which the first will take up `1/3` of the space and the second will take up `2/3`
    of the space.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Grid`，并在其中定义两行。第一行的高度应为 `"*"`，第二行的高度应为 `"2*"`。这将把空间分成两行，第一行将占据空间的 `1/3`，第二行将占据空间的
    `2/3`。
- en: Add an `Image` with the `Source` set to `"chat.png"` and its `VerticalOptions`
    and `HorizontalOptions` set to `"Center"`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `Image`，将 `Source` 设置为 `"chat.png"`，并将其 `VerticalOptions` 和 `HorizontalOptions`
    设置为 `"Center"`。
- en: Add `StackLayout` with the `Grid.Row` set to `"1"`, the `Padding` set to `"10"`,
    and the `Spacing` set to `"20"`. The `Grid.Row` property positions the `StackLayout`
    in the second row. The `Padding` adds 10 units of space around the `StackLayout`
    and the `Spacing` defines the amount of space between each element added in the
    `StackLayout`.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 `StackLayout`，将 `Grid.Row` 设置为 `"1"`，将 `Padding` 设置为 `"10"`，将 `Spacing`
    设置为 `"20"`。`Grid.Row` 属性将 `StackLayout` 定位在第二行。`Padding` 在 `StackLayout` 周围添加了
    10 个单位的空间，`Spacing` 定义了在 `StackLayout` 中添加的每个元素之间的空间量。
- en: In the `StackLayout`, add an `Entry` node that has its `Text` property set to
    `"{Binding UserName}"` and a `Placeholder` property set to `"Enter a username"`.
    The binding of the Text node will make sure that, when the user enters a value
    in the `Entry` control, it's updated in the `ViewModel`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackLayout` 中，添加一个 `Entry` 节点，将其 `Text` 属性设置为 `"{Binding UserName}"`，并将
    `Placeholder` 属性设置为 `"输入用户名"`。文本节点的绑定将确保当用户在 `Entry` 控件中输入值时，它会在 `ViewModel` 中更新。
- en: In the `StackLayout`, add a `Button` control that will have the `Text` property
    set to `"Start"` and its `Command` property set to `"{Binding Start}"`. The `Command` property
    binding will execute when the user taps the button. It will run the code that
    we defined in the `MainViewModel` class.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StackLayout` 中，添加一个 `Button` 控件，将其 `Text` 属性设置为 `"Start"`，并将其 `Command` 属性设置为
    `"{Binding Start}"`。当用户点击按钮时，`Command` 属性绑定将被执行。它将运行我们在 `MainViewModel` 类中定义的代码。
- en: 'When finished, the code should look as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，代码应如下所示：
- en: '[PRE14]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The layout is finished and we now need to turn our focus to the code behind
    this view to wire up some loose ends.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 布局已完成，现在我们需要将焦点转向这个视图的代码，以解决一些问题。
- en: Fixing the code behind the view
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复视图的代码
- en: 'As with all views, when using MVVM, we need to pass our view a `ViewModel`.
    Since we are using dependency injection in this project, we will pass it through
    the constructor and then assign it to the `BindingContext` of the view itself.
    We will also make sure that we enable safe areas to avoid controls being partially
    hidden behind the iPhone X notch at the top:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有视图一样，在使用 MVVM 时，我们需要向视图传递一个 `ViewModel`。由于在这个项目中使用了依赖注入，我们将通过构造函数传递它，然后将其分配给视图本身的
    `BindingContext`。我们还将确保启用安全区域，以避免控件部分隐藏在 iPhone X 顶部的刘海区域后面：
- en: Open the `MainView.xaml.cs` file.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml.cs` 文件。
- en: Add a parameter called `viewModel` of the `MainViewModel` type in the constructor
    of the `MainView` class. The argument for this parameter will be injected by `Autofac`
    at runtime.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainView` 类的构造函数中添加一个名为 `viewModel` 的 `MainViewModel` 类型的参数。这个参数的参数将在运行时由
    `Autofac` 注入。
- en: Add a `platform-specific` statement that instructs the application to use safe
    areas on iOS. A safe area makes sure that the app does not use the space on the
    side of the notch at the top of the screen on an iPhone X.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个指令，指示应用程序在 iOS 上使用安全区域。安全区域确保应用程序不会使用屏幕顶部 iPhone X 的刘海区域旁边的空间。
- en: Assign the `viewModel` argument to the `BindingContext` property of the view.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `viewModel` 参数分配给视图的 `BindingContext` 属性。
- en: 'The changes made are marked in bold in the code, as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所做的更改在代码中用粗体标记如下：
- en: '[PRE15]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our `MainView` is complete but we still need to tell the application to use
    it as the entry point view.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MainView` 完成了，但我们仍然需要告诉应用程序使用它作为入口视图。
- en: Setting the main view
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置主视图
- en: 'The entry point view, also referred to as the application''s `MainPage`, is
    set during the initialization of a Xamarin.Forms app. Usually, it is set in the
    constructor of the App class. We will be creating the `MainView` through the resolver
    we created earlier and wrapping it in `NavigationPage` to enable platform-specific
    navigation on the device that the app runs on:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 入口视图，也称为应用程序的 `MainPage`，在初始化 Xamarin.Forms 应用程序时设置。通常，在 App 类的构造函数中设置。我们将通过之前创建的解析器创建
    `MainView`，并将其包装在 `NavigationPage` 中，以在应用程序运行的设备上启用特定于平台的导航：
- en: Open the `App.xaml.cs` file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.xaml.cs` 文件。
- en: Resolve an instance to a `MainView` class by using the `Resolver` and storing
    it in a variable called `mainView`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用解析器将一个 `MainView` 类的实例解析为一个名为 `mainView` 的变量。
- en: Create a new instance of `NavigationPage` by passing the `mainView` variable
    as a constructor argument and assigning it to a variable called `navigationPage`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将 `mainView` 变量作为构造函数参数传递并将其赋值给一个名为 `navigationPage` 的变量，创建一个新的 `NavigationPage`
    实例。
- en: Assign the `navigationPage.Navigation` property to the static `Navigation` property
    on the `ViewModel` type. This property will be used when navigating between pages
    later on.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`navigationPage.Navigation`属性分配给`ViewModel`类型上的静态`Navigation`属性。稍后在页面之间导航时将使用此属性。
- en: 'Assign the `navigationPage` variable to the `MainPage` property on the `App`
    class. This sets the start view of our application:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`navigationPage`变量分配给`App`类的`MainPage`属性。这将设置我们应用程序的起始视图：
- en: '[PRE16]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'That''s it for the `MainView`; nice and easy. Let''s now move on to something
    more interesting: the `ChatView` that will be used to send and receive messages.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`MainView`；简单而容易。现在让我们转向更有趣的东西：`ChatView`，它将用于发送和接收消息。
- en: Creating the ChatView
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ChatView
- en: The `ChatView` is a standard chat client. It will have an area for displaying
    incoming and outgoing messages and a text field at the bottom in which the user
    can type a message. It will also have a button for taking a photo and a button
    for sending messages if the user doesn't hit return on the on-screen keyboard.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatView`是一个标准的聊天客户端。它将有一个用于显示传入和传出消息的区域，底部有一个文本字段，用户可以在其中输入消息。它还将有一个用于拍照的按钮和一个用于发送消息的按钮，如果用户没有在屏幕键盘上按回车键。'
- en: We will start by creating the `ChatViewModel` that contains all of the logic
    by acting as the glue between the view and the model. Our model, in this case,
    is represented by our `ChatService`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建`ChatViewModel`，它包含所有逻辑，充当视图和模型之间的粘合剂。在这种情况下，我们的模型由`ChatService`表示。
- en: After that, we will create the `ChatView` that handles the rendering of the **Graphical
    User Interface** (**GUI**).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建`ChatView`，它处理**图形用户界面**（**GUI**）的渲染。
- en: Creating the ChatViewModel
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ChatViewModel
- en: As stated previously, the `ChatViewModel` is the glue between the visual representation
    (the `View`) and the model (which is basically our `ChatService`). The `ChatViewModel`
    will handle the storing of messages and the communication with the `ChatService`
    by hooking up the functionality to send and receive messages.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ChatViewModel`是视觉表示（`View`）和模型（基本上是我们的`ChatService`）之间的粘合剂。`ChatViewModel`将处理消息的存储和与`ChatService`的通信，通过将发送和接收消息的功能连接起来。
- en: Creating the class
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建类
- en: The `ChatViewModel` is a simple class that inherits from the `ViewModel` base
    class we created earlier. In the first code exercise, we will create the class,
    adding relevant `using` statements and a property called Messages in which we
    will store the messages that we have received. The view will use the Message collection
    to display the messages in a `ListView`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatViewModel`是一个简单的类，它继承自我们之前创建的`ViewModel`基类。在第一个代码练习中，我们将创建这个类，添加相关的`using`语句，并添加一个名为Messages的属性，用于存储我们收到的消息。视图将使用消息集合来在`ListView`中显示消息。'
- en: 'Since this is a large block of code, we recommend that you write it first and
    then go over the numbered list to get to grips with what has been added to the
    class:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个大块的代码，我们建议您先编写它，然后按照编号列表来了解已添加到类中的内容：
- en: Create a new class called `ChatViewModel` in the `ViewModels` folder of the
    `Chat` project.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目的`ViewModels`文件夹中创建一个名为`ChatViewModel`的新类。
- en: Make the class `public` and inherit it from the `ViewModel` base class to gain
    the common base functionality from the base class.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类设置为`public`，并从`ViewModel`基类继承，以从基类获得共同的基本功能。
- en: Add a `readonly` property called `chatService` of the `IChatService` type. This
    will store a reference to an object that implements `IChatService` and make the
    concrete implementation of `ChatService` replaceable. It's good practice to expose
    any service as an interface.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`chatService`的`readonly`属性，类型为`IChatService`。这将存储一个实现`IChatService`的对象的引用，并使`ChatService`的具体实现可替换。将任何服务公开为接口是一个良好的实践。
- en: Add a public property called `Messages` of the `public ObservableCollection<Message>`type
    with a private setter. This collection will hold all messages. The private setter
    makes the property inaccessible from outside this class. This maintains the integrity
    of the collection by ensuring messages are not inserted anywhere but inside the
    class.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Messages`的公共属性，类型为`public ObservableCollection<Message>`，带有私有的setter。这个集合将保存所有消息。私有的setter使得该属性无法从类外部访问。这通过确保消息只能在类内部插入来维护集合的完整性。
- en: Add a constructor parameter called `chatService` of the `IChatService` type. When
    we use dependency injection, this is where `Autofac` will inject an object that
    implements `IChatService`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`chatService`的构造函数参数，类型为`IChatService`。当我们使用依赖注入时，这是`Autofac`将注入实现`IChatService`的对象的地方。
- en: In the constructor, assign the `chatService` parameter to the `chatService`
    property. This will store the reference to the `ChatService` so that we can use
    it during the lifetime of the `ChatViewModel`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`chatService`参数分配给`chatService`属性。这将存储对`ChatService`的引用，以便我们在`ChatViewModel`的生命周期内使用它。
- en: In the constructor, instantiate the `Messages` property to a new `ObservableCollection<Message>`.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，将`Messages`属性实例化为一个新的`ObservableCollection<Message>`。
- en: 'In the constructor, create a `Task.Run` statement that will call the `chatService.CreateConnection()`
    method if the `chatService.IsConnected` property is `false`. End the `Task.Run`
    statement by sending a new `UserConnected` message:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中，创建一个`Task.Run`语句，如果`chatService.IsConnected`属性为`false`，则调用`chatService.CreateConnection()`方法。通过发送一个新的`UserConnected`消息来结束`Task.Run`语句：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that we have our `ChatViewModel` instantiated, it's time to add a property
    that will hold whatever the user is typing at that moment.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实例化了`ChatViewModel`，是时候添加一个属性，用于保存用户当前输入的内容。
- en: Adding the text property
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加文本属性
- en: 'At the bottom of the GUI, there will be a text field (an entry control) that
    will allow the user to enter the message. This entry will be data-bound to a property
    that we will call `Text` in the `ChatViewModel`. Whenever the user changes the
    text, this property will be set. This is classic data binding:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在GUI的底部，将有一个文本字段（输入控件），允许用户输入消息。这个输入将与`ChatViewModel`中的一个我们称为`Text`的属性进行数据绑定。每当用户更改文本时，将设置此属性。这是经典的数据绑定：
- en: Add a new private field called `text` of the `string`type.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`text`的新私有字段，类型为`string`。
- en: 'Add a public property called `Text` that returns the private text field in
    the getter and makes a call to the `Set()` method of the base class in the setter.
    The `Set` method is defined in the `ViewModel` base class and will raise an event
    back to the view if the property changes in the `ChatViewModel`, effectively keeping
    them in `sync`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`Text`的公共属性，在getter中返回私有文本字段，并在setter中调用基类的`Set()`方法。`Set`方法在`ViewModel`基类中定义，并且如果`ChatViewModel`中的属性发生变化，它将向视图引发事件，有效地保持它们的同步：
- en: '[PRE18]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have a property ready for data-binding. Let's look at some code for receiving
    messages from the `ChatService`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好进行数据绑定。让我们看一些从`ChatService`接收消息的代码。
- en: Receiving messages
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收消息
- en: When a message is sent from the server, over SignalR, the `ChatService` will
    parse this message and transform it into a Message object. It will then raise
    an event called `NewMessage`, which is defined in the ChatService.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当从服务器通过SignalR发送消息时，`ChatService`将解析此消息并将其转换为一个Message对象。然后它将引发一个名为`NewMessage`的事件，该事件在ChatService中定义。
- en: What we will do in this section is implement an event handler to handle these
    events and add them to the Messages collection, unless a message with the same
    ID already exists in the collection.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个事件处理程序来处理这些事件，并将它们添加到Messages集合中，除非集合中已经存在具有相同ID的消息。
- en: 'Again, follow the steps and look at the code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，按照以下步骤并查看代码：
- en: In the `ChatViewModel`, create a method called `ChatService_NewMessage`, which will
    be a standard event handler. This has two parameters:  `sender`, which is of the
    `object` type, and `e`, which is of the `Events.NewMessageEventArgs` type.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChatViewModel`中，创建一个名为`ChatService_NewMessage`的方法，它将是一个标准的事件处理程序。它有两个参数：`sender`，类型为`object`，和`e`，类型为`Events.NewMessageEventArgs`。
- en: Wrap the code in this method in a `Device.BeginInvokeOnMainThread()` since we
    are going to add messages to the Message collection. Items added to this collection
    will be modifying the view and any code that modifies the view must be run on
    the UI thread.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中加入`Device.BeginInvokeOnMainThread()`，因为我们将要向消息集合中添加消息。添加到此集合的项目将修改视图，任何修改视图的代码都必须在UI线程上运行。
- en: In the `Device.BeginInvokeOnMainThread`, add the incoming message from `e.Message`
    to the `Messages` collection if a message with the specific `Message.Id` isn't
    already present in the collection. This is to avoid message duplication.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Device.BeginInvokeOnMainThread`中，如果集合中不存在具有特定`Message.Id`的消息，则将来自`e.Message`的传入消息添加到`Messages`集合中。这是为了避免消息重复。
- en: 'The method should look as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应如下所示：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the event handler is defined, we need to hook it up in the constructor:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义事件处理程序时，我们需要在构造函数中将其挂钩：
- en: Locate the constructor of the `ChatViewModel` class.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`ChatViewModel`类的构造函数。
- en: Wire up a `chatService.NewMessage` event to the `ChatService_NewMessage` handler
    we just created. A good place to do this is under the instantiation of the `Messages`
    collection.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`chatService.NewMessage`事件与我们刚刚创建的`ChatService_NewMessage`处理程序连接起来。这样做的一个好地方是在实例化`Messages`集合下面。
- en: 'The code marked in bold is what we should add to the `ChatViewModel` class:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 加粗标记的代码是我们应该添加到`ChatViewModel`类中的：
- en: '[PRE20]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The app will now be able to receive messages. How about sending them? Well,
    stay tuned!
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 应用现在将能够接收消息。那么如何发送消息呢？敬请关注！
- en: Creating the LocalSimpleTextMessage class
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建LocalSimpleTextMessage类
- en: 'To make it easier to recognize whether a message is coming from the server
    or whether it is sent by the user of the device that the code is executing on,
    we will create a `LocalSimpleTextMessage`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易识别消息是来自服务器还是由执行代码的设备上的用户发送的，我们将创建一个`LocalSimpleTextMessage`：
- en: Create a new class with the name `LocalSimpleTextMessage` in the `Chat.Messages`
    project.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat.Messages`项目中创建一个名为`LocalSimpleTextMessage`的新类。
- en: Add `SimpleTextMessage` as the base class.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`SimpleTextMessage`添加为基类。
- en: Create a constructor with `SimpleTextMessage` as the parameter.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个以`SimpleTextMessage`为参数的构造函数。
- en: 'Set the value to all of the base properties with the value from the parameter,
    as in the code that follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将值设置为参数中的所有基本属性的值，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sending text messages
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送文本消息
- en: Sending text messages is also very straightforward. We need to create a command
    that we can data-bind for the GUI. The command will be executed either when the
    user hits return or when the user clicks the send button. When a user does either
    of these two things, the command will create a new `SimpleTextMessage` and pass
    in the current user to identify the message for other users. We will copy the
    text from the `ChatViewModel` text property, which, in turn, is in sync with the
    `Entry` control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 发送文本消息也非常简单。我们需要创建一个可以为GUI进行数据绑定的命令。当用户按下回车键或点击发送按钮时，命令将被执行。当用户执行这两个操作之一时，命令将创建一个新的`SimpleTextMessage`并传入当前用户以标识消息给其他用户。我们将从`ChatViewModel`的`text`属性中复制文本，而这个属性又与`Entry`控件同步。
- en: We will then add the message to the Messages collection, triggering the `ListView`
    that will be handling messages to update. After that, we will pass the message
    to the `ChatService` and clear the `ChatViewModel` text property. By doing this,
    we notify the GUI that it has changed and let the data-binding magic clear the
    field.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将把消息添加到消息集合中，触发将处理消息的`ListView`更新的操作。之后，我们将把消息传递给`ChatService`并清除`ChatViewModel`的文本属性。通过这样做，我们通知GUI它已经改变，并让数据绑定魔法清除字段。
- en: 'Refer to the following steps and look at the code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下步骤并查看代码：
- en: Create a new property called `Send` of the `ICommand` type.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Send`的`ICommand`类型的新属性。
- en: Assign it a new `Command` instance and follow these steps to implement it.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分配一个新的`Command`实例，并按照以下步骤实现它。
- en: Create a new instance of a `SimpleTextMessage` class by passing the User property
    of the base class as an argument. Assign the instance to a variable called `message`.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将基类的User属性作为参数传递来创建`SimpleTextMessage`类的新实例。将该实例分配给名为`message`的变量。
- en: Set the `Text` property of the message variable to the `Text` property of the
    `ChatViewModel` class. This copies the current text in the chat entry defined
    by the GUI later on.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息变量的`Text`属性设置为`ChatViewModel`类的`Text`属性。这将复制稍后由GUI定义的聊天输入中的当前文本。
- en: Create a `LocalSimpleTextMessage` object and pass in the message variable as
    a constructor argument. The `LocalSimpleTextMessage` is a `SimpleTextMessage`
    and makes it possible for the view to recognize it as a message that the user
    of the app sent, effectively rendering it on the right side of the chat area.
    Add the `LocalSimpleTextMessage` instance to the Messages collection. This will
    display the message in the view.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`LocalSimpleTextMessage`对象，并将消息变量作为构造函数参数传入。`LocalSimpleTextMessage`是`SimpleTextMessage`，使视图能够识别它作为应用用户发送的消息，并在聊天区域的右侧有效地呈现它。将`LocalSimpleTextMessage`实例添加到Messages集合中。这将在视图中显示消息。
- en: Make a call to the `chatService.SendMessage()` method and pass the message variable
    as an argument.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`chatService.SendMessage()`方法并将消息变量作为参数传递。
- en: 'Empty the `Text` property of the `ChatViewModel` to clear the entry control
    in the GUI:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清空`ChatViewModel`的`Text`属性以清除GUI中的输入控件：
- en: '[PRE22]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: What good is a chat app if we can't send photos? Let's implement this in the
    next section.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能发送照片，聊天应用有何用？让我们在下一节中实现这一点。
- en: Installing the Acr.UserDialogs plugin
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Acr.UserDialogs插件
- en: '`Acr.UserDialogs` is a plugin that makes it possible to use several standard
    user dialogs from code that are shared between platforms. To install and configure
    it, there are a few steps we need to follow:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`Acr.UserDialogs`是一个插件，可以在代码中使用几个标准用户对话框，这些对话框在各个平台之间共享。要安装和配置它，我们需要遵循一些步骤：'
- en: Install the `Acr.UserDialogs`NuGet package to the `Chat-`, `Chat.iOS`, and `Chat.Android` projects.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Acr.UserDialogs` NuGet包安装到`Chat-`，`Chat.iOS`和`Chat.Android`项目中。
- en: 'In the `MainActivity.cs` file, add `UserDialogs.Init(this)` in the `OnCreate`
    method:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.cs`文件中，在`OnCreate`方法中添加`UserDialogs.Init(this)`：
- en: '[PRE23]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Installing the Media plugin
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装媒体插件
- en: 'We will use the `Xam.Plugin.Media` NuGet package to access the photo library
    of the device. We need to install the package to the `Chat-`, `Chat.iOS`, and
    `Chat.Android` projects in the solution. Before we can use the package, however,
    we need to do some configuration for each platform. We will start with Android:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`Xam.Plugin.Media` NuGet包来访问设备的照片库。我们需要在解决方案的`Chat-`，`Chat.iOS`和`Chat.Android`项目中安装该包。但是，在使用该包之前，我们需要为每个平台进行一些配置。我们将从Android开始：
- en: The plugin needs the `WRITE_EXTERNAL_STORAGE`and `READ_EXTERNAL_STORAGE` permissions.
    The plugin will add these for us, but we need to override the `OnRequestPermissionResult`
    in the `MainActivity.cs`.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该插件需要`WRITE_EXTERNAL_STORAGE`和`READ_EXTERNAL_STORAGE`权限。插件将为我们添加这些权限，但我们需要在`MainActivity.cs`中覆盖`OnRequestPermissionResult`。
- en: Call the `OnRequestPermissionsResult` method.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`OnRequestPermissionsResult`方法。
- en: 'Add `CrossCurrentActivity.Current.Init(this, savedInstanceState)`after the
    initalizing of Xamarin.Forms in the `OnCreate` method in the `MainActivity.cs`
    file, as shown in the following code:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainActivity.cs`文件的`OnCreate`方法中，在Xamarin.Forms初始化后添加`CrossCurrentActivity.Current.Init(this,
    savedInstanceState)`，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We also need to add some configuration for the file paths from which the users
    can pick photos:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为用户可以选择照片的文件路径添加一些配置：
- en: Add a folder called `xml` to the `Resources` folder in the Android project.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android项目的`Resources`文件夹中添加一个名为`xml`的文件夹。
- en: Create a new XML file called `file_paths.xml` in the new folder.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新文件夹中创建一个名为`file_paths.xml`的新XML文件。
- en: 'Add the following code to `file_paths.xml`:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`file_paths.xml`：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last thing we need to do to set up the plugin for the Android project is
    to add the code that follows in the `AndroidManifest.xml` field inside the application
    element:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 设置插件的最后一件事是在Android项目的`AndroidManifest.xml`字段中的应用程序元素中添加以下代码：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For the iOS project, the only thing we need to do is to add the following four
    usage descriptions to the `info.plist`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于iOS项目，我们唯一需要做的就是在`info.plist`中添加以下四个用途描述：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Sending photos
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送照片
- en: To be able to send photos, we will have to use a source of photos. In our case,
    we will be using the camera as the source. The camera will return the photo as
    a stream after it has been taken. We need to convert that stream into a byte array
    and then finally Base64 encode it into a string that is easy to send over SignalR.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够发送照片，我们将不得不使用照片的来源。在我们的情况下，我们将使用相机作为来源。相机将在拍摄后将照片作为流返回。我们需要将该流转换为字节数组，然后最终将其Base64编码为一个易于通过SignalR发送的字符串。
- en: The method that we are about to create, called `ReadFully()`, takes a stream
    and turns it into a byte array, which is a step towards achieving the Base64-encoded
    string. This is a standard piece of code that creates a buffer that will be used
    when we are reading the `Stream` parameter and writing it to the `MemoryStream`
    in chunks until we have read the full stream, hence the name of the method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将创建的名为`ReadFully()`的方法接受一个流并将其转换为字节数组，这是实现Base64编码字符串的一步。这是一个标准的代码片段，它创建一个缓冲区，当我们读取`Stream`参数并将其以块的形式写入`MemoryStream`直到读取完整的流时，将使用该缓冲区，因此方法的名称。
- en: 'Follow along and check out the code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 跟着检查代码：
- en: Create a method called `ReadFully` that takes a `stream` called `input` as a
    parameter and returns a `byte` array.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ReadFully`的方法，该方法接受名为`input`的`stream`作为参数并返回一个`byte`数组。
- en: Declare a `buffer` variable of the `byte[]` type and initialize it as a 16 KB
    big byte array. (`16 * 1024`)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`byte[]`类型的`buffer`变量，并将其初始化为16KB大小的字节数组（`16 * 1024`）。
- en: Inside a using statement, create a new `MemoryStream` called `ms`.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用语句内，创建一个名为`ms`的新`MemoryStream`。
- en: 'Read the input of the `Stream` into the `ms` variable:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Stream`的输入读取到`ms`变量中：
- en: '[PRE28]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Following this, we have a large chunk of code. This code exposes a command that
    will be executed when the user clicks the photo button in the app. It starts by
    configuring `CrossMedia` (a media plugin), which indicates the quality the photo
    should be, and then it starts the photo picker. When the photo picker returns
    from the `async` call to `PickPhotoAsync()`, we start uploading the photo. To
    notify the user, we use `UserDialogs.Instance.ShowLoading` to create a loading
    overlay with a message to indicate that we are uploading the photo.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一大块代码。该代码公开了一个命令，当用户在应用程序中点击照片按钮时将执行该命令。它首先配置了`CrossMedia`（一个媒体插件），指示照片的质量，然后启动了照片选择器。当照片选择器从`async`调用`PickPhotoAsync()`返回时，我们开始上传照片。为了通知用户，我们使用`UserDialogs.Instance.ShowLoading`创建一个带有消息的加载覆盖，以指示我们正在上传照片。
- en: We will then get the stream of the photo, convert it into a byte array using
    the `ReadFully()` method, and Base64 encode it into a string. The string will
    be wrapped in a `PhotoMessage` instance, added to the local `Message` collection
    of the `ChatViewModel`, and then sent to the server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将获取照片的流，使用`ReadFully()`方法将其转换为字节数组，并将其Base64编码为字符串。该字符串将被包装在一个`PhotoMessage`实例中，添加到`ChatViewModel`的本地`Message`集合中，然后发送到服务器。
- en: 'Follow the steps and study the code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤并学习代码：
- en: Create a new property called `Photo` of the `ICommand` type. Assign it a new
    `Command` instance.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Photo`的`ICommand`类型的新属性。为其分配一个新的`Command`实例。
- en: Create an anonymous `async` method (a lambda expression) and add the code defined
    in the upcoming steps into it. You can see the full code of the method in the
    code section following.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个匿名的`async`方法（lambda表达式），并将即将定义的代码添加到其中。您可以在随后的代码部分中看到该方法的完整代码。
- en: Create a new instance of the `PickMediaOptions` class and set the `CompressionQuality`
    property to `50`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`PickMediaOptions`类的一个新实例，并将`CompressionQuality`属性设置为`50`。
- en: Call `CrossMedia.Current.PickPhotoAsync` with an `async` method call and save
    the result to a local variable called `photo`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`async`方法调用`CrossMedia.Current.PickPhotoAsync`，并将结果保存到名为`photo`的本地变量中。
- en: Install the NuGet package.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装NuGet包。
- en: Show a message dialog by calling `UserDialogs.Instance.ShowLoading()` with the
    text, `"Uploading photo"`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`UserDialogs.Instance.ShowLoading()`显示一个消息对话框，文本为“正在上传照片”。
- en: Get the photo stream by calling the `GetStream()` method of the photo variable
    and save it to a variable called `stream`.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`photo`变量的`GetStream()`方法获取照片流，并将其保存到名为`stream`的变量中。
- en: Convert the stream in to a byte array by calling the `ReadFully()` method.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`ReadFully()`方法将流转换为字节数组。
- en: Convert the byte array in to a Base64-encoded string using the `Convert.ToBase64String()`
    method. Save the string to a variable called `base64photo`.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Convert.ToBase64String()`方法将字节数组转换为Base64编码的字符串。将字符串保存到名为`base64photo`的变量中。
- en: Create a new `PhotoMessage` instance and pass the `User` as the constructor
    argument. Set the `Base64Photo` property to the `base64photo` variable and the
    `FileEnding` property to the file ending of the `photo.Path` string, using the
    `Split` function of the string object. Store the new `PhotoMessage` instance in
    a variable called `message`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`PhotoMessage`实例，并将`User`作为构造函数参数传递。将`Base64Photo`属性设置为`base64photo`变量，将`FileEnding`属性设置为`photo.Path`字符串的文件结束，使用字符串对象的`Split`函数。将新的`PhotoMessage`实例存储在名为`message`的变量中。
- en: Add the message object to the `Messages` collection.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将消息对象添加到`Messages`集合中。
- en: Send the message to the server by calling the async `chatService.SendMessage()`
    method.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用异步的`chatService.SendMessage()`方法将消息发送到服务器。
- en: Hide the loading dialog by calling `UserDialogs.Instance.HideLoading()`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用`UserDialogs.Instance.HideLoading()`隐藏加载对话框。
- en: 'The code that follows shows how this can be implemented:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了如何实现这一点：
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `ChatViewModel` is complete. It's now time to visualize our GUI.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChatViewModel`已经完成。现在是时候可视化我们的GUI了。'
- en: Creating the ChatView
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建ChatView
- en: The `ChatView` is responsible for creating the user interface that the user
    will interact with. It will display local and remote messages, both text and photos,
    and also notify a user when a remote user has joined the chat. We'll start by
    creating a converter that will convert photos represented as a Base64-encoded
    string into an `ImageSource` that can be used as the source of the image control
    in XAML.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: ChatView负责创建用户将与之交互的用户界面。它将显示本地和远程消息，包括文本和照片，并在远程用户加入聊天时通知用户。我们将首先创建一个转换器，将以Base64编码的字符串表示的照片转换为可用作XAML中图像控件源的`ImageSource`。
- en: Creating Base64ToImageConverter
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Base64ToImageConverter
- en: When we take a picture using the phone's camera, it will be handed to us as
    a byte array. In order to send this to the server, we will convert in it to a
    Base64-encoded string. To display that message locally, we will need to convert
    it back into a byte array and then pass that byte array to a helper method of
    the `ImageSource` class to create an instance of the `ImageSource` object. This
    object will make sense to the `Image` control and an image will be displayed.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用手机相机拍照时，它将作为字节数组交给我们。为了将其发送到服务器，我们将其转换为Base64编码的字符串。为了在本地显示该消息，我们需要将其转换回字节数组，然后将该字节数组传递给`ImageSource`类的辅助方法，以创建`ImageSource`对象的实例。该对象将对`Image`控件有意义，并显示图像。
- en: 'Since there is a lot of code here, we suggest you follow the steps and look
    at each line of code in detail as you follow them:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这里有很多代码，我们建议您按照步骤进行，并在跟随时仔细查看每行代码：
- en: Create a folder called `Converters` in the `Chat` project.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Chat”项目中创建一个名为`Converters`的文件夹。
- en: Create a new class called `Base64ImageConverter` in the `Converters` folder;
    let the class implement the `IValueConverter` interface.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Converters`文件夹中创建一个名为`Base64ImageConverter`的新类；让该类实现`IValueConverter`接口。
- en: In the `Convert()` method of the class, cast the object parameter called value
    to a string called `base64String`.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的`Convert()`方法中，将名为value的对象参数转换为名为`base64String`的字符串。
- en: Convert the `base64String` to a byte array using the `System.Convert.FromBase64String()`
    method. Save the result to a variable called `bytes`.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`System.Convert.FromBase64String()`方法将`base64String`转换为字节数组。将结果保存到名为`bytes`的变量中。
- en: Create a new `MemoryStream` by passing the byte array into its constructor.
    Save the stream to a variable called `stream`.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将字节数组传递到其构造函数来创建一个新的`MemoryStream`。将流保存到名为`stream`的变量中。
- en: Call the `ImageSource.FromStream()` method and pass the stream as a lambda expression
    that returns the stream variable. Return the `ImageSource` object created.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`ImageSource.FromStream()`方法，并将流作为返回流变量的lambda表达式传递。返回创建的`ImageSource`对象。
- en: 'The `ConvertBack()` method does not need to be implemented since we will never
    convert an image back into a Base64-encoded string via data-binding. We will just
    let it throw a `NotImplementedException`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不需要实现`ConvertBack()`方法，因为我们永远不会通过数据绑定将图像转换回Base64编码的字符串。我们只需让它抛出`NotImplementedException`：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now it's time to start adding some actual XAML code to the view. We will start
    by creating the main layout skeleton that we will then gradually build on until
    we have the finished view.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始向视图添加一些实际的XAML代码了。我们将首先创建主要的布局骨架，然后逐渐构建，直到完成视图。
- en: Creating the skeleton ChatView
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建骨架ChatView
- en: 'This XAML file will contain the view that lists messages we have sent and messages
    we have received. It''s quite a large file to create, so for this part, I suggest
    that you copy the XAML and study every step carefully:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个XAML文件将包含我们发送和接收的消息列表的视图。创建这个文件相当大，所以在这一部分，我建议你复制XAML并仔细研究每一步：
- en: Create a new `XAML Content Page` in the `Views` folder called `ChatView`.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Views`文件夹中创建一个名为`ChatView`的新`XAML Content Page`。
- en: Add XML namespaces for `Chat.Selectors` and `Chat.Converters` and call them
    `selectors` and converters.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Chat.Selectors`和`Chat.Converters`添加XML命名空间，并将它们命名为`selectors`和`converters`。
- en: Add a `ContentPage.Resources` node that will, later on, contain resources for
    this view.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ContentPage.Resources`节点，稍后将包含此视图的资源。
- en: Add `ScrollView` as the page content.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ScrollView`添加为页面内容。
- en: Add `Grid` as the only child of the `ScrollView` and name it `MainGrid` by setting
    the `x:Name` property to `MainGrid`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Grid`作为`ScrollView`的唯一子元素，并通过将`x:Name`属性设置为`MainGrid`来命名它。
- en: Create a `RowDefinitions` element that contains three rows. The first should
    have a height of `*`, the second a height of `1`, and the third a platform-specific
    height based on the platform using an `OnPlatform` element.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含三行的`RowDefinitions`元素。第一行的高度应为`*`，第二行的高度为`1`，第三行的高度根据平台使用`OnPlatform`元素进行设置。
- en: Save some space for the `ListView` that will be inserted later on.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为稍后插入的`ListView`保存一些空间。
- en: Add a `BoxView` that will act as a visual divider by setting the `HeightRequest`
    property to `1`, the `BackgroundColor` property to `#33000000`, and the `Grid.Row`
    property to `1`. This will position the `BoxView` in the one-unit-high row of
    the grid, effectively drawing a single line across the screen.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`HeightRequest`属性设置为`1`，`BackgroundColor`属性设置为`#33000000`，将`Grid.Row`属性设置为`1`，添加一个`BoxView`，它将充当视觉分隔符。这将在网格的一单位高的行中定位`BoxView`，有效地在屏幕上绘制一条单行。
- en: 'Add another `Grid` that will use the space of the third row by setting the
    `Grid.Row` property to `2`. Also, add some padding by setting the `Padding` property
    to `10`. Define three rows in the grid with heights of `30`, `*`, and `30`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个`Grid`，通过将`Grid.Row`属性设置为`2`来使用第三行的空间。还可以通过将`Padding`属性设置为`10`来添加一些填充。在网格中定义三行，高度分别为`30`、`*`和`30`：
- en: '[PRE31]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that we have completed the main skeleton of our page, we need to start adding
    some specific content. First, we will add `ResourceDictionary` to create a `DataTemplate`
    selector that will select the correct layouts for different chat messages. Then,
    we need to put the `Base64ToImageConverter` to use and, to do that, we need to
    define it in the view.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了页面的主要骨架，我们需要开始添加一些具体的内容。首先，我们将添加`ResourceDictionary`来创建一个`DataTemplate`选择器，用于为不同的聊天消息选择正确的布局。然后，我们需要使用`Base64ToImageConverter`，为此，我们需要在视图中定义它。
- en: Adding ResourceDictionary
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ResourceDictionary
- en: 'It''s now time to add some resources to the view. In this case, we will be
    adding a template selector that we will create later on, and the `Base64ToImageConverter`
    that we created earlier. The template selector will look at each row that we will
    bind to the `ListView`, which will be presenting messages and selecting the best
    layout template that suits that message. To be able to use these pieces of code
    from XAML, we need to define a way for the XAML parser to find them:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候向视图添加一些资源了。在这种情况下，我们将添加一个模板选择器，稍后我们将创建它，以及我们之前创建的`Base64ToImageConverter`。模板选择器将查看我们将绑定到`ListView`的每一行，该行将呈现消息并选择最适合该消息的布局模板。为了能够从XAML中使用这些代码片段，我们需要定义XAML解析器找到它们的方法：
- en: Locate the `<!-- TODO Add resources -->` comment inside the `ContentPage.Resources`
    element.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContentPage.Resources`元素内部找到`<!-- TODO Add resources -->`注释。
- en: 'Add the XAML in the sample as follows, right underneath this comment mentioned
    in *step 1*:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在*步骤1*中的注释下面，按照示例中的XAML添加XAML：
- en: '[PRE32]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will create one instance of each resource that we define and make it accessible
    to the rest of the view.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们定义的每个资源的一个实例，并使其可以访问到视图的其余部分。
- en: Adding ListView
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ListView
- en: 'We will be using a `ListView` to display the messages in the chat app. Again,
    follow the steps and take a look at the code to make sure you understand each
    step:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`ListView`来显示聊天应用中的消息。再次，按照步骤并查看代码，确保你理解每一步：
- en: Locate the `<!-- TODO Add ListView -->` comment in the `ChatView.xaml` file.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChatView.xaml`文件中找到`<!-- TODO Add ListView -->`注释。
- en: Add a `ListView` and set the `x:Name` property to `MessageList`.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ListView`，并将`x:Name`属性设置为`MessageList`。
- en: Data-bind the `ListView` by setting the `ItemsSource` property to `{Binding
    Messages}`. This will make the `ListView` aware of changes in the `ObservableCollection<Message>`,
    which is exposed through the `Messages` property. Any time a message is added
    or removed, the `ListView` will update to reflect this change.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`ItemsSource`属性设置为`{Binding Messages}`来对`ListView`进行数据绑定。这将使`ListView`意识到`ObservableCollection<Message>`中的更改，该集合通过`Messages`属性公开。每当添加或删除消息时，`ListView`都会更新以反映这一变化。
- en: Add the `SelectMessageTemplate` resource we defined in the previous section
    to the `ItemTemplate` property. This will run some code each time that an item
    is added to make sure that we programmatically select the correct visual template
    for a specific message. No worries, we will soon write that code.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在上一节中定义的`SelectMessageTemplate`资源添加到`ItemTemplate`属性。这将在每次添加项目时运行一些代码，以确保我们以编程方式选择特定消息的正确视觉模板。别担心，我们很快就会写那段代码。
- en: Make sure that the `ListView` is able to create rows of uneven height by setting
    the `HasUnevenRows` property to `true`.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将`HasUnevenRows`属性设置为`true`，确保`ListView`能够创建不均匀高度的行。
- en: The last property we need to set is the `SeparatorVisibility`, and we set it
    to `None` to avoid a row in between each row.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要设置的最后一个属性是`SeparatorVisibility`，我们将其设置为`None`，以避免在每一行之间添加一行。
- en: We define a placeholder where we will add resources. The resources we will be
    adding are the different `DataTemplate` that we will be using to render different
    types of messages.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个占位符，我们将在其中添加资源。我们将添加的资源是我们将用于呈现不同类型消息的不同`DataTemplate`。
- en: 'The XAML should look as follows:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: XAML应该如下所示：
- en: '[PRE33]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Adding templates
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加模板
- en: We will now be adding five different templates, each corresponding to a specific
    message type that the app either sends or receives. Each of these templates goes
    under the `<!-- Resources go here later on -->` comment from the code snippet
    in the previous section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将添加五个不同的模板，每个模板对应应用程序发送或接收的特定消息类型。每个这些模板都放在前一节代码片段中的`<!--稍后放置资源-->`注释下。
- en: We will not be explaining each of these templates step by step, since the XAML
    that they contain should be starting to feel familiar at this point.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会逐步解释每个模板，因为它们包含的XAML应该在这一点上开始感到熟悉。
- en: 'Each template starts the same way: the root element is a `DataTemplate` with
    a name set. The name is important because we will be referencing it in code very
    soon. The first child of the `DataTemplate` is always `ViewCell` with the `IsEnabled`
    property set to `false` to avoid the user being able to interact with the content.
    We simply want to display it. The content that follows after this element is the
    actual content that the row will be constructed from.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板都以相同的方式开始：根元素是具有设置名称的`DataTemplate`。名称很重要，因为我们很快将在代码中引用它。`DataTemplate`的第一个子元素始终是`ViewCell`，并将`IsEnabled`属性设置为`false`，以避免用户能够与内容交互。我们只是想显示它。此元素之后的内容是构建行的实际内容。
- en: Bindings inside the `ViewCell` will also be local to each item or row that the
    `ListView` renders. In this case, this will be an instance of a `Message` class,
    since we are data binding the `ListView` to a collection of Message objects. You
    will see some `StyleClass` properties in the code. These will be used when we
    do the final styling of the app using **Cascading Style Sheets** (**CSS**).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewCell`内部的绑定也将针对`ListView`呈现的每个项目或行进行本地化。在这种情况下，这将是`Message`类的一个实例，因为我们正在将`ListView`的数据绑定到`Message`对象的集合。您将在代码中看到一些`StyleClass`属性。在最终使用**层叠样式表**（**CSS**）对应用程序进行最终样式设置时，将使用这些属性。'
- en: Our task here is to write each of these templates under the `<!-- Resources
    go here later on -->` comment.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是在`<!--稍后放置资源-->`注释下编写每个模板。
- en: 'The `SimpleText` is the `DataTemplate` that is selected when the Message is
    a remote message. It will be rendered on the left side of the list view, just
    as you might expect. It displays a `username` and a `text` message:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`SimpleText`是当消息是远程消息时选择的`DataTemplate`。它将在列表视图的左侧呈现，就像您可能期望的那样。它显示了`username`和`text`消息：'
- en: '[PRE34]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `LocalSimpleText` template is the same as the `SimpleText` data template,
    except that it renders on the right side of the `ListView` by setting the `Grid.Column`
    property to `1`, effectively using the right column:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocalSimpleText`模板与`SimpleText`数据模板相同，只是通过将`Grid.Column`属性设置为`1`，有效地使用右列，它在`ListView`的右侧呈现：'
- en: '[PRE35]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This `DataTemplate` is used when a user connects to the chat:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户连接到聊天时使用此`DataTemplate`：
- en: '[PRE36]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'A photo that is uploaded to the server is accessible via a URL. This `DataTemplate`
    displays an image based on a URL and is used for remote images:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过URL访问服务器上上传的照片。此`DataTemplate`基于URL显示图像，并用于远程图像：
- en: '[PRE37]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'A message that contains a photo that is sent by the user and rendered directly
    based on the Base64-encoded image that we generate from the camera. Since we don''t
    want to wait for the image to upload, we use this `DataTemplate`, which utilizes
    the `Base64ImageConverter` that we wrote earlier to transform the string into `ImageSource`
    that can be displayed by the Image control:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 包含用户发送并直接基于我们从相机生成的Base64编码图像进行渲染的照片的消息。由于我们不想等待图像上传，我们使用这个`DataTemplate`，它利用我们之前编写的`Base64ImageConverter`将字符串转换为可以由Image控件显示的`ImageSource`：
- en: '[PRE38]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: These are all of the templates we need. It's now time to add some code to make
    sure we select the right template for the message to display.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是我们需要的所有模板。现在是时候添加一些代码，以确保我们选择正确的模板来显示消息。
- en: Creating a template selector
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板选择器
- en: 'Using a template selector is a powerful way of injecting different layouts
    based on the items that are being data-bound. In this case, we will look at each
    message that we want to display and select the best `DataTemplate` for them. The
    code is somewhat repetitive, so we will be using the same approach as for the
    XAML—simply adding the code and letting you study it yourself:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板选择器是一种根据正在进行数据绑定的项目注入不同布局的强大方式。在这种情况下，我们将查看要显示的每条消息，并为它们选择最佳的`DataTemplate`。代码有些重复，所以我们将使用与XAML相同的方法——简单地添加代码，让您自己学习它：
- en: Create a folder called `Selectors` in the `Chat` project.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中创建一个名为`Selectors`的文件夹。
- en: Create a new class called `ChatMessagesSelector` in the `Selectors` folder and
    inherit it from `DataTemplateSelector`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Selectors`文件夹中创建一个名为`ChatMessagesSelector`的新类，并从`DataTemplateSelector`继承它。
- en: 'Add the following code, which will look at each object that is data-bound and
    pull the correct `DataTemplate` from the resources we just added:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码，它将查看每个数据绑定的对象，并从我们刚刚添加的资源中提取正确的`DataTemplate`：
- en: '[PRE39]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Adding the buttons and entry control
  id: totrans-349
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加按钮和输入控件
- en: 'Now we will add the buttons and the entry that the user will use for writing
    chat messages. The icons that we are using can be found in the GitHub repository
    for this chapter. For Android, the icons will be placed in the `Drawable` folder
    inside the `Resource` folder and for iOS, they will be in the `Resource` folder.
    The icons are in the same folder on GitHub:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加用户用于编写聊天消息的按钮和输入。我们使用的图标可以在本章的GitHub存储库中找到。对于Android，图标将放在`Resource`文件夹内的`Drawable`文件夹中，而对于iOS，它们将放在`Resource`文件夹中。GitHub上的同一文件夹中有这些图标：
- en: Locate the `<!-- TODO Add buttons and entry controls -->` comment in the `ChatView.xaml`
    file.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChatView.xaml`文件中找到`<!-- TODO Add buttons and entry controls -->`的注释。
- en: Add an `ImageButton`. The `Source` should be set to `photo.png`, the `Command`
    set to `{Binding Photo}`, and the `VerticalOptions` and `HorizontalOptions` set
    to `Center`. The `Source` is used to display an image; the `Command` will be executed
    when a user taps the image and the `HorizontalOptions` and `VerticalOptions` will
    be used to center the image in the middle of the control.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`ImageButton`。`Source`应设置为`photo.png`，`Command`设置为`{Binding Photo}`，`VerticalOptions`和`HorizontalOptions`设置为`Center`。`Source`用于显示图像；当用户点击图像时，`Command`将被执行，`HorizontalOptions`和`VerticalOptions`将用于将图像居中在控件的中间。
- en: Add an `Entry` control to allow the user the enter a message to be sent. The
    `Text` property should be set to `{Binding Text}`. Set the `Grid.Column` property
    to `1` and the `ReturnCommand` to `{Binding Send}` to execute the send command
    in the `ChatViewModel` when a user hits *Enter*.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`Entry`控件，允许用户输入要发送的消息。`Text`属性应设置为`{Binding Text}`。将`Grid.Column`属性设置为`1`，将`ReturnCommand`设置为`{Binding
    Send}`，以在用户按下*Enter*时执行`ChatViewModel`中的发送命令。
- en: 'An `ImageButton` with the `Grid.Column` property set to `2`, the `Source` set
    to `send.png`, and the `Command` set to `{Binding Send}` (the same as the return
    command). Center it horizontally and vertically:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个`ImageButton`，`Grid.Column`属性设置为`2`，`Source`设置为`send.png`，`Command`设置为`{Binding
    Send}`（与返回命令相同）。水平和垂直居中：
- en: '[PRE40]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Fixing the code behind
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修复代码后面
- en: 'Now that the XAML is done, we have some work to do in the code behind. We''ll
    start by modifying the class to be partial and then we''ll be adding some using
    statements:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在XAML已经完成，我们需要在代码后面做一些工作。我们将首先修改类为部分类，然后添加一些`using语句`：
- en: Open the `ChatView.xaml.cs` file.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ChatView.xaml.cs`文件。
- en: Mark the class as `partial`.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类标记为`partial`。
- en: Add a `private` field called `viewModel` of the `ChatViewModel` type, which will
    hold a local reference to the `ChatViewModel`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`viewModel`的`ChatViewModel`类型的`private`字段，它将保存对`ChatViewModel`的本地引用。
- en: Add `using statements` for `Chat.ViewModels`, `Xamarin.Forms`, and `Xamarin.Forms.PlatformConfiguration.iOSSpecific`.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`Chat.ViewModels`，`Xamarin.Forms`和`Xamarin.Forms.PlatformConfiguration.iOSSpecific`添加`using语句`。
- en: 'The class should now look as follows. The bold code indicates what should have
    changed:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该类应该如下所示。粗体代码表示应该已经更改的内容：
- en: '[PRE41]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'When a new message arrives, this will be added to the Messages collection in
    the `ChatViewModel`. To make sure that the `MessageList` and `ListView` scroll
    appropriately so that the new message is visible, we need to write some additional
    code:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当有新消息到达时，将其添加到`ChatViewModel`中的Messages集合中。为了确保`MessageList`和`ListView`适当滚动以使新消息可见，我们需要编写一些额外的代码：
- en: Create a new method called `Messages_CollectionChanged` that takes an object
    as the first parameter and `NotifyCollectionChangedEventArgs` as the second parameter.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Messages_CollectionChanged`的新方法，它以对象作为第一个参数，以`NotifyCollectionChangedEventArgs`作为第二个参数。
- en: Add a call to the `MessageList.ScrollTo()` method and pass the last Message
    in the `viewModel.Messages` collection by calling `viewModel.Messages.Last()`.
    The second parameter should be set to `ScrollPosition.End`, indicating that we
    want to make the entire messages `ListView` row visible. The third parameter should
    be set to `true` to enable animations.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`MessageList.ScrollTo()`方法，并通过调用`viewModel.Messages.Last()`将`viewModel.Messages`集合中的最后一条消息传递给它。第二个参数应设置为`ScrollPosition.End`，表示我们要使整个消息`ListView`行可见。第三个参数应设置为`true`以启用动画。
- en: 'The method should now look as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法现在应该如下所示：
- en: '[PRE42]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It''s now time to extend the constructor so that it takes `ChatViewModel` as
    a parameter and sets the `BindingContext` in the way that we are used to. The
    constructor will also make sure that we use the safe area when rendering controls
    and that we hook up to the events necessary for handling changes in the `Messages`
    collection of the `ChatViewModel`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候扩展构造函数，使其以`ChatViewModel`作为参数，并以我们习惯的方式设置`BindingContext`。构造函数还将确保在渲染控件时使用安全区域，并确保我们连接到处理`ChatViewModel`的`Messages`集合中的更改所必需的事件：
- en: Modify the constructor in the `ChatView` class so that it takes a `ChatViewModel`
    as the only parameter and name the parameter `viewModel`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ChatView`类中修改构造函数，使其以`ChatViewModel`作为唯一参数，并将参数命名为`viewModel`。
- en: Assign the `viewModel` parameter from the constructor to the local `viewModel`
    field in the class.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构造函数中的`viewModel`参数分配给类中的本地`viewModel`字段。
- en: 'The call to the `InitializeComponent()` method, add a platform-specific call
    to the `SetUseSafeArea(true)` method to ensure that the app will be visually safe
    to use on an iPhone X and not partially hidden behind the notch at the top:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InitializeComponent()`方法的调用中，添加一个特定于平台的调用`SetUseSafeArea(true)`方法，以确保应用程序在iPhone
    X上可视上是安全的，不会部分隐藏在顶部的刘海后面：
- en: '[PRE43]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Every time a view appears, the `OnAppearing()` method is called. This method
    is virtual and we can override it. We will use this feature to make sure that
    we will have the correct height on the `MainGrid`. This is because we have to
    wrap everything in a `ScrollView` because the view has to be able to scroll when
    the keyboard appears. If we don''t calculate the width of the `MainGrid` it could
    be bigger than the screen because the `ScrollView` allows it to expand:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 每次视图出现时，都会调用`OnAppearing()`方法。这个方法是虚拟的，我们可以重写它。我们将使用这个特性来确保`MainGrid`的高度是正确的。这是因为我们必须将所有内容包装在`ScrollView`中，因为视图在键盘出现时必须能够滚动。如果我们不计算`MainGrid`的宽度，它可能会比屏幕大，因为`ScrollView`允许它扩展。
- en: Override the `OnAppearing()` method.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖`OnAppearing()`方法。
- en: Calculate the safe area to use by calling the platform-specific method, `On<Xamarin.Forms.PlatformConfiguration.iOS>().SafeAreaInsets()`.
    This will return a `Xamarin.Forms.Thickness` object that will contain the inset
    information we need in order to calculate the height of the `MainGrid`. Assign
    the `Thickness` object to a variable called `safeArea`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用特定于平台的方法`On<Xamarin.Forms.PlatformConfiguration.iOS>().SafeAreaInsets()`来计算要使用的安全区域。这将返回一个`Xamarin.Forms.Thickness`对象，其中包含我们需要的插入信息，以便计算`MainGrid`的高度。将`Thickness`对象分配给名为`safeArea`的变量。
- en: 'Set the `MainGrid.HeightRequest` property to the height of the view (`this.Height`)
    and then subtract the `Top` and `Bottom`properties of the `safeArea`:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`MainGrid.HeightRequest`属性设置为视图的高度（`this.Height`），然后减去`safeArea`的`Top`和`Bottom`属性：
- en: '[PRE44]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Styling
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 样式
- en: Styling is an important part of an app. Just like with HTML, you can do styling
    by setting properties on each control directly, or by setting `Style` elements
    in the application's resource dictionary. Recently, however, a new way of styling
    has emerged in Xamarin.Forms, which is using Cascading Style Sheets, better known
    as CSS.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是应用程序的重要组成部分。就像HTML一样，您可以通过直接设置每个控件的属性或在应用程序的资源字典中设置`Style`元素来进行样式设置。然而，最近，Xamarin.Forms出现了一种新的样式设置方式，即使用层叠样式表，通常称为CSS。
- en: Since CSS doesn't cover all cases, we will fall back to standard application
    resource dictionary styling as well.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CSS并不能覆盖所有情况，我们还将回退到标准的应用程序资源字典样式。
- en: Styling with CSS
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CSS进行样式设置
- en: Xamarin.Forms supports styling via CSS files. It has a subset of the functionalities
    you would expect from normal CSS, but support is getting better with each version.
    We are going to use two different selectors to apply the styling.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.Forms支持通过CSS文件进行样式设置。它具有您从普通CSS中期望的功能的子集，但是每个版本的支持都在不断改进。我们将使用两种不同的选择器来应用样式。
- en: 'First, let''s create the style sheet and we''ll discuss the content of it after
    that:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建样式表，然后再讨论其内容：
- en: Create a folder called `Css` in the `Chat` project.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中创建一个名为`Css`的文件夹。
- en: Create a new text file in the `Css` folder and name it `Styles.css`.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Css`文件夹中创建一个新的文本文件，并将其命名为`Styles.css`。
- en: 'Copy the style sheet, shown as follows, into that file:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下样式表复制到该文件中：
- en: '[PRE45]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The first selector, button, applies to every button control in the entire application.
    It sets the background color to `#A4243B` and the foreground color to `white`.
    You can do this for almost every type of control in Xamarin.Forms.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选择器button适用于整个应用程序中的每个按钮控件。它将背景颜色设置为`#A4243B`，前景颜色设置为`白色`。您几乎可以为Xamarin.Forms中的每种类型的控件执行此操作。
- en: The second selectors we use are class selectors, which are the ones beginning
    with a period, such as `.chatHeader`. The selectors are used in the XAML with
    the `StyleClass` property. Look back at the `ChatView.xaml` file we created earlier
    and you'll find these in the template resources.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的第二个选择器是类选择器，以句点开头，例如`.chatHeader`。这些选择器在XAML中与`StyleClass`属性一起使用。回顾一下我们之前创建的`ChatView.xaml`文件，您将在模板资源中找到这些内容。
- en: Each property in the CSS is mapped to a property on the control itself. There
    are also some Xamarin.Forms specific properties that can be used, but those are
    out of the scope of this book. If you search for Xamarin.Forms and CSS on the
    internet, you'll find all of the information you need to dive deeper into this.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: CSS中的每个属性都映射到控件本身的属性。还有一些特定于Xamarin.Forms的属性可以使用，但这些超出了本书的范围。如果您在互联网上搜索Xamarin.Forms和CSS，您将找到深入了解此内容所需的所有信息。
- en: Applying the style sheet
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用样式表
- en: A style sheet is no good on its own. We need to apply it to our application.
    We also need to set some styling on the NavigationPage here as well, since we
    can't gain access to it from the CSS directly.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表本身是不够的。我们需要将其应用到我们的应用程序中。我们还需要在NavigationPage上设置一些样式，因为我们无法直接从CSS中访问它。
- en: 'We will be adding some resources and a reference to the style sheet. Copy the
    code and refer  to the steps to study what each line does:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一些资源和对样式表的引用。复制代码并参考步骤来学习每行代码的作用：
- en: Open the `App.xaml` file in the `Chat` project.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chat`项目中的`App.xaml`文件中打开。
- en: In the `Application.Resources` node, add a `<StyleSheet Source="/Css/Styles.css"
    />` node to reference the style sheet.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Application.Resources`节点中，添加一个`<StyleSheet Source="/Css/Styles.css" />`节点来引用样式表。
- en: Following is the `StyleSheet` node. Add a `Style` node with the `TargetType`
    set to `"NavigationPage"` and create a setter for the `BarBackgroundColor` property
    with a value of `"#273E47"` and a setter for the `BarTextColor` property with
    a value of `"White"`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是`StyleSheet`节点。添加一个`TargetType`设置为`"NavigationPage"`的`Style`节点，并为`BarBackgroundColor`属性创建一个值为`"#273E47"`的setter，为`BarTextColor`属性创建一个值为`"White"`的setter。
- en: 'The `App.xaml` file should now look as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.xaml`文件现在应如下所示：'
- en: '[PRE46]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Handling life cycle events
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理生命周期事件
- en: 'Finally, we need to add some life cycle events that will take care of our SignalR
    connection in case the app goes to sleep or when it wakes up again:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一些生命周期事件，以便在应用程序进入睡眠状态或再次唤醒时处理我们的SignalR连接：
- en: Open the `App.Xaml.cs` file.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`App.Xaml.cs`文件。
- en: 'Add the code that follows somewhere in the class:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中的某个地方添加以下代码：
- en: '[PRE47]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The `OnSleep()` method will be called when the user minimizes the app and it
    will dispose of any active `chatService` that is running by closing the active
    connections. The `OnResume()` method has a little more content. It will recreate
    the connection if there isn't one already active and, depending on whether the
    user is set or not, it will resolve to the correct view. If a user isn't present,
    it will display the `MainView`; otherwise it will display the `ChatView`. Finally,
    it sets the selected view, wrapped in a navigation page.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户最小化应用程序时，将调用`OnSleep()`方法，并通过关闭活动连接来处理任何正在运行的`chatService`。`OnResume()`方法有更多的内容。如果没有活动连接，它将重新创建连接，并根据用户是否已设置，解析到正确的视图。如果用户不存在，它将显示`MainView`；否则它将显示`ChatView`。最后，它将选定的视图包装在导航页面中。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: That's that—good work! We have now created a chat app that connects to our backend.
    We have learned how to work with SignalR, how to style an app with CSS, how to
    use template selectors in a `ListView`, and how to use a value converter to convert
    a `byte[]` into a Xamarin.Forms `ImageSource`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止 - 干得好！我们现在已经创建了一个连接到后端的聊天应用程序。我们已经学会了如何使用SignalR，如何用CSS样式化应用程序，如何在`ListView`中使用模板选择器，以及如何使用值转换器将`byte[]`转换为Xamarin.Forms的`ImageSource`。
- en: In the next chapter, we will dive into an augmented world! We will create an
    AR-game for iOS and Android using UrhoSharp together with ARKit (iOS) and ARCore
    (Android).
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨增强现实世界！我们将使用UrhoSharp和ARKit（iOS）以及ARCore（Android）共同为iOS和Android创建一个AR游戏。
