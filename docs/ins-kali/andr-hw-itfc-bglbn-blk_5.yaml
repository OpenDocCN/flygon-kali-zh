- en: Chapter 5. Interfacing with High-speed Sensors Using SPI
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用SPI与高速传感器进行接口
- en: In the previous chapter, you worked with the I2C bus to communicate with an
    FRAM device that requires far more complex communications than that of the simple
    on/off digital communications used by GPIOs. I2C is very powerful and flexible,
    but it can be quite slow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您使用了I2C总线与需要比GPIO的简单开关数字通信更复杂通信的FRAM设备进行通信。I2C非常强大和灵活，但速度可能相当慢。
- en: 'In this chapter, you will learn how to write an Android app that uses the BBB''s
    SPI capabilities to retrieve environmental data from a high-speed sensor. We will
    cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何编写一个Android应用程序，利用BBB的SPI功能从高速传感器中检索环境数据。我们将涵盖以下主题：
- en: Understanding SPI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解SPI
- en: Multiplexing for SPI on the BBB
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BBB上的SPI复用
- en: Representing SPI devices in the Linux kernel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux内核中表示SPI设备
- en: Building an SPI interface circuit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建SPI接口电路
- en: Exploring the SPI sensor example app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索SPI传感器示例应用程序
- en: Understanding SPI
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解SPI
- en: 'The **Serial Peripheral Interface** (**SPI**) bus is a high-speed, serial bus
    originally developed by Motorola. Its purpose is to facilitate point-to-point
    communication between a single master device and one or more slave device. The
    SPI bus is typically implemented using four signals:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**串行外围接口**（**SPI**）总线是由Motorola最初开发的高速串行总线。它的目的是在单个主设备和一个或多个从设备之间促进点对点通信。SPI总线通常使用四个信号来实现：'
- en: '`SCLK`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SCLK`'
- en: '`MOSI`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MOSI`'
- en: '`MISO`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MISO`'
- en: '`SS`/`CS`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SS`/`CS`'
- en: Like I2C, the master on the SPI bus sets the pace of communication between the
    master and the slave by producing a clock signal. With SPI, this clock signal
    is called the **serial clock** (`SCLK`). Unlike the bidirectional data bus of
    I2C, SPI uses dedicated outgoing and incoming data lines for each device. Using
    dedicated lines results in SPI being able to achieve communication speeds far
    higher than those of I2C. The master sends data to the slave via the **master
    out, slave in** (`MOSI`) signal, and it receives data from the slave via the **master
    in, slave out** (`MISO`) signal. The **slave select** (`SS`) signal, also called
    **chip select** (`CS`), tells the slave device whether it should be awake and
    paying attention for any clock signals on `SCLK` and data being sent to it via
    `MOSI`. There are variants on this four-wire SPI bus scheme, such as a three-wire
    scheme that omits the `SS`/`CS` signal, but the BBB uses a four-wire scheme for
    its SPI buses.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与I2C一样，SPI总线上的主设备通过产生时钟信号来设置主设备和从设备之间的通信速度。使用SPI，这个时钟信号被称为**串行时钟**（`SCLK`）。与I2C的双向数据总线不同，SPI为每个设备使用专用的传出和传入数据线。使用专用线路使得SPI能够实现远高于I2C的通信速度。主设备通过**主输出，从输入**（`MOSI`）信号向从设备发送数据，并通过**主输入，从输出**（`MISO`）信号从从设备接收数据。**从选择**（`SS`）信号，也称为**芯片选择**（`CS`），告诉从设备它是否应该醒来并关注`SCLK`上的任何时钟信号和通过`MOSI`发送给它的数据。SPI总线方案有各种变体，例如省略`SS`/`CS`信号的三线方案，但BBB使用四线方案来实现其SPI总线。
- en: '![Understanding SPI](img/00022.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![理解SPI](img/00022.jpeg)'
- en: The SPI master and slave devices on an SPI bus
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SPI总线上的SPI主设备和从设备
- en: The BBB can act as either an SPI master or slave, so it does not label its data
    input and output signals for SPI as `MISO` or `MOSI`. Instead, it uses the names
    `D0` and `D1` for these signals. If the BBB acts as the master on the SPI bus,
    `D0` is the `MISO` signal and `D1` is the `MOSI` signal. If the BBB acts as the
    slave on the SPI bus, these are reversed (`D1` is `MISO`, `D0` is `MOSI`). For
    this book, the BBB will always be acting as the SPI master.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: BBB可以作为SPI主设备或从设备，因此它不会将其SPI的数据输入和输出信号标记为`MISO`或`MOSI`。相反，它使用名称`D0`和`D1`来表示这些信号。如果BBB在SPI总线上充当主设备，则`D0`是`MISO`信号，`D1`是`MOSI`信号。如果BBB在SPI总线上充当从设备，则这些信号是相反的（`D1`是`MISO`，`D0`是`MOSI`）。对于本书来说，BBB将始终充当SPI主设备。
- en: Tip
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**How do I remember which BBB SPI signal is input and which is output?**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何记住BBB SPI信号是输入还是输出？**'
- en: It can be confusing to remember which signal is `MISO` and which is `MOSI` when
    the BBB uses the signal names `D0` and `D1`. One way to remember is to think of
    the `0` in `D0` as an *O* (for slave output) and the `1` in `D1` as an *I* (for
    slave input). If the BBB is the SPI master (which will almost always be the case),
    then `D1` is the slave input signal (`MOSI`) and `D0` is the slave output signal
    (`MISO`).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当BBB使用信号名称`D0`和`D1`时，记住哪个信号是`MISO`，哪个是`MOSI`可能会令人困惑。记住的一种方法是将`D0`中的`0`看作是*O*（从设备输出），将`D1`中的`1`看作是*I*（从设备输入）。如果BBB是SPI主设备（这几乎总是这种情况），那么`D1`是从设备输入信号（`MOSI`），`D0`是从设备输出信号（`MISO`）。
- en: The maximum `SCLK` speed for SPI on the BBB is 48 MHz, but speeds ranging from
    1 MHz to 16 MHz are commonly used. Even at these reduced clock speeds, SPI is
    far superior to the 400 KHz clock speed of I2C buses when considering the amount
    of raw data that can be transmitted each second. Only one device can transmit
    data on an I2C bus at any time, but both the master and slave can transmit data
    simultaneously on an SPI bus because each device has a dedicated transmission
    signal.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: BBB上SPI的最大`SCLK`速度为48 MHz，但通常使用范围从1 MHz到16 MHz。即使在这些降低的时钟速度下，SPI在每秒传输的原始数据量方面也远远优于I2C总线的400
    KHz时钟速度。在I2C总线上，只有一个设备可以传输数据，但在SPI总线上，主设备和从设备都可以同时传输数据，因为每个设备都有专用的传输信号。
- en: Multiplexing for SPI on the BBB
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BBB上的SPI复用
- en: 'The AM335X processor of the BBB provides two SPI buses: SPI0 and SPI1\. Both
    buses are accessible via the P9 header. By default, no SPI buses are muxed. The
    following figure shows each of the potential pins on the P9 header where SPI signals
    can be muxed in different pinmux modes:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: BBB的AM335X处理器提供了两个SPI总线：SPI0和SPI1。这两个总线都可以通过P9标头访问。默认情况下，没有SPI总线被复用。以下图显示了P9标头上的潜在引脚，可以在不同的引脚复用模式下复用SPI信号：
- en: '![Multiplexing for SPI on the BBB](img/00023.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![BBB上的SPI复用](img/00023.jpeg)'
- en: Locations of the SPI buses on the P9 header with different pinmux modes
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在P9标头上的SPI总线位置与不同的引脚复用模式
- en: 'When deciding how you would like your pins to be muxed using SPI in your projects,
    keep the following in mind:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何在项目中使用SPI对引脚进行复用时，请记住以下几点：
- en: When in doubt, stick with using the SPI0 bus muxed to the P9.17, P9.18, P9.21,
    and P9.22 pins.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有疑问，最好使用SPI0总线复用到P9.17、P9.18、P9.21和P9.22引脚。
- en: The SPI1 channel conflicts with the I2C bus used by the capemgr (P9.20) and
    audio output (P9.28, P9.29, P9.31). Be aware that muxing these pins to use SPI1
    can disable some other functionality that you are depending upon for a full-featured
    Android system.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SPI1通道与capemgr（P9.20）和音频输出（P9.28、P9.29、P9.31）使用的I2C总线冲突。请注意，将这些引脚复用为SPI1可能会禁用您依赖于完整功能Android系统的某些其他功能。
- en: If you are using other cape boards in your projects, make sure that these capes
    don't require the use of the SPI buses. Only one device can exist on each SPI
    bus unless you use a GPIO pin and extra logic circuitry to manually control each
    SPI device's chip select signal.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您在项目中使用其他cape板，请确保这些cape不需要使用SPI总线。除非使用GPIO引脚和额外的逻辑电路手动控制每个SPI设备的片选信号，否则每个SPI总线上只能存在一个设备。
- en: Representing SPI devices in the Linux kernel
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Linux内核中表示SPI设备
- en: The Linux kernel provides a general-purpose SPI driver named `spidev`. The `spidev`
    driver is a simple interface that abstracts many of the housekeeping details involved
    in SPI communications. The `spidev` driver is exposed via the `/dev` filesystem
    as the `/dev/spidevX.Y` file. Multiple versions of these `spidev` files can be
    present depending upon the number of SPI buses configured in the Device Tree.
    The `X` value in the `spidev` filename refers to the SPI controller number (1
    for SPI0 and 2 for SPI1), and the `Y` value refers to the SPI bus of that controller
    (0 for the first bus and 1 for the second bus). For the examples in this book,
    you will only be using the first SPI bus of the SPI0 controller, so `/dev/spidev1.0`
    is the only file with which PacktHAL will interact.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核提供了一个通用的SPI驱动程序，名为`spidev`。`spidev`驱动程序是一个简单的接口，它抽象了SPI通信中涉及的许多维护细节。`spidev`驱动程序通过`/dev`文件系统公开为`/dev/spidevX.Y`文件。根据设备树中配置的SPI总线数量，可能存在多个版本的这些`spidev`文件。`spidev`文件名中的`X`值是SPI控制器编号（SPI0为1，SPI1为2），`Y`值是该控制器的SPI总线（第一个总线为0，第二个总线为1）。在本书的示例中，您只会使用SPI0控制器的第一个SPI总线，因此`/dev/spidev1.0`是PacktHAL将与之交互的唯一文件。
- en: Preparing Android for SPI sensor use
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为SPI传感器使用准备Android
- en: In [Chapter 2](part0019_split_000.html#page "Chapter 2. Interfacing with Android"),
    *Interfacing with Android*, you used `adb` to push two prebuilt files to your
    Android system. These two files, `BB-PACKTPUB-00A0.dtbo` and `init.{ro.hardware}.rc`,
    configure your Android system to enable the `spidev` kernel device driver that
    handles SPI bus interfacing, muxes the pins to enable the SPI0 bus, and allow
    your apps to access them.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](part0019_split_000.html#page "第2章.与Android接口")中，*与Android接口*，您使用`adb`将两个预构建文件推送到Android系统。这两个文件，`BB-PACKTPUB-00A0.dtbo`和`init.{ro.hardware}.rc`，配置您的Android系统以启用处理SPI总线接口的`spidev`内核设备驱动程序，复用引脚以启用SPI0总线，并允许您的应用程序访问它们。
- en: 'As far as SPI is concerned, the `BB-PACKTPUB-00A0.dtbo` overlay muxes the P9.17,
    P9.18, P9.21, and P9.22 pins into the SPI `CS0`, `D1`, `D0`, and `SCLK` signals,
    respectively. In the `PacktHAL.tgz` file, the source code for the overlay is located
    in the `cape/BB-PACKTPUB-00A0.dts` file. The code responsible for muxing these
    two pins is located in the `bb_spi0_pins` node within `fragment@0`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就SPI而言，`BB-PACKTPUB-00A0.dtbo`叠加将P9.17、P9.18、P9.21和P9.22引脚复用为SPI的`CS0`、`D1`、`D0`和`SCLK`信号。在`PacktHAL.tgz`文件中，叠加的源代码位于`cape/BB-PACKTPUB-00A0.dts`文件中。负责复用这两个引脚的代码位于`fragment@0`中的`bb_spi0_pins`节点中：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'While this sets up the muxing, it doesn''t assign and configure a device driver
    to these pins. The `fragment@2` node performs this kernel driver allocation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这设置了复用，但它并没有为这些引脚分配和配置设备驱动程序。`fragment@2`节点执行这个内核驱动程序分配：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Without digging into the fine details, there are three settings in `fragment@2`
    that are of interest to you:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，`fragment@2`中有三个设置对你很有兴趣：
- en: '`pinctrl-0`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pinctrl-0`'
- en: '`compatible`'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compatible`'
- en: '`spi-max-frequency`'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spi-max-frequency`'
- en: The first is `pinctrl-0`, which ties this node of Device Tree to the pins muxed
    in the `bb_spi0_pins` node. The second is `compatible`, which specifies the particular
    kernel driver, `spidev`, that will handle our hardware device. The last is `spi-max-frequency`,
    which specifies the maximum allowable speed for this SPI bus (16 MHz). 16 MHz
    is the maximum frequency specified for `spidev` in the Device Tree overlays provided
    with the BBB's kernel source.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`pinctrl-0`，它将设备树的这个节点与`bb_spi0_pins`节点中复用的引脚联系起来。第二个是`compatible`，它指定了特定的内核驱动程序`spidev`，它将处理我们的硬件设备。最后是`spi-max-frequency`，它指定了此SPI总线的最大允许速度（16
    MHz）。16 MHz是BBB内核源代码提供的设备树叠加中为`spidev`指定的最大频率。
- en: The custom `init.{ro.hardware}.rc` file that you pushed to the Android system
    doesn't have to do anything special for PacktHAL's SPI interfacing. By default,
    BBBAndroid uses `chmod` to set the permissions of the `/dev/spidev*` files to
    777 (complete access for everyone). This is not a secure practice since any process
    on the system can potentially open a `spidev` device and begin reading and writing
    to the hardware. For our purposes, though, having the `/dev/spidev*` files accessible
    to every process is necessary to allow our unprivileged example app access to
    the SPI bus.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你推送到Android系统的自定义`init.{ro.hardware}.rc`文件对PacktHAL的SPI接口没有特殊要求。默认情况下，BBBAndroid使用`chmod`将`/dev/spidev*`文件的权限设置为777（每个人都有完全访问权限）。这不是一个安全的做法，因为系统上的任何进程都可能打开`spidev`设备并开始读写硬件。但是，为了我们的目的，让`/dev/spidev*`文件对每个进程都可访问是必要的，以允许我们的非特权示例应用程序访问SPI总线。
- en: Building an SPI interface circuit
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建SPI接口电路
- en: Now that you have an understanding of where SPI devices are connected to the
    BBB and how the Linux kernel presents an interface to these devices, it is time
    to connect an SPI device to the BBB.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了SPI设备连接到BBB的位置以及Linux内核如何向这些设备提供接口，是时候将SPI设备连接到BBB了。
- en: As we mentioned in [Chapter 1](part0014_split_000.html#page "Chapter 1. Introduction
    to Android and the BeagleBone Black"), *Introduction to Android and the BeagleBone
    Black*, you will be interfacing with a sensor in this chapter. To be specific,
    we will be using a Bosch Sensortec BMP183 digital pressure sensor. This 7-pin
    component provides pressure data samples (in 16- to 19-bit resolution) and temperature
    data samples (in 16-bit resolution) for applications used for navigation, weather
    forecasting, and to measure changes in vertical elevation and so on.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](part0014_split_000.html#page "第1章。Android和BeagleBone Black简介")中提到的，*Android和BeagleBone
    Black简介*，在本章中，您将与传感器进行接口。具体来说，我们将使用博世Sensortec BMP183数字压力传感器。这个7针元件提供了压力数据样本（16至19位分辨率）和温度数据样本（16位分辨率），用于导航、天气预报以及测量垂直高程变化等应用。
- en: This particular chip is only available in a **land grid array** (**LGA**), which
    is a surface mount package that can be difficult to work with when building prototype
    circuits. Luckily for us, the AdaFruit breakout board for the sensor already has
    the chip mounted, which makes prototyping simple and easy.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特殊的芯片只能以**陆地网格阵列**（**LGA**）的形式提供，这是一种表面贴装封装，可能在构建原型电路时很难使用。幸运的是，对于我们来说，传感器的AdaFruit分离板已经安装了芯片，这使得原型设计变得简单而容易。
- en: '![Building an SPI interface circuit](img/00024.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![构建SPI接口电路](img/00024.jpeg)'
- en: 'The sensor breakout board (source: [www.adafruit.com](http://www.adafruit.com))'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器分离板（来源：[www.adafruit.com](http://www.adafruit.com)）
- en: The breakout board labels the `SCLK` signal as `SCK`, `MOSI` as `SDI` (serial
    data in), `MISO` as `SDO` (serial data out), and `SS` as `CS` (chip select). To
    power the board, a +3.3 V signal is connected to `VCC` and a ground is connected
    to `GND`. The `3Vo` signal of the breakout board provides a +3.3 V signal and
    is not used in our examples.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 分离板将`SCLK`信号标记为`SCK`，`MOSI`标记为`SDI`（串行数据输入），`MISO`标记为`SDO`（串行数据输出），`SS`标记为`CS`（芯片选择）。为了给板子供电，+3.3V信号连接到`VCC`，地线连接到`GND`。分离板的`3Vo`信号提供+3.3V信号，在我们的示例中未使用。
- en: Tip
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t disassemble your circuit!**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要拆卸您的电路！**'
- en: The sensor circuit in this chapter is part of a much larger circuit used in
    [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating a Complete Interfacing
    Solution"), *Creating a Complete Interfacing Solution*. If you build the circuit
    as it is positioned in the diagram (towards the middle of the breadboard), you
    can simply leave the sensor breakout board and wires in place as you build the
    remaining circuits in this book. This way, it will already be constructed and
    working when you reach [Chapter 6](part0041_split_000.html#page "Chapter 6. Creating
    a Complete Interfacing Solution").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的传感器电路是[第6章](part0041_split_000.html#page "第6章。创建完整的接口解决方案")中使用的一个更大电路的一部分，*创建完整的接口解决方案*。如果您按照图中的位置（靠近面包板中间）构建电路，您可以在构建本书中的其余电路时将传感器分离板和电线保持在原位。这样，当您到达[第6章](part0041_split_000.html#page
    "第6章。创建完整的接口解决方案")时，它已经被构建并且可以使用。
- en: Connecting the sensor
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接传感器
- en: The following figure shows the connections between the sensor breakout board
    and the BBB. The six main SPI bus signals (+3.3 V, ground, and the SPI `SCLK`,
    `MISO`, `MOSI`, and `SS`) are made using the pins of the P9 connector, so we have
    placed the breadboard on the P9 side of the BBB.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了传感器分离板与BBB之间的连接。六个主要的SPI总线信号（+3.3V、地线和SPI `SCLK`、`MISO`、`MOSI`和`SS`）使用P9连接器的引脚进行连接，因此我们将面包板放在BBB的P9侧。
- en: '![Connecting the sensor](img/00025.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![连接传感器](img/00025.jpeg)'
- en: The complete sensor interfacing circuit
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的传感器接口电路
- en: 'Let''s get started:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: Connect P9.1 (ground) to the vertical ground bus of the breadboard and P9.3
    (3.3 V) to the vertical VCC bus of the breadboard. These connections are identical
    to the ones made for the GPIO and I2C breadboard circuits you created in [Chapter
    3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs with GPIOs"),
    *Handling Inputs and Outputs with GPIOs* and [Chapter 4](part0029_split_000.html#page
    "Chapter 4. Storing and Retrieving Data with I2C"), *Storing and Retrieving Data
    with I2C*.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将P9.1（地线）连接到面包板的垂直地线总线，将P9.3（3.3V）连接到面包板的垂直VCC总线。这些连接与您在[第3章](part0024_split_000.html#page
    "第3章。使用GPIO处理输入和输出")中创建的GPIO和I2C面包板电路以及[第4章](part0029_split_000.html#page "第4章。使用I2C存储和检索数据")中创建的电路相同。
- en: The four SPI bus signals, `SCLK`, `MISO` (`D0`), `MOSI` (`D1`), and `SS` are
    on the P9.22, P9.21, P9.18, and P9.17 pins, respectively. Wire the P9.22 pin to
    the pin marked SCK on the breakout board, and wire the P9.21 pin to the pin marked
    SDO. Then, wire the P9.18 pin to the pin marked SDI, and wire P9.17 to the pin
    marked CS.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 四个SPI总线信号，`SCLK`、`MISO`（`D0`）、`MOSI`（`D1`）和`SS`分别位于P9.22、P9.21、P9.18和P9.17引脚上。将P9.22引脚连接到分离板上标记为SCK的引脚，将P9.21引脚连接到标记为SDO的引脚。然后，将P9.18引脚连接到标记为SDI的引脚，将P9.17引脚连接到标记为CS的引脚。
- en: Wire the ground bus to the GND pin of the breakout board and the VCC bus to
    the VCC pin of the breakout board. Leave the 3Vo pin of the breakout board unconnected.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将地线连接到分离板的GND引脚，将VCC线连接到分离板的VCC引脚。将分离板的3Vo引脚保持未连接状态。
- en: The sensor breakout board is now electrically connected to the BBB and is ready
    for your use. Double-check your wiring against the diagram of the complete sensor
    interfacing circuit to ensure that everything is connected properly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器分离板现在已经电气连接到BBB，并且可以使用。请仔细检查您的布线，确保一切连接正确。
- en: Exploring the SPI sensor example app
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索SPI传感器示例应用
- en: In this section, you will examine the example Android app that performs the
    SPI bus interfacing on BBB. The purpose of this application is to demonstrate
    how to use PacktHAL to perform SPI reads and writes from within an actual app
    using a set of interfacing functions. These functions allow you to send and receive
    data between the SPI bus master (the BBB) and the SPI bus slave (the SPI sensor).
    The low-level details of the hardware interfacing are implemented in PacktHAL,
    so you can quickly and easily get your apps interacting with the sensor.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将检查执行BBB上的SPI总线接口的示例Android应用程序。此应用程序的目的是演示如何使用PacktHAL在实际应用程序中使用一组接口函数执行SPI读写。这些函数允许您在SPI总线主机（BBB）和SPI总线从机（SPI传感器）之间发送和接收数据。硬件接口的低级细节是在PacktHAL中实现的，因此您可以快速轻松地使您的应用程序与传感器进行交互。
- en: Before digging through the SPI app's code, you must install the code to your
    development system and install the app to your Android system. The source code
    for the app and the precompiled `.apk` packages are located in the `chapter5.tgz`
    file, which is available for download from Packt's website. Follow the same process
    to download and add the app to your Eclipse ADT environment that was described
    in [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs* and *Chapter 4, Storing
    and Retrieving Data with I2C*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究SPI应用程序的代码之前，您必须将代码安装到开发系统并将应用程序安装到Android系统。应用程序的源代码和预编译的`.apk`包位于`chapter5.tgz`文件中，可以从Packt的网站下载。按照[第3章](part0024_split_000.html#page
    "第3章。使用GPIO处理输入和输出")中描述的相同过程下载并将应用程序添加到Eclipse ADT环境中，*使用GPIO处理输入和输出*和*第4章，使用I2C存储和检索数据*。
- en: The app's user interface
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序的用户界面
- en: The app uses a very simple UI to interact with the sensor. As it is so simple,
    the only activity that the app has (by default) is `MainActivity`. The UI consists
    of only one button and two text views.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序使用非常简单的UI与传感器进行交互。因为它非常简单，所以该应用程序默认只有一个活动`MainActivity`。UI仅包括一个按钮和两个文本视图。
- en: '![The app''s user interface](img/00026.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序的用户界面](img/00026.jpeg)'
- en: The sensor sample app screen prior to receiving its first set of samples from
    the sensor
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在从传感器接收其第一组样本之前的传感器样本应用程序屏幕
- en: The top text view has the `temperatureTextView` identifier in the `activity_main.xml`
    file, and the bottom text view has the `pressureTextView` identifier. These text
    views will display the temperature and pressure data that is retrieved from the
    sensor. The button with the **Sample** label has the `sampleButton` identifier.
    This button has an `onClick()` method called `onClickSampleButton()` that triggers
    the process of interfacing with the sensor to sample the temperature and pressure
    data and then updating the text displayed in the `temperatureTextView` and `pressureTextView`
    text views.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部文本视图在`activity_main.xml`文件中具有`temperatureTextView`标识符，底部文本视图具有`pressureTextView`标识符。这些文本视图将显示从传感器检索到的温度和压力数据。带有**Sample**标签的按钮具有`sampleButton`标识符。此按钮具有一个名为`onClickSampleButton()`的`onClick()`方法，触发与传感器进行接口以对温度和压力数据进行采样，然后更新`temperatureTextView`和`pressureTextView`文本视图中显示的文本的过程。
- en: Calling the PacktHAL sensor functions
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用PacktHAL传感器函数
- en: The sensor interface functionality in PacktHAL is implemented in a variety of
    C functions in the `jni/bmp183.c` file within the `sensor` app's project. These
    functions not only interface with the sensor, but they also do a variety of conversion
    and calibration tasks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PacktHAL中的传感器接口功能是在`sensor`应用程序项目的`jni/bmp183.c`文件中实现的各种C函数中。这些函数不仅与传感器进行接口，还执行各种转换和校准任务。
- en: The `fram` app in the previous chapter used a specific kernel driver (the `24c256`
    EEPROM driver) to interact with the FRAM chip, so the user-space-interfacing logic
    that is implemented in PacktHAL is quite simple. PacktHAL does not use a sensor-specific
    kernel driver to communicate with the sensor, so it must use the generic `spidev`
    driver to communicate. It is up to PacktHAL to prepare, send, receive, and interpret
    the individual bytes of every SPI message that is going to or from the sensor.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中的`fram`应用程序使用了特定的内核驱动程序（`24c256` EEPROM驱动程序）来与FRAM芯片交互，因此在PacktHAL中实现的用户空间接口逻辑非常简单。PacktHAL不使用特定于传感器的内核驱动程序进行通信，因此必须使用通用的`spidev`驱动程序进行通信。PacktHAL必须准备、发送、接收和解释每个要发送到传感器或从传感器接收的SPI消息的每个字节。
- en: 'While there are a number of functions in PacktHAL to handle these tasks, only
    four of those functions are used by outside code to interact with the sensor:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然PacktHAL中有许多函数来处理这些任务，但只有四个函数被外部代码用来与传感器交互：
- en: '`openSensor()`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`openSensor()`'
- en: '`getSensorTemperature()`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSensorTemperature()`'
- en: '`getSensorPressure()`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getSensorPressure()`'
- en: '`closeSensor()`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`closeSensor()`'
- en: 'The prototypes for these functions are located in the `jni/PacktHAL.h` header
    file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的原型位于`jni/PacktHAL.h`头文件中：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `openSensor()` function initializes access to the SPI bus by opening `/dev/spidev1.0`
    and making several `ioctl()` calls to configure the SPI bus' communication parameters
    (such as the clock rate of `SCLK`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`openSensor()`函数通过打开`/dev/spidev1.0`并进行几次`ioctl()`调用来初始化对SPI总线的访问，并配置SPI总线的通信参数（如`SCLK`的时钟速率）。'
- en: Once this configuration is performed, all SPI communications performed inside
    of PacktHAL will use this bus. Calling the counterpart `closeSensor()` function
    closes the `/dev/spidev1.0` file, which shuts down the SPI bus and frees it for
    use by other processes on the system. The `getSensorTemperature()` and `getSensorPressure()`
    functions perform all of the preparation of the SPI messages, SPI communication,
    and sample conversion logic required to fetch and convert the samples retrieved
    from the sensor.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 配置完成后，PacktHAL内部执行的所有SPI通信都将使用此总线。调用对应的`closeSensor()`函数将关闭`/dev/spidev1.0`文件，关闭SPI总线并释放其供系统上其他进程使用。`getSensorTemperature()`和`getSensorPressure()`函数执行了从传感器获取和转换样本所需的所有SPI消息准备、SPI通信和样本转换逻辑。
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you were using a specialized kernel driver designed to talk to the specific
    sensor that we are using, then the sensor-reading logic inside the PacktHAL code
    would be very simple (only one or two `ioctl()` calls). It is always a balance
    between placing HAL code logic into the kernel versus keeping it in user space.
    The more code that you can push into the kernel, the simpler and faster the user
    space code will be. However, it can be very difficult to develop kernel code,
    so you must strike a balance between what is easiest to implement and what will
    provide you with the performance necessary for your hardware design.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用专门设计用于与我们使用的特定传感器通信的专用内核驱动程序，那么PacktHAL代码内部的传感器读取逻辑将非常简单（只有一个或两个`ioctl()`调用）。将HAL代码逻辑放入内核与保留在用户空间之间始终存在平衡。您可以将更多代码推送到内核中，用户空间代码将更简单和更快。但是，开发内核代码可能非常困难，因此您必须在实现最容易的方法和为硬件设计提供所需性能之间取得平衡。
- en: The `sensor` app has several similarities to apps from previous chapters. Like
    the `fram` app from [Chapter 4](part0029_split_000.html#page "Chapter 4. Storing
    and Retrieving Data with I2C"), *Storing and Retrieving Data with I2C*, the sensor
    app uses its own class derived from `AsyncTask`, `HardwareTask`, to make JNI calls
    to the underlying sensor-interfacing functions from PacktHAL. Interfacing with
    the hardware is triggered by the `onClick()` handler of a button pressed by the
    app's user, similar to what both the `gpio` and `fram` apps do.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`sensor`应用程序与以前章节的应用程序有几个相似之处。与[第4章](part0029_split_000.html#page "Chapter 4. Storing
    and Retrieving Data with I2C")中的`fram`应用程序，*使用I2C存储和检索数据*类似，传感器应用程序使用其自己的从`AsyncTask`派生的类`HardwareTask`，以调用PacktHAL的底层传感器接口函数的JNI调用。通过应用程序用户按下的按钮的`onClick()`处理程序触发与硬件的接口，类似于`gpio`和`fram`应用程序的做法。'
- en: Much like the GPIO-interfacing functions from PacktHAL that you used in [Chapter
    3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs with GPIOs"),
    *Handling Inputs and Outputs with GPIOs* and *Chapter 4, Storing and Retrieving
    Data with I2C*, the sensor-interfacing methods in `HardwareTask` are very fast
    to execute. It is not actually necessary to execute these methods from within
    a separate thread since they are not likely to take so long to execute that they
    will trigger the ANR dialog. However, SPI can be used for a wide variety of devices,
    and it is possible to need longer periods of time to send large amounts of data,
    so better safe than sorry.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与您在[第3章](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs")中使用的PacktHAL的GPIO接口函数，*处理GPIO输入和输出*和*第4章，使用I2C存储和检索数据*中的GPIO接口函数类似，`HardwareTask`中的传感器接口方法执行非常快。实际上不需要从单独的线程中执行这些方法，因为它们不太可能花费太长时间来执行，以至于会触发ANR对话框。但是，SPI可以用于各种设备，并且可能需要更长的时间来发送大量数据，所以最好小心谨慎。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**When should I use an AsyncTask for hardware interfacing?**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时应该使用AsyncTask进行硬件接口？**'
- en: The short answer to this is "all of the time". We did not want to distract you
    with the details of the `AsyncTask` class when you were working with GPIOs in
    [Chapter 3](part0024_split_000.html#page "Chapter 3. Handling Inputs and Outputs
    with GPIOs"), *Handling Inputs and Outputs with GPIOs*, so the `gpio` app made
    method calls to PacktHAL functions in the `onClick()` button handlers. However,
    the general rule to follow is to always use `AsyncTask` to perform any sort of
    I/O. I/O is notoriously slow, so any I/O (networking, accessing files on disk,
    and hardware interfacing) should really take place in its own thread via `AsyncTask`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的答案是“始终如此”。在[第3章](part0024_split_000.html#page "Chapter 3. Handling Inputs
    and Outputs with GPIOs")中处理GPIO时，我们不希望在您工作时分散注意力，因此`gpio`应用程序在`onClick()`按钮处理程序中对PacktHAL函数进行了方法调用。但是，遵循的一般规则是始终使用`AsyncTask`执行任何类型的I/O。I/O通常很慢，因此任何I/O（网络，访问磁盘上的文件和硬件接口）都应该通过`AsyncTask`在自己的线程中进行。
- en: Using the HardwareTask class
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`HardwareTask`类
- en: 'Like the `gpio` and `fram` apps, the `HardwareTask` class in the sensor app
    provides four native methods that are used to call the PacktHAL JNI functions
    related to sensor hardware interfacing:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 与`gpio`和`fram`应用程序一样，传感器应用程序中的`HardwareTask`类提供了四个本机方法，用于调用与传感器硬件接口相关的PacktHAL
    JNI函数：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As the details of the SPI bus setup process are encapsulated within the PacktHAL
    functions and hidden from the app, these methods take no parameters. They simply
    call their PacktHAL counterparts via the PacktHAL JNI wrapper functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SPI总线设置过程的细节被封装在PacktHAL函数中并且对应用程序隐藏，因此这些方法不需要参数。它们只是通过PacktHAL JNI包装器函数调用它们的PacktHAL对应方法。
- en: '![Using the HardwareTask class](img/00027.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用`HardwareTask`类](img/00027.jpeg)'
- en: The thread contexts in which the `HardwareTask` methods and the PacktHAL functions
    are executed
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`HardwareTask`方法和PacktHAL函数执行的线程上下文'
- en: 'In the sensor app, the `onClick()` handler for the sample button in the `MainActivity`
    class instantiates a new `HardwareTask` method. Immediately after this instantiation,
    the `pollSensor()` method of `HardwareTask` is called to request a current set
    of temperature and pressure data from the sensor:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在传感器应用程序中，`MainActivity`类中示例按钮的`onClick()`处理程序实例化了一个新的`HardwareTask`方法。在此实例化之后，调用`HardwareTask`的`pollSensor()`方法请求传感器的当前温度和压力数据：
- en: '[PRE4]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `pollSensor()` method begins the hardware-interfacing process by calling
    the `execution()` method of the base `AsyncTask` class to create a new thread:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`pollSensor()`方法通过调用基本`AsyncTask`类的`execution()`方法开始硬件接口过程，以创建一个新线程：'
- en: '[PRE5]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `execute()` method of `AsyncTask` calls the `onPreExecute()` method that
    the `HardwareTask` uses to initialize the SPI bus via its `openSensor()` native
    method. The `sampleButton` method is also disabled for the duration of the thread
    to prevent the possibility of multiple threads trying to use the SPI bus to talk
    to the sensor simultaneously:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask`的`execute()`方法调用`HardwareTask`使用的`onPreExecute()`方法，通过其`openSensor()`本机方法初始化SPI总线。在线程的持续时间内，`sampleButton`方法也被禁用，以防止多个线程尝试同时使用SPI总线与传感器通信：'
- en: '[PRE6]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Once the `onPreExecute()` method finishes, the `AsyncTask` base class spins
    a new thread and executes the `doInBackground()` method within that thread. For
    the sensor app, this is the proper place to perform any SPI bus communication
    required to get the current temperature and pressure samples from the sensor.
    The `getSensorTemperature()` and `getSensorPressure()` native methods of the `HardwareTask`
    class fetch the latest samples from the sensor via the `getSensorTemperature()`
    and `getSensorPressure()` functions in PacktHAL:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`onPreExecute()`方法完成，`AsyncTask`基类将旋转一个新线程，并在该线程中执行`doInBackground()`方法。对于传感器应用程序，这是执行任何需要进行SPI总线通信以从传感器获取当前温度和压力样本的适当位置。`HardwareTask`类的`getSensorTemperature()`和`getSensorPressure()`本机方法通过PacktHAL中的`getSensorTemperature()`和`getSensorPressure()`函数从传感器获取最新样本：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After `doInBackground()` is complete, the `AsyncTask` thread terminates. This
    triggers the calling of `doPostExecute()` from the UI thread. Now, as the app
    has finished its SPI communication tasks and received the latest temperature and
    pressure values from the sensor, it is time to close the SPI connection. The `doPostExecute()`
    method closes the SPI bus using the `closeSensor()` native method of the `HardwareTask`
    class. The `doPostExecute()` method then alerts the `MainActivity` class of the
    new data received from the sensor via the `updateSensorData()`method, and it re-enables
    the **Sample** button of `MainActivity`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`doInBackground()`完成后，`AsyncTask`线程终止。这将触发从UI线程调用`doPostExecute()`。现在，由于应用程序已经完成了SPI通信任务，并从传感器接收到了最新的温度和压力值，是时候关闭SPI连接了。`doPostExecute()`方法使用`HardwareTask`类的`closeSensor()`本机方法关闭SPI总线。然后，`doPostExecute()`方法通过`updateSensorData()`方法通知`MainActivity`类从传感器接收到新数据，并重新启用`MainActivity`的**Sample**按钮：'
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `MainActivity` class'' `updateSensorData()` method is responsible for updating
    the displayed values in the `temperatureTextView` and `pressureTextView` text
    views to reflect the newest received sensor values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`类的`updateSensorData()`方法负责更新`temperatureTextView`和`pressureTextView`文本视图中显示的值，以反映最新接收到的传感器值：'
- en: '[PRE9]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this point, execution of the `sensor` app has returned to its idle state.
    If the user clicks on the **Sample** button once more, another `HardwareTask`
    instance is instantiated and the open-sample-close interaction cycle of the hardware
    will occur again.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`sensor`应用程序的执行已经返回到空闲状态。如果用户再次点击**Sample**按钮，将实例化另一个`HardwareTask`实例，并且硬件的打开-采样-关闭交互循环将再次发生。
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Are you ready for a challenge?**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**您准备好接受挑战了吗？**'
- en: Now that you have seen all of the pieces of the sensor app, why not change it
    to add some new functionality? For a challenge, try adding a counter that shows
    how many samples have been taken so far and the average temperature and pressure
    from all of the samples taken. We have provided one possible implementation of
    this in the `chapter5_challenge.tgz` file, which is available for download from
    Packt's website.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了传感器应用程序的所有部分，为什么不改变它以添加一些新功能呢？作为挑战，尝试添加一个计数器，显示到目前为止已经采集了多少样本以及所有样本的平均温度和压力。我们在`chapter5_challenge.tgz`文件中提供了一个可能的实现，可以从Packt的网站上下载。
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to the SPI bus. You constructed a circuit
    that connected an SPI pressure and temperature sensor breakout board to the BBB,
    and you learned about the portions of the PacktHAL `init.{ro.hardware}.rc` file's
    Device Tree overlay that are responsible for configuring and making the SPI bus
    and `spidev` device driver available for your app's use. The sensor app in this
    chapter demonstrated how complex tasks in the HAL can be hidden from the app using
    a small set of functions that hide the low-level details. These simplified PacktHAL
    function calls can be made from a class derived from `AsyncTask` to perform more
    complex interfacing tasks simply from within an app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了SPI总线。您构建了一个电路，将SPI压力和温度传感器断开板连接到BBB，您了解了PacktHAL `init.{ro.hardware}.rc`文件的设备树叠加的部分，这些部分负责配置和使SPI总线和`spidev`设备驱动程序可用于您的应用程序。本章中的传感器应用程序演示了如何使用一小组隐藏低级细节的函数来隐藏HAL中的复杂任务。这些简化的PacktHAL函数调用可以从一个从`AsyncTask`派生的类中进行，以便从应用程序中简单地执行更复杂的接口任务。
- en: In the next chapter, you will learn about combining GPIO, I2C, and SPI together
    into an app capable of providing a complete hardware solution that uses a long-lived
    hardware-interfacing thread.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何将GPIO、I2C和SPI结合到一个应用程序中，从而提供一个完整的硬件解决方案，使用一个长期运行的硬件接口线程。
