- en: '*Chapter 3*: Running Application Containers on Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*：在Kubernetes上运行应用程序容器'
- en: This chapter contains a comprehensive overview of the smallest Lego block that
    Kubernetes provides – the Pod. Included is an explanation of the PodSpec YAML
    format and possible configurations, and a quick discussion of how Kubernetes handles
    and schedules Pods. The Pod is the most basic way to run applications on Kubernetes
    and is used in all higher-order application controllers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了Kubernetes提供的最小的乐高积木块——Pod的全面概述。其中包括PodSpec YAML格式和可能的配置的解释，以及Kubernetes如何处理和调度Pod的简要讨论。Pod是在Kubernetes上运行应用程序的最基本方式，并且在所有高阶应用程序控制器中使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a Pod?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Pod？
- en: Namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: The Pod life cycle
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod的生命周期
- en: The Pod resource spec
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod资源规范
- en: Pod scheduling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pod调度
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool, along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods for getting up and running with Kubernetes
    quickly, and for instructions on how to install the `kubectl` tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行本章详细介绍的命令，您需要一台支持`kubectl`命令行工具的计算机，以及一个可用的Kubernetes集群。请参见[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)，*与Kubernetes通信*，了解快速启动和运行Kubernetes的几种方法，以及如何安装`kubectl`工具的说明。
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在书的GitHub存储库中找到以下链接：
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3)'
- en: What is a Pod?
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Pod？
- en: The Pod is the simplest compute resource in Kubernetes. It specifies one or
    more containers to be started and run by the Kubernetes scheduler on a node. Pods
    have many potential configurations and extensions but remain the most basic way
    to run applications on Kubernetes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是Kubernetes中最简单的计算资源。它指定一个或多个容器由Kubernetes调度程序在节点上启动和运行。Pod有许多潜在的配置和扩展，但仍然是在Kubernetes上运行应用程序的最基本方式。
- en: Important note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: A Pod by itself is not a very good way to run applications on Kubernetes. Pods
    should be treated like fdisposable things in order to take advantage of the true
    capabilities of a container orchestrator like Kubernetes. This means treating
    containers (and therefore Pods) like cattle, not pets. To really make use of containers
    and Kubernetes, applications should be run in self-healing, scalable groups. The
    Pod is the building block of these groups, and we'll get into how to configure
    applications this way in later chapters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单独一个Pod并不是在Kubernetes上运行应用程序的很好的方式。Pod应该被视为一次性的东西，以便充分利用像Kubernetes这样的容器编排器的真正能力。这意味着将容器（因此也是Pod）视为牲畜，而不是宠物。为了真正利用容器和Kubernetes，应用程序应该在自愈、可扩展的组中运行。Pod是这些组的构建块，我们将在后面的章节中讨论如何以这种方式配置应用程序。
- en: Implementing Pods
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Pod
- en: Pods are implemented using Linux isolation tenets such as groups and namespaces,
    and generally can be thought of as a logical host machine. Pods run one or more
    containers (which can be based on Docker, CRI-O, or other runtimes) and these
    containers can communicate with each other in the same ways that different processes
    on a VM can communicate.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Pod是使用Linux隔离原则（如组和命名空间）实现的，并且通常可以被视为逻辑主机。Pod运行一个或多个容器（可以基于Docker、CRI-O或其他运行时），这些容器可以以与VM上的不同进程通信的方式相互通信。
- en: In order for containers within two different Pods to communicate, they need
    to access the other Pod (and container) via its IP. By default, only containers
    running on the same Pod can use lower-level methods of communication, though it
    is possible to configure different Pods with the availability to talk to each
    other via host IPC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使两个不同Pod中的容器进行通信，它们需要通过IP访问另一个Pod（和容器）。默认情况下，只有运行在同一个Pod上的容器才能使用更低级别的通信方法，尽管可以配置不同的Pod以使它们能够通过主机IPC相互通信。
- en: Pod paradigms
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod范例
- en: 'At the most basic level, there are two types of Pods:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的层面上，有两种类型的Pods：
- en: Single-container Pods
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单容器Pods
- en: Multi-container Pods
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多容器Pods
- en: It is generally a best practice to include a single container per Pod. This
    approach allows you to scale the different parts of your application separately,
    and generally keeps things simple when it comes to creating a Pod that starts
    and runs without issues.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好的做法是每个Pod包含一个单独的容器。这种方法允许您分别扩展应用程序的不同部分，并且在创建一个可以启动和运行而不出现问题的Pod时通常会保持简单。
- en: 'Multi-container Pods, on the other hand, are more complex but can be useful
    in various circumstances:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，多容器Pods更复杂，但在各种情况下都可能很有用：
- en: If there are multiple parts of your application that run in separate containers
    but are tightly coupled, you can run them both inside the same Pod to make communication
    and filesystem access seamless.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的应用程序有多个部分运行在不同的容器中，但彼此之间紧密耦合，您可以将它们都运行在同一个Pod中，以使通信和文件系统访问无缝。
- en: When implementing the *sidecar* pattern, where utility containers are injected
    alongside your main application to handle logging, metrics, networking, or advanced
    functionality such as a Service Mesh (more on this in [*Chapter 14*](B14790_14_Final_PG_ePub.xhtml#_idTextAnchor307),
    *Service Meshes and Serverless*).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实施*侧车*模式时，实用程序容器被注入到主应用程序旁边，用于处理日志记录、度量、网络或高级功能，比如服务网格（更多信息请参阅[*第14章*](B14790_14_Final_PG_ePub.xhtml#_idTextAnchor307)，*服务网格和无服务器*）。
- en: 'The following diagram shows a common sidecar implementation:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了一个常见的侧车实现：
- en: '![Figure 3.1 – Common sidebar implementation](image/B14790_03_001.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 - 常见的侧边栏实现](image/B14790_03_001.jpg)'
- en: Figure 3.1 – Common sidebar implementation
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 常见的侧边栏实现
- en: 'In this example, we have a single Pod with two containers: our application
    container running a web server, and a logging application that pulls logs from
    our server Pod and forwards them to our logging infrastructure. This is a very
    applicable use of the sidecar pattern, though many log collectors work at the
    node level, not at the Pod level, so this is not a universal way of collecting
    logs from our app containers in Kubernetes.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个只有两个容器的Pod：我们的应用容器运行一个Web服务器，一个日志应用程序从我们的服务器Pod中拉取日志并将其转发到我们的日志基础设施。这是侧车模式非常适用的一个例子，尽管许多日志收集器在节点级别工作，而不是在Pod级别，所以这并不是在Kubernetes中从我们的应用容器收集日志的通用方式。
- en: Pod networking
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod网络
- en: As we just mentioned, Pods have their own IP addresses that can be used in inter-pod
    communication. Each Pod has an IP address as well as ports, which are shared among
    the containers running in a Pod if there is more than one container.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚才提到的，Pods有自己的IP地址，可以用于Pod间通信。每个Pod都有一个IP地址和端口，如果有多个容器运行在一个Pod中，这些端口是共享的。
- en: Within a Pod, as we mentioned before, containers can communicate without calling
    the wrapping Pod's IP – instead they can simply use localhost. This is because
    containers within a Pod share a network namespace – in essence, they communicate
    via the same *bridge*, which is implemented using a virtual network interface.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod内部，正如我们之前提到的，容器可以在不调用封装Pod的IP的情况下进行通信 - 相反，它们可以简单地使用localhost。这是因为Pod内的容器共享网络命名空间
    - 本质上，它们通过相同的*bridge*进行通信，这是使用虚拟网络接口实现的。
- en: Pod storage
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod存储
- en: Storage in Kubernetes is a large topic on its own, and we will review it in
    depth in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage
    on Kubernetes* – but for now, you can think of Pod storage as either persistent
    or non-persistent volumes attached to a Pod. Non-persistent volumes can be used
    by a Pod to store data or files depending on the type, but they are deleted when
    the Pod shuts down. Persistent-type volumes will remain past Pod shutdown and
    can even be used to share data between multiple Pods or applications.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的存储是一个独立的大主题，我们将在[*第7章*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166)中深入讨论它
    - 但现在，您可以将Pod存储视为附加到Pod的持久或非持久卷。非持久卷可以被Pod用于存储数据或文件，具体取决于类型，但它们在Pod关闭时会被删除。持久类型的卷将在Pod关闭后保留，并且甚至可以用于在多个Pod或应用程序之间共享数据。
- en: Before we can continue with our discussion of Pods, we will take a quick moment
    to discuss namespaces. Since we'll be working with `kubectl` commands during our
    work with Pods, it's important to know how namespaces tie into Kubernetes and
    `kubectl`, since it can be a big "gotcha."
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续讨论Pod之前，我们将花一点时间讨论命名空间。由于我们在处理Pod时将使用`kubectl`命令，了解命名空间如何与Kubernetes和`kubectl`相关联非常重要，因为这可能是一个重要的“坑”。
- en: Namespaces
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: We talked briefly about namespaces in the section on authorization in *Chapter
    1*, *Communicating with Kubernetes*, but we will reiterate and expand on their
    purpose here. Namespaces are a way to logically separate different areas within
    your cluster. A common use case is having a namespace per environment – one for
    dev, one for staging, one for production – all living inside the same cluster.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第1章*的*与Kubernetes通信*部分，我们简要讨论了命名空间，但在这里我们将重申并扩展它们的目的。命名空间是一种在集群中逻辑上分隔不同区域的方式。一个常见的用例是每个环境一个命名空间
    - 一个用于开发，一个用于暂存，一个用于生产 - 所有这些都存在于同一个集群中。
- en: As we mentioned in the *Authorization* section, it is possible to specify user
    permissions on a per-namespace basis – for instance, letting a user deploy new
    applications and resources to the `dev` namespace but not to production.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*授权*部分中提到的，可以按命名空间指定用户权限 - 例如，允许用户向`dev`命名空间部署新应用程序和资源，但不允许向生产环境部署。
- en: 'In your running cluster, you can see what namespaces exist by running `kubectl
    get namespaces` or `kubectl get ns`, which should result in the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行的集群中，您可以通过运行`kubectl get namespaces`或`kubectl get ns`来查看存在哪些命名空间，这应该会产生以下输出：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To create a namespace imperatively, you can simply run `kubectl create namespace
    staging`, or run `kubectl apply -f /path/to/file.yaml` with the following YAML
    resource spec:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下命令可以创建一个命名空间：`kubectl create namespace staging`，或者使用以下YAML资源规范运行`kubectl
    apply -f /path/to/file.yaml`：
- en: Staging-ns.yaml
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Staging-ns.yaml
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, a `Namespace` spec is very simple. Let's move on to something
    more complex – the PodSpec itself.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Namespace`规范非常简单。让我们继续讨论更复杂的内容 - PodSpec本身。
- en: The Pod life cycle
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod生命周期
- en: To quickly see which Pods are running in your cluster, you can run `kubectl
    get pods` or `kubectl get pods --all-namespaces` to get Pods in either the current
    namespace (defined by your `kubectl` context, or the default namespace if none
    is specified) or all namespaces, respectively.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速查看集群中正在运行的Pods，您可以运行`kubectl get pods`或`kubectl get pods --all-namespaces`来分别获取当前命名空间中的Pods（由您的`kubectl`上下文定义，如果未指定，则为默认命名空间）或所有命名空间中的Pods。
- en: 'The output of `kubectl get pods` looks like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl get pods`的输出如下：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, Pods have a `STATUS` value that tells us in which state the
    Pod currently is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Pod具有一个`STATUS`值，告诉我们Pod当前处于哪种状态。
- en: 'The values for Pod state are as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Pod状态的值如下：
- en: '**Running**: In the `Running` status, a Pod has successfully spun up its container(s)
    without any issues. If the Pod has a single container, and it''s in `Running`
    status, then the container has not completed or exited its process. It could also
    currently be restarting, which you can tell by checking the `READY` column. If,
    for instance, the `READY` value is `0/1`, that means that the container in the
    Pod is currently not passing health checks. This could be for a variety of reasons:
    the container could still be spinning up, a database connection could be non-functional,
    or some important configuration could be preventing the application process from
    starting.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**：在`运行`状态下，Pod已成功启动其容器，没有任何问题。如果Pod只有一个容器，并且处于`运行`状态，那么容器尚未完成或退出其进程。它也可能正在重新启动，您可以通过检查`READY`列来判断。例如，如果`READY`值为`0/1`，这意味着Pod中的容器当前未通过健康检查。这可能是由于各种原因：容器可能仍在启动，数据库连接可能无法正常工作，或者一些重要配置可能会阻止应用程序进程启动。'
- en: '**Succeeded**: If your Pod container(s) are set to run a command that can complete
    or exit (not a long-running command, such as starting a web server), the Pod will
    show the `Succeeded` state if those containers have completed their process command.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成功**：如果您的Pod容器设置为运行可以完成或退出的命令（不是长时间运行的命令，例如启动Web服务器），则如果这些容器已完成其进程命令，Pod将显示`成功`状态。'
- en: '**Pending**: `Pending` statuses designate that at least one container in the
    Pod is waiting for its image. This is likely because the container image is still
    being fetched from an external repository, or because the Pod itself is waiting
    to be scheduled by `kube-scheduler`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂起**：`挂起`状态表示Pod中至少有一个容器正在等待其镜像。这可能是因为容器镜像仍在从外部存储库获取，或者因为Pod本身正在等待被`kube-scheduler`调度。'
- en: '**Unknown**: The `Unknown` status means that Kubernetes cannot tell what state
    the Pod is actually in. This usually means that the node that the Pod lives on
    is experiencing some form of error. It may be out of disk space, disconnected
    from the rest of the cluster, or otherwise be encountering problems.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未知：`未知`状态表示Kubernetes无法确定Pod实际处于什么状态。这通常意味着Pod所在的节点遇到某种错误。可能是磁盘空间不足，与集群的其余部分断开连接，或者遇到其他问题。
- en: '**Failed**: In the `Failed` status, one or more of the containers in the Pod
    has terminated with a failure status. Additionally, the other containers in the
    Pod must have terminated in either success or failure. This can happen for a variety
    of reasons due to the cluster removing Pods or something inside the container
    application breaking the process.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**失败**：在`失败`状态下，Pod中的一个或多个容器以失败状态终止。此外，Pod中的其他容器必须以成功或失败的方式终止。这可能是由于集群删除Pods或容器应用程序内部的某些东西破坏了进程而发生的各种原因。'
- en: Understanding the Pod resource spec
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Pod资源规范
- en: Since the Pod resource spec is the first one we've really dug into, we will
    spend our time detailing the various parts of the YAML file and how they fit together.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Pod资源规范是我们真正深入研究的第一个资源规范，我们将花时间详细介绍YAML文件的各个部分以及它们如何配合。
- en: 'Let''s start things off with a fully spec''d-out Pod file, which we can then
    pick apart and review:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个完全规范的Pod文件开始，然后我们可以分解和审查它：
- en: Simple-pod.yaml
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Simple-pod.yaml
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This Pod YAML file is somewhat more complicated than the one that we looked
    at in the first chapter. It exposes some new Pod functionality that we will review
    shortly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Pod YAML文件比我们在第一章中看到的要复杂一些。它公开了一些新的Pod功能，我们将很快进行审查。
- en: API version
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API版本
- en: 'Let''s start at line 1: `apiVersion`. As we mentioned in [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*, `apiVersion` tells Kubernetes which version of
    the API to look at when creating and configuring your resource. Pods have been
    around for a long time in Kubernetes, so the PodSpec is solidified into API version
    `v1`. Other resource types may contain group names in addition to version names
    – for instance, a CronJob resource in Kubernetes uses `batch/v1beta1` `apiVersion`,
    while the Job resource uses the `batch/v1` `apiVersion`. In both of these, `batch`
    corresponds to the API group name.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第1行开始：`apiVersion`。正如我们在[*第1章*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016)中提到的，*与Kubernetes通信*，`apiVersion`
    告诉Kubernetes在创建和配置资源时应查看哪个API版本。Pod在Kubernetes中已经存在很长时间，因此PodSpec已经固定为API版本`v1`。其他资源类型可能除了版本名称外还包含组名
    - 例如，在Kubernetes中，CronJob资源使用`batch/v1beta1` `apiVersion`，而Job资源使用`batch/v1` `apiVersion`。在这两种情况下，`batch`
    对应于API组名。
- en: Kind
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kind
- en: The `kind` value corresponds to the actual name of the resource type in Kubernetes.
    In this case, we're trying to spec out a Pod, so that's what we put. The `kind`
    value is always in camel case, such as `Pod`, `ConfigMap`, `CronJob`, and so on.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`kind` 值对应于Kubernetes中资源类型的实际名称。在这种情况下，我们正在尝试规范一个Pod，所以这就是我们放置的内容。`kind` 值始终采用驼峰命名法，例如
    `Pod`、`ConfigMap`、`CronJob` 等。'
- en: Important note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: For a full list of `kind` values, check the official Kubernetes documentation
    at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/). New Kubernetes
    `kind` values are added in new releases so the ones reviewed in this book may
    not be an exhaustive list.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的`kind`值列表，请查看官方Kubernetes文档[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)。新的Kubernetes
    `kind` 值会在新版本中添加，因此本书中审查的内容可能不是详尽的列表。
- en: Metadata
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元数据
- en: Metadata is a top-level key that can have several different values underneath.
    First of all, `name` is the resource name, which is what the resource will display
    as via `kubectl` and what it is stored as in `etcd`. `namespace` corresponds to
    the namespace that the resource should be created in. If no namespace is specified
    in the YAML spec, the resource will be created in the `default` namespace – unless
    a namespace is specified in the `apply` or `create` commands.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据是一个顶级键，可以在其下具有几个不同的值。首先，`name` 是资源名称，这是资源通过`kubectl`显示的名称，也是在`etcd`中存储的名称。`namespace`
    对应于资源应该被创建在的命名空间。如果在YAML规范中未指定命名空间，则资源将被创建在`default`命名空间中 - 除非在`apply`或`create`命令中指定了命名空间。
- en: Next, `labels` are key-value pairs that are used to add metadata to a resource.
    `labels` are special compared to other metadata because they are used by default
    in Kubernetes native `selectors` to filter and select resources – but they can
    also be used for custom functionality.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`labels` 是用于向资源添加元数据的键值对。`labels` 与其他元数据相比是特殊的，因为它们默认用于Kubernetes本机`selectors`中，以过滤和选择资源
    - 但它们也可以用于自定义功能。
- en: 'Finally, the `metadata` block can play host to multiple `annotations` which,
    like `labels`, can be used by controllers and custom Kubernetes functionality
    to provide additional configuration and feature-specific data. In this PodSpec,
    we have several annotations specified in our metadata:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`metadata`块可以承载多个`annotations`，就像`labels`一样，可以被控制器和自定义Kubernetes功能用来提供额外的配置和特定功能的数据。在这个PodSpec中，我们在元数据中指定了几个注释：
- en: pod-with-annotations.yaml
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-annotations.yaml
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Generally, it is better to use `labels` for Kubernetes-specific functionality
    and selectors while using `annotations` for adding data or extension functionality
    – this is just a convention.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，最好使用`labels`来进行Kubernetes特定功能和选择器的配置，同时使用`annotations`来添加数据或扩展功能 - 这只是一种惯例。
- en: Spec
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规范
- en: '`spec` is the top-level key that contains the resource-specific configuration.
    In this case, since our `kind` value is `Pod`, we''ll add some configuration that
    is specific to our Pod. All further keys will be indented under this `spec` key
    and will represent our Pod configuration.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`spec`是包含特定于资源的配置的顶级键。在这种情况下，由于我们的`kind`值是`Pod`，我们将添加一些特定于我们的Pod的配置。所有进一步的键将缩进在这个`spec`键下，并将代表我们的Pod配置。'
- en: Containers
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器
- en: The `containers` key expects a list of one or more containers that will run
    within a Pod. Each container spec will expose its own configuration values, which
    are indented under the container list item in your resource YAML. We will review
    some of these configurations here, but for a full list, check the Kubernetes documentation
    ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`containers`键期望一个或多个容器的列表，这些容器将在一个Pod中运行。每个容器规范将公开其自己的配置值，这些配置值缩进在资源YAML中的容器列表项下。我们将在这里审查一些这些配置，但是要获取完整列表，请查看Kubernetes文档（[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)）。'
- en: Name
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 名称
- en: Inside a container spec, `name` pertains to what the container will be named
    within a Pod. Container names can be used to specifically access the logs of a
    particular container using the `kubectl logs` command, but we'll get to that later.
    For now, ensure you choose a clear name for each container in your Pod to make
    things easier when it comes to debugging.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器规范中，`name`指的是容器在Pod中的名称。容器名称可以用于使用`kubectl logs`命令特别访问特定容器的日志，但这部分我们以后再说。现在，请确保为Pod中的每个容器选择一个清晰的名称，以便在调试时更容易处理事情。
- en: Image
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像
- en: For each container, `image` is used to specify the name of the Docker (or other
    runtime) image that should be started within the Pod. Images will be pulled from
    the configured repository, which is the public Docker Hub by default, but can
    be a private repository as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个容器，`image`用于指定应在Pod中启动的Docker（或其他运行时）镜像的名称。默认情况下，图像将从配置的存储库中拉取，这是公共Docker
    Hub，但也可以是私有存储库。
- en: And that's it – that's all you need to specify a Pod and run it in Kubernetes.
    Everything from this point on in the `Pod` section falls under the *additional
    configuration* umbrella.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样 - 这就是你需要指定一个Pod并在Kubernetes中运行它的全部内容。从`Pod`部分开始的一切都属于*额外配置*的范畴。
- en: Pod resource specifications
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod资源规范
- en: Pods can be configured to have specific amounts of memory and compute allocated
    to them. This prevents particularly hungry applications from impacting cluster
    performance and can also help prevent memory leaks. There are two possible resources
    that can be specified – `cpu` and `memory`. For each of these, there are two different
    types of specifications, `Requests` and `Limits`, for a total of four possible
    resource specification keys.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Pod可以配置为具有分配给它们的特定内存和计算量。这可以防止特别耗费资源的应用程序影响集群性能，也可以帮助防止内存泄漏。可以指定两种可能的资源 - `cpu`和`memory`。对于每个资源，有两种不同类型的规范，`Requests`和`Limits`，总共有四个可能的资源规范键。
- en: Memory requests and limits can be configured with any typical memory number
    suffix, or its power-of-two equivalent – for instance, 50 Mi (mebibytes), 50 MB
    (megabytes), or 1 Gi (gibibytes).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存请求和限制可以使用任何典型的内存数字后缀进行配置，或者其二的幂等价 - 例如，50 Mi（mebibytes），50 MB（megabytes）或1
    Gi（gibibytes）。
- en: 'CPU requests and limits can be configured either by using `m` which corresponds
    to 1 milli-CPU, or by just using a decimal number. So `200m` is equivalent to
    `0.2`, which equals 20% or one fifth of a logical CPU. This quantity will be the
    same amount of compute power regardless of the number of cores. 1 CPU equals a
    virtual core in AWS or a core in GCP. Let''s look at how these resource requests
    and limits look in our YAML file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: CPU请求和限制可以通过使用`m`来配置，它对应于1毫CPU，或者只是使用一个小数。因此，`200m`等同于`0.2`，相当于20%或五分之一的逻辑CPU。无论核心数量如何，这个数量都将是相同的计算能力。1
    CPU等于AWS中的虚拟核心或GCP中的核心。让我们看看这些资源请求和限制在我们的YAML文件中是什么样子的：
- en: pod-with-resource-limits.yaml
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-resource-limits.yaml
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this `Pod`, we have a container running a Docker image that is specified
    with both requests and limits on `cpu` and `memory`. In this case, our container
    image name, `mydockername`, is a placeholder - but if you want to test the Pod
    resource limits in this example, you can use the busybox image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Pod`中，我们有一个运行Docker镜像的容器，该容器在`cpu`和`memory`上都指定了请求和限制。在这种情况下，我们的容器镜像名称`mydockername`是一个占位符
    - 但是如果您想在此示例中测试Pod资源限制，可以使用busybox镜像。
- en: Container start commands
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 容器启动命令
- en: 'When a container starts in a Kubernetes Pod, it runs the default start script
    for the container – for instance, the script specified in the Docker container
    spec. In order to override this functionality with different commands or additional
    arguments, you can provide the `command` and `args` keys. Let''s look at a container
    configured with a `start` command and some arguments:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器在Kubernetes Pod中启动时，它将运行容器的默认启动脚本 - 例如，在Docker容器规范中指定的脚本。为了使用不同的命令或附加参数覆盖此功能，您可以提供`command`和`args`键。让我们看一个配置了`start`命令和一些参数的容器：
- en: pod-with-start-command.yaml
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-start-command.yaml
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we specify a command as well as a list of arguments as an array
    of strings, separated with commas where spaces would be.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们指定了一个命令以及作为字符串数组的参数列表，用逗号分隔空格。
- en: Init containers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化容器
- en: '`init` containers are special containers within a Pod that start, run, and
    shut down before the normal Pod container(s) start.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`容器是Pod中特殊的容器，在正常Pod容器启动之前启动、运行和关闭。'
- en: '`init` containers can be used for many different use cases, such as initializing
    files before an application starts or ensuring that other applications or services
    are running before starting a Pod.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`init`容器可用于许多不同的用例，例如在应用程序启动之前初始化文件，或者确保其他应用程序或服务在启动Pod之前正在运行。'
- en: If multiple `init` containers are specified, they will run in order until all
    `init` containers have shut down. For this reason, `init` containers must run
    a script that completes and has an endpoint. If your `init` container script or
    application keeps running, the normal container(s) in your Pod will not start.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了多个`init`容器，它们将按顺序运行，直到所有`init`容器都关闭。因此，`init`容器必须运行一个完成并具有端点的脚本。如果您的`init`容器脚本或应用程序继续运行，Pod中的正常容器将不会启动。
- en: 'In the following Pod, the `init` container is running a loop to check that
    our `config-service` exists via `nslookup`. Once it sees that `config-service`
    is up, the script ends, which triggers our `my-app` app container to start:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的Pod中，`init`容器正在运行一个循环，通过`nslookup`检查我们的`config-service`是否存在。一旦它看到`config-service`已经启动，脚本就会结束，从而触发我们的`my-app`应用容器启动：
- en: pod-with-init-container.yaml
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-init-container.yaml
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Important note
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When an `init` container fails, Kubernetes will automatically restart the Pod,
    similar to the usual Pod startup functionality. This functionality can be changed
    by changing `restartPolicy` at the Pod level.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当`init`容器失败时，Kubernetes将自动重新启动Pod，类似于通常的Pod启动功能。可以通过在Pod级别更改`restartPolicy`来更改此功能。
- en: 'Here''s a diagram showing the typical Pod startup flow in Kubernetes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个显示Kubernetes中典型Pod启动流程的图表：
- en: '![Figure 3.2 – Init container flowchart](image/B14790_03_002.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2-初始化容器流程图](image/B14790_03_002.jpg)'
- en: Figure 3.2 – Init container flowchart
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2-初始化容器流程图
- en: 'If a Pod has more than one `initContainer`, they will be invoked sequentially.
    This is valuable for times where you set up `initContainers` with modular steps
    that must be executed in order. The following YAML shows this:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Pod有多个`initContainer`，它们将按顺序被调用。这对于那些设置了必须按顺序执行的模块化步骤的`initContainers`非常有价值。以下YAML显示了这一点：
- en: pod-with-multiple-init-containers.yaml
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-multiple-init-containers.yaml
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: For instance, in this `Pod` YAML file, the `step-1 init` container needs to
    succeed before `init-step-2` is invoked, and both need to show success before
    the `my-app` container will be started.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这个`Pod` YAML文件中，`step-1 init`容器需要在调用`init-step-2`之前成功，两者都需要在启动`my-app`容器之前显示成功。
- en: Introducing different types of probes in Kubernetes
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Kubernetes中引入不同类型的探针
- en: In order to know when a container (and therefore a Pod) has failed, Kubernetes
    needs to know how to test that the container is functioning. We do this by defining
    `probes`, which Kubernetes can run at a specified interval to determine whether
    the container is working.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了知道容器（因此也是Pod）何时失败，Kubernetes需要知道如何测试容器是否正常工作。我们通过定义`probes`来实现这一点，Kubernetes可以在指定的间隔运行这些`probes`，以确定容器是否正常工作。
- en: There are three types of probes that Kubernetes lets us configure – readiness,
    liveness, and startup.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes允许我们配置三种类型的探针-就绪、存活和启动。
- en: Readiness probes
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 就绪探针
- en: First off, readiness probes can be used to determine whether a container is
    ready to perform a function such as accepting traffic via HTTP. These probes are
    helpful in the beginning stages of a running application, where it may still be
    fetching the configuration, for instance, and not yet be ready to accept connections.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，就绪探针可用于确定容器是否准备好执行诸如通过HTTP接受流量之类的功能。这些探针在应用程序运行的初始阶段非常有帮助，例如，当应用程序可能仍在获取配置，尚未准备好接受连接时。
- en: 'Let''s take a look at what a Pod with a readiness probe configured looks like.
    What follows is a PodSpec with a readiness probe attached:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下配置了就绪探针的Pod是什么样子。接下来是一个附有就绪探针的PodSpec：
- en: pod-with-readiness-probe.yaml
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-readiness-probe.yaml
- en: '[PRE9]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: For starters, as you can see, probes are defined per container, not per Pod.
    Kubernetes will run all probes per container and use that to determine the total
    health of the Pod.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，正如您所看到的，探针是针对每个容器而不是每个Pod定义的。Kubernetes将对每个容器运行所有探针，并使用它来确定Pod的总体健康状况。
- en: Liveness probes
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 存活探针
- en: 'Liveness probes can be used to determine whether an application has failed
    for some reason (for instance, due to a memory error). For application containers
    that run a long time, liveness probes can come in handy as a method to help Kubernetes
    recycle old and broken Pods for new ones. Though probes in and of themselves won''t
    cause a container to restart, other Kubernetes resources and controllers will
    check the probe status and use it to restart Pods when necessary. Here is a PodSpec
    with a liveness probe definition attached to it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 存活探针可用于确定应用程序是否因某种原因（例如，由于内存错误）而失败。对于长时间运行的应用程序容器，存活探针可以作为一种方法，帮助Kubernetes回收旧的和损坏的Pod，以便创建新的Pod。虽然探针本身不会导致容器重新启动，但其他Kubernetes资源和控制器将检查探针状态，并在必要时使用它来重新启动Pod。以下是附有存活探针定义的PodSpec：
- en: pod-with-liveness-probe.yaml
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-liveness-probe.yaml
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, our liveness probe is specified in the same way as our readiness
    probe, with one addition – `failureThreshold`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们的活跃性探针与就绪性探针以相同的方式指定，只是增加了`failureThreshold`。
- en: The `failureThreshold` value will determine how many times Kubernetes will attempt
    the probe before taking action. For liveness probes, Kubernetes will restart the
    Pod once the `failureThreshold` is crossed. For readiness probes, Kubernetes will
    simply mark the Pod as `Not Ready`. The default value for this threshold is `3`,
    but it can be changed to any value greater than or equal to `1`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`failureThreshold`值将决定Kubernetes在采取行动之前尝试探测的次数。对于活跃性探针，一旦超过`failureThreshold`，Kubernetes将重新启动Pod。对于就绪性探针，Kubernetes将简单地标记Pod为`Not
    Ready`。此阈值的默认值为`3`，但可以更改为大于或等于`1`的任何值。'
- en: In this case, we are using the `exec` mechanism with our probe. We will review
    the various probe mechanisms available shortly.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用了`exec`机制进行探测。我们将很快审查可用的各种探测机制。
- en: Startup probes
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动探针
- en: 'Finally, startup probes are a special type of probe that will only run once,
    on container startup. Some (often older) applications will take a long time to
    start up in a container, so by providing some extra leeway when a container starts
    up the first time, you can prevent the liveness or readiness probes failing and
    causing a restart. Here''s a startup probe configured with our Pod:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，启动探针是一种特殊类型的探针，它只会在容器启动时运行一次。一些（通常是较旧的）应用程序在容器中启动需要很长时间，因此在容器第一次启动时提供一些额外的余地，可以防止活跃性或就绪性探针失败并导致重新启动。以下是配置了启动探针的Pod示例：
- en: pod-with-startup-probe.yaml
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-startup-probe.yaml
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Startup probes provide a benefit greater than simply extending the time between
    liveness or readiness probes – they allow Kubernetes to maintain a quick reaction
    time when addressing problems that happen after startup and (more importantly)
    to prevent slow-starting applications from restarting constantly. If your application
    takes many seconds or even a minute or two to start up, you will have a much easier
    time implementing a startup probe.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 启动探针提供的好处不仅仅是延长活跃性或就绪性探针之间的时间 - 它们允许Kubernetes在启动后处理问题时保持快速反应，并且（更重要的是）防止启动缓慢的应用程序不断重新启动。如果您的应用程序需要多秒甚至一两分钟才能启动，您将更容易实现启动探针。
- en: '`successThreshold` is just what it seems, the opposite side of the coin to
    `failureThreshold`. It specifies how many successes in a row are required before
    a container is marked `Ready`. For applications that can go up and down on startup
    before stabilizing (like some self-clustering applications), changing this value
    can be useful. The default is `1`, and for liveness probes the only possible value
    is `1`, but we can change the value for readiness and startup probes.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`successThreshold`就像它的名字一样，是`failureThreshold`的对立面。它指定在容器标记为`Ready`之前需要连续多少次成功。对于在启动时可能会上下波动然后稳定下来的应用程序（如一些自我集群应用程序），更改此值可能很有用。默认值为`1`，对于活跃性探针，唯一可能的值是`1`，但我们可以更改就绪性和启动探针的值。'
- en: Probe mechanism configuration
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探测机制配置
- en: 'There are multiple mechanisms to specify any of the three probes: `exec`, `httpGet`,
    and `tcpSocket`.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种机制可以指定这三种探针中的任何一种：`exec`、`httpGet`和`tcpSocket`。
- en: The `exec` method allows you to specify a command that will be run inside the
    container. A successfully executed command will result in a passed probe, while
    a command that fails will result in a fail on the probe. All the probes we've
    configured so far have used the `exec` method, so configuration should be self-evident.
    If the chosen command (with any arguments specified in comma-separated list form)
    fails, the probe will fail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`方法允许您指定在容器内运行的命令。成功执行的命令将导致探测通过，而失败的命令将导致探测失败。到目前为止，我们配置的所有探针都使用了`exec`方法，因此配置应该是不言自明的。如果所选命令（以逗号分隔的列表形式指定的任何参数）失败，探测将失败。'
- en: The `httpGet` method for probes allows you to specify a URL on the container
    that will be hit with an HTTP `GET` request. If the HTTP request returns a code
    anywhere between `200` to `400`, it will result in a success on the probe. Any
    other HTTP code will result in a failure.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpGet`方法允许您为探针指定容器上的URL，该URL将受到HTTP `GET`请求的访问。如果HTTP请求返回的代码在`200`到`400`之间，它将导致探测成功。任何其他HTTP代码将导致失败。'
- en: 'The configuration for `httpGet` looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`httpGet`的配置如下：'
- en: pod-with-get-probe.yaml
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-get-probe.yaml
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Finally, the `tcpSocket` method will try to open the specified socket on the
    container and will use the result to dictate a success or failure. The `tcpSocket`
    configuration looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`tcpSocket`方法将尝试在容器上打开指定的套接字，并使用结果来决定成功或失败。`tcpSocket`配置如下：
- en: pod-with-tcp-probe.yaml
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: pod-with-tcp-probe.yaml
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this type of probe takes in a port, which will be pinged every
    time the check occurs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这种类型的探针接收一个端口，每次检查发生时都会对其进行ping测试。
- en: Common Pod transitions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见的Pod转换
- en: 'Failing Pods in Kubernetes tend to transition between statuses quite a bit.
    For a first-time user, this can be intimidating, so it is valuable to break down
    how the Pod statuses we listed earlier interact with probe functionality. Just
    to reiterate, here are our statuses:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的失败Pod往往在不同状态之间转换。对于初次使用者来说，这可能会令人生畏，因此将我们之前列出的Pod状态与探针功能相互作用进行分解是很有价值的。再次强调一下，这是我们的状态：
- en: '`Running`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Running`'
- en: '`Succeeded`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Succeeded`'
- en: '`Pending`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Pending`'
- en: '`Unknown`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unknown`'
- en: '`Failed`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Failed`'
- en: A common flow is to run `kubectl get pods -w` (the `-w` flag adds a watch to
    the command) and see offending Pods transitioning between `Pending` and `Failed`.
    Typically, what is occurring is that the Pods (and their containers) are spinning
    up and pulling images – which is the `Pending` state since the health checks have
    not yet started.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的流程是运行`kubectl get pods -w`（`-w`标志会在命令中添加一个监视器），然后查看有问题的Pod在`Pending`和`Failed`之间的转换。通常情况下，发生的是Pod（及其容器）正在启动和拉取镜像
    - 这是`Pending`状态，因为健康检查尚未开始。
- en: Once the initial probe timeout (which as we saw in the previous section is configurable)
    elapses, the first probe fails. This can continue for seconds or even minutes
    depending on how high the failure threshold is, with the status still pinned at
    `Pending`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦初始探测超时（正如我们在前一节中看到的那样，这是可配置的），第一个探测失败。这可能会持续几秒甚至几分钟，具体取决于失败阈值的高低，状态仍然固定在`Pending`。
- en: Finally, our failure threshold is reached, and our Pod status transitions to
    `Failed`. At this point, one of two things can happen, and the decision is based
    purely on the `RestartPolicy` on the PodSpec, which can either be `Always`, `Never`,
    or `OnFailure`. If a Pod fails and the `restartPolicy` is `Never`, the Pod will
    stay in the failed status. If it is one of the other two options, the Pod will
    restart automatically, and go back to `Pending`, which is the root cause of our
    never-ending transition cycle.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的失败阈值达到，我们的Pod状态转换为`Failed`。在这一点上，有两种情况可能发生，决定纯粹基于PodSpec上的`RestartPolicy`，它可以是`Always`、`Never`或`OnFailure`。如果一个Pod失败并且`restartPolicy`是`Never`，那么Pod将保持在失败状态。如果是其他两个选项之一，Pod将自动重新启动，并返回到`Pending`，这是我们永无止境的转换循环的根本原因。
- en: For a different example, you may see Pods stuck forever in the `Pending` status.
    This can be due to the Pod failing to be scheduled on any node. This could be
    due to resource request constraints (which we will cover in depth later in this
    book, in [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186), *Pod Placement
    Controls*), or other issues such as nodes being unreachable.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 举个不同的例子，您可能会看到Pod永远停留在`Pending`状态。这可能是由于Pod无法被调度到任何节点。这可能是由于资源请求约束（我们将在本书的后面深入讨论，[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)，*Pod放置控件*），或其他问题，比如节点无法访问。
- en: Finally, with `Unknown`, typically the node that the Pod is scheduled on is
    unreachable for some reason – the node might have shut down, for instance, or
    is unreachable via the network.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`Unknown`，通常Pod被调度的节点由于某种原因无法访问 - 例如，节点可能已关闭，或者通过网络无法访问。
- en: Pod scheduling
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pod调度
- en: The complexities of Pod scheduling and the ways the Kubernetes lets you influence
    and control it will be saved for our [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls* – but for now we will review the basics.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Pod调度的复杂性以及Kubernetes让您影响和控制它的方式将保存在我们的[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中，*Pod放置控件*
    - 但现在我们将回顾基础知识。
- en: When deciding where to schedule a Pod, Kubernetes takes many factors into account,
    but the most important to consider (when not delving into the more complex controls
    that Kubernetes lets us use) are Pod priority, node availability, and resource
    availability.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定在哪里调度一个Pod时，Kubernetes考虑了许多因素，但最重要的是考虑（当不深入研究Kubernetes让我们使用的更复杂的控件时）Pod优先级、节点可用性和资源可用性。
- en: The Kubernetes scheduler operates a constant control loop that monitors the
    cluster for unbound (unscheduled) Pods. If one or more unbound Pods is found,
    the scheduler will use the Pod priority to decide which one to schedule first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes调度程序操作一个不断的控制循环，监视集群中未绑定（未调度）的Pod。如果找到一个或多个未绑定的Pod，调度程序将使用Pod优先级来决定首先调度哪一个。
- en: Once the scheduler has decided on a Pod to schedule, it will perform several
    rounds and types of checks in order to find the local optima of a node for where
    to schedule the Pod. The latter rounds of checks are dictated by granular scheduling
    controls, which we'll get into in the [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*. We'll worry about the first couple of checks for now.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调度程序决定要调度一个Pod，它将执行几轮和类型的检查，以找到调度Pod的节点的局部最优解。后面的检查由细粒度的调度控件决定，我们将在[*第8章*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186)中详细介绍*Pod放置控件*。现在我们只关心前几轮的检查。
- en: First, Kubernetes checks to see which nodes are even schedulable at the current
    moment. Nodes may be non-functioning or otherwise encountering issues that would
    prevent new Pods from being scheduled.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Kubernetes检查当前时刻哪些节点可以被调度。节点可能无法正常工作，或者遇到其他问题，这将阻止新的Pod被调度。
- en: Secondly, Kubernetes filters schedulable nodes by checking to see which of those
    nodes match the minimum resource requirement stated in the PodSpec.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，Kubernetes 通过检查哪些节点与 PodSpec 中规定的最小资源需求匹配来过滤可调度的节点。
- en: At this point, in the absence of any other placement controls, the scheduler
    will make its decision and assign our new Pod to a node. When the `kubelet` on
    that node sees that it has a new Pod assigned to it, the Pod will be spun up.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有其他放置控制的情况下，调度器将做出决定并将新的 Pod 分配给一个节点。当该节点上的 `kubelet` 看到有一个新的 Pod 分配给它时，该
    Pod 将被启动。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned that Pods are the most basic building block we have
    to work with in Kubernetes. It's important to have a strong understanding of Pods
    and all their subtleties because all compute on Kubernetes uses Pods as a building
    block. It's probably pretty obvious by now, but Pods are very small, individual
    things that are not very sturdy. Running an application as a single Pod on Kubernetes
    with no controller is a bad decision, and any issue with your Pod will result
    in downtime.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解到 Pod 是我们在 Kubernetes 中使用的最基本的构建块。对 Pod 及其所有微妙之处有深入的理解非常重要，因为在 Kubernetes
    上的所有计算都使用 Pod 作为构建块。现在可能很明显了，但 Pod 是非常小的、独立的东西，不太牢固。在 Kubernetes 上以单个 Pod 运行应用程序而没有控制器是一个糟糕的决定，你的
    Pod 出现任何问题都会导致停机时间。
- en: In the next chapter, we'll see how to prevent this by using Pod controllers
    to run multiple replicas of an application at once.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何通过使用 Pod 控制器同时运行应用程序的多个副本来防止这种情况发生。
- en: Questions
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How could you use namespaces to separate application environments?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何使用命名空间来分隔应用程序环境？
- en: What is a possible reason for a Pod status to be listed as `Unknown`?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod 状态被列为 `Unknown` 的可能原因是什么？
- en: What could be a reason for constraining Pod memory resources?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制 Pod 内存资源的原因是什么？
- en: If an application running on Kubernetes often does not start in time before
    a failed probe restarts the Pod, which probe type should you tune? Readiness,
    liveness, or startup?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在 Kubernetes 上运行的应用程序经常在失败的探测重新启动 Pod 之前无法及时启动，你应该调整哪种探测类型？就绪性、存活性还是启动？
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Kubernetes 文档：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Kubernetes The Hard Way》：[https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)
