- en: '*Chapter 16*: Win and Lose Conditions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第16章*：赢和输的条件'
- en: Now that we have a basic gameplay experience, it's time to make the game end
    sometime, both in the cases of winning and losing. One common way to implement
    this is through separated components with the responsibility of overseeing a set
    of Objects to detect certain situations that need to happen, such as the Player
    life becoming 0 or all of the waves being cleared. We will implement this through
    the concept of Managers, components that will manage several Objects, monitoring
    them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经有了基本的游戏体验，现在是时候让游戏在某个时候结束，无论是赢还是输。一种常见的实现方法是通过分离的组件来监视一组对象，以检测需要发生的特定情况，比如玩家生命值变为0或者所有波次都被清除。我们将通过管理者的概念来实现这一点，管理者组件将管理多个对象并监控它们。
- en: 'In this chapter, we will examine the following Manager concepts:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究以下管理器概念：
- en: Creating Object Managers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: Creating Game Modes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: Improving our code with events
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件改进我们的代码
- en: With this knowledge, you will be able to not only create the victory and loose
    condition of the game, but also do that in a properly structured way using design
    patterns such as Singleton and Event Listeners. These skills are not only useful
    for creating the code for the winning and losing functions of the game, but any
    code in general.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你不仅能够创建游戏的胜利和失败条件，还能以正确的结构方式使用设计模式，比如单例和事件监听器。这些技能不仅对创建游戏的胜利和失败功能的代码有用，对任何代码都有用。
- en: Creating Object Managers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象管理器
- en: Not every Object in the scene should be something that can be seen, heard, or
    collided with. Some Objects can also exist with a conceptual meaning, not something
    tangible. Imagine you need to keep a count of the number of enemies, where do
    you save that? You also need someplace to save the current score of the Player,
    and you may be thinking it could be on the Player itself, but what happens if
    the Player dies and respawns? The data would be lost! In such scenarios, the concept
    of a Manager can be a useful way of solving this in our first games, so let's
    explore it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中并非每个对象都是可以看到、听到或碰撞的。有些对象也可以存在于概念上，而不是实体的东西。想象一下，你需要记录敌人的数量，你会把它保存在哪里？你还需要一个地方来保存玩家的当前分数，你可能会认为它可以保存在玩家身上，但如果玩家死亡并重生会发生什么？数据会丢失！在这种情况下，管理者的概念可以是解决我们的第一个游戏中的有用方式，所以让我们来探索一下。
- en: 'In this chapter, we are going to see the following Object Manager concepts:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到以下对象管理器的概念：
- en: Implementing the Singleton design pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现单例设计模式
- en: Creating Managers with Singleton
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用单例创建管理器
- en: We will start by discussing what the Singleton design pattern is and how it
    helps us simplify the communication of Objects. With it we will create Managers
    Objects, which will allow us to centralize information of a group of Objects,
    among other things. Let's start discussing the Singleton design pattern.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论单例设计模式是什么以及它如何帮助我们简化对象之间的通信开始。通过它，我们将创建管理者对象，这将允许我们集中一组对象的信息，等等。让我们开始讨论单例设计模式。
- en: Implementing the Singleton design pattern
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现单例设计模式
- en: Design patterns are usually described as common solutions to common problems.
    There are several coding design decisions you will have to make while you code
    your game, but luckily, the way to tackle the most common situations are well
    known and documented. In this section, we are going to discuss one of the most
    common design patterns, the Singleton, a very controversial but convenient one
    to implement in simple projects.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常被描述为常见问题的常见解决方案。在编写游戏代码时，你将不得不做出许多编码设计决策，但幸运的是，解决最常见情况的方法是众所周知和有文档记录的。在本节中，我们将讨论最常见的设计模式之一，即单例模式，这是一个非常有争议但在简单项目中实现起来非常方便的设计模式。
- en: A Singleton pattern is used when we need a single instance of an Object, meaning
    that there shouldn't be more than one instance of a class and that we want it
    to be easily accessible (not necessarily, but useful in our scenario). We have
    plenty of cases in our game where this can be applied, for example, `ScoreManager`,
    a component that will hold the current score. In this case, we will never have
    more than one score, so we can take advantage of the benefits of the Singleton
    Manager here.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要一个对象的单个实例时，就会使用单例模式，这意味着一个类不应该有多个实例，并且我们希望它易于访问（不一定，但在我们的场景中很有用）。在我们的游戏中有很多情况可以应用这个模式，例如`ScoreManager`，一个将保存当前分数的组件。在这种情况下，我们永远不会有多个分数，所以我们可以利用单例管理器的好处。
- en: One benefit is being sure that we won't have duplicated scores, which makes
    our code less error-prone. Also, so far, we have needed to create public references
    and drag Objects via the Editor to connect two Objects or look for them using
    `GetComponent`, but with this pattern, we will have global access to our Singleton
    component, meaning you can just write the name of the component and you will access
    it. In the end, there's just one `ScoreManager` component, so specifying which
    one via the Editor is redundant. This is similar to `Time.deltaTime`, the class
    responsible for managing time—we have just one time.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好处是确保我们不会有重复的分数，这使我们的代码更不容易出错。此外，到目前为止，我们需要创建公共引用并通过编辑器拖动对象来连接两个对象或使用`GetComponent`来查找它们，但是通过这种模式，我们将全局访问我们的单例组件，这意味着你只需写组件的名称，就可以访问它。最后，只有一个`ScoreManager`组件，因此通过编辑器指定它是多余的。这类似于`Time.deltaTime`，负责管理时间的类——我们只有一个时间。
- en: Important note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you are an advanced programmer, you may be thinking about code testing and
    dependency injection now, and you are right, but remember, we are trying to write
    simple code so far, so we will stick to this simple solution.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个高级程序员，现在可能会考虑代码测试和依赖注入，你是对的，但请记住，我们试图写简单的代码，所以我们将坚持这个简单的解决方案。
- en: 'Let''s create a Score Manager Object, responsible for handling the score, to
    show an example of a Singleton by doing the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个Score Manager对象，负责处理分数，以示例展示单例模式，具体操作如下：
- en: Create an empty GameObject (`ScoreManager`; usually, Managers are put in empty
    Objects, separated from the rest of the scene Objects.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的游戏对象（`ScoreManager`；通常，管理器会放在空对象中，与场景中的其他对象分开。
- en: Add a script called `ScoreManager` to this Object with an `int` field called
    `amount` that will hold the current score.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个对象上添加一个名为`ScoreManager`的脚本，其中包含一个名为`amount`的`int`字段，用于保存当前分数。
- en: Add a field of the `ScoreManager` type called `instance`, but add the `static`
    keyword to it; this will make the variable global, meaning it can be accessed
    anywhere by just writing its name:![Figure 16.1 – A static field that can be accessed
    anywhere in the code
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`instance`的`ScoreManager`类型字段，但在其前面加上`static`关键字；这将使变量成为全局变量，意味着可以通过简单地写出其名称在任何地方访问它：![图16.1
    – 可以在代码中任何地方访问的静态字段
- en: '](img/Figure_16.01_B14199.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.01_B14199.jpg)'
- en: Figure 16.1 – A static field that can be accessed anywhere in the code
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.1 – 可以在代码中任何地方访问的静态字段
- en: In `Awake`, check whether the `instance` field is not null, and in that case,
    set ourselves as the instance reference using the `this` reference.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，检查`instance`字段是否不为空，如果是，则使用`this`引用将自己设置为实例引用。
- en: In the `else` clause of the null checking `if` statement, print a message indicating
    that there's a second `ScoreManager` instance that must be destroyed:![Figure
    16.2 – Checking whether there's only one Singleton instance
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在空检查`if`语句的`else`子句中，打印一条消息，指示存在第二个`ScoreManager`实例必须被销毁：![图16.2 – 检查是否只有一个单例实例
- en: '](img/Figure_16.02_B14199.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.02_B14199.jpg)'
- en: Figure 16.2 – Checking whether there's only one Singleton instance
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.2 – 检查是否只有一个单例实例
- en: The idea is to save the reference to the only `ScoreManager` instance in the
    instance static field, but if by mistake the user creates two objects with the
    `ScoreManager` component, this `if` statement will detect it and inform the user
    of the error, asking them to take action. In this scenario, the first `ScoreManager`
    instance to execute `Awake` will find that there's no instance set (the field
    is null) so it will set itself as the current instance, while the second `ScoreManager`
    instance will find the instance is already set and will print the message. Remember
    that `instance` is a static field, the one shared between all classes, unlike
    regular reference fields, where each component will have its own reference, so
    in this case, we have two `ScoreManagers` added to the scene, and both will share
    the same instance field.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是将唯一的`ScoreManager`实例的引用保存在静态字段`instance`中，但如果用户错误地创建了两个带有`ScoreManager`组件的对象，这个`if`语句将会检测到并通知用户错误，并要求他们采取行动。在这种情况下，第一个`ScoreManager`实例执行`Awake`时会发现没有设置实例（字段为空），所以它会将自己设置为当前实例，而第二个`ScoreManager`实例会发现实例已经设置，并会打印消息。请记住，`instance`是一个静态字段，是所有类之间共享的字段，不同于常规引用字段，其中每个组件都有自己的引用，所以在这种情况下，我们在场景中添加了两个`ScoreManagers`，它们都将共享相同的实例字段。
- en: 'To improve the example a little bit, it would be ideal to have a simple way
    to find the second `ScoreManager` in the game. It will be hidden somewhere in
    the Hierarchy and it would be difficult to find. We can replace `print` with `Debug.Log`,
    which is basically the same but allows us to pass a second argument to the function,
    which is an Object, to highlight when the message is clicked in the console. In
    this case, we will pass the `gameObject` reference to allow the console to highlight
    the duplicated Object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了稍微改进示例，最好有一种简单的方法来找到游戏中的第二个`ScoreManager`。它将被隐藏在层次结构的某个地方，很难找到。我们可以用`Debug.Log`替换`print`，基本上是一样的，但允许我们向函数传递第二个参数，即一个对象，在控制台中点击消息时可以突出显示。在这种情况下，我们将传递`gameObject`引用，以允许控制台突出显示重复的对象：
- en: '![Figure 16.3 – Printing messages in the console with Debug.Log'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.3 – 使用Debug.Log在控制台中打印消息'
- en: '](img/Figure_16.03_B14199.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.03_B14199.jpg)'
- en: Figure 16.3 – Printing messages in the console with Debug.Log
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.3 – 使用Debug.Log在控制台中打印消息
- en: After clicking the log message, this GameObject will be highlighted in the Hierarchy:![Figure
    16.4 – The highlighted Object after clicking the message
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击日志消息后，此游戏对象将在层次结构中突出显示：![图16.4 – 点击消息后突出显示的对象
- en: '](img/Figure_16.04_B14199.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.04_B14199.jpg)'
- en: Figure 16.4 – The highlighted Object after clicking the message
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.4 – 点击消息后突出显示的对象
- en: Finally, a little improvement can be made here by replacing `Debug.Log` with
    `Debug.LogError`, which will also print the message but with an error icon. In
    a real game, you will have lots of messages in the console, and highlighting the
    errors over the information messages will help us to identify them quickly:![Figure
    16.5 – Using LogError to print an error message
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以通过将`Debug.Log`替换为`Debug.LogError`来进行一些改进，这样也会打印消息，但会带有错误图标。在真实的游戏中，控制台中会有大量的消息，将错误消息突出显示在信息消息之上将有助于我们快速识别它们：![图16.5
    – 使用LogError打印错误消息
- en: '](img/Figure_16.05_B14199.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.05_B14199.jpg)'
- en: Figure 16.5 – Using LogError to print an error message
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.5 – 使用LogError打印错误消息
- en: 'Try the code and observe the error message in the console:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行代码并观察控制台中的错误消息：
- en: '![Figure 16.6 – An error message in the console'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.6 – 控制台中的错误消息'
- en: '](img/Figure_16.06_B14199.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.06_B14199.jpg)'
- en: Figure 16.6 – An error message in the console
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.6 – 控制台中的错误消息
- en: 'The next step would be to use this Singleton somewhere, so in this case, we
    will make the enemies give points when they are killed by doing the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是在某个地方使用这个单例模式，所以在这种情况下，我们将使敌人在被杀死时给予分数，具体操作如下：
- en: Add a script to the `Enemy` Prefab called `ScoreOnDeath` with an `int` field
    called `amount`, which will indicate the number of points the Enemy will give
    when killed. Remember to set the value to something other than 0 in the Editor
    for the Prefab.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给`Enemy`预制体添加一个名为`ScoreOnDeath`的脚本，其中包含一个名为`amount`的`int`字段，它将指示敌人被杀时将给出的积分数。记得在预制体的编辑器中将值设置为非0的值。
- en: Create the `OnDestroy` event function, which will be automatically called by
    Unity when this Object is destroyed; in our case, the Enemy:![Figure 16.7 – The
    OnDestroy event function
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`OnDestroy`事件函数，当这个对象被销毁时，Unity将自动调用它；在我们的情况下，是敌人：![图16.7 – OnDestroy事件函数
- en: '](img/Figure_16.07_B14199.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.07_B14199.jpg)'
- en: Figure 16.7 – The OnDestroy event function
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.7 – OnDestroy事件函数
- en: Important note
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Consider that the `OnDestroy` function is also called when we change scenes
    or the game is quitting, so in this scenario, maybe we will get points when changing
    scenes, which is not correct. So far, this is not a problem in our case, but later
    in this chapter, we will see a way to prevent this.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到`OnDestroy`函数在我们切换场景或游戏退出时也会被调用，所以在这种情况下，也许我们会在切换场景时得到积分，这是不正确的。到目前为止，在我们的情况下这不是问题，但是在本章的后面，我们将看到一种防止这种情况发生的方法。
- en: Access the Singleton reference in the `OnDestroy` function by writing `ScoreManager.instance`,
    and add the `amount` field of our script to the `amount` field of the Singleton
    to increase the score when an Enemy is killed:![Figure 16.8 – Full ScoreOnDeath
    component class contents
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写`ScoreManager.instance`在`OnDestroy`函数中访问单例引用，并将我们脚本的`amount`字段添加到单例的`amount`字段中，以增加在杀死敌人时的得分：![图16.8
    – 完整的ScoreOnDeath组件类内容
- en: '](img/Figure_16.08_B14199.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.08_B14199.jpg)'
- en: Figure 16.8 – Full ScoreOnDeath component class contents
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.8 – 完整的ScoreOnDeath组件类内容
- en: Select the `ScoreManager` in the hierarchy, hit play, and kill some enemies
    to see the score increase with every kill. Remember to set the amount field of
    the `ScoreOnDeath` component of the Prefab.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择`ScoreManager`，点击播放，杀死一些敌人，看到得分随着每次杀敌而增加。记得设置预制体的`ScoreOnDeath`组件的`amount`字段。
- en: As you can see, the Singleton simplified a lot the way to access `ScoreManager`
    and prevented us from having two versions of the same Object, which will help
    us to reduce errors in our code. Something to take into account is that now you
    will be tempted to just make everything a Singleton, such as the Player life or
    Player bullets and use it just to make your life easier to create gameplay such
    as power-ups, and while that will totally work, remember that your game will change,
    and I mean, change a lot; any real project will suffer that. Maybe today, the
    game will have just one Player, but maybe in the future, you will want to add
    a second Player or an AI companion, and you want the power-ups to affect them
    too, so if you abuse the Singleton pattern, you will have trouble handling those
    scenarios. Maybe the companion will try to get the pickup but the main Player
    will be healed instead!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，单例简化了访问`ScoreManager`的方式，并防止我们拥有两个相同对象的版本，这将有助于减少我们代码中的错误。需要注意的是，现在你可能会诱惑只是把所有东西都变成单例，比如玩家生命或玩家子弹，并且只是为了让你的生活更容易地创建游戏玩法，比如道具，虽然这样完全可行，但要记住你的游戏会改变，我的意思是，会有很多变化；任何真正的项目都会经历这些。也许今天，游戏只有一个玩家，但也许在未来，你会想要添加第二个玩家或一个AI伙伴，并且你希望道具也能影响到他们，所以如果你滥用单例模式，你将很难处理这些情况。也许伙伴会试图拿到道具，但主要玩家会被治愈！
- en: The point here is to try to use the pattern as few times as you can, in cases
    where you don't have any other way to solve the problem. To be honest, there are
    always ways to solve problems without Singleton, but they are a little bit more
    difficult to implement for beginners, so I prefer to simplify your life a little
    bit to keep you motivated. With enough practice, you will reach a point where
    you will be ready to improve your coding standards.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是尽量少地使用这种模式，只有在没有其他解决问题的办法时才使用。老实说，总是有办法可以解决问题而不使用单例，但对于初学者来说，这些方法实现起来可能会更加困难，所以我更倾向于简化一下你的生活，让你保持动力。通过足够的练习，你将达到一个可以提高编码标准的水平。
- en: Now that we know how to create Singletons, let's finish some other Managers
    that we will need later in the game.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何创建单例了，让我们完成一些游戏后期需要的其他管理器。
- en: Creating Managers with Singleton
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单例创建管理器
- en: Sometimes, we need a place to put together information about a group of similar
    Objects, for example, an Enemy Manager, to check the number of enemies and potentially
    access an array of them to iterate over them and do something, or maybe `MissionManager`,
    to have access to all of the active missions in our game. Again, these cases can
    be considered Singletons, single Objects that won't be repeated (in our current
    game design), so let's create the ones we will need in our game, that is, `EnemyManager`
    and `WaveManager`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们需要一个地方来整合一组类似的对象的信息，例如，一个敌人管理器，用来检查敌人的数量并可能访问它们的数组来迭代它们并执行某些操作，或者`MissionManager`，用来访问游戏中所有的活动任务。同样，这些情况可以被视为单例，即不会重复出现的单个对象（在我们当前的游戏设计中），所以让我们创建我们游戏中需要的那些，即`EnemyManager`和`WaveManager`。
- en: "In our game, `EnemyManager` and `WaveManager` will just be places to save an\
    \ array of references to the existent enemies and waves in our game, just as a\
    \ way to know the current amount of them. There are ways to search all Objects\
    \ of a certain type to calculate the count of them, but those functions are expensive\
    \ and not recommended to use unless you really know what you are doing. So, having\
    \ a Singleton with a separate updated list \Lof references to the target Object\
    \ type will require more code but will perform better. Also, as the game features\
    \ increase, these Managers will have more functionality and helper functions to\
    \ interact with those Objects."
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，“EnemyManager”和“WaveManager”只是保存游戏中现有敌人和波的引用数组的地方，只是一种了解它们当前数量的方式。有一些方法可以搜索特定类型的所有对象来计算它们的数量，但这些函数很昂贵，不建议使用，除非你真的知道自己在做什么。因此，具有一个单独更新的引用列表的单例，将需要更多的代码，但性能会更好。此外，随着游戏功能的增加，这些管理器将具有更多的功能和辅助函数来与这些对象交互。
- en: 'Let''s start with the enemies Manager by doing the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从敌人管理器开始，做以下操作：
- en: Add a script called `Enemy` to the Enemy Prefab; this will be the script that
    will connect this Object with `EnemyManager` in a moment.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为“Enemy”的脚本添加到敌人预制件中；这将是将此对象与“EnemyManager”连接的脚本。
- en: Create an empty `GameObject` called `EnemyManager` and add a script to it called
    `EnemiesManager`.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“EnemyManager”的空“GameObject”，并向其添加名为“EnemiesManager”的脚本。
- en: Create a `public` static field of the `EnemiesManager` type called `instance`
    inside the script and add the Singleton repetition check in `Awake` as we did
    in `ScoreManager`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在脚本内创建一个名为“instance”的“EnemiesManager”类型的公共静态字段，并在“Awake”中添加与“ScoreManager”中相同的单例重复检查。
- en: Create a public field of the `List<Enemy>` type called `enemies`:![Figure 16.9
    – List of Enemy components
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为“enemies”的“List<Enemy>”类型的公共字段：！[图16.9-敌人组件列表
- en: '](img/Figure_16.09_B14199.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.09_B14199.jpg)'
- en: Figure 16.9 – List of Enemy components
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.9-敌人组件列表
- en: A list in C# represents a dynamic array, an array capable of adding and removing
    Objects. You will see that you can add and remove elements to this list in the
    Editor, but keep the list empty; we will add enemies another way. Take into account
    that `List` is in the `System.Collections.Generic` namespace; you will find the
    `using` sentence at the beginning of our script. Also, consider that you can make
    the list private and expose it to the code via a getter instead of making it a
    public field; but as usual, we will make our code as simple as possible for now.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: C#中的列表表示动态数组，可以添加和删除对象的数组。您会发现您可以在编辑器中向此列表添加和删除元素，但保持列表为空；我们将以另一种方式添加敌人。请注意，“List”在“System.Collections.Generic”命名空间中；您将在我们的脚本开头找到“using”语句。此外，请考虑您可以将列表设置为私有，并通过getter将其暴露给代码，而不是将其设置为公共字段；但通常情况下，我们将尽可能简化我们的代码。
- en: Important note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that `List` is a class type, so it must be instantiated, but as this
    type has exposing support in the Editor, Unity will automatically instantiate
    it. You must use the new keyword to instantiate it in cases where you want a non-Editor-exposed
    list, such as a private one or a list in a regular non-component C# class.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，“List”是一个类类型，因此必须实例化，但由于此类型在编辑器中具有暴露支持，Unity将自动实例化它。在您想要一个非编辑器暴露的列表，例如私有列表或常规非组件C#类中的列表的情况下，您必须使用new关键字进行实例化。
- en: The C# list internally is implemented as an array. if you need a linked list,
    look at the `LinkedList` collection type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C#列表在内部实际上是作为数组实现的。如果需要链表，请查看“LinkedList”集合类型。
- en: In the `Start` function of the `Enemy` script, access the `EnemyManager` Singleton
    and using the `Add` function of the enemies list, add this Object to the list.
    This will "register" this Enemy as active in the Manager, so other Objects can
    access the Manager and check for the current enemies. The `Start` function is
    called after all of the `Awake` function calls, and this is important because
    we need to be sure that the `Awake` function of the Manager is executed prior
    to the `Start` function of the Enemy to ensure that there is a Manager set as
    the instance.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“Enemy”脚本的“Start”函数中，访问“EnemyManager”单例，并使用敌人列表的“Add”函数，将此对象添加到列表中。这将在管理器中“注册”此敌人为活动状态，以便其他对象可以访问管理器并检查当前的敌人。
    “Start”函数在所有“Awake”函数调用之后调用，这很重要，因为我们需要确保在敌人的“Start”函数之前执行管理器的“Awake”函数，以确保有一个管理器设置为实例。
- en: Important Note
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The problem we solved with the `Start` function is called a race condition,
    that is, when two pieces of code are not guaranteed to be executed in the same
    order, whereas `Awake` execution order can change due to different reasons. There
    are plenty of situations in code where this will happen, so pay attention to the
    possible race conditions in your code. Also, you might consider using more advanced
    solutions such as lazy initialization here, which can give you better stability,
    but again, for the sake of simplicity and exploring the Unity API, we will use
    the `Start` function approach for now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过“Start”函数解决的问题称为竞争条件，即两段代码不能保证以相同的顺序执行，而“Awake”执行顺序可能会因不同原因而改变。代码中有很多情况会发生这种情况，因此请注意代码中可能出现的竞争条件。此外，您可能考虑在这里使用更高级的解决方案，例如延迟初始化，这可以为您提供更好的稳定性，但出于简单起见并探索Unity
    API，我们现在将使用“Start”函数方法。
- en: 'In the `OnDestroy` function, remove the Enemy from the list to keep the list
    updated with just the active ones:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“OnDestroy”函数中，从列表中移除敌人，以保持列表中只有活动的敌人：
- en: '![Figure 16.10 – The Enemy script to register ourselves as an active Enemy'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ！[图16.10-注册自己为活动敌人的敌人脚本
- en: '](img/Figure_16.10_B14199.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.10_B14199.jpg)'
- en: Figure 16.10 – The Enemy script to register ourselves as an active Enemy
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.10-注册自己为活动敌人的敌人脚本
- en: 'With this, now we have a centralized place to access all of the active enemies
    in a simple but efficient way. I challenge you to do the same with the waves,
    using `WaveManager`, which will have the collection of all active Waves to later
    check whether all waves finished their work to consider the game as won. Take
    some time to solve this; you will find the solution in the following screenshots,
    starting with `WavesManager`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，现在我们有了一个集中的地方以简单而有效的方式访问所有活动的敌人。我向你挑战，用“WaveManager”做同样的事情，它将拥有所有活动波的集合，以后检查所有波是否完成工作以考虑游戏是否获胜。花点时间解决这个问题；你将在以下截图中找到解决方案，从“WavesManager”开始：
- en: '![Figure 16.11 – The full WavesManager script'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.11 - 完整的WavesManager脚本'
- en: '](img/Figure_16.11_B14199.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.11_B14199.jpg)'
- en: Figure 16.11 – The full WavesManager script
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.11 - 完整的WavesManager脚本
- en: 'You will need also the `WavesSpawner` script:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要“WavesSpawner”脚本：
- en: '![Figure 16.12 – The modified WaveSpawner script to support WavesManager'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.12 - 修改后的WaveSpawner脚本以支持WavesManager'
- en: '](img/Figure_16.12_B14199.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.12_B14199.jpg)'
- en: Figure 16.12 – The modified WaveSpawner script to support WavesManager
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.12 - 修改后的WaveSpawner脚本以支持WavesManager
- en: As you can see, `WaveManager` is created the same way `EnemyManager` was, just
    a Singleton with a list of `WaveSpawner` references, but `WaveSpawner` is different.
    We execute the `Add` function of the list in the `Start` event of `WaveSpawner`
    to register the wave as an active one, but the `Remove` function needs more work.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，“WaveManager”的创建方式与“EnemyManager”相同，只是一个具有“WaveSpawner”引用列表的单例，但“WaveSpawner”是不同的。我们在“WaveSpawner”的“Start”事件中执行列表的“Add”函数，将波注册为活动波，但“Remove”函数需要更多的工作。
- en: The idea is to deregister the wave from the active waves list when it finishes
    spawning all enemies when the spawner finishes its work. Before this modification,
    we used `Invoke` to call the `CancelIncoke` function after a while to stop the
    spawning, but now we need to do more after the end time. Instead of calling `CancelInvoke`
    after the specified wave end time, we will call a custom function called `EndSpawner`,
    which will call `CancelInvoke` to stop the spawner, `Invoke Repeating`, but also
    will call `Remove` from `WavesManager` list function to make sure the removing
    from the list is called exactly when `WaveSpawner` finishes its work.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法是在生成器完成其工作后，当波完成生成所有敌人时，从活动波列表中注销该波。在进行这种修改之前，我们使用“Invoke”在一段时间后调用“CancelInvoke”函数来停止生成，但现在在结束时间之后我们需要做更多的事情。我们将在指定的波结束时间后调用“CancelInvoke”，而是调用一个名为“EndSpawner”的自定义函数，它将调用“CancelInvoke”来停止生成器，“Invoke
    Repeating”，但也将调用“WavesManager”列表中的“Remove”函数，以确保在“WaveSpawner”完成其工作时确切地调用从列表中移除。
- en: Using Object Managers, we have now centralized information about a group of
    Objects, and we can add all sorts of Objects group logic here, but besides having
    this information for updating the UI (which we will do in the next chapter), we
    can use this information to detect whether the Victory and Lose conditions of
    our game are met, creating a Game Mode Object to detect that.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对象管理器，我们现在集中了关于一组对象的信息，并且可以在这里添加各种对象组逻辑，但除了拥有这些信息以更新UI（我们将在下一章中进行），我们还可以使用这些信息来检测我们游戏的胜利和失败条件是否满足，创建一个游戏模式对象来检测这一点。
- en: Creating Game Modes
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建游戏模式
- en: We have created Objects to simulate lots of gameplay aspects of our game, but
    the game needs to end sometime, whether we win or lose. As always, the question
    is where to put this logic and that leads us to further questions. The main questions
    would be, will we always win or lose the game the same way? Will we have a special
    level with different criteria than to kill all of the waves, such as a timed survival?
    Only you know the answer to those questions, but if right now the answer is no,
    it doesn't mean that it won't change later, so it is advisable to prepare our
    code to adapt seamlessly to changes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了对象来模拟游戏中许多方面的玩法，但游戏总归需要在某个时候结束，无论是赢还是输。就像往常一样，问题是在哪里放置这个逻辑，这导致了更多的问题。主要问题是，我们是否总是以相同的方式赢得或输掉游戏？我们是否会有一个特殊的级别，其标准不同于杀死所有波，比如定时生存？只有你知道这些问题的答案，但如果现在的答案是否定的，这并不意味着以后不会改变，因此最好是准备我们的代码以无缝适应变化。
- en: Important note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To be honest, preparing our code to adapt seamlessly to changes is almost impossible;
    there's no way to have perfect code that will consider every possible case, and
    we will always need to rewrite some code sooner or later. We will try to make
    the code as adaptable as possible to changes; always doing that doesn't consume
    lots of developing time and it's sometimes preferable to write simple code fast
    then complex code slow that might not be necessary, and so balance your time budget
    wisely.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 老实说，让我们的代码无缝适应变化几乎是不可能的；没有办法编写完美的代码来考虑每种可能的情况，我们总是需要迟早重写一些代码。我们将尽量使代码尽可能适应变化；总是这样做并不会消耗大量的开发时间，有时快速编写简单的代码比缓慢编写复杂的代码更可取，而且可能并不必要，因此明智地平衡你的时间预算。
- en: To do this, we will separate the Victory and Lose conditions logic in its own
    Object, which I like to call the "Game Mode" (not necessarily an industry standard).
    This will be a component that will oversee the game, checking conditions that
    need to be met in order to consider the game over. It will be like the referee
    of our game. The Game Mode will constantly check the information in the Object
    Managers and maybe other sources of information to detect the needed conditions.
    Having this Object separated from other Objects allows us to create different
    levels with different Game Modes; just use another Game Mode script in that level
    and that's all.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将胜利和失败条件的逻辑分离到自己的对象中，我喜欢称之为“游戏模式”（不一定是行业标准）。这将是一个组件，将监督游戏，检查需要满足的条件以考虑游戏结束。它将像我们游戏的裁判一样。游戏模式将不断检查对象管理器中的信息，也许还有其他信息来源，以检测所需的条件。将这个对象与其他对象分离允许我们创建具有不同游戏模式的不同级别；只需在该级别中使用另一个游戏模式脚本，就可以了。
- en: 'In our case, we will have a single Game Mode for now, which will check whether
    the number of waves and enemies becomes 0, meaning that we have killed all of
    the possible enemies and the game is won. Also, it will check whether the life
    of the Player reaches 0, considering the game as lost in that situation. Let''s
    create it by doing the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，目前我们将只有一个游戏模式，它将检查波次和敌人的数量是否变为0，这意味着我们已经杀死了所有可能的敌人并且游戏获胜。此外，它还将检查玩家的生命值是否达到0，在这种情况下认为游戏失败。让我们通过以下方式创建它：
- en: Create a `GameMode` empty Object and add a `WavesGameMode` script to it. As
    you can see, we called the script with a descriptive name considering that we
    can add other game modes.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`GameMode`空对象，并向其添加一个`WavesGameMode`脚本。正如您所看到的，我们使用了一个描述性的名称来命名脚本，考虑到我们可以添加其他游戏模式。
- en: In its `Update` function, check whether the number of enemies and waves reached
    `0` by using the Enemy and Wave Managers; in that case, just `print` a message
    in the console for now. All lists have a `Count` property, which will tell you
    the number of elements stored inside.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`Update`函数中，使用敌人和波次管理器检查敌人和波次的数量是否达到了`0`；在这种情况下，目前只需在控制台中`print`一条消息。所有列表都有一个`Count`属性，它将告诉您存储在其中的元素数量。
- en: Add a `public` field of the `Life` type called `PlayerLife` and drag the Player
    to that one; the idea is to also detect the lose condition here.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`PlayerLife`的`Life`类型的`public`字段，并将玩家拖放到其中；这样也可以检测失败条件。
- en: In `Update`, add another check to detect whether the life amount of the `PlayerLife`
    reference has reached `0`, and in that case, `print` a lose message in the console:![Figure
    16.13 – Win and lose condition checks in WavesGameMode
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update`中，添加另一个检查，以检测`PlayerLife`引用的生命值是否达到了`0`，如果是，就在控制台中`print`一个失败消息：![图16.13
    - 在WavesGameMode中检查胜利和失败条件
- en: '](img/Figure_16.13_B14199.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.13_B14199.jpg)'
- en: Figure 16.13 – Win and lose condition checks in WavesGameMode
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.13 - 在WavesGameMode中检查胜利和失败条件
- en: Play the game and test both cases, whether the Player life reaches 0 or whether
    you have killed all enemies and waves.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏并测试两种情况，即玩家生命值是否达到0或者您是否已经杀死了所有敌人和波次。
- en: Important note
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Remember that we don't want two instances of this Object, so we can make it
    a Singleton also, but as this Object won't be accessed by others, that might be
    redundant; I will leave this up to you. Anyway, remember that this won't prevent
    you from having two different `GameModes` instantiated; for doing so, you can
    create a `GameMode` base class, with the Singleton functionality ready to prevent
    two `GameModes` in the same scene.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们不希望有两个此对象的实例，因此我们也可以将其设置为单例，但由于其他对象不会访问此对象，这可能是多余的；我会把这个决定留给您。无论如何，请记住，这不会阻止您实例化两个不同的`GameModes`；为此，您可以创建一个`GameMode`基类，其中包含单例功能，以防止在同一场景中出现两个`GameModes`。
- en: 'Now, it is time to replace the messages with something more interesting. For
    now, we will just change the current scene to a Win scene and Lose scene, which
    will only have a UI with a win and lose message and a button to play again. In
    the future, you can add a Main Menu scene and have an option to get back to it.
    Let''s do that by doing the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候用更有趣的东西替换这些消息了。目前，我们只会将当前场景更改为一个胜利场景和失败场景，它们只会有一个带有胜利和失败消息以及一个再玩一次按钮的UI。将来，您可以添加一个主菜单场景，并提供返回选项。让我们通过以下方式做到这一点：
- en: Create a new scene (`WinScreen`.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新场景（`WinScreen`）。
- en: Add a UI Text and center it with the text, `You won!`.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个UI文本，并将其与文本居中，写上“你赢了！”。
- en: Add a UI Button right below the text and change its text to `Play Again`:![Figure
    16.14 – WinScreen
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本下方添加一个UI按钮，并将其文本更改为“再玩一次”：![图16.14 - WinScreen
- en: '](img/Figure_16.14_B14199.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.14_B14199.jpg)'
- en: Figure 16.14 – WinScreen
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.14 - WinScreen
- en: Select the Scene in the Project View and press *Ctrl* + *D* (*Cmd* + *D* on
    Mac) to duplicate the scene. Rename it `LoseScreen`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中选择场景，按*Ctrl* + *D*（Mac上为*Cmd* + *D*）来复制场景。将其重命名为`LoseScreen`。
- en: Double-click the `LoseScreen` scene to open it and just change the `You won!`
    text with a `You lose!` text.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`LoseScreen`场景以打开它，然后将“你赢了！”文本更改为“你输了！”文本。
- en: Go to `WinScreen`, `LoseScreen`, and the scene we have created so far with the
    game scenario, which I called `Game`, so just drag those scenes from the Project
    View to the list of the Build Settings window; we will need this to make the Game
    Mode script change the scenes properly. Also, consider that the first scene in
    this list will be the first scene to be opened when we play the game in its final
    version (known as the build), so you may want to rearrange the list according
    to that:![Figure 16.15 – Registering the scenes to be included in the build of
    the game
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`WinScreen`，`LoseScreen`，以及我们迄今为止创建的游戏场景，我称之为`Game`，所以只需将这些场景从项目视图拖动到构建设置窗口的列表中；我们需要这样做来确保游戏模式脚本能够正确地改变场景。另外，请注意，这个列表中的第一个场景将是在最终版本（即构建版本）中打开的第一个场景，因此您可能希望根据这一点重新排列列表：![图16.15
    - 注册要包含在游戏构建中的场景
- en: '](img/Figure_16.15_B14199.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.15_B14199.jpg)'
- en: Figure 16.15 – Registering the scenes to be included in the build of the game
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.15 - 注册要包含在游戏构建中的场景
- en: In `WavesGameMode`, add a `using` statement for the `UnityEngine.SceneManagement`
    namespace to enable the scene changing functions in this script.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`中，添加一个`using`语句，用于启用此脚本中的场景更改功能的`UnityEngine.SceneManagement`命名空间。
- en: Replace the console `print` messages with calls to the `SceneManager.LoadScene`
    function, which will receive a string with the name of the scene to load; in this
    case, it would be `WinScreen` and `LoseScreen`. You just need the scene name,
    not the entire path to the file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用`SceneManager.LoadScene`函数替换控制台`print`消息，该函数将接收一个字符串，其中包含要加载的场景的名称；在这种情况下，它将是`WinScreen`和`LoseScreen`。您只需要场景名称，而不是整个文件路径。
- en: 'If you want to chain different levels, you can create a `public` string field
    to allow you to specify via the Editor which scenes to load. Remember to have
    the scenes added to the Build Settings, if not, you will receive an error message
    in the console when you try to change the scenes:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想链接不同的关卡，可以创建一个`public`字符串字段，允许你通过编辑器指定要加载哪些场景。记得将场景添加到构建设置中，否则当你尝试更改场景时，控制台会收到错误消息：
- en: '![Figure 16.16 – Changing scenes with SceneManager'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.16 – 使用SceneManager更改场景'
- en: '](img/Figure_16.16_B14199.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.16_B14199.jpg)'
- en: Figure 16.16 – Changing scenes with `SceneManager`
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.16 – 使用`SceneManager`更改场景
- en: Play the game and check whether the scenes change properly.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 玩游戏，检查场景是否正确更改。
- en: Important note
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Right now, we picked the simplest way to show whether we lost or won, but maybe
    in the future, you will want something more gentle than a sudden change of the
    scene, such as maybe waiting a few moments with `Invoke` to delay that change
    or directly show the winning message inside the game without changing the scenes.
    Consider that when testing the game with people and checking whether they understood
    what happens while they play, game feedback is important to keep the Player aware
    of what is happening and is not an easy task to tackle.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们选择了最简单的方式来显示我们是输了还是赢了，但也许在未来，你会希望有比突然改变场景更温和的方式，比如可能使用`Invoke`等待一段时间来延迟改变，或者直接在游戏中显示获胜消息而不改变场景。在测试游戏时，考虑到玩家在玩游戏时是否理解发生了什么，游戏反馈对于让玩家知晓正在发生的事情是很重要的，这并不是一件容易的事情。
- en: Now we have a fully functional simple game, with mechanics and win and lose
    conditions, and while this is enough to start developing other aspects of our
    game, I want to discuss some issues with our current Manager approach and how
    to solve them with events.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完全功能的简单游戏，具有机制和胜利和失败条件，虽然这已经足够开始开发游戏的其他方面，但我想讨论一下我们当前的管理器方法存在的一些问题，以及如何通过事件解决这些问题。
- en: Improving our code with events
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过事件改进我们的代码
- en: So far, we used Unity event functions to detect situations that can happen in
    the game such as `Awake` and `Update`. These functions are ways for Unity to communicate
    two components, as in the case of `OnTriggerEnter`, which is a way for the Rigidbody
    to inform other components in the GameObject that a collision has happened. In
    our case, we are using `ifs` inside Updates to detect changes on other components,
    such as `GameMode` checking whether the number of enemies reached 0\. But we can
    improve this if we are informed by the Enemy Manager when something has changed,
    and just do the check-in that moment, such as with the Rigidbody telling us the
    collisions instead of checking collisions every frame.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用了Unity事件函数来检测游戏中可能发生的情况，比如`Awake`和`Update`。这些函数是Unity用来让两个组件进行通信的方式，比如`OnTriggerEnter`，这是刚体通知游戏对象中的其他组件发生了碰撞的一种方式。在我们的情况下，我们在Update中使用`if`来检测其他组件的变化，比如`GameMode`检查敌人数量是否达到0。但是，如果敌人管理器在发生变化时通知我们，我们可以在那一刻进行检查，就像刚体告诉我们碰撞发生的情况一样，而不是每帧都检查碰撞。
- en: Also, sometimes, we rely on Unity events to execute logic, such as the score
    being given in the `OnDestroy` event, which informs us when the Object is destroyed,
    but due to the nature of the event, it can be called in situations we don't want
    to add to the score, such as when the scene is changed or the game is closed.
    Objects are destroyed in those cases, but not because the Player killed the Enemy,
    leading to the score being raised when it shouldn't. In this case, it would be
    great to have an event that tells us that the Player's lives have reached 0 to
    execute this logic, instead of relying on the general-purpose destroy event.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们依赖Unity事件来执行逻辑，比如在`OnDestroy`事件中给予分数，该事件通知我们对象被销毁时，但由于事件的性质，它可能在我们不希望加分的情况下被调用，比如场景改变或游戏关闭时。在这些情况下对象被销毁，但不是因为玩家杀死了敌人，导致分数被提高，这时候就需要一个事件告诉我们玩家的生命值已经达到0，以执行这个逻辑，而不是依赖通用的销毁事件。
- en: The idea of events is to improve the model of communication between our Objects,
    being sure that in the exact moment something happens, the interested parts in
    that situation are notified to react accordingly. Unity has lots of events, but
    we can create specific ones to our gameplay logic. Let's start seeing this applied
    in the Score scenario we discussed earlier; the idea is to make the `Life` component
    to have an event to communicate other components that the Object was destroyed
    because its life reached 0\.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 事件的理念是改进我们对象之间的通信模型，确保在某个情况发生时，对该情况感兴趣的部分被通知以做出相应反应。Unity有很多事件，但我们可以创建特定于我们游戏逻辑的事件。让我们从之前讨论的分数场景中开始看到这个应用；想法是让`Life`组件有一个事件来通知其他组件，对象被销毁是因为它的生命值达到了0。
- en: 'There are several ways to implement this, and we will use a little bit of a
    different approach than the `Awake` and `Update` methods; we will use the `UnityEvent`
    field type. This is a field type capable of holding references to functions to
    be executed when we want to, like C# delegates, but with other benefits, such
    as better Unity Editor integration. To implement this, do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以实现这一点，我们将使用与`Awake`和`Update`方法略有不同的方法；我们将使用`UnityEvent`字段类型。这是一种能够保存引用函数的字段类型，当我们想要执行时，就像C#委托一样，但具有其他好处，比如更好的Unity编辑器集成。要实现这一点，按照以下步骤进行：
- en: In the `Life` component, create a `public` field of the `UnityEvent` type called
    `onDeath`. This field will represent an event where other classes can subscribe
    to it to be aware of when `Life` reaches 0:![Figure 16.17 – Creating a custom
    event field
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Life`组件中，创建一个名为`onDeath`的`UnityEvent`类型的`public`字段。这个字段将代表一个事件，其他类可以订阅它以便在`Life`达到0时知晓：![图16.17
    – 创建自定义事件字段
- en: '](img/Image86832.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Image86832.jpg)'
- en: Figure 16.17 – Creating a custom event field
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.17 – 创建自定义事件字段
- en: If you save the script and go to the Editor, you can see the event in the Inspector.
    Unity Events support subscribing methods to them in the Editor so we can connect
    two Objects together. We will use this in the UI scripting chapter, so let's just
    ignore this for now:![Figure 16.18 – UnityEvents showing up in the Inspector
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你保存脚本并进入编辑器，你可以在检视器中看到事件。Unity事件支持在编辑器中订阅方法，这样我们可以连接两个对象。我们将在UI脚本章节中使用这个功能，所以现在就忽略它吧：![图16.18
    – UnityEvents显示在检视器中
- en: '](img/Figure_16.18_B14199.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.18_B14199.jpg)'
- en: Figure 16.18 – UnityEvents showing up in the Inspector
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.18 – UnityEvents显示在检视器中
- en: Important note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can use the generic delegate action or a custom delegate to create events
    instead of using `UnityEvent`, and aside from certain performance aspects, the
    only noticeable difference is that `UnityEvent` will show up in the Editor, as
    demonstrated in *step 2*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用通用委托动作或自定义委托来创建事件，而不是使用`UnityEvent`，除了某些性能方面的差异之外，唯一显著的区别是`UnityEvent`会显示在编辑器中，就像*步骤2*中演示的那样。
- en: When life reaches `0`, call the `Invoke` function of the event, and this way,
    we will be telling anyone interested in the event that it has happened:![Figure
    16.19 – Executing the event
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当生命值达到`0`时，调用事件的`Invoke`函数，这样我们就告诉任何对该事件感兴趣的人，事件已经发生：![图16.19 – 执行事件
- en: '](img/Figure_16.19_B14199.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.19_B14199.jpg)'
- en: Figure 16.19 – Executing the event
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.19 – 执行事件
- en: In `ScoreOnDeath`, rename the `OnDestroy` function to `GivePoints` or whatever
    name you prefer; the idea here is to stop giving points in the `OnDestroy` event.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`中，将`OnDestroy`函数重命名为`GivePoints`或者你喜欢的其他名称；这里的想法是停止在`OnDestroy`事件中给分。
- en: In the `Awake` function of the `ScoreOnDeath` script, get the `Life` component
    using `GetComponent` and save it in a local variable.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ScoreOnDeath`脚本的`Awake`函数中，使用`GetComponent`获取`Life`组件并将其保存在一个局部变量中。
- en: Call the `AddListener` function of the `onDeath` field of the `Life` reference
    and pass the `GivePoints` function as the first argument. The idea is to tell
    `Life` to execute `GivePoints` when the `onDeath` event is invoked. This way,
    `Life` informs us about that situation. Remember that you don't need to call `GivePoints`,
    but just pass the function as a field:![Figure 16.20 – Subscribing to the OnDeath
    event to give points in that scenario
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`Life`引用的`onDeath`字段的`AddListener`函数，并将`GivePoints`函数作为第一个参数传递。这样做的想法是告诉`Life`在`onDeath`事件被调用时执行`GivePoints`。这样，`Life`会通知我们发生了什么情况。记住，你不需要调用`GivePoints`，只需要将函数作为字段传递即可：![图16.20
    – 订阅OnDeath事件以在该场景中给分
- en: '](img/Figure_16.20_B14199.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.20_B14199.jpg)'
- en: Figure 16.20 – Subscribing to the OnDeath event to give points in that scenario
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.20 – 订阅OnDeath事件以在该场景中给分
- en: Important note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Consider calling `RemoveListener` in `OnDestroy`; as usual, it is convenient
    to unsubscribe listeners when possible to prevent any memory leak (a reference
    preventing the GC from deallocating memory). In this scenario, it is not entirely
    necessary because both the `Life` and `ScoreOnDeath` components will be destroyed
    at the same time, but try to get used to that good practice.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在`OnDestroy`中调用`RemoveListener`；通常情况下，尽可能取消订阅监听器是方便的，以防止内存泄漏（引用阻止GC释放内存）。在这种情况下，这并不是完全必要的，因为`Life`和`ScoreOnDeath`组件将同时被销毁，但尽量养成这种良好的习惯。
- en: Save, select `ScoreManager` in the Editor, and hit play to test this. Try deleting
    an Enemy from the Hierarchy while in Play Mode to check how the score doesn't
    rise because the Enemy was destroyed for any other reason than its life becoming
    0; you must destroy an Enemy by shooting at them to see the score being raised.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存，在编辑器中选择`ScoreManager`，然后点击播放进行测试。尝试在播放模式下从层次结构中删除一个敌人，以检查分数不会上升，因为敌人被摧毁不是因为生命值变为0；你必须通过射击摧毁敌人才能看到分数上升。
- en: 'Now that `Life` has an `onDeath` event, we can also replace the Player''s `Life`
    check from the `WavesGameMode` to use the event by doing the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Life`有了`onDeath`事件，我们也可以将`WavesGameMode`中对玩家`Life`的检查替换为使用事件，方法如下：
- en: Create an `OnLifeChanged` function on the `WavesGameMode` script and move the
    life checking condition from `Update` to this function.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`脚本中创建一个`OnLifeChanged`函数，并将生命检查条件从`Update`移动到这个函数中。
- en: 'In `Awake`, subscribe to this new function to the `onDeath` event of the Player''s
    `Life` component reference:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中，订阅玩家`Life`组件引用的`onDeath`事件到这个新函数：
- en: '![Figure 16.21 – Checking the lose condition with events'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.21 – 使用事件检查失败条件'
- en: '](img/Figure_16.21_B14199.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.21_B14199.jpg)'
- en: Figure 16.21 – Checking the lose condition with events
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.21 – 使用事件检查失败条件
- en: As you can see, creating custom events allows you to detect more specific situations
    other than the defaults in Unity, and keeps your code clean, without needing to
    constantly ask conditions in the `Update` function, which is not necessarily bad,
    but the event approach generates clearer code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，创建自定义事件可以让你检测到Unity中默认情况之外的更具体的情况，并且保持你的代码清晰，而不需要在`Update`函数中不断询问条件，这并不一定是坏事，但事件方法可以生成更清晰的代码。
- en: 'Remember that we can lose our game also by the Player''s Base Life reaching
    0, and we will explore the concept of the Player''s base later in this book, but
    for now, let''s create a cube that represents the Object that Enemies will attack
    to reduce the Base Life, like the Base Core. Taking this into account, I challenge
    you to add this other lose condition to our script. When you finish, you can check
    the solution in the following screenshot:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们也可以通过玩家的基础生命值达到0来输掉游戏，我们将在本书的后面探讨玩家基础的概念，但现在，让我们创建一个立方体，代表敌人将攻击以减少基础生命值的对象，就像基础核心一样。考虑到这一点，我挑战你将这个额外的失败条件添加到我们的脚本中。完成后，你可以在以下截图中检查解决方案：
- en: '![Figure 16.22 – Complete WavesGameMode lose condition'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.22 – 完整的WavesGameMode失败条件'
- en: '](img/Figure_16.22_B14199.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.22_B14199.jpg)'
- en: Figure 16.22 – Complete WavesGameMode lose condition
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.22 – 完整的WavesGameMode失败条件
- en: 'As you can see, we just repeated the life event subscription: remember to create
    an Object to represent the Player''s Base damage point, add a `Life` script to
    it, and drag that one as the Player Base Life reference of `WavesGameMode`.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们只是重复了生活事件的订阅：记得创建一个对象来代表玩家基地的伤害点，给它添加一个`Life`脚本，并将其作为`WavesGameMode`的玩家基地生命引用拖放进去。
- en: 'Now, let''s keep illustrating this concept by applying it in the Managers to
    prevent the Game Mode from checking conditions every frame:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过将其应用于管理器来继续说明这个概念，以防止游戏模式每帧检查条件：
- en: Add an `UnityEvent` field to `EnemyManager` called `onChanged`. This event will
    be executed whenever an Enemy is added or removed from the list.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EnemyManager`中添加一个`UnityEvent`字段，称为`onChanged`。每当敌人被添加或从列表中移除时，将执行此事件。
- en: Create two functions, `AddEnemy` and `RemoveEnemy`, both receiving a parameter
    of the `Enemy` type. The idea is that instead of `Enemy` adding and removing itself
    from the list directly, it should use these functions.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个函数，`AddEnemy`和`RemoveEnemy`，都接收`Enemy`类型的参数。想法是，`Enemy`不直接向列表中添加和移除自己，而是应该使用这些函数。
- en: Inside these two functions, invoke the `onChanged` event to inform others that
    the enemies list has been updated. The idea is that anyone who wants to add or
    remove enemies from the list needs to use these functions:![Figure 16.23 – Calling
    events when enemies are added or removed
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这两个函数中，调用`onChanged`事件通知其他人敌人列表已经更新。想法是任何想要向列表中添加或移除敌人的人都需要使用这些函数：![图16.23
    – 当敌人被添加或移除时调用事件
- en: '](img/Figure_16.23_B14199.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.23_B14199.jpg)'
- en: Figure 16.23 – Calling events when enemies are added or removed
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.23 – 当敌人被添加或移除时调用事件
- en: Important note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Here, we have the problem that nothing stops us from bypassing those two functions
    and using the list directly. You can solve that by making the list private and
    exposing it using the `IReadOnlyList` interface. Remember that this way, the list
    won't be visible in the Editor for debugging purposes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的问题是没有什么能阻止我们绕过这两个函数直接使用列表。你可以通过将列表设置为私有，并使用`IReadOnlyList`接口来公开它来解决这个问题。请记住，这种方式，列表不会出现在编辑器中以进行调试。
- en: 'Change the `Enemy` script to use these functions:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改`Enemy`脚本以使用这些函数：
- en: '![Figure 16.24 – Making the Enemy use the Add and Remove functions'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.24 – 使敌人使用Add和Remove函数'
- en: '](img/Figure_16.24_B14199.png)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.24_B14199.png)'
- en: Figure 16.24 – Making the Enemy use the Add and Remove functions
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.24 – 使敌人使用Add和Remove函数
- en: Repeat the same process for `WaveManager` and `WaveSpawner`, create an `onChanged`
    event, and create the `AddWave` and `RemoveWave` functions and call them in `WaveSpawner`
    instead of directly accessing the list. This way, we are sure the event is called
    when necessary as we did with `EnemyManager`. Try to solve this step by yourself
    and then check the solution in the following screenshot, starting with `WavesManager`:![Figure
    16.25 – Wave Manager On Changed event implementation
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`WaveManager`和`WaveSpawner`执行相同的过程，创建一个`onChanged`事件，并创建`AddWave`和`RemoveWave`函数，并在`WaveSpawner`中调用它们，而不是直接访问列表。这样，我们可以确保在必要时调用事件，就像我们在`EnemyManager`中所做的那样。尝试自己解决这一步，然后在下面的屏幕截图中检查解决方案，从`WavesManager`开始：![图16.25
    – Wave Manager On Changed事件实现
- en: '](img/Figure_16.25_B14199.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.25_B14199.jpg)'
- en: Figure 16.25 – Wave Manager On Changed event implementation
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.25 – Wave Manager On Changed事件实现
- en: 'Also, `WavesSpawner` needs changes:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`WavesSpawner` 需要更改：
- en: '![Figure 16.26 – Implementing the AddWave and RemoveWave functions'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.26 – 实现AddWave和RemoveWave函数'
- en: '](img/Figure_16.26_B14199.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.26_B14199.jpg)'
- en: Figure 16.26 – Implementing the AddWave and RemoveWave functions
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.26 – 实现AddWave和RemoveWave函数
- en: 'In `WavesGameMode`, rename `Update` to `CheckWinCondition` and subscribe this
    function to the `onChanged` event of `EnemyManager` and the `onChanged` event
    of `WavesManager`. The idea is to check for the number of enemies and waves being
    changed only when it is necessary. Remember to do the subscription to the events
    in the `Start` function due to the Singletons being initialized in `Awake`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WavesGameMode`中，将`Update`重命名为`CheckWinCondition`，并订阅此函数到`EnemyManager`的`onChanged`事件和`WavesManager`的`onChanged`事件。想法是只在必要时检查敌人和波数的变化。请记住在`Start`函数中订阅事件，因为单例在`Awake`中初始化：
- en: '![Figure 16.27 – Checking the win condition when the enemies or waves amount
    is changed'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '![图16.27 – 当敌人或波数发生变化时检查胜利条件'
- en: '](img/Figure_16.27_B14199.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_16.27_B14199.jpg)'
- en: Figure 16.27 – Checking the win condition when the enemies or waves amount is
    changed
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图16.27 – 当敌人或波数发生变化时检查胜利条件
- en: Yes, this way, we have to write more code than before, and in terms of functionality,
    we didn't obtain anything new, but in bigger projects, managing conditions through
    `Update` checks will lead to different kinds of problems as previously discussed,
    such as race conditions and performances issues. Having a scalable code base sometimes
    requires more code, and this is one of those cases.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这种方式，我们需要比以前写更多的代码，而且在功能上，我们并没有得到任何新的东西，但在更大的项目中，通过`Update`检查来管理条件会导致之前讨论过的不同种类的问题，比如竞争条件和性能问题。有一个可扩展的代码库有时需要更多的代码，这就是这种情况之一。
- en: Before we finish, something to consider is that Unity events are not the only
    way to create this kind of event communication in Unity; you will find a similar
    approach called **Action**, the native C# version of Unity events, which I recommend
    you to look for if you want to see all of the options out there.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成之前，需要考虑的一点是，Unity 事件并不是在Unity中创建这种事件通信的唯一方式；你会发现一种类似的方法叫做**Action**，这是Unity事件的本地C#版本，我建议你去寻找一下，如果你想看看所有的选择。
- en: Summary
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we finished an important part of the game, the ending, either
    by victory or by defeat. We discussed a simple but powerful way to separate the
    different layers of responsibilities by using Managers created through Singletons,
    to guarantee that there's not more than one instance of every kind of manager
    and simplifying the connections between them through static access (something
    to consider the day you discover code testing). Also, we visited the concept of
    events to streamline the communication between Objects to prevent problems and
    create more meaningful communication between Objects.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了游戏的重要部分，结局，无论是胜利还是失败。我们讨论了一种简单但强大的方法，通过使用通过单例创建的管理器来分离不同的责任层，以确保每种类型的管理器都不会有多个实例，并通过静态访问简化它们之间的连接（这是在发现代码测试的那一天要考虑的事情）。此外，我们讨论了事件的概念，以简化对象之间的通信，以防止问题并创建更有意义的对象之间的通信。
- en: With this knowledge, you are now able not only to detect the victory and lose
    conditions of the game but to also do that in a better-structured way. These patterns
    can be useful to improve our game code in general, and I recommend you to try
    to apply it in other relevant scenarios.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些知识，你现在不仅能够检测游戏的胜利和失败条件，还能以更好的结构方式来做到这一点。这些模式可以用来改进我们的游戏代码，我建议你尝试将其应用到其他相关场景中。
- en: In the next chapter, we are going to explore how to create visual and audio
    feedback to respond to our gameplay, combining scripting and the assets we integrated
    in *Part 2* of this book.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何创建视觉和音频反馈以响应我们的游戏玩法，结合本书第2部分中集成的脚本和资产。
