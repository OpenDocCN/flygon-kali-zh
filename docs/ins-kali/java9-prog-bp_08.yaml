- en: Photo Management with PhotoBeans
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PhotoBeans进行照片管理
- en: So far, we've written libraries. We've written command-line utilities. We've
    also written GUIs using JavaFX. In this chapter, we're going to try something
    completely different. We're going to build a photo management system, which, of
    course, needs to be a graphical application, but we're going to take a different
    approach. Rather than using pure JavaFX and building everything from the ground
    up, we'll use an existing application framework. That framework is the NetBeans
    **Rich Client Platform** (**RCP**), a mature, stable, and powerful framework,
    that powers not just the NetBeans IDE we've been using, but countless applications
    in a myriad of industries from oil and gas to air and space.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了库。我们编写了命令行实用程序。我们还使用JavaFX编写了GUI。在本章中，我们将尝试完全不同的东西。我们将构建一个照片管理系统，当然，它需要是一个图形应用程序，但我们将采取不同的方法。我们将使用现有的应用程序框架。该框架是NetBeans
    **Rich Client Platform**（**RCP**），这是一个成熟、稳定和强大的框架，不仅支持我们使用的NetBeans IDE，还支持从石油和天然气到航空航天等各行各业的无数应用程序。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How to bootstrap a NetBeans RCP project
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何启动NetBeans RCP项目
- en: How to integrate JavaFX with the NetBeans RCP
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将JavaFX与NetBeans RCP集成
- en: The fundamentals of an RCP application such as Nodes, Actions, Lookups, Services,
    and TopComponents
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RCP应用程序的基本原理，如节点、操作、查找、服务和顶级组件
- en: Without further ado then, let's jump right in.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，话不多说，让我们开始吧。
- en: Getting started
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: Probably the question at or near the top of your list is, **Why would I want
    to use NetBeans RCP?**. Before we get into the details of the application, let's
    address this very fair question, and try to understand why we're building it the
    way we are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您的问题清单中排在前面或附近的问题是，**我为什么要使用NetBeans RCP？**在我们深入了解应用程序的细节之前，让我们回答这个非常公平的问题，并尝试理解为什么我们要以这种方式构建它。
- en: One of the first things you'll notice when you start looking into the NetBeans
    platform is the strong notion of modularity. With the Java Module System being
    such a prominent feature of Java 9, this may seem like a minor detail, but NetBeans
    exposes this concept to us at the application level, making plugins incredibly
    simple, as well as allowing us to update the application on a piecemeal basis.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始研究NetBeans平台时，您会注意到的第一件事是模块化的强烈概念。由于Java 9的Java模块系统是Java的一个突出特性，这可能看起来像一个细节，但NetBeans在应用程序级别向我们公开了这个概念，使插件变得非常简单，并允许我们以逐步更新应用程序。
- en: The RCP also provides a robust, well-tested framework for handling windows,
    menus, actions, nodes, services, and so on. If we were to build this application
    from scratch, as we've done in the previous chapters using **plain** JavaFX, we
    would have to manually define areas on the screen, then handle window placement
    by hand. With the RCP, we have a rich windowing specification already defined,
    which we can easily use. It offers features such as maximizing/minimizing windows,
    sliding, detaching, and docking windows, and so on.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: RCP还提供了一个强大、经过充分测试的框架，用于处理窗口、菜单、操作、节点、服务等。如果我们要像在前几章中使用**纯**JavaFX一样从头开始构建这个应用程序，我们将不得不手动定义屏幕上的区域，然后手动处理窗口放置。使用RCP，我们已经定义了丰富的窗口规范，可以轻松使用。它提供了诸如最大化/最小化窗口、滑动、分离和停靠窗口等功能。
- en: The RCP also provides a strong notion of **nodes**, an encapsulation of domain-specific
    data in a user interface concept, which is most often seen as entries in a tree
    view on the left side of an application, as well as actions that can be associated
    with these nodes (or menu items) to act on the data they represent. Again, all
    of this can be done in JavaFX (or Swing), but you would have to code all of these
    features yourself. In fact, there are a number of open source frameworks that
    offer to do just that, such as Canoo's Dolphin Platform ([http://www.dolphin-platform.io](http://www.dolphin-platform.io/)),
    though none have had the years of production hardening and testing that the NetBeans
    RCP has had, so we'll keep our focus here.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: RCP还提供了**节点**的强大概念，将特定领域的数据封装在用户界面概念中，通常在应用程序的左侧树视图中看到，以及可以与这些节点（或菜单项）关联的操作，以对它们代表的数据进行操作。再次强调，所有这些都可以在JavaFX（或Swing）中完成，但您需要自己编写所有这些功能。实际上，有许多开源框架提供了这样的功能，例如Canoo的Dolphin
    Platform（[http://www.dolphin-platform.io](http://www.dolphin-platform.io/)），但没有一个像NetBeans
    RCP那样经过多年的生产硬化和测试，因此我们将保持关注在这里。
- en: Bootstrapping the project
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动项目
- en: How you create a NetBeans RCP project will have a very fundamental impact on
    how the rest of the project will be approached. By default, NetBeans uses Ant
    as the build system for all RCP apps. Almost all of the online documentation from
    the NetBeans project, and blog entries from the NetBeans evangelists, often reflect
    this preference as well. We've been using Maven for every other project, and we're
    not going to change that here. Fortunately, NetBeans does allow us to create an
    RCP project with Maven, which is what we'll do.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您如何创建NetBeans RCP项目将对项目的其余部分的处理方式产生非常基本的影响。默认情况下，NetBeans使用Ant作为所有RCP应用程序的构建系统。几乎所有来自NetBeans项目的在线文档和NetBeans传道者的博客条目也经常反映了这种偏好。我们一直在使用Maven进行其他项目，这里也不会改变。幸运的是，NetBeans确实允许我们使用Maven创建RCP项目，这就是我们要做的。
- en: '![](img/ba9bc9dd-b737-4aa3-a707-a312c86746f0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba9bc9dd-b737-4aa3-a707-a312c86746f0.png)'
- en: In the New Project window, we select Maven, then NetBeans Application. On the
    next screen, we configure the project as usual, specifying the project name, photobeans,
    project location, package, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在新项目窗口中，我们选择Maven，然后选择NetBeans Application。在下一个屏幕上，我们像往常一样配置项目，指定项目名称、photobeans、项目位置、包等。
- en: 'When we click on Next, we''ll be presented with the Module Options step of
    the New Project wizard. In this step, we configure some basic aspects of the RCP
    application. Specifically, we need to specify the version of the NetBeans APIs
    we''ll use, and whether or not we want to use OSGi bundles as dependencies, as
    seen in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们点击“下一步”时，将会出现“新项目向导”的“模块选项”步骤。在这一步中，我们配置 RCP 应用程序的一些基本方面。具体来说，我们需要指定我们将使用的
    NetBeans API 版本，以及是否要将 OSGi 捆绑包作为依赖项，如下面的屏幕截图所示：
- en: '![](img/431c03b2-1ada-42a4-b11a-f9dc98c1bad4.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/431c03b2-1ada-42a4-b11a-f9dc98c1bad4.png)'
- en: At the time of writing, the latest platform version is RELEASE82\. By the time
    Java 9 ships, it is reasonable to expect that NetBeans 9.0, and, therefore RELEASE90,
    will be available. We want the latest version available, but note that, depending
    on the release schedule of the NetBeans project, it may very well *not* be 9.0\.
    For the Allow OSGi bundles as dependencies option we can safely accept the default,
    though changing it won't cause us any issues, and we can easily change the value
    later should the need arise.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新的平台版本是 RELEASE82。到 Java 9 发布时，可以合理地期望 NetBeans 9.0，因此 RELEASE90 将可用。我们希望使用最新版本，但请注意，根据
    NetBeans 项目的发布计划，它很可能 *不* 是 9.0。对于“允许将 OSGi 捆绑包作为依赖项”选项，我们可以安全地接受默认值，尽管更改它不会给我们带来任何问题，而且如果需要，我们可以很容易地稍后更改该值。
- en: 'Once the project is created, we should see three new entries in the projects
    window: `PhotoBeans-parent`, `PhotoBeans-app`, and `PhotoBeans-branding`. The
    `-parent` project has no real deliverables. Like the `master` projects from other
    chapters, this serves merely to organize related modules, coordinate dependencies,
    and so on.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目后，我们应该在项目窗口中看到三个新条目：`PhotoBeans-parent`、`PhotoBeans-app` 和 `PhotoBeans-branding`。`-parent`
    项目没有真正的可交付成果。与其他章节的 `master` 项目一样，它仅用于组织相关模块、协调依赖关系等。
- en: Branding your application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的应用程序进行品牌定制
- en: 'The `-branding` module is where we can define, as you may have already guessed,
    the details of the application''s branding. You can access these branding properties
    by right-clicking on the branding module, and selecting `Branding...` near the
    bottom of the content menu. Upon doing so, you will be prompted with a screen
    like this one:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`-branding` 模块是我们可以定义应用程序品牌细节的地方，正如你可能已经猜到的那样。您可以通过右键单击品牌模块并在内容菜单底部附近选择 `品牌...`
    来访问这些品牌属性。这样做后，您将看到一个类似于这样的屏幕：'
- en: '![](img/02d5bdd7-9ad3-49b3-9c52-c3ce3f628ef1.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/02d5bdd7-9ad3-49b3-9c52-c3ce3f628ef1.png)'
- en: In this preceding tab, you can set or change the name of the application, as
    well as specify the application icon.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述选项卡中，您可以设置或更改应用程序的名称，并指定应用程序图标。
- en: 'In the Splash Screen tab, you can configure, most importantly, the image that
    is displayed on the splash screen as the application loads. You can also enable
    or disable the progress bar, and set the colors, font sizes, and positions of
    the progress bar and startup messages:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在“启动画面”选项卡中，您可以配置最重要的是在应用程序加载时显示在启动画面上的图像。您还可以启用或禁用进度条，并设置进度条和启动消息的颜色、字体大小和位置：
- en: '![](img/685b88d8-5aea-485d-a7a8-9b61469cee2b.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/685b88d8-5aea-485d-a7a8-9b61469cee2b.png)'
- en: 'The only other tab that is of interest to us at the moment is the Window System
    tab. In this tab, we can configure a number of features such as window drag and
    drop, window sliding, closing, and so on:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对我们感兴趣的唯一其他选项卡是“窗口系统”选项卡。在这个选项卡中，我们可以配置一些功能，比如窗口拖放、窗口滑动、关闭等等：
- en: '![](img/55bc7aca-986d-41de-9ac5-2c7a101ee28b.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55bc7aca-986d-41de-9ac5-2c7a101ee28b.png)'
- en: More likely than not, the defaults are acceptable for our purposes here. However,
    in your own NetBeans RCP application, this screen may be much more important.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，默认值对我们的目的是可以接受的。但是，在您自己的 NetBeans RCP 应用程序中，此屏幕可能更加重要。
- en: Our main interest is the `-app` module. This module is the one that will define
    all of the application's dependencies, and will be its entry point. Unlike the
    JavaFX applications we've seen in previous chapters, though, we don't need to
    define a `public static void main` method, as NetBeans handles that for us. In
    fact, the `-app` module doesn't have any Java classes in it at all, yet the app
    can run right out-of-the-box, though it doesn't do much. We'll fix that now.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注 `-app` 模块。这个模块将定义应用程序的所有依赖关系，并且将是其入口点。不过，与我们在之前章节中看到的 JavaFX 应用程序不同，我们不需要定义
    `public static void main` 方法，因为 NetBeans 会为我们处理。实际上，`-app` 模块根本没有任何 Java 类，但是应用程序可以直接运行，尽管它并没有做太多事情。我们现在来修复这个问题。
- en: NetBeans modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans 模块
- en: 'One of the strengths of the NetBeans platform is its modularity. If you''ve
    ever used the NetBeans IDE itself (before, say, reading this book), you''ve seen
    this modularity in action when working with plugins: every NetBeans plugin is
    made up of one or more modules. In fact, NetBeans itself is composed of numerous
    modules. That''s how RCP applications are designed to work. It promotes decoupling,
    and makes extending and upgrading the application much simpler.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans 平台的一个优点是其模块化。如果您以前曾使用过 NetBeans IDE（比如在阅读本书之前），那么在使用插件时就已经看到了这种模块化的作用：每个
    NetBeans 插件由一个或多个模块组成。实际上，NetBeans 本身由许多模块组成。这就是 RCP 应用程序设计的工作方式。它促进了解耦，并使扩展和升级应用程序变得更加简单。
- en: 'The generally accepted pattern is to, say, put the API classes in one module
    and the implementations in another. This makes the API classes reusable by other
    implementers, can help enforce low coupling by hiding private classes, and so
    on. To keep things simple as we learn the platform, though, we are going to create
    just one module that will provide all of the core functionality. To do that, we
    right-click on the Modules node under the parent project, and select Create New
    Module...: as shown in the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通常接受的模式是，将 API 类放在一个模块中，将实现放在另一个模块中。这样可以使其他实现者重用 API 类，可以通过隐藏私有类来帮助强制低耦合等等。然而，为了简化我们学习平台的过程，我们将创建一个模块，该模块将提供所有核心功能。为此，我们右键单击父项目下的“模块”节点，然后选择“创建新模块...”：如下图所示：
- en: '![](img/51979733-3823-4037-a5ff-4fdf71d46acf.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/51979733-3823-4037-a5ff-4fdf71d46acf.png)'
- en: 'Once selected, you will be shown the New Project window. Here, you will need
    to select the Maven category, and the NetBeans Module project type, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦选择，您将看到新项目窗口。在这里，您需要选择Maven类别和NetBeans模块项目类型，如下所示：
- en: '![](img/6813f74b-a46d-4b75-a214-f617bf0e6825.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6813f74b-a46d-4b75-a214-f617bf0e6825.png)'
- en: Clicking on Next will get you the Name and Location step we've seen several
    times already in this book. On this pane, we'll name the module `main`, set the
    package to `com.steeplesoft.photobeans.main`, and accept the defaults for the
    other fields. On the next pane, Module Options, we will make sure that the NetBeans
    Version is the same as was selected earlier, and click on Finish.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“下一步”将进入“名称和位置”步骤，这是本书中已经多次见过的步骤。在这个窗格上，我们将模块命名为“main”，将包设置为“com.steeplesoft.photobeans.main”，并接受其他字段的默认值。在下一个窗格“模块选项”中，我们将确保NetBeans版本与之前选择的版本相同，并点击“完成”。
- en: TopComponent - the class for tabs and windows
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TopComponent - 选项卡和窗口的类
- en: 'We now have a module that is mostly empty. NetBeans created a few artifacts
    for us, but we need not concern ourselves with those, as the build will manage
    those for us. What we do need to do, though, is create our first GUI element,
    which will be something that NetBeans calls a TopComponent. From the NetBeans
    Javadoc, found at [http://bits.netbeans.org/8.2/javadoc/](http://bits.netbeans.org/8.2/javadoc/),
    we find this definition:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个大部分为空的模块。NetBeans为我们创建了一些工件，但我们不需要关心这些，因为构建将为我们管理这些。不过，我们需要做的是创建我们的第一个GUI元素，这将是NetBeans称为TopComponent的东西。从NetBeans
    Javadoc中，可以在[http://bits.netbeans.org/8.2/javadoc/](http://bits.netbeans.org/8.2/javadoc/)找到这个定义：
- en: Embeddable visual component to be displayed in NetBeans. This is the basic unit
    of display--windows should not be created directly, but rather use this class.
    A top component may correspond to a single window, but may also be a tab (e.g.)
    in a window. It may be docked or undocked, have selected nodes, supply actions,
    etc.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可嵌入的可视组件，用于在NetBeans中显示。这是显示的基本单位--窗口不应该直接创建，而应该使用这个类。顶部组件可能对应于单个窗口，但也可能是窗口中的选项卡（例如）。它可以被停靠或未停靠，有选定的节点，提供操作等。
- en: As we'll see, this class is the main component of a NetBeans RCP application.
    It will hold and control various related user interface elements. It is, to put
    it another way, at the top of a component hierarchy in the user interface. To
    create TopComponent, we can use the NetBeans wizard by right-clicking on our now
    empty package in the Project Explorer tree, and selecting New | Window. If Window
    is not an option, select Other | Module Development | Window.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，这个类是NetBeans RCP应用程序的主要组件。它将保存和控制各种相关的用户界面元素。换句话说，它位于用户界面的组件层次结构的顶部。要创建TopComponent，我们可以通过在项目资源管理器树中右键单击我们现在空的包，并选择新建
    | 窗口来使用NetBeans向导。如果“窗口”不是一个选项，选择其他 | 模块开发 | 窗口。
- en: 'You should now see the following Basic Settings window:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到以下基本设置窗口：
- en: '![](img/23214245-cb24-48c2-825b-887194834139.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/23214245-cb24-48c2-825b-887194834139.png)'
- en: 'We have a number of options in the preceding window. What we''re creating is
    a window that will show a list of photos, so some reasonable settings would be
    to select the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的窗口中有许多选项。我们正在创建的是一个将显示照片列表的窗口，因此一些合理的设置是选择以下内容：
- en: Open on Application Start
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序启动时打开
- en: Closing not allowed
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许关闭
- en: Maximization not allowed
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许最大化
- en: 'These options seem pretty straightforward, but what is Window Position? Another
    of the benefits of using the NetBeans RCP as opposed to writing everything from
    scratch is that the platform provides a number of predefined concepts and facilities
    so that we don''t need to worry about them. One such concern is window positioning
    and placement. The NetBeans user interface specification (which can be found on
    the NetBeans site at [https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html](https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html))
    defines the following areas:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项似乎非常直接了当，但“窗口位置”是什么？使用NetBeans RCP而不是从头开始编写的另一个好处是，平台提供了许多预定义的概念和设施，因此我们不需要担心它们。其中一个关注点是窗口定位和放置。NetBeans用户界面规范（可以在NetBeans网站上找到，网址为[https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html](https://ui.netbeans.org/docs/ui/ws/ws_spec-netbeans_ide.html)）定义了以下区域：
- en: '**Explorer:** This is used for all windows that provide access to user objects,
    usually in tree browsers'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理器：** 这用于提供对用户对象的访问的所有窗口，通常是树浏览器'
- en: '**Output:** This is used for the Output window and VCS Output window by default'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输出：** 这是默认用于输出窗口和VCS输出窗口'
- en: '**Debugger:** This is used for all the debugger windows and other supporting
    windows that require a horizontal layout'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试器：** 这用于所有调试器窗口和其他需要水平布局的支持窗口'
- en: '**Palette:** This is used for the component palette window'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调色板：** 这用于组件调色板窗口'
- en: '**Inspector:** This is used for the component inspector window'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查器：** 这用于组件检查器窗口'
- en: '**Properties:** This is used for the properties window'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性：** 这用于属性窗口'
- en: '**Documents:** This is used for all the document windows'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档：** 这用于所有文档窗口'
- en: 'The documentation also provides this helpful illustration:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还提供了这个有用的插图：
- en: '![](img/0909beeb-225d-4bf0-a7c2-a9d42b9c1232.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0909beeb-225d-4bf0-a7c2-a9d42b9c1232.png)'
- en: 'The specification page has a great deal of additional information, but this
    should be enough for now to get you going. We would like our photo list to be
    on the left side of the application window, so we select editor for the window
    position. Clicking on Next, we configure the name and icon for the component.
    Strictly speaking, we don''t need to specify an icon for TopComponent, so we can
    just enter `PhotoList` for Class Name Prefix:, and click on Finish:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 规范页面有大量的额外信息，但现在这些信息足够让您开始了。我们希望我们的照片列表在应用程序窗口的左侧，所以我们选择窗口位置为编辑器。点击“下一步”，我们配置组件的名称和图标。严格来说，我们不需要为TopComponent指定图标，所以我们只需输入“PhotoList”作为类名前缀，并点击“完成”：
- en: '![](img/d05b3b56-34c1-447e-8e11-678bc22f827f.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d05b3b56-34c1-447e-8e11-678bc22f827f.png)'
- en: When you click on Finish here, NetBeans will create a couple of files for you,
    though only one will show up in the Project Explorer tree, that being `PhotoListTopComponent.java`.
    There is also a file called `PhotoListTopComponent.form` that you need to know
    about, though you will never edit it directly. NetBeans provides a very nice **WYSIWYG**
    (what you see is what you get) editor for building your user interface. The user
    interface definition is stored in the `.form` file, which is simply an XML file.
    As you make changes, NetBeans modifies this file for you, and generates the equivalent
    Java code in a method called `initComponents()`. You'll also notice that NetBeans
    will not allow you to modify the method. You can, of course, use another editor
    to do so, but any changes you make that way will be lost if you make changes in
    the GUI editor, so it's best just to leave the method alone. What does the rest
    of TopComponent look like?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在这里单击“完成”时，NetBeans会为您创建一些文件，尽管只有一个文件会显示在项目资源管理器树中，即`PhotoListTopComponent.java`。还有一个名为`PhotoListTopComponent.form`的文件，您需要了解一下，尽管您永远不会直接编辑它。NetBeans为构建用户界面提供了一个非常好的所见即所得（WYSIWYG）编辑器。用户界面定义存储在`.form`文件中，这只是一个XML文件。当您进行更改时，NetBeans会为您修改这个文件，并在一个名为`initComponents()`的方法中生成相应的Java代码。您还会注意到，NetBeans不允许您修改这个方法。当然，您可以使用另一个编辑器来这样做，但是如果您以这种方式进行更改，那么如果您在GUI编辑器中进行更改，那么您所做的任何更改都将丢失，所以最好还是让这个方法保持不变。`TopComponent`的其余部分是什么样子的呢？
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's a lot of annotations, but is also a good reminder of how much the NetBeans
    platform is doing for you. During the build process, these annotations are processed
    to create the metadata that the platform will use at runtime to configure and
    wire together your application.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是很多注释，但也是NetBeans平台为您做了多少事情的一个很好的提醒。在构建过程中，这些注释被处理以创建元数据，平台将在运行时使用这些元数据来配置和连接您的应用程序。
- en: 'Some of the highlights are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一些亮点如下：
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This registers our `TopComponent`, and reflects our choices of where to put
    it and when to open it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这样注册了我们的`TopComponent`，并反映了我们放置它的选择和何时打开它的选择。
- en: 'We also have some internationalization and localization work being done for
    us, as shown next:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些国际化和本地化工作正在进行，如下所示：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Without getting too far into the details and risking confusing things, the
    first three annotations register an open Action, and expose an item in the `Window`
    menu of our application. The last annotation, `@Messages`, is used to define the
    localization keys and strings. When this class is compiled, a class called `Bundle`
    is created in the same package, which defines methods using the specified keys
    to return the localized string. For example, for `CTL_PhotoListAction`, we get
    the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过多涉及细节并冒险混淆事情，前三个注释注册了一个开放的操作，并在我们的应用程序的“窗口”菜单中公开了一个项目。最后一个注释“@Messages”用于定义本地化键和字符串。当这个类被编译时，同一个包中会创建一个名为“Bundle”的类，该类使用指定的键来返回本地化字符串。例如，对于“CTL_PhotoListAction”，我们得到以下内容：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This preceding code looks up the key in the standard Java `.properties` file
    for a localized message. These key/value pairs are merged with any entries found
    in the `Bundle.properties` file that the NetBeans wizard generated for us.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码查找了标准Java的`.properties`文件中的本地化消息的键。这些键值对与NetBeans向我们生成的`Bundle.properties`文件中找到的任何条目合并。
- en: 'The following constructor of our `TopComponent` is also of interest:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`TopComponent`的以下构造函数也很有趣：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding constructor, we can see how the component's name and tool tip
    are set, as well as where our window-related options are set.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述构造函数中，我们可以看到组件的名称和工具提示是如何设置的，以及我们的与窗口相关的选项是如何设置的。
- en: 'If we run our application now, we won''t see any changes. What we need to do,
    then, is add a dependency on the `main` module to the application. We do that
    by right-clicking on the Dependencies node of the app module, as shown in this
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行我们的应用程序，我们不会看到任何变化。因此，我们需要在应用程序中添加对“main”模块的依赖。我们可以通过右键单击应用程序模块的“Dependencies”节点来实现这一点，如下图所示：
- en: '![](img/1aa28e23-b962-4fad-8f55-67e404fea645.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1aa28e23-b962-4fad-8f55-67e404fea645.png)'
- en: 'You should now see the Add Dependency window. Select the Open Projects tab,
    then select `main` as shown in this screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该看到“添加依赖项”窗口。选择“打开项目”选项卡，然后选择“main”，如下图所示：
- en: '![](img/914375f3-13e0-441f-aa45-afb38ecada31.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/914375f3-13e0-441f-aa45-afb38ecada31.png)'
- en: 'Once we''ve added the dependency, we need to build both modules, first `main`
    and then `app`, and then we''ll be ready to run PhotoBeans for the first time:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们添加了依赖项，我们需要先构建“main”模块，然后构建“app”，然后我们就可以准备运行PhotoBeans了：
- en: '![](img/22f3de03-4365-44a0-b88d-271ea1359073.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22f3de03-4365-44a0-b88d-271ea1359073.png)'
- en: Notice the odd date in the window title in the preceding screen? That's the
    build date of the NetBeans platform, and it's not very pretty in our app, so,
    let's fix that. We have two options. The first is to use the Branding user interface
    we looked at earlier. The other is to edit the file directly. To keep things interesting,
    and to help understand where things are on the disk, we'll use this second approach.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上一个屏幕中窗口标题中的奇怪日期？那是NetBeans平台的构建日期，在我们的应用程序中看起来不太好看，所以让我们来修复一下。我们有两个选择。第一个是使用我们之前看过的品牌用户界面。另一个是直接编辑文件。为了保持事情的有趣，并帮助理解磁盘上的位置，我们将使用第二种方法。
- en: 'In the branding module, under Other Sources | nbm-branding, you should find
    the `modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/ view/ui/Bundle.properties`
    file. In this file, you should see these lines:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在品牌模块中，在其他来源|nbm-branding下，您应该找到`modules/org-netbeans-core-windows.jar/org/netbeans/core/windows/
    view/ui/Bundle.properties`文件。在这个文件中，您应该看到这些行：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All we need to do is remove the `{0}` portions, rebuild this module and the
    app, and our title bar is much prettier. While that looks better, what about our
    TopComponent? To fix that, we need to learn a few new concepts.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所需要做的就是删除“{0}”部分，重新构建这个模块和应用程序，我们的标题栏就会变得更漂亮。虽然看起来更好了，但是我们的TopComponent呢？为了解决这个问题，我们需要学习一些新的概念。
- en: Nodes, a NetBeans presentation object
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节点，NetBeans演示对象
- en: You've already heard the term Node. I've used it several times to describe what
    and where to click. Officially, a Node represents one element in a hierarchy of
    objects (beans). It provides all the methods that are needed for communication
    between an explorer view and the bean. In the explorer section of our application,
    we want to represent a list of photos to the user. We'll represent each photo,
    as well as the year and month in which it was taken, as a Node. To display these
    Nodes, we'll use a NetBeans class called the `BeanTreeView`, which will display
    this node hierarchy as a tree. There are a few more concepts to learn, but let's
    start with what we have first.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经听过Node这个术语。我已经多次使用它来描述点击的内容和位置。正式地说，一个Node代表对象（bean）层次结构中的一个元素。它提供了在资源管理器视图和bean之间进行通信所需的所有方法。在我们的应用程序的资源管理器部分，我们希望向用户表示照片列表。我们将每张照片以及拍摄日期和月份表示为一个Node。为了显示这些节点，我们将使用一个名为`BeanTreeView`的NetBeans类，它将以树形式显示这个节点层次结构。还有一些概念需要学习，但让我们先从现有的开始。
- en: We'll begin by defining our Nodes, which will serve as a sort of wrapper or
    bridge between our application's business domain model and the NetBeans APIs.
    We have not, of course, defined such a model, so we need to settle on that now.
    Our basic data item is a photograph, a file on disk that holds an image. In the
    application, we're going to display these photos in a nested tree structure, grouping
    the photos by year, then month. If you expand a year node, you'll see a list of
    month Nodes, and if you expand a month Node, you'll see a list of photo Nodes.
    It's a very basic, somewhat naive data model, but it's both, effective enough
    to demonstrate the concepts, and simple enough that we don't obscure the concepts.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先定义我们的节点，它们将作为我们应用程序业务领域模型和NetBeans API之间的一种包装或桥梁。当然，我们还没有定义这样的模型，所以现在需要解决这个问题。我们的基本数据项是一张照片，是存储在磁盘上的图像文件。在应用程序中，我们将以嵌套树结构显示这些照片，按年份和月份进行分组。如果展开一个年份节点，您将看到一个月份节点列表，如果展开一个月份节点，您将看到一个照片节点列表。这是一个非常基本、有些天真的数据模型，但它足够有效地演示了这些概念，同时也足够简单，不会使概念变得模糊。
- en: 'As with all hierarchies, we need a root node, so we''ll start with that:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有层次结构一样，我们需要一个根节点，所以我们将从那里开始：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The base class of all nodes is, technically, Node, but extending that class
    puts much more of a burden on us, so we use the NetBeans-provided `AbstractNode`,
    which implements a fair amount of the basic behavior of the node for us with reasonable
    defaults.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 所有节点的基类在技术上是Node，但扩展该类会给我们带来更多的负担，因此我们使用NetBeans提供的`AbstractNode`，它为我们实现了大量节点的基本行为，并提供了合理的默认值。
- en: 'Next, we define some constructors as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一些构造函数，如下所示：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we have two constructors, one `public` and one `protected`. The reason
    for that is that we want to create and capture an instance of `InstanceContent`,
    which can be used by us, the creators of this class' Lookup, to control what is
    actually in the lookup. Since we need to pass `Lookup` to our class' parent constructor,
    we have this two-step approach to object instantiation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们有两个构造函数，一个是`public`，一个是`protected`。之所以这样做是因为我们想要创建和捕获`InstanceContent`的实例，这样我们作为这个类Lookup的创建者就可以控制Lookup中实际包含的内容。由于我们需要将Lookup传递给我们类的父构造函数，所以我们采用了这种两步实例化对象的方法。
- en: Lookup, a NetBeans fundamental
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lookup，NetBeans的基础
- en: What's a Lookup? It is a **general registry permitting clients to find instances
    of services (implementation of a given interface)**. To put it another way, it
    is a mechanism by which we can publish various artifacts, and other parts of the
    system can look up these artifacts by a key (either a `Class` or a `Lookup.Template`,
    which we'll not discuss here), with no coupling between the modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Lookup？它是一个**通用注册表，允许客户端找到服务的实例（给定接口的实现）**。换句话说，它是一个机制，通过它我们可以发布各种工件，系统的其他部分可以通过一个键（可以是`Class`或`Lookup.Template`，这里我们不讨论）查找这些工件，模块之间没有耦合。
- en: This is often used, as we'll see, to look up the implementations of a service
    interface. Do you recall earlier when I mentioned that often we see APIs defined
    in one module and implementations in another? This is where that comes in especially
    handy. Suppose you're developing an API to retrieve photos from an online service
    (which would be a great feature for this application!). You plan to deliver an
    implementation for one service, say Google Photos, but want to enable a third-party
    developer to provide an implementation for, say, Flickr. If you put the required
    API interfaces, classes, and so on in one module, and your Google Photos implementation
    in another, the third-party developer can depend on your API module alone, and
    avoid the weight of your implementation module. The Flickr module would declare
    an implementation of the photo service API, and we could load both that and our
    own Google Photos implementation via a request to the Lookup. In a nutshell, the
    system allows for decoupling the API definition, implementation, and instance
    acquisition in a very clean, simple API.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常用于查找服务接口的实现。您还记得我之前提到过吗？通常我们会看到API在一个模块中定义，而实现在另一个模块中。这就是它特别方便的地方。假设您正在开发一个从在线服务中检索照片的API（这将是该应用程序的一个很棒的功能！）。您计划为一个服务提供实现，比如Google照片，但希望让第三方开发人员为Flickr提供实现。如果您将所需的API接口、类等放在一个模块中，将Google照片的实现放在另一个模块中，第三方开发人员可以仅依赖于您的API模块，避免依赖于您的实现模块。Flickr模块将声明照片服务API的实现，我们可以通过查找请求加载Flickr和我们自己的Google照片实现。简而言之，该系统允许在一个非常干净、简单的API中解耦API定义、实现和实例获取。
- en: That's Lookup, but what is `InstanceContent`? The Lookup API only exposes methods
    for getting items. There is no mechanism for adding items to the Lookup, which
    makes sense as the Lookup instance is used by unknown third parties, and we don't
    want them changing the contents of our Lookup randomly. We, however, may actually
    want to change those contents, and we do that via `InstanceContent`, which exposes
    the methods we need to add or remove items. We'll see a demonstration of this
    concept later in the application.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Lookup，但是`InstanceContent`是什么？Lookup API只公开了获取项目的方法。没有机制可以向Lookup添加项目，这是有道理的，因为Lookup实例是由未知的第三方使用的，我们不希望他们随机更改我们的Lookup的内容。然而，我们可能确实希望更改这些内容，我们可以通过`InstanceContent`来实现，它公开了我们需要添加或删除项目的方法。我们将在应用程序的后续部分看到这个概念的演示。
- en: Writing our own nodes
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们自己的节点
- en: 'The preceding section covered those two classes, but what is `YearChildFactory`?
    The class `RootNode` defines for the system the root node of what will become
    our tree. Each node, though, if it has children, is responsible for loading and
    building those child Nodes, which is done through this `ChildFactory` class. Our
    instance looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的部分涵盖了这两个类，但是`YearChildFactory`是什么？类`RootNode`为系统定义了将成为我们树的根节点。但是，如果节点有子节点，它负责加载和构建这些子节点，这是通过这个`ChildFactory`类完成的。我们的实例看起来是这样的：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are creating a `ChildFactory` interface that will return nodes that operate
    on Strings. If you have a more complex data model, one that uses, for example,
    POJOs, you would specify that class as the parameterized type.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在创建一个`ChildFactory`接口，它将返回操作字符串的节点。如果您有一个更复杂的数据模型，例如使用POJOs的模型，您可以将该类指定为参数化类型。
- en: 'In our constructor, we see an example of finding a service implementation via
    the Lookup, which is this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的构造函数中，我们看到了通过Lookup查找服务实现的示例，就是这样：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We'll look at defining services later, but, for now, all you need to understand
    is that we're asking the global Lookup (which is, unlike the Lookup we created
    previously, not tied to a particular class) for an instance of the `PhotoManager`
    interface. Perhaps naively, we assume there is only one instance of this interface,
    but since we're not exporting the interface, we are safe in our assumption. We
    do, though, check to make sure there is at least one, exiting the application
    if there is not.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将讨论定义服务，但是现在，您需要理解的是，我们正在向全局Lookup（与我们之前创建的Lookup不同，它不与特定类绑定）请求`PhotoManager`接口的一个实例。或许有些天真，我们假设只有一个这个接口的实例，但由于我们没有导出这个接口，我们对这个假设感到放心。不过，我们确实检查确保至少有一个实例，如果没有，就退出应用程序。
- en: The next two methods are how the factory is used to create the child Nodes.
    The first method, `createKeys(List<String> list)`, is called by the system to
    generate a list of keys for the child nodes. In our implementation, we ask the
    `PhotoManager` interface for a list of years (which, as we'll see, is a simple
    query of the database to get a list of the years for which we have photos in the
    system). The platform then takes these keys, and passes them, one at a time, to
    `createNodeForKey(String key)` to create the actual node. Here, we create an instance
    of `YearNode` to represent the year.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个方法是工厂用来创建子节点的方法。第一个方法`createKeys(List<String> list)`是系统调用的，用于生成子节点的键列表。在我们的实现中，我们要求`PhotoManager`接口提供年份列表（正如我们将看到的，这是对数据库的一个简单查询，用于获取系统中我们拥有照片的年份列表）。然后平台获取这些键，并逐个传递给`createNodeForKey(String
    key)`来创建实际的节点。在这里，我们创建一个`YearNode`的实例来表示这一年。
- en: '`YearNode`, like `RootNode`, extends `AbstractNode`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`YearNode`，就像`RootNode`一样，扩展了`AbstractNode`。'
- en: '[PRE10]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding is clearly a simpler node, but the basics are the same--we create
    `ChildFactory` to create our children, and we create a Lookup, which, in this
    case, holds a single value, the year that the Node represents.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的内容显然是一个更简单的节点，但基本原理是一样的——我们创建`ChildFactory`来创建我们的子节点，我们创建一个Lookup，在这种情况下，它保存了一个值，即节点表示的年份。
- en: '`MonthNodeFactory` looks almost exactly like `YearNodeFactory` with the exception
    that it loads months for the given year, so we''ll not show the source here. It
    also creates `MonthNode` instances for each month in the list. Like `YearNode`,
    `MonthNode` is pretty simple, as you can see in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonthNodeFactory`看起来几乎和`YearNodeFactory`一样，唯一的区别是它为给定年份加载月份，所以我们不会在这里显示源代码。它还为列表中的每个月创建`MonthNode`实例。像`YearNode`一样，`MonthNode`非常简单，您可以在以下代码片段中看到：'
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We do a bit more work to give the Node a meaningful name and display name,
    but it''s pretty much the same. Note also that we have yet another `ChildFactory`
    that will generate, as the name implies, the PhotoNodes we''ll need as children.
    The factory itself has nothing new of interest, but `PhotoNode` does, so let''s
    take a look at that:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了更多的工作来给节点一个有意义的名称和显示名称，但基本上是一样的。还要注意，我们有另一个`ChildFactory`，它将生成我们需要的`PhotoNodes`作为子节点。工厂本身没有什么新鲜的内容，但`PhotoNode`有，所以让我们来看看它：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we again see the dual constructor approach, though, in this case, we do
    make use of `InstanceContent`. Note that the first parameter to `super()` is `Children.LEAF`,
    indicating that this Node does not have any children. We also pass the now familiar
    `new AbstractLookup(ic)`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次看到了双构造函数方法，不过，在这种情况下，我们确实使用了`InstanceContent`。请注意，`super()`的第一个参数是`Children.LEAF`，表示这个节点没有任何子节点。我们还传递了现在熟悉的`new
    AbstractLookup(ic)`。
- en: 'After setting the name and display name, we add a lambda to our `InstanceContent`
    object. The non-lambda version of this would look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设置名称和显示名称后，我们向`InstanceContent`对象添加了一个lambda。没有lambda版本的代码如下：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What is `OpenCookie`? It's a child of the marker interface `Node.Cookie`, and
    a cookie is **a design pattern used to add behaviors to existing data objects
    and nodes, or to separate implementation from the main object**. Using this cookie,
    we can neatly abstract away the signaling that something can be opened as well
    as how to open it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenCookie`是什么？它是标记接口`Node.Cookie`的子接口，cookie是**一种设计模式，用于向现有数据对象和节点添加行为，或将实现与主对象分禅**。使用这个cookie，我们可以很好地抽象出可以打开的信号以及如何打开它。'
- en: In this case, when the system tries to open the photo represented by the node,
    it will call our definition of `OpenCookie.open()`, which will attempt to find
    an open instance of the photo. Whether it finds an existing one or needs to create
    a new one, it instructs the system to make it active (or give it focus).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，当系统尝试打开节点表示的照片时，它将调用我们定义的`OpenCookie.open()`，该方法将尝试找到照片的打开实例。无论它找到现有的还是需要创建新的，它都会指示系统使其活动（或者给予焦点）。
- en: 'Note that the open photo is represented by another TopComponent. To find it,
    we have this method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，打开的照片由另一个TopComponent表示。为了找到它，我们有这个方法：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We ask the Lookup of `WindowManager` for all the opened TopComponents, then
    iterate through each, comparing `String photo`, which is the full path of the
    image, with any `String` stored in the Lookup of TopComponent. If there's a match,
    we return that TopComponent. This lookup by `String` is somewhat naive though,
    and could, in more complex applications, result in unexpected matches. We're likely
    safe enough in this application, but you'll need to make sure in your own application
    that the matching criteria are strict and unique enough to avoid false hits.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要求`WindowManager`的查找器获取所有打开的TopComponents，然后遍历每一个，将`String photo`（即图像的完整路径）与TopComponent的查找中存储的任何`String`进行比较。如果有匹配项，我们就返回该TopComponent。这种按`String`查找有点天真，可能会在更复杂的应用程序中导致意外的匹配。在本应用程序中，我们可能足够安全，但在您自己的应用程序中，您需要确保匹配标准足够严格和唯一，以避免错误的匹配。
- en: Performing Actions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行操作
- en: We'll look at `PhotoViewerTopComponent` in a moment, but there are a few more
    items we need to look at before moving on to that.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会看一下`PhotoViewerTopComponent`，但在继续之前，我们需要看一些其他项目。
- en: '`PhotoNode` overrides two additional methods, which are as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`PhotoNode`覆盖了另外两个方法，如下所示：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unsurprisingly, the `getActions()` method returns an array of Actions for this
    Node. Actions are an abstraction (from Swing, not NetBeans) that allow us to add
    items to menus, and provide a means for a user to interact with the system. Each
    entry you see in the main menu or a context menu is backed by an Action. In our
    case, we're associating the NetBeans-defined `OpenAction` with our node, which
    will, when clicked, look for an `OpenCookie` instance in the Node's lookup and
    call `OpenCookie.open()`, which we defined previously.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，`getActions()`方法返回了一个用于该节点的操作数组。操作是一个抽象（来自Swing，而不是NetBeans），它允许我们向菜单添加项目，并为用户与系统交互提供一种方式。主菜单或上下文菜单中的每个条目都由操作支持。在我们的情况下，我们将NetBeans定义的`OpenAction`与我们的节点关联起来，当点击时，它将在节点的查找中查找`OpenCookie`实例并调用`OpenCookie.open()`，这是我们之前定义的。
- en: We also override `getPreferredAction()`, which lets us define the behavior for
    when a Node is double-clicked. The combination of these two methods makes it possible
    for the user to right-click a Node and select `Open`, or double-click a Node,
    with the end result being that the TopComponent for that Node is opened.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还覆盖了`getPreferredAction()`，这让我们定义了当节点被双击时的行为。这两种方法的结合使用户可以右键单击一个节点并选择“打开”，或者双击一个节点，最终结果是打开该节点的TopComponent。
- en: Services - exposing decoupled functionality
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务 - 暴露解耦功能
- en: 'Before looking at the definition of our `TopComponent`, let''s look at `PhotoManager`,
    and learn a bit about its services. The `PhotoManager` interface itself is pretty
    simple:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看我们的`TopComponent`的定义之前，让我们先看看`PhotoManager`，并了解一下它的服务。`PhotoManager`接口本身非常简单：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is little of interest in the preceding code beyond the `extends Lookup.Provider`
    portion. Adding this here, we can force implementations to implement the lone
    method on that interface, as we''ll need that later. The interesting part comes
    from the implementation, which is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，除了`extends Lookup.Provider`部分外，没有什么值得注意的。通过在这里添加这个，我们可以强制实现来实现该接口上的唯一方法，因为我们以后会需要它。有趣的部分来自实现，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That is all it takes to register a service with the platform. The annotation
    specifies the metadata needed, and the build takes care of the rest. Let''s take
    a look at the rest of the implementation:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是向平台注册服务所需的全部内容。注解指定了所需的元数据，构建会处理其余部分。让我们来看看实现的其余部分：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this preceding, very simple, implementation, we're going to use SQLite to
    store information about the photos we find. The service will provide the code
    to scan the configured source directories, store information about the photos
    found, and expose methods for retrieving those pieces of that information that
    vary in specificity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的实现中，我们将使用SQLite来存储我们找到的照片的信息。该服务将提供代码来扫描配置的源目录，存储找到的照片信息，并公开检索那些在特定性上变化的信息的方法。
- en: To start with, we need to make sure that the database is properly set up if
    this is the first time the application is run. We could include a prebuilt database,
    but creating it on the user's machine adds a bit of resilience for those situations
    where the database is accidentally deleted.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保数据库在应用程序首次运行时已经正确设置。我们可以包含一个预构建的数据库，但在用户的机器上创建它可以增加一些弹性，以应对数据库意外删除的情况。
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, we ask for a reference to the NetBeans preferences for the module `PhotoManager`.
    We'll look at managing preferences later in the chapter where we'll delve into
    this API in more detail, but, for now, we'll say only that we are going to ask
    the system for the `sourceDirs` preference, which we'll then use to configure
    our scanning code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们要求引用`PhotoManager`模块的NetBeans首选项。我们将在本章后面更详细地探讨管理首选项，但现在我们只说我们将要向系统请求`sourceDirs`首选项，然后将其用于配置我们的扫描代码。
- en: We also create `PreferenceChangeListener` to capture when the user changes the
    preferences. In this listener, we verify that the preference we care about, `sourceDirs`,
    was changed, and, if it was, we store the new value in our `PhotoManager` instance,
    and initiate a directory scan.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了`PreferenceChangeListener`来捕获用户更改首选项的情况。在这个监听器中，我们验证我们关心的首选项`sourceDirs`是否已更改，如果是，我们将新值存储在我们的`PhotoManager`实例中，并启动目录扫描。
- en: Finally, we create `InstanceContent`, create and store a Lookup, and start a
    directory scan to make sure the application is up-to-date with the state of the
    photos on disk.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建`InstanceContent`，创建并存储一个Lookup，并开始扫描目录，以确保应用程序与磁盘上的照片状态保持最新。
- en: 'The `getYears()`, `getMonths()`, and `getPhotos()` methods are largely the
    same, differing only, of course, in the type of data they''re working with, so
    we''ll let `getYears()` serve as an explanation of all three:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`getYears()`、`getMonths()`和`getPhotos()`方法基本相同，当然，它们的工作数据类型不同，所以我们让`getYears()`来解释这三个方法：'
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If you are familiar with JDBC, this should not be surprising. We use Java 7's
    `try-with-resources` syntax to declare and instantiate both our `Statement` and
    our `ResultSet` objects. For those not familiar with this construct, it allows
    us to declare certain types of resource, and not have to worry about closing them
    as the system automatically closes them for us once the scope of the `try` terminates.
    The major restriction to be aware of with this, however, is that the class must
    implement `AutoCloseable`; a `Closeable` will not work. The other two `get*` methods
    are logically similar, so they are not shown here.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉JDBC，这应该不足为奇。我们使用Java 7的`try-with-resources`语法来声明和实例化我们的`Statement`和`ResultSet`对象。对于不熟悉这种结构的人来说，它允许我们声明某些类型的资源，并且一旦`try`的范围终止，系统会自动关闭它们，因此我们不必担心关闭它们。但需要注意的主要限制是，该类必须实现`AutoCloseable`；`Closeable`不起作用。其他两个`get*`方法在逻辑上是类似的，因此这里不再显示。
- en: 'The last major piece of functionality here is the scanning of source directories,
    which is coordinated by the `scanSourceDirs()` method, given as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后一个重要功能是源目录的扫描，由`scanSourceDirs()`方法协调，如下所示：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: To speed the process up a bit, we create Future for each configured source directory,
    which we pass to our `ExecutorService`. We have it configured at a maximum of
    five threads in the pool, which is largely arbitrary. A more sophisticated approach
    might make this configurable, or perhaps, auto-tuned, but this should be sufficient
    for our purposes here.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快这个过程，我们为每个配置的源目录创建一个Future，然后将它们传递给我们的`ExecutorService`。我们将其配置为池中最多有五个线程，这在很大程度上是任意的。更复杂的方法可能会使其可配置，或者自动调整，但对于我们的目的来说，这应该足够了。
- en: Once the Futures are created, we iterate over the list, requesting each result.
    If the number of source directories exceeds the size of our thread pool, the excess
    Futures will wait until a Thread becomes available, at which point the `ExecutorService`
    will pick one to run. Once they're all done, the calls to `.get()` will no longer
    block, and the application can continue. Note that we're not blocking the user
    interface to allow this to work, as we pass the bulk of this method as a lambda
    to `RequestProcessor.getDefault().execute()` to request that this run off the
    user interface thread.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Futures被创建，我们遍历列表，请求每个结果。如果源目录的数量超过了我们线程池的大小，多余的Futures将等待直到有一个线程可用，此时`ExecutorService`将选择一个线程来运行。一旦它们都完成了，对`.get()`的调用将不再阻塞，应用程序可以继续。请注意，我们没有阻塞用户界面来让这个方法工作，因为我们将这个方法的大部分作为lambda传递给`RequestProcessor.getDefault().execute()`，以请求在用户界面线程之外运行。
- en: 'When the list of photos has been built and returned, we process those photos
    with this method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当照片列表构建并返回后，我们用这个方法处理这些照片：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `isImageRecorded()` method checks to see if the image path is already in
    the database, returning true if it is. We `filter()` the stream based on the result
    of this test, so `forEach()` only operates on previously unknown images, which
    are then inserted into the database via `insertImage()`. Those two methods look
    like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`isImageRecorded()` 方法检查图像路径是否已经在数据库中，如果是，则返回true。我们根据这个测试的结果对流进行`filter()`操作，所以`forEach()`只对之前未知的图像进行操作，然后通过`insertImage()`将它们插入到数据库中。这两种方法看起来是这样的：'
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using `PreparedStatement`, as it is, generally, unwise to create SQL
    statements via concatenation, which can, and often does, lead to SQL injection
    attacks, so we can't use `try-with-resources` fully in the first method, requiring
    us to close the `ResultSet` manually.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`PreparedStatement`，因为通常通过连接创建SQL语句是不明智的，这往往会导致SQL注入攻击，所以我们无法在第一个方法中完全使用`try-with-resources`，需要手动关闭`ResultSet`。
- en: PhotoViewerTopComponent
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PhotoViewerTopComponent
- en: We can now find images, but we still can't tell the system where to look. Before
    turning our attention to handling preferences with the NetBeans platform, though,
    we have one more TopComponent to look at--`PhotoViewerTopComponent`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以找到图像，但我们仍然不能告诉系统去哪里找。在转向处理NetBeans平台的偏好设置之前，我们还有一个TopComponent要看一看--`PhotoViewerTopComponent`。
- en: 'If you think back to our discussion of the areas provided by the NetBeans window
    system, when we view an image, we want the image to be loaded in the `Editor`
    area. To create a TopComponent for that, we instruct NetBeans to create a new
    `Window` by right-clicking on the desired package, and selecting New | Window:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想一下我们在NetBeans窗口系统提供的区域的讨论，当我们查看一张图片时，我们希望图片加载到`Editor`区域。为此，我们指示NetBeans通过右键单击所需的包，并选择New
    | Window来创建一个TopComponent：
- en: '![](img/ae06490b-677c-4e4c-957f-8f075658b0b8.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ae06490b-677c-4e4c-957f-8f075658b0b8.png)'
- en: 'In the next pane, we specify a class name prefix for our new TopComponent--`PhotoViewer`
    as seen in the following screenshot:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个窗格中，我们为新的TopComponent指定一个类名前缀--如下截图所示的`PhotoViewer`：
- en: '![](img/b5e21806-8be6-417b-b315-27f30b73c35a.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5e21806-8be6-417b-b315-27f30b73c35a.png)'
- en: NetBeans will now create the files `PhotoViewerTopComponent.java` and `PhotoViewerTopComponent.form`
    just as was discussed earlier. For this TopComponent, though, we need to make
    a couple of changes. When we open the `Window`, we need to specify an image for
    it to load, so we need to provide a constructor that takes the path to the image.
    However, TopComponents must have a no-argument constructor, so we leave it but
    have it call our new constructor with an empty image path.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans现在将创建文件`PhotoViewerTopComponent.java`和`PhotoViewerTopComponent.form`，就像之前讨论的那样。不过，对于这个TopComponent，我们需要做一些改变。当我们打开`Window`时，我们需要指定一个要加载的图片，因此我们需要提供一个带有图片路径的构造函数。然而，TopComponents必须有一个无参数的构造函数，所以我们保留它，但让它调用我们的新构造函数并传入空的图片路径。
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'While it may seem like a lot, the steps here are simple: we save the photo
    path in an instance variable, we create a `File` instance from it to get the file
    name more easily, add the photo path to TopComponent''s Lookup (which is how we
    find the TopComponent for a given photo), change the layout, and then initialize
    the window.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能看起来很多，但这里的步骤很简单：我们将照片路径保存在一个实例变量中，然后从中创建一个`File`实例，以便更容易地获取文件名，将照片路径添加到TopComponent的Lookup中（这是我们如何找到给定照片的TopComponent），更改布局，然后初始化窗口。
- en: Integrating JavaFX with the NetBeans RCP
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将JavaFX与NetBeans RCP集成
- en: The `init()` method is interesting, though, in that we're going to do something
    slightly different; we're going to use JavaFX to view the image. There's no reason
    we couldn't use Swing like we are in our other TopComponent, but this gives us
    a good opportunity to demonstrate both how to integrate JavaFX and Swing, as well
    as JavaFX and the NetBeans platform.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`init()`方法很有趣，因为我们将做一些略有不同的事情；我们将使用JavaFX来查看图片。我们在其他TopComponent中也可以使用Swing，但这给了我们一个很好的机会，可以演示如何集成JavaFX和Swing，以及JavaFX和NetBeans平台。'
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`JFXPanel` is a Swing component that is used to embed JavaFX into Swing. Our
    Window''s layout is `BorderLayout`, so we add our `JFXPanel` to it in the `CENTER`
    area, and let it expand to fill the `Window`. Any complex layout of the JavaFX
    components will be handled by yet another container inside our `JFXPanel`. Our
    user interface, though, is fairly simple. As with our earlier JavaFX systems,
    we define our user interface via FXML as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`JFXPanel`是一个Swing组件，用于将JavaFX嵌入Swing中。我们的窗口布局是`BorderLayout`，所以我们将`JFXPanel`添加到`CENTER`区域，并让它扩展以填充`Window`。JavaFX组件的任何复杂布局将由我们`JFXPanel`内的另一个容器处理。不过，我们的用户界面相当简单。与我们之前的JavaFX系统一样，我们通过FXML定义用户界面如下：'
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since FXML needs a root element, we specify a `BorderLayout`, which, as discussed,
    gives us a `BorderLayout` in a `JFXPanel` in a `BorderLayout`. That may sound
    really odd, but that''s how embedding JavaFX works. Note also that we still specify
    a controller. In that controller, our `initialize()` method looks like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FXML需要一个根元素，我们指定了一个`BorderLayout`，正如讨论的那样，这给了我们在`JFXPanel`中的`BorderLayout`。这可能听起来很奇怪，但这就是嵌入JavaFX的工作方式。还要注意的是，我们仍然指定了一个控制器。在该控制器中，我们的`initialize()`方法如下：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this last method, all we're doing is binding the width and height properties
    to those of the border pane. We've also set `preserveRatio` to `True` in the FXML,
    so the image won't be distorted. This will be important as we rotate the image
    next.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种最后的方法中，我们所做的就是将宽度和高度属性绑定到边界窗格的属性上。我们还在FXML中将`preserveRatio`设置为`True`，这样图片就不会被扭曲。当我们旋转图片时，这将很重要。
- en: 'We haven''t seen the code for rotation, so let''s look at that now. We''ll
    start by adding a button as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到旋转的代码，所以现在让我们来看一下。我们将首先添加一个按钮，如下所示：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To the `top` section of `BorderPane`, we add `ButtonBar`, to which we add a
    single `SplitMenuButton`. That gives us a button like the one to the right. In
    its non-focused state, it looks like a normal button. When the user clicks on
    the arrow, the menu, as seen here, is presented to the user, offering the ability
    to rotate the image in the directions listed:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BorderPane`的`top`部分，我们添加了`ButtonBar`，然后添加了一个单独的`SplitMenuButton`。这给了我们一个像右侧的按钮。在非焦点状态下，它看起来像一个普通按钮。当用户点击箭头时，菜单会呈现给用户，提供了在列出的方向中旋转图片的能力：
- en: '![](img/b50c9cc1-2b53-4144-b3dd-e2065ed1c24f.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b50c9cc1-2b53-4144-b3dd-e2065ed1c24f.png)'
- en: 'We''ve tied those MenuItems to the appropriate methods in the controller in
    our FXML definition:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这些MenuItems绑定到了FXML定义中控制器中的适当方法：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Using the APIs provided by the JavaFX `ImageView`, we set the image rotation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaFX `ImageView`提供的API，我们设置了图片的旋转。
- en: We can find images, view them, and rotate them, but we still can't tell the
    system where to look for those images. It's time to fix that.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到图片，查看它们，并旋转它们，但我们仍然不能告诉系统在哪里查找这些图片。是时候解决这个问题了。
- en: NetBeans preferences and the Options panel
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NetBeans首选项和选项面板
- en: 'The key to managing preferences is two-fold: `NbPreferences` and the Options
    panel. `NbPreferences` is the means by which preferences are stored and loaded,
    and the options panel is the means by which the user is presented with a user
    interface for editing those preferences. We''ll start by looking at how to add
    an Options panel, which will lead naturally to the `NbPreferences` discussion.
    Next is the NetBeans Options window:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 管理首选项的关键在于`NbPreferences`和选项面板。`NbPreferences`是存储和加载首选项的手段，选项面板是向用户提供用于编辑这些首选项的用户界面的手段。我们将首先看看如何添加选项面板，这将自然地引向`NbPreferences`的讨论。接下来是NetBeans选项窗口：
- en: '![](img/303583cd-79b6-4894-b79b-82822cd57d77.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/303583cd-79b6-4894-b79b-82822cd57d77.png)'
- en: 'In the preceding window, we can see the two types of Options panel--primary
    and secondary. A primary Options panel is represented by icons across the top:
    General, Editor, Fonts & Colors, and so on. A secondary Options panel is a tab
    like we see in the middle section: Diff, Files, Output, and Terminal. When adding
    an Options panel, you must choose either primary or secondary. We''d like to add
    a new primary panel, as it will separate our preferences from the rest of the
    panels visually as well as giving us an opportunity to create both types of panel.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的窗口中，我们可以看到两种类型的选项面板--主选项和次要选项。主选项面板由顶部的图标表示：常规、编辑器、字体和颜色等。次要选项面板是一个选项卡，就像我们在中间部分看到的：Diff、Files、Output和Terminal。在添加选项面板时，您必须选择主选项或次要选项。我们想要添加一个新的主要面板，因为它将在视觉上将我们的首选项与其他面板分开，并且让我们有机会创建两种类型的面板。
- en: Adding a primary panel
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个主要面板
- en: 'To create a primary Options panel, right-click on the desired package or the
    project node, and click on New | Options Panel. If Options Panel is not visible,
    select New | Other | Module Development | Options Panel. Next, select Create Primary
    Panel:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个主选项面板，请右键单击所需的包或项目节点，然后单击“新建|选项面板”。如果选项面板不可见，请选择“新建|其他|模块开发|选项面板”。接下来，选择“创建主选项面板”：
- en: '![](img/cd62cb4c-24c6-4353-b665-7c86e6bd862f.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd62cb4c-24c6-4353-b665-7c86e6bd862f.png)'
- en: We must specify a label, which is the text we'll see under the icon. We must
    also select an icon. The system will let you select something other than a 32x32
    image, but if it's not the right size, it will look strange in the user interface;
    so, choose carefully. The system will also require you to enter keywords, which
    will be used if the user applies a filter to the Options window. Finally, select
    Allow Secondary Panels. The primary panel doesn't have any real content and serves
    only to display secondary panels, which we'll create shortly.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须指定一个标签，这是我们将在图标下看到的文本。我们还必须选择一个图标。系统将允许您选择除32x32图像之外的其他内容，但如果它不是正确的大小，它在用户界面中看起来会很奇怪；因此，请谨慎选择。系统还要求您输入关键字，如果用户对选项窗口应用了过滤器，将使用这些关键字。最后，选择“允许次要面板”。主要面板没有任何真正的内容，只用于显示次要面板，我们将很快创建。
- en: 'When you click on Next, you will be asked for the class prefix and package:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击“下一步”时，将要求您输入类前缀和包：
- en: '![](img/58423d52-bfb4-46b1-a482-499a076a6a7b.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/58423d52-bfb4-46b1-a482-499a076a6a7b.png)'
- en: 'When you click on Finish, NetBeans will create this single file, `package-info.java`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您点击“完成”时，NetBeans将创建这个单一文件，`package-info.java`：
- en: '[PRE30]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding a secondary panel
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加一个次要面板
- en: 'With the primary panel defined, we''re ready to create the secondary panel,
    which will do our work. We right-click on the package again, and select New |
    Options Panel, this time selecting Create Secondary Panel:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了主要面板后，我们准备创建次要面板，这将完成我们的工作。我们再次右键单击包，并选择“新建|选项面板”，这次选择“创建次要面板”：
- en: '![](img/497a878f-fe1c-4d38-9094-71b6db76400f.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/497a878f-fe1c-4d38-9094-71b6db76400f.png)'
- en: Since we've defined our own primary panel, we can select that as our parent,
    and we set the title and keywords as we did before. Click on Next, select and/or
    verify the class prefix and package, then click on Finish. This will create three
    artifacts--`SourceDirectoriesOptionPanelController.java`, `SourceDirectoriesPanel.java`,
    and `SourceDirectoriesPanel.form`, and NetBeans will present you with the GUI
    editor for your panel.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经定义了自己的主要面板，我们可以将其选择为我们的父级，并且像之前一样设置标题和关键字。点击“下一步”，选择和/或验证类前缀和包，然后点击“完成”。这将创建三个文件--`SourceDirectoriesOptionPanelController.java`、`SourceDirectoriesPanel.java`和`SourceDirectoriesPanel.form`，NetBeans将为您呈现面板的GUI编辑器。
- en: 'We want to add four elements to our panel--a label, a list view, and two buttons.
    We add those by dragging them from the palette on the right, and arranging them
    in the form as shown next:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要向我们的面板添加四个元素--一个标签、一个列表视图和两个按钮。我们通过从右侧的工具栏拖动它们，并将它们排列在下一个表单中来添加它们：
- en: '![](img/14b4277f-1eec-44c7-99a2-9873ee3f58aa.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14b4277f-1eec-44c7-99a2-9873ee3f58aa.png)'
- en: 'To make working with these user interface elements more meaningful, we need
    to set the variable names. We also need to set the text of the user interface
    so that each element is meaningful for the user. We can do both by right-clicking
    on each element, as shown in this screenshot:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使与这些用户界面元素的工作更有意义，我们需要设置变量名。我们还需要设置用户界面的文本，以便每个元素对用户来说都是有意义的。我们可以通过右键单击每个元素来做到这一点，如此屏幕截图所示：
- en: '![](img/e7a16fc5-c806-43c4-956e-c0101b9a51f4.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7a16fc5-c806-43c4-956e-c0101b9a51f4.png)'
- en: 'In the preceding screen, we can see the three items of interest--Edit Text,
    Change Variable Name..., and Events | Action | actionPeformed [buttonAddActionPerformed].
    For our buttons, we need to use all three, so we set the text to `Add` (or `Remove`),
    change the variable name to `buttonAdd`/`buttonRemove`, and select `actionPerformed`.
    Back in our Java source, we see a method created for us, which we need to fill
    out:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕上，我们可以看到三个感兴趣的项目--编辑文本、更改变量名称...和事件|操作|actionPeformed [buttonAddActionPerformed]。对于我们的按钮，我们需要使用所有三个，因此我们将文本设置为`Add`（或`Remove`），将变量名称更改为`buttonAdd`/`buttonRemove`，并选择`actionPerformed`。回到我们的Java源代码中，我们看到为我们创建的一个方法，我们需要填写它：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have quite a bit going on here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有很多事情要做：
- en: We start by retrieving the `lastDir` preference value. If set, we'll use this
    as the starting point for selecting the directories to add. Typically, at least
    in my experience, the directories of interest are, usually, pretty close to one
    another in the filesystem, so we use this preference to save the user some clicks.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先检索`lastDir`偏好值。如果设置了，我们将使用它作为选择要添加的目录的起点。通常，至少根据我的经验，感兴趣的目录在文件系统中通常相互靠近，因此我们使用这个偏好值来节省用户的点击次数。
- en: Next we create `JFileChooser`, which is the Swing class that will allow us to
    choose the directory.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建`JFileChooser`，这是一个Swing类，允许我们选择目录。
- en: If `lastDir` is not null, we pass it to `setCurrentDirectory()`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`lastDir`不为空，我们将其传递给`setCurrentDirectory()`。
- en: We set the title of the dialog to something meaningful.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将对话框的标题设置为有意义的内容。
- en: We specify that the dialog should only let us choose directories.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们指定对话框只能让我们选择目录。
- en: Finally, we disable the Select All file filter option.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们禁用“选择所有文件过滤器”选项。
- en: We call `chooser.showOpenDialog()` to present the dialog to the user, and wait
    for it close.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`chooser.showOpenDialog()`来向用户呈现对话框，并等待其关闭。
- en: If the return code from the dialog is `APPROVE_OPTION`, we need to add the chosen
    directory to our model.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果对话框的返回代码是`APPROVE_OPTION`，我们需要将所选目录添加到我们的模型中。
- en: We get the canonical path for the selected file.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取所选文件的规范路径。
- en: We call `ensureModel()`, which we'll look at in a moment, to get the model for
    our `ListView`, then add this new path to it.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`ensureModel()`，稍后我们将看到，以获取我们`ListView`的模型，然后将这个新路径添加到其中。
- en: Finally, we store the chosen path as `lastDir` in our preferences to set the
    starting directory as discussed earlier.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将所选路径存储为`lastDir`在我们的偏好中，以设置起始目录，如前所述。
- en: 'The action for the Remove button is much simpler, and is as follows:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除按钮的操作要简单得多，如下所示：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When we are removing items from the model, we remove them by the item index.
    However, when we remove an item, the index numbers for anything after that change.
    What we do here, then, is create a List of the selected indices, sort it to make
    sure it's in the right order (which is possibly excessive here, but it's a relatively
    inexpensive operation, and makes the next operation safer), then we reverse the
    order of the List. With our indices now in descending order, we can iterate over
    the List, removing each index from our model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从模型中删除项目时，我们按项目索引进行删除。但是，当我们删除一个项目时，之后的索引号会发生变化。因此，我们在这里所做的是创建一个选定索引的列表，对其进行排序以确保它处于正确的顺序（这可能在这里有些过度，但这是一个相对廉价的操作，并且使下一个操作更安全），然后我们反转列表的顺序。现在，我们的索引按降序排列，我们可以遍历列表，从我们的模型中删除每个索引。
- en: 'We''ve used `ensureModel()` a couple of times now, so let''s see what that
    looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经多次使用了`ensureModel()`，让我们看看它是什么样子的：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's important that we treat the model as `DefaultListModel` rather than the
    `ListModel` type that `ListView` expects, as the latter does not expose any methods
    for mutating the contents of the model, whereas the former does. By dealing with
    `DefaultListModel`, we can add and remove items as needed, as we've done here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们将模型视为`DefaultListModel`而不是`ListView`期望的`ListModel`类型，因为后者不公开任何用于改变模型内容的方法，而前者则公开。通过处理`DefaultListModel`，我们可以根据需要添加和删除项目，就像我们在这里所做的那样。
- en: Loading and saving preferences
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和保存偏好
- en: 'There are two more methods we need to look at in this class, the ones that
    load and store the options represented in the panel. We''ll start with `load()`,
    which is as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中还有两个我们需要看一下的方法，它们加载和存储面板中表示的选项。我们将从`load()`开始，如下所示：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`NbPreferences` does not support storing a list of strings, so, as we''ll see
    below, we store the list of source directories as a semicolon-delimited list of
    strings. Here, we load the value of `sourceDirs`, and, if not null, we split on
    the semicolon, and add each entry to our `DefaultListModel`.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`NbPreferences`不支持存储字符串列表，因此，正如我们将在下面看到的，我们将源目录列表存储为分号分隔的字符串列表。在这里，我们加载`sourceDirs`的值，如果不为空，我们在分号上拆分，并将每个条目添加到我们的`DefaultListModel`中。'
- en: 'Saving the source directories is also fairly straightforward:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 保存源目录也相当简单：
- en: '[PRE35]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We iterate over `ListModel`, adding each directory to a local `HashSet` instance,
    which helps us remove any duplicate directories. If `Set` is not empty, we use
    `String.join()` to create our delimited list, and `put()` it into our preferences
    store. If it is empty, we remove the preference entry from the store to clear
    out any old data that may have been persisted earlier.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历`ListModel`，将每个目录添加到本地`HashSet`实例中，这有助于我们删除任何重复的目录。如果`Set`不为空，我们使用`String.join()`创建我们的分隔列表，并将其`put()`到我们的偏好存储中。如果为空，我们将偏好条目从存储中删除，以清除可能早期持久化的任何旧数据。
- en: Reacting to changes in preferences
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对偏好更改做出反应
- en: 'Now that we can persist changes, we need to make the application react to the
    changes. Fortunately, the NetBeans RCP provides a neat, decoupled way to handle
    that. We need not explicitly call a method from our code here. We can attach a
    listener at the point in the system where we''re interested in the change. We''ve
    already seen this code back in `PhotoManagerImpl`:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以持久化更改，我们需要使应用程序对更改做出反应。幸运的是，NetBeans RCP提供了一种巧妙的、解耦的处理方式。我们不需要在这里从我们的代码中显式调用一个方法。我们可以在系统中感兴趣的变化点附加一个监听器。我们已经在`PhotoManagerImpl`中看到了这段代码：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When we save any preference for the `PhotoManager` module, this listener is
    called. We simply check to make sure it's for a key that we're interested in,
    and act accordingly, which, as we've seen, involves restarting the source directory
    scanning process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存`PhotoManager`模块的任何偏好设置时，将调用此监听器。我们只需检查确保它是我们感兴趣的键，并相应地采取行动，正如我们所见，这涉及重新启动源目录扫描过程。
- en: 'Once new data has been loaded, how do we make the user interface reflect that
    change? Do we have to update the user interface manually? Again, thanks to the
    RCP, the answer is no. We''ve seen the first half at the end of `scanSourceDirs()`,
    which is this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了新数据，我们如何使用户界面反映这种变化？我们需要手动更新用户界面吗？再次感谢RCP，答案是否定的。我们已经在`scanSourceDirs()`的末尾看到了前半部分，即：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'NetBeans has a number of cookie classes for indicating that certain actions
    should take place. While we don''t share the class hierarchy (due to the unfortunate
    dependency on the Nodes API), we do share the same nomenclature with the hope
    of stealing, so to speak, a bit of the familiarity. So what does `ReloadCookie`
    look like? There''s not much to it; it is given like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: NetBeans有许多cookie类来指示应该执行某些操作。虽然我们不共享类层次结构（由于不幸的依赖于节点API），但我们希望通过共享相同的命名方式来窃取一点熟悉感。那么`ReloadCookie`是什么样子呢？它并不复杂；它是这样给出的：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In our case, we just have an empty class. We don''t intend for this to be used
    elsewhere, so we don''t need to encode any functionality in the class. We will
    just be using this as an indicator, as we see in the constructor of `RootNode`,
    which is as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们只有一个空类。我们不打算在其他地方使用它，所以我们不需要在类中编码任何功能。我们将只是将其用作指示器，就像我们在 `RootNode`
    的构造函数中看到的那样，如下所示：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`Lookup.Template` is used to define the pattern by which the system can filter
    our `Lookup` requests. Using our template, we create a `Lookup.Result` object,
    `reloadResult`, and add a listener to it via a lambda. The lambda creates a new
    set of children using `Children.create()` and the `YearChildFactory` we looked
    at earlier, and passes those to `setChildren()` to update the user interface.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lookup.Template` 用于定义系统可以过滤我们的 `Lookup` 请求的模式。使用我们的模板，我们创建一个 `Lookup.Result`
    对象 `reloadResult`，并通过一个 lambda 为它添加一个监听器。这个 lambda 使用 `Children.create()` 和我们之前看过的
    `YearChildFactory` 创建了一组新的子节点，并将它们传递给 `setChildren()` 来更新用户界面。'
- en: That may seem like a fair bit of code just to update the user interface when
    a preference is changed, but the decoupling is certainly worth it. Imagine a more
    complicated application or a dependent module tree. Using this listener approach,
    we need not expose methods, or even classes, to the outside world, allowing our
    internal code to be modified without breaking client code. That is, in short,
    one of the primary reasons for decoupled code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是相当多的代码，只是为了在首选项更改时更新用户界面，但解耦肯定是值得的。想象一个更复杂的应用程序或一个依赖模块树。使用这种监听器方法，我们无需向外部世界公开方法，甚至类，从而使我们的内部代码可以在不破坏客户端代码的情况下进行修改。简而言之，这是解耦代码的主要原因之一。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Once again, we've come to the end of another application. You learned how to
    bootstrap a Maven-based NetBeans Rich Client Platform application. You learned
    about RCP modules, and how to include those modules in our application build.
    You also learned the basics of the NetBeans RCP Node API, how to create our own
    nodes, and how to nest child nodes. We explained how to use the NetBeans Preferences
    API, including creating new Options panels for editing preferences, how to load
    and store them, and how to react to changes in preferences.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 再一次，我们来到了另一个应用程序的尽头。你学会了如何引导基于 Maven 的 NetBeans 富客户端平台应用程序。你了解了 RCP 模块，以及如何将这些模块包含在我们的应用程序构建中。你还学会了
    NetBeans RCP Node API 的基础知识，如何创建我们自己的节点，以及如何嵌套子节点。我们解释了如何使用 NetBeans Preferences
    API，包括创建用于编辑首选项的新选项面板，如何加载和存储它们，以及如何对首选项的更改做出反应。
- en: One final word on the NetBeans RCP--While we have built a respectable application
    here, we have in no way pushed the limits of the RCP. I have attempted to cover
    just enough of the platform to get you going, but you will almost certainly need
    to learn more if you are to continue using the platform. While the official documentation
    is helpful, the go-to source for comprehensive coverage is *NetBeans Platform
    for Beginners* by Jason Wexbridge and Walter Nyland ([https://leanpub.com/nbp4beginners](https://leanpub.com/nbp4beginners)).
    It's a great book, and I highly recommend it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 NetBeans RCP 的最后一句话——虽然我们在这里构建了一个体面的应用程序，但我们并没有完全挖掘 RCP 的潜力。我尝试覆盖平台的足够部分来让你开始，但如果你要继续使用这个平台，你几乎肯定需要学到更多。虽然官方文档很有帮助，但全面覆盖的首选来源是
    Jason Wexbridge 和 Walter Nyland 的 *NetBeans Platform for Beginners*（[https://leanpub.com/nbp4beginners](https://leanpub.com/nbp4beginners)）。这是一本很棒的书，我强烈推荐它。
- en: In the next chapter, we're going to dip our toes into the waters of client/server
    programming, and implement our own note-taking application. It won't be as robust
    and full-featured as the competitors already in the market, but we'll make good
    headway in that direction and, hopefully, learn a lot along the way.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始涉足客户端/服务器编程，并实现我们自己的记事应用程序。它可能不像市场上已经存在的竞争对手那样健壮和功能齐全，但我们将朝着那个方向取得良好进展，并希望在这个过程中学到很多东西。
