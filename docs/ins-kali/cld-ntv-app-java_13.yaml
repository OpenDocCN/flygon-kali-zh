- en: API Design Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计最佳实践
- en: This chapter discusses how to design consumer-centric APIs that are granular
    and functionality-oriented. It also discusses the various best practices for API
    design concerns, such as how to identify the resources that will be used to form
    the API, how to categorize the APIs, API error handling, API versioning, and so
    on. We will cover models for describing the API through Open API and RAML.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论如何设计以消费者为中心的API，这些API是细粒度的，以功能为导向的。它还讨论了API设计关注的各种最佳实践，例如如何识别将用于形成API的资源，如何对API进行分类，API错误处理，API版本控制等。我们将通过Open
    API和RAML来描述API的模型。
- en: 'We will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: API design concerns
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API设计关注点
- en: API gateway deployment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关部署
- en: API design concerns
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计关注点
- en: The APIs are meant to be consumed and define how the API can be consumed. APIs
    specify the list of commands/operations as well as the format/schema of those
    commands that are required for interaction with the API.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: API旨在被消费并定义了API如何被消费。API指定了所需与API交互的命令/操作列表以及这些命令的格式/模式。
- en: When defining a REST API, the key abstraction of information is the resource.
    A resource is defined as a conceptual mapping to a set of entities. API design
    is centered around the resource that forms the nucleus of the design. **Uniform
    Resource Identifier **(**URI**), operations (using HTTP methods), and resource
    representations (JSON schema) are built keeping the resource in mind. It becomes
    very important to have the right abstraction of the resource to enable consumption,
    re-usability, and maintainability of the API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义REST API时，信息的关键抽象是资源。资源被定义为对一组实体的概念映射。API设计围绕着构成设计核心的资源。**统一资源标识符**（**URI**），操作（使用HTTP方法）和资源表示（JSON模式）都是以资源为中心构建的。拥有正确的资源抽象对于启用API的消费、可重用性和可维护性非常重要。
- en: 'The resource can point to a single entity or a collection of entities. For
    example, a product is a singular resource, whereas products are a collection of
    resources. We will cover the design guidelines at two levels:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 资源可以指向单个实体或一组实体。例如，产品是一个单一的资源，而产品是一组资源。我们将在两个层面上介绍设计准则：
- en: How to identify the right level of resource granularity
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何确定正确的资源粒度水平
- en: How to design the API around the identified resource
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何围绕已识别的资源设计API
- en: API resource identification
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API资源识别
- en: The design of the API is tied to the underlying business domain model of the
    problem domain. The APIs need to be consumer-centric and focus on the needs of
    the consumer. The domain-driven design principles are applied to identify the
    right granularity. The bounded context pattern is the central pattern that helps
    in dividing the problem area into different bounded contexts and being explicit
    about their relationship. For an enterprise, the resource identification is also
    driven by the canonical models defined by the central/group architecture teams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: API的设计与问题域的基础业务领域模型相关联。API需要以消费者为中心，关注消费者的需求。领域驱动设计原则被应用于确定正确的粒度。有界上下文模式是帮助将问题领域划分为不同有界上下文并明确它们关系的中心模式。对于企业，资源识别也受到中央/组架构团队定义的规范模型的驱动。
- en: 'Furthermore, depending upon where the API is defined and what features/functionality
    it is exposing, APIs can be classified into three, broad categories:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据API的定义位置和其暴露的功能/功能，API可以分为三个广泛的类别：
- en: '![](img/105a7699-7bf2-4e86-8fc5-57dd56a50515.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/105a7699-7bf2-4e86-8fc5-57dd56a50515.jpg)'
- en: Let's discuss these categories in detail in the following sections.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在接下来的章节中详细讨论这些类别。
- en: System API
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统API
- en: 'Key enterprise resources or systems of records need to be opened or exposed
    as a set of APIs for all downstream systems to build logic/experience around these
    services. For green field projects, system APIs typically represent the system
    of records or data stores that are being developed as part of the functionality.
    When it comes to enterprises, the system API represents all the enterprise systems,
    such as core **enterprise resource planning** (**ERP**) systems, operational data
    stores, mainframe applications, or many **commercial off-the-shelf** (**COTS**)
    products, such as **c****ustomer relationship management** (**CRM**), and so on
    that run the core processes of the enterprise. Some of the distinguishing features
    of system APIs are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关键企业资源或记录系统需要作为一组API对所有下游系统开放或暴露，以便这些服务周围构建逻辑/体验。对于绿地项目，系统API通常代表作为功能的一部分开发的记录系统或数据存储。当涉及企业时，系统API代表所有企业系统，例如核心企业资源规划（ERP）系统、运营数据存储、主机应用程序，或许多商业现成产品，例如客户关系管理（CRM）等，这些产品运行企业的核心流程。系统API的一些显著特点如下：
- en: The genesis of the domain-driven design stems from looking at the core system
    domains, and creating bounded contexts to define the system APIs.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域驱动设计的起源源于查看核心系统领域，并创建有界上下文来定义系统API。
- en: These systems of records typically map to the HTTP resource types—noun—and provide
    the entity services. For example, in the case of banking accounts, mortgages,
    securities, and cards are the core entities or nouns around which the system API
    is built.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些记录系统通常映射到HTTP资源类型—名词—并提供实体服务。例如，在银行账户的情况下，抵押贷款、证券和卡片是构建系统API的核心实体或名词。
- en: The model of bounded context defines that the services own their data stores.
    But in the case of existing systems, such as **enterprise resource planning** (**ERP**),
    the services might share the same underlying system. This requires a careful study
    of the underlying business process, identifying the domain (aka nouns), and exposing
    them as system APIs. Accounts can be a system API but account transfer will be
    a process API that makes use of the underlying account system API to provide the
    service.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有界上下文模型定义了服务拥有其数据存储。但在现有系统的情况下，例如企业资源规划（ERP），服务可能共享相同的基础系统。这需要对基础业务流程进行仔细研究，识别领域（也称为名词），并将其作为系统API公开。账户可以是一个系统API，但账户转账将是一个利用基础账户系统API提供服务的过程API。
- en: System APIs are traditionally very stable and are agnostic of the change in
    the channel or the process API layers. These form part of the core, stable enterprise
    side.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统API传统上非常稳定，并且不受渠道或过程API层变化的影响。这些是核心、稳定的企业端的一部分。
- en: The composition and integration mechanism of this enterprise system defines
    how the system APIs integrate with the underlying systems. For example, a mainframe
    dictates the use of MQ as the integration mechanism, leaving the system API to
    implement MQ to expose the mainframe functionality as an API.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业系统的组合和集成机制定义了系统API如何与基础系统集成。例如，一个主机可能会规定使用MQ作为集成机制，从而使系统API实现MQ以将主机功能暴露为API。
- en: The biggest issue with system APIs is their uptime and resiliency being tied
    to the stability of the underlying system. If the core application is going down
    frequently or has issues, these tend to get passed onto the system API layer.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统API最大的问题是它们的正常运行时间和弹性与基础系统的稳定性相关联。如果核心应用程序频繁崩溃或出现问题，这些问题往往会传递到系统API层。
- en: Process API
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过程API
- en: 'The purists will say that the system API exposes the core functionality of
    the systems and the applications should mash up the functionality from system
    APIs to provide the requisite functionality to the end customers. This might work
    well for smaller applications or initial iterations of your application. As the
    application grows bigger, or you start to expose the functionality across multiple
    channels or devices, you start looking at scenarios where the functionality starts
    getting replicated, which means lack of reuse resulting in harder to maintain
    systems. Some of the distinguishing features of process APIs are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 纯粹主义者会说，系统API暴露了系统的核心功能，应用程序应该从系统API中整合功能，以向最终客户提供所需的功能。这对于较小的应用程序或应用程序的初始迭代可能效果很好。随着应用程序变得更大，或者开始在多个渠道或设备上公开功能，您开始看到功能开始复制的情况，这意味着缺乏重用，导致系统难以维护。过程API的一些显着特点如下：
- en: Process APIs provide a richer functionality built on top of the system APIs.
    For example, instead of every channel writing an account transfer functionality,
    we can write the account transfer as a process API that gets reused across the
    channels to provide a consistent and reusable model.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程API提供了在系统API基础上构建的更丰富的功能。例如，我们可以将账户转账功能编写为过程API，而不是每个渠道都编写账户转账功能，以便在各个渠道之间提供一致且可重用的模型。
- en: From a consumer's point of view, process APIs provide a simpler model for accessing
    functionality than trying to orchestrate multiple system APIs. This helps improve
    the ease of use from the client side and helps reduce traffic at the API gateway
    level.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从消费者的角度来看，过程API提供了一个更简单的模型来访问功能，而不是尝试编排多个系统API。这有助于改善客户端的易用性，并有助于减少API网关层的流量。
- en: Process APIs can also be used to provide cross-channel/omni-channel capabilities
    to the application. Concerns such as channel context switchovers can be handled
    at this level.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程API还可以用于为应用程序提供跨渠道/全渠道功能。此级别可以处理诸如渠道上下文切换等问题。
- en: Applications tend to introduce process APIs to improve the performance of the
    overall systems. If the system API is tied to systems that are slow or can handle
    only limited throughput, a process API can be used to cache the data coming from
    the system API to avoid going to the underlying systems every time. In case of
    unavailability of a system of records and subsequently of the system API, the
    process API can be used to handle such requests by providing an alternate functional
    flow.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序倾向于引入过程API以改善整体系统的性能。如果系统API与速度慢或只能处理有限吞吐量的系统相关联，可以使用过程API来缓存来自系统API的数据，以避免每次都访问基础系统。如果系统记录不可用，随后系统API也不可用，过程API可以用于处理此类请求，提供替代的功能流程。
- en: Process APIs can also act as adapters to external third-party calls instead
    of applications making third-party calls directly. Using a process API allows
    us to handle scenarios where the failure of a third-party API does not impact
    the rest of the application. A process API can apply patterns, such as circuit
    breakers and throttling outgoing requests to handle multiple scenarios.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过程API也可以充当适配器，用于外部第三方调用，而不是应用程序直接进行第三方调用。使用过程API可以处理第三方API失败不影响应用程序其余部分的情况。过程API可以应用模式，例如断路器和限流对外部请求进行处理以处理多种情况。
- en: Channel API
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渠道API
- en: 'The final API categorization is the channel API. As the name suggests, these
    APIs are channel-specific and mapped to the customer journeys that are being built
    as part of the application. These are also referred to as experience APIs or journey
    APIs. For example, if you are building your application using Angular or React,
    customer journeys that are part of the **Single-Page Applications** (**SPA**)
    need to be mapped to underlying services that can be provided by channel APIs.
    Some of the distinguishing features of channel APIs are as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的API分类是通道API。顾名思义，这些API是特定于通道的，并映射到作为应用程序一部分构建的客户旅程。这些也被称为体验API或旅程API。例如，如果您正在使用Angular或React构建应用程序，则需要将**单页应用程序**（**SPA**）的客户旅程映射到通道API可以提供的底层服务。通道API的一些显着特点如下：
- en: Channel APIs are mapped to customer journeys, which are invariably tied to the
    channel. These are also called experience APIs at times. These APIs can be stateful
    since they serve customers during their journey and need to carry the session
    context. One can build stateless services, by externalizing the state to a session
    store such as Redis.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道API映射到与通道不可避免地相关的客户旅程。有时也称为体验API。这些API可以是有状态的，因为它们在客户旅程中为客户提供服务，并且需要携带会话上下文。人们可以通过将状态外部化到诸如Redis之类的会话存储中来构建无状态服务。
- en: Channel APIs will undergo change every time there is a change in the customer
    journey. The re-usability quotient among channel APIs is not very high. It usually
    ranges between 10-15%. For example, if a similar customer journey is mapped across
    Android and iOS applications, then there are chances of the same API getting reused.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当客户旅程发生变化时，通道API将发生变化。通道API之间的可重用性系数并不是很高。通常在10-15%之间。例如，如果类似的客户旅程映射到Android和iOS应用程序，则有可能重用相同的API。
- en: Channel APIs do not tend to have business logic or any service orchestration
    logic, as these concerns tend to be handled by the process API layer.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通道API通常不具有业务逻辑或任何服务编排逻辑，因为这些问题通常由过程API层处理。
- en: Concerns such as security (CQRS, CORS), authentication, authorization, throttling,
    and so on are handled at the API gateway level and not passed onto the channel
    API layer.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 诸如安全性（CQRS，CORS）、身份验证、授权、节流等问题是在API网关层处理的，而不是传递到通道API层。
- en: At times, during API development one might have done such a rigid differentiation
    and definition of APIs. But over the course of many application iterations, such
    differentiations start appearing in the API and one can start seeing the application
    moving toward these classifications.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，在API开发过程中，人们可能对API进行了严格的区分和定义。但在许多应用程序迭代过程中，这些区分开始出现在API中，人们可以开始看到应用程序朝着这些分类发展。
- en: Next, we will cover API design guidelines that are applicable to the three classifications
    we saw.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍适用于我们看到的三种分类的API设计指南。
- en: API design guidelines
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API设计指南
- en: Once the right level of resource granularity has been identified, the rest of
    the API design guidelines help craft the right level of contract/interface to
    enable consumption, reusability, and maintainability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了正确的资源粒度级别，API设计指南的其余部分将帮助制定合适的合同/接口，以实现可消费性、可重用性和可维护性。
- en: 'The RESTful client should be able to discover all the available actions and
    resources required by accessing the URI path. The client should be able to handle
    the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful客户端应能够通过访问URI路径发现所有可用的操作和资源。客户端应能够处理以下内容：
- en: '**Request**: Handle the inbound processing message that is sent to the server
    side'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求**：处理发送到服务器端的入站处理消息'
- en: '**Response**: Encapsulated information provided by the server'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应**：服务器提供的封装信息'
- en: '**Path**: Unique identifier of the resource being requested'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**路径**：所请求资源的唯一标识符'
- en: '**Parameters**: Elements added to the request as key/value pairs to specify
    operations such as filter, subset, and so on to the request'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：作为键/值对添加到请求中以指定操作（如过滤器、子集等）的元素'
- en: As we begin designing the API, we are sharing some of the best practices that
    we have encountered over the years.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始设计API时，我们分享了多年来遇到的一些最佳实践。
- en: Naming and associations
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名和关联
- en: 'The resource names are typically referring to the nouns extracted from the
    business domain. Once the nouns are identified, API contracts can be modeled as
    HTTP verbs against these nouns:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 资源名称通常指的是从业务领域提取的名词。一旦确定了名词，API合同就可以被建模为针对这些名词的HTTP动词：
- en: The selection of the resource needs to account for the fine-grained versus coarse-grained
    model. Too fine-grained means too much chattiness, and coarse-grained means to
    narrow the focus resulting in support for variations. One can reason that by using
    the system versus the process API model to an extent. But the issue becomes, if
    the resources are too fine-grained, the number of system APIs rises leading to
    unmaintainable complexity.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源的选择需要考虑细粒度与粗粒度模型。过于细粒度意味着过于啰嗦，而粗粒度意味着过于狭窄的焦点，导致对变化的支持。人们可以通过在一定程度上使用系统与过程API模型来推理。但问题在于，如果资源过于细粒度，系统API的数量会增加，导致难以维护的复杂性。
- en: APIs are designed by looking at the needs of the consumer. Derive your API needs
    based on the customer journeys and how they will map to the underlying data store.
    This means, look at the API design using the top design approach. Using the bottom
    model of doing data modeling first, might not yield the right balance. In case
    you have existing enterprise assets, you will need to perform a meet-in-the-middle
    kind of approach, where you need to balance the needs of the customers by writing
    process APIs that help bridge the gap.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API是通过查看消费者的需求来设计的。根据客户旅程和它们如何映射到底层数据存储来推导您的API需求。这意味着，使用顶层设计方法来查看API设计。首先进行数据建模的底层模型可能不会产生正确的平衡。如果您有现有的企业资产，您将需要执行一种中间相遇的方法，通过编写帮助弥合差距的过程API来平衡客户的需求。
- en: Base URLs for a resource
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源的基本URL
- en: 'This depends on how you treat the resource—as a singleton or as a collection.
    So ideally, you will end up with two base URLs for one resource, one for the collection
    and a second for the entity. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于您如何处理资源——作为单例还是作为集合。因此，理想情况下，您将得到一个资源的两个基本URL，一个用于集合，另一个用于实体。例如：
- en: '| **Resource** | `POST`(**Create**) | `GET`(**Read**) | `PUT`(**Update**) |
    `DELETE`(**Delete**) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **资源** | `POST`(**创建**) | `GET`(**读取**) | `PUT`(**更新**) | `DELETE`(**删除**)
    |'
- en: '| `/orders` | Create new order | Order list | Replace with a new order | Error
    (do not want to delete all orders) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `/orders` | 创建新订单 | 订单列表 | 替换为新订单 | 错误（不想删除所有订单） |'
- en: '| `/orders/1234` | error | Show the order with ID: `1234` | If it exists update
    the order; if it does not, create a new order | Delete the order with ID: `1234`
    |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `/orders/1234` | 错误 | 显示ID为`1234`的订单 | 如果存在则更新订单；如果不存在则创建新订单 | 删除ID为`1234`的订单
    |'
- en: Handling errors
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'Make use of the standard HTTP status code to indicate the problem/error:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 利用标准HTTP状态代码指示问题/错误：
- en: If using JSON, the error should be a top-level property
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用JSON，错误应该是一个顶级属性
- en: With errors—be descriptive, correct, and informative
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现错误时，要描述清楚、正确和有信息性
- en: 'A sample error message is as shown in the following snippet:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例错误消息片段：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Some examples of HTTP code usage are as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是HTTP代码使用的一些示例：
- en: 400 Bad Request
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 400 错误的请求
- en: 401 Unauthorized
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 401 未经授权
- en: 403 Forbidden
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 403 禁止
- en: 404 Not Found
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 未找到
- en: 409 Conflict
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 409 冲突
- en: 429 Too Many Requests
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 429 请求过多
- en: 5xx API is faulty
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5xx API有故障
- en: Versioning
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 版本控制
- en: 'There are multiple models for service versioning:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种服务版本模型：
- en: '**URL**: You simply add the API version into the URL, for example: `https://getOrder/order/v2.0/sobjects/Account`.
    Used frequently, but not good practice.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URL**：您只需将API版本添加到URL中，例如：`https://getOrder/order/v2.0/sobjects/Account`。经常使用，但不是良好的实践。'
- en: '**Accept header**: You modify the accept header to specify the version, for
    example: `Accept: application/vnd.getOrders.v2+json`. Rarely used and cumbersome
    for the client.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接受标头**：您可以修改接受标头以指定版本，例如：`Accept: application/vnd.getOrders.v2+json`。客户端很少使用，且繁琐。'
- en: '**Schema level**: Enforce the validation using schema, difficult to enforce
    with JSON, and works well with XML. Good practice/rare.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式级别**：使用模式强制执行验证，难以强制执行JSON，与XML配合效果很好。良好的实践/罕见。'
- en: '**API facade layer**: Use the facade layer to hide the version complexity from
    the client.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API外观层**：使用外观层来隐藏客户端的版本复杂性。'
- en: Remember, a resource is a semantic model; a resource's representational form
    and state may change over time but the identifier must consistently address the
    same resource. Hence, new URIs should only be used when there is an underlying
    change in concept. The API facade layer can abstract the Northbound API from underlying
    service and schema versions. API management platforms support creating the API
    facade layer.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，资源是一个语义模型；资源的表现形式和状态可能随时间变化，但标识符必须始终指向相同的资源。因此，只有在概念发生根本变化时才应使用新的URI。API外观层可以将北向API与底层服务和模式版本抽象出来。API管理平台支持创建API外观层。
- en: Pagination
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页
- en: Use the URL with the pagination information to handle results offset and limits.
    For example, `/orders?limit=25&offset=50`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有分页信息的URL来处理结果的偏移和限制。例如，`/orders?limit=25&offset=50`。
- en: Attributes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: The API should support provisioning of data attributes asked by the consumer
    using the query parameter model. For example, `/orders?fields=id,orderDate,total`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: API应支持使用查询参数模型由消费者请求的数据属性。例如，`/orders?fields=id,orderDate,total`。
- en: Data formats
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据格式
- en: The API should provide support for multiple data formats based on what the consumer
    asks for. For example, `/orders/1234.json` returns data in JSON format.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: API应根据消费者的要求提供多种数据格式的支持。例如，`/orders/1234.json`以JSON格式返回数据。
- en: Client support for limited HTTP methods
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端支持有限的HTTP方法
- en: 'Depending upon the device and its limited capability to support HTTP verbs,
    you may want to provide support for HTTP methods using the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 根据设备及其有限的支持HTTP动词的能力，您可能希望使用以下方法来提供对HTTP方法的支持：
- en: '**Create**: `/orders?method=post`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：`/orders?method=post`'
- en: '**Read**: `/orders`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读取**：`/orders`'
- en: '**Update**: `/orders/1234?method=put&location=park`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：`/orders/1234?method=put&location=park`'
- en: '**Delete** `/orders/1234?method=delete`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除** `/orders/1234?method=delete`'
- en: Authentication and authorization
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: REST services use a role-based membership for each exposed method when appropriate
    and provide the ability to independently enable `GET`, `POST`, `PUT`, and `DELETE`
    based on any number of specific roles.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: REST服务在适当时使用基于角色的成员资格，并提供独立启用`GET`、`POST`、`PUT`和`DELETE`的能力。
- en: Typically, this concern should be handled at the API gateway level. You should
    not be handling this as part of the service.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这个问题应该在API网关级别处理。您不应该将其作为服务的一部分处理。
- en: Endpoint redirection
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端点重定向
- en: Service inventories may change over time for business or technical reasons.
    It may not be possible to replace all references to old endpoints simultaneously.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 服务清单可能会因业务或技术原因随时间变化。可能无法立即替换所有对旧端点的引用。
- en: 'By adopting this design practice, consumers of a service endpoint adapt when
    service inventories are restructured. It automatically refers service consumers
    that access the stale endpoint identifier to the current identifier:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这种设计实践，服务端点的消费者在服务清单重组时会自动适应。它会自动将访问过时端点标识符的服务消费者引用到当前标识符：
- en: '![](img/af4ea0b7-d13a-46fd-a7d2-d3e5990d80b6.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af4ea0b7-d13a-46fd-a7d2-d3e5990d80b6.jpg)'
- en: 'HTTP natively supports the endpoint redirection pattern using a combination
    of 3xx status codes and standard headers:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP原生支持使用3xx状态代码和标准标头的端点重定向模式：
- en: 301 moved permanently
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 301 永久移动
- en: 307 temporary redirect
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 307 临时重定向
- en: location/newURI
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置/新URI
- en: Content negotiation
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容协商
- en: Service consumers may change their requirements in a way that is not backward
    compatible. A service may have to support both old and new consumers without having
    to introduce a specific capability for each kind of consumer.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 服务消费者可能会以不向后兼容的方式更改其要求。一个服务可能需要支持旧的和新的消费者，而不必为每种消费者引入特定的能力。
- en: A service can specify specific content and data representation formats to be
    accepted or returned by a service capability negotiated at runtime as part of
    its invocation. The service contract refers to multiple standardized media types.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以指定特定的内容和数据表示格式，以便在运行时作为其调用的一部分接受或返回。服务合同涉及多种标准化媒体类型。
- en: Secure
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全
- en: Always use SSL for your securing the URIs. SSL ensures guaranteed encrypted
    communications, which in turn simplifies authentication efforts—one need not sign
    each API request.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用SSL来保护您的URI。SSL确保了加密通信，从而简化了身份验证的工作——不需要为每个API请求签名。
- en: This covers some of the best practices that go with the API design. One can
    learn from how Google, Facebook, and Amazon are defining their public APIs and
    use those as the basis for your API design.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了一些与API设计相关的最佳实践。可以从谷歌、Facebook和亚马逊是如何定义他们的公共API中学习，并将其作为API设计的基础。
- en: API modeling
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API建模
- en: There are two standards that are competing to describe the APIs—Open APIs and
    RESTful APIs. We will discuss them more in the following sections.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种标准在竞相描述API——开放API和RESTful API。我们将在以下部分更详细地讨论它们。
- en: Open API
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放API
- en: The Open API initiative is focused on creating and promoting a vendor-neutral
    API description format based on the Swagger specification. The Open API specification
    allows us to define a standard, language-agnostic interface for REST APIs, which
    allows both humans and computers to discover and understand the capabilities of
    the service without access to source code.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 开放API倡议旨在创建和推广基于Swagger规范的供应商中立的API描述格式。开放API规范允许我们为REST API定义一个标准的、与语言无关的接口，这使得人类和计算机都能够在没有访问源代码的情况下发现和理解服务的能力。
- en: 'In the following figures, we have described a sample API definition based on
    Open API along with the various sections:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们描述了一个基于开放API的示例API定义以及各个部分：
- en: '![](img/44109d4d-7d5b-4fe3-8a9a-4397dfba17e6.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44109d4d-7d5b-4fe3-8a9a-4397dfba17e6.jpg)'
- en: 'Code continues in the following image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在下图中继续：
- en: '![](img/b70bd4dd-d2e9-42cd-ad0f-9e1f48d9bb96.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70bd4dd-d2e9-42cd-ad0f-9e1f48d9bb96.jpg)'
- en: 'Code continues in the following image:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 代码在下图中继续：
- en: '![](img/a66becbc-6580-4d77-bacc-d5ecc9ade2ca.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a66becbc-6580-4d77-bacc-d5ecc9ade2ca.jpg)'
- en: RESTful API Modeling Language (RAML)
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RESTful API建模语言（RAML）
- en: '**RESTful API Modeling Language** (**RAML**) is a standard language to describe
    the RESTful APIs. RAML is written in the same way as YAML, which is a human-readable
    data serialization language. The goal of RAML is to provide all the necessary
    information required to describe API. RAML provides a machine-readable API design
    that can be read by various API management tools.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**RESTful API建模语言**（**RAML**）是一种描述RESTful API的标准语言。RAML以与YAML相同的方式编写，YAML是一种人类可读的数据序列化语言。RAML的目标是提供描述API所需的所有必要信息。RAML提供了一种可供各种API管理工具读取的机器可读的API设计。'
- en: 'In the following figure, we have described a sample RAML along with the various
    sections:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中，我们描述了一个示例RAML以及各个部分：
- en: '![](img/22192408-6050-466b-9aa6-aab8c5e6ab51.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22192408-6050-466b-9aa6-aab8c5e6ab51.jpg)'
- en: 'RAML maps to the full API design life, which can be categorized as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: RAML映射到完整的API设计生命周期，可以分为以下几类：
- en: '![](img/05a2aabd-5ec8-474c-967f-8add021bf9dc.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/05a2aabd-5ec8-474c-967f-8add021bf9dc.jpg)'
- en: 'Let''s have a look at the flow:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下流程：
- en: '**Design**: API vendors provide editors as part of the API development suite
    to help design/write the API/RAML definition, resulting in faster development
    and fewer errors. The generated RAML can be augmented with mock data and allows
    iterations with respect to design with the business owners/consumers for validation
    and correctness.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**设计**：API供应商提供编辑器作为API开发套件的一部分，以帮助设计/编写API/RAML定义，从而实现更快的开发和更少的错误。生成的RAML可以用模拟数据进行增强，并允许与业务所有者/消费者进行迭代，以进行验证和正确性。'
- en: '**Build**: The generated RAML provides the specifications for the build of
    the API. The development suites can generate stubs based on the RAML for plugging
    in the logic.'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建**：生成的RAML提供了API构建的规范。开发套件可以基于RAML生成存根，以便插入逻辑。'
- en: '**Test**: RAML can be used to generate test scripts. Tools such as Postman
    and Abao allow RAML specifications to be imported and tests generated that are
    used to validate the API. In addition, tools such as API Fortress and SmartBear,
    can also test for response latency, payloads, and errors.'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**测试**：RAML可以用于生成测试脚本。诸如Postman和Abao之类的工具允许导入RAML规范并生成用于验证API的测试。此外，诸如API Fortress和SmartBear之类的工具还可以测试响应延迟、有效负载和错误。'
- en: '**Document**: The RAML specification can be converted into an HTML-based model.
    Tools such as RAML2HTML for PHP, API Console, and so on provide an easy way to
    expose the documentation specified as part of the RAML. This model allows any
    changes in the specification to be reflected in the documentation and keep them
    in sync.'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**文档**：RAML规范可以转换为基于HTML的模型。诸如RAML2HTML for PHP、API Console等工具提供了一种将RAML指定的文档公开的简单方法。该模型允许在规范中进行任何更改，并将其反映在文档中并保持同步。'
- en: '**Integrate**: The last stage of the API lifecycle is the ability to integrate
    or consume the API. Usage of RAML allows vendors/tools to create multiple ways
    to integrate and consumer the API. Using RAML, API-specific SDKs can be built.
    Vendors also provide tools that can make use of RAML to integrate with client-side
    logic.'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**集成**：API生命周期的最后阶段是能够集成或消费API。使用RAML，供应商/工具可以创建多种集成和消费API的方式。使用RAML，可以构建特定于API的SDK。供应商还提供可以利用RAML与客户端逻辑集成的工具。'
- en: The choice between the two standards depends upon the API gateway product stack
    chosen by the organization. Most of the products have a preference of one standard
    over the other although every product claims to provide support for both standards.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 两种标准之间的选择取决于组织选择的API网关产品堆栈。大多数产品都更偏好一种标准，尽管每个产品都声称支持两种标准。
- en: API gateway deployment models
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API网关部署模型
- en: The API gateway provides a facade pattern that encapsulates the inner workings
    of the system providing a single point of entry for all incoming clients. An API
    gateway can provide an API tailored for each type of client, all the while addressing
    concerns such as security, authentication, authorization, throttling, load balancing,
    and so on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: API网关提供了一个外观模式，封装了系统的内部工作，为所有传入客户端提供了一个统一的入口点。API网关可以为每种类型的客户端提供定制的API，同时解决诸如安全性、身份验证、授权、限流、负载平衡等问题。
- en: Let's look at the factors that impact how the APIs are deployed on the API gateway.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看影响API如何部署在API网关上的因素。
- en: '**Type of client or channel**: Depending upon the device or channel from where
    the request originates, the API might need to serve different subsets of data.
    For example, the desktop version of the service might be asking for more details
    as compared to the mobile client. There can be a difference in data even between
    phone and tablet. How do we make sure that the same microservice can service all
    device type requests and still handle these variations? In this case, we create
    multiple APIs for different device types that meet the specific needs of the client
    without the microservice being bothered.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端或通道类型**：根据请求的设备或通道的不同，API可能需要为不同的数据子集提供服务。例如，服务的桌面版本可能需要更多的细节，而移动客户端则需要更少。甚至手机和平板之间的数据也可能有差异。我们如何确保同一个微服务可以为所有设备类型的请求提供服务，并且仍然处理这些变化？在这种情况下，我们为不同的设备类型创建多个API，以满足客户端的特定需求，而不会打扰微服务。'
- en: '**Data transformation**: At times, the service on the backend is built to service
    JSON content. A requirement originates asking for an XML response or vice versa.
    In this case, the API gateway exposes an API that provides the XML as a response
    while doing the data transformation at the gateway level, allowing the service
    to work without any changes or knowledge of the client''s needs.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据转换**：有时，后端的服务是构建为提供JSON内容的。有一个要求要求提供XML响应或反之。在这种情况下，API网关在网关级别进行数据转换，同时提供一个提供XML响应的API，使服务能够在不改变或了解客户端需求的情况下工作。'
- en: '**Versioning**: For public APIs or APIs tied to a resource where versioning
    has not been added to the URI, an API gateway can route the incoming requests
    based on the client and the version used to the correct service. In this case,
    the API gateway can decipher the service version by using multiple techniques:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**：对于公共API或与未在URI中添加版本控制的资源相关的API，API网关可以根据客户端和使用的版本将传入的请求路由到正确的服务。在这种情况下，API网关可以使用多种技术解析服务版本：'
- en: Client identifiers can be used to identify whether they have moved to a new
    version or are using an older version.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端标识符可用于识别它们是否已切换到新版本或正在使用旧版本。
- en: Clients can be segregated into multiple categories based on SLAs. When the new
    version is released, the lowermost category, or low usage clients, can be asked
    to move to a new version. As clients upgrade, the API gateway can redirect them
    to the right version of the service.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据SLA将客户端分为多个类别。当新版本发布时，较低的类别或低使用率的客户端可以被要求切换到新版本。随着客户端升级，API网关可以将它们重定向到正确的服务版本。
- en: '**Orchestration**: At times, the API might require multiple backend services
    invoked and results be aggregated. In this case, the API gateway must invoke multiple
    services concurrently and aggregate the results. At times, there can be a dependency
    between the service calls. For example, incoming requests might need to be authenticated
    before actual service invocation, or additional client or session information
    might need to be pulled for invoking the call. One can write the entire orchestration
    logic in the API gateway layer as some of the products provide runtime support.
    Another option could be to write a process API that does the orchestration across
    the other services and provides a consolidated API for consumption. This helps
    reduce chattiness and improves the overall performance from a client''s perspective.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：有时，API可能需要调用多个后端服务并聚合结果。在这种情况下，API网关必须同时调用多个服务并聚合结果。有时，服务调用之间可能存在依赖关系。例如，传入请求可能需要在实际服务调用之前进行身份验证，或者可能需要提取额外的客户端或会话信息以调用该调用。可以在API网关层编写整个编排逻辑，因为一些产品提供了运行时支持。另一个选择可能是编写一个执行跨其他服务的编排并提供一个整合API供消费的过程API。这有助于减少交互并从客户端的角度提高整体性能。'
- en: We covered the orchestration patterns in Chapter 3, *Designing Your Cloud-Native
    Application*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章《设计您的云原生应用程序》中介绍了编排模式。
- en: '**Service discovery**: With the service instance going up and down, the service
    registry is the only true source of data in terms of the endpoints of the service
    that are available at any given point of time. An API gateway should be able to
    invoke the service registry to get the service endpoint at runtime and use that
    to invoke the service. A service registry can be used as a mechanism to load-balance
    the service calls across the registered service instances.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：随着服务实例的上下，服务注册表是关于服务端点在任何给定时间可用的唯一真实数据源。API网关应该能够在运行时调用服务注册表以获取服务端点，并使用它来调用服务。服务注册表可以用作跨注册服务实例的负载平衡机制。'
- en: '**Handling timeouts**: For services that do not respond within a reasonable
    time, the API gateway allows you to timeout the request. This allows the gateway
    to handle timeout failures and even provide a failure mode for the clients. One
    option can be to provide cached data (if applicable and depending upon the type
    of service) or fail fast model, where the gateway can return an error or failure
    immediately without invoking the service.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理超时**：对于在合理时间内没有响应的服务，API网关允许您设置超时请求。这使得网关可以处理超时失败，并为客户端提供故障模式。其中一种选择可以是提供缓存数据（如果适用并根据服务类型），或者快速失败模式，其中网关可以立即返回错误或失败，而不调用服务。'
- en: '**Data caching**: The API gateway can also cache data for service calls that
    provide static data or data that does not change frequently. This model allows
    the traffic getting reduced on the service instance. This improves the overall
    response latency and the overall system resiliency. The cached data can also be
    used as a secondary failure flow, in case of failure of the primary flow.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据缓存**：API网关还可以为提供静态数据或不经常更改的数据的服务调用缓存数据。这种模式可以减少服务实例上的流量，提高整体响应延迟和整体系统的弹性。缓存的数据也可以用作次要故障流程，以防主要流程失败。'
- en: '**Service invocation**: The service getting deployed can be using multiple
    interfaces or protocols. For example, you might have services that make use of
    an asynchronous messaging based mechanism (such as JMS, MQ, Kafka, and so on)
    or others can make use of synchronous models such as HTTP or Thrift. The API gateway
    should be able to support multiple service invocation models and provide orchestration
    models on top of these invocation methods.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务调用**：部署的服务可以使用多个接口或协议。例如，您可能有使用异步消息传递机制（如JMS、MQ、Kafka等）的服务，或者其他服务可能使用HTTP或Thrift等同步模型。API网关应该能够支持多种服务调用模型，并在这些调用方法之上提供编排模型。'
- en: '**Service metering/throttling**: For certain categories of clients, you may
    want to limit the number of service calls they can make. For example, if you are
    providing a freemium model of service with reduced functionality, along with limits
    of calls that can be made in a time frame. The ability to meter and throttle the
    incoming requests based on type of client (free or paid) helps provide a business
    model around your API and underlying services. This can also be helpful if you
    are making external API calls to another SaaS provider, routing those calls through
    the API gateway can help predict/manage the number of outgoing calls and give
    unnecessary shocks when the usage bill comes up.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务计量/限流**：对于某些类别的客户，您可能希望限制他们可以进行的服务调用次数。例如，如果您提供了一个功能减少的免费模式服务，以及在一定时间内可以进行的调用次数限制。根据客户类型（免费或付费）对传入请求进行计量和限流的能力有助于围绕您的API和基础服务提供商业模式。如果您正在对另一个SaaS提供商进行外部API调用，通过API网关路由这些调用可以帮助预测/管理外部调用的数量，并在使用账单出现时避免不必要的冲击。'
- en: '**API monitoring**: Another important concern is monitoring your API calls
    for any deviation, whether in terms of response latency across various percentiles,
    failures rates, API availability, and so on. These metrics need to be plotted
    on a dashboard with appropriate alerts and notification systems. Based on the
    type of failure, one can automate the recovery scripts to overcome them.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API监控**：另一个重要问题是监控API调用是否有任何偏差，无论是在各种百分位数的响应延迟、失败率、API可用性等方面。这些指标需要在仪表板上绘制，并配备适当的警报和通知系统。根据失败类型，可以自动化恢复脚本以克服它们。'
- en: This concludes the various usage scenarios and patterns that can be applied
    to an API gateway to expose your services as API to the consumers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是可以应用于API网关的各种使用场景和模式，以将您的服务作为API向消费者公开。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we saw how an API can be categorized into different models
    based on its primary usage and underlying resource. We saw the best practice with
    respect to the overall API design and the standards available to model the API
    through Open API or RAML specification. Next, we saw how the API gateway can be
    leveraged to address concerns not handled at the service levels.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了API如何根据其主要用途和基础资源进行分类。我们了解了关于整体API设计的最佳实践以及通过Open API或RAML规范对API进行建模的标准。接下来，我们看到了API网关如何利用来解决服务层未处理的问题。
- en: In the next chapter, we will cover the impact of cloud development on the existing
    landscape of an enterprise, and how it can achieve the transformation of moving
    toward a digital enterprise.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍云开发对企业现有格局的影响，以及它如何实现向数字化企业转型。
