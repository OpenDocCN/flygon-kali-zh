- en: Implementing Design Patterns - The Functional Way
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计模式-函数式方法
- en: In [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring Purity
    - Immutability*, we saw several functional techniques to solve different problems.
    However, programmers who are used to employing OOP may find that we have missed
    some well-known formulae and solutions, which are often used in imperative coding.
    Since design patterns are well known, and programmers will be likely already be
    aware of how they are applied in other languages, it's important to take a look
    at how a functional implementation would be done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章]（383f5538-72cc-420a-ae77-896776c03f27.xhtml）中，我们看到了几种解决不同问题的函数式技术。然而，习惯于使用OOP的程序员可能会发现我们错过了一些众所周知的公式和解决方案，这些公式和解决方案在命令式编码中经常使用。由于设计模式是众所周知的，并且程序员可能已经了解它们在其他语言中的应用，因此重要的是看看如何进行函数实现。
- en: 'In this chapter, we shall consider the solutions implied by *design patterns*,
    which are common in OOP to see their equivalences in FP. In particular, we will
    study the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将考虑设计模式所暗示的解决方案，这些解决方案在面向对象编程中很常见，以便看到它们在FP中的等价物。特别是，我们将研究以下主题：
- en: The concept of *design patterns*and to what they apply
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的概念及其适用范围
- en: A few OOP standard patterns and what alternative we have in FP, if we need one
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些OOP标准模式以及在FP中我们有什么替代方案，如果需要的话。
- en: A discussion about FP design patterns, not related to the OOP ones
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与面向对象设计模式无关的FP设计模式讨论
- en: What are Design Patterns?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: 'One of the most relevant books in software engineering was d*esign patterns:
    Elements of Reusable Object-Oriented Software*, 1994, written by the**GoF** (**Gang
    of Four**): Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. This
    book presented about two dozen different OOP *patterns*and has been recognized
    as a highly important book in computer science.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 软件工程中最重要的书籍之一是《设计模式：可复用面向对象软件的元素》，1994年，由GoF（四人帮）：Erich Gamma，Richard Helm，Ralph
    Johnson和John Vlissides编写。这本书介绍了大约两打不同的OOP模式，并被认为是计算机科学中非常重要的书籍。
- en: '*Patterns* are actually a concept from architectural design, originally defined
    by an architect, Christopher Alexander.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式*实际上是建筑设计的概念，最初由建筑师克里斯托弗·亚历山大定义。'
- en: In software terms, a *design pattern* is a generally applicable, reusable solution,
    to a usually seen, common problem in software design. Rather than a specific,
    finished and coded design, it's a description of a solution (the word *template*is
    also used) that can solve a given problem that appears in many contexts. Given
    their advantages, design patterns are on their own *best practices*, which can
    be used by developers working with different kinds of systems, programming languages,
    and environments.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件术语中，*设计模式*是软件设计中通常出现的常见问题的一般适用的可重用解决方案。它不是特定的、完成的和编码的设计，而是一个可以解决许多情境中出现的给定问题的解决方案的描述（也使用了“模板”这个词）。鉴于它们的优势，设计模式本身是开发人员在不同类型的系统、编程语言和环境中使用的*最佳实践*。
- en: The book obviously focused on OOP, and some of the patterns within cannot be
    recommended for or applied in FP. Other patterns are unnecessary or irrelevant
    because FP languages already provide standard solutions to the corresponding OOP
    problems. Even given this difficulty, since most programmers have been exposed
    to OOP design patterns and usually try to apply them even in other contexts such
    as FP, it makes sense to consider the original problems and then take a look at
    how a new solution can be produced. The standard object-based solutions may not
    apply, but the problem can still stand, so seeing how to solve it is still valid.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书显然侧重于OOP，并且其中的一些模式不能推荐或应用于FP。其他模式是不必要的或无关的，因为FP语言已经为相应的OOP问题提供了标准解决方案。即使存在这种困难，由于大多数程序员已经接触过OOP设计模式，并且通常会尝试在其他上下文中（如FP）应用它们，因此考虑原始问题，然后看看如何产生新的解决方案是有意义的。标准的基于对象的解决方案可能不适用，但问题仍然存在，因此看看如何解决它仍然是有效的。
- en: 'Patterns are often described in terms of four essential, basic elements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 通常用四个基本要素来描述模式：
- en: A simple, short, *name*that is used to describe the problem, its solutions,
    and their consequences. The name is useful for talking with colleagues, explaining
    a design decision, or describing a specific implementation.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于描述问题、解决方案及其后果的简单、简短的名称。这个名称对于与同事交流、解释设计决策或描述特定实现是有用的。
- en: 'The *context* to which the pattern applies: this implies specific situations
    that require a solution, with possibly some extra conditions that must be met.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模式适用的*上下文*：这意味着需要解决的特定情况，可能还需要满足一些额外条件。
- en: A*solution* that lists the elements (classes, objects, functions, relationships,
    and so on) that you'll need in order to solve the given situation.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出解决特定情况所需的元素（类、对象、函数、关系等）的解决方案
- en: The *consequences* (results and trade-offs) if you apply the pattern. You may
    derive some gains from the solution, but it may also imply some losses.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用模式，*后果*（结果和权衡）。您可能会从解决方案中获得一些收益，但它也可能意味着一些损失。
- en: In this chapter, we will assume that the reader is already aware of the design
    patterns that we will be describing and using, so we won't be providing much details
    about them. Rather, we will focus on how FP either makes the problem irrelevant
    (because there is an obvious way of applying functional techniques to solve it)
    or solves it in some fashion. Also, we won't be going over all the GoF patterns;
    we'll just focus on those for which applying FP is more interesting, bringing
    out more differences with the usual OOP implementations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将假设读者已经了解我们将描述和使用的设计模式，因此我们不会提供太多关于它们的细节。相反，我们将重点放在FP如何使问题变得无关（因为有一种明显的应用函数技术来解决它的方式）或以某种方式解决它。此外，我们不会涉及所有GoF模式；我们只会专注于那些应用FP更有趣的模式，从而带出与通常的OOP实现更多的差异。
- en: Design pattern categories
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式类别
- en: 'Design patterns are usually grouped into several distinct categories, according
    to their focus. The firstthree in the following list are the ones that appeared
    in the original GoF book, but more categories have been added:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式通常根据它们的焦点分为几个不同的类别。以下列表中的前三个是出现在原始GoF书中的模式，但还添加了更多的类别：
- en: '**Behavioral design patterns**: These have to do with interactions and communications
    between objects. Rather than focusing on how objects are created or built, the
    key consideration is how to connect them so that they can cooperate when performing
    a complex task, preferably in a way that provides well-known advantages, such
    as diminished *coupling* or enhanced *cohesiveness*.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为设计模式：这些与对象之间的交互和通信有关。与其关注对象如何创建或构建，关键是如何连接它们，以便它们在执行复杂任务时可以合作，最好以提供众所周知的优势的方式，例如减少耦合或增强内聚性。
- en: '**Creational design patterns**: They deal with ways to create objects in a
    manner that is suitable for the current problem, possibly guiding the selection
    between several alternative objects, so the program can work in different ways
    depending on parameters that may be known at compilation time or at runtime.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设计模式：它们处理以适合当前问题的方式创建对象的方法，可能引导在几种替代对象之间进行选择，以便程序可以根据可能在编译时或运行时已知的参数以不同的方式工作。
- en: '**Structural design patterns**: They have to do with the composition of objects,
    forming larger structures from many individual parts and implementing relationships
    between objects. Some of the patterns imply inheritance or implementation of interfaces,
    whereas others use different mechanisms, all geared towards being able to dynamically
    change the way objects are composed at runtime.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构设计模式：它们涉及对象的组成，从许多个体部分形成更大的结构，并实现对象之间的关系。一些模式意味着继承或接口的实现，而其他模式使用不同的机制，都旨在能够在运行时动态地改变对象组合的方式。
- en: '**Concurrency patterns**: They are related to dealing with multithreaded programming.
    Although FP is generally quite appropriate for that (given, for example, the lack
    of assignments and side effects) since we are working with JavaScript, these patterns
    are not very relevant to us.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发模式：它们与处理多线程编程有关。尽管函数式编程通常非常适合这样做（例如，由于缺少赋值和副作用），但由于我们使用JavaScript，这些模式对我们来说并不是很相关。
- en: '**Architectural patterns**: They are more high-level oriented, with a broader
    scope than the previous patterns we''ve listed, and provide general solutions
    to software architecture problems. As is, we aren''t considering such problems
    in the book, so we won''t deal with these either.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构模式：它们更加高层次，比我们列出的先前模式具有更广泛的范围，并提供了软件架构问题的一般解决方案。目前，我们不考虑这些问题，所以我们也不会处理这些问题。
- en: Coupling and cohesiveness are terms that were in use even before OOP came into
    vogue; they date back to the late 60's when*Structured Design*by Larry Constantine
    was out. The former measures the interdependence between any two modules,and the
    latter has to do with the degree to which all components of a module really belong
    together. Low coupling and high cohesiveness are good goals for software design
    because they imply that related things are close by and unrelated ones are separate.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合和内聚性是在面向对象编程流行之前就已经使用的术语；它们可以追溯到60年代末，当时Larry Constantine的《结构化设计》出版。前者衡量任何两个模块之间的相互依赖性，后者与模块的所有组件真正属于一起的程度有关。低耦合和高内聚性是软件设计的良好目标，因为它们意味着相关的事物是靠在一起的，而不相关的事物是分开的。
- en: Following along these lines, you could also classify design patterns as *Object
    Patterns* (which concern the dynamic relationships between objects) and *Class
    Patterns*that deal with the relationships between classes and subclasses (which
    are defined statically at compile time). We won't be worrying much about this
    classification because our point of view has more to do with behaviors and functions
    rather than classes and objects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着这些线路，你也可以将设计模式分类为“对象模式”（涉及对象之间的动态关系）和“类模式”（处理类和子类之间的关系，这些关系在编译时静态定义）。我们不会过多地担心这种分类，因为我们的观点更多地与行为和函数有关，而不是类和对象。
- en: As we mentioned earlier, we can now readily observe that these categories are
    heavily oriented toward OOP, and the first three directly mention objects. However,
    without the loss of generality, we will look beyond the definitions, remember
    what problem we were trying to solve, and then look into analogous solutions with
    FP, which if not 100% equivalent to the OOP ones, will in spirit be solving the
    same problem in a parallel way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，我们现在可以清楚地观察到这些类别是严重面向面向对象编程的，并且前三个直接提到了对象。然而，不失一般性，我们将超越定义，记住我们试图解决的问题，然后探讨函数式编程的类似解决方案，即使不是与面向对象编程完全等价，也会以类似的方式解决相同的问题。
- en: Do we need design patterns?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们需要设计模式吗？
- en: There is an interesting point of view that says that design patterns are only
    needed to patch shortcomings of a programming language. The rationale is that
    if you can solve a problem with a language, in a simple, trivial way, then you
    may not need a design pattern at all.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个有趣的观点认为，设计模式只是需要修补编程语言的缺陷。理由是，如果你可以用一种语言以简单、平凡的方式解决问题，那么你可能根本不需要设计模式。
- en: In any case, it's interesting, for OOP developers, to really understand why
    FP helps solve some problems without need of further tools. In the next section,
    we shall consider several well-known design patterns and take a look at why we
    don't need them or how we can easily implement them. It's also a fact that we
    have already applied several patterns earlier in the text, so we'll point out
    to those examples as well.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，对于面向对象的开发人员来说，真正理解为什么函数式编程可以解决一些问题而无需进一步的工具是很有趣的。在下一节中，我们将考虑几种众所周知的设计模式，并看看为什么我们不需要它们，或者我们如何可以轻松地实现它们。事实上，我们在文本中已经应用了几种模式，所以我们也会指出这些例子。
- en: We won't try, however, to express or convert all design patterns into FP terms.
    For example, the *Singleton* pattern basically requires a single, global, object,
    which is sort of opposed to everything that functional programmers are used to.
    Given our approach to FP (remember SFP, *Sorta Functional Programming*, from the
    initial part of the first chapter?), we won't mind either, and if a Singleton
    is required, we may consider using it, even though FP doesn't have an appropriate
    equivalent.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不会试图将所有设计模式都表达或转换成FP术语。例如，*Singleton*模式基本上需要一个单一的全局对象，这与函数式编程者习惯的一切都有点相悖。鉴于我们对FP的方法（还记得第一章初步部分的SFP，*Sorta
    Functional Programming*吗？），我们也不会介意，如果需要Singleton，我们可能会考虑使用它，即使FP没有合适的等价物。
- en: Finally, it must be said that one's point of view may affect what is considered
    a pattern and what isn't. What may be a pattern to some may be considered a trivial
    detail for others. We will find some such situations, given that FP lets us solve
    some particular problems in easy ways, and we have already seen examples of that
    in previous chapters.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，必须说一下，一个人的观点可能会影响什么被认为是模式，什么不是。对一些人来说可能是模式，对其他人来说可能被认为是微不足道的细节。我们会发现一些这样的情况，因为FP让我们以简单的方式解决一些特定问题，我们在之前的章节中已经看到了一些例子。
- en: Object-oriented design patterns
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象的设计模式
- en: In this section, we'll go over some of the GoF design patterns, check whether
    they are pertinent to FP, and study how to implement them. Of course, there are
    some design patterns that don't get an FP solution. For example, there's no equivalent
    for a Singleton, which implies the foreign concept of a globally accessed object.
    Also, while it's true that you may no longer need OOP-specific patterns, developers
    will still think in terms of those. Also, finally, since we're not going *fully
    functional* if an OOP pattern fits, why not use it?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些GoF设计模式，检查它们是否与FP相关，并学习如何实现它们。当然，有一些设计模式没有FP解决方案。例如，没有Singleton的等价物，这意味着全局访问对象的外来概念。此外，虽然你可能不再需要面向对象的特定模式，但开发人员仍会以这些术语思考。最后，既然我们不是*完全函数式*，如果面向对象的模式适用，为什么不使用呢？
- en: Façade and Adapter
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Façade和Adapter
- en: Out of these two patterns, let's start with the *Façade*. This is meant tosolve
    the problem of providing a different interface to the methods of a class or to
    a library. The idea is to provide a new interface to a system that makes it easier
    to use. You might say that aFaçade provides a better *control panel*to access
    certain functionalities, removing difficulties for the user.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种模式中，让我们从*Façade*开始。这是为了解决为类或库的方法提供不同接口的问题。其想法是为系统提供一个新的接口，使其更易于使用。你可以说，Façade提供了一个更好的*控制面板*来访问某些功能，为用户消除了困难。
- en: 'Façade or facade? The original word is an architectural term meaning the *front
    of a building* and comes from the French language. According to this source andthe
    usual sound of the cedilla (ç) character, its pronunciation is something like
    *fuh-sahd*. The other spelling probably has to do with the lack of international
    characters in keyboards and poses the following problem: Shouldn''t you read it
    as *faKade*? You may see this problem as the reverse of *celtic*, which is pronounced
    as *Keltic*, changing the *s*sound for a *k*sound.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Façade还是facade？原词是建筑术语，意思是*建筑物的正面*，来自法语。根据这个来源和ç的通常发音，它的发音大约是*fuh-sahd*。另一种拼写可能与键盘上国际字符的缺失有关，并提出了以下问题：你不应该把它读成*faKade*吗？你可以把这个问题看作是*celtic*的反面，*celtic*的发音是*Keltic*，用*k*音代替了*s*音。
- en: The main problem that we want to solve is being able to use external code in
    an easier way (of course, if it were your code, you could handle such problems
    directly; we must assume you cannot--or shouldn't--try to modify that other code.
    This would be the case when you use any library that's available over the web,
    for example). The key to this is to implement a module of your own that will provide
    an interface that better suits your need. Your code will use your module and won't
    directly interact with the original code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要解决的主要问题是能够以更简单的方式使用外部代码（当然，如果是你的代码，你可以直接处理这些问题；我们必须假设你不能——或者不应该——尝试修改其他代码。例如，当你使用任何可在网上获得的库时，就会出现这种情况）。关键是实现一个自己的模块，提供更适合你需求的接口。你的代码将使用你的模块，而不会直接与原始代码交互。
- en: 'Suppose that you want to do Ajax calls, and your only possibility is using
    some hard library with a really complex interface. With ES8''s modules, you might
    write something as the following, working with an imagined hard Ajax library:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要进行Ajax调用，你唯一的可能性是使用一些具有非常复杂接口的库。有了ES8的模块，你可以编写以下内容，使用一个想象中的复杂Ajax库：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, if you need to do a `GET` or `POST`, instead of having to go through all
    the complications of the provided hard Ajax library, you can use the new façade
    that provides a simpler way of working. Developers would just `import {getUrl,
    postUrl} from "simpleAjax"` and could then work in a more reasonable way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你需要进行`GET`或`POST`，而不是必须经历提供的复杂Ajax库的所有复杂性，你可以使用提供更简单工作方式的新façade。开发人员只需`import
    {getUrl, postUrl} from "simpleAjax"`，然后可以以更合理的方式工作。
- en: 'However, why are we showing this code that, though interesting, doesn''t show
    any particular FP aspects? The key is that, at least until modules are fully implemented
    in browsers, the internal, implicit way to do this is with the usage of an IIFE
    (*immediately invoked function expression*) as we saw in the*Immediate Invocation*sectionof
    [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with Functions
    - A Core Concept*, by means of a *revealing module* pattern:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为什么我们要展示这段代码，虽然有趣，但并没有显示任何特定的FP方面？关键是，至少在浏览器中完全实现模块之前，隐式的内部方法是使用IIFE（*立即调用函数表达式*），就像我们在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)的*立即调用*部分中看到的那样，通过*模块模式*的方式：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The reason for the *revealing module*name should be now obvious. With the preceding
    code, because of the scope rules in JS, the only visible attributes of `simpleAjax`
    will be `simpleAjax.getUrl` and `simpleAjax.postUrl`; using an IIFE lets us implement
    the module (and thus thefaçade) in a safe way, making implementation details private.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*揭示模块*名称的原因现在应该是显而易见的。由于JS中的作用域规则，`simpleAjax`的唯一可见属性将是`simpleAjax.getUrl`和`simpleAjax.postUrl`；使用IIFE让我们以安全的方式实现模块（因此也实现了外观），使实现细节成为私有的。'
- en: Now, the *Adapter* pattern is similar, insofar it is also meant to define a
    new interface. However, whileFaçadedefines a new interface to old code, Adapter
    is used when you need to implement an old interface for a new code, so it will
    match what you already had. If you are working with modules, it's clear that the
    same type of solution that worked for Façade will work here, so we don't have
    to study it in detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，*适配器*模式类似，因为它也意味着定义一个新接口。然而，虽然*外观*为旧代码定义了一个新接口，但当您需要为新代码实现旧接口时，就会使用适配器，以便匹配您已经拥有的内容。如果您正在使用模块，很明显，对于*外观*有效的解决方案在这里也同样有效，因此我们不必深入研究它。
- en: Decorator or Wrapper
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器或包装器
- en: The *Decorator* pattern (also known as *Wrapper*) is useful when you want to
    add additional responsibilities or functionalities to an object in a dynamic way.
    Let's consider a simple example, which we will illustrate with some React code.
    (Don't worry if you do not know this framework; the example will be easy to understand).
    Suppose we want to show some element on screen, and for debugging purposes, we
    want to show a thin red border around the object. How can you do it?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*装饰器*模式（也称为*包装器*）在您希望以动态方式向对象添加额外的职责或功能时非常有用。让我们考虑一个简单的例子，我们将用一些React代码来说明。
    （如果您不了解这个框架，不要担心；这个例子很容易理解）。假设我们想在屏幕上显示一些元素，并且出于调试目的，我们想在对象周围显示一个红色的细边框。您该如何做？'
- en: If you were programming using OO, you would probably have to create a new subclass,
    with the extended functionality. For this particular example, you may just provide
    some attribute with the name of some CSS class that would provide the required
    style, but let's keep ourfocusto the OO; using CSS won't always solve this software
    design problem, so we want a more general solution. The new subclass would *know*how
    to show itself with a border, and you'd use this subclass whenever you wanted
    an object's border to be visible.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用面向对象编程，您可能需要创建一个具有扩展功能的新子类。对于这个特定的例子，您可能只需提供一些属性，其名称为一些CSS类，该类将提供所需的样式，但让我们将注意力集中在面向对象上；使用CSS并不总是解决这个软件设计问题，因此我们需要一个更通用的解决方案。新的子类将*知道*如何显示自己的边框，并且每当您想要对象的边框可见时，您将使用这个子类。
- en: With our experience on higher-order functions, we can solve this in a different
    way using*wrapping*; wrap the original function within another one, which would
    provide the extra functionality.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们对高阶函数的经验，我们可以用*包装*的方式以不同的方式解决这个问题；将原始函数包装在另一个函数中，该函数将提供额外的功能。
- en: Note that we have already seen some examples of wrapping in the*Wrapping functions*sectionof
    [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml), *Producing Functions
    - Higher-Order Functions*. For example, in that section, we saw how to wrap functions
    in order to produce new versions that could log their input and output, provide
    timing information, or even memorize calls to avoid future delays. In this occasion,
    for a variety, we are applying the concept to *decorate*a visual component, but
    the principle remains the same.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)的*生成函数 - 高阶函数*部分中，我们已经看到了一些包装的示例。例如，在该部分中，我们看到了如何包装函数以生成可以记录其输入和输出、提供时间信息，甚至记忆调用以避免未来延迟的新版本。在这种情况下，为了多样性，我们将这个概念应用于*装饰*一个可视组件，但原则仍然是相同的。
- en: 'Let''s define a simple React component, `ListOfNames`, that can display a heading
    and a list of people, and for the latter, it will use a `FullNameDisplay` component.
    The code for those elements would be as seen in the following fragment:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个简单的React组件，`ListOfNames`，它可以显示一个标题和一个人员列表，对于后者，它将使用`FullNameDisplay`组件。这些元素的代码如下片段所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `ListOfNames` component uses mapping to create a `FullNameDisplay` component
    to show data for each person.The full logic for our application could then be
    the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListOfNames`组件使用映射来创建`FullNameDisplay`组件，以显示每个人的数据。我们应用程序的完整逻辑可能如下：'
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In real life, you wouldn''t put all the code for every component in the single,
    same source code file -- and you would probably have a few CSS files. However,
    for our example, having everything in one place, and going with inline styles
    is enough, so bear with me and keep in mind the following saying: *Do as I say,
    not as I do.*'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，您不会将每个组件的所有代码都放在同一个源代码文件中——您可能会有几个CSS文件。但是，对于我们的例子，将所有内容放在一个地方，并使用内联样式就足够了，所以请忍耐一下，并记住以下格言：*说话容易做到难*。
- en: 'We can quickly test the result in the online React sandbox at[https://codesandbox.io/](https://codesandbox.io/);
    Google for *react online sandbox*if you want some other options. Results aren''t
    much to talk about, but we are interested in a design pattern right now, and not
    in UI design; refer to Figure 11.1:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[https://codesandbox.io/](https://codesandbox.io/)在线React沙箱中快速测试结果；如果您想要其他选项，请搜索*react
    online sandbox*。结果并不值得讨论，但我们现在对设计模式感兴趣，而不是UI设计；参考图11.1：
- en: '![](assets/a42709b0-331b-4b4c-91d5-6311602b8b7b.png)Figure 11.1: The original
    version of our components shows a (not much to speak about) list of names'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/a42709b0-331b-4b4c-91d5-6311602b8b7b.png)图11.1：我们组件的原始版本显示了一个（不值得一提）的名称列表'
- en: 'In React, inline components are written in JSX (inline HTML style) and are
    actually compiled into objects, which are later transformed into HTML code to
    be displayed. Whenever the `render()` method is called, it returns a structure
    of objects. So, if we write a function that will take a component as a parameter,
    and return new JSX, which will be a wrapped object. In our case, we''d like to
    wrap the original component within a `<div>` with the required border:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，内联组件是用JSX（内联HTML样式）编写的，实际上被编译为对象，稍后将其转换为HTML代码以进行显示。每当调用`render()`方法时，它都会返回一组对象结构。因此，如果我们编写一个函数，该函数将以组件作为参数，并返回新的JSX，这将是一个包装对象。在我们的情况下，我们希望在所需的边框内包装原始组件：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you wish, you could make this function aware of whether it's executing in
    development mode or in production; in the latter case, it would simply return
    the original component argument without any change, but let's not worry about
    that now.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以使此函数知道它是在开发模式下执行还是在生产模式下执行；在后一种情况下，它将简单地返回原始组件参数，而不做任何更改，但现在让我们不要担心这个。
- en: 'We now have to change `ListOfNames` to use wrapped components:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须更改`ListOfNames`以使用包装组件：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The decorated version of the code works as expected: each of the `ListOfNames`
    components is now wrapped in another component that adds the desired border to
    them; refer to Figure 11.2:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的装饰版本按预期工作：现在`ListOfNames`组件中的每个组件都包装在另一个组件中，该组件为它们添加所需的边框；请参阅图11.2：
- en: '![](assets/745c6765-ee43-43b5-bc74-31bd45f70c3a.png)Figure 11.2: The decorated
    ListOfNames component is still nothing much to look at, but now it shows an added
    border'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![](assets/745c6765-ee43-43b5-bc74-31bd45f70c3a.png)图11.2：装饰的ListOfNames组件仍然没有太多可看的，但现在它显示了一个添加的边框'
- en: In earlier chapters, we saw how to decorate a function, wrapping it inside of
    another function, so it would perform extra code and add a few functionalities.
    Now, here, we saw how to apply the same style of solution to provide a *higher-order
    component*(as called in React parlance) wrapped in an extra `<div>` to provide
    some visual distinctive details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的章节中，我们看到如何装饰一个函数，将其包装在另一个函数中，以便执行额外的代码并添加一些功能。现在，在这里，我们看到了如何应用相同风格的解决方案，以提供一个*高阶组件*（在React术语中称为）包装在额外的`<div>`中，以提供一些视觉上的独特细节。
- en: If you have used Redux and the *react-redux* package, you may note that the
    latter's `connect()` method is also a decorator in the same sense; it receives
    a component class, and returns a new, connected to the store, component class
    for usage in your forms; refer to[https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux)
    for more details.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用过Redux和*react-redux*包，您可能会注意到后者的`connect()`方法也是以相同方式的装饰器；它接收一个组件类，并返回一个新的、连接到存储的组件类，供您在表单中使用；有关更多详细信息，请参阅[https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux)。
- en: Strategy, Template, and Command
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略、模板和命令
- en: The *Strategy* pattern applies whenever you want to have the ability to change
    a class, method, or function, possibly in a dynamic way, by changing the way it
    *does its thing*. For example, a GPS application might want to find a route between
    two places, but applying different strategies if the person is on foot, rides
    a bicycle, or goes by car. In that case, the fastest or the shortest routes might
    be desired. The problem is the same, but different algorithms must be applied,
    depending on the given condition.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*策略*模式适用于您希望能够通过更改*执行其操作方式*的方式来更改类、方法或函数的能力，可能是以动态方式。例如，GPS应用程序可能希望在两个地点之间找到一条路线，但如果人是步行、骑自行车或开车，就应用不同的策略。在这种情况下，可能需要最快或最短的路线。问题是相同的，但根据给定条件，必须应用不同的算法。'
- en: By the way, does this sound familiar? If so, it is because we have already met
    a similar problem. When we wanted to sort a set of strings in different ways,
    in [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*, we needed a way to specify how the ordering was to
    be applied or, equivalently, how to compare two given strings and determine which
    had to go first. Depending on the language, we had to sort applying different
    comparison methods.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，这听起来很熟悉吗？如果是这样，那是因为我们已经遇到过类似的问题。当我们想以不同的方式对一组字符串进行排序时，在[第3章](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml)中，*从函数开始
    - 核心概念*，我们需要一种方法来指定如何应用排序，或者等效地，如何比较两个给定的字符串并确定哪个应该先进行。根据语言的不同，我们必须应用不同的比较方法进行排序。
- en: 'Before trying an FP solution, let''s consider more ways of implementing our
    routing function. You could make do by having a big enough piece of code, which
    would receive an argument declaring which algorithm to use, plus the starting
    and ending points. With these arguments, the function could do a switch or something
    similar to apply the correct path-finding logic. The code would be roughly equivalent
    to the following fragment:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试FP解决方案之前，让我们考虑更多实现我们的路由功能的方法。您可以通过编写足够大的代码来实现，该代码将接收声明要使用哪种算法以及起点和终点的参数。有了这些参数，函数可以执行switch或类似的操作来应用正确的路径查找逻辑。代码大致等同于以下片段：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This kind of solution is really not desirable, and your function is really the
    sum of a lot of distinct other functions, which doesn't offer a high level of
    cohesion. If your language doesn't support lambda functions (as was the case with
    Java, for example, until Java 8 came out in 2014), the OO solution for this requires
    defining classes that implement the different strategies you may want, creating
    an appropriate object, and passing it around.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案确实不理想，您的函数实际上是许多不同其他函数的总和，这并不提供高度的内聚性。如果您的语言不支持lambda函数（例如，直到2014年Java
    8推出之前，Java就是这种情况），则此问题的OO解决方案需要定义实现您可能想要的不同策略的类，创建一个适当的对象，并将其传递。
- en: 'With FP in JS, implementing strategies is trivial, instead of using a variable
    such as`byMeans`to switch, you can just pass a function around, which will implement
    the desired path logic:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在JS中使用FP，实现策略是微不足道的，而不是使用`byMeans`这样的变量进行切换，您可以只是传递一个函数，该函数将实现所需的路径逻辑：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You would still have to implement all the desired strategies (no way around
    that) and decide which function to pass to `findRoute()`, but now that function
    is independent of the routing logic, and if you wanted to add new routing algorithms,
    you wouldn't touch `findRoute()`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然必须实现所有所需的策略（没有其他方法），并决定要传递给`findRoute()`的函数，但现在该函数独立于路由逻辑，如果您想要添加新的路由算法，您不会触及`findRoute()`。
- en: If you consider the *Template* pattern, the difference is that Strategy allows
    you to use completely different ways of achieving an outcome, while Template provides
    an overarching algorithm (or *template*) in which some implementation details
    are left to methods to be specified. In the same way, you can provide functions
    to implement the Strategy pattern; you can also provide them for a Template pattern.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果考虑*模板*模式，不同之处在于策略允许您使用完全不同的方式来实现结果，而模板提供了一个总体算法（或*模板*），其中一些实现细节留给方法来指定。同样，您可以提供函数来实现策略模式；您也可以为模板模式提供函数。
- en: Finally, the pattern*Command*also benefits from the ability of being able to
    pass functions as arguments.This pattern is meant to be enabled to encapsulate
    a request as an object, so for different requests, you have differently parameterized
    objects. Given that we can simply pass functions as arguments to other functions,
    there's no need for the *enclosing*object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，*命令*模式也受益于能够将函数作为参数传递。这种模式旨在将请求封装为对象，因此对于不同的请求，您有不同参数化的对象。鉴于我们可以简单地将函数作为参数传递给其他函数，因此不需要*封闭*对象。
- en: We also saw a similar use of this pattern back in the *A React+Redux reducer*section
    of [Chapter 3](89a2ff2f-a67d-4a21-a2f5-cd54bed7198a.xhtml), *Starting Out with
    Functions - A Core Concept*. There, we defined a table, each of whose entries
    was a callback that was called whenever needed. We could directly say that the
    Command pattern is just an object-oriented replacement for plain functions working
    as callbacks.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在《第3章》的*A React+Redux reducer*部分看到了这种模式的类似用法，*从函数开始 - 核心概念*。在那里，我们定义了一个表，其中每个条目都是在需要时调用的回调。我们可以直接说，命令模式只是作为回调工作的普通函数的面向对象替代。
- en: Other patterns
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他模式
- en: 'Let''s end this section by glossing over some other patterns, where the equivalence
    may or may not be so good:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过简要介绍一些其他模式来结束本节，其中等价性可能不那么完美：
- en: '**Currying and Partial Application** (which we saw in [Chapter 7](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml),
    *Transforming Functions - Currying and Partial Application*): This can be seen
    as approximately equivalent to a *Factory* for functions. Given a general function,
    you can produce specialized cases by fixing one or more arguments, and this is,
    in essence, what a Factory does, of course, speaking about functions, and not
    objects.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**柯里化和部分应用**（我们在[第7章](44b5eafa-dc7f-45e4-8b9e-9bb5bb9b02ec.xhtml)中看到，*转换函数
    - 柯里化和部分应用*）：这可以被视为函数的*工厂*的近似等价物。给定一个通用函数，您可以通过固定一个或多个参数来生成专门的情况，这本质上就是工厂所做的事情，当然，这是关于函数而不是对象。'
- en: '**Declarative functions**(such as `map()` or `reduce()`): They can be considered
    an application of the *Iterator* pattern. The traversal of the container''s elements
    is decoupled from the container itself. You might also provide different `map()`
    methods for different objects, so you could traverse all kinds of data structures.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明性函数**（例如`map()`或`reduce()`）：它们可以被视为*Iterator*模式的应用。容器元素的遍历与容器本身解耦。您还可以为不同的对象提供不同的`map()`方法，因此可以遍历各种数据结构。'
- en: '**Persistent data structures**: As mentioned in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml),
    *Ensuring Purity - Immutability*, they allow for an implementation of the *Memento*
    pattern. The central idea is, given an object, to be able to go back to a previous
    state. As we saw, each updated version of a data structure doesn''t impact on
    the previous one(s), so you could easily add a mechanism to provide any earlier
    state and *roll back*to it.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久数据结构**：如[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中所述，*确保纯度 - 不可变性*，它们允许实现*Memento*模式。其核心思想是，给定一个对象，能够返回到先前的状态。正如我们所看到的，数据结构的每个更新版本都不会影响先前的版本，因此您可以轻松添加一个机制来提供任何先前的状态并*回滚*到它。'
- en: 'A **Chain of Responsibility** pattern: In this pattern, there is a potentially
    variable number of *request processors*, and a stream of requests to be handled,
    may be implemented using `find()` to determine which is the processor that will
    handle the request (the desired one is the first in the list that accepts the
    request) and then simply doing the required process.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任链**模式：在这种模式中，可能存在可变数量的*请求处理器*，并且要处理的请求流可以使用`find()`来确定哪个是处理请求的处理器（所需的是接受请求的列表中的第一个），然后简单地执行所需的处理。'
- en: 'Remember the warning at the beginning: with these patterns, the match with
    FP techniques may not be so perfect as with others that we have previously seen,
    but the idea was to show that there are some common FP patterns that can be applied,
    and it will produce the same results as the OOP solutions, despite having different
    implementations.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住开始时的警告：对于这些模式，与FP技术的匹配可能不像我们之前看到的那样完美，但是我们的目的是要表明有一些常见的FP模式可以应用，并且将产生与面向对象解决方案相同的结果，尽管具有不同的实现。
- en: Functional design patterns
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能设计模式
- en: After having seen several OOP design patterns, it may seem a cheat to say that
    there's no approved, official, or even remotely generally accepted similar list
    of patterns for FP. There are, however,several problems for which there are standard
    FP solutions, which can be considered design patterns on their own, and we have
    already covered most of them in the book.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在看过了几种面向对象设计模式之后，可能会认为说FP没有经过批准、官方或甚至远程普遍接受的类似模式列表是一种欺骗。然而，对于某些问题，存在标准的FP解决方案，这些解决方案本身可以被视为设计模式，并且我们已经在书中涵盖了大部分。
- en: 'What are candidates for a possible list of patterns? Let''s attempt preparing
    one -- but remember, it''s just a personal view; also, I''ll admit that I''m not
    trying to mimic the usual style ofpattern definition--I''ll just be mentioning
    a general problem and refer to the way FP in JS can solve it, and I won''t be
    aiming for nice, short, memorable names for the patterns either:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的模式清单有哪些候选者？让我们尝试准备一个--但请记住，这只是一个个人观点；另外，我承认我并不打算模仿通常的模式定义风格--我只会提到一个一般问题并提到JS中FP的解决方法，我也不会为这些模式力求取一个好听、简短、易记的名字：
- en: '**Processing collections using filter/map/reduce:**Whenever you have to process
    a data collection, using declarative, higher-order functions, as `filter()`, `map()`,
    and `reduce()`, as we saw in [Chapter 5](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml),*Programming
    Declaratively - A Better Style*, is a way to remove complexity from the problem
    (the usual *MapReduce* web framework is an extension of this concept, which allows
    for distributed processing among several servers, even if the implementation and
    details aren''t exactly the same). Instead of performing looping and processing
    as a single step, you should think about the problem as a sequence of steps, sequentially
    applied, applying transformations until obtaining the final, desired result.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用filter/map/reduce处理集合**：每当你需要处理数据集合时，使用声明式的高阶函数，如`filter()`、`map()`和`reduce()`，就像我们在[第5章](3cf24154-32aa-4bcd-bfbe-e9de8fe35096.xhtml)中看到的那样，*声明式编程
    - 更好的风格*，是一种从问题中消除复杂性的方法（通常的*MapReduce* web框架是这个概念的扩展，它允许在多个服务器之间进行分布式处理，即使实现和细节并不完全相同）。你不应该将循环和处理作为一个步骤来执行，而应该将问题看作一系列顺序应用的步骤，应用转换直到获得最终期望的结果。'
- en: JS also includes *iterators*, that is, another way of looping through a collection.
    Using *iterators* isn't particularly functional, but you may want to look at them
    since they may be able to simplify some situations. Read more at[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: JS还包括*迭代器*，也就是通过集合的另一种循环方式。使用*迭代器*并不特别功能，但你可能想看看它们，因为它们可能能简化一些情况。在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)了解更多。
- en: '**Lazy evaluation with thunks**: The idea of *lazy evaluation*is not doing
    any calculations until they are actually needed. In some programming languages,
    this is built-in. However, in JS (and in most imperative languages as well) *eager
    evaluation* is applied, in which an expression is evaluated as soon as it is bound
    to some variable (another way of saying this is that JavaScript is a *strict programming
    language*, with a *strict paradigm*, which only allows calling a function if all
    of its parameters have been completely evaluated). This sort of evaluation is
    required when you need to specify the order of evaluation with precision, mainly
    because such evaluations may have side effects. In FP, which is rather more declarative
    and pure, you can delay such evaluation with *thunks* (which we used in the*Trampolines
    and Thunks*section of [Chapter 9](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml),
    *Designing Functions - Recursion*) by passing a thunk that can do instead of doing
    a calculationso that whenever the actual value is needed, it will be calculated
    at that time, but not earlier.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用thunks进行惰性求值**：*惰性求值*的概念是在实际需要之前不进行任何计算。在一些编程语言中，这是内置的。然而，在JS（以及大多数命令式语言）中，应用的是*急切求值*，也就是表达式在绑定到某个变量时立即求值（另一种说法是JavaScript是一种*严格的编程语言*，具有*严格的范式*，只有在所有参数都完全求值后才允许调用函数）。当你需要精确指定求值顺序时，这种求值是必需的，主要是因为这样的求值可能会产生副作用。在FP中，你可以通过传递一个可以执行而不是进行计算的thunk（我们在[第9章](0f9ddfc4-d3d9-40a9-941b-edbec62cc890.xhtml)的*Trampolines
    and Thunks*部分中使用了thunk，*设计函数 - 递归*）来延迟这种求值，这样每当实际值需要时，它将在那时计算，而不是更早。'
- en: You may also want to look at JS *generators*, which is another way of delaying
    evaluation, though it's not particularly related to FP at all. Read more about
    *generators* at[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator).
    The combination of *generators* and promises is called an async function, and
    those may be of interest to you; refer to[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想看看JS的*生成器*，这是另一种延迟求值的方式，尽管它与FP并没有特别的关系。在[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator)了解更多关于*生成器*的信息。*生成器*和promises的组合被称为异步函数，这可能会引起你的兴趣；参考[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)。
- en: '**Persistent data structures for immutability**. Having immutable data structures,
    as we saw in [Chapter 10](383f5538-72cc-420a-ae77-896776c03f27.xhtml), *Ensuring
    Purity - Immutability*, is mandatory when working with certain frameworks, and
    in general it is recommended because it helps to reason about a program or debugging
    it. (Earlier in this chapter, we also mentioned how the *Memento* OOP pattern
    can be implemented in this fashion). Whenever you have to represent structured
    data, the FP solution of using a persistent data structure helps in many ways.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变性的持久数据结构**。拥有不可变的数据结构，就像我们在[第10章](383f5538-72cc-420a-ae77-896776c03f27.xhtml)中看到的那样，*确保纯净
    - 不可变性*，在使用某些框架时是强制性的，而且一般来说是推荐的，因为它有助于推理程序或调试程序。（在本章的早些地方，我们还提到了*备忘录*面向对象模式可以以这种方式实现）。每当你需要表示结构化数据时，使用持久数据结构的FP解决方案在许多方面都有帮助。'
- en: '**Wrapped values for checks and operations**: If you directly work with variables
    or data structures, you may modify them at will (possibly violating any restrictions)
    or you may need to do many checks before using them (such as verifying that a
    value is not null before trying to access the corresponding object). The idea
    of this pattern is to wrap a value within an object or function, so direct manipulation
    won''t be possible, and checks can be managed in a more functional way. We''ll
    be referring to more of this in [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml),
    *Building Better Containers - Functional Data Types.*'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于检查和操作的包装值**：如果直接使用变量或数据结构，您可能会随意修改它们（可能违反任何限制），或者在使用它们之前可能需要进行许多检查（例如在尝试访问相应对象之前验证值不为空）。这种模式的想法是将一个值包装在对象或函数中，这样就不可能进行直接操作，并且可以以更加功能化的方式进行管理检查。我们将在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中更多地提到这一点，*构建更好的容器-功能数据类型*。'
- en: As we have said, the power of FP is such that instead of having a couple of
    dozens standard design patterns (and that's only in the GoF book; if you read
    other texts, the list grows!) there isn't yet a standard or acknowledged list
    of functional patterns.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，FP的力量在于，与其拥有几十种标准设计模式（这仅仅是在GoF书中；如果您阅读其他文本，列表会变得更长！），还没有一个标准或公认的功能模式列表。
- en: Questions
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: '11.1\. **Decorating methods, the future way**. In [Chapter 6](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml),
    *Producing Functions - Higher-Order Functions*, we wrote a decorator to enable
    logging for any function. Currently, method decorators are being considered for
    upcoming versions of JavaScript: refer to[https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)
    for that (Draft 2 means that inclusion of this feature in the standard is likely,
    although there may be some additions or small changes). Study the draft and take
    a look at what makes the next code tick.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 11.1\. **装饰方法，未来的方式**。在[第6章](9f36fbcb-da30-4a75-9b47-01cd3427633e.xhtml)中，*生成函数-高阶函数*，我们编写了一个装饰器来为任何函数启用日志记录。目前，方法装饰器正在考虑纳入JavaScript的即将推出的版本中：请参阅[https://tc39.github.io/proposal-decorators/](https://tc39.github.io/proposal-decorators/)（草案2意味着该功能很可能会被纳入标准，尽管可能会有一些添加或小的更改）。研究草案，看看是什么让下一个代码运行。
- en: 'Some questions: Do you see the need for the `savedMethod` variable? Why do
    we use `function()` when assigningnew `descriptor.value`, instead of an arrow
    function? Can you understand why `.bind()` is used? What is `descriptor`?'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些问题：您是否认为需要`savedMethod`变量？为什么在分配新的`descriptor.value`时使用`function()`，而不是箭头函数？您能理解为什么要使用`.bind()`吗？`descriptor`是什么？
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'A working example would be as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个工作示例如下：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '11.2.**Decorator with mixins**: Back in the *Questions* section of [Chapter
    1](395f5897-0ecc-4841-86ed-21521e148beb.xhtml), *Becoming Functional - Several
    Questions*, we saw that classes are first-class objects. Taking advantage of this,
    complete thefollowing`addBar()`function, which will add some mixins to the `Foo`
    class so that code will run as shown. The created `fooBar` object should have
    two attributes (`.fooValue` and `.barValue`) and twomethods (`.doSomething()`
    and `.doSomethingElse()`) that simply show some text and a property:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 11.2.**使用mixin的装饰器**：回到[第1章](395f5897-0ecc-4841-86ed-21521e148beb.xhtml)的*问题*部分，*成为功能性-几个问题*，我们看到类是一等对象。利用这一点，完成以下`addBar()`函数，它将向`Foo`类添加一些mixin，以便代码将如所示运行。创建的`fooBar`对象应该有两个属性（`.fooValue`和`.barValue`）和两个方法（`.doSomething()`和`.doSomethingElse()`），它们只是显示一些文本和一个属性。
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Could you include a third mixin, `addBazAndQux()`, so that`addBazAndQux(addBar(Foo))`
    would add even more attributes and methods to`Foo`?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您能否包括第三个mixin，`addBazAndQux()`，以便`addBazAndQux(addBar(Foo))`会向`Foo`添加更多属性和方法？
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have done a bridge from the object-oriented way of thinking,
    and the usual patterns that we use when coding that way, to the functional programming
    style, by showing how we can solve the same basic problems, but rather more easily
    than with classes and objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经从面向对象的思维方式和编码时使用的常规模式，过渡到了函数式编程风格，通过展示如何解决相同的基本问题，但比使用类和对象更容易。
- en: In [Chapter 12](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml), *Building Better
    Containers - Functional Data Types*, we will be working with a *potpourri*of functional
    programming concepts, which will give you, even more, ideas about tools you can
    use. I promised that this book wouldn't become deeply theoretical, but rather
    more practical, and we'll try to keep it this way, even if some of the presented
    concepts may look abstruse or remote.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](0d82d215-9bfc-436b-b09d-8ed2e2ebd441.xhtml)中，*构建更好的容器-功能数据类型*，我们将使用一系列功能编程概念，这将给您更多关于可以使用的工具的想法。我承诺这本书不会变得深奥理论，而更加实用，我们会尽量保持这种方式，即使其中一些概念可能看起来晦涩或遥远。
