- en: '*Chapter 9*: Helm Security Considerations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：Helm安全性考虑'
- en: As you have likely come to realize throughout this book, Helm is a powerful
    tool that presents many deployment possibilities to users. This power can, however,
    get out of hand if certain security paradigms are not recognized and followed.
    Luckily, Helm provides many ways to incorporate security into everyday usage in
    ways that are simple to achieve, from the moment the Helm CLI is downloaded to
    the moment a Helm chart is installed on a Kubernetes cluster.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能在本书中意识到的那样，Helm是一个强大的工具，为用户提供了许多部署可能性。然而，如果不认识和遵循某些安全范例，这种力量可能会失控。幸运的是，Helm提供了许多方法来将安全性纳入日常使用中，这些方法简单易行，从下载Helm
    CLI到在Kubernetes集群上安装Helm图表的整个过程中都可以实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Data provenance and integrity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据溯源和完整性
- en: Helm chart security
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm图表安全性
- en: Additional considerations around RBAC, values, and chart repositories
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于RBAC、值和图表仓库的额外考虑
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter will make use of the following technologies:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用以下技术：
- en: '`minikube`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minikube`'
- en: '`kubectl`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kubectl`'
- en: Helm
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm
- en: '**GNU Privacy Guard** (**GPG**)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GNU隐私保护**（**GPG**）'
- en: The installation and configuration of Minikube, Kubectl, and Helm was covered
    in [*Chapter 2*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098), *Preparing a
    Kubernetes and Helm Environment*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Minikube、Kubectl和Helm的安装和配置在[*第2章*](B15458_02_Final_JM_ePub.xhtml#_idTextAnchor098)，*准备Kubernetes和Helm环境*中有介绍。
- en: 'We will also leverage the `guestbook` chart from the Packt repository, located
    at [https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm),
    for a later example in this chapter. If you have not already cloned this repository,
    be sure to do so with the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将利用Packt仓库中的`guestbook`图表，位于[https://github.com/PacktPublishing/-Learn-Helm](https://github.com/PacktPublishing/-Learn-Helm)，在本章的后续示例中。如果你还没有克隆这个仓库，请使用以下命令进行克隆。
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Data provenance and integrity
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据溯源和完整性
- en: 'When working with any kind of data, there are two often-overlooked questions
    that should be considered:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理任何类型的数据时，有两个经常被忽视的问题需要考虑：
- en: Does the data come from a reliable source or from the source that you expected
    it to?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是否来自可靠的来源或者你期望的来源？
- en: Does the data contain all of the contents that you expected it to?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据是否包含你期望的所有内容？
- en: The first question refers to the topic of **data provenance**. Data provenance
    is about determining where data originated from.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题涉及**数据溯源**的主题。数据溯源是关于确定数据的来源。
- en: The second question refers to the topic of **data integrity**. Data integrity
    is about determining whether the contents you received from a remote location
    represent what you expected to receive and can help determine whether the data
    was tampered with as it was sent through the wire. Both data provenance and data
    integrity can be verified using a concept called **digital signatures**. An author
    can create a unique signature based on cryptography to sign data and the consumer
    of that data can use cryptographic tools to verify the authenticity of that signature.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题涉及**数据完整性**的主题。数据完整性是关于确定你从远程位置接收到的内容是否代表你期望接收到的内容，并且可以帮助确定数据在传输过程中是否被篡改。数据溯源和数据完整性都可以使用称为**数字签名**的概念进行验证。作者可以基于密码学创建一个唯一的签名来签署数据，而数据的消费者可以使用密码工具来验证该签名的真实性。
- en: If the authenticity is verified, then the consumer knows that the data originates
    from the expected source and was not tampered with as it was transferred.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果真实性得到验证，那么消费者就知道数据来自期望的来源，并且在传输过程中没有被篡改。
- en: Authors can create a digital signature by first creating a **Pretty Good Privacy**
    (**PGP**) keypair. PGP, in this context, refers to OpenPGP, which is a set of
    standards based on encryption. PGP focuses on establishing asymmetric encryption,
    which is based on the use of two different keys—private and public.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 作者可以通过首先创建一个**Pretty Good Privacy**（**PGP**）密钥对来创建数字签名。在这种情况下，PGP指的是OpenPGP，这是一组基于加密的标准。PGP侧重于建立非对称加密，这是基于使用两个不同密钥——私钥和公钥的。
- en: Private keys are meant to be kept secret, while public keys are designed to
    be shared. For digital signatures, the private key is used to encrypt data, while
    a public key is used by consumers to decrypt that data. The PGP keypair is often
    created using a tool called GPG, which is an open source tool that implements
    the OpenPGP standard.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥应保密，而公钥则设计为共享。对于数字签名，私钥用于加密数据，而公钥由消费者用于解密数据。PGP密钥对通常使用一个名为GPG的工具创建，这是一个实现OpenPGP标准的开源工具。
- en: 'Once the PGP keypair is created, the author can use GPG to sign the data. When
    the data is signed, GPG performs the following steps in the background:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建PGP密钥对后，作者可以使用GPG对数据进行签名。当数据被签名时，GPG在后台执行以下步骤：
- en: A hash is calculated based on the contents of the data. The output is a fixed-length
    string called the **message digest**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希是基于数据内容计算的。输出是一个称为**消息摘要**的固定长度字符串。
- en: The message digest is encrypted using the author's private key. The output is
    the digital signature.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息摘要使用作者的私钥加密。输出是数字签名。
- en: To verify the signature, consumers must use the author's public key to decrypt
    it. This verification can also be performed using GPG.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证签名，消费者必须使用作者的公钥来解密它。这种验证也可以使用GPG来执行。
- en: 'Digital signatures play a role in Helm in two ways:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名在Helm中发挥两种作用：
- en: First, each Helm download has an accompanying digital signature from one of
    the maintainers that can be used to verify the authenticity of the binary. The
    signature can be used to verify the origin of the download, as well as its integrity.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，每个Helm下载都有一个来自维护者之一的数字签名，可用于验证二进制文件的真实性。签名可用于验证下载的来源以及其完整性。
- en: Second, Helm charts can also be digitally signed to benefit from the same verifications.
    Authors of a chart sign the chart during packaging and the chart users verify
    the validity of the chart by using the author's public key.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，Helm图表也可以进行数字签名以从相同的验证中受益。图表的作者在打包期间对图表进行签名，图表用户使用作者的公钥验证图表的有效性。
- en: With an understanding of how data provenance and integrity come into play as
    they relate to digital signatures, let's create a GPG keypair on your local work
    station, if you do not already have one, that will be used to elaborate on many
    of the previously described concepts.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数据来源和完整性如何与数字签名相关之后，让我们在本地工作站上创建一个GPG密钥对，如果您还没有一个，这将用于详细说明先前描述的许多概念。
- en: Creating a GPG keypair
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GPG密钥对
- en: 'In order to create a keypair, you must first have GPG installed on your local
    machine. Use the following instructions as a guide to install GPG on your local
    machine. Note that on Linux systems, you probably already have GPG installed:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建密钥对，您必须首先在本地计算机上安装GPG。请使用以下说明作为在本地计算机上安装GPG的指南。请注意，在Linux系统上，您可能已经安装了GPG：
- en: 'For Windows, you can use the Chocolatey package manager, as in the following
    command:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于Windows，您可以使用Chocolatey软件包管理器，如下命令所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can also download the installer for Win[dows from https://gpg4win.org/dow](https://gpg4win.org/download.html)nload.html.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从https://gpg4win.org/download.html下载Win的安装程序。
- en: 'For macOS, you can use the Homebrew package manager using the following command:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于macOS，您可以使用Homebrew软件包管理器，使用以下命令：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can also download the macOS-based insta[lled from https://sourceforge.net/p/gpgosx/docu](https://sourceforge.net/p/gpgosx/docu/Download/)/Download/.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从https://sourceforge.net/p/gpgosx/docu](https://sourceforge.net/p/gpgosx/docu/Download/)下载基于macOS的安装程序。
- en: 'For Debian-based Linux distributions, you can use the `apt` package manager,
    as shown:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于Debian的Linux发行版，您可以使用`apt`软件包管理器，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For RPM-based Linux distributions, you can use the `dnf` package manager, as
    shown:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于RPM的Linux发行版，您可以使用`dnf`软件包管理器，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you have installed GPG, you can create your own GPG keypair, which we will
    use throughout our discussion on data provenance and integrity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了GPG之后，您可以创建自己的GPG密钥对，我们将在数据来源和完整性讨论中使用它。
- en: 'The steps to configure this keypair are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 配置此密钥对的步骤如下：
- en: 'Run the following command to create a new keypair. This command can be run
    from any directory:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令创建新的密钥对。此命令可以从任何目录运行：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Follow the prompts to enter your name and email address. These will be used
    to identify you as the owner of the keypair and will be the name and email address
    seen by people who receive your public key.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照提示输入您的姓名和电子邮件地址。这些将用于标识您作为密钥对的所有者，并且将是接收您的公钥的人看到的名称和电子邮件地址。
- en: Press the *O* key to continue.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*O*键继续。
- en: You will then be prompted to enter your private key password. Enter and confirm
    the desired passphrase that will be used for encryption and decryption operations..
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将提示您输入私钥密码。输入并确认所需的用于加密和解密操作的密码短语。
- en: 'You will see an output similar to the following once your GPG keypair has been
    created:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的GPG密钥对创建成功，您将看到类似以下的输出：
- en: '![Figure 9.1: The output after the successful creation of the GPG keypair'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1：成功创建GPG密钥对后的输出'
- en: '](image/Figure_9.1.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.1.jpg)'
- en: 'Figure 9.1: The output following successful creation of the GPG keypair'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：成功创建GPG密钥对后的输出
- en: The output displays information about the public (`pub`) and private (`sub`)
    keys, as well as the fingerprint of the public key (the second line of the output).
    The fingerprint is a unique identifier used to identify you as the owner of that
    key. The third line, beginning with `uid`, displays the name and email address
    that you entered as you generated your GPG keypair.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示有关公共(`pub`)和私有(`sub`)密钥的信息，以及公钥的指纹（输出的第二行）。指纹是用于识别您作为该密钥所有者的唯一标识符。以`uid`开头的第三行显示了您在生成GPG密钥对时输入的姓名和电子邮件地址。
- en: With your `gpg` keypair now created, continue to the next section to learn how
    a Helm download can be verified.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的`gpg`密钥对已创建，请继续下一节，了解如何验证Helm下载。
- en: Verifying Helm downloads
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证Helm下载
- en: 'As discussed in *Chapter 2*, *Preparing a Kubernetes and Helm Environment*,
    one of the ways Helm can be installed is by downloading an archive from GitHub.
    These archives can be installed from Helm''s GitHub releases page ([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))
    by selecting one of the links shown in the following screenshot:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如*第2章*中所讨论的，*准备Kubernetes和Helm环境*，Helm可以通过从GitHub下载存档的方式进行安装。可以从Helm的GitHub发布页面([https://github.com/helm/helm/releases](https://github.com/helm/helm/releases))安装这些存档，方法是选择以下截图中显示的链接之一：
- en: '![Figure 9.2: The Installation section from Helm’s GitHub releases page'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2：Helm的GitHub发布页面中的安装部分'
- en: '](image/Figure_9.2.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.2.jpg)'
- en: 'Figure 9.2: The Installation section from Helm''s GitHub releases page'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：Helm的GitHub发布页面中的安装部分
- en: At the bottom of the **Installation** section, you'll notice a paragraph explaining
    that the release was signed. Each Helm release is signed by a Helm maintainer
    and can be verified against the digital signature that corresponds to the downloaded
    Helm release. Each of the digital signatures are located under the **Assets**
    section.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在**安装**部分的底部，您会注意到一个段落解释了发布已经签名。每个Helm发布都由Helm维护人员签名，并可以根据对应于下载的Helm发布的数字签名进行验证。每个数字签名都位于**资产**部分下面。
- en: 'The following screenshot shows how these are represented:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些文件的表示方式：
- en: '![Figure 9.3: The Assets section from Helm’s GitHub releases page'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3：Helm的GitHub发布页面上的资产部分'
- en: '](image/Figure_9.3.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_9.3.jpg)'
- en: 'Figure 9.3: The Assets section from Helm''s GitHub releases page'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：Helm的GitHub发布页面上的资产部分
- en: To verify the provenance and integrity of your Helm download, you should also
    download the corresponding `.asc` file. Note that `.sha256.asc` files are used
    to verify the integrity only. In this example, we will download the corresponding
    `.asc` file, which will verify both the provenance and integrity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证Helm下载的来源和完整性，您还应该下载相应的`.asc`文件。请注意，`.sha256.asc`文件仅用于验证完整性。在本例中，我们将下载相应的`.asc`文件，它将同时验证来源和完整性。
- en: 'Begin verifying a Helm release by following these steps:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下步骤开始验证Helm发布：
- en: Download the Helm archive under the installation that corresponds with your
    operating system. Although the Helm binary is likely already installed, you can
    still download an archive to follow along with the example. Once you have finished
    with the example, you can remove the archive from your workstation.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与您的操作系统对应的安装下下载Helm存档。虽然Helm二进制文件可能已经安装，但您仍然可以下载存档以便按照示例进行操作。完成示例后，您可以从工作站中删除存档。
- en: Download the `.asc` file that corresponds with your operating system. For example,
    if you are running an AMD64-based Linux system, you would download the `helm-v3.0.0-linux-amd64.tar.gz.asc`
    file.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载与您的操作系统相对应的`.asc`文件。例如，如果您正在运行基于AMD64的Linux系统，您将下载`helm-v3.0.0-linux-amd64.tar.gz.asc`文件。
- en: Important note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The version contained in the filename corresponds to the actual Helm version
    you are downloading.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名中包含的版本对应于您正在下载的实际Helm版本。
- en: 'Once both files are downloaded, you should see two similar files in the same
    directory on the command line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完这两个文件后，您应该在命令行的同一目录中看到两个类似的文件：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The next step involves importing the Helm maintainer's public key to your local
    `gpg` keyring. This allows you to decrypt the digital signature contained in the
    `.asc` file to verify the provenance and integrity of your download. The maintainer's
    public key can be retrieved by following the link to their keybase account. The
    link can be found by hovering your cursor over the `keybase account` words. In
    the example from *Figure 9.2*, this location resolves to [https://keybase.io/bacongobbler](https://keybase.io/bacongobbler).
    The public key can then be downloaded by adding `/pgp_keys.asc` to the end, making
    the [resulting link https://keybase.io/bacongobbl](https://keybase.io/bacongobbler/pgp_keys.asc)er/pgp_keys.asc.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及将Helm维护人员的公钥导入到您的本地`gpg`密钥环中。这样可以解密`.asc`文件中包含的数字签名，以验证您下载的内容的来源和完整性。可以通过转到其keybase帐户来检索维护人员的公钥。将鼠标悬停在`keybase帐户`一词上，即可找到该链接。在*图9.2*的示例中，此位置解析为[https://keybase.io/bacongobbler](https://keybase.io/bacongobbler)。然后，可以通过在末尾添加`/pgp_keys.asc`来下载公钥，生成的链接为[https://keybase.io/bacongobbl](https://keybase.io/bacongobbler/pgp_keys.asc)er/pgp_keys.asc。
- en: Note that there are multiple Helm maintainers, so your link may differ if you
    are performing verification on a different release. Be sure that you are downloading
    the correct public key that corresponds to the key that signed the release.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Helm有多个维护者，因此如果您对不同版本执行验证，则您的链接可能会有所不同。请确保您下载的是与签署发布的密钥对应的正确公钥。
- en: 'Let''s continue with the verification process:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续验证过程：
- en: 'Using the command line, download the public key corresponding to the Helm release
    signature:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行，下载与Helm发布签名对应的公钥：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once downloaded, you need to import the public key to your gpg keyring. This
    is done by running the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载完成后，您需要将公钥导入到您的gpg密钥环中。通过运行以下命令来完成：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the import is successful, you will see the following message:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入成功，您将看到以下消息：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that the public key of the digital signature has been imported, you can
    verify the Helm installation''s release by leveraging the `--verify` subcommand
    of GPG. This should be run against the `helm*.asc` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在已经导入了数字签名的公钥，您可以通过利用GPG的“--verify”子命令来验证Helm安装的发布。这应该针对`helm*.asc`文件运行：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This command will attempt to decrypt the digital signature contained in the
    `.asc` file. If it is successful, it means that the Helm download (the file ending
    in `.tar.gz`) was signed by the person you expect (`Matthew Fisher` for this release)
    and the download was not modified or altered in any way. A successful output is
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将尝试解密`.asc`文件中包含的数字签名。如果成功，这意味着Helm下载（以`.tar.gz`结尾的文件）是由您期望的人（本次发布的`Matthew
    Fisher`）签名的，并且下载没有被修改或以任何方式更改。成功的输出如下：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Upon further inspection of this output, you may notice the `WARNING` message
    indicating that the key was not certified, which may lead you to question the
    validity of whether this was actually successful. The verification was successful,
    but you have not instructed gpg that the maintainer's public key is certified
    to belong to the person they say it belongs to.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步检查此输出时，您可能会注意到“警告”消息，指示该密钥未经认证，这可能会让您对此是否真正成功产生疑问。验证是成功的，但您尚未指示gpg维护者的公钥已获得认证，属于他们声称的人。
- en: 'You can perform this certification by following these steps:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤执行此认证：
- en: 'Check that the last 64 bits (8 characters) of the primary key fingerprint displayed
    at the end of the output match the 64-bit fingerprint displayed in the Helm releases
    page. As you will recall from *Figure 9.2*, the fingerprint was displayed, as
    shown:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查输出末尾显示的主密钥指纹的最后64位（8个字符），与Helm发布页面显示的64位指纹匹配。正如您从*图9.2*中记得的那样，指纹是这样显示的：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As you can see from the preceding code, the last 64 bits of the **primary key
    fingerprint** is displayed on the Helm releases page, so we know that this public
    key does belong to who we expect it to. As a result, we can safely certify the
    maintainer''s public key. This can be done by signing the public key using your
    own `gpg` keypair. Perform this step by using the following command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，Helm发布页面显示了**主密钥指纹**的最后64位，因此我们知道这个公钥确实属于我们期望的人。因此，我们可以安全地认证维护者的公钥。可以通过使用自己的`gpg`密钥对对公钥进行签名来完成此步骤。使用以下命令执行此步骤：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `Really sign?` prompt, enter `y`.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“真的要签名吗？”提示中，输入“y”。
- en: 'Now that you have signed the maintainer''s public key, the key is now certified.
    The verification can now be run without displaying a `WARNING` message in the
    output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经签署了维护者的公钥，该密钥现在已经获得认证。现在可以在不显示“警告”消息的情况下运行验证：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Digital signatures also play a role in verifying the provenance and integrity
    of Helm charts. We will continue this discussion in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名还在验证Helm图表的来源和完整性中发挥作用。我们将在下一节中继续讨论这个问题。
- en: Signing and verifying Helm charts
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署和验证Helm图表
- en: Similar to how the Helm maintainers sign releases, you can sign your own Helm
    charts so that users can verify that the chart they install actually came from
    you and contains the expected contents. To sign a chart, you must first have a
    `gpg` keypair present on your local workstation.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于Helm维护者如何签署发布版，您可以签署自己的Helm图表，以便用户可以验证他们安装的图表实际上来自您，并包含了预期的内容。要签署一个图表，您必须首先在本地工作站上拥有一个`gpg`密钥对。
- en: Next, you can leverage certain flags from the `helm package` command to sign
    your chart with a specified key.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您可以利用`helm package`命令的某些标志来使用指定的密钥对图表进行签名。
- en: Let's demonstrate how this can be accomplished by leveraging the `guestbook`
    chart from the Packt repository. This chart is located in the `Learn-Helm/helm-charts/charts/guestbook`
    folder. We will assume that you already have a gpg keypair on your local workstation,
    but if you do not, you can follow the instructions from the *Setup* section of
    the *Data provenance and integrity* section of this chapter to configure your
    keypair.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们演示如何通过利用Packt存储库中的“留言簿”图表来实现这一点。该图表位于`Learn-Helm/helm-charts/charts/guestbook`文件夹中。我们假设您已经在本地工作站上拥有gpg密钥对，但如果没有，您可以按照本章的*设置*部分中*数据来源和完整性*部分的说明来配置您的密钥对。
- en: One important point to note before signing the `guestbook` chart is that you
    must export your public and secret keyrings to a legacy format if you are using
    GPG version `2` or greater. Previous versions of GPG stored keyrings in a `.gpg`
    file format, which is the format that Helm expects your keyring to be in (at the
    time of writing). Newer versions of GPG store keyrings in the `.kbx` file format,
    which is not currently supported.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在签署“留言簿”图表之前需要注意的一点是，如果您使用GPG版本`2`或更高版本，则必须将您的公钥和秘钥导出为传统格式。之前的GPG版本将密钥环存储在`.gpg`文件格式中，这是Helm期望您的密钥环所在的格式（在撰写本文时）。较新版本的GPG将密钥环存储在`.kbx`文件格式中，目前不受支持。
- en: 'Begin the signing process by converting your GPG public and secret keyrings
    into the `.gpg` file format:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将您的GPG公钥和秘钥环转换为`.gpg`文件格式来开始签名过程：
- en: 'Find your `gpg` version by running the following command:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令来查找您的`gpg`版本：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If your `gpg` version is `2` or greater, export your public and secret keyring
    using the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您的`gpg`版本是`2`或更高版本，请使用以下命令导出您的公钥和秘钥环：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once your keyrings have been exported, you will be able to sign and package
    your Helm charts. The `helm package` command provides three key (pun intended)
    flags that allow you to sign and package a chart:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的密钥环被导出，您就可以对Helm图表进行签名和打包。`helm package`命令提供了三个关键（双关语）标志，允许您对图表进行签名和打包：
- en: '`--sign`: Allows you to sign a chart using a PGP private key'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`--sign`：允许您使用PGP私钥对图表进行签名'
- en: '`--key`: The name of the key to use when signing'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`--key`：签名时要使用的密钥的名称'
- en: '`--keyring`: The location of the keyring containing the PGP private key'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`--keyring`：包含PGP私钥的密钥环的位置'
- en: In the next step, these flags will be used with the `helm package` command to
    sign and package the guestbook Helm chart.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，这些标志将与`helm package`命令一起使用，以签署和打包“留言簿”Helm图表。
- en: 'Run the following `helm package` command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下`helm package`命令：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `$KEY_NAME` variable can refer to either the email, name, or fingerprint
    associated with the desired key. These details can be discovered by leveraging
    the `gpg --list-keys` command.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`$KEY_NAME`变量可以指代与所需密钥相关的电子邮件、姓名或指纹。这些细节可以通过利用`gpg --list-keys`命令来发现。'
- en: 'When using the `helm package` command without signing, you would expect to
    see one file produced as output—the `tgz` archive containing the Helm chart. In
    this case, when signing and packaging the `guestbook` Helm chart, you will see
    that the following two files are created:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在不签名的情况下使用`helm package`命令，您预计会看到一个文件作为输出——包含Helm图表的`tgz`存档。在这种情况下，当签名和打包`guestbook`Helm图表时，您将看到以下两个文件被创建：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `guestbook-1.0.0.tgz.prov` file is called a **provenance** file. The provenance
    file contains a provenance record, which displays the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`guestbook-1.0.0.tgz.prov`文件称为**来源**文件。来源文件包含一个来源记录，显示以下内容：'
- en: The chart metadata from the `Chart.yaml` file
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自`Chart.yaml`文件的图表元数据
- en: The sha256 hash of the Helm `guestbook-1.0.0.tgz` file
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm `guestbook-1.0.0.tgz`文件的sha256哈希值
- en: The PGP digital signature of the `guestbook-1.0.0.tgz` file
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`guestbook-1.0.0.tgz`文件的PGP数字签名'
- en: Users of a Helm chart will leverage the provenance file to verify the data provenance
    and integrity of the chart. When pushing a chart to a chart repository, developers
    should be sure to upload both the `.tgz` archive of the Helm chart and the `.tgz.prov`
    provenance file.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表的用户将利用来源文件来验证图表的数据来源和完整性。将图表推送到图表存储库时，开发人员应确保上传Helm图表的`.tgz`存档和`.tgz.prov`来源文件。
- en: Once you have packaged and signed your Helm chart, you will need to export the
    public key that corresponds to the private key used to encrypt your digital signature.
    This will allow users to download your public key and use it during the verification
    process.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您打包并签署了Helm图表，您将需要导出与用于加密数字签名的私钥对应的公钥。这将允许用户下载您的公钥并在验证过程中使用。
- en: 'Export your public key to the `ascii-armor` format by using the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将您的公钥导出为`ascii-armor`格式，使用以下命令：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you are releasing the `guestbook` chart publicly, this key can then be saved
    to a downloadable location by your chart users, such as Keybase. Users could then
    import this public key by leveraging the `gpg --import` command described in the
    *Verifying Helm releases* section of this chapter.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您公开发布`guestbook`图表，那么该密钥可以被您的图表用户保存到可下载的位置，例如Keybase。然后用户可以利用本章节*验证Helm发布*部分描述的`gpg
    --import`命令导入此公钥。
- en: Chart users can leverage the `helm verify` command to verify a chart's data
    provenance and integrity before installation. This command is designed to be run
    against a locally downloaded `.tgz` chart archive and `.tgz.prov` provenance file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图表用户可以利用`helm verify`命令在安装之前验证图表的数据来源和完整性。该命令旨在针对本地下载的`.tgz`图表存档和`.tgz.prov`来源文件运行。
- en: 'The following command provides an example of running this process against the
    `guestbook` Helm chart and assumes that your public key has been imported to a
    keyring called `~/.gnupg/pubring.gpg`:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令提供了针对`guestbook`Helm图表运行此过程的示例，并假定您的公钥已导入到名为`~/.gnupg/pubring.gpg`的密钥环中：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If the verification is successful, no output will be displayed. Otherwise,
    an error message will be returned. The verification could fail for a variety of
    reasons, including the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果验证成功，将不会显示任何输出。否则，将返回错误消息。验证可能因多种原因失败，包括以下情况：
- en: The .tgz and .tgz.prov files are not in the same directory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: .tgz和.tgz.prov文件不在同一个目录中。
- en: The .tgz.prov file is corrupt.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: .tgz.prov文件损坏。
- en: The file hashes do not match, indicating a loss of integrity.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 文件哈希值不匹配，表明完整性丢失。
- en: The public key used to decrypt the signature does not match the private key
    used to originally encrypt it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解密签名的公钥与最初用于加密的私钥不匹配。
- en: The `helm verify` command is designed to be run on locally downloaded charts,
    so users may find it better to instead leverage the `helm install --verify` command,
    which performs verification and installation in a single command, assuming that
    the `.tgz` and `.tgz.prov` files are both downloadable from a chart repository.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`helm verify`命令旨在在本地下载的图表上运行，因此用户可能会发现最好是利用`helm install --verify`命令，该命令执行验证和安装的单个命令，假设`.tgz`和`.tgz.prov`文件都可以从图表存储库下载。'
- en: 'The following command describes how the `helm install --verify` command can
    be used:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令描述了如何使用`helm install --verify`命令：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By using the methodologies described in this section for signing and verifying
    Helm charts, both you and your users can ensure that you are installing charts
    that both belong to you and have been unaltered.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用本节描述的签名和验证Helm图表的方法，您和您的用户都可以确保您安装的图表既属于您自己，又未经修改。
- en: With an understanding of how data provenance and integrity play a role in Helm,
    let's continue discussing the Helm security considerations by moving on to our
    next topic—security in relation to Helm charts and Helm chart development.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 了解数据可靠性和完整性在Helm中起到的作用后，让我们继续讨论Helm安全性考虑，转而讨论我们下一个主题——与Helm图表和Helm图表开发相关的安全性。
- en: Developing secure Helm charts
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发安全的Helm图表
- en: While provenance and integrity play a major role in the security of Helm, they
    are not the only concerns you need to consider. Chart developers should ensure
    that, during the development process, they are adhering to best practices regarding
    security to prevent vulnerabilities from being introduced when a user installs
    the chart in a Kubernetes cluster. In this section, we will discuss many of the
    primary concerns around security as it relates to Helm chart development and what
    you, as a developer, can do to write Helm charts with security as a priority.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可靠性和完整性在Helm的安全性中起着重要作用，但它们并不是您需要考虑的唯一问题。图表开发人员应确保在开发过程中，他们遵守有关安全性的最佳实践，以防止用户在Kubernetes集群中安装图表时引入漏洞。在本节中，我们将讨论与Helm图表开发相关的安全性的许多主要问题，以及作为开发人员，您可以做些什么来编写以安全性为优先考虑的Helm图表。
- en: We will begin by first discussing the security around any container images that
    your Helm chart may use.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先讨论您的Helm图表可能使用的任何容器镜像的安全性。
- en: Using secure images
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用安全镜像
- en: Since the goal of Helm (and Kubernetes) is to deploy container images, the image
    itself is a major security concern. To start, chart developers should be aware
    of the differences between image tags and image digests.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Helm（和Kubernetes）的目标是部署容器镜像，因此镜像本身是一个主要的安全问题。首先，图表开发人员应该意识到镜像标签和镜像摘要之间的区别。
- en: A tag is a human-readable reference to a given image and provides both developers
    and consumers with an easy method for determining the contents of an image. However,
    tags can present a security concern as there are no guarantees that the contents
    of a given tag will always remain the same. The image owner may choose to provide
    an updated image using the same tag, for example, to address security vulnerabilities,
    which would result in a different underlying image being executed at runtime,
    even though the tag is the same. Performing these modifications against the same
    tag introduces the possibility of regressions, which can cause unexpected adverse
    effects to users. Instead of referencing an image by tag, images can also be referenced
    by digest. An image digest is a computed SHA-256 value of an image that not only
    provides an immutable identifier to an exact image, but also allows for the container
    runtime to verify that the image retrieved from the remote image registry contains
    the expected contents. This removes the risk of deploying an image that contains
    an accidental regression against a given tag, and can also remove the risks of
    a man-in-the-middle attack, where the tag's contents are modified with malicious
    intent.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是对给定图像的可读引用，并为开发人员和消费者提供了一种确定图像内容的简单方法。然而，标签可能会带来安全问题，因为无法保证给定标签的内容始终保持不变。图像所有者可能会选择使用相同的标签提供更新的图像，例如，以解决安全漏洞，这将导致在运行时执行不同的基础图像，即使标签相同。对相同标签进行这些修改引入了回归的可能性，这可能会对用户造成意外的不利影响。除了使用标签引用图像外，图像也可以通过摘要引用。图像摘要是图像的计算SHA-256值，不仅为确切图像提供了不可变标识符，还允许容器运行时验证从远程图像注册表检索到的图像包含了预期的内容。这消除了部署包含对给定标签的意外回归的图像的风险，并且还可以消除中间人攻击的风险，其中标签的内容被恶意修改。
- en: As an example, instead of referencing an image as `quay.io/bitnami/redis:5.0.9`
    in a chart template, it can instead be referenced by digest as `quay.io/bitnami/redissha256:70b816f2127afb5d4af7ec9d6e8636b2f0f
    973a3cd8dda7032f9dcffa38ba11f`. Notice that instead of there being a tag after
    the name of the image, the SHA-256 digest is explicitly specified. This assures
    you that the image content will not change over time, even if the tag changes,
    thus strengthening your security posture.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，可以在图表模板中将图像的引用从`quay.io/bitnami/redis:5.0.9`改为使用摘要引用，如`quay.io/bitnami/redissha256:70b816f2127afb5d4af7ec9d6e8636b2f0f
    973a3cd8dda7032f9dcffa38ba11f`。请注意，图像名称后面没有标签，而是明确指定了SHA-256摘要。这可以确保图像内容随时间不会改变，即使标签发生变化，从而加强了您的安全性。
- en: Over time, you can expect a tag or a digest associated with an image to become
    unsafe to deploy as vulnerabilities are eventually likely to be published against
    packages or OS versions that this image may contain. There are many different
    ways to determine the vulnerabilities associated with a given image. One way is
    to leverage the native capabilities of the registry that the image belongs to.
    Many different image registries contain capabilities around image vulnerability
    scanning that can help provide insight as to when an image is vulnerable.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，可以预期与图像相关联的标签或摘要将变得不安全，因为最终可能会针对该图像可能包含的软件包或操作系统版本发布漏洞。有许多不同的方法可以确定与给定图像相关联的漏洞。一种方法是利用图像所属的注册表的本机功能。许多不同的图像注册表包含围绕图像漏洞扫描的功能，可以帮助了解图像何时存在漏洞。
- en: The Quay container registry, for example, can automatically scan images at specified
    intervals to determine the number of vulnerabilities an image contains. The Nexus
    and Artifactory container registries are also examples of container registries
    that have this capability. Outside of native scanning capabilities provided by
    container registries, other tools can be leveraged, such as Clair (which is also
    the backing scanning technology of **Quay**), Anchore, Vuls, and OpenSCAP. When
    your image registry or standalone scanning tool reports that an image is vulnerable,
    you should immediately update your chart's image to a newer version if available
    to prevent vulnerabilities from being introduced to your users' Kubernetes clusters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Quay容器注册表可以自动扫描镜像，以确定镜像包含的漏洞数量。Nexus和Artifactory容器注册表也是具有此功能的容器注册表的例子。除了容器注册表提供的原生扫描功能外，还可以利用其他工具，如Clair（也是**Quay**的后备扫描技术）、Anchore、Vuls和OpenSCAP。当您的镜像注册表或独立扫描工具报告镜像存在漏洞时，如果有新版本可用，您应立即更新图表的镜像，以防止漏洞被引入到用户的Kubernetes集群中。
- en: To help simplify the process around updating the container image, you can develop
    a regular cadence where image updates are checked. This helps to prevent you from
    getting to a point where your target image contains vulnerabilities that make
    it unfit for deployment. Many teams and organizations also specify that images
    can only be sourced from trusted registries to reduce the potential of running
    images that do contain vulnerabilities. This setting is configured at the container
    runtime level and the location and specific configurations vary based on each
    runtime.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化更新容器镜像的流程，您可以制定一个定期的节奏来检查镜像更新。这有助于防止您的目标镜像包含漏洞，使其不适合部署。许多团队和组织还规定镜像只能来自受信任的注册表，以减少运行包含漏洞的镜像的可能性。此设置在容器运行时级别进行配置，具体位置和配置因运行时而异。
- en: Apart from image vulnerability scanning and content sourcing, you should also
    avoid deploying images that require elevated permissions or capabilities. Capabilities
    are used to give a process a subset of root permissions. Some examples of capabilities
    are `NET_ADMIN`, which allows a process to perform network-related operations,
    and `SYS_TIME`, which allows a process to modify a system's clock. Running a container
    as root gives the container access to all the capabilities, which should be limited
    whenever possible. A list of capabilities can be found in the *CAPABILITIES(7)*
    pa[ge of the Linux manual pages (http://man7.org/linux/man-](http://man7.org/linux/man-pages/man7/capabilities.7.html)pages/man7/capabilities.7.html).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 除了镜像漏洞扫描和内容获取之外，您还应避免部署需要提升权限或功能的镜像。功能用于给进程提供一组根权限的子集。一些功能的例子是`NET_ADMIN`，允许进程执行与网络相关的操作，以及`SYS_TIME`，允许进程修改系统的时钟。以root身份运行容器会赋予容器所有功能，应尽可能限制。功能列表可以在Linux手册页的*CAPABILITIES(7)*页面中找到（http://man7.org/linux/man-pages/man7/capabilities.7.html）。
- en: Granting a container capability or allowing it to run as root gives malicious
    processes more leverage to damage the underlying host. Not only does this impact
    the container that introduced the vulnerability, but also any other container
    running on that host and, potentially, the entire Kubernetes cluster. If a container
    does have vulnerabilities but does not have any capabilities granted to it, the
    attack vector is much smaller and could possibly be prevented altogether. When
    developing a Helm chart, both an image's vulnerabilities and permission requirements
    must be taken into account to keep your users, as well as other tenants of the
    Kubernetes cluster, safe.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 授予容器功能或允许其以root身份运行会使恶意进程更有可能损害底层主机。这不仅影响引入漏洞的容器，还影响在该主机上运行的任何其他容器，可能还影响整个Kubernetes集群。如果容器存在漏洞但没有被授予任何功能，攻击向量将小得多，甚至可能完全被阻止。在开发Helm图表时，必须考虑图像的漏洞和权限要求，以确保用户和Kubernetes集群的其他租户的安全。
- en: In addition to the container image that is deployed, chart developers should
    also focus on the resources granted to an application. We will dive into this
    topic in the next section.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 除了部署的容器镜像外，图表开发人员还应关注授予应用程序的资源。我们将在下一节中深入探讨这个话题。
- en: Setting resource limits
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 设置资源限制
- en: A pod uses the resources that belong to its underlying node. Without the proper
    defaults in place, it is possible for a pod to exhaust the `node of resources`,
    causing issues such as CPU throttling and pod eviction. Exhausting the underlying
    node will also prevent other workloads from being scheduled there. Because of
    the issues that can occur when resource limits are not in check, chart developers
    should be concerned about setting reasonable defaults either in their Helm chart
    or in the Kubernetes cluster.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一个pod使用属于其底层节点的资源。如果没有适当的默认设置，pod可能会耗尽`节点资源`，导致诸如CPU限制和pod驱逐等问题。耗尽底层节点还将阻止其他工作负载在那里被调度。由于资源限制不受控制时可能出现的问题，图表开发人员应该关注在其Helm图表或Kubernetes集群中设置合理默认值。
- en: 'Many charts allow the deployment `resources` field to be declared as a Helm
    value. A chart developer can default the `resources` field in the `values.yaml`
    file, setting what is believed by the developer to be the amount of resources
    that the application should need. The following code shows an example of this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 许多图表允许将部署的`resources`字段声明为Helm值。图表开发人员可以在`values.yaml`文件中默认设置`resources`字段，设置开发人员认为应用程序应该需要的资源量。以下代码显示了一个示例：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If left at the default, this example value would be used to set the pod's CPU
    limit to `500m` and the memory limit to `2Gi`. Setting this default value in the
    `values.yaml` file prevents the pod from exhausting the node resources, while
    also providing a suggested value for the amount of application resources required.
    Users can then choose to override the resource limits if necessary. Note that
    the chart developers can also set a default for the resource requests, but this
    will not prevent the pod from exhausting the node resources.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保持默认设置，此示例值将用于将pod的CPU限制设置为`500m`，内存限制设置为`2Gi`。在`values.yaml`文件中设置此默认值可以防止pod耗尽节点资源，同时为所需的应用程序资源量提供建议值。用户可以选择在必要时覆盖资源限制。请注意，图表开发人员还可以为资源请求设置默认值，但这不会阻止pod耗尽节点资源。
- en: 'While you should consider setting default resource limits in the `values.yaml`
    file, you can also set limit ranges and resource quotas in the Kubernetes namespace
    that the chart will be installed on. These are resources that are typically not
    included in a Helm chart but are instead created by a cluster administrator before
    application deployment. Limit ranges are used to determine the number of resources
    a container is allowed to use within a namespace. Limit ranges are also used to
    set the default resource limits for each container deployed to the namespace that
    does not already have resource limits defined. The following is an example limit
    range defined by a `LimitRange` object:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您应该考虑在`values.yaml`文件中设置默认资源限制，但您也可以在将要安装图表的Kubernetes命名空间中设置限制范围和资源配额。这些资源通常不包括在Helm图表中，而是在应用部署之前由集群管理员创建。限制范围用于确定容器在命名空间内允许使用的资源数量。限制范围还用于为每个部署到尚未定义资源限制的命名空间的容器设置默认资源限制。以下是由`LimitRange`对象定义的示例限制范围：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`LimitRange` enforces the specified restrictions in the namespace where the
    `LimitRange` object was created. It sets the maximum amount of allowed container
    resources to `1` core of `cpu` and `4Gi` of `memory`. If a resource limit is not
    defined, it automatically sets the resource limit to `500m` of `cpu` and `2Gi`
    of `memory`. Limit ranges can also be applied at the pod level by setting the
    `type` field to `Pod`. This would ensure that the sum of resource utilization
    of all containers in the pod are under the specified limits. In addition to setting
    limits against CPU and memory utilization, you can also set a `LimitRange` object
    to default the storage claimed by a `PersistentVolumeClaim` object by setting
    the `type` field to `PersistentVolumeClaim`.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`LimitRange`在创建`LimitRange`对象的命名空间中强制执行指定的限制。它将允许容器资源的最大数量设置为`1`个`cpu`核心和`4Gi`的`内存`。如果未定义资源限制，它会自动将资源限制设置为`500m`的`cpu`和`2Gi`的`内存`。通过将`type`字段设置为`Pod`，还可以在Pod级别应用限制范围。这将确保Pod中所有容器的资源利用总和在指定限制之下。除了设置对CPU和内存利用的限制，您还可以通过将`type`字段设置为`PersistentVolumeClaim`来设置`LimitRange`对象以默认声明`PersistentVolumeClaim`对象的存储。'
- en: 'This would allow you to create the following resource to set a storage limit
    for a single PVC:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许您创建以下资源，以设置单个PVC的存储限制：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, you could also set a default storage amount in your Helm chart's
    `values.yaml` file. The default set in the `values.yaml` file reflects the amount
    of storage you think is required for a default installation, with the `LimitRange`
    object enforcing an absolute maximum that the user can override to.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以在Helm图表的`values.yaml`文件中设置默认存储量。在`values.yaml`文件中设置的默认值反映了您认为默认安装所需的存储量，`LimitRange`对象强制执行用户可以覆盖的绝对最大值。
- en: 'In addition to limit ranges, you can also set resource quotas to add additional
    restrictions against a namespace''s resource usage. While limit ranges enforce
    resources at a per-container, -pod, or -PVC level, resource quotas enforce resource
    usage at a per-namespace level. They are used to define the maximum number of
    resources a namespace can utilize. The following is an example resource quota:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 除了限制范围，您还可以设置资源配额以对命名空间的资源使用添加额外限制。虽然限制范围强制执行每个容器、Pod或PVC级别的资源，资源配额则强制执行每个命名空间级别的资源使用。它们用于定义命名空间可以利用的资源的最大数量。以下是一个资源配额的示例：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding `ResourceQuota` object, when applied to a Kubernetes namespace,
    sets the maximum CPU utilization to `4` cores, the maximum memory utilization
    to `8Gi`, and the maximum storage request to `20Gi` for the sum of all workloads
    in the namespace. Resource quotas can also be used to set a maximum amount of
    `secrets`, `ConfigMaps`, and other Kubernetes resources per namespace. By using
    `resource quotas`, you can prevent a single namespace from over-utilizing cluster
    resources.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`ResourceQuota`对象在应用于Kubernetes命名空间时，将最大CPU利用率设置为`4`核，最大内存利用率设置为`8Gi`，并将命名空间中所有工作负载的最大存储请求设置为`20Gi`。资源配额还可以用于设置每个命名空间中`secrets`、`ConfigMaps`和其他Kubernetes资源的最大数量。通过使用`资源配额`，您可以防止单个命名空间过度利用集群资源。
- en: By setting reasonable default resource limits in your Helm chart, along with
    the existence of `LimitRange` and `ResourceQuota`, you can ensure that users of
    your Helm chart do not exhaust cluster resources and cause disruptions or outages.
    With an understanding of how you can enforce resource limits, let's move on to
    the next topic around Helm chart security—handling secrets in Helm charts.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Helm图表中设置合理的默认资源限制，以及存在`LimitRange`和`ResourceQuota`，您可以确保Helm图表的用户不会耗尽集群资源并导致中断或停机。了解如何强制执行资源限制后，让我们继续讨论Helm图表安全性周围的下一个主题——处理Helm图表中的机密信息。
- en: Handling secrets in Helm charts
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Helm图表中处理机密信息
- en: Handling secrets is a common concern when working with Helm charts. Consider
    the WordPress application from [*Chapter 3*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147),
    *Installing Your First Helm Chart*, where you were required to provide a password
    to configure an admin user. This password was not provided by default in the `values.yaml`
    file because this would have left the application vulnerable if you forgot to
    override the `password` value. Chart developers should be in the habit of not
    providing defaults for secret values such as passwords and should instead require
    users to provide an explicit value. This can easily be done by leveraging the
    `required` function. Helm also has the ability to generate random strings using
    the `randAlphaNum` function.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 处理机密信息是在使用Helm图表时的常见问题。考虑一下来自[*第3章*](B15458_03_Final_JM_ePub.xhtml#_idTextAnchor147)的WordPress应用程序，*安装您的第一个Helm图表*，在那里您需要提供一个密码来配置管理员用户。这个密码在`values.yaml`文件中默认没有提供，因为如果您忘记覆盖`password`值，这将使应用程序容易受到攻击。图表开发人员应该养成不为诸如密码之类的机密值提供默认值的习惯，而应该要求用户提供明确的值。这可以通过利用`required`函数轻松实现。Helm还具有使用`randAlphaNum`函数生成随机字符串的能力。
- en: Note, however, that this function generates a new random string each time the
    chart is upgraded. For that reason, developers should design charts with the expectation
    that users will provide their own password or other secret key, with the `required`
    function serving as a gate to ensure that a value is provided.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此函数每次升级图表时都会生成一个新的随机字符串。因此，开发人员应设计图表，期望用户提供自己的密码或其他机密密钥，并且`required`函数作为确保提供值的门槛。
- en: When a user provides a secret during chart installation, that value should be
    saved in `secret`, not `ConfigMap`. ConfigMaps display values in plain text and
    are not designed to contain credentials or other secret values. Secrets, on the
    other hand, provide obfuscation by Base64-encoding its contents. Secrets also
    allow you to mount its contents to a pod as a `tmpfs` mount, meaning the contents
    are mounted to the pod in volatile memory instead of on a disk. As a chart developer,
    you should ensure that all credentials and secret configuration managed by your
    Helm charts are created using Kubernetes Secrets.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在图表安装期间提供秘密时，该值应保存在`secret`中，而不是`ConfigMap`中。ConfigMaps以明文显示值，并且不设计包含凭据或其他秘密值。另一方面，Secrets通过Base64编码其内容提供了混淆。Secrets还允许您将其内容挂载到pod作为`tmpfs`挂载，这意味着内容被挂载到pod的易失性内存中，而不是在磁盘上。作为图表开发人员，您应确保由您的Helm图表管理的所有凭据和秘密配置都是使用Kubernetes
    Secrets创建的。
- en: While chart developers should ensure that secrets are handled appropriately
    using Kubernetes Secrets and the `required` function, chart users should ensure
    that secrets such as credentials are provided to a Helm chart securely. Values
    are most commonly provided to a Helm chart with the `--values` flag, where additional
    or overridden values are declared in a separate `values` file and are passed to
    the Helm CLI during installation. This is an appropriate method when working with
    regular values, but caution should be taken when using this approach with secret
    values. Users should be sure that the `values` files that contain secrets are
    not checked into a `git` repository or an otherwise public location where those
    secrets could be exposed. One way that users can avoid exposing secrets is by
    leveraging the `--set` flag to pass secrets inline from their local command line.
    This reduces the risk of credentials being exposed, but users should be aware
    that this would reveal the credentials in the bash history.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图表开发人员应确保使用Kubernetes Secrets和`required`函数适当处理密钥，而图表用户应确保诸如凭据之类的密钥安全地提供给Helm图表。通常，值是通过`--values`标志提供给Helm图表的，额外或覆盖的值在单独的`values`文件中声明，并在安装期间传递给Helm
    CLI。这是在处理常规值时的适当方法，但在处理秘密值时应谨慎。用户应确保包含秘密的`values`文件未被检入`git`存储库或其他公共位置，以免泄露这些秘密。用户可以通过利用`--set`标志从本地命令行内联传递秘密来避免泄露秘密。这降低了凭据泄露的风险，但用户应意识到这将在bash历史记录中显示凭据。
- en: 'Another way that users can avoid exposing secrets is by leveraging an encryption
    tool to encrypt `values` files that contain secrets. This would continue to allow
    users to apply the `--values` flag and push the `values` file to a remote location,
    such as a git repository. The `values` file could then only be decrypted by users
    who have the appropriate key and would remain encrypted for all other users, only
    allowing trusted members access to the data. Users can simply leverage GPG to
    encrypt the `values` files, or they can levera[ge a special tool such as **Sops**.](https://github.com/mozilla/sops)
    **Sops** (https://github.com/mozilla/sops) is a tool designed to encrypt the values
    of YAML or JSON files but leave the keys unencrypted. The following code shows
    a secret key/value pair from a Sops-encrypted file:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过利用加密工具加密包含秘密的`values`文件来避免泄露秘密。这将继续允许用户应用`--values`标志并将`values`文件推送到远程位置，例如git存储库。然后，只有具有适当密钥的用户才能解密`values`文件，并且对于所有其他用户，它将保持加密状态，只允许受信任的成员访问数据。用户可以简单地利用GPG加密`values`文件，或者他们可以利用特殊工具如**Sops**。**Sops**
    (https://github.com/mozilla/sops) 是一个设计用于加密YAML或JSON文件的值但保留密钥未加密的工具。以下代码显示了来自Sops加密文件的秘密键/值对：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice how the `password` key is unencrypted but the value is encrypted. This
    allows you to easily see what kind of values are contained in the file without
    exposing their secrets.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`password`键是未加密的，但值是加密的。这样可以让您轻松地查看文件中包含的值的类型，而不会暴露它们的机密信息。
- en: There are other tools capable of encrypting the `values` files that contain
    se[crets. Some examples include `git-`](https://github.com/AGWA/git-crypt)`crypt`
    ([https://github.com/AGWA/git-crypt](https://github.com/AGWA/git-crypt)) and `blackbox`
    ([https://github.com/StackExchange/blackbox](https://github.com/StackExchange/blackbox)).
    Additionally, tools such as HashiCorp's `Vault` or CyberArk Conjur can be used
    to encrypt secrets in the form of key/value stores. Secrets can then be retrieved
    by authenticating with a secret management system and then by utilizing them within
    Helm by passing them with `--set`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他工具可以加密包含机密的`values`文件。一些例子包括`git-`（https://github.com/AGWA/git-crypt）`crypt`（https://github.com/AGWA/git-crypt）和`blackbox`（https://github.com/StackExchange/blackbox）。此外，诸如HashiCorp的`Vault`或CyberArk
    Conjur之类的工具可以用于以键/值存储的形式加密机密。然后，可以通过使用秘密管理系统进行身份验证，然后通过使用`--set`将它们传递给Helm来检索机密。
- en: With an understanding of how security plays a role in Helm chart development,
    let's now discuss how **Role-Based Access Control** (**RBAC**) can be applied
    in Kubernetes to provide greater security to your users.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 了解安全如何在Helm图表开发中发挥作用后，现在让我们讨论如何在Kubernetes中应用**基于角色的访问控制**（**RBAC**）以为用户提供更大的安全性。
- en: Configuring RBAC rules
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置RBAC规则
- en: 'The ability of an authenticated user in Kubernetes to perform actions is governed
    through a set of RBAC policies. As introduced in *Chapter 2*, *Preparing a Kubernetes
    and Helm Environment*, policies, known as roles, can be associated with users
    or service accounts, and Kubernetes contains several default roles that can be
    associated. RBAC has been enabled by default in Kubernetes since version `1.6`.
    When thinking about Kubernetes RBAC in the context of Helm usage, you need to
    consider two factors:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，经过身份验证的用户执行操作的能力是通过一组RBAC策略来管理的。正如*第2章*中介绍的*准备Kubernetes和Helm环境*，策略，也就是角色，可以与用户或服务账户关联，Kubernetes包含几个可以关联的默认角色。自Kubernetes版本`1.6`以来，RBAC已默认启用。在考虑Helm使用中的Kubernetes
    RBAC时，您需要考虑两个因素：
- en: The user installing a Helm chart
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Helm图表的用户
- en: The service account associated with the pod running the workload
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与运行工作负载的pod关联的服务账户
- en: In most cases, the individual responsible for installing a Helm chart is associated
    with a Kubernetes user. However, Helm charts can be installed through other means,
    such as by a Kubernetes operator with an associated service account.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，安装Helm图表的个人与Kubernetes用户关联。但是，Helm图表也可以通过其他方式安装，例如由与服务账户关联的Kubernetes操作员。
- en: By default, users and service accounts have minimal permissions in a Kubernetes
    cluster. Additional permissions are granted through the use of roles that are
    scoped to an individual namespace, or cluster roles that grant access at a cluster
    level. These are then associated with a user or service account using either a
    role binding or a cluster role binding, depending on the type of policy being
    targeted. While Kubernetes has a number of included roles that can be applied,
    the concept of **least-privileged access** should be used wherever possible. Least-privileged
    access refers to a user or application that is granted only the minimum set of
    permissions that is needed to properly function. For example, take the `guestbook`
    chart that we developed earlier. Imagine we wanted to add new functionality that
    can query the metadata of pods in the `guestbook` application's namespace.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中，默认情况下，用户和服务账户具有最低权限。通过将权限授予个别命名空间的角色或授予集群级别访问权限的集群角色来获得额外的权限。然后，根据所针对的策略类型，将其与用户或服务账户关联起来，使用角色绑定或集群角色绑定。虽然
    Kubernetes 包含了一些可以应用的角色，但应尽可能使用**最低权限访问**的概念。最低权限访问是指只授予用户或应用程序所需的最小权限集以正常运行。例如，我们之前开发的
    `guestbook` 图表。假设我们想要添加新功能，可以查询 `guestbook` 应用程序命名空间中的 pods 的元数据。
- en: While Kubernetes contains a built-in role called **view** that provides the
    necessary permissions to read pod manifests in a given namespace, it also gives
    access to other resources, such as ConfigMaps and deployments. To minimize the
    level of access that is granted to an application, a custom policy in the form
    of a role or cluster role can be created that provides only the necessary permissions
    that the application needs. Since most typical users of a Kubernetes cluster do
    not have access to create resources at a cluster level, let's create a role that
    is applied to the namespace that the Helm chart is deployed in.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 包含一个名为**view**的内置角色，提供了在给定命名空间中读取 pod 清单所需的权限，但它也可以访问其他资源，如 ConfigMaps
    和部署。为了最小化授予应用程序的访问级别，可以创建一个自定义策略，以角色或集群角色的形式，仅提供应用程序所需的必要权限。由于 Kubernetes 集群的大多数典型用户无权在集群级别创建资源，让我们创建一个应用于
    Helm 图表部署的命名空间的角色。
- en: 'To create a new role, the `kubectl create role` command can be used. A basic
    role contains two key elements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新角色，可以使用 `kubectl create role` 命令。一个基本的角色包含两个关键元素：
- en: The type of action (verb) made against the Kubernetes API
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对 Kubernetes API 进行的操作类型（动词）
- en: The list of Kubernetes resources to target
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要定位的 Kubernetes 资源列表
- en: As an example, to demonstrate how RBAC can be configured in Kubernetes, let's
    configure a set of RBAC rules to allow an authenticated user to view pods within
    a namespace.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了演示如何在 Kubernetes 中配置 RBAC，让我们配置一组 RBAC 规则，允许经过身份验证的用户在命名空间内查看 pods。
- en: Important note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: If you want to run through this example on your local workstation, make sure
    that Minikube is started first by running `minikube start`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地工作站上运行此示例，请确保首先运行 `minikube start` 来启动 Minikube。
- en: 'You can then create a new namespace called `chapter9` by running `kubectl create
    ns chapter9`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后可以通过运行 `kubectl create ns chapter9` 来创建一个名为 `chapter9` 的新命名空间：
- en: 'Use the `kubectl` CLI to create a new role called `guestbook-pod-viewer`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `kubectl` CLI 创建一个名为 `guestbook-pod-viewer` 的新角色：
- en: '[PRE27]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With this new role created, it needs to be associated with a user or service
    account. Since we want to associate it with an application running in Kubernetes,
    we will apply the role to a service account. When a pod is created, it makes use
    of a service account called `default`. When attempting to abide by the least-privileged
    access principle, it is recommended that a separate service account is used. This
    is to ensure that no other workloads are deployed in the same namespace as the
    `guestbook` application as it would also inherit the same permissions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新角色，它需要与用户或服务账户关联。由于我们想要将其与在Kubernetes中运行的应用程序关联起来，我们将把角色应用到一个服务账户上。当创建一个pod时，它会使用一个名为`default`的服务账户。在尝试遵守最小特权访问原则时，建议使用一个单独的服务账户。这是为了确保在与`guestbook`应用程序相同的命名空间中没有部署其他工作负载，因为它也会继承相同的权限。
- en: 'Create a new service account called `guestbook` by executing the following
    command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过执行以下命令创建一个名为`guestbook`的新服务账户：
- en: '[PRE28]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, create a role binding called `guestbook-pod-viewers` to associate `guestbook-pod-viewer`
    with `guestbook ServiceAccount`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为`guestbook-pod-viewers`的角色绑定，将`guestbook-pod-viewer`与`guestbook ServiceAccount`关联起来：
- en: '[PRE29]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Finally, to run the `guestbook` application itself using the newly created `guestbook`
    `ServiceAccount`, the name of the service account would need to be applied to
    the deployment.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要使用新创建的`guestbook` `ServiceAccount`来运行`guestbook`应用程序本身，需要将服务账户的名称应用到部署中。
- en: 'The following shows how the `serviceAccount` configuration appears in the deployment
    YAML:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 以下显示了在部署YAML中`serviceAccount`配置的外观：
- en: '[PRE30]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can easily install the `guestbook` application by using the chart you created
    in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265), *Building Your
    First Helm Chart*, or by using [the chart located in the Packt repository at https://github.com/PacktPublishing/-Learn](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)-Helm/tree/master/helm-charts/charts/guestbook.
    This chart exposes a set of values for configuring the deployment's service account.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用您在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中创建的图表，或者通过使用[位于Packt存储库中的图表](https://github.com/PacktPublishing/-Learn-Helm/tree/master/helm-charts/charts/guestbook)来轻松安装`guestbook`应用程序。该图表公开了一组用于配置部署服务账户的值。
- en: 'Install the `guestbook` Helm chart by running the following command:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过运行以下命令安装`guestbook` Helm图表：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that in *step 4*, the `serviceAccount.create` value is set to `false`.
    When you scaffolded your Helm chart in [*Chapter 5*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265),
    *Building Your first Helm Chart,* using the `helm create` command, the ability
    to create a service account upon chart installation was provided. Since you already
    created a service account using `kubectl` previously, this was not needed. However,
    the ability to create additional resources related to RBAC during chart installation
    does not need to end at creating service accounts. In fact, you could perform
    steps 1, 2, and 3 in a single chart installation if your Helm chart contained
    the YAML resources necessary to create roles and role bindings as well.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在*步骤4*中，`serviceAccount.create`的值设置为`false`。当您在[*第5章*](B15458_05_Final_JM_ePub.xhtml#_idTextAnchor265)中使用`helm
    create`命令创建Helm图表时，提供了在图表安装时创建服务账户的能力。由于您之前已经使用`kubectl`创建了一个服务账户，这是不需要的。然而，在图表安装期间创建与RBAC相关的其他资源的能力并不需要止步于创建服务账户。实际上，如果您的Helm图表包含创建角色和角色绑定所需的YAML资源，您可以在单个图表安装中执行步骤1、2和3。
- en: 'At this point, the `guestbook` application has the permissions necessary to
    list and get pods. To verify this assumption, `kubectl` has a command that queries
    whether a user or service account has the authority to perform an action. Execute
    the following command to verify that the `ServiceAccount` guestbook has access
    to query all the pods in the `guestbook` namespace:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，`guestbook`应用程序具有列出和获取pod所需的权限。为了验证这一假设，`kubectl`有一个命令可以查询用户或服务账户是否有权执行某个操作。执行以下命令来验证`ServiceAccount`
    guestbook是否有权限查询`guestbook`命名空间中的所有pod：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `--as` flag makes use of the user impersonation feature in Kubernetes to
    allow the debugging of authorization policies.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`--as`标志利用了Kubernetes中的用户模拟功能，允许调试授权策略。'
- en: 'The result of the command should print `yes` as output. To confirm that the
    service account cannot access a resource that it should not be able to, such as
    listing deployments, execute the following command:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该命令的结果应该打印`yes`作为输出。为了确认服务账户不能访问不应该能够访问的资源，比如列出部署，执行以下命令：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Feel free to delete your release with the `helm uninstall` command:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`helm uninstall`命令随意删除您的发布：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can also stop your Minikube instance, which is not needed for the remainder
    of this chapter:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以停止Minikube实例，这在本章的其余部分中是不需要的：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As you can see from the output of `no`, the expected policies are in place.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 从`no`的输出中可以看到，预期的策略已经就位。
- en: When used effectively, Kubernetes RBAC aids in providing Helm chart developers
    with the tools needed to enforce least-privilege access, protecting users and
    applications from potential errant or malicious actions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当有效使用时，Kubernetes RBAC有助于为Helm图表开发人员提供必要的工具，以强制执行最小特权访问，保护用户和应用程序免受潜在的错误或恶意行为的影响。
- en: Next, we will discuss how chart repositories can be secured and accessed in
    a way that enhances the overall security of Helm.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何保护和访问图表仓库，以增强Helm的整体安全性。
- en: Accessing secure chart repositories
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问安全的图表仓库
- en: 'Chart repositories provide the ability to discover Helm charts and install
    them on your Kubernetes cluster. Repositories were introduced in *"*[*Chapter
    1*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017)*: Understanding Kubernetes
    and Helm" on page 305*, *Understanding Kubernetes and Helm*, as an HTTP server
    that includes an `index.yaml` file containing metadata related to charts present
    in the repository. In previous chapters, we made use of charts that were sourced
    from various upstream repositories and also implemented our own repository using
    GitHub Pages. Each of these repositories is freely available for use for whoever
    may be interested. However, Helm does support incorporating additional security
    measures to protect the content stored within the repository, including the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '图表仓库提供了在Kubernetes集群上发现Helm图表并安装它们的能力。仓库在*"*[*第1章*](B15458_01_Final_JM_ePub.xhtml#_idTextAnchor017)*:
    Understanding Kubernetes and Helm" on page 305*，*Understanding Kubernetes and
    Helm*中被介绍为一个包含与仓库中图表相关的元数据的`index.yaml`文件的HTTP服务器。在之前的章节中，我们使用了来自各种上游仓库的图表，并且还使用GitHub
    Pages实现了我们自己的仓库。这些仓库都可以自由使用，供任何感兴趣的人使用。然而，Helm确实支持整合额外的安全措施来保护仓库中存储的内容，包括以下内容：'
- en: Authentication
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认证
- en: '**Secure Sockets Layer**/**Transport Layer Security** (**SSL**/**TLS**) encryption'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全套接字层**/**传输层安全**（**SSL**/**TLS**）加密'
- en: 'While the majority of public Helm repositories do not require any form of authentication,
    Helm does allow users to perform basic and certificate-based authentication against
    a secured chart repository. For basic authentication, a username and password
    can be provided when adding a repository using the `helm repo add` command through
    the use of the `--username` and `--password` flags. For example, if you want to
    access a repository that is protected using basic authentication, adding the repository
    would take the following form:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数公共Helm存储库不需要任何形式的身份验证，但Helm确实允许用户对受保护的图表存储库执行基本和基于证书的身份验证。对于基本身份验证，可以在使用`helm
    repo add`命令添加存储库时提供用户名和密码，通过使用`--username`和`--password`标志。例如，如果您想访问受基本身份验证保护的存储库，则添加存储库将采取以下形式：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Then, the repository can be interacted with without needing to repeatedly provide
    the credentials.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，存储库可以进行交互，而无需重复提供凭据。
- en: For certificate-based authentication, the `helm repo add` command provides the
    `--ca-file`, `--cert-file`, and `--key-file` flags. The `--ca-file` flag is used
    to verify the chart repository's certificate authority, while the `--cert-file`
    and `--key-file` flags are used to specify your client certificate and key, respectively.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于证书的身份验证，`helm repo add`命令提供`--ca-file`，`--cert-file`和`--key-file`标志。`--ca-file`标志用于验证图表存储库的证书颁发机构，而`--cert-file`和`--key-file`标志用于分别指定您的客户端证书和密钥。
- en: Enabling basic authentication and certificate authentication on the chart repository
    itself depends on the repository implementation that is used. For example, ChartMuseum,
    the popular chart repository, provides the `--basic-auth-user` and `--basic-auth-pass`
    flags that can be used at startup to configure the username and password for basic
    authentication. It also provides the `--tls-ca-cert` flag to configure the **Certificate
    Authority** (**CA**) certificate for certificate authentication. Other chart repository
    implementations may provide other flags or require you to provide a configuration
    file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在图表存储库本身上启用基本身份验证和证书身份验证取决于所使用的存储库实现。例如，流行的图表存储库ChartMuseum提供了`--basic-auth-user`和`--basic-auth-pass`标志，可在启动时用于配置基本身份验证的用户名和密码。它还提供了`--tls-ca-cert`标志来配置证书身份验证的**证书颁发机构**（CA）证书。其他图表存储库实现可能提供其他标志或要求您提供配置文件。
- en: Even with authentication in place, it is important that the transmission between
    the HTTP server and your Helm client is facilitated securely. This can be performed
    using Secure Sockets Layer (SSL) / Transport Layer Security (TLS) based encryption
    to secure communication between your Helm client and your Helm chart repository.
    While a requirement for certificate authentication, repositories requiring basic
    authentication (and unauthenticated repositories) can still benefit from encrypting
    network traffic as this will protect authentication attempts as well as the contents
    of the repository. As with authentication, configuring TLS on the chart repository
    depends on the repository implementation that is used. ChartMuseum provides the
    `--tls-cert` and `--tls-key` flags to provide the certificate chain and key files.
    More general web servers, such as NGINX, typically require a configuration file
    that provides the location of the certificate and key files on the server. Offerings
    such as GitHub Pages already have TLS configured.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了认证，确保HTTP服务器和Helm客户端之间的传输是安全的也很重要。这可以通过使用安全套接字层（SSL）/传输层安全性（TLS）加密来实现，以保护Helm客户端和Helm图表存储库之间的通信。虽然需要证书认证，但需要基本认证（和未经认证的存储库）的存储库仍然可以从加密网络流量中受益，因为这将保护认证尝试以及存储库的内容。与认证一样，配置图表存储库上的TLS取决于所使用的存储库实现。ChartMuseum提供了`--tls-cert`和`--tls-key`标志来提供证书链和密钥文件。更一般的Web服务器，如NGINX，通常需要一个配置文件，提供服务器上证书和密钥文件的位置。像GitHub
    Pages这样的服务已经配置了TLS。
- en: 'Each of the Helm repositories that we have used so far have used certificates
    signed by publicly available CAs that are stored in both your web browser as well
    as your underlying operating system. Many large organizations have their own CAs
    that can be used to produce the certificates configured in the chart repository.
    Since this certificate is likely not from a publicly available CA, the Helm CLI
    may not trust the certificate, and adding the repository results in the following
    error:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们使用的每个Helm存储库都使用了由公开可用的CA签名的证书，这些证书存储在您的Web浏览器和底层操作系统中。许多大型组织都有自己的CA，可以用来生成图表存储库中配置的证书。由于这个证书可能不是来自公开可用的CA，Helm
    CLI可能不信任该证书，添加存储库会导致以下错误：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To allow the Helm CLI to trust the chart repository's certificate, the CA certificate,
    or CA bundle containing multiple certificates, can either be added to the trust
    store of the operating system or explicitly specified using the `--ca-file` flag
    of the `helm repo add` command. This allows the command to be executed without
    error.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Helm CLI信任图表存储库的证书，CA证书或包含多个证书的CA捆绑包可以添加到操作系统的信任存储中，或者可以在`helm repo add`命令的`--ca-file`标志中明确指定。这样可以使命令在没有错误的情况下执行。
- en: Finally, depending on how the chart repository is configured, additional metrics
    can also be obtained to perform request-level auditing and logging to determine
    who has attempted to access the repository.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据图表存储库的配置，还可以获取额外的指标来执行请求级别的审计和日志记录，以确定谁尝试访问存储库。
- en: Through the use of authentication and managing certificates governing the transport
    layer, additional capabilities are realized for enhancing the security footprint
    of Helm repositories.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用认证和管理传输层的证书，可以实现增强Helm存储库的安全性。
- en: Summary
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned about some of the different topics around security
    that need to be considered when working with Helm. First, you learned how data
    provenance and the integrity of Helm releases and Helm charts can be proven. Next,
    you learned about Helm chart security and how a chart developer can employ best
    practices around security to write a stable and secure Helm chart. Finally, you
    learned how RBAC can be used to create an environment based on the concept of
    least privilege access and how chart repositories can be secured to provide HTTPS
    encryption and to require authentication. Now, with these concepts, you are better
    equipped to create a secure Helm architecture and working environment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了在使用Helm时需要考虑的一些安全主题。首先，你了解了如何证明Helm发布和Helm图表的数据来源和完整性。接下来，你了解了Helm图表安全性以及图表开发人员如何在安全方面采用最佳实践来编写稳定和安全的Helm图表。最后，你了解了如何使用RBAC来创建基于最小特权访问概念的环境，以及如何保护图表存储库以提供HTTPS加密并要求身份验证。现在，有了这些概念，你更有能力创建一个安全的Helm架构和工作环境。
- en: Further reading
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To learn more about data provenance [and integrity in the context of Helm c](https://helm.sh/docs/topics/provenance/)harts,
    go to [https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/).
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解有关Helm图表中数据来源和完整性的更多信息，请访问[https://helm.sh/docs/topics/provenance/](https://helm.sh/docs/topics/provenance/)。
- en: To learn more about Kubernetes RBAC, check out the *Using RBAC Auth*[*orization*
    page from the Kubernetes documentation at https://k](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)ubernetes.io/docs/reference/access-authn-authz/rbac/.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要了解更多关于Kubernetes RBAC的信息，请查看Kubernetes文档中的*使用RBAC授权*页面，网址为[https://kubernetes.io/docs/reference/access-authn-authz/rbac/](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)。
- en: Check out the chart repository guide from the Helm docu[mentation to learn more
    about chart repositor](https://helm.sh/docs/topics/chart_repository/)ies at [https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Helm文档中的图表存储库指南，了解更多关于图表存储库的信息，网址为[https://helm.sh/docs/topics/chart_repository/](https://helm.sh/docs/topics/chart_repository/)。
- en: Questions
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is data provenance and integrity? How are data provenance and data integrity
    different?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是数据来源和完整性？数据来源和数据完整性有什么不同？
- en: Imagine you want to prove the data provenance and integrity of a Helm download.
    Besides the release archive, what file does a user need to download from Helm's
    GitHub release page to accomplish this?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，你想要证明Helm下载的数据来源和完整性。除了发布存档之外，用户需要从Helm的GitHub发布页面下载哪个文件来完成这个任务？
- en: What commands can a user run to verify the data provenance and integrity of
    a Helm chart?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户可以运行哪些命令来验证Helm图表的数据来源和完整性？
- en: As a Helm chart developer, what can you do to ensure that you are deploying
    a stable container image?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为Helm图表开发人员，你可以做些什么来确保部署稳定的容器镜像？
- en: Why is it important to set resource limits on your Helm chart? What other Kubernetes
    resources can be used to configure a pod and namespace's resource limits?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Helm图表上设置资源限制为什么很重要？还有哪些Kubernetes资源可以用来配置Pod和命名空间的资源限制？
- en: What is the concept of least privilege access? Which Kubernetes resources allow
    you to configure authorization and help achieve least privilege access?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是最小特权访问的概念？哪些Kubernetes资源允许你配置授权并帮助实现最小特权访问？
- en: What command and set of flags can be used to authenticate against a chart repository?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用什么命令和一组标志来对图表存储库进行身份验证？
