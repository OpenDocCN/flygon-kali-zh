- en: '*Chapter 4*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*'
- en: Object-Oriented Programming
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Learning Objectives
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'By the end of this lesson, you''ll be able to:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本课程结束时，您将能够：
- en: Explain the concept of classes and objects in Java
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释Java中的类和对象的概念
- en: Explain the four underlying principles of object-oriented programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释面向对象编程的四个基本原则
- en: Create simple classes and access them using objects in Java
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中创建简单的类并使用对象访问它们
- en: Implement inheritance in Java
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中实现继承
- en: Experiment with method overloading and overriding in Java
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中尝试方法重载和重写
- en: Create and use annotations in Java
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中创建和使用注释
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we've looked at the basics of Java and how to use simple constructs
    such as **conditional** statements and looping statements, and how methods are
    implemented in Java. These basic ideas are very important to understand and are
    useful when building simple programs. However, to build and maintain large and
    complex programs, the basic types and constructs do not suffice. What makes Java
    really powerful is the fact that it is an object-oriented programming language.
    It allows you to build and integrate complex programs effectively, while maintaining
    a consistent structure, making it easy to scale, maintain, and reuse.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Java的基础知识以及如何使用简单的构造，如**条件**语句和循环语句，以及如何在Java中实现方法。理解这些基本概念非常重要，并且在构建简单程序时非常有用。然而，要构建和维护大型和复杂的程序，基本类型和构造是不够的。使Java真正强大的是它是一种面向对象的编程语言。它允许您有效地构建和集成复杂的程序，同时保持一致的结构，使其易于扩展、维护和重用。
- en: In this lesson, we will introduce a programming paradigm called object-oriented
    programming (OOP), which lies at the core of Java. We will have a look at how
    OOP is done in Java and how you can implement it to design better programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我们将介绍一种称为面向对象编程（OOP）的编程范式，它是Java的核心。我们将看看在Java中如何进行OOP以及如何实现它来设计更好的程序。
- en: We will start this lesson with a definition of OOP and the principles underlying
    it, will look at OOP constructs called **classes** and **objects**, and will conclude
    the lesson by looking at a concept called **inheritance**.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从OOP的定义和其基本原则开始，然后看看称为**类**和**对象**的OOP构造，并最后通过查看称为**继承**的概念来结束本课。
- en: 'We will write two simple OOP applications in Java: one to represent people
    who are normally found in a university, such as students, lecturers, and the staff,
    and the other to represent domestic animals in a farm. Let''s get started!'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Java中编写两个简单的OOP应用程序：一个用于表示通常在大学中找到的人，如学生、讲师和工作人员，另一个用于表示农场中的家畜。让我们开始吧！
- en: Object-Oriented Principles
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象原则
- en: 'OOP is governed by four main principles, as follows. Throughout the rest of
    this lesson, we will delve further into each of these principles:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: OOP受四个主要原则的约束，如下所示。在本课的其余部分，我们将深入研究这些原则中的每一个：
- en: '**Inheritance**: We will learn how we can reuse code by using hierarchies of
    classes and inheriting behavior from derived classes'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：我们将学习如何通过使用类的层次结构和从派生类继承行为来重用代码'
- en: '**Encapsulation**: We will also look at how we can hide the implementation
    details from the outside world while providing a consistent interface to communicate
    with our objects through methods'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装**：我们还将看看如何可以隐藏外部世界的实现细节，同时通过方法提供一致的接口与我们的对象进行通信'
- en: '**Abstraction**: We will look at how we can focus on the important details
    of an object and ignore the other details'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：我们将看看如何可以专注于对象的重要细节并忽略其他细节'
- en: '**Polymorphism**: We will also have a look at how we can define abstract behaviors
    and let other classes provide implementations for these behaviors'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多态**：我们还将看看如何定义抽象行为并让其他类为这些行为提供实现'
- en: Classes and Objects
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和对象
- en: A paradigm in programming is a style of writing programs. Different languages
    support different paradigms. A language can support more than one paradigm.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中的范式是编写程序的风格。不同的语言支持不同的范式。一种语言可以支持多种范式。
- en: Object-Oriented Programming
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: Object-oriented programming, often referred to as OOP, is a style of programming
    in which we deal with objects. Objects are entities that have properties to hold
    their data and methods to manipulate the data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程，通常称为OOP，是一种处理对象的编程风格。对象是具有属性来保存其数据和方法来操作数据的实体。
- en: Let's break this down into simpler terms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更简单的术语来解释这一点。
- en: 'In OOP, we primarily deal with objects and classes. An object is a representation
    of a real-world item. An example of an object is your car or yourself. An object
    has properties associated with it and actions it can perform. For example, your
    car has wheels, doors, an engine, and gears, which are all properties, and it
    can perform actions such as speeding, braking, and stopping, which are all called
    methods. The following diagram is an illustration of the properties and methods
    you have, as a person. Properties can sometimes be referred to as **fields**:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，我们主要处理对象和类。对象是现实世界项目的表示。对象的一个例子是您的汽车或您自己。对象具有与之关联的属性和可以执行的操作。例如，您的汽车具有轮子、门、发动机和齿轮，这些都是属性，它可以执行诸如加速、刹车和停止等操作，这些都称为方法。以下图表是您作为一个人所拥有的属性和方法的插图。属性有时可以称为**字段**：
- en: '![Figure 4.1: Representation of objects relating to humans](img/C09581_Figure_04_01.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：与人类相关的对象表示](img/C09581_Figure_04_01.jpg)'
- en: 'Figure 4.1: Representation of objects relating to humans'
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.1：与人类相关的对象表示
- en: In OOP, we define classes as blueprints of our items and objects as instances
    of classes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在OOP中，我们将类定义为项目的蓝图，将对象定义为类的实例。
- en: 'An example of a class is `Person` and an example of an object/instance of `Person`
    is a student or lecturer. These are specific example objects that belong to the
    `Person` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类的一个例子是`Person`，`Person`的一个对象/实例的例子是学生或讲师。这些是属于`Person`类的具体示例对象：
- en: '![Figure 4.2 Representation of an instance of a class](img/C09581_Figure_04_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 类实例的表示](img/C09581_Figure_04_02.jpg)'
- en: Figure 4.2 Representation of an instance of a class
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.2 类实例的表示
- en: In the preceding diagram, the `Person` class is used to represent all people,
    regardless of their gender, age, or height. From this class, we can create specific
    examples of people, as shown in the boxes inside the `Person` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上图中，`Person`类用于表示所有人，而不考虑他们的性别、年龄或身高。从这个类中，我们可以创建人的具体示例，如`Person`类内部的方框所示。
- en: In Java, we mainly deal with classes and objects, so it is very important that
    you understand the difference between the two.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们主要处理类和对象，因此非常重要的是您理解两者之间的区别。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: In Java, everything except primitive data types are objects.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，除了原始数据类型之外，一切都是对象。
- en: 'Here is the format of a class definition in Java:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Java中类定义的格式：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A class definition in Java consists of the following parts:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的类定义由以下部分组成：
- en: '`public`, `private`, `protected`, or have no modifier. A `public` class is
    accessible from other classes in other packages. A `private` class is only accessible
    from within the class it is declared. A `protected` class member is accessible
    within all classes in the same package.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`，`private`，`protected`，或者没有修饰符。一个`public`类可以从其他包中的其他类访问。一个`private`类只能从声明它的类中访问。一个`protected`类成员可以在同一个包中的所有类中访问。'
- en: '**Class name**: The name should begin with an initial letter.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类名**：名称应以初始字母开头。'
- en: '**Body**: The class body is surrounded by braces, { }. This is where we define
    the properties and methods of the class.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主体**：类主体由大括号{ }括起来。这是我们定义类的属性和方法的地方。'
- en: Naming Conventions for Class Names
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类名的命名约定
- en: 'Naming conventions for classes in Java are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Java中类的命名约定如下：
- en: Class names should use camelCase. That is, the first word should start with
    a capital letter and all of the inner words should have a capitalized first word,
    for example, `Cat`, `CatOwner`, and `House`.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应该使用驼峰命名法。也就是说，第一个单词应以大写字母开头，所有内部单词的第一个字母都应大写，例如`Cat`，`CatOwner`和`House`。
- en: Class names should be nouns.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应该是名词。
- en: Class names should be descriptive and should not be initials, unless they are
    widely known.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名应该是描述性的，不应该是缩写，除非它们是广为人知的。
- en: 'Here is an example of how the `Person` class would be defined:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Person`类的定义示例：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The modifier is public, meaning that the class can be accessed from other Java
    packages. The class name is `Person`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符是public，意味着该类可以从其他Java包中访问。类名是`Person`。
- en: 'Here is a more robust example of the `Person` class with a few properties and
    methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Person`类的更健壮的示例，具有一些属性和方法：
- en: '[PRE2]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'These properties are used to hold the state of the object. That is, `age` holds
    the age of the current person, which can be different from that of the next person.
    `name` is used to hold the name of the current person, which will also be different
    from the next person. They answer the question: who is this person?'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性用于保存对象的状态。也就是说，`age`保存当前人的年龄，这可能与下一个人的年龄不同。`name`用于保存当前人的名字，这也将与下一个人不同。它们回答了这个问题：这个人是谁？
- en: 'The methods are used to hold the logic of the class. That is, they answer the
    question: what can this person do? Methods can be private, public, or protected.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 方法用于保存类的逻辑。也就是说，它们回答了这个问题：这个人能做什么？方法可以是私有的、公共的或受保护的。
- en: The operations in the methods can be as complex as your application needs. You
    can even call methods from other methods, as well as adding parameters to those
    methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 方法中的操作可以根据应用程序的需要变得复杂。您甚至可以从其他方法调用方法，以及向这些方法添加参数。
- en: 'Exercise 11: Working with Classes and Objects'
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习11：使用类和对象
- en: 'Perform the following steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open IntelliJ IDEA and create a file called `Person.java`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开IntelliJ IDEA并创建一个名为`Person.java`的文件。
- en: 'Create a public class with the name `Person` with three properties, that is,
    `age`, `height`, and `name`. The `age` and `height` properties will hold integer
    values, whereas the `name` property will hold a string value:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Person`的公共类，具有三个属性，即`age`，`height`和`name`。`age`和`height`属性将保存整数值，而`name`属性将保存字符串值：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Define three methods, that is, `walk()`, `sleep()`, and `takeShower()`. Write
    the print statements for each so that you can print out the text to the console
    when they are called:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义三个方法，即`walk()`，`sleep()`和`takeShower()`。为每个方法编写打印语句，以便在调用它们时将文本打印到控制台上：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, pass the `speed` parameter to the `walk()` method. If the `speed` is above
    10, we print the output to the console, otherwise we don''t:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`speed`参数传递给`walk()`方法。如果`speed`超过10，我们将输出打印到控制台，否则我们不会：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have the `Person` class, we can create objects for it using the
    `new` keyword. In the following code, we have created three objects:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了`Person`类，我们可以使用`new`关键字为其创建对象。在以下代码中，我们创建了三个对象：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `me` variable is now an object of the `Person` class. It represents a specific
    type of person, me.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`me`变量现在是`Person`类的对象。它代表了一种特定类型的人，即我。'
- en: With this object, we can do anything we wish, such as calling the `walk()` method,
    calling the `sleep()` method, and much more. We can do this as long as there are
    methods in the class. Later, we will look at how we can add all of this behavior
    to a class. This code will not have any output since we do not have the **main**
    method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个对象，我们可以做任何我们想做的事情，比如调用`walk()`方法，调用`sleep()`方法，以及更多。只要类中有方法，我们就可以这样做。稍后，我们将看看如何将所有这些行为添加到一个类中。由于我们没有**main**方法，这段代码不会有任何输出。
- en: 'Exercise 12: Using the Person Class'
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 练习12：使用Person类
- en: 'To call the member functions of a class, perform the following steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用类的成员函数，请执行以下步骤：
- en: Create a new class in IntelliJ called `PersonTest`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IntelliJ中创建一个名为`PersonTest`的新类。
- en: Inside the `PersonTest` class, create the `main` method.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PersonTest`类中，创建`main`方法。
- en: Inside the `main` method, create three objects of the `Person` class
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，创建`Person`类的三个对象
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Call the `walk()` method for the first object:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用第一个对象的`walk()`方法：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the class and observe the output:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行类并观察输出：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Do the same using the `myNeighbour` and `lecturer` objects instead of `me`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`myNeighbour`和`lecturer`对象来做同样的事情，而不是使用`me`：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the program again and observe the output:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行程序并观察输出：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, we created a new class called `PersonTest` and inside it created
    three objects of the `Person` class. We then called the methods of the `me` object.
    From this program, it is evident that the `Person` class is a blueprint from which
    we can create as many objects as we wish. We can manipulate each of these objects
    separately as they are completely different and independent. We can pass these
    objects around as if they were just like any other variables, and can even pass
    them to other objects as parameters. This is the flexibility of object-oriented
    programming.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为`PersonTest`的新类，并在其中创建了`Person`类的三个对象。然后我们调用了`me`对象的方法。从这个程序中，可以明显看出`Person`类是一个蓝图，我们可以根据需要创建尽可能多的对象。我们可以分别操作这些对象，因为它们是完全不同和独立的。我们可以像处理其他变量一样传递这些对象，甚至可以将它们作为参数传递给其他对象。这就是面向对象编程的灵活性。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: We didn't call `me.takeShower()` because this method is declared private in
    the `Person` class. Private methods cannot be called outside their class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有调用`me.takeShower()`，因为这个方法在`Person`类中声明为私有。私有方法不能在其类外部调用。
- en: Constructors
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'To be able to create an object of a class, we need a constructor. A constructor
    is called when you want to create an object of a class. When we create a class
    without a constructor, Java creates an empty default constructor for us that takes
    no parameters. If a class is created without a constructor, we can still instantiate
    it with the default constructor. A good example of this is the `Person` class
    that we used previously. When we wanted a new object of the `Person` class, we
    wrote the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够创建一个类的对象，我们需要一个构造函数。当你想要创建一个类的对象时，就会调用构造函数。当我们创建一个没有构造函数的类时，Java会为我们创建一个空的默认构造函数，不带参数。如果一个类创建时没有构造函数，我们仍然可以用默认构造函数来实例化它。我们之前使用的`Person`类就是一个很好的例子。当我们想要一个`Person`类的新对象时，我们写下了以下内容：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The default constructor is `Person()`, and it returns a new instance of the
    `Person` class. We then assign this returned instance to our variable, `me`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 默认构造函数是`Person()`，它返回`Person`类的一个新实例。然后我们将这个返回的实例赋给我们的变量`me`。
- en: 'A constructor is just like any other method, except for a few differences:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和其他方法一样，只是有一些不同：
- en: A constructor has the same name as the class
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数的名称与类名相同
- en: A constructor can be `public` or `private`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数可以是`public`或`private`
- en: A constructor doesn't return anything, even `void`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数不返回任何东西，甚至不返回`void`
- en: 'Let''s look at an example. Let''s create a simple constructor for our `Person`
    class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。让我们为我们的`Person`类创建一个简单的构造函数：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This constructor takes one argument, an integer called `myAge`, and assigns
    its value to the `age` property in the class. Remember that the constructor implicitly
    returns an instance of the class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数接受一个参数，一个名为`myAge`的整数，并将其值赋给类中的`age`属性。记住构造函数隐式返回类的实例。
- en: 'We can use the constructor to create the `me` object again, this time passing
    `age`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用构造函数再次创建`me`对象，这次传递`age`：
- en: '[PRE14]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The this Keyword
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this关键字
- en: 'In our `Person` class, we saw the following line in our constructor:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Person`类中，我们在构造函数中看到了以下行：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In this line, as we saw earlier, we are setting the `age` variable in our current
    object to the new value, `myAge`, which is passed in as a parameter. Sometimes,
    we wish to be explicit about the object we are referring to. When we want to refer
    to the properties in the current object we are dealing with, we use the `this`
    keyword. As an example, we could rewrite the preceding line as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行中，正如我们之前看到的，我们正在将当前对象的`age`变量设置为传入的新值`myAge`。有时，我们希望明确指出我们所指的对象。当我们想引用当前正在处理的对象中的属性时，我们使用`this`关键字。例如，我们可以将前面的行重写为以下形式：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this new line, `this.age` is used to refer to the age property in the current
    object we are dealing with. `this` is used to access the current object's instance
    variables.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一新行中，`this.age`用于引用当前正在处理的对象中的age属性。`this`用于访问当前对象的实例变量。
- en: For example, in the preceding line, we are setting the current object's `age`
    to the value that's passed into the constructor.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在前面的行中，我们正在将当前对象的`age`设置为传递给构造函数的值。
- en: In addition to referring to the current object, `this` can also be used to invoke
    a class' other constructors if you have more than one constructor.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了引用当前对象，如果你有多个构造函数，`this`还可以用来调用类的其他构造函数。
- en: 'In our `Person` class, we will create a second constructor that takes no parameter.
    If this constructor is invoked, it invokes the other constructor we created with
    a default value of 28:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Person`类中，我们将创建一个不带参数的第二个构造函数。如果调用此构造函数，它将调用我们创建的另一个构造函数，并使用默认值28：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when the call of `Person me = new Person()` is made, the second constructor
    will call the first constructor with `myAge` set to 28\. The first constructor
    will then set the current object's `age` to 28\.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当调用`Person me = new Person()`时，第二个构造函数将调用第一个构造函数，并将`myAge`设置为28。第一个构造函数将当前对象的`age`设置为28。
- en: 'Activity 12: Creating a Simple Class in Java'
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动12：在Java中创建一个简单的类
- en: 'Scenario: Let''s imagine we want to create a program for an animal farm. In
    this program, we need to keep track of all the animals that are on the farm. To
    start with, we need a way to represent the animals. We will create an animal class
    to represent a single animal and then create instances of this class to represent
    the specific animals themselves.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：假设我们想为一个动物农场创建一个程序。在这个程序中，我们需要跟踪农场上的所有动物。首先，我们需要一种方法来表示动物。我们将创建一个动物类来表示单个动物，然后创建这个类的实例来表示具体的动物本身。
- en: 'Objective: We will create a Java class to represent animals and create instances
    of that class. By the end of this activity, we should have a simple `Animal` class
    and a few instances of that class.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：我们将创建一个Java类来表示动物，并创建该类的实例。到本次活动结束时，我们应该有一个简单的`Animal`类和该类的几个实例。
- en: 'Aim: To understand how to create classes and objects in Java.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：了解如何在Java中创建类和对象。
- en: Follow these steps to complete the activity
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成活动
- en: Create a new project in the IDE and name it `Animals`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在IDE中创建一个新项目，命名为`Animals`。
- en: In the project, create a new file called `Animal.java` under the **src/** folder.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中，在**src/**文件夹下创建一个名为`Animal.java`的新文件。
- en: Create a class named `Animal` and add the instance variables `legs`, `ears`,
    `eyes`, `family`, and `name`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Animal`的类，并添加实例变量`legs`、`ears`、`eyes`、`family`和`name`。
- en: Define a constructor with no parameters and initialize `legs` to 4, `ears` to
    2, and `eyes` to 2.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个没有参数的构造函数，并将`legs`初始化为4，`ears`初始化为2，`eyes`初始化为2。
- en: Define another parameterized constructor which takes the `legs`, `ears`, and
    `eyes` as arguments.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个带有`legs`、`ears`和`eyes`作为参数的带参数构造函数。
- en: Add getters and setters for `name` and `family`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`name`和`family`添加getter和setter。
- en: Create another file called `Animals.java`, define the `main` method, and create
    two objects of the `Animal` class.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`Animals.java`的文件，定义`main`方法，并创建`Animal`类的两个对象。
- en: Create another animal with two `legs`, two `ears`, and two `eyes`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个具有两条`legs`、两只`ears`和两只`eyes`的动物。
- en: To set the animals' `name` and `family`, we will use the getters and setters
    we created in the class and print names of the animals.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了设置动物的`name`和`family`，我们将使用在类中创建的getter和setter，并打印动物的名字。
- en: 'The output should be similar to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '![Figure 4.4: Output of the Animal class](img/C09581_Figure_04_03.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：Animal类的输出](img/C09581_Figure_04_03.jpg)'
- en: 'Figure 4.3: Output of the Animal class'
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.3：Animal类的输出
- en: Note
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 314.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的解决方案可以在314页找到。
- en: 'Activity 13: Writing a Calculator Class'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动13：编写一个Calculator类
- en: For this activity you'll create a Calculator class that, given two operands
    and one operator, can execute the operation and return the result. This class
    will have one operate method which will execute the operation using the two operands.
    The operands and the operator will be fields in the class, set through the constructor.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个活动，你将创建一个Calculator类，给定两个操作数和一个运算符，可以执行操作并返回结果。这个类将有一个operate方法，它将使用两个操作数执行操作。操作数和运算符将是类中的字段，通过构造函数设置。
- en: With the Calculator class ready, write an application that executes some sample
    operations and prints the results to the console.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有了Calculator类准备好后，编写一个应用程序，执行一些示例操作，并将结果打印到控制台。
- en: 'To complete this activity you''ll need to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这项活动，你需要：
- en: 'Create a class `Calculator` with three fields: `double` `operand1`, `double`
    `operand2` and `String` `operator`. Add a constructor that sets all three fields.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Calculator`的类，有三个字段：`double` `operand1`、`double` `operand2`和`String`
    `operator`。添加一个设置所有三个字段的构造函数。
- en: In this class, add an `operate` method that will check what operator is ("+",
    "-", "x" or "/") and executes the correct operation, returning the result.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，添加一个`operate`方法，它将检查运算符是什么（"+"、"-"、"x"或"/"），并执行正确的操作，返回结果。
- en: Add a `main` method to this class so that you can write a few sample cases and
    print the results.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中添加一个`main`方法，这样你就可以写几个示例案例并打印结果。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 318.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这项活动的解决方案可以在318页找到。
- en: Inheritance
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: In this section, we will have a look at another important principle of OOP,
    called inheritance. Inheritance in OOP has the same meaning as it has in English.
    Let's look at an example by using our family trees. Our parents inherit from our
    grandparents. We then inherit from our parents, and finally, our children inherit,
    or will inherit, from us. Similarly, a class can inherit the properties of another
    class. These properties include methods and fields. Then, another class can still
    inherit from it, and so on. This forms what we call an **inheritance hierarchy**.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一下面向对象编程的另一个重要原则，称为继承。面向对象编程中的继承与英语中的继承意思相同。让我们通过使用我们的家谱来看一个例子。我们的父母继承自我们的祖父母。然后我们从我们的父母那里继承，最后，我们的孩子继承，或者将从我们那里继承。同样，一个类可以继承另一个类的属性。这些属性包括方法和字段。然后，另一个类仍然可以从它那里继承，依此类推。这形成了我们所说的**继承层次结构**。
- en: The class being inherited from is called the **superclass** or the **base**
    class, and the class that is inheriting is called the **subclass** or the **derived**
    class. In Java, a class can only inherit from one superclass.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 被继承的类称为**超类**或**基类**，继承的类称为**子类**或**派生类**。在Java中，一个类只能从一个超类继承。
- en: Types of Inheritance
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承的类型
- en: 'An example of inheritance is a management hierarchy in a company or in the
    government:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的一个例子是公司或政府中的管理层次结构：
- en: '**Single Level Inheritance**: In single level inheritance, a class inherits
    from only one other class:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单级继承**：在单级继承中，一个类只从另一个类继承：'
- en: '![Figure 4.5: Representation of single level inheritance](img/C09581_Figure_04_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：单级继承的表示](img/C09581_Figure_04_05.jpg)'
- en: 'Figure 4.4: Representation of single level inheritance'
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.4：单级继承的表示
- en: '**Multi-level inheritance**: In multi-level inheritance, a class can inherit
    from another class that also inherits from another class:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多级继承**：在多级继承中，一个类可以继承另一个类，而另一个类也可以继承另一个类：'
- en: '![Figure 4.6: Representation of multi-level inheritance](img/C09581_Figure_04_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：多级继承的表示](img/C09581_Figure_04_06.jpg)'
- en: 'Figure 4.5: Representation of multi-level inheritance'
  id: totrans-148
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.5：多级继承的表示
- en: '**Multiple inheritance**: Here, a class can inherit from more than one class:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多重继承**：在这里，一个类可以从多个类继承：'
- en: '![Figure 4.7: Representation of multiple inheritance](img/C09581_Figure_04_07.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：多重继承的表示](img/C09581_Figure_04_07.jpg)'
- en: 'Figure 4.6: Representation of multiple inheritance'
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.6：多重继承的表示
- en: Multiple inheritance is not directly supported in Java, but can be achieved
    by using **interfaces**, which will be covered in the next lesson.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中不直接支持多重继承，但可以通过使用**接口**来实现，这将在下一课程中介绍。
- en: Importance of Inheritance in OOP
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向对象编程中继承的重要性
- en: Let's go back to our `Person` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Person`类。
- en: It is clear that there are common properties and actions that all people support,
    despite their gender or race. For example, in terms of properties, everyone has
    a name, and everyone has an age, height, and weight. With regard to common actions,
    all people sleep, all people eat, and all people breathe, among other things.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，所有人都支持一些共同的属性和行为，尽管他们的性别或种族不同。例如，在属性方面，每个人都有一个名字，每个人都有年龄、身高和体重。在行为方面，所有人都睡觉，所有人都吃饭，所有人都呼吸，等等。
- en: Instead of writing code for all of these properties and methods in all of our
    `Person` classes, we can define all of these common properties and actions in
    one class and let the other Person classes inherit from this class. That way,
    we won't have to rewrite the properties and methods in these subclasses. Therefore,
    inheritance allows us to write more concise code by reusing code.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在所有的`Person`类中定义所有这些属性和方法的代码，也可以在一个类中定义所有这些常见属性和操作，让其他`Person`类从这个类继承。这样，我们就不必在这些子类中重写属性和方法。因此，继承允许我们通过重用代码来编写更简洁的代码。
- en: 'The syntax for a class to inherit from another class is as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类从另一个类继承的语法如下：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We use the `extends` keyword to denote inheritance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`extends`关键字来表示继承。
- en: 'For example, if we wanted our `Student` class to extend the `Person` class,
    we would declare it like so:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望我们的`Student`类扩展`Person`类，我们会这样声明：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this `Student` class, we have access to the public properties and methods
    that we defined earlier in the `Person` class. When we create an instance of this
    `Student` class, we automatically have access to the methods we defined in the
    `Person` class earlier, such as `walk()` and `sleep()`. We don't need to recreate
    those methods anymore as our `Student` class is now a subclass of the `Person`
    class. We, however, don't have access to private methods such as `takeShower()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`Student`类中，我们可以访问我们在`Person`类中之前定义的公共属性和方法。当我们创建这个`Student`类的实例时，我们自动可以访问我们之前在`Person`类中定义的方法，比如`walk()`和`sleep()`。我们不需要再重新创建这些方法，因为我们的`Student`类现在是`Person`类的子类。但是，我们无法访问私有方法，比如`takeShower()`。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that a subclass only has access to the public properties and methods
    in its superclass. If a property or method is declared as private in the superclass,
    we cannot access it from the subclass. By default, the properties we declared
    are only accessible from classes in the same package, unless we specifically put
    the `public` modifier before them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，子类只能访问其超类中的公共属性和方法。如果在超类中将属性或方法声明为私有，则无法从子类访问它。默认情况下，我们声明的属性只能从同一包中的类中访问，除非我们在它们之前明确放置`public`修饰符。
- en: 'In our `Person` class, let''s define some common properties and methods that
    all people have. Then, we will inherit these properties from this class to create
    other classes, such as `Student` and `Lecturer`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Person`类中，让我们定义一些所有人都具有的常见属性和方法。然后，我们将从这个类继承这些属性，以创建其他类，比如`Student`和`Lecturer`：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we have defined four properties, two constructors, and seven methods.
    Can you explain what each method does? The methods are fairly simple for now so
    that we can focus on the core concepts of inheritance. We have also modified the
    constructors to take three parameters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了四个属性，两个构造函数和七个方法。您能解释每个方法的作用吗？目前这些方法都相当简单，这样我们就可以专注于继承的核心概念。我们还修改了构造函数以接受三个参数。
- en: 'Let''s create a `Student` class that inherits from this `Person` class, create
    an object of the class, and set the name of the student:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个从`Person`类继承的`Student`类，创建一个类的对象，并设置学生的名字：
- en: '[PRE21]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have created a new `Student` class that inherits from the `Person` class.
    We have also created a new instance of the `Student` class and set its name. Note
    that we didn''t redefine the `setName()` method in the `Student` class because
    it is already defined in the `Person` class. We can also call other methods on
    our `student` object:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个新的`Student`类，它继承自`Person`类。我们还创建了`Student`类的一个新实例，并设置了它的名字。请注意，我们没有在`Student`类中重新定义`setName()`方法，因为它已经在`Person`类中定义了。我们还可以在我们的`student`对象上调用其他方法：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note that we did not create these methods in the `Student` class as they are
    already defined in the `Person` class from which the `Student` class inherits.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有在`Student`类中创建这些方法，因为它们已经在`Student`类继承的`Person`类中定义。
- en: Implementing Inheritance in Java
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Java中实现继承
- en: Write down the expected output of the preceding program. Explain the output
    by looking at the program.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 写下上述程序的预期输出。通过查看程序来解释输出。
- en: 'The solution was:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是：
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s define a `Lecturer` class that inherits from the same `Person` class:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个从相同的`Person`类继承的`Lecturer`类：
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Please note how Inheritance has helped us reduce the amount of code we write
    by reusing the same `Person` class. Without inheritance, we would have had to
    repeat the same methods and properties in all of our classes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意继承如何帮助我们通过重用相同的`Person`类来减少我们编写的代码量。如果没有继承，我们将不得不在所有的类中重复相同的方法和属性。
- en: 'Activity 14: Creating a Calculator Using Inheritance'
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动14：使用继承创建计算器
- en: In the previous activity, you created a `Calculator` class that contained all
    the known operations in the same class. This makes this class harder to extend
    when you think about adding new operations. The operator method would grow indefinitely.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的活动中，您创建了一个`Calculator`类，其中包含了同一类中所有已知的操作。当您考虑添加新操作时，这使得这个类更难扩展。操作方法将无限增长。
- en: 'To make this better, you will use OOP practices to split the operator logic
    out of this class into its own class. In this activity you''ll create a class
    Operator that defaults to the sum operation and then three other classes that
    implement the other three operations: subtraction, multiplication and division.
    This Operator class has a `matches` method that, given a String returns a boolean
    that is true if the String represents that operator or false if not.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个更好，你将使用面向对象的实践将操作逻辑从这个类中拆分出来，放到它自己的类中。在这个活动中，你将创建一个名为Operator的类，默认为求和操作，然后创建另外三个类来实现其他三种操作：减法、乘法和除法。这个Operator类有一个`matches`方法，给定一个字符串，如果该字符串表示该操作符，则返回true，否则返回false。
- en: 'With the operation logic in their own classes, write a new class called `CalculatorWithFixedOperators`
    with three fields: `double` `operand1`, `double` `operand2` and `operator` of
    type `Operator`. This class will have the same constructor that the previous calculator,
    but instead of storing the operator as a String, it will check for the operator
    classes using the matches method to determine the correct operator.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 将操作逻辑放在它们自己的类中，编写一个名为`CalculatorWithFixedOperators`的新类，其中有三个字段：`double` `operand1`、`double`
    `operand2`和类型为`Operator`的`operator`。这个类将具有与之前计算器相同的构造函数，但不再将操作符存储为字符串，而是使用`matches`方法来确定正确的操作符。
- en: As the previous calculator, this calculator also has a method operate that returns
    a double, but instead of any login in there, it delegates the current operator,
    determined in the constructor.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的计算器一样，这个计算器也有一个返回double的`operate`方法，但不再有任何逻辑，而是委托给在构造函数中确定的当前操作符。
- en: 'To complete this activity you''ll need to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，你需要：
- en: Create a class `Operator` that has one String field initialized in the constructor
    that represents the operator. This class should have a default constructor that
    represents the default operator, which is `sum`. The operator class should also
    have a method called operate that receives two doubles and return the result of
    the operator as a double. The default operation is sum.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Operator`的类，它有一个在构造函数中初始化的String字段，表示操作符。这个类应该有一个默认构造函数，表示默认操作符，即`sum`。操作符类还应该有一个名为`operate`的方法，接收两个double并将操作符的结果作为double返回。默认操作是求和。
- en: 'Create three other classes: `Subtraction`, `Multiplication` and `Division`.
    They extend from Operator and override the `operate` method with each operation
    that they represent. They also need a no-argument constructor that calls super
    passing the operator that they represent.'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另外三个类：`Subtraction`、`Multiplication`和`Division`。它们继承自Operator，并重写了代表它们的每种操作的`operate`方法。它们还需要一个不带参数的构造函数，调用super传递它们代表的操作符。
- en: 'Create a new class, called `CalculatorWithFixedOperators`. This class will
    contain four fields that are constants (finals) and represent the four possible
    operations. It should also have three other fields: `operand1` and `operator2`
    of type double and `operator` of type `Operator`. These other three fields will
    be initialized in the constructor that will receive the operands and the operator
    as a String. Using the match methods of the possible operators, determine which
    one will be set as the operator fields.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`CalculatorWithFixedOperators`的新类。这个类将包含四个常量（finals）字段，表示四种可能的操作。它还应该有另外三个字段：类型为double的`operand1`和`operator2`，以及类型为`Operator`的`operator`。这另外三个字段将在构造函数中初始化，该构造函数将接收操作数和操作符作为字符串。使用可能操作符的匹配方法，确定哪一个将被设置为操作符字段。
- en: As the previous `Calculator` class, this one will also have an `operate` method,
    but it will only delegate to the `operator` instance.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与之前的`Calculator`类一样，这个类也将有一个`operate`方法，但它只会委托给`operator`实例。
- en: Last, write a `main` method that calls the new calculator a few times, printing
    the results of the operation for each time.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，编写一个`main`方法，多次调用新的计算器，打印每次操作的结果。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: Rewriting the calculator to use more classes seems more complex than the initial
    code. But it abstracts some important behavior which opens some possibilities
    that will be explored in future activities.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 重写计算器以使用更多的类似乎比最初的代码更复杂。但它抽象了一些重要的行为，打开了一些将在未来活动中探索的可能性。
- en: Note
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 319.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第319页找到。
- en: Overloading
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载
- en: 'The next principle of OOP we will discuss is called overloading. Overloading
    is a powerful concept in OOP that allows us to reuse method names as long as they
    have different signatures. A **method signature** is the method name, its parameters,
    and the order of the parameters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的下一个面向对象的原则叫做重载。重载是面向对象编程中的一个强大概念，它允许我们重用方法名，只要它们具有不同的签名。**方法签名**是方法名、它的参数和参数的顺序：
- en: '![Figure 4.8: Representation of a method signature](img/C09581_Figure_04_08.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：方法签名的表示](img/C09581_Figure_04_08.jpg)'
- en: 'Figure 4.7: Representation of a method signature'
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.7：方法签名的表示
- en: The preceding is an example of a method that withdraws funds from a given bank
    name. The method returns a double and accepts a String parameter. The method signature
    here is the name of the `getMyFundsFromBank()` method and the String parameter
    `bankName`. The signature doesn't include the return type of the method, only
    the name and the parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述是一个从给定银行名称中提取资金的方法的示例。该方法返回一个double并接受一个String参数。这里的方法签名是`getMyFundsFromBank()`方法的名称和String参数`bankName`。签名不包括方法的返回类型，只包括名称和参数。
- en: With overloading, we are able to define more than one method with the same method
    names but different parameters. This can be useful in defining methods that do
    the same thing but take different parameters.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重载，我们能够定义多个方法，这些方法具有相同的方法名，但参数不同。这在定义执行相同操作但接受不同参数的方法时非常有用。
- en: Let's look at an example.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。
- en: 'Let''s define a class called `Sum` with three overloaded methods that add the
    parameters that are passed and returns the result:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`Sum`的类，其中有三个重载的方法，用来对传递的参数进行相加并返回结果：
- en: '[PRE25]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, the `sum()` method is overloaded to take different parameters
    and return the sum. The method name is the same, but each of the methods takes
    a different set of parameters. This difference in the method signatures allows
    us to use the same name as many times as we wish.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`sum()`方法被重载以接受不同的参数并返回总和。方法名相同，但每个方法都接受不同的参数集。方法签名的差异允许我们使用相同的名称多次。
- en: You might be wondering about the benefits overloading brings to OOP. Imagine
    a scenario where we wouldn't be able to reuse a certain method name more than
    once, as in certain languages, such as C. For us to be able to accept different
    sets of parameters, we would need to come up with six different method names.
    Coming up with six different names for methods that essentially do the same thing
    is tiresome and painful when dealing with large programs. Overloading saves us
    from such scenarios.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道重载对面向对象编程带来了什么好处。想象一种情况，我们不能多次重用某个方法名称，就像在某些语言中，比如C语言。为了能够接受不同的参数集，我们需要想出六个不同的方法名称。为了那些本质上做同样事情的方法想出六个不同的名称是繁琐和痛苦的，尤其是在处理大型程序时。重载可以避免我们遇到这样的情况。
- en: 'Let''s go back to our `Student` class and create two overloaded methods. In
    the first method, we will print a string to print "Going to class...", regardless
    of which day of the week it is. In the second method, we will pass the day of
    the week and check whether it is the weekend. If it is the weekend, we will print
    out a different string in comparison to the rest of the week. Here is how we will
    implement this:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Student`类，并创建两个重载的方法。在第一个方法中，我们将打印一个字符串来打印“去上课...”，无论这一周的哪一天。在第二个方法中，我们将传递一周的哪一天，并检查它是否是周末。如果是周末，我们将打印出一个与其他工作日不同的字符串。这是我们将如何实现它：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows::'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Open the `Lecturer` class we created and add two overloaded methods, as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们创建的`Lecturer`类，并添加两个重载的方法，如下所示：
- en: '`teachClass()` prints out "Teaching a random class"'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teachClass()`打印出"Teaching a random class"'
- en: '`teachClass(String className)` prints out "`Teaching` " + `className`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teachClass(String className)`打印出"`Teaching` " + `className`'
- en: 'Following is the code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是代码：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can overload the main method in a class, but once the program starts up,
    the JVM will only call `main(String[] args)`. We can call our overloaded `main`
    method from this `main` method. Here is an example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个类中重载主方法，但一旦程序启动，JVM只会调用`main(String[] args)`。我们可以从这个`main`方法中调用我们重载的`main`方法。以下是一个例子：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, the `main` method is overloaded three times. However, when
    we run our program, the main method whose signature is `main(String[] args)` will
    be called. From anywhere in our code, we can then freely call the other main methods.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`main`方法被重载了三次。然而，当我们运行程序时，只会调用签名为`main(String[] args)`的主方法。从我们的代码的任何地方，我们都可以自由地调用其他主方法。
- en: Constructor Overloading
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数重载
- en: Just like methods, constructors can be overloaded too. When the same constructors
    are declared with different parameters in the same class, this is known as **constructor
    overloading**. The compiler differentiates which constructor is to be called,
    depending on the number of parameters and their data types.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法一样，构造函数也可以被重载。当在同一个类中使用不同参数声明相同的构造函数时，这被称为**构造函数重载**。编译器根据参数的数量和数据类型来区分应该调用哪个构造函数。
- en: 'In our discussion on constructors, we created a second constructor for our
    `Person` class that takes `age`, `height`, and `weight` as parameters. We can
    have this constructor in the same class as the constructor that takes in no parameters.
    This is because the two constructors have a different signature and can hence
    be used side by side. Let''s look at how we can do this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论构造函数时，我们为我们的`Person`类创建了第二个构造函数，它接受`age`、`height`和`weight`作为参数。我们可以在同一个类中拥有不接受参数的构造函数和这个构造函数。这是因为这两个构造函数具有不同的签名，因此可以并存。让我们看看我们如何做到这一点：
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The two constructors have same name (the class name) but take different parameters.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个构造函数具有相同的名称（类名），但接受不同的参数。
- en: Add a third constructor that takes `age`, `height`, `weight`, and `name`. Inside
    the constructor, set all the class variables to the passed parameters.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个接受`age`、`height`、`weight`和`name`的第三个构造函数。在构造函数内，将所有类变量设置为传递的参数。
- en: 'The code is as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '[PRE32]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Polymorphism and Overriding
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态和重写
- en: The next principle of OOP we will cover is called polymorphism. The term "**polymorphism**"
    stems from biology in that an organism can take many forms and stages. This term
    is also used in OOP in that sub-classes can define their unique behaviors yet
    still share some functionalities with their parent classes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的下一个面向对象编程原则是多态。术语“**多态**”源自生物学，即一个生物体可以呈现多种形式和阶段。这个术语也用在面向对象编程中，子类可以定义它们独特的行为，但仍然与父类共享一些功能。
- en: Let's illustrate this with an example.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个例子来说明这一点。
- en: 'In our `Person` example, we had a method, `walk`. In our `Student` class, which
    inherits from the `Person` class, we will redefine the same `walk` method, but
    now walking to class instead of just walking. In our `Lecturer` class, we will
    also redefine the same `walk` method and this time walk to the staff room instead
    of walking to class. This method must have the same signature and return type
    as the `walk` method in the superclass for this to be considered polymorphic.
    Here is what the implementation looks like in our `Student` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Person`示例中，我们有一个名为`walk`的方法。在我们的`Student`类中，它继承自`Person`类，我们将重新定义相同的`walk`方法，但现在是走去上课而不仅仅是走路。在我们的`Lecturer`类中，我们也将重新定义相同的`walk`方法，这次是走到教职工室而不是走到教室。这个方法必须与超类中的`walk`方法具有相同的签名和返回类型，才能被认为是多态的。以下是我们`Student`类中实现的样子：
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When we call `student.walk(20)`, this method in our `Student` class will be
    called instead of the same method in the `Person` class. That is, we have provided
    a unique way to walk for our `Student` class that isn't the same for the `Lecturer`
    and `Person` classes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`student.walk(20)`时，我们的`Student`类中的这个方法将被调用，而不是`Person`类中的相同方法。也就是说，我们为我们的`Student`类提供了一种独特的行走方式，这与`Lecturer`和`Person`类不同。
- en: In Java, we refer to such a method as overridden and the process as method overriding.
    The Java virtual machine (JVM) calls the appropriate method for the object that
    is referred.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们将这样的方法称为重写方法，这个过程称为方法重写。Java虚拟机（JVM）调用适当的方法来引用对象。
- en: The Difference between Overriding and Overloading
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写和重载之间的区别
- en: 'Let''s have a look at the difference between method overloading and overriding:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下方法重载和重写之间的区别：
- en: 'Method overloading deals with the notion of having two or more methods in the
    same class with the same name but different arguments:'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重载涉及在同一个类中有两个或更多个具有相同名称但不同参数的方法：
- en: '[PRE34]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Method overriding means having two methods with the same arguments, but different
    implementations. One of them would exist in the parent class, while another would
    exist in the child class:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法重写意味着有两个具有相同参数但不同实现的方法。其中一个存在于父类中，而另一个存在于子类中：
- en: '[PRE35]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Annotations
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: We will now cover another important topic that will help us write better Java
    programs.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将介绍另一个将帮助我们编写更好的Java程序的重要主题。
- en: Annotations are a way in which we can add metadata to our programs. This metadata
    can include information such as the version of a class we are developing. This
    is useful in scenarios where a class is deprecated or where we are overriding
    a certain method. Such metadata is not part of the program itself, but can help
    us catch errors or offer guidance. Annotations have no direct effect on the operation
    of the code they annotate.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是我们可以向程序添加元数据的一种方式。这些元数据可以包括我们正在开发的类的版本信息。这在类被弃用或者我们正在重写某个方法的情况下非常有用。这样的元数据不是程序本身的一部分，但可以帮助我们捕捉错误或提供指导。注解对其注释的代码的操作没有直接影响。
- en: Let's look at a scenario. How do we ensure that we are overriding a certain
    method and not creating another completely different method? When overriding a
    method, a single mistake such as using a different return type will cause the
    method to not be overridden anymore. Such a mistake is easy to make but can lead
    to software bugs later on if not taken care of early in the software development
    stages. How, then, do we enforce overriding? The answer, as you might have already
    guessed, is using annotations.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个场景。我们如何确保我们正在重写某个方法而不是创建另一个完全不同的方法？当重写方法时，一个错误，比如使用不同的返回类型，将导致该方法不再被重写。这样的错误很容易犯，但如果在软件开发阶段没有及时处理，后来可能会导致软件错误。那么，我们如何强制重写？答案，你可能已经猜到了，就是使用注解。
- en: The @ character indicates to the compiler that what follows is an annotation.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '@字符告诉编译器接下来是一个注解。'
- en: 'Let''s enforce overriding in our `Student` class with an annotation:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的`Student`类中使用注解来强制重写：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that we have added the `@Override` line above the method name to indicate
    that the method is overridden from the superclass. This annotation will be checked
    by the compiler when you're compiling the program and it will immediately know
    that we are trying to override this method. It will check whether this method
    exists in the superclass and whether the overriding has been done correctly. If
    it hasn't, it will report an error to indicate that the method is not correct.
    This, in a way, will have prevented us from making a mistake.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在方法名称上方添加了`@Override`行，以指示该方法是从超类中重写的。当编译程序时，编译器将检查此注解，并立即知道我们正在尝试重写此方法。它将检查此方法是否存在于超类中，以及重写是否已正确完成。如果没有，它将报告错误以指示该方法不正确。这在某种程度上将防止我们犯错。
- en: 'Java contains built-in annotations, and you can also create your own. Annotations
    can be applied to declarations of classes, properties, methods, and other program
    elements. When used on a declaration, each annotation appears, by convention,
    on its own line. Let''s look at a few examples of the built-in annotations in
    Java:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Java包含内置注解，您也可以创建自己的注解。注解可以应用于类、属性、方法和其他程序元素的声明。在声明上使用时，每个注解按照惯例出现在自己的一行上。让我们看一些Java中内置注解的例子：
- en: '![Table 4.1: Table with different annotations and their use](img/C09581_Table_04_01.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![表4.1：不同注解及其用途的表格](img/C09581_Table_04_01.jpg)'
- en: 'Table 4.1: Table with different annotations and their use'
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 表4.1：不同注解及其用途的表格
- en: Creating Your Own Annotation Types
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建您自己的注解类型
- en: 'Annotations are created using the **interface** keyword. Let''s declare an
    annotation so that we can add the author information of a class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是使用**interface**关键字创建的。让我们声明一个注解，以便我们可以添加类的作者信息：
- en: '[PRE37]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This annotation accepts the name of the author and the date. We can then use
    this annotation in our `Student` class:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此注释接受作者的姓名和日期。然后我们可以在我们的`Student`类中使用这个注释：
- en: '[PRE38]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can replace the name and date with your values in the preceding example.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在上面的示例中用您的值替换名称和日期。
- en: References
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用
- en: As you work with objects, it is important that you understand **references**.
    A reference is an address that indicates where an object's variables and methods
    are stored.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用对象时，重要的是您了解**引用**。引用是一个地址，指示对象的变量和方法存储在哪里。
- en: When we assign objects to variables or pass them to methods as parameters, we
    aren't actually passing the object itself or its copy – we are passing references
    to the objects themselves in memory.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将对象分配给变量或将它们作为参数传递给方法时，我们实际上并没有传递对象本身或其副本 - 我们传递的是对象本身在内存中的引用。
- en: To better understand how references work, let's illustrate this with an example.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解引用的工作原理，让我们举个例子。
- en: 'Following is an example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个例子：
- en: 'Create a new class called `Rectangle`, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Rectangle`的新类，如下所示：
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output is as follows::'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '[PRE40]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here is a summary of what happens in the preceding program:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面程序中发生的事情的总结：
- en: We create two variables, `r1` and `r2`, of type `Rectangle`.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了两个类型为`Rectangle`的变量`r1`和`r2`。
- en: A new `Rectangle` object is assigned to `r1`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个新的`Rectangle`对象被赋给`r1`。
- en: The value of `r1` is assigned to `r2`.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`r1`的值被赋给`r2`。'
- en: The width and height of `r2` are changed.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`r2`的宽度和高度被改变。'
- en: The values of the two objects are finally printed.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终打印了这两个对象的值。
- en: 'You might have expected the values of `r1` and `r2` to have different values.
    However, the output says otherwise. This is because when we used `r2 = r1 ,` we
    created a reference from `r2` to `r1` instead of creating `r2` as a new object
    copied from `r1`. That is, `r2` points to the same object that was pointed to
    by `r1`. Either variable can be used to refer to the object and change its variables:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望`r1`和`r2`的值不同。然而，输出结果却不是这样。这是因为当我们使用`r2 = r1`时，我们创建了一个从`r2`到`r1`的引用，而不是创建一个从`r1`复制的新对象`r2`。也就是说，`r2`指向了`r1`所指向的相同对象。任何一个变量都可以用来引用对象并改变它的变量：
- en: '![Figure 4.9: Representation of objects r1, r2](img/C09581_Figure_04_09.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：对象r1，r2的表示](img/C09581_Figure_04_09.jpg)'
- en: 'Figure 4.8: Representation of objects r1, r2'
  id: totrans-276
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4.8：对象r1，r2的表示
- en: 'If you want `r2` to refer to a new object, use the following code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让`r2`引用一个新对象，使用以下代码：
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: References in Java become particularly important when arguments are passed to
    methods.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，引用在参数传递给方法时变得特别重要。
- en: Note
  id: totrans-280
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: There are no explicit pointers or pointer arithmetic in Java, as there is in
    C and C++. By using references, however, most pointer capabilities are duplicated
    without many of their drawbacks.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中没有显式指针或指针算术，就像C和C++中一样。然而，通过使用引用，大多数指针功能被复制，而不带有许多它们的缺点。
- en: 'Activity 15: Understanding Inheritance and Polymorphism in Java'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 活动15：理解Java中的继承和多态
- en: 'Scenario: Imagine we want our `Animals` class we created in Activity one to
    be more object oriented. That way, it would be easier to maintain it and scale
    it in the future in case our farm needs to.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 场景：想象我们希望我们在活动一中创建的`Animals`类更加面向对象。这样，以后如果我们的农场需要，它将更容易维护和扩展。
- en: 'Objective: We are going to create classes to inherit from our `Animals` class,
    implement overloaded and overridden methods, and create an annotation to version
    our classes.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：我们将创建类来继承我们的`Animals`类，实现重载和重写的方法，并创建一个注解来对我们的类进行版本控制。
- en: 'Aim: To understand how to inherit from a class, overload and override methods,
    and create annotations in Java.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 目标：理解如何从一个类继承，重载和重写方法，并在Java中创建注解。
- en: 'Procedure:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤：
- en: Open up the `Animals` project we created earlier.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们之前创建的`Animals`项目。
- en: In the project, create a new file named `Cat.java` in the `src/` folder.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中，在`src/`文件夹中创建一个名为`Cat.java`的新文件。
- en: Open `Cat.java` and inherit from the `Animals` class.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Cat.java`并从`Animals`类继承。
- en: In it, create a new instance of the `Cat` class and set the family to "`Cat`",
    the name to "`Puppy`", `ears` to two, `eyes` to two, and `legs` to four. Don't
    redefine these methods and fields – instead, use the inherited ones from the `Animals`
    class.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中，创建`Cat`类的一个新实例，并将家庭设置为"`Cat`"，名称设置为"`Puppy`"，`ears`设置为两个，`eyes`设置为两个，`legs`设置为四个。不要重新定义这些方法和字段
    - 而是使用从`Animals`类继承的方法。
- en: Print the `family`, `name`, `ears`, `legs`, and `eyes`. What is the output?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印`family`，`name`，`ears`，`legs`和`eyes`。输出是什么？
- en: Note
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 322.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在第322页找到。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this lesson, we have learned that classes are blueprints from which we can
    create objects, while objects are instances of a class and provide a specific
    implementation of that class. A class can be public, private, or protected. A
    class has a default constructor that takes no parameters. We can have user-defined
    constructors in Java. The `this` keyword is used to refer to the current instance
    of a class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在这节课中，我们学到了类是可以创建对象的蓝图，而对象是类的实例，并提供了该类的具体实现。类可以是公共的、私有的或受保护的。类有一个不带参数的默认构造函数。我们可以在Java中有用户定义的构造函数。`this`关键字用于引用类的当前实例。
- en: We then learned that inheritance is a property where a subclass inherits the
    properties of a superclass.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着学习了继承是一个子类继承了父类的属性的特性。
- en: We went on to study overloading, polymorphism, annotation, and references in
    Java.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续学习了Java中的重载、多态、注解和引用。
- en: In the next lesson, we will have a look at the use of interfaces and the `Object`
    class in Java.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节课中，我们将看一下在Java中使用接口和`Object`类。
