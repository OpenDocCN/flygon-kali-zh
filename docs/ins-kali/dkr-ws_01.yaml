- en: 1\. Running My First Docker Container
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 运行我的第一个Docker容器
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn the basics of Docker and containerization, and
    explore the benefits of migrating traditional multi-tier applications to a fast
    and reliable containerized infrastructure. By the end of this chapter, you will
    have a firm understanding of the benefits of running containerized applications
    as well as the basics of running containers using the `docker run` command. This
    chapter will not only introduce you to the fundamentals of Docker but also provide
    a solid understanding of the Docker concepts that will be built upon throughout
    this workshop.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习Docker和容器化的基础知识，并探索将传统的多层应用程序迁移到快速可靠的容器化基础设施的好处。通过本章的学习，您将对运行容器化应用程序的好处有深入的了解，以及使用`docker
    run`命令运行容器的基础知识。本章不仅将向您介绍Docker的基础知识，还将为您提供对本次研讨会中将要构建的Docker概念的扎实理解。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: In recent years, technological innovations across all industries are rapidly
    increasing the rate at which software products are delivered. Due to trends in
    technology, such as agile development (a methodology for quickly writing software)
    and continuous integration pipelines, which enable the rapid delivery of software,
    operations' staff have recently struggled to build infrastructure quickly enough
    to quell the increasing demand. In order to keep up, many organizations have opted
    to migrate to cloud infrastructure.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，各行各业的技术创新迅速增加了软件产品交付的速度。由于技术趋势，如敏捷开发（一种快速编写软件的方法）和持续集成管道，使软件的快速交付成为可能，运营人员最近一直在努力快速构建基础设施，以满足不断增长的需求。为了跟上发展，许多组织选择迁移到云基础设施。
- en: Cloud infrastructure provides hosted virtualization, network, and storage solutions
    that can be leveraged on a pay-as-you-go model. These providers allow any organization
    or individual to sign up and receive access to infrastructure that would traditionally
    require large amounts of space and expensive hardware to implement on-site or
    in a data center. Cloud providers such as Amazon Web Services and Google Cloud
    Platform provide easy-to-use APIs that allow for the creation of large fleets
    of **virtual machines** (or **VMs**) almost instantly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 云基础设施提供了托管的虚拟化、网络和存储解决方案，可以按需使用。这些提供商允许任何组织或个人注册并获得传统上需要大量空间和昂贵硬件才能在现场或数据中心实施的基础设施。云提供商，如亚马逊网络服务和谷歌云平台，提供易于使用的API，允许几乎立即创建大量的虚拟机（或VMs）。
- en: Deploying infrastructure to the cloud provided a solution to many of the dilemmas
    that organizations were facing with traditional infrastructure solutions, but
    also created additional problems related to managing costs in running these services
    at scale. How do companies manage the on-going monthly and yearly expenditures
    of running expensive servers 24 hours a day, 7 days a week?
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 将基础设施部署到云端为组织面临的许多传统基础设施解决了难题，但也带来了与在规模上运行这些服务相关的管理成本的额外问题。公司如何管理全天候运行昂贵服务器的持续月度和年度支出？
- en: VMs revolutionized infrastructure by leveraging hypervisors to create smaller
    servers on top of larger hardware. The downside of virtualization was how resource-intensive
    it was to run a VM. VMs themselves look, act, and feel like real bare metal hardware
    since hypervisors such as Zen, KVM, and VMWare allocate resources to boot and
    manage an entire operating system image. The dedicated resources associated with
    VMs make them large and somewhat difficult to manage. Moving VMs between an on-premises
    hypervisor and the cloud could potentially mean moving hundreds of gigabytes worth
    of data per VM.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机通过利用hypervisors在较大的硬件之上创建较小的服务器，从而革新了基础设施。虚拟化的缺点在于运行虚拟机的资源密集程度。虚拟机本身看起来、行为和感觉都像真正的裸金属硬件，因为hypervisors（如Zen、KVM和VMWare）分配资源来引导和管理整个操作系统镜像。与虚拟机相关的专用资源使其变得庞大且难以管理。在本地hypervisor和云之间迁移虚拟机可能意味着每个虚拟机移动数百GB的数据。
- en: To provide a greater degree of automation, make better use of compute density,
    and optimize their cloud presence, companies find themselves moving toward containerization
    and microservices architectures as a solution. Containers provide process-level
    isolation or running software services within isolated sections of the kernel
    of the host operating system. Instead of running an entire operating system kernel
    to provide isolation, containers can share the kernel of the host operating system
    to run multiple software applications. This is accomplished in the Linux kernel
    through features known as **control groups** (or **cgroups**) and **namespace
    isolation**. On a single VM or bare metal machine, a user could potentially run
    hundreds of containers that run individual software application instances on a
    single host operating system.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更高程度的自动化，更好地利用计算密度，并优化他们的云存在，公司发现自己朝着容器化和微服务架构的方向迈进作为解决方案。容器提供了进程级别的隔离，或者在主机操作系统内核的隔离部分内运行软件服务。与运行整个操作系统内核以提供隔离不同，容器可以共享主机操作系统的内核来运行多个软件应用程序。这是通过Linux内核中的控制组（或cgroups）和命名空间隔离等功能实现的。在单个虚拟机或裸金属机器上，用户可能会运行数百个容器，这些容器在单个主机操作系统上运行各自的软件应用程序实例。
- en: This is in stark contrast to a traditional VM architecture. Generally, when
    we deploy a VM, we purpose that machine to run a single server or a minor subset
    of services. This creates a waste of valuable CPU cycles that could be allocated
    to other tasks and serve other requests. We could, in theory, resolve this dilemma
    by installing multiple services on a single VM. However, this can create a tremendous
    amount of confusion regarding which machine is running which service. It also
    places the ownership of hosting multiple software installations and backend dependencies
    in a single operating system.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统的虚拟机架构形成鲜明对比。通常，当我们部署虚拟机时，我们目的是让该机器运行单个服务器或一小部分服务。这会导致宝贵的CPU周期的浪费，这些周期本可以分配给其他任务并提供其他请求。理论上，我们可以通过在单个虚拟机上安装多个服务来解决这个困境。然而，这可能会在关于哪台机器运行哪项服务方面造成极大的混乱。它还将多个软件安装和后端依赖项的托管权放在单个操作系统中。
- en: A containerized microservices approach solves this by allowing the container
    runtime to schedule and run containers on the host operating system. The container
    runtime does not care what application is running inside the container, but rather
    that a container exists and can be downloaded and executed on the host operating
    system. It doesn't matter if the application running inside the container is a
    Go web API, a simple Python script, or a legacy Cobol application. Since the container
    is in a standard format, the container runtime will download the container image
    and execute the software within it. Throughout this book, we will study the Docker
    container runtime and learn the basics of running containers both locally and
    at scale.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化的微服务方法通过允许容器运行时在主机操作系统上调度和运行容器来解决了这个问题。容器运行时不关心容器内运行的是什么应用程序，而是关心容器是否存在，并且可以在主机操作系统上下载和执行。容器内运行的应用程序是Go
    web API、简单的Python脚本还是传统的Cobol应用程序都无关紧要。由于容器是以标准格式存在的，容器运行时将下载容器镜像并在其中执行软件。在本书中，我们将学习Docker容器运行时，并学习在本地和规模化运行容器的基础知识。
- en: Docker is a container runtime that was developed in 2013 and designed to take
    advantage of the process isolation features of the Linux kernel. What separated
    Docker from other container runtime implementations is that Docker developed a
    system to not only run containers but also to build and push containers to container
    repositories. This innovation led to the concept of container immutability—only
    changing containers by building and pushing new versions of the containers when
    software changes occur.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个容器运行时，于2013年开发，旨在利用Linux内核的进程隔离功能。与其他容器运行时实现不同的是，Docker开发了一个系统，不仅可以运行容器，还可以构建和推送容器到容器存储库。这一创新引领了容器不可变性的概念——只有在软件发生变化时才通过构建和推送容器的新版本来改变容器。
- en: 'As seen in the following diagram (*Figure 1.1*), we have a series of containerized
    applications deployed across two Docker servers. Between two server instances,
    seven containerized applications have been deployed. Each container hosts its
    own set of binaries, libraries, and self-contained dependencies. When Docker runs
    a container, the container itself hosts everything that it requires to function
    properly. It is even possible to deploy different versions of the same application
    framework since each container exists in its own kernel space:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示（*图1.1*），我们在两个Docker服务器上部署了一系列容器化应用程序。在两个服务器实例之间，部署了七个容器化应用程序。每个容器都托管着自己所需的二进制文件、库和自包含的依赖关系。当Docker运行一个容器时，容器本身承载了其正常运行所需的一切。甚至可以部署同一应用程序框架的不同版本，因为每个容器都存在于自己的内核空间中。
- en: '![Figure 1.1: Seven containers running across two different container servers'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1：在两个不同的容器服务器上运行的七个容器'
- en: '](image/B15021_01_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_01_01.jpg)'
- en: 'Figure 1.1: Seven containers running across two different container servers'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1：在两个不同的容器服务器上运行的七个容器
- en: In this chapter, you will get to know various advantages provided by Docker
    with the help of containerization. You will also learn the basics of running containers
    using the `docker run` command.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将通过容器化的帮助了解Docker提供的各种优势。您还将学习使用`docker run`命令来运行容器的基础知识。
- en: Advantages of Using Docker
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker的优势
- en: In a traditional VM approach, code changes would require operations folk or
    a configuration management tool to access that machine and install a new version
    of the software. The principle of immutable containers means that when a code
    change occurs, a new version of that container image will be built and created
    as a new artifact. If this change needed to be rolled back, it would be as easy
    as downloading and restarting the older version of the container image.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的虚拟机方法中，代码更改需要运维人员或配置管理工具访问该机器并安装软件的新版本。不可变容器的原则意味着当代码更改发生时，将构建新版本的容器映像，并创建为新的构件。如果需要回滚此更改，只需下载并重新启动容器映像的旧版本就可以了。
- en: Leveraging a containerized approach also enables software development teams
    to predictably and reliably test applications in various scenarios and multiple
    environments locally. Since the Docker runtime environment provides a standard
    execution environment, software developers can quickly recreate issues and debug
    problems easily. Because of container immutability, developers can be assured
    that the same code is running across all environments because the same Docker
    images can be deployed in any environment. This means that configuration variables
    such as invalid database connection strings, API credentials, or other environment-specific
    variance are the primary source of failures. This eases the operational burden
    and provides an unparalleled degree of efficiency and reusability.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 利用容器化方法还使软件开发团队能够在各种场景和多个环境中可预测和可靠地测试应用程序。由于Docker运行时环境提供了标准的执行环境，软件开发人员可以快速重现问题并轻松调试问题。由于容器的不可变性，开发人员可以确保相同的代码在所有环境中运行，因为相同的Docker映像可以部署在任何环境中。这意味着配置变量，如无效的数据库连接字符串、API凭据或其他特定于环境的差异，是故障的主要来源。这减轻了运维负担，并提供了无与伦比的效率和可重用性。
- en: Another advantage of using Docker is that containerized applications are traditionally
    quite small and flexible compared to their traditional infrastructure counterparts.
    Instead of providing a full operating system kernel and execution environment,
    containers generally only provide the necessary libraries and packages that are
    required to run an application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker的另一个优势是，与传统基础设施相比，容器化应用程序通常更小、更灵活。容器通常只提供运行应用程序所需的必要库和软件包，而不是提供完整的操作系统内核和执行环境。
- en: When building Docker containers, developers are no longer at the mercy of packages
    and tools installed on the host operating system, which may differ between environments.
    They can pack inside a container image only the exact versions of libraries and
    utilities that the application requires to run. When deployed onto a production
    machine, developers and operations teams are no longer concerned about what hardware
    or operating system version the container is running on, as long as their container
    is running.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Docker容器时，开发人员不再受限于主机操作系统上安装的软件包和工具，这些可能在不同环境之间有所不同。他们可以将容器映像中仅包含应用程序运行所需的确切版本的库和实用程序。在部署到生产机器上时，开发人员和运维团队不再关心容器运行在什么硬件或操作系统版本上，只要他们的容器在运行就可以了。
- en: For example, as of January 1, 2020, Python 2 is no longer supported. As a result,
    many software repositories are phasing out Python 2 packages and runtimes. Leveraging
    a containerized approach, you can continue to run legacy Python 2 applications
    in a controlled, secure, and reliable fashion until the legacy applications can
    be rewritten. This removes the fear of worrying about installing operating-system-level
    patches, which may remove Python 2 support and break legacy application stacks.
    These Python 2 containers can even run in parallel on Docker servers with Python
    3 applications to provide precise testing as these applications are migrated to
    the new modernized stacks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，截至2020年1月1日，Python 2不再受支持。因此，许多软件仓库正在逐步淘汰Python 2包和运行时。利用容器化方法，您可以继续以受控、安全和可靠的方式运行传统的Python
    2应用程序，直到这些传统应用程序可以被重写。这消除了担心安装操作系统级补丁的恐惧，这些补丁可能会移除Python 2支持并破坏传统应用程序堆栈。这些Python
    2容器甚至可以与Docker服务器上的Python 3应用程序并行运行，以在这些应用程序迁移到新的现代化堆栈时提供精确的测试。
- en: Now that we have taken a look at what Docker is and how it works, we can start
    to work with Docker to get an idea of how process isolation differs from virtualization
    and other similar technologies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Docker是什么以及它是如何工作的，我们可以开始使用Docker来了解进程隔离与虚拟化和其他类似技术的区别。
- en: Note
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before we can begin to run containers, you must first have a working installation
    of Docker on your local development workstation. For details, please review the
    *Preface* section of this book.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始运行容器之前，您必须在本地开发工作站上安装Docker。有关详细信息，请查看本书的*前言*部分。
- en: Docker Engine
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker引擎
- en: '**Docker Engine** is the interface that provides access to the process isolation
    features of the Linux kernel. Since only Linux exposes the features that allow
    containers to run, Windows and macOS hosts leverage a Linux VM in the background
    to make container execution possible. For Windows and macOS users, Docker provides
    the "**Docker Desktop**" suite of packages that deploy and run this VM in the
    background for you. This allows Docker commands to be executed natively from the
    terminal or PowerShell console of the macOS or Windows host. Linux hosts have
    the privilege of directly executing the Docker Engine natively because modern
    versions of the Linux kernel support `cgroups` and namespace isolation.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker引擎**是提供对Linux内核进程隔离功能的接口。由于只有Linux暴露了允许容器运行的功能，因此Windows和macOS主机利用后台的Linux虚拟机来实现容器执行。对于Windows和macOS用户，Docker提供了“**Docker桌面**”套件，用于在后台部署和运行这个虚拟机。这允许从macOS或Windows主机的终端或PowerShell控制台本地执行Docker命令。Linux主机有特权直接在本地执行Docker引擎，因为现代版本的Linux内核支持`cgroups`和命名空间隔离。'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since Windows, macOS, and Linux have fundamentally different operating system
    architectures in terms of networking and process management, a few of the examples
    in this book (specifically in regard to networking) are sometimes called out as
    having different behaviors depending on the operating system that is running on
    your development workstation. These differences are called out as they occur.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Windows、macOS和Linux在网络和进程管理方面具有根本不同的操作系统架构，本书中的一些示例（特别是在网络方面）有时会根据在您的开发工作站上运行的操作系统而有不同的行为。这些差异会在出现时进行说明。
- en: Docker Engine supports not only the execution of container images but also provides
    built-in mechanisms to build and test container images from source code files
    known as `Dockerfiles`. When container images are built, they can be pushed to
    container **image registries**. An **image registry** is a repository of container
    images from which other Docker hosts can download and execute container images.
    The Docker engine supports running container images, building container images,
    and even hosting container image registries when configured to run as such.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎不仅支持执行容器镜像，还提供了内置机制，可以从源代码文件（称为`Dockerfiles`）构建和测试容器镜像。构建容器镜像后，可以将其推送到容器镜像注册表。**镜像注册表**是容器镜像的存储库，其他Docker主机可以从中下载和执行容器镜像。Docker引擎支持运行容器镜像、构建容器镜像，甚至在配置为这样运行时托管容器镜像注册表。
- en: When a container is started, Docker will, by default, download the container
    image, store it in its local container image cache, and finally execute the container's
    `entrypoint` directive. The `entrypoint` directive is the command that will start
    the primary process of the application. When this process stops or goes down,
    the container will also cease to run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，Docker默认会下载容器镜像，将其存储在本地容器镜像缓存中，最后执行容器的`entrypoint`指令。`entrypoint`指令是启动应用程序主要进程的命令。当这个进程停止或关闭时，容器也将停止运行。
- en: Depending on the application running inside the container, the `entrypoint`
    directive might be a long-running server daemon that is available all the time,
    or it could be a short-lived script that will naturally stop when the execution
    is completed. Alternatively, many containers execute `entrypoint` scripts that
    complete a series of setup steps before starting the primary process, which could
    be long- or short-lived.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 根据容器内运行的应用程序，`entrypoint`指令可能是长期运行的服务器守护程序，始终可用，或者可能是一个短暂的脚本，在执行完成后自然停止。另外，许多容器执行`entrypoint`脚本，在启动主要进程之前完成一系列设置步骤，这可能是长期或短期的。
- en: Before running any container, it is a best practice to first understand the
    type of application that will be running inside the container and whether it will
    be a short-lived execution or a long-running server daemon.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行任何容器之前，最好先了解将在容器内运行的应用程序类型，以及它是短暂执行还是长期运行的服务器守护程序。
- en: Running Docker Containers
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Docker容器
- en: Best practices for building containers and microservices architecture dictate
    that a container should only run a single process. Keeping this principle in mind,
    we can design containers that are easy to build, troubleshoot, scale, and deploy.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 构建容器和微服务架构的最佳实践规定，一个容器应该只运行一个进程。牢记这一原则，我们可以设计容器，使其易于构建、故障排除、扩展和部署。
- en: The life cycle of a container is defined by the state of the container and the
    running processes within it. A container can be in a running or stopped state
    based on actions taken by the operator, the container orchestrator, or the state
    of the application running inside the container itself. For example, an operator
    can manually stop or start a container using the `docker stop` or `docker start`
    **command-line interface** (**CLI**) interface commands. Docker itself may automatically
    stop or restart a container if it detects that the container has entered an unhealthy
    state. Furthermore, if the primary application running inside the container fails
    or stops, the running container instance should also stop. Many container runtime
    platforms such as Docker even provide automated mechanisms to restart containers
    that enter a stopped state automatically. Many container platforms use this principle
    to build job and task execution functionality.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的生命周期由容器的状态和其中运行的进程定义。根据操作员、容器编排器或容器内部运行的应用程序的状态，容器可以处于运行或停止状态。例如，操作员可以使用`docker
    stop`或`docker start`命令手动停止或启动容器。如果Docker检测到容器进入不健康状态，它甚至可能自动停止或重新启动容器。此外，如果容器内部运行的主要应用程序失败或停止，运行的容器实例也应该停止。许多容器运行时平台，如Docker，甚至提供自动机制来自动重新启动进入停止状态的容器。许多容器平台利用这一原则构建作业和任务执行功能。
- en: 'Since containers terminate when the primary process within the container finishes,
    containers are excellent platforms to execute scripts and other types of jobs
    that have an indefinite lifespan. The following *Figure 1.2* illustrates the life
    cycle of a typical container:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由于容器在容器内部的主要进程完成时终止，容器是执行脚本和其他类型的具有无限寿命的作业的优秀平台。下面的*图1.2*说明了典型容器的生命周期：
- en: '![Figure 1.2: The life cycle of a typical container'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.2：典型容器的生命周期'
- en: '](image/B15021_01_02.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_01_02.jpg)'
- en: 'Figure 1.2: The life cycle of a typical container'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2：典型容器的生命周期
- en: Once you have Docker downloaded and installed on your targeted operating system,
    you can start running containers. The Docker CLI has an aptly named `docker run`
    command specifically for starting and running Docker containers. As we learned
    previously, containers provide isolation from the rest of the applications and
    processes running on the system. Due to this fact, the life cycle of a Docker
    container is determined by the primary process running inside that container.
    When a container stops, Docker may attempt to restart the container to ensure
    continuity of the application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在目标操作系统上下载并安装了Docker，就可以开始运行容器。Docker CLI具有一个名为`docker run`的命令，专门用于启动和运行Docker容器。正如我们之前学到的，容器提供了与系统上运行的其他应用程序和进程隔离的功能。由于这个事实，Docker容器的生命周期由容器内部运行的主要进程决定。当容器停止时，Docker可能会尝试重新启动容器，以确保应用程序的连续性。
- en: To see the running containers on our host system, we will also be leveraging
    the `docker ps` command. The `docker ps` command is similar to the Unix-style
    `ps` command that is used to show the running processes on a Linux or Unix-based
    operating system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看主机系统上正在运行的容器，我们还将利用`docker ps`命令。`docker ps`命令类似于Unix风格的`ps`命令，用于显示Linux或基于Unix的操作系统上运行的进程。
- en: Remember that when Docker first runs a container, if it does not have the container
    image stored in its local cache, it will download the container image from a container
    image registry. To view the container images that are stored locally, use the
    `docker images` command.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当Docker首次运行容器时，如果它在本地缓存中没有存储容器镜像，它将从容器镜像注册表中下载容器镜像。要查看本地存储的容器镜像，使用`docker
    images`命令。
- en: The following exercise will demonstrate how to use the `docker run`, `docker
    ps`, and `docker images` commands to start and view the status of a simple `hello-world`
    container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下练习将演示如何使用`docker run`、`docker ps`和`docker images`命令来启动和查看简单的`hello-world`容器的状态。
- en: 'Exercise 1.01: Running the hello-world Container'
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.01：运行hello-world容器
- en: A simple "Hello World" application is generally the first line of code a developer
    writes when learning software development or starting a new programming language,
    and containerization is no different. Docker has published a `hello-world` container
    that is extremely small in size and simple to execute. This container demonstrates
    the nature of containers running a single process with an indefinite lifespan.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的“Hello World”应用程序通常是开发人员在学习软件开发或开始新的编程语言时编写的第一行代码，容器化也不例外。Docker发布了一个非常小且简单执行的`hello-world`容器。该容器演示了运行单个具有无限寿命的进程的容器的特性。
- en: 'In this exercise, you will use the `docker run` command to start the `hello-world`
    container and the `docker ps` command to view the status of the container after
    it has finished execution. This will provide a basic overview of running containers
    in your local development environment:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`docker run`命令启动`hello-world`容器，并使用`docker ps`命令查看容器在执行完成后的状态。这将为你提供一个在本地开发环境中运行容器的基本概述。
- en: 'Enter the `docker run` command in a Bash terminal or PowerShell window. This
    instructs Docker to run a container called `hello-world`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Bash终端或PowerShell窗口中输入`docker run`命令。这会指示Docker运行一个名为`hello-world`的容器：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Your shell should return output similar to the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你的shell应该返回类似以下的输出：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What just happened? You told Docker to run the container, `hello-world`. So,
    first, Docker will look in its local container cache for a container by that same
    name. If it doesn't find one, it will look to a container registry on the internet
    in an attempt to satisfy the command. By simply specifying the name of the container,
    Docker will, by default, query Docker Hub for a published container image by that
    name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚发生了什么？你告诉Docker运行名为`hello-world`的容器。所以，首先，Docker会在本地容器缓存中查找具有相同名称的容器。如果找不到，它将尝试在互联网上的容器注册表中查找以满足命令。通过简单地指定容器的名称，Docker将默认查询Docker
    Hub以获取该名称的已发布容器镜像。
- en: As you can see, it was able to find a container called the `library/hello-world`
    and began the process of pulling in the container image layer by layer. You will
    get a closer look into container images and layers in *Chapter 2*, *Getting Started
    with Dockerfiles*. Once the image has fully downloaded, Docker runs the image,
    which displays the `Hello from Docker` output. Since the primary process of this
    image is simply to display that output, the container then stops itself and ceases
    to run after the output displays.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，它能够找到一个名为`library/hello-world`的容器，并开始逐层拉取容器镜像。在*第2章*《使用Dockerfiles入门》中，你将更深入地了解容器镜像和层。一旦镜像完全下载，Docker运行该镜像，显示`Hello
    from Docker`输出。由于该镜像的主要进程只是显示该输出，容器在显示输出后停止并停止运行。
- en: 'Use the `docker ps` command to see what containers are running on your system.
    In your Bash or PowerShell terminal, type the following command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令查看系统上正在运行的容器。在Bash或PowerShell终端中，输入以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will return output similar to the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回类似以下的输出：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The output of the `docker ps` command is empty because it only shows currently
    running containers by default. This is similar to the Linux/Unix `ps` command,
    which only shows the running processes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker ps`命令的输出为空，因为它默认只显示当前正在运行的容器。这类似于Linux/Unix的`ps`命令，它只显示正在运行的进程。'
- en: 'Use the `docker ps -a` command to display all the containers, even the stopped
    ones:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps -a`命令显示所有容器，甚至是已停止的容器：
- en: '[PRE4]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the output returned, you should see the `hello-world` container instance:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的输出中，你应该看到`hello-world`容器实例：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, Docker gave the container a unique container ID. It also displays
    the `IMAGE` that was run, the `COMMAND` within that image that was executed, the
    `TIME` it was created, and the `STATUS` of the process running that container,
    as well as a unique human-readable name. This particular container was created
    approximately one minute ago, executed the program `/hello`, and ran successfully.
    You can tell that the program ran and executed successfully since it resulted
    in an `Exited (0)` code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Docker给容器分配了一个唯一的容器ID。它还显示了运行的`IMAGE`，在该映像中执行的`COMMAND`，创建的`TIME`，以及运行该容器的进程的`STATUS`，以及一个唯一的可读名称。这个特定的容器大约一分钟前创建，执行了程序`/hello`，并成功运行。你可以看出程序运行并成功执行，因为它产生了一个`Exited
    (0)`的代码。
- en: 'You can query your system to see what container images Docker cached locally.
    Execute the `docker images` command to view the local cache:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以查询你的系统，看看Docker本地缓存了哪些容器映像。执行`docker images`命令来查看本地缓存：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The returned output should display the locally cached container images:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出应该显示本地缓存的容器映像：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only image cached so far is the `hello-world` container image. This image
    is running the `latest` version, which was created 3 months ago, and has a size
    of 13.3 kilobytes. From the preceding output, you know that this Docker image
    is incredibly slim and that developers haven't published a code change for this
    image in 3 months. This output can be very helpful for troubleshooting differences
    between software versions in the real world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，唯一缓存的映像是`hello-world`容器映像。这个映像正在运行`latest`版本，创建于3个月前，大小为13.3千字节。从前面的输出中，你知道这个Docker映像非常精简，开发者在3个月内没有发布过这个映像的代码更改。这个输出对于排除现实世界中软件版本之间的差异非常有帮助。
- en: Since you simply told Docker to run the `hello-world` container without specifying
    a version, Docker will pull the latest version by default. You can specify different
    versions by specifying a tag in your `docker run` command. For example, if the
    `hello-world` container image had a version `2.0`, you could run that version
    using the `docker run hello-world:2.0` command.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你只是告诉Docker运行`hello-world`容器而没有指定版本，Docker将默认拉取最新版本。你可以通过在`docker run`命令中指定标签来指定不同的版本。例如，如果`hello-world`容器映像有一个版本`2.0`，你可以使用`docker
    run hello-world:2.0`命令运行该版本。
- en: Imagine for a minute that the container was a bit more complex than a simple
    `hello-world` application. Imagine your colleague wrote software with the requirement
    to download very specific versions of many third-party libraries. If you run this
    application traditionally, you would have to download the runtime environment
    for the language they develop in, plus all of the third-party libraries, as well
    as detailed instructions on how to build and execute their code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果容器比一个简单的`hello-world`应用程序复杂一些。想象一下，你的同事编写了一个软件，需要下载许多第三方库的非常特定的版本。如果你传统地运行这个应用程序，你将不得不下载他们开发语言的运行环境，以及所有的第三方库，以及详细的构建和执行他们的代码的说明。
- en: However, if they publish a Docker image of their code to an internal Docker
    registry, all they have to provide to you is the `docker run` syntax for running
    the container. Since you have Docker, the container image will run the same no
    matter what your underlying platform is. The container image itself already has
    the libraries and runtime details baked in.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果他们将他们的代码的Docker镜像发布到内部Docker注册表，他们只需要向您提供运行容器的`docker run`语法。由于您拥有Docker，无论您的基础平台是什么，容器图像都将运行相同。容器图像本身已经包含了库和运行时的详细信息。
- en: 'If you execute the same `docker run` command over again, then, for each `docker
    run` command a user inputs, a new container instance will be created. It should
    be noted that one of the benefits of containerization is the ability to easily
    run multiple instances of a software application. To see how Docker handles multiple
    container instances, run the same `docker run` command again to create another
    instance of the `hello-world` container:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您再次执行相同的`docker run`命令，那么对于用户输入的每个`docker run`命令，都将创建一个新的容器实例。值得注意的是，容器化的一个好处是能够轻松运行多个软件应用的实例。为了看到Docker如何处理多个容器实例，再次运行相同的`docker
    run`命令，以创建`hello-world`容器的另一个实例：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You should see the following output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that, this time, Docker did not have to download the container image
    from Docker Hub again. This is because you now have that container image cached
    locally. Instead, Docker was able to directly run the container and display the
    output to the screen. Let's see what your `docker ps -a` output looks like now.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这一次，Docker不必再次从Docker Hub下载容器图像。这是因为您现在在本地缓存了该容器图像。相反，Docker能够直接运行容器并将输出显示在屏幕上。让我们看看您的`docker
    ps -a`输出现在是什么样子。
- en: 'In your terminal, run the `docker ps -a` command again:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的终端中，再次运行`docker ps -a`命令：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the output, you should see that the second instance of this container image
    has completed its execution and entered a stopped state, as indicated by `Exit
    (0)` in the `STATUS` column of the output:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您应该看到这个容器图像的第二个实例已经完成了执行并进入了停止状态，如输出的`STATUS`列中的`Exit (0)`所示：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You now have a second instance of this container showing in your output. Each
    time you execute the `docker run` command, Docker will create a new instance of
    that container with its attributes and data. You can run as many instances of
    a container as your system resources will allow. You created one instance in this
    example 20 minutes ago. The second instance you created 2 minutes ago.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在在输出中看到了这个容器的第二个实例。每次执行`docker run`命令时，Docker都会创建该容器的一个新实例，具有其属性和数据。您可以运行尽可能多的容器实例，只要您的系统资源允许。在这个例子中，您20分钟前创建了一个实例。您2分钟前创建了第二个实例。
- en: 'Check the base image again by executing the `docker images` command once more:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行`docker images`命令，检查基本图像：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The returned output will show the single base image that Docker created two
    running instances from:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出将显示Docker从单个基本图像创建的两个运行实例：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this exercise, you used `docker run` to start the `hello-world` container.
    To accomplish this, Docker downloaded the image from the Docker Hub registry and
    executed it in the Docker Engine. Once the base image was downloaded, you could
    create as many instances of that container as you wanted using subsequent `docker
    run` commands.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您使用`docker run`启动了`hello-world`容器。为了实现这一点，Docker从Docker Hub注册表下载了图像，并在Docker
    Engine中执行了它。一旦基本图像被下载，您可以使用后续的`docker run`命令创建任意数量的该容器的实例。
- en: Docker container management is more complex than simply starting and viewing
    the status of containers running in your development environment. Docker also
    supports many other actions that help provide insight into the status of applications
    running on Docker hosts. In the next section, we will learn how to manage Docker
    containers using different commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器管理比在开发环境中仅仅启动和查看容器状态更加复杂。Docker 还支持许多其他操作，这些操作有助于了解在 Docker 主机上运行的应用程序的状态。在接下来的部分中，我们将学习如何使用不同的命令来管理
    Docker 容器。
- en: Managing Docker Containers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理 Docker 容器
- en: 'Throughout our container journey, we will be pulling, starting, stopping, and
    removing containers from our local environment quite frequently. Prior to deploying
    a container in a production environment, it is critical that we first run the
    container locally to understand how it functions and what normal behavior looks
    like. This includes starting containers, stopping containers, getting verbose
    details about how the container is running, and, of course, accessing the container
    logs to view critical details about the applications running inside the containers.
    These basic commands are outlined as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的容器之旅中，我们将经常从本地环境中拉取、启动、停止和删除容器。在将容器部署到生产环境之前，我们首先需要在本地运行容器，以了解其功能和正常行为。这包括启动容器、停止容器、获取有关容器运行方式的详细信息，当然还包括访问容器日志以查看容器内运行的应用程序的关键细节。这些基本命令如下所述：
- en: '`docker pull`: This command downloads a container image to the local cache'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker pull`：此命令将容器镜像下载到本地缓存'
- en: '`docker stop`: This command stops a running container instance'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker stop`：此命令停止运行中的容器实例'
- en: '`docker start`: This command starts a container instance that is no longer
    in a running state'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker start`：此命令启动不再处于运行状态的容器实例'
- en: '`docker restart`: This command restarts a running container'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker restart`：此命令重新启动运行中的容器'
- en: '`docker attach`: This command allows users to gain access (or attach) to the
    primary process of a running Docker container instance'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker attach`：此命令允许用户访问（或附加）运行中的 Docker 容器实例的主要进程'
- en: '`docker exec`: This command executes a command inside a running container'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec`：此命令在运行中的容器内执行命令'
- en: '`docker rm`: This command deletes a stopped container'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rm`：此命令删除已停止的容器'
- en: '`docker rmi`: This command deletes a container image'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker rmi`：此命令删除容器镜像'
- en: '`docker inspect`: This command shows verbose details about the state of a container'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker inspect`：此命令显示有关容器状态的详细信息'
- en: Container life cycle management is a critical component of effective container
    management in production environments. Knowing how to investigate running containers
    is critical when looking to evaluate the health of your containerized infrastructure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 容器生命周期管理是生产环境中有效容器管理的关键组成部分。在评估容器化基础设施的健康状况时，了解如何调查运行中的容器是至关重要的。
- en: In the following exercise, we are going to work with these commands individually
    to get an in-depth understanding of how they work and how they can be leveraged
    to provide visibility into the health of your containerized infrastructure.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，我们将逐个使用这些命令，深入了解它们的工作原理以及如何利用它们来了解容器化基础设施的健康状况。
- en: 'Exercise 1.02: Managing Container Life Cycles'
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02：管理容器生命周期
- en: When managing containers in both development and production environments, it
    is critical to understand the status of container instances. Many developers use
    base container images that contain a specific baseline configuration on top of
    which their applications can be deployed. Ubuntu is a commonly used base image
    that users use to package their applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发和生产环境中管理容器时，了解容器实例的状态至关重要。许多开发人员使用包含特定基线配置的基础容器镜像，他们的应用程序可以在其上部署。Ubuntu是一个常用的基础镜像，用户用它来打包他们的应用程序。
- en: Unlike the full operating system image, the Ubuntu base container image is quite
    slim and intentionally leaves out a lot of packages the full operating system
    installation has. Most base images do have package systems that will allow you
    to install any missing packages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 与完整的操作系统镜像不同，Ubuntu基础容器镜像非常精简，故意省略了许多完整操作系统安装中的软件包。大多数基础镜像都有软件包系统，可以让您安装任何缺失的软件包。
- en: Keep in mind that when building container images, you want to keep the base
    images as slim as possible, only installing the most necessary packages. This
    ensures that container images can quickly be pulled and started by Docker hosts.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在构建容器镜像时，您希望尽可能保持基础镜像的精简，只安装最必要的软件包。这样可以确保Docker主机可以快速拉取和启动容器镜像。
- en: 'In this exercise, you will work with the official Ubuntu base container image.
    This image will be used to start container instances that will be used to test
    the various container life cycle management commands, such as `docker pull`, `docker
    start`, and `docker stop`. This container image is useful because the default
    base image allows us to run container instances in long-running sessions to understand
    how the container life cycle management commands function. In this exercise, you
    will also pull the `Ubuntu 18.04` container image and compare it with the `Ubuntu
    19.04` container image:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用官方的Ubuntu基础容器镜像。这个镜像将用于启动容器实例，用于测试各种容器生命周期管理命令，比如`docker pull`、`docker
    start`和`docker stop`。这个容器镜像很有用，因为默认的基础镜像允许我们在长时间运行的会话中运行容器实例，以了解容器生命周期管理命令的功能。在这个练习中，您还将拉取`Ubuntu
    18.04`容器镜像，并将其与`Ubuntu 19.04`容器镜像进行比较：
- en: 'In a new terminal or PowerShell window, execute the `docker pull` command to
    download the `Ubuntu 18.04` container image:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的终端或PowerShell窗口中，执行`docker pull`命令以下载`Ubuntu 18.04`容器镜像：
- en: '[PRE14]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You should see the following output indicating that Docker is downloading all
    the layers of the base image:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出，表明Docker正在下载基础镜像的所有层：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Use the `docker pull` command to download the `Ubuntu 19.04` base image:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker pull`命令下载`Ubuntu 19.04`基础镜像：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You will see similar output as Docker downloads the `Ubuntu 19.04` base image:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker下载`Ubuntu 19.04`基础镜像时，您将看到类似的输出：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Use the `docker images` command to confirm that the container images are downloaded
    to the local container cache:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker images`命令确认容器镜像已下载到本地容器缓存：
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The contents of the local container cache will display the `Ubuntu 18.04` and
    `Ubuntu 19.04` base images, as well as our `hello-world` image from the earlier
    exercise:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本地容器缓存的内容将显示`Ubuntu 18.04`和`Ubuntu 19.04`基础镜像，以及我们之前练习中的`hello-world`镜像：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Before running these images, use the `docker inspect` command to get verbose
    output about what makes up the container images and how they differ. In your terminal,
    run the `docker inspect` command and use the image ID of the `Ubuntu 18.04` container
    image as the main argument:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行这些镜像之前，使用`docker inspect`命令获取关于容器镜像的详细输出以及它们之间的差异。在你的终端中，运行`docker inspect`命令，并使用`Ubuntu
    18.04`容器镜像的ID作为主要参数：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `inspect` output will contain a large list of all the attributes that define
    that container. For example, you can see what environment variables are configured
    within the container, whether the container has a hostname set when the image
    was last updated, and a breakdown of all the layers that define that container.
    This output contains critical debugging details that can prove valuable when planning
    an upgrade. The following is the truncated output of the `inspect` command. In
    the `Ubuntu 18.04` image, the `"Created"` parameter should provide the date and
    time the container image was built:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`inspect`输出将包含定义该容器的所有属性的大型列表。例如，你可以看到容器中配置了哪些环境变量，容器在最后一次更新镜像时是否设置了主机名，以及定义该容器的所有层的详细信息。这个输出包含了在规划升级时可能会有价值的关键调试细节。以下是`inspect`命令的截断输出。在`Ubuntu
    18.04`镜像中，`"Created"`参数应该提供构建容器镜像的日期和时间：'
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inspecting the `Ubuntu 19.04` container, you can see that this parameter is
    different. Run the `docker inspect` command in the `Ubuntu 19.04` container image
    ID:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`Ubuntu 19.04`容器，你会看到这个参数是不同的。在`Ubuntu 19.04`容器镜像ID中运行`docker inspect`命令：
- en: '[PRE22]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the displayed output, you will see that this container image was created
    on a different date to the `18.04` container image:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示的输出中，你会看到这个容器镜像是在一个不同的日期创建的，与`18.04`容器镜像不同：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This could be critical if you knew that a security vulnerability might be present
    in an Ubuntu base image. This information can also prove vital to helping you
    determine which version of the container you want to run.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道Ubuntu基础镜像中可能存在安全漏洞，这可能是至关重要的信息。这些信息也可以对帮助你确定要运行哪个版本的容器至关重要。
- en: After inspecting both the container images, it will be clear that your best
    choice is to stick with the Ubuntu Long Term Support 18.04 release. As you saw
    from the preceding outputs, the 18.04 release is more up to date than the 19.04
    release. This is to be expected as Ubuntu will generally provide more stable updates
    to the long-term support releases.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查了两个容器镜像之后，很明显你最好的选择是坚持使用Ubuntu长期支持版18.04版本。正如你从前面的输出中看到的，18.04版本比19.04版本更加更新。这是可以预期的，因为Ubuntu通常会为长期支持版本提供更稳定的更新。
- en: 'Use the `docker run` command to start an instance of the Ubuntu 18.04 container:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令启动Ubuntu 18.04容器的一个实例：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that this time we are using the `docker run` command with the `-d` flag.
    This tells Docker to run the container in daemon mode (or in the background).
    If we omit the `-d` flag, the container will take over our current terminal until
    the primary process inside the container terminates.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这次我们使用了带有`-d`标志的`docker run`命令。这告诉Docker以守护进程模式（或后台模式）运行容器。如果我们省略`-d`标志，容器将占用我们当前的终端，直到容器内的主要进程终止。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A successful invocation of the `docker run` command will usually only return
    the container ID as output. Some versions of Docker will not return any output.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 成功调用`docker run`命令通常只会返回容器ID作为输出。某些版本的Docker不会返回任何输出。
- en: 'Check the status of the container using the `docker ps -a` command:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps -a`命令检查容器的状态：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will reveal a similar output to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示类似于以下内容的输出：
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, your container is stopped and exited. This is because the primary
    process inside the container is `/bin/bash`, which is a shell. The Bash shell
    cannot run without being executed in an interactive mode since it expects text
    input and output from a user.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你的容器已经停止并退出。这是因为容器内的主要进程是`/bin/bash`，这是一个shell。Bash shell不能在没有以交互模式执行的情况下运行，因为它期望来自用户的文本输入和输出。
- en: 'Run the `docker run` command again, passing in the `-i` flag to make the session
    interactive (expecting user input), and the `-t` flag to allocate a **pseudo-tty**
    handler to the container. `pseudo-tty` handler will essentially link the user''s
    terminal to the interactive Bash shell running inside the container. This will
    allow Bash to run properly since it will instruct the container to run in an interactive
    mode, expecting user input. You can also give the container a human-readable name
    by passing in the `--name` flag. Type the following command in your Bash terminal:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行`docker run`命令，传入`-i`标志以使会话交互（期望用户输入），并传入`-t`标志以为容器分配一个**伪tty**处理程序。`伪tty`处理程序将基本上将用户的终端链接到容器内运行的交互式Bash
    shell。这将允许Bash正确运行，因为它将指示容器以交互模式运行，期望用户输入。您还可以通过传入`--name`标志为容器指定一个易读的名称。在您的Bash终端中键入以下命令：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Execute the `docker ps -a` command again to check the status of the container
    instance:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次执行`docker ps -a`命令以检查容器实例的状态：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You should now see the new instance running, as well as the instance that failed
    to start moments ago:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到新的实例正在运行，以及刚刚无法启动的实例：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'You now have an Ubuntu container up and running. You can run commands inside
    this container using the `docker exec` command. Run the `exec` command to access
    a Bash shell, which will allow us to run commands inside the container. Similar
    to `docker run`, pass in the `-i` and `-t` flags to make it an interactive session.
    Also pass in the name or ID of the container, so that Docker knows which container
    you are targeting. The final argument of `docker exec` is always the command you
    wish to execute. In this case, it will be `/bin/bash` to start a Bash shell inside
    the container instance:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在有一个正在运行的Ubuntu容器。您可以使用`docker exec`命令在此容器内运行命令。运行`exec`命令以访问Bash shell，这将允许我们在容器内运行命令。类似于`docker
    run`，传入`-i`和`-t`标志使其成为交互式会话。还传入容器的名称或ID，以便Docker知道您要定位哪个容器。`docker exec`的最后一个参数始终是您希望执行的命令。在这种情况下，它将是`/bin/bash`，以在容器实例内启动Bash
    shell：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You should immediately see your prompt change to a root shell. This indicates
    that you have successfully launched a shell inside your Ubuntu container. The
    hostname of the container, `cfaa37795a7b`, is taken from the first twelve characters
    of the container ID. This allows the user to know for certain which container
    are they accessing, as seen in the following example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该立即看到您的提示更改为根shell。这表明您已成功在Ubuntu容器内启动了一个shell。容器的主机名`cfaa37795a7b`取自容器ID的前12个字符。这使用户可以确定他们正在访问哪个容器，如下例所示：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'From inside the container, you are very limited in terms of what tools you
    have available. Unlike a VM image, container images are extremely minimal in terms
    of the packages that come preinstalled. The `echo` command should be available,
    however. Use `echo` to write a simple message to a text file:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器内，您所拥有的工具非常有限。与VM镜像不同，容器镜像在预安装的软件包方面非常精简。但是`echo`命令应该是可用的。使用`echo`将一个简单的消息写入文本文件：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the `exit` command to exit from the Bash shell of the `ubuntu1` container.
    You should return to your normal terminal shell:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`exit`命令退出`ubuntu1`容器的Bash shell。您应该返回到正常的终端shell：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The command will return output like the following. Please note that the output
    may vary for every user running the command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回以下输出。请注意，对于运行该命令的每个用户，输出可能会有所不同：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now create a second container called `ubuntu2` that will also run in your Docker
    environment using the `Ubuntu 19.04` image:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为`ubuntu2`的第二个容器，它也将在您的Docker环境中使用`Ubuntu 19.04`镜像运行：
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Run `docker exec` to access a shell of this second container. Remember to use
    the name or container ID of the new container you created. Likewise, access a
    Bash shell inside this container, so the final argument will be `/bin/bash`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker exec`来访问第二个容器的shell。记得使用你创建的新容器的名称或容器ID。同样地，访问这个容器内部的Bash shell，所以最后一个参数将是`/bin/bash`：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You should observe your prompt change to a Bash root shell, similar to how
    it did for the `Ubuntu 18.04` container image:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该观察到你的提示会变成一个Bash root shell，类似于`Ubuntu 18.04`容器镜像的情况：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the `echo` command inside the `ubuntu2` container instance to write a similar
    `hello-world`-type greeting:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ubuntu2`容器实例内部运行`echo`命令，写入类似的`hello-world`类型的问候语：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Currently, you have two Ubuntu container instances running in your Docker environment
    with two separate `hello-world` greeting messages in the home directory of the
    root account. Use `docker ps` to see the two running container images:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，在你的Docker环境中有两个运行中的Ubuntu容器实例，根账户的主目录中有两个单独的`hello-world`问候消息。使用`docker ps`来查看这两个运行中的容器镜像：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The list of running containers should reflect the two Ubuntu containers, as
    well as the time elapsed since they have been created:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器的列表应该反映出两个Ubuntu容器，以及它们创建后经过的时间：
- en: '[PRE40]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Instead of using `docker exec` to access a shell inside our containers, use
    it to display the output of the `hello-world.txt` files you wrote by executing
    the `cat` command inside the containers:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要使用`docker exec`来访问容器内部的shell，而是使用它来显示你通过在容器内执行`cat`命令写入的`hello-world.txt`文件的输出：
- en: '[PRE41]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The output will display the `hello-world` message you passed into the container
    in the previous steps. Notice that as soon as the `cat` command was completed
    and the output displayed, the user was moved back to the context of your main
    terminal. This is because the `docker exec` session will only exist for as long
    as the command the user is executing will run.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示你在之前步骤中传递给容器的`hello-world`消息。请注意，一旦`cat`命令完成并显示输出，用户就会被移回到主终端的上下文中。这是因为`docker
    exec`会话只会存在于用户执行命令的时间内。
- en: 'In the earlier example of the Bash shell, Bash will only exit if the user terminates
    it by using the `exit` command. In this example, only the `Hello world` output
    is displayed because the `cat` command displayed the output and exited, ending
    the `docker exec` session:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的Bash shell示例中，只有用户使用`exit`命令终止它时，Bash才会退出。在这个例子中，只显示了`Hello world`输出，因为`cat`命令显示了输出并退出，结束了`docker
    exec`会话：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You will observe the contents of the `hello-world` file displayed, followed
    by a return to your main terminal session.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到`hello-world`文件的内容显示，然后返回到你的主终端会话。
- en: 'Run the same `cat` command in the `ubuntu2` container instance:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ubuntu2`容器实例中运行相同的`cat`命令：
- en: '[PRE43]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similar to the first example, the `ubuntu2` container instance will display
    the contents of the `hello-world.txt` file provided previously:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与第一个例子类似，`ubuntu2`容器实例将显示之前提供的`hello-world.txt`文件的内容：
- en: '[PRE44]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: As you can see, Docker was able to allocate an interactive session on both the
    containers, execute the command, and return the output directly in our running
    container instances.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Docker能够在两个容器上分配一个交互式会话，执行命令，并直接返回输出到我们正在运行的容器实例中。
- en: 'In a similar manner to that you used to execute commands inside our running
    containers, you can also stop, start, and restart them. Stop one of your container
    instances using the `docker stop` command. In your terminal session, execute the
    `docker stop` command, followed by the name or container ID of the `ubuntu2` container:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与你用来在运行中的容器内执行命令的方式类似，你也可以停止、启动和重新启动它们。使用`docker stop`命令停止其中一个容器实例。在你的终端会话中，执行`docker
    stop`命令，然后是`ubuntu2`容器的名称或容器ID：
- en: '[PRE45]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This command should return no output.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该不返回任何输出。
- en: 'Use the `docker ps` command to view all running container instances:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令查看所有正在运行的容器实例：
- en: '[PRE46]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output will display the `ubuntu1` container up and running:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示`ubuntu1`容器正在运行：
- en: '[PRE47]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Execute the `docker ps -a` command to view all container instances, regardless
    of whether they are running, to see your container in a stopped state:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker ps -a`命令以查看所有容器实例，无论它们是否正在运行，以查看您的容器是否处于停止状态：
- en: '[PRE48]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The command will return the following output:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将返回以下输出：
- en: '[PRE49]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Use the `docker start` or `docker restart` command to restart the container
    instance:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker start`或`docker restart`命令重新启动容器实例：
- en: '[PRE50]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This command will return no output, although some versions of Docker may display
    the container ID.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将不返回任何输出，尽管某些版本的Docker可能会显示容器ID。
- en: 'Verify that the container is running again by using the `docker ps` command:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令验证容器是否再次运行：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that `STATUS` shows that this container has only been up for a short
    period (`1 second`), although the container instance was created 29 minutes ago:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`STATUS`显示该容器只运行了很短的时间（`1秒`），尽管容器实例是29分钟前创建的：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From this state, you can experiment with starting, stopping, or executing commands
    inside these containers.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个状态开始，您可以尝试启动、停止或在这些容器内执行命令。
- en: 'The final stage of the container management life cycle is cleaning up the container
    instances you created. Use the `docker stop` command to stop the `ubuntu1` container
    instance:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器管理生命周期的最后阶段是清理您创建的容器实例。使用`docker stop`命令停止`ubuntu1`容器实例：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This command will return no output, although some versions of Docker may return
    the container ID.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将不返回任何输出，尽管某些版本的Docker可能会返回容器ID。
- en: 'Perform the same `docker stop` command to stop the `ubuntu2` container instance:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行相同的`docker stop`命令以停止`ubuntu2`容器实例：
- en: '[PRE54]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When container instances are in a stopped state, use the `docker rm` command
    to delete the container instances altogether. Use `docker rm` followed by the
    name or container ID to delete the `ubuntu1` container instance:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器实例处于停止状态时，使用`docker rm`命令彻底删除容器实例。使用`docker rm`后跟名称或容器ID删除`ubuntu1`容器实例：
- en: '[PRE55]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This command will return no output, although some versions of Docker may return
    the container ID.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将不返回任何输出，尽管某些版本的Docker可能会返回容器ID。
- en: 'Perform this same step on the `ubuntu2` container instance:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ubuntu2`容器实例上执行相同的步骤：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Execute `docker ps -a` to see all containers, even the ones in a stopped state.
    You will find that the stopped containers no longer exist due to the fact they
    have been deleted by our previous command. You may also delete the `hello-world`
    container instances, as well. Delete the `hello-world` container using the container
    ID captured from the `docker ps -a` output:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker ps -a`以查看所有容器，即使它们处于停止状态。您会发现停止的容器由于之前的命令已被删除。您也可以删除`hello-world`容器实例。使用从`docker
    ps -a`输出中捕获的容器ID删除`hello-world`容器：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To completely reset the state of our Docker environment, delete the base images
    you downloaded during this exercise as well. Use the `docker images` command to
    view the cached base images:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要完全重置我们的Docker环境状态，请删除您在此练习中下载的基本图像。使用`docker images`命令查看缓存的基本图像：
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The list of Docker images and all associated metadata in your local cache will
    display:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您的本地缓存中将显示Docker图像列表和所有关联的元数据：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Execute the `docker rmi` command followed by the image ID to delete the first
    image ID:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行`docker rmi`命令，后跟图像ID以删除第一个图像ID：
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Similar to `docker pull`, the `rmi` command will delete each image and all
    associated layers:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`docker pull`，`rmi`命令将删除每个图像和所有关联的层：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Perform this step for each image you wish to delete, substituting in the various
    image IDs. For each base image you delete, you will see all of the image layers
    get untagged and deleted along with it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于要删除的每个映像，执行此步骤，替换各种映像ID。对于删除的每个基本映像，您将看到所有图像层都被取消标记并与其一起删除。
- en: It is important to periodically clean up your Docker environment as frequently
    building and running containers can cause large amounts of hard disk usage over
    time. Now that you know how to run and manage Docker containers in your local
    development environment, you can use more advanced Docker commands to understand
    how a container's primary process functions and how to troubleshoot issues. In
    the next section, we will look at the `docker attach` command to directly access
    the primary process of a container.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 定期清理Docker环境很重要，因为频繁构建和运行容器会导致长时间大量的硬盘使用。现在您已经知道如何在本地开发环境中运行和管理Docker容器，可以使用更高级的Docker命令来了解容器的主要进程功能以及如何解决问题。在下一节中，我们将看看`docker
    attach`命令，直接访问容器的主要进程。
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To streamline the process of cleaning up your environment, Docker provides
    a `prune` command that will automatically remove old containers and base images:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化清理环境的过程，Docker提供了一个`prune`命令，将自动删除旧的容器和基本映像：
- en: '`$ docker system prune -fa`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker system prune -fa`'
- en: Executing this command will remove any container images that are not tied to
    an existing running container, along with any other resources in your Docker environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令将删除任何未绑定到现有运行容器的容器映像，以及Docker环境中的任何其他资源。
- en: Attaching to Containers Using the attach Command
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用attach命令附加到容器
- en: In the previous exercise, you saw how to use the `docker exec` command to spin
    up a new shell session in a running container instance in which to execute commands.
    The `docker exec` command is very good for quickly gaining access to a containerized
    instance for debugging, troubleshooting, and understanding the context the container
    is running in.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，您看到了如何使用`docker exec`命令在运行的容器实例中启动新的shell会话以执行命令。`docker exec`命令非常适合快速访问容器化实例以进行调试、故障排除和了解容器运行的上下文。
- en: However, as covered earlier in the chapter, Docker containers run as per the
    life of the primary process running inside the container. When this process exits,
    the container will stop. If you wanted to access the primary process inside the
    container directly (as opposed to a secondary shell session), then Docker provides
    the `docker attach` command to attach to the primary running process inside the
    container.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如本章前面所述，Docker容器按照容器内部运行的主要进程的生命周期运行。当此进程退出时，容器将停止。如果要直接访问容器内部的主要进程（而不是次要的shell会话），那么Docker提供了`docker
    attach`命令来附加到容器内部正在运行的主要进程。
- en: When using `docker attach`, you are gaining access to the primary process running
    in the container. If this process is interactive, such as a Bash or Bourne shell
    session, you will be able to execute commands directly through a `docker attach`
    session (similar to `docker exec`). However, if the primary process in your container
    terminates, so will the entire container instance, since the Docker container
    life cycle is dependent on the running state of the primary process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker attach`时，您可以访问容器中运行的主要进程。如果此进程是交互式的，例如Bash或Bourne shell会话，您将能够通过`docker
    attach`会话直接执行命令（类似于`docker exec`）。但是，如果容器中的主要进程终止，整个容器实例也将终止，因为Docker容器的生命周期取决于主要进程的运行状态。
- en: In the following exercise, you will use the `docker attach` command to directly
    access the primary process of an Ubuntu container. By default, the primary process
    of this container is `/bin/bash`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的练习中，您将使用`docker attach`命令直接访问Ubuntu容器的主要进程。默认情况下，此容器的主要进程是`/bin/bash`。
- en: 'Exercise 1.03: Attaching to an Ubuntu Container'
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：附加到Ubuntu容器
- en: 'The `docker attach` command is used to attach to a running container in the
    context of the primary process. In this exercise, you will use the `docker attach`
    command to attach to running containers and investigate the main container `entrypoint`
    process directly:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker attach`命令用于在主要进程的上下文中附加到运行中的容器。在此练习中，您将使用`docker attach`命令附加到运行中的容器并直接调查主容器`entrypoint`进程：'
- en: 'Use the `docker run` command to start a new Ubuntu container instance. Run
    this container in interactive mode (`-i`), allocate a TTY session (`-t`), and
    run it in the background (`-d`). Call this container `attach-example1`:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker run`命令启动一个新的Ubuntu容器实例。以交互模式（`-i`）运行此容器，分配一个TTY会话（`-t`），并在后台（`-d`）运行。将此容器命名为`attach-example1`：
- en: '[PRE62]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will start a new Ubuntu container instance named `attach-example1` using
    the latest version of the Ubuntu container image.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用Ubuntu容器图像的最新版本启动一个名为`attach-example1`的新Ubuntu容器实例。
- en: 'Use the `docker ps` command to check that this container is running in our
    environment:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令来检查该容器是否在我们的环境中运行：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The details of the running container instance will be displayed. Take note
    that the primary process of this container is a Bash shell (`/bin/bash`):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示运行中容器实例的详细信息。请注意，此容器的主要进程是Bash shell（`/bin/bash`）：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Run the `docker attach` command to attach to the primary process inside this
    container, (`/bin/bash`). Use `docker attach` followed by the name or ID of the
    container instance:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`docker attach`命令以附加到此容器内部的主要进程（`/bin/bash`）。使用`docker attach`后跟容器实例的名称或ID：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should drop you into the primary Bash shell session of this container
    instance. Note that your terminal session should change to a root shell session,
    indicating you have successfully accessed the container instance:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该将您放入此容器实例的主Bash shell会话中。请注意，您的终端会话应更改为根shell会话，表示您已成功访问了容器实例：
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: It should be noted here that using commands such as `exit` to terminate a shell
    session will result in stopping the container instance because you are now attached
    to the primary process of the container instance. By default, Docker provides
    the shortcut key sequence of *Ctrl* + *P* and then *Ctrl* + *Q* to gracefully
    detach from an `attach` session.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意，使用诸如`exit`之类的命令来终止shell会话将导致停止容器实例，因为您现在已连接到容器实例的主要进程。默认情况下，Docker提供了*Ctrl*
    + *P*然后*Ctrl* + *Q*的快捷键序列，以正常分离`attach`会话。
- en: 'Use the keyboard combinations *Ctrl* + *P* and then *Ctrl* + *Q* to detach
    from this session gracefully:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用键盘组合*Ctrl* + *P*然后*Ctrl* + *Q*正常分离此会话：
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You will not type the words `CTRL-p CTRL-q`; rather, you will press and hold
    the *Ctrl* key, press the *P* key, and then release both keys. Then, press and
    hold the *Ctrl* key again, press the *Q* key, and then again release both keys.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您不会输入`CTRL-p CTRL-q`这些单词；相反，您将按住*Ctrl*键，按下*P*键，然后释放两个键。然后，再次按住*Ctrl*键，按下*Q*键，然后再次释放两个键。
- en: 'Upon successful detachment of the container, the words `read escape sequence`
    will be displayed before returning you to your main terminal or PowerShell session:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 成功分离容器后，将显示单词`read escape sequence`，然后将您返回到主终端或PowerShell会话：
- en: '[PRE68]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Use `docker ps` to verify that the Ubuntu container is still running as expected:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`验证Ubuntu容器是否仍然按预期运行：
- en: '[PRE69]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The `attach-example1` container will be displayed, still running as expected:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`attach-example1`容器将被显示为预期运行：'
- en: '[PRE70]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Use the `docker attach` command to attach once more to the `attach-example1`
    container instance:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker attach`命令再次附加到`attach-example1`容器实例：
- en: '[PRE71]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'You should be put back into the Bash session of the primary process:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该被放回到主进程的Bash会话中：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, terminate the primary process of this container using the `exit` command.
    In the Bash shell session, type the `exit` command:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`exit`命令终止这个容器的主进程。在Bash shell会话中，输入`exit`命令：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The terminal session should have exited, returning you once more to your primary
    terminal.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 终端会话应该已经退出，再次返回到您的主终端。
- en: 'Use the `docker ps` command to observe that the `attach-example1` container
    should no longer be running:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps`命令观察`attach-example1`容器不再运行：
- en: '[PRE74]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'This should return no running container instances:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该不会显示任何正在运行的容器实例：
- en: '[PRE75]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use the `docker ps -a` command to view all the containers, even ones that have
    been stopped or have exited:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker ps -a`命令查看所有容器，即使已停止或已退出的容器也会显示：
- en: '[PRE76]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'This should display the `attach-example1` container in a stopped state:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该显示`attach-example1`容器处于停止状态：
- en: '[PRE77]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see, the container has gracefully terminated (`Exited (0)`) approximately
    3 minutes ago. The `exit` command gracefully terminates a Bash shell session.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，容器已经优雅地终止（`Exited (0)`）大约3分钟前。`exit`命令会优雅地终止Bash shell会话。
- en: 'Use the `docker system prune -fa` command to clean up the stopped container
    instances:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker system prune -fa`命令清理已停止的容器实例：
- en: '[PRE78]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This should remove all stopped container instances, including the `attach-example1`
    container instance, as seen in the following output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该删除所有已停止的容器实例，包括`attach-example1`容器实例，如下面的输出所示：
- en: '[PRE79]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: In this exercise, we used the `docker attach` command to gain direct access
    to the primary process of a running container. This differs from the `docker exec`
    command we explored earlier in the chapter because `docker exec` executes a new
    process inside a running container, whereas `docker attach` attaches to the main
    process of a container directly. Careful attention must be paid, however, when
    attaching to a container not to stop the container by terminating the main process.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用`docker attach`命令直接访问正在运行的容器的主进程。这与我们在本章中早些时候探讨的`docker exec`命令不同，因为`docker
    exec`在运行的容器内执行一个新的进程，而`docker attach`直接附加到容器的主进程。然而，在附加到容器时，必须注意不要通过终止主进程来停止容器。
- en: In the next activity, we will put together the Docker management commands we
    covered in this chapter to start putting together the building block containers
    that will become the Panoramic Trekking microservices application stack.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，我们将整合本章中涵盖的Docker管理命令，开始组装成全景徒步旅行微服务应用程序堆栈的构建块容器。
- en: 'Activity 1.01: Pulling and Running the PostgreSQL Container Image from Docker
    Hub'
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.01：从Docker Hub拉取并运行PostgreSQL容器镜像
- en: Panoramic Trekking is the multi-tier web application that we will be building
    throughout this book. Similar to any web application, it will consist of a web
    server container (NGINX), a Python Django backend application, and a PostgreSQL
    database. Before you can start deploying the web application or the frontend web
    server, you must first deploy the backend database.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 全景徒步旅行是我们将在本书中构建的多层Web应用程序。与任何Web应用程序类似，它将包括一个Web服务器容器（NGINX）、一个Python Django后端应用程序和一个PostgreSQL数据库。在部署Web应用程序或前端Web服务器之前，您必须先部署后端数据库。
- en: In this activity, you are asked to start a PostgreSQL version 12 database container
    with default credentials.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，您被要求使用默认凭据启动一个PostgreSQL版本12的数据库容器。
- en: Note
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The official Postgres container image provides many environment variable overrides
    you can leverage to configure the PostgreSQL instance. Review the documentation
    for the container on Docker Hub at [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的Postgres容器映像提供了许多环境变量覆盖，您可以利用这些变量来配置PostgreSQL实例。在Docker Hub上查看有关容器的文档[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)。
- en: 'Perform the following steps:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Create a Postgres database container instance that will serve as the data tier
    of our application stack.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个Postgres数据库容器实例，将作为我们应用程序堆栈的数据层。
- en: 'Use environment variables to configure the container at runtime to use the
    following database credentials:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用环境变量在运行时配置容器以使用以下数据库凭据：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Verify whether the container is running and healthy.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证容器是否正在运行和健康。
- en: '**Expected Output:**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出：**'
- en: 'The following output should be returned on running `docker ps` command:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`docker ps`命令应返回以下输出：
- en: '[PRE81]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor316).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor316)找到。
- en: In the next activity, you will access the database that has just been set up
    in this activity inside the container instance. You will also interact with the
    container to fetch the list of databases running in the container.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个活动中，您将访问刚刚在容器实例中设置的数据库。您还将与容器交互，以获取容器中运行的数据库列表。
- en: 'Activity 1.02: Accessing the Panoramic Trekking App Database'
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1.02：访问全景徒步应用程序数据库
- en: This activity will involve accessing the database running inside the container
    instance using the `PSQL` CLI utility. Once you have logged in using the credentials
    (`panoramic/trekking`), you will query for the list of databases running in the
    container.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动将涉及使用`PSQL` CLI实用程序访问在容器实例内运行的数据库。一旦您使用凭据（`panoramic/trekking`）登录，您将查询容器中运行的数据库列表。
- en: 'Perform the following steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Log in to the Postgres database container using the PSQL command-line utility.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用PSQL命令行实用程序登录到Postgres数据库容器。
- en: Once logged in to the database, return a list of databases in Postgres by default.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到数据库后，默认情况下返回Postgres中的数据库列表。
- en: Note
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are not familiar with the PSQL CLI, the following is a list of reference
    commands to assist you with this activity:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对PSQL CLI不熟悉，以下是一些参考命令的列表，以帮助您完成此活动：
- en: 'Logging in: `psql --username username --password`'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 登录：`psql --username username --password`
- en: 'Listing the database: `\l`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 列出数据库：`\l`
- en: 'Quitting the PSQL shell: `\q`'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 退出PSQL shell：`\q`
- en: '**Expected Output:**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**预期输出：**'
- en: '![Figure 1.3: Expected output of Activity 1.02'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：活动1.02的预期输出'
- en: '](image/B15021_01_03.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/B15021_01_03.jpg)'
- en: 'Figure 1.3: Expected output of Activity 1.02'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3：活动1.02的预期输出
- en: Note
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found via [this link](B15021_Solution_Final_SMP.xhtml#_idTextAnchor318).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以通过[此链接](B15021_Solution_Final_SMP.xhtml#_idTextAnchor318)找到。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned the fundamentals of containerization, the benefits
    of running applications in containers, and the basic Docker life cycle commands
    to manage containerized instances. You learned that containers serve as a universal
    software deployment package that truly can be built once and run anywhere. Because
    we are running Docker locally, we can know for certain that the same container
    images running in our local environment can be deployed in production and run
    with confidence.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了容器化的基础知识，以及在容器中运行应用程序的好处，以及管理容器化实例的基本Docker生命周期命令。您了解到容器作为一个真正可以构建一次并在任何地方运行的通用软件部署包。因为我们在本地运行Docker，我们可以确信在我们的本地环境中运行的相同容器映像可以部署到生产环境并且可以放心地运行。
- en: Using commands such as `docker run`, `docker start`, `docker exec`, `docker
    ps`, and `docker stop`, we have explored the basics of container life cycle management
    through the Docker CLI. Through the various exercises, we launched container instances
    from the same base image, configured them using `docker exec`, and cleaned up
    the deployments using other basic container life cycle commands such as `docker
    rm` and `docker rmi`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 通过诸如`docker run`、`docker start`、`docker exec`、`docker ps`和`docker stop`之类的命令，我们通过Docker
    CLI探索了容器生命周期管理的基础知识。通过各种练习，我们从相同的基础映像启动了容器实例，使用`docker exec`对其进行了配置，并使用其他基本的容器生命周期命令（如`docker
    rm`和`docker rmi`）清理了部署。
- en: In the final portion of this chapter, we jumped in head-first, taking the first
    steps toward running our Panoramic Trekking application by launching a PostgreSQL
    database container instance. Using environment variables that we placed within
    the `docker run` command, we created an instance configured with a default username
    and password. We tested the configuration by executing the PSQL command-line tool
    from inside the container and querying the database to see the schema.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们毅然决然地迈出了第一步，通过启动一个PostgreSQL数据库容器实例，开始运行我们的全景徒步应用程序。我们在`docker run`命令中使用环境变量创建了一个配置了默认用户名和密码的实例。我们通过在容器内部执行PSQL命令行工具并查询数据库来测试配置，以查看模式。
- en: Although this is only scratching the surface of what Docker is capable of, we
    hope it was able to whet your appetite for the material that will be covered in
    the upcoming chapters. In the next chapter, we will discuss building truly immutable
    containers using `Dockerfiles` and the `docker build` command. Writing custom
    `Dockerfiles` to build and deploy unique container images will demonstrate the
    power of running containerized applications at scale.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是触及Docker能力表面的一部分，但我们希望它能激发你对即将在后续章节中涵盖的内容的兴趣。在下一章中，我们将讨论使用`Dockerfiles`和`docker
    build`命令构建真正不可变的容器。编写自定义的`Dockerfiles`来构建和部署独特的容器映像将展示在规模上运行容器化应用程序的强大能力。
