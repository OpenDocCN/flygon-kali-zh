["```cs\nBaseEntity class:\n```", "```cs\npublic abstract class BaseEntity \n{ \n\n  public BaseEntity() \n  { \n    this.CreatedOn = DateTime.Now; \n    this.UpdatedOn = DateTime.Now; \n    this.State = (int)EntityState.New; \n\n  } \n  public string CreatedBy { get; set; } \n  public DateTime CreatedOn { get; set; } \n  public string UpdatedBy { get; set; } \n  public DateTime UpdatedOn { get; set; } \n\n} \n\n```", "```cs\npublic interface IUnitOfWork: IDisposable \n{ \n  void BeginTransaction(); \n\n  void RollbackTransaction(); \n\n  void CommitTransaction(); \n\n  Task<bool> SaveChangesAsync(); \n\n} \n```", "```cs\npublic interface IRepository<T> where T : BaseEntity \n{ \n  IUnitOfWork UnitOfWork { get; } \n\n  IQueryable<T> All<T>() where T : BaseEntity; \n  T Find<T>(Expression<Func<T, bool>> predicate) where T : BaseEntity; \n\n  bool Contains<T>(Expression<Func<T, bool>> predicate) where T : BaseEntity; \n} \n```", "```cs\npublic static class LoggingEvents \n{ \n  public const int GET_ITEM = 1001; \n  public const int GET_ITEMS = 1002; \n  public const int CREATE_ITEM = 1003; \n  public const int UPDATE_ITEM = 1004; \n  public const int DELETE_ITEM = 1005; \n  public const int DATABASE_ERROR = 2000; \n  public const int SERVICE_ERROR = 2001; \n  public const int ERROR = 2002; \n  public const int ACCESS_METHOD = 3000; \n} \nLoggerHelper class:\n```", "```cs\npublic static string GetExceptionDetails(Exception ex) \n{ \n\n  StringBuilder errorString = new StringBuilder(); \n  errorString.AppendLine(\"An error occured. \"); \n  Exception inner = ex; \n  while (inner != null) \n  { \n    errorString.Append(\"Error Message:\"); \n    errorString.AppendLine(ex.Message); \n    errorString.Append(\"Stack Trace:\"); \n    errorString.AppendLine(ex.StackTrace); \n    inner = inner.InnerException; \n  } \n  return errorString.ToString(); \n} \n```", "```cs\nBaseController class:\n```", "```cs\npublic class BaseController : Controller \n{ \n  private ILogger _logger; \n  public BaseController(ILogger logger) \n  { \n    _logger = logger; \n  } \n\n  public ILogger Logger { get { return _logger; } } \n  public HttpResponseMessage LogException(Exception ex) \n  { \n    HttpResponseMessage message = new HttpResponseMessage(); \n    message.Content = new StringContent(ex.Message); \n    message.StatusCode = System.Net.HttpStatusCode.ExpectationFailed; \n    return message; \n  } \n} \n```", "```cs\nLoggingActionFilter class:\n```", "```cs\npublic class LoggingActionFilter: ActionFilterAttribute \n{ \n  public override void OnActionExecuting(ActionExecutingContext context) \n  { \n\n    Log(\"OnActionExecuting\", context.RouteData, context.Controller); \n\n  } \n\n  public override void OnActionExecuted(ActionExecutedContext context) \n  { \n    Log(\"OnActionExecuted\", context.RouteData, context.Controller); \n\n  } \n\n  public override void OnResultExecuted(ResultExecutedContext context) \n  { \n    Log(\"OnResultExecuted\", context.RouteData, context.Controller); \n  } \n\n  public override void OnResultExecuting(ResultExecutingContext context) \n  { \n    Log(\"OnResultExecuting\", context.RouteData, context.Controller); \n  } \n\n  private void Log(string methodName, RouteData routeData, Object controller) \n  { \n    var controllerName = routeData.Values[\"controller\"]; \n    var actionName = routeData.Values[\"action\"]; \n    var message = String.Format(\"{0} controller:{1} action:{2}\", \n    methodName, controllerName, actionName); \n    BaseController baseController = ((BaseController)controller); \n    baseController.Logger.LogInformation(LoggingEvents.ACCESS_METHOD, message); \n  } \n} \n```", "```cs\n<PackageReference Include=\"AspNet.Security.OAuth.Validation\" Version=\"2.0.0-rc1-final\" /> \n<PackageReference Include=\"AspNet.Security.OpenIdConnect.Server\" Version=\"2.0.0-rc1-final\" /> \n<PackageReference Include=\"Microsoft.AspNetCore.Identity\" Version=\"2.0.1\" /> \n<PackageReference Include=\"Microsoft.AspNetCore.Identity.EntityFrameworkCore\" Version=\"2.0.1\" /> \n<PackageReference Include=\"Microsoft.VisualStudio.Web.CodeGeneration.Design\" Version=\"2.0.2\" /> \n<PackageReference Include=\"OpenIddict\" Version=\"2.0.0-rc2-0797\" /> \n<PackageReference Include=\"OpenIddict.Core\" Version=\"2.0.0-rc2-0797\" /> \n<PackageReference Include=\"OpenIddict.EntityFrameworkCore\" Version=\"2.0.0-rc2-0797\" /> \n<PackageReference Include=\"OpenIddict.Models\" Version=\"2.0.0-rc2-0797\" /> \n<PackageReference Include=\"OpenIddict.Mvc\" Version=\"2.0.0-rc2-0797\" /> \n```", "```cs\npublic class UserEntity : IdentityUser<Guid> \n{ \n\n  public int VendorId { get; set; } \n\n  public string FirstName { get; set; } \n  public string LastName { get; set; } \n\n  public DateTimeOffset CreatedAt { get; set; } \n\n} \n```", "```cs\npublic class UserRoleEntity : IdentityRole<Guid> \n{ \n  public UserRoleEntity() : base() { } \n\n  public UserRoleEntity(string roleName) : base(roleName) { } \n} \n```", "```cs\npublic class BFIdentityContext : IdentityDbContext<UserEntity, UserRoleEntity, Guid> \n{ \n  public BFIdentityContext(Microsoft.EntityFrameworkCore.DbContextOptions options) : \n  base(options) { } \n} \n```", "```cs\npublic void ConfigureServices(IServiceCollection services) \n{ \n  var connection= Configuration[\"ConnectionString\"]; \n\n  services.AddDbContext<BFIdentityContext>(options => \n  { \n    // Configure the context to use Microsoft SQL Server. \n    options.UseSqlServer(connection); \n  }); \n\n  services.AddIdentity<UserEntity, UserRole>().AddEntityFrameworkStores<BFIdentityContext>(); \n\n  services.AddMvc(); \n}   \n```", "```cs\nAdd-Migration Initial\n```", "```cs\npublic void ConfigureServices(IServiceCollection services) \n{ \n\n  var connection = @\"Server=.sqlexpress;Database=FraymsIdentityDB;\n  User Id=sa;Password=P@ssw0rd;\"; \n\n  services.AddDbContext<BFIdentityContext>(options => \n  { \n    // Configure the context to use Microsoft SQL Server. \n    options.UseSqlServer(connection); \n\n    // Register the entity sets needed by OpenIddict. \n    // Note: use the generic overload if you need \n    // to replace the default OpenIddict entities. \n    options.UseOpenIddict(); \n  }); \n\n  services.AddIdentity<UserEntity, UserRoleEntity>() \n  .AddEntityFrameworkStores<BFIdentityContext>(); \n\n  // Configure Identity to use the same JWT claims as OpenIddict instead \n  // of the legacy WS-Federation claims it uses by default (ClaimTypes), \n  // which saves you from doing the mapping in your authorization controller. \n  services.Configure<IdentityOptions>(options => \n  { \n    options.ClaimsIdentity.UserNameClaimType = OpenIdConnectConstants.Claims.Name; \n    options.ClaimsIdentity.UserIdClaimType = OpenIdConnectConstants.Claims.Subject; \n    options.ClaimsIdentity.RoleClaimType = OpenIdConnectConstants.Claims.Role; \n  }); \n\n  // Register the OpenIddict services. \n  services.AddOpenIddict(options => \n  { \n    // Register the Entity Framework stores. \n    options.AddEntityFrameworkCoreStores<BFIdentityContext>(); \n\n    // Register the ASP.NET Core MVC binder used by OpenIddict. \n    // Note: if you don't call this method, you won't be able to \n    // bind OpenIdConnectRequest or OpenIdConnectResponse parameters. \n    options.AddMvcBinders(); \n\n    // Enable the authorization, logout, userinfo, and introspection endpoints. \n    options.EnableAuthorizationEndpoint(\"/connect/authorize\") \n    .EnableLogoutEndpoint(\"/connect/logout\") \n    .EnableIntrospectionEndpoint(\"/connect/introspect\") \n    .EnableUserinfoEndpoint(\"/api/userinfo\"); \n\n    // Note: the sample only uses the implicit code flow but you can enable \n    // the other flows if you need to support implicit, password or client credentials. \n    options.AllowImplicitFlow(); \n\n    // During development, you can disable the HTTPS requirement. \n    options.DisableHttpsRequirement(); \n\n    // Register a new ephemeral key, that is discarded when the application \n    // shuts down. Tokens signed using this key are automatically invalidated. \n    // This method should only be used during development. \n    options.AddEphemeralSigningKey(); \n\n    options.UseJsonWebTokens(); \n  }); \n\n  services.AddAuthentication() \n  .AddOAuthValidation(); \n\n  services.AddCors(); \n  services.AddMvc(); \n}  \n```", "```cs\nservices.Configure<IdentityOptions>(options => \n{ \n  options.ClaimsIdentity.UserNameClaimType = OpenIdConnectConstants.Claims.Name; \n  options.ClaimsIdentity.UserIdClaimType = OpenIdConnectConstants.Claims.Subject; \n  options.ClaimsIdentity.RoleClaimType = OpenIdConnectConstants.Claims.Role; \n}); \n```", "```cs\npublic void Configure(IApplicationBuilder app) \n{ \n  app.UseCors(builder => \n  { \n    builder.AllowAnyOrigin(); \n    builder.AllowAnyHeader(); \n    builder.AllowAnyMethod(); \n  }); \n\n  app.UseAuthentication(); \n\n  app.UseMvcWithDefaultRoute(); \n\n  // Seed the database with the sample applications. \n  // Note: in a real world application, this step should be part of a setup script. \n  InitializeAsync(app.ApplicationServices, CancellationToken.None).GetAwaiter().GetResult(); \n} \n```", "```cs\nprivate async Task InitializeAsync(IServiceProvider services, CancellationToken cancellationToken) \n{ \n  // Create a new service scope to ensure the database context \n  // is correctly disposed when this methods returns. \n  using (var scope = services.GetRequiredService<IServiceScopeFactory>().CreateScope()) \n  { \n    var context = scope.ServiceProvider.GetRequiredService<BFIdentityContext>(); \n    await context.Database.EnsureCreatedAsync(); \n\n    var manager = scope.ServiceProvider.GetRequiredService\n    <OpenIddictApplicationManager<OpenIddictApplication>>(); \n\n    if (await manager.FindByClientIdAsync(\"bfrwebapp\", cancellationToken) == null) \n    { \n      var descriptor = new OpenIddictApplicationDescriptor \n      { \n        ClientId = \"bfrwebapp\", \n        DisplayName = \"Business Frayms web application\", \n        PostLogoutRedirectUris = { new Uri(\"http://localhost:8080/signout-oidc\") }, \n        RedirectUris = { new Uri(\"http://localhost:8080/signin-oidc\") } \n      }; \n\n      await manager.CreateAsync(descriptor, cancellationToken); \n    } \n\n    if (await manager.FindByClientIdAsync(\"vendor-api\", cancellationToken) == null) \n    { \n      var descriptor = new OpenIddictApplicationDescriptor \n      { \n        ClientId = \"vendor-api\", \n        ClientSecret = \"846B62D0-DEF9-4215-A99D-86E6B8DAB342\", \n        //RedirectUris = { new Uri(\"http://localhost:12345/api\") } \n      }; \n\n      await manager.CreateAsync(descriptor, cancellationToken); \n    } \n\n  } \n} \n```", "```cs\nAuthorizationController:\n```", "```cs\npublic class AuthorizationController : Controller \n{ \n  private readonly IOptions<IdentityOptions> _identityOptions; \n  private readonly SignInManager<UserEntity> _signInManager; \n  private readonly UserManager<UserEntity> _userManager; \n\n  public AuthorizationController( \n    IOptions<IdentityOptions> identityOptions, \n    SignInManager<UserEntity> signInManager, \n    UserManager<UserEntity> userManager) \n  { \n    _identityOptions = identityOptions; \n    _signInManager = signInManager; \n    _userManager = userManager; \n  } \n\n  [HttpGet(\"~/connect/authorize\")] \n  public async Task<IActionResult> Authorize(OpenIdConnectRequest request) \n  { \n    Debug.Assert(request.IsAuthorizationRequest(), \n    \"The OpenIddict binder for ASP.NET Core MVC is not registered. \" + \n    \"Make sure services.AddOpenIddict().AddMvcBinders() is correctly called.\"); \n\n    if (!User.Identity.IsAuthenticated) \n    { \n      // If the client application request promptless authentication, \n      // return an error indicating that the user is not logged in. \n      if (request.HasPrompt(OpenIdConnectConstants.Prompts.None)) \n      { \n        var properties = new AuthenticationProperties(new Dictionary<string, string> \n        { \n          [OpenIdConnectConstants.Properties.Error] = \n          OpenIdConnectConstants.Errors.LoginRequired, \n          [OpenIdConnectConstants.Properties.ErrorDescription] = \n          \"The user is not logged in.\" \n        }); \n\n        // Ask OpenIddict to return a login_required error to the client application. \n        return Forbid(properties, OpenIdConnectServerDefaults.AuthenticationScheme); \n      } \n\n      return Challenge(); \n    } \n\n    // Retrieve the profile of the logged in user. \n    var user = await _userManager.GetUserAsync(User); \n    if (user == null) \n    { \n      return BadRequest(new OpenIdConnectResponse \n      { \n        Error = OpenIdConnectConstants.Errors.InvalidGrant, \n        ErrorDescription = \"The username/password couple is invalid.\" \n      }); \n    } \n\n    // Create a new authentication ticket. \n    var ticket = await CreateTicketAsync(request, user); \n\n    // Returning a SignInResult will ask OpenIddict to issue \n    the appropriate access/identity tokens. \n    return SignIn(ticket.Principal, ticket.Properties, ticket.AuthenticationScheme); \n  } \n\n  [HttpGet(\"~/connect/logout\")] \n  public async Task<IActionResult> Logout() \n  { \n    // Ask ASP.NET Core Identity to delete the local and external cookies created \n    // when the user agent is redirected from the external identity provider \n    // after a successful authentication flow (e.g Google or Facebook). \n    await _signInManager.SignOutAsync(); \n\n    // Returning a SignOutResult will ask OpenIddict to redirect the user agent \n    // to the post_logout_redirect_uri specified by the client application. \n    return SignOut(OpenIdConnectServerDefaults.AuthenticationScheme); \n  } \n\n  private async Task<AuthenticationTicket> CreateTicketAsync(\n  OpenIdConnectRequest request, UserEntity user) \n  { \n    // Create a new ClaimsPrincipal containing the claims that \n    // will be used to create an id_token, a token or a code. \n    var principal = await _signInManager.CreateUserPrincipalAsync(user); \n\n    // Create a new authentication ticket holding the user identity. \n    var ticket = new AuthenticationTicket(principal, \n    new AuthenticationProperties(), \n    OpenIdConnectServerDefaults.AuthenticationScheme); \n\n    // Set the list of scopes granted to the client application. \n    ticket.SetScopes(new[] \n    { \n      OpenIdConnectConstants.Scopes.OpenId, \n      OpenIdConnectConstants.Scopes.Email, \n      OpenIdConnectConstants.Scopes.Profile, \n      OpenIddictConstants.Scopes.Roles \n    }.Intersect(request.GetScopes())); \n\n    ticket.SetResources(\"vendor-api\"); \n\n    // Note: by default, claims are NOT automatically included in \n    // the access and identity tokens. \n    // To allow OpenIddict to serialize them, you must attach them a destination, that specifies \n    // whether they should be included in access tokens, in identity tokens or in both. \n\n    foreach (var claim in ticket.Principal.Claims) \n    { \n      // Never include the security stamp in the access and \n      // identity tokens, as it's a secret value. \n      if (claim.Type == _identityOptions.Value.ClaimsIdentity.SecurityStampClaimType) \n      { \n        continue; \n      } \n\n      var destinations = new List<string> \n      { \n        OpenIdConnectConstants.Destinations.AccessToken \n      }; \n\n      // Only add the iterated claim to the id_token if \n      // the corresponding scope was granted to the client application. \n      // The other claims will only be added to the access_token, \n      // which is encrypted when using the default format. \n      if ((claim.Type == OpenIdConnectConstants.Claims.Name && \n      ticket.HasScope(OpenIdConnectConstants.Scopes.Profile)) || \n      (claim.Type == OpenIdConnectConstants.Claims.Email && \n      ticket.HasScope(OpenIdConnectConstants.Scopes.Email)) || \n      (claim.Type == OpenIdConnectConstants.Claims.Role && \n      ticket.HasScope(OpenIddictConstants.Claims.Roles))) \n      { \n        destinations.Add(OpenIdConnectConstants.Destinations.IdentityToken); \n      } \n\n      claim.SetDestinations(destinations); \n    } \n\n    return ticket; \n  } \n} \n```", "```cs\nVendorMaster class:\n```", "```cs\npublic class VendorMaster : BaseEntity \n{ \n  [Key] \n  public int ID { get; set; } \n  public string VendorName { get; set; } \n  public string ContractNumber { get; set; } \n  public string Email { get; set; } \n  public string Title { get; set; } \n  public string PrimaryContactPersonName{ get; set; } \n  public string PrimaryContactEmail { get; set; } \n  public string PrimaryContactNumber { get; set; } \n  public string SecondaryContactPersonName { get; set; } \n  public string SecondaryContactEmail { get; set; } \n  public string SecondaryContactNumber { get; set; } \n  public string Website { get; set; } \n  public string FaxNumber { get; set; } \n  public string AddressLine1 { get; set; } \n  public string AddressLine2 { get; set; } \n  public string City { get; set; } \n  public string State { get; set; } \n  public string Country { get; set; } \n\n  public List<VendorDocument> VendorDocuments { get; set; } \n\n} \nVendorDocument class:\n```", "```cs\npublic class VendorDocument : BaseEntity \n{ \n\n  [Key] \n  public int ID { get; set; } \n  public string DocumentName { get; set; } \n  public string DocumentType { get; set; } \n  public Byte[] DocumentContent { get; set; } \n  public DateTime DocumentExpiry { get; set; } \n\n  public int VendorMasterID { get; set; } \n\n  [ForeignKey(\"VendorMasterID\")] \n  public VendorMaster VendorMaster { get; set; } \n\n} \nIVendorRepository interface:\n```", "```cs\npublic interface IVendorRepository : IRepository<VendorMaster> \n{ \n  VendorMaster Add(VendorMaster vendorMaster); \n\n  void Update(VendorMaster vendorMaster); \n\n  Task<VendorMaster> GetAsync(int vendorID); \n\n  void Add(VendorDocument vendorDocument); \n\n  void Delete(int vendorDocumentID); \n} \n```", "```cs\npublic class VendorDBContext : DbContext, IUnitOfWork \n{ \n\n  public VendorDBContext(DbContextOptions options) : base(options) \n  { \n\n  } \n\n  protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) \n  { \n    base.OnConfiguring(optionsBuilder); \n    //  optionsBuilder.UseSqlServer(@\"Data Source=.sqlexpress;\n    Initial Catalog=FraymsVendorDB;Integrated Security=False; User Id=sa; \n    Password=P@ssw0rd; Timeout=500000;\"); \n  } \n\n  protected override void OnModelCreating(ModelBuilder builder) \n  { \n    base.OnModelCreating(builder); \n  } \n\n  public void BeginTransaction() \n  { \n    this.Database.BeginTransaction(); \n  } \n  public void RollbackTransaction() \n  { \n    this.Database.RollbackTransaction(); \n  } \n  public void CommitTransaction() \n  { \n    this.Database.CommitTransaction(); \n  } \n  public Task<bool> SaveChangesAsync() \n  { \n    return this.SaveChangesAsync(); \n  } \n\n  public DbSet<VendorMaster> VendorMaster { get; set; } \n  public DbSet<VendorDocument> VendorDocuments { get; protected set; } \n```", "```cs\npublic class VendorRepository : IVendorRepository \n{ \n\n  VendorDBContext _dbContext; \n\n  public VendorRepository(VendorDBContext dbContext) \n  { \n    this._dbContext = dbContext; \n  } \n\n  public IUnitOfWork UnitOfWork \n  { \n    get \n    { \n      return _dbContext; \n    } \n  } \n\n  public VendorMaster Add(VendorMaster vendorMaster) \n  { \n    var res= _dbContext.Add(vendorMaster); \n    return res.Entity; \n  } \n\n  public void AddDocument(VendorDocument vendorDocument) \n  { \n    var res = _dbContext.Add(vendorDocument); \n  } \n\n  public void Update(VendorMaster vendorMaster) \n  { \n    _dbContext.Entry(vendorMaster).State = Microsoft.EntityFrameworkCore.EntityState.Modified; \n  } \n\n  public async Task<VendorMaster> GetAsync(int vendorID) \n  { \n    var vendorMaster = await _dbContext.VendorMaster.FindAsync(vendorID); \n    if (vendorMaster != null) \n    { \n      await _dbContext.Entry(vendorMaster) \n      .Collection(i => i.VendorDocuments).LoadAsync(); \n    } \n    return vendorMaster; \n  } \n\n  public IQueryable<T> All<T>() where T : BaseEntity \n  { \n    return _dbContext.Set<T>().AsQueryable(); \n  } \n\n  public bool Contains<T>(Expression<Func<T, bool>> predicate) where T : BaseEntity \n  { \n    return _dbContext.Set<T>().Count<T>(predicate) > 0; \n  } \n\n  public T Find<T>(Expression<Func<T, bool>> predicate) where T : BaseEntity \n  { \n    return _dbContext.Set<T>().FirstOrDefault<T>(predicate); \n  }       \n}\n```", "```cs\nCreateVendorCommand:\n```", "```cs\npublic class CreateVendorCommand : IRequest<bool> \n{ \n\n  [DataMember] \n  public VendorViewModel VendorViewModel { get; set; } \n\n  public CreateVendorCommand(VendorViewModel vendorViewModel) \n  { \n    VendorViewModel = vendorViewModel; \n  } \n\n} \n```", "```cs\nCreateVendorCommandHandler:\n```", "```cs\npublic class CreateVendorCommandHandler : IRequestHandler<CreateVendorCommand, bool> \n{ \n  private readonly IVendorRepository _vendorRepository; \n\n  public CreateVendorCommandHandler(IVendorRepository vendorRepository) \n  { \n    _vendorRepository = vendorRepository; \n  } \n\n  public async Task<bool> Handle(CreateVendorCommand command, \n  CancellationToken cancellationToken) \n  { \n\n    _vendorRepository.UnitOfWork.BeginTransaction(); \n    try \n    { \n      _vendorRepository.Add(command.VendorMaster); \n      _vendorRepository.UnitOfWork.CommitTransaction(); \n    }catch(Exception ex) \n    { \n      _vendorRepository.UnitOfWork.RollbackTransaction(); \n    } \n    return await _vendorRepository.UnitOfWork.SaveChangesAsync();            } \n} \n```", "```cs\nCreateVendorNotification event that will be used by the notification handlers:\n```", "```cs\npublic class CreateVendorNotification : INotification \n{  \n  public VendorMaster _vendorVM; \n  public CreateVendorNotification(VendorMaster vendorVM) \n  { \n    _vendorVM = vendorVM; \n  }  \n} \nCreateUserHandler:\n```", "```cs\npublic class CreateUserHandler : INotificationHandler<CreateVendorNotification> \n{ \n  IResilientHttpClient _client;  \n  public CreateUserHandler(IResilientHttpClient client) \n  { \n    _client = client; \n  } \n  public Task Handle(CreateVendorNotification notification, CancellationToken cancellationToken) \n  { \n    string uri = \"http://businessfrayms.com/api/Identity\"; \n    string token = \"\";//read token from user session \n    var response = _client.Post<VendorMaster>(uri, notification._vendorVM,\"\"); \n    return Task.FromResult(0);  \n  } \n} \nSendEmailHandler:\n```", "```cs\npublic class SendEmailHandler : INotificationHandler<CreateVendorNotification> \n{ \n\n  MessagingService _service; \n\n  public SendEmailHandler(MessagingService service) : base() \n  { \n    _service = service; \n  } \n\n  public Task Handle(CreateVendorNotification notification, CancellationToken cancellationToken) \n  { \n    _service.SendEmail(notification._vendorVM.Email, \"Registration\", \n    \"Thankyou for registration\"); \n    return Task.FromResult(0); \n  } \n} \n```", "```cs\nVendorController:\n```", "```cs\n[Produces(\"application/json\")] \n[Route(\"api/Vendor\")] \npublic class VendorController : BaseController \n{ \n  private readonly IMediator _mediator; \n  private ILogger _logger; \n\n  public VendorController(IMediator mediator, ILogger logger) : base(logger) \n  { \n    _mediator = mediator; \n    _logger = logger; \n  } \n\n  [Authorize(AuthenticationSchemes = OAuthIntrospectionDefaults.AuthenticationScheme)] \n  // POST: api/VendorMaster \n  [HttpPost] \n  public void Post([FromBody]VendorMaster value) \n  { \n    try \n    { \n\n      bool result = _mediator.Send(new CreateVendorCommand(value)).Result; \n      if (result) \n      { \n        //Record saved succesfully, publishing event now \n        _mediator.Publish(new CreateVendorNotification(value)); \n      } \n    } \n    catch (Exception ex) \n    { \n      _logger.LogError(ex.Message); \n    } \n  } \n\n}\n```", "```cs\nversion: '1' \n\nservices: \n  vendor.api: \n    image: vendor.api \n    build: \n      context: . \n      dockerfile: srcmicroservicesVendorVendor.APIDockerfile \n\n  identity.api: \n    image: identity.api \n    build: \n      context: . \n      dockerfile: srcmicroservicesAuthServerIdentity.AuthServerDockerfile \n```", "```cs\nFROM microsoft/aspnetcore:2.0-nanoserver-1709 AS base \nWORKDIR /app \nEXPOSE 80 \n\nFROM microsoft/aspnetcore-build:2.0-nanoserver-1709 AS build \nWORKDIR /src    \nCOPY *.sln ./ \nCOPY src/microservices/Vendor/Vendor.API/Vendor.API.csproj src/microservices/Vendor/Vendor.API/ \nRUN dotnet restore \nCOPY . . \nWORKDIR /src/src/microservices/Vendor/Vendor.API \nRUN dotnet build -c Release -o /app \n\nFROM build AS publish \nRUN dotnet publish -c Release -o /app \n\nFROM base AS final \nWORKDIR /app \nCOPY --from=publish /app . \nENTRYPOINT [\"dotnet\", \"Vendor.API.dll\"] \n\n```", "```cs\ndocker-compose up \n```", "```cs\ndocker ps \n```", "```cs\ndocker inspect -f \"{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}\" containerid  \n```"]