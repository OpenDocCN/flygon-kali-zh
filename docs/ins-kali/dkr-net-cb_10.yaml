- en: Chapter 10. Leveraging IPv6
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。利用IPv6
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下教程：
- en: IPv6 command-line basics
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv6命令行基础知识
- en: Enabling IPv6 capabilities in Docker
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker中启用IPv6功能
- en: Working with IPv6-enabled containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IPv6启用的容器
- en: Configuring NDP proxying
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置NDP代理
- en: User-defined networks and IPv6
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的网络和IPv6
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Up until this point in the book, we've focused solely on IPv4 networking. However,
    IPv4 is not the only IP protocol available to us. Although IPv4 is still the most
    widely understood protocol, IPv6 has started to gain significant attraction. Public
    IPv4 space is exhausted and many are starting to foresee issues with running out
    of private IPv4 allocations as well. IPv6 looks to overcome this problem by defining
    a much larger set of usable IP space. However, IPv6 does some things differently
    from IPv4 making some believe that implementing IPv6 would be cumbersome. I would
    argue that as you look to deploy container technology, you should also be looking
    at how to effectively leverage IPv6\. Although IPv6 is a different animal, it
    will soon become a requirement in many networks. With containers representing
    the possibility of introducing many more IP endpoints on your network making the
    transition sooner rather than later is a good idea. In this chapter, we'll look
    at what IPv6 features Docker currently supports.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的这一部分，我们一直专注于IPv4网络。然而，IPv4并不是我们唯一可用的IP协议。尽管IPv4仍然是最广为人知的协议，但IPv6开始引起了重大关注。公共IPv4空间已经耗尽，许多人开始预见到私有IPv4分配用尽的问题。IPv6看起来可以通过定义更大的可用IP空间来解决这个问题。然而，IPv6与IPv4有一些不同之处，使一些人认为实施IPv6将会很麻烦。我认为，当你考虑部署容器技术时，你也应该考虑如何有效地利用IPv6。尽管IPv6是一个不同的协议，但它很快将成为许多网络的要求。随着容器代表着在你的网络上引入更多IP端点的可能性，尽早进行过渡是一个好主意。在本章中，我们将看看Docker目前支持的IPv6功能。
- en: IPv6 command-line basics
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv6命令行基础知识
- en: Even if you understand the basics of the IPv6 protocol, working with IPv6 on
    a Linux host for the first time can be a bit daunting. Much like IPv4, IPv6 has
    its own unique set of command-line tools that can be leveraged to configure and
    troubleshoot IPv6 connectivity. Some of these tools are the same that we used
    with IPv4 and just use a slightly different syntax. Other tools are completely
    unique to IPv6\. In this recipe, we'll walk through configuring and verifying
    basic IPv6 connectivity.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你了解IPv6协议的基础知识，第一次在Linux主机上使用IPv6可能会有点令人畏惧。与IPv4类似，IPv6有其独特的一套命令行工具，可以用来配置和排除IPv6连接问题。其中一些工具与我们在IPv4中使用的相同，只是语法略有不同。其他工具则是完全独特于IPv6。在这个教程中，我们将介绍如何配置和验证基本的IPv6连接。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using a small lab consisting of two Linux hosts:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，我们将使用由两个Linux主机组成的小型实验室：
- en: '![Getting ready](graphics/5453_10_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/5453_10_01.jpg)'
- en: Each host has both an IPv4 address as well as an IPv6 address assigned to its
    physical interface. You'll need root-level access to each host to make network
    configuration changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每台主机都分配了一个IPv4地址和一个IPv6地址给其物理接口。你需要root级别的访问权限来对每台主机进行网络配置更改。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The intent of this recipe is not to teach the basics of IPv6 or IPv6 network
    design. The examples in this recipe are for example purposes only. Although we
    may cover some of the basics during the examples, it is assumed that the reader
    has a base understanding of how the IPv6 protocol works.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个教程的目的不是教授IPv6或IPv6网络设计的基础知识。本教程中的示例仅供举例。虽然在示例中我们可能会涵盖一些基础知识，但假定读者已经对IPv6协议的工作原理有基本的了解。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'As shown in the preceding figure, each Linux host has been assigned both an
    IPv4 and an IPv6 IP address. These were both configured as part of the host''s
    network configuration script. The following are sample configurations from each
    of the two lab hosts:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，每台Linux主机都被分配了IPv4和IPv6 IP地址。这些都是作为主机网络配置脚本的一部分进行配置的。以下是两台实验主机的示例配置：
- en: '`net1.lab.lab`'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net1.lab.lab`'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`net2.lab.lab`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net2.lab.lab`'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that in each case, we''re adding the IPv6 address to the existing physical
    network interface. In this type of configuration, both the IPv4 and IPv6 addresses
    coexist on the same NIC. This is commonly referred to as running **dual stack**
    since both protocols share the same physical adapter. Once configured, you''ll
    need to reload the interfaces for the configuration to take effect. You should
    then be able to confirm that each host has the correct configuration by either
    using the `ifconfig` tool or the `ip` (`iproute2`) toolset:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在每种情况下，我们都将IPv6地址添加到现有的物理网络接口上。在这种类型的配置中，IPv4和IPv6地址共存于同一个网卡上。这通常被称为运行**双栈**，因为两种协议共享同一个物理适配器。配置完成后，您需要重新加载接口以使配置生效。然后，您应该能够通过使用`ifconfig`工具或`ip`（`iproute2`）工具集来确认每台主机是否具有正确的配置：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The advantage of using the older `ifconfig` tool is that you can see the IPv4
    and IPv6 interface information at the same time. When using the `ip` tool, you
    need to specify that you wish to see IPv6 information by passing the `-6` flag.
    We'll see this is the same case later on when we use the `ip` tool for configuration
    of IPv6 interfaces.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用较旧的`ifconfig`工具的优势在于您可以同时看到IPv4和IPv6接口信息。当使用`ip`工具时，您需要通过传递`-6`标志来指定您希望看到IPv6信息。当我们在后面使用`ip`工具配置IPv6接口时，我们将看到这种情况是一样的。
- en: In either case, both hosts now appear to be configured for IPv6 on their `eth0`
    interfaces. However, note that we actually have two IPv6 addresses defined. You'll
    notice that one address has a scope of local and the other has a scope of global.
    In IPv6, each IP interface gets assigned both a global and a local IPv6 address.
    The locally scoped interface is only valid for communication on the link it is
    assigned on and is commonly used to reach neighboring devices on the same segment.
    In most cases, the link local address is dynamically determined by the host itself.
    This means that an IPv6-enabled interface almost always has a link local IPv6
    address defined even if you haven't specifically configured a global IPv6 address
    on the interface. Packets using link local IP addresses are never forwarded by
    a router which restricts them to the segment they are defined on. For the majority
    of our discussion, we'll be focusing on the global address.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在任一情况下，两台主机现在似乎都已经在它们的`eth0`接口上配置了IPv6。但是，请注意，实际上我们定义了两个IPv6地址。您会注意到一个地址的范围是本地的，另一个地址的范围是全局的。在IPv6中，每个IP接口都被分配了全局和本地IPv6地址。本地范围的接口仅对其分配的链路上的通信有效，并且通常用于到达同一段上的相邻设备。在大多数情况下，链路本地地址是由主机自己动态确定的。这意味着几乎每个启用IPv6的接口都有一个链路本地IPv6地址，即使您没有在接口上专门配置全局IPv6地址。使用链路本地IP地址的数据包永远不会被路由器转发，这将限制它们在定义的段上。在我们的大部分讨论中，我们将专注于全局地址。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Any further reference to an IPv6 address is referring to a globally scoped IPv6
    address unless otherwise noted.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对IPv6地址的进一步引用都是指全局范围的IPv6地址，除非另有说明。
- en: 'Since both of our hosts are on the same subnet, we should be able to reach
    one server from the other using IPv6:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的两台主机都在同一个子网上，我们应该能够使用IPv6从一台服务器到达另一台服务器：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that instead of using the standard ping tool, we're using the `ping6` tool
    to verify IPv6 reachability.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`ping6`工具而不是标准的ping工具来验证IPv6的可达性。
- en: The last thing we want to check is the neighbor discovery table. Another major
    change with IPv6 is that it doesn't use ARP to find the hardware or MAC address
    of an IP endpoint. The major reason for this is that IPv6 does not support broadcast
    traffic. ARP relies on broadcasts to work, so it couldn't be used in IPv6\. Instead,
    IPv6 uses neighbor discovery, which leverages multicast.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要检查的最后一件事是邻居发现表。IPv6的另一个重大变化是它不使用ARP来查找IP端点的硬件或MAC地址。这样做的主要原因是IPv6不支持广播流量。ARP依赖广播来工作，因此不能在IPv6中使用。相反，IPv6使用邻居发现，它利用多播。
- en: 'That being said, you need to look at the neighbor discovery table rather than
    the ARP table when troubleshooting local network. To do this, we can use the familiar
    `iproute2` toolset:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，当排除本地网络故障时，您需要查看邻居发现表，而不是ARP表。为此，我们可以使用熟悉的`iproute2`工具集：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Much like the ARP table, the neighbor table shows us the hardware or MAC address
    of the IPv6 address we wish to reach. Note that as before we passed the `-6` flag
    to the `ip` command to tell it we wanted IPv6 information.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 与ARP表类似，邻居表向我们显示了我们希望到达的IPv6地址的硬件或MAC地址。请注意，与之前一样，我们向`ip`命令传递了`-6`标志，告诉它我们需要IPv6信息。
- en: 'Now that we have basic connectivity, let''s add a new IPv6 interface to each
    host. To do that, we follow almost the same steps we did when we added an IPv4
    interface. For instance, adding a dummy interface is almost identical:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了基本的连接性，让我们在每个主机上添加一个新的IPv6接口。为此，我们几乎可以按照添加IPv4接口时所做的相同步骤进行操作。例如，添加虚拟接口几乎是相同的：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note that the only difference is that we need to tell `iproute2` that we''re
    specifying a IPv6 address by once again passing the `-6` flag. In all other regards,
    the configuration is identical to how we did this in IPv4\. Let''s configure another
    dummy interface on the second host as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，唯一的区别是我们需要再次传递`-6`标志，告诉`iproute2`我们正在指定一个IPv6地址。在其他方面，配置与我们在IPv4中所做的方式完全相同。让我们也在第二个主机上配置另一个虚拟接口：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this point, our topology now looks as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的拓扑现在如下所示：
- en: '![How to do it…](graphics/5453_10_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](graphics/5453_10_02.jpg)'
- en: 'Let''s now check the IPv6 routing table on each host. As before we can also
    use the `iproute2` tool to check the IPv6 routing table:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们检查每个主机的IPv6路由表。与之前一样，我们也可以使用`iproute2`工具来检查IPv6路由表：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As we can see, each host knows about its directly connected interfaces but
    does not know about the other hosts dummy interface. In order for either host
    to reach the other hosts dummy interface, we''re going to need to route to get
    to it. Since these hosts are directly connected, this could be solved by adding
    a default IPv6 route. Each default route would reference the other host as the
    next hop. Although that''s doable, let''s instead add specific routes to each
    host that reference the network that the dummy interface is in:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，每个主机都知道自己直接连接的接口，但不知道其他主机的虚拟接口。为了使任何一个主机能够到达其他主机的虚拟接口，我们需要进行路由。由于这些主机是直接连接的，可以通过添加默认的IPv6路由来解决。每个默认路由将引用另一个主机作为下一跳。虽然这是可行的，但让我们改为向每个主机添加特定路由，引用虚拟接口所在的网络：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After adding these routes, either host should be able to reach the other hosts
    `ipv6_dummy` interface:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 添加这些路由后，任何一个主机都应该能够到达其他主机的`ipv6_dummy`接口：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You'll likely notice that just adding one route on a single host will allow
    that host to reach the dummy interface on the other host. This is because we only
    need the route to get the traffic off the initiating host. The traffic will be
    sourced by the hosts `eth0` interface (`2003:ab11::/64`), which the other host
    knows how to get to inherently. If the ping was sourced from the dummy interface,
    you'd need both routes for this to work.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，只在单个主机上添加一个路由就可以使该主机到达另一个主机上的虚拟接口。这是因为我们只需要路由来将流量从发起主机上移出。流量将由主机的 `eth0`
    接口（`2003:ab11::/64`）发出，而另一个主机知道如何到达它。如果 ping 是从虚拟接口发出的，您需要这两个路由才能使其正常工作。
- en: 'Now that we''ve configured and verified basic connectivity, let''s take one
    final step and rebuild these interfaces using network namespaces. To do that,
    let''s first clean up the dummy interfaces since we''ll be reusing those IPv6
    subnets inside the namespaces:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置并验证了基本的连接性，让我们迈出最后一步，使用网络命名空间重建这些接口。为此，让我们首先清理虚拟接口，因为我们将在命名空间内重用这些 IPv6
    子网：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The configuration we''re after will look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要配置的配置如下：
- en: '![How to do it…](graphics/5453_10_03.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤…](graphics/5453_10_03.jpg)'
- en: Although very similar to the last configuration, there are two major differences.
    You'll notice that we are now using network namespaces to encapsulate the new
    interfaces. In doing so, we've configured the IPv6 address for the new interface
    on one side of a VETH pair. The other end of the VETH pair lives on the host in
    the default network namespace.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与上一个配置非常相似，但有两个主要区别。您会注意到我们现在使用网络命名空间来封装新接口。这样做，我们已经为 VETH 对的一端配置了新接口的 IPv6
    地址。VETH 对的另一端位于默认网络命名空间中的主机上。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren't comfortable with some of these Linux networking constructs, please
    review [Chapter 1](ch01.html "Chapter 1. Linux Networking Constructs"), *Linux
    Networking Constructs*, where we discuss namespaces and VETH interfaces in much
    greater detail.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对一些 Linux 网络构造不太熟悉，请查看[第1章](ch01.html "第1章. Linux 网络构造")中的 *Linux 网络构造*，在那里我们会更详细地讨论命名空间和
    VETH 接口。
- en: 'To configure this, we''ll apply the following configuration:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行配置，我们将应用以下配置：
- en: 'Add a new network namespace named `net1_ns`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个名为 `net1_ns` 的新网络命名空间：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a VETH pair naming one end `host_veth1` and the other end `ns_veth1`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `host_veth1` 的 VETH 对，并将另一端命名为 `ns_veth1`：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Move the namespace side of the VETH pair into the namespace:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将 VETH 对的命名空间端移入命名空间：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Within the namespace, give the VETH interface an IP address:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内，给 VETH 接口分配一个 IP 地址：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Within the namespace, bring the interface up:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内，启动接口：
- en: '[PRE15]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within the namespace, add a route to reach the namespace on the other host:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名空间内，添加一个路由以到达另一个主机上的命名空间：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Give the host side of the VETH pair an IP address:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给 VETH 对的主机端分配一个 IP 地址：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Bring the host side of VETH interface up:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 VETH 接口的主机端：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we only added a route within the namespace to reach the other namespace.
    We did not add the same route on the Linux host. This is because we already did
    this earlier in the recipe in order to reach the dummy interface. If you removed
    that route, you'll need to add it back for this to work.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们只在命名空间内添加了一个路由以到达另一个命名空间。我们没有在 Linux 主机上添加相同的路由。这是因为我们之前已经在配方中添加了这个路由，以便到达虚拟接口。如果您删除了该路由，您需要将其添加回来才能使其正常工作。
- en: 'We must now perform a similar configuration on the second host:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在必须在第二个主机上执行类似的配置：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once this is added, you should be able to verify that each namespace has the
    routing information required to reach the other hosts namespace:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加后，您应该能够验证每个命名空间是否具有到达其他主机命名空间所需的路由信息：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'But when we try to reach from namespace to namespace, the connection fails:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们尝试从一个命名空间到另一个命名空间时，连接失败：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is because we''re now trying to use the Linux host as a router. If you
    recall from earlier chapters when we want the Linux kernel to forward or route
    packets we have to enable that functionality. This is done by changing these two
    kernel parameters on each host:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们现在正在尝试将Linux主机用作路由器。如果您回忆起早期章节，当我们希望Linux内核转发或路由数据包时，我们必须启用该功能。这是通过更改每个主机上的这两个内核参数来完成的：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that these settings won't persist through a reboot when defined
    in this manner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以这种方式定义的设置在重新启动时不会持久保存。
- en: 'Once these settings are made on both hosts, your ping should now begin to work:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在两个主机上进行了这些设置，您的ping现在应该开始工作：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As an interesting side note, check your neighbor table on the host once you''ve
    enabled IPv6 forwarding in the kernel:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在启用内核中的IPv6转发后，检查主机上的邻居表：
- en: '[PRE24]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Can you notice anything different about the neighbor entry for the other Linux
    host? It now has the `router` flag as part of the neighbor definition. The Linux
    host advertises itself as a router on the segment when IPv6 forwarding is enabled
    in the kernel.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到另一个Linux主机的邻居条目有什么不同之处？现在，它的邻居定义中包含`router`标志。当Linux主机在内核中启用IPv6转发时，它会在该段上作为路由器进行广告。
- en: Enabling IPv6 capabilities in Docker
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用Docker中的IPv6功能
- en: IPv6 functionality is disabled by default in Docker. Much like other features
    we reviewed earlier, enabling it requires doing so at the service level. Once
    enabled, Docker will provision the host interfaces associated with Docker, as
    well as the containers themselves, with IPv6 addressing.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Docker中默认禁用IPv6功能。与我们之前审查的其他功能一样，要启用它需要在服务级别进行设置。一旦启用，Docker将为与Docker关联的主机接口以及容器本身提供IPv6地址。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'In this recipe, we''ll be using a small lab consisting of two Docker hosts:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用由两个Docker主机组成的小型实验室：
- en: '![Getting ready](graphics/5453_10_04.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![准备就绪](graphics/5453_10_04.jpg)'
- en: Each host has both an IPv4 address as well as an IPv6 address assigned to its
    physical interface. You'll need root-level access to each host to make network
    configuration changes. It is assumed that Docker is installed, and it's a default
    configuration.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主机都有分配给其物理接口的IPv4地址和IPv6地址。您需要对每个主机进行网络配置更改的根级访问权限。假定已安装了Docker，并且它是默认配置。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: As mentioned, Docker will not provision containers with an IPv6 address unless
    told to do so. To enable IPv6 in Docker, we need to pass a service-level flag
    to the Docker service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，除非告知，Docker不会为容器提供IPv6地址。要在Docker中启用IPv6，我们需要向Docker服务传递一个服务级标志。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need a refresher on defining Docker service-level parameters, see the
    last recipe in [Chapter 2](ch02.html "Chapter 2. Configuring and Monitoring Docker
    Networks"), *Configuring and Monitoring Docker Networks*, where we discuss configuring
    these on a system running `systemd`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要复习定义Docker服务级参数，请参阅[第2章](ch02.html "第2章。配置和监视Docker网络")中的最后一个示例，*配置和监视Docker网络*，在那里我们讨论了在运行`systemd`的系统上配置这些参数。
- en: 'In addition to enabling IPv6 functionality, you also need to define a subnet
    for the `docker0` bridge. To do this, we''ll modify our `systemd` drop-in file
    for Docker and make sure that it has the following options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启用IPv6功能，您还需要为`docker0`桥定义一个子网。为此，我们将修改Docker的`systemd`附加文件，并确保它具有以下选项：
- en: 'On the host `docker1`:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机`docker1`上：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'On the host `docker2`:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主机`docker2`上：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If we apply this configuration, reload the `systemd` configuration and restart
    the Docker service on each host, we should see that the `docker0` bridge has taken
    the first available IP address from the defined IPv6 CIDR range:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们应用此配置，在每个主机上重新加载`systemd`配置并重新启动Docker服务，我们应该会看到`docker0`桥已经从定义的IPv6 CIDR范围中获取了第一个可用的IP地址：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'At this point, our topology looks a lot like it did in the first recipe:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的拓扑结构看起来很像第一个配方中的样子：
- en: '![How to do it…](graphics/5453_10_05.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤](graphics/5453_10_05.jpg)'
- en: 'Docker will issue an IPv6 address along with an IPv4 address to each container
    it creates. Let''s spin up a container on the first host to see what I mean:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将为其创建的每个容器分配一个IPv6地址和一个IPv4地址。让我们在第一个主机上启动一个容器，看看我的意思是什么：
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that we did not pass the `-P` flag to the containers to publish the containers
    exposed ports. If we test locally, we can validate that the host can reach the
    service within the container from both the containers IPv4 and IPv6 address:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有向容器传递`-P`标志来发布容器暴露的端口。如果我们在本地测试，我们可以验证主机可以从容器的IPv4和IPv6地址访问容器内的服务：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When using `curl` with IPv6 addresses, you need to put the IPv6 address inside
    of brackets and then tell `curl` not to glob by passing the `-g` flag.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用带有IPv6地址的`curl`时，您需要将IPv6地址放在方括号中，然后通过传递`-g`标志告诉`curl`不要进行全局匹配。
- en: 'As we can see, the behavior with the IPv6 address is the same as it is with
    the IPv4 address. Following suit, containers on the same host can talk directly
    to each other across the `docker0` bridge using their assigned IPv6 address. Let''s
    start a second container on the same host:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，IPv6地址的行为与IPv4地址的行为相同。随之而来，同一主机上的容器可以使用其分配的IPv6地址直接相互通信，跨过`docker0`桥。让我们在同一主机上启动第二个容器：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A quick validation will prove to us that these two containers are allowed to
    talk directly to one another with their IPv6 addresses just as expected:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 快速验证将向我们证明这两个容器可以像预期的那样使用其IPv6地址直接相互通信：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Working with IPv6-enabled containers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用IPv6启用的容器
- en: In the previous recipe, we saw how Docker handles the basic allocation of IPv6-enabled
    containers. The behavior we've seen up to this point has closely mimicked what
    we saw in earlier chapters when only dealing with IPv4 addressed containers. However,
    this is not the case for all of the network functionality. Docker does not currently
    have complete feature parity between IPv4 and IPv6\. Namely, as we'll see in this
    recipe, Docker does not have `iptables` (ip6tables) integration for IPv6 enabled
    containers. In this chapter, we'll review some of the network features that we
    previously visited with IPv4 only enabled containers and see how they act when
    using IPv6 addressing.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个配方中，我们看到了Docker如何处理启用IPv6的容器的基本分配。到目前为止，我们看到的行为与之前章节中处理IPv4地址容器时所看到的行为非常相似。然而，并非所有网络功能都是如此。Docker目前在IPv4和IPv6之间并没有完全的功能对等。特别是，正如我们将在这个配方中看到的，Docker对于启用IPv6的容器并没有`iptables`（ip6tables）集成。在本章中，我们将回顾一些我们之前在仅启用IPv4的容器中访问过的网络功能，并看看在使用IPv6寻址时它们的表现如何。
- en: Getting ready
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll be building off of the lab we built in the previous recipe.
    You'll need root-level access to each host to make network configuration changes.
    It is assumed that Docker is installed, and it's a default configuration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将继续构建上一个配方中构建的实验室。您需要root级别的访问权限来对每个主机进行网络配置更改。假设Docker已安装，并且是默认配置。
- en: How to do it…
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作步骤
- en: As mentioned, Docker does not currently have host firewall, specifically netfilter
    or `iptables`, integration for IPv6\. This means that several of the features
    we relied on previously with IPv4 behave differently when dealing with a containers
    IPv6 address. Let's start with some of the basic functionality. In the previous
    recipe, we saw that two containers on the same host, connected to the `docker0`
    bridge, could talk directly with one another.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker目前没有针对IPv6的主机防火墙，特别是netfilter或`iptables`的集成。这意味着我们以前依赖IPv4的几个功能在处理容器的IPv6地址时会有所不同。让我们从一些基本功能开始。在上一个示例中，我们看到了在连接到`docker0`桥接器的同一主机上的两个容器可以直接相互通信。
- en: 'This behavior was expected and works in much the same manner when using IPv4
    addresses. If we wanted to prevent this communication, we might look to disable
    **Inter-Container Communication** (**ICC**) in the Docker service. Let''s update
    our Docker options on the host `docker1` to set ICC to `false`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是预期的，并且在使用IPv4地址时的方式基本相同。如果我们想要阻止这种通信，我们可能会考虑在Docker服务中禁用**容器间通信**（**ICC**）。让我们更新主机`docker1`上的Docker选项，将ICC设置为`false`：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we can reload the `systemd` configuration, restart the Docker service,
    and restart the containers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以重新加载`systemd`配置，重新启动Docker服务，并重新启动容器：
- en: '[PRE33]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, the attempt on IPv4 fails and the subsequent IPv6 attempt works.
    Since Docker is not managing any firewall rules related to the containers IPv6
    address, there is nothing to prevent direct connectivity between IPv6 addresses.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，IPv4尝试失败，随后的IPv6尝试成功。由于Docker没有管理与容器的IPv6地址相关的防火墙规则，因此没有任何阻止IPv6地址之间直接连接的内容。
- en: 'Since Docker isn''t managing IPv6-related firewall rules, you might also assume
    that features like outbound masquerade and port publishing no longer work as well.
    And while this is true in the sense that Docker is not creating IPv6 associated
    NAT rules and firewall policy, it does not mean that a containers IPv6 address
    is not reachable from the outside network. Let''s walk through an example to show
    you what I mean. Let''s start a container on the second Docker host:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker没有管理与IPv6相关的防火墙规则，您可能还会认为出站伪装和端口发布等功能也不再起作用。虽然这在某种意义上是正确的，即Docker不会创建IPv6相关的NAT规则和防火墙策略，但这并不意味着容器的IPv6地址无法从外部网络访问。让我们通过一个示例来向您展示我的意思。让我们在第二个Docker主机上启动一个容器：
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that when we ran the container on the host `docker2` that we passed the
    `-P` flag to tell Docker to publish the exposed ports of the container. If we
    check the port mapping, we can see that the host has chosen port `32768`. Note
    that the port mapping indicates an IP address of `0.0.0.0`, which typically indicates
    any IPv4 address. Let''s perform some quick tests from the other Docker host to
    validate what is and isn''t working:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们在主机`docker2`上运行容器时，我们传递了`-P`标志，告诉Docker发布容器的暴露端口。如果我们检查端口映射，我们可以看到主机选择了端口`32768`。请注意，端口映射指示IP地址为`0.0.0.0`，通常表示任何IPv4地址。让我们从另一个Docker主机执行一些快速测试，以验证工作和不工作的内容：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As expected, the IPv4 port mapping works. We''re able to access the containers
    service through the Docker hosts IPv4 address by leveraging the `iptables` NAT
    rule to map port `32769` to the actual service port of `80`. Let''s now try the
    same example but using the hosts IPv6 address:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，IPv4端口映射起作用。通过利用`iptables` NAT规则将端口`32769`映射到实际服务端口`80`，我们能够通过Docker主机的IPv4地址访问容器的服务。现在让我们尝试相同的示例，但使用主机的IPv6地址：
- en: '[PRE36]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Surprisingly, this also works. You might be wondering how this is working considering
    that Docker doesn''t manage or integrate with any of the hosts IPv6 firewall policy.
    The answer is actually quite simple. If we look at the second Docker hosts open
    ports, we''ll see that there is a `docker-proxy` service bound to port `32769`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这也起作用。您可能想知道这是如何工作的，考虑到Docker不管理或集成任何主机IPv6防火墙策略。答案实际上非常简单。如果我们查看第二个Docker主机的开放端口，我们会看到有一个绑定到端口`32769`的`docker-proxy`服务：
- en: '[PRE37]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we saw in earlier chapters, the `docker-proxy` service facilitates inter
    container and published port connectivity. In order for this to work, the `docker-proxy`
    service has to bind to the port in which the container publishes. Recall that
    services listening on all IPv4 interfaces use the syntax of `0.0.0.0` to represent
    all IPv4 interfaces. In a similar fashion, IPv6 interfaces use the syntax of `:::`
    to indicate the same thing. You'll note that the `docker-proxy` port references
    all IPv6 interfaces. Although this may differ based on your operating system,
    binding to all IPv6 interfaces also implies binding to all IPv4 interfaces. That
    is, the preceding `docker-proxy` service is actually listening on all of the hosts
    IPv4 and IPv6 interfaces.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前几章中看到的，`docker-proxy`服务促进了容器之间和发布端口的连接。为了使其工作，`docker-proxy`服务必须绑定到容器发布的端口。请记住，监听所有IPv4接口的服务使用`0.0.0.0`的语法来表示所有IPv4接口。类似地，IPv6接口使用`:::`的语法来表示相同的事情。您会注意到`docker-proxy`端口引用了所有IPv6接口。尽管这可能因操作系统而异，但绑定到所有IPv6接口也意味着绑定到所有IPv4接口。也就是说，前面的`docker-proxy`服务实际上正在监听所有主机的IPv4和IPv6接口。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that `docker-proxy` is not typically used for inbound services.
    Those rely on the `iptables` NAT rules to map the published port to the container.
    However, in the case that those rules don't exist, the host is still listening
    on all of its interfaces for traffic to port `32769`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`docker-proxy`通常不用于入站服务。这些依赖于`iptables` NAT规则将发布的端口映射到容器。但是，在这些规则不存在的情况下，主机仍然在其所有接口上监听端口`32769`的流量。
- en: The net result of this is that despite not having an IPv6 NAT rule, I'm still
    able to access the containers service through the Docker hosts interfaces. In
    this manner, published ports with IPv6 still work. However, this only works when
    using the `docker-proxy`. That mode of operation, while still the default, is
    intended to be removed in favor of hairpin NAT. We can enable hairpin NAT on the
    Docker host by passing the `--userland-proxy=false` parameter to Docker as a service-level
    option. Doing so would prevent this means of IPv6 port publishing from working.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的最终结果是，尽管没有IPv6 NAT规则，我仍然能够通过Docker主机接口访问容器服务。以这种方式，具有IPv6的发布端口仍然有效。但是，只有在使用`docker-proxy`时才有效。尽管这种操作模式仍然是默认的，但打算在hairpin
    NAT的支持下移除。我们可以通过将`--userland-proxy=false`参数传递给Docker作为服务级选项来在Docker主机上启用hairpin
    NAT。这样做将阻止这种IPv6端口发布方式的工作。
- en: Finally, the lack of firewall integration also means that we no longer have
    support for the outbound masquerade feature. In IPv4, this feature allowed containers
    to talk to the outside network without having to worry about routing or IP address
    overlapping. Container traffic leaving the host was always hidden behind one of
    the hosts IP interfaces. However, this was not a mandated configuration. As we
    saw in earlier chapters, you could very easily disable the outbound masquerade
    feature and provision the `docker0` bridge with a routable IP address and subnet.
    So long as the outside, or external, network knew how to reach that subnet, a
    container could very easily have a unique routable IP address.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，缺乏防火墙集成也意味着我们不再支持出站伪装功能。在IPv4中，这个功能允许容器与外部网络通信，而不必担心路由或IP地址重叠。离开主机的容器流量总是隐藏在主机IP接口之一的后面。然而，这并不是一个强制性的配置。正如我们在前几章中看到的，您可以非常容易地禁用出站伪装功能，并为`docker0`桥接分配一个可路由的IP地址和子网。只要外部或外部网络知道如何到达该子网，容器就可以非常容易地拥有一个独特的可路由IP地址。
- en: 'One of the reasons IPv6 came to be was because of the rapid depletion of IPv4
    addresses. NAT in IPv4 served as a largely successful, although equally troublesome,
    temporary stop gap to the address depletion problem. This means that many believe
    that we shouldn''t be implementing any sort of NAT in regard to IPv6 whatsoever.
    Rather, all IPv6 prefixes should be natively routable and reachable without the
    obfuscation of an IP translation. Lacking IPv6 firewall integration, natively
    routing IPv6 traffic to each host is the current means in which Docker can facilitate
    reachability across multiple Docker hosts and the outside network. This requires
    that each Docker host uses a unique IPv6 CIDR range and that the Docker hosts
    know how to reach all of the other Docker hosts defined CIDR range. While this
    typically requires the physical network to have network reachability information,
    in our simple lab example each host just requires a static route to the other
    hosts CIDR. Much like we did in the first recipe, we''ll add an IPv6 route on
    each host so both know how to reach the IPv6 subnet of the other `docker0` bridge:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6出现的一个原因是IPv4地址的迅速枯竭。IPv4中的NAT作为一个相当成功的，尽管同样麻烦的临时缓解了地址枯竭问题。这意味着许多人认为，我们不应该在IPv6方面实施任何形式的NAT。相反，所有IPv6前缀都应该是本地可路由和可达的，而不需要IP转换的混淆。缺乏IPv6防火墙集成，直接将IPv6流量路由到每个主机是Docker实现跨多个Docker主机和外部网络可达性的当前手段。这要求每个Docker主机使用唯一的IPv6
    CIDR范围，并且Docker主机知道如何到达所有其他Docker主机定义的CIDR范围。虽然这通常需要物理网络具有网络可达性信息，在我们简单的实验室示例中，每个主机只需要对其他主机的CIDR添加静态路由。就像我们在第一个配方中所做的那样，我们将在每个主机上添加一个IPv6路由，以便两者都知道如何到达另一个`docker0`桥接的IPv6子网：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'After adding the routes, each Docker host knows how to get to the other host''s
    IPv6 `docker0` bridge subnet:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 添加路由后，每个Docker主机都知道如何到达另一个主机的IPv6 `docker0`桥接子网：
- en: '![How to do it…](graphics/5453_10_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![操作步骤...](graphics/5453_10_06.jpg)'
- en: 'If we now check, we should have reachability between containers on each host:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在检查，我们应该在每个主机上的容器之间有可达性：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, the container on the host `docker1` was able to successfully
    route directly to the container running on the host `docker2`. So as long as each
    Docker host has the appropriate routing information, containers will be able to
    route directly to one another.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，主机`docker1`上的容器能够成功地直接路由到运行在主机`docker2`上的容器。只要每个Docker主机具有适当的路由信息，容器就能够直接路由到彼此。
- en: The downside of this approach is that the container is now a fully exposed network
    endpoint. We no longer get the advantage of exposing only certain ports to the
    outside network through Docker published ports. If you want to ensure that only
    certain ports are exposed on your IPv6 interfaces the userland proxy may be your
    best option at this point. Keep these options in mind when designing services
    around IPv6 connectivity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是容器现在是一个完全暴露的网络端点。我们不再能够通过Docker发布的端口仅暴露某些端口到外部网络的优势。如果您希望确保仅在IPv6接口上暴露某些端口，那么用户态代理可能是您目前的最佳选择。在设计围绕IPv6连接的服务时，请记住这些选项。
- en: Configuring NDP proxying
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置NDP代理
- en: As we saw in the last recipe, one of the major differences with IPv6 support
    in Docker is the lack of the firewall integration. Without that integration, we
    lose things like outbound masquerade and full port publishing capabilities. And
    while this may not be necessary in all cases, there is a certain convenience factor
    that is lost when not using this. For instance, when running in IPv4 only mode,
    an administrator could install Docker and immediately connect your containers
    to the outside network. This is because the container was only ever seen through
    the Docker host's IP addresses for both inbound (published port) and outbound
    (masquerade) connectivity. This meant that there was no need to inform the outside
    network about additional subnets because the outside network only ever saw the
    Docker host's IP addresses. In the IPv6 model, the outside network has to know
    about the container subnets in order to route to them. In this chapter, we'll
    review how to configure NDP proxying as a workaround to this problem.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个教程中看到的，Docker中IPv6支持的一个主要区别是缺乏防火墙集成。没有这种集成，我们失去了出站伪装和完整端口发布功能。虽然这在所有情况下可能并非必要，但当不使用时会失去一定的便利因素。例如，在仅运行IPv4模式时，管理员可以安装Docker并立即将容器连接到外部网络。这是因为容器只能通过Docker主机的IP地址进行入站（发布端口）和出站（伪装）连接。这意味着无需通知外部网络有关额外子网的信息，因为外部网络只能看到Docker主机的IP地址。在IPv6模型中，外部网络必须知道容器子网才能路由到它们。在本章中，我们将讨论如何配置NDP代理作为解决此问题的方法。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In this recipe, we''ll be using this lab topology:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将使用以下实验拓扑：
- en: '![Getting ready](graphics/5453_10_07.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](graphics/5453_10_07.jpg)'
- en: You'll need root-level access to each host to make network configuration changes.
    It is assumed that Docker is installed, and it's a default configuration.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要root级别的访问权限来对每个主机进行网络配置更改。假设Docker已安装，并且是默认配置。
- en: How to do it…
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: The preceding topology shows that our hosts are dual stack connected to the
    network, but Docker has not yet been configured to use IPv6\. Like we saw in the
    previous recipe, configuring Docker for IPv6 would also typically mean configuring
    routing on the outside network, so it knows how to reach the IPv6 CIDR you define
    for the `docker0` bridge to use. However, assume for a moment that this isn't
    possible. Assume that you have no control over the outside network, which means
    you can't advertise or notify other network endpoints about any newly defined
    IPv6 subnet on your Docker host.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的拓扑图显示我们的主机是双栈连接到网络的，但是Docker还没有配置为使用IPv6。就像我们在上一个教程中看到的那样，配置Docker以支持IPv6通常意味着在外部网络上配置路由，以便它知道如何到达您为`docker0`桥定义的IPv6
    CIDR。然而，假设一会儿这是不可能的。假设您无法控制外部网络，这意味着您无法向其他网络端点广告或通知有关Docker主机上任何新定义的IPv6子网。
- en: 'Let''s also assume that while you can''t advertise any newly defined IPv6 networks,
    you are however able to reserve additional IPv6 space within the existing networks.
    For instance, the hosts currently have interfaces defined within the `2003:ab11::/64`
    network. If we carve up this space, we can split it into four `/66` networks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 假设虽然您无法广告任何新定义的IPv6网络，但您可以在现有网络中保留额外的IPv6空间。例如，主机当前在`2003:ab11::/64`网络中定义了接口。如果我们划分这个空间，我们可以将其分割成四个`/66`网络：
- en: '`2003:ab11::/66`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2003:ab11::/66`'
- en: '`2003:ab11:0:0:4000::/66`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2003:ab11:0:0:4000::/66`'
- en: '`2003:ab11:0:0:8000::/66`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2003:ab11:0:0:8000::/66`'
- en: '`2003:ab11:0:0:c000::/66`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2003:ab11:0:0:c000::/66`'
- en: 'Let''s assume for a second that we are allowed to reserve the last two subnets
    for our use. We can now enable IPv6 within Docker and allocate these two networks
    as the IPv6 CIDR ranges. Here are the configuration options for each Docker host:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们被允许为我们的使用保留最后两个子网。我们现在可以在Docker中启用IPv6，并将这两个网络分配为IPv6 CIDR范围。以下是每个Docker主机的配置选项：
- en: '`docker1`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker1`'
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`docker2`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker2`'
- en: '[PRE41]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After loading the new configuration into `systemd` and restarting the Docker
    service, our lab topology would now look like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将新配置加载到`systemd`中并重新启动Docker服务后，我们的实验室拓扑现在看起来是这样的：
- en: '![How to do it…](graphics/5453_10_08.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](graphics/5453_10_08.jpg)'
- en: 'Let''s launch a container on both hosts:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在两个主机上启动一个容器：
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now determine the allocated IPv6 address of the `web1` container:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在确定`web1`容器的分配的IPv6地址：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let''s try and reach that container from the `web2` container:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试从`web2`容器到达该容器：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This fails because the Docker hosts believe that the destination address is
    directly connected to their `eth0` interface. When the `web2` container attempts
    the connection, the following actions occur:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这失败是因为Docker主机认为目标地址直接连接到它们的`eth0`接口。当`web2`容器尝试连接时，会发生以下操作：
- en: The container does a route lookup and determines that the address `2003:ab11::8000:242:ac11:2`
    does not fall within its local subnet of `2003:ab11:0:0:c000::1/66`, so it forwards
    the traffic to its default gateway (the `docker0` bridge interface)
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器进行路由查找，并确定地址`2003:ab11::8000:242:ac11:2`不在其本地子网`2003:ab11:0:0:c000::1/66`内，因此将流量转发到其默认网关（`docker0`桥接口）
- en: The host receives the traffic and does a route lookup and determines that the
    destination address of `2003:ab11::8000:242:ac11:2` falls within its local subnet
    of `2003:ab11::/64` (`eth0`) and uses NDP to try and find the host with that destination
    IP address
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机接收流量并进行路由查找，确定`2003:ab11::8000:242:ac11:2`的目标地址落在其本地子网`2003:ab11::/64`（`eth0`）内，并使用NDP尝试找到具有该目标IP地址的主机
- en: The host receives no response to this query and the flow fails
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机对此查询没有响应，流量失败
- en: 'We can verify that this is what''s happening by checking the `docker2` host''s
    IPv6 neighbor table:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查`docker2`主机的IPv6邻居表来验证这一点：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Following the normal routing logic, everything is working the way it should.
    However IPv6 has a feature called NDP proxy, which can help solve this problem.
    Those of you familiar with proxy ARP in IPv4 will find NDP proxy to provide similar
    functionality. Essentially, NDP proxy allows a host to answer neighbor requests
    on behalf of another endpoint. In our case, we can tell both Docker hosts to answer
    on behalf of the containers. To do this, we need to first enable NDP proxy on
    the host itself. This is done by enabling the kernel parameter `net.ipv6.conf.eth0.proxy_ndp`,
    as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照正常的路由逻辑，一切都按预期工作。然而，IPv6有一个叫做NDP代理的功能，可以帮助解决这个问题。熟悉IPv4中代理ARP的人会发现NDP代理提供了类似的功能。基本上，NDP代理允许主机代表另一个端点回答邻居请求。在我们的情况下，我们可以告诉两个Docker主机代表容器回答。为了做到这一点，我们首先需要在主机上启用NDP代理。这是通过启用内核参数`net.ipv6.conf.eth0.proxy_ndp`来完成的，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that these settings won't persist through a reboot when defined
    in this manner.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，以这种方式定义的设置在重启后不会持久保存。
- en: 'Once that is enabled, we need to manually tell each host what IPv6 address
    to answer for. We do that by adding proxy entries to each host''s neighbor table.
    In the preceding example, we need to do that for both the source and the destination
    container in order to allow for bidirectional traffic flow. First, add the entry
    on the host `docker1` for the destination:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启用了这个功能，我们需要手动告诉每个主机要回答哪个IPv6地址。我们通过向每个主机的邻居表添加代理条目来实现这一点。在前面的例子中，我们需要为源容器和目标容器都这样做，以便允许双向流量。首先，在主机`docker1`上为目标添加条目：
- en: '[PRE47]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, determine the IPv6 address of the `web2` container, which will act as
    the source of the traffic and add a proxy entry for that on the host `docker2`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确定`web2`容器的IPv6地址，它将作为流量的源，并在主机`docker2`上为其添加代理条目：
- en: '[PRE48]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will tell each Docker host to reply to the neighbor solicitation requests
    on behalf of the containers. Ping tests should now work as expected:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉每个Docker主机代表容器回复邻居请求。Ping测试现在应该按预期工作：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'And we should see the relevant neighbor entry on each host:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该在每个主机上看到相关的邻居条目：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Much like proxy ARP, NDP proxy works by the host providing its own MAC address
    in response to the neighbor discovery request. We can see that in both cases,
    the MAC address in the neighbor table is actually each host''s `eth0` MAC address:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代理ARP一样，NDP代理是通过主机在邻居发现请求中提供自己的MAC地址来工作的。我们可以看到，在这两种情况下，邻居表中的MAC地址实际上是每个主机的`eth0`
    MAC地址。
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This approach works fairly well in cases where you can't advertise your Docker
    IPv6 subnet to the outside network. However, it relies on individual proxy entries
    for each IPv6 address you wish to proxy. For each container spawned you would
    need to generate an additional IPv6 proxy address.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在无法将Docker IPv6子网广告传播到外部网络的情况下效果相当不错。然而，它依赖于每个希望代理的IPv6地址的单独代理条目。对于每个生成的容器，您都需要生成一个额外的IPv6代理地址。
- en: User-defined networks and IPv6
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的网络和IPv6
- en: Much like we saw with IPv4, user-defined networks can leverage IPv6 addressing.
    That is, all of the network-related parameters relate to both IPv4 and IPv6\.
    In this chapter, we'll walk through defining a user-defined IPv6 network and demonstrate
    some of the related configuration options.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在IPv4中看到的那样，用户定义的网络可以利用IPv6寻址。也就是说，所有与网络相关的参数都与IPv4和IPv6相关。在本章中，我们将介绍如何定义用户定义的IPv6网络，并演示一些相关的配置选项。
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we'll be using a single Docker host. It is assumed that Docker
    is installed and is its default configuration. It is not required that the Docker
    service be enabled with the `--ipv6` service-level parameter in order to use IPv6
    addressing on user-defined networks.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将使用一个单独的Docker主机。假设Docker已安装并处于默认配置。不需要使用`--ipv6`服务级参数启用Docker服务，以便在用户定义的网络上使用IPv6寻址。
- en: How to do it…
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'When working with user-defined networks, we can define configuration for both
    IPv4 and IPv6\. In addition, when we run containers we can specify both their
    IPv4 and IPv6 addresses. To demonstrate this, let''s first define a user-defined
    network that has both IPv4 and IPv6 addressing:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用用户定义的网络时，我们可以为IPv4和IPv6定义配置。此外，当我们运行容器时，我们可以指定它们的IPv4和IPv6地址。为了演示这一点，让我们首先定义一个具有IPv4和IPv6寻址的用户定义网络：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The syntax of this command should be familiar to you from [Chapter 3](ch03.html
    "Chapter 3. User-Defined Networks"), *User-Defined Networks*, where we discussed
    user-defined networks. However, there are a couple of things to point out.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的语法应该对你来说很熟悉，来自[第3章](ch03.html "第3章。用户定义的网络")*用户定义的网络*，在那里我们讨论了用户定义的网络。然而，有几点需要指出。
- en: First, you'll notice that we've defined the `--subnet` parameter twice. In doing
    so, we defined both an IPv4 subnet as well as an IPv6 subnet. The `--gateway`
    and `--aux-address` fields can be used in a similar fashion when defining IPv4
    and IPv6 addresses. Second, we defined an option to enable IPv6 on this network.
    If you do not define this option to enable IPv6 the gateway interface of the host
    will not be defined.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您会注意到我们定义了`--subnet`参数两次。这样做，我们既定义了一个IPv4子网，也定义了一个IPv6子网。当定义IPv4和IPv6地址时，`--gateway`和`--aux-address`字段可以以类似的方式使用。其次，我们定义了一个选项来在此网络上启用IPv6。如果您不定义此选项以启用IPv6，则主机的网关接口将不会被定义。
- en: 'Once defined, let''s start a container on the network to see what our configuration
    looks like:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义好，让我们在网络上启动一个容器，看看我们的配置是什么样的：
- en: '[PRE53]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This syntax should also look familiar to you. Note that we specified that this
    container should be a member of the user-defined network `ipv6_bridge`. In doing
    so, we can also define both an IPv4 and IPv6 address for the container using the
    `--ip` and `--ip6` parameters.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法对你来说也应该很熟悉。请注意，我们指定这个容器应该是用户定义网络`ipv6_bridge`的成员。这样做，我们还可以使用`--ip`和`--ip6`参数为容器定义IPv4和IPv6地址。
- en: 'If we inspect the network, we should see the container attached as well as
    all of the relevant information related to both the network definition as well
    as the containers network interfaces:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查网络，我们应该看到容器附加以及与网络定义以及容器网络接口相关的所有相关信息：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'By checking the host''s network configuration, we should see that a new bridge
    has been created that matches up with these networks:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查主机的网络配置，我们应该看到已创建了一个与这些网络匹配的新桥：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we check the container itself, we''ll note that these interfaces are what
    the containers on this network will use for both their IPv4 and IPv6 default gateway:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查容器本身，我们会注意到这些接口是这个网络上的容器将用于其IPv4和IPv6默认网关的接口：
- en: '[PRE56]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Just like the default network modes, user-defined networks do not support host
    firewall integration to support outbound masquerade or inbound port publishing.
    IPv6 connectivity on and off of the host is the same as the `docker0` bridge in
    regard to having to route the IPv6 traffic natively.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就像默认网络模式一样，用户定义的网络不支持主机防火墙集成，以支持出站伪装或入站端口发布。关于IPv6的连接，主机内外的情况与`docker0`桥相同，需要原生路由IPv6流量。
- en: 'You''ll also note that if you start a second container on the host that embedded
    DNS works for both IPv4 and IPv6 addressing:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您还会注意到，如果您在主机上启动第二个容器，嵌入式DNS将同时适用于IPv4和IPv6寻址。
- en: '[PRE57]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
