- en: Primitive and Built-In Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始和内置类型
- en: So far, we have explored the meaning of clean code from several different perspectives.
    We've explored how the code we write allows our users to wield remarkable complexity
    by leveraging abstractions. We've gone on to discuss the tenets of clean code,
    such as reliability and usability, and the various traps and challenges to watch
    out for when pursuing these goals.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经从几个不同的角度探讨了清晰代码的含义。我们探讨了我们编写的代码如何让用户通过利用抽象来处理复杂性。我们继续讨论了清晰代码的原则，如可靠性和可用性，以及在追求这些目标时需要注意的各种陷阱和挑战。
- en: In this chapter, we'll be exploring the JavaScript language itself, in great
    detail, including both the more common language constructs and the more obscure
    and confusing aspects. We'll be applying our accrued wealth of knowledge about
    clean code to all these parts of the language and will build an understanding
    of JavaScript that's tailored purely to the creation of clean code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨 JavaScript 语言本身，包括更常见的语言构造和更晦涩和令人困惑的方面。我们将把我们对清晰代码的积累知识应用到语言的所有部分，并建立一个纯粹针对清晰代码创建的
    JavaScript 理解。
- en: 'We''ll begin by looking at the most atomic part of JavaScript: the primitive
    values that serve as the building blocks for any program. Then, we''ll move on
    to non-primitive values, known as **objects**. In our exploration of these types,
    we will, through examples, be exposing the semantics that make each type unique
    and the pitfalls to avoid in their usage. The crucial knowledge that we''ll gain
    in this chapter will be applied in later chapters as we build up a truly complete
    knowledge of what it means to write clean code in JavaScript.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从 JavaScript 最基本的部分开始：作为任何程序的构建块的原始值。然后，我们将转向非原始值，即**对象**。在我们探索这些类型时，我们将通过示例揭示使每种类型独特的语义和在使用中需要避免的陷阱。我们在本章中获得的关键知识将应用在后面的章节中，以便我们真正完全地了解在
    JavaScript 中编写清晰代码的含义。
- en: 'By the end of this chapter, you should feel comfortable in the following topic
    areas:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你应该对以下主题感到自如：
- en: Primitive types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型
- en: Objects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数
- en: Arrays and iterables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组和可迭代对象
- en: Regular expressions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正则表达式
- en: Primitive types
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始类型
- en: 'A primitive type in JavaScript is any value that is not an object and thus
    does not have any methods or properties. There are seven primitive types in JavaScript:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，原始类型是指任何不是对象的值，因此没有任何方法或属性。JavaScript 中有七种原始类型：
- en: Number
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字
- en: String
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Boolean
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔
- en: Undefined
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: 'Null'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空
- en: BigInt
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大整数
- en: Symbol
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号
- en: In this section, we'll explore the common characteristics among these primitives
    and delve into each individual type to explore how it works and what potential
    hazards exist in its usage. We'll gain an appreciation for how the JavaScript
    language itself is just a set of distinct abstractions that, when wielded masterfully,
    can make easy work of any problem domain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索这些原始值之间的共同特征，并深入研究每种类型，探讨它的工作原理以及在使用中存在的潜在危险。我们将欣赏到 JavaScript 语言本身只是一组不同抽象的集合，当巧妙地使用时，可以轻松解决任何问题领域。
- en: Immutability of primitives
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始值的不可变性
- en: All primitive values are immutable, meaning that you cannot mutate their values.
    This is a core part of their primitiveness. You cannot, for example, change the
    number value of `3.14` to `42`, or change the value of a string to its uppercased
    variation.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始值都是不可变的，这意味着你不能改变它们的值。这是它们原始性的核心部分。例如，你不能将数字值 `3.14` 改变为 `42`，或者将字符串的值更改为它的大写变体。
- en: '**But I can change the value of a string to its uppercased variation!** You
    may be confused right now if you recall being able to do this. But there is a
    crucial distinction to be made here between the reassignment of variables to new
    primitive values, which is fully possible (and likely what you''re remembering),
    and the mutation of primitive values, which is not possible.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**但我可以将字符串的值更改为它的大写变体！** 如果你记得能够这样做，你现在可能会感到困惑。但这里需要做出一个重要的区分，即变量重新赋值为新的原始值是完全可能的（也可能是你记得的），而原始值的变异是不可能的。'
- en: 'When we reassign a variable, giving it a new value, we are not changing the
    value itself; we are only changing which value the variable refers to, as shown
    here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重新分配一个变量，给它一个新的值时，我们并没有改变值本身；我们只是改变了变量所引用的值，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note how `copy` has remained lowercase. The primitive value `simon` has not
    been mutated; instead, a new primitive value has been derived from it, via the
    `toUpperCase` method, and then assigned to the variable that previously held the
    lowercase variant.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `copy` 保持小写。原始值 `simon` 没有被改变；相反，通过 `toUpperCase` 方法派生出一个新的原始值，然后赋给之前持有小写变体的变量。
- en: Primitive wrappers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原始包装器
- en: You'll remember that we mentioned that primitive values don't have methods as
    they are not objects. So, how exactly are we able to call `toUpperCase` on the
    preceding string? Is that not a method? Yes, it is. And to allow us to access
    this method, JavaScript wraps primitive values in their respective wrapper objects
    at the time of property access. This occurs for all primitive values, apart from `null`
    and `undefined`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你会记得我们提到原始值没有方法，因为它们不是对象。那么，我们是如何能够在前面的字符串上调用 `toUpperCase` 的呢？那不是一个方法吗？是的，是方法。为了让我们能够访问这个方法，JavaScript
    在属性访问时会将原始值包装在它们各自的包装对象中。这适用于所有原始值，除了 `null` 和 `undefined`。
- en: 'Primitive values, in these moments of being wrapped, remain immutable but,
    via their wrapped instance, provide access to properties and methods. A string
    value would be wrapped in a `String` instance, while a number value would be wrapped
    in a `Number` instance. The same would occur for all other non-null and non-undefined
    primitives. You are free to instantiate these wrapper objects yourself: you will
    observe that they no longer behave like primitives, though; they are objects,
    and, as such, you can add and mutate properties on them:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些被包装的时刻，原始值保持不变，但是通过它们的包装实例，可以访问属性和方法。字符串值将被包装在`String`实例中，而数字值将被包装在`Number`实例中。对于所有其他非空和非未定义的原始值也是如此。您可以自由地实例化这些包装对象：您会发现它们不再像原始值那样行为了；它们是对象，因此您可以在它们上面添加和改变属性：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you require an object to add custom properties to, it is best to use a plain
    object. Using wrapper objects for anything other than wrapping their primitive
    values is an anti-pattern as it would not be expected by other programmers. Nonetheless,
    it is useful to observe and remember the differences between primitives and their
    respective wrapper objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要一个对象来添加自定义属性，最好使用一个普通对象。除了用于包装其原始值以外的任何其他内容，都是一种反模式，因为其他程序员不会预期这样做。尽管如此，观察和记住原始类型及其相应包装对象之间的差异是很有用的。
- en: 'Invoking a wrapper constructor (for example, `Number`, `String`, and so on)
    as a regular function has a unique behavior. Instead of returning a new wrapper
    instance, it will cast the value to a particular type and return a regular primitive.
    This is quite useful when you''re casting one type to another:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调用包装构造函数（例如`Number`，`String`等）作为常规函数具有独特的行为。它不会返回一个新的包装实例，而是会将值转换为特定类型并返回一个常规的原始值。当您需要将一种类型转换为另一种类型时，这是非常有用的：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Invoking wrapper constructors as functions, as we have done here, is a useful
    casting technique, though it's not the only one. We'll cover typecasting and coercion
    in a lot more detail in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic
    Typing*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将包装构造函数作为函数调用，就像我们在这里所做的那样，是一种有用的转换技术，尽管这不是唯一的一种。我们将在[第7章](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml)中更详细地介绍类型转换和强制转换，*动态类型*。
- en: The falsy primitives
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚假原始值
- en: 'In JavaScript, all the values in Boolean contexts will evaluate to either `true`
    or `false`. To describe this behavior, we usually refer to values as either truthy
    or falsy. To determine the truthiness of a value, we can simply pass it to the
    `Boolean` function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，布尔上下文中的所有值都将计算为`true`或`false`。为了描述这种行为，我们通常将值称为真实或虚假。要确定值的真实性，我们可以简单地将其传递给`Boolean`函数：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are only eight falsy values in JavaScript, and all of them are primitive
    types:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中只有八个虚假值，它们都是原始类型：
- en: '`null`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`'
- en: '`undefined`'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未定义
- en: '`+0`  or  `-0` (zero, a number)'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`+0`或`-0`（零，一个数字）'
- en: '`false` (a Boolean)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`（布尔值）'
- en: '`""` (an empty string)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`""`（空字符串）'
- en: '`0n` (zero, a `BigInt`)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0n`（零，一个`BigInt`）'
- en: '`NaN` (not a number)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaN`（不是一个数字）'
- en: 'All values that are not falsy are, therefore, truthy. Throughout this and the
    next chapter, we will be exploring the implications of these truthy and falsy
    values. For now, it''s only important to know that the preceding falsy values
    will, when used in conditional or logical contexts, behave as if they were false.
    A falsy value, when used in an `if` statement, for example, would act the same
    as if it were false:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有不是虚假的值都是真实的。在本章和下一章中，我们将探讨这些真实和虚假值的含义。现在，只需要知道前面的虚假值在条件或逻辑上下文中使用时会表现得像假一样。例如，当虚假值在`if`语句中使用时，它会像假一样行事：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The existence of these falsy values means that we must be wary of how we check
    for certain conditions. It''s easy to fall into the trap of testing for the existence
    of a certain value state by using only its truthiness to determine existence.
    For example, let''s say that we need to be able to check for the age of a person:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些虚假值的存在意味着我们必须谨慎地检查某些条件。很容易陷入陷阱，只使用其真实性来确定存在的某个值状态。例如，假设我们需要能够检查一个人的年龄：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a contrived example, but we can imagine a system in which the identities
    of individuals need to be processed somehow, perhaps through a medical application.
    Checking for the existence of the `age` property is not going to do what''s intended
    if the age happens to be 0\. Perhaps the system needs to cater to the eventuality
    of a newborn baby being entered into the system, but suddenly it breaks because
    the `age` is `0`. In such scenarios, it''s best to be preemptively explicit, even
    if you don''t expect odd falsy values. In this context, we likely want to check
    for either `null` or `undefined`, so we should explicitly do that:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个牵强的例子，但我们可以想象一个需要以某种方式处理个体身份的系统，也许是通过医疗应用。如果年龄恰好为0，检查`age`属性的存在将不会达到预期的效果。也许系统需要适应新生儿被输入系统的可能性，但突然间因为`age`是`0`而崩溃。在这种情况下，最好是预先明确，即使您不希望出现奇怪的虚假值。在这种情况下，我们可能希望检查`null`或`undefined`，因此我们应该明确这样做：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is far more resilient to the possible variabilities of the `age` property.
    We could also, perhaps, be more in line with our requirements and check only for
    the specific characteristics that we are interested in, such as that the age property
    is a number within specific bounds. The point is that it's better to be explicit
    in Boolean contexts such as `if` statements so that you don't run into an unexpected
    falsy value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对`age`属性的可能变化更具弹性。我们也可以更符合我们的要求，仅检查我们感兴趣的特定特征，比如`age`属性是在特定范围内的数字。关键是在布尔上下文中，比如`if`语句中最好是明确的，这样您就不会遇到意外的虚假值。
- en: Number
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字
- en: 'The number primitive type is used to express numerical data. It stores this
    data in the double-precision 64-bit floating-point format (IEEE 754). 64 bits
    here refers to there being 64 binary digits available to store information. The
    entire 64-bit format that''s used in the IEEE 754 standards can be broken down
    into three chunks:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 数字原始类型用于表示数字数据。它以双精度64位浮点格式（IEEE 754）存储这些数据。这里的64位指的是有64个二进制数字可用于存储信息。在IEEE
    754标准中使用的整个64位格式可以分解为三个部分：
- en: '**1 bit for the sign of the number being represented**: Whether the number
    is positive or negative'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字的符号需要1位**：表示数字是正数还是负数'
- en: '**11 bits for the exponent of the number**: This tells us where the radix or
    decimal dot resides'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字的指数需要11位**：这告诉我们小数点的位置'
- en: '**52 bits for what''s termed the fraction or significand**: This tells us the
    integer value'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用于分数或有效数字的52位**：这告诉我们整数值'
- en: 'A side effect of this floating-point formation means that there are technically
    two zeros: positive zero (`+0`) and negative zero (`-0`). Thankfully, in JavaScript,
    you don''t have to be explicit when checking for these values. Both will return
    true when compared with the strict equality operator ( `+0 === -0`) and both are
    considered falsy.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点形式的一个副作用是，从技术上讲有两个零：正零（`+0`）和负零（`-0`）。幸运的是，在JavaScript中，您在检查这些值时不必明确指定。当使用严格相等运算符（`+0
    === -0`）进行比较时，两者都将返回true，并且都被视为假值。
- en: 'Technically, there are 53 bits available (not 52) for the expression of an
    integer value as the leading bit of the significand field resides within the exponent
    field. This is an important clarification as it has a direct effect on how much
    precision we can get from JavaScript numbers. Having 53 bits available to express
    an integer value means that any numbers greater than *2^(53)-1* are considered
    unsafe. These safety limits are available as constants on the `Number` object:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，有53位可用（而不是52）来表示整数值，因为有效数字字段的最高位位于指数字段内。这是一个重要的澄清，因为它直接影响了我们可以从JavaScript数字中获得多少精度。有53位可用于表示整数值意味着任何大于*2^(53)-1*的数字都被认为是不安全的。这些安全限制作为`Number`对象的常量可用：
- en: Integers larger than `2^(53)` or `9007199254740991` (`Number.MAX_SAFE_INTEGER`)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于`2^(53)`或`9007199254740991`（`Number.MAX_SAFE_INTEGER`）的整数
- en: Integers smaller than `-2^(53)` or `-9007199254740991` (`Number.MIN_SAFE_INTEGER`)
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于`-2^(53)`或`-9007199254740991`（`Number.MIN_SAFE_INTEGER`）的整数
- en: 'The loss of precision beyond these bounds can be observed if we try to perform
    addition on the upper limit:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试对上限进行加法，就会观察到超出这些范围的精度损失：
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, we can see that the evaluated additions are incorrect. Beyond `MAX_SAFE_INTEGER`,
    all mathematical operations will be similarly imprecise.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到评估的加法是不正确的。超出`MAX_SAFE_INTEGER`，所有数学运算都将同样不精确。
- en: It is still possible to express values larger than `MAX_SAFE_INTEGER` within
    JavaScript. Many values up to `2^(1024)` (`Number.MAX_VALUE`) can be expressed,
    but many cannot. Therefore, it is considered very unwise to attempt to express
    numbers beyond `Number.MAX_SAFE_INTEGER`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中仍然可以表示大于`MAX_SAFE_INTEGER`的值。可以表示多达`2^(1024)`（`Number.MAX_VALUE`）的许多值，但也有许多值无法表示。因此，尝试表示超出`Number.MAX_SAFE_INTEGER`的数字被认为是非常不明智的。
- en: 'To sum this up, any values between `Number.MIN_SAFE_INTEGER` and `Number.MAX_SAFE_INTEGER`
    are safe to use and will provide integer precision, while values beyond these
    bounds should be considered unsafe. If we feel ourselves needing an integer outside
    of these bounds, then we can use JavaScript''s `BigInt` primitive:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，任何介于`Number.MIN_SAFE_INTEGER`和`Number.MAX_SAFE_INTEGER`之间的值都是安全的，并且将提供整数精度，而超出这些范围的值应被视为不安全。如果我们需要超出这些范围的整数，那么我们可以使用JavaScript的`BigInt`原始类型：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We''ll explore the `BigInt` primitive further in a later part of this section.
    For now, just remember to always consider the largeness of your numbers and whether
    they can be fully accommodated by JavaScript''s `Number` type. It''s also important
    to consider the precision of decimal values (such as in fractions) as well. When
    expressing decimals in JavaScript, you''ll likely encounter issues like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本节的后面进一步探讨`BigInt`原始类型。现在，只需记住始终考虑您的数字的大小以及它们是否可以完全由JavaScript的`Number`类型容纳。同样重要的是考虑小数值的精度（例如在分数中）。在JavaScript中表示小数时，您可能会遇到此类问题：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is due to inherent mechanism by which fractions are expressed in the floating-point
    standard. You can imagine that if we were interested in querying whether a decimal
    is equal to, greater than, or less than another value, it would be as simple as
    using the following code:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是由浮点标准中表达分数的固有机制所致。您可以想象，如果我们有兴趣查询一个小数是否等于、大于或小于另一个值，那么使用以下代码将会非常简单：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But `yay()` will never run. To get around this problem, there are two options.
    The first involves something called the epsilon. The epsilon is the margin of
    error inherent to floating-point math, and JavaScript makes this available to
    use as `Number.EPSILON`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 但`yay()`永远不会运行。为了解决这个问题，有两个选择。第一个涉及到一个叫做epsilon的东西。Epsilon是浮点数学固有的误差范围，JavaScript使其可用作`Number.EPSILON`：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a very tiny number, but it must be taken into account if we are to
    have a hope of doing basic mathematical operations on decimals. If we wish to
    compare two numbers, we can simply subtract them from each other and check that
    the margin is less than the `EPSILON`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的数字，但如果我们希望对小数进行基本的数学运算，就必须考虑到它。如果我们希望比较两个数字，我们可以简单地将它们相互减去，并检查边际是否小于`EPSILON`：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The other approach we can take is to convert any decimals we''re dealing with
    into integers expressed by either `Number` or `BigInt` types. So, if we have a
    need to represent values from `0` to `1` with a precision of eight decimal places,
    for example, then we can simply multiply these values by `100,000,000` (or `10⁸`):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以采取的另一种方法是将我们处理的任何小数转换为由`Number`或`BigInt`类型表示的整数。因此，如果我们需要以八位小数的精度表示从`0`到`1`的值，那么我们可以简单地将这些值乘以`100,000,000`（或`10⁸`）：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we are free to conduct integer math on these values and divide them back
    down into their fractions when done. It's crucial to note that any decimal value
    longer than 15 digits cannot be expressed in JavaScript's `Number` type, so you'll
    need to explore other options. JavaScript currently doesn't have a native `BigDecimal`
    type, but there are many third-party libraries available that fulfill a similar
    purpose (you can easily find these online).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以自由地对这些值进行整数运算，并在完成后将它们分解为分数。需要注意的是，任何小数值超过15位数字都无法在JavaScript的`Number`类型中表示，因此您需要探索其他选项。JavaScript目前没有本地的`BigDecimal`类型，但有许多第三方库可用来实现类似的目的（您可以轻松在网上找到这些）。
- en: If you ever find yourself needing to operate on large or very precise numbers
    in JavaScript, or if your code concerns sensitive matters such as finance, medicine,
    or science, it's absolutely crucial to take the time to fully understand what
    levels of precision you require and whether JavaScript can natively support those
    needs.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发现自己需要在JavaScript中操作大型或非常精确的数字，或者如果您的代码涉及财务、医学或科学等敏感事项，那么完全理解您需要的精度级别以及JavaScript是否可以原生支持这些需求是非常重要的。
- en: 'There''s one more topic to discuss under the `Number` type, and that is `NaN`. `NaN`
    is a primitive that technically belongs to the `Number` type. It represents a
    failure to parse something as a number; for example, `Number(''wow'')` evaluates
    to `NaN`. Since `typeof NaN` is a `number`, we should check for a valid number
    in the following way:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`Number`类型下要讨论的话题，那就是`NaN`。`NaN`是一个技术上属于`Number`类型的原始值。它表示无法将某些东西解析为数字；例如，`Number('wow')`评估为`NaN`。由于`typeof
    NaN`是`number`，我们应该以以下方式检查有效数字：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The value `NaN` can create a headache when its existence is not foreseen. It'll
    usually crop up in areas where you're attempting to cast strings to numbers or
    where this happens implicitly (coercion).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有预见到`NaN`的存在时，它可能会带来麻烦。它通常会出现在您试图将字符串转换为数字或在这种情况下隐式发生（强制转换）的地方。
- en: We'll be covering the topic of coercion, casting, and detection more in the
    next chapter. This will include a section where we get into the complexity of
    `NaN` and compare `isNaN()`, the global function, to the slightly different `Number.isNaN()`.
    For now, it's only important to appreciate that `NaN` is its own distinct value
    and is itself, oddly, considered a number within JavaScript.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中更多地涵盖强制、转换和检测的主题。这将包括一个部分，我们将深入探讨`NaN`的复杂性，并比较全局函数`isNaN()`与稍有不同的`Number.isNaN()`。目前，重要的是要欣赏`NaN`是其自己独特的值，并且在JavaScript中奇怪地被认为是一个数字。
- en: 'There is another value encapsulated by the `Number` type that is not a normal
    number: `Infinity`. You will receive `Infinity` when you attempt to do mathematical
    operations such as dividing by `0`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Number`类型中封装的另一个值不是普通数字：`Infinity`。当您尝试进行数学运算，如除以`0`时，您将收到`Infinity`：'
- en: '[PRE15]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Infinity`, like `NaN`, is a globally available primitive value that you can
    reference and check for:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`，就像`NaN`一样，是一个全局可用的原始值，您可以引用和检查：'
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'There is also `-Infinity`, which is technically a distinct value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`-Infinity`，这在技术上是一个不同的值：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`Infinity`, like `NaN`, is of the `Number` type, so when passed to the `typeof`
    operator, it will evaluate to `"number"`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Infinity`，就像`NaN`一样，属于`Number`类型，因此当传递给`typeof`运算符时，它将被评估为`"number"`：'
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Outside of `Infinity`, `-Infinity`, and `NaN`, all values that are of the `Number`
    type can be considered regular everyday numbers. Overall, and for most use cases,
    the `Number` type is very simple to use and operate on. It is, however, vital
    to know about its limitations, many of which we've covered here so that you can
    make an informed decision about when it may not be appropriate to use.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Infinity`、`-Infinity`和`NaN`之外，所有属于`Number`类型的值都可以被视为普通的日常数字。总的来说，对于大多数用例，`Number`类型非常简单易用。然而，了解它的限制是非常重要的，我们在这里涵盖了许多限制，以便您可以明智地决定何时不适合使用它。
- en: String
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 字符串
- en: The `String` type in JavaScript allows us to express sequences of characters.
    It is usually used to encapsulate words, sentences, lists, HTML, and many other
    forms of text-like content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`String`类型允许我们表示字符序列。它通常用于封装单词、句子、列表、HTML和许多其他形式的文本内容。
- en: 'Strings are expressed by delimiting sequences of characters with either single
    quotes, double quotes, or backticks:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串通过用单引号、双引号或反引号界定字符序列来表示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Only backtick-delimited strings, known as **template literals** (or template
    strings), can occupy multiple lines. Single quote- or double quote-delimited strings
    can technically be spread along multiple lines as well, but this is only achieved
    by escaping their invisible newline characters (with a `\` character), which effectively
    removes the newlines:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 只有用反引号界定的字符串，称为**模板文字**（或模板字符串），才能占据多行。单引号或双引号界定的字符串也可以在多行上分布，但这只能通过转义它们的不可见换行字符（使用`\`字符）来实现，这实际上删除了换行：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Nowadays, template literals are preferred as they retain newlines and allow
    us to interpolate arbitrary expressions, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，模板文字被认为是首选，因为它们保留了换行，并允许我们插入任意表达式，就像这样：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Strings come with a number of curious challenges once your usage exceeds the
    most simple use cases. Under the surface, the humble string is masking a miraculous
    scale of complexity in the form of Unicode.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的使用超出了最简单的用例，字符串就会带来许多有趣的挑战。在表面下，这个普通的字符串掩盖了Unicode形式的复杂性奇迹。
- en: Unicode is an industry standard for the encoding, representation, and handling
    of text that's used in writing systems around the world. The Unicode standard
    contains over 130,000 characters, including all of your favorite emojis.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode是一个行业标准，用于编码、表示和处理世界各地书写系统中使用的文本。Unicode标准包含超过130,000个字符，包括所有您喜爱的表情符号。
- en: 'To step beneath the veneer of the String abstraction slightly, we can say that
    Strings in JavaScript are really just an ordered sequence of 16-bit unsigned integers.
    Each of these integers is interpreted as a UTF-16 code unit. UTF-16 is a type
    of encoding for the Unicode character set. Using it, we are able to express hundreds
    of thousands of valid Unicode code points. This means that we can express emojis,
    many languages, and a myriad of Unicode oddities via our strings:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微深入字符串抽象的表面，我们可以说JavaScript中的字符串实际上只是一系列有序的16位无符号整数。这些整数中的每一个都被解释为UTF-16代码单元。UTF-16是Unicode字符集的一种编码类型。使用它，我们能够表示数十万个有效的Unicode代码点。这意味着我们可以通过我们的字符串来表示表情符号、许多语言和一大堆Unicode的奇特之处：
- en: '![](assets/1cfee330-5c7a-4adf-9e65-53644f2acf6e.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1cfee330-5c7a-4adf-9e65-53644f2acf6e.png)'
- en: 'A Unicode code point is a character (such as the letter *B*, a question mark,
    or a smiling emoji). We can express a code point by using one or more UTF-16 code
    units. Most code points that we use from day to day only need a single code unit.
    These are known as **scalars**. There are, however, quite a few Unicode code points
    that require a pair of code units (known as a **surrogate pair**). The panda emoji
    is an example of such a surrogate pair:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Unicode代码点是一个字符（比如字母*B*、问号或笑脸表情符号）。我们可以通过一个或多个UTF-16代码单元来表示一个代码点。我们日常使用的大多数代码点只需要一个代码单元。这些被称为**标量**。然而，有相当多的Unicode代码点需要一对代码单元（称为**代理对**）。熊猫表情符号就是这样一个代理对的例子：
- en: '![](assets/932e06b3-c837-45a4-9998-fa9e94b15f83.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/932e06b3-c837-45a4-9998-fa9e94b15f83.png)'
- en: Since UTF-16 only has 16 bits to work with, it has to use pairs of 16-bit integers
    to express some characters. Naturally, if we're using UTF-32 encoding (with 32
    bits to play with), then we'd be able to express the panda emoji in a single 32-bit
    integer.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UTF-16只有16位可用，它必须使用一对16位整数来表示一些字符。自然地，如果我们使用UTF-32编码（有32位可用），那么我们将能够用一个32位整数来表示熊猫表情符号。
- en: Here, we've used `charCodeAt()` to determine the individual UTF-16 code units
    of the Panda emoji and we've found that these are the *55,357^(th)* and *56,380^(th)*
    decimal code units within Unicode. Since there are so many code units, it is simpler
    and more convenient to use hexadecimal digits to express them, so we can say that
    the panda emoji is expressed by code units  `U+D83D` and `U+DC3C` (Unicode hexadecimal
    values are conventionally prefixed with `U+`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`charCodeAt()`来确定熊猫表情符号的单个UTF-16代码单元，并发现这些是Unicode中的第*55,357*和*56,380*个十进制代码单元。由于有这么多代码单元，使用十六进制数字来表示它们更简单、更方便，因此我们可以说熊猫表情符号由代码单元`U+D83D`和`U+DC3C`表示（Unicode十六进制值通常以`U+`为前缀）。
- en: 'In addition to surrogate pairs, there is another type of combination that''s
    useful to know about. The *Combining Code Point* enables certain traditional *non-combining* code
    points to be augmented into new characters. Examples of this include traditional
    Latin characters that can be augmented with accents or other augmentations, such
    as the combining tilde:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了代理对，还有另一种有用的组合类型需要了解。*组合代码点*可以将某些传统的*非组合*代码点增强为新的字符。其中的例子包括可以用重音或其他增强来增强的传统拉丁字符，比如组合波浪符：
- en: '![](assets/74a8f34d-49af-4c20-91ec-ff6a9c3a72b3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/74a8f34d-49af-4c20-91ec-ff6a9c3a72b3.png)'
- en: We've chosen to express this particular combining character via a Unicode escape
    sequence (`\u0303`). The format of `\uXXXX` allows us to express Unicode code
    units between `U+0000` and `U+FFFF` within JavaScript strings.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择通过Unicode转义序列（`\u0303`）来表示这个特定的组合字符。`\uXXXX`的格式允许我们在JavaScript字符串中表示`U+0000`到`U+FFFF`之间的Unicode代码单元。
- en: The range of Unicode between `U+0000` and `U+FFFF` is known as the **Basic Multilingual
    Plane** (**BMP**) and includes the most commonly used everyday characters.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`U+0000`到`U+FFFF`之间的Unicode范围被称为**基本多文种平面**（**BMP**），包括最常用的日常字符。'
- en: 'Our panda emoji, as we''ve already seen, is quite an obscure symbol. It does
    not exist on the BMP and is thus expressed by a surrogate pair of two UTF-16 code
    units. We can express these individually in JavaScript strings via two Unicode
    escape sequences:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的熊猫表情符号，正如我们已经看到的那样，是一个相当晦涩的符号。它在BMP上不存在，因此由两个UTF-16代码单元的代理对表示。我们可以通过两个Unicode转义序列在JavaScript字符串中分别表示它们：
- en: '![](assets/027dce04-a27f-41cb-8b99-e4c742858944.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/027dce04-a27f-41cb-8b99-e4c742858944.png)'
- en: 'More obscure and ancient symbols are found in the *supplementary* (or *astral*)
    planes between `U+010000` and `U+10FFFF`. The escaping format of `\uXXXX` does
    not have enough slots for us to express these. Symbols within the astral planes
    require at least five hexadecimal digits to express, so we must use the more recently
    introduced escape sequence format of `\u{X}`. This provides up to six hexadecimal
    slots (`\u{XXXXXX}`) and can thus express over 1 million different code points.
    Using this type of escape sequence, we can express our Panda emoji directly via
    its 32-bit representation (`U+1F43C`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 更晦涩和古老的符号位于`U+010000`和`U+10FFFF`之间的*补充*（或*星体*）平面。`\uXXXX`的转义格式没有足够的槽位来表示这些。星体平面内的符号需要至少五个十六进制数字来表示，因此我们必须使用更近期引入的转义序列格式`\u{X}`。这提供了最多六个十六进制槽位（`\u{XXXXXX}`），因此可以表示超过100万个不同的代码点。使用这种类型的转义序列，我们可以直接通过其32位表示（`U+1F43C`）来表示我们的熊猫表情符号：
- en: '![](assets/8ac0deef-10e0-4718-a4f9-686f78db91fa.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ac0deef-10e0-4718-a4f9-686f78db91fa.png)'
- en: 'The newer `\u{X}` escape sequence is really convenient and goes some way in
    making Unicode less burdensome to use than JavaScript. But there is still a little
    more complexity to explore. Surrogate pairs and combining characters are examples
    where UTF-16 code units are combined to produce individual symbols. On top of
    this, there are longer sequences called **grapheme clusters**. These are used
    to express combinations of code points that can be combined to create an aggregate
    symbol:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`\u{X}`转义序列非常方便，使得Unicode比JavaScript更易于使用。但是还有更多复杂性需要探索。代理对和组合字符是UTF-16代码单元组合成单个符号的例子。此外，还有更长的序列称为**图形簇**。这些用于表示可以组合成一个聚合符号的代码点组合：
- en: '![](assets/1eb89558-39ae-414f-a0fd-fa6322c9fe8b.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1eb89558-39ae-414f-a0fd-fa6322c9fe8b.png)'
- en: 'Wow! Unicode is a pretty incredible feat of engineering, but it can make things
    complicated for us. The ability to combine Unicode in all of these ways (combining
    characters, surrogate pairs, and grapheme clusters) creates a challenge for us.
    JavaScript strings, as you may know, have a `length` property. This property returns
    the number of code units in a given string (that is, the number of 16-bit integers
    in the entire sequence). For most strings, this is straightforward:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！Unicode是一项非常了不起的工程成就，但它可能会让我们的事情变得复杂。能够以所有这些方式组合Unicode（组合字符、代理对和图形簇）对我们来说是一个挑战。JavaScript字符串，你可能知道，有一个`length`属性。这个属性返回给定字符串中代码单元的数量（即整个序列中的16位整数）。对于大多数字符串来说，这是直接的：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'However, as we know, we are able to combine code units to create code points
    and we are also able to combine code points to create grapheme clusters. This
    means the `length` property, which is only concerned with the 16-bit code units,
    can give us unexpected results:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们所知，我们能够组合代码单元来创建代码点，也能够组合代码点来创建图形簇。这意味着`length`属性，它只关注16位代码单元，可能会给我们带来意想不到的结果：
- en: '![](assets/db5089b2-18e2-45bf-9195-d6d02babb3a3.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/db5089b2-18e2-45bf-9195-d6d02babb3a3.png)'
- en: The smiling-face emoji is composed of two code units, so JavaScript correctly
    tells us this string has a length of `2`. But this may not be what we expect or
    desire. It's even more challenging when we're dealing with grapheme clusters that
    may use a dozen different code units to express a single symbol.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 笑脸表情符号由两个代码单元组成，因此JavaScript正确告诉我们这个字符串的长度为`2`。但这可能不是我们期望或希望的结果。当我们处理可能使用十几个不同代码单元来表示单个符号的图形簇时，情况会更加复杂。
- en: Watch out when attempting to truncate or establish the width of a piece of text
    within a UI using only its `length` property. Due to the fact that many Unicode
    symbols may be expressed by multiple code units, using `length` alone is not reliable.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在UI中尝试仅使用其`length`属性截断或确定文本的宽度时要小心。由于许多Unicode符号可能由多个代码单元表示，仅使用`length`是不可靠的。
- en: Throughout this section, we've explored the tricky domain of Unicode. Va our
    new understanding of it, we're now far more empowered to cleanly work with strings
    in JavaScript. Excluding the complexity of Unicode, the behavior of strings in
    JavaScript is rather intuitive and shouldn't cause many headaches as long as we
    use them in a way that clearly communicates our intent.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Unicode的棘手领域。通过对它的新理解，我们现在更有能力在JavaScript中清晰地处理字符串。除了Unicode的复杂性，JavaScript中的字符串行为相当直观，只要我们以能清晰传达意图的方式使用它们，就不应该引起太多头痛。
- en: Boolean
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Boolean
- en: 'The `Boolean` primitive type in JavaScript is used to represent either `true`
    or `false`. These polar opposites are its only values:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`Boolean`原始类型用于表示`true`或`false`。这两个极端是它唯一的值：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Semantically, Booleans are used to represent real-life or problem domain values
    that can be considered on or off (`0` or `1`), for example, whether a feature
    is enabled, or whether the user is over a certain age. These are Boolean characteristics
    and so are appropriate to express via Boolean values. We can use such values to
    dictate control flow within a program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上讲，布尔值用于表示现实生活或问题域的值，可以被认为是开启或关闭（`0`或`1`），例如，一个功能是否启用，或者用户是否超过一定年龄。这些都是布尔特征，因此适合通过布尔值来表达。我们可以使用这些值来控制程序中的控制流程：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `Boolean` primitive, just like `String` and `Number`, can be manually wrapped
    in a wrapper instance like so:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Boolean`原始类型，就像`String`和`Number`一样，可以手动包装在包装实例中，如下所示：'
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that, once you do this, `Boolean` will behave just like any other object
    in conditional statements. So, the following conditional statement will succeed,
    even though the wrapped primitive value is `false`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦你这样做，`Boolean`将会像条件语句中的任何其他对象一样行为。因此，即使包装的原始值是`false`，以下条件语句也会成功：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `Boolean` instance here is not equivalent to its primitive value; it merely contains its
    primitive value. `isFalseObj` will behave just like any other Object in a `Boolean`
    context, resolving to `true`. Manually wrapping a `Boolean` like this is not especially
    useful and should be avoided as an anti-pattern in most programs as it doesn't
    behave according to Boolean semantics and may produce unexpected results.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`Boolean`实例与其原始值不等效；它只是包含其原始值。在`Boolean`上下文中，`isFalseObj`将像`Boolean`上下文中的任何其他对象一样，解析为`true`。手动包装`Boolean`不是特别有用的，应该在大多数程序中避免使用，因为它不符合布尔语义，可能会产生意外结果。
- en: '`Boolean` primitives are returned by JavaScript''s logical operators such as
    greater than or equal to (`>=`) or strict equality (`===`). We''ll cover these
    in more detail in [Chapter 8](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml),*Operators*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的逻辑运算符（如大于或等于（`>=`）或严格相等（`===`））返回`Boolean`原始值。我们将在[第8章](d8c326c9-db6f-4562-b92d-975dd0159182.xhtml)中更详细地介绍这些内容，*运算符*。
- en: BigInt
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BigInt
- en: 'The `BigInt` primitive type in JavaScript is used to represent an integer of
    arbitrary precision. This means that it can be used to represent integers that
    are not able to be precisely represented by JavaScript''s `Number` type (anything
    larger than ~*2^(53)*). Literal BigInts are declared by suffixing any sequence
    of digits with the `n` character, like so:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`BigInt`原始类型用于表示任意精度的整数。这意味着它可以用来表示JavaScript的`Number`类型无法精确表示的整数（大于~*2^(53)*）。通过在任何数字序列后缀加上`n`字符来声明文字BigInt，如下所示：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`BigInt` is capable of representing integers of arbitrary precision, meaning
    that you can store integers of unlimited length. This is especially useful in
    financial applications or any case where high-accuracy integers need to be expressed
    and operated on.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt`能够表示任意精度的整数，这意味着你可以存储任意长度的整数。这在金融应用程序或任何需要表达和操作高精度整数的情况下特别有用。'
- en: 'A `BigInt` can only operate on itself, and is therefore not compatible with
    many of JavaScript''s native `Math` methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt`只能对自身进行操作，因此与JavaScript的许多原生`Math`方法不兼容：'
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'All native mathematics operators work with `BigInt` as long as both operands
    are of the same type:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 只要两个操作数的类型相同，所有原生数学运算符都可以与`BigInt`一起使用：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'However, if one operand is a `BigInt` and the other is a `Number`, then you''ll
    receive a `TypeError`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果一个操作数是`BigInt`，另一个是`Number`，那么你将收到一个`TypeError`：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The semantics of a `BigInt` is similar to `Number`: any value that is intuitively
    numerical and can be expressed as an integer can be stored in either `BigInt`
    or `Number`, depending on the extent of precision that it requires.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`BigInt`的语义与`Number`类似：任何直观数值且可以表示为整数的值都可以存储在`BigInt`或`Number`中，具体取决于它所需的精度。'
- en: Symbol
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号
- en: 'A `Symbol` primitive is used to represent an entirely unique value. Symbols
    are created via invoking the `Symbol` function, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Symbol`原始类型用于表示完全独特的值。通过调用`Symbol`函数创建符号，如下所示：'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can optionally pass an initial argument to this function to annotate your
    symbol for your own debugging purposes, but this is not necessary:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择向这个函数传递一个初始参数，以便为你自己的调试目的注释你的符号，但这并不是必要的：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Symbols are used to act as property keys where uniqueness is required or where
    you want to store metadata on objects. When you add a property to an object with
    a `Symbol` key, it will not be iterated over by normal object iteration approaches
    (such as `for...in`). `Symbol` keys of an object can only be retrieved via `Object.getOwnPropertySymbols`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 符号用作属性键，需要唯一性，或者想要在对象上存储元数据。当你使用`Symbol`键向对象添加属性时，它不会被普通的对象迭代方法（如`for...in`）迭代。对象的`Symbol`键只能通过`Object.getOwnPropertySymbols`来检索：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Since `Symbol` keys exist in an explicit but hidden manner, they are useful
    for storing programmatic information semantically that''s unrelated to the core
    data of the object but useful in fulfilling some programmatic need. For example,
    you may have a logging library and wish to annotate specific objects with custom-rendering
    functions that log in a specific way. Such a need could be easily fulfilled with
    symbols:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Symbol`键以显式但隐藏的方式存在，它们对于存储程序信息在语义上是有用的，这些信息与对象的核心数据无关，但在满足某些程序需求时很有用。例如，你可能有一个日志记录库，并希望用特定方式记录的自定义渲染函数注释特定对象。这样的需求可以很容易地通过符号来实现：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are not many everyday situations that would necessitate the creation and
    usage of new symbols, but there are many instances of prescribing native behavior
    by such symbols. For example, you can define a custom iterator for your object
    by using the `Symbol.iterator` property. We will cover this in greater detail
    in the *Arrays and iterables* section, later in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是很多日常情况下需要创建和使用新符号，但有很多情况下需要通过这些符号来规定原生行为。例如，你可以使用`Symbol.iterator`属性为你的对象定义一个自定义迭代器。我们将在本章后面的*数组和可迭代对象*部分详细介绍这一点。
- en: 'null'
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'null'
- en: 'The `null` primitive type is used to express the intentional absence of a value.
    It is a type with only one value: the only null value is `null`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`原始类型用于表示有意的值的缺失。它是一个只有一个值的类型：唯一的null值是`null`。'
- en: The semantics of `null` are crucially different from `undefined`. The `undefined` value
    is used to indicate something that is not declared or defined, while `null` is
    an explicitly declared absent value. We usually use the `null` value to indicate
    that a value is either explicitly not yet set or, for whatever reason, unavailable.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`的语义与`undefined`有着根本的不同。`undefined`值用于指示未声明或未定义的内容，而`null`是一个明确声明的缺失值。我们通常使用`null`值来表示一个值要么明确尚未设置，要么由于某种原因不可用。'
- en: 'For example, let''s consider an API where we specify various properties related
    to a restaurant review:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑一个API，我们在其中指定与餐厅评论相关的各种属性：
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `null` value, in this context, means that we do not know the value of `hasParking` yet.
    When we have the necessary information, we can specify `hasParking` as either `true`
    or `false` (`Boolean`), but to express our ignorance of its true value, we're
    setting it to `null`. We could also completely leave the value out, meaning that
    it would effectively be `undefined`. The key difference is that using `null` is
    always proactively done, while `undefined` is the result of wh something isn't
    done.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`null`值表示我们不知道`hasParking`的值。当我们有必要的信息时，我们可以将`hasParking`指定为`true`或`false`（`Boolean`），但为了表示我们对其真实值的无知，我们将其设置为`null`。我们也可以完全省略该值，这意味着它实际上是`undefined`。关键区别在于使用`null`总是主动进行的，而`undefined`是某事没有完成的结果。
- en: 'A `null` value, as we mentioned previously, is always falsy, meaning that it
    will always evaluate to `false` in a `Boolean` context. So, if we attempt to use
    `null` in a conditional statement, then it would not succeed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`null`值始终是假值，这意味着在`Boolean`上下文中它将始终计算为`false`。因此，如果我们尝试在条件语句中使用`null`，那么它将不会成功：
- en: '[PRE36]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'It is important to check for the exact values we want so that we can avoid
    bugs and communicate effectively to the people reading our code. In this case, 
    we may wish to explicitly check for `undefined` and `null` as we want to execute
    distinct code for that case versus the case of `false`. We could accomplish this
    like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要检查我们想要的确切值，这样我们可以避免错误并有效地向阅读我们代码的人传达信息。在这种情况下，我们可能希望明确检查`undefined`和`null`，因为我们想要针对这种情况执行不同的代码，而不是针对`false`的情况。我们可以这样做：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can also use the abstract equality operator (*`==`*) to compare to `null`,
    which will helpfully evaluate to `true` if the operand is either `null` or `undefined`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用抽象相等运算符（`==`）来与`null`进行比较，如果操作数是`null`或`undefined`，它将有用地评估为`true`：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is, in fact, doing the same as the more explicit comparison, but is far
    more succinct. Unfortunately, it's not very clear that its intention is to check
    for both `null` and `undefined`. We should usually prefer being explicit as this
    allows us to communicate our intent to other programmers in a more efficient way.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这与更明确的比较是一样的，但更加简洁。不幸的是，它并不清楚它的意图是检查`null`和`undefined`。通常我们应该更加明确，因为这样可以更有效地向其他程序员传达我们的意图。
- en: A final trap to avoid with null is the `typeof` operator. Due to some legacies
    of the JavaScript language, `typeof null` will, rather confusingly, return `"object"`
    and is therefore entirely unreliable.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免的最后一个陷阱是`null`的`typeof`运算符。由于JavaScript语言的一些遗留问题，`typeof null`会返回`"object"`，因此完全不可靠。
- en: More information about `typeof` and detection of the `null` type can be found
    in [Chapter 7](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml), *Dynamic Typing*,
    in the *Detection* section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 有关`typeof`和检测`null`类型的更多信息可以在[第7章](43f1d47f-08cd-4c87-a731-7c359ef3bedd.xhtml)的*动态类型*中的*检测*部分找到。
- en: 'So, there you have it. Null is a simple enough value and, insofar as clean
    code is concerned, you won''t go wrong if you remember two key points: that it
    should only be used to express the intentional absence of a value and that it
    should, ideally, be checked explicitly (prefer `value === null`).'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经知道了。`null`是一个足够简单的值，在干净的代码方面，只要记住两个关键点就不会出错：它只应该用来表示有意识地缺少一个值，并且最好明确地检查它（最好使用`value
    === null`）。
- en: undefined
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: undefined
- en: 'The `undefined` primitive type expresses that something hasn''t been defined
    yet or remains undefined. Like `null`, it is a type with only one value (`undefined`). Unlike
    `null`, an `undefined` value should not be explicitly set, but may be returned
    by the language when something does not have a value:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`undefined`原始类型表示某物尚未被定义或仍然未定义。与`null`一样，它是一个只有一个值（`undefined`）的类型。与`null`不同，`undefined`值不应该被明确设置，但当某物没有值时语言可能会返回它：'
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Undefined is best thought of as the absence of something. If you ever find yourself
    wishing to explicitly set something to `undefined`, you should probably reach
    for `null` instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 未定义最好被认为是某物的缺失。如果你发现自己希望明确地将某物设置为`undefined`，你应该考虑使用`null`代替。
- en: 'It''s important to distinguish between the concepts of undefined and not even
    declared. In JavaScript, if you try to evaluate an identifier that does not exist
    within your scope, you will get a `ReferenceError`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要区分未定义和甚至未声明的概念。在JavaScript中，如果你尝试评估一个在你的范围内不存在的标识符，你会得到一个`ReferenceError`：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, as you''ve already seen, if you try to evaluate a property of an object
    and the property does not exist, you will get no such error. Instead, it will
    evaluate to `undefined`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如你已经看到的，如果你尝试评估一个对象的属性，而该属性不存在，你将不会得到任何错误。相反，它将评估为`undefined`：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, if you try to access a property under the non-existent `foo` property,
    you''ll receive a `TypeError` complaining that it cannot read a property that
    has an `undefined` value:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试访问不存在的`foo`属性下的属性，你将收到一个`TypeError`，抱怨它无法读取一个具有`undefined`值的属性：
- en: '[PRE42]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This behavior is an extension of the fact that seeking to access any property
    on an `undefined` or `null` value will always throw such a `TypeError`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是寻求访问`undefined`或`null`值的任何属性时总是会抛出`TypeError`的扩展：
- en: '[PRE43]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Curiously, the `undefined` value, unlike `null`, is not a literal, but is a
    globally available value provided by the language. Overwriting this global value
    is not possible in ECMAScript 2015 onward, but it is still possible to define
    your own value for the undefined identifier in local (non-global) scopes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，与`null`不同，`undefined`值不是一个字面量，而是语言提供的一个全局可用的值。在ECMAScript 2015及以后的版本中不可能覆盖这个全局值，但在本地（非全局）范围内定义自己的`undefined`标识符的值仍然是可能的：
- en: '[PRE44]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is an anti-pattern as it can create very awkward and unexpected results.
    The accidental setting of `undefined` in a scope higher than your scope can mean
    that, if you were to rely on the value directly, you may end up referring to a
    value other than `undefined`. This lack of trust in the `undefined` value has
    historically meant that people have found other ways to forcefully make `undefined`
    available in their scope. For example, declaring a variable but not assigning
    it will always result in its value being `undefined`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种反模式，因为它可能会产生非常尴尬和意想不到的结果。在比你的范围更高的范围意外设置`undefined`可能意味着，如果你依赖于该值，你最终可能会引用一个不是`undefined`的值。对`undefined`值的不信任在历史上意味着人们已经找到其他方法来强制在他们的范围内使`undefined`可用。例如，声明一个变量但不给它赋值将始终导致它的值为`undefined`：
- en: '[PRE45]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also use JavaScript''s `void` operator on any value that will always
    return the `real` undefined value:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以对任何值使用JavaScript的`void`运算符，它将始终返回`real`的`undefined`值：
- en: '[PRE46]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Explicitly setting undefined within your scope means that you can safely refer
    to your `undefined` value without worrying that it has been compromised. Fortunately,
    however, you can avoid the pain of having to worry about this risk by using the `typeof`
    operator:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的范围内明确设置未定义意味着你可以安全地引用你的`undefined`值，而不必担心它已被破坏。然而，幸运的是，你可以通过使用`typeof`运算符来避免担心这种风险的痛苦：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will not throw a `ReferenceError` even if `myValue` does not exist. The
    `typeof` operator, as we've discovered with `null`, is a bit of a fair-weather
    friend as we can't always rely on it, but it is nonetheless very useful when explicitly
    checking for `undefined`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`myValue`不存在，这也不会抛出`ReferenceError`。正如我们已经发现的那样，`typeof`运算符与`null`一样，有时我们不能总是依赖它，但当明确检查`undefined`时，它仍然非常有用。
- en: Another way to avoid the risk of undefined is to enforce its correct usage within
    your code base by using a linting tool. We'll cover linting tools in [Chapter
    15](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml), *Tools for Cleaner Code.*
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 避免`undefined`的另一种方法是通过使用linting工具在代码库中强制正确使用它。我们将在[第15章](be9ab437-faeb-4a14-8a5f-663ddba470fd.xhtml)中介绍linting工具，*更干净的代码的工具*。
- en: 'In summary, `undefined` can be used cleanly if you remember the following two
    points:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，如果记住以下两点，可以干净地使用`undefined`：
- en: Avoid directly assigning `undefined` to a variable; you should use `null` instead
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免直接将`undefined`分配给变量；您应该使用`null`代替
- en: Always check for `undefined` explicitly, preferring the `typeof` operator
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终明确检查`undefined`，优先使用`typeof`运算符
- en: This concludes our exploration of primitive types in JavaScript. Now, we'll
    move on to non-primitives, that is, objects.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们对JavaScript中原始类型的探索。现在，我们将转向非原始类型，也就是对象。
- en: Objects
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: 'Everything that is not a primitive value in JavaScript can be considered an
    object. Even functions are, in fact, specialized objects; their only difference
    is that they can be invoked. Usually, however, when we use the term `Object`,
    we are referring to a plain object that is normally declared as an object literal
    delimited by curly braces, with a set of key-value pairs within:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，除了原始值之外的所有内容都可以视为对象。甚至函数实际上也是专门的对象；它们唯一的区别在于它们可以被调用。然而，通常情况下，当我们使用术语`对象`时，我们指的是通常以花括号括起来的对象文字声明的普通对象，其中包含一组键值对：
- en: '[PRE48]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can also instantiate an object via the `Object` constructor and then add
    properties directly:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过`Object`构造函数实例化对象，然后直接添加属性：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Even though they are equivalent, it's preferable to use an object literal in
    most situations as it is simpler to declare and to read, especially if there are
    many properties. It also has the added benefit of allowing you to create and pass
    an object as an expression without having to prepare it beforehand.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们是等效的，但在大多数情况下最好使用对象文字，因为它更简单声明和阅读，特别是如果有许多属性。它还具有一个额外的好处，即允许您创建并传递对象作为表达式，而无需事先准备。
- en: Property names
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性名称
- en: 'The keys that are used to add properties to objects (the property names) are
    internally stored as strings. However, when using the object literal syntax, you
    can declare the keys as regular identifiers (that is, anything you could use as
    a variable name), number literals, or string literals:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 用于向对象添加属性（属性名称）的键内部存储为字符串。但是，当使用对象文字语法时，可以将键声明为常规标识符（即，任何您可以用作变量名的内容）、数字文字或字符串文字：
- en: '[PRE50]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It''s preferable to use identifiers where possible as this helpfully restricts
    you to using key names that can easily be accessed as properties. If you use a
    string literal that is not also a valid identifier, then you''ll have to use square-bracket
    notation to access it, which can be burdensome:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最好尽可能使用标识符，因为这有助于限制您使用可以轻松访问为属性的键名。如果您使用的是不是有效标识符的字符串文字，那么您将不得不使用方括号表示法来访问它，这可能会很麻烦：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also use computed property names (delimited by square brackets) to
    add dynamically named items to an object literal:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用计算属性名称（用方括号括起来）将动态命名的项添加到对象文字中：
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we mentioned previously, all non-primitives in JavaScript are technically
    objects. What else makes something an object, though? Objects allow us to assign
    arbitrary values to them as properties, which is something primitives are not
    capable of. Beyond this characteristic, the definition of an object in JavaScript
    is left invitingly generic. We can wield objects in many different ways to suit
    the code we''re writing. Many languages will provide language constructs for dictionaries
    or hashmaps. In JavaScript, we can use objects to fulfill most of these needs.
    When we need to use store a key-value pair where the key is something other than
    a string, it''s common to provide a string representation of that value via the
    object''s `toString` method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，JavaScript中的所有非原始值在技术上都是对象。但是，还有什么使某物成为对象呢？对象允许我们将任意值分配给它们作为属性，这是原始值无法做到的。除了这一特征之外，JavaScript中对象的定义留下了令人愉快的泛化。我们可以以许多不同的方式使用对象来适应我们正在编写的代码。许多语言将为字典或哈希映射提供语言构造。在JavaScript中，我们可以使用对象来满足这些需求的大部分。当我们需要存储键值对，其中键不是字符串时，通常通过对象的`toString`方法提供该值的字符串表示：
- en: '[PRE53]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will be called internally when the object is put in a context where it
    is coerced to a string, such as when accessing or assigning via square-bracket
    notation:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被放置在强制转换为字符串的上下文中时，将在内部调用此方法，例如通过方括号表示法进行访问或分配：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This has historically been used to allow the implementation of data structures
    where the key is effectively non-primitive (even though objects technically store
    property names as strings). Nowadays, however, using `Map` or `WeakMap` is preferred.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这在历史上曾被用于允许实现数据结构，其中键实际上是非原始的（尽管对象在技术上将属性名称存储为字符串）。然而，如今更倾向于使用`Map`或`WeakMap`。
- en: Property descriptors
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性描述符
- en: 'When adding properties to objects in the conventional fashion, either via property
    access or via an object literal, the properties will be given the following implicit
    traits:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 以常规方式向对象添加属性，无论是通过属性访问还是通过对象文字，属性都将具有以下隐式特征：
- en: '`configurable`: This means the property can be deleted from the object (and
    if its property descriptor can be changed)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`configurable`：这意味着属性可以从对象中删除（如果其属性描述符可以更改）'
- en: '`enumerable`: This means the property will be visible to enumerations such
    as `for...in` and `Object.keys()`'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`enumerable`：这意味着属性将对`for...in`和`Object.keys()`等枚举可见'
- en: '`writable`: This means the property''s value can be changed via an assignment
    operator (such as `obj.prop = ...`)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`writable`：这意味着可以通过赋值运算符（例如`obj.prop = ...`）更改属性的值'
- en: JavaScript gives you the power to turn off these traits individually, but be
    wary that changes to these traits can obscure the behavior of your code. For example,
    if a property is described as not being writeable but a write is attempted via
    assignment (for example, `obj.prop = 123`), then the programmer will receive no
    warning that the write has not occurred. This can create unexpected and hard-to-find
    bugs. As ever, it's vital to keep in mind the expectations of the programmers
    who will be consuming your interfaces. So you keep the property descriptors with
    care and consideration.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript赋予你关闭这些特性的权力，但要注意，对这些特性的更改可能会使代码的行为变得模糊。例如，如果一个属性被描述为不可写，但尝试通过赋值进行写入（例如，`obj.prop
    = 123`），那么程序员将收到没有发生写入的警告。这可能会导致意外和难以找到的错误。因此，牢记将要使用你的接口的程序员的期望是至关重要的。因此，你要小心谨慎地保留属性描述符。
- en: 'You can define your own traits for a given property via the natively provided `Object.defineProperty()`.
    When setting up a new property descriptor, the default of each trait will be `false`,
    so if you wish to give the property a trait of either `configurable`, `enumerable`,
    or `writable`, then you will need to specify these as `true` explicitly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过原生提供的`Object.defineProperty()`为给定的属性定义自己的特性。在设置新属性描述符时，每个特性的默认值将为`false`，因此，如果希望给属性赋予`configurable`、`enumerable`或`writable`的特性，则需要明确指定这些特性为`true`。
- en: '[PRE55]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also use `Object.defineProperties()` to describe many properties at
    once:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`Object.defineProperties()`一次描述多个属性：
- en: '[PRE56]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you attempt to change the traits of a property that has `configurable` set
    to `false`, then you will receive a `TypeError`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试更改具有`configurable`设置为`false`的属性的特性，则会收到`TypeError`：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It is also possible to set custom setters and getters*. *A getter defines what
    value will be returned when a property is accessed, while a setter will define
    what occurs when an assignment is attempted on that property (that is, via the
    assignment operator). Using these can be useful in situations where you wish to
    have an internal implementation that holds the value in a unique way or somehow
    filters or processes the value upon assignment, for example:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以设置自定义的setter和getter。*getter定义了在访问属性时将返回的值，而setter将定义在尝试对该属性进行赋值时发生的情况（即通过赋值运算符）。在希望以独特方式保存值或在赋值时对值进行过滤或处理的情况下，使用这些功能可能很有用，例如：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'As the `name` property here has been described via `defineProperties`, it will
    have all of the default traits disabled, which means it is not enumerable, writeable,
    or configurable. If we try to enumerate it, we''ll discover that our internally
    used `normalizedName` is found:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`name`属性是通过`defineProperties`描述的，它将禁用所有默认特性，这意味着它不可枚举，不可写，也不可配置。如果我们尝试枚举它，我们会发现我们内部使用的`normalizedName`被找到了：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is something to keep in mind when working with property descriptors. Make
    sure you're aware of what traits every property has and watch out for leakage
    of your internal implementation!
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理属性描述符时要牢记这一点。确保你了解每个属性具有什么特性，并注意内部实现的泄漏！
- en: 'It''s worth noting that it is also possible (and often preferable) to define
    getters and setters for properties directly within an object literal or class
    definition. For example, we could create a subclass of `Array` with the addition
    of a `last` property, which acts as a getter for the last element in the array:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，也可以（通常更可取）在对象文字或类定义中直接为属性定义getter和setter。例如，我们可以创建一个`Array`的子类，添加一个`last`属性，该属性充当数组中最后一个元素的getter：
- en: '[PRE60]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There are many such creative uses of getters and setters. But, as with the traits
    of `configurable`, `enumerable`, and `writable`, it's important to be cautious
    of how your custom behaviors will affect the expectations of your fellow programmers.
    If the abstraction or data structures you create are not familiar or predictable
    in their behavior, then you're paving the way for misunderstandings and bugs.
    The best approach is to align with the natural semantics of the language itself.
    So, whenever you are about to create a custom setter or describe a property as
    unwritable, ask yourself whether it would be reasonable for a programmer to expect
    it to work that way. Follow a helpful rule dubbed as the **Principle of Least
    Astonishment** (**POLA**)!
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多这样创造性的getter和setter的用法。但是，与`configurable`、`enumerable`和`writable`的特性一样，重要的是要谨慎考虑你的自定义行为将如何影响你的同行程序员的期望。如果你创建的抽象或数据结构在行为上不熟悉或不可预测，那么你就为误解和错误铺平了道路。最好的方法是与语言本身的自然语义保持一致。因此，每当你要创建一个自定义setter或将属性描述为不可写时，请问自己程序员是否可以合理地期望它以这种方式工作。遵循一个有帮助的规则，被称为**最少惊讶原则**（**POLA**）！
- en: The POLA (or least surprise) applies to software design and UX design. It broadly
    means that a given function or component of a system should act as most users
    would expect it to and should seek not to surprise or astonish too much.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: POLA（或最少惊讶）适用于软件设计和UX设计。它广泛意味着系统的给定功能或组件应该像大多数用户期望的那样行事，并且不应该过于惊讶或使人惊讶。
- en: Map and WeakMap
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Map和WeakMap
- en: 'The  `Map` and `WeakMap` abstractions are capable of storing key-value pairs
    where, unlike regular objects, the key can be anything, including non-primitive
    values:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`和`WeakMap`抽象能够存储键值对，其中，与常规对象不同，键可以是任何东西，包括非原始值：'
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`WeakMap` is similar to `Map`, but it only holds a weak reference to the object
    that''s used as a key, meaning that, if the object becomes unavailable due to
    being garbage-collected elsewhere in your program, then `WeakMap` will cease to
    keep a hold of it.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakMap`类似于`Map`，但它只保留对用作键的对象的弱引用，这意味着，如果由于在程序的其他位置进行垃圾回收而使对象不可用，那么`WeakMap`将停止保持它。'
- en: Most of the time, a plain object is all you will need. You should only reach
    for `Map` or `WeakMap` if you need your keys to be non-primitive or if you want
    to weakly hold your values.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，普通对象就足够了。只有在需要键为非原始类型或者想要弱引用值时，才应该使用`Map`或`WeakMap`。
- en: The prototype
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: 'JavaScript is a prototypical language where inheritance is achieved via prototypes.
    This can be a daunting concept, but it is, in fact, beautifully simple. JavaScript''s
    prototypal behavior can be described like this: every time a property is accessed
    on an object, if it is not available on the object itself, JavaScript will attempt
    to access it on an internally available property called  `[[Prototype]]`. It will
    then repeat this process until it either finds the property or gets to the top
    of the prototype *chain* and returns `undefined`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种原型语言，继承是通过原型实现的。这可能是一个令人生畏的概念，但实际上非常简单。JavaScript的原型行为可以描述如下：每当在对象上访问属性时，如果该属性在对象本身上不可用，JavaScript将尝试在内部可用的`[[Prototype]]`属性上访问它。然后它将重复这个过程，直到找到属性或到达原型链的顶部并返回`undefined`。
- en: Understanding what this `[[Prototype]]` property is capable of will give you
    great power over the language and will immediately make JavaScript less daunting. 
    It can be difficult to grasp but is worth it in the end.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 了解`[[Prototype]]`属性的功能将使您对语言有很大的掌握，并且会立即使JavaScript变得不那么令人生畏。这可能很难理解，但最终是值得的。
- en: 'A `[[Prototype]]` object, which could feasibly be attached to any other object,
    is just a regular object itself. We could create one called `engineerPrototype` and
    have it contain data and methods related to the role of an engineer, for example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`[[Prototype]]`对象本身实际上就是一个普通对象，可以合理地附加到任何其他对象上。我们可以创建一个称为`engineerPrototype`的对象，并使其包含与工程师角色相关的数据和方法，例如：'
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we could attach this prototype to another object, thus making its properties
    available there as well. To do this, we use `Object.create()`, which creates a
    new object with a hardcoded `[[Prototype]]`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将这个原型附加到另一个对象上，从而使其属性也在那里可用。为此，我们使用`Object.create()`，它创建一个带有硬编码`[[Prototype]]`的新对象：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The internal `[[Prototype]]` property cannot be directly set, so we must use
    mechanisms such as `Object.create` and `Object.setPrototypeOf`. Note that you
    may have seen code that uses the non-standard `__proto__` property to set `[[Prototype]]`,
    but this is a legacy feature and should not be relied on.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 内部的`[[Prototype]]`属性不能直接设置，因此我们必须使用`Object.create`和`Object.setPrototypeOf`等机制。请注意，您可能已经看到使用非标准的`__proto__`属性来设置`[[Prototype]]`的代码，但这是一个遗留特性，不应依赖它。
- en: 'With this newly created `pandaTheEngineer` object, we are able to access any
    properties available on its `[[Prototype]]`, such as `engineerPrototype`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个新创建的`pandaTheEngineer`对象，我们可以访问其`[[Prototype]]`上可用的任何属性，比如`engineerPrototype`：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We can illustrate that the objects are now linked by adding a new property
    to `engineerPrototype` and observe how it is made available on `pandaTheEngineer`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过向`engineerPrototype`添加新属性来说明这些对象现在是链接在一起的，并观察它如何在`pandaTheEngineer`上可用：
- en: '[PRE65]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'As we mentioned previously, the `[[Prototype]]` of an object will only be used
    to resolve a property if it is not already available on the object itself. The
    following code shows how we can set our own `sayHello` method on our `pandaTheEngineer` object,
    and that by doing so we no longer have access to the `sayHello` method defined
    on `[[Prototype]]`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果对象本身上没有可用的属性，`[[Prototype]]`的属性将被用于解析属性。以下代码显示了我们如何在`pandaTheEngineer`对象上设置自己的`sayHello`方法，这样一来，我们就不再可以访问`[[Prototype]]`上定义的`sayHello`方法：
- en: '[PRE66]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'However, deleting this newly added `sayHello` method would mean we once again
    have access to the `[[Prototype]]` `sayHello` method:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，删除这个新添加的`sayHello`方法意味着我们再次可以访问`[[Prototype]]`上的`sayHello`方法：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To understand what''s happening and which properties are coming from which
    object, we are always able to inspect the `[[Prototype]]` of an object using `Object.getPrototypeOf`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解发生了什么以及哪些属性来自哪个对象，我们始终可以使用`Object.getPrototypeOf`来检查对象的`[[Prototype]]`：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we can inspect its properties via `Object.getOwnPropertyNames`:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过`Object.getOwnPropertyNames`检查它的属性：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Here, we can see that the `[[Prototype]]` object (that is, `engineerPrototype`)
    is providing the `type`, `sayHello,` and `sayGoodbye` properties. If we inspect
    the `pandaTheEngineer` object itself, we can see that it only has a `name` property:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到`[[Prototype]]`对象（即`engineerPrototype`）提供了`type`、`sayHello`和`sayGoodbye`属性。如果我们检查`pandaTheEngineer`对象本身，我们会发现它只有一个`name`属性：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'As we observed with our earlier addition of the `sayGoodbye` method, we can
    modify that prototype at any time and have our changes accessible to any objects
    that use that prototype. Here''s another example of doing this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前添加`sayGoodbye`方法时观察到的，我们可以随时修改该原型，并且我们的更改将对使用该原型的任何对象可用。这里是另一个这样做的例子：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, you can see how our inherited `sayHello` method is producing a string
    that includes our mutated type property (that is, `"Awesome Engineer"`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们继承的`sayHello`方法是如何生成一个包含我们变异的类型属性（即`"Awesome Engineer"`）的字符串。
- en: Hopefully, you are beginning to see how we could construct a hierarchy of inheritance
    using prototypes. The very simple mechanism of `[[Prototype]]` allows us to express
    complex hierarchical relations between problem domains expressed as objects. This
    is how OOP is achieved in JavaScript.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您开始看到我们如何使用原型构建继承层次结构。`[[Prototype]]`的非常简单的机制允许我们在对象表示的问题域之间表达复杂的层次关系。这就是JavaScript中实现OOP的方式。
- en: We could feasibly create another prototype that itself uses `engineerPrototype`,
    possibly `fullStackEngineerPrototype`, and it would work as expected, with each
    prototype defining another layer of property resolution.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以合理地创建另一个原型，它本身使用`engineerPrototype`，可能是`fullStackEngineerPrototype`，并且它将按预期工作，每个原型定义另一层属性解析。
- en: 'Below the surface, JavaScript''s newer *Class Definition Syntax*, which you
    may have grown accustomed to, relies on this underlying mechanism of prototypes
    as well. This can be observed here:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的新*类定义语法*在表面之下，你可能已经习惯了，依赖于原型的这种基本机制。这可以在这里观察到：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: You'll notice that there are some subtle differences here. The most crucial
    one is that, when declaring classes, there is currently no way to define non-method
    properties on the prototype object. When we declare the `type` property, we are
    populating the instance itself so that when we inspect the properties of the instance,
    we get `"type"` and `"name"`. However, the methods (such as `sayHello`) will exist
    on the `[[Prototype]]`. Another difference is that, of course, when using classes,
    we are able to declare a `constructor`, which itself is a method/property on the
    `[[Prototype]]`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里有一些细微的差别。最关键的一个是，在声明类时，目前没有办法在原型对象上定义非方法属性。当我们声明`type`属性时，我们正在填充实例本身，所以当我们检查实例的属性时，我们得到`"type"`和`"name"`。然而，方法（比如`sayHello`）将存在于`[[Prototype]]`上。另一个区别是，当使用类时，我们能够声明一个`constructor`，它本身是`[[Prototype]]`上的一个方法/属性。
- en: Fundamentally, the *Class Definition Syntax* (introduced in *ECMAScript 2015*),
    does not make anything possible that was not already possible in the language.
    It's just utilizing the existing prototypical mechanism. However, the newer syntax
    does make some things simpler, such as referring to a superclass with the `super`
    keyword.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，*类定义语法*（在*ECMAScript 2015*中引入）并没有使语言中已经存在的任何东西成为可能。它只是利用了现有的原型机制。然而，新的语法确实使一些事情变得更简单，比如使用`super`关键字引用超类。
- en: 'Before class definitions existed, we typically wrote class-like abstractions
    by assigning our intended `[[Prototype]]` object to the `prototype` property of
    a function, as shown here:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在类定义存在之前，我们通常通过将我们预期的`[[Prototype]]`对象分配给函数的`prototype`属性来编写类似类的抽象，如下所示：
- en: '[PRE73]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'When a function is instantiated via the `new` operator, JavaScript will implicitly
    create a new object with its `[[Prototype]]` set to the function''s `prototype`
    property, if it has one. Let''s try instantiating the `Engineer` function:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数通过`new`运算符实例化时，如果有的话，JavaScript将隐式地创建一个`[[Prototype]]`设置为函数的`prototype`属性的新对象。让我们尝试实例化`Engineer`函数：
- en: '[PRE74]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Inspecting this yields the same characteristics that we saw in our original
    `Object.create` approach:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 检查这个结果会得到我们在原始`Object.create`方法中看到的相同特征：
- en: '[PRE75]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Broadly, all of these approaches are the same but have some subtle differences
    around where certain properties reside (that is, whether its properties are on
    the instance itself or on its `[[Prototype]]`). The newer *Class Definition Syntax*
    is useful and succinct and so is preferable nowadays, but it is nonetheless useful
    to have an underlying knowledge about how prototypes work as it drives the entirety
    of the language, including all of its native types. We can inspect these native
    types in the same manner as in the preceding code:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，所有这些方法都是相同的，但在某些属性所在的位置上有一些细微的差别（即，它的属性是在实例本身上还是在它的`[[Prototype]]`上）。新的*类定义语法*很有用且简洁，因此现在更受欢迎，但了解原型工作的基本知识仍然很有用，因为它驱动着整个语言，包括所有的原生类型。我们可以像在前面的代码中一样检查这些原生类型：
- en: '[PRE76]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Mutating native prototypes is an anti-pattern and should be avoided at all
    costs as it can create unexpected conflicts with other code in your code base.
    Since a runtime will only have a single set of native types available, when you
    modify them, you are modifying the capabilities of every single instance of that
    type that currently exists. Therefore, it is best to abide by a simple rule: **only
    modify your own prototypes**.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 变异原生原型是一种反模式，应该尽量避免，因为它可能会在代码库中与其他代码产生意外的冲突。由于运行时只有一个集合的原生类型可用，当你修改它们时，你正在修改当前存在的该类型的每个实例的能力。因此，最好遵守一个简单的规则：**只修改你自己的原型**。
- en: 'If you ever catch yourself trying to modify a native prototype, it may be better
    if you created your own subclass of that type and added your functionality there:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己试图修改一个原生原型，最好是创建该类型的自己的子类，并在那里添加你的功能：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, we're creating our own `Array` subclass called `HeartArray` so that we
    can add our own specialized `join` method.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建我们自己的`Array`子类，称为`HeartArray`，以便我们可以添加我们自己专门的`join`方法。
- en: When and how to use objects
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时以及如何使用对象
- en: An object of any type, much like our primitive values, should only be used inline
    with the semantic concept it represents. The preceding case of subclassing `Array`
    to `HeartArray` makes sense as the data we wish to express via it is indeed array-like,
    that is, it is a sequential set of words.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类型的对象，就像我们的原始值一样，应该只与它所代表的语义概念一起使用。将`Array`子类化为`HeartArray`的前面案例是有意义的，因为我们希望通过它来表达的数据确实类似于数组，也就是说，它是一组顺序的单词。
- en: When we go about molding objects into abstractions that suit our needs, we should
    always consider the expectations that other programmers will have about objects
    and the ramifications of those expectations. We'll go into the subtleties of designing
    good abstractions in [Chapter 11](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml),
    *Design Patterns,* where we will be utilizing objects to craft abstractions in
    a multitude of ways.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始将对象塑造成适合我们需求的抽象时，我们应该始终考虑其他程序员对对象的期望以及这些期望的后果。我们将在[第11章](9ef81929-c89f-4988-aa66-436c59f7f43f.xhtml)中深入探讨设计良好的抽象的微妙之处，那里我们将利用对象以多种方式来构建抽象。
- en: This section has introduced you to the concept of objects in JavaScript—how
    they are everywhere—and how they operate beneath the surface via prototypes. This
    fundamental knowledge will make working with JavaScript much easier and will help
    you write cleaner code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了JavaScript中对象的概念——它们无处不在——以及它们是如何通过原型在表面之下运作的。这些基本知识将使你更容易地使用JavaScript，并帮助你编写更干净的代码。
- en: Functions
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Functions in JavaScript are like any other type; they can be passed around just
    like objects and primitive types. When we talk about most other values, however,
    we see that there is usually only one way to literally declare them. Object literals
    are declared using braces. Array literals are delimited square brackets. Functions,
    however, come in a variety of literal forms.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数就像任何其他类型一样；它们可以像对象和原始类型一样传递。然而，当我们谈论大多数其他值时，我们会发现通常只有一种方式来声明它们。对象文字使用大括号声明。数组文字使用方括号分隔。然而，函数以各种文字形式出现。
- en: 'When outside of an object literal or class definition, you can declare a function
    in three different ways: as a function declaration, as a function expression,
    or as a fat-arrow function expression:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象文字或类定义之外，可以以三种不同的方式声明函数：作为函数声明，作为函数表达式，或作为一个箭头函数表达式：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'When declaring functions inside object literals, however, there is a more succinct
    syntax, called a **method definition**:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在对象文字中声明函数有一种更简洁的语法，称为**方法定义**：
- en: '[PRE79]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to separate these method definitions with a comma (just as we''d have
    to do with any other properties defined in an object literal). Class definitions
    also allow us to use method definitions, although they don''t require separating
    commas:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要用逗号分隔这些方法定义（就像我们必须对对象文字中定义的任何其他属性做的那样）。类定义也允许我们使用方法定义，尽管它们不需要分隔逗号：
- en: '[PRE80]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Methods are just functions that are *bound* to an object when invoked. This
    includes functions defined within class definitions and functions that are in
    any way assigned to a property of an object. When discussing code with other programmers,
    it's useful to know what people mean when they say *method* versus *function*.
    Fundamentally, however, the language of JavaScript does not distinguish between
    these—they are all technically just functions.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是在调用时绑定到对象的函数。这包括在类定义内部定义的函数和以任何方式分配给对象属性的函数。然而，在讨论代码时，了解人们说*方法*和*函数*时的含义是有用的。然而，从根本上讲，JavaScript的语言并不区分它们——它们在技术上都只是函数。
- en: 'All the various ways of defining functions have subtle differences that are
    worth knowing about because the typical JavaScript code base will use most, if
    not all, of these styles. The types of differences you''ll encounter in how functions
    are declared include the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数的各种方式都有微妙的差异，值得了解，因为典型的JavaScript代码库将使用大多数，如果不是所有这些风格。您将遇到的函数声明的差异类型包括以下内容：
- en: Whether the definition style is *hoisted* to the top of its scope; for example,
    with function declarations
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义风格是否*提升*到其作用域的顶部；例如，函数声明
- en: Whether the definition style creates a function that has its own bindings (for
    example, `this`); for example, with function expressions
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义风格是否创建具有自己绑定的函数（例如，`this`）；例如，函数表达式
- en: Whether the definition style creates a function with its own `name` property;
    for example, with function declarations
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义风格是否创建具有自己`name`属性的函数；例如，函数声明
- en: Whether the definition style is contextual to specific areas of code; for example,
    with method definitions
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义风格是否与代码的特定区域相关；例如，方法定义
- en: Now, we can go into more detail about the syntax of the various definition styles.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更详细地讨论各种定义风格的语法。
- en: Syntactic context
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法上下文
- en: 'There are three syntactic contexts in which a function can exist:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以存在于三种语法上下文中：
- en: As a statement
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个声明
- en: As an expression
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个表达式
- en: As a method definition
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为方法定义
- en: '**Statements** can be thought of as the scaffolding. For example, `const X
    = 123` is a *Statement* that contains a `const` declaration and assignment. **Expressions** can
    be thought of as the values that you place into the scaffolding; for example, `123` in
    the latter *statement* is an *expression*. In [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml),
    *Parts of Syntax and Scope**,* we''ll talk about this topic in more detail.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**语句**可以被视为脚手架。例如，`const X = 123`是一个包含`const`声明和赋值的*语句*。**表达式**可以被视为您放入脚手架中的值；例如，后一个*语句*中的`123`是一个*表达式*。在[第9章](1b37008e-8843-431a-9545-56d4246e3447.xhtml)中，*语法和作用域的部分*，我们将更详细地讨论这个主题。'
- en: 'The difference between functions as statements and functions as expressions
    is exemplified by the function expression and the function declaration. The function
    declaration is quite unique in that it is the only way to declare a function that
    is technically a statement. To be considered a function declaration, the syntax
    of `function name() {}` must reside on its own without being used in the context
    of an expression. This can be incredibly confusing because you cannot always tell
    whether a function is a function declaration or function expression based purely
    on its own syntax; instead, you must look at the context in which it exists:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 函数作为语句和函数作为表达式之间的区别体现在函数表达式和函数声明上。函数声明非常独特，因为它是声明函数的唯一方式。要被视为函数声明，`function
    name() {}`的语法必须独立存在，不能用在表达式的上下文中。这可能非常令人困惑，因为你不能仅仅根据函数自身的语法来判断函数是函数声明还是函数表达式；相反，你必须看它存在的上下文：
- en: '[PRE81]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As we mentioned previously, a function expression is allowed to have a name,
    just like a function declaration, but that name may not match the name of the
    variable that the function is assigned to.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，函数表达式允许有一个名称，就像函数声明一样，但该名称可能与分配给函数的变量的名称不匹配。
- en: 'It''s easiest to think of expressions as anything that can legally exist to
    the right-hand side of the assignment operator. All of the following *right-hand
    sides* are legal expressions:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最容易将表达式视为任何可以合法存在于赋值运算符的右侧的东西。以下所有的*右侧*都是合法的表达式：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Function expressions are as flexible as all the other values in JavaScript in
    terms of where they can be placed syntactically. Function declarations, as we
    will discover, are limited. Method definitionsare also limited to exist within
    the confines of either an object literal or a class definition.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式在语法上与JavaScript中的所有其他值一样灵活。我们将发现，函数声明是有限制的。方法定义也受限于存在于对象字面量或类定义的范围内。
- en: Function bindings and this
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数绑定和this
- en: 'A function''s bindings refer to a set of additional and implicit values that
    JavaScript makes available for referencing within the body of the function. These
    bindings include the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的绑定指的是JavaScript在函数体内提供的一组额外和隐式值的引用。这些绑定包括以下内容：
- en: '`this`: The `this` keyword refers to the execution context of a function''s
    invocation'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`：`this`关键字指的是函数调用的执行上下文'
- en: '`super`: The `super` keyword in a method or constructor refers to its super-class'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super`：方法或构造函数中的`super`关键字指的是其超类'
- en: '`new.target`: This binding informs you as to whether the function was invoked
    as a constructor (via the `new` operator)'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`new.target`：此绑定告诉您函数是否是通过`new`运算符作为构造函数调用的'
- en: '`arguments`: This binding provides access to the arguments that are passed
    to a function when it is invoked'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`arguments`：此绑定提供了对在调用函数时传递的参数的访问'
- en: These bindings are available to all functions except those defined with the
    arrow syntax (`fn = () => {}`). Functions defined in this way will effectively absorb
    the bindings from the parent scope (if one is available). Each of these bindings
    has unique behaviors and constraints. We will explore these in the following subsections.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这些绑定对所有函数都可用，除了使用箭头语法定义的函数（`fn = () => {}`）。以这种方式定义的函数将有效地吸收父作用域的绑定（如果有的话）。每个绑定都有独特的行为和约束。我们将在以下子节中探讨这些内容。
- en: Execution context
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行上下文
- en: 'The `this` keyword is usually determined at the calltime of the function and
    will normally resolve to the object that the function is being invoked on. It
    is sometimes referred to as the execution context of a function or its `thisArg`. This
    can be unintuitive since it means that the `this` value can technically change
    between calls. For example, we could assign a method from one object to another,
    call it on the second, and observe that its `this` is always the object it''s
    been called on:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字通常在函数调用时确定，并且通常会解析为函数被调用的对象。它有时被称为函数的执行上下文或`thisArg`。这可能不直观，因为这意味着`this`值在调用之间可以在技术上发生变化。例如，我们可以将一个对象的方法分配给另一个对象，然后在第二个对象上调用它，并观察到它的`this`始终是调用它的对象：'
- en: '[PRE83]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: When called without an object of invocation, as is the case when we directly
    call `sayMyName`, its presumed execution context is the global environment in
    which the code resides. On the browser, this global environment is equal to the
    window object (which provides access to the browser-and-document object models),
    while in Node.js, this refers to an environment that's unique to each specific
    module/file, which includes, among other things, that module's exports.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有调用对象时，例如我们直接调用`sayMyName`时，它的假定执行上下文是代码所在的全局环境。在浏览器中，这个全局环境等同于window对象（提供对浏览器和文档对象模型的访问），而在Node.js中，this指的是每个特定模块/文件独有的环境，其中包括该模块的exports等内容。
- en: 'In addition to the case of calling a function globally, there are two cases
    where the `this` keyword will be something other than the apparent object of invocation:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在全局调用函数的情况下，还有两种情况下`this`关键字会是除了明显的调用对象之外的东西：
- en: If the function being called was defined as an arrow-function, then it will
    absorb the `this` value from the scope in which it is situated
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被调用的函数被定义为箭头函数，那么它将吸收所在作用域的`this`值
- en: If the function being called is a constructor, its `this` value that will be
    a new object that has its `[[Prototype]]` preset to the prototype property of
    the function
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果被调用的函数是构造函数，它的`this`值将是一个新对象，其`[[Prototype]]`预设为函数的原型属性
- en: 'There are also ways to force the value of `this` when calling or declaring
    a function. You can use `bind(X)` to create a new function that will have its
    `this` value set to `X`:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用或声明函数时，也有一些方法可以强制`this`的值。您可以使用`bind(X)`来创建一个新函数，其`this`值设置为`X`：
- en: '[PRE84]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can also use a function''s `call` and `apply` methods to force the `this`
    value for any given invocation, but note that this will not work if the function
    is being called as a constructor (that is, with a new keyword) or if it has been
    defined with the arrow-function syntax:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用函数的`call`和`apply`方法来强制任何给定调用的`this`值，但请注意，如果函数被调用为构造函数（即使用`new`关键字）或者使用箭头函数语法定义，则这将不起作用：
- en: '[PRE85]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In your everyday function calls, it's best to avoid awkward techniques of invocation
    like this. Such techniques can make it difficult for the readers of your code
    to discern what's happening. There are many valid applications of invoking via
    `call`, `apply`, or `bind`, but these are usually limited to lower-level libraries
    or utility code. Higher-level logic should avoid them. If you find yourself having
    to rely on these methods in higher-level abstractions, then you're likely making
    something more complicated than it needs to be.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常函数调用中，最好避免像这样的奇怪调用技术。这些技术可能会使您的代码的读者难以理解发生了什么。使用`call`、`apply`或`bind`进行调用有许多有效的应用，但这些通常局限于较低级别的库或实用程序代码。高级逻辑应该避免使用它们。如果您发现自己在高级抽象中不得不依赖这些方法，那么您可能正在使事情变得比必要的更加复杂。
- en: super
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: super
- en: 'The super keyword comes in three distinct flavors:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: super关键字有三种不同的用法：
- en: '`super()` as a direct function invocation will call the superclass''s constructor
    (that is, its object''s  `[[Prototype]]` constructor) and is only valid to call
    within a constructor. It also must be called before trying to access `this` as
    it is `super()` itself that''ll initiate the execution context.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super()`作为直接函数调用将调用超类的构造函数（即其对象的`[[Prototype]]`构造函数），并且只能在构造函数中调用。它还必须在尝试访问`this`之前调用，因为是`super()`本身将启动执行上下文。'
- en: '`super.property` will access a property on the superclass (that is, the `[[Prototype]]`),
    and is only valid to reference within a constructor or method defined using the
    method definition syntax.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super.property`将访问超类的属性（即`[[Prototype]]`），并且只能在使用方法定义语法定义的构造函数或方法中引用。'
- en: '`super.method()` will invoke a method on the superclass (that is, the `[[Prototype]]`),
    and is only valid to call within a constructor or method defined using the method
    definition syntax.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`super.method()`将调用超类的方法（即`[[Prototype]]`），并且只能在构造函数或使用方法定义语法定义的方法中调用。'
- en: 'The `super` keyword was introduced to the language at the same time as the
    class definition and method definition syntax, so it is tied up in those constructs.
    You are free to use `super` in class constructors, methods, and also in method
    definitions within object literals:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`关键字是在语言中引入的同时，类定义和方法定义语法也一起引入的，因此它与这些结构有关。您可以在类构造函数、方法以及对象文字中的方法定义中自由使用`super`：'
- en: '[PRE86]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `super` keyword, as its name suggests, is semantically suited to referencing
    a superclass, so 99% of its valid use cases will be within class definitions,
    where you''re seeking to reference the class being extended, like so:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`关键字，正如其名称所示，语义上适合引用超类，因此它的99%有效用例将在类定义中，您希望引用被扩展的类时使用，如下所示：'
- en: '[PRE87]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Using `super` in this manner is entirely intuitive, especially to programmers
    who are used to other OOP languages. For individuals adept with JavaScript's prototype
    mechanism, however, the implementation of `super` can seem confusing. Unlike the `this`
    value, `super` is bound at definition time, instead of call time. We've seen how
    we can manipulate the value of this by calling a method in a specific manner (for
    example, using `fn.call()`). You cannot similarly manipulate `super`. Hopefully,
    this will not affect you in any way, but it is useful to remember nonetheless.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用`super`是完全直观的，特别是对于习惯于其他面向对象编程语言的程序员。然而，对于精通JavaScript原型机制的人来说，`super`的实现可能会令人困惑。与`this`值不同，`super`在定义时绑定，而不是在调用时。我们已经看到了如何通过以特定方式调用方法（例如使用`fn.call()`）来操纵`this`的值。您不能类似地操纵`super`。希望这不会以任何方式影响您，但是记住这一点也是有用的。
- en: new.target
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: new.target
- en: 'The `new.target` binding will be equal to the current function being called
    if the function has been called via a `new` operator. We typically use the `new`
    operator to instantiate classes, and in this case, we will correctly expect `new.target`
    to be that class:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '`new.target`绑定将等于当前被调用的函数，如果函数是通过`new`运算符调用的。我们通常使用`new`运算符来实例化类，在这种情况下，我们将正确地期望`new.target`是该类：'
- en: '[PRE88]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'This is useful when we may wish to carry out a certain behavior if a constructor
    is called directly versus when called via `new`. A common defensive strategy is
    to make your constructor behave in the same way, regardless of whether it''s called
    with or without `new`. This can be achieved by checking for `new.target`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们希望在直接调用构造函数与通过`new`调用时执行某种行为时，这是有用的。一个常见的防御策略是使您的构造函数以相同的方式行为，无论是使用还是不使用`new`调用。这可以通过检查`new.target`来实现：
- en: '[PRE89]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Alternatively, you may wish to throw an error to check that a constructor has
    been invoked incorrectly:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可能希望抛出错误以检查构造函数是否被错误调用：
- en: '[PRE90]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Both of these examples would be considered intuitive use cases of `new.target`.
    There is, of course, the possibility to use it to deliver entirely different functionality
    depending on the calling pattern, but in the interest of catering to the reasonable
    expectations of programmers, it's best to avoid such behavior. Remember the POLA.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都被认为是`new.target`的直观用例。当然，也有可能根据调用模式提供完全不同的功能，但为了满足程序员的合理期望，最好避免这种行为。记住POLA。
- en: arguments
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: arguments
- en: The `arguments` binding is made available as an array-like object and will contain
    the arguments that a given function was called with.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`绑定作为一个类似数组的对象提供，并且将包含给定函数调用时使用的参数。'
- en: When we say that `arguments` is array-like, we are referring to the fact that
    it has a `length` property and properties indexed from zero (just like a regular
    `Array`), but it still just a regular `Object` and therefore does not have any
    of array's built-in methods available, such as `forEach`, `reduce`, and `map`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说`arguments`类似于数组时，我们指的是它具有`length`属性和从零开始索引的属性（就像普通的`Array`一样），但它仍然只是一个普通的`Object`，因此没有任何数组的内置方法可用，例如`forEach`、`reduce`和`map`。
- en: 'Here, we can observe that the arguments are provided within the scope of a
    given function:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到参数是在给定函数的范围内提供的：
- en: '[PRE91]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The `arguments` binding was popularly used to gain access to an arbitrary (that
    is, non-fixed) amount of arguments, though its usefulness quickly disappeared
    after the language introduced the *rest parameter* syntax (`...arg`). This newer
    syntax can be used when defining a function to instruct JavaScript to place remaining
    arguments into a singular array. This meant that you could achieve all of the
    utility of the older `arguments` binding, plus you''d have a value that was not
    merely array-like but actually a genuine array. Here''s an example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments`绑定曾经被广泛用于访问任意（即非固定）数量的参数，尽管在语言引入了*rest参数*语法（`...arg`）后，其实用性迅速消失。这种更新的语法可以在定义函数时使用，指示JavaScript将剩余参数放入一个数组中。这意味着您可以实现所有旧的`arguments`绑定的实用性，而且您将获得一个不仅仅是类似数组而且实际上是真正数组的值。以下是一个示例：'
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Even though the `arguments` object has fallen out of favor, it is still within
    the language spec and works in older environments, so you may still see it in
    the wild. Most of the time, its usage can be avoided.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`arguments`对象已经不再流行，但它仍在语言规范中，并在旧环境中工作，因此你可能仍然会在实际中看到它。大多数情况下，可以避免使用它。
- en: Function names
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数名称
- en: 'Confusingly, functions have names, and these names are not the same as the
    variables or properties that we assign to functions. The name of a function is
    within its syntax, prior to its parentheses:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 令人困惑的是，函数有名称，这些名称与我们分配给函数的变量或属性不同。函数的名称在其括号之前的语法中：
- en: '[PRE93]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You can access a function''s name via its `name` property:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过其`name`属性访问函数的名称：
- en: '[PRE94]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'When you define a function via the function declaration syntax, it''ll assign
    that function to a local variable of the same name, meaning that we can reference
    the function as we would expect:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当您通过函数声明语法定义函数时，它将将该函数分配给同名的局部变量，这意味着我们可以像预期的那样引用该函数：
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Method definitionswill also assign the method to a property name that is equal
    to the function name:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义也将方法分配给等于函数名称的属性名称：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You may be thinking this all seems incredibly intuitive. And it is. It makes
    perfect sense that the names we give our functions and methods are themselves
    used to dictate what variable or property those things will be assigned to. Oddly,
    though, it is also possible to have named function expressions, and these names
    do not cause such an assignment. The following is an example of this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这一切看起来非常直观。的确如此。我们给函数和方法的名称本身用来指示那些东西将被分配给什么变量或属性是完全合理的。然而，奇怪的是，也可以有命名函数表达式，而这些名称并不会导致这样的分配。以下是一个例子：
- en: '[PRE97]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The `const` name here, `myFunction`, dictates what we will use in subsequent
    lines to reference the function. However, the function technically has a name
    of `"hullaballoo"`:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`const`名称`myFunction`决定了我们将在随后的行中用来引用函数。然而，函数在技术上有一个名为`"hullaballoo"`的名称：
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If we try to reference the function via its formal name, we will get an error:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试通过其正式名称引用函数，将会出错：
- en: '[PRE99]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This can seem odd. Why is it possible to give a function a name if that name
    itself is not used to refer to the function? This is a mixture of legacy and convenience.
    One hidden feature of the named function expression is that the name is actually
    available to you to reference the function, but only inside the scope of the function
    itself:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很奇怪。如果函数的名称本身不用于引用函数，为什么可以给函数命名？这是一种遗留和便利的混合。命名函数表达式的一个隐藏特性是，名称实际上是可用于引用函数的，但只能在函数本身的范围内：
- en: '[PRE100]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'This can be useful in situations where you want to supply an *anonymous* callback
    to some other function but still be able to reference your own callback for any
    repeated or recursive calls, like so:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这在您想要为某个其他函数提供一个*匿名*回调，但仍然能够引用您自己的回调以进行任何重复或递归调用的情况下非常有用，如下所示：
- en: '[PRE101]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: So, even though the named function expression is an odd thing, it does have
    its merits. In usage, however, it's best to take into consideration the clarity
    of your code for people who might not know of these idiosyncratic behaviors. This
    does not mean avoiding it altogether, but just being ever more mindful of the
    readability of your code when using it.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使命名函数表达式是一件奇怪的事情，它也有其优点。然而，在使用时，最好考虑到你的代码对于可能不了解这些特殊行为的人的清晰度。这并不意味着完全避免它，而只是在使用时更加注意代码的可读性。
- en: Function declarations
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明
- en: 'Function declarations are a type of *hoisted declaration*. A hoisted declaration
    is one that will, at runtime, be effectively hoisted up the top of its execution
    context, meaning that it will be immediately accessible to preceding lines of
    code (seemingly *before* it''s declared):'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明是一种*提升声明*。提升声明是在运行时有效地将其提升到其执行上下文的顶部，这意味着它将立即对前面的代码行可访问（看起来是*在*它声明之前）：
- en: '[PRE102]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'This, of course, is not possible with a function expression that''s been assigned
    to a variable:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这对于分配给变量的*函数表达式*是不可能的：
- en: '[PRE103]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The hoisted behavior of function declarations can create unexpected results,
    so it is typically considered an anti-pattern to rely on the hoist. In general,
    it's fine to use function declarations, as long as they're used in a way that
    respects the assumptions that programmers will intuitively make. Hoisting, as
    a practice, is not very intuitive to most people, and so it's usually best to
    avoid it.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 函数声明的变量提升行为可能会产生意想不到的结果，因此通常被认为是依赖提升的反模式。一般来说，使用函数声明是可以的，只要以程序员直观假设的方式使用。提升作为一种实践，对大多数人来说并不直观，因此最好避免使用它。
- en: For more information on scopes and how hoisting occurs in the case of function
    declarations, please take a look at [Chapter 9](1b37008e-8843-431a-9545-56d4246e3447.xhtml), *Parts
    of Syntax and Scope*, and go to the *Scopes and Declarations* section.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 有关作用域和函数声明的变量提升发生的更多信息，请查看[第9章](1b37008e-8843-431a-9545-56d4246e3447.xhtml)，*语法和作用域的部分*，并转到*作用域和声明*部分。
- en: Function expressions
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数表达式
- en: 'Function expressions are the easiest and most predictable to use as they are
    syntactically similar to all the other values within JavaScript. You can use them
    to *literally* define functions anywhere you would define any other value as they
    are a type of expression. Observe here, for example, how we''re defining an array
    of functions:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式是最容易和最可预测的使用，因为它们在语法上类似于JavaScript中的所有其他值。您可以使用它们*字面上*在任何定义其他值的地方定义函数，因为它们是一种表达式。例如，观察这里，我们如何定义一个函数数组：
- en: '[PRE104]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'A common application of the function expression is in passing callbacks to
    other functions so that they can be called at some later point. Many native `Array`
    methods, such as `forEach`, accept functions in this manner:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式的常见应用是将回调传递给其他函数，以便它们可以在以后的某个时间点被调用。许多原生的`Array`方法，如`forEach`，以这种方式接受函数：
- en: '[PRE105]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Here, we are passing a function expression to the `forEach` method. We haven't
    named this function by assigning it to a variable, so it is considered an anonymous
    function. Anonymous functions are useful as they mean that we don't need to preassign
    a function to a variable in order to make use of it; we can simply write our function
    into our code at the exact location of usage.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个函数表达式传递给`forEach`方法。我们没有通过将其分配给变量来命名此函数，因此它被视为匿名函数。匿名函数很有用，因为这意味着我们不需要预先将函数分配给变量以便使用它；我们可以简单地将我们的函数写入我们代码的确切位置。
- en: 'The function expression is most similar in its expressive manner to the arrow
    function.The key difference, as we will discover, is that the arrow function does
    not have access to its own bindings (for example, to `this` or `arguments`). A
    function expression, however, does have access to these values, and so in some
    contexts will be more useful to you. It''s very common to need a binding to `this`
    in order to operate successfully with the DOM API, for example, where many native
    DOM methods will invoke callbacks and event handlers with the relevant element
    as execution context. Additionally, you''ll want to use function expressions when
    defining methods on objects or prototypes that will need to access the current
    instance. As illustrated here, using an arrow function would not be appropriate:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式在表达方式上与箭头函数最相似。我们将发现，关键的区别在于箭头函数无法访问自己的绑定（例如`this`或`arguments`）。然而，函数表达式可以访问这些值，在某些情况下对你更有用。例如，通常需要绑定到`this`以便成功地与DOM
    API进行操作，例如，许多原生DOM方法将使用相关元素作为执行上下文调用回调和事件处理程序。此外，当定义对象或原型上需要访问当前实例的方法时，您将希望使用函数表达式。正如这里所示，使用箭头函数是不合适的：
- en: '[PRE106]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, using the arrow function syntax prevents us from accessing the
    instance via `this`, while the function expression syntax allows us to do this.
    Therefore, the function expression, although somewhat superseded by the more succinct
    arrow function, is still a very useful tool.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用箭头函数语法阻止我们通过`this`访问实例，而函数表达式语法允许我们这样做。因此，尽管箭头函数在某种程度上已被更简洁的箭头函数取代，但它仍然是一个非常有用的工具。
- en: Arrow functions
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头函数
- en: 'The arrow function is, in many ways, just a slightly more succinct version
    of the function expression, although it does have some practical differences.
    It comes in two flavors:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多方面，箭头函数只是函数表达式的略微更简洁的版本，尽管它确实有一些实际上的区别。它有两种风格：
- en: '[PRE107]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: As you can see, the *concise* variant includes an implicit return, while the
    *regular* variant, much like other function definition styles, requires you to
    define a regular function body delimited by curly braces in which you must explicitly
    return a value with a `return` statement.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，*简洁*变体包括一个隐式返回，而*常规*变体，就像其他函数定义样式一样，需要你定义一个由大括号限定的常规函数体，在其中你必须明确使用`return`语句返回一个值。
- en: 'Additionally, arrow functions allow you to avoid using parentheses when declaring
    a function with only one argument. In these cases, you can just place the identifier
    of the argument by itself prior to the arrow, like so:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，箭头函数允许您在声明只有一个参数的函数时避免使用括号。在这些情况下，您可以在箭头之前只放置参数的标识符，如下所示：
- en: '[PRE108]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The succinctness of the arrow function can be very useful in situations where
    you need to pass functions around quite a lot. This is common, for example, when
    operating on arrays via native methods such as `map`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数的简洁性在需要频繁传递函数的情况下非常有用。例如，在通过`map`等原生方法操作数组时很常见：
- en: '[PRE109]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Despite its superhero status as the succinct variant of otherwise verbose function
    definitions, the arrow function comes with its own challenges. The fact that the
    language must accommodate both *concise* and *regular* variants of syntax means
    that there is some ambiguity when attempting to return an object literal from
    the concise arrow function:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管箭头函数作为通常冗长的函数定义的简洁变体具有超级英雄的地位，但它也带来了自己的挑战。语言必须适应*简洁*和*常规*语法变体，这意味着在尝试从简洁的箭头函数中返回对象字面量时存在一些歧义：
- en: '[PRE110]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This syntax will confuse the JavaScript parser as the opening curly brace implies
    that a regular function body resides within. Due to this, the parser gives us
    an error about an unexpected token as it is not expecting the body of an object
    literal. If we want to return an object literal from the concise form of the arrow
    function, then we must awkwardly wrap it in parentheses to disambiguate the syntax:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法会让JavaScript解析器困惑，因为开放的大括号意味着一个常规函数体存在。因此，解析器会给出一个意外标记的错误，因为它不期望对象字面量的主体。如果我们想要从箭头函数的简洁形式返回一个对象字面量，那么我们必须笨拙地用括号将其包裹起来以消除歧义的语法：
- en: '[PRE111]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Functionally, the arrow function differs from the function expression in two
    ways:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上讲，箭头函数与函数表达式有两种不同之处：
- en: It does not provide access to bindings such as `this` or `arguments`
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它不提供访问诸如`this`或`arguments`之类的绑定。
- en: It does not have a `prototype` property, so it cannot be used as a constructor
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有`prototype`属性，因此不能用作构造函数
- en: 'These differences mean that, on the whole, arrow functions are typically unsuitable
    to use as methods or constructors. They are best used in contexts where you wish
    to pass a callback or handler to another function, and especially in cases where
    you wish to retain your `this` binding. For example, if we were to bind event
    handlers within the context of a `UIComponent` abstraction, we may wish to retain
    the `this` value in order to carry out certain instance-specific functionality:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异意味着，总的来说，箭头函数通常不适合用作方法或构造函数。它们最适合用于希望将回调或处理程序传递给另一个函数的上下文中，特别是在希望保留`this`绑定的情况下。例如，如果我们想要在`UIComponent`抽象的上下文中绑定事件处理程序，我们可能希望保留`this`值以执行某些特定于实例的功能：
- en: '[PRE112]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The arrow function feels most at home in scenarios like this. Its succinctness,
    however, means that there can be a risk of confusion when reading overly dense
    lines of code, such as the following:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数在这种情况下感觉最自然。然而，它的简洁性意味着在阅读过于密集的代码行时可能会产生混淆，比如下面的例子：
- en: '[PRE113]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'For this reason, it is best to employ the arrow function with the same consideration
    and practicality with which you would employ any other construct: ensure that
    you always put the usability and readability of your code first, above the very
    enticing niftiness of *cool* or succinct syntax.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最好以与使用任何其他构造相同的考虑和实用性来使用箭头函数：确保始终将代码的可用性和可读性放在首位，而不是非常诱人的*酷*或简洁语法的巧妙性。
- en: Immediately Invoked Function Expressions
  id: totrans-418
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即调用函数表达式
- en: Function expressions and arrow functions are the only function definition styles
    that are, technically, expressions. As we have seen, this quality makes them useful
    when we need to pass them as values to other functions without having to go through
    the process of assignment.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式和箭头函数是唯一的函数定义样式，从技术上讲，它们是表达式。正如我们所见，这种特性使它们在需要将它们作为值传递给其他函数时非常有用，而无需经历赋值的过程。
- en: 'As we mentioned previously, a function without an assignment, and thus without
    a reference to its value, is typically called an *anonymous function *and will
    look like this:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，没有赋值的函数，因此没有对其值的引用，通常被称为*匿名函数*，看起来像这样：
- en: '[PRE114]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The idea of an *anonymous function* is extended further by the concept of an
    **Immediately Invoked Function Expression** (**IIFE**). An IIFE is just a regular
    *anonymous function* that is invoked immediately, like so:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '*匿名函数*的概念通过**立即调用函数表达式**（**IIFE**）的概念进一步扩展。IIFE只是一个立即调用的常规*匿名函数*，如下所示：'
- en: '[PRE115]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note the invocation parentheses (that is, `...()`) after the closing curly brace.
    This will call the function and thus makes the preceding syntactic construct an
    IIEE.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在闭合大括号后的调用括号（也就是`...()`）。这将调用函数，因此使前面的语法结构成为IIEE。
- en: An IIFE is not a distinct concept within the language itself. It is just a useful
    term that the community has come up with to describe the common pattern of *immediately*
    invoking a function. It's a useful pattern because it allows us to create an ad
    hoc scope, meaning that any variables defined within it are constrained to that
    scope and will not leak outside, just as we'd expect from any function. This immediate
    scope is useful to quickly do self-contained work without affecting the parent
    scope.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE在语言本身并不是一个独特的概念。它只是社区提出的一个有用术语，用来描述*立即*调用函数的常见模式。这是一个有用的模式，因为它允许我们创建一个临时作用域，这意味着在其中定义的任何变量都受到该作用域的限制，不会泄漏到外部，就像我们从任何函数中期望的那样。这种立即作用域对于快速进行自包含工作而不影响父作用域非常有用。
- en: IIFEs were popularized in the browser era when it was preferable to avoid polluting
    the global namespace. Nowadays, with pre-compilation being so popular, the IIFE
    is less useful.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器时代，IIFE变得流行起来，因为最好避免污染全局命名空间。然而，如今，预编译如此流行，IIFE的用处就不那么大了。
- en: 'The exact syntax of an IIFE can vary. For example, if we use an arrow function,
    then the calling parenthesis must be placed after the wrapped function expression:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE的确切语法可能会有所不同。例如，如果我们使用箭头函数，那么调用括号必须放在包装的函数表达式之后：
- en: '[PRE116]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The mechanism remains essentially the same, regardless of whether we use a function
    expression or an arrow function.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 无论我们使用函数表达式还是箭头函数，机制本质上都是相同的。
- en: 'If the concept of an IIFE is confusing, it''s simpler to understand what''s
    going on if we replace the actual function with an identifier, `fn`, and imagine
    that we have previously assigned a function to this identifier. Here, we can call
    `fn` like so:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 如果IIFE的概念令人困惑，那么如果我们用标识符`fn`替换实际函数，并想象我们之前已经将一个函数分配给了这个标识符，那么理解正在发生的事情就更简单了。在这里，我们可以这样调用`fn`：
- en: '[PRE117]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Now, we could choose to wrap the `fn` reference in parentheses. This would
    make no difference to the invocation, although it may look bizarre:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择用括号包裹`fn`引用。这对调用没有任何影响，尽管看起来可能很奇怪：
- en: '[PRE118]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'It''s useful to remember that parentheses are just syntactic vessels that are
    sometimes needed to avoid syntactic ambiguity. So, all of these are technically
    equivalent:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 值得记住的是，括号只是有时需要的语法容器，以避免语法歧义。因此，所有这些从技术上讲都是等价的：
- en: '[PRE119]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If we replace the `fn` reference here with an inline anonymous function, nothing
    groundbreaking occurs. Instead of referencing an existing function, we are just
    expressing an inline function, on the spot, and then invoking it:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这里用内联匿名函数替换`fn`引用，就不会发生什么突破性的事情。我们只是在现场表达一个内联函数，然后调用它，而不是引用现有的函数：
- en: '[PRE120]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We call the pattern of an inline function expression an IIFE, but it really
    isn't anything special. Consider that the invocation parentheses, that is, `...()`,
    don't really care what they're attached to, as long as it's a function. The expression
    prior to the invocation could be literally *anything* as long as it evaluates
    to a function.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称内联函数表达式的模式为IIFE，但它实际上并不特别。考虑到调用括号，也就是`...()`，实际上并不在乎它们附加到什么上，只要它是一个函数。在调用之前的表达式可以是任何东西，只要它求值为一个函数。
- en: 'IIFEs are useful because they provide scope isolation without the burden of
    having to define a function with a name and then later reference and invoke it,
    as we''re doing here:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: IIFE很有用，因为它们提供了作用域隔离，而无需定义一个带有名称的函数，然后稍后引用和调用它，就像我们在这里做的一样：
- en: '[PRE121]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Within the browser, prior to complex builds involving compilation and bundling,
    IIFEs were useful because they provided scope isolation while not leaking any
    names into the global scope. Nowadays, however, the IIFE is rarely necessary.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，在涉及编译和捆绑的复杂构建之前，IIFE很有用，因为它们提供了作用域隔离，同时不会将任何名称泄漏到全局作用域。然而，如今，IIFE很少是必要的。
- en: Interestingly, the `initializeApp` function in the preceding code is, arguably,
    more readable and understandable with an explicit name. This is why, even if necessary,
    IIFEs are sometimes considered needlessly confusing and fancy. A named function
    usefully provides a clue as to its purpose and the intent of the author. Without
    a name, the reader of our code is left with the cognitive burden of having to
    read through the function itself to discover its broad purpose. For this reason,
    it is usually preferable to avoid IIFEs and similar anonymous constructs unless
    you have a very specific need.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，前面代码中的`initializeApp`函数，可以说，通过显式名称更易读和理解。这就是为什么，即使必要，IIFE有时被认为是不必要的混乱和花哨。有名字的函数有助于提供关于其目的和作者意图的线索。没有名称，我们的代码读者就必须承担阅读函数本身以发现其广泛目的的认知负担。因此，通常最好避免IIFE和类似的匿名结构，除非您有非常特定的需求。
- en: Method definitions
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法定义
- en: 'Method definitions were added to the language at the same time as class definitions
    to allow you to easily declare methods bound to a specific object. They are not
    limited to class definitions, though. You can use them freely in object literals
    as well:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 方法定义是在与类定义同时添加到语言中的，允许您轻松声明绑定到特定对象的方法。但它们不仅限于类定义。您也可以在对象文字中自由使用它们：
- en: '[PRE122]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In classes, you can also declare methods in this manner:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中，您也可以以这种方式声明方法：
- en: '[PRE123]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'You can also use traditional styles of function definition to declare your
    methods, such as a function expression assigned to an identifier:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用传统的函数定义样式来声明您的方法，比如将函数表达式分配给一个标识符：
- en: '[PRE124]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'There is, however, a crucial difference between method definitions and other
    styles of function definition. A method definition will always be bound to the
    object in which it was first defined. This is known internally as its `[[HomeObject]]`.
    This home object will determine what `super` binding is available to the method
    when it is called. Only method definitions are allowed to make reference to `super`,
    and the `super` they reference will always be the `[[Prototype]]` of their `[[HomeObject]]`.
    This means that if you try to *borrow* methods from other objects, you may be
    surprised to discover that `super` is not what you intended:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，方法定义和其他函数定义风格之间存在一个关键区别。方法定义将始终绑定到首次定义它的对象。这在内部被称为它的`[[HomeObject]]`。这个主对象将确定方法在被调用时可用的`super`绑定。只有方法定义允许引用`super`，它们引用的`super`将始终是它们的`[[HomeObject]]`的`[[Prototype]]`。这意味着，如果您尝试从其他对象*借用*方法，您可能会惊讶地发现`super`不是您想要的：
- en: '[PRE125]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Here, we can observe that both `JessieTheCat` and `JessieTheDog` have `greet`
    methods:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以观察到`JessieTheCat`和`JessieTheDog`都有`greet`方法：
- en: '[PRE126]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can also observe that their greet methods are implemented in identical ways.
    They both return the interpolated string ``${super.greet()} I am Jessie!``. Due
    to this, it might seem logical to be able to let `JessieTheCat` borrow the method
    from `JessieTheDog`. After all,  they''re exactly the same:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以观察到它们的greet方法以相同的方式实现。它们都返回插值字符串``${super.greet()} I am Jessie!``。因此，让`JessieTheCat`从`JessieTheDog`借用该方法似乎是合乎逻辑的。毕竟，它们完全相同：
- en: '[PRE127]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'We might intuitively expect `super` in the greet method to refer to the superclass
    of the current instance, which in the case of `JessieTheCat` will be `Cat`. But
    curiously, when we call this borrowed method, we experience something different:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能直觉地期望`greet`方法中的`super`指的是当前实例的超类，在`JessieTheCat`的情况下将是`Cat`。但奇怪的是，当我们调用这个借用的方法时，我们会经历一些不同的东西：
- en: '[PRE128]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: It barks! The borrowed method has annoyingly retained its binding to its original
    `[[HomeObject]]`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 它会叫！借用的方法令人讨厌地保留了它对原始`[[HomeObject]]`的绑定。
- en: In summary, method definitions are simpler and more succinct variants of their
    more verbose cousins, the function declaration and function expression. However,
    they come with an implicit mechanic that sets them apart and can create confusion.
    99% of the time, method definitions won't bite you; they'll behave as expected.
    The other 1% of the time, it's useful at the very least to know why your code
    is misbehaving so that you can explore other options. As always, knowledge about
    the idiosyncrasies of JavaScript can only help us in our pursuit of a cleaner
    and more reliable code base.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，方法定义是更简洁的变体，比起它们更冗长的表亲，函数声明和函数表达式。然而，它们具有一个将它们与众不同的隐式机制，可能会引起混淆。99%的时间，方法定义不会让你失望；它们会表现如预期。另外的1%的时间，至少知道为什么您的代码表现不佳是有用的，这样您就可以探索其他选项。就像往常一样，对JavaScript的特殊性的了解只能帮助我们追求更清洁和更可靠的代码库。
- en: Async functions
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数
- en: '**Asynchronous** (**async**) functions are specified with an `async` keyword
    preceding the function keyword. All function definition styles can be prefixed
    with it:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '**异步**（**async**）函数在函数关键字之前用`async`关键字指定。所有函数定义样式都可以以它为前缀：'
- en: '[PRE129]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'An async function allows you to easily conduct asynchronous operations by providing
    you with two key features:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 异步函数允许您通过提供两个关键功能轻松进行异步操作：
- en: You can use `await` within your async function to await the completion of Promises
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在异步函数中使用`await`来等待Promise的完成
- en: Your function will always return a Promise, which can, itself, be awaited
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的函数将始终返回一个Promise，它本身可以被等待
- en: The Promise is a natively supplied abstraction for dealing with asynchronous
    operations. It can seem complicated, but it's best to think of a Promise as an
    object that will either resolve or reject at a time later than *now *(that is,
    asynchronously).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: Promise是处理异步操作的本地提供的抽象。它可能看起来很复杂，但最好将Promise视为一个对象，它将在比*现在*更晚的时间解析或拒绝（即异步）。
- en: 'Traditionally, in JavaScript, we''d have to pass around callbacks to ensure
    that we''re able to respond to such asynchronous activity:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在JavaScript中，我们必须传递回调函数，以确保我们能够响应这种异步活动：
- en: '[PRE130]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'However, with an async function and `await`, we can achieve this more succinctly:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通过异步函数和`await`，我们可以更简洁地实现这一点：
- en: '[PRE131]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: The `await` clause here will halt current execution until `getUserDetails` completes
    and resolves to a value. Note that we can only use await within functions that
    are themselves async.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`await`子句将暂停当前执行，直到`getUserDetails`完成并解析为一个值。请注意，我们只能在自身是异步的函数中使用await。
- en: Asynchronous execution is a complex topic, so there is a whole chapter dedicated
    to it, that is, [Chapter 10](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml), *Control
    Flow*. For now, it's useful to know that async functions are a distinct type of
    a function that will always return a Promise.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 异步执行是一个复杂的话题，因此有一个专门的章节，即[第10章](b41df1c6-fc76-4d51-b95c-ae39ab040ab1.xhtml)，*控制流*。现在，有必要知道异步函数是一种特殊类型的函数，它将始终返回一个Promise。
- en: Other than allowing `await` clauses and returning Promises, async functions
    carry the same features and characteristics as the respective function definition
    style that's used. An async arrow function, just like a regular arrow function,
    does not have its own bindings to this or arguments. An async function declaration
    is hoisted just like its non-async cousin. Essentially, async should be thought
    of as a layer atop all of the learnings you've already picked up concerning the
    different function definition styles.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 除了允许`await`子句和返回Promise之外，异步函数具有与所使用的相应函数定义样式相同的特性和特征。异步箭头函数，就像常规箭头函数一样，没有自己的this或arguments绑定。异步函数声明像它的非异步表亲一样被提升。基本上，异步应该被视为覆盖您已经掌握的关于不同函数定义样式的所有知识的一层。
- en: Generator functions
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器函数
- en: The very last type of function definition style we will cover is the very powerful
    *generator function.* Broadly, generators are used to supply and control the iteration
    behavior for a sequence of one or more, or even infinite, items.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的最后一种函数定义样式是非常强大的*生成器函数*。广义上，生成器用于提供和控制一个或多个，甚至无限个项目的迭代行为。
- en: '*Generator functions* in JavaScript are specified with an asterisk following
    the function keyword:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，*生成器函数*是在函数关键字后面加上一个星号来指定的：
- en: '[PRE132]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: When called, they will return a generator object, which uniquely conforms to
    both the iterable protocol and the iterator protocol*,* meaning that they can
    be iterated over themselves or can serve as an object's iteration logic.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用时，它们将返回一个生成器对象，该对象唯一地符合可迭代协议和迭代器协议，这意味着它们可以被自身迭代，或者可以作为对象的迭代逻辑。
- en: Feel free to skip ahead to the section on the iterable protocol*. *The generator
    function makes far more sense when you think of it as a convenient way to create
    an iterator or iterable.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 可以直接跳到关于可迭代协议的部分。*当您将生成器函数视为创建迭代器或可迭代对象的便捷方式时，它会更加有意义。
- en: 'A generator function will halt and return a value at the point of a `yield`
    statement, and this can occur multiple times. After a `yield`, the function is
    effectively stalled while it waits for a consumer to need its next value. This
    is best illustrated with an example:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数将在`yield`语句的位置暂停并返回一个值，这可以发生多次。在`yield`之后，函数在等待消费者需要其下一个值时实际上被暂停了。这最好通过一个例子来说明：
- en: '[PRE133]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: As you can see, the generator object that's returned from the function has a
    `next` method, which, when called, will return an object with a `value` (indicating
    the current value of the iteration) and a `done` property (indicating whether
    the iteration/generation is complete). This is the *iterator protocol* and is
    the contract you can expect all generators to fulfill.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，从函数返回的生成器对象具有`next`方法，当调用时，将返回一个带有`value`（指示迭代的当前值）和`done`属性（指示迭代/生成是否完成）的对象。这是*迭代器协议*，也是您可以期望所有生成器满足的约定。
- en: 'A generator fulfills not only the iterator protocol but also the iterable protocol,
    which means it can be iterated over by language constructs that accept iterables
    (such as `for...of` or the `...spread` operator):'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器不仅满足迭代器协议，还满足可迭代协议，这意味着它们可以被语言结构迭代（例如`for...of`或`...spread`运算符）接受：
- en: '[PRE134]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '*Async generator functions* can also be specified. They usefully combine the
    async and generator formats into a hybrid that allows for custom asynchronous
    generation logic, like so:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步生成器函数*也可以被指定。它们有用地将异步和生成器格式结合成一种混合形式，允许自定义异步生成逻辑，就像这样：'
- en: '[PRE135]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: You'll notice how we're using the `for await` iteration construct to iterate
    through our asynchronous generator. This will ensure that each iteration will
    await its result before continuing.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到我们正在使用`for await`迭代结构来迭代我们的异步生成器。这将确保每次迭代都会在继续之前等待其结果。
- en: 'Generator functions are very powerful, but it''s important to be aware of the
    underlying mechanics at play. They are not regular functions and are not guaranteed
    to run to completion. Their implementation should take into account the context
    in which they will be run. If your generator is intended to be used as an iterator,
    then it should respect the implied expectations of iteration: that it is a read-only
    operation of an underlying piece of data or generation logic. While it is possible
    to mutate underlying data within a generator, this should be avoided.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器函数非常强大，但重要的是要了解其中的基本机制。它们不是常规函数，也不能保证完全运行。它们的实现应该考虑它们将被运行的上下文。如果您的生成器旨在用作迭代器，则它应该尊重迭代的暗示期望：它是对底层数据或生成逻辑的只读操作。虽然可能在生成器内部改变底层数据，但应该避免这样做。
- en: Arrays and iterables
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和可迭代对象
- en: An array in JavaScript is a type of object that is specialized in that it contains
    a set of ordered elements.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组是一种特殊的对象类型，它包含一组有序的元素。
- en: 'You can express an array using its literal syntax, which is a comma-separated
    list of expressions delimited by square brackets:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用数组的文字语法来表示一个数组，这是一个由方括号分隔的表达式的逗号分隔列表：
- en: '[PRE136]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'These comma-separated expressions can be as complex or simple as we desire:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这些逗号分隔的表达式可以是复杂或简单的，取决于我们的需要。
- en: '[PRE137]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: An array is capable of containing all manner of values. There are very few constraints
    on how we can use arrays. Technically, an array's limited to a `length` of around
    4 billion, due to its `length` being stored as a 32-bit integer. For most purposes,
    of course, this should be absolutely fine.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 数组能够包含各种值。我们对如何使用数组几乎没有什么限制。从技术上讲，数组的`length`由于存储为32位整数，因此受到约40亿的限制。当然，对于大多数目的来说，这应该完全没问题。
- en: 'Arrays have a numeric property for every indexed element within them and a
    `length` property to describe how many elements there are. They also have a set
    of useful methods for reading from and operating on the data within them:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 数组具有用于描述其中每个索引元素的数值属性和一个`length`属性来描述其中有多少元素。它们还有一组有用的方法来读取和操作其中的数据：
- en: '[PRE138]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Historically, arrays were iterated over using conventional `for(...)` and `while(...)`
    loops that increment a counter toward the `length` so that, upon each iteration,
    the current element could be accessed via `array[counter]`, like so:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在历史上，数组是通过传统的`for(...)`和`while(...)`循环进行迭代的，这些循环会向`length`递增一个计数器，以便在每次迭代时可以通过`array[counter]`访问当前元素，如下所示：
- en: '[PRE139]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Nowadays, however, it''s preferable to use other methods of iteration, such
    as `forEach` or `for...of`:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如今更倾向于使用其他迭代方法，比如`forEach`或`for...of`：
- en: '[PRE140]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '`for...of` has the benefit of being breakable, meaning you can use `break`
    and `continue` statements within them and easily escape from the iteration.  It
    will also work on any object that is iterable, whereas `forEach` is only an `Array`
    method. The `forEach` style, however, is useful in that it provides you with the
    current index of the iteration via the second argument to your callback.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '`for...of`的好处是可以中断，这意味着你可以在其中使用`break`和`continue`语句，并轻松地跳出迭代。它还可以用于任何可迭代的对象，而`forEach`只是一个`Array`方法。然而，`forEach`风格的迭代对于通过回调的第二个参数提供当前迭代的索引是有用的。'
- en: Which style of iteration you use should be determined by the value you are iterating
    over and what you wish to do on each iteration. Nowadays, it is quite rare to
    need to use traditional styles of array iteration such as `for(...)` and `while(...)`.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用哪种迭代方式应该由你要迭代的值和你希望在每次迭代中执行的操作决定。如今，几乎不需要使用传统的数组迭代方式，比如`for(...)`和`while(...)`。
- en: Array-like objects
  id: totrans-504
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类似数组的对象
- en: 'Most native Array methods are generic, meaning that they can be used on any
    object that *looks like* an array. All we need to achieve  the appearance of an
    array is use a `length` property and individual properties for each index (indexed
    from zero):'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数原生数组方法都是通用的，这意味着它们可以用于任何*看起来像*数组的对象。我们只需要实现一个`length`属性和每个索引的单独属性（从零开始索引）来实现数组的外观：
- en: '[PRE141]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, we've constructed an array-like object and then provided it with a `join`
    method of its own by borrowing the `join` method of an array (that is, from `Array.prototype`).
    The native array `join` method is so generically implemented that it doesn't mind
    operating on an object as long as that object fulfills the contract of an array
    by providing a `length` property and corresponding indexes (`0`, `1`, `2`, and
    so on). Most native array methods are similarly generic.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建了一个类似数组的对象，然后通过借用数组的`join`方法（即从`Array.prototype`中）为其提供了自己的`join`方法。原生数组的`join`方法实现得非常通用，它不介意在对象上操作，只要该对象满足数组的约定，即提供一个`length`属性和相应的索引（`0`，`1`，`2`等）。大多数原生数组方法都是通用的。
- en: 'One example of an array-like object within the language itself is the `arguments`
    binding that we explored earlier in this chapter. Another example is `NodeList`,
    which is a type of object that is returned from various DOM selection methods.
    If necessary, we can derive proper arrays from these objects by borrowing and
    calling the array `slice` method, like so:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 语言本身中类似数组的对象的一个例子是我们在本章前面探讨过的`arguments`绑定。另一个例子是`NodeList`，它是从各种DOM选择方法返回的对象类型。如果需要，我们可以通过借用和调用数组的`slice`方法从这些对象中派生出真正的数组，如下所示：
- en: '[PRE142]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'However, in the case of `arguments` or the `NodeList` object, we can also rely
    on them being iterable, meaning that we can use the spread syntax to derive a
    true array:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`arguments`或`NodeList`对象的情况下，我们也可以依赖它们是可迭代的，这意味着我们可以使用扩展语法来派生出一个真正的数组：
- en: '[PRE143]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: If you find yourself needing to create an array-like object, consider having
    it implement the iterable protocol (which we're about to explore) so that the
    spread syntax can be used in this way.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要创建一个类似数组的对象，考虑让它实现可迭代协议（我们即将探讨），以便以这种方式使用扩展语法。
- en: Set and WeakSet
  id: totrans-513
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Set和WeakSet
- en: '`Set` and `WeakSet` are native abstractions that allow us to store sequences
    of unique objects. This is in contrast to arrays, which give you no assurances
    as to the uniqueness of your values. Here''s an illustration:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`Set`和`WeakSet`是允许我们存储唯一对象序列的原生抽象。这与数组形成对比，数组无法保证值的唯一性。下面是一个例子：'
- en: '[PRE144]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: As you can see, values given to a `Set` will always be ignored if they already
    exist in the `Set`.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，给定给`Set`的值如果已经存在于`Set`中，将始终被忽略。
- en: 'Sets can be initialized by passing an iterable value to the constructor; for
    example, a string:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将可迭代的值传递给构造函数，可以初始化集合；例如，一个字符串：
- en: '[PRE145]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'If you need to convert a `Set` into an array, you can most simply do this with
    the spread syntax (as sets are, themselves, iterable):'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将`Set`转换为数组，你可以使用扩展语法最简单地实现这一点（因为集合本身是可迭代的）：
- en: '[PRE146]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: WeakSets are similar to the previously covered WeakMaps. They are for *weakly* holding
    values in a way that allows that value to be garbage-collected in another part
    of the program. The semantics and best practices around using sets are similar
    to those concerning arrays. It's advisable to only use sets if you need to store
    unique sequences of values; otherwise, just use a simple array.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: WeakSet与之前介绍的WeakMap类似。它们用于以一种允许值在程序的其他部分被垃圾回收的方式*弱引用*值。使用集合的语义和最佳实践与使用数组的类似。建议只在需要存储唯一值序列时使用集合；否则，只需使用简单的数组。
- en: Iterable protocol
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可迭代协议
- en: The iterable protocol allows values containing sequences to share a common set
    of characteristics, allowing them to all be iterated over or treated in a similar
    way.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代协议允许包含序列的值共享一组共同的特征，使它们可以被迭代或以类似的方式处理。
- en: We can say that an object that implements the iterable protocol is iterable.
    Iterable objects within JavaScript include `Array`, `Map`, `Set`, and `String`.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以说，实现可迭代协议的对象是可迭代的。JavaScript中的可迭代对象包括`Array`、`Map`、`Set`和`String`。
- en: Any object can define its own iterable protocol by simply supplying an iterator
    function under the property name's `Symbol.iterator` (which maps to the internal
    `@@iterator` property).
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 任何对象都可以通过简单地在属性名`Symbol.iterator`下提供迭代器函数来定义自己的可迭代协议（它映射到内部的`@@iterator`属性）。
- en: 'This iterator function must fulfill the iterator protocol by returning an object
    with a `next` function. This `next` function, when called, must return an object
    with `done` and `value` keys indicating what the current value of the iteration
    is and whether the iteration is completed:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迭代器函数必须通过返回一个带有`next`函数的对象来满足迭代器协议。当调用这个`next`函数时，它必须返回一个带有`done`和`value`键的对象，指示迭代的当前值和迭代是否完成：
- en: '[PRE147]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'So, to be utterly clear about this, there are two distinct protocols:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了对此有绝对的清晰认识，有两个不同的协议：
- en: '**The iterable protocol**: Any object that implements an `@@iterator` via `[Symbol.iterator]`
    fulfills this protocol. Native examples include `Array`, `String`, `Set`, and
    `Map`.'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可迭代协议**：通过`[Symbol.iterator]`实现`@@iterator`的任何对象都满足这个协议。原生示例包括`Array`、`String`、`Set`和`Map`。'
- en: '**The iterator protocol**: Any function that returns an object of the form
    `{... next: Function}` and whose `next` method, when called, returns an object
    in the following form: `{value: Boolean, done: ...}`.'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器协议**：任何返回形式为`{... next: Function}`的对象的函数，其`next`方法在调用时返回以下形式的对象：`{value:
    Boolean, done: ...}`。'
- en: 'For an object to fulfill the iterable protocol, it must implement `[Symbol.iterator]`,
    like so:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了满足可迭代协议，对象必须实现`[Symbol.iterator]`，如下所示：
- en: '[PRE148]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Providing custom methods of iteration via the iterable protocol can be useful
    when you want to control the order of iteration or if you want to somehow process,
    filter, or generate values during iteration. Here, for example, we are specifying
    an iterator function as a generator function, which, as you may recall, returns
    a generator that fulfills both the *iterator* and iterable protocols. This generator
    function will yield two variants for every word stored – one uppercase and one
    lowercase:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可迭代协议提供自定义迭代方法在您想要控制迭代顺序或在迭代过程中进行某种处理、过滤或生成值时非常有用。例如，在这里，我们将迭代器函数指定为生成器函数，正如您可能记得的那样，它返回一个满足*迭代器*和可迭代协议的生成器。这个生成器函数将为每个存储的单词产生两个变体，一个大写和一个小写：
- en: '[PRE149]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Specifying iterator functions as generator functions like this is far simpler
    than having to manually implement the iterator protocol. Generators naturally
    fulfill this contract, so they can be used far more seamlessly. Generators also
    tend to be more readable and succinct and have the dual benefit of implementing
    both the iterator and iterable protocols, meaning that they can be used to decorate
    an object with iteration capabilities:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器函数指定为生成器函数比手动实现迭代器协议要简单得多。生成器自然地满足这一约定，因此它们可以更加无缝地使用。生成器通常也更易读和简洁，并且具有实现迭代器和可迭代协议的双重好处，这意味着它们可以用于为对象添加迭代功能：
- en: '[PRE150]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'They can, themselves, also provide that iteration capability:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 它们本身也可以提供迭代功能：
- en: '[PRE151]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: It's important to keep in mind that any work that's done within a custom iterable
    should be in line with the expectations of consumers. Iteration is usually considered
    a read-only operation, so you should steer clear of mutations of the underlying
    value-set during iteration. Implementing your own iterables can be incredibly
    powerful, but can also lead to unexpected behavior by the consumers of your code
    who aren't aware of your custom iteration logic.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在自定义可迭代中进行的任何工作都应符合消费者的期望。迭代通常被认为是只读操作，因此在迭代过程中应避免对基础值集的突变。实现自己的可迭代可以非常强大，但也可能导致消费者对您的自定义迭代逻辑不熟悉的意外行为。
- en: It's vital to balance the convenience of custom iteration for those people who
    are *in the know* with those people who might only be experiencing your interface
    or abstraction for the first time.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些了解情况的人和那些可能是第一次体验您的接口或抽象的人来说，平衡自定义迭代的便利性是非常重要的。
- en: RegExp
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RegExp
- en: JavaScript natively supports regular expressions via the object type `RegExp`,
    allowing them to be expressed via the literal syntax `/foo/` or directly via the
    constructor (`RegExp('foo')`).  Regular expressions are used to define patterns
    of characters that can be matched or executed against strings.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript通过对象类型`RegExp`原生支持正则表达式，允许通过文字语法`/foo/`或直接通过构造函数(`RegExp('foo')`)来表达。正则表达式用于定义可以与字符串匹配或执行的字符模式。
- en: 'Here is an example in which we extract only the long words (`>=10` characters)
    from a corpus of text:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，我们从文本语料库中提取只有长单词（`>=10`个字符）的单词：
- en: '[PRE152]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: The grammar and syntax of regular expressions can be complex. It is technically
    an entire language unto itself, requiring many days of study. We won't be able
    to explore all of its complexity here. We will, however,  be covering the ways
    in which we typically operate on regular expressions within JavaScript and explore
    some of the challenges in doing so. It is suggested that you conduct further study
    into regular expressions yourself.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的语法和语法可能很复杂。从技术上讲，它本质上是一种完整的语言，需要多天的学习。我们无法在这里探索它的所有复杂性。然而，我们将涵盖我们通常在JavaScript中操作正则表达式的方式，并探讨其中的一些挑战。建议您自行进一步研究正则表达式。
- en: Regular expression 101
  id: totrans-546
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式101
- en: 'Regular expressions allow us to describe a pattern of characters. They are
    used for matching and extracting values from strings. For example, if we had a
    string that contained digits `(1,2,3)` at various positions, a regular expression
    would allow us to easily retrieve them:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式允许我们描述字符的模式。它们用于匹配和提取字符串中的值。例如，如果我们有一个包含数字`(1,2,3)`的字符串，正则表达式将允许我们轻松地检索它们：
- en: '[PRE153]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'A regular expression is written as a pattern delimited by forward slashes,
    with optional flags following the final forward slash:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是以斜杠分隔的模式编写的，最终斜杠后面可以跟随可选标志：
- en: '[PRE154]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The pattern you write can contain both literal and special characters that
    together inform the regular expression engine of what to look for. The regular
    expression we''re using in our example contains literal characters (that is, `1`,
    `2`, `3`) and the pipe (that is, `|`) special character:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 您编写的模式可以包含文字和特殊字符，这些字符共同告诉正则表达式引擎要查找什么。我们在示例中使用的正则表达式包含文字字符（即`1`、`2`、`3`）和管道（即`|`）特殊字符：
- en: '[PRE155]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The pipe special character tells the regular expression engine that the characters
    on the left or the right of the pipe may match. The `g`, following the final forward
    slash, is a *global* flag that directs the engine to search globally within the
    string and not to give up after the first match is found. For us, this means that
    our regular expression will match either `"1"`, `"2"`, or `"3"`, wherever they
    appear within a subject string.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 管道特殊字符告诉正则表达式引擎，管道左侧或右侧的字符可能匹配。在最终斜杠后面的`g`是一个*全局*标志，指示引擎在字符串中全局搜索，并在找到第一个匹配项后不放弃。对我们来说，这意味着我们的正则表达式将匹配主题字符串中出现的`"1"`、`"2"`或`"3"`。
- en: 'There are specific special characters we can use within regular expressions
    that act as shortcuts. The notation `[0-9]` is an example of this. It is a* character
    class* that will match all the digits from `0` to `9` so that we don''t have to
    list all of these digits individually. There is also a *shorthand character class*,
    `\d`, that allows us to express this even more succinctly. Thus, we can shorten
    our regular expression to the following:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，我们可以使用特定的特殊字符作为快捷方式。`[0-9]`的表示法就是一个例子。它是一个*字符类*，将匹配从`0`到`9`的所有数字，这样我们就不必逐个列出所有这些数字。还有一个*简写字符类*`\d`，可以更简洁地表示这一点。因此，我们可以将我们的正则表达式缩短为以下形式：
- en: '[PRE156]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'For a more realistic application, we may imagine a scenario in which we wish
    to match sequences of digits, such as phone numbers. Perhaps we wish to match
    only those phone numbers beginning with `0800` and containing a further `4` to
    `6` digits. We could do this with the following regular expression:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更现实的应用，我们可以想象一种情况，我们希望匹配数字序列，比如电话号码。也许我们只希望匹配以`0800`开头并包含进一步`4`到`6`位数字的电话号码。我们可以使用以下正则表达式来实现：
- en: '[PRE157]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Here, we are using the `{n, n}` syntax, which allows us to express a quantity
    for the preceding special character, `\d`. We can confirm that our pattern works 
    by passing it to a test string''s `match` method:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`{n, n}`语法，允许我们为前面的特殊字符`\d`表示数量。我们可以通过将其传递给测试字符串的`match`方法来确认我们的模式是否有效：
- en: '[PRE158]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: This brief introduction only touches on the very surface of what regular expressions
    can do. The syntax of regular expressions allows us to express significant complexity,
    allowing us to validate that specific text exists within a string or to extract
    specific text for use within our programs.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的介绍只是触及了正则表达式的表面。正则表达式的语法允许我们表达重要的复杂性，使我们能够验证字符串中是否存在特定文本，或者提取特定文本以在我们的程序中使用。
- en: RegExp flags
  id: totrans-561
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RegExp标志
- en: 'The literal syntax of regular expressions allows for specific *flags*, such
    as `i` (*ignore-case*), to be specified after the final delimiting forward slash.
    These flags will affect the way the regular expression is executed:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式的文字语法允许在最终的斜杠之后指定特定的*标志*，例如`i`（*忽略大小写*）。这些标志将影响正则表达式的执行方式：
- en: '[PRE159]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'When using the `RegExp` constructor, you can pass your flags as the second
    argument:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`RegExp`构造函数时，可以将标志作为第二个参数传递：
- en: '[PRE160]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'There are six available flags in JavaScript''s flavor of regular expression:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的正则表达式有六个可用的标志：
- en: '`i`: The *ignore-case* flag will ignore the case of the string when matching
    letters (that is, `/a/i` would match both `''a''` andor `''A''` in a string).'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`i`：*忽略大小写*标志将在匹配字母时忽略字符串的大小写（即`/a/i`将匹配字符串中的`''a''`和`''A''`）。'
- en: '`g`: The *global-match* flag will make the regular expression find *all* matches
    instead of stopping after the first match.'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`g`：*全局匹配*标志将使正则表达式找到*所有*匹配项，而不是在找到第一个匹配项后停止。'
- en: '`m`: The *multiline* flag will make beginning and end anchors (that is, `^`
    and `$`) mark the beginnings and ends of individual lines instead of entire strings.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`：*多行*标志将使开始和结束锚点（即`^`和`$`）标记单独行的开头和结尾，而不是整个字符串的开头和结尾。'
- en: '`s`: The *dotAll* flag will cause the dot character in your regular expression
    (which usually only matches non-newline characters) to match newline characters.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`：*dotAll*标志将使正则表达式中的点字符（通常仅匹配非换行符字符）匹配换行符字符。'
- en: '`u`: The *Unicode* flag will treat the sequence of characters in your regular
    expression as individual Unicode code points instead of code units. This broadly
    means you can painlessly match and test for rare or exotic symbols such as emojis
    (see the section within this chapter on the `String` type to get a more thorough
    understanding of Unicode).'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`u`：*Unicode*标志将把正则表达式中的字符序列视为单独的Unicode代码点，而不是代码单元。这基本上意味着您可以轻松地匹配和测试罕见或特殊符号，例如表情符号（请参阅本章中关于`String`类型的部分，以更全面地了解Unicode）。'
- en: '`y`: The *sticky* flag will cause all `RegExp` operations to attempt a match
    at the exact index detailed by the `lastIndex` property and then mutate `lastIndex`
    upon matches.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`y`：*粘性*标志将导致所有`RegExp`操作尝试在`lastIndex`属性指定的确切索引处进行匹配，然后在匹配时改变`lastIndex`。'
- en: 'As we''ve seen, regular expressions can also be constructed via the `RegExp`
    constructor. This can usefully be invoked as both a constructor or a regular function:
    either way, you''ll receive a `RegExp` object equivalent to what was derived from
    the literal syntax:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，正则表达式也可以通过`RegExp`构造函数构造。这可以有用地作为构造函数或常规函数调用：无论哪种方式，你都会收到一个等同于从文字语法中派生的`RegExp`对象：
- en: '[PRE161]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: This is quite a unique behavior. In fact, the `RegExp` constructor is the only
    natively provided constructor that can be invoked as both a constructor and a
    regular function and, in both cases, returns a new instance. You'll recall that
    the primitive constructors (such as `String` and `Number`) can be invoked as regular
    functions but will behave differently when invoked as constructors.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常独特的行为。事实上，`RegExp`构造函数是唯一可以作为构造函数和常规函数调用的本地提供的构造函数，在这两种情况下都返回一个新实例。你会记得，原始构造函数（如`String`和`Number`）可以作为常规函数调用，但在作为构造函数调用时会有不同的行为。
- en: Methods accepting RegExp
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接受RegExp的方法
- en: 'There are seven methods provided by JavaScript that are capable of utilizing
    regular expressions:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript提供了七种方法，可以利用正则表达式：
- en: '`RegExp.prototype.test(String)`: Runs the regular expression against the passed
    string and return true if it finds at least one match. It will return false if
    no matches are found.'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.prototype.test(String)`: 对传递的字符串运行正则表达式，如果找到至少一个匹配，则返回true。如果没有找到匹配，则返回false。'
- en: '`RegExp.prototype.exec(String)`: If the regular expression has a global (`g`),
    flag then `exec()` will return the next match from the current `lastIndex` (and
    will update the regular expression''s `lastIndex` after doing so); otherwise,
    it will return the first match of the regular expression (similar to `String.prototype.match`).'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegExp.prototype.exec(String)`: 如果正则表达式有全局（`g`）标志，那么`exec()`将从当前`lastIndex`返回下一个匹配（并在这样做后更新正则表达式的`lastIndex`）；否则，它将返回正则表达式的第一个匹配（类似于`String.prototype.match`）。'
- en: '`String.prototype.match(RegExp)`: This `String` method will return a match
    (or if the global flag is set, all matches) of the passed regular expression made
    against the string.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.match(RegExp)`: 这个`String`方法将返回针对字符串进行的匹配（或者如果设置了全局标志，则返回所有匹配）。'
- en: '`String.prototype.replace(RegExp, Function)`: This `String` method will execute
    the passed function on every single match and will, for each match, replace the
    matched text with whatever the function returns.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.replace(RegExp, Function)`: 这个`String`方法将在每次匹配上执行传递的函数，并且对于每次匹配，用函数返回的内容替换匹配的文本。'
- en: '`String.prototype.matchAll(RegExp)`: This `String` method will return an iterator
    of all results and their individual groups. This is useful when you have a global
    regular expression with individual matching groups.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.matchAll(RegExp)`: 这个`String`方法将返回所有结果及其各自的组的迭代器。当你有一个具有各自匹配组的全局正则表达式时，这是很有用的。'
- en: '`String.prototype.search(RegExp)`: This `String` method will return the index
    of the first match or -1 if there are no matches found.'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.search(RegExp)`: 这个`String`方法将返回第一个匹配的索引，如果没有找到匹配，则返回-1。'
- en: '`String.prototype.split(RegExp)`: This `String` method will return an array
    containing parts of the string split by the provided separator (which can be a
    regular expression).'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String.prototype.split(RegExp)`: 这个`String`方法将返回一个包含由提供的分隔符（可以是正则表达式）分割的字符串部分的数组。'
- en: There are many methods to choose from, but for most situations, you'll likely
    find that the `RegExp` method, `test()`, and the String methods, `match()` and
    `replace()`, are the most useful.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可供选择，但在大多数情况下，你可能会发现`RegExp`方法`test()`和`String`方法`match()`和`replace()`最有用。
- en: 'Here''s a rundown of some examples of these methods. This should give you an
    idea of the situations in which each method may be used:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些这些方法的示例。这应该让你了解每种方法可能使用的情况：
- en: '[PRE162]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Most of these methods, as you can see, behave intuitively. However, there is
    some complexity surrounding *stickiness* and the `lastIndex` property, which we
    will now go over.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，大多数这些方法的行为都很直观。然而，围绕*粘性*和`lastIndex`属性存在一些复杂性，我们现在将对此进行讨论。
- en: RegExp methods and lastIndex
  id: totrans-589
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RegExp方法和lastIndex
- en: By default, if your `RegExp` is global (that is, uses the `g` flag), the `RegExp`
    methods (that is, `test()` and `exec()`) will mutate the `lastIndex` property
    of the `RegExp` object upon each execution. These methods will attempt to match
    the subject string from the index specified by the current `lastIndex` property,
    which is 0 by default, and will then update the `lastIndex` upon every subsequent
    call.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果你的`RegExp`是全局的（即使用了`g`标志），`RegExp`方法（即`test()`和`exec()`）将在每次执行时改变`RegExp`对象的`lastIndex`属性。这些方法将尝试从当前`lastIndex`属性指定的索引匹配主题字符串，该属性默认为0，然后在每次后续调用时更新`lastIndex`。
- en: 'This can lead to unexpected behavior if you expect `exec()` or `test()` to
    always return the same result for a given global regular expression and string:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你期望`exec()`或`test()`对于给定的全局正则表达式和字符串始终返回相同的结果，这可能会导致意外行为：
- en: '[PRE163]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'It will also lead to confusion if you attempt to execute a global regular expression
    on more than one string without resetting the `lastIndex` yourself:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在多个字符串上执行全局正则表达式而不自己重置`lastIndex`，这也会导致混乱：
- en: '[PRE164]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: As you can see, following the match with the `"monkeys"` substring, the `lastIndex`
    is updated to the next index (`7`),  which means, when executed on a different
    string, the regular expression will continue where it left off and attempt to
    match everything beyond that index, which in the case of the second string, `"birds
    flying"`, is the substring `"lying"`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在匹配了`"monkeys"`子字符串之后，`lastIndex`被更新为下一个索引（`7`），这意味着，在不同的字符串上执行时，正则表达式将继续之前的位置，并尝试匹配该索引之后的所有内容，在第二个字符串`"birds
    flying"`的情况下，是子字符串`"lying"`。
- en: 'As a rule, to avoid these confusions, it''s important to always have ownership
    over your regular expressions. Don''t accept regular expressions from elsewhere
    in a program if you''re using `RegExp` methods. Also, don''t attempt to use `exec()` or
    `test()` on different strings without resetting the `lastIndex` before each execution:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，为了避免这些混淆，始终拥有对正则表达式的所有权是非常重要的。如果你在程序中使用`RegExp`方法，不要接受来自其他地方的正则表达式。此外，在每次执行之前不要尝试在不同的字符串上使用`exec()`或`test()`而不重置`lastIndex`：
- en: '[PRE165]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, you can see that, if we don't reset the `lastIndex`, our regular expression
    fails to match on subsequent strings that are passed to the `exec()` method. If,
    however, we reset the `lastIndex` prior to each subsequent `exec()` call, we'll
    observe a match.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到，如果我们不重置`lastIndex`，我们的正则表达式在传递给`exec()`方法的后续字符串上无法匹配。然而，如果我们在每次后续的`exec()`调用之前重置`lastIndex`，我们将观察到匹配。
- en: Stickiness
  id: totrans-599
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粘性
- en: 'Stickiness means that a regular expression will try to match at the exact `lastIndex` and
    that, if a match is not available at that exact index, it will fail (that is,
    return `null` or `false`, depending on the method used). The sticky flag (`y`)
    will force `RegExp` to read and mutate `lastIndex` with each match. Traditionally
    sticky methods such as `exec()` and `test()`, as we mentioned previously, will
    always do this, but the `y` flag will *force* stickiness even when using non-sticky
    methods, such as `match()`:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 粘性意味着正则表达式将尝试在确切的`lastIndex`处进行匹配，如果在该确切索引处找不到匹配，它将失败（即根据使用的方法返回`null`或`false`）。粘性标志（`y`）将强制`RegExp`在每次匹配时读取和改变`lastIndex`。传统的粘性方法，如`exec()`和`test()`，如我们之前提到的，将始终这样做，但`y`标志将*强制*粘性，即使在使用非粘性方法时，如`match()`：
- en: '[PRE166]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Stickiness can be useful if you're looking for a match at a specific index in
    a string or series of strings. However, its behavior can be unexpected if you're
    not in full control of `lastIndex`.  As we mentioned previously, a good general
    rule is to always have ownership over your own `RegExp` objects so that any mutations
    to `lastIndex` are only made by your code.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找字符串或一系列字符串中特定索引处的匹配，粘性可能是有用的。然而，如果你无法完全控制`lastIndex`，它的行为可能会出乎意料。正如我们之前提到的，一个很好的一般规则是始终拥有对自己的`RegExp`对象的所有权，以便对`lastIndex`的任何变化只能由你的代码进行。
- en: Summary
  id: totrans-603
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have begun to delve into JavaScript by looking at the built-in
    types that the language provides. The point of our exploration has been to look
    at these language constructs through the lens of clean code. By doing so, we've
    highlighted the importance of caution when dealing with some of the more obscure
    areas of the language. We've discovered many of the nasty edge cases and challenges
    involved in using JavaScript types, such as the lack of precision in the floating-point
    `Number` type and the complexity of Unicode in the `String` type. Exploring these
    more difficult parts of the language allows us not only to avoid specific traps
    but instills a fluency within us that will hugely boost our ability to wield JavaScript
    in the service of clean code.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经开始通过查看语言提供的内置类型来深入研究JavaScript。我们探索的重点是通过清晰的代码视角来看待这些语言构造。通过这样做，我们强调了在处理语言的一些更晦涩的领域时要小心的重要性。我们发现了许多涉及使用JavaScript类型的恶劣边缘情况和挑战，比如浮点`Number`类型的精度不足以及`String`类型中Unicode的复杂性。探索语言中这些更困难的部分不仅可以避免特定的陷阱，而且可以在我们内心培养一种流利，这将极大地提高我们运用JavaScript服务于清晰代码的能力。
- en: In the next chapter, we will continue to enhance this fluency. We will learn
    more about JavaScript's type system and begin to operate on and manipulate these
    types to suit our needs.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续增强这种流畅性。我们将更多地了解JavaScript的类型系统，并开始对这些类型进行操作和操纵以满足我们的需求。
