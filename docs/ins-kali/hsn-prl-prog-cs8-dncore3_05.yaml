- en: Using PLINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PLINQ
- en: '**PLINQ** is a parallel implementation of the **Language Integrate Query**
    (**LINQ**). PLINQ was first introduced in .NET Framework 4.0 and since then has
    been made feature-rich. Before LINQ, it was difficult for developers to fetch
    data from various data sources such as XML or databases as each source required
    different skills. LINQ is a language syntax that relies on .NET delegates and
    built-in methods to query or modify data without having to worry about learning
    low-level tasks.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ是**Language Integrate Query**（LINQ）的并行实现。PLINQ首次在.NET Framework 4.0中引入，此后已经变得功能丰富。在LINQ之前，开发人员很难从各种数据源（如XML或数据库）中获取数据，因为每个源都需要不同的技能。LINQ是一种语言语法，依赖于.NET委托和内置方法来查询或修改数据，而无需担心学习低级任务。
- en: In this chapter, we will start by understanding the LINQ providers in .NET.
    With PLINQ being the preferred choice for programmers, we will cover its various
    programming aspects, along with some disadvantages associated with it. Finally,
    we will understand the factors that affect the performance of PLINQ.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先了解.NET中的LINQ提供程序。随着PLINQ成为程序员的首选，我们将涵盖其各种编程方面，以及与之相关的一些缺点。最后，我们将了解影响PLINQ性能的因素。
- en: 'We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: LINQ providers in .NET
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET中的LINQ提供程序
- en: Writing PLINQ queries
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写PLINQ查询
- en: Preserving order in PLINQ
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PLINQ中保持顺序
- en: Merge options in PLINQ
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ中的合并选项
- en: Handling exceptions in PLINQ
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在PLINQ中处理异常
- en: Combining parallel and sequential queries
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合并行和顺序查询
- en: PLINQ disadvantages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ的缺点
- en: Speedups in PLINQ
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ中的加速
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this chapter, you should have a good understanding of TPL and C#.
    The source code for this chapter is available on GitHub at [https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章，您应该对TPL和C#有很好的了解。本章的源代码可在GitHub上找到[https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04](https://github.com/PacktPublishing/Hands-On-Parallel-Programming-with-C-8-and-.NET-Core-3/tree/master/Chapter04)。
- en: LINQ providers in .NET
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET中的LINQ提供程序
- en: 'LINQ is a set of APIs that help us work with XML, objects, and databases more
    easily. LINQ has many providers, including the following, all of which are commonly
    used:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ是一组API，帮助我们更轻松地处理XML、对象和数据库。LINQ有许多提供程序，包括以下常用的：
- en: LINQ to objects: LINQ to objects allows developers to query in-memory objects such as
    arrays, collections, generic types, and so on. It returns an `IEnumerable` and
    supports features such as sorting, filtering, grouping, ordering, and aggregate
    functions. Its functionality is defined in the `System.Linq` namespace.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的LINQ：LINQ到对象允许开发人员查询内存中的对象，如数组、集合、泛型类型等。它返回一个`IEnumerable`，支持排序、过滤、分组、排序和聚合函数等功能。其功能在`System.Linq`命名空间中定义。
- en: LINQ to XML: LINQ to XML, or XLINQ, allows developers to query or modify XML
    data sources. It's defined in the `System.Xml.Linq` namespace.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到XML：LINQ到XML允许开发人员查询或修改XML数据源。它在`System.Xml.Linq`命名空间中定义。
- en: LINQ to ADO.NET: LINQ to ADO.NET is not one but a group of technologies that
    allows developers to query or modify relational data sources such as the SQL Server,
    MySQL, or Oracle.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到ADO.NET：LINQ到ADO.NET不是一个技术，而是一组技术，允许开发人员查询或修改关系数据源，如SQL Server、MySQL或Oracle。
- en: LINQ to SQL: This is also known as DLINQ. DLINQ uses **Object Relational** **Mapping** (**ORM**)
    and is a legacy technology that is supported but not enhanced by Microsoft. It
    works only with the SQL Server and allows users to map database tables to .NET
    classes. It also has an adapter that works like a developer interface to a database.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到SQL：也称为DLINQ。DLINQ使用对象关系映射（ORM），是微软支持但不再增强的传统技术。它仅适用于SQL Server，并允许用户将数据库表映射到.NET类。它还有一个适配器，类似于开发人员接口到数据库。
- en: 'LINQ to datasets: This allows developers to query or modify datasets in memory.
    It works with any database that ADO.NET has a provider for.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LINQ到数据集：这允许开发人员查询或修改内存中的数据集。它与ADO.NET支持的任何数据库一起工作。
- en: LINQ to entities: This is the most advanced and sought-after technology. It
    allows developers to work with any relational database, including SQL Server,
    Oracle, IBM Db2, and MySQL. LINQ to entities also supports ORM.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体的LINQ：这是最先进和最受追捧的技术。它允许开发人员使用任何关系数据库，包括SQL Server、Oracle、IBM Db2和MySQL。LINQ
    to entities还支持ORM。
- en: PLINQ: This is also known as PLINQ. PLINQ is a parallel implementation of LINQ
    for objects. LINQ queries execute sequentially and can be really slow for heavy
    computing operations. PLINQ supports the parallel execution of queries by having
    a task scheduled to be run on multiple threads and optionally on multiple cores
    as well.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLINQ：也称为PLINQ。PLINQ是对象的LINQ的并行实现。LINQ查询是顺序执行的，对于大量计算操作来说可能非常慢。PLINQ通过在多个线程上调度任务，并且可选地在多个核心上运行，支持查询的并行执行。
- en: .NET supports the seamless conversion of LINQ to PLINQ using the `AsParallel()` method.
    PLINQ is a very good choice for computing heavy operations. It works by portioning
    the source data into chunks, which are, in turn, executed by different threads
    running on multiple cores. PLINQ also supports XLINQ and LINQ to objects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: .NET支持使用`AsParallel()`方法将LINQ无缝转换为PLINQ。PLINQ是进行大量计算操作的非常好的选择。它通过将源数据分成块，然后由运行在多个核心上的不同线程执行来工作。PLINQ还支持XLINQ和LINQ到对象。
- en: Writing PLINQ queries
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写PLINQ查询
- en: To understand PLINQ queries, we need to understand the `ParallelEnumerable`
    class first. Once we have an understanding of the `ParallelEnumerable` class,
    we will learn how to write parallel queries.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解PLINQ查询，我们需要先了解`ParallelEnumerable`类。一旦我们了解了`ParallelEnumerable`类，我们将学习如何编写并行查询。
- en: Introducing the ParallelEnumerable class
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍ParallelEnumerable类
- en: The `ParallelEnumerable` class is available in the `System.Linq` namespace and
    the `System.Core` assembly.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelEnumerable`类位于`System.Linq`命名空间和`System.Core`程序集中。'
- en: 'Apart from supporting most of the standard query operators defined by LINQ,
    the `ParallelEnumerable` class supports a lot of extra methods that support parallel
    execution:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 除了支持LINQ定义的大多数标准查询操作符之外，`ParallelEnumerable`类还支持许多额外的支持并行执行的方法：
- en: '`AsParallel()`: This is the seed method that''s required for parallelization.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsParallel()`: 这是并行化所需的种子方法。'
- en: '`AsSequential()`: Enables sequential execution of a parallel query by changing
    the parallel behavior.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsSequential()`:通过改变并行行为，启用并行查询的顺序执行。'
- en: '`AsOrdered()`: By default, PLINQ doesn''t preserve the order in which tasks
    are executed and results are returned. We can preserve this ordering by calling
    the `AsOrdered()` method.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsOrdered()`: 默认情况下，PLINQ不保留任务执行和结果返回的顺序。我们可以通过调用`AsOrdered()`方法来保留这个顺序。'
- en: '`AsUnordered()`:This is the default behavior of `ParallelQuery`, which can
    be overridden by the `AsOrdered()` method. We can change the behavior from ordered
    to unordered by calling this method.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsUnordered()`:这是`ParallelQuery`的默认行为，可以通过`AsOrdered()`方法覆盖。我们可以通过调用这个方法将行为从有序改为无序。'
- en: '`ForAll()`:Enables query execution to be performed in parallel.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ForAll()`:启用并行执行查询。'
- en: '`Aggregate()`: This method can be used to aggregate results from various thread-local
    partitions in a parallel query.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Aggregate()`: 这个方法可以用来聚合并行查询中各个线程本地分区的结果。'
- en: '`WithDegreesOfParallelism()`:Using this method, we can specify the maximum
    number of processors that are used to parallelize query executions.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithDegreesOfParallelism()`:使用这个方法，我们可以指定用于并行化查询执行的最大处理器数量。'
- en: '`WithParallelOption()`:Using this method, we can buffer the results that are
    produced by a parallel query.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithParallelOption()`:使用这个方法，我们可以缓冲并行查询产生的结果。'
- en: '`WithExecutionMode()`:Using this method, we can force the parallel execution
    of a query or let PLINQ decide whether the query needs to be executed as sequential
    or parallel.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WithExecutionMode()`:使用这个方法，我们可以强制查询的并行执行，或者让PLINQ决定查询是否需要以顺序或并行方式执行。'
- en: We will learn more about these methods later in this chapter through the use
    of code examples. There is a very handy tool called LINQPad that's worth mentioning
    here. LINQPad helps us learn about LINQ/PLINQ queries since it has more than 500
    available samples and the ability to connect to a variety of data sources. You
    can download it from [https://www.linqpad.net/](https://www.linqpad.net/).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过代码示例在本章后面学习更多关于这些方法的内容。这里值得一提的是一个非常方便的工具叫做LINQPad。LINQPad帮助我们学习关于LINQ/PLINQ查询，因为它有500多个可用的示例和连接到各种数据源的能力。您可以从[https://www.linqpad.net/](https://www.linqpad.net/)下载它。
- en: Our first PLINQ query
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个PLINQ查询
- en: Let's say that we want to find all the numbers that are divisible by three.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要找到所有可以被三整除的数字。
- en: 'First, we define a range of 100,000 numbers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个范围为100,000的数字：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To find all the numbers that are divisible by three sequentially, use the following
    LINQ query:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要顺序找到所有可以被三整除的数字，使用以下LINQ查询：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is a parallel version of the same query using the `AsParallel`
    method but using the method syntax:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`AsParallel`方法的相同查询的并行版本，但使用方法语法：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here is the same version using the query syntax option in LINQ:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在LINQ中使用查询语法选项的相同版本：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the complete code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的代码：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of this will be as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下输出：
- en: '![](img/0c9852c6-5fe8-414a-91aa-388584a16007.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0c9852c6-5fe8-414a-91aa-388584a16007.png)'
- en: Preserving order in PLINQ while doing parallel executions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在进行并行执行时保留PLINQ中的顺序
- en: PLINQ executes work items in parallel and, by default, doesn't care about preserving
    the order of items to improve the performance of parallel queries. However, it
    is sometimes important that items are executed in the same order as they exist
    in the source collection. For example, imagine you are sending multiple requests
    to the server to download files in chunks and later on merging those chunks to
    recreate the file on the client side. Since the file is downloaded in parts, every
    part needs to be downloaded and merged in the correct order. Preserving the order
    while executing items in parallel has a direct impact on performance as we need
    to preserve the original ordering throughout the partitions and ensure that the
    ordering is consistent when merging items.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ并行执行工作项，并且默认情况下不关心保留项目的顺序以提高并行查询的性能。然而，有时重要的是项目按照它们在源集合中的顺序执行。例如，想象一下，您正在向服务器发送多个请求以按块下载文件，然后在客户端合并这些块以重新创建文件。由于文件是分部分下载的，每个部分都需要按正确的顺序下载和合并。在并行执行项目时保留顺序对性能有直接影响，因为我们需要在整个分区中保留原始顺序，并在合并项目时确保顺序一致。
- en: We can override the default behavior and turn on order preservation by using
    the `AsOrdered()` method on the source collection. If, at any point, we want to
    turn off the order preservation, we can call the `AsUnOrdered()` method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在源集合上使用`AsOrdered()`方法来覆盖默认行为并打开顺序保留。如果在任何时候，我们想要关闭顺序保留，我们可以调用`AsUnOrdered()`方法。
- en: 'Let''s look at an example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is sequential, so when we run it, we get the following output:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是顺序的，所以当我们运行它时，我们得到以下输出：
- en: '![](img/7ee9fa01-fe43-4286-a5e7-2da1ac67513f.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7ee9fa01-fe43-4286-a5e7-2da1ac67513f.png)'
- en: 'We can make a parallel version using the `AsParallel()` method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`AsParallel()`方法制作一个并行版本：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The preceding code executes in parallel, but the ordering is all messed up:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码是并行执行的，但是顺序全乱了：
- en: '![](img/109be61b-ab59-478d-82cf-ebd3186a4600.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/109be61b-ab59-478d-82cf-ebd3186a4600.png)'
- en: 'To get the best of both worlds, that is, parallel execution with ordering,
    we can modify the code as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了兼顾并行执行和顺序，我们可以修改代码如下：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '![](img/a62a7b42-bb90-4a57-8585-453ebf546d32.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a62a7b42-bb90-4a57-8585-453ebf546d32.png)'
- en: As you can see, when we call the `AsOrdered()` method, it executes all the work
    items in parallel while preserving the original order, whereas, in the default
    one, the order was not preserved. The performance implications of using the `AsOrdered()`
    method are huge since the order is restored at every step of the execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，当我们调用`AsOrdered()`方法时，它会并行执行所有工作项，同时保留原始顺序，而在默认情况下，顺序未被保留。使用`AsOrdered()`方法的性能影响巨大，因为顺序在执行的每个步骤中都得到恢复。
- en: Sequential execution using the AsUnOrdered() method
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AsUnOrdered()方法进行顺序执行
- en: Once we have called `AsOrdered` on PLINQ, the query will execute sequentially.
    There may be situations in which we want to execute a query as ordered for a certain
    period but change to unordered after that to gain performance.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在PLINQ上调用了`AsOrdered`，查询将会顺序执行。可能会有一些情况，我们希望在一定时间内按顺序执行查询，但之后改为无序以获得性能。
- en: 'Let''s say we want to generate the squares of the first 100 numbers from a
    range of numbers. One way to do this in parallel is as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要生成前100个数字的平方，我们可以并行执行如下：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We need `AsOrdered()` to get the first 100 numbers. The problem is that the
    `Select` query will also perform as ordered. We can improve performance by combining
    `AsOrdered()` and `AsUnOrdered()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要`AsOrdered()`来获取前100个数字。问题在于`Select`查询也将按顺序执行。我们可以通过结合`AsOrdered()`和`AsUnOrdered()`来提高性能：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, the first 100 items will be retrieved in parallel and in order. After that,
    the query will execute without any order preservation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前100个项目将并行按顺序检索。之后，查询将在不保留任何顺序的情况下执行。
- en: Merge options in PLINQ
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PLINQ中的合并选项
- en: As we mentioned previously, when we create a parallel query, the source collection
    is partitioned so that multiple tasks can work on sections concurrently. Once
    the query completes, the results need to be merged so that they can be made available
    to the consuming thread. There are various ways to merge the results, depending
    on the query operators. We can specify how we want to merge the results explicitly
    using the `ParallelMergeOperation` enumeration and the `WithMergeOption()` extension
    method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，当我们创建并行查询时，源集合被分区，以便多个任务可以同时处理部分。一旦查询完成，结果就需要合并，以便它们可以提供给消费线程。根据查询运算符，可以指定如何显式合并结果，使用`ParallelMergeOperation`枚举和`WithMergeOption()`扩展方法。
- en: Let's take a look at the various merge options that are available to us.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以使用的各种合并选项。
- en: Using the NotBuffered merge option
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NotBuffered合并选项
- en: 'The results of concurrent tasks are not buffered. As soon as any of the tasks
    finish, they return the result to the consuming thread:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 并发任务的结果不会被缓冲。一旦任何任务完成，它们就会将结果返回给消费线程：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of this is as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/f57d286b-cd53-4c1e-a6a8-4ce2c49db628.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f57d286b-cd53-4c1e-a6a8-4ce2c49db628.png)'
- en: Using the AutoBuffered merge option
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AutoBuffered合并选项
- en: The results from concurrent tasks are buffered and the buffer is made available
    to consuming threads in periodic intervals. Depending on the size of the collection,
    multiple buffers might be returned. Using this option, the consuming thread needs
    to wait longer to get the first result. This is also the default option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 并发任务的结果被缓冲，并且缓冲区定期提供给消费线程。根据集合的大小，可能会返回多个缓冲区。使用此选项，消费线程需要等待更长时间才能获得第一个结果。这也是默认选项。
- en: 'Consider the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/a4ff17e0-f114-4331-96ef-0cdfc05fb90d.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4ff17e0-f114-4331-96ef-0cdfc05fb90d.png)'
- en: Using the FullyBuffered merge option
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FullyBuffered合并选项
- en: 'The results from concurrent tasks are fully buffered before they are made available
    in one go to the consuming thread. This improves the overall performance, though
    the time it takes to get the first result will be longer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 并发任务的结果在提供给消费线程之前完全缓冲。这提高了整体性能，尽管获得第一个结果所需的时间会更长：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/3438d1bb-7fa1-4d8a-b73f-7bb47658899f.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3438d1bb-7fa1-4d8a-b73f-7bb47658899f.png)'
- en: 'Not all query operators support all merge modes. The following is a list of
    operators, along with their restrictions:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有查询运算符都支持所有合并模式。以下是一些运算符及其限制的列表：
- en: '![](img/e4778fae-b79c-4ac2-9f71-ae424eea9626.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4778fae-b79c-4ac2-9f71-ae424eea9626.png)'
- en: This information can be found at [http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息可在[http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx)找到。
- en: Apart from the preceding operators, `ForAll()` is always `NotBuffered` and `OrderBy`
    is always `FullyBuffered`. If any custom merge options are specified on these
    operators, they are just ignored.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的运算符外，`ForAll()`始终为`NotBuffered`，`OrderBy`始终为`FullyBuffered`。如果在这些运算符上指定了任何自定义合并选项，则它们将被忽略。
- en: Throwing and handling exceptions with PLINQ
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PLINQ抛出和处理异常
- en: Just like other parallel primitives, PLINQ throws a `System.AggregateException`
    whenever it encounters an exception. Exception handling largely depends on your
    design. You may want the program to fail as soon as possible or you may want all
    the exceptions to be returned to the caller.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他并行原语一样，每当PLINQ遇到异常时，都会抛出`System.AggregateException`。异常处理在很大程度上取决于您的设计。您可能希望程序尽快失败，或者您可能希望所有异常都返回给调用者。
- en: 'In the following example, we will wrap a parallel query inside a `try`-`catch`
    block. When the query throws an exception, it will propagate back to the caller,
    wrapped in `System.AggregateException`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将在`try`-`catch`块中包装一个并行查询。当查询引发异常时，它将传播回调用者，包装在`System.AggregateException`中：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output will be as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/c8c67d50-21a0-4685-a992-5ed7d2be1a04.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c8c67d50-21a0-4685-a992-5ed7d2be1a04.png)'
- en: 'We can also specify a `try`-`catch` block within a delegate, which would alert
    us about error conditions as soon as possible. It can also be used in a scenario
    in which we just want to log an exception and continue the query''s execution
    by providing a default value as the query result in the case of an exception:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在委托内部指定一个`try`-`catch`块，这样可以尽快通知我们有关错误条件。它还可以用于一种情况，即我们只想记录异常并通过在异常情况下提供默认值作为查询结果来继续查询的执行：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/a11c41a4-91fe-4229-a8ad-03dd5941f418.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a11c41a4-91fe-4229-a8ad-03dd5941f418.png)'
- en: Exception handling is very important for maintaining the correct flow in the
    application, as well as to notify the user of applications with error conditions.
    With proper exception handling and logging, we can troubleshoot application errors
    in production environments as well. In the next section, we will discuss how to
    merge parallel and sequential queries.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理对于维护应用程序中的正确流程以及通知用户应用程序中的错误条件非常重要。通过适当的异常处理和日志记录，我们可以在生产环境中排除应用程序错误。在下一节中，我们将讨论如何合并并行和顺序查询。
- en: Combining parallel and sequential LINQ queries
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并并行和顺序LINQ查询
- en: 'We have already discussed the use of `AsParallel()` to create parallel queries.
    Sometimes, we may want to execute operators sequentially. We can force PLINQ to
    operate sequentially using the `AsSequential()` method. Once this method is applied
    to any parallel query, the following operators execute in a sequence. Consider
    the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了使用`AsParallel()`创建并行查询的用法。有时，我们可能希望按顺序执行操作。我们可以使用`AsSequential()`方法强制PLINQ按顺序操作。一旦这个方法应用到任何并行查询中，后续的操作将按顺序执行。考虑以下代码：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the first `Where` class, `Where(i => i % 2 == 0)`, will execute in parallel.
    The second `Where` class, `Where(i => i % 8 == 0)`, however, will execute sequentially.
    `OrderBy` will also be switched to parallel execution mode.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，第一个`Where`类，`Where(i => i % 2 == 0)`，将并行执行。然而，第二个`Where`类，`Where(i => i %
    8 == 0)`，将顺序执行。`OrderBy`也将切换到并行执行模式。
- en: 'This is shown in the following diagram:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如下图所示：
- en: '![](img/7a54d9fe-386b-409d-891c-fb7feebc4132.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7a54d9fe-386b-409d-891c-fb7feebc4132.png)'
- en: Now, we should have a good idea about how to merge synchronous and parallel
    LINQ queries. In the next section, we will learn how to cancel PLINQ queries to
    save CPU resources.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该对如何合并同步和并行LINQ查询有了一个很好的了解。在下一节中，我们将学习如何取消PLINQ查询以节省CPU资源。
- en: Canceling PLINQ queries
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消PLINQ查询
- en: We can cancel a PLINQ query using the `CancellationTokenSource` and `CancellationToken`
    classes. The cancellation token is passed to the PLINQ query using the `WithCancellation` clause
    and then we can call `CancellationToken.Cancel` to cancel the query operation.
    When a query is canceled, it throws `OperationCancelledException`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`CancellationTokenSource`和`CancellationToken`类取消PLINQ查询。取消令牌通过`WithCancellation`子句传递给PLINQ查询，然后我们可以调用`CancellationToken.Cancel`来取消查询操作。当查询被取消时，会抛出`OperationCancelledException`。
- en: 'This is done as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 操作如下：
- en: 'Create a cancellation token source:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个取消令牌源：
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Wrap the PLINQ query inside a `try` block:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将PLINQ查询包装在`try`块内：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add two `catch` blocks; one to catch `OperationCanceledException` and the other
    to capture `AggregateException`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个`catch`块；一个用于捕获`OperationCanceledException`，另一个用于捕获`AggregateException`：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Take the range as a very large value that takes more than four seconds to execute:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将范围设置为一个非常大的值，需要超过四秒才能执行：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code. After four seconds, we will see the following output:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。四秒后，我们将看到以下输出：
- en: '![](img/b9611cf2-ff56-446a-b1ec-eb8ca922b462.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9611cf2-ff56-446a-b1ec-eb8ca922b462.png)'
- en: Parallel programming comes with its own caveats. In the next section, we will
    introduce the disadvantages of writing parallel code with PLINQ.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并行编程有其自己的注意事项。在下一节中，我们将介绍使用PLINQ编写并行代码的缺点。
- en: Disadvantages of parallel programming with PLINQ
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PLINQ的并行编程的缺点
- en: 'In most cases, PLINQ performs much faster than its non-parallel counterpart
    LINQ. However, there is some performance overhead, which is related to partitioning
    and merging while parallelizing the LINQ. The following are some of the things
    we need to consider while using PLINQ:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，PLINQ的性能要比其非并行对应的LINQ快得多。然而，与将LINQ并行化相关的分区和合并会带来一些性能开销。在使用PLINQ时，我们需要考虑以下一些事项：
- en: '**Parallel is not always faster**:Parallelization is an overhead. Unless your
    source collection is huge or it has compute-bound operations, it makes more sense
    to execute the operations in sequence. Always measure the performance of sequential
    and parallel queries to make an informed decision.'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**并不总是并行更快**：并行化是一种开销。除非你的源集合很大或者它有计算密集型操作，否则按顺序执行操作更有意义。始终测量顺序和并行查询的性能，以做出明智的决定。'
- en: '**Avoid I/O operations that involve atomicity**:All I/O operations that involve
    writing to a filesystem, database, network, or shared memory location should be
    avoided inside PLINQ. This is because these methods are not thread-safe, so using
    them may lead to exceptions. A solution would be to use synchronization primitives,
    but this would also reduce performance drastically.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**避免涉及原子性的I/O操作**：所有涉及写入文件系统、数据库、网络或共享内存位置的I/O操作都应该避免在PLINQ内部进行。这是因为这些方法不是线程安全的，因此使用它们可能会导致异常。一个解决方案是使用同步原语，但这也会严重降低性能。'
- en: '**Your queries may not always be running in parallel**:Parallelization in PLINQ
    is a decision that''s taken by CLR. Even if we called the `AsParallel()` method
    in the query, it isn''t guaranteed to take a parallel path and may run sequentially
    instead.'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**你的查询可能并不总是并行运行**：在PLINQ中进行并行化是CLR做出的决定。即使我们在查询中调用了`AsParallel()`方法，也不能保证它会采用并行路径，可能会顺序运行。'
- en: Understanding the factors that affect the performance of PLINQ (speedups)
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解影响PLINQ性能的因素（加速）
- en: The primary purpose of PLINQ is to speed up query execution by splitting the
    task and executing it in parallel. However, there are a lot of factors that can
    impact the performance of PLINQ. These include synchronization overheads to do
    with chunking and partitioning, as well as scheduling and collecting results from
    threads. PLINQ performs best in *delightfully parallel* scenarios, where threads
    don't have to share a state and don't have to worry about the order of execution.
    Being *delightfully parallel* is ideal but not always achievable due to the nature
    of work. Let's try to understand the factors that can impact the performance of
    PLINQ.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ的主要目的是通过将任务拆分并并行执行来加速查询执行。然而，有许多因素可能会影响PLINQ的性能。这些因素包括与分块和分区相关的同步开销，以及来自线程的调度和收集结果的开销。PLINQ在*令人愉快地并行*的场景中表现最佳，其中线程不必共享状态，也不必担心执行顺序。*令人愉快地并行*是理想的，但由于工作的性质，不一定总是可行的。让我们试着了解可能影响PLINQ性能的因素。
- en: Degree of parallelism
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行度
- en: With a greater number of cores at our disposal, we can achieve significant performance
    gains since TPL makes sure multiple tasks can execute concurrently on multiple
    cores. This improvement in performance may not be exponential and, while tuning
    the performance, we should try to run on different systems with multiple cores
    and compare results.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有了更多的核心可供我们使用，我们可以实现显著的性能提升，因为TPL确保多个任务可以在多个核心上并发执行。性能的提升可能不是指数级的，因此在调整性能时，我们应该尝试在具有多个核心的不同系统上运行并比较结果。
- en: Merge option
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并选项
- en: We can significantly improve the user experience in scenarios where results
    change often and the user wants to see results as soon as possible without waiting.
    The default option with PLINQ is to buffer results and later merge them and return
    them to the user. We can modify this behavior by choosing an appropriate merge
    option.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在结果经常变化且用户希望尽快看到结果而不必等待的情况下显著改善用户体验。PLINQ的默认选项是缓冲结果，然后合并并将其返回给用户。我们可以通过选择适当的合并选项来修改此行为。
- en: Partitioning type
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分区类型
- en: We should always check whether our work items are balanced or unbalanced. For
    unbalanced work item scenarios, custom partitioners may be introduced to improve
    performance.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终检查我们的工作项是平衡的还是不平衡的。对于不平衡的工作项场景，可以引入自定义分区器来提高性能。
- en: Deciding when to stay sequential with PLINQ
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 决定何时使用PLINQ保持顺序
- en: 'We should always work out the computational cost of each work item and the
    entire operation as a whole so that we can decide whether we want to stay sequential
    or move to parallelism. Parallel queries may not always be fast due to the additional
    overhead of partitioning, scheduling, and so on:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终计算每个工作项和整个操作的计算成本，以便决定是保持顺序还是转移到并行。并行查询可能并不总是快速的，因为存在分区、调度等额外开销：
- en: '*Computational Cost   =  Cost to execute 1 work item * total number of work
    items*'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*计算成本 = 执行1个工作项的成本 * 总工作项数*'
- en: Parallel queries can provide significant performance gains with increasing computational
    cost per item. However, if the performance gain is very low, it makes sense to
    execute the query sequentially.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 并行查询可以在每个项目的计算成本增加时提供显著的性能提升。然而，如果性能提升非常低，那么按顺序执行查询是有意义的。
- en: 'Whether PLINQ decides to execute sequentially or in parallel depends on the
    combination of operators in the query. Simply put, if the query has any of the
    following operators, PLINQ may decide to run a query as sequential:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ决定是按顺序还是并行执行取决于查询中操作符的组合。简单来说，如果查询中有以下任何一个操作符，PLINQ可能决定按顺序运行查询：
- en: '`Take`, `TakeWhile`, `Skip`, `SkipWhile`, `First`, `Last`, `Concat`, `Zip`,
    or `ElementAt`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Take`、`TakeWhile`、`Skip`、`SkipWhile`、`First`、`Last`、`Concat`、`Zip`或`ElementAt`'
- en: Indexed `Where` and `Select`, which are overloads of `Where` and `Select`, respectively
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 索引的`Where`和`Select`，它们分别是`Where`和`Select`的重载
- en: 'The following code demonstrates using indexed `Where` and `Select`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了使用索引的`Where`和`Select`：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Order of operation
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作顺序
- en: PLINQ provides better performance with unordered collections as there are performance
    costs associated with making collections execute as ordered. This performance
    cost includes partitioning, scheduling, and gathering results, as well as calling
    `GroupJoin` and filters. As a developer, you should consider when you want to
    use `AsOrdered()`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与无序集合相比，PLINQ在性能上提供了更好的表现，因为使集合按顺序执行会带来性能成本。这种性能成本包括分区、调度和收集结果，以及调用`GroupJoin`和过滤器。作为开发人员，您应该考虑何时使用`AsOrdered()`。
- en: ForAll versus calling ToArray() or ToList()
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ForAll与调用ToArray()或ToList()的区别
- en: When we call `ToList()` or `ToArray()` or enumerate a result in a loop, we force
    PLINQ to merge results from all the parallel threads into a single data structure.
    This is a performance overhead. If we just want to perform some actions on a set
    of items, it is better to use the `ForAll()` method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`ToList()`或`ToArray()`或在循环中枚举结果时，我们强制PLINQ将所有并行线程的结果合并为单个数据结构。这是一种性能开销。如果我们只是想对一组项目执行一些操作，最好使用`ForAll()`方法。
- en: Forcing parallelism
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制并行
- en: 'PLINQ is not guaranteed to carry out parallel execution every time. It may
    decide to run sequential executions, depending on the type of query. We can control
    this using the `WithExecutionMode` method. `WithExecutionMode` is an extension
    method that works on objects of the `ParallelQuery` type. It takes `ParallelExecutionMode`
    as a parameter, which is an `enum`. The default value of `ParallelExecutionMode`
    lets PLINQ decide on the best execution mode. We can force the execution mode
    to be parallel using the `ForceParallelism` option:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: PLINQ并不保证每次都进行并行执行。它可能决定按顺序执行，这取决于查询的类型。我们可以使用`WithExecutionMode`方法来控制这一点。`WithExecutionMode`是一个作用于`ParallelQuery`类型对象的扩展方法。它以`ParallelExecutionMode`作为参数，这是一个枚举。`ParallelExecutionMode`的默认值让PLINQ决定最佳的执行模式。我们可以使用`ForceParallelism`选项强制执行模式为并行：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Generating sequences
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成序列
- en: 'Throughout this book, we used the `Enumerable.Range()` method to generate a
    sequence of numbers. We can generate numbers in parallel as well using the `ParallelEnumerable`
    class. Let''s do a simple test comparison between `Enumerable` and the `ParallelEnumerable`
    class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们使用`Enumerable.Range()`方法来生成一系列数字。我们也可以使用`ParallelEnumerable`类来并行生成数字。让我们对`Enumerable`和`ParallelEnumerable`类进行一个简单的测试比较：
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b9290369-ab08-4566-9f7f-87ed4670f5c2.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9290369-ab08-4566-9f7f-87ed4670f5c2.png)'
- en: As you can see, `ParallelEnumerable` works much faster than `Enumerable` for
    creating a range.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`ParallelEnumerable`比`Enumerable`更快地创建了一个范围。
- en: 'In a similar scenario, we may want to generate a number a certain amount of
    times. We can use the `ParallelEnumerable.Repeat()` method for this scenario,
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在类似的情况下，我们可能希望生成一定数量的数字。我们可以使用`ParallelEnumerable.Repeat()`方法来实现这种情况，如下所示：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now that we've understood the factors that affect the performance of PLINQ,
    we have come to the end of this chapter. Now, let's summarize what we've learned.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了影响PLINQ性能的因素，我们已经到达了本章的结尾。现在，让我们总结一下我们学到的东西。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the basics of LINQ before moving on to understand
    how we can write parallel queries using PLINQ. We learned that PLINQ can work
    well to improve the performance of the application as a whole, but it is important
    to bear its disadvantages in mind. As a programmer, it is always a good idea to
    weigh up your options by writing both LINQ and PLINQ queries and comparing their
    performance.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了LINQ的基础知识，然后继续了解如何使用PLINQ编写并行查询。我们了解到PLINQ可以很好地提高整个应用程序的性能，但重要的是要记住它的缺点。作为程序员，通过编写LINQ和PLINQ查询并比较它们的性能，权衡你的选择总是一个好主意。
- en: In the next chapter, we will learn about using synchronization primitives to
    preserve the consistency and state of data when data is shared across multiple
    threads.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用同步原语来保持数据的一致性和状态，当数据在多个线程之间共享时。
- en: Questions
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of these LINQ providers has better support for relational objects?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个LINQ提供程序对关系对象有更好的支持？
- en: LINQ to SQL
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LINQ到SQL
- en: LINQ to entities
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实体的LINQ
- en: We can easily convert LINQ into parallel LINQ by using `AsParallel()`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过使用`AsParallel()`轻松将LINQ转换为并行LINQ。
- en: 'True'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: It's not possible to switch between ordered and unordered execution in PLINQ.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在PLINQ中无法在有序和无序执行之间切换。
- en: 'True'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 真
- en: 'False'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假
- en: Which of these allows the results for concurrent tasks to be buffered and made
    available to consuming threads at periodic intervals?
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其中一个允许并发任务的结果被缓冲并定期提供给消费线程？
- en: '`FullyBuffered`'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全缓冲
- en: '`AutoBuffered`'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 自动缓冲
- en: '`NotBuffered`'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 非缓冲
- en: Which exception will be thrown if the following code is executed inside a task?
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在任务内执行以下代码，将抛出哪个异常？
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`AggregateException`'
  id: totrans-188
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AggregateException`'
- en: '`DivideByZeroException`'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DivideByZeroException`'
