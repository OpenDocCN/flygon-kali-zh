- en: Lambda Expressions and Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式和函数式编程
- en: This chapter explains the concept of functional programming. It provides an
    overview of the functional interfaces that come with JDK, explains how to use
    them in lambda expressions, and how to write lambda expressions in the most concise
    style.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了函数式编程的概念。它概述了JDK提供的函数式接口，解释了如何在Lambda表达式中使用它们，以及如何以最简洁的方式编写Lambda表达式。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Functional programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional interfaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式接口
- en: Lambda expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: Method references
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法引用
- en: Exercise – Using method references for creating a new object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习-使用方法引用创建一个新对象
- en: Functional programming
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming allows us to treat a block of code (a function) like
    an object, passing it as a parameter or as a return value of a method. This feature
    is present in many programming languages. It does not require us to manage the
    object state. The function is stateless. Its result depends only on the input
    data, no matter how many times it was called. This style makes the outcome more
    predictable, which is the most attractive aspect of functional programming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程允许我们将一块代码（一个函数）视为对象，将其作为参数或方法的返回值。这个特性存在于许多编程语言中。它不要求我们管理对象状态。函数是无状态的。它的结果只取决于输入数据，无论调用多少次。这种风格使结果更可预测，这是函数式编程最吸引人的方面。
- en: Without functional programming, the only way to pass a functionality as a parameter
    in Java would be through writing a class that implements an interface, creating
    its object, and then passing it as a parameter. But even the least involved style—using
    the anonymous class—requires writing too much of the boilerplate code. Using functional
    interfaces and lambda expressions makes the code shorter, clearer, and more expressive.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有函数式编程，将功能作为参数传递的唯一方法是通过编写实现接口的类，创建其对象，然后将其作为参数传递。但即使是最不涉及的样式-使用匿名类-也需要编写太多的样板代码。使用函数式接口和Lambda表达式使代码更短，更清晰，更具表现力。
- en: Adding it to Java increases parallel programming capabilities by shifting the
    responsibility for parallelism from the client code to the library. Before that,
    in order to process elements of Java collections, the client code had to iterate
    over the collection and organize processing. In Java 8, new (default) methods
    were added that accept a function (the implementation of a functional interface)
    as a parameter and then apply it to each element of the collection in parallel
    or not, depending on the internal processing algorithm. So, it is the library's
    responsibility to organize parallel processing.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到Java中可以通过将并行编程能力从客户端代码转移到库来增加。在此之前，为了处理Java集合的元素，客户端代码必须迭代集合并组织处理。在Java
    8中，添加了接受函数（函数式接口的实现）作为参数然后将其应用于集合的每个元素的新（默认）方法，具体取决于内部处理算法是并行还是串行。因此，组织并行处理是库的责任。
- en: Throughout this chapter, we will define and explain these Java features—functional
    interfaces and lambda expressions—and demonstrate their applicability in code
    examples. They make functions the first-class citizens of the language on the
    same level of importance as objects.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将定义和解释这些Java特性-函数式接口和Lambda表达式-并演示它们在代码示例中的适用性。它们使函数成为语言中与对象同等重要的一等公民。
- en: What is a functional interface?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是函数式接口？
- en: In fact, you have already seen elements of functional programming in our demonstration
    code. One example is the `forEach(Consumer consumer)` method, available for every `Iterable`,
    where `Consumer` is a functional interface. Another example is the `removeIf(Predicate
    predicate)` method, available for every `Collection` object. The passed-in `Predicate` object
    is a function – an implementation of a functional interface. Similarly, the `sort(Comparator
    comparator)` and `replaceAll(UnaryOperator uo)` methods in the `List` interface
    and several `compute()` methods in `Map` are examples of functional programming.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您已经在我们的演示代码中看到了函数式编程的元素。一个例子是`forEach(Consumer consumer)`方法，对每个`Iterable`都可用，其中`Consumer`是一个函数式接口。另一个例子是`removeIf(Predicate
    predicate)`方法，对每个`Collection`对象都可用。传入的`Predicate`对象是一个函数-函数式接口的实现。类似地，`List`接口中的`sort(Comparator
    comparator)`和`replaceAll(UnaryOperator uo)`方法以及`Map`中的几个`compute()`方法都是函数式编程的例子。
- en: A functional interface is an interface that has only one abstract method, including
    those that were inherited from the parent interface.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式接口是一个只有一个抽象方法的接口，包括从父接口继承的方法。
- en: 'To help avoid runtime errors, an `@FunctionalInterface` annotation was introduced
    in Java 8 that tells the compiler about the intent, so the compiler can check
    to see whether there is truly only one abstract method in the annotated interface.
    Let''s review the following interfaces of the same line of inheritance:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免运行时错误，Java 8引入了`@FunctionalInterface`注解，告诉编译器意图，因此编译器可以检查注解接口中是否真的只有一个抽象方法。让我们回顾一下相同继承线的以下接口：
- en: '```java'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@FunctionalInterface'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: interface A {
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接口A {
- en: void method1();
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: void method1();
- en: default void method2(){}
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: default void method2(){}
- en: static void method3(){}
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: static void method3(){}
- en: '}'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@FunctionalInterface'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: interface B extends A {
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接口B扩展自A {
- en: default void method4(){}
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: default void method4(){}
- en: '}'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@FunctionalInterface'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: interface C extends B {
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接口C扩展自B {
- en: void method1();
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: void method1();
- en: '}'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: //@FunctionalInterface  //compilation error
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: //@FunctionalInterface  //编译错误
- en: interface D extends C {
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 接口D扩展自C {
- en: void method5();
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: void method5();
- en: '}'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Interface `A` is a functional interface because it has only one abstract method: `method1()`.
    Interface `B` is also a functional interface because it has only one abstract
    method too – the same `method1()` inherited from interface `A`. Interface `C`
    is a functional interface because it has only one abstract method, `method1()`,
    which overrides the abstract `method1()` method of the parent interface `A`. Interface
    `D` cannot be a functional interface because it has two abstract methods – `method1()`,
    from the parent interface `A`, and `method5()`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接口`A`是一个功能接口，因为它只有一个抽象方法：`method1()`。接口`B`也是一个功能接口，因为它也只有一个抽象方法-与从接口`A`继承的相同的`method1()`。接口`C`是一个功能接口，因为它只有一个抽象方法，`method1()`，它覆盖了父接口`A`的抽象`method1()`方法。接口`D`不能是一个功能接口，因为它有两个抽象方法-从父接口`A`继承的`method1()`和`method5()`。
- en: When the `@FunctionalInterface` annotation is used, it tells the compiler to
    check on the presence of only one abstract method, and it warns the programmer,
    who reads the code, that this interface has only one abstract method intentionally.
    Otherwise, the programmer may waste time enhancing the interface only to discover
    later that it cannot be done.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`@FunctionalInterface`注释时，它告诉编译器仅检查一个抽象方法的存在，并警告程序员，读取代码时，此接口只有一个抽象方法是有意的。否则，程序员可能会浪费时间增强接口，只是后来发现无法完成。
- en: 'For the same reason, the `Runnable` and `Callable` interfaces that existed
    in Java since its early versions were annotated in Java 8 as `@FunctionalInterface`.
    It makes this distinction explicit and serves as a reminder to its users and to
    those who might attempt to add another abstract method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 出于同样的原因，自Java早期版本以来就存在的`Runnable`和`Callable`接口在Java 8中被注释为`@FunctionalInterface`。它使这种区别变得明确，并提醒其用户和那些可能尝试添加另一个抽象方法的人：
- en: '```java'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: '@FunctionalInterface'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: interface Runnable {
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接口Runnable {
- en: void run();
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: void run();
- en: '}'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '@FunctionalInterface'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '@FunctionalInterface'
- en: interface Callable<V> {
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接口Callable<V> {
- en: V call() throws Exception;
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: V call() throws Exception;
- en: '}'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, creating a functional interface is easy. But before doing that,
    consider using one of the 43 functional interfaces provided in the `java.util.function` package.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，创建功能接口很容易。但在这之前，考虑使用`java.util.function`包中提供的43个功能接口之一。
- en: Ready-to-use standard functional interfaces
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准功能接口即用即用
- en: 'Most of the interfaces provided in the `java.util.function` package are specializations
    of the following four interfaces: `Function`, `Consumer`, `Supplier`, and `Predicate`.
    Let''s review them and then have a short overview of the rest of the 39 standard
    functional interfaces.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中提供的大多数接口都是以下四个接口的特殊化：`Function`、`Consumer`、`Supplier`和`Predicate`。让我们先来回顾一下它们，然后简要概述其他39个标准功能接口。'
- en: Function<T, R>
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Function<T, R>
- en: The notation of this and other functional `<indexentry content="standard functional
    interfaces:function">` interfaces includes listing of the types of the input data
    (`T`) and the returned data (`R`). So, `Function<T, R>` means that the only abstract
    method of this interface accepts an argument of type `T` and produces a result
    of type `R`. You can find the name of that abstract method by reading the online
    documentation. In the case of the `Function<T, R>` interface, its method is `R
    apply(T)`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此及其他功能`<indexentry content="standard functional interfaces:function">`接口的表示法包括输入数据（`T`）和返回数据（`R`）类型的列表。因此，`Function<T,
    R>`表示此接口的唯一抽象方法接受`T`类型的参数并产生`R`类型的结果。您可以通过阅读在线文档找到该抽象方法的名称。在`Function<T, R>`接口的情况下，其方法是`R
    apply(T)`。
- en: 'After learning all that, we can create an implementation of this interface
    using an anonymous class:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 学习了所有这些之后，我们可以使用匿名类创建此接口的实现：
- en: '```java'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> multiplyByTen = new Function<Integer, Double>(){
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByTen = new Function<Integer, Double>(){
- en: public Double apply(Integer i){
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: public Double apply(Integer i){
- en: return i * 10.0;
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: return i * 10.0;
- en: '}'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: '```'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: It is up to the programmer to decide which actual type will be `T` (the input
    parameter) and which type will be `R` (the returned value). In our example, we
    have decided that the input parameters will be of the `Integer` type and the result
    will be of the `Double` type. As you have probably realized by now, the types
    can be reference types only, and the boxing and unboxing of primitive types is
    performed automatically.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由程序员决定`T`（输入参数）将是哪种实际类型，`R`（返回值）将是哪种类型。在我们的例子中，我们已经决定输入参数将是`Integer`类型，结果将是`Double`类型。正如您现在可能已经意识到的那样，类型只能是引用类型，并且原始类型的装箱和拆箱是自动执行的。
- en: 'We can now use our new `Function<Integer, Double> multiplyByTen` function any
    way we need. We can just use it directly, as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以根据需要使用我们的新`Function<Integer, Double> multiplyByTen`函数。我们可以直接使用它，如下所示：
- en: '```java'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'System.out.println(multiplyByTen.apply(1)); //prints: 10.0'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(multiplyByTen.apply(1)); //prints: 10.0'
- en: '```'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or we can create a method that accepts this function as a parameter:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以创建一个接受此函数作为参数的方法：
- en: '```java'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void useFunc(Function<Integer, Double> processingFunc, int input){
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: void useFunc(Function<Integer, Double> processingFunc, int input){
- en: System.out.println(processingFunc.apply(input));
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(processingFunc.apply(input));
- en: '}'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can then pass our function into this method and let the method use it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将我们的函数传递到这个方法中，并让方法使用它：
- en: '```java'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: 'useFunc(multiplyByTen, 10);     //prints: 100.00'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 'useFunc(multiplyByTen, 10);     //prints: 100.00'
- en: '```'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can also create a method that will generate a function whenever we need
    one:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个方法，每当需要时就会生成一个函数：
- en: '```java'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> createMultiplyBy(double num){
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> createMultiplyBy(double num){
- en: Function<Integer, Double> func = new Function<Integer, Double>(){
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> func = new Function<Integer, Double>(){
- en: public Double apply(Integer i){
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: public Double apply(Integer i){
- en: return i * num;
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: return i * num;
- en: '}'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Using the preceding method, we can write the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法，我们可以编写以下代码：
- en: '```java'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: 'System.out.println(multiplyByFive.apply(1)); //prints: 5.0'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 'System.out.println(multiplyByFive.apply(1)); //prints: 5.0'
- en: 'useFunc(multiplyByFive, 10);                 //prints: 50.0'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 'useFunc(multiplyByFive, 10);                 //prints: 50.0'
- en: '```'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: In the next section, we will introduce lambda expressions and will show how
    they can be used to express the functional interface implementation with much
    less code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍lambda表达式，并展示它们如何用更少的代码来表达函数接口的实现。
- en: Consumer<T>
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费者<T>
- en: 'By looking at the `Consumer<T>` interface definition, you can already guess
    that this interface has an abstract method that accepts a parameter of the `T`
    type <indexentry content="standard functional interfaces:Consumer">and does not
    return anything. From the documentation of the `Consumer<T>` interface, we learn
    that its abstract method is `void accept(T)`, which means that, for example, we
    can implement it as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`Consumer<T>`接口的定义，你已经猜到这个接口有一个接受`T`类型参数的抽象方法，并且不返回任何东西。从`Consumer<T>`接口的文档中，我们了解到它的抽象方法是`void
    accept(T)`，这意味着，例如，我们可以这样实现它：
- en: '```java'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Consumer<Double> printResult = new Consumer<Double>() {
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult = new Consumer<Double>() {
- en: public void accept(Double d) {
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: public void accept(Double d) {
- en: System.out.println("Result=" + d);
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Result=" + d);
- en: '}'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: 'printResult.accept(10.0);         //prints: Result=10.0'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'printResult.accept(10.0);         //prints: Result=10.0'
- en: '```'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Or we can create a method that will generate the function:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以创建一个生成函数的方法：
- en: '```java'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者<Double> createPrintingFunc(String prefix, String postfix){
- en: Consumer<Double> func = new Consumer<Double>() {
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> func = new Consumer<Double>() {
- en: public void accept(Double d) {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: public void accept(Double d) {
- en: System.out.println(prefix + d + postfix);
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(prefix + d + postfix);
- en: '}'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now we can use it as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以这样使用它：
- en: '```java'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者<Double> printResult = createPrintingFunc("Result=", " Great!");
- en: 'printResult.accept(10.0);    //prints: Result=10.0 Great!'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 'printResult.accept(10.0);    //prints: Result=10.0 Great!'
- en: '```'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can also create a new method that not only accepts a processing function
    as a parameter but also a printing function too:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建一个新的方法，不仅接受处理函数作为参数，还接受打印函数：
- en: '```java'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void processAndConsume(int input,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: void processAndConsume(int input,
- en: Function<Integer, Double> processingFunc,
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 功能<Integer, Double> processingFunc,
- en: Consumer<Double> consumer){
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> consumer){
- en: consumer.accept(processingFunc.apply(input));
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: consumer.accept(processingFunc.apply(input));
- en: '}'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can then write the following code:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以写下面的代码：
- en: '```java'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 功能<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者<Double> printResult = createPrintingFunc("Result=", " Great!");
- en: processAndConsume(10, multiplyByFive, printResult); //Result=50.0 Great!
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: processAndConsume(10, multiplyByFive, printResult); //Result=50.0 Great!
- en: '```'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As we have mentioned before, in the next section, we will introduce lambda expressions
    and will show how they can be used to express the functional interface implementation
    with much less code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，在下一节中，我们将介绍lambda表达式，并展示它们如何用更少的代码来表达函数接口的实现。
- en: Supplier<T>
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 供应商<T>
- en: 'Here is a trick question: guess the input and the output types of the abstract
    method of the `Supplier<T>` interface. The answer is: it accepts no parameters
    and returns the `T` type. As you understand now, the difference is in the name
    of the interface itself. It should give you a hint: the consumer just consumes
    and returns nothing, while the supplier just supplies without any input. The abstract
    method of the `Supplier<T>` interface is `T get()`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个技巧问题：猜猜`Supplier<T>`接口的抽象方法的输入和输出类型是什么。答案是：它不接受任何参数，返回`T`类型。现在你明白了，区别在于接口本身的名称。它应该给你一个提示：消费者只消费而不返回任何东西，而供应商只提供而不需要任何输入。`Supplier<T>`接口的抽象方法是`T
    get()`。
- en: 'Similar to the previous functions, we can write the supplier generating method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的函数类似，我们可以编写生成供应商的方法：
- en: '```java'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> createSuppplier(int num){
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商<Integer> createSuppplier(int num){
- en: Supplier<Integer> func = new Supplier<Integer>() {
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商<Integer> func = new 供应商<Integer>() {
- en: public Integer get() { return num; }
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: public Integer get() { return num; }
- en: '};'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can now write a method that accepts only functions:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写一个只接受函数的方法：
- en: '```java'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void supplyProcessAndConsume(Supplier<Integer> input,
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: void supplyProcessAndConsume(供应商<Integer> input,
- en: Function<Integer, Double> process,
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 功能<Integer, Double> process,
- en: Consumer<Double> consume){
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> consume){
- en: consume.accept(processFunc.apply(input.get()));
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: consume.accept(processFunc.apply(input.get()));
- en: '}'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Notice how the output type of the `input` function is the same as the input
    of the `process` function, which returns the same type as consumed by the `consume` function.
    It makes the following code possible:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`input`函数的输出类型与`process`函数的输入类型相同，它返回的类型与`consume`函数消耗的类型相同。这使得下面的代码成为可能：```
- en: '```java'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> supply7 = createSuppplier(7);
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 供应商<Integer> supply7 = createSuppplier(7);
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 功能<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者<Double> printResult = createPrintingFunc("Result=", " Great!");
- en: supplyProcessAndConsume(supply7, multiplyByFive, printResult);
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: supplyProcessAndConsume(supply7, multiplyByFive, printResult);
- en: '//prints: Result=35.0 Great!'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '//prints: Result=35.0 Great!'
- en: '```'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: At this point, we hope, you start to appreciate the value functional programming
    brings to the table. It allows us to pass around chunks of functionality that
    can be plugged into the middle of an algorithm without needing to create an object.
    Static methods do not require creating an object either, but they are shared by
    all application threads because they are unique in the JVM. Meanwhile, each function
    is an object and can be either unique in the JVM (if assigned to a static variable)
    or created for each processing thread (which typically is the case). It has very
    little coding overhead and can have even less plumbing when used in a lambda expression
    – the topic of our next section.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们希望您开始欣赏函数式编程为我们带来的价值。它允许我们传递功能块，这些功能块可以插入到算法的中间，而无需创建对象。静态方法也不需要创建对象，但它们由JVM中的所有应用程序线程共享，因为它们在JVM中是唯一的。与此同时，每个函数都是一个对象，可以在JVM中是唯一的（如果分配给静态变量）或为每个处理线程创建（这通常是情况）。它的编码开销很小，在lambda表达式中使用时甚至可以更少——这是我们下一节的主题。
- en: So far, we have demonstrated how a function can be plugged into the existing
    control-flow expression. And now we will describe the last missing piece – a function
    that represents the decision-making construct that can be passed around as an
    object too.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经演示了如何将函数插入现有的控制流表达式中。现在我们将描述最后一个缺失的部分——代表决策构造的函数，它也可以作为对象传递。
- en: Predicate<T>
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Predicate<T>
- en: 'This is an interface that represents a Boolean-valued function that has a single
    method: `boolean test(T)`. Here is an example of a method that creates a `Predicate<Integer>`
    function:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个表示布尔值函数的接口，它有一个方法：`boolean test(T)`。以下是一个创建`Predicate<Integer>`函数的方法示例：
- en: '```java'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Predicate<Integer> createTestSmallerThan(int num){
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> createTestSmallerThan(int num){
- en: Predicate<Integer> func = new Predicate<Integer>() {
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> func = new Predicate<Integer>() {
- en: public boolean test(Integer d) {
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean test(Integer d) {
- en: return d < num;
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: return d < num;
- en: '}'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can use it to add some logic to the processing method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用它来向处理方法添加一些逻辑：
- en: '```java'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void supplyDecideProcessAndConsume(Supplier<Integer> input,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: void supplyDecideProcessAndConsume(Supplier<Integer> input,
- en: Predicate<Integer> test,
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test,
- en: Function<Integer, Double> process,
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> process,
- en: Consumer<Double> consume){
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> consume){
- en: int in = input.get();
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: int in = input.get();
- en: if(test.test(in)){
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: if(test.test(in)){
- en: consume.accept(process.apply(in));
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: consume.accept(process.apply(in));
- en: '} else {'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("Input " + in +
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Input " + in +
- en: '" does not pass the test and not processed.");'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '" does not pass the test and not processed.");'
- en: '}'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And the following code demonstrates its usage:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了它的用法：
- en: '```java'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> input = createSuppplier(7);
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = createSuppplier(7);
- en: Predicate<Integer> test = createTestSmallerThan(5);
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test = createTestSmallerThan(5);
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
- en: '//prints: Input 7 does not pass the test and not processed.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：Input 7 does not pass the test and not processed.
- en: '```'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s set the input to 3, for example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以3为例设置输入：
- en: '```java'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> input = createSuppplier(3)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = createSuppplier(3)
- en: '```'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code would result in the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将产生以下输出：
- en: '```java'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Result=15.0 Great!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Result=15.0 Great!
- en: '```'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Other standard functional interfaces
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他标准函数接口
- en: 'The other 39 functional interfaces in the `java.util.function` package are
    variations of the four interfaces we have just reviewed. These variations are
    created in order to achieve one or any combination of the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中的其他39个函数接口是我们刚刚审查的四个接口的变体。这些变体是为了实现以下一个或多个组合：'
- en: Better performance by avoiding autoboxing and unboxing via the explicit usage
    of the integer, double, or long primitives
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过显式使用整数、双精度或长整型原始类型来避免自动装箱和拆箱，从而获得更好的性能
- en: Allowing two input parameters
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许两个输入参数
- en: A shorter notation
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更短的符号
- en: 'Here are just a few of examples:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些示例：
- en: '`IntFunction<R>` with the `R apply(int)` method provides shorter notation (without
    generics for the input parameter type) and avoids autoboxing by requiring the `int` primitive
    as the parameter'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntFunction<R>`具有`R apply(int)`方法，提供了更短的符号（无需为输入参数类型使用泛型），并通过要求`int`原始类型作为参数来避免自动装箱'
- en: '`BiFunction<T,U,R>` with the `R apply(T,U)` method allows two input parameters'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BiFunction<T,U,R>`具有`R apply(T,U)`方法，允许两个输入参数'
- en: '`BinaryOperator<T>` with the `T apply(T,T)` method allows two input parameters
    of the `T` type and returns a value of the same `T` type'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BinaryOperator<T>`具有`T apply(T,T)`方法，允许`T`类型的两个输入参数，并返回相同`T`类型的值'
- en: '`IntBinaryOperator` with the `int applAsInt(int,int)` method accepts two parameters
    of the `int` type and returns the value of the `int` type'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntBinaryOperator`具有`int applAsInt(int,int)`方法，接受两个`int`类型的参数，并返回`int`类型的值'
- en: If you are going to use functional interfaces, we encourage you to study the
    API of the interfaces of the `java.util.functional` package.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要使用函数接口，我们鼓励您研究`java.util.functional`包的接口API。
- en: Chaining standard functions
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接标准函数
- en: 'Most of the functional interfaces in the `java.util.function` package have default
    methods that allow us to build a chain (also called a pipe or pipeline) of functions
    that pass the result of one as the input parameter to another, thus composing
    a new complex function. For example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function`包中的大多数函数接口都有默认方法，允许我们构建一个函数链（也称为管道），将一个函数的结果作为输入参数传递给另一个函数，从而组成一个新的复杂函数。例如：'
- en: '```java'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Double, Long> f1 = d -> Double.valueOf(d / 2.).longValue();
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, Long> f1 = d -> Double.valueOf(d / 2.).longValue();
- en: 'Function<Long, String> f2 = l -> "Result: " + (l + 1);'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 'Function<Long, String> f2 = l -> "Result: " + (l + 1);'
- en: Function<Double, String> f3 = f1.andThen(f2);
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, String> f3 = f1.andThen(f2);
- en: 'System.out.println(f3.apply(4.));            //prints: 3'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(f3.apply(4.));            //打印：3
- en: '```'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see from the preceding code, we have created a new `f3` function
    by combining the `f1` and `f2` functions using the `andThen()` method. That's
    the idea behind the methods we are going to explore in this section. First, we
    express the functions as anonymous classes and, in the following section, we introduce
    the lambda expressions that we used in the preceding example.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的代码中可以看出，我们通过使用`andThen()`方法组合了`f1`和`f2`函数，创建了一个新的`f3`函数。这就是我们将要在本节中探讨的方法的思想。首先，我们将函数表示为匿名类，然后在下一节中，我们将介绍在前面的示例中使用的lambda表达式。
- en: Chain two Function<T,R>
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接两个Function<T,R>
- en: 'We can use the `andThen(Function after)` default method of the `Function` interface.
    We have already created the `Function<Integer, Double> createMultiplyBy()` method:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Function`接口的`andThen(Function after)`默认方法。我们已经创建了`Function<Integer, Double>
    createMultiplyBy()`方法：
- en: '```java'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> createMultiplyBy(double num){
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> createMultiplyBy(double num){
- en: Function<Integer, Double> func = new Function<Integer, Double>(){
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> func = new Function<Integer, Double>(){
- en: public Double apply(Integer i){
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: public Double apply(Integer i){
- en: return i * num;
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 返回i * num;
- en: '}'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '```'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can also write another method that creates a subtracting function with the `Double` input
    type, so we can chain it to the multiplying function:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以编写另一个方法，创建一个带有`Double`输入类型的减法函数，这样我们就可以将其链接到乘法函数：
- en: '```java'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: private static Function<Double, Long> createSubtractInt(int num){
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: private static Function<Double, Long> createSubtractInt(int num){
- en: Function<Double, Long> func = new Function<Double, Long>(){
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, Long> func = new Function<Double, Long>(){
- en: public Long apply(Double dbl){
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: public Long apply(Double dbl){
- en: return Math.round(dbl - num);
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Math.round(dbl - num);
- en: '}'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 返回func;
- en: '}'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now we can write the following code:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写以下代码：
- en: '```java'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: 'System.out.println(multiplyByFive.apply(2));  //prints: 10.0'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(multiplyByFive.apply(2));  //打印：10.0
- en: Function<Double, Long> subtract7 = createSubtractInt(7);
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, Long> subtract7 = createSubtractInt(7);
- en: 'System.out.println(subtract7.apply(11.0));   //prints: 4'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(subtract7.apply(11.0));   //打印：4
- en: long r = multiplyByFive.andThen(subtract7).apply(2);
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: long r = multiplyByFive.andThen(subtract7).apply(2);
- en: 'System.out.println(r);                          //prints: 3'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);                          //打印：3
- en: '```'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the `multiplyByFive.andThen(subtract7)` chain acts effectively
    as `Function<Integer, Long> multiplyByFiveAndSubtractSeven`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`multiplyByFive.andThen(subtract7)`链实际上是`Function<Integer, Long> multiplyByFiveAndSubtractSeven`。
- en: 'The `Function` interface has another default method, `Function<V,R> compose(Function<V,T>
    before)`, that also allows us to chain two functions. The function that has to
    be executed first can be passed as the `before` parameter into the `compose()` method
    of the second function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function`接口还有另一个默认方法，`Function<V,R> compose(Function<V,T> before)`，它也允许我们链接两个函数。必须首先执行的函数可以作为`before`参数传递到第二个函数的`compose()`方法中：'
- en: '```java'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: boolean r = subtract7.compose(multiplyByFive).apply(2);
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: boolean r = subtract7.compose(multiplyByFive).apply(2);
- en: 'System.out.println(r);                          //prints: 3'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);                          //打印：3
- en: '```'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Chain two Consumer<T>
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接两个Consumer<T>
- en: 'The `Consumer` interface has the `andThen(Consumer after)` method too. We have
    already written the method that creates the printing function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer`接口也有`andThen(Consumer after)`方法。我们已经编写了创建打印函数的方法：'
- en: '```java'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> createPrintingFunc(String prefix, String postfix){
- en: Consumer<Double> func = new Consumer<Double>() {
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> func = new Consumer<Double>() {
- en: public void accept(Double d) {
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: public void accept(Double d) {
- en: System.out.println(prefix + d + postfix);
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(prefix + d + postfix);
- en: '}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'And now we can create and chain two printing functions, as follows:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建并链接两个打印函数，如下所示：
- en: '```java'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Consumer<Double> print21By = createPrintingFunc("21 by ", "");
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> print21By = createPrintingFunc("21 by ", "");
- en: Consumer<Double> equalsBy21 = createPrintingFunc("equals ", " by 21");
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> equalsBy21 = createPrintingFunc("equals ", " by 21");
- en: print21By.andThen(equalsBy21).accept(2d);
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: print21By.andThen(equalsBy21).accept(2d);
- en: '//prints: 21 by 2.0'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：21 by 2.0
- en: //        equals 2.0 by 21
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: // 由21等于2.0
- en: '```'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see in the `Consumer` chain, both functions consume the same value
    in the sequence defined by the chain.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在`Consumer`链中所看到的，两个函数按照链条定义的顺序消耗相同的值。
- en: Chain two Predicate<T>
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接两个Predicate<T>
- en: 'The `Supplier` interface does not have default methods, while the `Predicate` interface
    has one static method, `isEqual(Object targetRef)`, and three default methods:
    `and(Predicate other)`, `negate()`, and `or(Predicate other)`. To demonstrate
    usage of the `and(Predicate other)` and `or(Predicate other)` methods, for example,
    let''s write the methods that create two `Predicate<Double>` functions. One function
    checks whether the value is smaller than the input:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`Supplier`接口没有默认方法，而`Predicate`接口有一个静态方法`isEqual(Object targetRef)`和三个默认方法：`and(Predicate
    other)`、`negate()`和`or(Predicate other)`。为了演示`and(Predicate other)`和`or(Predicate
    other)`方法的使用，例如，让我们编写创建两个`Predicate<Double>`函数的方法。一个函数检查值是否小于输入：'
- en: '```java'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Predicate<Double> testSmallerThan(double limit){
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> testSmallerThan(double limit){
- en: Predicate<Double> func = new Predicate<Double>() {
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> func = new Predicate<Double>() {
- en: public boolean test(Double num) {
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean test(Double num) {
- en: System.out.println("Test if " + num + " is smaller than " + limit);
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Test if " + num + " is smaller than " + limit);
- en: return num < limit;
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 返回num < limit;
- en: '}'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 返回func;
- en: '}'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Another function checks whether the value is bigger than the input:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数检查值是否大于输入：
- en: '```java'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Predicate<Double> testBiggerThan(double limit){
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> testBiggerThan(double limit){
- en: Predicate<Double> func = new Predicate<Double>() {
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> func = new Predicate<Double>() {
- en: public boolean test(Double num) {
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: public boolean test(Double num) {
- en: System.out.println("Test if " + num + " is bigger than " + limit);
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Test if " + num + " is bigger than " + limit);
- en: return num > limit;
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 返回num > limit;
- en: '}'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: return func;
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Now we can create two `Predicate<Double>` functions and chain them:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建两个 `Predicate<Double>` 函数并将它们链接起来：
- en: '```java'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Predicate<Double> isSmallerThan20 = testSmallerThan(20d);
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> isSmallerThan20 = testSmallerThan(20d);
- en: System.out.println(isSmallerThan20.test(10d));
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(isSmallerThan20.test(10d));
- en: '//prints: Test if 10.0 is smaller than 20.0'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：测试10.0是否小于20.0
- en: //        true
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: //        true
- en: Predicate<Double> isBiggerThan18 = testBiggerThan(18d);
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Double> isBiggerThan18 = testBiggerThan(18d);
- en: System.out.println(isBiggerThan18.test(10d));
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(isBiggerThan18.test(10d));
- en: '//prints: Test if 10.0 is bigger than 18.0'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：测试10.0是否大于18.0
- en: //        false
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: //        false
- en: boolean b = isSmallerThan20.and(isBiggerThan18).test(10.);
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: boolean b = isSmallerThan20.and(isBiggerThan18).test(10.);
- en: System.out.println(b);
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);
- en: '//prints: Test if 10.0 is smaller than 20.0'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：测试10.0是否小于20.0
- en: //        Test if 10.0 is bigger than 18.0
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: //        测试10.0是否大于18.0
- en: //        false
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: //        false
- en: b = isSmallerThan20.or(isBiggerThan18).test(10.);
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: b = isSmallerThan20.or(isBiggerThan18).test(10.);
- en: System.out.println(b);
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(b);
- en: '//prints: Test if 10.0 is smaller than 20.0'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: //打印：测试10.0是否小于20.0
- en: //        true
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: //        true
- en: '```'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the `and()` method required execution of each of the functions,
    while the `or()` method did not execute the second function as soon as the first
    one in the chain returned `true`.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`and()` 方法需要执行每个函数，而 `or()` 方法在链中的第一个函数返回 `true` 时不执行第二个函数。
- en: identity() and other default methods
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: identity() 和其他默认方法
- en: 'Functional interfaces of the `java.util.function` package have other helpful
    default methods. The one that stands out is the `identity()` method, which returns
    a function that always returns its input argument:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.function` 包的函数接口还有其他有用的默认方法。其中最突出的是 `identity()` 方法，它返回一个始终返回其输入参数的函数：'
- en: '```java'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Integer> id = Function.identity();
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Integer> id = Function.identity();
- en: 'System.out.println(id.apply(4));          //prints: 4'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(id.apply(4));          //打印：4
- en: '```'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The `identity()` method is very helpful when some procedure requires providing
    a certain function, but you do not want the provided function to change anything.
    In such cases, you create an identity function with the necessary output type.
    For example, in one of our previous code snippets, we may decide that the `multiplyByFive`
    function should not change anything in the `multiplyByFive.andThen(subtract7)`
    chain:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`identity()` 方法在某些程序需要提供某个函数，但你不希望提供的函数改变任何东西时非常有用。在这种情况下，你可以创建一个具有必要输出类型的恒等函数。例如，在我们之前的代码片段中，我们可能决定
    `multiplyByFive` 函数不应该在 `multiplyByFive.andThen(subtract7)` 链中改变任何东西：'
- en: '```java'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Double, Double> multiplyByFive = Function.identity();
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, Double> multiplyByFive = Function.identity();
- en: 'System.out.println(multiplyByFive.apply(2.));  //prints: 2.0'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(multiplyByFive.apply(2.));  //打印：2.0
- en: Function<Double, Long> subtract7 = createSubtractInt(7);
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Double, Long> subtract7 = createSubtractInt(7);
- en: 'System.out.println(subtract7.apply(11.0));    //prints: 4'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(subtract7.apply(11.0));    //打印：4
- en: long r = multiplyByFive.andThen(subtract7).apply(2.);
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: long r = multiplyByFive.andThen(subtract7).apply(2.);
- en: 'System.out.println(r);                       //prints: -5'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(r);                       //打印：-5
- en: '```'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: As you can see, the  `multiplyByFive` function did not do anything with the
    input parameter `2`, so the result (after `7` was subtracted) is `-5`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`multiplyByFive` 函数没有对输入参数 `2` 做任何处理，所以结果（减去 `7` 后）是 `-5`。
- en: Other default methods are mostly related to conversion and boxing and unboxing,
    but also extracting minimum and maximum values of two parameters. If you are interested,
    you can look through the API of interfaces of the `java.util.function` package
    and get a feeling for the possibilities.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 其他默认方法大多与转换和装箱和拆箱有关，但也包括提取两个参数的最小值和最大值。如果你感兴趣，可以查看一下 `java.util.function` 包接口的API，了解一下可能性。
- en: Lambda expressions
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda表达式
- en: The examples in the previous section (that used anonymous classes for the implementation
    of functional interfaces) looked bulky and felt excessively verbose. For one,
    there was no need to repeat the interface name, because we had declared it already
    as the type for the object reference. And, second, in the case of a functional
    interface that had only one abstract method, there is no need to specify the method
    name that has to be implemented. The compiler and Java runtime can figure it out.
    All we need is to provide the new functionality. Lambda expressions were introduced
    for exactly this purpose.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中的示例（使用匿名类实现函数接口）看起来笨重且过于冗长。首先，没有必要重复接口名称，因为我们已经将其声明为对象引用的类型。其次，在只有一个抽象方法的函数接口的情况下，没有必要指定必须实现的方法名称。编译器和Java运行时可以弄清楚。我们只需要提供新的功能。Lambda表达式就是为了这个目的而引入的。
- en: What is a lambda expression?
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是lambda表达式？
- en: The term lambda comes from lambda calculus—a universal model of computation
    that can be used to simulate any Turing machine. It was introduced by mathematician,
    Alonzo Church, in the 1930s. A lambda expression is a function, implemented in
    Java as an anonymous method, that also allows us to omit modifiers, return types,
    and parameter types. That makes for a very compact notation.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 术语lambda来自于lambda演算——一种通用的计算模型，可以用来模拟任何图灵机。它是由数学家阿隆佐·邱奇在20世纪30年代引入的。lambda表达式是一个函数，在Java中实现为匿名方法，它还允许我们省略修饰符、返回类型和参数类型。这使得它的表示非常紧凑。
- en: The syntax of a lambda expression includes the list of parameters, an arrow
    token `->`, and a body. The list of parameters can be empty `()`, without brackets
    (if there is only one parameter), or a comma-separated list of parameters surrounded
    by brackets. The body can be a single expression or a statement block.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式的语法包括参数列表、箭头标记 `->` 和主体。参数列表可以是空的 `()`，如果只有一个参数，则不需要括号，或者由括号括起来的逗号分隔的参数列表。主体可以是单个表达式或语句块。
- en: 'Let us look at a few examples:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一些例子：
- en: '`() -> 42;` always returns `42`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`() -> 42;` 总是返回 `42`'
- en: '`x -> x + 1;` increments the `x` variable by `1`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -> x + 1;` 将 `x` 变量增加 `1`'
- en: '`(x, y) -> x * y;` multiplies `x` by `y` and returns the result'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(x, y) -> x * y;` multiplies `x` by `y` and returns the result'
- en: '`(char x) -> x == ''$'';` compares the value of the `x` variable and the `$` symbol,
    and returns a Boolean value'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`(char x) -> x == ''$'';` compares the value of the `x` variable and the `$` symbol,
    and returns a Boolean value'
- en: '`x -> {  System.out.println("x=" + x); };` prints the `x` value with the `x=` prefix'
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x -> {  System.out.println("x=" + x); };` prints the `x` value with the `x=` prefix'
- en: Re-implementing functions
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Re-implementing functions
- en: 'We can rewrite our functions, created in the previous section, using lambda
    expressions, as follows:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can rewrite our functions, created in the previous section, using lambda
    expressions, as follows:'
- en: '```java'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> createMultiplyBy(double num){
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> createMultiplyBy(double num){
- en: Function<Integer, Double> func = i -> i * num;
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> func = i -> i * num;
- en: return func;
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Consumer<Double> createPrintingFunc(String prefix, String postfix){
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> createPrintingFunc(String prefix, String postfix){
- en: Consumer<Double> func = d -> System.out.println(prefix + d + postfix);
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> func = d -> System.out.println(prefix + d + postfix);
- en: return func;
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Supplier<Integer> createSuppplier(int num){
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> createSuppplier(int num){
- en: Supplier<Integer> func = () -> num;
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> func = () -> num;
- en: return func;
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: Predicate<Integer> createTestSmallerThan(int num){
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> createTestSmallerThan(int num){
- en: Predicate<Integer> func = d -> d < num;
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> func = d -> d < num;
- en: return func;
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: return func;
- en: '}'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: We don't repeat the name of the implemented interface because it is specified
    as the return type in the method signature. And we do not specify the name of
    the abstract method either because it is the only method of the interface that
    has to be implemented. Writing such a compact and efficient code became possible
    because of the combination of the lambda expression and functional interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: We don't repeat the name of the implemented interface because it is specified
    as the return type in the method signature. And we do not specify the name of
    the abstract method either because it is the only method of the interface that
    has to be implemented. Writing such a compact and efficient code became possible
    because of the combination of the lambda expression and functional interface.
- en: 'Looking at the preceding examples, you probably realize that there is no need
    to have methods that create a function anymore. Let''s change the code that calls
    the `supplyDecideProcessAndConsume()` method:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 'Looking at the preceding examples, you probably realize that there is no need
    to have methods that create a function anymore. Let''s change the code that calls
    the `supplyDecideProcessAndConsume()` method:'
- en: '```java'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: void supplyDecideProcessAndConsume(Supplier<Integer> input,
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: void supplyDecideProcessAndConsume(Supplier<Integer> input,
- en: Predicate<Integer> test,
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test,
- en: Function<Integer, Double> process,
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> process,
- en: Consumer<Double> consume){
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> consume){
- en: int in = input.get();
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: int in = input.get();
- en: if(test.test(in)){
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: if(test.test(in)){
- en: consume.accept(process.apply(in));
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: consume.accept(process.apply(in));
- en: '} else {'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: System.out.println("Input " + in +
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Input " + in +
- en: '" does not pass the test and not processed.");'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '" does not pass the test and not processed.");'
- en: '}'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'Let''s revisit the following lines:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 'Let''s revisit the following lines:'
- en: '```java'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> input = createSuppplier(7);
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = createSuppplier(7);
- en: Predicate<Integer> test = createTestSmallerThan(5);
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test = createTestSmallerThan(5);
- en: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = createMultiplyBy(5);
- en: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult = createPrintingFunc("Result=", " Great!");
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
- en: '```'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can change the preceding code to the following without changing the functionality:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can change the preceding code to the following without changing the functionality:'
- en: '```java'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> input = () -> 7;
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = () -> 7;
- en: Predicate<Integer> test = d -> d < 5.;
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test = d -> d < 5.;
- en: Function<Integer, Double> multiplyByFive = i -> i * 5.;;
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = i -> i * 5.;;
- en: Consumer<Double> printResult =
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult =
- en: d -> System.out.println("Result=" + d + " Great!");
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: d -> System.out.println("Result=" + d + " Great!");
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
- en: '```'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'We can even inline the preceding functions and write the preceding code in
    one line like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 'We can even inline the preceding functions and write the preceding code in
    one line like this:'
- en: '```java'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
- en: d -> System.out.println("Result=" + d + " Great!"));
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: d -> System.out.println("Result=" + d + " Great!"));
- en: '```'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Notice how much more transparent the definition of the printing function has
    become. That is the power and the beauty of lambda expressions in combination
    with functional interfaces. In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*, you will see that lambda expressions are, in fact, the
    only way to process streamed data.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Notice how much more transparent the definition of the printing function has
    become. That is the power and the beauty of lambda expressions in combination
    with functional interfaces. In [Chapter 18](be052e15-ac84-4e19-9bd9-24548aa3f904.xhtml),
    *Streams and Pipelines*, you will see that lambda expressions are, in fact, the
    only way to process streamed data.
- en: Lambda limitations
  id: totrans-421
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda limitations
- en: 'There are two aspects of a lambda expression that we would like to point out
    and clarify, which are:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'There are two aspects of a lambda expression that we would like to point out
    and clarify, which are:'
- en: If a lambda expression uses a local variable created outside it, this local
    variable has to be final or effectively final (not re-assigned in the same context)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: If a lambda expression uses a local variable created outside it, this local
    variable has to be final or effectively final (not re-assigned in the same context)
- en: The `this` keyword in a lambda expression refers to the enclosing context, and
    not the lambda expression itself
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `this` keyword in a lambda expression refers to the enclosing context, and
    not the lambda expression itself
- en: Effectively final local variable
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Effectively final local variable
- en: 'As in the anonymous class, the variable, created outside and used inside the
    lambda expression, becomes effectively final and cannot be modified. You can write
    the following:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 'As in the anonymous class, the variable, created outside and used inside the
    lambda expression, becomes effectively final and cannot be modified. You can write
    the following:'
- en: '```java'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: int x = 7;
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: int x = 7;
- en: //x = 3;       //compilation error
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: //x = 3;       //compilation error
- en: int y = 5;
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: int y = 5;
- en: double z = 5.;
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: double z = 5.;
- en: supplyDecideProcessAndConsume(() -> x, d -> d < y, i -> i * z,
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(() -> x, d -> d < y, i -> i * z,
- en: d -> { //x = 3;      //compilation error
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: d -> { //x = 3;      //compilation error
- en: System.out.println("Result=" + d + " Great!"); } );
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Result=" + d + " Great!"); } );
- en: '```'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But, as you can see, we cannot change the value of the local variable used in
    the lambda expression. The reason for this restriction is that a function can
    be passed around and executed in different contexts (different threads, for example),
    and the attempt to synchronize these contexts would defeat the original idea of
    the stateless function and independent distributed evaluation of the expression.
    That is why all the local variables used in the lambda expression are effectively
    final, meaning that they can either be declared final explicitly or become final
    by virtue of their usage in a lambda expression.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，正如你所看到的，我们无法改变lambda表达式中使用的局部变量的值。这种限制的原因是函数可以在不同的上下文（例如不同的线程）中传递并执行，尝试同步这些上下文将破坏*无状态函数*和表达式的独立分布式评估的原始想法。这就是为什么lambda表达式中使用的所有局部变量实际上都是final的原因，这意味着它们可以显式地声明为final，也可以通过在lambda表达式中使用而变为final。
- en: 'There is one possible workaround for this limitation. If the local variable
    is of a reference type (but not `String` or a primitive wrapping type), it is
    possible to change its state even if this local variable is used in the lambda
    expression:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这种限制有一个可能的变通方法。如果局部变量是引用类型（但不是`String`或原始包装类型），即使该局部变量在lambda表达式中使用，也可以改变其状态：
- en: '```java'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class A {
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: class A {
- en: private int x;
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: private int x;
- en: public int getX(){ return this.x; }
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: public int getX(){ return this.x; }
- en: public void setX(int x){ this.x = x; }
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: public void setX(int x){ this.x = x; }
- en: '}'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: void localVariable2(){
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: void localVariable2(){
- en: A a = new A();
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: A a = new A();
- en: a.setX(7);
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: a.setX(7);
- en: a.setX(3);
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: a.setX(3);
- en: int y = 5;
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: int y = 5;
- en: double z = 5.;
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: double z = 5.;
- en: supplyDecideProcessAndConsume(() -> a.getX(), d -> d < y, i -> i * z,
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(() -> a.getX(), d -> d < y, i -> i * z,
- en: d -> { a.setX(5);
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: d -> { a.setX(5);
- en: System.out.println("Result=" + d + " Great!"); } );
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Result=" + d + " Great!"); } );
- en: '}'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: But this workaround should be used only when really needed and has to be done
    with care because of the danger of unexpected side effects.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种变通方法只有在真正需要时才应该使用，并且必须小心操作，因为存在意外副作用的危险。
- en: The this keyword interpretation
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: this关键字的解释
- en: One principal difference between the anonymous class and lambda expressions
    is the interpretation of the `this` keyword. Inside an anonymous class, it refers
    to the instance of the anonymous class. Inside a lambda expression, `this` refers
    to the instance of the class that surrounds the expression, also called an *enclosing
    instance*, *enclosing context*, or *enclosing scope*.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类和lambda表达式之间的一个主要区别是对`this`关键字的解释。在匿名类中，它指的是匿名类的实例。在lambda表达式中，`this`指的是包围表达式的类实例，也称为*包围实例*、*包围上下文*或*包围范围*。
- en: 'Let''s write a `ThisDemo` class that illustrates the difference:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个`ThisDemo`类来说明这种差异：
- en: '```java'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: class ThisDemo {
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: class ThisDemo {
- en: private String field = "ThisDemo.field";
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: private String field = "ThisDemo.field";
- en: public void useAnonymousClass() {
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: public void useAnonymousClass() {
- en: Consumer<String> consumer = new Consumer<>() {
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<String> consumer = new Consumer<>() {
- en: private String field = "AnonymousClassConsumer.field";
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: private String field = "AnonymousClassConsumer.field";
- en: public void accept(String s) {
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: public void accept(String s) {
- en: System.out.println(this.field);
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(this.field);
- en: '}'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: consumer.accept(this.field);
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: consumer.accept(this.field);
- en: '}'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public void useLambdaExpression() {
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: public void useLambdaExpression() {
- en: Consumer<String> consumer = consumer = s -> {
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<String> consumer = consumer = s -> {
- en: System.out.println(this.field);
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println(this.field);
- en: '};'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '};'
- en: consumer.accept(this.field);
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: consumer.accept(this.field);
- en: '}'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'As you can see, `this` inside the anonymous class refers to the anonymous class
    instance, while `this` in the lambda expression refers to the enclosing class
    instance. Lambda expressions just do not have and cannot have a field. If we execute
    the preceding methods, the output confirms our assumptions:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，匿名类中的`this`指的是匿名类实例，而lambda表达式中的`this`指的是包围表达式的类实例。Lambda表达式根本没有字段，也不能有字段。如果我们执行前面的方法，输出将确认我们的假设：
- en: '```java'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: ThisDemo d = new ThisDemo();
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ThisDemo d = new ThisDemo();
- en: 'd.useAnonymousClass();   //prints: AnonymousClassConsumer.field'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: d.useAnonymousClass();   //输出：AnonymousClassConsumer.field
- en: 'd.useLambdaExpression(); //prints: ThisDemo.field'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: d.useLambdaExpression(); //输出：ThisDemo.field
- en: '```'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The lambda expression is not a class instance and cannot be referred to by `this`.
    According to Java Specification, such an approach *allows more flexibility for
    implementations* by *treating [this] the same as in the surrounding context.*
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: lambda表达式不是类实例，也不能被`this`引用。根据Java规范，这种方法*允许更多的实现灵活性*，*将[this]视为与周围上下文中的相同*。
- en: Method references
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法引用
- en: 'Let''s look at our last implementation of the call to the `supplyDecidePprocessAndConsume()` method:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们对`supplyDecidePprocessAndConsume()`方法的最后一个实现：
- en: '```java'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(() -> 7, d -> d < 5, i -> i * 5.,
- en: d -> System.out.println("Result=" + d + " Great!"));
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: d -> System.out.println("Result=" + d + " Great!"));
- en: '```'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The functions we have used are pretty trivial. In real-life code, each of them
    may require a multiple-line implementation. In such a case, to put a code block
    inline would make the code almost unreadable. In such cases, referring to the
    methods with the necessary implementation helps. Let''s assume we have the following `Helper` class:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的函数都相当简单。在实际代码中，每个函数可能需要多行实现。在这种情况下，将代码块内联会使代码几乎无法阅读。在这种情况下，引用具有必要实现的方法是有帮助的。假设我们有以下`Helper`类：
- en: '```java'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Helper {
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: public class Helper {
- en: public double calculateResult(int i){
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: public double calculateResult(int i){
- en: // Maybe many lines of code here
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: // 这里可能有很多行代码
- en: return i* 5;
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: return i* 5;
- en: '}'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: public static void printResult(double d){
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: public static void printResult(double d){
- en: // Maybe many lines of code here
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: // 这里可能有很多行代码
- en: System.out.println("Result=" + d + " Great!");
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: System.out.println("Result=" + d + " Great!");
- en: '}'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The lambda expressions in the `Lambdas` class may refer to the methods of the
    `Helper` and `Lambdas` classes, as follows:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lambdas`类中的lambda表达式可以引用`Helper`和`Lambdas`类的方法，如下所示：'
- en: '```java'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: public class Lambdas {
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: public class Lambdas {
- en: public void methodReference() {
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: public void methodReference() {
- en: Supplier<Integer> input = () -> generateInput();
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = () -> generateInput();
- en: Predicate<Integer> test = d -> checkValue(d);
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test = d -> checkValue(d);
- en: Function<Integer, Double> multiplyByFive =
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive =
- en: i -> new Helper().calculateResult(i);
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将使读者熟悉数据流处理的强大概念。它解释了流是什么，如何创建它们并处理它们的元素，以及如何构建处理管道。它还展示了如何轻松地将流处理组织成并行处理。
- en: Consumer<Double> printResult = d -> Helper.printResult(d);
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult = d -> Helper.printResult(d);
- en: supplyDecideProcessAndConsume(input, test,
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法引用来表示创建一个新对象。假设我们有`class A{}`。用另一个使用方法引用的`Supplier`函数声明替换以下内容：
- en: multiplyByFive, printResult);
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
- en: '}'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private int generateInput(){
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: private int generateInput(){
- en: // Maybe many lines of code here
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: // 这里可能有很多行代码
- en: return 7;
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: return 7;
- en: '}'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: private static boolean checkValue(double d){
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: private static boolean checkValue(double d){
- en: // Maybe many lines of code here
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 答案
- en: return d < 5;
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: return d < 5;
- en: '}'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<A> supplier = A::new;
- en: '}'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: // 这里可能有很多行代码
- en: '```'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: 'The preceding code reads better already, and the functions may be inlined again:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码已经读起来更好了，函数可以再次内联：
- en: '```java'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: supplyDecideProcessAndConsume(() -> generateInput(), d -> checkValue(d),
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(() -> generateInput(), d -> checkValue(d),
- en: i -> new Helper().calculateResult(i), Helper.printResult(d));
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: i -> new Helper().calculateResult(i), Helper.printResult(d));
- en: '```'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(input, test,
- en: But in such cases, the notation can be made even more compact. When a one-line
    lambda expression consists of a reference to an existing method, it is possible
    to further simplify the notation by using a method reference without listing the
    parameters.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，表示法甚至可以更加简洁。当一行lambda表达式由对现有方法的引用组成时，可以通过使用方法引用进一步简化表示法，而无需列出参数。
- en: The syntax of the method reference is `Location::methodName`, where `Location`
    indicates where (in which object or class) the `methodName` method can be found,
    and the two colons (`::`) serve as a separator between the location and the method
    name. If there are several methods with the same name at the specified location
    (because of the method overload), the reference method is identified by the signature
    of the abstract method of the functional interface implemented by the lambda expression.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 方法引用的语法是`Location::methodName`，其中`Location`表示可以找到`methodName`方法的位置（在哪个对象或类中），两个冒号（`::`）作为位置和方法名之间的分隔符。如果在指定位置有多个同名方法（因为方法重载），则引用方法由lambda表达式实现的函数式接口的抽象方法的签名来确定。
- en: 'Using the method reference, the preceding code under `methodReference()` method
    in the `Lambdas` class can be rewritten as follows:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法引用，`Lambdas`类中`methodReference()`方法下的前述代码可以重写如下：
- en: '```java'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<Integer> input = this::generateInput;
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: Function<Integer, Double> multiplyByFive = new Helper()::calculateResult;;
- en: Predicate<Integer> test = Lambdas::checkValue;
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Function<Integer, Double> multiplyByFive = new Helper()::calculateResult;;
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述文本按行翻译成中文，不要输出原文：
- en: Consumer<Double> printResult = Helper::printResult;
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: supplyDecideProcessAndConsume(input, test, multiplyByFive, printResult);
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '```'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: multiplyByFive, printResult);
- en: 'To inline such functions makes even more sense:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 要内联这样的函数更有意义：
- en: '```java'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: supplyDecideProcessAndConsume(this::generateInput, Lambdas::checkValue,
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: supplyDecideProcessAndConsume(this::generateInput, Lambdas::checkValue,
- en: new Helper()::calculateResult, Helper::printResult);
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: new Helper()::calculateResult, Helper::printResult);
- en: '```'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Consumer<Double> printResult = Helper::printResult;
- en: You have probably noticed that we have intentionally used different locations
    and two instance methods and two static methods in order to demonstrate the variety
    of possibilities.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们故意在不同位置使用了两个实例方法和两个静态方法，以展示各种可能性。
- en: If it feels like too much to remember, the good news is that a modern IDE (IntelliJ
    IDEA is one example) can do it for you and convert the code you are writing into
    the most compact form.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 如果感觉记住太多，好消息是现代IDE（例如IntelliJ IDEA）可以为您完成，并将您正在编写的代码转换为最紧凑的形式。
- en: Exercise – Using the method reference to create a new object
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习 - 使用方法引用创建一个新对象
- en: 'Use the method reference to express creating a new object. Let''s assume that
    we have `class A{}`. Replace the following `Supplier` function declaration with
    another one that uses the method reference:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: Predicate<Integer> test = Lambdas::checkValue;
- en: '```java'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<A> supplier = () -> new A();
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<A> supplier = () -> new A();
- en: '```'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了函数式编程的概念。它概述了JDK提供的函数式接口，并演示了如何使用它们。它还讨论并演示了lambda表达式以及它们如何有效地提高代码的可读性。
- en: Answer
  id: totrans-554
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: i -> new Helper().calculateResult(i);
- en: 'The answer is:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是：
- en: '```java'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '```java'
- en: Supplier<A> supplier = A::new;
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Supplier<Integer> input = this::generateInput;
- en: '```'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: Summary
  id: totrans-559
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter introduced the concept of functional programming. It provided an
    overview of the functional interfaces that come with JDK and demonstrated how
    to use them. It also discussed and demonstrated lambda expressions and how effectively
    they can improve code readability.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
- en: The next chapter will make the reader familiar with the powerful concept of
    datastreams processing. It explains what streams are, how to create them and process
    their elements, and how to build processing pipelines. It also shows how easily
    you can organize stream processing in parallel.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '```'
