- en: 'Chapter 10. Demonstrating Functional Reactive Programming in JavaScript: A
    Live Example Part III – A Calendar'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。在JavaScript中演示函数式响应式编程：一个实时示例第III部分-日历
- en: This chapter will be the most involved in the book. Throughout the book, there
    have been minor to not-so-minor differences between chapters. These are intended
    so that if you meet a fork in the road, this book offers coverage to both options.
    The chapters are intended to be complementary, instead of hitting the same note
    all the time. Here, we will not be revealing much more about core ReactJS, but
    show how to engage a problem with the thorniness of real-world business problems,
    and a solution that engages ReactJS but is not focused on it. We will be engaging
    ReactJS on a more serious application, a calendar with support for recurring events
    that offers more sophistication and power than, for instance, Google Calendar,
    as seen in the upcoming figures. *If you have a 7:00 PM second and fourth Thursdays
    each month Toastmasters' Club meeting, it's supported!* The core functionality
    is very much intended not to be a mere toy.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是本书中最复杂的部分。在整本书中，各章之间存在着从轻微到不那么轻微的差异。这些差异是有意为之的，以便如果你在岔路口遇到了困难，本书可以覆盖两种选择。这些章节旨在相辅相成，而不是一直强调同一点。在这里，我们不会透露关于核心ReactJS的更多信息，而是展示如何应对现实世界中棘手的商业问题，以及一个涉及ReactJS但并非专注于它的解决方案。我们将在一个更严肃的应用程序中使用ReactJS，一个支持重复事件的日历，提供的功能和能力比如Google日历更加复杂和强大，如下图所示。*如果你每个月第二和第四个星期四晚上7:00有Toastmasters俱乐部会议，这个日历都支持！*核心功能的目的绝不是玩具。
- en: 'In this chapter, we will discuss the following points:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下几点：
- en: Learning about calendars with repeating calendar entries
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解具有重复日历条目的日历
- en: The nuts and bolts for a class and its Hijaxed form
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类及其Hijaxed形式的要点
- en: The basic data types—plain old JavaScript objects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本数据类型-普通的JavaScript对象
- en: A rendering function—an outer wrapper
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个渲染函数-外部包装器
- en: Rendering the page—a one-time calendar entry UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染页面-一次性日历条目UI
- en: An expanded user interface for recurring calendar entries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复日历条目的扩展用户界面
- en: Rendering calendar entries—anonymous helper functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 渲染日历条目-匿名辅助函数
- en: The main loop for displaying calendar entries
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示日历条目的主循环
- en: Sorting each day's calendar entries for display
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对每天的日历条目进行排序以显示
- en: Supporting Markdown in calendar entry descriptions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持日历条目描述中的Markdown
- en: Working on one main component at a time
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只处理一个主要组件
- en: Play it again Sam – an interesting challenge
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 再来一次山姆-一个有趣的挑战
- en: 'The following is a sample screenshot showing how you enter a repeating entry
    in Google Calendar:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例屏幕截图，显示了如何在Google日历中输入重复条目：
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![再来一次山姆-一个有趣的挑战](img/B04108_10_01.jpg)'
- en: 'This calendar system is inspired by a private calendar system that uses regular
    expressions matched against a date string, like this: `Wed Apr 29 18:13:24 CDT`.
    Also, there is really quite a lot that can be done with the power of regular expressions.
    An entry to *check car engine fluids*, for instance, *every first Saturday of
    even-numbered months*, is `periodic_Sat.(Feb|Apr|Jun|Aug|Oct|Dec).( 1| 2| 3| 4|
    5| 6| 7)..................,Check fluid levels in car`. This, however, is nothing
    compared to the hairy beast of a truly complex regular expression. But it does
    give a hint on why regular expressions are considered write-only code. It may
    be guessed that even if you are a regular expression writer, you put off checking
    until later (if you have to). In other words, you don''t want to check whether
    the regular expression quoted earlier in this paragraph matches the date for the
    first Saturdays of even-numbered months. This is the effect that regular expressions
    have on programmers, and this regular expression is elegant compared to a URL
    regular expression, which begins like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这个日历系统受到了一个使用正则表达式匹配日期字符串的私人日历系统的启发，就像这样：`Wed Apr 29 18:13:24 CDT`。此外，使用正则表达式确实可以做很多事情。例如，*每个偶数月的第一个星期六*的*检查汽车发动机液体*条目是`periodic_Sat.(Feb|Apr|Jun|Aug|Oct|Dec).(
    1| 2| 3| 4| 5| 6| 7)..................,Check fluid levels in car`。然而，这与一个真正复杂的正则表达式相比微不足道。但这确实暗示了为什么正则表达式被认为是只能写不能读的代码。可以猜测，即使你是一个正则表达式的作者，你也会推迟检查（如果必须的话）。换句话说，你不想检查之前段落中引用的正则表达式是否匹配偶数月的第一个星期六的日期。这就是正则表达式对程序员的影响，而这个正则表达式与URL正则表达式相比是优雅的，URL正则表达式是这样开始的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in this chapter is intended to be readable, at times slowly and laboriously,
    but very clearly without a trace of regular expressions. It has been said that
    a programmer has a problem with strings, and says, "I know! I'll use regular expressions!"
    Now the programmer has two problems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码旨在可读性，有时会慢慢地费力地，但非常清晰，没有任何正则表达式的痕迹。有人说程序员遇到字符串问题时会说：“我知道！我会用正则表达式！”现在程序员有了两个问题。
- en: In my own experience, I've been using regular expressions for years, and they
    are by far, byte for byte, my most effective defect injection method, and I often
    get simple regular expressions wrong the first time. This is why I'm following
    others in deprecating regular expressions as Not a Good Part.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我多年来一直在使用正则表达式，它们无疑是我最有效的缺陷注入方法，而且我经常第一次就搞错简单的正则表达式。这就是为什么我和其他人一样，不再看好正则表达式。
- en: The program, by default, presents a relatively simple user interface for entering
    one-time calendar entries.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该程序为输入一次性日历条目提供了一个相对简单的用户界面。
- en: 'Here is a screenshot of our program''s user interface as it is initially presented,
    without a drill-down into the smorgasbord of options for repeating calendar entries:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们程序的用户界面的屏幕截图，最初呈现的样子，没有深入了解重复日历条目的各种选项：
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![再来一次山姆-一个有趣的挑战](img/B04108_10_02.jpg)'
- en: Progressive disclosure reserves a more detailed combination of supported items
    for recurring calendar entries, with added controls for repeating calendar entries
    displayed if a user opts to see them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 渐进式披露为重复日历条目保留了更详细的组合，如果用户选择查看它们，则显示了重复日历条目的附加控件。
- en: The following is a screenshot of the more advanced interface for recurring calendar
    entries. Because there are several different ways in which recurring calendar
    entries are often organized, several controls are available.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于重复日历条目的更高级界面的屏幕截图。由于重复日历条目通常以几种不同的方式组织，因此提供了几个控件。
- en: '![Play it again Sam – an interesting challenge](img/B04108_10_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![再来一次山姆-一个有趣的挑战](img/B04108_10_03.jpg)'
- en: Classical Hijaxing works well
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 经典的Hijaxing效果很好
- en: 'As we open the class, one member is conspicuous by its absence—`mixins: [React.addons.LinkedStateMixin]`.
    This member was featured heavily in our previous chapter where we had two-way
    data binding between form fields, for which we specified the HTML field/JSX component''s
    value and this complementary implementation where the form is not controlled (value
    not being specified). Here, form elements are queried in the old-fashioned way
    as they are needed. While ReactJS strongly believes that one-way data binding
    should be the norm, two-way data binding can be legitimate, preferably in a small
    and quarantined area. This chapter and the previous ones are intended to provide
    working examples of two slightly different approaches so as to give a reference
    to the one that you prefer:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们打开这个类时，一个成员因其缺席而显眼——`mixins: [React.addons.LinkedStateMixin]`。这个成员在我们之前的章节中大量出现，我们在那里介绍了表单字段之间的双向数据绑定，我们指定了HTML字段/JSX组件的值，以及这个补充实现，其中表单不受控制（值未指定）。在这里，表单元素以旧式方式查询，因为它们是需要的。虽然ReactJS坚信单向数据绑定应该是规范，但双向数据绑定也是合法的，最好是在一个小而隔离的区域内。这一章和之前的章节旨在提供两种略有不同的方法的工作示例，以便为您提供一个参考：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `getInitialState()` function initializes two items. One is a list for calendar
    entries. The other is a patient who is, on the operating table until the surgery
    is complete and it can be added to the list of live entries.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`getInitialState（）`函数初始化了两个项目。一个是日历条目的列表。另一个是一个患者，手术进行中，直到手术完成并可以添加到活动条目列表中。'
- en: 'There are two types of entries: a smaller, basic entry that just gives the
    date for a one-off calendar entry, and a larger, more involved entry that gives
    the fuller information that is needed for a repeating series of calendar entries.
    Another implementation might keep them in separate lists; here, we use one list
    and check individual entries to see whether they have the `repeats` field, which
    recurring series have and one-off calendar entries lack:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的条目：一个较小的基本条目，只给出一次性日历条目的日期，另一个是更大、更复杂的条目，提供了重复系列日历条目所需的更完整信息。另一种实现可能会将它们保存在单独的列表中；在这里，我们使用一个列表，并检查单个条目，以查看它们是否具有“重复”字段，这是重复系列具有的，而一次性日历条目则没有：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `handle_submit()` function Hijaxes form submission, taking the entry that
    is on the operating table and filling in its fields, whether for a one-time calendar
    entry or for a series. Then it adds the entry to the list of entries and resets
    the form (it would be simpler to simply `reset()` the form, but this provides
    slightly finer control, updating the default date to today's date so that the
    form's `reset()` does not always reset the page originally loaded to the date).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_submit（）`函数劫持了表单提交，获取手术台上的条目并填写其字段，无论是一次性日历条目还是系列。然后将条目添加到条目列表中并重置表单（直接`reset（）`表单会更简单，但这提供了稍微更精细的控制，更新默认日期为今天的日期，以便表单的`reset（）`不会总是将页面最初加载的日期重置）。'
- en: The entries are formulaic in character—all plain old JavaScript objects, easily
    JSON-serializable—and are, in essence, dictionaries containing strings, integers,
    and Booleans (in two cases, the entries also contain other dictionaries that contain
    strings and integers). There is no use of closures or other more sophisticated
    techniques here; the design is intended to be simple enough for someone to attentively
    read `handle_submit()` and accurately know how one-time and recurring calendar
    entries are represented.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 条目的性质是公式化的——都是普通的旧JavaScript对象，易于JSON序列化——本质上是包含字符串、整数和布尔值的字典（在两种情况下，条目还包含其他包含字符串和整数的字典）。这里没有使用闭包或其他更复杂的技术；设计意在简单到足以让某人仔细阅读`handle_submit（）`并准确知道一次性和重复日历条目是如何表示的。
- en: 'The `handle_submit()` function pulls from the form information on whether it
    represents a one-time or repeating calendar entry:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`handle_submit（）`函数从表单中提取信息，判断它代表一次性还是重复的日历条目：'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At the end, it adds the entry read from the form to the list of live entries
    and puts a new one in place for further data entry:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将从表单中读取的条目添加到活动条目列表中，并为进一步的数据输入放置一个新的条目：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we create a new entry. This will be a one-time calendar entry that can
    be augmented to represent a series later on, if desired.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新条目。这将是一个一次性的日历条目，如果需要，稍后可以扩展为代表系列。
- en: 'Here is a screenshot of the calendar with the one one-time event represented:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示了一次性事件的日历的屏幕截图：
- en: '![Classical Hijaxing works well](img/B04108_10_07.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![经典Hijaxing效果很好](img/B04108_10_07.jpg)'
- en: Built with usability in mind, but there's still room to grow
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 考虑到可用性，但仍有增长空间
- en: 'Here''s a note that may address a confusing point of the code: the time units
    represented in an entry are not intended to represent everything that a JavaScript
    Date object represents, but to be maximally compatible with a JavaScript Date
    object. This means, in particular, that some programmer-confusing designs of the
    Date object are accommodated in our code because the JavaScript Date object numbers
    the dates of a month from 1 to 31, just like general calendar use, but months
    are represented from 0 (January) to 11 (December). Similarly, hours range from
    0 to 23 in the Date object.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点可能会解释代码中的一个令人困惑的地方：输入中表示的时间单位并不是要表示 JavaScript 日期对象表示的所有内容，而是要最大限度地与 JavaScript
    日期对象兼容。这意味着，特别是一些令程序员困惑的设计在我们的代码中得到了容纳，因为 JavaScript 日期对象将一个月的日期从1到31进行编号，就像一般的日历使用一样，但月份从0（一月）到11（十二月）表示。同样，日期对象中的小时范围是从0到23。
- en: This function is a constructor in terms of what it does, but it is not designed
    for the new keyword, as the entire constructor and `this` is something that Crockford
    no longer includes in *The Better Parts* after he tried—in the wake of creating
    AdSafe, which forbade the use of the `this` keyword for security reasons—to take
    the medicine he was prescribing for others. He found that his code got smaller
    and better for the discipline. Working with code built to use `this` is nonnegotiable
    for serious work in ReactJS, but it may be suggested that we should opt out when
    we do not need to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数在功能上是一个构造函数，但它并不是为了使用 new 关键字而设计的，因为整个构造函数和 `this` 是 Crockford 在 *The Better
    Parts* 中不再包括的东西，他在创建 AdSafe 后试图按照自己的建议行事，禁止使用 `this` 关键字出于安全原因。他发现他的代码变得更小更好。在
    ReactJS 中，使用 `this` 构建的代码是不可妥协的，但当我们不需要时，可以选择退出。
- en: 'There is one more specific detour, as some more perceptive readers may note:
    the initial hours are set to 12 instead of, for instance, 0\. The school that
    says not to allow the user to enter invalid data in the first place can, by itself,
    lead to some "anti-patterns" in usability. Consider the hall-of-shame-worthy interface
    to enter a United States social security number, which should be needed very rarely
    and not because you need an institution-wide identifier.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个特定的绕道，一些更敏锐的读者可能会注意到：初始小时设置为12，而不是0。那些说不允许用户首先输入无效数据的学校，可能会导致可用性上的一些“反模式”。考虑一下值得耻辱的界面，用于输入美国社会安全号码，这种情况可能很少发生，也不是因为你需要一个机构范围的标识符。
- en: 'The next screenshot shows perhaps the worst way—in terms of usability and user
    interface concerns—of ensuring that (something that could be) a United States
    social security number is entered in an appropriate format:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个截图显示了也许是确保以适当格式输入（可能是）美国社会安全号码的最糟糕的方式，从可用性和用户界面的角度来看：
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![考虑到可用性，但仍有改进空间](img/B04108_10_04.jpg)'
- en: This user interface is not appropriate; a much better approach would be to allow
    a text input, use JavaScript to enforce exactly nine digits, and simply ignore
    the hyphens (and preferably any other non-digit characters).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这个用户界面不合适；一个更好的方法是允许文本输入，使用 JavaScript 强制精确的九位数字，并简单地忽略连字符（最好也忽略其他非数字字符）。
- en: This interface, as implemented, represents careful thoughts but real compromises
    with respect to usability, and a good laboratory could probably improve it nicely
    (the Holy Grail here would be to have one text field where the user types the
    time and the system automagically uses heuristics to identify what was really
    meant, but that system might have trouble identifying whether a calendar entry
    scheduled at 8 is at 8 A.M. or 8 P.M.) Putting A.M. or P.M. immediately after
    the hour and in the same input, as is done a bit further down, is a violation
    of the principle of least astonishment, which says that whatever the software
    does, it should astonish the user the least. The expected approach, which is usually
    the right approach, is to have one field for hours, one field for minutes, and
    one field for A.M. or P.M. But depending on the default values, this allows someone
    with a mid-afternoon commitment to enter 3 for the hours, 15 for the minutes,
    and click on **Save**, only to get an appointment scheduled for 3:15 AM. Mistakes
    are still possible, as they always are, but the design that is taken is intended
    to help people start in the middle of the day and have more of a fighting chance
    of entering the hour that they really intended.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界面的实现代表了仔细的思考，但在可用性方面存在一些妥协，一个好的实验室可能会对其进行改进（这里的圣杯是有一个文本字段，用户在其中输入时间，系统自动使用启发式方法来识别实际意思，但该系统可能难以确定日历条目是否安排在上午8点还是下午8点）。在输入小时后立即放置上午或下午，并放在同一个输入框中，违反了最少惊讶原则，该原则认为无论软件做什么，都应该尽量减少用户的惊讶。通常预期的方法是为小时设置一个字段，为分钟设置一个字段，为上午或下午设置一个字段。但根据默认值的不同，这允许有中午约定的人输入3小时，15分钟，并单击**保存**，结果却得到了一个安排在上午3:15的约会。错误仍然可能发生，但所采用的设计意在帮助人们在一天中的中间开始，并更有可能输入他们真正想要的小时。
- en: 'The following screenshot shows our program''s default user interface, without
    the added controls for the user interface. It shows the drop-down menu for the
    hour of the day, intended as a sensible default and to reduce user errors of the
    time being entered as AM or PM:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们程序的默认用户界面，没有为用户界面添加控件。它显示了一天中的小时下拉菜单，旨在作为一个合理的默认值，并减少用户输入时间时出现上午或下午的错误：
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_05.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![考虑到可用性，但仍有改进空间](img/B04108_10_05.jpg)'
- en: One usability improvement on the interface would be to use—instead of a minute
    dropdown—a text field with JavaScript validation, enforcing an integer value from
    0 to 59, possibly with a leading zero before a single-digit value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 界面上的一个可用性改进是使用文本字段而不是分钟下拉菜单，使用JavaScript验证，强制执行从0到59的整数值，可能是单个数字值之前的前导零。
- en: But let's move on from the default starting hours of the noon to something else.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是让我们从默认的开始时间移动到其他时间。
- en: 'Here is an example of a calendar with a one-time event and a repeating event:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是具有一次性事件和重复事件的日历示例：
- en: '![Built with usability in mind, but there''s still room to grow](img/B04108_10_09.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![考虑到可用性，但仍有改进的空间](img/B04108_10_09.jpg)'
- en: Plain old JavaScript objects are all you need
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只需简单的JavaScript对象
- en: 'Let''s take a look at the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下以下代码：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For one-time calendar entries, the fields are used just as you might expect.
    For series of calendar entries, the date becomes not the time when the calendar
    entry occurs, but the time when it starts. The user interface offers several ways
    that you might narrow down when a calendar entry occurs. This can be said to be
    every first, Tuesday only, and for a particular month. Every selection that is
    made narrows things down further, and so the desired usage is to be just specific
    enough to request the behavior that you want.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一次性日历条目，字段的使用方式与您可能期望的一样。对于一系列日历条目，日期不再是日历条目发生的时间，而是开始的时间。用户界面提供了几种可能缩小日历条目发生时间的方法。这可以说是每个月的第一个，仅限星期二，以及特定月份。每次选择都会进一步缩小范围，因此期望的用法是足够具体，以请求您想要的行为。
- en: 'Most of the variable names here are meant to be self-explanatory. Two that
    might need explanation are `frequency` and `month_occurrences`. The `frequency`
    variable has values of `Every`, `Every First`, `Every Second`, `Every Third`,
    `Every Fourth`, `Every Last`, `Every First and Third`, and `Every Second and Fourth`
    (this is the part of the web application that accommodates your Toastmasters''
    meeting at 7:00 P.M. every second and fourth Thursday). The `month_occurrences`
    variable specifies in which month something occurs (0 to 11 as per the JavaScript
    Date object for January to December, or -1 to indicate every month):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的大多数变量名都是自解释的。可能需要解释的两个变量是`frequency`和`month_occurrences`。`frequency`变量的值为`Every`、`Every
    First`、`Every Second`、`Every Third`、`Every Fourth`、`Every Last`、`Every First and
    Third`和`Every Second and Fourth`（这是网络应用程序的一部分，适应您Toastmasters每个第二和第四个星期四晚上7:00的会议）。`month_occurrences`变量指定某事发生的月份（根据JavaScript
    Date对象为1月到12月的0到11，或-1表示每个月）：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is a screenshot that shows an activity that repeats every other week:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示每隔一周重复一次的活动的屏幕截图：
- en: '![Plain old JavaScript objects are all you need](img/B04108_10_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![只需简单的JavaScript对象](img/B04108_10_08.jpg)'
- en: Progressive disclosure that starts simply
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从简单开始的渐进式披露
- en: 'The `on_change()` function is called when the checkbox for repeating calendar
    entries is ticked, and it allows progressive disclosure, displaying the entire
    user interface for repeating calendar entries if the user opts for them. It toggles
    `this.state.entry_being_added.repeats`, which is respected by the `render()` function.
    This function displays the additional form area if the entry that is presently
    on the operating table has a `repeats` field, and it is true. If the entry does
    not have a `repeats` field, a new series is created, any time data already entered
    in the one-time calendar entry is copied over, and the new and (partly) blank
    entry is placed on the operating table:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当复选框用于重复日历条目被选中时，将调用`on_change()`函数，并且它允许渐进式披露，如果用户选择它们，则显示重复日历条目的整个用户界面。它切换`this.state.entry_being_added.repeats`，这受到`render()`函数的尊重。如果当前正在操作的条目具有`repeats`字段，并且为true，则此函数将显示附加的表单区域。如果条目没有`repeats`字段，则会创建一个新系列，已经输入的任何时间数据都会被复制，然后将新的（部分）空白条目放在操作表上：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows an event that happens every other week live
    in the interface:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了界面中每隔一周发生的事件：
- en: '![Progressive disclosure that starts simply](img/B04108_10_09.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![从简单开始的渐进式披露](img/B04108_10_09.jpg)'
- en: A render() method can easily delegate
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: render()方法可以轻松地委托
- en: 'The (outer) `render` function, is more of a wrapper than a workhorse. It displays
    the fields for a one-time calendar entry that belongs to both one-time calendar
    entries and series. Additionally, if the calendar entry that is on the operating
    table is a recurring calendar entry (which will be true only if the checkbox that
    indicates a recurring calendar entry is checked), this function includes the added
    form elements that are appropriate for a recurring calendar entry:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: （外部）`render`函数更像是一个包装器而不是一个工作马。它显示了属于一次性日历条目和系列的日历条目的字段。此外，如果正在操作的日历条目是重复的日历条目（仅当指示重复的日历条目的复选框被选中时才为真），此函数将包括适用于重复日历条目的附加表单元素：
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The JSX syntax is surprisingly forgiving. However, it does have some rules,
    and they are enforced with descriptive error messages, including that if there
    are multiple elements, they need to be wrapped in an enclosing element. So, you
    do not write `<em>Hello</em>, <strong>world</strong>!`. Instead, you write `<span><em>Hello</em>,
    <strong>world</strong>!</span>`. But given a few other ground rules, JSX will
    do the right thing for a remarkably broad stretch of uses and abuses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: JSX语法出人意料地宽容。但是，它确实有一些规则，并且通过描述性错误消息来执行这些规则，包括如果有多个元素，它们需要被包裹在一个封闭的元素中。因此，您不会写`<em>Hello</em>,
    <strong>world</strong>!`。相反，您会写`<span><em>Hello</em>, <strong>world</strong>!</span>`。但是在一些其他基本规则的情况下，JSX将为广泛的用途和滥用做正确的事情。
- en: 'Here is a `render()` method, which is a central method for any component you
    define. In some cases the `render()` method will not be monolithic, but will delegate
    some or all of its work to other methods. Let''s explore:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`render()`方法，对于您定义的任何组件来说都是一个中心方法。在某些情况下，`render()`方法不会是单一的，而是会将其一些或全部工作委托给其他方法。让我们来探讨一下：
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Boring code is better than interesting code!
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无聊的代码比有趣的代码更好！
- en: 'Readers familiar with Terry Pratchett would have probably heard of *Interesting
    Times*, which opens with something that has been misattributed to China in an
    urban legend: There is a curse. *They Say: May You Live in Interesting Times!*
    One of the characters, Rincewind (this is not a kind of cheese), is on a perennial
    quest for things that are boring, and boring is precisely what he never gets.
    Part of the book''s plot has Rincewind tricked from living on a remote, boring
    tropical island to a teeming empire where all sorts of interesting things involving
    him keep on happening. For Rincewind, boring is a kind of Holy Grail that keeps
    on slipping through his fingers.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉特里·普拉切特的读者可能已经听说过《有趣的时代》，它以一个被误归于中国的城市传说开篇：有一种诅咒。他们说：愿你生活在有趣的时代！其中一个角色，林斯温德（这不是一种奶酪），一直在追求无聊的事物，但无聊正是他从未得到的。书中的情节之一是林斯温德被骗去生活在一个偏僻、无聊的热带岛屿，然后被转移到一个繁荣的帝国，那里发生了各种各样与他有关的有趣的事情。对于林斯温德来说，无聊就像一个圣杯，总是从他手中溜走。
- en: This code is meant to be *boring*, Rincewind-style. It would be possible to
    write more concise code that would populate a hash (or array) for `hour_options`
    rather than specify the array directly. But it would not be so easily checked
    to see whether it is right or wrong. And developing in this way doesn't mean extra
    typing, which (expert opinions have recognized this) is not any real bottleneck
    in programming.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的目的是*无聊*，就像林斯温德一样。可以编写更简洁的代码，用`hour_options`来填充哈希（或数组），而不是直接指定数组。但这样做不容易检查它是对还是错。以这种方式开发并不意味着额外的输入，（专家意见已经认识到）在编程中并不是真正的瓶颈。
- en: The way the following code works essentially defines arrays, and then these
    arrays are used to create/form elements (which are mostly `SELECT` populated in
    a straightforward fashion from the arrays). The task that it accomplishes is to
    display the user interface for a one-time calendar entry (plus the checkbox to
    indicate a recurring calendar entry).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码的工作原理基本上是定义数组，然后使用这些数组来创建/形成元素（大部分是从数组中直接填充的`SELECT`）。它的任务是显示一次性日历条目的用户界面（以及复选框，表示重复的日历条目）。
- en: There has been a conscious decision in this chapter to do things the boring
    way, with one exception—populating the menu for the number of days in a month
    that is intended. This could be 28, 29, 30, or 31 days. We show the code to generate
    the dropdown menu for hours; minutes (and months) are simpler examples of the
    same pattern.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有意决定以无聊的方式做事，只有一个例外——填充所需月份天数的菜单。这可以是28、29、30或31天。我们展示了生成小时下拉菜单的代码；分钟（和月份）是同一模式的更简单的例子。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: No programmer's wrists were harmed in the production of this chapter (it really
    didn't take that much typing or development time).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的编写过程中，没有程序员的手腕受到伤害（实际上并没有那么多的输入或开发时间）。
- en: A simple UI for simply non-recurring entries...
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的用户界面，用于非重复条目...
- en: For the more basic type of calendar entry, the kind that only happens once,
    we collect the date, month, and year, defaulting to the current date's values.
    Some things are "all-day" events for that day, such as someone's birthday; others
    start at a specific time. The interface could possibly be expanded to include
    optional end time. This functionality would be an extension of the same principles
    demonstrated here.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更基本的日历条目类型，即只发生一次的类型，我们收集日期、月份和年份，默认为当前日期的值。有些事情是“全天”事件，比如某人的生日；其他事件从特定时间开始。界面可能会扩展，以包括可选的结束时间。这个功能将是这里展示的原则的延伸。
- en: 'We begin to see the UI for rendering basic entries:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始看到呈现基本条目的用户界面：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The JSX here is similar to others that we have seen before; it is provided
    to reinforce what it would be like in a case like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的JSX与我们之前看到的其他JSX类似；它是为了加强在这种情况下的体验：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We use a dropdown for the day of a month that the user selects, and try to
    provide a slightly nicer alternative to making a first through a 31st year round
    (users shouldn''t be required to know which months have 30 days). We query the
    form''s month dropdown for the month that is presently selected. As a reminder,
    we are aiming for compatibility with JavaScript''s Date object, and while a JavaScript
    Date object can have a 1-based date value from 1 to at most 31, the month value
    is 0-based, from 0 (January) to 11 (December), and we follow this lead:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用下拉菜单让用户选择一个月中的日期，并尝试提供一个更好的选择，而不是让用户在1日到31日之间选择（用户不应该被要求知道哪些月份有30天）。我们查询表单的月份下拉菜单，以获取当前选择的月份。提醒一下，我们的目标是与JavaScript的Date对象兼容，虽然JavaScript的Date对象可以有一个从1到31的基于1的日期值，但月份值是基于0的，从0（一月）到11（十二月），我们遵循这个规则：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The user can still opt-in for more
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户仍然可以选择更多
- en: This method is similar to the previous one, but displays the entire interface
    for repeating calendar entries. It shows further variations on the theme.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法与之前的方法类似，但显示了整个重复日历条目的界面。它展示了主题的进一步变化。
- en: The fact that the present implementation goes with the intersection of all restricting
    criteria for recurring calendar entries is good enough for a first pass.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的实现选择了所有限制条件的交集，对于重复的日历条目来说已经足够了。
- en: 'The `frequency_options` functions are populated slightly differently from other
    fields; while this could also have been done with the date options, `SELECT` is
    populated in the `<option>description</option>` format, as opposed to the (usually
    secondary) `<option value="code">description</option>` format:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`frequency_options`函数的填充方式与其他字段略有不同；虽然这也可以用日期选项来完成，但`SELECT`是以`<option>description</option>`的格式填充，而不是（通常是次要的）`<option
    value="code">description</option>`的格式。'
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The weekdays are straightforward even if they break the pattern of populating
    `SELECT`, in a situation where a checkbox is the more obvious type of input. A
    radio button for selecting one day is also conceivable, but we are trying to accommodate
    more use cases, and a calendar entry with recurring Tuesdays and Thursdays or
    recurring Mondays, Wednesdays, and Fridays is common. Also, these aren''t the
    only patterns in which something occurs more than once per week (it would be nice
    if a college student using our program did not have to make more than one entry
    for classes that meet more than once per week):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 工作日很简单，即使它们打破了填充 `SELECT` 的模式，在复选框更明显的输入类型的情况下。选择一天的单选按钮也是可以想象的，但我们试图适应更多的用例，一个包含重复星期二和星期四或重复星期一、三和五的日历条目是常见的。此外，这些并不是发生一周多次的唯一模式（如果一个大学生使用我们的程序不必为每周多次上课而做多次输入，那将是很好的）：
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Avoiding being clever
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免聪明
- en: 'Let''s see a subtlety (which is less obvious when scrolling through the code
    than looking at the user interface): there are two separate dropdown menus with
    their own populating arrays representing the month. The reason for this is that
    in one case, there is supposed to be a choice, not only between specific months,
    but also between specifying one month only and all months. That menu includes
    an option of `[-1, "Every Month"]`.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个微妙之处（在浏览代码时不太明显，但在查看用户界面时很明显）：有两个单独的下拉菜单，它们有自己的填充数组来表示月份。这样做的原因是，在某种情况下，不仅可以在特定月份之间进行选择，还可以在指定一个月份和所有月份之间进行选择。该菜单包括一个
    `[-1, "每月"]` 的选项。
- en: 'The other example is for the (optionally specified) end date for a series of
    calendar entries. This is a use case where it does not really make sense to specify
    that something ends every month. The intended use is to give the day, month, and
    year on which something stops displaying. The combination of these two use cases
    makes for two separate, non-cookie-cutter ways of choosing a month. The more exclusive
    could be gotten from the more inclusive with an `array.slice(1)` function, but
    we are again going for Rincewind-style, boring code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例是一系列日历条目的（可选指定的）结束日期。这是一个使用情况，指定每个月结束的情况并不是真的有意义。预期的用法是给出停止显示的日期、月份和年份。这两种用例的组合形成了两种单独的、非模板式的选择月份的方式。更专有的可以从更包容的中得到，使用
    `array.slice(1)` 函数，但我们再次选择了 Rincewind 风格的无聊代码：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These are baked into two separate arrays in a user interface that is slowly
    built up to calendar "entry-ually" include the last option, a checkbox to mark
    that the repeating calendar entry ends on a certain date, and fields to specify
    which date, month, and year it ends on, drawing on the first of the two preceding
    arrays:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都被嵌入到用户界面中的两个单独的数组中，慢慢地构建成日历“逐步”包括最后一个选项，一个复选框，用于标记重复的日历条目在特定日期结束，并指定它结束的日期、月份和年份的字段，利用前两个数组中的第一个：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The previous two major methods are building forms for a user to enter data.
    The next method switches gears somewhat; it is set to display upcoming calendar
    entries from the present date to a year after the last scheduled one-time calendar
    entry.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个主要方法是为用户输入数据构建表单。下一个方法在某种程度上转变了方向；它被设置为从当前日期到最后一个一次性日历条目的一年后显示即将到来的日历条目。
- en: Anonymous helper functions may lack pixie dust
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名辅助函数可能缺乏小精灵的魔尘
- en: 'Internally, calendar entries are segregated into one-time and recurring calendar
    entries. Premature optimization may be the root of all evil, but when it comes
    to working on calendars on other systems, looking at every calendar entry for
    every day has worse performance characteristics, roughly *O(n * m)* instead of
    the slight mindfulness shown here, which is closer to *O(n + m)*. Calendar entries
    are displayed as an H2 and a UL, each given a CSS class to facilitate styling
    (at present, the project has this portion as an unstyled, blank canvas):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，日历条目被分为一次性和重复的日历条目。过早的优化可能是一切罪恶的根源，但是当在其他系统上处理日历时，查看每天的每个日历条目的性能特征更差，大约是
    *O(n * m)*，而不是这里所显示的轻微的注意，接近 *O(n + m)*。日历条目显示为 H2 和 UL，每个都有一个 CSS 类来方便样式化（目前，项目将这部分作为未经样式化的空白画布）：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code, unusually for the examples we have seen so far, uses the `var that
    = this;` hack. In general, ReactJS guarantees that this is available at any time
    and not only when a function is first run. However, ReactJS does not ensure that
    inner functions will have the same benefits as top-level methods, and in general,
    it may be recommended that you use an inner function inside a top-level method
    only if you can do without at least some of ReactJS's pixie dust. Inner functions
    are here used as, for example, detached comparators. They don't interact directly
    with ReactJS and are limited with respect to what is available in terms of direct
    interaction with ReactJS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们迄今为止看到的示例不同，使用了 `var that = this;` 的黑客技巧。一般来说，ReactJS 保证 `this` 随时可用，而不仅仅是在函数首次运行时。然而，ReactJS
    不能保证内部函数会像顶层方法一样具有相同的优势，一般来说，如果你可以在顶层方法中不使用至少一些 ReactJS 的小精灵魔尘，可能会建议你只在顶层方法中使用内部函数。内部函数在这里被用作分离的比较器，例如。它们不直接与
    ReactJS 交互，并且在直接与 ReactJS 交互方面受到限制。
- en: 'Here, we have a comparator. It is written to be boring, as are other parts
    of this method; more terse replacements are readily available, but would lose
    plodding, "Rincewind-boring" clarity:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个比较器。它被写成无聊的，就像这个方法的其他部分一样；更简洁的替代方案是随时可用的，但会失去沉闷的“Rincewind-无聊”清晰度：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `successor()` function uses modified one-time entries as representations
    of days. These keep the date, month, year, and also the number of days in the
    future that a day represents. The original entry used as a day has the number
    of days (`0`) added to it as a member.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`successor()` 函数使用修改后的一次性条目来表示日期。这些条目保留了日期、月份、年份，以及一天后的未来天数。原始条目作为一天使用时，将天数（`0`）添加为成员。'
- en: 'Another aspect of the design is to eschew creating functions so anonymously
    that they''re not assigned to a variable. The `successor()` function is written
    for a `for` loop analogous to the `for(var index = 0; index < limit; ++index)`
    loop, and it could have been made inline, but it would have been much less clear
    (and much less boring) than if it were pulled out into its own function. This
    may not be needed for a two-line anonymous function, but here the code appears
    to be clearer and more boring, with `successor()` stored in its own variable with
    a name that is meant to be descriptive:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的另一个方面是避免创建函数，以至于它们没有分配给变量。`successor()`函数是为`for`循环编写的，类似于`for(var index =
    0; index < limit; ++index)`循环，它可以内联完成，但这样做会比将其提取到自己的函数中清晰得多（也会更无聊）。对于两行的匿名函数可能不需要这样做，但在这里，代码似乎更清晰、更无聊，`successor()`存储在它自己的变量中，名称旨在描述：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How far in the future should we show?
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们应该展示多远的未来？
- en: 'The `greatest` function immediately stores the greatest one-time calendar entry''s
    date that exists in the list, and is then modified to represent the last day that
    will be represented, which is a year after the greatest one-time calendar entry
    found (if there are recurring calendar entries, there will probably be a number
    of instances rendered after the last one-time calendar entry):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: “最大”函数立即存储列表中存在的最大一次日历条目的日期，然后被修改为表示将要表示的最后一天，这是在找到最大一次日历条目后的一年（如果有重复的日历条目，可能会在最后一个一次性日历条目之后呈现一些实例）：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Different stripes for different entry types
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的条纹代表不同的条目类型
- en: 'Calendar entries are segregated into one-time and repeating entries, so only
    a probable minority of repeating calendar entries are checked for every day. One-time
    calendar entries are put into a hash with a key straightforwardly taken from their
    date:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 日历条目被分为一次性和重复条目，因此每天只检查可能的少数重复日历条目。一次性日历条目被放入一个哈希中，其键直接取自其日期：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now we're ready to display!
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在我们准备好显示了！
- en: 'Here is the `for` loop mentioned earlier; it is considerably more readable
    with `compare()` and `successor()` pulled into their own variables with descriptive
    names rather than inline. For each day, the loop compiles a (possibly empty) list
    starting with one-time activities for that day, and checks all recurring calendar
    entries against it. For a recurring calendar entry, it starts out with `accepts_this_date`
    as `true`, indicating that the calendar entry does occur on that day, and then
    each of the criteria for a repeating date has a cumulative opportunity to say
    that the criterion they are checking is not met and veto that calendar entry happening
    on that day. If a recurring calendar entry passes through the gauntlet without
    any vetoes, it is added to the calendar entries displayed for that day:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面提到的`for`循环；将`compare()`和`successor()`提取到自己的变量中并使用描述性名称，使其更易读。对于每一天，循环编译一个（可能为空）列表，从该天的一次性活动开始，并检查所有重复的日历条目。对于重复的日历条目，它开始时`accepts_this_date`为`true`，表示该日历条目确实发生在那一天，然后每个重复日期的标准都有累积的机会来表示他们正在检查的标准未达到，并否决该日历条目在那一天发生。如果一个重复的日历条目在没有任何否决的情况下通过了审查，它将被添加到该天显示的日历条目中：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's be nice and sort each day in order
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们友好地按顺序排列每一天
- en: 'Now that all the calendar entries, both one-time and recurring, have been assembled
    for the day, they are sorted. We begin with the all-day activities, which are
    sorted alphabetically, and then proceed with the calendar entries that occur at
    a specific time, sorted by time ascending:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，所有日历条目，包括一次性和重复的，都已经为当天准备好了。我们从全天活动开始，按字母顺序排列，然后进行特定时间发生的日历条目，按时间升序排列：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The day is displayed in a human-friendly fashion; it''s `Monday`, not `Mon`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 日期以人性化的方式显示；是“星期一”，而不是“Mon”：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let them use Markdown!
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让他们使用Markdown！
- en: The description for activities supports Markdown. Note—as is pointed out in
    Facebook's own documentation on the deliberately named `dangerouslySetInnerHTML`—that
    we are implicitly trusting Showdown (which provided our `converter`) to be secure.
    There also exist tools intended to tag clean and sanitize HTML in a fashion appropriate
    for XSS-secure display of HTML here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 活动的描述支持Markdown。请注意——正如Facebook在“dangerouslySetInnerHTML”上的官方文档中指出的那样——我们默认信任Showdown（提供我们的“converter”）是安全的。还存在旨在标记清理和消毒HTML的工具，以适合在此处安全显示HTML的XSS-secure显示方式。
- en: 'We strip off open and close `P` tags, so that the descriptions will appear
    on the same line as any time or other information given by the day''s ordered
    list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们去掉开放和关闭的“P”标签，这样描述将出现在该天有序列表给出的任何时间或其他信息的同一行上：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: One thing at a time!
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次只做一件事！
- en: 'Finally, in the top-level `Pragmatometer` class, we comment out the display
    of `Todo`, so that only this will display while we are working on it. Next, we
    comment out the `Calendar` component to work on the scratchpad, and when this
    is done, the final integration will place these elements in the four corners of
    the screen:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在顶层的“Pragmatometer”类中，我们注释掉了“Todo”的显示，这样只有这个显示在我们工作时才会显示。接下来，我们注释掉“Calendar”组件，以便在草稿本上工作，完成后，最终集成将把这些元素放在屏幕的四个角落：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The holidays that inspired this calendar
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启发这个日历的节日
- en: 'Here, you can see the calendar set up and gracefully accommodating all the
    holidays in a list of American holidays:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到日历设置，并优雅地容纳了美国节日的所有节日列表：
- en: '![The holidays that inspired this calendar](img/B04108_10_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![启发这个日历的节日](img/B04108_10_11.jpg)'
- en: Each nation has its own holidays, and no disrespect is meant to other nations
    and their holidays, but I know U.S. holidays better than those of other nations,
    and the approach in this chapter is partly shaped by accommodating almost all
    major holidays. The exception is Easter/Pascha (with Good Friday 2 days before),
    which is calculated according to a very specific algorithm, but one much more
    intricate than anything else we cover in this project, and it actually has two
    different algorithms for most Catholics and Protestants on one hand, and most
    Orthodox on the other. It could perhaps be included as a special case, but it
    is not entirely clear how one can create a generic solution that will accommodate
    equally complex calculations without a compromise of security (The most promising
    route for that would probably be to allow calculations in a sandbox based on Douglas
    Crockford's AdSafe project, which would allow a fairly free hand in calculations
    without needing to compromise overall page security).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 每个国家都有自己的假期，并且并不是对其他国家和他们的假期表示不尊重，但我对美国的假期了解比其他国家更多，本章的方法在一定程度上是为了适应几乎所有主要假期。例外是复活节/复活节（前两天是耶稣受难日），根据一个非常特定的算法计算，但比我们在这个项目中涵盖的任何其他内容都要复杂得多，实际上，对于大多数天主教徒和新教徒，它有两种不同的算法，而对于大多数东正教徒，它有两种不同的算法。也许可以将其作为一个特例包括进来，但并不完全清楚如何创建一个通用解决方案，可以在不牺牲安全性的情况下容纳同样复杂的计算（最有希望的途径可能是允许在基于Douglas
    Crockford的AdSafe项目的沙箱中进行计算，这将允许在不需要牺牲整体页面安全性的情况下进行相当自由的计算）。
- en: 'Apart from Good Friday and Easter, the main official holidays in the U.S. are
    listed as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复活节和耶稣受难日，美国的主要官方假期列举如下：
- en: New Year's Day (January 1, fixed)
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元旦（1月1日，固定）
- en: Martin Luther King Day (third Monday in January)
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 马丁·路德·金纪念日（1月的第三个星期一）
- en: President's Day (third Monday in February)
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总统日（2月的第三个星期一）
- en: Memorial Day (last Monday in May)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阵亡将士纪念日（5月的最后一个星期一）
- en: Independence Day (July 4, fixed)
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立日（7月4日，固定）
- en: Labor Day (first Monday in September)
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 劳动节（9月的第一个星期一）
- en: Columbus Day (second Monday in October)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哥伦布日（10月的第二个星期一）
- en: Veteran's Day (November 11, fixed)
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退伍军人节（11月11日，固定）
- en: Thanksgiving (fourth Thursday in November)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 感恩节（11月的第四个星期四）
- en: Christmas (Western, December 25, fixed)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圣诞节（西方，12月25日，固定）
- en: New Year's Eve (December 31, fixed)
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了耶稣受难日和复活节外，美国的主要官方假期列举如下：
- en: This system, is similar to the private calendar that served as its inspiration,
    is intended (among other things) to be powerful enough to allow calculation of
    floating and fixed holidays (with the regretted and intricately complex exception
    of Easter/Pascha), Also, it provides a very straightforward interface to enter
    every single holiday on the bulleted list, and much more. With a modern calendaring
    system, people in the U.S. do not research holidays on Wikipedia, and manually
    enter in their calendars that Thanksgiving is on the fourth Monday in November.
    They include a calendar that lists the holidays. However, this system is flexible
    enough for someone so inclined in any country to get a very direct interface to
    enter these holidays or others following the anticipated pattern or others like
    it.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统与作为灵感的私人日历类似，旨在（除其他目的外）足够强大，可以计算浮动和固定假期（遗憾的是，复活节/复活节有复杂的例外），此外，它提供了一个非常简单的界面，可以输入列表中的每个假期，以及更多。有了现代的日历系统，美国人不会在维基百科上查找假期，并手动输入感恩节是在11月的第四个星期一。他们包括一个列出假期的日历。然而，这个系统足够灵活，可以让任何国家的人以非常直接的方式输入这些假期或其他遵循预期模式的假期。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was meant to provide a slightly more involved example of a user
    interface built on ReactJS that has non-toy functionality. We saw both rendering
    code and backend-type functionality, that adds depth beyond a user interface alone.
    The approach was intended to be complementary to the previous chapter, in terms
    of (for instance) controlled inputs that specify what their value will be, as
    opposed to near classic Hijaxing of queried forms.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章的目的是提供一个在ReactJS上构建的用户界面的稍微复杂的示例，具有非玩具功能。我们看到了渲染代码和后端类型的功能，这使得用户界面不仅仅是表面的。这种方法旨在与上一章互补，例如，指定其值的受控输入，而不是对查询表单进行近乎经典的Hijaxing。
- en: Note
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From a usability perspective, the best way of handling user input for recurring
    calendar entries is probably not to directly tweak and enhance a complex and somewhat
    heterogeneous form, as we have done here. The kind of advanced recurring events
    we use here are a use case for a wizard or interview approach.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从可用性的角度来看，处理重复日历条目的用户输入的最佳方式可能并不是直接调整和增强一个复杂且有些异构的表单，就像我们在这里所做的那样。我们在这里使用的高级重复事件是向导或面试方法的一个用例。
- en: We looked at a calendaring system that uses ReactJS in the kind of messy problem
    solving that we encounter in the real world. We have an approach to sophisticated
    render methods. With respect to usability, which ReactJS developers should perhaps
    be the most sensitive to (as they are the people most responsible for development
    that touches usability), there has been attention and a constant eye on usability,
    coupled with awareness that the user interface could stand improvement.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了一个使用ReactJS的日历系统，解决了在现实世界中遇到的混乱问题。我们有一种复杂的渲染方法。就可用性而言，ReactJS开发人员可能应该是最敏感的（因为他们是最负责与可用性相关的开发的人），对可用性进行了关注，并始终关注用户界面可能需要改进的意识。
- en: Along the way, we looked at boring code and boring plain old JavaScript objects
    that rather work extremely well when we need records. Finally, we looked at the
    holidays for a specific nation that our calendar was intended to be powerful enough
    to depict with its recurring event facilities.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们看了一些乏味的代码和乏味的普通JavaScript对象，当我们需要记录时，它们表现得非常出色。最后，我们看了我们的日历旨在强大到足以描绘其重复事件设施的特定国家的假期。
- en: Join us in the next chapter as we look at incorporating a third-party (non-ReactJS)
    tool and integrate the code of various applications into a single page.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们一起看看如何将第三方（非ReactJS）工具整合到一个页面中，并将各种应用程序的代码集成到一起。
