- en: Chapter 5. Querying Any Collection Easily with LINQ
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用LINQ轻松查询任何集合
- en: 'After having a discussion on delegates, lambda expressions, and extension methods,
    we are now ready to continue our discussion about LINQ. In this chapter, we will
    delve into LINQ, which is essential in composing functional code. Here, we will
    discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了委托、lambda表达式和扩展方法之后，我们现在准备继续讨论LINQ。在本章中，我们将深入探讨LINQ，这在组成功能代码中是至关重要的。在这里，我们将讨论以下主题：
- en: Introducing LINQ Queries
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍LINQ查询
- en: Understanding deferred execution in LINQ
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解LINQ中的延迟执行
- en: Comparing LINQ fluent syntax and LINQ query expression syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较LINQ流畅语法和LINQ查询表达式语法
- en: Enumerating LINQ operator
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举LINQ运算符
- en: Getting started with LINQ
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用LINQ
- en: '**Language Integrated Query** ( **LINQ** ), which was introduced in C# 3.0,
    is a language feature of .NET Framework that enables us to query data in collections
    easily implementing the `IEnumerable<T>` interface, such as `ArrayList<T>` , `List<T>`
    , an XML document, and a database. It becomes easier to query any data in a collection
    since, using LINQ, we do not need to learn a different syntax for a different
    source of data. For instance, we don''t need to learn SQL if we use LINQ when
    the data source is a database. Also, using LINQ, we don''t have to learn XQuery
    when we deal with an XML document. Fortunately, LINQ has eased our use of a common
    syntax for all the sources of data.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**语言集成查询**（**LINQ**）是C# 3.0中引入的.NET Framework的语言特性，它使我们能够轻松查询实现`IEnumerable<T>`接口的集合中的数据，例如`ArrayList<T>`，`List<T>`，XML文档和数据库。使用LINQ，查询集合中的任何数据变得更容易，因为我们不需要为不同的数据源学习不同的语法。例如，如果数据源是数据库，我们就不需要学习SQL，而是使用LINQ。同样，使用LINQ时，我们不必学习XQuery，而是处理XML文档。幸运的是，LINQ为我们提供了一个通用的语法，适用于所有数据源。'
- en: 'There are two basic data units in LINQ; they are sequences, which include any
    object that implements `IEnumerable<T>` , and elements, which include the items
    in the sequence. Suppose we have the following `int` array named `intArray` :'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ中有两种基本数据单元；它们是序列，包括实现`IEnumerable<T>`的任何对象，和元素，包括序列中的项目。假设我们有以下名为`intArray`的`int`数组：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding collection, we can say that `intArray` is a sequence, and
    the contents of the array, which include the numbers from 0 to 49, are the elements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的集合中，我们可以说`intArray`是一个序列，数组的内容，包括从0到49的数字，是元素。
- en: 'A sequence can be transformed using a method called a query operator. The query
    operator accepts an input sequence and then produce the transformed sequence.
    The query will transform the sequence when it is enumerated. The query consists
    of at least an input sequence and an operator. Let''s take a look at the following
    code, which we can find in the `SequencesAndElements.csproj` project, which will
    look for the prime number from our preceding collection, `intArray` :'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用称为查询运算符的方法来转换序列。查询运算符接受输入序列，然后生成转换后的序列。当枚举序列时，查询将转换序列。查询至少包括一个输入序列和一个运算符。让我们看一下以下代码，我们可以在`SequencesAndElements.csproj`项目中找到，它将从我们之前的集合`intArray`中查找素数：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `IsPrime()` extension method will have the following implementation:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`IsPrime()`扩展方法将有以下实现：'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'From our preceding code, we can see that we use the `Where` operator, which
    can be found in the `System.Linq.Enumerable` class, to transform the `intArray`
    sequence into the `extractedData` sequence, as shown in the following code snippet:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的代码中，我们可以看到我们使用`Where`运算符，它可以在`System.Linq.Enumerable`类中找到，将`intArray`序列转换为`extractedData`序列，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `extractedData` collection will now contain the prime numbers obtained
    from the `intArray` collection. If we run the project, we will get the following
    output on the console:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`extractedData`集合现在将包含从`intArray`集合中获得的素数。如果我们运行项目，将在控制台上获得以下输出：'
- en: '![Getting started with LINQ](img/Image00049.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![开始使用LINQ](img/Image00049.jpg)'
- en: 'We can actually modify our preceding code snippet in a simpler way since all
    query operators are extension methods and can be used directly in the collection.
    The modification of the preceding code snippet is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以以更简单的方式修改我们之前的代码片段，因为所有查询运算符都是扩展方法，可以直接在集合中使用。修改之前的代码片段如下：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'By modifying the invocation of the `Where` operator, we will get the complete
    implementation, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过修改`Where`运算符的调用，我们将获得完整的实现，如下所示：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we run the preceding `ExtractArrayWithMethodSyntax()` method, we will get
    the exact same output with the `ExtractArray()` method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`ExtractArrayWithMethodSyntax()`方法，将得到与`ExtractArray()`方法完全相同的输出。
- en: Deferring LINQ execution
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 延迟LINQ执行
- en: 'LINQ implements a deferred execution concept when we query the data from a
    collection. This means that the query will not be executed in the constructor
    time but in the enumeration process instead. For example, we use the `Where` operator
    to query data from a collection. Actually, the query is not executed until we
    enumerate it. We can use the `foreach` operation to call the `MoveNext` command
    in order to enumerate the query. To discuss deferred execution in further detail,
    let''s take a look at the following code, which we can find in the `DeferredExecution.csproj`
    project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从集合中查询数据时，LINQ实现了延迟执行的概念。这意味着查询不会在构造函数中执行，而是在枚举过程中执行。例如，我们使用`Where`运算符从集合中查询数据。实际上，直到我们枚举它时，查询才会被执行。我们可以使用`foreach`操作调用`MoveNext`命令来枚举查询。为了更详细地讨论延迟执行，让我们看一下以下代码，我们可以在`DeferredExecution.csproj`项目中找到：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As you can see in the implementation of the preceding `DeferredExecution()`
    method, we construct a `List<Member>` member list named `memberList` , which contains
    four instances of every member who has joined to the club. The `Member` class
    itself is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的`DeferredExecution()`方法的实现所示，我们构造了一个名为`memberList`的`List<Member>`成员列表，其中包含每个加入俱乐部的成员的四个实例。`Member`类本身如下所示：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: After constructing `memberList` , we query the data from `memberList` , which
    includes the all members who joined after 2014\. Here, we can confirm that only
    three of four members satisfy the requirements. They are Eddie Morgan, Millie
    Duncan, and Emilia Shaw in ascending order, of course, since we use the `orderby
    m.Name` phrase in the query.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造`memberList`之后，我们从`memberList`中查询数据，其中包括2014年后加入的所有成员。在这里，我们可以确认只有四个成员中的三个满足要求。它们是Eddie
    Morgan，Millie Duncan和Emilia Shaw，当然，因为我们在查询中使用了`orderby m.Name`短语，所以它们是按升序排列的。
- en: 'After we have the query, we add a new member to `memberList` and then run the
    `foreach` operation in order to enumerate the query. What will happen next is
    that, because most of the query operators implement deferred execution, which
    will be executed only in the enumeration process, we will have four members after
    enumerating the query since the last member we add to `memberList` satisfies the
    query requirement. To make this clear, let''s take a look at the following output
    we get on the console after invoking the `DeferredExecution()` method:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了查询之后，我们向`memberList`添加了一个新成员，然后运行`foreach`操作以枚举查询。接下来会发生什么是，因为大多数查询操作符实现了延迟执行，只有在枚举过程中才会执行，所以在枚举查询后，我们将有四个成员，因为我们添加到`memberList`的最后一个成员满足查询要求。为了搞清楚这一点，让我们看一下在调用`DeferredExecution()`方法后我们在控制台上得到的以下输出：
- en: '![Deferring LINQ execution](img/Image00050.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![延迟执行LINQ](img/Image00050.jpg)'
- en: As you can see, `Chloe Day` , who is the last member to have joined the club,
    is included in the query result as well. This is where the deferred execution
    plays its role.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`Chloe Day`，作为最后一个加入俱乐部的成员，也包含在查询结果中。这就是延迟执行发挥作用的地方。
- en: 'Almost all query operators provide deferred execution but not the operators
    that:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有查询操作符都提供延迟执行，但不包括以下操作符：
- en: Return a scalar value or a single element, such as `Count` and `First` .
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回标量值或单个元素，例如`Count`和`First`。
- en: Convert the result of a query, such as `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换查询结果，例如`ToList`，`ToArray`，`ToDictionary`和`ToLookup`。它们也被称为转换操作符。
- en: 'The `Count()` and `First()` method will be executed immediately since they
    return a single object, so it''s almost impossible to provide deferred execution
    as well as conversion operators. Using the conversion operator, we can obtain
    a cached copy of the query results and can avoid repeating the process due to
    the reevaluate operation in deferred execution. Now, let''s take a look at the
    following code, which we can find in the `NonDeferredExecution.csproj` project,
    to demonstrate the nondeferred execution process:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`Count()`和`First()`方法将立即执行，因为它们返回单个对象，所以几乎不可能提供延迟执行以及转换操作符。使用转换操作符，我们可以获得查询结果的缓存副本，并且可以避免由于延迟执行中的重新评估操作而重复该过程。现在，让我们看一下以下代码，我们可以在`NonDeferredExecution.csproj`项目中找到，以演示非延迟执行过程：'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'First, in the preceding code, we have a `List<int>` integer list named `intList`
    , which contains numbers from `0` to `9` . We then create a query named `queryInt`
    in order to select all members of `intList` and multiply them by `2` . We also
    count the total of the query data using the `Count()` method. Since `queryInt`
    is not executed yet, we create a new query named `queryIntCached` , which converts
    `queryInt` to `List<int>` using the `ToList()` conversion operator. We also count
    the total of the data in that query. We have two queries now, `queryInt` and `queryIntCached`
    . We then clear `intList` and enumerate the two queries. The following is the
    result of them being displayed on the console:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在前面的代码中，我们有一个名为`intList`的`List<int>`整数列表，其中包含从`0`到`9`的数字。然后，我们创建一个名为`queryInt`的查询，以选择`intList`的所有成员并将它们乘以`2`。我们还使用`Count()`方法计算查询数据的总数。由于`queryInt`尚未执行，我们创建了一个名为`queryIntCached`的新查询，它使用`ToList()`转换操作符将`queryInt`转换为`List<int>`。我们还计算了该查询中数据的总数。现在我们有两个查询，`queryInt`和`queryIntCached`。然后我们清除`intList`并枚举这两个查询。以下是它们在控制台上显示的结果：
- en: '![Deferring LINQ execution](img/Image00051.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![延迟执行LINQ](img/Image00051.jpg)'
- en: As you can see in the preceding console, the enumeration of `queryInt` results
    in no item. This is clear since we have removed all `intList` items, so `queryInt`
    will find no item in `intList` . However, `queryInt` is counted as ten items since
    we have run the `Count()` method before we clear `intList` , and the method is
    immediately executed right after we construct it. In contrast to `queryInt` ,
    we have ten items' data when we enumerate `queryIntCached` . This is because we
    have invoked the `ToList()` conversion operator and it is immediately executed
    as well.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的控制台中所看到的，对`queryInt`的枚举结果没有任何项目。这很明显，因为我们已经移除了所有`intList`项目，所以`queryInt`在`intList`中找不到任何项目。然而，`queryInt`被计为十个项目，因为我们在清除`intList`之前运行了`Count()`方法，并且该方法在构造后立即执行。与`queryInt`相反，当我们枚举`queryIntCached`时，我们有十个项目的数据。这是因为我们调用了`ToList()`转换操作符，并且它也立即执行了。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is one more type of deferred execution. It happens when we chain the `OrderBy`
    method after a `Select` method, for instance. The `Select` method will only retrieve
    one element at the time that it has to produce an element, while the `OrderBy`
    method has to consume the entire input sequence before it returns the first element.
    So, when we chain an `OrderBy` method after the `Select` method, the execution
    will be deferred until we retrieve the first element, and then the `OrderBy` method
    will ask `Select` for all the elements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种延迟执行的类型。当我们在`Select`方法之后链`OrderBy`方法时，就会发生这种情况。例如，`Select`方法只会在必须生成元素时检索一个元素，而`OrderBy`方法必须在返回第一个元素之前消耗整个输入序列。因此，当我们在`Select`方法之后链`OrderBy`方法时，执行将被延迟，直到我们检索第一个元素，然后`OrderBy`方法将要求`Select`提供所有元素。
- en: Choosing between fluent syntax and query expression syntax
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在流畅语法和查询表达式语法之间进行选择
- en: From our preceding discussion, we found two types of querying syntaxes so far.
    Let's discuss this further by distinguishing these two syntaxes.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的讨论中，到目前为止我们发现了两种类型的查询语法。让我们通过区分这两种语法来进一步讨论这个问题。
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code snippet is the fluent syntax type. We invoke the `Select`
    and `Count` operators by invoking their extension method in the `Enumerable` class.
    Using the fluent syntax, we can also chain the method so it will approach functional
    programming as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段是流畅语法类型。我们通过调用 `Enumerable` 类中的扩展方法来调用 `Select` 和 `Count` 运算符。使用流畅语法，我们还可以链接方法，使其接近函数式编程，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another syntax type we can use in querying data in LINQ is query expression
    syntax. We applied this syntax type when we discussed deferred execution in the
    previous topic. The code snippet of the query expression syntax is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 LINQ 中查询数据时可以使用的另一种语法类型是查询表达式语法。我们在上一个主题中讨论延迟执行时应用了这种语法类型。查询表达式语法的代码片段如下：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In fact, the fluent syntax and the query expression syntax will do the same
    thing. The difference between them is only the syntax. Each keyword in the query
    expression syntax has its own extension method in the `Enumerable` class. To prove
    this, we can refactor the preceding code snippet to the following fluent syntax
    type:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，流畅语法和查询表达式语法将执行相同的操作。它们之间的区别只是语法。查询表达式语法中的每个关键字在 `Enumerable` 类中都有其自己的扩展方法。为了证明这一点，我们可以将前面的代码片段重构为以下流畅语法类型：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Indeed, we will get the exact same output for these two types of syntaxes. However,
    the fluent syntax is closer to the functional approach than the query expression
    syntax.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两种类型的语法将得到完全相同的输出。然而，流畅语法比查询表达式语法更接近函数式方法。
- en: Understanding the LINQ fluent syntax
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LINQ 流畅语法
- en: 'Basically, the LINQ fluent syntax is the extension methods found in the `Enumerable`
    class. The method will extend any variable implementing the `IEnumerable<T>` interface.
    The fluent syntax takes a lambda expression as the parameter to represent the
    logic that will be performed in the sequence enumeration. As we discussed earlier,
    the fluent syntax implemented the method chain so that it can be used in the functional
    approach. In the beginning of this chapter, we had also discussed the extension
    method from which the query operator can be invoked directly using the static
    method from its class, which is the `Enumerable` class. However, by invoking the
    method directly from its class, we cannot implement the method chain we usually
    use in the functional approach. Let''s take at the following code, which we can
    find in the `FluentSyntax.csproj` project, to demonstrate the advantages of the
    fluent syntax by invoking the extension method instead of the conventional `static`
    method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，LINQ 流畅语法是在 `Enumerable` 类中找到的扩展方法。该方法将扩展任何实现 `IEnumerable<T>` 接口的变量。流畅语法采用
    lambda 表达式作为参数，表示将在序列枚举中执行的逻辑。正如我们之前讨论过的，流畅语法实现了方法链，以便在函数式方法中使用。在本章的开头，我们还讨论了扩展方法，可以直接使用其类的静态方法来调用查询运算符，即
    `Enumerable` 类。然而，通过直接从其类调用方法，我们无法实现通常在函数式方法中使用的方法链。让我们看一下以下代码，我们可以在 `FluentSyntax.csproj`
    项目中找到，以演示通过调用扩展方法而不是传统的 `static` 方法来使用流畅语法的优势：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The names collection we used in the preceding code is as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中使用的名称集合如下：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see, we use three query operators when we query the data from a
    collection in the preceding code. They are the `Where` , `OrderBy` , and `Select`
    operators. Let''s take a look at the following code snippet to make this clear:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，当我们在前面的代码中从集合中查询数据时，我们使用了三个查询运算符。它们是 `Where`、`OrderBy` 和 `Select` 运算符。让我们看一下以下代码片段，以澄清这一点：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Based on the preceding query, we will get the string collection in which each
    string contains more than four characters. The collection will be sorted in an
    ascending order by its first letter, and the string will be in uppercase characters.
    Here''s what we get on the console if we run the `UsingExtensionMethod()` method
    as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的查询，我们将得到一个字符串集合，其中每个字符串包含超过四个字符。该集合将按其第一个字母的升序排列，并且字符串将以大写字符显示。如果我们运行以下截图中显示的
    `UsingExtensionMethod()` 方法，我们将在控制台上看到以下内容：
- en: '![Understanding the LINQ fluent syntax](img/Image00052.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![理解 LINQ 流畅语法](img/Image00052.jpg)'
- en: 'Now, let''s refactor the preceding query to use the conventional static method.
    But before we go through it, here are the signatures of the three methods we have
    used in the preceding query:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构前面的查询，使用传统的静态方法。但在我们进行之前，这里是我们在前面的查询中使用的三个方法的签名：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, all three methods take `IEnumerable<TSource>` as the first parameter
    and also return `IEnumerable<TResult>` . We can use this similarity so that the
    return from the first method can be fed to the argument of the second method,
    the return from the second method can be fed to the argument of the third method,
    and so on.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，所有三个方法都以 `IEnumerable<TSource>` 作为第一个参数，并且还返回 `IEnumerable<TResult>`。我们可以利用这种相似性，使第一个方法的返回值可以作为第二个方法的参数，第二个方法的返回值可以作为第三个方法的参数，依此类推。
- en: In the `Where()` method, we use the second parameter, predicate, to filter the
    sequence based on it. It's a `Func<TSource, bool>` delegate, so we can use a lambda
    expression here. The `Func<TSource, TKey>` delegate can also be found in the second
    parameter of the `OrderBy()` method, which is used as the key to sort the element
    of the sequence in an ascending order. It can be fed by anonymous method. The
    last is the `Select()` method, in which we use its second parameter, `selector`
    , to project each element in the sequence in the new form. The anonymous method
    can also be used as the argument.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Where()` 方法中，我们使用第二个参数 predicate 来基于它过滤序列。它是一个 `Func<TSource, bool>` 委托，所以我们可以在这里使用
    lambda 表达式。在 `OrderBy()` 方法的第二个参数中也可以找到 `Func<TSource, TKey>` 委托，它用作对序列元素进行升序排序的键。它可以由匿名方法提供。最后是
    `Select()` 方法，在其中我们使用它的第二个参数 `selector`，将序列中的每个元素投影为新形式。匿名方法也可以作为参数使用。
- en: 'Based on the signature of the methods we used in the previous `UsingExtensionMethod()`
    method, we can refactor the query as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们在之前的 `UsingExtensionMethod()` 方法中使用的方法的签名，我们可以重构查询如下：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the complete `UsingStaticMethod()` method, which is the refactoring
    code when we use a conventional static method instead of the extension method:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完整的 `UsingStaticMethod()` 方法，这是当我们使用传统的静态方法而不是扩展方法时的重构代码：
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: By running the `UsingStaticMethod()` method, we will get the exact output on
    the console compared to the `UsingExtensionMethod()` method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行 `UsingStaticMethod()` 方法，我们将在控制台上获得与 `UsingExtensionMethod()` 方法相比完全相同的输出。
- en: Understanding the LINQ query expression syntax
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 LINQ 查询表达式语法
- en: A LINQ query expression syntax is a shorthand syntax that we can use to perform
    LINQ queries. In a query expression syntax, .NET framework provides the keywords
    for each query operator but not all operators. By using the query syntax, we can
    invoke the operator like we query the data using SQL in the database. Our code
    will be more readable and will require less coding when we use the query expression
    syntax.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 查询表达式语法是一种简写语法，我们可以使用它执行 LINQ 查询。在查询表达式语法中，.NET Framework 为每个查询操作符提供关键字，但并非所有操作符。通过使用查询语法，我们可以像在数据库中使用
    SQL 查询数据一样调用操作符。当我们使用查询表达式语法时，我们的代码将更易读，并且在编写时需要更少的代码。
- en: 'In the fluent syntax discussion, we created a query to extract the string from
    the string list that contains more than four characters, sorted in an ascending
    order by its first letter and converted to uppercase characters. We can do this
    using the query expression syntax, as shown in the following code, which we can
    find in the `QueryExpressionSyntax.csproj` project:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在流畅语法讨论中，我们创建了一个查询，从包含超过四个字符的字符串列表中提取字符串，按其第一个字母的升序排序，并转换为大写字符。我们可以使用查询表达式语法来执行此操作，如下面的代码所示，我们可以在
    `QueryExpressionSyntax.csproj` 项目中找到：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we have refactored the previous code, which uses the fluent
    syntax for the query expression syntax. Indeed, if we run the `InvokingQueryExpression()`
    method, the exact same output will be displayed will be displayed compared to
    the `UsingExtensionMethod()` method.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经重构了之前的代码，它使用了查询表达式语法的流畅语法。事实上，如果我们运行 `InvokingQueryExpression()`
    方法，与 `UsingExtensionMethod()` 方法相比，将显示完全相同的输出。
- en: 'Unfortunately, there are several LINQ operators that have no keyword in the
    query expression syntax, such as the `distinct` operator since it doesn''t take
    a lambda expression. In this case, we have to use the fluent syntax, at least
    in part if we still want to use it. The following are the operators that have
    a keyword in the query expression syntax:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，有几个 LINQ 操作符在查询表达式语法中没有关键字，例如 `distinct` 操作符，因为它不接受 lambda 表达式。在这种情况下，如果我们仍然想使用它，我们必须至少部分使用流畅语法。以下是在查询表达式语法中具有关键字的操作符：
- en: '`Where`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Where`'
- en: '`Select`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Select`'
- en: '`SelectMany`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectMany`'
- en: '`OrderBy`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderBy`'
- en: '`ThenBy`'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenBy`'
- en: '`OrderByDescending`'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderByDescending`'
- en: '`ThenByDescending`'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThenByDescending`'
- en: '`GroupBy`'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupBy`'
- en: '`Join`'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Join`'
- en: '`GroupJoin`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GroupJoin`'
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Actually, the compiler converts the query expression syntax into fluent syntax
    in the compiling process. Although the query expression syntax is sometimes easier
    to read, we cannot perform all the operations using it; instead, we have to use
    the fluent syntax, for instance, `count` operators as we discussed in *Deferring
    LINQ execution* topic. What we write in the query expression syntax can also be
    written in the fluent syntax. Therefore, the fluent syntax is the best approach
    when we code using LINQ, especially in the functional approach.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，编译器在编译过程中将查询表达式语法转换为流畅语法。虽然查询表达式语法有时更容易阅读，但我们不能使用它执行所有操作；相反，我们必须使用流畅语法，例如我们在
    *延迟 LINQ 执行* 主题中讨论的 `count` 操作符。我们在查询表达式语法中编写的内容也可以用流畅语法编写。因此，在使用 LINQ 编码时，特别是在功能方法中，流畅语法是最佳方法。
- en: Enumerating standard query operators
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举标准查询操作符
- en: There are more than 50 query operators in the `Enumerable` class included in
    the `System.Linq` namespace. They are also known as standard query operators.
    Based on the function of the operators, we can divide them into several operations.
    Here, we are going to discuss all the query operators in LINQ provided by .NET
    Framework.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `System.Linq` 命名空间中包含的 `Enumerable` 类中有 50 多个查询操作符。它们也被称为标准查询操作符。根据操作符的功能，我们可以将它们分为几个操作。在这里，我们将讨论
    .NET Framework 提供的所有 LINQ 查询操作符。
- en: Filtering
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: Filtering is an operation that will evaluate the element of data so that only
    the element satisfying the condition will be selected. There are six filtering
    operators; they are `Where` , `Take` , `Skip` , `TakeWhile` , `SkipWhile` , and
    `Distinct` . As we know, we have already discussed the `Where` operator in our
    previous sample code, both in the fluent syntax and the query expression syntax,
    and have an idea that it will return a subset of elements satisfying a condition
    given by a predicate. Since we are clear enough about the `Where` operator, we
    can skip it and continue with the remaining five filtering operators.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤是一个操作，它将评估数据的元素，以便只选择满足条件的元素。有六个过滤操作符；它们是 `Where` 、`Take` 、`Skip` 、`TakeWhile`
    、`SkipWhile` 和 `Distinct` 。正如我们所知，我们已经在之前的示例代码中讨论了 `Where` 操作符，无论是在流畅语法还是查询表达式语法中，并且知道它将返回满足谓词给定条件的元素子集。由于我们对
    `Where` 操作符已经足够清楚，我们可以跳过它，继续使用剩下的五个过滤操作符。
- en: 'The `Take` operator returns the first `n` elements and dumps the rest. In contrast,
    the `Skip` operator ignores the first `n` elements and returns the rest. Let''s
    take a look at the following code from the `FilteringOperation.csproj` project:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Take` 操作符返回前 `n` 个元素并丢弃其余的元素。相反，`Skip` 操作符忽略前 `n` 个元素并返回其余的元素。让我们来看一下 `FilteringOperation.csproj`
    项目中的以下代码：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have two queries in the preceding code, `queryTake` , which applies the
    `Take` operator, and `querySkip` , which applies the `Skip` operator. They both
    consume `intList` , which is actually a list of integers containing the following
    data:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有两个查询，`queryTake`应用了`Take`操作符，`querySkip`应用了`Skip`操作符。它们都消耗`intList`，实际上是一个包含以下数据的整数列表：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we run the preceding `SimplyTakeAndSkipOperator()` method, we will get the
    following output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`SimplyTakeAndSkipOperator()`方法，将会得到以下输出：
- en: '![Filtering](img/Image00053.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00053.jpg)'
- en: 'The preceding `Take` and `Skip` operator sample is simple code, since it deals
    with a collection containing only twenty elements. In fact, the `Take` and `Skip`
    operators are useful when we work with a huge collection, or maybe a database,
    to ease user access to the data. Suppose we have a million elements of the integer
    collection and we are looking for the element that is multiplied by two and seven.
    Without using the `Take` and `Skip` operators, we will have a ton of results,
    and if we show them on the console, they will clutter the console display. Let''s
    take a look at the following code to prove this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`Take`和`Skip`操作符示例是简单的代码，因为它处理的是一个只包含二十个元素的集合。事实上，当我们处理大量集合或者数据库时，`Take`和`Skip`操作符非常有用，可以方便用户访问数据。假设我们有一个包含一百万个整数的集合，我们要找到其中一个元素，它乘以二和七。如果不使用`Take`和`Skip`操作符，将会得到大量结果，如果在控制台上显示，会使控制台显示混乱。让我们看一下下面的代码来证明这一点：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see here, we have `hugeQuery` containing huge data. If we run the
    method, it needs about ten seconds to complete the iteration of all elements.
    We can also add the `Count` operator if we want to retrieve the actual elements
    `hugeQuery` contains, which is *71428* elements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在这里所看到的，我们有一个包含大量数据的`hugeQuery`。如果我们运行该方法，需要大约十秒钟来完成所有元素的迭代。如果我们想要获取`hugeQuery`实际包含的元素，我们也可以添加`Count`操作符，即*71428*个元素。
- en: 'Now, we can modify the code by adding the `Take` and `Skip` operators around
    the `foreach` loop, as shown in the following code:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过在`foreach`循环周围添加`Take`和`Skip`操作符来修改代码，如下所示：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding `TakeAndSkipOperator()` method, we add a couple of line of
    code in the highlighted lines. Now, although we have a lot of data, the output
    will be displayed conveniently when we run the method, as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`TakeAndSkipOperator()`方法中，我们在高亮显示的行中添加了一些代码。现在，尽管我们有很多数据，但当我们运行该方法时，输出将会很方便地显示如下：
- en: '![Filtering](img/Image00054.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00054.jpg)'
- en: As you can see, the entire result is not presented on the console, only ten
    integers each time. Users can press **Enter** key if they want to continue to
    read the rest of data. This is what we usually call pagination. The `Take` and
    `Skip` operators have done a good job to achieve it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，整个结果并没有全部显示在控制台上，每次只显示十个整数。用户可以按**Enter**键，如果他们想要继续阅读其余的数据。这通常被称为分页。`Take`和`Skip`操作符已经很好地实现了这一点。
- en: 'Besides discussing `Take` and `Skip` operators, we are going to discuss `TakeWhile`
    and `SkipWhile` operators in filtering operators. In `TakeWhile` operator, the
    input collection will be enumerated and each element will be sent to the query
    until the predicate is `false` . In contrast, the input collection will be enumerated,
    and when the predicate is `true` , the element will be sent to the query. Now,
    let''s take a look at the following code to demonstrate the `TakeWhile` and `SkipWhile`
    operators:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了讨论`Take`和`Skip`操作符，我们还将讨论过滤操作符中的`TakeWhile`和`SkipWhile`操作符。在`TakeWhile`操作符中，输入集合将被枚举，每个元素将被发送到查询，直到谓词为`false`。相反，在`SkipWhile`中，当输入集合被枚举时，当谓词为`true`时，元素将被发送到查询。现在，让我们看一下下面的代码来演示`TakeWhile`和`SkipWhile`操作符：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When we run the preceding method, we will get the following output on the console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的方法时，将在控制台上得到以下输出：
- en: '![Filtering](img/Image00055.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00055.jpg)'
- en: Since we have `n < 50` in the predicate, in `TakeWhile` , the enumeration will
    emit the elements until it reaches `53` , and in `SkipWhile` , the element start
    to be emitted when the enumeration reaches `53` .
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在谓词中有`n < 50`，在`TakeWhile`中，枚举将会发出元素，直到达到`53`，而在`SkipWhile`中，当枚举到达`53`时，元素开始被发出。
- en: 'We also have the `Distinct` operator in this filtering operation. The `Distinct`
    operator will return the input sequence without any duplicate elements. Suppose
    we have the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过滤操作中，我们还有`Distinct`操作符。`Distinct`操作符将返回没有任何重复元素的输入序列。假设我们有以下代码：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the preceding code, we have a string and we intend to remove all duplicate
    letters in that string. We use the `Distinct` operator to get the query and then
    enumerate it. The result will be as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们有一个字符串，我们打算删除该字符串中的所有重复字母。我们使用`Distinct`操作符来获取查询，然后枚举它。结果将如下所示：
- en: '![Filtering](img/Image00056.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![Filtering](img/Image00056.jpg)'
- en: As you can see, there are some letters that have disappeared due to the use
    of the `Distinct` operator. There are no duplicate letters that appear in this
    case.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，由于使用了`Distinct`操作符，一些字母已经消失了。在这种情况下，没有重复的字母出现。
- en: Projection
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 投影
- en: Projection is an operation that transforms an object into a new form. There
    are two projection operators; they are `Select` and `SelectMany` . Using the `Select`
    operator, we can transform each input element based on the given lambda expression,
    whereas using the `SelectMany` operator, we can transform each input element and
    then and flatten the resulting sequences into one sequence by concatenating them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 投影是将对象转换为新形式的操作。有两个投影操作符，它们是`Select`和`SelectMany`。使用`Select`操作符，我们可以根据给定的lambda表达式转换每个输入元素，而使用`SelectMany`操作符，我们可以转换每个输入元素，然后通过连接它们来将结果序列扁平化为一个序列。
- en: 'We had applied the `Select` operator when we discussed deferring LINQ execution.
    The following is the code snippet that uses the `Select` operator that we extract
    from the sample in Deferring LINQ execution topic:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论延迟执行LINQ时，我们应用了`Select`操作符。以下是使用`Select`操作符的代码片段，我们从延迟执行LINQ主题的示例中提取出来的：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see, we use the `Select` operator, which is the `Select` keyword
    in this case since we use the query expression syntax, to select all the resulting
    elements filtered by the `Where` keyword. As we know from the `Select` operator,
    the object can be transformed into another form, and we can transform that element
    typed `Member` class object into the element typed `RecentMember` class object
    using the following code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们使用了`Select`操作符，这里是`Select`关键字，因为我们使用了查询表达式语法，来选择所有由`Where`关键字过滤的结果元素。正如我们从`Select`操作符中知道的，对象可以被转换成另一种形式，我们可以使用以下代码将以`Member`类对象类型的元素转换为以`RecentMember`类对象类型的元素：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the preceding code, we assume that there is a class named `RecentMember`
    , as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的代码，我们假设有一个名为`RecentMember`的类，如下所示：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'From the preceding code snippet, we can see that we transform each input element
    using the `Select` operator. We can insert the code snippet into the following
    complete source:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，我们可以看到我们使用`Select`操作符来转换每个输入元素。我们可以将代码片段插入到以下完整的源代码中：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since we have enumerated the query using the `foreach` iterator and have written
    the element to the console using the `Console.WriteLine()` method, after running
    the preceding `SelectOperator()` method, we will get the following output on the
    console:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经使用`foreach`迭代器枚举了查询，并使用`Console.WriteLine()`方法将元素写入控制台，在运行前面的`SelectOperator()`方法后，我们将在控制台上得到以下输出：
- en: '![Projection](img/Image00057.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![Projection](img/Image00057.jpg)'
- en: 'From the preceding console screenshot, we can see that we have successfully
    transformed the `Member` type input elements into the `RecentMember` type output
    elements. We can also use the fluent syntax to produce the exact same result,
    as shown in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的控制台截图中，我们可以看到我们成功地将`Member`类型的输入元素转换为`RecentMember`类型的输出元素。我们也可以使用流畅语法来产生完全相同的结果，如下面的代码片段所示：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s move on to the `SelectMany` operator. Using this operator, we can
    select more than one sequence and then flatten the result into one sequence. Suppose
    we have two collections and we are going to select all of them; we can achieve
    the goal using the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续讨论`SelectMany`操作符。使用这个操作符，我们可以选择多个序列，然后将结果展平成一个序列。假设我们有两个集合，我们要选择它们的所有元素；我们可以使用以下代码实现这个目标：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you can see, we have two collections named `numberTypes` and `numbers` and
    want to take any possible combination from their elements. The result is in a
    new form typed `NumberType` with the following definition:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有两个名为`numberTypes`和`numbers`的集合，想要从它们的元素中取出任何可能的组合。结果是以新形式`NumberType`的形式，定义如下：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we run the preceding `SelectManyOperator()` method, the following output
    will be displayed on the console:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`SelectManyOperator()`方法，将在控制台上显示以下输出：
- en: '![Projection](img/Image00058.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![Projection](img/Image00058.jpg)'
- en: 'In this code, we actually iterate the two collections to construct the combination
    of two collections since the implementation of the `SelectMany` operator is as
    follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们实际上迭代了两个集合，构造了两个集合的组合，因为`SelectMany`操作符的实现如下：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also apply the query expression syntax to replace the preceding fluent
    syntax using the following code snippet:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以应用查询表达式语法来替换前面的流畅语法，使用以下代码片段：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output from the query expression syntax will be exactly the same as the
    fluent syntax.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用查询表达式语法的输出将与流畅语法完全相同。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `from` keyword has two different meanings in the query expression syntax.
    When we use the keyword at the start of the syntax, it will introduce the original
    range variable and the input sequence. When we use the keyword anywhere other
    than at the beginning, it will be translated into the `SelectMany` operator.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`from`关键字在查询表达式语法中有两个不同的含义。当我们在语法的开头使用关键字时，它将引入原始范围变量和输入序列。当我们在任何位置使用关键字时，它将被转换为`SelectMany`操作符。'
- en: Joining
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接
- en: Joining is an operation that meshes different source sequences with no direct
    object model relationship into a single output sequence. Nevertheless, the elements
    in each source have to share a value that can be compared for equality. There
    are two joining operators in LINQ; they are `Join` and `GroupJoin` .
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是一种将不具有直接对象模型关系的不同源序列融合成单个输出序列的操作。然而，每个源中的元素都必须共享一个可以进行相等比较的值。在LINQ中有两个连接操作符；它们是`Join`和`GroupJoin`。
- en: 'The `Join` operator uses a lookup technique to match elements from two sequences
    and then returns a flat result set. To explain this further, let''s take a look
    at the following code, which we can find in the `Joining.csproj` project:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`Join`操作符使用查找技术来匹配两个序列的元素，然后返回一个扁平的结果集。为了进一步解释这一点，让我们看一下在`Joining.csproj`项目中可以找到的以下代码：'
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The preceding code consumes `Student` and `Course` classes with the following
    implementation:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码使用了以下实现的`Student`和`Course`类：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we run the preceding `JoinOperator()` method, we will get the following
    output on the console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`JoinOperator()`方法，我们将在控制台上得到以下输出：
- en: '![Joining](img/Image00059.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Joining](img/Image00059.jpg)'
- en: 'From the preceding code, we can see that we have two sequences, which are `courses`
    and `students` . We can join these two sequences using the `Join` operator and
    then we create an anonymous type as the result. We can also use the query expression
    syntax to join these two sequences. The following is the code snippet we have
    to replace in our previous query creation:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们可以看到我们有两个序列，它们是`courses`和`students`。我们可以使用`Join`操作符连接这两个序列，然后创建一个匿名类型作为结果。我们也可以使用查询表达式语法来连接这两个序列。以下是我们必须在之前的查询创建中替换的代码片段：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we run the `JoinOperator()` method again, we will get the exact same output
    on the console.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行`JoinOperator()`方法，我们将在控制台上得到完全相同的输出。
- en: 'The `GroupJoin` operator uses the same technique that the `Join` operator uses,
    but it returns a hierarchical result set. Let''s take a look at the following
    code that explains the `GroupJoin` operator:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupJoin`操作符使用与`Join`操作符相同的技术，但返回一个分层结果集。让我们看一下下面解释`GroupJoin`操作符的代码：'
- en: '[PRE38]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code is similar to the Join operator code that we discussed earlier.
    The difference is in the way we create the query. In the `GroupJoin` operator,
    we join the two sequences into another sequence with a key. Let''s invoke the
    preceding `GroupJoinOperator()` method, and we will get the following output on
    the console:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与我们之前讨论过的Join操作符代码类似。不同之处在于我们创建查询的方式。在`GroupJoin`操作符中，我们将两个序列与一个键合并为另一个序列。让我们调用前面的`GroupJoinOperator()`方法，我们将在控制台上得到以下输出：
- en: '![Joining](img/Image00060.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![Joining](img/Image00060.jpg)'
- en: As you can see in the output, we group all the students who take a particular
    course. We then enumerate the query to get the result.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中所见，我们对所有选修特定课程的学生进行分组，然后枚举查询以获得结果。
- en: Ordering
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'Ordering is an operation that will sort the return sequence from the input
    sequence using the default comparer. For instance, if we have a sequence in the
    string type, the default comparer will perform an alphabetical sort from A to
    Z. Let''s take a look at the following code, which we can find in the `Ordering.csproj`
    project:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是一种操作，它将使用默认比较器对输入序列的返回序列进行排序。例如，如果我们有一个字符串类型的序列，那么默认比较器将按字母顺序从A到Z进行排序。让我们看一下以下代码，可以在`Ordering.csproj`项目中找到：
- en: '[PRE39]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'For the sequence that we have to feed to the query, the code is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们必须提供给查询的序列，代码如下：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we run the preceding `OrderByOperator()` method, we will get the following
    output on the console:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的`OrderByOperator()`方法，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00061.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00061.jpg)'
- en: 'As you can see, we execute the ordering operation using the default comparer,
    so the sequence is sorted alphabetically. We can also use the query expression
    syntax to replace the following code snippet:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用默认比较器执行了排序操作，因此序列按字母顺序排序。我们还可以使用查询表达式语法来替换以下代码片段：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The query expression syntax we have for the sequence is shown in the following
    code snippet:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对序列的查询表达式语法如下代码片段所示：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can create our own comparer as the key selector to sort the sequence by
    the last character in each element; here is the code we can use to achieve this
    using the `IComparer<T>` interface. Suppose we want to sort our previous sequence:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的比较器作为键选择器，通过每个元素的最后一个字符对序列进行排序；以下是我们可以使用`IComparer<T>`接口来实现这一点的代码。假设我们要对先前的序列进行排序：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We also create a new class, `LastCharacterComparer` , which inherits the `IComparer<string>`
    interface, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个新类`LastCharacterComparer`，它继承了`IComparer<string>`接口，如下所示：
- en: '[PRE44]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will get the following output on the console when we run the preceding `OrderByOperatorWithComparer()`
    method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行前面的`OrderByOperatorWithComparer()`方法时，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00062.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00062.jpg)'
- en: As you can see, we have an ordered sequence now, but the sorting key is the
    last character of each element. This is achieved with the help of our custom comparer.
    Unfortunately, the custom comparer is only available using the fluent syntax.
    In other words, we can't use it in the query expression method.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们现在有一个有序的序列，但排序键是每个元素的最后一个字符。这是通过我们自定义的比较器实现的。不幸的是，自定义比较器只能在流畅语法中使用。换句话说，我们不能在查询表达式方法中使用它。
- en: 'When we sort the sequence, we can have more than one comparer as a condition.
    We can use the `ThenBy` extension method for the second condition after we call
    the `OrderBy` method. Let''s take a look at the following code to demonstrate
    this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对序列进行排序时，可以有多个比较器作为条件。在调用`OrderBy`方法后，我们可以使用`ThenBy`扩展方法来进行第二个条件的排序。让我们看一下以下代码来演示这一点：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'From the preceding code, we sort the sequence by the length of each element,
    and then we sort the result alphabetically. If we call the `OrderByThenByOperator()`
    method, we will get the following output:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，我们按每个元素的长度对序列进行排序，然后按字母顺序对结果进行排序。如果我们调用`OrderByThenByOperator()`方法，将得到以下输出：
- en: '![Ordering](img/Image00063.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00063.jpg)'
- en: 'We can also use query expression syntax when we need to sort a sequence using
    two conditions, as shown in the following code snippet:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要使用两个条件对序列进行排序时，也可以使用查询表达式语法，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If we run `OrderByThenByOperator()` method again after replacing the query operation
    with the query expression syntax, we will get the exact same output as we get
    when we use the fluent syntax. However, there is no `ThenBy` keyword in the query
    expression syntax. What we need to do is just separate the condition using a comma.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在用查询表达式语法替换查询操作后再次运行`OrderByThenByOperator()`方法，我们将得到与使用流畅语法时相同的输出。然而，在查询表达式语法中没有`ThenBy`关键字。我们只需要用逗号分隔条件。
- en: 'We can use our custom comparer in the use of the `ThenBy` method as well. Let''s
    take a look at the following code to try this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在使用`ThenBy`方法时使用自定义比较器。让我们看一下以下代码来尝试这个：
- en: '[PRE47]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In this code, we use the same `LastCharacterComparer` class that we use in
    the `OrderByOperatorWithComparer()` method. If we call the `OrderByThenByOperatorWithComparer()`
    method, the following is the output we will get on the console:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们使用了与`OrderByOperatorWithComparer()`方法中相同的`LastCharacterComparer`类。如果我们调用`OrderByThenByOperatorWithComparer()`方法，将在控制台上得到以下输出：
- en: '![Ordering](img/Image00064.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![Ordering](img/Image00064.jpg)'
- en: 'Besides ascending sorting, we also have descending sorting. In fluent syntax,
    we can simply use `OrderByDescending()` and `ThenByDescending()` methods. The
    usage in code is exactly the same, as the code for sorting in an ascending order.
    However, in the query expression syntax, we have the descending keyword to achieve
    this goal. We use this keyword just after we define the condition in the `orderby`
    keyword, as shown in the following code:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 除了升序排序，我们还有降序排序。在流畅语法中，我们可以简单地使用`OrderByDescending()`和`ThenByDescending()`方法。在代码中的使用方式与按升序排序的代码完全相同。然而，在查询表达式语法中，我们有descending关键字来实现这个目标。我们在`orderby`关键字中定义条件后，使用这个关键字，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, there is a descending keyword in the as well code. Actually,
    we can replace the descending keyword with the ascending keyword in order to sort
    the sequence in an ascending manner. However, ascending sorting is the default
    sorting in LINQ, so the ascending keyword can be omitted. The following is the
    output if we run the code and invoke the `OrderByDescendingOperator()` method:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码中也有一个descending关键字。实际上，我们可以用ascending关键字替换descending关键字，以按升序对序列进行排序。然而，在LINQ中，升序排序是默认排序，因此可以省略ascending关键字。如果运行代码并调用`OrderByDescendingOperator()`方法，将得到以下输出：
- en: '![Ordering](img/Image00065.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![排序](img/Image00065.jpg)'
- en: Grouping
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: Grouping is an operation that will generate a sequence of `IGrouping<TKey, TElement>`
    objects, which are grouped by the `TKey` key value. For instance, we will group
    a sequence of path address files in one directory by their first letters. The
    following code can be found in the `Grouping.csproj` project file and will search
    all file in `G:\packages` , which is the setup files of Visual Studio 2015 Community
    Edition. You can adjust the drive letter and folder name based on the drive letter
    and folder name on your computer.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 分组是一种操作，将生成一系列`IGrouping<TKey, TElement>`对象，这些对象根据`TKey`键值进行分组。例如，我们将按照它们文件名的第一个字母，将一个目录中的路径地址文件序列进行分组。以下代码可以在`Grouping.csproj`项目文件中找到，并将搜索`G:\packages`中的所有文件，这是Visual
    Studio 2015 Community Edition的安装文件。您可以根据计算机上的驱动器号和文件夹名称调整驱动器号和文件夹名称。
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The preceding code will find all files in the `G:\packages` folder (including
    all the subdirectories) then group them based on the first letter in their filenames.
    As you can see when we enumerate a query using the `foreach` loop, we have `g.Key`
    , which is the key selector for grouping that string list. If we run the `GroupingByFileNameExtension()`
    method, we will get the following output on the console:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将在`G:\packages`文件夹中（包括所有子目录）找到所有文件，然后根据它们文件名的第一个字母进行分组。如您所见，当我们使用`foreach`循环枚举查询时，我们有`g.Key`，它是用于对字符串列表进行分组的键选择器。如果运行`GroupingByFileNameExtension()`方法，将在控制台上得到以下输出：
- en: '![Grouping](img/Image00066.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![分组](img/Image00066.jpg)'
- en: 'The `GroupBy` extension method also has a clause in order to be used in the
    query expression syntax. The clauses we can use are `group` and `by` . The following
    code snippet can replace the query in our previous code:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupBy`扩展方法还有一个子句，可以在查询表达式语法中使用。我们可以使用的子句是`group`和`by`。以下代码片段可以替换我们先前代码中的查询：'
- en: '[PRE50]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We will still have the same output as the fluent syntax output, although we
    replace the query using the query expression syntax. As you can see, the grouping
    operation in LINQ only groups the sequence; it does not sort. We can sort the
    result using the `OrderBy` operator provided by LINQ.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然会得到与流畅语法输出相同的输出，尽管我们使用查询表达式语法替换了查询。如您所见，LINQ中的分组操作只对序列进行分组，而不进行排序。我们可以使用LINQ提供的`OrderBy`操作符对结果进行排序。
- en: 'In the preceding query expression syntax, we see that we do not need the select
    clause again since the group clause will end the query as well. However, we still
    need the select clause when using the group clause if we add a query continuation
    clause. Now let''s we take a look at the following code, which applies the query
    continuation clause to sort the sequence:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的查询表达式语法中，我们看到由于group子句也会结束查询，因此我们不需要再次使用select子句。然而，当使用group子句并添加查询继续子句时，我们仍然需要select子句。现在让我们看一下以下代码，它应用了查询继续子句来对序列进行排序：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see in the preceding code, we modify the query by adding the query
    continuation clause and the `orderby` operator to sort the sequence result. The
    query continuation clause we use is the `into` keyword. Using the `into` keyword,
    we store the grouping result, and then we manipulate the grouping again. If we
    run the preceding code, we will get the following output on the console:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的代码所示，我们通过添加查询继续子句和`orderby`操作符来修改查询，以对序列结果进行排序。我们使用的查询继续子句是`into`关键字。使用`into`关键字，我们存储分组结果，然后再次操作分组。如果运行前面的代码，将在控制台上得到以下输出：
- en: '![Grouping](img/Image00067.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![分组](img/Image00067.jpg)'
- en: We deliberately remove the elements of each group since what we want to examine
    now is the key itself. Now, we can see that the key is in the ascending order.
    This happens since we first store the result of the grouping then we sort the
    key in an ascending manner.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意删除了每个组的元素，因为我们现在要检查的是键本身。现在我们可以看到键是按升序排列的。这是因为我们首先存储了分组的结果，然后按升序对键进行排序。
- en: The set operation
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合操作
- en: The set operation is an operation that returns a result set that is based on
    the presence or the absence of equivalent elements within the same or separate
    collection. There are four set operators that LINQ provides; they are `Concat`
    , `Union` , `Intersect` , and `Except` . For all the four set operators, there
    is no query expression keyword.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 集合操作是一种基于相同或不同集合中等价元素的存在或不存在而返回结果集的操作。LINQ提供了四种集合操作符，它们是`Concat`，`Union`，`Intersect`和`Except`。对于这四种集合操作符，都没有查询表达式关键字。
- en: 'Let''s start with `Concat` and `Union` . Using the `Concat` operator, we will
    get all the elements of first sequence followed by all the elements of the second
    sequence as a result. `Union` does this with the `Concat` operator but returns
    only one element for the duplicate elements. The following code, which we can
    find in the `SetOperation.csproj` project, demonstrates the difference between
    `Concat` and `Union` :'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`Concat`和`Union`开始。使用`Concat`运算符，我们将得到第一个序列的所有元素，然后是第二个序列的所有元素。`Union`使用`Concat`运算符执行此操作，但对于重复的元素只返回一个元素。以下代码在`SetOperation.csproj`项目中可以找到，演示了`Concat`和`Union`之间的区别：
- en: '[PRE52]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The two sequences we have as as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个序列如下：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Our preceding code tries to use the `Concat` and `Union` operators. And as
    per our discussion, the following is the output we will get if we run the `ConcatUnionOperator()`
    method:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的代码尝试使用`Concat`和`Union`运算符。根据我们的讨论，如果我们运行`ConcatUnionOperator()`方法，将得到以下输出：
- en: '![The set operation](img/Image00068.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![集合操作](img/Image00068.jpg)'
- en: 'The `Intersect` and `Except` are set operators as well. `Intersect` returns
    the elements that are present in both of the input sequences. `Except` returns
    the elements of the first input sequence, which are not present in the second.
    The following code explains the difference between `Intersect` and `Except` :'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intersect`和`Except`也是集合运算符。`Intersect`返回两个输入序列中都存在的元素。`Except`返回第一个输入序列中不在第二个序列中的元素。以下代码解释了`Intersect`和`Except`之间的区别：'
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we invoke the `IntersectExceptOperator()` method, the following output will
    be displayed on the console screen:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用`IntersectExceptOperator()`方法，将在控制台屏幕上显示以下输出：
- en: '![The set operation](img/Image00069.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![集合操作](img/Image00069.jpg)'
- en: We apply the two sequences we used earlier in the `ConcatUnionOperator()` method
    as an input. As you can see from the preceding console screenshot, in the `Intersect`
    operation, only duplication elements are returned. In the `Except` operation,
    only the unique element will be returned.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将之前在`ConcatUnionOperator()`方法中使用的两个序列作为输入。从上述控制台截图中可以看出，在`Intersect`操作中，只返回重复的元素。在`Except`操作中，只返回唯一的元素。
- en: Conversion methods
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换方法
- en: The main role of conversion methods is to convert one type of collections to
    other types of collection. Here, we will discuss the conversion methods provided
    by LINQ; they are `OfType` , `Cast` , `ToArray` , `ToList` , `ToDictionary` ,
    and `ToLookup` .
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 转换方法的主要作用是将一种类型的集合转换为其他类型的集合。在这里，我们将讨论LINQ提供的转换方法；它们是`OfType`、`Cast`、`ToArray`、`ToList`、`ToDictionary`和`ToLookup`。
- en: 'The `OfType` and `Cast` methods have a similar function; they convert `IEnumerable`
    into `IEnumerable<T>` . The difference is that `OfType` will discard the wrong
    type elements, if any, and `Cast` will throw an exception if there is any wrong
    type element. Let''s take a look at the following code, which we can find in the
    `ConversionMethods.csproj` project:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`OfType`和`Cast`方法具有类似的功能；它们将`IEnumerable`转换为`IEnumerable<T>`。不同之处在于，`OfType`将丢弃错误类型的元素（如果有的话），而`Cast`将在存在错误类型元素时抛出异常。让我们来看一下以下代码，在`ConversionMethods.csproj`项目中可以找到：'
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The preceding code is a simple example of using the `OfType` and `Cast` conversions.
    We have an array that contains only `int` elements. Indeed, they can be converted
    easily. The following will be the output if we run the `OfTypeCastSimple()` method:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是使用`OfType`和`Cast`转换的一个简单示例。我们有一个只包含`int`元素的数组。实际上，它们可以很容易地转换。如果我们运行`OfTypeCastSimple()`方法，将得到以下输出：
- en: '![Conversion methods](img/Image00070.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![转换方法](img/Image00070.jpg)'
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In .NET Core, `ArrayList` definition lies in `System.Collections.NonGeneric.dll`
    . Hence, we have to download the NuGet package on [https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET Core中，`ArrayList`的定义位于`System.Collections.NonGeneric.dll`中。因此，我们必须在[https://www.nuget.org/packages/System.Collections.NonGeneric/](https://www.nuget.org/packages/System.Collections.NonGeneric/)上下载NuGet包。
- en: 'Now let''s add several lines of code to the preceding code. The code will now
    be as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向上述代码添加几行代码。代码现在将如下所示：
- en: '[PRE56]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: From the preceding code, we can see that we changed the method name to `OfTypeCastComplex`
    and inserted the code to add a string element to `arrayList` . If we run the method,
    the `OfType` conversion will run successfully and return only the `int` element,
    while the `Cast` conversion will throw an exception since there are some string
    elements in the input sequence.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述代码中，我们可以看到，我们将方法名称更改为`OfTypeCastComplex`，并插入了将字符串元素添加到`arrayList`的代码。如果我们运行该方法，`OfType`转换将成功运行并仅返回`int`元素，而`Cast`转换将抛出异常，因为输入序列中有一些字符串元素。
- en: The others conversion methods are `ToArray()` and `ToList()` . The difference
    between them is that `ToArray()` will convert the sequence into an array and `ToList()`
    into a generic list. Also, `ToDictionary()` and `ToLookup()` method names are
    available for conversion. `ToDictionary()` will create `Dictionary<TKey, TValue>`
    from the sequence based on a specified key selector function, and `ToLookup()`
    will create `Lookup<TKey, TElement>` from the sequence based on the specified
    key selector and element selector functions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 其他的转换方法包括`ToArray()`和`ToList()`。它们之间的区别在于，`ToArray()`将序列转换为数组，而`ToList()`将转换为通用列表。此外，还有`ToDictionary()`和`ToLookup()`方法可用于转换。`ToDictionary()`将根据指定的键选择器函数从序列中创建`Dictionary<TKey,
    TValue>`，而`ToLookup()`将根据指定的键选择器和元素选择器函数从序列中创建`Lookup<TKey, TElement>`。
- en: Element operation
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元素操作
- en: Element operation is an operation that extracts individual elements from the
    sequence according to their index or using a predicate. There are several element
    operators that exist in LINQ; they are `First` , `FirstOrDefault` , `Last` , `Single`
    , `SingleOrDefault` , `ElementAt` , and `DefaultIfEmpty` . Let's use the sample
    code to understand the function of all these element operators.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 元素操作是根据它们的索引或使用谓词从序列中提取单个元素的操作。LINQ中存在几个元素运算符；它们是`First`，`FirstOrDefault`，`Last`，`Single`，`SingleOrDefault`，`ElementAt`和`DefaultIfEmpty`。让我们使用示例代码来了解所有这些元素运算符的功能。
- en: 'The following is the code to demonstrate the element operator, which we can
    find in the `ElementOperation.csproj` project:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示元素运算符的代码，我们可以在`ElementOperation.csproj`项目中找到：
- en: '[PRE57]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code demonstrates the use of the `First` and `Last` operators.
    The numbers array is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码演示了`First`和`Last`运算符的使用。数字数组如下：
- en: '[PRE58]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Before we move further, let''s take a moment to look at the following output
    on the console if we run the `FirstLastOperator()` method:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步进行之前，让我们花一点时间看一下如果运行`FirstLastOperator()`方法，控制台上的以下输出：
- en: '![Element operation](img/Image00071.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![元素操作](img/Image00071.jpg)'
- en: From the output, we can find that the `First` operator will return the first
    element of the sequence, and the `Last` operator will return the last element.
    We can also use a lambda expression for the `First` and `Last` operators to filter
    the sequence. In the preceding example, we filtered the sequence to numbers that
    can be divided only by four.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以发现`First`运算符将返回序列的第一个元素，而`Last`运算符将返回最后一个元素。我们还可以使用lambda表达式来过滤序列的`First`和`Last`运算符。在前面的示例中，我们过滤了只能被四整除的数字序列。
- en: 'Unfortunately, the `First` and `Last` operators cannot return an empty value;
    instead, they throw an exception. Let''s examine the following code regarding
    the use of the `First` operator, which will return an empty sequence:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`First`和`Last`运算符不能返回空值；相反，它们会抛出异常。让我们检查以下代码，关于使用`First`运算符，它将返回一个空序列：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If we uncomment all commented code lines in the preceding code, the method will
    throw an exception since there's no number that can be divided by `10` . To solve
    this problem, we can use the `FirstOrDefault` operator instead, and it will return
    the default value because the numbers are in the sequence of integers. So, it
    will return the default value of the integer, which is `0` .
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们取消注释前面代码中的所有注释代码行，由于没有可以被`10`整除的数字，该方法将抛出异常。为了解决这个问题，我们可以使用`FirstOrDefault`运算符，它将返回默认值，因为数字是整数序列。因此，它将返回整数的默认值，即`0`。
- en: 'We also have `Single` and `SingleOrDefault` as element operators, and we can
    take a look at their use in the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`Single`和`SingleOrDefault`作为元素运算符，我们可以看一下它们在以下代码中的使用：
- en: '[PRE60]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If we run the preceding code, an exception is thrown due to the following code
    snippet:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，由于以下代码片段，将会抛出异常：
- en: '[PRE61]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Also, the following code snippet causes an error:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下代码片段会导致错误：
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The error occurs because the `Single` operator can only have one matching element.
    In the first code snippet, we have `2` , `4` , `6` , and `8` as the result. In
    the second code snippet, we have `3` , `6` , and `9` as the result.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 错误发生是因为`Single`运算符只能有一个匹配的元素。在第一个代码片段中，我们得到了`2`，`4`，`6`和`8`作为结果。在第二个代码片段中，我们得到了`3`，`6`和`9`作为结果。
- en: 'The `Element` operation also has `ElementAt` and `ElementAtOrDefault` operators
    to get the nth element from the sequence. Let''s take a look at the following
    code to demonstrate the operators:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`Element`操作还有`ElementAt`和`ElementAtOrDefault`运算符，用于从序列中获取第n个元素。让我们看一下以下代码，演示这些运算符的使用：'
- en: '[PRE63]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Like the `First` and `Last` operators, `ElementAt` has to return the value as
    well. The commented code lines in the preceding code will throw an exception since
    there's no element in index `11` . However, we can overcome this problem using
    `ElementAtOrDefault` , and then the commented lines will return the default value
    of `int` .
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 与`First`和`Last`运算符一样，`ElementAt`也必须返回值。在前面的代码中，注释的代码行将抛出异常，因为在索引`11`中没有元素。但是，我们可以使用`ElementAtOrDefault`来解决这个问题，然后注释的行将返回`int`的默认值。
- en: 'The last in element operation is the `DefaultIfEmpty` operator, which will
    return the default value in a sequence if no element is found in the input sequence.
    The following code will demonstrate the `DefaultIfEmpty` operator:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 元素操作中的最后一个是`DefaultIfEmpty`运算符，如果在输入序列中找不到元素，它将返回序列中的默认值。以下代码将演示`DefaultIfEmpty`运算符：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Since the return of the `DefaultIfEmpty` operator is `IEnumerable<T>` , we have
    to enumerate it, although it contains only one element. As you can see in the
    preceding code, we comment the direct access of the numbers variable because it
    will return the type of variable, not the value of the variable. Instead, we have
    to enumerate the numbers query to get the one and only value stored in the `IEnumerable<T>`
    variable.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`DefaultIfEmpty`运算符的返回值是`IEnumerable<T>`，我们必须对其进行枚举，即使它只包含一个元素。正如您在前面的代码中所看到的，我们注释了对numbers变量的直接访问，因为它将返回变量的类型，而不是变量的值。相反，我们必须枚举numbers查询，以获取存储在`IEnumerable<T>`变量中的唯一值。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'LINQ has made our task of querying a collection easier because we don''t need
    to learn much syntax to access different types of collections. It implements a
    deferred execution concept, which means that the query will not be executed in
    the constructor time but in the enumeration process. Almost all query operators
    provide the deferred execution concept; however, there are exceptions for the
    operators that do the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ使我们查询集合的任务变得更容易，因为我们不需要学习太多语法来访问不同类型的集合。它实现了延迟执行的概念，这意味着查询不会在构造函数中执行，而是在枚举过程中执行。几乎所有查询运算符都提供了延迟执行的概念；但是，对于执行以下操作的运算符，存在例外情况：
- en: Return a scalar value or single element, such as `Count` and `First` .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 返回标量值或单个元素，例如`Count`和`First`。
- en: Convert the result of query; they are `ToList` , `ToArray` , `ToDictionary`
    , and `ToLookup` . They are also called conversion operators.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将查询的结果转换为`ToList`，`ToArray`，`ToDictionary`和`ToLookup`。它们也被称为转换操作符。
- en: In other words, methods that return a sequence implement deferred execution
    for instance, the `Select` method `(IEnumerable<X>-> Select -> IEnumerable<Y>)`
     and methods that return a single object don't implement deferred execution, for
    instance, the `First` method `(IEnumerable<X>-> First -> Y)` .
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，返回序列的方法实现了延迟执行，例如`Select`方法`(IEnumerable<X>-> Select -> IEnumerable<Y>)`，而返回单个对象的方法不实现延迟执行，例如`First`方法`(IEnumerable<X>->
    First -> Y)`。
- en: There are two types of LINQ querying syntaxes; they are the fluent syntax and
    the query expression syntax. The former takes a lambda expression for the parameter
    to represent the logic that will be performed in the sequence enumeration. The
    latter is a shorthand syntax that we can use in order to perform LINQ queries.
    In the query expression syntax, .NET Framework provides the keywords for each
    query operator but not all operators. Our code will be more readable and required
    less coding when we use the query expression syntax. However, both fluent and
    query syntax will do the same thing. The difference between them is only the syntax.
    Each keyword in the query expression syntax has its own extension method in the
    `Enumerable` class.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ有两种查询语法；它们是流畅语法和查询表达式语法。前者采用lambda表达式作为参数，表示将在序列枚举中执行的逻辑。后者是一种简写语法，我们可以使用它来执行LINQ查询。在查询表达式语法中，.NET
    Framework为每个查询操作符提供关键字，但并非所有操作符。当我们使用查询表达式语法时，我们的代码将更易读，编码量也会减少。然而，流畅语法和查询语法都会做同样的事情。它们之间的区别只在于语法。查询表达式语法中的每个关键字都在`Enumerable`类中有自己的扩展方法。
- en: By understanding LINQ, we now have had enough knowledge to create functional
    programming. In the next chapter, we will discuss asynchronous programming in
    order to enhance code responsiveness in order to build user-friendly application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解LINQ，我们现在已经有足够的知识来创建函数式编程。在下一章中，我们将讨论异步编程，以增强代码的响应性，从而构建用户友好的应用程序。
