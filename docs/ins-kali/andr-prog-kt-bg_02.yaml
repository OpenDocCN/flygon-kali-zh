- en: Chapter 2. Kotlin, XML, and the UI Designer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Kotlin，XML和UI设计师
- en: 'At this stage, we have a working Android development environment and we have
    built and deployed our first app. It is obvious, however, that code autogenerated
    by Android Studio is not going to make the next top-selling app on Google Play.
    We need to explore this autogenerated code so that we can begin to understand
    Android and then learn how to build on this useful template. With this aim in
    mind, we will do the following in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经有了一个可用的Android开发环境，并且已经构建并部署了我们的第一个应用程序。然而，显然，由Android Studio自动生成的代码不会成为下一个畅销的Google
    Play应用程序。我们需要探索这些自动生成的代码，以便开始了解Android，然后学习如何构建这个有用的模板。为了达到这个目的，我们将在本章中进行以下操作：
- en: See how to get technical feedback from our apps.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何从我们的应用程序中获得技术反馈。
- en: Examine the Kotlin code and **User Interface** (**UI**) XML code from our first
    app.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们第一个应用程序的Kotlin代码和用户界面（UI）XML代码。
- en: Get our first taste of using the Android UI designer.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次尝试使用Android UI设计师。
- en: Write our first Kotlin code.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写我们的第一个Kotlin代码。
- en: Learn some core Kotlin fundamentals and how they relate to Android.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习一些核心的Kotlin基础知识以及它们与Android的关系。
- en: First, let's see how to get feedback from our apps.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看如何从我们的应用程序中获得反馈。
- en: Examining the log output
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查日志输出
- en: In the previous chapter, we mentioned that our app was running in debug mode
    on the emulator or real device; this is so that we can monitor it and get feedback
    when things go wrong. So, where is all this feedback?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到我们的应用程序在模拟器或真实设备上以调试模式运行；这样我们就可以监视它，并在出现问题时获得反馈。那么，所有这些反馈在哪里呢？
- en: 'You might have noticed a lot of scrolling text at the bottom of the Android
    Studio window. If not, click on the **logcat** tab, as shown by the highlighted
    area labeled as **1** in the following screenshot:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到Android Studio窗口底部有很多滚动文本。如果没有，请点击logcat选项卡，如下面截图中标有1的区域所示：
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that the emulator must be running, or a real device must be attached in
    debugging mode, for you to see the following window. Furthermore, if you restarted
    Android Studio for some reason and have not yet executed the app, then the **logcat**
    window will be empty. Refer to the first chapter to get the app running on an
    emulator or a real device:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，模拟器必须在运行状态，或者真实设备必须以调试模式连接，才能看到下面的窗口。此外，如果由于某种原因重新启动了Android Studio，并且尚未执行应用程序，则logcat窗口将为空。请参考第一章，在模拟器或真实设备上运行应用程序：
- en: '![Examining the log output](img/B12806_02_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![检查日志输出](img/B12806_02_01.jpg)'
- en: You can drag the window to make it taller, just as you can in most other Windows
    applications, if you want to see more.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要查看更多内容，您可以像大多数其他Windows应用程序一样，拖动窗口使其更高。
- en: This window is called **logcat**, or, sometimes, it is referred to as **console**.
    It is our app's way of telling us what is going on underneath what the user sees.
    If the app crashes or has errors, the reason or clues will appear here. If we
    need to output debugging information, we can do so here as well.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个窗口称为logcat，有时也被称为控制台。这是我们的应用程序告诉我们用户看不到的情况。如果应用程序崩溃或出现错误，原因或线索将出现在这里。如果我们需要输出调试信息，我们也可以在这里进行。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you just cannot work out why your app is crashing, copying and pasting a
    bit of the text from logcat into Google will often reveal the reason.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不明白为什么你的应用程序崩溃了，将logcat中的一部分文本复制粘贴到Google中通常会揭示原因。
- en: Filtering the logcat output
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤logcat输出
- en: You might have noticed that most, if not all, of the content of logcat is almost
    unintelligible. That's OK; right now, we are only interested in errors that will
    be highlighted in red and the debugging information that we will learn about next.
    In order to see less of the superfluous text in our **logcat** window, we can
    turn on some filters to make things clearer.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，logcat的大部分内容，如果不是全部，几乎是难以理解的。没关系；现在，我们只对将在红色中突出显示的错误和我们将在下面学习的调试信息感兴趣。为了在logcat窗口中看到更少的无关文本，我们可以打开一些过滤器以使事情更清晰。
- en: In the previous screenshot, I highlighted two more areas, as **2** and **3**.
    Area **2** is the drop-down list that controls the first filter. Left-click on
    it now and change it from **Verbose** to **Info**. We have cut down the text output
    significantly. We will see how this is useful when we have made some changes to
    our app and redeployed it. We will do this after we have explored the code and
    the assets that make up our project. Also, double-check that the area labeled
    as **3** says **Show only the selected application**. If it doesn't, left-click
    on it and change it to **Show only the selected application**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一张截图中，我还突出显示了另外两个区域，标记为2和3。区域2是控制第一个过滤器的下拉列表。现在左键单击它，并将其从Verbose更改为Info。我们已经大大减少了文本输出。当我们对应用程序进行了一些更改并重新部署后，我们将看到这是有用的。在我们探索构成我们项目的代码和资产之后，我们将这样做。另外，请确保标记为3的区域显示为“仅显示所选应用程序”。如果不是，请左键单击它，并将其更改为“仅显示所选应用程序”。
- en: Now we can look at what Android Studio has automatically generated for us, and
    then we can set about changing and adding to the code to personalize it beyond
    what we got from the project creation phase.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以看一下Android Studio自动生成的内容，然后开始修改和添加代码，以个性化我们从项目创建阶段得到的内容。
- en: Exploring the project's Kotlin code and the main layout's XML code
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索项目的Kotlin代码和主要布局的XML代码
- en: We are going to look at the resource files containing the code that defines
    our simple UI layout and the file that has our Kotlin code. At this stage, we
    won't try to understand it all, as we need to learn some more basics before it
    makes sense to do so. What we will see, however, is the basic content and structure
    of both files, so we can reconcile their content with what we already know about
    Android resources and Kotlin.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看包含定义简单UI布局的代码的资源文件，以及包含我们Kotlin代码的文件。在这个阶段，我们不会试图理解所有内容，因为在理解之前我们需要学习更多的基础知识。然而，我们将看到这两个文件的基本内容和结构，以便将它们的内容与我们已经了解的Android资源和Kotlin知识相协调。
- en: Examining the MainActivity.kt file
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查MainActivity.kt文件
- en: 'Let''s take a look at the Kotlin code first. You can see this code by left-clicking
    on the `MainActivity.kt` tab, as shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们看一下Kotlin代码。你可以通过左键单击`MainActivity.kt`标签来查看这段代码，如下面的截图所示：
- en: '![Examining the MainActivity.kt file](img/B12806_02_02.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![检查MainActivity.kt文件](img/B12806_02_02.jpg)'
- en: 'As we are not looking at the intricate details of the code, an annotated screenshot
    is more useful than reproducing the actual code in text form. Regularly refer
    to the following screenshot while reading this section:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不会详细讨论代码的细节，带注释的截图比以文本形式重现实际代码更有用。在阅读本节时，请经常参考以下截图：
- en: '![Examining the MainActivity.kt file](img/B12806_02_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![检查MainActivity.kt文件](img/B12806_02_03.jpg)'
- en: The first thing to note is that I have added a few empty lines in among the
    code to space things out and present a clearer image.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我在代码中添加了一些空行，以便排版和呈现更清晰的图像。
- en: Code folding (hiding) in Android Studio
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Android Studio中折叠（隐藏）代码
- en: 'Now, look at the left-hand side of the window in Android Studio (not the preceding
    screenshot) and observe all the **+** and **-** buttons on the left-hand side
    of the editor that can collapse and expand parts of the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看一下Android Studio窗口的左侧（不是前面的截图），观察编辑器左侧的所有**+**和**-**按钮，可以折叠和展开代码的部分：
- en: '![Code folding (hiding) in Android Studio](img/B12806_02_04.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![在Android Studio中折叠（隐藏）代码](img/B12806_02_04.jpg)'
- en: I have collapsed some parts of the code, and have left other parts visible.
    So, what you can see on your screen is slightly different to what you will see
    if you look at the preceding screenshot. In Android Studio, play with the **+**
    and **–** buttons for a while to practice hiding and unhiding sections of the
    code. You might be able to get your screen to look like the preceding screenshot,
    but this is not a requirement to continue. The technical term for hiding code
    like this is called **folding** .
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经折叠了一些代码部分，留下了其他部分可见。因此，你屏幕上看到的与前面的截图略有不同。在Android Studio中，尝试一段时间使用左侧的**+**和**–**按钮，练习隐藏和显示代码的部分。你可能能够让你的屏幕看起来像前面的截图，但这并不是继续的要求。像这样隐藏代码的技术术语称为**折叠**。
- en: The package declaration
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包声明
- en: Part **1** is called the **package declaration** and, as you can see, it is
    the package name that we chose when we created the project, preceded by the word
    `package`. Every Kotlin file will have a package declaration at the top.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第**1**部分称为**包声明**，正如你所看到的，它是我们在创建项目时选择的包名称，前面加上`package`这个词。每个Kotlin文件的顶部都会有一个包声明。
- en: Importing classes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导入类
- en: Part **2** is six lines of code that all begin with `import`. After `import,`
    we can see there are various dot-separated words. The last word of each line is
    the name of the class that line imports into our project, and all the earlier
    words in each line are the packages and subpackages that contain these classes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第**2**部分是六行代码，都以`import`开头。在`import`之后，我们可以看到各种用点分隔的单词。每行的最后一个单词是该行导入到我们项目中的类的名称，而每行中较早的单词都是包和子包，其中包含这些类。
- en: 'For example, this next line imports the `AppCompatActivity` class from the
    `androidx.appcompat.app` package and subpackages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下一行导入了`androidx.appcompat.app`包和子包中的`AppCompatActivity`类：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This means that in our project, we will have access to these classes. In fact,
    it is these classes that the autogenerated code uses to make our simple app, which
    we saw in action in the previous chapter.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在我们的项目中，我们将可以访问这些类。实际上，正是这些类被自动生成的代码用来制作我们在上一章中看到的简单应用程序。
- en: We will not discuss all of these classes in this chapter. It is just the idea
    that we can do this importing of classes that gives us access to more functionality
    that is significant right now. Note that we can add extra classes from any package
    at any time, and we will do so when we improve upon our app shortly.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们不会讨论所有这些类。重要的是我们可以导入这些类，这使我们能够立即获得更多功能。请注意，我们可以随时从任何包中添加额外的类，并且在不久的将来我们将这样做以改进我们的应用程序。
- en: The class declaration
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类声明
- en: 'Part **3** of our code is called the **class declaration**. Here is that line
    in full; I have highlighted one part of it, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码的第**3**部分称为**类声明**。以下是完整的那一行；我已经突出显示了其中的一部分，如下所示：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The class declaration is the start of a class. Notice that the highlighted part,
    `MainActivity`, is the name that was autogenerated when we created the project
    and is also the same as the `MainActivity.kt` filename. This is as we would expect,
    having discussed Kotlin classes previously.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 类声明是类的开始。请注意，突出显示的部分`MainActivity`是在创建项目时自动生成的名称，也与`MainActivity.kt`文件名相同。这正如我们之前讨论过的Kotlin类一样。
- en: The colon (`:`) means that our class called `MainActivity` will be of the type
    `AppCompatActivity`. This indicates that although there are not that many lines
    of code in this file, we are also using more code that we don't see that comes
    from the `AppCompatActivity` class. All this and more will become clear in [Chapter
    10,](ch10.html "Chapter 10. Object-Oriented Programming") *Object-Oriented Programming*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号(`:`)表示我们的名为`MainActivity`的类将是`AppCompatActivity`类型。这表明，虽然这个文件中的代码行数不多，但我们也使用了更多的代码，这些代码来自`AppCompatActivity`类。所有这些以及更多内容将在[第10章](ch10.html
    "第10章.面向对象编程")*面向对象编程*中变得清晰。
- en: 'Finally, for part **3**, look at the opening curly brace at the end of the
    line: `{`. Now look at the bottom of the screenshot at part **4** of our code.
    This closing curly brace (`}`) denotes the end of the class. Everything in between
    the opening and closing curly braces, `{...},` is part of the class.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于第**3**部分，看一下行末的左花括号：`{`。现在看看我们代码截图的第**4**部分。这个右花括号(`}`)表示类的结束。在左右花括号之间的所有内容，`{...},`都是类的一部分。
- en: Functions inside the class
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类内的函数
- en: 'Now look at part **5** of the code. Here is that line of code in full, with
    the key part for our current discussion highlighted:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看代码的第**5**部分。这是完整的代码行，其中突出显示了我们当前讨论的关键部分：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a function **signature**. The highlighted part, `onCreate`, is the function
    **name**. The Kotlin `fun` keyword makes it clear that this is the start of a
    function. We make a function execute its code by using its name. We say we are
    **calling** a function when we do this.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个函数**签名**。高亮显示的部分`onCreate`是函数**名称**。Kotlin的`fun`关键字清楚地表明这是函数的开始。我们通过使用函数的名称来执行其代码。当我们这样做时，我们说我们正在**调用**一个函数。
- en: Although we will not concern ourselves now with the parts of the code on either
    side of the function name, you might have noticed `Bundle`, one of the classes
    that we imported in part **2** of our code. If we remove that related `import`
    line, Android Studio will not know what the `Bundle` class is, and it will be
    unusable and highlighted in red underline as an error.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们现在不会关心函数名两侧的代码部分，但你可能已经注意到`Bundle`，这是我们在代码的第**2**部分中导入的类之一。如果我们删除相关的`import`行，Android
    Studio将不知道`Bundle`类是什么，它将无法使用，并且会以红色下划线突出显示为错误。
- en: Our code will then not compile and run. Notice that the very last thing in the
    line of the preceding code is an opening curly brace (`{`). This denotes the start
    of the code contained within the `onCreate` function. Now jump to part **6** of
    our code and you will see a closing curly brace (`}`). You might have guessed
    that this is the end of the function. Everything in between the opening and closing
    curly braces of the `onCreate` function is the code that executes when the function
    is called.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们的代码将无法编译和运行。请注意，前面代码行的最后一件事是一个左花括号（`{`）。这表示`onCreate`函数中包含的代码的开始。现在跳到我们代码的第**6**部分，您将看到一个右花括号（`}`）。您可能已经猜到这是函数的结束。在`onCreate`函数的左右花括号之间的所有代码都是在调用函数时执行的代码。
- en: We do not need to go into what this code does yet but, as an overview, it sets
    up the appearance and layout of the app by referring to some resource files that
    were autogenerated by Android Studio when we created the project. I have highlighted
    these resource files with an outline in the previous screenshot labeled **9**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不需要深入了解这段代码的作用，但是总体上，它通过引用一些由Android Studio在创建项目时自动生成的资源文件来设置应用的外观和布局。我在前面的截图中用标号**9**标出了这些资源文件的轮廓。
- en: Parts **7** and **8** are also functions that I have collapsed to make the screenshot
    and this discussion more straightforward. Their names are `onCreateOptionsMenu`
    and `onOptionsItemSelected`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 部分**7**和**8**也是我折叠起来以使截图和讨论更简单的函数。它们的名称分别是`onCreateOptionsMenu`和`onOptionsItemSelected`。
- en: We know enough about our Kotlin code to make some progress. We will see this
    code again and change it later in this chapter.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对我们的Kotlin代码了解足够多，可以取得一些进展。我们将在本章后面再次看到这段代码并进行更改。
- en: A summary of the Kotlin code so far
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 到目前为止的Kotlin代码摘要
- en: It is true that, contained within the preceding code, there is some complex
    syntax. However, what we are doing is building up just enough knowledge about
    this code, so that we can work within it and begin to make rapid progress in learning
    Kotlin and Android without having to read hundreds of pages of Kotlin theory first.
    By the end of the book, all the code will make sense. But in order to make quick
    progress now, we just need to accept that some of the details will remain a mystery
    for a little while longer.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，在前面的代码中包含了一些复杂的语法。然而，我们正在建立对这段代码的足够了解，以便我们可以在其中工作，并开始快速学习Kotlin和Android，而不必先阅读数百页的Kotlin理论。到本书结束时，所有的代码都会让人明白。但为了现在快速进展，我们只需要接受一些细节将在稍后一段时间内仍然是个谜。
- en: Examining the main layout file
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查主布局文件
- en: Now we will look at just one of the many `.xml` files. There are several different
    layout files and we will meet them all throughout the course of this book, but
    let's start with the most significant one that decides the appearance of our app.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将只看其中一个`.xml`文件。在本书的整个过程中，我们将遇到几个不同的布局文件，但让我们从最重要的一个开始，它决定了我们应用的外观。
- en: Left-click on the `content_main.xml` tab next to the `MainActivity.kt` tab that
    we have been discussing.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 单击我们一直在讨论的`MainActivity.kt`标签旁边的`content_main.xml`标签。
- en: 'In the main window on the right-hand side, you will see the **Design** view
    of our app, as shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的主窗口中，您将看到我们应用的**设计**视图，如下截图所示：
- en: '![Examining the main layout file](img/B12806_02_05.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![检查主布局文件](img/B12806_02_05.jpg)'
- en: Most of the work that we do throughout the book when we design apps will be
    done in this design view. It is important, however, to know what is going on behind
    the scenes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在设计应用程序时所做的大部分工作将在这个设计视图中完成。然而，了解背后发生了什么是很重要的。
- en: 'The design view is a graphical representation of the XML code contained in
    the `content_main.xml` file. Click on the **Text** tab (as outlined near the bottom-left
    in the previous screenshot) to see the XML code that forms the layout. I have
    annotated a screenshot of the XML text so that we can discuss it next:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 设计视图是`content_main.xml`文件中包含的XML代码的图形表示。单击**Text**标签（如前面截图底部附近所示）以查看构成布局的XML代码。我已经注释了XML文本的截图，以便我们可以接下来讨论它：
- en: '![Examining the main layout file](img/B12806_02_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![检查主布局文件](img/B12806_02_06.jpg)'
- en: The first thing to note is that this file does not represent the entire layout.
    It does, however, represent most of the surface area and the **Hello World** message
    in the center. Also, on the left-hand side, we can see the now familiar **+**
    and **–** icons so that we can fold and unfold sections of the code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，这个文件并不代表整个布局。但它确实代表了大部分的表面积和中心的**Hello World**消息。此外，在左侧，我们可以看到现在熟悉的**+**和**-**图标，以便我们可以折叠和展开代码的各个部分。
- en: UI layout elements
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI布局元素
- en: If we first look at the part of the code labeled **1**, we can see that the
    very first thing is `…ConstraintLayout...`. A `ConstraintLayout` element is a
    UI element that is used to wrap other parts of the UI.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们首先看一下标记为**1**的代码部分，我们会看到的第一件事是`…ConstraintLayout...`。`ConstraintLayout`元素是用于包装UI的UI元素。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are more technical and specific ways to refer to the different "elements"
    of our user interface designs. As we progress, we will introduce terminology such
    as widget, view, and view-group, as well.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有更多技术和具体的方式来指代我们用户界面设计的不同“元素”。随着我们的进展，我们将介绍诸如小部件、视图和视图组等术语。
- en: When we add a new element to a UI in Android, we always start a line with a
    left angle bracket (`<`) followed by the element's name.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Android中的UI中添加一个新元素时，我们总是以左尖括号（`<`）开头，后面跟着元素的名称。
- en: The code that follows this rather long and cumbersome-looking line defines the
    **attributes** that this element will have. This can include dozens of different
    things, depending upon the type of UI element it is. Here, among a bit of other
    XML, we can see things such as `layout_width`, `layout_height`, and `showIn`.
    All these attributes define how the `ConstraintLayout` element will appear on
    the user's screen. The attributes for the `ConstraintLayout` element end at the
    first right angle bracket (`>`), labeled **1b**.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随这行看起来相当长而繁琐的代码之后的代码定义了这个元素将具有的**属性**。这可能包括数十种不同的东西，取决于它是什么类型的UI元素。在这里，除了其他一些XML之外，我们可以看到诸如`layout_width`、`layout_height`和`showIn`之类的东西。所有这些属性定义了`ConstraintLayout`元素将如何出现在用户的屏幕上。`ConstraintLayout`元素的属性在第一个右尖括号（`>`）处结束，标记为**1b**。
- en: If we look at the bottom of our XML screenshot, we will see the code labeled
    **2**. This code, `</…ConstraintLayout>`, marks the end of the `ConstraintLayout`
    element Anything in between the closing right angle bracket (`>`) of the element's
    attributes and the `</…ConstraintLayout>` code that defines its end is considered
    a **child** of the element. So, we can see that our `ConstraintLayout` element
    has (or contains) a child. Let's take a look at that child now.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下XML截图的底部，我们会看到标记为**2**的代码。这段代码`</…ConstraintLayout>`标志着`ConstraintLayout`元素的结束。在元素的属性的右尖括号（`>`）和定义其结束的`</…ConstraintLayout>`代码之间的任何内容都被视为元素的**子元素**。因此，我们可以看到我们的`ConstraintLayout`元素有（或包含）一个子元素。现在让我们来看看这个子元素。
- en: UI text elements
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI文本元素
- en: 'Using what we have just learned, we can devise that the UI element that starts
    at position **3** in the screenshot is called a `TextView` element. Just like
    its parent, it starts with a left angle bracket (`<`) and its name: `<TextView...`.
    If we look further into our `TextView` element, we can see that it has several
    attributes. It has a `text` attribute that is set to `"Hello world!"`. This, of
    course, is the exact text that our app shows to the user. It also has `layout_width`
    and `layout_height` attributes that are both set to `"wrap_content"`. This tells
    the `TextView` element that it can take up as much space as the content it has
    needs, but no more. As we will see throughout the book, there are many more attributes
    available for this and other UI elements.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们刚刚学到的知识，我们可以推断出在截图的位置**3**开始的UI元素称为`TextView`元素。就像它的父元素一样，它以左尖括号（`<`）和它的名称开始：`<TextView...`。如果我们进一步查看我们的`TextView`元素，我们会发现它有几个属性。它有一个`text`属性，设置为`"Hello
    world!"`。当然，这就是我们的应用向用户显示的确切文本。它还有`layout_width`和`layout_height`属性，都设置为`"wrap_content"`。这告诉`TextView`元素，它可以占用所需的内容空间，但不会超过。正如我们将在本书中看到的，对于这个和其他UI元素，还有许多其他属性可用。
- en: 'Notice that the code at the **4** position on our XML screenshot is `/>`. This
    marks the end of the `TextView` element. This is slightly different to how the
    end of the `ConstraintLayout` element was written. When an element in XML has
    no children, we can just end it like this: `/>`. When the element has children
    and its end comes further on in the code from where its attributes are defined,
    it is much clearer to end the element by repeating its name like this: `</…ConstraintLayout>`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们的XML截图上**4**位置的代码是`/>`。这标志着`TextView`元素的结束。这与`ConstraintLayout`元素的结束方式略有不同。当XML中的元素没有子元素时，我们可以像这样结束它：`/>`。当元素有子元素并且其结束位置在其属性定义的代码之后时，通过重复其名称来结束元素会更清晰，像这样：`</…ConstraintLayout>`。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why the element name for the `TextView` element is short
    and concise (simply, `TextView`), yet the full name for the `ConstraintView` element
    is preceded by apparent complicated clutter (`androidx.constraintlayout.widget.ConstraintLayout`).
    This `ConstraintLayout` element is a special version of the layout that is used
    to ensure our app's compatibility with older versions of Android. As we will see
    in a minute, when we add buttons to the app, most elements have simple and concise
    names.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么`TextView`元素的元素名称简短而简洁（只是`TextView`），而`ConstraintView`元素的完整名称前面有明显复杂的杂乱（`androidx.constraintlayout.widget.ConstraintLayout`）。这个`ConstraintLayout`元素是布局的特殊版本，用于确保我们的应用与较旧版本的Android兼容。正如我们将在一分钟内看到的，当我们向应用添加按钮时，大多数元素都有简单而简洁的名称。
- en: We will edit this code in the next section and learn more about the attributes,
    as well as explore another type of UI element – that is, a `Button` element.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中编辑这段代码，并了解更多关于属性的知识，同时探索另一种类型的UI元素——即`Button`元素。
- en: Adding buttons to the main layout file
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将按钮添加到主布局文件
- en: Here, we will add a couple of buttons to the screen and will then explore a
    quick way to make them do something. We will add a button in two different ways;
    first, using the visual designer, and second, by adding to and editing the XML
    code directly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在屏幕上添加一对按钮，然后探索一种快速的方法让它们做一些事情。我们将以两种不同的方式添加按钮；首先，使用可视化设计师，其次，通过直接添加和编辑XML代码。
- en: Adding a button via the visual designer
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过可视化设计师添加按钮
- en: 'To get started adding our first button, switch back to the design view by clicking
    on the **Design** tab underneath the XML code that we have just been discussing.
    The button is highlighted in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始添加我们的第一个按钮，请点击我们刚刚讨论过的XML代码下方的**Design**选项卡，切换回设计视图。按钮在以下截图中被突出显示：
- en: '![Adding a button via the visual designer](img/B12806_02_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![通过可视化设计师添加按钮](img/B12806_02_07.jpg)'
- en: 'Notice that in the left-hand side of the layout, we have a window that is called
    **Palette**:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在布局的左侧，我们有一个名为**Palette**的窗口：
- en: '![Adding a button via the visual designer](img/B12806_02_08.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![通过可视化设计师添加按钮](img/B12806_02_08.jpg)'
- en: The palette window is divided into two parts. The left-hand list has the categories
    of the UI elements and allows you to select a category, while the right-hand side
    shows you all the available UI elements from the currently selected category.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 调色板窗口分为两部分。左侧列表显示了UI元素的类别，并允许您选择类别，而右侧显示了当前选定类别中所有可用的UI元素。
- en: Make sure that the **Common** category is selected, as shown in the previous
    screenshot. Now, left-click and hold on the **Button** widget, and then drag it
    onto the layout somewhere near the top and center.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择了**Common**类别，如前面的截图所示。现在，左键单击并按住**Button**小部件，然后将其拖放到布局的顶部和中心附近。
- en: 'It doesn''t matter if it is not exact; however, it is good to practice to get
    it right. So, if you are not happy with the position of your button, then you
    can left-click on it to select it on the layout and then tap the *Delete* key
    on the keyboard to get rid of it. Now you can repeat the previous step until you
    have one neatly placed button that you are happy with, as demonstrated in the
    following diagram:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它不需要完全一样；然而，练习做对是很好的。所以，如果你对按钮的位置不满意，那么你可以左键单击它在布局上进行选择，然后在键盘上按下*Delete*键将其删除。现在你可以重复上一步，直到你有一个你满意的整齐放置的按钮，就像下图所示：
- en: '![Adding a button via the visual designer](img/B12806_02_09.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![通过可视化设计师添加按钮](img/B12806_02_09.jpg)'
- en: At this point, we can run the app on the emulator or on a real device, and the
    button will be there. If we click on it, there will even be a simple animation
    to represent the button being pressed and released. Feel free to try this now
    if you like.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以在模拟器上或真实设备上运行应用程序，按钮将会出现。如果我们点击它，甚至会有一个简单的动画来表示按钮被按下和释放。如果你愿意，现在可以尝试一下。
- en: To start making the app more interesting, we are going to edit the attributes
    of our button using the **Attributes** window.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使应用程序更有趣，我们将使用**Attributes**窗口编辑按钮的属性。
- en: Editing the button's attributes
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑按钮的属性
- en: 'Make sure the button is selected by left-clicking on it. Now find the **Attributes**
    window to the right of the editing window, as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保按钮被左键单击选择。现在找到编辑窗口右侧的**Attributes**窗口，如下所示：
- en: '![Editing the button''s attributes](img/B12806_02_10.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![编辑按钮的属性](img/B12806_02_10.jpg)'
- en: In the preceding screenshot, you can see that we have access to some, although
    not all, of the button's attributes. To reveal more of the attributes, click on
    the **View all attributes** link (indicated in the preceding screenshot).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，您可以看到我们可以访问一些按钮的属性，尽管不是全部。要显示更多属性，请单击**查看所有属性**链接（如前面的截图所示）。
- en: 'Now you can see the full details of the button and we can set about editing
    it. It might seem surprising to see the substantial number of attributes that
    something as apparently simple as a button has. This is a sign of the versatility
    and power that the Android API provides for UI manipulation. Look at the following
    screenshot that shows the full attributes list for our recently added button:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到按钮的全部细节，我们可以开始编辑它。看起来似乎很惊讶，看到一个按钮这样一个明显简单的东西有如此多的属性。这是Android API为UI操作提供的多功能性和强大性的体现。看下面的截图，显示了我们最近添加的按钮的完整属性列表：
- en: '![Editing the button''s attributes](img/B12806_02_11.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![编辑按钮的属性](img/B12806_02_11.jpg)'
- en: Furthermore, notice that even the previous screenshot doesn't show everything,
    and you can use the scroll bar on the right of the **Attributes** window to reveal
    even more attributes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，注意即使前面的截图并没有显示所有内容，你可以使用**Attributes**窗口右侧的滚动条来显示更多属性。
- en: 'As you can see, there is a large array of different attributes that we can
    edit right here in the UI designer. In [Chapter 12](ch12.html "Chapter 12. Connecting
    Our Kotlin to the UI and Nullability"), *Connecting our Kotlin to the UI and Nullability*,
    we will also edit and manipulate these attributes using our Kotlin code. For now,
    we will edit just one attribute. Scroll down the **Attributes** window until you
    see the **onClick** attribute and then left-click on it to select it for editing,
    as shown in the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以在UI设计师中编辑的不同属性有很多。在[第12章](ch12.html "第12章。将我们的Kotlin连接到UI和空值性")中，*将我们的Kotlin连接到UI和空值性*，我们还将使用我们的Kotlin代码编辑和操作这些属性。现在，我们只编辑一个属性。滚动**Attributes**窗口，直到找到**onClick**属性，然后左键单击它进行编辑，如下图所示：
- en: '![Editing the button''s attributes](img/B12806_02_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![编辑按钮的属性](img/B12806_02_12.jpg)'
- en: Tip
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The attributes are in alphabetical order and **onClick** can be found about
    two thirds of the way down the lengthy list.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 属性按字母顺序排列，**onClick**大约在冗长列表的三分之二处。
- en: Type `topClick` in the **onClick** attribute's edit box and press *Enter* on
    the keyboard. Be sure to use the same case, including the slightly counterintuitive
    lowercase `t` and upper-case `C`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在**onClick**属性的编辑框中键入`topClick`，然后在键盘上按*Enter*。确保使用相同的大小写，包括略微反直觉的小写`t`和大写`C`。
- en: 'The **Attributes** window will look like the next screenshot when you are done:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，**Attributes**窗口将如下截图所示：
- en: '![Editing the button''s attributes](img/B12806_02_13.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![编辑按钮的属性](img/B12806_02_13.jpg)'
- en: What we have done here is named the Kotlin function in our code that we want
    to call (or execute) when this button is clicked on by the user. The name is arbitrary
    but, as this button is on the top part of the screen, the name seems meaningful
    and easy to remember. The odd casing that we used is a convention that will help
    us to keep our code clear and easy to read. We will see the benefits of this as
    our code gets longer and more complicated.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是在我们的代码中命名了我们想要在用户点击该按钮时调用（或执行）的Kotlin函数。名称是任意的，但是，由于这个按钮位于屏幕顶部，名称似乎有意义且易于记忆。我们使用的奇怪大小写是一种约定，将帮助我们保持代码清晰易读。随着我们的代码变得越来越长和复杂，我们将看到这种做法的好处。
- en: Of course, the `topClick` function doesn't exist yet. Android Studio is very
    helpful, but there are some things that we need to do for ourselves. We will write
    this function using Kotlin code after we have added a second button to our UI.
    You can run the app at this point, and it will still work, but if you click on
    the button, the app will crash and you will get an error message, because the
    function does not exist.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，“topClick”函数目前还不存在。Android Studio非常有帮助，但有一些事情我们需要自己做。在添加第二个按钮到我们的UI后，我们将使用Kotlin代码编写这个函数。此时，您可以运行应用程序，它仍然可以工作，但如果单击按钮，应用程序将崩溃，并显示错误消息，因为该函数不存在。
- en: Examining the XML code for the new button
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查新按钮的XML代码
- en: 'Before we add our final button for this project, click on the **Text** tab
    underneath the editor to switch back to seeing the XML code that makes our UI:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在为该项目添加最终按钮之前，单击编辑器下方的**Text**选项卡，切换回查看构成我们UI的XML代码：
- en: '![Examining the XML code for the new button](img/B12806_02_14.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![检查新按钮的XML代码](img/B12806_02_14.jpg)'
- en: 'Notice that there is a new block of code amongst the XML code that we examined
    earlier. Here is a screenshot of the new block of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在我们之前检查的XML代码中有一个新的代码块。以下是新代码块的屏幕截图：
- en: '![Examining the XML code for the new button](img/B12806_02_15.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![检查新按钮的XML代码](img/B12806_02_15.jpg)'
- en: 'Notice the following details, which should correspond to what we know about
    XML and Android UI elements:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下细节，这些细节应该与我们对XML和Android UI元素的了解相对应：
- en: The new code starts with the `<Button` text and ends with `/>.`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码以`<Button`开头，以`/>`结束。
- en: The new code has a range of attributes that define the button, including `layoutWidth`
    and `layoutHeight.`
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新代码具有一系列属性，定义了按钮，包括`layoutWidth`和`layoutHeight`。
- en: The code includes the `onClick` attribute that we added with a value of `"topClick".`
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码包括我们添加的带有值“topClick”的`onClick`属性。
- en: The `topClick` value of the `onClick` attribute is underlined in red, showing
    an error because the function does not exist yet.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onClick`属性的“topClick”值被红色下划线标出，显示错误，因为函数目前还不存在。'
- en: The start and end of the code representing the button is enclosed within the
    `ConstraintLayout` element.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按钮代码的开始和结束被包含在`ConstraintLayout`元素中。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `dp` is a unit of measurement/distance and will be discussed in more depth
    in [Chapter 5](ch05.html "Chapter 5. Beautiful Layouts with CardView and ScrollView"),
    *Beautiful Layouts with CardViewand ScrollView*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`dp` 是一个测量/距离的单位，将在[第5章](ch05.html "第5章。使用CardView和ScrollView创建美丽的布局")中更深入地讨论，*使用CardView和ScrollView创建美丽的布局*。'
- en: 'Hover the mouse cursor over the underlined `topClick` value to reveal the details
    of the problem, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将鼠标悬停在下划线的“topClick”值上，以显示问题的详细信息，如下面的屏幕截图所示：
- en: '![Examining the XML code for the new button](img/B12806_02_16.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![检查新按钮的XML代码](img/B12806_02_16.jpg)'
- en: We can confirm that the issue is that Android Studio expects a function called
    `topClick` to be implemented within our code. We will do this as soon as we have
    added that second button.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确认问题是，Android Studio期望我们的代码中实现一个名为“topClick”的函数。在添加第二个按钮后，我们将这样做。
- en: Adding a button by editing the XML code
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过编辑XML代码添加按钮
- en: Just for variety, and to prove that we can, we will now add another button using
    only the XML code, and not the UI designer. Most of the time, we will use the
    UI designer, but this quick exercise should cement the relationship between the
    UI designer and the underlying XML code in your mind.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了多样化，并证明我们可以，我们现在将只使用XML代码添加另一个按钮，而不使用UI设计师。大多数时候，我们会使用UI设计师，但这个快速练习应该巩固UI设计师和底层XML代码之间的关系。
- en: We will achieve this by copying and pasting the code for the existing button.
    We will then make some minor edits to the pasted code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过复制和粘贴现有按钮的代码来实现这一点。然后，我们将对粘贴的代码进行一些小的编辑。
- en: 'Left-click just before the button code that starts `<Button`. Notice that the
    beginning and end of the code now has a slight highlight:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在以`<Button`开头的按钮代码之前单击左键。请注意，代码的开头和结尾现在有轻微的高亮显示：
- en: '![Adding a button by editing the XML code](img/B12806_02_17.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![通过编辑XML代码添加按钮](img/B12806_02_17.jpg)'
- en: 'This has identified the part of the code that we want to copy. Now, left-click
    and drag to select all the button code, including the highlighted start and end,
    as shown in the next screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经确定了我们要复制的代码部分。现在，左键单击并拖动以选择所有按钮代码，包括高亮显示的开头和结尾，如下一个屏幕截图所示：
- en: '![Adding a button by editing the XML code](img/B12806_02_18.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![通过编辑XML代码添加按钮](img/B12806_02_18.jpg)'
- en: Press the *Ctrl* + *C* keyboard combination to copy the highlighted text. Place
    the cursor below the existing button code and tap the *Enter* key a few times
    to leave some additional empty lines.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*组合键复制突出显示的文本。将光标放在现有按钮代码下方，然后按几次*Enter*键，留下一些额外的空行。
- en: 'Press the *Ctrl* + *V* keyboard combination to paste the button code. At this
    point, we have two buttons; however, there are a couple of problems:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *V*组合键粘贴按钮代码。此时，我们有两个按钮；但是，有一些问题：
- en: '![Adding a button by editing the XML code](img/B12806_02_19.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![通过编辑XML代码添加按钮](img/B12806_02_19.jpg)'
- en: We have an additional error in both blocks of code that represent our buttons.
    The `id` attribute (in both blocks) is underlined in red. The reason for this
    error is that both buttons have an `id` attribute that is the same. The `id` attribute
    is supposed to distinguish a UI element from all other UI elements, so they must
    not be the same. Let's try and fix that.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在代表我们的按钮的两个代码块中都有额外的错误。`id`属性（在两个代码块中）被红色下划线标出。这个错误的原因是两个按钮都有相同的`id`属性。`id`属性应该将UI元素与所有其他UI元素区分开来，所以它们不能相同。让我们试着解决这个问题。
- en: Giving the buttons unique id attributes
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给按钮唯一的id属性
- en: 'We could solve the problem by calling the second button as `button2,` but it
    will be more meaningful to change them both. Edit the code in the first button
    to give it an `id` attribute of `buttonTop`. To do so, identify this following
    line of code (in the first button):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将第二个按钮称为`button2`来解决问题，但更有意义的是改变它们两个。编辑第一个按钮的代码，给它一个`id`属性为`buttonTop`。为此，找到第一个按钮中的以下代码行：
- en: '[PRE3]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, change the line of code to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将代码行更改为以下内容：
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Notice the lowercase `b` in `button` and the uppercase `T` in `Top`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`button`中的小写`b`和`Top`中的大写`T`。
- en: 'Now identify this line of code in the second button:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在找到第二个按钮中的以下代码行：
- en: '[PRE5]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, change the line of code to the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将代码行更改为以下内容：
- en: '[PRE6]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The errors on the `id` attribute lines are gone. At this point, you might think
    that we can move on to solving our missing function problem.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`id`属性行上的错误已经消失。此时，你可能会认为我们可以继续解决我们的缺失功能问题。'
- en: 'However, if you run the app and take a quick glance at it, you will see that
    we only appear to have one button. Not only that, but the buttons are not in the
    places that we expected them to be in, either:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行应用程序并快速浏览一下，你会发现我们似乎只有一个按钮。不仅如此，按钮的位置也不是我们期望的：
- en: '![Giving the buttons unique id attributes](img/B12806_02_20.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![给按钮唯一的id属性](img/B12806_02_20.jpg)'
- en: The reason for this is that we haven't explicitly positioned them, so they have
    defaulted to the top-left of the screen. The position we see on the **Design**
    tab is just a design-time position. So, let's change that now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的原因是我们没有明确地定位它们，所以它们默认位于屏幕的左上角。我们在**设计**选项卡上看到的位置只是设计时的位置。所以，现在让我们来改变它。
- en: Positioning the two buttons in the layout
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在布局中定位这两个按钮
- en: 'The reason we can only see one button is that both buttons are in the same
    position. The second button is exactly covering the first button. So, even in
    the **Design** tab (feel free to take a look), the buttons are still sat on top
    of each other, although they are in the middle of the screen:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能看到一个按钮的原因是，两个按钮都在同一个位置。第二个按钮正好覆盖在第一个按钮上。因此，即使在**设计**选项卡中（随时可以查看），按钮仍然重叠在一起，尽管它们位于屏幕中间：
- en: '![Positioning the two buttons in the layout](img/B12806_02_21.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中定位这两个按钮](img/B12806_02_21.jpg)'
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You might be wondering why the UI layout tool was designed in this apparently
    counterintuitive way; the reason is flexibility. As you will see in the next two
    chapters, not only is it possible to position UI elements differently at design
    time to when the app is running, but there is also a range of different layout
    schemes that the app designer (that's you) can choose from to suit their plans.
    This flexibility results in a little awkwardness while learning about Android,
    and great design power once you have got past this awkwardness. But don't worry,
    we will move a step at a time until you have this thing beaten.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么UI布局工具被设计成这种看似反直觉的方式；原因是灵活性。正如你将在接下来的两章中看到的，不仅可以在设计时以不同的方式定位UI元素，而且还有一系列不同的布局方案供应用程序设计者（也就是你）选择，以适应他们的计划。这种灵活性在学习Android时会导致一些尴尬，但一旦你克服了这种尴尬，就会获得很强大的设计能力。但不要担心，我们会一步一步地进行，直到你掌握了这个技巧。
- en: 'We will make Android Studio solve the problem for us automatically by first
    adding to our code, and then using the UI designer. First, let''s get the design
    time layout right. In the code for the second button, locate this line of code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让Android Studio自动为我们解决问题，首先添加到我们的代码，然后使用UI设计工具。首先，让我们正确设置设计时布局。在第二个按钮的代码中，找到以下代码行：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now edit it to be the same as the following line of code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将其编辑为与以下代码行相同：
- en: '[PRE8]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Depending upon exactly where you positioned your first button, the values in
    Android Studio will likely be different to the values just discussed. If the second
    button is around 70dp higher than the first button, then you can proceed with
    this exercise.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你放置第一个按钮的确切位置，Android Studio中的值可能与刚刚讨论的值不同。如果第二个按钮比第一个按钮高大约70dp，那么你可以继续进行这个练习。
- en: This subtle change will move the second button down a little, but only for design
    time. If you look in the **Design** tab, the button is positioned neatly underneath
    the first button, but if you run the app on the emulator, they are both still
    in the top-left corner of the screen and are on top of one another.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微小的改变会使第二个按钮向下移动一点，但只在设计时有效。如果你在**设计**选项卡中查看，按钮将整齐地放置在第一个按钮的下方，但如果你在模拟器上运行应用程序，它们仍然都在屏幕的左上角，并且彼此重叠。
- en: 'Switch to the **Design** tab and find the **Infer Constraints** button that
    is shown in the following screenshot:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到**设计**选项卡，找到如下截图所示的**推断约束**按钮：
- en: '![Positioning the two buttons in the layout](img/B12806_02_22.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中定位这两个按钮](img/B12806_02_22.jpg)'
- en: 'Click on the **Infer Constraints** button. Android Studio will edit the XML
    code. Let''s take a brief look at what has happened behind the scenes. From the
    end of both of the sections of code representing the buttons, the following lines
    of code were removed:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**推断约束**按钮。Android Studio将编辑XML代码。让我们简要看一下幕后发生了什么。从代表按钮的代码部分的末尾，删除了以下代码行：
- en: '[PRE9]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These two lines of code were what positioned the buttons horizontally (`…absoluteX`)
    and vertically (`…absoluteY`).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这两行代码是水平（`…absoluteX`）和垂直（`…absoluteY`）定位按钮的原因。
- en: 'Android Studio also added four lines of code to the first button, and three
    lines of code to the second button. Here is the code that was added near the start
    of the first button:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio还向第一个按钮添加了四行代码，向第二个按钮添加了三行代码。以下是在第一个按钮附近添加的代码：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Exact values of `dp` might vary depending on precisely where you placed your
    buttons.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`dp`的确切值可能会有所不同，具体取决于您放置按钮的位置。'
- en: 'This code causes the button to have a margin of `30` on the top. But on the
    top of what exactly? Look at the following three lines of code that were added
    at the end of the first button:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码导致按钮在顶部有一个`30`的边距。但是在什么顶部呢？看看以下添加到第一个按钮末尾的三行代码：
- en: '[PRE11]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice the new attributes of `layout_constraintEnd_toEndOf`, `layout_constraintStart_toStartOf`,
    and `layout_constraintTop_toTopOf`. The value that is assigned to each of these
    attributes is `"parent"`. This causes the first button to be positioned relative
    to the parent UI element. The parent is the layout that contains everything else;
    in this case, the parent is the `ConstraintLayout` element.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`layout_constraintEnd_toEndOf`，`layout_constraintStart_toStartOf`和`layout_constraintTop_toTopOf`的新属性。分配给这些属性的值是`"parent"`。这导致第一个按钮相对于父UI元素进行定位。父元素是包含所有其他元素的布局；在这种情况下，父元素是`ConstraintLayout`元素。
- en: Now look at the three lines of code added to the second (bottom) button.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看添加到第二个（底部）按钮的三行代码。
- en: 'Near the start of the code, we see the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的开头附近，我们看到以下内容：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Again, exact values of `dp` might vary depending on precisely where you placed
    your buttons.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`dp`的确切值可能会有所不同，具体取决于您放置按钮的位置。
- en: 'At the end of the code for the second button, we see the following two extra
    lines of code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个按钮的代码末尾，我们看到以下两行额外的代码：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This means that the second button is positioned with a margin of 22 relative
    to `buttonTop`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着第二个按钮相对于`buttonTop`的位置有一个`22`的边距。
- en: 'Now run the app and you will see that we have two distinct buttons. One has
    an `id` attribute of `buttonTop,` and it is above the other button with an `id`
    attribute of `buttonBottom`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，您将看到我们有两个不同的按钮。一个具有`buttonTop`的`id`属性，它在具有`buttonBottom`的`id`属性的另一个按钮上方：
- en: '![Positioning the two buttons in the layout](img/B12806_02_23.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![在布局中定位两个按钮](img/B12806_02_23.jpg)'
- en: Clearly, there is more to layouts than I have alluded to so far, but you have
    had your first glance at the options provided by Android Studio to design the
    UI of our apps. We will be taking a closer look at `ConstraintLayout`, as well
    as exploring more layout options in [Chapter 4,](ch04.html "Chapter 4. Getting
    Started with Layouts and Material Design") *Getting Started with Layouts and Material
    Design*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，布局比我目前提到的要复杂得多，但您已经初步了解了Android Studio提供的选项，用于设计我们应用程序的UI。我们将更仔细地研究`ConstraintLayout`，并在[第4章](ch04.html
    "第4章。开始布局和材料设计")*开始布局和材料设计*中探索更多的布局选项。
- en: We want to make one more alteration to our XML code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想对我们的XML代码进行一些修改。
- en: Making the buttons call different functions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使按钮调用不同的函数
- en: 'Switch back to the **Text** tab and identify this next line of code in the
    second (`buttonBottom`) button:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 切换回**Text**标签，并在第二个（`buttonBottom`）按钮中找到下一行代码：
- en: '[PRE14]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, edit the code as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑代码如下：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now we have two buttons, one above the other. The top one has an `id` attribute
    of `buttonTop` and an `onClick` attribute with a value of `topClick`. The other
    has an `id` attribute of `buttonBottom` and an `onClick` attribute with a value
    of `bottomClick`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个按钮，一个在另一个上面。顶部按钮的`id`属性为`buttonTop`，`onClick`属性的值为`topClick`。另一个按钮的`id`属性为`buttonBottom`，`onClick`属性的值为`bottomClick`。
- en: These last XML code changes now mean we need to supply two functions (`topClick`
    and `bottomClick`) in our Kotlin code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最后的XML代码更改现在意味着我们需要在Kotlin代码中提供两个函数（`topClick`和`bottomClick`）。
- en: Tip
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It is technically OK for two buttons to call the same function when they are
    clicked on – it is not a syntax error. However, most buttons do have distinct
    purposes, so this exercise will be more meaningful if our buttons do different
    things.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，当点击两个按钮时调用相同的函数是可以的-这不是语法错误。然而，大多数按钮确实有不同的目的，因此如果我们的按钮执行不同的操作，这个练习将更有意义。
- en: We will do that soon, but before we do, let's learn a little bit more about
    Kotlin comments and look at some Kotlin code that we can write to send messages
    to the user, and to ourselves for debugging purposes.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会做到，但在我们这样做之前，让我们先了解一下Kotlin注释，并查看一些我们可以编写的Kotlin代码，以向用户发送消息，并为调试目的向自己发送消息。
- en: Leaving comments in our Kotlin code
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的Kotlin代码中留下注释
- en: 'In programming, it is always a clever idea to write messages known as code
    comments, and sprinkle them liberally amongst your code. This is to remind us
    what we were thinking at the time we wrote the code. To do this, you simply append
    a double forward slash and then type your comment, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，写代码注释是一个聪明的主意，并且在你的代码中大量使用它们。这是为了提醒我们在编写代码时的想法。要做到这一点，你只需添加双斜杠，然后输入你的注释，如下所示：
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In addition, we can use comments to comment out a line of code. Suppose we
    have a line of code that we temporarily want to disable; we can do so by adding
    two forward slashes, as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用注释来注释掉一行代码。假设我们有一行代码暂时想要禁用；我们可以通过添加两个斜杠来实现，如下所示：
- en: '[PRE17]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Using comments to comment out code should only be a temporary measure. Once
    you have found the correct code to use, commented-out code should be cut to keep
    the code file clean and organized.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释注释掉代码应该只是一个临时措施。一旦找到正确的代码使用，注释掉的代码应该被删除，以保持代码文件的清洁和有组织性。
- en: Let's take a look at two separate ways to send messages in Android, and then
    we can write some functions that will send messages when our UI buttons are pressed.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在Android中发送消息的两种不同方式，然后我们可以编写一些函数，当我们的UI按钮被按下时发送消息。
- en: Coding messages to the user and the developer
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向用户和开发者编码消息
- en: In the introduction to this chapter and in the previous chapter, we talked a
    bit about using other people's code, specifically via the classes and their functions
    of the Android API. We saw that we could do some quite complex things with fairly
    insignificant amounts of code (such as talking to satellites).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的介绍和上一章中，我们谈到了一些关于使用其他人的代码的事情，特别是通过安卓API的类和它们的函数。我们看到我们可以用相当少量的代码做一些相当复杂的事情（比如与卫星通信）。
- en: To get us started on coding, we are going to use two different classes from
    the Android API that allow us to output messages. The first class, `Log`, allows
    us to output messages to the logcat window. The second class, `Toast`, is not
    a tasty breakfast treat, but it will produce a toast-shaped pop up message for
    our app's user to see.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们开始编码，我们将使用安卓API中的两个不同类，这些类允许我们输出消息。第一个类`Log`允许我们将消息输出到logcat窗口。第二个类`Toast`不是一种美味的早餐款待，而是会为我们的应用程序用户产生一个类似吐司的弹出消息。
- en: 'Here is the code we need to write to send a message to logcat:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要编写的代码，以便将消息发送到logcat：
- en: '[PRE18]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Exactly why this works will become clearer in [Chapter 10](ch10.html "Chapter 10. Object-Oriented
    Programming"), *Object-Oriented Programming*, but for now, we just need to know
    that whatever we put between the two sets of quote marks will be output to the
    logcat window. We will see where to put this type of code shortly.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样做有效将在[第10章](ch10.html "第10章。面向对象编程")*面向对象编程*中变得更清晰，但现在，我们只需要知道我们放在引号之间的任何内容都将输出到logcat窗口。我们很快就会看到在哪里放置这种类型的代码。
- en: 'Here is the code we need to write in order to send a message to the user''s
    screen:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要编写的代码，以便向用户屏幕发送消息：
- en: '[PRE19]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is a very convoluted-looking line of code and exactly how it works, again,
    will not become clear until [Chapter 9](ch09.html "Chapter 9. Kotlin Functions"),
    *Kotlin Functions*. The important thing here is that whatever we put between the
    quote marks will appear in a pop-up message to our users.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一行非常复杂的代码，它的工作原理将在[第9章](ch09.html "第9章。Kotlin函数")*Kotlin函数*中变得更清晰。这里重要的是，我们放在引号之间的任何内容都将出现在一个弹出消息中供我们的用户查看。
- en: Let's put some code (like we have just seen) into our app for real.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把一些代码（就像我们刚刚看到的）真正放入我们的应用程序中。
- en: Writing our first Kotlin code
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写我们的第一个Kotlin代码
- en: So, we now know the code that will output to logcat or the user's screen. However,
    where do we put the code? To answer this question, we need to understand that
    the `onCreate` function in `MainActivity.kt` executes as the app is preparing
    to be shown to the user. So, if we put our code at the end of this function, it
    will run just as the user sees it; that sounds good.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了将输出到logcat或用户屏幕的代码。但是，我们应该把代码放在哪里呢？要回答这个问题，我们需要理解`MainActivity.kt`中的`onCreate`函数在应用程序准备展示给用户时执行。因此，如果我们将我们的代码放在这个函数的末尾，它将在用户看到它时运行；听起来不错。
- en: Tip
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: We know that to execute the code in a function, we need to **call** it. We have
    wired our buttons up to call a couple of functions, such as `topClick` and `bottomClick`.
    Soon, we will write these functions. But who or what is calling `onCreate`? The
    answer to this mystery is that Android itself calls `onCreate` in response to
    the user clicking on the app icon to run the app. In [Chapter 6,](ch06.html "Chapter 6. The
    Android Lifecycle") *The Android Lifecycle*, we will look deeper, and it will
    be clear what exactly the code executes and when. You don't need to completely
    comprehend this now; I just wanted to give you an overview of what was going on.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道要执行函数中的代码，我们需要**调用**它。我们已经将我们的按钮连接起来调用一些函数，比如`topClick`和`bottomClick`。很快，我们将编写这些函数。但是谁或什么在调用`onCreate`呢？这个谜团的答案是，安卓本身在用户点击应用图标运行应用时调用`onCreate`。在[第6章](ch06.html
    "第6章。安卓生命周期")*安卓生命周期*中，我们将深入探讨，清楚地了解代码何时执行。你现在不需要完全理解这一点；我只是想给你一个概述。
- en: Let's quickly try this out; switch to the `MainActivity.kt` tab in Android Studio.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速尝试一下；切换到安卓工作室中的`MainActivity.kt`选项卡。
- en: We know that the `onCreate` function is called just before the app starts for
    real. Let's copy and paste some code into the `onCreate` function of our Hello
    World app and see what happens when we run it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道`onCreate`函数是在应用程序真正启动之前调用的。让我们将一些代码复制粘贴到我们的Hello World应用程序的`onCreate`函数中，看看当我们运行它时会发生什么。
- en: Adding message code to the onCreate function
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向`onCreate`函数添加消息代码
- en: 'Find the closing curly brace (`}`) of the `onCreate` function and add the highlighted
    code shown in the following code block. In the code, I haven''t shown the complete
    content of the `onCreate` function, but instead, I have used `…` to indicate a
    number of lines of code not being shown. The important thing is to place the new
    code (shown in full) right at the end, but before the closing curly brace (`}`):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 找到`onCreate`函数的闭合大括号（`}`），并在下面的代码块中添加突出显示的代码。在代码中，我没有显示`onCreate`函数的完整内容，而是使用`…`表示未显示的一些行代码。重要的是将新代码（完整显示）放在最后，但在闭合大括号（`}`）之前：
- en: '[PRE20]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that the instances of `Toast` and `Log` are highlighted in red in Android
    Studio. They are errors. We know that `Toast` and `Log` are classes and that classes
    are containers for code.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在安卓工作室中，`Toast`和`Log`的实例被标记为红色。它们是错误。我们知道`Toast`和`Log`是类，而类是代码的容器。
- en: The problem is that Android Studio doesn't know about them until we tell it.
    We must add an `import` directive for each class. Fortunately, this is semi-automatic.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，安卓工作室在我们告诉它之前并不知道它们。我们必须为每个类添加一个`import`指令。幸运的是，这是半自动的。
- en: Left-click on `Toast`; now hold the *Alt* key and tap *Enter*. You need to do
    this step twice, once for `Toast`, and once for `Log`. Android Studio adds the
    `import` directives at the top of the code with our other imports, and the errors
    are gone.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Toast`上单击左键；现在按住*Alt*键，然后点击*Enter*键。您需要执行此步骤两次，一次是为`Toast`，一次是为`Log`。安卓工作室将`import`指令添加到我们其他导入的代码顶部，并且错误消失了。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '*Alt* + *Enter* is just one of many useful keyboard shortcuts. The following
    is a keyboard shortcut reference for Android Studio. More specifically, it is
    for the IntelliJ Idea IDE, which Android Studio is based on. Bookmark this web
    page; it will be invaluable over the course of this book: [http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf).'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*Alt* + *Enter*只是许多有用的键盘快捷键之一。以下是Android Studio的键盘快捷键参考。更具体地说，这是基于的IntelliJ
    Idea IDE的键盘快捷键。收藏这个网页；在本书的过程中它将是无价的：[http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf](http://www.jetbrains.com/idea/docs/IntelliJIDEA_ReferenceCard.pdf)。'
- en: 'Scroll to the top of `MainActivity.kt` and look at the added `import` directives.
    Here they are for your convenience:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动到`MainActivity.kt`的顶部，查看添加的`import`指令。以下是为您方便起见：
- en: '[PRE21]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the app in the usual way and look at the output in the **logcat** window.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式运行应用程序，并查看**logcat**窗口中的输出。
- en: Examining the output
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查输出
- en: 'The following is a screenshot of the output in the logcat window:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是logcat窗口中输出的屏幕截图：
- en: '![Examining the output](img/B12806_02_24.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![检查输出](img/B12806_02_24.jpg)'
- en: 'Looking at the logcat, you can see that our message – **Done creating the app**
    – was output, although it is mixed up amongst other system messages that we are
    currently not interested in. If you watched the emulator when the app first starts,
    you will also see the neat pop-up message that the user will see:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 查看logcat，您会看到我们的消息 - **完成创建应用程序** - 已输出，尽管它混杂在我们目前不感兴趣的其他系统消息中。如果您在应用程序首次启动时观看模拟器，您还将看到用户将看到的整洁弹出消息：
- en: '![Examining the output](img/B12806_02_25.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![检查输出](img/B12806_02_25.jpg)'
- en: You might be wondering why the messages were output at the time that they were.
    The simple answer is that the `onCreate` function is called just before the app
    starts to respond to the user. It is common practice amongst Android developers
    to put code in this function to get their apps set up and ready for user input.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道为什么消息在那个时间输出。简单的答案是`onCreate`函数在应用程序开始响应用户之前被调用。在Android开发人员中，将代码放在此函数中以准备好应用程序并为用户输入做好准备是常见做法。
- en: Now, we will go a step further and write our own functions that are called by
    our UI buttons. We will place similar `Log` and `Toast` messages inside them.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步迈出一步，编写我们自己的函数，这些函数由我们的UI按钮调用。我们将在其中放置类似的`Log`和`Toast`消息。
- en: Writing our own Kotlin functions
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写我们自己的Kotlin函数
- en: Let's go straight on to writing our first Kotlin functions with some more `Log`
    and `Toast` messages inside them.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接开始编写我们的第一个Kotlin函数，并在其中添加一些`Log`和`Toast`消息。
- en: Tip
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Now will be a good time, if you haven't done so already, to get the download
    bundle that contains all the code files. You can view the completed code for each
    chapter. For example, the completed code for this chapter can be found in the
    `Chapter02` folder. I have further subdivided the `Chapter02` folder into `kotlin`
    and `res` folders (for Kotlin and resource files). In chapters with more than
    one project, I will divide the folders further to include the project name. You
    should view these files in a text editor. My favorite is Notepad++, a free download
    from [https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/).
    Code viewed in a text editor is easier to read than directly from the book, especially
    the paperback version, and even more so where the lines of code are long. The
    text editor is also a great way to select sections of the code to copy and paste
    into Android Studio. You could open the code in Android Studio, but then you risk
    mixing up my code with the autogenerated code of Android Studio.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，现在是获取包含所有代码文件的下载包的好时机。您可以查看每个章节的完成代码。例如，本章的完成代码可以在`Chapter02`文件夹中找到。我进一步将`Chapter02`文件夹细分为`kotlin`和`res`文件夹（用于Kotlin和资源文件）。在有多个项目的章节中，我将进一步划分文件夹以包含项目名称。您应该在文本编辑器中查看这些文件。我的最爱是Notepad++，可以从[https://notepad-plus-plus.org/download/](https://notepad-plus-plus.org/download/)免费下载。在文本编辑器中查看代码比直接从书中阅读更容易，尤其是平装版本，尤其是代码行很长的情况下。文本编辑器还是将代码部分选择复制并粘贴到Android
    Studio中的绝佳方式。您可以在Android Studio中打开代码，但这样您就有可能将我的代码与Android Studio的自动生成代码混淆。
- en: Identify the closing curly brace (`}`) of the `MainActivity` class.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 识别`MainActivity`类的闭合大括号（`}`）。
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that you are looking for the end of the entire class, not the end of the
    `onCreate` function, as in the previous section. Take your time to identify the
    new code and where it goes among the existing code.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您要寻找的是整个类的结尾，而不是`onCreate`函数的结尾，就像前一节一样。花点时间来识别新代码以及它在现有代码中的位置。
- en: 'Inside that curly brace, enter the following code that is highlighted:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个大括号内，输入以下突出显示的代码：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that the two instances of `View` are in red, indicating an error. Simply
    use the *Alt* + *Enter* keyboard combination to import the `View` class and remove
    the errors.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，两个`View`实例是红色的，表示错误。只需使用*Alt* + *Enter*键组合导入`View`类并删除错误。
- en: Deploy the app to a real device or emulator in the usual way and start tapping
    the buttons so that we can observe the output.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 以通常的方式将应用程序部署到真实设备或模拟器，并开始点击按钮，以便我们观察输出。
- en: Examining the output
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查输出
- en: At last, our app does something! We can see that the function names we defined
    in the button `onClick` attribute are indeed called when the buttons are clicked
    on; the appropriate messages are added to the **logcat** window; and the appropriate
    `Toast` messages are shown to the user.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的应用程序有所作为！我们可以看到我们在按钮`onClick`属性中定义的函数名称确实在按钮被点击时被调用；适当的消息被添加到**logcat**窗口；并且适当的`Toast`消息显示给用户。
- en: 'Admittedly, we still don''t understand why `Toast` and `Log` really work, nor
    do we fully comprehend the `(v: View)` parts of our function''s syntax, or the
    rest of the autogenerated code. This will become clear as we progress. As stated
    previously, in [Chapter 10](ch10.html "Chapter 10. Object-Oriented Programming"),
    *Object-Oriented Programming*, we will take a deep dive into the world of classes
    and, in [Chapter 9](ch09.html "Chapter 9. Kotlin Functions"), *Kotlin* *Functions*,
    we will master the rest of the syntax associated with functions.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '诚然，我们仍然不理解为什么`Toast`和`Log`真正起作用，也不完全理解我们函数语法中的`(v: View)`部分，或者自动生成的代码的其余部分。随着我们的进展，这将变得清晰起来。如前所述，在[第10章](ch10.html
    "第10章。面向对象编程") *面向对象编程*中，我们将深入探讨类的世界，在[第9章](ch09.html "第9章。Kotlin函数") *Kotlin函数*中，我们将掌握与函数相关的其余语法。'
- en: 'Take a look at the logcat output; you can see that a log entry was made from
    the `onCreate` function just as before, as well as from the two functions that
    we wrote ourselves, each time you clicked on a button. In the following screenshot,
    you can see that I clicked on each button three times:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 查看logcat输出；您可以看到`onCreate`函数之前记录了一个日志条目，以及我们自己编写的两个函数，每次点击按钮时都会记录。在下面的屏幕截图中，您可以看到我点击了每个按钮三次：
- en: '![Examining the output](img/B12806_02_26.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![检查输出](img/B12806_02_26.jpg)'
- en: 'As you are now familiar with where to find the **logcat** window, in future,
    I will present the logcat output as trimmed text as it is clearer to read:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您现在已经熟悉了**logcat**窗口的位置，因此在未来，我将以修剪后的文本形式呈现logcat输出，因为这样更容易阅读：
- en: '[PRE23]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the following screenshot, you can see that the top button has been clicked
    on and that the `topClick` function was called, triggering the pop-up `Toast`
    message:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到顶部按钮已被点击，并且`topClick`函数被调用，触发了弹出的`Toast`消息：
- en: '![Examining the output](img/B12806_02_27.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![检查输出](img/B12806_02_27.jpg)'
- en: Throughout this book, we will regularly output to logcat, so that we can see
    what is going on behind the UI of our apps. `Toast` messages are more for notifying
    the user that something has occurred. This might be a download that has completed,
    a new email has arrived, or some other occurrence that needs their attention.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将定期输出到logcat，以便我们可以看到我们应用程序UI背后发生了什么。`Toast`消息更多是用于通知用户发生了某事。这可能是下载完成，新邮件到达，或者其他需要他们注意的事件。
- en: Frequently asked questions
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q.1) Can you remind me what functions are?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Q.1）你能提醒我函数是什么吗？
- en: A) Functions are containers for our code that can be executed (called) from
    other parts of our code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: A）函数是我们的代码的容器，可以从代码的其他部分执行（调用）它们。
- en: Q.2) Like the first, I found this chapter tough going. Do I need to re-read
    it?
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Q.2）像第一个问题一样，我觉得这一章很难。我需要重新阅读吗？
- en: A) No, if you managed to build the app, you have made enough progress to handle
    all of the next chapter. All the blanks in our knowledge will be steadily filled
    in and replaced with glorious moments of realization as the book progresses.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: A）不，如果您成功构建了应用程序，您已经取得了足够的进步来处理下一章的所有内容。我们知识中的所有空白将逐渐填补，并随着书籍的进展而被美好的领悟时刻所取代。
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We have achieved a lot in this exercise. It is true that much of the XML code
    is still generally incomprehensible. That's OK, because in the next two chapters,
    we will be really getting to grips with the visual designer and learning more
    about the XML code, although, ultimately, our aim is to use the XML code as little
    as possible.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们取得了很多成就。的确，XML代码仍然普遍难以理解。没关系，因为在接下来的两章中，我们将真正掌握可视化设计师，并更多地了解XML代码，尽管最终我们的目标是尽可能少地使用XML代码。
- en: We have seen how, when we drag a button onto our design, the XML code is generated
    for us. Also, if we change an attribute in the **Attributes** window then, again,
    the XML code is edited for us. Furthermore, we can type (or, in our case, copy
    and paste) the XML code directly to create new buttons on our UI or edit existing
    ones.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，当我们将按钮拖放到设计中时，XML代码会为我们生成。此外，如果我们在**属性**窗口中更改属性，那么XML代码也会被编辑。此外，我们可以直接输入（或者在我们的情况下，复制和粘贴）XML代码来创建新的按钮或编辑现有按钮。
- en: We have seen as well as written our first Kotlin code, including comments that
    help us document our code, and we have even added our own functions to output
    debugging messages to logcat and pop-up `Toast` messages to the user.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到并编写了我们的第一个Kotlin代码，包括帮助我们记录代码的注释，并且我们甚至添加了自己的函数来输出调试消息到logcat和弹出`Toast`消息给用户。
- en: In the next chapter, we will take a full guided tour of Android Studio to see
    exactly where different things get done. Additionally, we will gain an understanding
    of how our project's assets, such as files and folders, are structured and how
    we can manage them. This will prepare us for a more in-depth look at UI design
    in [Chapter 4](ch04.html "Chapter 4. Getting Started with Layouts and Material
    Design"), *Getting Started with layouts and Material Design* and [Chapter 5](ch05.html
    "Chapter 5. Beautiful Layouts with CardView and ScrollView"), *Beautiful Layouts
    with CardView and ScrollView*, when we will build some significant real-world
    layouts for our apps.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将全面介绍Android Studio，以了解不同的操作在哪里完成。此外，我们将了解项目的资产（如文件和文件夹）的结构以及如何管理它们。这将为我们更深入地研究UI设计做好准备，[第4章](ch04.html
    "第4章。开始布局和Material Design") *开始布局和Material Design* 和[第5章](ch05.html "第5章。CardView和ScrollView创建美丽的布局")
    *CardView和ScrollView创建美丽的布局*，在这两章中，我们将为我们的应用程序构建一些重要的真实布局。
